fine SWITCH_CACHE_DOCUMENTS      ( SWITCH_CACHE_MANUAL+1)
#define SWITCH_CACHE_PROGRAMS       ( SWITCH_CACHE_DOCUMENTS+1)
#define SWITCH_CACHE_NONE           ( SWITCH_CACHE_PROGRAMS+1)


static MESSAGE ShareMsgList[] = {
{ APE2_SHARE_MSG_SPOOLED,           NULL },
{ APE2_SHARE_MSG_NAME,              NULL },
{ APE2_SHARE_MSG_DEVICE,            NULL },
{ APE2_SHARE_MSG_PERM,              NULL },
{ APE2_SHARE_MSG_MAX_USERS,         NULL },
{ APE2_SHARE_MSG_ULIMIT,            NULL },
{ APE2_SHARE_MSG_USERS,             NULL },
{ APE2_SHARE_MSG_CACHING,           NULL },
{ APE2_GEN_PATH,                    NULL },
{ APE2_GEN_REMARK,                  NULL },
{ APE2_GEN_CACHED_MANUAL,           NULL },
{ APE2_GEN_CACHED_AUTO,             NULL },
{ APE2_GEN_CACHED_VDO,              NULL },
{ APE2_GEN_CACHED_DISABLED,         NULL },
{ APE2_GEN_CACHE_AUTOMATIC,         NULL },
{ APE2_GEN_CACHE_MANUAL,            NULL },
{ APE2_GEN_CACHE_DOCUMENTS,         NULL },
{ APE2_GEN_CACHE_PROGRAMS,          NULL },
{ APE2_GEN_CACHE_NONE,              NULL },
};

#define NUM_SHARE_MSGS (sizeof(ShareMsgList)/sizeof(ShareMsgList[0]))
#define NUM_SHARE_MSGS_MAX         8

#define MAX_PEER_USERS  2


/***
 *  share_display_all()
 *      Display info about one share or all shares
 *
 *  Args:
 *      netname - the share to display of NULL for all
 *
 *  Returns:
 *      nothing - success
 *      exit(2) - command failed
 */
VOID share_display_all(VOID)
{
    DWORD            dwErr;
    DWORD            cTotalAvail;
    LPTSTR           pBuffer;
    DWORD            num_read;           /* num entries read by API */
    DWORD            maxLen;             /* max msg length */
    DWORD            i;
    LPSHARE_INFO_2   share_entry;
    PSHARE_INFO_1005 s1005;
    BOOLEAN          b1005 = TRUE;
    BOOLEAN          bWroteComment;

    start_autostart(txt_SERVICE_FILE_SRV);
    if (dwErr = NetShareEnum(
                            NULL,
                            2,
                            (LPBYTE*)&pBuffer,
                            MAX_PREFERRED_LENGTH,
                            &num_read,
                            &cTotalAvail,
                            NULL)) {
        ErrorExit(dwErr);
    }

    if (num_read == 0)
        EmptyExit();

    qsort(pBuffer, num_read, sizeof(SHARE_INFO_2), CmpShrInfo2);

    GetMessageList(NUM_SHARE_MSGS, ShareMsgList, &maxLen);

    PrintNL();
    InfoPrint(APE2_SHARE_MSG_HDR);
    PrintLine();

    for (i = 0, share_entry = (LPSHARE_INFO_2) pBuffer;
        i < num_read; i++, share_entry++)
    {
        if (SizeOfHalfWidthString(share_entry->shi2_netname) <= 12)
            WriteToCon(TEXT("%Fws "),PaddedString(12,share_entry->shi2_netname,NULL));
        else
        {
            WriteToCon(TEXT("%Fws"), share_entry->shi2_netname);
            PrintNL();
            WriteToCon(TEXT("%-12.12Fws "), TEXT(""));
        }

        share_entry->shi2_type &= ~STYPE_SPECIAL;

        if (share_entry->shi2_type == STYPE_PRINTQ)
        {
            get_print_devices(share_entry->shi2_netname);
            WriteToCon(TEXT("%ws "),PaddedString(-22, Buffer, NULL));
            WriteToCon(TEXT("%ws "),PaddedString(  8,
                                                 ShareMsgList[SHARE_MSG_SPOOLED].msg_text,
                                                  NULL));
        }
        else if (SizeOfHalfWidthString(share_entry->shi2_path) <= 31)
            WriteToCon(TEXT("%Fws "),PaddedString(-31,share_entry->shi2_path,NULL));
        else
        {
            WriteToCon(TEXT("%Fws"), share_entry->shi2_path);
            PrintNL();
            WriteToCon(TEXT("%-44.44Fws "), TEXT(""));
        }

        bWroteComment = FALSE;
        if( share_entry->shi2_remark && *share_entry->shi2_remark != '\0' ) {
            WriteToCon(TEXT("%Fws"),PaddedString(-34,share_entry->shi2_remark,NULL));
            bWroteComment = TRUE;
        }

        //
        // If this share is cacheable, write out a descriptive line
        //

        if( b1005 && NetShareGetInfo(NULL,
                               share_entry->shi2_netname,
                               1005,
                               (LPBYTE*)&s1005 ) == NO_ERROR ) {

            TCHAR FAR *      pCacheStr = NULL;

            switch( s1005->shi1005_flags & CSC_MASK ) {
//          case CSC_CACHE_MANUAL_REINT:
//             pCacheStr =  ShareMsgList[ SHARE_MSG_CACHED_MANUAL ].msg_text;
//            break;
            case CSC_CACHE_AUTO_REINT:
                pCacheStr =  ShareMsgList[ SHARE_MSG_CACHED_AUTO ].msg_text;
                break;
            case CSC_CACHE_VDO:
                pCacheStr =  ShareMsgList[ SHARE_MSG_CACHED_VDO ].msg_text;
                break;
            case CSC_CACHE_NONE:
                pCacheStr =  ShareMsgList[ SHARE_MSG_CACHED_DISABLED ].msg_text;
                break;
            }

            if( pCacheStr != NULL ) {
                if( bWroteComment == TRUE ) {
                    PrintNL();
                    WriteToCon( TEXT("%ws%Fws"), PaddedString( 45, TEXT(""), NULL ), pCacheStr );
                } else {
                    WriteToCon( TEXT( "%ws" ), pCacheStr );
                }
            }

            NetApiBufferFree( (TCHAR FAR *)s1005 );
        } else {
            b1005 = FALSE;
        }

        PrintNL();

    }
    InfoSuccess();
    NetApiBufferFree(pBuffer);
}


/***
 *  CmpShrInfo2(shr1,shr2)
 *
 *  Compares two SHARE_INFO_2 structures and returns a relative
 *  lexical value, suitable for using in qsort.
 *
 *  This function relies on the fact that special shares are returned
 *  by the API in the order we want; i.e. IPC$ is first, ADMIN$ second, etc.
 */

int __cdecl
CmpShrInfo2(
    const VOID * shr1,
    const VOID * shr2
    )
{
    LPTSTR  name1;
    LPTSTR  name2;
    BOOL    special1, special2;
    DWORD   devType1, devType2;

    /* first sort by whether share is special $ share */
    name1 = ((LPSHARE_INFO_2) shr1)->shi2_netname;
    name2 = ((LPSHARE_INFO_2) shr2)->shi2_netname;
    special1 = (name1 + _tcslen(name1) - 1 == _tcschr(name1, DOLLAR));
    special2 = (name2 + _tcslen(name2) - 1 == _tcschr(name2, DOLLAR));

    if (special2 && special1)
        return 0;               /* if both are special, leave alone */
    if (special1 && !special2)
        return -1;
    if (special2 && !special1)
        return +1;

    /* then sort by device type */
    devType1 = ((LPSHARE_INFO_2) shr1)->shi2_type & ~STYPE_SPECIAL;
    devType2 = ((LPSHARE_INFO_2) shr2)->shi2_type & ~STYPE_SPECIAL;
    if (devType1 != devType2)
        return( (devType1 < devType2) ? -1 : 1 );

    /* otherwise by net name */
    return _tcsicmp (name1, name2);
}

VOID share_display_share(TCHAR * netname)
{
    DWORD                dwErr;
    DWORD                cTotalAvail;
    LPTSTR               pBuffer;
    DWORD                num_read;           /* num entries read by API */
    DWORD                maxLen;             /* max msg length */
    DWORD                dummyLen;
    LPSHARE_INFO_2       share_entry;
    LPCONNECTION_INFO_1  conn_entry;
    DWORD                i;
    USHORT               more_data = FALSE;
    TCHAR                txt_UNKNOWN[APE2_GEN_MAX_MSG_LEN];
    PSHARE_INFO_1005     s1005;
    DWORD                Idx = 0;
    BOOL                 CacheInfo = FALSE;


    LUI_GetMsg(txt_UNKNOWN, APE2_GEN_MAX_MSG_LEN, APE2_GEN_UNKNOWN);

    //
    // On NT, the redir doesn't have to be running to use the server
    //
    start_autostart(txt_SERVICE_FILE_SRV);

    if (dwErr = NetShareGetInfo(NULL,
                                netname,
                                2,
                                (LPBYTE *) &share_entry))
    {
        ErrorExit(dwErr);
    }

    //
    // Get the caching info
    //
    dwErr = NetShareGetInfo(NULL, netname, 1005, (LPBYTE*)&s1005);

    if (dwErr == NO_ERROR ) {
        switch( s1005->shi1005_flags & CSC_MASK ) {
        case CSC_CACHE_MANUAL_REINT:
            Idx = SHARE_MSG_CACHED_MANUAL;
            CacheInfo = TRUE;
            break;
        case CSC_CACHE_AUTO_REINT:
            Idx = SHARE_MSG_CACHED_AUTO;
            CacheInfo = TRUE;
            break;
        case CSC_CACHE_VDO:
            Idx = SHARE_MSG_CACHED_VDO;
            CacheInfo = TRUE;
            break;
        case CSC_CACHE_NONE:
            Idx = SHARE_MSG_CACHED_DISABLED;
            CacheInfo = TRUE;
            break;
        }
        NetApiBufferFree( (TCHAR FAR *)s1005 );
    }

    //
    // Set so that the maxLen is only given for the messages
    // we care about.
    //
    GetMessageList(NUM_SHARE_MSGS_MAX, ShareMsgList, &maxLen);
    maxLen += 5;

    //
    // Now load all the messages, ignoring the length returned
    //
    GetMessageList(NUM_SHARE_MSGS, ShareMsgList, &dummyLen);

    share_entry->shi2_type &= ~STYPE_SPECIAL;

    if (share_entry->shi2_type == STYPE_PRINTQ)
        get_print_devices(share_entry->shi2_netname);
    else
        _tcscpy(Buffer, share_entry->shi2_path);

    WriteToCon(fmtPSZ, 0, maxLen,
               PaddedString(maxLen,ShareMsgList[SHARE_MSG_NAME].msg_text,NULL),
               share_entry->shi2_netname);

    WriteToCon(fmtNPSZ, 0, maxLen,
               PaddedString(maxLen,ShareMsgList[SHARE_MSG_PATH].msg_text,NULL),
               Buffer);

    WriteToCon(fmtPSZ, 0, maxLen,
               PaddedString(maxLen,ShareMsgList[SHARE_MSG_REMARK].msg_text,NULL),
               share_entry->shi2_remark);

    if (share_entry->shi2_max_uses == SHI_USES_UNLIMITED)
        WriteToCon(fmtNPSZ, 0, maxLen,
                   PaddedString(maxLen,ShareMsgList[SHARE_MSG_MAX_USERS].msg_text,NULL),
                   ShareMsgList[SHARE_MSG_ULIMIT].msg_text);
    else
        WriteToCon(fmtULONG, 0, maxLen,
                   PaddedString(maxLen,ShareMsgList[SHARE_MSG_MAX_USERS].msg_text,NULL),
                   share_entry->shi2_max_uses);

    NetApiBufferFree((TCHAR FAR *) share_entry);

    if( (dwErr = NetConnectionEnum(
                       NULL,
                       netname,
                       1,
                       (LPBYTE*)&pBuffer,
                       MAX_PREFERRED_LENGTH,
                       &num_read,
                       &cTotalAvail,
                       NULL)) == ERROR_MORE_DATA)
        more_data = TRUE;
    else if (dwErr)
        ErrorExit(dwErr);


    WriteToCon(TEXT("%-*.*ws"),0,maxLen,
               PaddedString(maxLen,ShareMsgList[SHARE_MSG_USERS].msg_text,NULL));
    for (i = 0, conn_entry = (LPCONNECTION_INFO_1) pBuffer;
        i < num_read; i++, conn_entry++)
    {
        if ((i != 0) && ((i % 3) == 0))

            WriteToCon(TEXT("%-*.*ws"),maxLen,maxLen, NULL_STRING);
        WriteToCon(TEXT("%Fws"),
                   PaddedString(21,(conn_entry->coni1_username == NULL)
                                   ? (TCHAR FAR *)txt_UNKNOWN :
                                     conn_entry->coni1_username, NULL));
        if (((i + 1) % 3) == 0)
            PrintNL();
    }
    if ((i == 0) || ((i % 3) != 0))
        PrintNL();

    if (CacheInfo == TRUE)
        WriteToCon(fmtNPSZ, 0, maxLen,
               PaddedString(maxLen,ShareMsgList[SHARE_MSG_CACHING].msg_text,NULL),
               ShareMsgList[Idx].msg_text);

    if (num_read) {
        NetApiBufferFree(pBuffer);
    }

    if( more_data )
        InfoPrint(APE_MoreData);
    else
        InfoSuccess();

}


/***
 *  share_add()
 *      Add a share: NET SHARE netname[=resource[;resource...]]
 *
 *  Args:
 *      name - netname=resource string
 *      pass - password
 *      type - 0: unknown, STYPE_PRINTQ: printQ, STYPE_DEVICE: comm
 *
 *  Returns:
 *      nothing - success
 *      exit(2) - command failed
 */
VOID share_add(TCHAR * name, TCHAR * pass, int type)
{
    DWORD           dwErr;
    LPTSTR          resource;
    LPTSTR          ptr;
    LPSHARE_INFO_2  share_entry;
    ULONG           setType;
    TCHAR           disk_dev_buf[4];
    DWORD           cacheable;
    DWORD           maxLen;

    GetMessageList(NUM_SHARE_MSGS, ShareMsgList, &maxLen);

    start_autostart(txt_SERVICE_FILE_SRV);

    share_entry = (LPSHARE_INFO_2) GetBuffer(BIG_BUFFER_SIZE);

    if (share_entry == NULL)
    {
        ErrorExit(ERROR_NOT_ENOUGH_MEMORY);
    }

    share_entry->shi2_max_uses    = (DWORD) SHI_USES_UNLIMITED;
    share_entry->shi2_permissions = ACCESS_ALL & (~ACCESS_PERM); /* default */
    share_entry->shi2_remark      = 0L;

    /* Find netname and resource. We determine a value for resource rather  */
    /* strangely due to problems caused by _tcschr() returning a FAR char * */
    /* and resource needing to be a NEAR char *.                                                    */

    if (ptr = _tcschr(name, '='))
    {
        *ptr = NULLC;
        resource = name + _tcslen(name) + 1;

        /* if use specified path for IPC$ or ADMIN$, barf! */
        if (!_tcsicmp(name, ADMIN_DOLLAR) || !_tcsicmp(name, IPC_DOLLAR))
            ErrorExit(APE_CannotShareSpecial) ;
    }
    else
        resource = NULL;

    share_entry->shi2_netname = name;

    if (type == STYPE_DEVICE)
    {
        share_entry->shi2_type = STYPE_DEVICE;
        share_entry->shi2_path = resource;
        share_entry->shi2_permissions = ACCESS_CREATE | ACCESS_WRITE |
                                        ACCESS_READ;
    }
    else if (resource == NULL)
    {
        /* Here must have  IPC$ or ADMIN$.  Assume the parser got it right  */
        if (! _tcsicmp(share_entry->shi2_netname, ADMIN_DOLLAR))
        {
            share_entry->shi2_type = STYPE_DISKTREE;
            share_entry->shi2_path = NULL;
        }
        else
        {
            share_entry->shi2_type = STYPE_IPC;
            share_entry->shi2_path = NULL;
        }
    }
    else
    {
        /* Disk or Spooled thing? */

        if (I_NetPathType(NULL, resource, &setType, 0L))
            /*  resource has already been typed successfully
             *  by the call to I_NetListCanon, so this error
             *  must mean that we have a LIST.
             */
            setType = ITYPE_DEVICE_LPT;

        if (setType == ITYPE_DEVICE_DISK)
        {
            _tcsncpy(disk_dev_buf,resource,3);
            _tcscpy(disk_dev_buf+2, TEXT("\\"));
            share_entry->shi2_path = (TCHAR FAR *)disk_dev_buf;
            share_entry->shi2_type = STYPE_DISKTREE;
        }
        else
        {
            share_entry->shi2_type = STYPE_DISKTREE;
            share_entry->shi2_path = resource;
        }
    }

    share_entry->shi2_passwd = TEXT("");

    share_munge(share_entry, &cacheable );

    if( cacheable != 0xFFFF && share_entry->shi2_type != STYPE_DISKTREE ) {
        ErrorExit( APE_BadCacheType );
    }

    if ((share_entry->shi2_type == STYPE_DISKTREE) && resource)
    {
        TCHAR dev[DEVLEN+1] ;
  
        dev[0] = *resource ;
        dev[1] = TEXT(':') ;
        dev[2] = TEXT('\\') ;
        dev[3] = 0 ;

        if (GetDriveType(dev) == DRIVE_REMOTE)
            ErrorExit(APE_BadResource) ;
    }

    if (dwErr = NetShareAdd(NULL,
                            2,
                            (LPBYTE)share_entry,
                            NULL))
        ErrorExit(dwErr);

    InfoPrintInsTxt(APE_ShareSuccess, share_entry->shi2_netname);

    if( cacheable != 0xFFFF ) {
        PSHARE_INFO_1005 s1005;

        if (dwErr = NetShareGetInfo(NULL,
                                    share_entry->shi2_netname,
                                    1005,
                                    (LPBYTE*)&s1005 )) {
            ErrorExit(dwErr);
        }

        s1005->shi1005_flags &= ~CSC_MASK;
        s1005->shi1005_flags |= cacheable;

        if (dwErr = NetShareSetInfo(NULL,
                                    share_entry->shi2_netname,
                                    1005,
                                    (LPBYTE)s1005,
                                    NULL)) {
 
            ErrorExit(dwErr);
        }

        NetApiBufferFree( (TCHAR FAR *)s1005 );
    }

    NetApiBufferFree((TCHAR FAR *) share_entry);
}



/***
 *  share_del()
 *      Delete a share
 *
 *  Args:
 *      name - share to delete
 *
 *  Returns:
 *      nothing - success
 *      exit(1) - command completed with errors
 *      exit(2) - command failed
 */
VOID share_del(TCHAR * name)
{
    DWORD            err;                /* API return status */
    DWORD            err2;               /* API return status */
    DWORD            cTotalAvail;
    LPTSTR           pEnumBuffer;
    DWORD            last_err;
    DWORD            err_cnt = 0;
    DWORD            num_read;           /* num entries read by API */
    DWORD            i;
    ULONG            LongType;
    DWORD            type;
    int              found;
    TCHAR            share[NNLEN+1];
    LPSHARE_INFO_2   share_entry;

    /*
     * MAINTENANCE NOTE: While doing maintenance for bug fix 1800, it was
     * noticed that this function uses BigBuf, and so does the function
     * delete_share() which is called by this function.  In the current
     * implementation this is not a problem, because of the api calling
     * pattern. However, the slightest change could break this function, or
     * delete_share(), so beware!  Bug fix 1800 was directly ported from
     * the MSKK code. The api calls in this function and in share_del() are
     * incredibly redundant, but I left it as is rather than risk breaking
     * it. - RobDu
     */

    err = delete_share(name);  /* check for Open files, and delete share */

    switch (err)
    {
    case NERR_Success:
        return;

    case NERR_NetNameNotFound:
        /*
         * the name was not found, so we try deleting the sticky entry
         * in registry.
         */
        err = NetShareDelSticky(NULL, name, 0) ;
        if (err == NERR_Success)
        {
            InfoPrintInsTxt(APE_DelStickySuccess, name);
            return ;
        }
        else if (err == NERR_NetNameNotFound)
            break;
        else
            ErrorExit(err);

    default:
        ErrorExit(err);
    }

/***
 *  Only get here if "share" that user asked us to delete was
 *  NOT a share name.  Could be a disk path, or a com or lpt
 *  device
 */
    if (err2 = I_NetPathType(NULL, name, &LongType, 0L))
        ErrorExit(err2);

    if (LongType == ITYPE_PATH_ABSD)
        type = STYPE_DISKTREE;
    else
    {
        if ((LongType & ITYPE_DEVICE) == 0)
            ErrorExit(NERR_NetNameNotFound);
        else
        {
            if (err = NetShareCheck(NULL, name, &type))
                ErrorExit(err);
        }
    }

    found = FALSE;

    switch (type)
    {
    case STYPE_DISKTREE:
        if (err = NetShareEnum(NULL,
                               2,
                               (LPBYTE*)&pEnumBuffer,
                               MAX_PREFERRED_LENGTH,
                               &num_read,
                               &cTotalAvail,
                               NULL))
            ErrorExit(err);

        for (i = 0, share_entry = (LPSHARE_INFO_2) pEnumBuffer;
             i < num_read; i++, share_entry++)
        {
            if (! _tcsicmp(share_entry->shi2_path, name))
            {
                found = TRUE;
                _tcscpy(share, share_entry->shi2_netname);
                ShrinkBuffer();

                if (err = delete_share(share))
                {
                    last_err = err;
                    err_cnt++;
                    InfoPrintInsTxt(APE_ShareErrDeleting, share);
                }
            }
        }
        NetApiBufferFree(pEnumBuffer);

        break;

    default:
        ErrorExit(ERROR_INVALID_PARAMETER) ;

    } /* switch */


/***
 *  Bye, bye
 */

    if ((err_cnt) && (err_cnt == num_read))
        ErrorExit(last_err);
    else if (err_cnt)
    {
        InfoPrint(APE_CmdComplWErrors);
        NetcmdExit(1);
    }
    else if (! found)
        ErrorExit(APE_ShareNotFound);

    InfoPrintInsTxt(APE_DelSuccess, name);
}




/***
 *  share_change()
 *      Change options on a share
 *
 *  Args:
 *      netname - netname of share to change
 *
 *  Returns:
 *      nothing - success
 *      exit(2) - command failed
 */
VOID
share_change(
    LPTSTR netname
    )
{
    DWORD             dwErr;
    LPTSTR            pBuffer;
    DWORD             cacheable;
    PSHARE_INFO_1005  s1005;
    DWORD             maxLen;

    GetMessageList(NUM_SHARE_MSGS, ShareMsgList, &maxLen);

    if (dwErr = NetShareGetInfo(NULL,
                                netname,
                                2,
                                (LPBYTE*)&pBuffer))
        ErrorExit(dwErr);

    if(dwErr = NetShareGetInfo(NULL,
                               netname,
                               1005,
                               (LPBYTE*)&s1005)) {
        ErrorExit(dwErr);
    }

    share_munge((LPSHARE_INFO_2) pBuffer, &cacheable );

    if (dwErr = NetShareSetInfo(NULL,
                                netname,
                                2,
                                (LPBYTE)pBuffer,
                                NULL))
        ErrorExit(dwErr);

    if( cacheable != 0xFFFF && (s1005->shi1005_flags & CSC_MASK) != cacheable ) {

        s1005->shi1005_flags &= ~CSC_MASK;
        s1005->shi1005_flags |= cacheable;

        if( dwErr = NetShareSetInfo( NULL,
                                     netname,
                                     1005,
                                     (LPBYTE)s1005,
                                     NULL )) {
            ErrorExit(dwErr);
        }
    }

    NetApiBufferFree(pBuffer);
    NetApiBufferFree( s1005 );
    InfoSuccess();
}


/***
 *  share_admin()
 *      Process NET SHARE [ipc$ | admin$] command line (display or add)
 *
 *  Args:
 *      name - the share
 *
 *  Returns:
 *      nothing - success
 *      exit(2) - command failed
 */
VOID share_admin(TCHAR * name)
{
    DWORD                    dwErr;
    TCHAR FAR *              pBuffer;

    start_autostart(txt_SERVICE_FILE_SRV);
    if (dwErr = NetShareGetInfo(NULL,
                                name,
                                0,
                                (LPBYTE*)&pBuffer))
    {
        if (dwErr == NERR_NetNameNotFound)
        {
            /* must be a new use */
            if (! _tcsicmp(name,  ADMIN_DOLLAR))
                check_max_uses();
            share_add(name, NULL, 0);
        }
        else
            ErrorExit(dwErr);
    }
    else
    {
        /* Share exists */
        if (SwitchList[0])
            share_change(name);
        else
            share_display_share(name);
    }

    NetApiBufferFree(pBuffer);
}

/***
 *  share_munge()
 *      Set the values in the share info struct based on switches
 *
 *  Args:
 *      none
 *
 *  Returns:
 *      nothing - success
 *      exit(2) - command failed
 */
VOID
share_munge(
    LPSHARE_INFO_2 share_entry,
    LPDWORD        CacheFlag
    )
{
    int i;
    TCHAR * pos;
    int len;

    *CacheFlag = 0xFFFF;        // default setting

    for (i = 0; SwitchList[i]; i++)
    {
	if (! _tcscmp(SwitchList[i], swtxt_SW_SHARE_UNLIMITED))
	{
	    share_entry->shi2_max_uses = (DWORD) SHI_USES_UNLIMITED;
	    continue;
	}
        else if (! _tcscmp(SwitchList[i], swtxt_SW_SHARE_COMM))
            continue;
        else if (! _tcscmp(SwitchList[i], swtxt_SW_SHARE_PRINT))
            continue;

        if ((pos = FindColon(SwitchList[i])) == NULL)
            ErrorExit(APE_InvalidSwitchArg);

        if (! _tcscmp(SwitchList[i], swtxt_SW_SHARE_USERS))
        {
            share_entry->shi2_max_uses =
                do_atoul(pos,APE_CmdArgIllegal,swtxt_SW_SHARE_USERS);
            if ( share_entry->shi2_max_uses < 1)
            {
                ErrorExitInsTxt(APE_CmdArgIllegal, swtxt_SW_SHARE_USERS);
            }
        }
        else if (! _tcscmp(SwitchList[i], swtxt_SW_REMARK))
        {
	    if (_tcslen(pos) > LM20_MAXCOMMENTSZ)
	        ErrorExitInsTxt(APE_CmdArgIllegal,swtxt_SW_REMARK);
	    share_entry->shi2_remark = pos;
        }
        else if( ! _tcscmp( SwitchList[i], swtxt_SW_CACHE))
        {
            if( CacheFlag == NULL ) {
                ErrorExit( APE_InvalidSwitch );
            }

            _tcsupr( pos );
            len = _tcslen( pos );

            _tcsupr( ShareMsgList[ SWITCH_CACHE_AUTOMATIC ].msg_text );
            _tcsupr( ShareMsgList[ SWITCH_CACHE_MANUAL ].msg_text );
            _tcsupr( ShareMsgList[ SWITCH_CACHE_DOCUMENTS ].msg_text );
            _tcsupr( ShareMsgList[ SWITCH_CACHE_PROGRAMS ].msg_text );
            _tcsupr( ShareMsgList[ SWITCH_CACHE_NONE ].msg_text );

            if( !_tcsncmp( pos, ShareMsgList[ SWITCH_CACHE_AUTOMATIC ].msg_text, len ) ||
                *pos == YES_KEY ) {

                *CacheFlag = CSC_CACHE_AUTO_REINT;

            } else if( !_tcsncmp( pos, ShareMsgList[ SWITCH_CACHE_MANUAL ].msg_text, len ) ) {

                *CacheFlag = CSC_CACHE_MANUAL_REINT;

            } else if( !_tcsncmp( pos, ShareMsgList[ SWITCH_CACHE_DOCUMENTS ].msg_text, len ) ) {

                *CacheFlag = CSC_CACHE_AUTO_REINT;

            } else if( !_tcsncmp( pos, ShareMsgList[ SWITCH_CACHE_PROGRAMS ].msg_text, len ) ) {

                *CacheFlag = CSC_CACHE_VDO;

            } else if( !_tcsncmp( pos, ShareMsgList[ SWITCH_CACHE_NONE ].msg_text, len ) ) {

                *CacheFlag = CSC_CACHE_NONE;

            } else if( *pos == NO_KEY ) {

                *CacheFlag = CSC_CACHE_NONE;

            } else {
                ErrorExitInsTxt( APE_CmdArgIllegal,swtxt_SW_CACHE );
            }

            continue;
        }

    }
}

/***
 *  check_max_uses()
 *
 *      Check if a share has a /USERS:n switch or a /UNLIMITED
 *      switch.  If not, set max_users to the value of num_admin.
 *
 *      Currently used only on the ADMIN$ share.
 *
 *  Args:
 *      none
 *
 *  Returns:
 *      nothing - success
 *      exit(2) - command failed
 */
VOID NEAR check_max_uses(VOID)
{
    DWORD                   dwErr;
    int                     i;
    LPSERVER_INFO_2         server_entry;
    LPTSTR                  ptr;
    DWORD                   swlen1, swlen2 ;
    static TCHAR            users_switch[20] ;

    _tcscpy(users_switch,swtxt_SW_SHARE_USERS);
    swlen1 = _tcslen(users_switch);
    swlen2 = _tcslen(swtxt_SW_SHARE_UNLIMITED);
    for (i = 0; SwitchList[i]; i++)
    {
        if ( (_tcsncmp(SwitchList[i], users_switch, swlen1) == 0) ||
             (_tcsncmp(SwitchList[i], swtxt_SW_SHARE_UNLIMITED, swlen2) == 0)
           )
        {
            return;     //  A specific switch exists; return without
                        //  further action.
        }
    }

    if (dwErr = MNetServerGetInfo(NULL,
                                  2,
                                  (LPBYTE*)&server_entry))
    {
        ErrorExit (dwErr);
    }

    ptr = _tcschr(users_switch, NULLC);
    swprintf(ptr, TEXT(":%u"), server_entry->sv2_numadmin);

    SwitchList[i] = users_switch;
    NetApiBufferFree((TCHAR FAR *) server_entry);
}


DWORD delete_share(TCHAR * name)
{
    DWORD                dwErr;
    DWORD                cTotalAvail;
    LPTSTR               pBuffer;
    DWORD                num_read;           /* num entries read by API */
    WORD                 num_prtq;           /* num entries read by API */
    DWORD                i;
    DWORD                total_open = 0;
    WORD                 available;          /* num entries available */
    LPSHARE_INFO_2       share_entry;
    LPCONNECTION_INFO_1  conn_entry;

    PRQINFO far * q_ptr;
    PRJINFO far * job_ptr;
    int     uses;
    unsigned short  num_jobs;

    /*
     * MAINTENANCE NOTE: While doing maintenance for bug fix 1800, it was
     * noticed that this function uses BigBuf, and so does the function
     * that calls this function (share_del()).  In the current implementation,
     * this is not a problem because of the api calling pattern.  However, the
     * slightest change could break this function, or share_del(), so beware!
     * Bug fix 1800 was directly ported from the MSKK code. The api calls in
     * this function and in share_del() are incredibly redundant, but I left it
     * as is rather than risking breaking it. - RobDu
     */

    if (dwErr = NetShareGetInfo(NULL,
                                name,
                                2,
                                (LPBYTE*)&pBuffer))
    {
	return dwErr;
    }

    share_entry = (LPSHARE_INFO_2) pBuffer;

    //
    // don't delete the share during spooling
    //
    uses = share_entry->shi2_current_uses;

    share_entry->shi2_type &= ~STYPE_SPECIAL;
    if (share_entry->shi2_type == STYPE_PRINTQ)
    {
        if (dwErr = CallDosPrintEnumApi(DOS_PRINT_Q_ENUM, NULL, NULL,
                                        2, &num_prtq, &available))
        {
            ErrorExit (dwErr);
        }

        q_ptr = (PRQINFO *) BigBuf;

        while (num_prtq--)
        {
            job_ptr = (PRJINFO far *)(q_ptr + 1);
            num_jobs = q_ptr->cJobs;
            if(job_ptr->fsStatus & PRJ_QS_SPOOLING)
            {
                ErrorExit (APE_ShareSpooling);
            }

            q_ptr = (PRQINFO *)(job_ptr + num_jobs);
        }
    }

    if (uses)
    {
        NetApiBufferFree(pBuffer);
        if (dwErr = NetConnectionEnum(
                                      NULL,
                                      name,
                                      1,
                                      (LPBYTE*)&pBuffer,
                                      MAX_PREFERRED_LENGTH,
                                      &num_read,
                                      &cTotalAvail,
                                      NULL))
            ErrorExit (dwErr);

        for (i = 0, conn_entry = (LPCONNECTION_INFO_1) pBuffer;
            i < num_read; i++, conn_entry++)
        {
            total_open += conn_entry->coni1_num_opens;
        }

        ShrinkBuffer();

        if (total_open)
        {
            InfoPrintInsTxt(APE_ShareOpens, name);

            if (!YorN(APE_ProceedWOp, 0))
                NetcmdExit(2);
        }
    }

    if (dwErr = NetShareDel(NULL, name, 0))
        ErrorExit(dwErr);

    InfoPrintInsTxt(APE_DelSuccess, name);
    return NERR_Success;
    NetApiBufferFree(pBuffer);
}

/***
 *  Gets the destination list for a print q.
 *
 *  Q name is arg.  Destination list is in Buffer on EXIT.
 */
VOID NEAR get_print_devices(TCHAR FAR * queue)
{
    USHORT                  available;
    PRQINFO FAR *           q_info;

    if (DosPrintQGetInfo(NULL,
                        queue,
                        1,
                        (LPBYTE)Buffer,
                        LITTLE_BUF_SIZE,
                        &available))
    {
        *Buffer = NULLC;
        return;
    }

    q_info = (PRQINFO FAR *)Buffer;

    /* Does _tcscpy deal with overlapping regions? */
    memcpy(Buffer,
            q_info->pszDestinations,
            (_tcslen(q_info->pszDestinations)+1) * sizeof(TCHAR));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\netcmd\stats.c ===
/********************************************************************/
/**			Microsoft LAN Manager			   **/
/**		  Copyright(c) Microsoft Corp., 1987-1990	   **/
/********************************************************************/

/***
 *  stats.c 
 *	Functions to display and clear network statistics
 *
 *  History:
 *	mm/dd/yy, who, comment
 *	06/12/87, agh, new code
 *	03/21/89, kms, 1.2 changes
 *	02/20/91, danhi, change to use lm 16/32 mapping layer
 *      08/22/92, chuckc, fixed to match lastest rdr stats structure
 */

/* Include files */

#define INCL_NOCOMMON
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <os2.h>
#include <lmcons.h>
#include <lmerr.h>
#include <lmapibuf.h>
#include <apperr.h>
#include <apperr2.h>
#include <lmsvc.h>
#include <lui.h>
#include <lmstats.h>
#include <dlwksta.h>
#include "mwksta.h"
#include "netcmds.h"
#include "nettext.h"
#include "msystem.h"

/* Constants */

#define KBYTES 1024	/* By fiat of Darryl, this is 1024,
			 * the techie version of "K". -paulc
			 */

#define DLWBUFSIZE  22	/* buffer big enough to represent a 64-bit unsigned int
			 * LONG number in base 10
			 */
#define STATS_UNKNOWN	0xFFFFFFFF

/*
 * macros
 */

/*  This code rounds to the NEARest 2^^10   JONN 6/13/90    */
/*  Does not check for high-byte overflow; do not call when */
/*	(lo) == (hi) == 0xffffffff			    */
#define DLW_DIVIDE_1K(hi,lo)	if ((lo) & (0x1 << 9)) \
	    { \
		(lo) += (0x1 << 9); \
		if ((lo) == 0x0) \
		    (hi) += 0x1; \
	    } \
	    (lo) = ( (hi) << 22) | ((lo) >> 10); \
	    (hi) = (hi) >> 10


/* Static variables */

static TCHAR stat_fmt3[] = TEXT("  %-*.*ws%lu\r\n");
static TCHAR stat_fmt4[] = TEXT("  %-*.*ws%ws\r\n");

/* The list of services for which stats are collected */

static TCHAR * allowed_svc[] = {
    SERVICE_WORKSTATION,
    SERVICE_SERVER,
    NULL };


/* Forward declarations */

VOID   stats_headers(TCHAR *, USHORT, TCHAR FAR **);
LPTSTR format_dlword(ULONG, ULONG, TCHAR *);
VOID   revstr_add(TCHAR FAR *, TCHAR FAR *);
VOID   SrvPrintStat(TCHAR *,TCHAR *,DWORD,USHORT,ULONG);
VOID   WksPrintStat(TCHAR *,TCHAR *,DWORD,USHORT,ULONG);
VOID   WksPrintLargeInt(TCHAR *, DWORD, USHORT, ULONG, ULONG);
DWORD  TimeToSecsSince1970(PLARGE_INTEGER time, PULONG seconds);


#define W_MSG_BYTES_RECEIVED 	    	0
#define W_MSG_SMBS_RECEIVED		1
#define W_MSG_BYTES_TRANSMITTED		2
#define W_MSG_SMBS_TRANSMITTED		3
#define W_MSG_READ_OPS			4
#define W_MSG_WRITE_OPS			5
#define W_MSG_RAW_READS_DENIED		6
#define W_MSG_RAW_WRITES_DENIED		7
#define W_MSG_NETWORK_ERRORS		8
#define W_MSG_TOTAL_CONNECTS		9
#define W_MSG_RECONNECTS		10
#define W_MSG_SRV_DISCONNECTS		11
#define W_MSG_SESSIONS			12
#define W_MSG_HUNG_SESSIONS		13
#define W_MSG_FAILED_SESSIONS		14
#define W_MSG_FAILED_OPS		15
#define W_MSG_USE_COUNT			16
#define W_MSG_FAILED_USE_COUNT		17
#define W_MSG_GEN_UNKNOWN		18

static MESSAGE WkstaMsgList[] = {
    {APE2_STATS_BYTES_RECEIVED,		NULL},
    {APE2_STATS_SMBS_RECEIVED,		NULL},
    {APE2_STATS_BYTES_TRANSMITTED,	NULL},
    {APE2_STATS_SMBS_TRANSMITTED,	NULL},
    {APE2_STATS_READ_OPS, 		NULL},
    {APE2_STATS_WRITE_OPS,		NULL},
    {APE2_STATS_RAW_READS_DENIED,	NULL},
    {APE2_STATS_RAW_WRITES_DENIED,	NULL},
    {APE2_STATS_NETWORK_ERRORS,		NULL},
    {APE2_STATS_TOTAL_CONNECTS,		NULL},
    {APE2_STATS_RECONNECTS, 		NULL},
    {APE2_STATS_SRV_DISCONNECTS, 	NULL},
    {APE2_STATS_SESSIONS,		NULL},
    {APE2_STATS_HUNG_SESSIONS, 		NULL},
    {APE2_STATS_FAILED_SESSIONS, 	NULL},
    {APE2_STATS_FAILED_OPS, 		NULL},
    {APE2_STATS_USE_COUNT, 		NULL},
    {APE2_STATS_FAILED_USE_COUNT, 	NULL},
    {APE2_GEN_UNKNOWN,			NULL},
};

#define WKSTAMSGSIZE	    (sizeof(WkstaMsgList) / sizeof(WkstaMsgList[0]))

#define S_MSG_STATS_S_ACCEPTED	    0
#define S_MSG_STATS_S_TIMEDOUT	    (S_MSG_STATS_S_ACCEPTED + 1)
#define S_MSG_STATS_ERROREDOUT	    (S_MSG_STATS_S_TIMEDOUT + 1)
#define S_MSG_STATS_B_SENT	    (S_MSG_STATS_ERROREDOUT + 1)
#define S_MSG_STATS_B_RECEIVED	    (S_MSG_STATS_B_SENT + 1)
#define S_MSG_STATS_RESPONSE	    (S_MSG_STATS_B_RECEIVED + 1)
#define S_MSG_STATS_NETIO_ERR	    (S_MSG_STATS_RESPONSE + 1)
#define S_MSG_STATS_SYSTEM_ERR	    (S_MSG_STATS_NETIO_ERR + 1)
#define S_MSG_STATS_PERM_ERR	    (S_MSG_STATS_SYSTEM_ERR + 1)
#define S_MSG_STATS_PASS_ERR	    (S_MSG_STATS_PERM_ERR + 1)
#define S_MSG_STATS_FILES_ACC	    (S_MSG_STATS_PASS_ERR + 1)
#define S_MSG_STATS_COMM_ACC	    (S_MSG_STATS_FILES_ACC + 1)
#define S_MSG_STATS_PRINT_ACC	    (S_MSG_STATS_COMM_ACC + 1)
#define S_MSG_STATS_BIGBUF	    (S_MSG_STATS_PRINT_ACC + 1)
#define S_MSG_STATS_REQBUF	    (S_MSG_STATS_BIGBUF + 1)
#define S_MSG_GEN_UNKNOWN	    (S_MSG_STATS_REQBUF + 1)

static MESSAGE ServerMsgList[] = {
    {APE2_STATS_S_ACCEPTED,	NULL},
    {APE2_STATS_S_TIMEDOUT,	NULL},
    {APE2_STATS_ERROREDOUT,	NULL},
    {APE2_STATS_B_SENT, 	NULL},
    {APE2_STATS_B_RECEIVED,	NULL},
    {APE2_STATS_RESPONSE,	NULL},
    {APE2_STATS_NETIO_ERR,	NULL},
    {APE2_STATS_SYSTEM_ERR,	NULL},
    {APE2_STATS_PERM_ERR,	NULL},
    {APE2_STATS_PASS_ERR,	NULL},
    {APE2_STATS_FILES_ACC,	NULL},
    {APE2_STATS_COMM_ACC,	NULL},
    {APE2_STATS_PRINT_ACC,	NULL},
    {APE2_STATS_BIGBUF, 	NULL},
    {APE2_STATS_REQBUF, 	NULL},
    {APE2_GEN_UNKNOWN,		NULL},
};

#define SRVMSGSIZE	(sizeof(ServerMsgList) / sizeof(ServerMsgList[0]))




/***
 *  stats_display ()
 *	Displays the list of installed services that have stats
 *
 */
VOID stats_display(VOID)
{
    DWORD             dwErr;
    DWORD             cTotalAvail;
    LPTSTR            pBuffer;
    DWORD	      _read;	/* num entries read by API */
    DWORD	      i;
    USHORT            j;
    int               printed = 0;
    LPSERVICE_INFO_2  info_list_entry;

    if (dwErr = NetServiceEnum(
			    NULL,
			    2,
			    (LPBYTE *) &pBuffer,
                            MAX_PREFERRED_LENGTH,
			    &_read,
                            &cTotalAvail,
                            NULL))
	ErrorExit(dwErr);

    if (_read == 0)
	EmptyExit();

    InfoPrint(APE_StatsHeader);

    for (i=0, info_list_entry = (LPSERVICE_INFO_2) pBuffer;
	 i < _read; i++, info_list_entry++)
    {
	for (j = 0 ;  allowed_svc[j] ; j++)
	{
	    if (!(_tcsicmp(allowed_svc[j], info_list_entry->svci2_name)) )
	    {
		WriteToCon(TEXT("   %Fws"), info_list_entry->svci2_display_name);
		PrintNL();
		break;
	    }
	}
    }

    PrintNL();
    NetApiBufferFree(pBuffer);

    InfoSuccess();
}

/*
 * generic stats entry point. based on the service name, it will
 * call the correct worker function. it tries to map a display name to a 
 * key name, and then looks for that keyname in a list of 'known' services
 * that we may special case. note that if a display name cannot be mapped,
 * we use it as a key name. this ensures old batch files are not broken.
 */
VOID stats_generic_display(TCHAR *service)
{
    TCHAR *keyname ;
    UINT  type ;

    keyname = MapServiceDisplayToKey(service) ;

    type = FindKnownService(keyname) ;

    switch (type)
    {
	case  KNOWN_SVC_WKSTA :
	    stats_wksta_display() ;
	    break ;
	case  KNOWN_SVC_SERVER :
	    stats_server_display() ;
	    break ;
  	default:
	    help_help(0, USAGE_ONLY) ;
	    break ;
    }
}


/***
 *  stats_server_display()
 *	Display server statistics
 *
 *  Args:
 *	none
 *
 *  Returns:
 *	nothing - success
 *	exit 2 - command failed
 */
VOID stats_server_display(VOID)
{
    LPSTAT_SERVER_0 stats_entry;
    DWORD           maxmsglen;
    TCHAR           dlwbuf[DLWBUFSIZE];
    TCHAR           time_buf[30];

    /* get the text we'll need */
    GetMessageList(SRVMSGSIZE, ServerMsgList, &maxmsglen);

#ifdef DEBUG
    WriteToCon(TEXT("stats_server_display: Got message list\r\n"));
#endif

    maxmsglen += 5;

    start_autostart(txt_SERVICE_FILE_SRV);

    /*
     * stats_headers() will call the NetStatisticsGetInfo call
     */
    stats_headers(txt_SERVICE_FILE_SRV, APE2_STATS_SERVER,
	(TCHAR FAR **) & stats_entry);

    UnicodeCtime(&stats_entry->sts0_start, time_buf, 30);

    InfoPrintInsTxt(APE2_STATS_SINCE, time_buf);
    PrintNL();

    SrvPrintStat(fmtULONG, fmtNPSZ, maxmsglen, S_MSG_STATS_S_ACCEPTED,
		stats_entry->sts0_sopens);

    SrvPrintStat(fmtULONG, fmtNPSZ, maxmsglen, S_MSG_STATS_S_TIMEDOUT,
		stats_entry->sts0_stimedout);

    SrvPrintStat(fmtULONG, fmtNPSZ, maxmsglen, S_MSG_STATS_ERROREDOUT,
		stats_entry->sts0_serrorout);

    PrintNL();

    if( stats_entry->sts0_bytessent_high == STATS_UNKNOWN &&
	stats_entry->sts0_bytessent_low == STATS_UNKNOWN )
    {
	WriteToCon(fmtNPSZ, 0, maxmsglen,
		PaddedString(maxmsglen,ServerMsgList[S_MSG_STATS_B_SENT].msg_text,NULL),
		ServerMsgList[S_MSG_GEN_UNKNOWN].msg_text);
    }
    else
    {
	DLW_DIVIDE_1K(stats_entry->sts0_bytessent_high,
	      stats_entry->sts0_bytessent_low);

	WriteToCon(fmtNPSZ, 0, maxmsglen,
	    PaddedString(maxmsglen,ServerMsgList[S_MSG_STATS_B_SENT].msg_text,NULL),
	    format_dlword(stats_entry->sts0_bytessent_high,
			  stats_entry->sts0_bytessent_low,
			  dlwbuf));
    }

    if( stats_entry->sts0_bytesrcvd_high == STATS_UNKNOWN &&
	stats_entry->sts0_bytesrcvd_low == STATS_UNKNOWN )
    {
	WriteToCon(fmtNPSZ, 0, maxmsglen,
		PaddedString(maxmsglen,ServerMsgList[S_MSG_STATS_B_RECEIVED].msg_text,NULL),
		ServerMsgList[S_MSG_GEN_UNKNOWN].msg_text);
    }
    else
    {
	DLW_DIVIDE_1K(stats_entry->sts0_bytesrcvd_high,
	      stats_entry->sts0_bytesrcvd_low);

	WriteToCon(fmtNPSZ, 0, maxmsglen,
	    PaddedString(maxmsglen,ServerMsgList[S_MSG_STATS_B_RECEIVED].msg_text,NULL),
	    format_dlword(stats_entry->sts0_bytesrcvd_high,
			  stats_entry->sts0_bytesrcvd_low,
			  dlwbuf));
    }

    PrintNL();

    SrvPrintStat(fmtULONG, fmtNPSZ, maxmsglen, S_MSG_STATS_RESPONSE,
		stats_entry->sts0_avresponse);

    PrintNL();


    SrvPrintStat(fmtULONG, fmtNPSZ, maxmsglen, S_MSG_STATS_SYSTEM_ERR,
		stats_entry->sts0_syserrors);

    SrvPrintStat(fmtULONG, fmtNPSZ, maxmsglen, S_MSG_STATS_PERM_ERR,
		stats_entry->sts0_permerrors);

    SrvPrintStat(fmtULONG, fmtNPSZ, maxmsglen, S_MSG_STATS_PASS_ERR,
		stats_entry->sts0_pwerrors);

    PrintNL();

    SrvPrintStat(fmtULONG, fmtNPSZ, maxmsglen, S_MSG_STATS_FILES_ACC,
		stats_entry->sts0_fopens);

    SrvPrintStat(fmtULONG, fmtNPSZ, maxmsglen, S_MSG_STATS_COMM_ACC,
		stats_entry->sts0_devopens);

    SrvPrintStat(fmtULONG, fmtNPSZ, maxmsglen, S_MSG_STATS_PRINT_ACC,
		stats_entry->sts0_jobsqueued);

    PrintNL();
    InfoPrint(APE2_STATS_BUFCOUNT);

    SrvPrintStat(stat_fmt3,
                 stat_fmt4,
                 maxmsglen - 2,
                 S_MSG_STATS_BIGBUF,
                 stats_entry->sts0_bigbufneed);

    SrvPrintStat(stat_fmt3,
		stat_fmt4,
		maxmsglen - 2,
		S_MSG_STATS_REQBUF,
		stats_entry->sts0_reqbufneed);
    PrintNL() ;

    NetApiBufferFree((TCHAR FAR *) stats_entry);

    InfoSuccess();
}


/***
 *  stats_wksta_display()
 *	Display wksta statistics
 *
 *  Args:
 *	none
 *
 *  Returns:
 *	nothing - success
 *	exit 2 - command failed
 */
VOID
stats_wksta_display(
    VOID
    )
{
    LPSTAT_WORKSTATION_0 stats_entry;
    DWORD                maxmsglen;
    DWORD                err;
    unsigned int         entry_unknown = FALSE;/* TRUE if a stat which is summed to
					          create another stat is unknown. */
    ULONG	         total_connects;       /* for totaling connections. */
    DWORD                start_time ;
    TCHAR	         time_buf[64];         /* for displaying time */

    /* get the text we'll need */
    GetMessageList(WKSTAMSGSIZE, WkstaMsgList, &maxmsglen);

    maxmsglen += 5;

    start_autostart(txt_SERVICE_REDIR);

    /*
     * stats_headers() will call the NetStatisticsGetInfo call
     */
    stats_headers(txt_SERVICE_REDIR, APE2_STATS_WKSTA,
	          (TCHAR FAR **) & stats_entry);

    /*
     * display the time its been running. if system reports a time
     * outside the expressible range (shouldnt happen), we claim
     * it is unknown.
     */
    if (TimeToSecsSince1970(&stats_entry->StatisticsStartTime,
			     &start_time) != NERR_Success)
	
    {
        if (err = LUI_GetMsg(time_buf, 64, APE2_GEN_UNKNOWN))
            ErrorExit(err);
    }
    else
    {
        UnicodeCtime(&start_time, time_buf, 30);
    }

    InfoPrintInsTxt(APE2_STATS_SINCE, time_buf);
    PrintNL();


    /*
     * now print the actual stats
     */
    WksPrintLargeInt(stat_fmt4, maxmsglen, W_MSG_BYTES_RECEIVED,
		     stats_entry->BytesReceived.HighPart,
		     stats_entry->BytesReceived.LowPart ) ;
    WksPrintLargeInt(stat_fmt4, maxmsglen, W_MSG_SMBS_RECEIVED,
		     stats_entry->SmbsReceived.HighPart,
		     stats_entry->SmbsReceived.LowPart ) ;
    WksPrintLargeInt(stat_fmt4, maxmsglen, W_MSG_BYTES_TRANSMITTED,
		     stats_entry->BytesTransmitted.HighPart,
		     stats_entry->BytesTransmitted.LowPart ) ;
    WksPrintLargeInt(stat_fmt4, maxmsglen, W_MSG_SMBS_TRANSMITTED,
		     stats_entry->SmbsTransmitted.HighPart,
		     stats_entry->SmbsTransmitted.LowPart ) ;
    WksPrintStat(stat_fmt3, stat_fmt4, maxmsglen,
	    W_MSG_READ_OPS, stats_entry->ReadOperations ) ;
    WksPrintStat(stat_fmt3, stat_fmt4, maxmsglen,
	    W_MSG_WRITE_OPS, stats_entry->WriteOperations ) ;
    WksPrintStat(stat_fmt3, stat_fmt4, maxmsglen,
	    W_MSG_RAW_READS_DENIED, stats_entry->RawReadsDenied ) ;
    WksPrintStat(stat_fmt3, stat_fmt4, maxmsglen,
	    W_MSG_RAW_WRITES_DENIED, stats_entry->RawWritesDenied ) ;

    PrintNL() ;

    WksPrintStat(stat_fmt3, stat_fmt4, maxmsglen,
	    W_MSG_NETWORK_ERRORS, stats_entry->NetworkErrors ) ;

    total_connects = stats_entry->CoreConnects +
                     stats_entry->Lanman20Connects +
                     stats_entry->Lanman21Connects +
                     stats_entry->LanmanNtConnects ;
    WksPrintStat(stat_fmt3, stat_fmt4, maxmsglen,
	    W_MSG_TOTAL_CONNECTS, total_connects ) ;

    WksPrintStat(stat_fmt3, stat_fmt4, maxmsglen,
	    W_MSG_RECONNECTS, stats_entry->Reconnects ) ;
    WksPrintStat(stat_fmt3, stat_fmt4, maxmsglen,
	    W_MSG_SRV_DISCONNECTS, stats_entry->ServerDisconnects ) ;

    PrintNL() ;

    WksPrintStat(stat_fmt3, stat_fmt4, maxmsglen,
	    W_MSG_SESSIONS, stats_entry->Sessions ) ;
    WksPrintStat(stat_fmt3, stat_fmt4, maxmsglen,
	    W_MSG_HUNG_SESSIONS, stats_entry->HungSessions ) ;
    WksPrintStat(stat_fmt3, stat_fmt4, maxmsglen,
	    W_MSG_FAILED_SESSIONS, stats_entry->FailedSessions ) ;
    WksPrintStat(stat_fmt3, stat_fmt4, maxmsglen,
	    W_MSG_FAILED_OPS, 
		stats_entry->InitiallyFailedOperations + 
		stats_entry->FailedCompletionOperations ) ;
    WksPrintStat(stat_fmt3, stat_fmt4, maxmsglen,
	    W_MSG_USE_COUNT, stats_entry->UseCount ) ;
    WksPrintStat(stat_fmt3, stat_fmt4, maxmsglen,
	    W_MSG_FAILED_USE_COUNT, stats_entry->FailedUseCount ) ;
    PrintNL() ;

    NetApiBufferFree((TCHAR FAR *) stats_entry);

    InfoSuccess();
}


/***
 *  stats_headers()
 *	Display statistics headers
 *	BigBuf contains the stats_info_struct on return
 *
 *  Args:
 *	none
 *
 *  Returns:
 *	nothing - success
 *	exit 2 - command failed
 */
VOID
stats_headers(
    TCHAR  * service,
    USHORT headermsg,
    TCHAR  ** ppBuffer
    )
{
    DWORD              dwErr;
    TCHAR              cname[MAX_PATH+1];
    LPWKSTA_INFO_10    wksta_entry;

    /* get cname name for display */

    if (dwErr = MNetWkstaGetInfo(10, (LPBYTE *) &wksta_entry))
    {
	*cname = NULLC;
    }
    else
    {
	_tcscpy(cname, wksta_entry->wki10_computername);
        NetApiBufferFree((TCHAR FAR *) wksta_entry);
    }

#ifdef DEBUG
    WriteToCon(TEXT("About to call NetStatisticsGet2, service == %Fws\r\n"),
	    (TCHAR FAR *) service);
#endif

    if (dwErr = NetStatisticsGet(NULL,
				 service,
				 0,
				 0L,
				 (LPBYTE*)ppBuffer))
    {
	ErrorExit(dwErr);
    }

#ifdef DEBUG
    WriteToCon(TEXT("stats_headers: NetStatisticsGet succeeded\r\n"));
#endif

    InfoPrintInsTxt(headermsg, cname);
    PrintNL();
}


/*
 * format_dlword --
 *
 * This function takes a 64-bit number and writes its base-10 representation
 * into a string.
 *
 * Much magic occurs within this function, so beware. We do a lot of string-
 * reversing and addition-by-hand in order to get it to work.
 *
 *  ENTRY
 *	high	- high 32 bits
 *	low	- low 32 bits
 *	buf	- buffer to put it into
 *
 *  RETURNS
 *	pointer to buffer if successful
 */

TCHAR * format_dlword(ULONG high, ULONG low, TCHAR * buf)
{
    TCHAR addend[DLWBUFSIZE];  /* REVERSED power of two */
    TCHAR copy[DLWBUFSIZE];
    int i = 0;

    _ultow(low, buf, 10);    /* the low part is easy */
    _tcsrev(buf);	    /* and reverse it */

    /* set up addend with rep. of 2^32 */
    _ultow(0xFFFFFFFF, addend, 10);  /* 2^32 -1 */
    _tcsrev(addend);		    /* reversed, and will stay this way */
    revstr_add(addend, TEXT("1"));	    /* and add one == 2^32 */

    /* addend will contain the reverse-ASCII base-10 rep. of 2^(i+32) */

    /* now, we loop through each digit of the high longword */
    while (TRUE) {
	/* if this bit is set, add in its base-10 rep */
	if (high & 1)
	    revstr_add(buf,addend);

	/* move on to next bit */
	high >>= 1;

	/* if no more digits in high, bag out */
	if (!high)
	    break;

	/* we increment i, and double addend */
	i++;
	_tcscpy(copy, addend);
	revstr_add(addend,copy); /* i.e. add it to itself */

    }

    _tcsrev(buf);
    return buf;
}



/*
 * revstr_add --
 *
 *  This function will add together reversed ASCII representations of
 *  base-10 numbers.
 *
 *  Examples:	"2" + "2" = "4" "9" + "9" = "81"
 *
 *  This handles arbitrarily large numbers.
 *
 *  ENTRY
 *
 *  source	- number to add in
 *  target	- we add source to this
 *
 *  EXIT
 *  target	- contains sum of entry values of source and target
 *
 */

VOID
revstr_add(TCHAR FAR * target, TCHAR FAR * source)
{
    register TCHAR   accum;
    register TCHAR   target_digit;
    unsigned int    carrybit = 0;
    unsigned int    srcstrlen;
    unsigned int    i;

    srcstrlen = _tcslen(source);

    for (i = 0; (i < srcstrlen) || carrybit; ++i) {

	/* add in the source digit */
	accum =  (i < srcstrlen) ? (TCHAR) (source[i] - '0') : (TCHAR) 0;

	/* add in the target digit, or '0' if we hit null term */
	target_digit = target[i];
	accum += (target_digit) ? target_digit : '0';

	/* add in the carry bit */
	accum += (TCHAR) carrybit;

	/* do a carry out, if necessary */
	if (accum > '9') {
	    carrybit = 1;
	    accum -= 10;
	}
	else
	    carrybit = 0;

	/* if we're expanding the string, must put in a new null term */
	if (!target_digit)
	    target[i+1] = NULLC;

	/* and write out the digit */
	target[i] = accum;
    }

}



/*** SrvPrintStat - Print a server stat
 *
 */
VOID
SrvPrintStat(
    LPTSTR deffmt,
    LPTSTR unkfmt,
    DWORD  len,
    USHORT msg,
    ULONG _stat
    )
{
    if( _stat == STATS_UNKNOWN )
    {
        WriteToCon( unkfmt, 0, len,
                    PaddedString(len,ServerMsgList[msg].msg_text,NULL),
                    ServerMsgList[S_MSG_GEN_UNKNOWN].msg_text);
    }
    else
    {
        WriteToCon( deffmt, 0, len,
                    PaddedString(len,ServerMsgList[msg].msg_text,NULL),
                    _stat );
    }
}


/*** WksPrintStat - Print a workstation stat
 *
 */
VOID
WksPrintStat(
    TCHAR  *deffmt,
    TCHAR  *unkfmt,
    DWORD  len,
    USHORT msg,
    ULONG  _stat
    )
{
    if( _stat == STATS_UNKNOWN )
    {
        WriteToCon( unkfmt, 0, len,
            PaddedString(len,WkstaMsgList[msg].msg_text,NULL),
            WkstaMsgList[W_MSG_GEN_UNKNOWN].msg_text);
    }
    else
    {
        WriteToCon( deffmt, 0, len,
            PaddedString(len,WkstaMsgList[msg].msg_text,NULL),
	    _stat );
    }
}

/*** WksPrintLargeInt - Print a LARGE_INTEGER statistic
 *
 */
VOID
WksPrintLargeInt(
    TCHAR  *format,
    DWORD  maxmsglen,
    USHORT msgnum,
    ULONG  high,
    ULONG  low
    )
{
    TCHAR dlwbuf[DLWBUFSIZE];

    WriteToCon(format, 0, maxmsglen,
	   PaddedString(maxmsglen,WkstaMsgList[msgnum].msg_text,NULL),
	   format_dlword(high, low, dlwbuf));
}


//
// call Rtl routine to convert NT time to seconds since 1970.
//
DWORD
TimeToSecsSince1970(
    PLARGE_INTEGER time,
    PULONG         seconds
    )
{
    //
    // convert the NT time (large integer) to seconds
    //
    if (!RtlTimeToSecondsSince1970(time, seconds))
    {
        *seconds = 0L ;
        return ERROR_INVALID_PARAMETER ;
    }

    return NERR_Success ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\netcmd\start.c ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/***
 *  start.c
 *      Functions to start lanman services
 *
 *  History:
 *      mm/dd/yy, who, comment
 *      06/11/87, andyh, new code
 *      06/18/87, andyh, lot's o' changes
 *      07/15/87, paulc, removed 'buflen' from call to NetServiceInstall
 *      10/31/88, erichn, uses OS2.H instead of DOSCALLS
 *      01/04/89, erichn, filenames now MAXPATHLEN LONG
 *      05/02/89, erichn, NLS conversion
 *      05/09/89, erichn, local security mods
 *      06/08/89, erichn, canonicalization sweep
 *      08/16/89, paulc, support UIC_FILE
 *      08/20/89, paulc, moved print_start_error_msg to svcutil.c as
 *                          Print_UIC_Error
 *      03/08/90, thomaspa, autostarting calls will wait if another process
 *                          has already initiated the service start.
 *      02/20/91, danhi, converted to 16/32 mapping layer
 *      03/08/91, robdu, lm21 bug fix 451, consistent REPL password
 *                       canonicalization
 */

/* Include files */

#define INCL_NOCOMMON
#define INCL_DOSPROCESS
#define INCL_DOSQUEUES
#define INCL_DOSMISC
#define INCL_DOSFILEMGR
#include <os2.h>
#include <lmcons.h>
#include <lmerr.h>
#include <lmapibuf.h>
#include <apperr.h>
#include <apperr2.h>
#include <lmsvc.h>
#include <stdlib.h>
#include <dlwksta.h>
#include "mwksta.h"
#include <swtchtxt.h>
#include "netcmds.h"
#include "nettext.h"
#include "swtchtbl.h"
#include "msystem.h"

/* Constants */

/* External variables */

extern SWITCHTAB            start_rdr_switches[];
extern SWITCHTAB            start_rdr_ignore_switches[];
extern SWITCHTAB            start_netlogon_ignore_switches[];


/* Static variables */

static TCHAR *               ignore_service = NULL;
static TCHAR                 ignore_switch[] = TEXT(" ") SW_INTERNAL_IGNSVC TEXT(":");
/*
 * autostarting is set to TRUE by start_autostart, and is checked in
 * start service to determine whether or not to wait if the service is
 * in the start pending state.
 */
static BOOL                 autostarting = FALSE;

/* Forward declarations */

VOID  start_service(TCHAR *, int);
DWORD start_service_with_args(LPTSTR, LPTSTR, LPBYTE *);
int __cdecl CmpServiceInfo2(const VOID FAR * svc1, const VOID FAR * svc2) ;

/***
 *  start_display()
 *      Display started (and not stopped or errored) services
 *
 *  Args:
 *      none
 *
 *  Returns:
 *      nothing - success
 *      exit(2) - command failed
 */
VOID start_display(VOID)
{
    DWORD            dwErr;
    DWORD            cTotalAvail;
    LPTSTR           pBuffer;
    DWORD            num_read;           /* num entries read by API */
    LPSERVICE_INFO_2 service_entry;
    DWORD            i;

    dwErr = NetServiceEnum(NULL,
                           2,
                           (LPBYTE *) &pBuffer,
                           MAX_PREFERRED_LENGTH,
                           & num_read,
                           & cTotalAvail,
                           NULL);
    switch(dwErr)
    {
        case NERR_Success:
            InfoPrint(APE_StartStartedList);
            qsort(pBuffer,
                  num_read,
                  sizeof(SERVICE_INFO_2),
                  CmpServiceInfo2);

            for (i = 0, service_entry = (LPSERVICE_INFO_2) pBuffer;
                i < num_read; i++, service_entry++)
            {
                WriteToCon(TEXT("   %Fs"), service_entry->svci2_display_name);
                PrintNL();
            }

            PrintNL();
            InfoSuccess();
            NetApiBufferFree(pBuffer);
            break;

        case NERR_WkstaNotStarted:
            InfoPrint(APE_NothingRunning);
            if (!YorN(APE_StartRedir, 1))
                NetcmdExit(2);
            start_service(txt_SERVICE_REDIR, 0);
            break;

        default:
            ErrorExit(dwErr);
    }

}


/*
 * generic start service entry point. based on the service name, it will
 * call the correct worker function. it tries to map a display name to a
 * key name, and then looks for that keyname in a list of 'known' services
 * that we may special case. note that if a display name cannot be mapped,
 * we use it as a key name. this ensures old batch files are not broken.
 */
VOID start_generic(TCHAR *service, TCHAR *name)
{
    TCHAR *keyname ;
    UINT  type ;

    keyname = MapServiceDisplayToKey(service) ;

    type = FindKnownService(keyname) ;

    switch (type)
    {
	case  KNOWN_SVC_MESSENGER :
	    ValidateSwitches(0,start_msg_switches) ;
	    start_other(txt_SERVICE_MSG_SRV, name) ;
	    break ;
	case  KNOWN_SVC_WKSTA :
	    ValidateSwitches(0,start_rdr_switches) ;
	    start_workstation(name) ;
	    break ;
	case  KNOWN_SVC_SERVER :
	    ValidateSwitches(0,start_srv_switches) ;
	    start_other(txt_SERVICE_FILE_SRV, name) ;
	    break ;
	case  KNOWN_SVC_ALERTER :
	    ValidateSwitches(0,start_alerter_switches) ;
	    start_other(txt_SERVICE_ALERTER, NULL) ;
	    break ;
	case  KNOWN_SVC_NETLOGON :
	    ValidateSwitches(0,start_netlogon_switches) ;
	    start_other(txt_SERVICE_NETLOGON, NULL) ;
	    break ;
	case  KNOWN_SVC_NOTFOUND :
        default:
	    start_other(keyname, NULL);
	    break ;
    }
}



/***
 *  start_workstation()
 *      Start the lanman workstation.  Remove wksta switches from the
 *      SwitchList.
 *
 *  Args:
 *      name - computername for the workstation
 *
 *  Returns:
 *      nothing - success
 *      exit 2 - command failed
 */
VOID start_workstation(TCHAR * name)
{
    int                     i,j;
    TCHAR FAR *              good_one;   /* which element (cmd_line
                                        or trans) of the valid_list */
    TCHAR FAR *              found;
    TCHAR FAR *              tfpC;


    /* copy switches into BigBuf */
    *BigBuf = NULLC;
    tfpC = BigBuf;

    for (i = 0; SwitchList[i]; i++)
    {
        for(j = 0; start_rdr_switches[j].cmd_line; j++)
        {
            if (start_rdr_switches[j].translation)
                good_one = start_rdr_switches[j].translation;
            else
                good_one = start_rdr_switches[j].cmd_line;

            if (! _tcsncmp(good_one, SwitchList[i], _tcslen(good_one)))
            {
                _tcscpy(tfpC, SwitchList[i]);
                *SwitchList[i] = NULLC;
                tfpC = _tcschr(tfpC, NULLC) + 1;
            }
        }
    }
    *tfpC = NULLC;

    if (name)
    {

        /* check is there was a /COMPUTERNAME switch */
        for (found = BigBuf; *found; found = _tcschr(found, NULLC)+1)
            if (!_tcsncmp(swtxt_SW_WKSTA_COMPUTERNAME,
                        found,
                        _tcslen(swtxt_SW_WKSTA_COMPUTERNAME)))
                break;

        if (found == tfpC)
        {
            /* there was not */
            _tcscpy(tfpC, swtxt_SW_WKSTA_COMPUTERNAME);
            _tcscat(tfpC, TEXT(":"));
            _tcscat(tfpC, name);
            tfpC = _tcschr(tfpC, NULLC) + 1; /* NEED to update tfpC */
            *tfpC = NULLC;
        }
    }
    start_service(txt_SERVICE_REDIR, (int)(tfpC - BigBuf));
}



/***
 *  start_other()
 *      Start services other than the wksta
 *
 *  Args:
 *      service - service to start
 *      name - computername for the workstation
 *
 *  Returns:
 *      nothing - success
 *      exit 2 - command failed
 */
VOID
start_other(
    LPTSTR service,
    LPTSTR name
    )
{
    int     i;
    LPTSTR  tfpC;

    (void) name ; // not used

    ignore_service = service;

    /* copy switches into BigBuf */
    *BigBuf = NULLC;
    tfpC = BigBuf;
    for (i = 0; SwitchList[i]; i++)
    {
        if (*SwitchList[i] == NULLC)
        {
            /* Switch was a wksta switch which has been used already */
            continue;
        }

        _tcscpy(tfpC, SwitchList[i]);

        tfpC = _tcschr(tfpC, NULLC) + 1;
    }

    *tfpC = NULLC;

    start_service(service, (int)(tfpC - BigBuf));
}



/***
 *  start_service()
 *      Actually start the service
 *
 *  Args:
 *      service - service to start
 *      buflen - length of DosExec args in BigBuf,
 *               not counting terminating NULL.
 *               NULL terminator not needed on input when buflen = 0;
 *
 *  Returns:
 *      nothing - success
 *      exit 2 - command failed
 *
 *  Remarks:
 *      BigBuf has DosExec args on entry
 */
VOID NEAR start_service(TCHAR * service, int buflen)
{
    DWORD             dwErr;
    USHORT            i = 0;
    ULONG             specific_err ;
    LPTSTR            pBuffer;
    LPSERVICE_INFO_2  service_entry;
    LPSERVICE_INFO_2  statbuf;
    USHORT            modifier;
    ULONG             sleep_time;
    DWORD             old_checkpoint, new_checkpoint;
    DWORD             max_tries;
    BOOL              fCheckPointUpdated = TRUE ;
    BOOL              started_by_other = FALSE; /* service started by */
                                                /* another process */


    if (buflen == 0)
    {
        *BigBuf = NULLC;
        *(BigBuf + 1) = NULLC;
    }

    if (dwErr = start_service_with_args(service,
                                        BigBuf,
                                        (LPBYTE *) &statbuf))
    {
        if( autostarting && dwErr == NERR_ServiceInstalled )
        {
            /*
             * NetServiceControl() may return NERR_ServiceNotInstalled
             * even though NetServiceInstall() returned NERR_ServiceInstalled.
             * This is a small window between the time the workstation
             * sets up its wkstainitseg and the time it sets up its service
             * table.  If we get this situation, we just wait a couple of
             * seconds and try the NetServiceControl one more time.
             */
            if ((dwErr = NetServiceControl(NULL,
                                           service,
                                           SERVICE_CTRL_INTERROGATE,
                                           NULLC,
                                           (LPBYTE*)&pBuffer))
                && (dwErr !=  NERR_ServiceNotInstalled ))
            {
                ErrorExit(dwErr);
            }
            else if (dwErr == NERR_ServiceNotInstalled)
            {
                /*
                 * Wait for a while and try again.
                 */
                Sleep(4000L);
                NetApiBufferFree(pBuffer);
                if (dwErr = NetServiceControl(NULL,
                                              service,
                                              SERVICE_CTRL_INTERROGATE,
                                              NULLC,
                                              (LPBYTE*)&pBuffer))
                    ErrorExit(dwErr);
            }
            service_entry = (LPSERVICE_INFO_2) pBuffer;
            if ((service_entry->svci2_status & SERVICE_INSTALL_STATE)
                    == SERVICE_INSTALLED)
            {
                /*
                 * It finished installing, return.
                 */
                NetApiBufferFree(pBuffer);
                return;
            }
            /*
             * Fake the status and code fields in the statbuf and enter
             * the normal polling loop.
             */

            // Since NetService APIs don't return a buffer on error,
            // I have to allocate my own here.
            statbuf = (LPSERVICE_INFO_2) GetBuffer(sizeof(SERVICE_INFO_2));

            if (statbuf == NULL)
            {
               ErrorExit(ERROR_NOT_ENOUGH_MEMORY);
            }

            statbuf->svci2_status = service_entry->svci2_status;
            statbuf->svci2_code = service_entry->svci2_code;
            statbuf->svci2_specific_error = service_entry->svci2_specific_error;
            started_by_other = TRUE;
        }
        else
            ErrorExit(dwErr);

        NetApiBufferFree(pBuffer);
    }



    if ((statbuf->svci2_status & SERVICE_INSTALL_STATE) == SERVICE_UNINSTALLED)
    {
        USHORT err;

        modifier = (USHORT) statbuf->svci2_code;
        err = (USHORT)(statbuf->svci2_code >>= 16);
        IStrings[0] = MapServiceKeyToDisplay(service);
        ErrorPrint(APE_StartFailed, 1);
        if (modifier == ERROR_SERVICE_SPECIFIC_ERROR)
            Print_ServiceSpecificError(statbuf->svci2_specific_error) ;
        else
            Print_UIC_Error(err, modifier, statbuf->svci2_text);
        NetcmdExit(2);
    }
    else if (((statbuf->svci2_status & SERVICE_INSTALL_STATE) ==
            SERVICE_INSTALL_PENDING) ||
         ((statbuf->svci2_status & SERVICE_INSTALL_STATE) ==
            SERVICE_UNINSTALL_PENDING))
    {
        if (started_by_other)
            InfoPrintInsTxt(APE_StartPendingOther,
                            MapServiceKeyToDisplay(service));
        else
            InfoPrintInsTxt(APE_StartPending,
                            MapServiceKeyToDisplay(service));
    }

    //
    // Need to copy BigBuf into an allocated buffer so that we don't have
    // to keep track of which code path we took to know what we have to free
    //

    pBuffer = GetBuffer(BIG_BUFFER_SIZE);
    if (!pBuffer) {
        ErrorExit(ERROR_NOT_ENOUGH_MEMORY);
    }
    memcpy(pBuffer, BigBuf, BIG_BUFFER_SIZE);

    service_entry = (LPSERVICE_INFO_2) pBuffer;
    service_entry->svci2_status = statbuf->svci2_status;
    service_entry->svci2_code = statbuf->svci2_code;
    service_entry->svci2_specific_error = statbuf->svci2_specific_error;
    old_checkpoint = GET_CHECKPOINT(service_entry->svci2_code);
    max_tries = IP_MAXTRIES;

    while (((service_entry->svci2_status & SERVICE_INSTALL_STATE)
        != SERVICE_INSTALLED) && (i++ < max_tries))
    {
        PrintDot();

/***
 *  If there is a hint and our status is INSTALL_PENDING, determine both
 *  sleep_time and max_tries. If the hint time is greater the 2500 ms, the
 *  sleep time will be 2500 ms, and the maxtries will be re-computed to
 *  allow for the full requested duration.  The service gets (3 * hint time)
 *  total time from the last valid hint.
 */

        if (((service_entry->svci2_status & SERVICE_INSTALL_STATE)
             == SERVICE_INSTALL_PENDING) &&
            ( service_entry->svci2_code & SERVICE_IP_QUERY_HINT) &&
            fCheckPointUpdated)
        {
            sleep_time = GET_HINT(service_entry->svci2_code);
            if (sleep_time > IP_SLEEP_TIME)
            {
                max_tries = (3 * sleep_time) / IP_SLEEP_TIME;
                sleep_time = IP_SLEEP_TIME;
                i = 0;
            }
        }
        else
            sleep_time = IP_SLEEP_TIME;

        Sleep(sleep_time);
        NetApiBufferFree(pBuffer);
        if (dwErr = NetServiceControl(NULL,
                                      service,
                                      SERVICE_CTRL_INTERROGATE,
                                      NULLC,
                                      (LPBYTE *) &pBuffer))
        {
            ErrorExit(dwErr);
        }

        service_entry = (LPSERVICE_INFO_2) pBuffer;
        if ((service_entry->svci2_status & SERVICE_INSTALL_STATE)
            == SERVICE_UNINSTALLED)
            break;

        new_checkpoint = GET_CHECKPOINT(service_entry->svci2_code);
        if (new_checkpoint != old_checkpoint)
        {
            i = 0;
	    fCheckPointUpdated = TRUE ;
            old_checkpoint = new_checkpoint;
        }
        else
	    fCheckPointUpdated = FALSE ;

    } /* while */

    PrintNL();
    if ((service_entry->svci2_status & SERVICE_INSTALL_STATE)
        != SERVICE_INSTALLED)
    {
        USHORT err;

        modifier = (USHORT) service_entry->svci2_code;
        err = (USHORT)(service_entry->svci2_code >>= 16);
        specific_err = service_entry->svci2_specific_error ;
/***
 * if the service state is still INSTALL_PENDING,
 * this control call will fail.  The service MAY finish
 * installing itself at some later time.  The install failed
 * message would then be wrong.
 */

        //
        // this call will overwrite pBuffer. but we still
        // have reference via service_entry, so dont free it
        // yet. the memory will be freed during NetcmdExit(2),
        // which is typical of NET.EXE.
        //
        NetServiceControl(NULL,
                          service,
                          SERVICE_CTRL_UNINSTALL,
                          NULLC,
                          (LPBYTE *) &pBuffer);

        IStrings[0] = MapServiceKeyToDisplay(service);
        ErrorPrint(APE_StartFailed, 1);
        if (modifier == ERROR_SERVICE_SPECIFIC_ERROR)
            Print_ServiceSpecificError(specific_err) ;
        else
            Print_UIC_Error(err, modifier, service_entry->svci2_text);
        NetcmdExit(2);
    }
    else
    {
        InfoPrintInsTxt(APE_StartSuccess,
                        MapServiceKeyToDisplay(service));
    }

    NetApiBufferFree(pBuffer);
    NetApiBufferFree((TCHAR *) statbuf);
}




/***
 *  start_autostart()
 *      Assures that a service is started:  checks, and if not, starts it.
 *
 *  Args:
 *      service - service to start
 *
 *  Returns:
 *      1 - service already started
 *      2 - service started by start_autostart
 *      exit(2) -  command failed
 */
int PASCAL
start_autostart(
    LPTSTR service
    )
{
    DWORD             dwErr;
    LPSERVICE_INFO_2  service_entry;
    BOOL              install_pending = FALSE;
    static BOOL       wksta_started = FALSE ;

    /*
     * we special case the wksta since it is most commonly checked one
     */
    if (!_tcscmp(txt_SERVICE_REDIR, service))
    {
        LPWKSTA_INFO_0 info_entry_w;

        /*
         * once noted to be started, we dont recheck for the duration
         * of this NET.EXE invocation.
         */
        if (wksta_started)
            return START_ALREADY_STARTED;

        /*
         * this is an optimization for the wksta. the call to
         * wksta is much faster than hitting the service controller.
         * esp. since we will most likely will be talking to the wksta
         * again in a while.
         */
        dwErr = MNetWkstaGetInfo(0, (LPBYTE*) &info_entry_w);

        if (dwErr == NERR_Success)
        {
            wksta_started = TRUE ;  // no need to check again
            NetApiBufferFree((TCHAR FAR *) info_entry_w);
            return START_ALREADY_STARTED;
        }
    }

    if (dwErr = NetServiceControl(NULL,
                                  service,
                                  SERVICE_CTRL_INTERROGATE,
                                  NULLC,
                                  (LPBYTE*)&service_entry))
    {
        if (dwErr != NERR_ServiceNotInstalled)
            ErrorExit(dwErr);
    }
    else
    {
        switch (service_entry->svci2_status & SERVICE_INSTALL_STATE)
        {
        case SERVICE_INSTALLED:
            NetApiBufferFree((TCHAR FAR *) service_entry);
            return START_ALREADY_STARTED;

        case SERVICE_UNINSTALL_PENDING:
            ErrorExit(APE_ServiceStatePending);
            break;

        case SERVICE_INSTALL_PENDING:
            install_pending = TRUE;
            break;

        case SERVICE_UNINSTALLED:
            break;
        }
    }

    NetApiBufferFree((TCHAR FAR *) service_entry);

    /* We only get here if the service is not yet installed */
    if (!install_pending)
    {
        InfoPrintInsTxt(APE_StartNotStarted,
                        MapServiceKeyToDisplay(service));

        if (!YorN(APE_StartOkToStart, 1))
        NetcmdExit(2);
    }

    /*
     * Set global autostarting flag so that start_service will not fail
     * on NERR_ServiceInstalled.
     */
    autostarting = TRUE;
    start_service(service, 0);

    return START_STARTED;
}



/***
 *  CmpServiceInfo2(svc1,svc2)
 *
 *  Compares two SERVICE_INFO_2 structures and returns a relative
 *  lexical value, suitable for using in qsort.
 *
 */

int __cdecl CmpServiceInfo2(const VOID FAR * svc1, const VOID FAR * svc2)
{
    LPSERVICE_INFO_2 p1, p2 ;

    p1 = (LPSERVICE_INFO_2) svc1 ;
    p2 = (LPSERVICE_INFO_2) svc2 ;

    if ( !(p1->svci2_display_name) )
        return -1 ;
    if ( !(p2->svci2_display_name) )
        return 1 ;
    return _tcsicmp ( p1->svci2_display_name, p2->svci2_display_name ) ;
}


DWORD
start_service_with_args(
    LPTSTR pszService,
    LPTSTR pszCmdArgs,
    LPBYTE * ppbBuffer)
{
#define DEFAULT_NUMBER_OF_ARGUMENTS 25

    DWORD   MaxNumberofArguments = DEFAULT_NUMBER_OF_ARGUMENTS;
    DWORD   dwErr;  // return from Netapi
    DWORD   argc = 0;
    LPTSTR* ppszArgv = NULL;
    LPTSTR* ppszArgvTemp;
    BOOL    fDone = FALSE;

    //
    // First see if there are any parms in the buffer, if so,
    // allocate a buffer for the array of pointers, we will grow this
    // later if there are more than will fit
    //

    if (!pszCmdArgs || *pszCmdArgs == NULLC)
    {
        fDone = TRUE;
    }
    else
    {
        ppszArgv = malloc(DEFAULT_NUMBER_OF_ARGUMENTS * sizeof(LPTSTR));
        if (ppszArgv == NULL)
        {
            return(ERROR_NOT_ENOUGH_MEMORY);
        }
    }

    //
    // The buffer is a series of unicodez strings, terminated by and additional
    // NULL.  This peels them off one at a time, putting a pointer to the
    // string in ppszArgv[argc] until it hits the final NULL.
    //

    while (!fDone)
    {
        //
        // Save the pointer to the string
        //

        ppszArgv[argc++] = pszCmdArgs;

        //
        // Make sure we don't have too many arguments to fit into our array.
        // Grow the array if we do.
        //

        if (argc >= MaxNumberofArguments)
        {
            MaxNumberofArguments *= 2;
            if((ppszArgvTemp = realloc(ppszArgv,
                    MaxNumberofArguments * sizeof(LPTSTR))) == NULL)
            {
                free(ppszArgv);
                return(ERROR_NOT_ENOUGH_MEMORY);
            }

            ppszArgv = ppszArgvTemp;
        }

        //
        // Find the start of the next string
        //

        while (*pszCmdArgs++ != NULLC);

        //
        // If the next character is another null, we're thru
        //

        if (*pszCmdArgs == NULLC)
            fDone = TRUE;
    }

    //
    // Start the service
    //
    dwErr = NetServiceInstall(NULL,
                              pszService,
                              argc,
                              ppszArgv,
                              ppbBuffer);

    free(ppszArgv);

    return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\netcmd\svcutil.c ===
/*****************************************************************/
/**	     Microsoft LAN Manager	    **/
/**	   Copyright(c) Microsoft Corp., 1990	    **/
/*****************************************************************/

/***
 *  svcutil.c
 *	Functions to assist with service control
 *
 *  History:
 *	mm/dd/yy, who, comment
 *	08/20/89, paulc, created file
 *	02/20/91, danhi, change to use lm 16/32 mapping layer
 */

/* Include files */

#define INCL_NOCOMMON
#define INCL_DOSPROCESS
#define INCL_DOSQUEUES
#define INCL_DOSMISC
#define INCL_DOSFILEMGR
#include <os2.h>
#include <lmcons.h>
#include <lmerr.h>
#include <apperr.h>
#include <apperr2.h>
#include <lmsvc.h>
#include "netcmds.h"
#include "msystem.h"


/***
 *  Print_UIC_Error()
 *	Print message based on UIC code and modifier.
 *
 *  Args:
 *	code - UIC  (uninstall code)
 *	modifier - UIC modifier
 *
 *  Returns:
 *	VOID
 */

VOID
Print_UIC_Error(
    USHORT code,
    USHORT modifier,
    LPTSTR text
    )
{
    DWORD msg_len;
    TCHAR istrings_buffer_0[TEXT_BUF_SIZE];	// For istrings[0]
    TCHAR istrings_buffer_1[TEXT_BUF_SIZE];	// For istrings[1]

    switch(code)
    {
	case 0:
	    ErrorPrint(APE_NoErrorReported, 0);
	    break;

	case SERVICE_UIC_BADPARMVAL:
	case SERVICE_UIC_MISSPARM:
	case SERVICE_UIC_UNKPARM:
	case SERVICE_UIC_AMBIGPARM:
	case SERVICE_UIC_DUPPARM:
	case SERVICE_UIC_SUBSERV:
	case SERVICE_UIC_CONFLPARM:
	    IStrings[0] = text;
	    ErrorPrint(code, 1);
	    break;

	case SERVICE_UIC_RESOURCE:
	case SERVICE_UIC_CONFIG:
	    if (DosGetMessageW(NULL,
                               0,
                               istrings_buffer_0,
                               TEXT_BUF_SIZE,
                               modifier,
                               MESSAGE_FILENAME,
                               &msg_len))
            {
                IStrings[0] = TEXT("");
            }
	    else
	    {
                IStrings[0] = istrings_buffer_0;
                *(istrings_buffer_0 + msg_len) = NULLC;
	    }

	    ErrorPrint(code, 1);
	    break;

	case SERVICE_UIC_SYSTEM:
	    ErrorPrint(code, 0);
	    if (modifier != 0)
		ErrorPrint(modifier, 0);
	    break;

	case SERVICE_UIC_FILE:
	    /*	For FILE UIC codes, %1 is the filename (taken from
	     *	the text supplied by the service) and %2 is the modifier
	     *	text explaining the problem.  If the filename text
	     *	is a null-string use the text UNKNOWN from the message
	     *	file.
	     */

	    if (_tcslen(text) > 0)
		IStrings[0] = text;	// %1 text (filename)
	    else
	    {
		if (DosGetMessageW(NULL,
				   0,
				   istrings_buffer_0,
				   TEXT_BUF_SIZE,
				   APE2_GEN_UKNOWN_IN_PARENS,
				   MESSAGE_FILENAME,
				   &msg_len))
                {
		    IStrings[0] = TEXT("");
                }
		else
		{
                    IStrings[0] = istrings_buffer_0;
                    *(istrings_buffer_0 + msg_len) = NULLC;
		}
	    }

	    if (DosGetMessageW(NULL,
                               0,
                               istrings_buffer_1,
                               TEXT_BUF_SIZE,
                               modifier,
                               MESSAGE_FILENAME,
                               &msg_len))
            {
		IStrings[1] = TEXT("");		    // Unknown modifier
            }
	    else
	    {
                IStrings[1] = istrings_buffer_1;    // Modifier text is %2
                *(istrings_buffer_1 + msg_len) = NULLC;
	    }

	    ErrorPrint(code, 2);
	    break;

	case SERVICE_UIC_INTERNAL:
	case SERVICE_UIC_KILL:
	case SERVICE_UIC_EXEC:
	    ErrorPrint(code, 0);
	    break;
    }
    return;
}


/***
 *  Print_ServiceSpecificError()
 *	Print a service specific error.
 *
 *  Args:
 *	err - the service specific error
 *
 *  Returns:
 *	VOID
 */

VOID Print_ServiceSpecificError(ULONG err) 
{
    TCHAR buf[16];

    _ultow(err, buf, 10);
    IStrings[0] = buf ;
    ErrorPrint(APE_ServiceSpecificError, 1);
    
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\netcmd\stop.c ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/***
 *  stop.c
 *      Functions for stop network services.
 *
 *  History:
 *      mm/dd/yy, who, comment
 *      06/11/87, andyh, new code
 *      10/31/88, erichn, uses OS2.H instead of DOSCALLS
 *      01/04/89, erichn, filenames now MAXPATHLEN LONG
 *      05/02/89, erichn, NLS conversion
 *      05/09/89, erichn, local security mods
 *      05/14/89, chuckc, stopping service hints
 *      06/08/89, erichn, canonicalization sweep
 *      02/20/91, danhi, convert to 16/32 mapping layer
 *      03/22/91, robdu, lm21 bug fix 1031
 *                       (no DOS svc's stopped if nongbl TSR envt)
 *      08/22/92, chuckc, added code to show dependent services.
 */

/* Include files */

#define INCL_NOCOMMON
#define INCL_DOSPROCESS
#include <os2.h>
#include <lmcons.h>
#include <lmerr.h>
#include <lmapibuf.h>
#include <apperr.h>
#include <apperr2.h>
#include <lmsvc.h>
#include "netcmds.h"
#include "nettext.h"
#include "msystem.h"


/***
 *  stop_server()
 *      Stop the server and (if running) netlogon
 *
 *  Args:
 *
 *  Returns:
 *      nothing - success
 *      exit 2 - command failed
 */
VOID stop_server(VOID)
{
    session_del_all(0,0);  // dont print InfoSuccess, dont actually delete
			   // either, since server is going down anyway.
    stop_service(txt_SERVICE_FILE_SRV, TRUE);
}




/***
 *  stop_workstation()
 *      Stop the workstation
 *
 *  Args:
 *      none
 *
 *  Returns:
 *      nothing - success
 *      exit 2 - command failed
 */
VOID stop_workstation(VOID)
{
    KillConnections() ;
    stop_service(txt_SERVICE_REDIR, TRUE);
    return;
}



/***
 *  stop_service()
 *      Stops a service
 *
 *  Args:
 *      service - service to stop
 *      fStopDependent services - TRUE if dependent services should be stopped
 *                                Added to stop recursion
 *
 *  Returns:
 *      nothing - success
 *      exit 2 - command failed
 */
VOID stop_service(TCHAR * service, BOOL fStopDependent)
{
    DWORD             dwErr;
    LPSERVICE_INFO_2  service_entry;
    DWORD             i = 0;
    DWORD             max_tries;
    ULONG             sleep_time;
    DWORD             old_checkpoint, new_checkpoint;


    if (fStopDependent)
    {
        DisplayAndStopDependentServices(service);
    }

    if (dwErr = NetServiceControl(NULL,
                                  service,
                                  SERVICE_CTRL_UNINSTALL,
                                  0,
				  (LPBYTE *) &service_entry))
    {
        ErrorExit(dwErr);
    }

    if ((service_entry->svci2_status & SERVICE_INSTALL_STATE)
        == SERVICE_UNINSTALL_PENDING)
    {
        InfoPrintInsTxt(APE_StopPending, MapServiceKeyToDisplay(service));
    }

    old_checkpoint = new_checkpoint = 0;
    max_tries = MAXTRIES ;
    sleep_time = SLEEP_TIME ;
    while (((service_entry->svci2_status & SERVICE_INSTALL_STATE)
        != SERVICE_UNINSTALLED) && (i++ < max_tries))
    {

        PrintDot();
/***
 *  If there is a hint and our status is INSTALL_PENDING, determine both
 *  sleep_time and max_tries. If the hint time is greater the 2500 ms, the
 *  sleep time will be 2500 ms, and the maxtries will be re-computed to
 *  allow for the full requested duration.  The service gets (3 * hint time)
 *  total time from the last valid hint.
 */

        new_checkpoint = GET_CHECKPOINT(service_entry->svci2_code) ;

        if (((service_entry->svci2_status & SERVICE_INSTALL_STATE)
             == SERVICE_UNINSTALL_PENDING) &&
            ( service_entry->svci2_code & SERVICE_IP_QUERY_HINT) &&
            (new_checkpoint != old_checkpoint))
        {
            sleep_time = GET_HINT(service_entry->svci2_code);
            if (sleep_time > IP_SLEEP_TIME)
            {
                max_tries = (3 * sleep_time) / IP_SLEEP_TIME;
                sleep_time = IP_SLEEP_TIME;
                i = 0;
            }
        }
        else
            sleep_time = IP_SLEEP_TIME;

        old_checkpoint = new_checkpoint ;
        Sleep(sleep_time);
        NetApiBufferFree((TCHAR FAR *) service_entry);

        if (dwErr = NetServiceControl(NULL,
                                      service,
                                      SERVICE_CTRL_INTERROGATE,
                                      0,
                                      (LPBYTE*)&service_entry))
        {
            if (dwErr == NERR_ServiceNotInstalled) {
                break;
            }
            else {
                ErrorExit(dwErr);
            }
        }

        if ((service_entry->svci2_status & SERVICE_INSTALL_STATE)
            == SERVICE_INSTALLED)
            break;

    } /* while */

    /*
     *  WARNING:  The following code relies on the fact that the only
     *  way to get out of the above loop with a non-zero value in
     *  'dwErr' is if the value is something "nice".  Currently, this
     *  includes only NERR_ServiceNotInstalled.  It also assumes that
     *  a value of 0 in err means that the service_entry is valid
     *  and can be checked.
     */

    PrintNL();

    if (dwErr == 0) {
        if ((service_entry->svci2_status & SERVICE_INSTALL_STATE)
            != SERVICE_UNINSTALLED)
        {
            IStrings[0] = MapServiceKeyToDisplay(service);
            NetApiBufferFree((TCHAR FAR *) service_entry);
            InfoPrintInsTxt(APE_StopFailed, MapServiceKeyToDisplay(service));
        }
        else
        {
            if ( (service_entry->svci2_code) != 0 )
            {
                USHORT  modifier;
                USHORT  code;

                modifier = (USHORT) service_entry->svci2_code;
                code = (USHORT)(service_entry->svci2_code >>= 16);
                if ((modifier == ERROR_SERVICE_SPECIFIC_ERROR) &&
                    (code != 0))
                {
                    Print_ServiceSpecificError(
                        (ULONG)service_entry->svci2_specific_error) ;
                }
                else
                    Print_UIC_Error(code, modifier, service_entry->svci2_text);
            }

            NetApiBufferFree((TCHAR FAR *) service_entry);
            InfoPrintInsTxt(APE_StopSuccess, MapServiceKeyToDisplay(service));
        }
    }
    else {
        InfoPrintInsTxt(APE_StopSuccess, MapServiceKeyToDisplay(service));
    }
}

/*
 * generic stop service entry point. based on the service name, it will
 * call the correct worker function. it tries to map a display name to a 
 * key name, and then looks for that keyname in a list of 'known' services
 * that we may special case. note that if a display name cannot be mapped,
 * we use it as a key name. this ensures old batch files are not broken.
 */
VOID stop_generic(TCHAR *service)
{
    TCHAR *keyname ;
    UINT  type ;

    keyname = MapServiceDisplayToKey(service) ;

    type = FindKnownService(keyname) ;

    switch (type)
    {
	case  KNOWN_SVC_MESSENGER :
	    stop_service(txt_SERVICE_MSG_SRV, TRUE) ;
	    break ;
	case  KNOWN_SVC_WKSTA :
	    stop_workstation() ;
	    break ;
	case  KNOWN_SVC_SERVER :
	    stop_server() ;
	    break ;
	case  KNOWN_SVC_NOTFOUND :
        default:
	    stop_service(keyname, TRUE);
	    break ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\netcmd\switches.c ===
/********************************************************************/
/**			Microsoft LAN Manager			   **/
/**		  Copyright(c) Microsoft Corp., 1987-1990	   **/
/********************************************************************/

/*
 *	       Switches.c - switch handling routines
 *
 *	??/??/??, ??????, initial code
 *	10/31/88, erichn, uses OS2.H instead of DOSCALLS
 *	12/04/88, erichn, DOS LM integration
 *	06/08/89, erichn, canonicalization sweep, stronger typing
 *	02/20/91, danhi, change to use lm 16/32 mapping layer
 */


#define INCL_NOCOMMON
#include <os2.h>
#include <apperr.h>
#include <lmerr.h>
#include <malloc.h>
#include "netcmds.h"
#include "nettext.h"

/* External variables */

int DOSNEAR FASTCALL firstswitch(TCHAR *known)
{
    if (SwitchList[0] == NULL)
	return 0;
    if (sw_compare(known, SwitchList[0]) >= 0)
	return 1;
    else
	return 0;
}


/*
 * Is the cmd line a valid form of NET ADMIN /C
 */
int DOSNEAR FASTCALL IsAdminCommand(VOID)
{
    if (!SwitchList[0] || !ArgList[1])
	return 0;
    _tcsupr(SwitchList[0]);
    return (IsComputerName(ArgList[1]) &&
	    (sw_compare(swtxt_SW_ADMIN_COMMAND, SwitchList[0]) >= 0));
}

/***	noswitch, oneswitch, twoswitch
 *
 *  noswitch()	Returns TRUE is no switches on the command line
 *  oneswitch() Returns TRUE is there is exactly one switch
 *  twoswitch() Returns TRUE is there are exactly two switches
 *
 */

int DOSNEAR FASTCALL noswitch(VOID)
{
    return (SwitchList[0] == NULL);
}

int DOSNEAR FASTCALL oneswitch(VOID)
{
    return ((SwitchList[0] != NULL) && (SwitchList[1] == NULL));
}

int DOSNEAR FASTCALL twoswitch(VOID)
{
    return ((SwitchList[0] != NULL) && (SwitchList[1] != NULL)
	    && (SwitchList[2] == NULL));
}

/***	noswitch_optional, oneswitch_optional
 *
 *  as above, except that the switch provided as argument is considered
 *  an optional switch that will be allowed. So if you say 
 *  oneswitch_optional("/FOO"), then one switch (any switch) is OK,
 *  and so is two switches if one of them is "/FOO".
 */
int DOSNEAR FASTCALL noswitch_optional(TCHAR *optional_switch ) 
{
    return ( noswitch() ||
             ( oneswitch() && 
	       (sw_compare(optional_switch, SwitchList[0]) >= 0) )
           ) ;
}

int DOSNEAR FASTCALL oneswitch_optional(TCHAR *optional_switch ) 
{
    return ( oneswitch() ||
             ( twoswitch() && 
	       ( (sw_compare(optional_switch, SwitchList[0]) >= 0) ||
	         (sw_compare(optional_switch, SwitchList[1]) >= 0) ) )
           ) ;
}


/***
 * o n l y s w i t c h
 *
 *  Returns TRUE if the first switch matches the named switch, and it
 *  is the only switch.
 */
int DOSNEAR FASTCALL onlyswitch(TCHAR *known)
{
    return (oneswitch() && firstswitch(known));
}


/***	ValidateSwitches
 *
 *  Given a list of valid switches, check each entry in the switch
 *  list.
 *
 *  This function not only checks for invalid switches, but also
 *  attempts to discern ambiguous usages.  A usage is ambiguous if
 *  it does not match any valid swithc exactly, and it a partial
 *  match of more than one switch.  See sw_compare().  This
 *  algorithm can be fooled by nasty lists of valid switches, such
 *  as one which lists the same switch twice.
 *
 *  The function has been modified to canonicalize the SwitchList.
 *  It replaces an '=' in /x=value with a ':'; it translates
 *  switches if needed, (see switches.h); and it expands unambiguous
 *  partial matches to the full switch name.
 *
 *  Returns:
 *	 1:  All switches OK
 *	 *:  If any error, prints a message and exits.
 *
 */

int DOSNEAR FASTCALL ValidateSwitches(USHORT cmd, SWITCHTAB valid_list[])
{
    USHORT	 match;
    int 	 comp_result;
    USHORT	 candidate; /* most recent NEAR match */
    USHORT	 i,j;
    TCHAR *	 good_one; /* which element (cmd_line or trans) of the valid_list */
    int 	 needed;
    TCHAR   FAR * sepptr;

    for (i = 0; SwitchList[i]; i++)
    {
	sepptr = _tcschr(SwitchList[i], ':');
	if (sepptr)
	    *sepptr = NULLC;
	_tcsupr(SwitchList[i]);
	if (sepptr)
	    *sepptr = ':';

	candidate = 0;
	match = 0;

	for (j = 0; valid_list[j].cmd_line; j++)
	{
	    comp_result = sw_compare(valid_list[j].cmd_line, SwitchList[i]);

	    if (comp_result == 0)
	    {
		candidate = j;
		match = 1;
		break;
	    }
	    else if (comp_result == 1)
	    {
		match++;
		candidate = j;
	    }
	}

	if (match == 0)
	{
	    if (! _tcscmp(swtxt_SW_HELP, SwitchList[i]))
		help_help(cmd, ALL);

	    if (! _tcscmp(swtxt_SW_SYNTAX, SwitchList[i]))
		help_help(cmd, USAGE_ONLY);

	    IStrings[0] = SwitchList[i];
	    ErrorPrint(APE_SwUnkSw, 1);
	    help_help(cmd, USAGE_ONLY);
	}
	else if (match > 1)
	{
	    IStrings[0] = SwitchList[i];
	    ErrorPrint(APE_SwAmbSw, 1);
	    help_help(cmd, USAGE_ONLY);
	}

	switch(valid_list[candidate].arg_ok)
	{
	case NO_ARG:
	    if (sepptr)
	    {
		ErrorPrint(APE_InvalidSwitchArg, 0);
		help_help(cmd, USAGE_ONLY);
	    }
	    break;

	case ARG_OPT:
	    break;

	case ARG_REQ:
	    if (!sepptr)
	    {
		ErrorPrint(APE_InvalidSwitchArg, 0);
		help_help(cmd, USAGE_ONLY);
	    }
	    break;
	}

	/* (expansion || translation) required ? */
	if (comp_result || valid_list[candidate].translation)
	{
	     if (valid_list[candidate].translation)
		good_one = valid_list[candidate].translation;
	    else
		good_one = valid_list[candidate].cmd_line;

	    needed = _tcslen(good_one);

	    if (sepptr)
		needed += _tcslen(sepptr);

	    if ((SwitchList[i] = calloc(needed+1, sizeof(TCHAR))) == NULL)
		ErrorExit(NERR_InternalError);

	    _tcscpy(SwitchList[i], good_one);

	    if (sepptr)
		_tcscat(SwitchList[i], sepptr);
	}
    }

    return 1;
}


/***	sw_compare
 *
 *  Compare a known switch name to a switch string passed from
 *  the command line.
 *
 *  The command-line switch may still retain the "excess baggage"
 *  of a value (as in /B:1024).  The comparison is not sensitive
 *  to case, and should be DBCS compatible as it uses the runtime
 *  library to do all searches and compares.
 *
 *  Returns:
 *	-1:  No match
 *	 0:  Exact match to full length of known switch
 *	 1:  Partial match;  matches initial substring of
 *	    known switch
 *
 *  The difference between return 0/1 is used by ValidateSwitches()
 *  to detect the presence of a possibly ambiguous usage.  Once
 *  that function has checked all switches, further compares can
 *  treat results 0 & 1 from this function as "match".
 */

int DOSNEAR FASTCALL sw_compare(TCHAR  *known, TCHAR  *cand)
{
    register unsigned int complen;

    /* Try to find end of switch name by looking */
    /* the for separator between name and value, */
    /* otherwise use total length. */

    complen = _tcscspn(cand, TEXT(":"));

    if (complen < 2)	    /* Special check for empty switch SLASH */
	return -1;

    if (complen > _tcslen(known))
	return -1;

    if (_tcsncmp(known,cand,complen) != 0)
	return -1;

    if (complen == _tcslen(known))
	return 0;

    return 1;
}





/*
 * Used only by interpre.c
 */

int DOSNEAR FASTCALL CheckSwitch(TCHAR *x)
{
    register TCHAR **p;

    for (p=SwitchList; *p; p++)
	if (sw_compare(x,*p) >= 0)
	{
	    return 1;
	}

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\netcmd\swtchtbl.h ===
extern SWITCHTAB no_switches[];
extern SWITCHTAB add_only_switches[];
extern SWITCHTAB del_only_switches[];
extern SWITCHTAB domain_only_switches[];
extern SWITCHTAB add_del_switches[];
extern SWITCHTAB accounts_switches[];
#ifdef NTENV
extern SWITCHTAB computer_switches[];
#endif /* NTENV */
extern SWITCHTAB config_wksta_switches[];
#ifndef NTENV
#endif /* !NTENV */
#ifdef NTENV
extern SWITCHTAB config_server_switches[];
#else /* !NTENV */
extern SWITCHTAB config_server_switches[];
#endif /* !NTENV */
extern SWITCHTAB file_switches[];
extern SWITCHTAB help_switches[];
extern SWITCHTAB print_switches[];
#ifndef NTENV
#endif /* !NTENV */
extern SWITCHTAB send_switches[];
extern SWITCHTAB share_switches[];
#ifndef NTENV
#endif /* !NTENV */
extern SWITCHTAB start_alerter_switches[];
extern SWITCHTAB start_netlogon_switches[];
extern SWITCHTAB start_netlogon_ignore_switches[];
extern SWITCHTAB start_repl_switches[];
extern SWITCHTAB start_rdr_switches[];
extern SWITCHTAB start_rdr_ignore_switches[];
extern SWITCHTAB start_msg_switches[];
#ifdef	DOS3
#endif
#ifndef NTENV
extern SWITCHTAB start_srv_switches[];
#else /* NTENV */
extern SWITCHTAB start_srv_switches[];
#endif /* NTENV */
extern SWITCHTAB start_ups_switches[];
extern SWITCHTAB stats_switches[];
extern SWITCHTAB use_switches[];
#ifdef NTENV
#else
#endif /* NTENV */
extern SWITCHTAB user_switches[];
extern SWITCHTAB group_switches[];
extern SWITCHTAB ntalias_switches[];
extern SWITCHTAB time_switches[];
extern SWITCHTAB who_switches[];
extern SWITCHTAB view_switches[];
#ifndef NTENV
extern SWITCHTAB access_switches[];
extern SWITCHTAB access_audit_switches[];
extern SWITCHTAB admin_switches[];
extern SWITCHTAB admin_fs_switches[];
extern SWITCHTAB audit_switches[];
extern SWITCHTAB comm_switches[];
extern SWITCHTAB console_fs_switches[];
extern SWITCHTAB device_switches[];
extern SWITCHTAB error_switches[];
extern SWITCHTAB log_switches[];
extern SWITCHTAB start_ripl_switches[];
extern SWITCHTAB start_netrun_switches[];
extern SWITCHTAB alias_switches[];
extern SWITCHTAB user_fs_switches[];
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\netcmd\swtchtxt.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/


#define SW_YES          TEXT("/YES")
#define SW_NO           TEXT("/NO")
#define SW_HELP         TEXT("/HELP")
#define SW_SYNTAX       TEXT("/?")

#define SW_ADD          TEXT("/ADD")
#define SW_DELETE       TEXT("/DELETE")
#define SW_REMARK       TEXT("/REMARK")
#define SW_COMMENT      TEXT("/COMMENT")
#define SW_CACHE        TEXT("/CACHE")

#define SW_COUNT        TEXT("/COUNT")
#define SW_REVERSE      TEXT("/REVERSE")
#define SW_SERVICE      TEXT("/SERVICE")

#define SW_OPTIONS      TEXT("/OPTIONS")
#define SW_PRIORITY     TEXT("/PRIORITY")
#define SW_ROUTE        TEXT("/ROUTE")
#define SW_PURGE        TEXT("/PURGE")
#define SW_DOMAIN       TEXT("/DOMAIN")
#define SW_PERSISTENT   TEXT("/PERSISTENT")
#define SW_NETWARE      TEXT("/FPNW")
#define SW_RANDOM       TEXT("/RANDOM")
#define SW_RTSDOMAIN    TEXT("/RTSDOMAIN")
#define SW_SETSNTP      TEXT("/SETSNTP")
#define SW_QUERYSNTP    TEXT("/QUERYSNTP")


#define SW_ALERTER_SIZALERTBUF  TEXT("/SIZALERTBUF")
#define SW_NETLOGON_CENTRALIZED TEXT("/CENTRALIZED")
#define SW_NETLOGON_PULSE   TEXT("/PULSE")
#define SW_NETLOGON_RANDOMIZE   TEXT("/RANDOMIZE")
#define SW_NETLOGON_SYNCHRONIZE TEXT("/UPDATE")
#define SW_NETLOGON_SCRIPTS TEXT("/SCRIPTS")

#define SW_COMM_PURGE       TEXT("/PURGE")
#define SW_COMM_OPTIONS     TEXT("/OPTIONS")
#define SW_COMM_PRIORITY    TEXT("/PRIORITY")
#define SW_COMM_ROUTE       TEXT("/ROUTE")

#define SW_WKSTA_CHARCOUNT  TEXT("/CHARCOUNT")
#define SW_WKSTA_CHARTIME   TEXT("/CHARTIME")
#define SW_WKSTA_CHARWAIT   TEXT("/CHARWAIT")
#define SW_WKSTA_COMPUTERNAME   TEXT("/COMPUTERNAME")
#define SW_WKSTA_KEEPCONN   TEXT("/KEEPCONN")
#define SW_WKSTA_KEEPSEARCH TEXT("/KEEPSEARCH")
#define SW_WKSTA_LOGONSERVER    TEXT("/LOGONSERVER")
#define SW_WKSTA_MAILSLOTS  TEXT("/MAILSLOTS")
#define SW_WKSTA_MAXERRORLOG    TEXT("/MAXERRORLOG")
#define SW_WKSTA_MAXTHREADS TEXT("/MAXTHREADS")
#define SW_WKSTA_MAXWRKCACHE    TEXT("/MAXWRKCACHE")
#define SW_WKSTA_NUMALERTS  TEXT("/NUMALERTS")
#define SW_WKSTA_NUMCHARBUF TEXT("/NUMCHARBUF")
#define SW_WKSTA_NUMDGRAMBUF    TEXT("/NUMDGRAMBUF")
#define SW_WKSTA_NUMSERVICES    TEXT("/NUMSERVICES")
#define SW_WKSTA_NUMWORKBUF TEXT("/NUMWORKBUF")
#define SW_WKSTA_OTHDOMAINS TEXT("/OTHDOMAINS")
#define SW_WKSTA_PRIMARYDOMAIN  TEXT("/DOMAIN")
#define SW_WKSTA_PRINTBUFTIME   TEXT("/PRINTBUFTIME")
#define SW_WKSTA_SESSTIMEOUT    TEXT("/SESSTIMEOUT")
#define SW_WKSTA_SIZCHARBUF TEXT("/SIZCHARBUF")
#define SW_WKSTA_SIZERROR   TEXT("/SIZERROR")
#define SW_WKSTA_SIZWORKBUF TEXT("/SIZWORKBUF")
#define SW_WKSTA_WRKHEURISTICS  TEXT("/WRKHEURISTICS")
#define SW_WKSTA_WRKNETS    TEXT("/WRKNETS")
#define SW_WKSTA_WRKSERVICES    TEXT("/WRKSERVICES")

#define SW_INTERNAL_IGNSVC  TEXT("/IGNSVC")

#define SW_PRINT_AFTER      TEXT("/AFTER")
#define SW_PRINT_DELETE     TEXT("/DELETE")
#define SW_PRINT_FIRST      TEXT("/FIRST")
#define SW_PRINT_HOLD       TEXT("/HOLD")
#define SW_PRINT_LAST       TEXT("/LAST")
#define SW_PRINT_OPTIONS    TEXT("/OPTIONS")
#define SW_PRINT_PARMS      TEXT("/PARMS")
#define SW_PRINT_PRIORITY   TEXT("/PRIORITY")
#define SW_PRINT_PROCESSOR  TEXT("/PROCESSOR")
#define SW_PRINT_PURGE      TEXT("/PURGE")
#define SW_PRINT_RELEASE    TEXT("/RELEASE")
#define SW_PRINT_REMARK     TEXT("/REMARK")
#define SW_PRINT_ROUTE      TEXT("/ROUTE")
#define SW_PRINT_SEPARATOR  TEXT("/SEPARATOR")
#define SW_PRINT_UNTIL      TEXT("/UNTIL")
#define SW_PRINT_DRIVER     TEXT("/DRIVER")

#define SW_SHARE_COMM       TEXT("/COMM")
#define SW_SHARE_DELETE     TEXT("/DELETE")
#define SW_SHARE_PERMISSIONS    TEXT("/PERMISSIONS")
#define SW_SHARE_PRINT      TEXT("/PRINT")
#define SW_SHARE_REMARK     TEXT("/REMARK")
#define SW_SHARE_UNLIMITED  TEXT("/UNLIMITED")
#define SW_SHARE_USERS      TEXT("/USERS")

#define SW_USE_COMM     TEXT("/COMM")
#define SW_USE_USER     TEXT("/USER")
#define SW_USE_SMARTCARD    TEXT("/SMARTCARD")
#define SW_USE_SAVECRED     TEXT("/SAVECRED")
#define SW_USE_HOME     TEXT("/HOME")
#define SW_USE_DELETE       TEXT("/DELETE")
#define SW_USE_PERSISTENT   TEXT("/PERSISTENT")

#define SW_NETRUN_MAXRUNS   TEXT("/MAXRUNS")
#define SW_NETRUN_RUNPATH   TEXT("/RUNPATH")

#define SW_USER_ACTIVE      TEXT("/ACTIVE")
#define SW_USER_COUNTRYCODE TEXT("/COUNTRYCODE")
#define SW_USER_EXPIRES     TEXT("/EXPIRES")
#define SW_USER_ENABLESCRIPT    TEXT("/ENABLESCRIPT")
#define SW_USER_FULLNAME    TEXT("/FULLNAME")
#define SW_USER_HOMEDIR     TEXT("/HOMEDIR")
#define SW_USER_LOGONSERVER TEXT("/LOGONSERVER")
#define SW_USER_MAXSTORAGE  TEXT("/MAXSTORAGE")
#define SW_USER_PARMS       TEXT("/PARMS")
#define SW_USER_PASSWORDREQ TEXT("/PASSWORDREQ")
#define SW_USER_PASSWORDCHG TEXT("/PASSWORDCHG")
#define SW_USER_SCRIPTPATH  TEXT("/SCRIPTPATH")
#define SW_USER_TIMES       TEXT("/TIMES")
#define SW_USER_USERCOMMENT TEXT("/USERCOMMENT")
#define SW_USER_WORKSTATIONS    TEXT("/WORKSTATIONS")
#define SW_USER_PROFILEPATH TEXT("/PROFILEPATH")

#if defined(NTENV)
#define SW_SRV_SRVCOMMENT   TEXT("/SRVCOMMENT")
#define SW_SRV_AUTODISCONNECT   TEXT("/AUTODISCONNECT")
#define SW_SRV_MAXUSERS     TEXT("/USERS")
#define SW_SRV_SRVANNOUNCE  TEXT("/ANNOUNCE")
#define SW_SRV_SRVANNDELTA  TEXT("/ANNDELTA")
#define SW_SRV_MAXSESSOPENS TEXT("/SESSOPENS")
#define SW_SRV_NUMREQBUF    TEXT("/MAXWORKITEMS")
#define SW_SRV_SIZREQBUF    TEXT("/SIZREQBUF")
#define SW_SRV_NUMBIGBUF    TEXT("/RAWWORKITEMS")
#define SW_SRV_SRVHIDDEN    TEXT("/HIDDEN")
#define SW_SRV_DEBUG        TEXT("/DEBUG")

#else /* !NTENV */

#define SW_SRV_SRVCOMMENT   TEXT("/SRVCOMMENT")
#define SW_SRV_ACCESSALERT  TEXT("/ACCESSALERT")
#define SW_SRV_ALERTNAMES   TEXT("/ALERTNAMES")
#define SW_SRV_ALERTSCHED   TEXT("/ALERTSCHED")
#define SW_SRV_AUTODISCONNECT   TEXT("/AUTODISCONNECT")
#define SW_SRV_DISKALERT    TEXT("/DISKALERT")
#define SW_SRV_ERRORALERT   TEXT("/ERRORALERT")
#define SW_SRV_LOGONALERT   TEXT("/LOGONALERT")
#define SW_SRV_MAXAUDITLOG  TEXT("/MAXAUDITLOG")
#define SW_SRV_NETIOALERT   TEXT("/NETIOALERT")
#define SW_SRV_SRVHIDDEN    TEXT("/SRVHIDDEN")

#define SW_SRV_MAXUSERS     TEXT("/MAXUSERS")
#define SW_SRV_SECURITY     TEXT("/SECURITY")
#define SW_SRV_AUDITING     TEXT("/AUDITING")
#define SW_SRV_NOAUDITING   TEXT("/NOAUDITING")
#define SW_SRV_NUMADMIN     TEXT("/NUMADMIN")
#define SW_SRV_SRVNETS      TEXT("/SRVNETS")
#define SW_SRV_SRVSERVICES  TEXT("/SRVSERVICES")
#define SW_SRV_SRVANNOUNCE  TEXT("/SRVANNOUNCE")
#define SW_SRV_SRVANNDELTA  TEXT("/SRVANNDELTA")
#define SW_SRV_GUESTACCT    TEXT("/GUESTACCT")
#define SW_SRV_USERPATH     TEXT("/USERPATH")
#define SW_SRV_MAXSHARES    TEXT("/MAXSHARES")
#define SW_SRV_MAXSESSOPENS TEXT("/MAXSESSOPENS")
#define SW_SRV_MAXSESSREQS  TEXT("/MAXSESSREQS")
#define SW_SRV_NUMREQBUF    TEXT("/NUMREQBUF")
#define SW_SRV_SIZREQBUF    TEXT("/SIZREQBUF")
#define SW_SRV_NUMBIGBUF    TEXT("/NUMBIGBUF")
#define SW_SRV_SRVHEURISTICS    TEXT("/SRVHEURISTICS")
#define SW_SRV_IGNSVC       TEXT("/IGNSVC")
#define SW_SRV_AUTOPROFILE  TEXT("/AUTOPROFILE")
#define SW_SRV_AUTOPATH         TEXT("/AUTOPATH")

#endif

#define SW_ACCESS_GRANT     TEXT("/GRANT")
#define SW_ACCESS_CHANGE    TEXT("/CHANGE")
#define SW_ACCESS_REVOKE    TEXT("/REVOKE")
#define SW_ACCESS_TRAIL     TEXT("/TRAIL")
#define SW_ACCESS_TREE      TEXT("/TREE")
#define SW_ACCESS_SUCCESS   TEXT("/SUCCESS")
#define SW_ACCESS_FAILURE   TEXT("/FAILURE")

#define SW_ACCESS_OPEN      TEXT("OPEN")
#define SW_ACCESS_WRITE     TEXT("WRITE")
#define SW_ACCESS_DELETE    TEXT("DELETE")
#define SW_ACCESS_ACL       TEXT("ACL")
#define SW_ACCESS_NONE      TEXT("NONE")
#define SW_ACCESS_ALL       TEXT("ALL")

#define SW_DEV_RESTART      TEXT("/RESTART")

#define SW_STATS_CLEAR      TEXT("/CLEAR")

#define SW_ADMIN_COMMAND    TEXT("/COMMAND")

#define SW_FS_GREY      TEXT("/MONOCHROME")

#define SW_MESSAGE_BROADCAST    TEXT("/BROADCAST")

#define SW_ACCOUNTS_FORCELOGOFF TEXT("/FORCELOGOFF")
#define SW_ACCOUNTS_UNIQUEPW    TEXT("/UNIQUEPW")
#define SW_ACCOUNTS_MINPWLEN    TEXT("/MINPWLEN")
#define SW_ACCOUNTS_MINPWAGE    TEXT("/MINPWAGE")
#define SW_ACCOUNTS_MAXPWAGE    TEXT("/MAXPWAGE")
#define SW_ACCOUNTS_ROLE    TEXT("/ROLE")
#define SW_ACCOUNTS_PRIMARY TEXT("/PRIMARY")
#define SW_ACCOUNTS_LOCKOUT TEXT("/LOCKOUT")
#define SW_ACCOUNTS_SYNCH   TEXT("/SYNCHRONIZE")
#define SW_ACCOUNTS_LOCKOUT_THRESHOLD TEXT("/LOCKOUTTHRESHOLD")
#define SW_ACCOUNTS_LOCKOUT_DURATION  TEXT("/LOCKOUTDURATION")
#define SW_ACCOUNTS_LOCKOUT_WINDOW    TEXT("/LOCKOUTWINDOW")


#define SW_REPL_REPL         TEXT("/REPLICATE")
#define SW_REPL_EXPPATH      TEXT("/EXPORTPATH")
#define SW_REPL_IMPPATH      TEXT("/IMPORTPATH")
#define SW_REPL_EXPLIST      TEXT("/EXPORTLIST")
#define SW_REPL_IMPLIST      TEXT("/IMPORTLIST")
#define SW_REPL_TRYUSER      TEXT("/TRYUSER")
#define SW_REPL_LOGON        TEXT("/LOGON")
#define SW_REPL_PASSWD       TEXT("/PASSWORD")
#define SW_REPL_SYNCH        TEXT("/INTERVAL")
#define SW_REPL_PULSE        TEXT("/PULSE")
#define SW_REPL_GUARD        TEXT("/GUARDTIME")
#define SW_REPL_RANDOM       TEXT("/RANDOM")

#define SW_RIPL_RPL1            TEXT("/RPL1")
#define SW_RIPL_RPL2            TEXT("/RPL2")
#define SW_RIPL_RPL3            TEXT("/RPL3")
#define SW_RIPL_RPL4            TEXT("/RPL4")
#define SW_RIPL_RPL5            TEXT("/RPL5")
#define SW_RIPL_RPL6            TEXT("/RPL6")
#define SW_RIPL_RPL7            TEXT("/RPL7")
#define SW_RIPL_RPL8            TEXT("/RPL8")
#define SW_RIPL_RPL9            TEXT("/RPL9")
#define SW_RIPL_RPL10           TEXT("/RPL10")
#define SW_RIPL_RPL11           TEXT("/RPL11")
#define SW_RIPL_RPL12           TEXT("/RPL12")
#define SW_RIPL_RPLDIR          TEXT("/RPLDIR")
#define SW_RIPL_MAXTHREADS      TEXT("/MAXTHREADS")
#define SW_RIPL_AUDITINGFILE        TEXT("/AUDITINGFILE")
#define SW_RIPL_RPLCHECKSUM     TEXT("/RPLCHECKSUM")
#define SW_RIPL_FORCEDEFAULTBOOT    TEXT("/FORCEDEFAULTBOOT")
#define SW_RIPL_RPLLOGONKBD     TEXT("/RPLLOGONKBD")
#define SW_RIPL_RPLFILES        TEXT("/RPLFILES")
#define SW_RIPL_BINFILES        TEXT("/BINFILES")
#define SW_RIPL_TMPFILES        TEXT("/TMPFILES")
#define SW_RIPL_XNSSAP          TEXT("/XNSSAP")

#define SW_COPY_FROM        TEXT("/FROM")
#define SW_COPY_TO      TEXT("/TO")
#define SW_COPY_PASSWORD    TEXT("/PASSWORD")

#define SW_TIME_DOMAIN       TEXT("/DOMAIN")
#define SW_TIME_SET      TEXT("/SET")

#define SW_ALIAS_MODE       TEXT("/WHEN")
#define SW_ALIAS_PRIORITY   TEXT("/PRIORITY")

#define SW_UPS_BATTERYTIME  TEXT("/BATTERYTIME")
#define SW_UPS_CMDFILE      TEXT("/CMDFILE")
#define SW_UPS_DEVICENAME   TEXT("/DEVICENAME")
#define SW_UPS_MESSDELAY    TEXT("/MESSDELAY")
#define SW_UPS_MESSTIME     TEXT("/MESSTIME")
#define SW_UPS_RECHARGE     TEXT("/RECHARGE")
#define SW_UPS_SIGNALS      TEXT("/SIGNALS")
#define SW_UPS_VOLTLEVELS   TEXT("/VOLTLEVELS")

#define SW_COMPUTER_JOIN    TEXT("/JOIN")
#define SW_COMPUTER_LEAVE   TEXT("/LEAVE")
#define SW_NETWORK          TEXT("/NETWORK")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\netcmd\time.c ===
/********************************************************************/
/**                        Microsoft LAN Manager                   **/
/**                  Copyright(c) Microsoft Corp., 1987-1990       **/
/********************************************************************/

/***
 *  time.c
 *        NET TIME command
 *
 *  History:
 *        mm/dd/yy, who, comment
 *        03/25/89, kevinsch, new code
 *        05/11/90, erichn, moved from nettime.c, removed DosGetInfoSeg
 *        06/08/89, erichn, canonicalization sweep
 *        07/06/89, thomaspa, fix find_dc() to use large enough buffer
 *                    (now uses BigBuf)
 *
 *        02/20/91, danhi, change to use lm 16/32 mapping layer
 */



#include <nt.h>		   // base definitions
#include <ntrtl.h>	
#include <nturtl.h>	   // these 2 includes allows <windows.h> to compile.
			           // since we'vealready included NT, and <winnt.h> will
			           // not be picked up, and <winbase.h> needs these defs.

#define INCL_DOS
#define INCL_ERRORS
#include <os2.h>
#include <lmcons.h>
#include <lmerr.h>
#include <lmapibuf.h>
#include <lmaccess.h>
#include <lmremutl.h>
#include <dlserver.h>
#include <dlwksta.h>
#include "mserver.h"
#include "mwksta.h"
#include <timelib.h>
#include <lui.h>
#include <apperr.h>
#include <apperr2.h>
#include <netlib.h>
#include <dsgetdc.h>

#include "netcmds.h"
#include "nettext.h"
#include "msystem.h"
#include "nwsupp.h"


/* Constants */

#define SECS_PER_DAY	86400
#define SECS_PER_HOUR	 3600
#define SECS_PER_MINUTE    60


/* Globals */

extern int YorN_Switch;

/* Function prototypes */
DWORD  display_time(TCHAR FAR *, BOOL *lanman);
DWORD  set_time(TCHAR FAR *, BOOL lanman);
USHORT find_rts(TCHAR FAR *, USHORT, BOOL);
USHORT find_dc(TCHAR FAR **);
DWORD  SetDateTime(PDATETIME pDateTime, BOOL LocalTime);

VOID
GetTimeInfo(
    VOID
    );


TCHAR		szTimeSep[3] ;   // enough for 1 SBCS/MBCS.
USHORT 		fsTimeFmt ;


/*
 * This function retrieves the time from the server passed, displays it,
 * and optionally tries to set the time locally.
 *
 * Parameters
 *     server           - name of server to retrieve time from
 *     set     - if TRUE, we try to set the time
 *
 * Does not return on error.
 */

DWORD time_display_server_worker(TCHAR FAR * server, BOOL set)
{
    DWORD  dwErr;
    BOOL   lanman = TRUE ;


    /* first display the time */
    dwErr = display_time(server, &lanman);
    if (dwErr)
        return dwErr;

    /* set the time, if we are asked to */
    if (set) {
        dwErr = set_time(server, lanman);
        if (dwErr)
            return dwErr;
    }

    /* everything worked out great */
    return 0;
}


VOID time_display_server(TCHAR FAR * server, BOOL set)
{
    DWORD dwErr;

    dwErr = time_display_server_worker(server, set);
    if (dwErr)
        ErrorExit(dwErr);

    InfoSuccess();
}


/*
 * This function retrieves the time from a domain controller, displays it, and
 * optionally sets the time locally.
 *
 * this function checks the switch list for the presence of the /DOMAIN switch.
 * If it finds a domain listed, we poll the domain controller of that domain for
 * the time. Otherwise we poll the domain controller of our primary domain.
 *
 * Parameters
 *     set     - if TRUE, we try to set the time
 *
 * Does not return on error.
 */

VOID time_display_dc(BOOL set)
{
    TCHAR    FAR *dc;
    USHORT         err;

    DWORD          dwErr;

    /* get the domain controller */
    err = find_dc(&dc);

    if (err)
        ErrorExit(err);

    /* now act like any other server */
    dwErr = time_display_server_worker(dc, set);

    if (dwErr)
        ErrorExit(dwErr);

    InfoSuccess();
}

/*
 * This function looks for reliable time servers, polls one for the time, and
 * displays it. It optionally sets the time locally.
 *
 * Parameters
 *     set     - if TRUE, we try to set the time
 *
 *
 * Does not return on error.
 */

VOID time_display_rts(BOOL set, BOOL fUseDomain )

{
    TCHAR        rts[MAX_PATH+1];
    USHORT        err;

    DWORD         dwErr;

    /* find a reliable time server */
    err = find_rts(rts,sizeof(rts),FALSE);

    if (err)
        ErrorExit(err);

    /* now treat it like any old server */
    dwErr = time_display_server_worker(rts, set);

    if (dwErr == ERROR_NETNAME_DELETED || dwErr == ERROR_BAD_NETPATH)
    {
        // Try one more time
        err = find_rts(rts,sizeof(rts),TRUE);
        if (err)
            ErrorExit(err);
        dwErr = time_display_server_worker(rts, set);
    }

    if (dwErr)
        ErrorExit(dwErr);

    InfoSuccess();
}


#define TIMESVC_REGKEY  L"System\\CurrentControlSet\\Services\\w32time\\Parameters"
#define NTP_AUTO_KEY    L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters"
#define SNTP_VALUE_NAME L"ntpserver"
#define TYPE_VALUE_NAME L"Type"
#define NTP_TYPE L"NTP"
#define NTDS_TYPE L"Nt5DS"
/*
 * This function sets the Reliable Time Server for this computer
 *
 */
VOID time_set_sntp( TCHAR FAR * server )
{
    LPWSTR  ptr = NULL;
    HKEY    hServer = NULL;
    HKEY    hKey = NULL;
    LONG    err = 0;
    int     i;

    /* look for a /SETSNTP switch */
    for (i = 0; SwitchList[i]; i++)
        if (_tcsstr(SwitchList[i],swtxt_SW_SETSNTP) == SwitchList[i]) {
            ptr = SwitchList[i];   /* found one -- point to it */
            break;
        }

    /* if we found one, look for a colon and argument */
    if (ptr != NULL) {
        ptr = _tcschr(ptr, ':');    /* look for colon */
        if (ptr != NULL)        /* found a colon; increment past it */
            ptr++;
    }

    if ( server != NULL )
    {
        err = RegConnectRegistry( server, HKEY_LOCAL_MACHINE, &hServer );
        if (err)
        {
            ErrorExit(err);
        }
    }

    err = RegOpenKeyEx(server == NULL ? HKEY_LOCAL_MACHINE : hServer,
                        TIMESVC_REGKEY,
                        0L,
                        KEY_SET_VALUE,
                        &hKey);

    if (err)
    {
        if (hServer)
            RegCloseKey( hServer );
        ErrorExit(err);
    }


    if ((ptr == NULL) || (*ptr == '\0'))
    {
        // Remove sntpserver value
        err = RegDeleteValue( hKey,
                              SNTP_VALUE_NAME );

        if (err == ERROR_FILE_NOT_FOUND)
        {
            //
            // It's not there -- just as good as a successful delete
            //

            err = NO_ERROR;
        }

        if (err == 0)
        {
            err = RegSetValueEx( hKey,
                                TYPE_VALUE_NAME,
                                0,
                                REG_SZ,
                                (LPBYTE)NTDS_TYPE,
                                sizeof(NTDS_TYPE) );
        }
    }
    else
    {
        // Set sntpserver value
        err = RegSetValueEx( hKey,
                             SNTP_VALUE_NAME,
                             0,
                             REG_SZ,
                             (LPBYTE)ptr,
                             (_tcslen(ptr) + 1)*sizeof(WCHAR) );

        if (err == 0)
        {
            err = RegSetValueEx( hKey,
                                TYPE_VALUE_NAME,
                                0,
                                REG_SZ,
                                (LPBYTE)NTP_TYPE,
                                sizeof(NTP_TYPE) );
        }

    }

    if ( hKey )
        RegCloseKey( hKey );

    if (hServer)
        RegCloseKey( hServer );

    if (err)
        ErrorExit(err);

    InfoSuccess();
}

VOID time_get_sntp( TCHAR FAR * server )
{
    LONG    err;
    HKEY    hKey = NULL;
    HKEY    hServer = NULL;
    LPBYTE  buffer = NULL;
    DWORD   datatype;
    DWORD   buffersize = 0;
    BOOL    fAutoConfigured = FALSE;    // TRUE if compute is NTPServer
                                        // comes from DHCP.

    if ( server != NULL )
    {
        err = RegConnectRegistry( server, HKEY_LOCAL_MACHINE, &hServer );
        if (err)
        {
            ErrorExit(err);
        }
    }

    err = RegOpenKeyEx(server == NULL ? HKEY_LOCAL_MACHINE : hServer,
                        TIMESVC_REGKEY,
                        0L,
                        KEY_QUERY_VALUE,
                        &hKey);

    if (!err)
    {

        buffersize = 1024;
        datatype = REG_SZ;
        if (err = NetApiBufferAllocate(buffersize, &buffer) )
        {
            RegCloseKey(hKey);
            ErrorExit(ERROR_OUTOFMEMORY);
        }

        err = RegQueryValueEx(hKey,
                                SNTP_VALUE_NAME,
                                0L,
                                &datatype,
                                buffer,
                                &buffersize);

        if (err == ERROR_MORE_DATA)
        {
            err = NetApiBufferReallocate(buffer, buffersize, &buffer);
            if (err)
            {
                RegCloseKey(hKey);
                ErrorExit(ERROR_OUTOFMEMORY);
            }

            err = RegQueryValueEx(hKey,
                                    SNTP_VALUE_NAME,
                                    0L,
                                    &datatype,
                                    buffer,
                                    &buffersize);

        }

        RegCloseKey(hKey);
    }

    //
    // If an error, try reading the DHCP ntpServer setting
    if (err)
    {
        err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                             NTP_AUTO_KEY,
                             0L,
                             KEY_QUERY_VALUE,
                             &hKey);
        if (!err)
        {
            err = RegQueryValueEx(hKey,
                                    SNTP_VALUE_NAME,
                                    0L,
                                    &datatype,
                                    buffer,
                                    &buffersize);
            if (!err)
            {
                fAutoConfigured = TRUE;
            }
            RegCloseKey(hKey);
        }
    }

    if (!err)
    {
        IStrings[0] = (WCHAR *)buffer;
        if (fAutoConfigured)
        {
            InfoPrintIns(APE_TIME_SNTP_AUTO, 1);
        }
        else
        {
            InfoPrintIns(APE_TIME_SNTP, 1);
        }
    }
    else
    {
        InfoPrint(APE_TIME_SNTP_DEFAULT);
    }

    if (buffer)
        NetApiBufferFree(buffer);

    if (hServer)
        RegCloseKey(hServer);

    InfoSuccess();
}



/*
 * This function polls server for the time, and writes a message to stdout
 * displaying the time.
 *
 * Parameters
 *     server                   name of server to poll
 *
 * Returns
 *     0               success
 *     otherwise           API return code describing the problem
 *
 *
 */

DWORD display_time(TCHAR FAR * server, BOOL *lanman)
{
    DWORD                 dwErr;                /* API return status */
    LPTIME_OF_DAY_INFO    tod;
    DWORD                 elapsedt ;

    /* get the time of day from the server */
    dwErr = NetRemoteTOD(server, (LPBYTE *)&tod);
    if (!dwErr)
    {
        elapsedt = tod->tod_elapsedt ;
        *lanman = TRUE ;

        /* format it nicely */
        UnicodeCtime((ULONG FAR *)&elapsedt, BigBuf, BIG_BUF_SIZE);
    }
    else
    {
        USHORT        err1 ;
        NWCONN_HANDLE hConn ;
        BYTE          year ;
        BYTE          month ;
        BYTE          day ;
        BYTE          hour ;
        BYTE          minute ;
        BYTE          second ;
        BYTE          dayofweek ;
        SYSTEMTIME    st;
        DWORD         cchD ;

        err1 = NetcmdNWAttachToFileServerW(server + 2, 0, &hConn) ;
        if (err1)
            return dwErr;

        err1 = NetcmdNWGetFileServerDateAndTime(hConn,
                                                &year,
                                                &month,
                                                &day,
                                                &hour,
                                                &minute,
                                                &second,
                                                &dayofweek) ;

        (void) NetcmdNWDetachFromFileServer(hConn) ;

        if (err1)
            return dwErr ;

        *lanman = FALSE ;

        st.wYear   = (WORD)(year + 1900);
	    st.wMonth  = (WORD)(month);
        st.wDay    = (WORD)(day);
        st.wHour   = (WORD)(hour);
        st.wMinute = (WORD)(minute);
        st.wSecond = (WORD)(second);
        st.wMilliseconds = 0;

        cchD = GetDateFormatW(GetThreadLocale(),
                              0,
                              &st,
                              NULL,
                              BigBuf,
                              BIG_BUF_SIZE);
        if (cchD != 0)
        {
            *(BigBuf+cchD-1) = TEXT(' ');	/* replace NULLC with blank */
            (void) GetTimeFormatW(GetThreadLocale(),
                                  TIME_NOSECONDS,
                                  &st,
                                  NULL,
                                  BigBuf+cchD,
                                  BIG_BUF_SIZE-cchD);
        }
    }


    /* print it out nicely */
    IStrings[0] = server;
    IStrings[1] = BigBuf;
    InfoPrintIns(APE_TIME_TimeDisp,2);
    if ((*lanman) && (NetpLocalTimeZoneOffset() != tod->tod_timezone*60))
    {
        static TCHAR tmpBuf[6];
        /* If the remote server is in a different timezone, then display
           the time relative to the remote machine (as if you were typing
           "time" on the remote console.
        */
        UnicodeCtimeWorker((ULONG FAR *)&elapsedt, BigBuf, BIG_BUF_SIZE, tod->tod_timezone * 60 );
        IStrings[0] = server;
        IStrings[1] = BigBuf;

        if ( tod->tod_timezone < 0 )
        {
            swprintf(tmpBuf, TEXT("+%02u:%02u"), -tod->tod_timezone / 60, -tod->tod_timezone % 60);
        }
        else if ( tod->tod_timezone > 0 )
        {
            swprintf( tmpBuf, TEXT("-%02u:%02u"), tod->tod_timezone / 60, tod->tod_timezone % 60);
        }
        else
        {
            *tmpBuf = '\0';
        }

        IStrings[2] = tmpBuf;
        InfoPrintIns(APE_TIME_TimeDispLocal,3);
    }

    NetApiBufferFree((TCHAR FAR *) tod);

    return 0;

}


/*
 * This function is used to set the time locally from a remote server.
 * It follows the following steps:
 *
 *     1. We look for confirmation.
 *
 *     3. We poll the server for the time.
 *
 *     4. We set the local time using the time we just got from the polled server.
 *
 *
 * Parameters:
 *     server                   name of server to poll for time
 *
 * Returns:
 *     0               success
 *     otherwise           API return code describing the problem
 *
 */


DWORD set_time(TCHAR FAR * server, BOOL lanman)
{
    LPTIME_OF_DAY_INFO    tod;
    USHORT                err;      /* API return status */
    DWORD                 dwErr;
    ULONG                 time_value;
    DATETIME              datetime;

    switch( YorN_Switch )
    {
        case 0:     /* no switch on command line */
            /* display local time */
            time_value = (DWORD) time_now();
            UnicodeCtime( &time_value, BigBuf, BIG_BUF_SIZE);

            IStrings[0] = BigBuf;
            IStrings[1] = server;
            if( !LUI_YorNIns( IStrings, 2, APE_TIME_SetTime, 1) )
                return( 0 );
            break;
        case 1:     /* Yes */
            break;
        case 2:     /* No */
            return( 0 );
    }


    if (lanman)
    {
        /* once again, get the time of day */
        if (dwErr = NetRemoteTOD(server, (LPBYTE *) &tod))
        {
            return dwErr;
        }

        /* copy over info from tod to datetime, quickly */
        datetime.hours        = (UCHAR)  tod->tod_hours;
        datetime.minutes        = (UCHAR)  tod->tod_mins;
        datetime.seconds        = (UCHAR)  tod->tod_secs;
        datetime.hundredths = (UCHAR)  tod->tod_hunds;
        datetime.day        = (UCHAR)  tod->tod_day;
        datetime.month        = (UCHAR)  tod->tod_month;
        datetime.year        = (USHORT) tod->tod_year;
        datetime.timezone        = (SHORT)  tod->tod_timezone;
        datetime.weekday        = (UCHAR)  tod->tod_weekday;


        NetApiBufferFree((TCHAR FAR *) tod);

        /* now set the local time */
        if (dwErr = SetDateTime(&datetime, FALSE)) // FALSE -> UTC
        {
            return dwErr;
        }
    }
    else
    {
        NWCONN_HANDLE hConn ;
        BYTE          year ;
        BYTE          month ;
        BYTE          day ;
        BYTE          hour ;
        BYTE          minute ;
        BYTE          second ;
        BYTE          dayofweek ;

        err = NetcmdNWAttachToFileServerW(server + 2, 0, &hConn);

        if (err)
            return ERROR_BAD_NETPATH;

        err = NetcmdNWGetFileServerDateAndTime(hConn,
                                               &year,
                                               &month,
                                               &day,
                                               &hour,
                                               &minute,
                                               &second,
                                               &dayofweek);

        NetcmdNWDetachFromFileServer(hConn);

        if (err)
            return ERROR_BAD_NETPATH ;


        /* copy over info from tod to datetime, quickly */
        datetime.hours      = hour;
        datetime.minutes    = minute;
        datetime.seconds    = second;
        datetime.hundredths = 0 ;
        datetime.day        = day;
        datetime.month      = month;
        datetime.year       = year + 1900;
        datetime.timezone   = 0 ;  // not used
        datetime.weekday    = 0 ;  // not used


        /* now set the local time */
        if (dwErr = SetDateTime(&datetime, TRUE))  // TRUE -> set local time
        {
            return dwErr;
        }
    }

    return 0;
}


/*
 * This function finds a reliable time server and returns the name in buf.
 *
 * Parameters:
 *     buf               buffer to fill with servername
 *     buflen                   maximum length of buffer
 *     retry             The servername previously returned from find_rts is
 *                        no longer available, try another.
 *
 *
 * Returns:
 *     0            success
 *     APE_TIME_RtsNotFound    reliable time server not found
 *     otherwise        API return code describing the problem
 *
 */

USHORT
find_rts(
    LPTSTR buf,
    USHORT buflen,
    BOOL retry
    )
{
    DWORD             dwErr;
    LPSERVER_INFO_0   si;
    DWORD             eread;
    TCHAR *           ptr = NULL;
    int i;

    UNREFERENCED_PARAMETER(buflen) ;


    /* look for a /RTSDOMAIN switch */
    for (i = 0; SwitchList[i]; i++)
        if (_tcsstr(SwitchList[i],swtxt_SW_RTSDOMAIN) == SwitchList[i]) {
            ptr = SwitchList[i];   /* found one -- point to it */
            break;
        }

    /* if we found one, look for a colon and argument */
    if (ptr != NULL) {
        ptr = _tcschr(ptr, ':');    /* look for colon */
        if (ptr != NULL)        /* found a colon; increment past it */
            ptr++;
    }

    /* find a reliable time server */
    dwErr = MNetServerEnum(NULL,
                           100,
                           (LPBYTE *) &si,
                           &eread,
                           (ULONG) SV_TYPE_TIME_SOURCE,
                           ptr);

    /* there are none -- bag it */
    if (dwErr != NERR_Success || eread == 0 || (retry && eread <= 1))
    {
        DOMAIN_CONTROLLER_INFO *pTimeServerInfo;
        /* Try finding a NT5 DC */
        if (DsGetDcName( NULL,
                         ptr,
                         NULL,
                         NULL,
                         retry ? DS_FORCE_REDISCOVERY | DS_TIMESERV_REQUIRED
                               : DS_TIMESERV_REQUIRED,
                         &pTimeServerInfo ))
        {
            return APE_TIME_RtsNotFound;
        }

        //
        // DomainControllerName starts with \\ already
        //

        _tcscpy(buf, pTimeServerInfo->DomainControllerName);

        return 0;
    }

    if (retry && (eread > 1))
    {
        // go to the next entry returned.  This makes the assumption that the
        // order of entries returned is the same as the previous failed call,
        // so let's try the next one in the buffer.
        si++;
    }

    /* copy over name into buffer */
    _tcscpy(buf,TEXT("\\\\"));
    _tcscat(buf,si->sv0_name);

    NetApiBufferFree((TCHAR FAR *) si);

    return 0;

}

/*
 * This function finds the name of a domain controller and returns it in buf.
 *
 * It searches the switch table for a "/DOMAIN" switch, and if it finds one it
 * returns the name of the domain controller for that domain.
 *
 * Otherwise it returns the name of the domain controller for the primary domain.
 *
 *
 * Parameters:
 *     buf               buffer to fill with domain controller name
 *     buflen                   length of buf
 *
 * Returns:
 *  0                       success
 *
 *  Uses BigBuf for NetWkstaGetInfo call, but this only occurs in the error case
 *  Does not return on error.
 */



USHORT find_dc(TCHAR FAR ** ppBuffer)

{
    DWORD                  dwErr;
    TCHAR *                ptr = NULL;
    LPWKSTA_INFO_10        wkinfo;
    int                    i;
    DOMAIN_CONTROLLER_INFO *pDCInfo = (DOMAIN_CONTROLLER_INFO *) NULL;

    /* look for a /DOMAIN switch */
    for (i = 0; SwitchList[i]; i++)
    {
        if (_tcsstr(SwitchList[i],swtxt_SW_DOMAIN) == SwitchList[i])
        {
            ptr = SwitchList[i];   /* found one -- point to it */
            break;
        }
    }

    /* if we found one, look for a colon and argument */
    if (ptr != NULL)
    {
        ptr = _tcschr(ptr, ':');    /* look for colon */
        if (ptr != NULL)        /* found a colon; increment past it */
            ptr++;
    }

    /* now go look up this domain (ptr == NULL        means primary domain) */

    dwErr = DsGetDcName( NULL,
                         ptr,
                         NULL,
                         NULL,
                         DS_DIRECTORY_SERVICE_PREFERRED,
                         &pDCInfo );

    if (!dwErr)
    {
        *ppBuffer = pDCInfo->DomainControllerName;
    }
    else
    {
        /* we failed on primary domain; find out the name */
        if (ptr == NULL)
        {
            if (dwErr = MNetWkstaGetInfo(10, (LPBYTE*)ppBuffer))
            {
                ErrorExit(dwErr);
            }

            wkinfo = (LPWKSTA_INFO_10) *ppBuffer;
            IStrings[0] = wkinfo->wki10_langroup;
        }
        else
        {
            IStrings[0] = ptr;
        }

        ErrorExitIns(APE_TIME_DcNotFound, 1);
    }

    return 0;
}


int
UnicodeCtime(
    DWORD * Time,
    PTCHAR String,
    int StringLength
    )
/*++

Routine Description:

    This function converts the UTC time expressed in seconds since 1/1/70
    to an ASCII String.

Arguments:

    Time         - Pointer to the number of seconds since 1970 (UTC).

    String       - Pointer to the buffer to place the ASCII representation.

    StringLength - The length of String in bytes.

Return Value:

    None.

--*/
{
    return ( UnicodeCtimeWorker( Time, String, StringLength, -1 ));
}


int
UnicodeCtimeWorker(
    DWORD * Time,
    PTCHAR String,
    int StringLength,
    int BiasForLocalTime
    )
/*++

Routine Description:

    This function converts the UTC time expressed in seconds since 1/1/70
    to an ASCII String.

Arguments:

    Time         - Pointer to the number of seconds since 1970 (UTC).

    String       - Pointer to the buffer to place the ASCII representation.

    StringLength - The length of String in bytes.

Return Value:

    None.

--*/
{
    time_t LocalTime;
    struct tm TmTemp;
    SYSTEMTIME st;
    int	cchT=0, cchD;

    if ( BiasForLocalTime  != -1)
    {
        LocalTime = (time_t) (*Time - BiasForLocalTime);
    }
    else
    {
        DWORD  dwTimeTemp;

        NetpGmtTimeToLocalTime(*Time, &dwTimeTemp);

        //
        // Cast the DWORD returned by NetpGmtTimeToLocalTime up to
        // a time_t.  On 32-bit, this is a no-op.  On 64-bit, this
        // ensures the high DWORD of LocalTime is zeroed out.
        //
        LocalTime = (time_t) dwTimeTemp;
    }

    net_gmtime(&LocalTime, &TmTemp);

    st.wYear   = (WORD)(TmTemp.tm_year + 1900);
    st.wMonth  = (WORD)(TmTemp.tm_mon + 1);
    st.wDay    = (WORD)(TmTemp.tm_mday);
    st.wHour   = (WORD)(TmTemp.tm_hour);
    st.wMinute = (WORD)(TmTemp.tm_min);
    st.wSecond = (WORD)(TmTemp.tm_sec);
    st.wMilliseconds = 0;

    cchD = GetDateFormatW(GetThreadLocale(), 0, &st, NULL, String, StringLength);

    if (cchD != 0)
    {
        *(String + cchD - 1) = TEXT(' ');    /* replace NULLC with blank */
        cchT = GetTimeFormatW(GetThreadLocale(),
                              TIME_NOSECONDS,
                              &st,
                              NULL,
                              String + cchD,
                              StringLength - cchD);

        if (cchT == 0)
        {
            //
            // If this gets hit, MAX_DATE_TIME_LEN (in netapi\inc\timelib.h)
            // needs to be increased
            //
            ASSERT(FALSE);
            *(String + cchD - 1) = TEXT('\0');
        }
    }

    return cchD + cchT;
}


/* local routine */
VOID
GetTimeInfo(
    VOID
    )
{
    // get the defautl separator from the system
    GetProfileString(TEXT("intl"),
                      TEXT("sTime"),
                      TEXT(":"),
                      szTimeSep,
                      DIMENSION(szTimeSep)) ;
}


/*
 *LUI_FormatDuration(seconds,buffer,buffer_len)
 *
 *Purpose:
 *	Converts a time stored in seconds to a character string.
 *
 *History
 * 	8/23/89 - chuckc, stolen from NETLIB
 */

USHORT
LUI_FormatDuration(
    LONG * time,
    TCHAR * buf,
    USHORT buflen
    )
{

    ULONG duration;
    ULONG d1, d2, d3;
    TCHAR szDayAbbrev[8], szHourAbbrev[8], szMinuteAbbrev[8] ;
    TCHAR tmpbuf[LUI_FORMAT_DURATION_LEN] ;

    /*
     * check for input bufsize
     */
    if (buflen < LUI_FORMAT_DURATION_LEN)
	return (NERR_BufTooSmall) ;  /* buffer too small */

    /*
     * setup country info & setup day/hour/minute strings
     */
    GetTimeInfo() ;
    if (LUI_GetMsg(szHourAbbrev, DIMENSION(szHourAbbrev),
		   APE2_TIME_HOURS_ABBREV))
	_tcscpy(szHourAbbrev, TEXT("H")) ;	/* default if error */
    if (LUI_GetMsg(szMinuteAbbrev, DIMENSION(szMinuteAbbrev),
		   APE2_TIME_MINUTES_ABBREV))
	_tcscpy(szMinuteAbbrev, TEXT("M")) ;	/* default if error */
    if (LUI_GetMsg(szDayAbbrev, DIMENSION(szDayAbbrev),
		   APE2_TIME_DAYS_ABBREV))
	_tcscpy(szDayAbbrev, TEXT("D")) ;	/* default if error */

    /*
     * format as 00:00:00 or  5D 4H 2M as appropriate
     */
    duration = *time;
    if(duration < SECS_PER_DAY)
    {
	d1 = duration / SECS_PER_HOUR;
	duration %= SECS_PER_HOUR;
	d2 = duration / SECS_PER_MINUTE;
	duration %= SECS_PER_MINUTE;
	d3 = duration;

	swprintf(tmpbuf, TEXT("%2.2lu%ws%2.2lu%ws%2.2lu\0"),
	 	  d1, szTimeSep, d2, szTimeSep, d3 ) ;
     }
     else
     {
	 d1 = duration / SECS_PER_DAY;
	 duration %= SECS_PER_DAY;
	 d2 = duration / SECS_PER_HOUR;
	 duration %= SECS_PER_HOUR;
	 d3 = duration / SECS_PER_MINUTE;
	 swprintf(tmpbuf, TEXT("%2.2lu%ws %2.2lu%ws %2.2lu%ws\0"),
	 	  d1, szDayAbbrev,
		  d2, szHourAbbrev,
		  d3, szMinuteAbbrev);
     };

    _tcscpy(buf,tmpbuf) ;
    return(0);
}


/*
 * FormatTimeofDay(seconds,buffer,buffer_len)
 *
 *Purpose:
 *	Converts a time stored in seconds to a character string.
 *
 *History
 * 	8/23/89 - chuckc, stolen from NETLIB
 *	4/18/91 - danhi 32 bit NT version
 */
DWORD
FormatTimeofDay(
    time_t *time,
    LPTSTR buf,
    DWORD  buflen
    )
{
    int 		hrs, min ;
    TCHAR		szTimeAM[8], szTimePM[8] ;
    TCHAR		tmpbuf[LUI_FORMAT_TIME_LEN] ;
    time_t		seconds ;

    /*
     * initial checks
     */
    if(buflen < LUI_FORMAT_TIME_LEN)
	return (NERR_BufTooSmall) ;
    seconds = *time ;
    if (seconds < 0 || seconds >= SECS_PER_DAY)
	return(ERROR_INVALID_PARAMETER) ;

    /*
     * get country info & setup strings
     */
    GetTimeInfo() ;
    if (LUI_GetMsg(szTimeAM, DIMENSION(szTimeAM),
		APE2_GEN_TIME_AM1))
	_tcscpy(szTimeAM, TEXT("AM")) ;	    /* default if error */
    if (LUI_GetMsg(szTimePM, DIMENSION(szTimePM),
		APE2_GEN_TIME_PM1))
	_tcscpy(szTimePM,TEXT("PM")) ;	    /* default if error */

    min = (int) ((seconds /60)%60);
    hrs = (int) (seconds /3600);

    /*
     * Do 24 hour or 12 hour format as appropriate
     */
    if(fsTimeFmt == 0x001)
    {
	swprintf(tmpbuf, TEXT("%2.2u%ws%2.2u"), hrs, szTimeSep, min) ;
    }
    else
    {
	if(hrs >= 12)
	{
	    if (hrs > 12)
		hrs -= 12 ;
	    swprintf(tmpbuf, TEXT("%2u%ws%2.2u%ws\0"),
		    hrs, szTimeSep, min, szTimePM) ;
	}
	else
	{
	    if (hrs == 0)
		hrs =  12 ;
	    swprintf(tmpbuf, TEXT("%2u%ws%2.2u%ws\0"),
		    hrs, szTimeSep, min, szTimeAM);
	};
    };
    _tcscpy(buf,tmpbuf) ;
    return(0);
}


DWORD
SetDateTime(
    PDATETIME pDateTime,
    BOOL      LocalTime
    )
{
    SYSTEMTIME                 Date_And_Time;
    ULONG                      privileges[1];
    NET_API_STATUS             status;

    Date_And_Time.wHour         = (WORD) pDateTime->hours;
    Date_And_Time.wMinute       = (WORD) pDateTime->minutes;
    Date_And_Time.wSecond       = (WORD) pDateTime->seconds;
    Date_And_Time.wMilliseconds = (WORD) (pDateTime->hundredths * 10);
    Date_And_Time.wDay          = (WORD) pDateTime->day;
    Date_And_Time.wMonth        = (WORD) pDateTime->month;
    Date_And_Time.wYear         = (WORD) pDateTime->year;
    Date_And_Time.wDayOfWeek    = (WORD) pDateTime->weekday;

    privileges[0] = SE_SYSTEMTIME_PRIVILEGE;

    status = NetpGetPrivilege(1, privileges);

    if (status != NO_ERROR)
    {
        return ERROR_ACCESS_DENIED;    // report as access denied
    }

    if (LocalTime)
    {
        if (!SetLocalTime(&Date_And_Time))
        {
            return GetLastError();
        }
    }
    else 
    {
        if (!SetSystemTime(&Date_And_Time))
        {
            return GetLastError();
        }
    }

    NetpReleasePrivilege();
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\netuse\net.c ===
#include    "interpre.h"

#define INCL_NOCOMMON
#include <os2.h>

#define USE 600
#define VIEW 601
#define EOS EOF

#include <stdio.h>
#include <lmcons.h>
#include <lmshare.h>

#include "netcmds.h"
#include "nettext.h"
#include "swtchtbl.h"
#include "os2incl.h"

extern void call_net1(void) ;

    char *Rule_strings[] = {
        0
    };
    short   Index_strings[] = {
    0
    };

#define _net 0
#define _use 11
#define _view 78
#define _unknown 89
#define _no_command 92
#define _device_or_wildcard 95
#define _device_name 98
#define _resource_name 101
#define _netname 104
#define _username 107
#define _qualified_username 110
#define _pass 113
#define _networkname 116
#define _networkname2 119
    TCHAR   XXtype[] = {
/*  0  */   X_OR,   /*  3  */
/*  1  */   X_PROC, /*  _no_command  */
/*  2  */   X_ACCEPT,   /*  123  */
/*  3  */   X_OR,   /*  6  */
/*  4  */   X_PROC, /*  _use  */
/*  5  */   X_ACCEPT,   /*  124  */
/*  6  */   X_OR,   /*  9  */
/*  7  */   X_PROC, /*  _view  */
/*  8  */   X_ACCEPT,   /*  125  */
/*  9  */   X_PROC, /*  _unknown  */
/*  10  */  X_ACCEPT,   /*  127  */
/*  11  */  X_TOKEN,    /*  (short)USE  */
/*  12  */  X_CONDIT,   /*  0  */
/*  13  */  X_OR,   /*  24  */
/*  14  */  X_TOKEN,    /*  (short)EOS  */
/*  15  */  X_OR,   /*  19  */
/*  16  */  X_CONDIT,   /*  1  */
/*  17  */  X_ACTION,   /*  0  */
/*  18  */  X_ACCEPT,   /*  137  */
/*  19  */  X_SWITCH,   /*  0  */
/*  20  */  X_CONDIT,   /*  2  */
/*  21  */  X_ACTION,   /*  1  */
/*  22  */  X_ACCEPT,   /*  140  */
/*  23  */  X_ACCEPT,   /*  141  */
/*  24  */  X_OR,   /*  41  */
/*  25  */  X_PROC, /*  _networkname  */
/*  26  */  X_OR,   /*  36  */
/*  27  */  X_TOKEN,    /*  (short)EOS  */
/*  28  */  X_OR,   /*  33  */
/*  29  */  X_SWITCH,   /*  1  */
/*  30  */  X_CONDIT,   /*  3  */
/*  31  */  X_ACTION,   /*  2  */
/*  32  */  X_ACCEPT,   /*  148  */
/*  33  */  X_ACTION,   /*  3  */
/*  34  */  X_ACCEPT,   /*  152  */
/*  35  */  X_ACCEPT,   /*  153  */
/*  36  */  X_PROC, /*  _pass  */
/*  37  */  X_TOKEN,    /*  (short)EOS  */
/*  38  */  X_ACTION,   /*  4  */
/*  39  */  X_ACCEPT,   /*  156  */
/*  40  */  X_ACCEPT,   /*  157  */
/*  41  */  X_PROC, /*  _device_or_wildcard  */
/*  42  */  X_OR,   /*  57  */
/*  43  */  X_TOKEN,    /*  (short)EOS  */
/*  44  */  X_OR,   /*  48  */
/*  45  */  X_CONDIT,   /*  4  */
/*  46  */  X_ACTION,   /*  5  */
/*  47  */  X_ACCEPT,   /*  164  */
/*  48  */  X_OR,   /*  53  */
/*  49  */  X_SWITCH,   /*  1  */
/*  50  */  X_CONDIT,   /*  5  */
/*  51  */  X_ACTION,   /*  6  */
/*  52  */  X_ACCEPT,   /*  167  */
/*  53  */  X_SWITCH,   /*  2  */
/*  54  */  X_ACTION,   /*  7  */
/*  55  */  X_ACCEPT,   /*  170  */
/*  56  */  X_ACCEPT,   /*  171  */
/*  57  */  X_OR,   /*  64  */
/*  58  */  X_PROC, /*  _pass  */
/*  59  */  X_TOKEN,    /*  (short)EOS  */
/*  60  */  X_SWITCH,   /*  2  */
/*  61  */  X_ACTION,   /*  8  */
/*  62  */  X_ACCEPT,   /*  176  */
/*  63  */  X_ACCEPT,   /*  177  */
/*  64  */  X_PROC, /*  _networkname  */
/*  65  */  X_OR,   /*  71  */
/*  66  */  X_PROC, /*  _pass  */
/*  67  */  X_TOKEN,    /*  (short)EOS  */
/*  68  */  X_ACTION,   /*  9  */
/*  69  */  X_ACCEPT,   /*  192  */
/*  70  */  X_ACCEPT,   /*  193  */
/*  71  */  X_TOKEN,    /*  (short)EOS  */
/*  72  */  X_ACTION,   /*  10  */
/*  73  */  X_ACCEPT,   /*  206  */
/*  74  */  X_ACCEPT,   /*  207  */
/*  75  */  X_ACCEPT,   /*  208  */
/*  76  */  X_ACCEPT,   /*  209  */
/*  77  */  X_ACCEPT,   /*  209  */
/*  78  */  X_TOKEN,    /*  (short)VIEW  */
/*  79  */  X_CONDIT,   /*  6  */
/*  80  */  X_OR,   /*  84  */
/*  81  */  X_TOKEN,    /*  (short)EOS  */
/*  82  */  X_ACTION,   /*  11  */
/*  83  */  X_ACCEPT,   /*  216  */
/*  84  */  X_PROC, /*  _networkname2  */
/*  85  */  X_TOKEN,    /*  (short)EOS  */
/*  86  */  X_ACTION,   /*  12  */
/*  87  */  X_ACCEPT,   /*  219  */
/*  88  */  X_ACCEPT,   /*  219  */
/*  89  */  X_ANY,  /*  0  */
/*  90  */  X_ACTION,   /*  13  */
/*  91  */  X_ACCEPT,   /*  228  */
/*  92  */  X_TOKEN,    /*  (short)EOS  */
/*  93  */  X_ACTION,   /*  14  */
/*  94  */  X_ACCEPT,   /*  232  */
/*  95  */  X_ANY,  /*  0  */
/*  96  */  X_CONDIT,   /*  7  */
/*  97  */  X_ACCEPT,   /*  239  */
/*  98  */  X_ANY,  /*  0  */
/*  99  */  X_CONDIT,   /*  8  */
/*  100  */ X_ACCEPT,   /*  241  */
/*  101  */ X_ANY,  /*  0  */
/*  102  */ X_CONDIT,   /*  9  */
/*  103  */ X_ACCEPT,   /*  243  */
/*  104  */ X_ANY,  /*  0  */
/*  105  */ X_CONDIT,   /*  10  */
/*  106  */ X_ACCEPT,   /*  245  */
/*  107  */ X_ANY,  /*  0  */
/*  108  */ X_CONDIT,   /*  11  */
/*  109  */ X_ACCEPT,   /*  247  */
/*  110  */ X_ANY,  /*  0  */
/*  111  */ X_CONDIT,   /*  12  */
/*  112  */ X_ACCEPT,   /*  249  */
/*  113  */ X_ANY,  /*  0  */
/*  114  */ X_CONDIT,   /*  13  */
/*  115  */ X_ACCEPT,   /*  251  */
/*  116  */ X_ANY,  /*  0  */
/*  117  */ X_CONDIT,   /*  14  */
/*  118  */ X_ACCEPT,   /*  253  */
/*  119  */ X_ANY,  /*  0  */
/*  120  */ X_CONDIT,   /*  15  */
/*  121  */ X_ACCEPT,   /*  255  */
    };
    short   XXvalues[] = {
/*  0  */   3,
/*  1  */   _no_command,
/*  2  */   123,
/*  3  */   6,
/*  4  */   _use,
/*  5  */   124,
/*  6  */   9,
/*  7  */   _view,
/*  8  */   125,
/*  9  */   _unknown,
/*  10  */  127,
/*  11  */  (short)USE,
/*  12  */  0,
/*  13  */  24,
/*  14  */  (short)EOS,
/*  15  */  19,
/*  16  */  1,
/*  17  */  0,
/*  18  */  137,
/*  19  */  0,
/*  20  */  2,
/*  21  */  1,
/*  22  */  140,
/*  23  */  141,
/*  24  */  41,
/*  25  */  _networkname,
/*  26  */  36,
/*  27  */  (short)EOS,
/*  28  */  33,
/*  29  */  1,
/*  30  */  3,
/*  31  */  2,
/*  32  */  148,
/*  33  */  3,
/*  34  */  152,
/*  35  */  153,
/*  36  */  _pass,
/*  37  */  (short)EOS,
/*  38  */  4,
/*  39  */  156,
/*  40  */  157,
/*  41  */  _device_or_wildcard,
/*  42  */  57,
/*  43  */  (short)EOS,
/*  44  */  48,
/*  45  */  4,
/*  46  */  5,
/*  47  */  164,
/*  48  */  53,
/*  49  */  1,
/*  50  */  5,
/*  51  */  6,
/*  52  */  167,
/*  53  */  2,
/*  54  */  7,
/*  55  */  170,
/*  56  */  171,
/*  57  */  64,
/*  58  */  _pass,
/*  59  */  (short)EOS,
/*  60  */  2,
/*  61  */  8,
/*  62  */  176,
/*  63  */  177,
/*  64  */  _networkname,
/*  65  */  71,
/*  66  */  _pass,
/*  67  */  (short)EOS,
/*  68  */  9,
/*  69  */  192,
/*  70  */  193,
/*  71  */  (short)EOS,
/*  72  */  10,
/*  73  */  206,
/*  74  */  207,
/*  75  */  208,
/*  76  */  209,
/*  77  */  209,
/*  78  */  (short)VIEW,
/*  79  */  6,
/*  80  */  84,
/*  81  */  (short)EOS,
/*  82  */  11,
/*  83  */  216,
/*  84  */  _networkname2,
/*  85  */  (short)EOS,
/*  86  */  12,
/*  87  */  219,
/*  88  */  219,
/*  89  */  0,
/*  90  */  13,
/*  91  */  228,
/*  92  */  (short)EOS,
/*  93  */  14,
/*  94  */  232,
/*  95  */  0,
/*  96  */  7,
/*  97  */  239,
/*  98  */  0,
/*  99  */  8,
/*  100  */ 241,
/*  101  */ 0,
/*  102  */ 9,
/*  103  */ 243,
/*  104  */ 0,
/*  105  */ 10,
/*  106  */ 245,
/*  107  */ 0,
/*  108  */ 11,
/*  109  */ 247,
/*  110  */ 0,
/*  111  */ 12,
/*  112  */ 249,
/*  113  */ 0,
/*  114  */ 13,
/*  115  */ 251,
/*  116  */ 0,
/*  117  */ 14,
/*  118  */ 253,
/*  119  */ 0,
/*  120  */ 15,
/*  121  */ 255,
    };
extern  TCHAR * XXnode;
xxcondition(index,xxvar)int index;register TCHAR * xxvar[]; {switch(index) {
#line 131 "msnet.nt"
        case 0 :
            return(ValidateSwitches(0,use_switches));
#line 135 "msnet.nt"
        case 1 :
            return(noswitch());
#line 138 "msnet.nt"
        case 2 :
            return(oneswitch());
#line 146 "msnet.nt"
        case 3 :
            return(oneswitch());
#line 162 "msnet.nt"
        case 4 :
            return(noswitch());
#line 165 "msnet.nt"
        case 5 :
            return(oneswitch());
#line 212 "msnet.nt"
        case 6 :
            return(ValidateSwitches(0,view_switches));
#line 239 "msnet.nt"
        case 7 :
            return(IsDeviceName(xxvar[0]) || IsWildCard(xxvar[0]));
#line 241 "msnet.nt"
        case 8 :
            return(IsDeviceName(xxvar[0]));
#line 243 "msnet.nt"
        case 9 :
            return(IsResource(xxvar[0]));
#line 245 "msnet.nt"
        case 10 :
            return(IsNetname(xxvar[0]));
#line 247 "msnet.nt"
        case 11 :
            return(IsUsername(xxvar[0]));
#line 249 "msnet.nt"
        case 12 :
            return(IsQualifiedUsername(xxvar[0]));
#line 251 "msnet.nt"
        case 13 :
            return(IsPassword(xxvar[0]));
#line 253 "msnet.nt"
        case 14 :
            return(!IsDeviceName(xxvar[0]) && !IsWildCard(xxvar[0]));
#line 255 "msnet.nt"
        case 15 :
            return(!IsWildCard(xxvar[0]));
        } return FALSE; }
xxaction(index,xxvar)int index;register TCHAR * xxvar[]; {switch(index) {
#line 136 "msnet.nt"
        case 0 :
            {use_display_all(); } break;
#line 139 "msnet.nt"
        case 1 :
            {use_set_remembered(); } break;
#line 147 "msnet.nt"
        case 2 :
            {use_del(xxvar[1], TRUE, TRUE); } break;
#line 151 "msnet.nt"
        case 3 :
            {use_unc(xxvar[1]); } break;
#line 155 "msnet.nt"
        case 4 :
            {use_add(NULL, xxvar[1], xxvar[2], FALSE, TRUE); } break;
#line 163 "msnet.nt"
        case 5 :
            {use_display_dev(xxvar[1]); } break;
#line 166 "msnet.nt"
        case 6 :
            {use_del(xxvar[1], FALSE, TRUE); } break;
#line 169 "msnet.nt"
        case 7 :
            {use_add_home(xxvar[1], NULL); } break;
#line 175 "msnet.nt"
        case 8 :
            {use_add_home(xxvar[1], xxvar[2]); } break;
#line 182 "msnet.nt"
        case 9 :
            {use_add(xxvar[1], xxvar[2], xxvar[3], FALSE, TRUE); } break;
#line 196 "msnet.nt"
        case 10 :
            {use_add(xxvar[1], xxvar[2], NULL, FALSE, TRUE); } break;
#line 215 "msnet.nt"
        case 11 :
            {view_display(NULL); } break;
#line 218 "msnet.nt"
        case 12 :
            {view_display(xxvar[1]); } break;
#line 227 "msnet.nt"
        case 13 :
            {call_net1(); } break;
#line 231 "msnet.nt"
        case 14 :
            {call_net1(); } break;
        } return 0; }
TCHAR * xxswitch[] = {
TEXT("/PERSISTENT"),
TEXT("/DELETE"),
TEXT("/HOME"),
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\netcmd\usertime.c ===
/********************************************************************/
/**			Microsoft LAN Manager			   **/
/**		  Copyright(c) Microsoft Corp., 1987-1990	   **/
/********************************************************************/

/***
 * usertime.c --
 *
 *   parsing routines for net user /times.
 */


#define INCL_NOCOMMON
#define INCL_DOS
#include <os2.h>


#include "timelib.h"
#include <lui.h>
#include <apperr.h>
#include <apperr2.h>

#include "netcmds.h"
#include "luidate.h"

#define TIME_FORMAT_12	   1
#define TIME_FORMAT_24	   2
#define TIME_FORMAT_EITHER 3

/*
 * A day. We only need 24 bits, but we use 32 because we can do better
 * bit manipulation with a LONGword.
 *
 *
 */
typedef ULONG DAY;

/*
 * Array of 7 boolean values, to specify days in a week.
 */
typedef BOOL WEEKLIST[7];



/*
 * function prototypes
 */

DWORD  parse_days(LPTSTR, WEEKLIST, LPTSTR *);
BOOL   might_be_time_token(LPTSTR);
BOOL   is_single_day(LPTSTR);
DWORD  parse_single_day(LPTSTR, PDWORD);
DWORD  parse_day_range(LPTSTR, PDWORD, PDWORD);
VOID   set_day_range(DWORD, DWORD, WEEKLIST);
VOID   map_days_times(WEEKLIST, DAY *, PUCHAR);
DWORD  parse_times(LPTSTR, DAY *, LPDWORD, LPDWORD);
DWORD  parse_time_range(LPTSTR, PDWORD, PDWORD);
VOID   set_time_range(DWORD, DWORD, DAY *);
DWORD  parse_single_time(LPTSTR, PDWORD, DWORD);
LPTSTR get_token(LPTSTR *, LPTSTR);


/*
 * all sorts of text that gets loaded in at runtime from the message file.
 */

MESSAGE     LocalizedDays[7] = {
    { APE2_GEN_SUNDAY,	    NULL},
    { APE2_GEN_MONDAY,	    NULL},
    { APE2_GEN_TUESDAY,     NULL},
    { APE2_GEN_WEDNSDAY,   NULL},
    { APE2_GEN_THURSDAY,    NULL},
    { APE2_GEN_FRIDAY,	    NULL},
    { APE2_GEN_SATURDAY,    NULL},
};

MESSAGE     LocalizedDaysAbbrev[7] = {
    { APE2_GEN_SUNDAY_ABBREV,	   NULL},
    { APE2_GEN_MONDAY_ABBREV,	   NULL},
    { APE2_GEN_TUESDAY_ABBREV,	   NULL},
    { APE2_GEN_WEDNSDAY_ABBREV,   NULL},
    { APE2_GEN_THURSDAY_ABBREV,    NULL},
    { APE2_GEN_FRIDAY_ABBREV,	   NULL},
    { APE2_GEN_SATURDAY_ABBREV,    NULL},
};

/*
 * These are not in the message file because they are not ever localized.
 * They are switch parameters, constant throughout all localized versions.
 * Localized versions of the days of the week are loaded in separately.
 */

TCHAR FAR * NonlocalizedDays[7] = {
    TEXT("SUNDAY"), TEXT("MONDAY"), TEXT("TUESDAY"), TEXT("WEDNESDAY"),
    TEXT("THURSDAY"), TEXT("FRIDAY"), TEXT("SATURDAY")
};


/*
 * parse_days_times --
 *
 *  This is the main entry point to the day/time parsing.
 *
 *  ENTRY
 *  psz -- string to be parsed
 *
 *  EXIT
 *  bmap -- set to represent times
 *
 *  RETURNS
 *  0	    success
 *  otherwise	code describing problem
 */

DWORD
parse_days_times(
    LPTSTR psz,
    PUCHAR bmap)
{
    WEEKLIST      days;
    DAY           times;
    LPTSTR        tok;
    LPTSTR        timetok;
    DWORD         err;
    DWORD         max_len;
    DWORD         dwStartTime;
    DWORD         dwEndTime;

#if DBG
    int           i,j;
    PUCHAR        weekptr;
#endif

    /* zap it all */
    memset(bmap, 0, sizeof(WEEK));

    /* get our tables of messages */

    GetMessageList(7, LocalizedDays, &max_len);
    GetMessageList(7, LocalizedDaysAbbrev, &max_len);

#if DBG
    WriteToCon(TEXT("parse_days_times: parsing: %Fs\r\n"),(TCHAR FAR *) psz);
#endif

    /* for each day-time section... */
    while (  (tok = get_token(&psz, TEXT(";"))) != NULL) {

	/* parse up the days */
	if (err = parse_days(tok, days, &timetok))
        {
	    return err;
        }

	/* and the times */
	if (err = parse_times(timetok, &times, &dwStartTime, &dwEndTime))
        {
            if (err == APE_ReversedTimeRange)
            {
                //
                // Time range that spans days.  Do this in two passes --
                // beginning to midnight for all the days and then midnight
                // to end for all the days plus one.
                //

                BOOL fLastDay;

                set_time_range(dwStartTime, 24, &times);
                map_days_times(days, &times, bmap);

                fLastDay = days[6];
                memmove(&days[1], &days[0], sizeof(BOOL) * 6);
                days[0] = fLastDay;

                set_time_range(0, dwEndTime, &times);
                map_days_times(days, &times, bmap);
            }
            else
            {
                return err;
            }
        }
        else
        {
            /* then "or" them into our week bitmap */
            map_days_times( days, &times, bmap );
        }
    }

#if DBG
    weekptr = bmap;
    for (i = 0; i < 7; ++i) {
	WriteToCon(TEXT("%-2.2s "),LocalizedDaysAbbrev[i].msg_text);
	for (j = 2; j >= 0; --j)
	    WriteToCon(TEXT("%hx "), (DWORD) *(weekptr++));
	WriteToCon(TEXT("\r\n"));
    }
#endif

    return 0;
}


/*
 * parse_days --
 *
 *  This parses up the "days" portion of the time format.
 *  We strip off day tokens, until we hit a time token. We then
 *  set timetok to point to the beginning of the time tokens, and
 *  return.
 *
 *  ENTRY
 *  psz -- string to be parsed
 *
 *  EXIT
 *  days -- set to represent days
 *  timetok -- points to start of time tokens
 *
 *  RETURNS
 *  0	    success
 *  otherwise	code describing problem
 */


DWORD
parse_days(
    LPTSTR   psz,
    WEEKLIST days,
    LPTSTR   *timetok
    )
{
    DWORD     i;
    LPTSTR    tok;
    DWORD     err;
    DWORD     day;
    DWORD     first;
    DWORD     last;

    for (i = 0; i < 7; ++i)
	days[i] =  FALSE;

#if DBG
    WriteToCon(TEXT("parse_days: parsing: %Fs\r\n"),(TCHAR FAR *) psz);
#endif

    if (might_be_time_token(psz))   /* want at last one day */
	return APE_BadDayRange;

    while ( !might_be_time_token(psz)) {

	tok = get_token(&psz, TEXT(","));
	if (tok == NULL)
	    return APE_BadDayRange;

	if (is_single_day(tok)) {
	    if (err = parse_single_day(tok, &day))
		return err;
	    set_day_range(day, day, days);
	}

	else {
	    if (err = parse_day_range(tok, &first, &last))
		return err;
	    set_day_range(first, last, days);
	}
    }
    *timetok = psz;

    return 0;
}




/*
 * might_be_time_token --
 *
 *  This is used to tell when we've past the days portion of the time
 *  format and are now into the times portion.
 *
 *  The algorithm we employ is trivial -- all time tokens start with a
 *  digit, and none of the day tokens do.
 *
 *  ENTRY
 *     psz -- points to comma-separated list of the rest of the tokens
 *
 *  RETURNS
 *     TRUE - first token in list might be a time token, and is
 *	  certainly not a day token.
 *     FALSE	- first token is not a time token.
 */

BOOL might_be_time_token(TCHAR FAR * psz)
{
    return ( _istdigit(*psz) );

}

/*
 *  is_single_day --
 *
 *  This is used to find out whether we have a single day, or a range of
 *   days.
 *
 *  Algorithm is simple here too -- just look for a hyphen.
 *
 *
 *  ENTRY
 *  psz -- points to the token in question
 *
 *  RETURNS
 *  TRUE	- this is a single day
 *  FALSE	- this is a range of days
 */

BOOL is_single_day(TCHAR FAR * psz)
{
    return (_tcschr(psz, MINUS) == NULL);

}


/*
 * parse_single_day --
 *
 *  This is used to map a name for a day into a value for that day.
 *  This routine encapsulates the localization for day names.
 *
 *  We look in 3 lists for a match --
 *  1. full names of days, localized by country
 *  2. abbrevations of days, localized
 *  3. full U.S. names of days, not localized
 *
 *  ENTRY
 *  psz     - name of day
 *
 *  EXIT
 *  day     - set to value of day (0 - 6, 0 = Sunday)
 *
 *  RETURNS
 *  0	    success
 *  otherwise	code describing problem
 */

DWORD
parse_single_day(
    LPTSTR psz,
    PDWORD day
    )
{

    if (ParseWeekDay(psz, day))
    {
	return APE_BadDayRange;
    }

    /*
     * ParseWeekDay returns with 0=Monday.  Convert to 0=Sunday;
     */
    *day = (*day + 1) % 7;

    return 0;
}


/*
 *  parse_day_range --
 *
 *  This function parses a range of days into two numbers representing
 *  the first and last days of the range.
 *
 *  ENTRY
 *  psz - token representing the range
 *
 *  EXIT
 *  first   - set to beginning of range
 *  last    - set to end of range
 *
 *  RETURNS
 *  0	    success
 *  otherwise	code describing problem
 */

DWORD
parse_day_range(
    LPTSTR psz,
    PDWORD first,
    PDWORD last
    )
{
    LPTSTR tok;
    DWORD  result;

#if DBG
    WriteToCon(TEXT("parse_day_range: parsing: %Fs\r\n"),(TCHAR FAR *) psz);
#endif

    tok = get_token(&psz, TEXT("-"));

    result = parse_single_day(tok, first);
    if (result)
	return result;
    result = parse_single_day(psz, last);

    return result;
}


/*
 * set_day_range --
 *
 *  This function fills in a WEEKLIST structure, setting all the days
 *  in the specified range to TRUE.
 *
 *  ENTRY
 *  first	- beginning of range
 *  last	- end of range
 *
 *  EXIT
 *  week	- set to represent range of days
 */

VOID
set_day_range(
    DWORD    first,
    DWORD    last,
    WEEKLIST week
    )
{
#if DBG
    WriteToCon(TEXT("set_day_range: %u %u\r\n"), first, last);
#endif

    if (last < first) {
	while (last > 0)
	    week[last--] = TRUE;
	week[last] = TRUE;
	last = 6;
    }

    while (first <= last)
	week[first++] = TRUE;

}


/*
 * map_days_times --
 *
 *  This is a real workhorse function. Given a set of days and a set of
 *  times in a day, this function will "logical or" in those times on those
 *  days into the week structure.
 *
 *  ENTRY
 *  days	- days of the week
 *  times	- hours in the day
 *  week	- may contain previous data
 *
 *  EXIT
 *  week	- contains previous data, plus new times "or" ed in
 */

VOID
map_days_times(
    WEEKLIST days,
    DAY      *times,
    PUCHAR   week
    )
{
    int        i;
    int        j;
    ULONG      mytimes;

    for (i = 0; i < 7; ++i) {
	if (days[i]) {
	    mytimes = (*times);
	    for (j = 0; j < 3; ++j) {
		*(week++) |= mytimes & 0x000000FF;
	    mytimes >>= 8;
	    }
	}
	else
	    week += 3;  /* skip this day */
    }
}



/*
 * parse_times --
 *
 *  This function takes a comma-separated list of hour ranges and maps them
 *  into a bitmap of hours in a day.
 *
 *  ENTRY
 *  psz - string to parse
 *
 *  EXIT
 *  times   - contains bitmap of hours represented by psz
 *
 *  RETURNS
 *  0	    success
 *  otherwise	code describing problem
 */

DWORD
parse_times(
    LPTSTR  psz,
    DAY     *times,
    LPDWORD lpdwStartTime,
    LPDWORD lpdwEndTime
    )
{
    DAY     part_times;
    LPTSTR  tok;
    DWORD   first;
    DWORD   last;
    DWORD   err;


#if DBG
    WriteToCon(TEXT("parse_times: parsing: %Fs\r\n"),(TCHAR FAR *) psz);
#endif

    *times = 0L;

    while ( (tok = get_token(&psz, TEXT(","))) != NULL)
    {
	if (err = parse_time_range(tok, &first, &last))
        {
            //
            // Fill in the start and end times in case the end time
            // is before the start time.  If that's the case, we'll
            // treat the range as wrapping days and deal with it
            // in parse_days_times.
            //
            *lpdwStartTime = first;
            *lpdwEndTime = last;

	    return err;
        }

	set_time_range( first, last, &part_times);
	(*times) |= part_times;
    }

    return 0;
}




/*
 * parse_time_range --
 *
 *  This function parses a time range into two numbers representing the
 *   starting and ending times of the range.
 *
 *  ENTRY
 *  psz - string to parse
 *
 *  EXIT
 *  first   - beginning of range
 *  last    - end of range
 *
 *  RETURNS
 *  0	    success
 *  otherwise	code describing the problem
 */

DWORD
parse_time_range(
    LPTSTR  psz,
    PDWORD  first,
    PDWORD  last
    )
{
    LPTSTR  tok;
    DWORD   err;

#if DBG
    WriteToCon(TEXT("parse_time_range: parsing: %Fs\r\n"),(TCHAR FAR *) psz);
#endif

    tok = get_token(&psz,TEXT("-"));

    if (tok == NULL) {
        return APE_BadTimeRange;
    }

    if (*psz == NULLC) {
	/* only one time */
	if (err = parse_single_time(tok, first, TIME_FORMAT_EITHER))
	    return err;

	*last = (*first + 1) % 24 ;
    }
    else {
	if ((err = parse_single_time(tok, first, TIME_FORMAT_12)) == 0) {
	    if (err = parse_single_time(psz, last, TIME_FORMAT_12))
		return err;
	}
	else if ((err = parse_single_time(tok, first, TIME_FORMAT_24)) == 0) {
	    if (err = parse_single_time(psz, last, TIME_FORMAT_24))
		return err;
	}
	else
	    return err;
    }

    if ((*last) == 0)
	(*last) = 24;

    if ((*first) >= (*last))
	return APE_ReversedTimeRange;

    return 0;
}


/*
 * set_time_range --
 *  This routine maps a range of hours specified by two numbers into
 *   a bitmap.
 *
 *  ENTRY
 *  first	- beginning of range
 *  last	- end of range
 *
 *  EXIT
 *  times	- set to represent range of hours
 */


VOID
set_time_range(
    DWORD first,
    DWORD last,
    DAY   *times)
{
    DWORD bits;

#if DBG
    WriteToCon(TEXT("set_time_range: %u %u\r\n"), first, last);
#endif

    /* count the number of consecutive bits we need */
    bits = last - first;

    /* now put them at the low end of times */
    (*times) = (1L << bits) - 1;

    /* now move them into place */
    (*times) <<= first;
}




/*
 * parse_single_time --
 *
 *  This function converts a string representing an hour into a number
 *  for that hour. This function encapsulates all the localization for
 *  time formats.
 *
 *  ENTRY
 *  psz -- time to parse
 *
 *  EXIT
 *  time -- set to digit representing hour, midnight == 0
 *
 *  RETURNS
 *  0	    success
 *  otherwise	code describing problem
 */

DWORD
parse_single_time(
    LPTSTR  psz,
    PDWORD  hour,
    DWORD   format
    )
{
    time_t       time;
    DWORD        len, res ;
    struct tm    tmtemp;

    if (format == TIME_FORMAT_12)
	res = ParseTime12(psz, &time, &len,0) ;
    else if (format == TIME_FORMAT_24)
	res = ParseTime24(psz, &time, &len, 0) ;
    else
	res = ParseTime(psz, &time, &len, 0) ;

    if (res)
	return(APE_BadTimeRange) ;

    if (len != _tcslen(psz))
	return(APE_BadTimeRange) ;

    net_gmtime(&time, &tmtemp);
    if (tmtemp.tm_sec != 0 || tmtemp.tm_min != 0)
	return(APE_NonzeroMinutes);

    (*hour) = (DWORD) tmtemp.tm_hour;

    return 0;
}


/*
 * get_token --
 *
 *   This function strips a token off the front of the string, and
 *  returns a pointer to the rest of the string.
 *
 *  We act destructively on the string passed to us, converting the
 *  token delimiter to a \0.
 *
 *  ENTRY
 *  source	- source string
 *  seps	- list of valid separator characters
 *
 *  EXIT
 *  source	- points to first character of next token
 *
 *  RETURNS
 *  NULL	- no more tokens
 *  otherwise	- pointer to token
 */

LPTSTR
get_token(
    LPTSTR  *source,
    LPTSTR  seps
    )
{
    LPTSTR retval;

    retval = (*source);

    if (*retval == NULLC)    /* no tokens! */
	return NULL;

    (*source) += _tcscspn((*source), seps);

    if (**source != NULLC) { /* we actually found a separator */
	(**source) = NULLC;
	(*source)++;
    }

    return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\netcmd\user.c ===
/********************************************************************/
/**         Microsoft LAN Manager              **/
/**       Copyright(c) Microsoft Corp., 1987-1990      **/
/********************************************************************/

/***
 *  user.c
 *  Display/update user accounts at a server
 *
 *  History:
 *  mm/dd/yy, who, comment
 *  06/11/87, andyh, new code
 *  12/17/87, hongly, set old password "" instead of NULL
 *  10/31/88, erichn, uses OS2.H instead of DOSCALLS
 *  01/04/89, erichn, filenames now MAXPATHLEN LONG
 *  01/28/89, paulc, mods for 1.2
 *  04/20/89, paulc, add /OPERATOR switch
 *  05/01/89, chuckc, bug fixes, add /WORKSTATION, bring
 *            user_display to LM2.0 specs.
 *  05/02/89, erichn, NLS conversion
 *  05/09/89, erichn, local security mods
 *  05/19/89, erichn, NETCMD output sorting
 *  05/28/89, chuckc, /LOGONSERVER, /COUNTRYCODE, /PASSWORDCHG,
 *            net_ctime instead of ctime.
 *  06/08/89, erichn, canonicalization sweep
 *  06/23/89, erichn, auto-remoting to domain controller
 *  06/25/89, erichn, replaced old NetI canon calls with new I_Net;
 *            cleanup in get_logon_svr & get_wksta_list
 *  01/28/91, robdu, added lockout support (UF_LOCKOUT)
 *  02/15/91, danhi, converted to 16/32 mapping layer
 *  09/01/92, chuckc, cleanup to remove dead functionality (ie LOGONSERVER,
 *                    MAXSTORAGE)
 *  10/06/94, chuckc, added FPNW support.
 */

/*---- Include files ----*/
#include <nt.h>        // base definitions
#include <ntrtl.h>  
#include <nturtl.h>    // these 2 includes allows <windows.h> to compile.
                           // since we've already included NT, and <winnt.h> will
                           // not be picked up, and <winbase.h> needs these defs.
#include <ntsam.h>

#define INCL_NOCOMMON
#define INCL_DOSFILEMGR
#define INCL_ERRORS
#include <os2.h>
#include <lmcons.h>
#include <lmerr.h>
#include <lmapibuf.h>
#include <apperr2.h>
#include <apperr.h>
#define INCL_ERROR_H
#include <lmaccess.h>
#include <dlwksta.h>
#include "mwksta.h"
#include <timelib.h>
#include <lui.h>
#include <icanon.h>
#include <loghours.h>    // NetpRotateLogonHours
#include "netcmds.h"
#include "nettext.h"
#include "luidate.h"
#include <sam.h>
#include <tstring.h>

#include "nwsupp.h"

/*---- Constants ----*/

#define CHANGE  0
#define ADD 1
#define USERS_ALIAS TEXT("USERS")
#define DEFAULT_RANDOM_PASSWD_LEN  8
#define MAXWORKSTATIONS            8

#define MY_LIST_DELIMITER_STR_UI_NO_SPACE      L"\t;,"
#define MY_LIST_DELIMITER_STR_NULL_NULL        L""


/*---- Time stuff ----*/

#define SECS_PER_DAY (24*60*60L)
#define TIME_PAD     (SECS_PER_DAY * 10000L)
    /*  This is added to time-of-day to allow it to be passed to our
     *  ctime routine.  This routine rejects low dates as being
     *  before the millenia (1-1-80) since 0 is 1-1-70, and that is
     *  Before IBM PC.  So, we add this, which doesn't effect the
     *  time-of-day portion.
     */

/*---- Static variables ----*/

/*---- Forward declarations ----*/

void SamErrorExit(USHORT err) ;   // CODEWORK. move to netcmds.h
VOID NEAR user_munge(LPUSER_INFO_3 user_entry, int add, int *is_nw, int *random_len);
DWORD get_password_dates ( ULONG, ULONG *, ULONG *, ULONG *, TCHAR * );
VOID NEAR print_logon_hours ( DWORD, DWORD, UCHAR FAR [] );
int NEAR yes_or_no ( TCHAR *, TCHAR * );
int NEAR bitval ( UCHAR FAR [], int );
VOID NEAR print_times ( DWORD, LONG, LONG, unsigned int );
VOID print_aliases(TCHAR *controller,
                   DWORD fsz,
                   TCHAR *domain,
                   TCHAR *user,
                   TCHAR *fmt,
                   TCHAR *msgtext) ;
UCHAR FAR * NEAR set_logon_hours(TCHAR FAR *);
TCHAR * get_wksta_list(TCHAR *inbuf);
TCHAR FAR * get_country(DWORD code) ;
int __cdecl CmpUserInfo0(const VOID FAR *, const VOID FAR *) ;
int __cdecl CmpAlias(const VOID FAR * alias1, const VOID FAR * alias2) ;

DWORD add_to_users_alias(TCHAR *controller, TCHAR *domain, TCHAR *user) ;
void   GenerateRandomPassword(TCHAR *pword, int len) ;

DWORD LUI_ListPrepare(PTCHAR, PTCHAR, PTCHAR, USHORT, PULONG);


/*---- functions proper -----*/

/***
 *  user_add()
 *  Add a user to the accounts file on a server
 *
 *  Args:
 *  user - user to add
 *  pass - passwd for user
 *
 *  Returns:
 *  nothing - success
 *  exit 2 - command failed
 */
VOID
user_add(
    LPWSTR user,
    LPWSTR pass
    )
{
    static WCHAR       pword[PWLEN+1];
    USHORT             err;

    DWORD              dwErr;
    LPUSER_INFO_3      user_entry;
    WCHAR              controller[MAX_PATH+1];   /* DC name */
    DWORD              dwControllerLen = 0;
    WCHAR              domainname[DNLEN+1];
    int                isNetWareSwitch, random_len = 0  ;
    LPBYTE             pbLogonHours;

    //
    // Deprecate creation of users with SAM names
    // containing '@' to avoid fun with UPNs.
    //

    if (wcschr(user, L'@'))
    {
        ErrorExit(ERROR_BAD_USERNAME);
    }

    /* Register this as memory to zero out on exit.
     */
    AddToMemClearList(pword, sizeof(pword), FALSE) ;

    /* Initialize the user record.  All fields are zeroed, except those
     * specifically set to some other value.
     *
     *
     *  WARNING:  This assumes that ((TCHAR FAR *) NULL) == 0, since we
     *  are couting on memset to set a lot of things to the proper
     *  default, i.e. NULL pointer.
     */

    user_entry = (LPUSER_INFO_3) BigBuf;
    memset ( BigBuf, 0, sizeof(USER_INFO_3));

    /*  Set non-zero defaults.  Note that in some cases, the values assigned
     *  *may* be zero.  However, we are using manifests and shouldn't really
     *  know that the value is zero, so in the interests of safety we put the
     *  code here.  We are less careful with the NUMM manifest, as noted
     *  above.
     */

    user_entry->usri3_priv = USER_PRIV_USER;
    user_entry->usri3_flags = UF_SCRIPT;
    user_entry->usri3_acct_expires = TIMEQ_FOREVER; /* Never */
    user_entry->usri3_max_storage = USER_MAXSTORAGE_UNLIMITED;
    user_entry->usri3_full_name = TEXT("");
    user_entry->usri3_logon_server = SERVER_ANY;
    user_entry->usri3_primary_group_id = DOMAIN_GROUP_RID_USERS ;

    /*  Set username and password from the parameters to this function.
     */

    user_entry->usri3_name = user;

    if (pass == NULL)
    {
        user_entry->usri3_password = NULL;
    }
    else if (! _tcscmp(TEXT("*"), pass))
    {
        ReadPass(pword, PWLEN, 1, APE_UserUserPass, 0, TRUE);
        user_entry->usri3_password = pword;
    }
    else
    {
        if (err = LUI_CanonPassword(pass))
            ErrorExit(err);
        user_entry->usri3_password = pass;

        /*
         * NT4 and Win9x clients can't handle passwords longer than 14 (LM20_PWLEN) chars
         */
        if (user_entry->usri3_password != NULL && _tcslen( user_entry->usri3_password ) > 14)
        {
            if (!YorN(APE_UserPasswordCompatWarning, 1))
            {
                NetcmdExit(2);
            }
        }
    }




    /*  Set the other components of the record, using the switchs from the
     *  command line.
     */

    user_munge(user_entry, ADD, &isNetWareSwitch, &random_len);

    /*  If no password specified and /RANDOM is specified, use random password
     */
    if ((pass == NULL) && random_len)
    {
        GenerateRandomPassword(pword, random_len) ;
        user_entry->usri3_password = pword;
    }

    /*  Set the dummy NetWare password field
     */
    if (isNetWareSwitch == LUI_YES_VAL)
    {
        dwErr = SetNetWareProperties( user_entry,
                                      L"",      // dummy password
                                      TRUE,     // set password only
                                      FALSE ) ; // doesn't matter

        if (dwErr)
        {
            ErrorExit(APE_CannotSetNW);
        }
    }

    /*  Record is all set up, ADD IT.
     */

    /* find primary domain controller */
    if (dwErr = GetSAMLocation(controller, DIMENSION(controller),
                               domainname, DIMENSION(domainname),
                               TRUE))
    {
        ErrorExit(dwErr);
    }

    dwControllerLen = _tcslen(controller);

    pbLogonHours = ((LPUSER_INFO_3) BigBuf)->usri3_logon_hours;

    if (pbLogonHours != NULL
         &&
        !NetpRotateLogonHours(pbLogonHours,
                              UNITS_PER_WEEK,
                              TRUE))
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        dwErr = NetUserAdd(controller, 3, (LPBYTE) BigBuf, NULL);
    }

    switch (dwErr)
    {
        case NERR_Success:
            break;
        case ERROR_INVALID_PARAMETER:
            ErrorExit(APE_UserBadArgs);
            break;
        case ERROR_BAD_NETPATH:
            ErrorExitInsTxt(APE_DCNotFound, controller);
        default:
            ErrorExit(dwErr);
    }

    //
    // add the user to the USERS alias only if we are acting
    // on a WinNT machine (must be locally).
    //
    if ( (IsLocalMachineWinNT() == TRUE) &&
         (dwControllerLen == 0) )
    {
        dwErr = add_to_users_alias(controller,
                                   domainname,
                                   user_entry->usri3_name);
        if (dwErr)
        {
            ErrorPrint(dwErr,0);
            ErrorExit(APE_UserFailAddToUsersAlias) ;
        }
    }

    //
    // This has been specified as NetWare user. set NetWare properties
    // Note we add the user first so that the RID is defined before we can
    // perform this step.
    //
    if (isNetWareSwitch == LUI_YES_VAL)
    {
        LPUSER_INFO_3  user_3_entry;
        BOOL           ntas;

        //
        // if local machine is NTAS or if /DOMAIN is specified, then
        // must be NTAS.
        //
        ntas = (!(IsLocalMachineWinNT() || IsLocalMachineStandard()) ||
                (dwControllerLen > 0)) ;

        //
        // retrieve the user parms & RID.  No need to rotate the user's
        // logon hours since SetNetWareProperties doesn't touch them.
        //
        dwErr = NetUserGetInfo(controller,
                               user,
                               3,
                               (LPBYTE*) &user_3_entry);
        if (dwErr)
        {
            ErrorExit(APE_CannotEnableNW);
        }

        //
        // munge the user proprties
        //
        dwErr = SetNetWareProperties(user_3_entry,
                                     user_entry->usri3_password,
                                     FALSE,    // new user, so set ALL
                                     ntas) ;

        if (dwErr)
        {
            ErrorExit(APE_CannotEnableNW);
        }

        //
        // now set it -- don't rotate the logon hours back to GMT time
        // since we didn't rotate them to local time above.
        //
        dwErr = NetUserSetInfo(controller,
                               user,
                               3,
                               (LPBYTE) user_3_entry,
                               NULL);

        if (dwErr)
        {
            ErrorExit(APE_CannotEnableNW);
        }
    }

    if ((pass == NULL) && random_len)
    {
        IStrings[0] = user ;
        IStrings[1] = pword ;
        InfoPrintIns(APE_RandomPassword, 2) ;
    }

    InfoSuccess();
}



/***
 *  user_del()
 *  Delete a user from the accounts file on a server
 *
 *  Args:
 *  user - user to delete
 *
 *  Returns:
 *  nothing - success
 *  exit 2 - command failed
 */
VOID user_del(TCHAR * user)
{
    DWORD            dwErr;
    TCHAR            controller[MAX_PATH+1];   /* domain controller */
    LPUSER_INFO_2    user_2_entry;

    /* find primary domain controller */
    if (dwErr = GetSAMLocation(controller, DIMENSION(controller),
                               NULL, 0, TRUE))
        ErrorExit(dwErr);

    /* check if its a machine account before we do it */
    dwErr = NetUserGetInfo(controller,
                           user,
                           2,
                           (LPBYTE *) &user_2_entry);

    if (dwErr == NERR_Success)
    {
        if (user_2_entry->usri2_flags & UF_MACHINE_ACCOUNT_MASK)
        {
            NetApiBufferFree((TCHAR FAR *) user_2_entry);
            ErrorExitInsTxt(APE_NoSuchUser,user) ;
        }
        NetApiBufferFree((TCHAR FAR *) user_2_entry);
    }

    // if cannot GetInfo(), carry on and let the UserDel fail.

    dwErr = NetUserDel(controller, user);

    switch (dwErr)
    {
        case NERR_Success:
            break;
        case ERROR_BAD_NETPATH:
            ErrorExitInsTxt(APE_DCNotFound, controller);
        default:
            ErrorExit(dwErr);
    }
    InfoSuccess();
}





/***
 *  user_change()
 *  Change data in a user's record
 *
 *  Args:
 *  user - user to change
 *  pass - user's new passwd
 *
 *  Returns:
 *  nothing - success
 *  exit 2 - command failed
 */
VOID user_change(TCHAR * user, TCHAR * pass)
{
    static TCHAR       pword[PWLEN+1];
    USHORT             err;

    DWORD              dwErr, dwErrNW = NERR_Success;
    LPUSER_INFO_3      user_entry;
    TCHAR                     controller[MAX_PATH+1];   /* domain controller */
    BOOL                      ntas ;
    BOOL                      already_netware = FALSE ;
    int                       isNetWareSwitch, random_len = 0 ;
    TCHAR                     dummyChar ;
    UNICODE_STRING            dummyUnicodeStr ;
    LPBYTE                    pbLogonHours;

    /* add this to list of mem to zero out on exit */
    pword[0] = 0 ;
    AddToMemClearList(pword, sizeof(pword), FALSE) ;

    /* munge switches once just to check them */
    user_entry = (LPUSER_INFO_3) BigBuf;
    user_munge(user_entry, CHANGE, &isNetWareSwitch, &random_len);

    /* find primary domain controller */
    if (dwErr = GetSAMLocation(controller, DIMENSION(controller),
                               NULL, 0, TRUE))
        ErrorExit(dwErr);

    dwErr = NetUserGetInfo(controller, user, 3, (LPBYTE *) &user_entry);

    if (dwErr == NERR_Success || dwErr == ERROR_MORE_DATA)
    {
        DWORD     dwUnitsPerWeek;

        //
        // Convert GMT relative logon hours to local time
        //
        pbLogonHours   = ((LPUSER_INFO_3) user_entry)->usri3_logon_hours;
        dwUnitsPerWeek = ((LPUSER_INFO_3) user_entry)->usri3_units_per_week;

        if (pbLogonHours != NULL)
        {
            if (!NetpRotateLogonHours(pbLogonHours,
                                      dwUnitsPerWeek,
                                      FALSE))
            {
                dwErr = NERR_InternalError;  // Since the info we got back is bad
            }
        }
    }

    switch (dwErr)
    {
        case NERR_Success:
            break;
        case ERROR_BAD_NETPATH:
            ErrorExitInsTxt(APE_DCNotFound, controller);
        default:
            ErrorExit(dwErr);
    }

    //
    // Set the password.
    //
    // If we actually change the password,
    //  mark it as no longer expired since we did just change it.
    //

    if (pass == NULL)
    {
        if (random_len)
        {
            GenerateRandomPassword(pword, random_len) ;
            user_entry->usri3_password = pword;
            user_entry->usri3_password_expired = FALSE;
        }
        else
        {
            user_entry->usri3_password = NULL;
        }
    }
    else if (! _tcscmp(TEXT("*"), pass))
    {
        ReadPass(pword, PWLEN, 1, APE_UserUserPass, 0, TRUE);
        user_entry->usri3_password = pword;
        user_entry->usri3_password_expired = FALSE;
    }
    else
    {
        if (err = LUI_CanonPassword(pass))
            ErrorExit(err);
        user_entry->usri3_password = pass;
        user_entry->usri3_password_expired = FALSE;
        _tcscpy(pword, pass);
    }

    user_munge(user_entry, CHANGE, NULL, NULL);

    //
    // if local machine is NTAS or if /DOMAIN is specified, then
    // must be NTAS.
    //
    ntas = (!(IsLocalMachineWinNT() || IsLocalMachineStandard()) ||
            (_tcslen(controller) > 0)) ;


    //
    // query the NW passwd to see if user is already NW enabled.
    //
    if (NT_SUCCESS(NetcmdQueryUserProperty(user_entry->usri3_parms,
                                           NWPASSWORD,
                                           &dummyChar,
                                           &dummyUnicodeStr)) &&
        dummyUnicodeStr.Buffer != NULL)
    {
        already_netware = TRUE ;
        LocalFree(dummyUnicodeStr.Buffer) ;
    }

    //
    // check if /NW is specified
    //
    if (isNetWareSwitch == LUI_YES_VAL)
    {
        if (!pass && !random_len)  // no password specified
        {
            if (!already_netware)
            {
                //
                // NW specified, no NW passwd yet, need prompt for one
                //
                ReadPass(pword, PWLEN, 1, APE_UserUserPass, 0, TRUE);
                user_entry->usri3_password = pword;
                dwErrNW = SetNetWareProperties(user_entry,
                                               pword,
                                               FALSE, // set all, since first time
                                               ntas) ;
            }
            else
            {
                // no new passwd specified, already NW, nothing more to do
            }
        }
        else       // password specified on command line
        {
            if (!already_netware)
            {
                //
                // not NW user yet. so we need set the new properties.
                //
                dwErrNW = SetNetWareProperties(user_entry,
                                               pword,
                                               FALSE, // set all, since first time
                                               ntas) ;
            }
            else
            {
                //
                // already NW user. just set password
                //
                dwErrNW = SetNetWareProperties(user_entry,
                                               pword,
                                               TRUE,    // passwd only
                                               ntas) ;
            }
        }
    }
    else if (isNetWareSwitch == LUI_UNDEFINED_VAL)   // no change
    {
        if (pass && already_netware)
        {
            //
            // already NW user, so we need set NW password to match NT one.
            //
            dwErrNW = SetNetWareProperties(user_entry,
                                           pword,
                                           TRUE,    // passwd only
                                           ntas) ;
        }
        else
        {
            // in all other cases, it is of no interest to FPNW.
        }
    }
    else    // disable NetWare
    {
        if (already_netware)
        {
            dwErrNW = DeleteNetWareProperties(user_entry) ;
        }
        else
        {
            // no-op
        }
    }

    //
    // finally, set the info -- convert the logon hours to
    // GMT relative first.
    //
    pbLogonHours = ((LPUSER_INFO_3) user_entry)->usri3_logon_hours;

    if (pbLogonHours != NULL
         &&
        !NetpRotateLogonHours(pbLogonHours,
                              UNITS_PER_WEEK,
                              TRUE))
    {
        dwErr = ERROR_INVALID_PARAMETER;
    }
    else
    {
        dwErr = NetUserSetInfo(controller, user, 3, (LPBYTE) user_entry, NULL);
    }

    switch (dwErr)
    {
        case NERR_Success:
            break;
        case ERROR_BAD_NETPATH:
            ErrorExitInsTxt(APE_DCNotFound, controller);
        default:
            ErrorExit(dwErr);
    }

    NetApiBufferFree((TCHAR FAR *) user_entry);

    if (dwErrNW)
    {
        ErrorExit(APE_CannotSetNW) ;
    }
    else
    {
        if ((pass == NULL) && random_len)
        {
            IStrings[0] = user ;
            IStrings[1] = pword ;
            InfoPrintIns(APE_RandomPassword, 2) ;
        }
        InfoSuccess();
    }
}


/***
 *  user_enum()
 *  Display info about all user accounts on a server
 *
 *  Args:
 *  none
 *
 *  Returns:
 *  nothing - success
 *  exit 1 - command completed with errors
 *  exit 2 - command failed
 */
VOID
user_enum(
    VOID
    )
{
    DWORD               dwErr;
    DWORD               cTotalAvail;
    TCHAR FAR *         pBuffer;
    DWORD               num_read;       /* num entries read by API */
    DWORD               i, j;
    int                 t_err = 0;
    int                 more_data = FALSE;
    TCHAR               localserver[MAX_PATH+1];
    LPUSER_INFO_0       user_entry;
    LPWKSTA_INFO_10     wksta_entry;
    TCHAR               controller[MAX_PATH+1];   /* domain controller */
    LPTSTR              pszTmp;


    /* get localserver name for display */
    if (dwErr = MNetWkstaGetInfo(10, (LPBYTE *) &wksta_entry))
    {
        t_err = TRUE;
        *localserver = NULLC;
    }
    else
    {
        _tcscpy(localserver, wksta_entry->wki10_computername);
        NetApiBufferFree((LPTSTR) wksta_entry);
    }

    if (dwErr = GetSAMLocation(controller, DIMENSION(controller),
                               NULL, 0, FALSE))
    {
        ErrorExit(dwErr);
    }

    dwErr = NetUserEnum(controller,
                        0,
                        UF_NORMAL_ACCOUNT | UF_TEMP_DUPLICATE_ACCOUNT,
                        (LPBYTE*)&pBuffer,
                        MAX_PREFERRED_LENGTH,
                        &num_read,
                        &cTotalAvail,
                        NULL);

    if( dwErr == ERROR_MORE_DATA )
        more_data = TRUE;
    else if( dwErr )
        ErrorExit(dwErr);

    if (num_read == 0)
        EmptyExit();

    qsort(pBuffer, num_read, sizeof(USER_INFO_0), CmpUserInfo0);

    PrintNL();
    InfoPrintInsTxt(APE_UserAccounts,
                    controller[0] ? controller + _tcsspn(controller, TEXT("\\")) :
                        localserver);
    PrintLine();

    for (i = 0, j = 0, user_entry = (LPUSER_INFO_0) pBuffer;
         i < num_read;
         i++, j++, user_entry++)
    {
        // filter out computer accounts
        pszTmp = _tcsrchr(user_entry->usri0_name,DOLLAR);
        if (pszTmp && (_tcslen(pszTmp) == 1))
        {
            j-- ;
            continue ;
        }


        WriteToCon(TEXT("%Fws"), PaddedString(25,user_entry->usri0_name,NULL));
        if (((j + 1) % 3) == 0)
            PrintNL();
    }
    NetApiBufferFree(pBuffer);
    if ((j % 3) != 0)
        PrintNL();
    if (t_err)
    {
        InfoPrint(APE_CmdComplWErrors);
        NetcmdExit(1);
    }
    else if( more_data )
    {
        InfoPrint(APE_MoreData);
        NetcmdExit(1);
    }
    else
        InfoSuccess();
    return;
}


/***
 *  CmpUserInfo0(user1,user2)
 *
 *  Compares two USER_INFO_0 structures and returns a relative
 *  lexical value, suitable for using in qsort.
 *
 */

int __cdecl CmpUserInfo0(const VOID FAR * user1, const VOID FAR * user2)
{
    INT n;
    n = CompareStringW( GetUserDefaultLCID(),
                        NORM_IGNORECASE,
                        (LPCWSTR)((LPUSER_INFO_0) user1)->usri0_name,
                        (int)-1,
                        (LPCWSTR)((LPUSER_INFO_0) user2)->usri0_name,
                        (int)-1);
    n -= 2;

    return n;
}

/***
 *  user_display()
 *  Display info about a user
 *
 *  Args:
 *  user - name of user to display
 *
 *  Returns:
 *  nothing - success
 *  exit 1 - command completed with errors
 *  exit 2 - command failed
 */

/* The following manifests are used to print the messages. */

#define UDMN_NAME       0
#define UDMN_FULLNAME       (UDMN_NAME+1)
#define UDMN_COMMENT        (UDMN_FULLNAME+1)
#define UDMN_USRCOMMENT     (UDMN_COMMENT+1)
#define UDMN_PARMS      (UDMN_USRCOMMENT+1)
#define UDMN_CCODE      (UDMN_PARMS+1)
#define UDMN_PRIV       (UDMN_CCODE+1)
#define UDMN_OPRIGHTS       (UDMN_PRIV+1)
#define UDMN_ENABLED        (UDMN_OPRIGHTS+1)
#define UDMN_EXPIRES        (UDMN_ENABLED+1)
#define UDMN_PWSET      (UDMN_EXPIRES+1)
#define UDMN_PWEXP      (UDMN_PWSET+1)
#define UDMN_PWCHG      (UDMN_PWEXP+1)
#define UDMN_WKSTA      (UDMN_PWCHG+1)
#define UDMN_PROFILEPATH        (UDMN_WKSTA+1)
#define UDMN_ALIASES       (UDMN_PROFILEPATH+1)
#define UDMN_LOGONSCRIPT    (UDMN_ALIASES+1)
#define UDMN_HOMEDIR        (UDMN_LOGONSCRIPT+1)
#define UDMN_LASTON     (UDMN_HOMEDIR+1)
#define UDMN_GROUPS     (UDMN_LASTON+1)
#define UDMN_LOGONHRS       (UDMN_GROUPS+1)
#define UDMN_PWREQ      (UDMN_LOGONHRS+1)
#define UDMN_PWUCHNG        (UDMN_PWREQ+1)

static MESSAGE msglist[] = {
    {   APE2_USERDISP_USERNAME,     NULL },
    {   APE2_USERDISP_FULLNAME,     NULL },
    {   APE2_USERDISP_COMMENT,      NULL },
    {   APE2_USERDISP_USRCOMMENT,   NULL },
    {   APE2_USERDISP_PARMS,        NULL },
    {   APE2_USERDISP_COUNTRYCODE,  NULL },
    {   APE2_USERDISP_PRIV,     NULL },
    {   APE2_USERDISP_OPRIGHTS,     NULL },
    {   APE2_USERDISP_ACCENABLED,   NULL },
    {   APE2_USERDISP_ACCEXP,       NULL },
    {   APE2_USERDISP_PSWDSET,      NULL },
    {   APE2_USERDISP_PSWDEXP,      NULL },
    {   APE2_USERDISP_PSWDCHNG,     NULL },
    {   APE2_USERDISP_WKSTA,        NULL },
    {   APE2_USERDISP_PROFILE,      NULL },
    {   APE2_USERDISP_ALIASES,      NULL },
    {   APE2_USERDISP_LOGONSCRIPT,  NULL },
    {   APE2_USERDISP_HOMEDIR,      NULL },
    {   APE2_USERDISP_LASTLOGON,    NULL },
    {   APE2_USERDISP_GROUPS,       NULL },
    {   APE2_USERDISP_LOGHOURS,     NULL },
    {   APE2_USERDISP_PSWDREQ,      NULL },
    {   APE2_USERDISP_PSWDUCHNG,    NULL }  };

#define NUMUMSG (sizeof(msglist)/sizeof(msglist[0]))


#define UDVT_YES        0
#define UDVT_NO         1
#define UDVT_UNLIMITED      2
#define UDVT_ALL        3
#define UDVT_UNKNOWN        4
#define UDVT_NEVER      5
#define UDVT_NONE       6
#define UDVT_ANY        7
#define UDVT_DC     8
#define UDVT_LOCKED 9
#define UDVT_NEVER_EXPIRED 10
#define UDVT_NEVER_LOGON   11

static MESSAGE valtext[] = {
    {   APE2_GEN_YES,           NULL },
    {   APE2_GEN_NO,            NULL },
    {   APE2_GEN_UNLIMITED,     NULL },
    {   APE2_GEN_ALL,           NULL },
    {   APE2_GEN_UNKNOWN,       NULL },
    {   APE2_GEN_NEVER,         NULL },
    {   APE2_GEN_NONE,          NULL },
    {   APE2_GEN_ANY,           NULL },
    {   APE2_USERDISP_LOGONSRV_DC,  NULL },
    {   APE2_USERDISP_LOCKOUT,   NULL },
    {   APE2_NEVER_EXPIRED,     NULL },
    {   APE2_NEVER_LOGON,     NULL },
    };


#define NUMVT (sizeof(valtext)/sizeof(valtext[0]))

static MESSAGE weekday_text[] = {
    {   APE2_GEN_SUNDAY,        NULL },
    {   APE2_GEN_MONDAY,        NULL },
    {   APE2_GEN_TUESDAY,       NULL },
    {   APE2_GEN_WEDNSDAY,      NULL },
    {   APE2_GEN_THURSDAY,      NULL },
    {   APE2_GEN_FRIDAY,        NULL },
    {   APE2_GEN_SATURDAY,      NULL },
    };

#define NUMWKT (sizeof(weekday_text)/sizeof(weekday_text[0]))

VOID user_display(TCHAR * user)
{
    DWORD                    dwErr;
    DWORD                    cTotalAvail;
    TCHAR FAR *              pBuffer;
    DWORD                    num_read;   /* num entries read by API */
    DWORD                    i, fsz;
    int                      t_err = 0;
    LPUSER_INFO_3            user_3_entry;
    LPGROUP_INFO_0           group_entry;
    ULONG                    pw_mod, pw_exp, pw_chg;
    ULONG                    last_logon, acct_expires ;
    static TCHAR             fmt2[] = TEXT("%-*.*ws");
    TCHAR                    ctime_buf[MAX_DATE_TIME_LEN];
    LPTSTR                   usrdisab_textptr;
    LPTSTR                   usrwksta_textptr;
    LPTSTR                   usrpwreq_textptr;
    LPTSTR                   usrpwuchng_textptr;
    LPTSTR                   usrcountry_textptr ;
    LPTSTR                   ptr;        /* Temp ptr */
    DWORD                    maxmsglen, dummy;
    TCHAR                    controller[MAX_PATH+1]; /* DC name */
    TCHAR                    domainname[DNLEN+1];
    TCHAR                    dummyChar ;
    UNICODE_STRING           dummyUnicodeStr ;

    /* determine where to make the API call */
    if (dwErr = GetSAMLocation(controller, DIMENSION(controller),
                               domainname, DIMENSION(domainname),
                               FALSE))
    {
         ErrorExit(dwErr);
    }

    dwErr = NetUserGetInfo(controller,
                           user,
                           3,
                           (LPBYTE *) &user_3_entry);

    if (dwErr == NERR_Success || dwErr == ERROR_MORE_DATA)
    {
        LPBYTE  pbLogonHours;
        DWORD   dwUnitsPerWeek;

        //
        // Convert GMT relative logon hours to local time
        //
        pbLogonHours   = ((LPUSER_INFO_3) user_3_entry)->usri3_logon_hours;
        dwUnitsPerWeek = ((LPUSER_INFO_3) user_3_entry)->usri3_units_per_week;

        if (pbLogonHours != NULL)
        {
            if (!NetpRotateLogonHours(pbLogonHours,
                                      dwUnitsPerWeek,
                                      FALSE))
            {
                dwErr = NERR_InternalError;    // Since the info we got back is bad
            }
        }
    }

    if (dwErr != NERR_Success)
    {
        ErrorExit(dwErr);
    }

    if (user_3_entry->usri3_flags & UF_MACHINE_ACCOUNT_MASK)
    {
        ErrorExitInsTxt(APE_NoSuchUser,user);
    }

    GetMessageList(NUMUMSG, msglist, &maxmsglen);
    fsz = maxmsglen + 5;
    GetMessageList(NUMVT, valtext, &dummy);
    GetMessageList(NUMWKT, weekday_text, &dummy);

    /*  Text for workstations.  This sets usrwksta_textptr to point
     *  either to the list, or to the word "All", which is retrieved
     *  from a message file.
     */

    if (_tcslen(user_3_entry->usri3_workstations) == 0)
        usrwksta_textptr = valtext[UDVT_ALL].msg_text;
    else
        usrwksta_textptr = (TCHAR FAR *) user_3_entry->usri3_workstations;

    /*  Determine which message to fetch for account state,
     *  passwd required, user may change password.
     */

    /* The account is listed as inactive if it is either disabled or locked */

    if ( user_3_entry->usri3_flags & UF_ACCOUNTDISABLE )
        usrdisab_textptr = valtext[UDVT_NO].msg_text;
    else if ( user_3_entry->usri3_flags & UF_LOCKOUT )
        usrdisab_textptr = valtext[UDVT_LOCKED].msg_text;
    else
        usrdisab_textptr = valtext[UDVT_YES].msg_text;

    usrpwreq_textptr = (user_3_entry->usri3_flags & UF_PASSWD_NOTREQD) ?
     valtext[UDVT_NO].msg_text : valtext[UDVT_YES].msg_text;
    usrpwuchng_textptr = (user_3_entry->usri3_flags & UF_PASSWD_CANT_CHANGE) ?
     valtext[UDVT_NO].msg_text : valtext[UDVT_YES].msg_text;

    /*  Now get the country code */
    usrcountry_textptr = get_country(user_3_entry->usri3_country_code);


    /*  Finally ... display the user's info */

    WriteToCon(fmtPSZ, 0, fsz,
            PaddedString(fsz, msglist[UDMN_NAME].msg_text, NULL),
            (TCHAR FAR *) user_3_entry->usri3_name);
    WriteToCon(fmtPSZ, 0, fsz,
            PaddedString(fsz, msglist[UDMN_FULLNAME].msg_text, NULL),
            (TCHAR FAR *) user_3_entry->usri3_full_name);
    WriteToCon(fmtPSZ, 0, fsz,
            PaddedString(fsz, msglist[UDMN_COMMENT].msg_text, NULL),
            (TCHAR FAR *) user_3_entry->usri3_comment);
    WriteToCon(fmtPSZ, 0, fsz,
            PaddedString(fsz, msglist[UDMN_USRCOMMENT].msg_text, NULL),
            (TCHAR FAR *) user_3_entry->usri3_usr_comment);
    WriteToCon(fmtPSZ, 0, fsz,
            PaddedString(fsz, msglist[UDMN_CCODE].msg_text, NULL),
            (TCHAR FAR *) usrcountry_textptr);
    WriteToCon(fmtPSZ, 0, fsz,
            PaddedString(fsz, msglist[UDMN_ENABLED].msg_text, NULL),
            (TCHAR FAR *) usrdisab_textptr);
    if ((acct_expires = user_3_entry->usri3_acct_expires) != TIMEQ_FOREVER)
    {
        UnicodeCtime ( &acct_expires, ctime_buf, DIMENSION(ctime_buf) );
        ptr = (TCHAR FAR *) ctime_buf ;
        WriteToCon(fmtPSZ, 0, fsz,
           PaddedString(fsz,msglist[UDMN_EXPIRES].msg_text,NULL),
           ptr );
    }
    else
    {
        ptr = valtext[UDVT_NEVER_EXPIRED].msg_text;
        WriteToCon(fmtPSZ, 0, fsz,
           PaddedString(fsz,msglist[UDMN_EXPIRES].msg_text,NULL),
           ptr );
    }

    PrintNL();

    if (dwErr = get_password_dates (  user_3_entry->usri3_password_age,
                    &pw_mod, &pw_exp, &pw_chg, controller ))
        ErrorExit(dwErr);

    UnicodeCtime ( &pw_mod, ctime_buf, DIMENSION(ctime_buf) );
    WriteToCon(fmtPSZ, 0, fsz,
               PaddedString(fsz,msglist[UDMN_PWSET].msg_text,NULL),
               (TCHAR FAR *) ctime_buf);

    if ( (user_3_entry->usri3_flags & UF_DONT_EXPIRE_PASSWD)
         || (pw_exp == TIMEQ_FOREVER))
    {
        ptr = valtext[UDVT_NEVER_EXPIRED].msg_text;
        WriteToCon(fmtPSZ, 0, fsz,
           PaddedString(fsz, msglist[UDMN_PWEXP].msg_text, NULL),
           ptr );
    }
    else
    {
        UnicodeCtime ( &pw_exp, ctime_buf, DIMENSION(ctime_buf) );
        ptr = (TCHAR FAR *) ctime_buf ;
        WriteToCon(fmtPSZ, 0, fsz,
           PaddedString(fsz, msglist[UDMN_PWEXP].msg_text, NULL),
           ptr );
    }

    if (pw_chg != TIMEQ_FOREVER)
    {
        UnicodeCtime ( &pw_chg, ctime_buf, DIMENSION(ctime_buf) );
        ptr = (TCHAR FAR *) ctime_buf ;
        WriteToCon(fmtPSZ, 0, fsz,
           PaddedString(fsz, msglist[UDMN_PWCHG].msg_text, NULL),
           ptr );
    }
    else
    {
        ptr = valtext[UDVT_NEVER_EXPIRED].msg_text;
        WriteToCon(fmtPSZ, 0, fsz,
           PaddedString(fsz, msglist[UDMN_PWCHG].msg_text, NULL),
           ptr );
    }
    WriteToCon(fmtPSZ, 0, fsz,
            PaddedString(fsz, msglist[UDMN_PWREQ].msg_text, NULL),
            usrpwreq_textptr );
    WriteToCon(fmtPSZ, 0, fsz,
            PaddedString(fsz, msglist[UDMN_PWUCHNG].msg_text, NULL),
            usrpwuchng_textptr );

    PrintNL();

    WriteToCon(fmtPSZ, 0, fsz,
            PaddedString(fsz, msglist[UDMN_WKSTA].msg_text, NULL),
            (TCHAR FAR *) usrwksta_textptr );
    WriteToCon(fmtPSZ, 0, fsz,
            PaddedString(fsz, msglist[UDMN_LOGONSCRIPT].msg_text, NULL),
            (TCHAR FAR *) user_3_entry->usri3_script_path);
    WriteToCon(fmtPSZ, 0, fsz,
            PaddedString(fsz, msglist[UDMN_PROFILEPATH].msg_text, NULL),
            (TCHAR FAR *) user_3_entry->usri3_profile);
    WriteToCon(fmtPSZ, 0, fsz,
            PaddedString(fsz, msglist[UDMN_HOMEDIR].msg_text, NULL),
            (TCHAR FAR *) user_3_entry->usri3_home_dir);
    if ((last_logon = user_3_entry->usri3_last_logon) > 0)
    {
        UnicodeCtime ( &last_logon, ctime_buf, DIMENSION(ctime_buf) );
        ptr = (TCHAR FAR *) ctime_buf ;
        WriteToCon(fmtPSZ, 0, fsz,
           PaddedString(fsz, msglist[UDMN_LASTON].msg_text, NULL),
           ptr );
    }
    else
    {
        ptr = valtext[UDVT_NEVER_LOGON].msg_text;
        WriteToCon(fmtPSZ, 0, fsz,
           PaddedString(fsz, msglist[UDMN_LASTON].msg_text, NULL),
           ptr );
    }

    if (NT_SUCCESS(NetcmdQueryUserProperty(user_3_entry->usri3_parms,
                                           NWPASSWORD,
                                           &dummyChar,
                                           &dummyUnicodeStr)) &&
        dummyUnicodeStr.Buffer != NULL)
    {
        TCHAR   NWString[256] ;
        NWString[0] = NULLC ;
        LUI_GetMsg(NWString, DIMENSION(NWString), APE_NWCompat) ;
        WriteToCon(fmtPSZ, fsz, fsz, msglist[UDMN_PARMS].msg_text, NWString );
        LocalFree(dummyUnicodeStr.Buffer) ;
    }

    PrintNL();

    print_logon_hours ( fsz,
            user_3_entry->usri3_units_per_week,
            user_3_entry->usri3_logon_hours );

    PrintNL();

    /*  WARNING:  The next call frees the user record buffer, After this
     *  point we cannot reference the user record in user_3_entry.
     */

    NetApiBufferFree((TCHAR FAR *) user_3_entry);

    /* Display the aliases this guy is a member of
     */
    print_aliases(controller, fsz, domainname, user, fmt2, msglist[UDMN_ALIASES].msg_text );

    /* Display groups
     */
    if (dwErr = NetUserGetGroups(
                  controller,
                  user,
                  0,
                  (LPBYTE*)&pBuffer,
                  MAX_PREFERRED_LENGTH,
                  &num_read,
                  &cTotalAvail))
        t_err = TRUE;
    else
    {
    /*  Print group names.  The local var gpl is groups-per-line,
     *  and is 1 or 2, depending on the scale of "fsz".  We print
     *  a newline and padding every "gpl" groups.  However, there
     *  is NO padding on the first (0) group, since the item label
     *  has been placed there already.
     */

        int gpl;

        gpl = (fsz > 30 ? 1 : 2);
        group_entry = (LPGROUP_INFO_0) pBuffer;

        WriteToCon(fmt2, 0, fsz,
           PaddedString(fsz, msglist[UDMN_GROUPS].msg_text ,NULL));

        for (i = 0; i < num_read; i++, group_entry++)
        {
            /* Pad if needed */
            if ((i != 0) && ((i % gpl) == 0))
                WriteToCon(fmt2, fsz, fsz, NULL_STRING );
            WriteToCon(TEXT("*%Fws"), PaddedString(21, group_entry->grpi0_name, NULL));
            /* If end of line, put out newline */
            if (((i + 1) % gpl) == 0)
                PrintNL();
        }

        /*  If ended on an "odd number" end the line.  Note that this
         *  is only needed where gpl is not 1.
         */

        if ((i == 0) || ((gpl > 1) && ((i % gpl) != 0)))
            PrintNL();
    }

    NetApiBufferFree(pBuffer);
    if (t_err)
    {
        InfoPrint(APE_CmdComplWErrors);
        NetcmdExit(1);
    }
    else
        InfoSuccess();
}


/***  print_logon_hours -- Print logon hours from user record
 *
 *  Parameters:
 *
 *  fsz     Format size for use with fmtPSZ
 *  upw     Units per week
 *  hrptr       Pointer to hours bitmap
 *
 *  Returns:
 *
 *  Nothing.  Exits in case of fatal error.
 *
 *  Globals:
 *
 *  Accesses text in valtext[] and msglist[], which must be
 *  set up prior to calling this function.  Currently these are
 *  initialized in user_display().
 *
 *  Accesses fmtPSZ for formatting output.
 */

VOID NEAR print_logon_hours ( DWORD fsz, DWORD upw,
    UCHAR FAR hrptr[] )
{
    TCHAR *      msgtext = NULL;
    LONG        timeinc, start_time, end_time;
    unsigned int    bv, bitno;
    unsigned int    first = 1;
    DWORD    upd;        /* Units per day */


#ifdef DEBUG
    WriteToCon(TEXT("hptr is %Fp\r\n"), hrptr);
    brkpt();
#endif

    /* NULL pointer means default, which is "all hours" */

    if (hrptr == NULL)
    {
        WriteToCon(fmtPSZ, 0, fsz,
            PaddedString(fsz, msglist[UDMN_LOGONHRS].msg_text, NULL),
            (TCHAR FAR *) valtext[UDVT_ALL].msg_text );
        return;
    }


#ifdef DEBUG
    WriteToCon(TEXT("UPW is %u, UPD is %u\r\n"), upw, upd);
#endif

    if (upw == 0 || (upw % 7) != 0)
        ErrorExit(APE_UserBadUPW);

    upd = upw / 7;

    if ((upd % 24) != 0)
        ErrorExit(APE_UserBadUPW);

    if ((upd / 24) > 6)
        ErrorExit(APE_UserBadUPW);

    timeinc = SECS_PER_DAY / upd;   /* Time per bit in seconds */

#ifdef DEBUG
    WriteToCon(TEXT("timeinc is %ld\r\n"), timeinc);
#endif

    for (bitno=0; bitno<upw; bitno++)
    {
        bv = bitval(hrptr,bitno);
        if (bv)
        {
            start_time = timeinc * bitno;
            while (bv != 0 && bitno < upw)
            {
                bitno++;
                if (bitno < upw)
                    bv = bitval(hrptr,bitno);
            }
            end_time = timeinc * bitno;

            if (start_time == 0 && bitno >= upw)
                WriteToCon(fmtPSZ, 0, fsz,
                    PaddedString(fsz, msglist[UDMN_LOGONHRS].msg_text, NULL),
                    (TCHAR FAR *) valtext[UDVT_ALL].msg_text );
            else
                print_times(fsz, start_time, end_time, first);
                first = 0;
        }
    }

    if (first)
        WriteToCon(fmtPSZ, 0, fsz,
            PaddedString(fsz, msglist[UDMN_LOGONHRS].msg_text, NULL),
            (TCHAR FAR *) valtext[UDVT_NONE].msg_text );

    return;
}

/***  print_times   -- Print a range of times
 *
 *  Parameters:
 *
 *  fsz     Format size for left margin text
 *  upw     Units per week
 *  hrptr       Pointer to hours bitmap
 *  first       TRUE if first call to print_times
 *
 *  Returns:
 *
 *  Nothing.  Exits in case of fatal error.
 *
 *  Globals:
 *
 *  Accesses text in valtext[] and msglist[], which must be
 *  set up prior to calling this function.  Currently these are
 *  initialized in user_display().
 *
 *  Accesses ud_fmt4[] for formatting output.
 */

VOID NEAR print_times ( DWORD fsz, LONG start, LONG end,
    unsigned int first )
{
    ULONG   time;
    ULONG   GmtTime ;
    LPTSTR  day_text;
    LPTSTR  time_text;
    LPTSTR  left_text = TEXT("");
    int     day_1, day_2;
    TCHAR   ctime_buf[MAX_DATE_TIME_LEN];

    /* use PaddedString rather than left justify formatting */
    static TCHAR prtmfmt_1[] = TEXT("%ws%ws%Fws -");
    static TCHAR prtmfmt_2[] = TEXT(" %ws");
    static TCHAR prtmfmt_3[] = TEXT("%Fws\r\n");



    day_1 = (int) (start / SECS_PER_DAY);
    day_text = weekday_text[day_1].msg_text;

    time = (start % SECS_PER_DAY) + TIME_PAD;
    NetpLocalTimeToGmtTime(time, &GmtTime) ;
#ifdef DEBUG
    WriteToCon(TEXT("start day %d time %ld\r\n"), day_1, GmtTime);
#endif
    UnicodeCtime ( &GmtTime, ctime_buf, DIMENSION(ctime_buf) );

    //
    // Skip leading spaces
    //
    time_text = ctime_buf;

    while (*time_text && *time_text == BLANK)
    {
        time_text++;
    }

    time_text = _tcschr(time_text, BLANK);

    if (first)
    {
        left_text = msglist[UDMN_LOGONHRS].msg_text;
    }

    /* use PaddedString rather than left justify formatting */
    WriteToCon ( prtmfmt_1, PaddedString(fsz, left_text, NULL), day_text, time_text );

    day_2 = (int) (end / SECS_PER_DAY) % 7 ;

    if (day_2 != day_1)
    {
        WriteToCon(prtmfmt_2,weekday_text[day_2].msg_text);
    }

    time = (end % SECS_PER_DAY) + TIME_PAD;
    NetpLocalTimeToGmtTime(time, &GmtTime) ;
#ifdef DEBUG
    WriteToCon(TEXT("end day %d time %ld\r\n"), day_2, GmtTime);
#endif
    UnicodeCtime ( &GmtTime, ctime_buf, DIMENSION(ctime_buf) );

    //
    // Skip leading spaces
    //
    time_text = ctime_buf;

    while (*time_text && *time_text == BLANK)
    {
        time_text++;
    }

    time_text = _tcschr(time_text, BLANK);
    WriteToCon(prtmfmt_3, time_text);

    return;
}


/***
 *  user_munge()
 *  Change the values in a USER_INFO_1 struct
 *
 *
 *  This function is called twice by user_change().  The first is to check
 *  the user input for mistakes, before we do any API calls that might
 *  fail.  The second time is to actually set the
 *  structures from what was passed on the command line.  This function
 *  could arguably be two seperate functions, but it was thought that having
 *  all the switch handling code in one place would be more maintainable,
 *  especially for NET USER, which has TONS of switches.  Also, keeping
 *  track of which switches were given, using flags or whatnot, would be
 *  ugly and require adding new flags with new switches.  So, we just call
 *  the wretched thing twice.  Expensive, but she's worth it.
 *
 *  When adding new switches, be careful not to break the loop flow
 *  (by adding continue statements, for example), as after each switch
 *  is processed, the colon that is replaced by a NULL in FindColon() is
 *  restored back to a colon for the next call.
 *
 *  Args:
 *  flag - ADD if we are adding a user, CHANGE if changing
 *  user_entry - pointer to user structure
 *
 *  Returns:
 *  nothing - success
 *  exit 2 - command failed
 */
VOID
user_munge(
    LPUSER_INFO_3  user_entry,
    int            flag,
    int            *is_nw,
    int            *random_len)
{
    int             i;
    TCHAR *          ptr;
    ULONG           type;

    /* init this to false if present */
    if (is_nw)
        *is_nw = LUI_UNDEFINED_VAL ;

    /* process /Switches */
    for (i = 0; SwitchList[i]; i++)
    {
    /* switches with no COLON */

        /* Skip the DOMAIN switch */
        if (! _tcscmp(SwitchList[i], swtxt_SW_DOMAIN))
            continue;

        if (! _tcscmp(SwitchList[i], swtxt_SW_ADD))
        {
            if (flag != ADD)
            ErrorExit(APE_InvalidSwitch);
            continue;
        }
        else if (! _tcscmp(SwitchList[i], swtxt_SW_USER_ACTIVE))
        {
            user_entry->usri3_flags &= ~(UF_ACCOUNTDISABLE | UF_LOCKOUT);
            continue;
        }
        else if (! _tcscmp(SwitchList[i], swtxt_SW_RANDOM))
        {
            if (random_len)
                *random_len = DEFAULT_RANDOM_PASSWD_LEN ;
            continue;
        }
        else if (! _tcscmp(SwitchList[i], swtxt_SW_NETWARE))
        {
            if (is_nw)
                *is_nw = LUI_YES_VAL ;
            continue;
        }

        /*  Switches which require the COLON.  Since this routine
         *  can be called twice, the colon must always be restored.
         *  FindColon() sets it to NULL; the end of this series of
         *  statements restores it.  DO NOT PUT ANY CONTINUE STATEMENTS
         *  IN THIS LOOP AFTER THE FINDCOLON CALL.
         */

        if (! (ptr = FindColon(SwitchList[i])))
            ErrorExit(APE_InvalidSwitchArg);

        if (! _tcscmp(SwitchList[i], swtxt_SW_USER_FULLNAME))
        {
            if (_tcslen(ptr) > LM20_MAXCOMMENTSZ)
                ErrorExitInsTxt(APE_CmdArgIllegal,swtxt_SW_USER_FULLNAME);
            user_entry->usri3_full_name = (TCHAR FAR *) ptr;
        }
        else if (! _tcscmp(SwitchList[i], swtxt_SW_USER_ENABLESCRIPT))
        {
            if (yes_or_no(ptr,swtxt_SW_USER_ENABLESCRIPT)) {
                user_entry->usri3_flags |= UF_SCRIPT;
            } else
                ErrorExit(APE_UserBadEnablescript) ;
        }
        else if (! _tcscmp(SwitchList[i], swtxt_SW_USER_HOMEDIR))
        {
            if( *ptr )
            {
                if (I_NetPathType(NULL, ptr, &type, 0L))
                    ErrorExitInsTxt(APE_CmdArgIllegal,swtxt_SW_USER_HOMEDIR);
                if ((type != ITYPE_PATH_ABSD) && (type != ITYPE_PATH_RELND)
                    && (type != ITYPE_UNC))
                    ErrorExitInsTxt(APE_CmdArgIllegal,swtxt_SW_USER_HOMEDIR);
            }

            user_entry->usri3_home_dir = (TCHAR FAR *) ptr;
        }
        else if (! _tcscmp(SwitchList[i], swtxt_SW_USER_PARMS))
        {
            user_entry->usri3_parms = (TCHAR FAR *) ptr;
        }
        else if (! _tcscmp(SwitchList[i], swtxt_SW_COMMENT))
        {
            if (_tcslen(ptr) > LM20_MAXCOMMENTSZ)
                ErrorExitInsTxt(APE_CmdArgIllegal,swtxt_SW_COMMENT);
            user_entry->usri3_comment = (TCHAR FAR *) ptr;
        }
        else if (! _tcscmp(SwitchList[i], swtxt_SW_USER_USERCOMMENT))
        {
            if (_tcslen(ptr) > LM20_MAXCOMMENTSZ)
                ErrorExitInsTxt(APE_CmdArgIllegal,swtxt_SW_USER_USERCOMMENT);
            user_entry->usri3_usr_comment = (TCHAR FAR *) ptr;
        }
        else if (! _tcscmp(SwitchList[i], swtxt_SW_USER_SCRIPTPATH))
        {
            if (ptr && (*ptr == 0))
                user_entry->usri3_script_path = (TCHAR FAR *) ptr;
            else
            {
                if ((I_NetPathType(NULL, ptr, &type, 0L) != 0) ||
                    (type != ITYPE_PATH_RELND))
                {
                    ErrorExitInsTxt(APE_CmdArgIllegal,swtxt_SW_USER_SCRIPTPATH);
                }
                user_entry->usri3_script_path = (TCHAR FAR *) ptr;
            }
        }
        else if (! _tcscmp(SwitchList[i], swtxt_SW_USER_PROFILEPATH))
        {
            if (ptr && (*ptr == 0))
                user_entry->usri3_profile = (TCHAR FAR *) ptr;
            else
            {
                if ((I_NetPathType(NULL, ptr, &type, 0L) != 0) ||
                    ((type != ITYPE_PATH_ABSD) && (type != ITYPE_UNC)))
                {
                    ErrorExitInsTxt(APE_CmdArgIllegal,
                                    swtxt_SW_USER_PROFILEPATH);
                }
                user_entry->usri3_profile = (TCHAR FAR *) ptr;
            }
        }
        else if (! _tcscmp(SwitchList[i], swtxt_SW_USER_ACTIVE))
        {
            if (yes_or_no(ptr,swtxt_SW_USER_ACTIVE))
                user_entry->usri3_flags &= (~(UF_ACCOUNTDISABLE | UF_LOCKOUT));
            else
                user_entry->usri3_flags |= UF_ACCOUNTDISABLE;
        }
        else if (! _tcscmp(SwitchList[i], swtxt_SW_NETWARE))
        {
            if (yes_or_no(ptr,swtxt_SW_NETWARE))
            {
                if (is_nw)
                    *is_nw = LUI_YES_VAL ;
            }
            else
            {
                if (is_nw)
                    *is_nw = LUI_NO_VAL ;
            }
        }
        else if (! _tcscmp(SwitchList[i], swtxt_SW_USER_PASSWORDREQ))
        {
            if (yes_or_no(ptr,swtxt_SW_USER_PASSWORDREQ))
                user_entry->usri3_flags &= (~ UF_PASSWD_NOTREQD);
            else
                user_entry->usri3_flags |= UF_PASSWD_NOTREQD;
        }
        else if (! _tcscmp(SwitchList[i], swtxt_SW_USER_PASSWORDCHG))
        {
            if (yes_or_no(ptr,swtxt_SW_USER_PASSWORDCHG))
                user_entry->usri3_flags &= (~ UF_PASSWD_CANT_CHANGE);
            else
                user_entry->usri3_flags |= UF_PASSWD_CANT_CHANGE;
        }
        else if (! _tcscmp(SwitchList[i], swtxt_SW_USER_TIMES))
        {
            user_entry->usri3_logon_hours = (PBYTE)set_logon_hours(ptr);
            user_entry->usri3_units_per_week = UNITS_PER_WEEK;
        }
        else if (! _tcscmp(SwitchList[i], swtxt_SW_USER_WORKSTATIONS))
        {
            /* if we got back ok, we know ptr returned is OK */
            user_entry->usri3_workstations = get_wksta_list(ptr);
        }
        else if (! _tcscmp(SwitchList[i], swtxt_SW_USER_COUNTRYCODE))
        {
            DWORD ccode ;
            ccode = do_atoul(ptr,APE_CmdArgIllegal,swtxt_SW_USER_COUNTRYCODE) ;
            if (get_country(ccode) == NULL)
            {
                ErrorExit(APE_UserBadCountryCode);
            }
            user_entry->usri3_country_code = ccode ;
        }
        else if (! _tcscmp(SwitchList[i], swtxt_SW_RANDOM))
        {
            USHORT ccode ;
            if (random_len)
            {
                *random_len = do_atou(ptr,
                                      APE_CmdArgIllegal,
                                      swtxt_SW_RANDOM) ;
                if (*random_len > PWLEN)
                {
                    ErrorExitInsTxt(APE_CmdArgIllegal,
                                    swtxt_SW_RANDOM) ;
                }
            }
        }
        else if (! _tcscmp(SwitchList[i], swtxt_SW_USER_EXPIRES))
        {
            LONG  acct_expires ;

            if (_tcsicmp(ptr, USER_NEVER) == 0)
            {
                acct_expires = TIMEQ_FOREVER ;
                user_entry->usri3_acct_expires = acct_expires ;
            }
            else
            {
                DWORD   err;
                DWORD   len;
                ULONG   GmtTime;
                time_t  Time;

                if ((err = ParseDate(ptr, &Time, &len, 0))
                      ||
                     len != _tcslen(ptr))
                {
                    ErrorExit(APE_BadDateFormat) ;
                }

                acct_expires = (LONG) Time;

                NetpLocalTimeToGmtTime(acct_expires, &GmtTime) ;
                user_entry->usri3_acct_expires = GmtTime ;
            }
        }

        *--ptr = ':';        /* restore colon for next call */
    }

    return;
}


/***  yes_or_no  -- decides if string passed in is yes or no
 *
 *  Parameters:
 *
 *  str String to parse
 *  sw_str      Switch we are processing (for error messages)
 *
 *  Returns:
 *
 *  TRUE    If string is YES or an abbreviation
 *  FALSE   If string is NO or an abbreviation
 *
 *  Aborts via ErrorExit if string is neither YES nor NO.
 *
 */

int
yes_or_no(
    LPTSTR str,
    LPTSTR sw_str
    )
{
    DWORD  res;
    DWORD answer;

    if ((res = LUI_ParseYesNo(str, &answer)) != 0)
    {
        ErrorExitInsTxt(APE_CmdArgIllegal, sw_str);
    }

    if (answer == LUI_YES_VAL)
    {
        return TRUE;
    }

    return FALSE;   /* cannot be anything else */
}

/***  get_password_dates  -- Get dates for various password events
 *
 *  Since the password date in the user record is an "age", we use the
 *  current time to deduce the "last mod" time.  From this, and the
 *  modals, we calcuate the expiration and next-change dates.
 *
 *  Parameters:
 *
 *  age     Password age in seconds.
 *  mod_p   (r) Ptr to date of last PW modification (returned)
 *  exp_p   (r) Ptr to date of PW expiration (returned)
 *  chg_p   (r) Ptr to date of next allowed PW modification (returned)
 *
 *  Returns:
 *
 *  0       OK
 *  non-zero    error from NetUserModalsGet
 *
 */

DWORD get_password_dates ( ULONG age,
                           ULONG * mod_p,
                           ULONG * exp_p,
                           ULONG * chg_p,
                           TCHAR * controller )
{
    ULONG now, last_mod;
    LPUSER_MODALS_INFO_0 uminf;
    DWORD dwErr;

    dwErr = NetUserModalsGet (controller, 0,
                              (LPBYTE*)&uminf);

    if (dwErr != 0 && dwErr != ERROR_MORE_DATA)
        return dwErr;

    now = (ULONG) time_now() ;

    *mod_p = last_mod = now - age;

    if (uminf->usrmod0_max_passwd_age == TIMEQ_FOREVER)
        *exp_p = TIMEQ_FOREVER;
    else
        *exp_p = last_mod + uminf->usrmod0_max_passwd_age;

    if (uminf->usrmod0_min_passwd_age == TIMEQ_FOREVER)
        *chg_p = TIMEQ_FOREVER;
    else
        *chg_p = last_mod + uminf->usrmod0_min_passwd_age;

    NetApiBufferFree((TCHAR FAR *) uminf);

    return 0;
}


/***  bitval  -- Gets value of a specified bit in an array
 *
 *  Parameters:
 *
 *  a       Array of bytes
 *  b       Bit number
 *
 *  Details:
 *
 *  The value returned is that of the bit at offset TEXT('b') in the
 *  array.  Bit 0 is the low-order bit in byte 0, bit 7 is the
 *  high order bit in byte 0.  Bit 8 is the low bit in byte 1,
 *  etc.
 *
 *  Returns:
 *
 *  TRUE  -- bit was set
 *  FALSE -- bit was unset
 */

int NEAR bitval ( UCHAR FAR a[], int b )
{
    int offset = b / 8;
    int mask   = 1 << (b & 0x7);

    return ((a[offset] & mask) != 0);
}


/*
 *  set_logon_hours --
 *
 *  This function allocates a chunk of memory to represent the bitmap of
 *  logon hours, then  sets the bits to represent the hours described in
 *  the string passed.
 *
 *  ALL     - all hours
 *  ""      - no hours
 *  no arg  - no hours
 *  otherwise   - pass to parse_days_times() to parse it up
 *
 *  RETURNS
 *  pointer to bitmap of hours
 *  NULL if all hours set
 *
 */


PUCHAR
set_logon_hours(
    LPTSTR txt
    )
{
    static PUCHAR   bufptr = NULL;
    DWORD           result;

    /*
     * if bufptr already none null - we have been called before &
     * already have the bitmap in order. This is because user_munge is
     * called twice.
     */
    if (bufptr != NULL)
        return bufptr;

    /* get our bitmap */
    if ( (bufptr = (PUCHAR) malloc(sizeof(WEEK))) == NULL )
        ErrorExit(NERR_InternalError) ;

    /* all hours? */
    if (!_tcsicmp(txt, USER_ALL))
        memset(bufptr,0xff, sizeof(WEEK));

    /* if they said "none", set it all to zeroes.  USER_HOURS_NONE
     * is a NULL string, thus _tcscmp is OK (instead of _tcsicmp)
     */
    else if ((*txt == NULLC) || !_tcscmp(txt, USER_HOURS_NONE))
        memset(bufptr, 0, sizeof(WEEK));
    else {
        /* hmmm, complicated. Pass it off to be parsed up. */
        result = parse_days_times(txt, bufptr);
        if (result)
            ErrorExit(result);
    }


    /* and return our pointer */
    return bufptr;

}

/*
 * Name:    get_wksta_list
 *      get workstation list & do LUI_ListPrepare on it.
 *      check number of entries does not exceed MAXWORKSTATIONS.
 *      ErrorExits if problems.
 *
 * Args:    TCHAR    *inbuf ;    -- string containing list
 * Returns: pointer to list of workstations
 * Globals: (none)
 * Statics: (none)
 * Remarks: (none)
 * Updates: (none)
 */
TCHAR * get_wksta_list(TCHAR *  inbuf)
{
    DWORD  count ;
    TCHAR      tmpbuf[MAX_PATH * 2] ;

    if ( inbuf == NULL || _tcslen(inbuf)==0 || !_tcsicmp(inbuf,WKSTA_ALL) )
        return(TEXT("")) ;

    if (LUI_ListPrepare(NULL,       /* server name, NULL means local */
            inbuf,      /* list to canonicalize */
            tmpbuf,
            DIMENSION(tmpbuf),
            &count))

        ErrorExitInsTxt(APE_CmdArgIllegal,swtxt_SW_USER_WORKSTATIONS);

    if (count > MAXWORKSTATIONS)
        ErrorExitInsTxt(APE_CmdArgTooMany,swtxt_SW_USER_WORKSTATIONS);

    if (_tcslen(tmpbuf) > _tcslen(inbuf))
        if ((inbuf = calloc(_tcslen(tmpbuf)+1,sizeof(TCHAR))) == NULL)
            ErrorExit(NERR_InternalError);

    _tcscpy(inbuf, tmpbuf);
    return (inbuf) ;
}

/*-- country info --*/

struct ccode_struct {
    DWORD  code ;
    DWORD  country ;
    };

struct ccode_struct ccode_table[] = {
    { 0,    APE2_CTRY_System_Default },
    { 1,    APE2_CTRY_United_States },
    { 2,    APE2_CTRY_Canada_French},
    { 3,    APE2_CTRY_Latin_America},
    { 31,    APE2_CTRY_Netherlands},
    { 32,    APE2_CTRY_Belgium},
    { 33,    APE2_CTRY_France},
    { 34,    APE2_CTRY_Spain},
    { 39,    APE2_CTRY_Italy},
    { 41,    APE2_CTRY_Switzerland},
    { 44,    APE2_CTRY_United_Kingdom},
    { 45,    APE2_CTRY_Denmark},
    { 46,    APE2_CTRY_Sweden},
    { 47,    APE2_CTRY_Norway},
    { 49,    APE2_CTRY_Germany},
    { 61,    APE2_CTRY_Australia},
    { 81,    APE2_CTRY_Japan},
    { 82,    APE2_CTRY_Korea},
    { 86,    APE2_CTRY_China_PRC},
    { 88,    APE2_CTRY_Taiwan},
    { 99,    APE2_CTRY_Asia},
    { 351,    APE2_CTRY_Portugal},
    { 358,    APE2_CTRY_Finland},
    { 785,    APE2_CTRY_Arabic},
    { 972,    APE2_CTRY_Hebrew},
    { (DWORD) -1,   0},
} ;



/*
 * Name:    get_country
 *      given the OS/2 country code, return a pointer
 *      to a string containing the country.
 * Args:    SHORT ccode
 * Returns: pointer to string containing country if ccode is valid,
 *  NULL otherwise.
 * Globals: (none)
 * Statics: TCHAR buffer[64] - for the returned string.
 * Remarks: result must be used immediately, another call will
 *  overwrite static buffeer.
 * Updates: (none)
 */
LPTSTR
get_country(
    DWORD ccode
    )
{
    static  TCHAR buffer[64] ;
    struct  ccode_struct *next_entry ;
    TCHAR   countryname[64] ;

    for ( next_entry = &ccode_table[0]; ; next_entry++)
    {
        if (next_entry->code == ccode)
        {
            countryname[0] = NULLC ;
            LUI_GetMsg(countryname, DIMENSION(countryname), next_entry->country);
            swprintf(buffer, TEXT("%03d (%ws)"), ccode, countryname) ;
            return buffer ;
        }
        if (next_entry->code == (DWORD) -1)
            return(NULL) ;
    }
}

/***
 *  add_to_users_alias(TCHAR *controller, TCHAR *user)
 *  add user to the USERS alias
 *
 *  Args:
 *  user - the name of the user
 *
 *  Returns:
 *  nothing - success
 *  exit(2) - command failed
 */
DWORD add_to_users_alias(TCHAR *controller, TCHAR *domain, TCHAR *user)
{
    DWORD            dwErr ;
    TCHAR           *ntalias = USERS_ALIAS ;
    TCHAR            qualified_name[DNLEN+UNLEN+2] ;

    /* access the database */
    if (dwErr = OpenSAM(controller, WRITE_PRIV))
    {
        return dwErr;
    }

    /* access the alias */
    if (dwErr = OpenAliasUsingRid(DOMAIN_ALIAS_RID_USERS, ALIAS_ADD_MEMBER, USE_BUILTIN_DOMAIN))
    {
        CloseSAM() ;
        return dwErr;
    }

    //
    // where possible, use a fully qualified name
    //
    _tcscpy(qualified_name, TEXT("")) ;
    if (domain && _tcslen(domain))
    {
        _tcscat(qualified_name, domain) ;
        _tcscat(qualified_name, TEXT("\\")) ;
    }
    _tcscat(qualified_name, user) ;
    dwErr = AliasAddMember(qualified_name);

    switch (dwErr)
    {
        case NERR_Success:
            break;
    
        case NERR_UserInGroup:
            if ( SamGetNameFromRid( DOMAIN_ALIAS_RID_USERS, &ntalias, TRUE ) )
                ntalias = USERS_ALIAS;
            IStrings[0] = user;
            IStrings[1] = ntalias;
            ErrorPrint(APE_AccountAlreadyInLocalGroup,2);
            break;

        case NERR_UserNotFound:
            IStrings[0] = user;
            ErrorPrint(APE_NoSuchAccount,1);
            break;

        case ERROR_INVALID_NAME:
            IStrings[0] = user;
            ErrorPrint(APE_BadUGName,1);
            break;

        default:
            break ;
    }

    CloseAlias() ;
    CloseSAM() ;
    return(dwErr) ;
}

/***
 *  print_aliases()
 *  Display aliases the user is member of.
 *
 *  Args:
 *  user - name of ntalias to display
 *
 *  Returns:
 *  nothing - success
 *  exit 1 - command completed with errors
 *  exit 2 - command failed
 */
VOID print_aliases(TCHAR *controller,
           DWORD fsz,
           TCHAR *domain,
           TCHAR *user,
           TCHAR *fmt,
           TCHAR *msgtext)
{
    DWORD           dwErr ;
    TCHAR **        alias_list ;
    DWORD    num_aliases, i ;
    int         gpl;    /* groups perline */
    TCHAR           qualified_name[UNLEN + DNLEN + 2] ;

    //
    // where possible, use a fully qualified name
    //
    _tcscpy(qualified_name, TEXT("")) ;
    if (domain && _tcslen(domain))
    {
        _tcscat(qualified_name, domain) ;
        _tcscat(qualified_name, TEXT("\\")) ;
    }
    _tcscat(qualified_name,user) ;

    /* access the database */
    if (dwErr = OpenSAM(controller,READ_PRIV))
        return ;

    /* now get members */
    if (dwErr = UserEnumAliases(qualified_name, &alias_list, &num_aliases))
    {
        CloseSAM() ;
        CloseAlias() ;
        return ;
    }

    /* sort the buffer */
    qsort((TCHAR *) alias_list, num_aliases,
             sizeof(TCHAR *), CmpAlias);

    /* display all members */
    gpl = (fsz > 30 ? 1 : 2);
    WriteToCon(fmt, 0, fsz, PaddedString(fsz, msgtext, NULL) );
    for (i = 0 ; i < num_aliases; i++)
    {
        /* Pad if needed */
        if ((i != 0) && ((i % gpl) == 0))
            WriteToCon(fmt, fsz, fsz, NULL_STRING );
        WriteToCon(TEXT("*%Fws"), PaddedString(21,alias_list[i],NULL));
        /* If end of line, put out newline */
        if (((i + 1) % gpl) == 0)
            PrintNL();
    }

    if ((i == 0) || ((gpl > 1) && ((i % gpl) != 0)))
        PrintNL();

    // free up stuff, cleanup
    UserFreeAliases(alias_list, num_aliases);
    NetApiBufferFree((TCHAR FAR *) alias_list);
    CloseSAM() ;

    return;
}



/***
 *  CmpAliasMemberEntry(member1,member2)
 *
 *  Compares two TCHAR ** and returns a relative
 *  lexical value, suitable for using in qsort.
 *
 */
int __cdecl CmpAlias(const VOID FAR * alias1, const VOID FAR * alias2)
{
    INT n;
    n = CompareStringW( GetUserDefaultLCID(),
                        NORM_IGNORECASE,
                        *(LPCWSTR*)alias1,
                        (int)-1,
                        *(LPCWSTR*)alias2,
                        (int)-1);
    n -= 2;

    return n;
}

TCHAR *PasswordChars = TEXT("0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ@#$%-$:_") ;

/***
 *   GenerateRandomPassword
 *
 *   Args:
 *       pword  - array to receive random password
 *       len    - length of random password
 *
 *   Returns:
 *       nothing
 */
void   GenerateRandomPassword(TCHAR *pword, int len)
{
    int i, chars ;

    srand(GetTickCount()) ;
    chars = _tcslen(PasswordChars) ;

    for (i = 0; i < len; i++)
    {
        int index = rand() % chars ;
        pword[i] = PasswordChars[index] ;
    }
}


/*
 *      DWORD LUI_ListPrepare( server, inList, outList, outListSize )
 *
 *      This function takes a list of computer names and 'prepares' them for being
 *      passed to the API's.  APIs require lists in single-space separated
 *      format, with no duplicates.  The function takes a list, puts it into
 *      NULL-NULL form, and then copies it object by object into the output
 *      buffer, making sure the item does not already exist in the output list.
 *
 *      ENTRY
 *              server - server to perform canonicalization & comparison
 *              inList - input list of items to prepare
 *              outList - buffer to hold output list
 *              outListSize - size, in bytes, of outList
 *      EXIT
 *              outList - holds list ready to be passed to API
 *              count - holds number of items in outlist
 *      RETURNS
 *              errors from I_NetListCanonicalize
 */

#define BUFSIZE 512

DWORD
LUI_ListPrepare(
    PTCHAR server,
    PTCHAR inList,
    PTCHAR outList,
    USHORT outListSize,
    PULONG count
    )
{
    TCHAR List1[BUFSIZE];  /* first temporary list buffer */
    TCHAR List2[BUFSIZE];  /* second temporary list buffer */
    LPTSTR List1Ptr;       /* pointer into 1st buffer */
    LPTSTR List2Ptr;       /* pointer into 2nd buffer */
    LPTSTR Element1;       /* ptr to element in 1st buf */
    LPTSTR Element2;       /* ptr to element in 2nd buf */
    LPTSTR endPtr;         /* ptr to end of 2nd buffer */
    ULONG types[64];       /* types for I_NetListCanon */
    DWORD dwErr;           /* API return code */
    USHORT found;          /* flag for tracking */
    ULONG result;          /* result from NetObjCompare */

    /* first place list in null-null form for comparison */

    if (dwErr = I_NetListCanonicalize(server,
                                      inList,
                                      MY_LIST_DELIMITER_STR_UI_NO_SPACE,
                                      List1,
                                      DIMENSION(List1),
                                      count,
                                      types,
                                      DIMENSION(types),
                                      OUTLIST_TYPE_NULL_NULL |
                                        NAMETYPE_COMPUTER |
                                        INLC_FLAGS_MULTIPLE_DELIMITERS))
    {
        return(dwErr);
    }

    /* prepare List2 by setting to NULL */
    memset((LPBYTE)List2, 0, sizeof(List2));
    endPtr = List2;
    List1Ptr = List1;

    /* run through each element in the canonically formed List1 */

    /* for each element in temporary list */
    while (Element1 = I_NetListTraverse(NULL, &List1Ptr, 0L))
    {
        List2Ptr = List2;
        found = FALSE;

        /* look for similar element in 2nd list */
        while (Element2 = I_NetListTraverse(NULL, &List2Ptr, 0L))
        {
            /* use NameCompare function */
            result = I_NetNameCompare(server,
                                      Element1,
                                      Element2,
                                      NAMETYPE_COMPUTER,
                                      0);

            if (!result)     /* found a match */
            {
                found = TRUE;
                break;  /* save time, break out of loop */
            }
        }
        if (!found)     /* if match was NOT found */
        {
            /*
             * Append element to end of out list.  We don't
             * need to worry about overruning the buffer, since
             * they are the same size.  We let the canon calls
             * tell us if the buffers are too small.
             */
            STRCPY(endPtr, Element1);
            endPtr += STRLEN(Element1) + 1;
        }
    }   /* for each element in first list */

    /* finally run list through canon again to place into API form */
    if (dwErr = I_NetListCanonicalize(server,
                                      List2,
                                      MY_LIST_DELIMITER_STR_NULL_NULL,
                                      outList,
                                      outListSize,
                                      count,
                                      types,
                                      DIMENSION(types),
                                      (NAMETYPE_COPYONLY | OUTLIST_TYPE_API)))
    {
        return(dwErr);
    }

    if(outListSize > STRLEN(outList))
    {
        dwErr = NERR_Success;
    }
    else
    {
        dwErr = NERR_BufTooSmall;
    }

    return(dwErr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\netuse\main.c ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1990          **/
/********************************************************************/

/*
 * MSNET - a command processor for MSNET 3.0.
 * The command grammar is specified in msnet.x
 *
 *      History
 *
 *      ??/??/??, ??????, initial code
 *      10/31/88, erichn, uses OS2.H instead of DOSCALLS
 *      05/02/89, erichn, NLS conversion
 *      06/08/89, erichn, canonicalization sweep, no LONGer u-cases input
 *      02/15/91, danhi,  convert to be 16/32 portable
 *      10/16/91, JohnRo, added DEFAULT_SERVER support.
 */

/* #define INCL_NOCOMMON */
#include <os2.h>
#include <lmcons.h>
#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <io.h>
#include <apperr.h>
#include "netcmds.h"
#include "nettext.h"
#include "msystem.h"
#include "locale.h"

#define _SHELL32_
#include <shellapi.h>


static VOID init(VOID);
VOID call_net1(VOID) ;

TCHAR *                      ArgList[LIST_SIZE] = {0};
SHORT                       ArgPos[LIST_SIZE] = {0};
TCHAR *                      SwitchList[LIST_SIZE] = {0};
SHORT                       SwitchPos[LIST_SIZE] = {0};

/* Insertion strings for InfoMessage() */
TCHAR FAR *                  IStrings[10] = {0};
TCHAR FAR *                  StarStrings[10] = {TEXT("***"),
                                                TEXT("***"),
                                                TEXT("***"),
                                                TEXT("***"),
                                                TEXT("***"),
                                                TEXT("***"),
                                                TEXT("***"),
                                                TEXT("***"),
                                                TEXT("***")};

/* 1 is /Yes, 2 is /No */
SHORT                       YorN_Switch = 0;
TCHAR **                     MyArgv;   /* argv */

UINT                        SavedArgc = 0 ;
CHAR **                     SavedArgv = NULL ;

/* Buffers for APIs to use */
TCHAR                        Buffer[LITTLE_BUF_SIZE];    /* For GetInfo's, etc.*/
TCHAR                        BigBuffer[BIG_BUF_SIZE];    /* For Enum's */
TCHAR FAR *                  BigBuf = BigBuffer;

//
// Globals for standard console handles
//

HANDLE  g_hStdOut;
HANDLE  g_hStdErr;


/***
 * MAIN - Seperate the command line into switches and arguments.
 * Then call the parser, which will dispatch the command and
 * report on error conditions.  Allocate the BigBuf.
 */

VOID os2cmd(VOID);
CPINFO CurrentCPInfo;

VOID __cdecl main(int argc, CHAR **argv)
{
    SHORT           sindex, aindex;
    SHORT           pos=0;
    DWORD	    cp;
    CHAR            achCodePage[12] = ".OCP";    // '.' + UINT in decimal + '\0'

    SavedArgc = argc ;
    SavedArgv = argv ;


    /*
       Added for bilingual message support.  This is needed for FormatMessage
       to work correctly.  (Called from DosGetMessage).
       Get current CodePage Info.  We need this to decide whether
       or not to use half-width characters.
    */

    cp = GetConsoleOutputCP();

    GetCPInfo(cp, &CurrentCPInfo);

    switch ( cp )
    {
        case 932:
        case 936:
        case 949:
        case 950:
            SetThreadLocale(
                MAKELCID(
                    MAKELANGID(
                        PRIMARYLANGID(GetSystemDefaultLangID()),
                            SUBLANG_ENGLISH_US ),
                    SORT_DEFAULT
                    )
                );
            break;

        default:
            SetThreadLocale(
            MAKELCID(
                MAKELANGID( LANG_ENGLISH, SUBLANG_ENGLISH_US ),
                    SORT_DEFAULT
                    )
                );
            break;
    }

    if (cp)
    {
        sprintf(achCodePage, ".%u", cp);
    }

    setlocale(LC_ALL, achCodePage);

    g_hStdOut = GetStdHandle(STD_OUTPUT_HANDLE);

    if (g_hStdOut == INVALID_HANDLE_VALUE)
    {
        ErrorExit(GetLastError());
    }

    g_hStdErr = GetStdHandle(STD_ERROR_HANDLE);

    if (g_hStdErr == INVALID_HANDLE_VALUE)
    {
        ErrorExit(GetLastError());
    }

    MyArgv = CommandLineToArgvW(GetCommandLineW(), &argc);
    if (MyArgv == NULL)
    {
        ErrorExit(ERROR_NOT_ENOUGH_MEMORY) ;
    }

    /* seperate switches and arguments */
    ++MyArgv;
    for (sindex = 0, aindex = 0; --argc; ++MyArgv, ++pos)
    {
        if (**MyArgv == SLASH)
        {
            SHORT arglen;
            SHORT arg_is_special = 0;

            arglen = (SHORT) _tcslen(*MyArgv);

            if (arglen > 1)
            {
                if ( _tcsnicmp(swtxt_SW_YES, (*MyArgv), arglen) == 0 )
                {
                    if (YorN_Switch == NO)
                        ErrorExit(APE_ConflictingSwitches);
                    arg_is_special = 1;
                    YorN_Switch = YES;
                }
                else if ( _tcsnicmp(swtxt_SW_NO, (*MyArgv), arglen) == 0 )
                {
                    if (YorN_Switch == YES)
                        ErrorExit(APE_ConflictingSwitches);
                    arg_is_special = 1;
                    YorN_Switch = NO;
                }
            }

            if ( ! arg_is_special )
            {
                if (sindex >= LIST_SIZE)
                    ErrorExit(APE_NumArgs) ;
                SwitchList[sindex] = *MyArgv;
                SwitchPos[sindex] = pos;
                sindex++;
            }
        }
        else
        {
            if (aindex >= LIST_SIZE)
                ErrorExit(APE_NumArgs) ;
            ArgList[aindex] = *MyArgv;
            ArgPos[aindex] = pos;
            aindex++;
        }
    }

    // register as locations to zero out on exit
    AddToMemClearList(BigBuffer, sizeof(BigBuffer), FALSE) ;
    AddToMemClearList(Buffer, sizeof(Buffer),FALSE) ;

    init();

    os2cmd();

    NetcmdExit(0);
}


static VOID NEAR init(VOID)
{
    _setmode(_fileno(stdin), O_TEXT);
}

/***
 *  M y E x i t
 *
 *    Wrapper around C runtime that cleans up memory for security reasons.
 */

VOID DOSNEAR FASTCALL
MyExit(int Status)
{
    ClearMemory() ;
    exit(Status);
}

typedef struct _MEMOMY_ELEMENT {
    LPBYTE                  lpLocation ;
    struct _MEMORY_ELEMENT *lpNext ;
    UINT                    nSize ;
    BOOL                    fDelete ;
}  MEMORY_ELEMENT, *LPMEMORY_ELEMENT ;

LPMEMORY_ELEMENT lpToDeleteList = NULL ;

/***
 *  AddToMemClearList
 *
 *   add an entry to list of things to clear
 */
VOID
AddToMemClearList(
    VOID *lpBuffer,
    UINT  nSize,
    BOOL  fDelete
    )
{
    LPMEMORY_ELEMENT lpNew, lpTmp ;
    DWORD err ;

    if (err = AllocMem(sizeof(MEMORY_ELEMENT),(LPBYTE *) &lpNew))
    {
        ErrorExit(err);
    }

    lpNew->lpLocation = (LPBYTE) lpBuffer ;
    lpNew->nSize = nSize ;
    lpNew->fDelete = fDelete ;
    lpNew->lpNext = NULL ;

    if (!lpToDeleteList)
    {
        lpToDeleteList = lpNew ;
    }
    else
    {
        lpTmp = lpToDeleteList ;
        while (lpTmp->lpNext)
            lpTmp = (LPMEMORY_ELEMENT) lpTmp->lpNext ;
        lpTmp->lpNext = (struct _MEMORY_ELEMENT *) lpNew ;
    }
}

/***
 *  ClearMemory()
 *
 *   go thru list of things to clear, and clear them.
 */
VOID ClearMemory(VOID)
{

    LPMEMORY_ELEMENT lpList, lpTmp ;
    UINT index ;

    /*
     * Go thru memory registered to be cleaned up.
     */
    lpList = lpToDeleteList ;
    while (lpList)
    {
        memset(lpList->lpLocation, 0, lpList->nSize) ;
        lpTmp = (LPMEMORY_ELEMENT) lpList->lpNext ;
        if (lpList->fDelete)
        {
            FreeMem(lpList->lpLocation);
        }

        FreeMem( (LPBYTE) lpList);
        lpList = lpTmp ;
    }
    lpToDeleteList = NULL ;

    /*
     * cleanup our copy of the args
     */
    index = 0;
    while (ArgList[index])
    {
        ClearStringW(ArgList[index]) ;
        index++ ;
    }

    /*
     * cleanup original argv
     */
    for ( index = 1 ; index < SavedArgc ; index++ )
    {
        ClearStringA(SavedArgv[index]) ;
    }
    ClearStringW(GetCommandLine());
}

VOID call_net1(VOID)
{
    STARTUPINFO startupinfo ;
    PROCESS_INFORMATION processinfo;
    LPWSTR cmdline, newcmdline, firstarg;
    DWORD  err ;
    int net1exitcode = 0;


    memset(&startupinfo, 0, sizeof(startupinfo)) ;
    startupinfo.cb = sizeof(startupinfo);
    cmdline = GetCommandLineW() ;
    firstarg = _tcschr(cmdline, TEXT(' ')) ;

    if (err = AllocMem((_tcslen(cmdline)+1) * sizeof(TCHAR)
                        + sizeof(TEXT("net1")),
                        (LPBYTE *)&newcmdline))
    {
        ErrorExit(err) ;
    }

    _tcscpy(newcmdline, TEXT("net1")) ;
    if (firstarg)
        _tcscat(newcmdline, firstarg) ;

    if (!CreateProcess(NULL,
                       newcmdline,
                       NULL,
                       NULL,
                       TRUE,
                       NORMAL_PRIORITY_CLASS,
                       NULL,
                       NULL,
                       &startupinfo,
                       &processinfo))
    {
        ErrorExit(GetLastError());
    }

    CloseHandle(processinfo.hThread) ;
    WaitForSingleObject(processinfo.hProcess, INFINITE) ;
    GetExitCodeProcess(processinfo.hProcess, &net1exitcode) ;
    CloseHandle(processinfo.hProcess) ;
    MyExit(net1exitcode) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\netcmd\util.c ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1992          **/
/********************************************************************/

/***
 *  util.c
 *      Utility functions used by netcmd
 *
 *  History:
 *      mm/dd/yy, who, comment
 *      06/10/87, andyh, new code
 *      04/05/88, andyh, split off mutil.c
 *      10/31/88, erichn, uses OS2.H instead of DOSCALLS
 *      01/04/89, erichn, filenames now MAXPATHLEN LONG
 *      05/02/89, erichn, NLS conversion
 *      05/09/89, erichn, local security mods
 *      05/19/89, erichn, NETCMD output sorting
 *      06/08/89, erichn, canonicalization sweep
 *      06/23/89, erichn, added GetPrimaryDCName for auto-remoting
 *      06/27/89, erichn, replaced Canonicalize with ListPrepare; calls
 *                  LUI_ListPrepare & I_NetListCanon instead of NetIListCan
 *      10/03/89, thomaspa, added GetLogonDCName
 *      03/05/90, thomaspa, delete UNC uses with multiple connections in
 *                  KillConnections.
 *      02/20/91, danhi, change to use lm 16/32 mapping layer
 *      07/20/92, JohnRo, RAID 160: Avoid 64KB requests (be nice to Winball).
 *      08/22/92, chuckc, added code to show dependent services
 */

/* Include files */

#define INCL_NOCOMMON
#define INCL_DOSMEMMGR
#define INCL_DOSFILEMGR
#define INCL_DOSSIGNALS
#define INCL_ERRORS
#include <os2.h>
#include <lmcons.h>
#include <lmerr.h>
#include <lmapibuf.h>
#include <apperr.h>
#include <apperr2.h>
#define INCL_ERROR_H
#include <lmaccess.h>
#include <search.h>
#include <lmuse.h>
#include <lmserver.h>
#include <dosprint.h>
#include <dsgetdc.h>
#include <lui.h>
#include "netcmds.h"
#include "nettext.h"
#include <dsrole.h>
#include "sam.h"
#include "msystem.h"


/* Comparison function for sorting from USE.C */
int __cdecl CmpUseInfo1(const VOID FAR *, const VOID far *);

/* External variable */

extern TCHAR BigBuffer[];


/***
 *  perm_map()
 *      Maps perm bits into RWDX... string
 *
 *  Args:
 *      perms - perms bit map
 *      pBuffer - string for RWDX...
 *
 *  Returns:
 *      nothing
 */
VOID FASTCALL
PermMap(
    DWORD  perms,
    LPTSTR pBuffer,
    DWORD  bufSize
    )
{
    int     i, j = 0;
    DWORD   err;
    LPTSTR  perm_CHARs;
    TCHAR   textBuf[APE2_GEN_MAX_MSG_LEN];

    perms &= (~ACCESS_GROUP);       /*  turn off group bit if on */
    perm_CHARs = TEXT(ACCESS_LETTERS);
    for (i = 0; perms != 0; perms >>= 1, i++)
    {
        if (perms & 1)
        {
            pBuffer[j++] = perm_CHARs[i];
        }
    }

    pBuffer[j] = NULLC;

    if (j == 0)
    {
        if (err = LUI_GetMsg(textBuf, DIMENSION(textBuf), APE2_GEN_MSG_NONE))
        {
            ErrorExit(err);
        }

        textBuf[DIMENSION(textBuf)-1] = NULLC;
        _tcsncpy(pBuffer, textBuf, bufSize);
    }
}


/***
 *  ExtractServernamef : gets \\comp\que in queue
 *          puts comp in server
 *          and que in queue
 *
 */
VOID FASTCALL ExtractServernamef(TCHAR FAR * server, TCHAR FAR * queue)
{
    TCHAR FAR * backslash;

    /* find the backslash ; skip the first two "\\" */

    backslash = _tcschr(queue + 2 ,BACKSLASH);
    *backslash = NULLC;

    /* now copy computername to server and queuename to queue */
    _tcscpy(server, queue);
    _tcscpy(queue, backslash + 1);
}


/***
 * K i l l C o n n e c t i o n s
 *
 * Check connection list for stopping redir and logging off
 */
VOID FASTCALL KillConnections(VOID)
{
    DWORD         dwErr;
    DWORD         cTotalAvail;
    LPTSTR        pBuffer;
    DWORD         num_read;           /* num entries read by API */
    LPUSE_INFO_1  use_entry;
    DWORD         i,j;

    if (dwErr = NetUseEnum(
                          NULL,
                          1,
                          (LPBYTE*)&pBuffer,
                          MAX_PREFERRED_LENGTH,
                          &num_read,
                          &cTotalAvail,
                          NULL))
    {
        ErrorExit((dwErr == RPC_S_UNKNOWN_IF) ? NERR_WkstaNotStarted : dwErr);
    }

    qsort(pBuffer, num_read, sizeof(USE_INFO_1), CmpUseInfo1);

    for (i = 0, use_entry = (LPUSE_INFO_1) pBuffer;
        i < num_read; i++, use_entry++)
    {
        if ((use_entry->ui1_local[0] != NULLC)
            || (use_entry->ui1_usecount != 0)
            || (use_entry->ui1_refcount != 0))
            break;
    }

    if (i != num_read)
    {
        InfoPrint(APE_KillDevList);

        /* make two passes through the loop; one for local, one for UNC */

        for (i = 0, use_entry = (LPUSE_INFO_1) pBuffer;
            i < num_read; i++, use_entry++)
            if (use_entry->ui1_local[0] != NULLC)
                WriteToCon(TEXT("    %-15.15Fws %Fws\r\n"), use_entry->ui1_local,
                                              use_entry->ui1_remote);
            else if ((use_entry->ui1_local[0] == NULLC) &&
                ((use_entry->ui1_usecount != 0) ||
                (use_entry->ui1_refcount != 0)))
                WriteToCon(TEXT("    %-15.15Fws %Fws\r\n"), use_entry->ui1_local,
                                              use_entry->ui1_remote);

        InfoPrint(APE_KillCancel);
        if (!YorN(APE_ProceedWOp, 0))
            NetcmdExit(2);
    }

    for (i = 0, use_entry = (LPUSE_INFO_1) pBuffer;
        i < num_read; i++, use_entry++)
    {
        /* delete both local and UNC uses */
        if (use_entry->ui1_local[0] != NULLC)
            dwErr = NetUseDel(NULL, use_entry->ui1_local, USE_FORCE);
        else
        {
            /*
             * Delete All UNC uses to use_entry->ui1_remote
             */
            for( j = 0; j < use_entry->ui1_usecount; j++ )
            {
                dwErr = NetUseDel(NULL,
                                  use_entry->ui1_remote,
                                  USE_FORCE);
            }
        }

        switch(dwErr)
        {
        case NERR_Success:
        /* The use was returned by Enum, but is already gone */
        case ERROR_BAD_NET_NAME:
        case NERR_UseNotFound:
            break;

        case NERR_OpenFiles:
            if (use_entry->ui1_local[0] != NULLC)
                IStrings[0] = use_entry->ui1_local;
            else
                IStrings[0] = use_entry->ui1_remote;
            InfoPrintIns(APE_OpenHandles, 1);
            if (!YorN(APE_UseBlowAway, 0))
                NetcmdExit(2);

            if (use_entry->ui1_local[0] != NULLC)
                dwErr = NetUseDel(NULL,
                                  use_entry->ui1_local,
                                  USE_LOTS_OF_FORCE);
            else
            {
                /*
                * Delete All UNC uses to use_entry->ui1_remote
                */
                for( j = 0; j < use_entry->ui1_usecount; j++ )
                {
                    dwErr = NetUseDel(NULL,
                                      use_entry->ui1_remote,
                                      USE_LOTS_OF_FORCE);
                }
            }
            if (dwErr)
                ErrorExit(dwErr);
            break;

        default:
            ErrorExit(dwErr);
        }
    }
    NetApiBufferFree(pBuffer);
    ShrinkBuffer();
    return;
}



/***
 *  CmpUseInfo1(use1,use2)
 *
 *  Compares two USE_INFO_1 structures and returns a relative
 *  lexical value, suitable for using in qsort.
 *
 */

int __cdecl CmpUseInfo1(const VOID FAR * use1, const VOID FAR * use2)
{
    register USHORT localDev1, localDev2;
    register DWORD devType1, devType2;

    /* first sort by whether use has local device name */
    localDev1 = ((LPUSE_INFO_1) use1)->ui1_local[0];
    localDev2 = ((LPUSE_INFO_1) use2)->ui1_local[0];
    if (localDev1 && !localDev2)
        return -1;
    if (localDev2 && !localDev1)
        return +1;

    /* then sort by device type */
    devType1 = ((LPUSE_INFO_1) use1)->ui1_asg_type;
    devType2 = ((LPUSE_INFO_1) use2)->ui1_asg_type;
    if (devType1 != devType2)
        return( (devType1 < devType2) ? -1 : 1 );

    /* if local device, sort by local name */
    if (localDev1)
    {
        return _tcsicmp(((LPUSE_INFO_1) use1)->ui1_local,
                        ((LPUSE_INFO_1) use2)->ui1_local);
    }
    else
    {
        /* sort by remote name */
        return _tcsicmp(((LPUSE_INFO_1) use1)->ui1_remote,
                        ((LPUSE_INFO_1) use2)->ui1_remote);
    }
}


DWORD FASTCALL
CallDosPrintEnumApi(
    DWORD    dwApi,
    LPTSTR   server,
    LPTSTR   arg,
    WORD     level,
    LPWORD   num_read,
    LPWORD   available
    )
{
    USHORT     buf_size;
    DWORD      err;

    buf_size = BIG_BUF_SIZE;

    do {

        if (dwApi == DOS_PRINT_JOB_ENUM)
        {
            err = DosPrintJobEnum(server,
                                  arg,
                                  level,
                                  (PBYTE) BigBuf,
                                  buf_size,
                                  num_read,
                                  available);
        }
        else if (dwApi == DOS_PRINT_Q_ENUM)
        {
            err = DosPrintQEnum(server,
                                level,
                                (PBYTE) BigBuf,
                                buf_size,
                                num_read,
                                available);
        }
        else
        {
            err = ERROR_INVALID_LEVEL;
        }

        switch(err) {
        case ERROR_MORE_DATA:
        case NERR_BufTooSmall:
        case ERROR_BUFFER_OVERFLOW:
            if (MakeBiggerBuffer())
                return err;

            if ( buf_size >= (*available) ) {
                return (NERR_InternalError);
            }

            buf_size = *available;

            err = ERROR_MORE_DATA;   // kludge to force another iteration.
            break;

        default:
            return err;
        }

    } while (err == ERROR_MORE_DATA);

    /*NOTREACHED*/
    return err;
}

/************* buffer related stuff *************/

unsigned int FASTCALL
MakeBiggerBuffer(
    VOID
    )
{
    static TCHAR FAR *       keep_pBuffer;
    static int              pBuffer_grown = FALSE;

    if (pBuffer_grown)
    {
        BigBuf = keep_pBuffer;
    }
    else
    {
        if (AllocMem(FULL_SEG_BUF, &BigBuf))
        {
            return 1;
        }

        keep_pBuffer = BigBuf;
        pBuffer_grown = TRUE;
    }

    return 0;
}


VOID FASTCALL ShrinkBuffer(VOID)
{
    BigBuf = BigBuffer;
}


#define MINI_BUF_SIZE   256


/*
 * check if there is a /DOMAIN switch. if there isnt, assume
 * it user wants local. It is used in NET USER|GROUP|ACCOUNTS|NTALIAS
 * to mean modify SAM on local machine vs SAM on DOMAIN.
 *
 * if the usePDC arg is true, we will go find a writeable DC. otherwise,
 * a BDC is deemed acceptable. in which case if the local machine is
 * a LanManNT machine, we'll just make the call locally. typically,
 * Enum/Display will not require the PDC while Set/Add/Del will.
 *
 */
DWORD  FASTCALL GetSAMLocation(TCHAR   *controllerbuf,
                               USHORT  controllerbufSize,
                               TCHAR   *domainbuf,
                               ULONG   domainbufSize,
                               BOOL    fUsePDC)
{
    DWORD                               dwErr ;
    int                                 i ;
    BOOL                                fDomainSwitch = FALSE ;
    PDSROLE_PRIMARY_DOMAIN_INFO_BASIC   pDomainInfo;
    static BOOL                         info_msg_printed = FALSE ;
    DOMAIN_CONTROLLER_INFO *pDCInfo = (DOMAIN_CONTROLLER_INFO *)NULL;

    //
    // check and initialize the return data
    //
    if( controllerbufSize < MAX_PATH )
        return NERR_BufTooSmall;
    *controllerbuf = NULLC ;

    if ( domainbuf )
    {
        if ( domainbufSize < DNLEN+1 )
            return NERR_BufTooSmall;
        *domainbuf = NULLC ;
    }

    //
    // look for /DOMAIN switch
    //
    for (i = 0; SwitchList[i]; i++)
    {
        if (sw_compare(swtxt_SW_DOMAIN, SwitchList[i]) >= 0)
            fDomainSwitch = TRUE ;
    }

    //
    // retrieve role of local  machine
    //

    dwErr = DsRoleGetPrimaryDomainInformation(
                 NULL,
                 DsRolePrimaryDomainInfoBasic,
                 (PBYTE *)&pDomainInfo);
    if (dwErr)
    {
        ErrorExit(dwErr);
    }


    //
    // Caller expects the NetBIOS domain name back
    //
    if (domainbuf)
        _tcscpy(domainbuf,pDomainInfo->DomainNameFlat) ;

    if (pDomainInfo->MachineRole == DsRole_RoleBackupDomainController ||
        pDomainInfo->MachineRole == DsRole_RolePrimaryDomainController )
    {
        _tcscpy(controllerbuf, TEXT(""));
        DsRoleFreeMemory(pDomainInfo);
        return NERR_Success;
    }
    else
    {
        //
        //  if without /DOMAIN, act locally, but domain name
        //  must be set to computername
        //
        if (!fDomainSwitch)
        {
            _tcscpy(controllerbuf, TEXT(""));

            if (domainbuf)
            {
                if (GetComputerName(domainbuf, &domainbufSize))

                {
                    // all is well. nothing more to do
                }
                else
                {
                    // use an empty domain name (will usually work)
                    _tcscpy(domainbuf,TEXT("")) ;
                }
            }
            DsRoleFreeMemory(pDomainInfo);
            return NERR_Success;
        }

        // get here only if WinNT and specified /DOMAIN, so
        // we drop thru and get PDC for primary domain as
        // we would for Backups.
    }

    //
    // We wish to find the DC. First, we inform the
    // user that we are going remote, in case we fail
    //
    if (!info_msg_printed)
    {
        InfoPrintInsTxt(APE_RemotingToDC,
                        pDomainInfo->DomainNameDns== NULL ?
                            pDomainInfo->DomainNameFlat :
                            pDomainInfo->DomainNameDns);
        info_msg_printed = TRUE ;
    }

    dwErr = DsGetDcName( NULL,
                         NULL,
                         NULL,
                         NULL,
                         fUsePDC ? DS_DIRECTORY_SERVICE_PREFERRED
                                      | DS_WRITABLE_REQUIRED
                                 : DS_DIRECTORY_SERVICE_PREFERRED,
                         &pDCInfo );


    if (dwErr)
    {
        ErrorExit(dwErr);
    }

    DsRoleFreeMemory(pDomainInfo);

    if (pDCInfo->DomainControllerName == NULL)
    {
        controllerbuf[0] = 0 ;
        return NERR_Success;
    }

    if (_tcslen(pDCInfo->DomainControllerName) > (unsigned int) controllerbufSize)
    {
        NetApiBufferFree(pDCInfo);
        return NERR_BufTooSmall;
    }

    _tcscpy(controllerbuf, pDCInfo->DomainControllerName);
    NetApiBufferFree(pDCInfo);
    return NERR_Success;
}

/*
 * operations that cannot be performed on a local WinNT machine
 * should call this check first. the check will ErrorExit() if the
 * local machine is a WinNT machine AND no /DOMAIN switch was specified,
 * since this now implies operate on local WinNT machine.
 */
VOID FASTCALL CheckForLanmanNT(VOID)
{
    BOOL   fDomainSwitch = FALSE ;
    int i ;

    // look for the /DOMAIN switch
    for (i = 0; SwitchList[i]; i++)
    {
        if (sw_compare(swtxt_SW_DOMAIN,SwitchList[i]) >= 0)
            fDomainSwitch = TRUE ;
    }

    // error exit if is WinNT and no /DOMAIN
    if (IsLocalMachineWinNT() && !fDomainSwitch)
        ErrorExit(APE_LanmanNTOnly) ;
}

//
// tow globals for the routines below
//

static SC_HANDLE scm_handle = NULL ;


/*
 * display the services that are dependent on a service.
 * this routine will generate output to the screen. it returns
 * 0 if successful, error code otherwise.
 */
void DisplayAndStopDependentServices(TCHAR *service)
{
    SC_HANDLE svc_handle = NULL ;
    SERVICE_STATUS svc_status ;
    TCHAR *    buffer = NULL ;
    TCHAR *    insert_text = NULL ;
    DWORD     err = 0 ;
    DWORD     buffer_size ;
    DWORD     size_needed ;
    DWORD     num_dependent ;
    ULONG     i ;
    TCHAR service_name_buffer[512] ;

    // allocate some memory for this operation
    buffer_size = 4000 ;  // lets try about 4K.
    if (AllocMem(buffer_size,&buffer))
        ErrorExit(ERROR_NOT_ENOUGH_MEMORY) ;

    // open service control manager if need
    if (!scm_handle)
    {
        if (!(scm_handle = OpenSCManager(NULL,
                                         NULL,
                                         GENERIC_READ)))
        {
            err = GetLastError() ;
            goto common_exit ;
        }
    }

    // open service
    if (!(svc_handle = OpenService(scm_handle,
                                   service,
                                   (SERVICE_ENUMERATE_DEPENDENTS |
                                   SERVICE_QUERY_STATUS) )))
    {
        err = GetLastError() ;
        goto common_exit ;
    }

    // check if it is stoppable
    if (!QueryServiceStatus(svc_handle, &svc_status))
    {
        err = GetLastError() ;
        goto common_exit ;
    }
    if (svc_status.dwCurrentState == SERVICE_STOPPED)
    {
        err = APE_StartNotStarted ;
        insert_text = MapServiceKeyToDisplay(service) ;
        goto common_exit ;
    }
    if ( (svc_status.dwControlsAccepted & SERVICE_ACCEPT_STOP) == 0 )
    {
        err = NERR_ServiceCtlNotValid ;
        goto common_exit ;
    }


    // enumerate dependent services
    if (!EnumDependentServices(svc_handle,
                               SERVICE_ACTIVE,
                               (LPENUM_SERVICE_STATUS) buffer,
                               buffer_size,
                               &size_needed,
                               &num_dependent))
    {
        err = GetLastError() ;

        if (err == ERROR_MORE_DATA)
        {
            // free old buffer and reallocate more memory
            FreeMem(buffer);
            buffer_size = size_needed ;
            if (AllocMem(buffer_size,&buffer))
            {
                err = ERROR_NOT_ENOUGH_MEMORY ;
                goto common_exit ;
            }

            if (!EnumDependentServices(svc_handle,
                               SERVICE_ACTIVE,
                               (LPENUM_SERVICE_STATUS) buffer,
                               buffer_size,
                               &size_needed,
                               &num_dependent))
            {
                err = GetLastError() ;
                goto common_exit ;
            }
        }
        else
            goto common_exit ;
    }

    if (num_dependent == 0)
    {
        //
        // no dependencies. just return
        //
        err = NERR_Success ;
        goto common_exit ;
    }

    InfoPrintInsTxt(APE_StopServiceList,MapServiceKeyToDisplay(service)) ;

    // loop thru and display them all.
    for (i = 0; i < num_dependent; i++)
    {
        LPENUM_SERVICE_STATUS lpService =
            ((LPENUM_SERVICE_STATUS)buffer) + i ;

	WriteToCon(TEXT("   %Fws"), lpService->lpDisplayName);
        PrintNL();
    }

    PrintNL();
    if (!YorN(APE_ProceedWOp, 0))
        NetcmdExit(2);

    // loop thru and stop tem all
    for (i = 0; i < num_dependent; i++)
    {
        LPENUM_SERVICE_STATUS lpService =
            ((LPENUM_SERVICE_STATUS)buffer) + i ;

        // Since EnumDependentServices() itself recurses, we don't need
        // to have stop_service() stop dependent services
        stop_service(lpService->lpServiceName, FALSE);
    }
    err = NERR_Success ;

common_exit:

    if (buffer) FreeMem(buffer);
    if (svc_handle) CloseServiceHandle(svc_handle) ;  // ignore any errors
    if (err)
    {
        if (insert_text)
            ErrorExitInsTxt(err,insert_text);
        else
            ErrorExit (err);
    }
}

/*
 * Map a service display name to key name.
 * ErrorExits is it cannot open the service controller.
 * returns pointer to mapped string if found, and
 * pointer to the original otherwise.
 */
TCHAR *MapServiceDisplayToKey(TCHAR *displayname)
{
    static TCHAR service_name_buffer[512] ;
    DWORD bufsize = DIMENSION(service_name_buffer);

    // open service control manager if need
    if (!scm_handle)
    {
        if (!(scm_handle = OpenSCManager(NULL,
                                         NULL,
                                         GENERIC_READ)))
        {
            ErrorExit(GetLastError());
        }
    }

    if (!GetServiceKeyName(scm_handle,
                           displayname,
                           service_name_buffer,
                           &bufsize))
    {
        return displayname ;
    }

    return service_name_buffer ;
}

/*
 * Map a service key name to display name.
 * ErrorExits is it cannot open the service controller.
 * returns pointer to mapped string if found, and
 * pointer to the original otherwise.
 */
TCHAR *MapServiceKeyToDisplay(TCHAR *keyname)
{
    static TCHAR service_name_buffer[512] ;
    DWORD bufsize = DIMENSION(service_name_buffer);

    // open service control manager if need
    if (!scm_handle)
    {
        if (!(scm_handle = OpenSCManager(NULL,
                                         NULL,
                                         GENERIC_READ)))
        {
            ErrorExit(GetLastError());
        }
    }

    if (!GetServiceDisplayName(scm_handle,
                               keyname,
                               service_name_buffer,
                               &bufsize))
    {
        return keyname ;
    }

    return service_name_buffer ;
}

SVC_MAP service_mapping[] = {
    {TEXT("msg"), KNOWN_SVC_MESSENGER},
    {TEXT("messenger"), KNOWN_SVC_MESSENGER},
    {TEXT("receiver"), KNOWN_SVC_MESSENGER},
    {TEXT("rcv"), KNOWN_SVC_MESSENGER},
    {TEXT("redirector"), KNOWN_SVC_WKSTA},
    {TEXT("redir"), KNOWN_SVC_WKSTA},
    {TEXT("rdr"), KNOWN_SVC_WKSTA},
    {TEXT("workstation"), KNOWN_SVC_WKSTA},
    {TEXT("work"), KNOWN_SVC_WKSTA},
    {TEXT("wksta"), KNOWN_SVC_WKSTA},
    {TEXT("prdr"), KNOWN_SVC_WKSTA},
    {TEXT("devrdr"), KNOWN_SVC_WKSTA},
    {TEXT("lanmanworkstation"), KNOWN_SVC_WKSTA},
    {TEXT("server"), KNOWN_SVC_SERVER},
    {TEXT("svr"), KNOWN_SVC_SERVER},
    {TEXT("srv"), KNOWN_SVC_SERVER},
    {TEXT("lanmanserver"), KNOWN_SVC_SERVER},
    {TEXT("alerter"), KNOWN_SVC_ALERTER},
    {TEXT("netlogon"), KNOWN_SVC_NETLOGON},
    {NULL, KNOWN_SVC_NOTFOUND}
} ;

UINT FindKnownService(TCHAR *keyname)
{
    int i = 0 ;

    while (service_mapping[i].name)
    {
        if (!_tcsicmp(service_mapping[i].name,keyname))
	    return service_mapping[i].type ;
        i++ ;
    }

    return KNOWN_SVC_NOTFOUND ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\netuse\os2cmd.c ===
#include <windows.h>
#include "os2cmd.h"
KEYTAB KeyTab[] = {
	USE, TEXT("use"),
	VIEW, TEXT("view"),
	0,0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\netuse\os2cmd.h ===
typedef struct {
	int key;
	TCHAR *text;
	} KEYTAB;
#define USE 600
#define VIEW 601
#define EOS EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netdom\cmdtable.cxx ===
//+----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:      cmdtable.cxx
//
//  Contents:  Defines tables which contain the command line arguments.
//
//  History:   26-Mar-2001    EricB  Created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include <netdom.h>
#include "cmdtable.h"

//+----------------------------------------------------------------------------
// Parser tables
//-----------------------------------------------------------------------------

ARG_RECORD rgNetDomPriArgs[] = 
{
   //
   // Primary operation commands
   //
   //
   // help, h
   //
   {MSG_TAG_HELP, NULL,
   MSG_TAG_HELPSHORT, NULL,
   ARG_TYPE_HELP, 0,
   (CMD_TYPE)FALSE,
   0, NULL},

   //
   // ?
   //
   {MSG_TAG_QHELP, NULL,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_HELP, 0,
   (CMD_TYPE)FALSE,
   0, NULL},

   //
   // Add primary command
   //
   {MSG_TAG_ADD, NULL,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_VERB, ARG_FLAG_ATLEASTONE | ARG_FLAG_VERB,
   0,
   0, NULL},

   //
   // ComputerName primary command
   //
   {MSG_TAG_COMPNAME, NULL,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_VERB, ARG_FLAG_ATLEASTONE | ARG_FLAG_VERB,
   0,
   0, NULL},

   //
   // Join primary command
   //
   {MSG_TAG_JOIN, NULL,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_VERB, ARG_FLAG_ATLEASTONE | ARG_FLAG_VERB,
   0,
   0, NULL},

   //
   // Move primary command
   //
   {MSG_TAG_MOVE, NULL,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_VERB, ARG_FLAG_ATLEASTONE | ARG_FLAG_VERB,
   0,
   0, NULL},

   //
   // Query primary command
   //
   {MSG_TAG_QUERY, NULL,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_VERB, ARG_FLAG_ATLEASTONE | ARG_FLAG_VERB,
   0,
   0, NULL},

   //
   // Remove primary command
   //
   {MSG_TAG_REMOVE, NULL,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_VERB, ARG_FLAG_ATLEASTONE | ARG_FLAG_VERB,
   0,
   0, NULL},

   //
   // Rename primary command
   //
   {MSG_TAG_RENAME, NULL,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_VERB, ARG_FLAG_ATLEASTONE | ARG_FLAG_VERB,
   0,
   0, NULL},

   //
   // Rename Computer primary command
   //
   {MSG_TAG_RENAMECOMPUTER, NULL,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_VERB, ARG_FLAG_ATLEASTONE | ARG_FLAG_VERB,
   0,
   0, NULL},

   //
   // Reset primary command
   //
   {MSG_TAG_RESET, NULL,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_VERB, ARG_FLAG_ATLEASTONE | ARG_FLAG_VERB,
   0,
   0, NULL},

   //
   // Reset Password primary command
   //
   {MSG_TAG_RESETPWD, NULL,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_VERB, ARG_FLAG_ATLEASTONE | ARG_FLAG_VERB,
   0,
   0, NULL},

   //
   // Trust primary command
   //
   {MSG_TAG_TRUST, NULL,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_VERB, ARG_FLAG_ATLEASTONE | ARG_FLAG_VERB,
   0,
   0, NULL},

   //
   // Verify primary command
   //
   {MSG_TAG_VERIFY, NULL,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_VERB, ARG_FLAG_ATLEASTONE | ARG_FLAG_VERB,
   0,
   0, NULL},

   //
   // Time primary command
   //
   {MSG_TAG_TIME, NULL,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_VERB, ARG_FLAG_ATLEASTONE | ARG_FLAG_VERB,
   0,
   0, NULL},

   {ARG_TERMINATOR}
};

ARG_RECORD rgNetDomArgs[] = 
{
   //
   // Object name
   //
   {0, L"Object",
   ID_ARG2_NULL, NULL,
   ARG_TYPE_STR, ARG_FLAG_OBJECT,
   NULL,
   0, NULL},

   //
   // Query operations
   //
   //
   // PDC
   //
   {MSG_TAG_QUERY_PDC, NULL,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_VERB, ARG_FLAG_VERB,
   NULL,
   0, NULL},

   //
   // SERVER
   //
   {MSG_TAG_QUERY_SERVER, NULL,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_VERB, ARG_FLAG_VERB,
   NULL,
   0, NULL},

   //
   // WORKSTATION
   //
   {MSG_TAG_QUERY_WKSTA, NULL,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_VERB, ARG_FLAG_VERB,
   NULL,
   0, NULL},

   //
   // DC
   //
   {MSG_TAG_QUERY_DC, NULL,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_VERB, ARG_FLAG_VERB,
   NULL,
   0, NULL},

   //
   // OU
   //
   {MSG_TAG_QUERY_OU, NULL,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_VERB, ARG_FLAG_VERB,
   NULL,
   0, NULL},

   //
   // FSMO
   //
   {MSG_TAG_QUERY_FSMO, NULL,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_VERB, ARG_FLAG_VERB,
   NULL,
   0, NULL},

   //
   // TRUST
   //
   {MSG_TAG_QUERY_TRUST, NULL,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_VERB, ARG_FLAG_VERB,
   NULL,
   0, NULL},

   //
   // Common switches
   //
   //
   // help, h
   //
   {MSG_TAG_HELP, NULL,
   MSG_TAG_HELPSHORT, NULL,
   ARG_TYPE_HELP, 0,
   (CMD_TYPE)FALSE,
   0, NULL},

   //
   // ?
   //
   {MSG_TAG_QHELP, NULL,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_HELP, 0,
   (CMD_TYPE)FALSE,
   0, NULL},

   //
   // UserO, uo
   //
   {MSG_TAG_USERO, NULL,
   MSG_TAG_USERO_SHORT, NULL,
   ARG_TYPE_STR, 0,
   NULL,
   0, NULL},

   //
   // PasswordO, po
   //
   {MSG_TAG_PO, NULL,
   MSG_TAG_PO_SHORT, NULL,
   ARG_TYPE_STR, ARG_FLAG_DEFAULTABLE,
   (CMD_TYPE)L"",
   0, NULL}, //ValidateAdminPassword,

   //
   // UserD, ud
   //
   {MSG_TAG_USERD, NULL,
   MSG_TAG_USERD_SHORT, NULL,
   ARG_TYPE_STR, 0,
   NULL,
   0, NULL},

   //
   // PasswordD, pd
   //
   {MSG_TAG_PD, NULL,
   MSG_TAG_PD_SHORT, NULL,
   ARG_TYPE_STR, ARG_FLAG_DEFAULTABLE,
   (CMD_TYPE)L"",
   0, NULL}, //ValidateAdminPassword,

   //
   // Domain, d
   //
   {MSG_TAG_DOMAIN, NULL,
   MSG_TAG_DOMAIN_SHORT, NULL,
   ARG_TYPE_STR, 0,
   NULL,
   0, NULL},

   //
   // OU
   //
   {MSG_TAG_OU, NULL,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_STR, 0,
   NULL,
   0, NULL},

   //
   // Verify sub command, v
   //
   {MSG_TAG_TVERIFY, NULL,
   MSG_TAG_TVERIFY_SHORT, NULL,
   ARG_TYPE_BOOL, 0,
   NULL,
   0, NULL},

   //
   // Verbose
   //
   {MSG_TAG_VERBOSE, NULL,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, 0,
   NULL,
   0, NULL},

   //
   // Server, s
   //
   {MSG_TAG_SERVER, NULL,
   MSG_TAG_SERVER_SHORT, NULL,
   ARG_TYPE_STR, 0,  
   NULL,    
   0, NULL},

   //
   // Reset sub command, rese
   //
   {MSG_TAG_TRESET, NULL,
   MSG_TAG_TRESET_SHORT, NULL,
   ARG_TYPE_BOOL, 0,
   NULL,
   0, NULL},

   //
   // Reboot, reb
   //
   {MSG_TAG_RESTART, NULL,
   MSG_TAG_RESTART_SHORT, NULL,
   ARG_TYPE_INT, ARG_FLAG_DEFAULTABLE,
   (CMD_TYPE)30,
   0, NULL},

   //
   // Force
   //
   {MSG_TAG_FORCE, NULL,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, 0,
   NULL,
   0, NULL},

   //
   // Help switch
   //
   //
   // Syntax
   //
   {MSG_TAG_SYNTAX, NULL,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_BOOL, 0,
   NULL,
   0, NULL},

   //
   // Add switch
   //
   //
   // DC
   //
   {MSG_TAG_ADD_DC, NULL,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   (CMD_TYPE)L"",
   0, NULL},

   //
   // Move switches
   //
   //
   // UserF, uf
   //
   {MSG_TAG_USERF, NULL,
   MSG_TAG_USERF_SHORT, NULL,
   ARG_TYPE_STR, 0,
   NULL,
   0, NULL},

   //
   // PasswordF, pf
   //
   {MSG_TAG_PF, NULL,
   MSG_TAG_PF_SHORT, NULL,
   ARG_TYPE_STR, ARG_FLAG_DEFAULTABLE,
   (CMD_TYPE)L"",
   0, NULL}, //ValidateAdminPassword,

   //
   // Query switch
   //
   //
   // Direct
   //
   {MSG_TAG_DIRECT, NULL,
   MSG_TAG_DIRECT_SHORT, NULL,
   ARG_TYPE_BOOL, 0,
   NULL,
   0, NULL},

   //
   // Rename Computer switch
   //
   //
   // NewName
   //
   {MSG_TAG_NEW_NAME, NULL,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_STR, 0,
   NULL,
   0, NULL},

   //
   // Trust switches
   //
   //
   // Realm, rea
   //
   {MSG_TAG_REALM, NULL,
   MSG_TAG_REALM_SHORT, NULL,
   ARG_TYPE_BOOL, 0,
   NULL,
   0, NULL},

   //
   // PasswordT, pt
   //
   {MSG_TAG_PT, NULL,
   MSG_TAG_PT_SHORT, NULL,
   ARG_TYPE_STR, 0,
   (CMD_TYPE)L"",
   0, NULL},

   //
   // Add, a, also used by CompName
   //
   {MSG_TAG_TADD, NULL,
   MSG_TAG_TADD_SHORT, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   (CMD_TYPE)L"",
   0, NULL},

   //
   // Remove, rem, also used by CompName
   //
   {MSG_TAG_TREMOVE, NULL,
   MSG_TAG_TREMOVE_SHORT, NULL,
   ARG_TYPE_STR, ARG_FLAG_OPTIONAL,
   (CMD_TYPE)L"",
   0, NULL},

   //
   // TwoWay, t
   //
   {MSG_TAG_TWOWAY, NULL,
   MSG_TAG_TWOWAY_SHORT, NULL,
   ARG_TYPE_BOOL, 0,
   NULL,
   0, NULL},

   //
   // Kerberos, k
   //
   {MSG_TAG_KERBEROS, NULL,
   MSG_TAG_KERBEROS_SHORT, NULL,
   ARG_TYPE_BOOL, 0,
   NULL,
   0, NULL},

   //
   // Transitive, trans
   //
   {MSG_TAG_TRANSITIVE, NULL,
   MSG_TAG_TRANSITIVE_SHORT, NULL,
   ARG_TYPE_STR, ARG_FLAG_DEFAULTABLE,
   (CMD_TYPE)L"",
   0, NULL},

   //
   // OneSide, os
   //
   {MSG_TAG_ONESIDE, NULL,
   MSG_TAG_ONESIDE_SHORT, NULL,
   ARG_TYPE_STR, 0,
   NULL,
   0, NULL},

   //
   // NameSuffixes, ns
   //
   {MSG_TAG_NAMESUFFIXES, NULL,
   MSG_TAG_NAMESUFFIX_SHORT, NULL,
   ARG_TYPE_STR, 0,
   NULL,
   0, NULL},

   //
   // ToggleSuffix, ts
   //
   {MSG_TAG_TOGGLESUFFIX, NULL,
   MSG_TAG_TOGGLESUFFIX_SHORT, NULL,
   ARG_TYPE_STR, 0,
   NULL,
   0, NULL},

   //
   // FilterSIDs
   //
   {MSG_TAG_FILTER_SIDS, NULL,
   ID_ARG2_NULL, NULL,
   ARG_TYPE_STR, ARG_FLAG_DEFAULTABLE,
   (CMD_TYPE)L"",
   0, NULL},

   //
   // ComputerName switches.
   //
   //
   // MakePrimary, MP
   //
   {MSG_TAG_MAKEPRIMARY, NULL,
   MSG_TAG_MAKEPRIMARY_SHORT, NULL,
   ARG_TYPE_STR, 0,
   NULL,
   0, NULL},

   //
   // Enumerate, Enum
   //
   {MSG_TAG_ENUM, NULL,
   MSG_TAG_ENUM_SHORT, NULL,
   ARG_TYPE_STR, ARG_FLAG_DEFAULTABLE,
   (CMD_TYPE)L"",
   0, NULL},

   {ARG_TERMINATOR}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\netuse\os2incl.h ===
#define XX_USERLEX lexor
#define XX_USERPARSE os2cmd
#define XX_USERTYPE char *
#define XX_START 0
#define INTER_FRAME 5
#define INTER_OR 9
extern	TCHAR	XXtype[];
extern	short	XXvalues[];
typedef struct
{
XX_USERTYPE node;
int token;
} TOKSTACK;
int xxaction(int, TCHAR**);
int xxcondition(int, TCHAR**);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netdom\compname.h ===
//+----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:      CompName.h
//
//  Contents:  Definitions for the computer name management code.
//
//  History:   20-April-2001    EricB  Created
//
//-----------------------------------------------------------------------------

#ifndef _COMPNAME_H_
#define _COMPNAME_H_

//+----------------------------------------------------------------------------
//
//  Function:  NetDomComputerNames
//
//  Synopsis:  Entry point for the computer name command.
//
//  Arguments: [rgNetDomArgs] - The command line argument array.
//
//-----------------------------------------------------------------------------
DWORD
NetDomComputerNames(ARG_RECORD * rgNetDomArgs);


#endif // _COMPNAME_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netdom\cmdtable.h ===
//+----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:      cmdtable.h
//
//  Contents:  Defines an enum for the index into the tables which contain the
//             command line arguments.
//
//  History:   26-Mar-2001    EricB  Created
//
//-----------------------------------------------------------------------------

#ifndef _CMDTABLE_H_
#define _CMDTABLE_H_

typedef enum TAG_NETDOM_ARG_ENUM
{
   eArgBegin = 0,
   //
   // Primary operation commands
   //
   ePriHelp = eArgBegin,
   ePriHelp2,
   ePriAdd,
   ePriCompName,
   ePriJoin,
   ePriMove,
   ePriQuery,
   ePriRemove,
   ePriRename,
   ePriRenameComputer,
   ePriReset,
   ePriResetPwd,
   ePriTrust,
   ePriVerify,
   ePriTime,
   ePriEnd = ePriTime,

   //
   // Object argument.
   //
   eObject = eArgBegin,

   //
   // Query sub-commands.
   //
   eQueryBegin,
   eQueryPDC = eQueryBegin,
   eQueryServer,
   eQueryWksta,
   eQueryDC,
   eQueryOU,
   eQueryFSMO,
   eQueryTrust,
   eQueryEnd = eQueryTrust,

   //
   // Common switches
   //
   eCommHelp,
   eCommQHelp,
   eCommUserNameO,
   eCommPasswordO,
   eCommUserNameD,
   eCommPasswordD,
   eCommDomain,
   eCommOU,
   eCommVerify,
   eCommVerbose,
   eCommServer,
   eCommReset,
   eCommRestart,
   eCommForce,

   //
   // Help switch
   //
   eHelpSyntax,

   //
   // Add switch
   //
   eAddDC,

   //
   // Move switches
   //
   eMoveUserNameF,
   eMovePasswordF,

   //
   // Query switch
   //
   eQueryDirect,

   //
   // Rename Computer switch
   //
   eRenCompNewName,

   //
   // Trust switches (add and remove also used by CompName)
   //
   eTrustRealm,
   eTrustPasswordT,
   eCommAdd,
   eCommRemove,
   eTrustTwoWay,
   eTrustKerberos,
   eTrustTransitive,
   eTrustOneSide,
   eTrustNameSuffixes,
   eTrustToggleSuffixes,
   eTrustFilterSIDs,

   //
   // ComputerName switches.
   //
   eCompNameMakePri,
   eCompNameEnum,

   eArgEnd,
   eArgError,
   eArgNull
} NETDOM_ARG_ENUM;

//
// The parser tables
//
extern ARG_RECORD rgNetDomPriArgs[];
extern ARG_RECORD rgNetDomArgs[];

#endif //_CMDTABLE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netdom\compname.cxx ===
//+----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:      CompName.h
//
//  Contents:  Definitions for the computer name management code.
//
//  History:   20-April-2001    EricB  Created
//
//-----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "netdom.h"
#include "CompName.h"

//+----------------------------------------------------------------------------
//
//  Function:  NetDomComputerNames
//
//  Synopsis:  Entry point for the computer name command.
//
//  Arguments: [rgNetDomArgs] - The command line argument array.
//
//-----------------------------------------------------------------------------
DWORD
NetDomComputerNames(ARG_RECORD * rgNetDomArgs)
{
   DWORD Win32Err = ERROR_SUCCESS;

   Win32Err = NetDompValidateSecondaryArguments(rgNetDomArgs,
                                                eObject,
                                                eCommUserNameO,
                                                eCommPasswordO,
                                                eCommUserNameD,
                                                eCommPasswordD,
                                                eCommAdd,
                                                eCommRemove,
                                                eCompNameMakePri,
                                                eCompNameEnum,
                                                eCommVerbose,
                                                eArgEnd);
   if (ERROR_SUCCESS != Win32Err)
   {
      DisplayHelp(ePriCompName);
      return Win32Err;
   }

   PWSTR pwzMachine = rgNetDomArgs[eObject].strValue;

   if (!pwzMachine)
   {
      DisplayHelp(ePriCompName);
      return ERROR_INVALID_PARAMETER;
   }

   //
   // Get the users and passwords if they were entered.
   //
   ND5_AUTH_INFO MachineUser = {0}, DomainUser = {0};

   if (CmdFlagOn(rgNetDomArgs, eCommUserNameO))
   {
      Win32Err = NetDompGetUserAndPasswordForOperation(rgNetDomArgs,
                                                       eCommUserNameO,
                                                       pwzMachine,
                                                       &MachineUser);
      if (ERROR_SUCCESS != Win32Err)
      {
         DisplayHelp(ePriCompName);
         return Win32Err;
      }
   }

   if (CmdFlagOn(rgNetDomArgs, eCommUserNameD))
   {
      Win32Err = NetDompGetUserAndPasswordForOperation(rgNetDomArgs,
                                                       eCommUserNameD,
                                                       pwzMachine,
                                                       &DomainUser);
      if (ERROR_SUCCESS != Win32Err)
      {
         DisplayHelp(ePriCompName);
         goto CompNameExit;
      }
   }

   //
   // See which name operation is specified.
   //
   bool fHaveOp = false;
   PWSTR pwzOp = NULL;
   NETDOM_ARG_ENUM eOp = eArgNull, eBadOp = eArgNull;

   if (CmdFlagOn(rgNetDomArgs, eCommAdd))
   {
      Win32Err = NetDompGetArgumentString(rgNetDomArgs,
                                          eCommAdd,
                                          &pwzOp);
      if (NO_ERROR == Win32Err)
      {
         eOp = eCommAdd;
      }
   }

   if (CmdFlagOn(rgNetDomArgs, eCommRemove))
   {
      Win32Err = NetDompGetArgumentString(rgNetDomArgs,
                                          eCommRemove,
                                          &pwzOp);
      if (NO_ERROR == Win32Err)
      {
         if (eArgNull == eOp)
         {
            eOp = eCommRemove;
         }
         else
         {
            eBadOp = eCommRemove;
         }
      }
   }

   if (CmdFlagOn(rgNetDomArgs, eCompNameMakePri))
   {
      Win32Err = NetDompGetArgumentString(rgNetDomArgs,
                                          eCompNameMakePri,
                                          &pwzOp);
      if (NO_ERROR == Win32Err)
      {
         if (eArgNull == eOp)
         {
            eOp = eCompNameMakePri;
         }
         else
         {
            eBadOp = eCompNameMakePri;
         }
      }
   }

   if (CmdFlagOn(rgNetDomArgs, eCompNameEnum))
   {
      Win32Err = NetDompGetArgumentString(rgNetDomArgs,
                                          eCompNameEnum,
                                          &pwzOp);
      if (NO_ERROR == Win32Err)
      {
         if (eArgNull == eOp)
         {
            eOp = eCompNameEnum;
         }
         else
         {
            eBadOp = eCompNameEnum;
         }
      }
   }

   if (eArgNull != eBadOp)
   {
      ASSERT(rgNetDomArgs[eBadOp].strArg1);
      NetDompDisplayUnexpectedParameter(rgNetDomArgs[eBadOp].strArg1);
      DisplayHelp(ePriCompName);
      Win32Err = ERROR_INVALID_PARAMETER;
      goto CompNameExit;
   }

   if (eArgNull == eOp)
   {
      DisplayHelp(ePriCompName);
      Win32Err = ERROR_INVALID_PARAMETER;
      goto CompNameExit;
   }

   if (CmdFlagOn(rgNetDomArgs, eCommUserNameO))
   {
      LOG_VERBOSE((MSG_VERBOSE_ESTABLISH_SESSION, pwzMachine));
      Win32Err = NetpManageIPCConnect(pwzMachine,
                                      MachineUser.User,
                                      MachineUser.Password,
                                      NETSETUPP_CONNECT_IPC);
   }

   if (NO_ERROR != Win32Err)
   {
      goto CompNameExit;
   }

   //
   // Do the operation.
   //
   switch (eOp)
   {
   case eCommAdd:
      if (!rgNetDomArgs[eCommAdd].strValue ||
          !wcslen(rgNetDomArgs[eCommAdd].strValue))
      {
         DisplayHelp(ePriCompName);
         Win32Err = ERROR_INVALID_PARAMETER;
         goto CompNameExit;
      }
      Win32Err = NetAddAlternateComputerName(pwzMachine,
                                             rgNetDomArgs[eCommAdd].strValue,
                                             DomainUser.User,
                                             DomainUser.Password,
                                             0);
      if (NO_ERROR == Win32Err)
      {
         NetDompDisplayMessage(MSG_COMPNAME_ADD, rgNetDomArgs[eCommAdd].strValue);
      }
      else
      {
         NetDompDisplayMessage(MSG_COMPNAME_ADD_FAIL, rgNetDomArgs[eCommAdd].strValue);
         NetDompDisplayErrorMessage(Win32Err);
      }
      break;

   case eCommRemove:
      if (!rgNetDomArgs[eCommRemove].strValue ||
          !wcslen(rgNetDomArgs[eCommRemove].strValue))
      {
         DisplayHelp(ePriCompName);
         Win32Err = ERROR_INVALID_PARAMETER;
         goto CompNameExit;
      }
      Win32Err = NetRemoveAlternateComputerName(pwzMachine,
                                                rgNetDomArgs[eCommRemove].strValue,
                                                DomainUser.User,
                                                DomainUser.Password,
                                                0);
      if (NO_ERROR == Win32Err)
      {
         NetDompDisplayMessage(MSG_COMPNAME_REM, rgNetDomArgs[eCommRemove].strValue);
      }
      else
      {
         NetDompDisplayMessage(MSG_COMPNAME_REM_FAIL, rgNetDomArgs[eCommRemove].strValue);
         NetDompDisplayErrorMessage(Win32Err);
      }
      break;

   case eCompNameMakePri:
      if (!rgNetDomArgs[eCompNameMakePri].strValue ||
          !wcslen(rgNetDomArgs[eCompNameMakePri].strValue))
      {
         DisplayHelp(ePriCompName);
         Win32Err = ERROR_INVALID_PARAMETER;
         goto CompNameExit;
      }
      Win32Err = NetSetPrimaryComputerName(pwzMachine,
                                           rgNetDomArgs[eCompNameMakePri].strValue,
                                           DomainUser.User,
                                           DomainUser.Password,
                                           0);
      if (NO_ERROR == Win32Err)
      {
         NetDompDisplayMessage(MSG_COMPNAME_MAKEPRI, rgNetDomArgs[eCompNameMakePri].strValue);
      }
      else
      {
         NetDompDisplayMessage(MSG_COMPNAME_MAKEPRI_FAIL, rgNetDomArgs[eCompNameMakePri].strValue);
         NetDompDisplayErrorMessage(Win32Err);
      }
      break;

   case eCompNameEnum:
      {
         NET_COMPUTER_NAME_TYPE NameType = NetAllComputerNames;
         WCHAR wzBuf[MAX_PATH+1];
         DWORD dwMsgID = MSG_COMPNAME_ENUMALL;

         if (rgNetDomArgs[eCompNameEnum].strValue &&
             wcslen(rgNetDomArgs[eCompNameEnum].strValue))
         {
            if (!LoadString(g_hInstance, IDS_ENUM_ALT, wzBuf, MAX_PATH))
            {
               Win32Err = GetLastError();
               goto CompNameExit;
            }
            if (_wcsicmp(wzBuf, rgNetDomArgs[eCompNameEnum].strValue) == 0)
            {
               NameType = NetAlternateComputerNames;
               dwMsgID = MSG_COMPNAME_ENUMALT;
            }
            else
            {
               if (!LoadString(g_hInstance, IDS_ENUM_PRI, wzBuf, MAX_PATH))
               {
                  Win32Err = GetLastError();
                  goto CompNameExit;
               }
               if (_wcsicmp(wzBuf, rgNetDomArgs[eCompNameEnum].strValue) == 0)
               {
                  NameType = NetPrimaryComputerName;
                  dwMsgID = MSG_COMPNAME_ENUMPRI;
               }
               else
               {
                  if (!LoadString(g_hInstance, IDS_ENUM_ALL, wzBuf, MAX_PATH))
                  {
                     Win32Err = GetLastError();
                     goto CompNameExit;
                  }
                  if (_wcsicmp(wzBuf, rgNetDomArgs[eCompNameEnum].strValue) == 0)
                  {
                     NameType = NetAllComputerNames;
                     dwMsgID = MSG_COMPNAME_ENUMALL;
                  }
                  else
                  {
                     NetDompDisplayUnexpectedParameter(rgNetDomArgs[eCompNameEnum].strValue);
                     DisplayHelp(ePriCompName);
                     Win32Err = ERROR_INVALID_PARAMETER;
                     goto CompNameExit;
                  }
               }
            }
         }
         DWORD dwCount = 0;
         PWSTR * rgpwzNames = NULL;
         DBG_VERBOSE(("NetEnumerateComputerNames(%ws, %d, 0, etc)\n", pwzMachine, NameType));

         Win32Err = NetEnumerateComputerNames(pwzMachine,
                                              NameType,
                                              0,
                                              &dwCount,
                                              &rgpwzNames);
         if (NO_ERROR != Win32Err)
         {
            NetDompDisplayErrorMessage(Win32Err);
            goto CompNameExit;
         }
         NetDompDisplayMessage(dwMsgID);
         for (DWORD i = 0; i < dwCount; i++)
         {
            ASSERT(rgpwzNames[i]);
            printf("%ws\n", rgpwzNames[i]);
         }
         if (rgpwzNames)
         {
            NetApiBufferFree(rgpwzNames);
         }
      }
      break;

   default:
      ASSERT(FALSE);
      Win32Err = ERROR_INVALID_PARAMETER;
      goto CompNameExit;
   }

CompNameExit:

   if (CmdFlagOn(rgNetDomArgs, eCommUserNameO))
   {
      LOG_VERBOSE((MSG_VERBOSE_DELETE_SESSION, pwzMachine));
      NetpManageIPCConnect(pwzMachine,
                           MachineUser.User,
                           MachineUser.Password,
                           NETSETUPP_DISCONNECT_IPC);
   }

   NetDompFreeAuthIdent(&MachineUser);
   NetDompFreeAuthIdent(&DomainUser);

   return Win32Err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netdom\join.cxx ===
/*++

Microsoft Windows

Copyright (C) Microsoft Corporation, 1998 - 2001

Module Name:

    join.c

Abstract:

    Handles the various functions for joining a machine to a domain, including creating and
    deleting machine accounts and managing domain membership

--*/
#include "pch.h"
#pragma hdrstop
#include <netdom.h>


DWORD
NetDompHandleAdd(ARG_RECORD * rgNetDomArgs)
/*++

Routine Description:

    This function will add a machine account to the domain using the default password

Arguments:

    Args - List of command line arguments

Return Value:

    ERROR_INVALID_PARAMETER - No object name was supplied

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    PWSTR Domain = NULL;
    ND5_AUTH_INFO DomainUser;
    PWSTR Server = NULL, OU = NULL, FullServer = NULL;
    PDOMAIN_CONTROLLER_INFO pDcInfo = NULL;
    ULONG DsGetDcOptions = 0, Length;
    WCHAR DefaultPassword[ LM20_PWLEN + 1 ];
    WCHAR DefaultMachineAccountName[ MAX_COMPUTERNAME_LENGTH + 2 ];
    USER_INFO_1 NetUI1;

    RtlZeroMemory( &DomainUser, sizeof( ND5_AUTH_INFO ) );

    Win32Err = NetDompValidateSecondaryArguments(rgNetDomArgs,
                                                 eObject,
                                                 eCommDomain,
                                                 eCommOU,
                                                 eCommUserNameD,
                                                 eCommPasswordD,
                                                 eCommServer,
                                                 eAddDC,
                                                 eCommVerbose,
                                                 eArgEnd);
    if ( Win32Err != ERROR_SUCCESS ) {

        DisplayHelp(ePriAdd);
        return( ERROR_INVALID_PARAMETER );
    }

    PWSTR Object = rgNetDomArgs[eObject].strValue;

    if ( !Object ) {

        DisplayHelp(ePriAdd);
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // Make sure that the object name we were given is valid
    //
    Win32Err = I_NetNameValidate( NULL,
                                  Object,
                                  NAMETYPE_COMPUTER,
                                  LM2X_COMPATIBLE );
    if ( Win32Err != ERROR_SUCCESS ) {

        goto HandleAddExit;
    }

    //
    // Get the server if it exists
    //
    Win32Err = NetDompGetArgumentString(rgNetDomArgs,
                                        eCommServer,
                                        &Server);

    if ( Win32Err != ERROR_SUCCESS ) {

        goto HandleAddExit;
    }

    //
    // Get the domain.
    //
    Win32Err = NetDompGetDomainForOperation(rgNetDomArgs,
                                            Server,
                                            TRUE,
                                            &Domain);

    if ( Win32Err != ERROR_SUCCESS ) {

        goto HandleAddExit;
    }

    //
    // Get the password and user if it exists
    //
    if ( CmdFlagOn(rgNetDomArgs, eCommUserNameD) ) {

        Win32Err = NetDompGetUserAndPasswordForOperation(rgNetDomArgs,
                                                         eCommUserNameD,
                                                         Domain,
                                                         &DomainUser);

        if ( Win32Err != ERROR_SUCCESS ) {

            goto HandleAddExit;
        }
    }

    //
    // Get the OU if it exists
    //
    Win32Err = NetDompGetArgumentString(rgNetDomArgs,
                                        eCommOU,
                                        &OU);

    if ( Win32Err != ERROR_SUCCESS ) {

        goto HandleAddExit;
    }

    //
    // Get the name of a server for the domain
    //
    if ( Server == NULL || CmdFlagOn(rgNetDomArgs, eAddDC)) {

        LOG_VERBOSE(( MSG_VERBOSE_FIND_DC, Domain ));
        DsGetDcOptions = DS_WRITABLE_REQUIRED;

        if ( OU ) {

            DsGetDcOptions |= DS_DIRECTORY_SERVICE_REQUIRED;

        } else {

            DsGetDcOptions |= DS_DIRECTORY_SERVICE_PREFERRED;
        }

        Win32Err = DsGetDcName( Server,
                                Domain,
                                NULL,
                                NULL,
                                DsGetDcOptions,
                                &pDcInfo );

        if ( Win32Err == ERROR_SUCCESS ) {

            Server = pDcInfo->DomainControllerName;
        }
    }

    if ( Win32Err != ERROR_SUCCESS ) {

        goto HandleAddExit;
    }

    //
    // Set the default password as the first 14 characters of the machine name, lowercased
    //
    wcsncpy( DefaultPassword, Object, LM20_PWLEN );
    DefaultPassword[ LM20_PWLEN ] = UNICODE_NULL;
    _wcslwr( DefaultPassword );

    //
    // Ok, now, do the add
    //
    if ( OU ) {

        LOG_VERBOSE(( MSG_VERBOSE_CREATE_ACCT_OU, Object, OU ));

        //
        // Use the Ds routines
        //

        if (CmdFlagOn(rgNetDomArgs, eAddDC) ||
            CmdFlagOn(rgNetDomArgs, eCommServer))
        {
           //
           // Don't support adding domain controllers in different OU's,
           // domain controllers are always in the Domain Controllers OU
           // Can't specify a server name since the OU add must be run directly
           // on a DC.
           //
           Win32Err = ERROR_INVALID_PARAMETER;
           goto HandleAddExit;
        }
        else
        {
           Win32Err = NetpCreateComputerObjectInDs(pDcInfo,
                                                   DomainUser.User,
                                                   DomainUser.Password,
                                                   Object,
                                                   DefaultPassword,
                                                   NULL,
                                                   OU);
        }

    } else {

        LOG_VERBOSE(( MSG_VERBOSE_ESTABLISH_SESSION, Server ));
        Win32Err = NetpManageIPCConnect( Server,
                                         DomainUser.User,
                                         DomainUser.Password,
                                         NETSETUPP_CONNECT_IPC );

        if ( Win32Err == ERROR_SUCCESS ) {

            wcsncpy( DefaultMachineAccountName, Object, MAX_COMPUTERNAME_LENGTH );
            DefaultMachineAccountName[ MAX_COMPUTERNAME_LENGTH ] = L'\0';
            wcscat( DefaultMachineAccountName, L"$" );

            RtlZeroMemory( &NetUI1, sizeof( NetUI1 ) );

            //
            // Initialize it..
            //
            NetUI1.usri1_name = DefaultMachineAccountName;
            NetUI1.usri1_password = DefaultPassword;

            if (CmdFlagOn(rgNetDomArgs, eAddDC))
            {
                NetUI1.usri1_flags  = UF_SERVER_TRUST_ACCOUNT | UF_SCRIPT;
            }
            else
            {
                NetUI1.usri1_flags  = UF_WORKSTATION_TRUST_ACCOUNT | UF_SCRIPT;
            }

            NetUI1.usri1_priv = USER_PRIV_USER;

            if ( Server && *Server != L'\\' ) {

                Win32Err = NetApiBufferAllocate( ( wcslen( Server ) + 3 ) * sizeof( WCHAR ),
                                                 (PVOID*)&FullServer );

                if ( Win32Err == ERROR_SUCCESS ) {

                    swprintf( FullServer, L"\\\\%ws", Server );
                }

            } else {

                FullServer = Server;
            }

            if ( Win32Err == ERROR_SUCCESS ) {

                LOG_VERBOSE(( MSG_VERBOSE_CREATE_ACCT, Object ));
                Win32Err = NetUserAdd( FullServer,
                                       1,
                                       ( PBYTE )&NetUI1,
                                       NULL );
            }

            LOG_VERBOSE(( MSG_VERBOSE_DELETE_SESSION, Server ));
            NetpManageIPCConnect( Server,
                                  DomainUser.User,
                                  DomainUser.Password,
                                  NETSETUPP_DISCONNECT_IPC );
        }

    }

HandleAddExit:

    NetApiBufferFree( Domain );
    NetApiBufferFree( OU );

    NetDompFreeAuthIdent( &DomainUser );

    if ( pDcInfo ) {

        NetApiBufferFree( pDcInfo );

    } else {

        NetApiBufferFree( Server );
    }

    if ( FullServer != Server ) {

        NetApiBufferFree( FullServer );
    }

    if (NO_ERROR != Win32Err)
    {
        NetDompDisplayErrorMessage(Win32Err);
    }

    return( Win32Err );
}



DWORD
NetDompHandleRemove(ARG_RECORD * rgNetDomArgs)
/*++

Routine Description:

    This function will remove a machine from the domain

Arguments:

    Args - List of command line arguments

Return Value:

    ERROR_INVALID_PARAMETER - No object name was supplied

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    PWSTR Domain = NULL;
    ND5_AUTH_INFO DomainUser, ObjectUser;
    WCHAR DefaultMachineAccountName[ MAX_COMPUTERNAME_LENGTH + 2 ];
    USER_INFO_1 NetUI1;
    BOOL NeedReboot = FALSE;

    RtlZeroMemory( &DomainUser, sizeof( ND5_AUTH_INFO ) );
    RtlZeroMemory( &ObjectUser, sizeof( ND5_AUTH_INFO ) );

    Win32Err = NetDompValidateSecondaryArguments(rgNetDomArgs,
                                                 eObject,
                                                 eCommDomain,
                                                 eCommUserNameO,
                                                 eCommPasswordO,
                                                 eCommUserNameD,
                                                 eCommPasswordD,
                                                 eCommRestart,
                                                 eCommVerbose,
                                                 eArgEnd);
    if ( Win32Err != ERROR_SUCCESS ) {

        DisplayHelp(ePriRemove);
        return( ERROR_INVALID_PARAMETER );
    }

    PWSTR Object = rgNetDomArgs[eObject].strValue;

    if ( !Object ) {

        DisplayHelp(ePriRemove);
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // Make sure that we have a specified domain...
    //
    Win32Err = NetDompGetDomainForOperation(rgNetDomArgs,
                                            Object,
                                            TRUE,
                                            &Domain);

    if ( Win32Err != ERROR_SUCCESS ) {

        goto HandleRemoveExit;
    }

    //
    // Get the password and user if it exists
    //
    if ( CmdFlagOn(rgNetDomArgs, eCommUserNameD) ) {

        Win32Err = NetDompGetUserAndPasswordForOperation(rgNetDomArgs,
                                                         eCommUserNameD,
                                                         Domain,
                                                         &DomainUser);

        if ( Win32Err != ERROR_SUCCESS ) {

            goto HandleRemoveExit;
        }
    }

    if ( CmdFlagOn(rgNetDomArgs, eCommUserNameO) ) {

        Win32Err = NetDompGetUserAndPasswordForOperation(rgNetDomArgs,
                                                         eCommUserNameO,
                                                         Object,
                                                         &ObjectUser);

        if ( Win32Err != ERROR_SUCCESS ) {

            goto HandleRemoveExit;
        }
    }

    //
    // See if the reboot argument is specified
    //
    NeedReboot = NetDompGetArgumentBoolean(rgNetDomArgs,
                                           eCommRestart);
    //
    // Try and unjoin the specified machine from the network by speaking directly to that
    // machine
    //
    LOG_VERBOSE(( MSG_VERBOSE_ESTABLISH_SESSION, Object ));
    Win32Err = NetpManageIPCConnect( Object,
                                     ObjectUser.User,
                                     ObjectUser.Password,
                                     NETSETUPP_CONNECT_IPC );
    if ( Win32Err == ERROR_SUCCESS ) {

        // NETSETUP_ACCT_DELETE means disable the old account object.
        //
        Win32Err = NetUnjoinDomain( Object,
                                    DomainUser.User,
                                    DomainUser.Password,
                                    NETSETUP_ACCT_DELETE );

        LOG_VERBOSE(( MSG_VERBOSE_DELETE_SESSION, Object ));
        NetpManageIPCConnect( Object,
                              ObjectUser.User,
                              ObjectUser.Password,
                              NETSETUPP_DISCONNECT_IPC );
    } else {

        LOG_VERBOSE(( MSG_VERBOSE_SESSION_FAILED, Object ));
        ERROR_VERBOSE( Win32Err );
    }

    if ( NeedReboot ) {

        NetDompRestartAsRequired(rgNetDomArgs,
                                 Object,
                                 ObjectUser.User,
                                 Win32Err,
                                 MSG_DOMAIN_CHANGE_RESTART_MSG);
    }

HandleRemoveExit:

    NetApiBufferFree( Domain );
    NetDompFreeAuthIdent( &DomainUser );
    NetDompFreeAuthIdent( &ObjectUser );

    if (NO_ERROR != Win32Err)
    {
        NetDompDisplayErrorMessage(Win32Err);
    }

    return( Win32Err );
}



DWORD
NetDompHandleJoin(ARG_RECORD * rgNetDomArgs, BOOL AllowMove)
/*++

Routine Description:

    This function will join a machine to the domain

Arguments:

    Args - List of command line arguments

    AllowMove - If TRUE, allow the join if the machine is already joined to a domain

Return Value:

    ERROR_INVALID_PARAMETER - No object name was supplied

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    USER_INFO_1 * pui1 = NULL;
    PWSTR pwzNewDomain = NULL, pwzOldDomain = NULL, OU = NULL;
    ND5_AUTH_INFO DomainUser, WkstaUser, FormerDomainUser;
    ULONG JoinOptions = 0;
    BOOL NeedReboot = FALSE, fConnectedO = FALSE;

    RtlZeroMemory( &DomainUser, sizeof( ND5_AUTH_INFO ) );
    RtlZeroMemory( &WkstaUser, sizeof( ND5_AUTH_INFO ) );
    RtlZeroMemory( &FormerDomainUser, sizeof( ND5_AUTH_INFO ) );

    if (AllowMove)
    {
       Win32Err = NetDompValidateSecondaryArguments(rgNetDomArgs,
                                                    eObject,
                                                    eCommDomain,
                                                    eCommOU,
                                                    eCommUserNameO,
                                                    eCommPasswordO,
                                                    eCommUserNameD,
                                                    eCommPasswordD,
                                                    eMoveUserNameF,
                                                    eMovePasswordF,
                                                    eCommRestart,
                                                    eCommVerbose,
                                                    eArgEnd);
    }
    else
    {
       Win32Err = NetDompValidateSecondaryArguments(rgNetDomArgs,
                                                    eObject,
                                                    eCommDomain,
                                                    eCommOU,
                                                    eCommUserNameO,
                                                    eCommPasswordO,
                                                    eCommUserNameD,
                                                    eCommPasswordD,
                                                    eCommRestart,
                                                    eCommVerbose,
                                                    eArgEnd);
    }

    if ( Win32Err != ERROR_SUCCESS ) {

        DisplayHelp((AllowMove) ? ePriMove : ePriJoin);
        return( ERROR_INVALID_PARAMETER );
    }

    PWSTR pwzWksta = rgNetDomArgs[eObject].strValue;

    if ( !pwzWksta ) {

        DisplayHelp((AllowMove) ? ePriMove : ePriJoin);
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // Ok, make sure that we have a specified domain...
    //
    Win32Err = NetDompGetDomainForOperation(rgNetDomArgs,
                                            NULL,
                                            FALSE,
                                            &pwzNewDomain);

    if ( Win32Err != ERROR_SUCCESS ) {

        goto HandleJoinExit;
    }

    //
    // Get the password and user for the new domain if specified on command line.
    //
    if ( CmdFlagOn(rgNetDomArgs, eCommUserNameD) ) {

        Win32Err = NetDompGetUserAndPasswordForOperation(rgNetDomArgs,
                                                         eCommUserNameD,
                                                         pwzNewDomain,
                                                         &DomainUser);

        if ( Win32Err != ERROR_SUCCESS ) {

            goto HandleJoinExit;
        }
    }

    //
    // Get the password and user for the workstation and establish the
    // connection if the args are specified on the command line.
    //
    if ( CmdFlagOn(rgNetDomArgs, eCommUserNameO) ) {

        Win32Err = NetDompGetUserAndPasswordForOperation(rgNetDomArgs,
                                                         eCommUserNameO,
                                                         pwzWksta,
                                                         &WkstaUser);

        if ( Win32Err != ERROR_SUCCESS ) {

            goto HandleJoinExit;
        }

        LOG_VERBOSE((MSG_VERBOSE_ESTABLISH_SESSION, pwzWksta));
        Win32Err = NetpManageIPCConnect(pwzWksta,
                                        WkstaUser.User,
                                        WkstaUser.Password,
                                        NETSETUPP_CONNECT_IPC);
        if (ERROR_SUCCESS != Win32Err)
        {
            LOG_VERBOSE((MSG_VERBOSE_SESSION_FAILED, pwzWksta));
            goto HandleJoinExit;
        }

        fConnectedO = TRUE;
    }

    if (AllowMove)
    {
        // Get the machine's current domain membership. This must be done after
        // the NetpManageIPCConnect above so as to have rights to read the info.
        //
        Win32Err = NetDompGetDomainForOperation(NULL,
                                                pwzWksta,
                                                TRUE,
                                                &pwzOldDomain);

        if (ERROR_INVALID_PARAMETER == Win32Err)
        {
            // ERROR_INVALID_PARAMETER is returned by NetDompGetDomainForOperation
            // if the machine is not joined to a domain.
            //
            LOG_VERBOSE((MSG_VERBOSE_NOT_JOINED, pwzWksta, pwzNewDomain));
            
            pwzOldDomain = NULL;

            AllowMove = FALSE;
        }
        else
        {
            if (ERROR_SUCCESS != Win32Err)
            {
                ERROR_VERBOSE(Win32Err);
                goto HandleJoinExit;
            }
            if (_wcsicmp(pwzNewDomain, pwzOldDomain) == 0)
            {
                NetDompDisplayMessage(MSG_ALREADY_JOINED, pwzNewDomain);
                Win32Err = ERROR_DS_CROSS_DOM_MOVE_ERROR;
                goto HandleJoinExit;
            }
        }
    }

    if (AllowMove && CmdFlagOn(rgNetDomArgs, eMoveUserNameF))
    {
        //
        // Get the password and user for the former domain if specified on command line.
        //
        Win32Err = NetDompGetUserAndPasswordForOperation(rgNetDomArgs,
                                                         eMoveUserNameF,
                                                         pwzOldDomain,
                                                         &FormerDomainUser);
        if (ERROR_SUCCESS != Win32Err)
        {
            goto HandleJoinExit;
        }
    }

    //
    // See if the reboot argument is specified
    //
    NeedReboot = NetDompGetArgumentBoolean(rgNetDomArgs,
                                           eCommRestart);
    //
    // Get the OU if it exists
    //
    Win32Err = NetDompGetArgumentString(rgNetDomArgs,
                                        eCommOU,
                                        &OU);

    if ( Win32Err != ERROR_SUCCESS ) {

        goto HandleJoinExit;
    }

    //
    // Try and join the specified machine to the domain by speaking directly to that
    // machine
    //
    JoinOptions = NETSETUP_JOIN_DOMAIN | NETSETUP_ACCT_CREATE;

    if ( AllowMove ) {

        JoinOptions |= NETSETUP_DOMAIN_JOIN_IF_JOINED;
    }

    LOG_VERBOSE(( MSG_VERBOSE_DOMAIN_JOIN, pwzNewDomain ));
    Win32Err = NetJoinDomain( pwzWksta,
                              pwzNewDomain,
                              OU,
                              DomainUser.User,
                              DomainUser.Password,
                              JoinOptions );

    if (Win32Err == RPC_S_PROCNUM_OUT_OF_RANGE)
    {
        //
        // Try the NT4 unjoin
        //
        PDOMAIN_CONTROLLER_INFO pDcInfo = NULL;
        NeedReboot = TRUE;

        LOG_VERBOSE(( MSG_VERBOSE_FIND_DC, pwzNewDomain ));

        Win32Err = DsGetDcName( NULL,
                                pwzNewDomain,
                                NULL,
                                NULL,
                                DS_WRITABLE_REQUIRED | DS_DIRECTORY_SERVICE_PREFERRED,
                                &pDcInfo );

        if ( Win32Err == ERROR_SUCCESS ) {

            LOG_VERBOSE(( MSG_VERBOSE_ESTABLISH_SESSION, pDcInfo->DomainControllerName ));
            Win32Err = NetpManageIPCConnect( pDcInfo->DomainControllerName,
                                             DomainUser.User,
                                             DomainUser.Password,
                                             NETSETUPP_CONNECT_IPC );

            if ( Win32Err == ERROR_SUCCESS ) {

                Win32Err = NetDompJoinDownlevel( pwzWksta,
                                                 DomainUser.User,
                                                 DomainUser.Password,
                                                 pDcInfo->DomainControllerName,
                                                 pDcInfo->Flags,
                                                 AllowMove );

                LOG_VERBOSE(( MSG_VERBOSE_DELETE_SESSION, pDcInfo->DomainControllerName ));
                NetpManageIPCConnect( pDcInfo->DomainControllerName,
                                      DomainUser.User,
                                      DomainUser.Password,
                                      NETSETUPP_DISCONNECT_IPC );
            } else {

                LOG_VERBOSE(( MSG_VERBOSE_SESSION_FAILED, pDcInfo->DomainControllerName ));
                ERROR_VERBOSE( Win32Err );
            }
        }
        NetApiBufferFree( pDcInfo );
    }
    else
    {
        if (ERROR_SUCCESS != Win32Err)
        {
            LOG_VERBOSE(( MSG_VERBOSE_MOVE_COMPUTER_FAILED, Win32Err ));
            goto HandleJoinExit;
        }
        //
        // Uplevel join successful. If a Move operation, disable the old account.
        //
        if (AllowMove && pwzOldDomain)
        {
            PDOMAIN_CONTROLLER_INFO pOldDcInfo = NULL;

            LOG_VERBOSE((MSG_VERBOSE_DISABLE_OLD_ACCT, pwzOldDomain));

            Win32Err = DsGetDcName(NULL,
                                   pwzOldDomain,
                                   NULL,
                                   NULL,
                                   DS_WRITABLE_REQUIRED,
                                   &pOldDcInfo);

            if (ERROR_SUCCESS == Win32Err)
            {
                LOG_VERBOSE((MSG_VERBOSE_ESTABLISH_SESSION, pOldDcInfo->DomainControllerName));
                Win32Err = NetpManageIPCConnect(pOldDcInfo->DomainControllerName,
                                                FormerDomainUser.User,
                                                FormerDomainUser.Password,
                                                NETSETUPP_CONNECT_IPC );
                if (ERROR_SUCCESS == Win32Err)
                {
                    PWSTR pwzWkstaDollar;

                    Win32Err = NetApiBufferAllocate((wcslen(pwzWksta) + 2) * sizeof(WCHAR),
                                                    (PVOID*)&pwzWkstaDollar);
                    if (ERROR_SUCCESS == Win32Err)
                    {
                        wcscpy(pwzWkstaDollar, pwzWksta);
                        wcscat(pwzWkstaDollar, L"$");

                        Win32Err = NetUserGetInfo(pOldDcInfo->DomainControllerName,
                                                  pwzWkstaDollar, 1, (PBYTE *)&pui1);

                        if (ERROR_SUCCESS == Win32Err)
                        {
                            pui1->usri1_flags |= UF_ACCOUNTDISABLE;

                            Win32Err = NetUserSetInfo(pOldDcInfo->DomainControllerName,
                                                      pwzWkstaDollar, 1, (PBYTE)pui1, NULL);
                            NetApiBufferFree(pui1);
                        }

                        NetApiBufferFree(pwzWkstaDollar);
                    }

                    LOG_VERBOSE((MSG_VERBOSE_DELETE_SESSION, pOldDcInfo->DomainControllerName));
                    NetpManageIPCConnect(pOldDcInfo->DomainControllerName,
                                         FormerDomainUser.User,
                                         FormerDomainUser.Password,
                                         NETSETUPP_DISCONNECT_IPC);
                }

                NetApiBufferFree(pOldDcInfo);
            }
        }
    }

    if (NeedReboot && (ERROR_SUCCESS == Win32Err))
    {
        NetDompRestartAsRequired(rgNetDomArgs,
                                 pwzWksta,
                                 WkstaUser.User,
                                 Win32Err,
                                 MSG_DOMAIN_CHANGE_RESTART_MSG);
    }

HandleJoinExit:

    if (fConnectedO)
    {
        LOG_VERBOSE((MSG_VERBOSE_DELETE_SESSION, pwzWksta));
        NetpManageIPCConnect(pwzWksta,
                             WkstaUser.User,
                             WkstaUser.Password,
                             NETSETUPP_DISCONNECT_IPC);
    }

    NetApiBufferFree(pwzNewDomain);
    NetDompFreeAuthIdent(&DomainUser);
    NetDompFreeAuthIdent(&FormerDomainUser);
    NetDompFreeAuthIdent(&WkstaUser);
    if (pwzOldDomain)
    {
        NetApiBufferFree(pwzOldDomain);
    }

    if (NO_ERROR != Win32Err)
    {
        NetDompDisplayErrorMessage(Win32Err);
    }

    return( Win32Err );
}



DWORD
NetDompHandleMove(ARG_RECORD * rgNetDomArgs)
/*++

Routine Description:

    This function will move a machine from one domain to another

Arguments:

    SelectedOptions - List of arguments present in the Args list

    Args - List of command line arguments

    ArgCount - Number of arguments in the list

    Object - Name of the machine to join to the domain

Return Value:

    ERROR_INVALID_PARAMETER - No object name was supplied

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;

    Win32Err = NetDompHandleJoin(rgNetDomArgs, TRUE);

    return( Win32Err );
}





DWORD
NetDompResetServerSC(
    IN PWSTR Domain,
    IN PWSTR Server,
    IN PWSTR DomainController, OPTIONAL
    IN PND5_AUTH_INFO AuthInfo,
    IN ULONG OkMessageId,
    IN ULONG FailedMessageId
    )
{
    DWORD Win32Err = ERROR_SUCCESS;
    PWSTR ScDomain = NULL;
    PNETLOGON_INFO_2 NetlogonInfo2 = NULL;
    BOOL DomainMember = FALSE, SessionEstablished = FALSE;

    //
    // If it doesn't, get the name of a server for the domain
    //
    if ( DomainController != NULL ) {

        Win32Err = NetApiBufferAllocate( ( wcslen( Domain ) + 1 +
                                              wcslen( DomainController ) + 1 ) * sizeof( WCHAR ),
                                         (PVOID*)&ScDomain );

        if ( Win32Err == ERROR_SUCCESS ) {

            swprintf( ScDomain, L"%ws\\%ws", Domain, DomainController );
        }

    } else {

        ScDomain = Domain;
    }


    if ( Win32Err == ERROR_SUCCESS ) {

        LOG_VERBOSE(( MSG_VERBOSE_ESTABLISH_SESSION, Server ));
        Win32Err = NetpManageIPCConnect( Server,
                                         AuthInfo->User,
                                         AuthInfo->Password,
                                         NETSETUPP_CONNECT_IPC );

        if ( Win32Err == ERROR_SUCCESS ) {

            SessionEstablished = TRUE;
        }
    }

    //
    // See if we're a domain member or not
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = NetDompCheckDomainMembership( Server,
                                                 AuthInfo,
                                                 FALSE,
                                                 &DomainMember );

        if ( Win32Err == ERROR_SUCCESS && !DomainMember ) {

            Win32Err = NERR_SetupNotJoined;
        }
    }

    if ( Win32Err == ERROR_SUCCESS ) {

        LOG_VERBOSE(( MSG_VERBOSE_RESET_SC, ScDomain ));
        Win32Err = I_NetLogonControl2( Server,
                                       NETLOGON_CONTROL_REDISCOVER,
                                       2,
                                       ( LPBYTE )&ScDomain,
                                       ( LPBYTE *)&NetlogonInfo2 );

        if ( Win32Err == ERROR_NO_SUCH_DOMAIN && ScDomain != Domain ) {

            LOG_VERBOSE(( MSG_VERBOSE_RETRY_RESET_SC, ScDomain, Domain ));

            //
            // Must be using an downlevel domain, so try it again with out the server
            //
            Win32Err = I_NetLogonControl2( Server,
                                           NETLOGON_CONTROL_REDISCOVER,
                                           2,
                                           ( LPBYTE )&Domain,
                                           ( LPBYTE *)&NetlogonInfo2 );

            if ( Win32Err == ERROR_SUCCESS ) {

                LOG_VERBOSE(( MSG_VERBOSE_RESET_NOT_NAMED, Server ));
                Win32Err = I_NetLogonControl2( Server,
                                               NETLOGON_CONTROL_TC_QUERY,
                                               2,
                                               ( LPBYTE )&Domain,
                                               ( LPBYTE *)&NetlogonInfo2 );
            }
        }

        if ( Win32Err == ERROR_SUCCESS ) {

            NetDompDisplayMessage( OkMessageId, _wcsupr( Server ), _wcsupr( Domain ),
                                   _wcsupr( NetlogonInfo2->netlog2_trusted_dc_name ) );

        } else {

            if ( FailedMessageId ) {

                NetDompDisplayMessage( FailedMessageId, _wcsupr( Server ), _wcsupr( Domain ) );
                NetDompDisplayErrorMessage( Win32Err );
            }
        }
    }


    if ( SessionEstablished ) {

        LOG_VERBOSE(( MSG_VERBOSE_DELETE_SESSION, Server ));
        NetpManageIPCConnect( Server,
                              AuthInfo->User,
                              AuthInfo->Password,
                              NETSETUPP_DISCONNECT_IPC );

    }

    NetApiBufferFree( NetlogonInfo2 );
    return( Win32Err );
}



DWORD
NetDompHandleReset(ARG_RECORD * rgNetDomArgs)
/*++

Routine Description:

    This function will reset the secure channel with the domain

Arguments:

    Args - List of command line arguments

Return Value:

    ERROR_INVALID_PARAMETER - No object name was supplied

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    PWSTR Domain = NULL;
    ND5_AUTH_INFO ObjectUser;
    PWSTR Server = NULL;

    RtlZeroMemory( &ObjectUser, sizeof( ND5_AUTH_INFO ) );

    Win32Err = NetDompValidateSecondaryArguments(rgNetDomArgs,
                                                 eObject,
                                                 eCommDomain,
                                                 eCommUserNameO,
                                                 eCommPasswordO,
                                                 eCommServer,
                                                 eCommVerbose,
                                                 eArgEnd);
    if ( Win32Err != ERROR_SUCCESS ) {

        DisplayHelp(ePriReset);
        return( ERROR_INVALID_PARAMETER );
    }

    PWSTR Object = rgNetDomArgs[eObject].strValue;

    if ( !Object ) {

        DisplayHelp(ePriReset);
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // Make sure that the object name we were given is valid
    //
    Win32Err = I_NetNameValidate( NULL,
                                  Object,
                                  NAMETYPE_COMPUTER,
                                  LM2X_COMPATIBLE );
    if ( Win32Err != ERROR_SUCCESS ) {

        goto HandleResetExit;
    }

    //
    // Ok, make sure that we have a specified domain...
    //
    Win32Err = NetDompGetDomainForOperation(rgNetDomArgs,
                                            Object,
                                            TRUE,
                                            &Domain);

    if ( Win32Err != ERROR_SUCCESS ) {

        goto HandleResetExit;
    }

    //
    // Get the password and user if it exists
    //
    Win32Err = NetDompGetUserAndPasswordForOperation(rgNetDomArgs,
                                                     eCommUserNameO,
                                                     Domain,
                                                     &ObjectUser);

    if ( Win32Err != ERROR_SUCCESS ) {

        goto HandleResetExit;
    }


    //
    // Get the server if it exists
    //
    Win32Err = NetDompGetArgumentString(rgNetDomArgs,
                                        eCommServer,
                                        &Server);

    if ( Win32Err != ERROR_SUCCESS ) {

        goto HandleResetExit;
    }

    Win32Err = NetDompResetServerSC( Domain,
                                     Object,
                                     Server,
                                     &ObjectUser,
                                     MSG_RESET_OK,
                                     MSG_RESET_BAD );

HandleResetExit:

    NetDompFreeAuthIdent( &ObjectUser );

    NetApiBufferFree( Server );

    NetApiBufferFree( Domain );

    if (NO_ERROR != Win32Err)
    {
        NetDompDisplayErrorMessage(Win32Err);
    }

    return( Win32Err );
}


DWORD
NetDompResetPwd(
    IN PWSTR DomainController, 
    IN PND5_AUTH_INFO AuthInfo,
    IN ULONG OkMessageId,
    IN ULONG FailedMessageId
    )
/*++

Routine Description:

    This function reset machine account password for the local machine
    on the specified domain controller.

Arguments:
    DomainController - name of dc

    AuthInfo         - user/password that has admin access on
                       the local machine and on DomainController

    OkMessageId      - message to display on success

    FailedMessageId  - message to display on failure

Return Value:

    win32 error as returned by NetpSetComputerAccountPassword

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    BOOL DomainMember = FALSE, SessionEstablished = FALSE;

    Win32Err = NetpSetComputerAccountPassword( NULL,
                                               DomainController,
                                               AuthInfo->User,
                                               AuthInfo->Password,
                                               NULL );

    if ( Win32Err == ERROR_SUCCESS ) {

        NetDompDisplayMessage( OkMessageId );

    } else {

        NetDompDisplayMessage( FailedMessageId );
    }

    return( Win32Err );
}


DWORD
NetDompHandleResetPwd(ARG_RECORD * rgNetDomArgs)
/*++

Routine Description:

    This function resets the machine account password for the local.
    Currently there is no support for resetting machine password of
    a remote machine.

Arguments:

    Args - List of command line arguments

Return Value:

    ERROR_INVALID_PARAMETER - if any param is invalid

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    PWSTR Domain = NULL;
    ND5_AUTH_INFO ObjectUser = {0};
    PWSTR Server = NULL;

    RtlZeroMemory( &ObjectUser, sizeof( ND5_AUTH_INFO ) );

    Win32Err = NetDompValidateSecondaryArguments(rgNetDomArgs,
                                                 eCommServer,
                                                 eCommUserNameD,
                                                 eCommPasswordD,
                                                 eCommVerbose,
                                                 eArgEnd);
    if ( Win32Err != ERROR_SUCCESS ) {

        DisplayHelp(ePriResetPwd);
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // Get the server
    //
    Win32Err = NetDompGetArgumentString(rgNetDomArgs,
                                        eCommServer,
                                        &Server);

    if (ERROR_SUCCESS != Win32Err)
    {
        NetDompDisplayErrorMessage(Win32Err);
        return Win32Err;
    }

    if (!Server)
    {
        DisplayHelp(ePriResetPwd);
        return ERROR_INVALID_PARAMETER;
    }

    Win32Err = NetDompGetDomainForOperation(rgNetDomArgs,
                                            NULL,
                                            TRUE,
                                            &Domain);
    if (ERROR_SUCCESS != Win32Err)
    {
        NetDompDisplayErrorMessage(Win32Err);
        return Win32Err;
    }

    //
    // Get the password and user
    //
    Win32Err = NetDompGetUserAndPasswordForOperation(rgNetDomArgs,
                                                     eCommUserNameD,
                                                     Domain,
                                                     &ObjectUser);
    if (ERROR_SUCCESS != Win32Err)
    {
        NetDompDisplayErrorMessage(Win32Err);
        goto HandleResetExit;
    }

    if (!ObjectUser.User)
    {
        DisplayHelp(ePriResetPwd);
        Win32Err = ERROR_INVALID_PARAMETER;
        goto HandleResetExit;
    }

    Win32Err = NetDompResetPwd( Server,
                                &ObjectUser,
                                MSG_RESETPWD_OK,
                                MSG_RESETPWD_BAD );
    if (NO_ERROR != Win32Err)
    {
        NetDompDisplayErrorMessage(Win32Err);
    }

HandleResetExit:

    NetDompFreeAuthIdent( &ObjectUser );

    NetApiBufferFree( Server );

    NetApiBufferFree( Domain );

    return( Win32Err );
}


DWORD
NetDompVerifyServerSC(
    IN PWSTR Domain,
    IN PWSTR Server,
    IN PND5_AUTH_INFO AuthInfo,
    IN ULONG OkMessageId,
    IN ULONG FailedMessageId
    )
{
    DWORD Win32Err = ERROR_SUCCESS;
    PNETLOGON_INFO_2 NetlogonInfo2 = NULL;
    BOOL DomainMember = FALSE, SessionEstablished = FALSE;

    LOG_VERBOSE(( MSG_VERBOSE_ESTABLISH_SESSION, Server ));
    Win32Err = NetpManageIPCConnect( Server,
                                     AuthInfo->User,
                                     AuthInfo->Password,
                                     NETSETUPP_CONNECT_IPC );

    if ( Win32Err == ERROR_SUCCESS ) {

        SessionEstablished = TRUE;

    }

    //
    // See if we're a domain member or not
    //

    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = NetDompCheckDomainMembership( Server,
                                                 AuthInfo,
                                                 FALSE,
                                                 &DomainMember );

        if ( Win32Err == ERROR_SUCCESS && !DomainMember ) {

            Win32Err = NERR_SetupNotJoined;
        }
    }


    if ( Win32Err == ERROR_SUCCESS ) {

        LOG_VERBOSE(( MSG_VERBOSE_CHECKING_SC, Domain ));
        Win32Err = I_NetLogonControl2( Server,
                                       NETLOGON_CONTROL_TC_QUERY,
                                       2,
                                       ( LPBYTE )&Domain,
                                       ( LPBYTE *)&NetlogonInfo2 );

        if ( Win32Err == ERROR_SUCCESS ) {

            Win32Err = NetlogonInfo2->netlog2_pdc_connection_status;

            if ( Win32Err == ERROR_SUCCESS ) {

                NetDompDisplayMessage( OkMessageId, _wcsupr( Server ), _wcsupr( Domain ),
                                       _wcsupr( NetlogonInfo2->netlog2_trusted_dc_name ) );

            } else {

                if ( FailedMessageId ) {

                    NetDompDisplayMessage( FailedMessageId, _wcsupr( Server ), _wcsupr( Domain ) );
                    NetDompDisplayErrorMessage( Win32Err );
                }
            }

            NetApiBufferFree( NetlogonInfo2 );

        }
    }

    if ( SessionEstablished ) {

        LOG_VERBOSE(( MSG_VERBOSE_DELETE_SESSION, Server ));
        NetpManageIPCConnect( Server,
                              AuthInfo->User,
                              AuthInfo->Password,
                              NETSETUPP_DISCONNECT_IPC );

    }


    return( Win32Err );
}


DWORD
NetDompHandleVerify(ARG_RECORD * rgNetDomArgs)
/*++

Routine Description:

    This function will verify the secure channel with the domain

Arguments:

    Args - List of command line arguments

Return Value:

    ERROR_INVALID_PARAMETER - No object name was supplied

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    PWSTR Domain = NULL;
    ND5_AUTH_INFO ObjectUser;

    RtlZeroMemory( &ObjectUser, sizeof( ND5_AUTH_INFO ) );

    Win32Err = NetDompValidateSecondaryArguments(rgNetDomArgs,
                                                 eObject,
                                                 eCommDomain,
                                                 eCommUserNameO,
                                                 eCommPasswordO,
                                                 eCommVerbose,
                                                 eArgEnd);
    if ( Win32Err != ERROR_SUCCESS ) {

        DisplayHelp(ePriVerify);
        return( ERROR_INVALID_PARAMETER );
    }

    PWSTR Object = rgNetDomArgs[eObject].strValue;

    if ( !Object ) {

        DisplayHelp(ePriVerify);
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // Make sure that the object name we were given is valid
    //
    Win32Err = I_NetNameValidate( NULL,
                                  Object,
                                  NAMETYPE_COMPUTER,
                                  LM2X_COMPATIBLE );
    if ( Win32Err != ERROR_SUCCESS ) {

        goto HandleVerifyExit;
    }

    //
    // Ok, make sure that we have a specified domain...
    //
    Win32Err = NetDompGetDomainForOperation(rgNetDomArgs,
                                            Object,
                                            TRUE,
                                            &Domain);

    if ( Win32Err != ERROR_SUCCESS ) {

        goto HandleVerifyExit;
    }

    //
    // Get the password and user if it exists
    //
    Win32Err = NetDompGetUserAndPasswordForOperation(rgNetDomArgs,
                                                     eCommUserNameO,
                                                     Domain,
                                                     &ObjectUser);

    if ( Win32Err != ERROR_SUCCESS ) {

        goto HandleVerifyExit;
    }

    Win32Err = NetDompVerifyServerSC( Domain,
                                      Object,
                                      &ObjectUser,
                                      MSG_SC_OK,
                                      MSG_SC_BAD );



HandleVerifyExit:

    NetDompFreeAuthIdent( &ObjectUser );

    NetApiBufferFree( Domain );

    if (NO_ERROR != Win32Err)
    {
        NetDompDisplayErrorMessage(Win32Err);
    }

    return( Win32Err );
}

DWORD
NetDompJoinDownlevel(
    IN PWSTR Server,
    IN PWSTR Account,
    IN PWSTR Password,
    IN PWSTR Dc,
    IN ULONG DcFlags,
    IN BOOL AllowMove
    )
/*++

Routine Description:

    This function will join an NT4 machine to the domain.  It does this remotely

Arguments:

    Server - Server to join

    Account - Account to use to contact the domain controller

    Password - Password to use with the above account

    Dc - Domain controller to speak to

    DcFlags - Flags specifying various properties of Dc

    AllowMove - If TRUE, allow the machine to join the domain even if it's already
                joined to a domain

Return Value:

    ERROR_INVALID_PARAMETER - No object name was supplied

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    NTSTATUS Status = STATUS_SUCCESS;
    LSA_HANDLE ClientLsaHandle = NULL, ServerLsaHandle = NULL, SecretHandle = NULL;
    PPOLICY_PRIMARY_DOMAIN_INFO CurrentPolicyPDI = NULL, DomainPolicyPDI = NULL;
    OBJECT_ATTRIBUTES OA;
    UNICODE_STRING ServerU, Secret;
    WCHAR AccountPassword[ LM20_PWLEN + 1 ];
    BOOL DefaultJoin = FALSE, ServiceSet = FALSE, GroupsSet = FALSE, SidSet = FALSE;

    //
    // We will do things in the following order:
    //
    //   - Create the computer account on the domain controller
    //   - Set the domain sid
    //   - Configure the netlogon service
    //   - Set the group memberships
    //   - Set the local secret.  No rollback after this succeeds.


    InitializeObjectAttributes(
        &OA,
        NULL,
        0L,
        NULL,
        NULL
    );


    if ( Server ) {

        RtlInitUnicodeString( &ServerU, Server );
    }

    //InitializeObjectAttributes( &OA, NULL, 0, NULL, NULL );

    Status = LsaOpenPolicy( Server ? &ServerU : NULL,
                            &OA,
                            MAXIMUM_ALLOWED,
                            &ClientLsaHandle );

    if ( NT_SUCCESS( Status ) ) {

        RtlInitUnicodeString( &ServerU, Dc );

        InitializeObjectAttributes( &OA, NULL, 0, NULL, NULL );

        Status = LsaOpenPolicy( &ServerU,
                                &OA,
                                 MAXIMUM_ALLOWED,
                                &ServerLsaHandle );
    }

    //
    // Read the current LSA policy
    //
    if ( NT_SUCCESS( Status ) ) {

        Status = LsaQueryInformationPolicy( ClientLsaHandle,
                                            PolicyPrimaryDomainInformation,
                                            ( PVOID * )&CurrentPolicyPDI );

        if ( NT_SUCCESS( Status ) ) {

            Status = LsaQueryInformationPolicy( ServerLsaHandle,
                                                PolicyPrimaryDomainInformation,
                                                ( PVOID * )&DomainPolicyPDI );
        }
    }

    Win32Err = RtlNtStatusToDosError( Status );

    if ( Win32Err == ERROR_SUCCESS ) {

        if ( CurrentPolicyPDI->Sid && !AllowMove ) {

            Win32Err = NERR_SetupAlreadyJoined;
        }
    }

    //
    // Ok, now generate the password to use on the account
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = NetpGetNt4RefusePasswordChangeStatus( Dc, &DefaultJoin );

        if ( Win32Err == ERROR_SUCCESS ) {

            if ( (Server != NULL) & DefaultJoin ) {

                wcsncpy( AccountPassword, Server, LM20_PWLEN );
                AccountPassword[ LM20_PWLEN ] = UNICODE_NULL;
                _wcslwr( AccountPassword );

            } else {

                Win32Err = NetDompGenerateRandomPassword( AccountPassword,
                                                          LM20_PWLEN );
            }
        }
    }

    //
    // Ok, if that worked, we'll start the actual set
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        //
        // Manage the account
        //
        Win32Err = NetpManageMachineAccountWithSid( Server,
                                                    NULL,
                                                    Dc,
                                                    AccountPassword,
                                                    DomainPolicyPDI->Sid,
                                                    NETSETUPP_CREATE,
                                                    0,
                                                    (DcFlags & DS_DS_FLAG) == 0 ?
                                                        TRUE :    // NT4 or older DC
                                                        FALSE );  // NT5 DC
    }

    //
    // Now,  set the domain information
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        Status = LsaSetInformationPolicy( ClientLsaHandle,
                                          PolicyPrimaryDomainInformation,
                                          DomainPolicyPDI );

        Win32Err = RtlNtStatusToDosError( Status );
    }

    if ( Win32Err == ERROR_SUCCESS ) {

        SidSet = TRUE;
        Win32Err = NetDompManageGroupMembership( Server,
                                                 DomainPolicyPDI->Sid,
                                                 FALSE );
    }

    //
    // Configure netlogon
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        GroupsSet = TRUE;
        Win32Err = NetDompControlService( Server,
                                          SERVICE_NETLOGON,
                                          SERVICE_AUTO_START );
    }

    //
    // Finally, the secret
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        ServiceSet = TRUE;

        Win32Err = NetDompManageMachineSecret(ClientLsaHandle,
                                              AccountPassword,
                                              NETSETUPP_CREATE);

    }

    //
    // Unwind, if something failed
    //
    if ( Win32Err != ERROR_SUCCESS ) {

        if ( ServiceSet ) {

            NetDompControlService( Server,
                                   SERVICE_NETLOGON,
                                   SERVICE_DEMAND_START );
        }

        if ( GroupsSet ) {

            NetDompManageGroupMembership( Server,
                                          DomainPolicyPDI->Sid,
                                          TRUE );
        }

        if ( SidSet ) {

            LsaSetInformationPolicy( ClientLsaHandle,
                                     PolicyPrimaryDomainInformation,
                                     CurrentPolicyPDI );
        }
    }

    LsaFreeMemory( CurrentPolicyPDI );
    LsaFreeMemory( DomainPolicyPDI );
    LsaClose( ClientLsaHandle );
    LsaClose( ServerLsaHandle );

    return( Win32Err );
}

DWORD
NetDompManageGroupMembership(
    IN PWSTR Server,
    IN PSID DomainSid,
    IN BOOL Delete
    )
/*++

Routine Description:

    Performs SAM account handling to either add or remove the DomainAdmins,
    etc groups from the local groups.


Arguments:

    Server - Server on which to perform the operation

    DomainSid - SID of the domain being joined/left

    Delete - Whether to add or remove the admin alias

Returns:

    ERROR_SUCCESS -- Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    //
    // Keep these in synch with the rids and Sids below
    //
    ULONG LocalRids[] = {

        DOMAIN_ALIAS_RID_ADMINS,
        DOMAIN_ALIAS_RID_USERS
        };

    PWSTR LocalGroups[ sizeof( LocalRids ) / sizeof( ULONG )] = {
        NULL,
        NULL,
    };

    ULONG Rids[] = {
        DOMAIN_GROUP_RID_ADMINS,
        DOMAIN_GROUP_RID_USERS
    };

    static SID_IDENTIFIER_AUTHORITY BultinAuth = SECURITY_NT_AUTHORITY;
    DWORD Sids[sizeof( SID )/sizeof( DWORD ) +
                                    SID_MAX_SUB_AUTHORITIES ][ sizeof( Rids ) / sizeof( ULONG ) ];
    DWORD DSidSize, *LastSub, i, j;
    PUCHAR SubAuthCnt;
    PWSTR LocalGroupName = NULL;
    WCHAR DomainName[ sizeof( L"BUILTIN" )];
    ULONG Size, DomainSize;
    SID_NAME_USE SNE;
    PWSTR FullServer = NULL;

    if ( DomainSid == NULL ) {

        return( Win32Err );
    }

    if ( Server && *Server != L'\\' ) {

        Win32Err = NetApiBufferAllocate( ( wcslen( Server ) + 3 ) * sizeof( WCHAR ),
                                         (PVOID*)&FullServer );

        if ( Win32Err == ERROR_SUCCESS ) {

            swprintf( FullServer, L"\\\\%ws", Server );
        }

    } else {

        FullServer = Server;
    }


    DSidSize = RtlLengthSid( DomainSid );

    for ( i = 0 ; i <  sizeof(Rids) / sizeof(ULONG) && Win32Err == NERR_Success; i++) {

        Size = 0;
        DomainSize = sizeof( DomainName );

        //
        // Get the name of the local group first...
        //
        RtlInitializeSid( ( PSID )Sids[ i ], &BultinAuth, 2 );

        *( RtlSubAuthoritySid( ( PSID )Sids[ i ], 0 ) ) = SECURITY_BUILTIN_DOMAIN_RID;
        *( RtlSubAuthoritySid( ( PSID )Sids[ i ], 1 ) ) = LocalRids[ i ];

        LookupAccountSidW( FullServer,
                           ( PSID )Sids[ i ],
                           NULL,
                           &Size,
                           DomainName,
                           &DomainSize,
                           &SNE );

        if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER ) {

            Win32Err = NetApiBufferAllocate( Size * sizeof( WCHAR ),
                                             (PVOID*)&LocalGroupName );

            if ( Win32Err == NERR_Success ) {

                if ( !LookupAccountSidW( FullServer, ( PSID )Sids[ i ], LocalGroupName,
                                         &Size, DomainName, &DomainSize, &SNE ) ) {

                    Win32Err = GetLastError();

                    if ( Win32Err == ERROR_NONE_MAPPED ) {

                        Win32Err = NERR_Success;
                        continue;
                    }

                } else {

                    LocalGroups[ i ] = LocalGroupName;
                }

            } else {

                break;
            }
        }

        RtlCopyMemory( ( PBYTE )Sids[i], DomainSid, DSidSize );

        //
        // Now, add the new domain relative rid
        //
        SubAuthCnt = GetSidSubAuthorityCount( ( PSID )Sids[ i ] );

        ( *SubAuthCnt )++;

        LastSub = GetSidSubAuthority( ( PSID )Sids[ i ], ( *SubAuthCnt ) - 1 );

        *LastSub = Rids[ i ];


        if ( !Delete ) {

            LOG_VERBOSE(( MSG_VERBOSE_ADD_LOCALGRP, LocalGroups[ i ] ));
            Win32Err = NetLocalGroupAddMember( FullServer,
                                               LocalGroups[i],
                                               ( PSID )Sids[ i ] );

            if ( Win32Err == ERROR_MEMBER_IN_ALIAS ) {

                Win32Err = NERR_Success;
            }

        } else {

            LOG_VERBOSE(( MSG_VERBOSE_REMOVE_LOCALGRP, LocalGroups[ i ] ));
            Win32Err = NetLocalGroupDelMember( FullServer,
                                               LocalGroups[i],
                                               ( PSID )Sids[ i ] );

            if ( Win32Err == ERROR_MEMBER_NOT_IN_ALIAS ) {

                Win32Err = NERR_Success;
            }
        }
    }

    //
    // If something failed, try to restore what was deleted
    //
    if ( Win32Err != NERR_Success ) {

        for ( j = 0;  j < i; j++ ) {

            if ( !Delete ) {

                NetLocalGroupAddMember( FullServer,
                                        LocalGroups[ j ],
                                        ( PSID )Sids[ j ] );

            } else {

                NetLocalGroupDelMember( FullServer,
                                        LocalGroups[ j ],
                                        ( PSID )Sids[ j ] );
            }
        }
    }

    for ( i = 0; i < sizeof( LocalRids ) / sizeof( ULONG ); i++ ) {

        if ( LocalGroups[ i ] ) {

            NetApiBufferFree( LocalGroups[ i ] );
        }
    }

    if ( FullServer != Server ) {

        NetApiBufferFree( FullServer );
    }

    return( Win32Err );
}

DWORD
NetDompManageMachineSecret(
    IN  LSA_HANDLE  PolicyHandle,
    IN  LPWSTR      lpPassword,
    IN  INT         fControl
    )
/*++

Routine Description:

    Create/delete the machine secret


Arguments:

    PolicyHandle  -- Optional open handle to the policy
    lpPassword    -- Machine password to use.
    fControl      -- create/remove flags

Returns:

    NERR_Success -- Success

--*/
{
    NTSTATUS            Status = STATUS_SUCCESS;
    LSA_HANDLE          SecretHandle = NULL;
    UNICODE_STRING      Key, Data;
    BOOLEAN             SecretCreated = FALSE;

    //
    // open/create the secret
    //

    RtlInitUnicodeString( &Key, L"$MACHINE.ACC" );
    RtlInitUnicodeString( &Data, lpPassword );

    Status = LsaOpenSecret(PolicyHandle,
                           &Key,
                           fControl == NETSETUPP_CREATE ?
                           SECRET_SET_VALUE | SECRET_QUERY_VALUE :
                           DELETE,
                           &SecretHandle );

    if ( Status == STATUS_OBJECT_NAME_NOT_FOUND )
    {
        if ( fControl == NETSETUPP_DELETE )
        {
            Status = STATUS_SUCCESS;
        }
        else
        {
            Status = LsaCreateSecret( PolicyHandle, &Key,
                                      SECRET_SET_VALUE, &SecretHandle );

            if ( NT_SUCCESS( Status ) )
            {
                SecretCreated = TRUE;
            }
        }
    }

    if ( !NT_SUCCESS( Status ) )
    {
        NetpLog((  "NetpManageMachineSecret: Open/Create secret failed: 0x%lx\n", Status ));
    }

    if ( NT_SUCCESS( Status ) )
    {
        if ( fControl == NETSETUPP_CREATE )
        {
#if !defined(USE_LSA_STORE_PRIVATE_DATA)
            //
            // cannot read the current value over the net for NT4 machine,
            // so save the new value as current value
            //
            Status = LsaSetSecret( SecretHandle, &Data, &Data );
#else
            //
            // LsaStorePrivateData sets the old pw to be the current pw and then
            // stores the new pw as the current.
            //
            Status = LsaStorePrivateData(PolicyHandle, &Key, &Data);
#endif
        }
        else
        {
            //
            // No secret handle means we failed earlier in
            // some intermediate state.  That's ok, just press on.
            //
            if ( SecretHandle != NULL )
            {
                Status = LsaDelete( SecretHandle );

                if ( NT_SUCCESS( Status ) )
                {
                    SecretHandle = NULL;
                }
            }
        }
    }

    if ( SecretHandle )
    {
        LsaClose( SecretHandle );
    }

    return( RtlNtStatusToDosError( Status ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\netuse\use.c ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1991          **/
/********************************************************************/

/***
 *  use.c
 *      Functions for displaying and manipulating network uses
 *      Redirected device can only be: disks a: to z:;
 *      comm devs com1[:] to com9[:]; and lpt1[:] to lpt9[:].
 *      NOTE: even though it uses the WNet*** calls, it is not
 *            intended to be used for networks other than LM.
 *            we use WNet purely to leverage off the persistent
 *            connections.
 *
 *  History:
 *      mm/dd/yy, who, comment
 *      06/09/87, andyh, new code
 *      07/02/87, andyh, del with ucond = 1
 *      10/31/88, erichn, uses OS2.H instead of DOSCALLS
 *      01/04/89, erichn, filenames now MAX_PATH LONG
 *      05/02/89, erichn, NLS conversion
 *      05/09/89, erichn, local security mods
 *      05/19/89, erichn, NETCMD output sorting
 *      06/08/89, erichn, canonicalization sweep
 *      06/23/89, erichn, replaced old NetI canon calls with new I_Net
 *      03/03/90, thomaspa, INTERNAL retry with mixed case for
 *                                  password errors from down-level servers
 *      03/06/90, thomaspa, integrate INTERNAL to shipped product
 *      02/09/91, danhi, change to use lm 16/32 mapping layer
 *      02/20/91, robdu, added profile update code
 *      02/18/92, chuckc, use WNet*** to handle sticky connections (part I)
 *      04/25/92, jonn, removed two cases for build fix
 *      09/21/92  keithmo, use unicode versions of WNet*** API.
 */

/* Include files */

#define INCL_NOCOMMON
#define INCL_DOSFILEMGR
#define INCL_ERRORS
#define INCL_ERROR_H
#include <os2.h>
#include <search.h>
#include <lmcons.h>
#include <lmerr.h>
#include <lmapibuf.h>
#include <lmaccess.h>
#include <lmuse.h>
#include <apperr.h>
#include <apperr2.h>
#include <icanon.h>
#include <lui.h>
#include <wincred.h>

#include <dlwksta.h>
#include "mwksta.h"
#include "netcmds.h"
#include "nettext.h"
#include "msystem.h"

// pull in the win32 headers
#include <mpr.h>                // for MPR_* manifests


//
// structure for combines LM and WNet info
//
typedef struct _NET_USE_INFO {
    LPWSTR lpLocalName ;
    LPWSTR lpRemoteName ;
    LPWSTR lpProviderName ;
    DWORD  dwType ;
    DWORD  dwStatus ;
    DWORD  dwRefCount ;
    DWORD  dwUseCount ;
    BOOL   fIsLanman ;
} NET_USE_INFO ;

/* Static variables */

TCHAR *LanmanProviderName = NULL ;

/* Forward declarations */

VOID LanmanDisplayUse(LPUSE_INFO_1);
int    NEAR is_admin_dollar(TCHAR FAR *);
int    __cdecl  CmpUseInfo(const VOID FAR *, const VOID FAR *);
VOID   NEAR UseInit(VOID);

USHORT QueryDefaultPersistence(BOOL *pfRemember) ;
DWORD  SetDefaultPersistence(BOOL fRemember) ;
BOOL   CheckIfWantUpdate(TCHAR *dev, TCHAR *resource) ;
VOID   WNetErrorExit(ULONG err);
WCHAR  *GetLanmanProviderName(void) ;
TCHAR  *MapWildCard(TCHAR *dev, TCHAR *startdev) ;
DWORD  MprUseEnum(PDWORD       num_read,
                  NET_USE_INFO **NetUseInfoBuffer,
                  PDWORD       NetUseInfoCount);
DWORD LanmanUseAugment(DWORD num_read,
                       NET_USE_INFO *NetUseInfoBuffer) ;
DWORD UnavailUseAugment(PDWORD       num_read,
                        NET_USE_INFO **NetUseInfoBuffer,
                        PDWORD       NetUseInfoCount);
VOID   MprUseDisplay(TCHAR *dev) ;
VOID use_del_all() ;

/* Externs */

extern int YorN_Switch;

/* Message related definitions */

#define USE_STATUS_OK               0
#define USE_STATUS_PAUSED           ( USE_STATUS_OK + 1 )
#define USE_STATUS_SESSION_LOST     ( USE_STATUS_PAUSED + 1 )
#define USE_STATUS_NET_ERROR        ( USE_STATUS_SESSION_LOST + 1 )
#define USE_STATUS_CONNECTING       ( USE_STATUS_NET_ERROR + 1 )
#define USE_STATUS_RECONNECTING     ( USE_STATUS_CONNECTING + 1 )
#define USE_STATUS_UNAVAIL          ( USE_STATUS_RECONNECTING + 1 )
#ifdef  DEBUG
#define USE_STATUS_UNKNOWN          ( USE_STATUS_UNAVAIL + 1 )
#endif

#define USE_REMEMBERED              0xFFFE

static MESSAGE UseStatusList[] =
{
    { APE2_USE_STATUS_OK,                   NULL },
    { APE2_USE_STATUS_PAUSED,               NULL },
    { APE2_USE_STATUS_SESSION_LOST,         NULL },
    { APE2_USE_STATUS_NET_ERROR,            NULL },
    { APE2_USE_STATUS_CONNECTING,           NULL },
    { APE2_USE_STATUS_RECONNECTING,         NULL },
    { APE2_USE_STATUS_UNAVAIL,              NULL }
#ifdef  DEBUG
                                                                                          ,
    { APE2_GEN_UNKNOWN,                     NULL }
#endif
};

#define NUM_STATUS_MSGS (sizeof(UseStatusList)/sizeof(UseStatusList[0]))

#define USE_MSG_LOCAL               0
#define USE_MSG_REMOTE              ( USE_MSG_LOCAL + 1 )
#define USE_MSG_TYPE                ( USE_MSG_REMOTE + 1 )
#define USE_TYPE_TBD                ( USE_MSG_TYPE + 1 )
#define USE_MSG_STATUS              ( USE_TYPE_TBD + 1 )
#define USE_STATUS_TBD              ( USE_MSG_STATUS + 1 )
#define USE_MSG_OPEN_COUNT          ( USE_STATUS_TBD + 1 )
#define USE_MSG_USE_COUNT           ( USE_MSG_OPEN_COUNT + 1 )

static MESSAGE UseMsgList[] =
{
    { APE2_USE_MSG_LOCAL,                   NULL },
    { APE2_USE_MSG_REMOTE,                  NULL },
    { APE2_USE_MSG_TYPE,                    NULL },
    { APE2_GEN_UNKNOWN /* ie, TBD */,       NULL },
    { APE2_USE_MSG_STATUS,                  NULL },
    { APE2_GEN_UNKNOWN /* ie, TBD */,       NULL },
    { APE2_USE_MSG_OPEN_COUNT,              NULL },
    { APE2_USE_MSG_USE_COUNT,               NULL }
};

#define NUM_USE_MSGS (sizeof(UseMsgList)/sizeof(UseMsgList[0]))

/***
 *  use_display_all()
 *      Display all network uses
 *
 *  Args:
 *      none
 *
 *  Returns:
 *      0 - success
 *      exit(2) - command failed
 */
VOID
use_display_all(
    VOID
    )
{
    DWORD                   err;                /* API return status */
    DWORD                   num_read;           /* num entries read by API */
    DWORD                   maxLen;             /* max message length */
    DWORD                   i;
    int                     msgno;
    BOOL                    fRemember ;
    DWORD                   NetUseInfoCount = 0 ;
    NET_USE_INFO            *NetUseInfoBuffer = NULL ;
    NET_USE_INFO            *pNetUseInfo ;

    UseInit();

    if (err = MprUseEnum(&num_read, &NetUseInfoBuffer, &NetUseInfoCount))
        ErrorExit(err);


    if (err = UnavailUseAugment(&num_read, &NetUseInfoBuffer, &NetUseInfoCount))
        ErrorExit(err);

    if (err = LanmanUseAugment(num_read, NetUseInfoBuffer))
        ErrorExit(err);


    if (QueryDefaultPersistence(&fRemember) == NERR_Success)
        InfoPrint(fRemember ? APE_ConnectionsAreRemembered :
                              APE_ConnectionsAreNotRemembered);
    else
        InfoPrint(APE_ProfileReadError);

    if (num_read == 0)
        EmptyExit();

    for (i = 0, pNetUseInfo = NetUseInfoBuffer;
        i < num_read; i++, pNetUseInfo++)
    {
        //
        // if we find at least one entry we will display, break
        //
        if (!(pNetUseInfo->fIsLanman)
            || (pNetUseInfo->dwStatus != USE_OK)
            || (pNetUseInfo->dwUseCount != 0)
            || (pNetUseInfo->dwRefCount != 0))
            break;
    }
    if (i == num_read)
        EmptyExit();    // loop reached limit, so no entries to display

    qsort(NetUseInfoBuffer,
             num_read,
             sizeof(NET_USE_INFO), CmpUseInfo);

    GetMessageList(NUM_STATUS_MSGS, UseStatusList, &maxLen);

    PrintNL();
    InfoPrint(APE2_USE_HEADER);
    PrintLine();

    for (i = 0, pNetUseInfo = NetUseInfoBuffer;
         i < num_read;
         i++, pNetUseInfo++)
    {
        TCHAR *status_string ;

        switch(pNetUseInfo->dwStatus)
        {
            case USE_OK:
                if ((pNetUseInfo->dwUseCount == 0)
                    && (pNetUseInfo->dwRefCount == 0)
                    && pNetUseInfo->fIsLanman)
                    continue;
                else
                    msgno = USE_STATUS_OK;
                break;
            case USE_PAUSED:
                msgno = USE_STATUS_PAUSED;
                break;
            case USE_SESSLOST:
                msgno = USE_STATUS_SESSION_LOST;
                break;
            case USE_NETERR:
                msgno = USE_STATUS_NET_ERROR;
                break;
            case USE_CONN:
                msgno = USE_STATUS_CONNECTING;
                break;
            case USE_REMEMBERED:
                msgno = USE_STATUS_UNAVAIL;
                break;
            case USE_RECONN:
                msgno = USE_STATUS_RECONNECTING;
                break;
            default:
                msgno = -1;
                break;
        }

        if (msgno != -1)
            status_string = UseStatusList[msgno].msg_text ;
        else
            status_string = TEXT("") ;

        {
            TCHAR Buffer1[13],Buffer2[10],Buffer3[MAX_PATH + 1];

            if( wcslen( pNetUseInfo->lpRemoteName ) <= 25 ) {
                WriteToCon(TEXT("%Fs %Fs %Fs %Fs\r\n"),
                       PaddedString(12,status_string,Buffer1),
                       PaddedString( 9,pNetUseInfo->lpLocalName,Buffer2),
                       PaddedString(25,pNetUseInfo->lpRemoteName,Buffer3),
                       pNetUseInfo->lpProviderName);
            }
            else
            {
                TCHAR Buffer4[13],Buffer5[10],Buffer6[25];
                WriteToCon(TEXT("%Fs %Fs %Fs \r\n%Fs %Fs %Fs %Fs\r\n"),
                       PaddedString(12,status_string,Buffer1),
                       PaddedString( 9,pNetUseInfo->lpLocalName,Buffer2),
                       PaddedString(wcslen(pNetUseInfo->lpRemoteName),
                                    pNetUseInfo->lpRemoteName,
                                    Buffer3),
                       PaddedString(12,TEXT(""),Buffer4),
                       PaddedString(9,TEXT(""),Buffer5),
                       PaddedString(25,TEXT(""),Buffer6),
                       pNetUseInfo->lpProviderName);
            }
        }
    }

    FreeMem((LPBYTE)NetUseInfoBuffer);
    InfoSuccess();

}

/***
 *  LanmanUseAugment()
 *      Enumerate uses from Lanman
 *
 *  Args:
 *      none
 *
 *  Returns:
 *      0 - success
 *      exit(2) - command failed
 */
DWORD
LanmanUseAugment(
    DWORD        num_read,
    NET_USE_INFO *NetUseInfoBuffer
    )
{
    DWORD         dwErr;
    DWORD         cTotalAvail;
    LPSTR         pBuffer;
    DWORD         numLMread;          /* num entries read by API */
    DWORD         j;
    DWORD         i;
    LPUSE_INFO_1  use_entry;
    NET_USE_INFO  *pNetUseInfo = NetUseInfoBuffer ;

    dwErr = NetUseEnum(NULL, 1, &pBuffer, MAX_PREFERRED_LENGTH,
                       &numLMread, &cTotalAvail, NULL);

    if (dwErr != NERR_Success)
    {
        // consider as success (ie. there are no Lanman ones)
        return NERR_Success;
    }

    if (numLMread == 0)
    {
        return NERR_Success;
    }

    //
    // for all MPR returned entries that are Lanman uses,
    // augment with extra info if we have it.
    //
    for (i = 0;  i < num_read; i++, pNetUseInfo++)
    {
        //
        // not LM, skip it
        //
        if (!(pNetUseInfo->fIsLanman))
            continue ;

        //
        // lets find it in the NetUseEnum return data
        //
        for (j = 0, use_entry = (LPUSE_INFO_1) pBuffer;
            j < numLMread; j++, use_entry++)
        {
            //
            // look for match. if device names are present & match, we've found
            // one. else we match only if remote names match *and* both device
            // names are not present.
            //
            TCHAR *local = use_entry->ui1_local ;
            TCHAR *remote = use_entry->ui1_remote ;


            if ( (local && *local && !_tcsicmp(pNetUseInfo->lpLocalName,local))
                 ||
                 ( (!local || !*local) &&
                   !*(pNetUseInfo->lpLocalName) &&
                   !_tcsicmp(pNetUseInfo->lpRemoteName,remote)
                 )
               )
            {
                //
                // found the device in the LM list or
                // found as deviceless connection
                //
                pNetUseInfo->dwUseCount = use_entry->ui1_usecount ;
                pNetUseInfo->dwRefCount = use_entry->ui1_refcount ;
                pNetUseInfo->dwStatus   = use_entry->ui1_status ;
                break ;
            }
        }
    }
    NetApiBufferFree(pBuffer);

    return NERR_Success;
}



/***
 *  MprUseEnum()
 *      Enumerates uses returned by WNET
 *
 *  Args:
 *      none
 *
 *  Returns:
 *      0 - success
 *      exit(2) - command failed
 */
DWORD
MprUseEnum(
    LPDWORD      num_read,
    NET_USE_INFO **NetUseInfoBuffer,
    LPDWORD      NetUseInfoCount
    )
{
    DWORD        EntriesRead = 0;
    LPBYTE       Buffer;
    DWORD        dwErr;
    DWORD        dwAllocErr;
    HANDLE       EnumHandle;
    DWORD        BufferSize, Count;
    static TCHAR *NullString = TEXT("");

    //
    // initialize
    //
    *num_read = 0;
    *NetUseInfoCount = 64; // assume 64 entries initially. realloc if need
    if (dwAllocErr = AllocMem( *NetUseInfoCount * sizeof(NET_USE_INFO),
                           (LPBYTE *) NetUseInfoBuffer ))
    {
        ErrorExit(dwAllocErr);
    }

    //
    // allocate memory and open the enumeration
    //
    if (dwAllocErr = AllocMem(BufferSize = 4096, &Buffer))
    {
        ErrorExit(dwAllocErr);
    }

    dwErr = WNetOpenEnum(RESOURCE_CONNECTED, 0, 0, NULL, &EnumHandle) ;
    if (dwErr != WN_SUCCESS)
    {
        return dwErr;
    }

    do
    {
        Count = 0xFFFFFFFF ;
        dwErr = WNetEnumResource(EnumHandle, &Count, Buffer, &BufferSize) ;

        if (dwErr == WN_SUCCESS || dwErr == WN_NO_MORE_ENTRIES)
        {
            LPNETRESOURCE lpNetResource ;
            NET_USE_INFO  *lpNetUseInfo ;
            DWORD i ;

            //
            // grow the buffer if need. note there are no
            // pointers that point back to the buffer, so we
            // should be fine with the realloc.
            //
            if (EntriesRead + Count >= *NetUseInfoCount)
            {
                //
                // make sure it can hold all the new data, and add 64
                // to reduce the number of reallocs
                //
                *NetUseInfoCount = EntriesRead + Count + 64;
                dwAllocErr = ReallocMem(*NetUseInfoCount * sizeof(NET_USE_INFO),
                                  (LPBYTE *)NetUseInfoBuffer) ;
                if (dwAllocErr != NERR_Success)
                    return dwAllocErr;
            }
            lpNetResource = (LPNETRESOURCE) Buffer ;
            lpNetUseInfo = *NetUseInfoBuffer + EntriesRead ;

            //
            // stick the entries into the NetUseInfoBuffer
            //
            for ( i = 0;
                  i < Count;
                  i++,EntriesRead++,lpNetUseInfo++,lpNetResource++ )
            {
                lpNetUseInfo->lpLocalName = lpNetResource->lpLocalName ?
                    lpNetResource->lpLocalName : NullString ;
                lpNetUseInfo->lpRemoteName = lpNetResource->lpRemoteName ?
                    lpNetResource->lpRemoteName : NullString ;
                lpNetUseInfo->lpProviderName = lpNetResource->lpProvider ?
                    lpNetResource->lpProvider : NullString ;
                lpNetUseInfo->dwType = lpNetResource->dwType ;
                lpNetUseInfo->fIsLanman =
                    (_tcscmp(lpNetResource->lpProvider,LanmanProviderName)==0) ;
                lpNetUseInfo->dwStatus = 0xFFFFFFFF ;
                lpNetUseInfo->dwRefCount =
                    lpNetUseInfo->dwUseCount = 0 ;

            }

            //
            // allocate a new buffer for next set, since we still need
            // data in the old one, we dont free it. Netcmd lets the
            // system clean up when it exits.
            //
            if (dwErr == WN_SUCCESS)
            {
                if (dwAllocErr = AllocMem(BufferSize = 4096, &Buffer))
                {
                    ErrorExit(dwAllocErr);
                }
            }
        }
        else
        {
            return dwErr;
        }
    }
    while (dwErr == WN_SUCCESS);

    dwErr = WNetCloseEnum(EnumHandle) ;  // we dont report any errors here

    *num_read = EntriesRead ;
    return NERR_Success ;
}


/***
 *  UnavailUseAugment()
 *      Enumerate unavail uses & tags them on.
 *
 *  Args:
 *      none
 *
 *  Returns:
 *      0 - success
 *      exit(2) - command failed
 */
DWORD
UnavailUseAugment(
    LPDWORD      NumRead,
    NET_USE_INFO **NetUseInfoBuffer,
    LPDWORD      NetUseInfoCount
    )
{
    LPBYTE       Buffer ;
    DWORD        dwErr ;
    HANDLE       EnumHandle ;
    DWORD        BufferSize, Count, InitialUseInfoCount ;
    DWORD        err ;
    static TCHAR *NullString = TEXT("") ;

    InitialUseInfoCount = *NumRead ;

    //
    // allocate memory and open the enumeration
    //
    if (err = AllocMem(BufferSize = 4096, &Buffer))
    {
        ErrorExit(err);
    }

    dwErr = WNetOpenEnum(RESOURCE_REMEMBERED, 0, 0, NULL, &EnumHandle) ;

    if (dwErr != WN_SUCCESS)
    {
        return dwErr;
    }

    do
    {
        Count = 0xFFFFFFFF ;
        dwErr = WNetEnumResource(EnumHandle, &Count, Buffer, &BufferSize) ;

        if (dwErr == WN_SUCCESS || dwErr == WN_NO_MORE_ENTRIES)
        {
            LPNETRESOURCE lpNetResource ;
            NET_USE_INFO  *lpNetUseInfo ;
            DWORD i,j ;

            if (Count == 0xFFFFFFFF || Count == 0)
                break ;

            lpNetResource = (LPNETRESOURCE) Buffer ;

            //
            // for each entry, see if it is an unavail one
            //
            for ( i = 0;
                  i < Count;
                  i++,lpNetResource++ )
            {
                lpNetUseInfo =  *NetUseInfoBuffer ;

                //
                // search thru the ones we already have
                //
                for (j = 0;
                     j < InitialUseInfoCount;
                     j++, ++lpNetUseInfo)
                {
                    if (lpNetUseInfo->lpLocalName &&
                        lpNetResource->lpLocalName)
                    {
                        if ( *lpNetUseInfo->lpLocalName != 0 )
                        {
                            // Use _tcsnicmp because the Net api returns an LPTX
                            // redirection without the ':' whereas the WNet api
                            // includes the ':'.
                            if (_tcsnicmp(lpNetResource->lpLocalName,
                                          lpNetUseInfo->lpLocalName,
                                          _tcslen(lpNetUseInfo->lpLocalName))==0)
                            {
                                break;
                            }
                        }
                        else if (*lpNetResource->lpLocalName == 0)
                        {
                            break ;
                        }
                    }
                }

                //
                // if we broke out early, this is already connected, so
                // we dont bother add an 'unavailable' entry.
                //
                if (j < InitialUseInfoCount)
                    continue ;

                //
                // grow the buffer if need. note there are no
                // pointers that point back to the buffer, so we
                // should be fine with the realloc.
                //
                if (*NumRead >= *NetUseInfoCount)
                {
                    //
                    // make sure it can hold all the new data, and add 64
                    // to reduce the number of reallocs
                    //
                    *NetUseInfoCount += 64 ;
                    err = ReallocMem(*NetUseInfoCount * sizeof(NET_USE_INFO),
                                     (LPBYTE *) NetUseInfoBuffer);

                    if (err != NERR_Success)
                    {
                        return err;
                    }
                }

                lpNetUseInfo = *NetUseInfoBuffer + *NumRead ;

                lpNetUseInfo->lpLocalName = lpNetResource->lpLocalName ?
                    lpNetResource->lpLocalName : NullString ;
                lpNetUseInfo->lpRemoteName = lpNetResource->lpRemoteName ?
                    lpNetResource->lpRemoteName : NullString ;
                lpNetUseInfo->lpProviderName = lpNetResource->lpProvider ?
                    lpNetResource->lpProvider : NullString ;
                lpNetUseInfo->dwType = lpNetResource->dwType ;
                lpNetUseInfo->fIsLanman = FALSE ;   // no more info of interest
                lpNetUseInfo->dwStatus = USE_REMEMBERED ;
                lpNetUseInfo->dwRefCount =
                    lpNetUseInfo->dwUseCount = 0 ;

                _tcsupr(lpNetUseInfo->lpLocalName) ;
                *NumRead += 1 ;
            }

            //
            // allocate a new buffer for next set, since we still need
            // data in the old one, we dont free it. Netcmd lets the
            // system clean up when it exits.
            //
            if (dwErr == WN_SUCCESS)
            {
                if (err = AllocMem(BufferSize = 4096, &Buffer))
                {
                    ErrorExit(err);
                }
            }
        }
        else
        {
            return dwErr;
        }
    }
    while (dwErr == WN_SUCCESS) ;

    dwErr = WNetCloseEnum(EnumHandle) ;  // we dont report any errors here

    return NERR_Success ;
}


/***
 *  CmpUseInfo(use1,use2)
 *
 *  Compares two USE_INFO_1 structures and returns a relative
 *  lexical value, suitable for using in qsort.
 *
 */

int __cdecl CmpUseInfo(const VOID FAR * use1, const VOID FAR * use2)
{
    register USHORT localDev1, localDev2;
    register DWORD devType1, devType2;

    /* first sort by whether use has local device name */
    localDev1 = ((NET_USE_INFO *) use1)->lpLocalName[0];
    localDev2 = ((NET_USE_INFO *) use2)->lpLocalName[0];
    if (localDev1 && !localDev2)
        return -1;
    if (localDev2 && !localDev1)
        return +1;

    /* then sort by device type */
    devType1 = ((NET_USE_INFO *) use1)->dwType;
    devType2 = ((NET_USE_INFO *) use2)->dwType;
    if (devType1 != devType2)
        return( (devType1 < devType2) ? -1 : 1 );


    /* if local device, sort by local name */
    if (localDev1)
        return _tcsicmp ( ((NET_USE_INFO *) use1)->lpLocalName,
              ((NET_USE_INFO *) use2)->lpLocalName);
    else
        /* sort by remote name */
        return _tcsicmp ( ((NET_USE_INFO *) use1)->lpRemoteName,
              ((NET_USE_INFO *) use2)->lpRemoteName);
}



/***
 *  use_unc()
 *      Process "NET USE unc-name" command line (display or add)
 *
 *  Args:
 *      name - the unc name
 *
 *  Returns:
 *      0 - success
 *      exit(2) - command failed
 */
VOID use_unc(TCHAR * name)
{
    DWORD         dwErr;
    LPUSE_INFO_1  use_entry;

    UseInit();
    if (dwErr = NetUseGetInfo(NULL,
                              name,
                              1,
                              (LPBYTE *) &use_entry))
    {
        //
        // hit an error, so just add it
        //
        NetApiBufferFree((LPBYTE) use_entry);
        use_add(NULL, name, NULL, FALSE, TRUE);
    }
    else
    {
        //
        // it is Lanman. treat it as we have in the past
        //
        if ((use_entry->ui1_usecount == 0) && (use_entry->ui1_refcount == 0))
            use_add(NULL, name, NULL, FALSE, FALSE);
        else
            LanmanDisplayUse(use_entry);
        NetApiBufferFree((CHAR FAR *) use_entry);
        InfoSuccess();
    }
}



/***
 *  use_display_dev()
 *      Display status of redirected device.
 *
 *  Args:
 *      dev - redirected device
 *
 *  Returns:
 *      0 - success
 *      exit(2) - command failed
 */
VOID use_display_dev(TCHAR * dev)
{
    DWORD         dwErr;
    LPUSE_INFO_1  use_entry = NULL;

    if (IsWildCard(dev))
    help_help(0, USAGE_ONLY) ;

    UseInit();
    if (dwErr = NetUseGetInfo(NULL,
                              dev,
                              1,
                              (LPBYTE *) &use_entry))
    {
        //
        // Lanman failed, so try MPR
        //
        NetApiBufferFree((LPBYTE) use_entry);
        MprUseDisplay(dev) ;
        InfoSuccess();
    }
    else
    {
        LanmanDisplayUse(use_entry);
        NetApiBufferFree((CHAR FAR *) use_entry);
        InfoSuccess();
    }
}

VOID
MprUseDisplay(
    TCHAR *dev
    )
{
    DWORD   dwErr;
    DWORD   dwLength = 0;
    LPTSTR  lpRemoteName;
    DWORD   maxLen;

    //
    // Figure out how large a buffer we need
    //
    dwErr = WNetGetConnection(dev, NULL, &dwLength);

    if (dwErr != WN_MORE_DATA)
    {
        ErrorExit(dwErr);
    }

    dwErr = AllocMem(dwLength * sizeof(TCHAR), &lpRemoteName);

    if (dwErr != NERR_Success)
    {
        ErrorExit(dwErr);
    }

    dwErr = WNetGetConnection(dev, lpRemoteName, &dwLength);

    if (dwErr != WN_SUCCESS && dwErr != WN_CONNECTION_CLOSED)
    {
        ErrorExit(dwErr);
    }

    dwLength = _tcslen(dev);

    if (dwLength == 2 && _istalpha(dev[0]) && dev[1] == TEXT(':'))
    {
        UseMsgList[USE_TYPE_TBD].msg_number = APE2_USE_TYPE_DISK;
    }
    else if (dwLength >= 3 && _tcsnicmp(dev, TEXT("LPT"), 3) == 0)
    {
        UseMsgList[USE_TYPE_TBD].msg_number = APE2_USE_TYPE_PRINT;
    }
    else
    {
        UseMsgList[USE_TYPE_TBD].msg_number = APE2_GEN_UNKNOWN;
    }

    GetMessageList(NUM_USE_MSGS, UseMsgList, &maxLen);
    maxLen += 5;

    WriteToCon(fmtPSZ,0,maxLen,
               PaddedString(maxLen,UseMsgList[USE_MSG_LOCAL].msg_text,NULL),
               dev);

    WriteToCon(fmtPSZ,0,maxLen,
               PaddedString(maxLen,UseMsgList[USE_MSG_REMOTE].msg_text,NULL),
               lpRemoteName);

    WriteToCon(fmtNPSZ,0,maxLen,
               PaddedString(maxLen,UseMsgList[USE_MSG_TYPE].msg_text,NULL),
               UseMsgList[USE_TYPE_TBD].msg_text);

    FreeMem(lpRemoteName);

    return;
}


/***
 *  use_add()
 *      Add a redirection
 *
 *  Args:
 *      dev - local device to redirect
 *      name - remote name to redirect to
 *      pass - password to use when validating the use
 *      comm - TRUE --> use as a char dev
 *      print_ok - should a message be printed on success?
 *
 *  Returns:
 *      0 - success
 *      exit(2) - command failed
 */
VOID use_add(TCHAR * dev, TCHAR * name, TCHAR * pass, int comm, int print_ok)
{
    static TCHAR            pbuf[(PWLEN>CREDUI_MAX_PASSWORD_LENGTH?PWLEN:CREDUI_MAX_PASSWORD_LENGTH)+1];
    static TCHAR            UserBuffer[CREDUI_MAX_USERNAME_LENGTH+1];
    static TCHAR ServerNameBuffer[MAX_PATH+1];

    USHORT                  err;                /* short return status */
    ULONG                   ulErr ;             /* long return status */
    ULONG                   longtype;           /* type field for I_NetPath */
    NETRESOURCEW            netresource ;
    BOOL                    fRememberSwitch = FALSE ;
    BOOL                    fRemember = FALSE ;
    BOOL                    fSmartCard = FALSE;
    ULONG                   bConnectFlags = 0L ;
    LPWSTR                  pw_username = NULL;
    LPWSTR                  pw_pass     = NULL;
    TCHAR                   *devicename = dev ;
    BOOL                    fExitCodeIsDrive = FALSE ;
    BOOL fSaveCred = FALSE;

    // unreferenced
    (void) comm ;

    UseInit();

    //
    // Build a non-UNC version of name to connect to.
    //

    if ( name != NULL ) {
        TCHAR *SlashPointer;

        //
        // Lob off the leading backslashes
        //

        if ( name[0] == '\\' && name[1] == '\\' ) {
            _tcscpy( ServerNameBuffer, &name[2] );
        } else {
            _tcscpy( ServerNameBuffer, name );
        }

        //
        // Lob off the share name
        //

        SlashPointer = _tcschr( ServerNameBuffer, '\\');
        if ( SlashPointer != NULL ) {
            *SlashPointer = '\0';
        }

    } else {
        ServerNameBuffer[0] = '\0';
    }

    // make sure we clean this up
    AddToMemClearList(pbuf, sizeof(pbuf), FALSE) ;

    // deal with any wild card Device specification
    if (devicename)
    {
        // If the devicname is a '?', then the exit code should be the ASCII
        // value of the drive that we connect.
        if (IsQuestionMark(devicename))
        {
            fExitCodeIsDrive = TRUE;
        }
        devicename = MapWildCard(devicename, NULL) ;
        if (!devicename)
        {
            // this can omly happen if no drives left
            ErrorExit(APE_UseWildCardNoneLeft) ;
        }
    }

    /* Initialize netresource structure */
    netresource.lpProvider = NULL ;
    netresource.lpLocalName = NULL ;
    netresource.lpRemoteName = NULL ;
    netresource.dwType = 0L ;

    if (devicename)
    {
        if (I_NetPathType(NULL, devicename, &longtype, 0L))
            ErrorExit(APE_UnknDevType);

        /*
         * NOTE: I would haved LOVED to have used a switch statement here.
         * But since types are now LONGS, and the compiler doesn't support
         * long switch statements, we're stuck with multiple if's.  Sorry.
         */
        if (longtype == ITYPE_DEVICE_DISK)
            netresource.dwType = RESOURCETYPE_DISK;
        else if (longtype == ITYPE_DEVICE_LPT)
            netresource.dwType = RESOURCETYPE_PRINT;
        else if (longtype == ITYPE_DEVICE_COM)
            netresource.dwType = RESOURCETYPE_PRINT;
        else
            ErrorExit(APE_UnknDevType);

        netresource.lpLocalName = devicename ;
    }
    else
    {
        netresource.dwType = RESOURCETYPE_ANY;
        netresource.lpLocalName = L"" ;
    }

    if( name != NULL )
    {
        netresource.lpRemoteName = name ;
    }

    {
        USHORT i;

        // Find out if the /USER or /PERSISTENT switches are used
        for (i = 0; SwitchList[i]; i++)
        {
            //
            // Handle the /PERSISTENT switch
            //
            if ( !(_tcsncmp(SwitchList[i],
                 swtxt_SW_USE_PERSISTENT,
                 _tcslen(swtxt_SW_USE_PERSISTENT))) )
            {
                LPTSTR ptr;
                DWORD  res;
                DWORD  answer;

                fRememberSwitch = TRUE;

                // find the colon separator
                if ((ptr = FindColon(SwitchList[i])) == NULL)
                {
                    ErrorExit(APE_InvalidSwitchArg);
                }

                // parse string after colon for YES or NO
                if ((res = LUI_ParseYesNo(ptr,&answer)) != 0)
                {
                    ErrorExitInsTxt(APE_CmdArgIllegal,SwitchList[i]);
                }

                fRemember = (answer == LUI_YES_VAL) ;

            //
            // Handle the /USER switch
            //
            }
            else if ( !(_tcsncmp(SwitchList[i],
                      swtxt_SW_USE_USER,
                      _tcslen(swtxt_SW_USE_USER))) )
            {
                PTCHAR ptr;
                // find the colon separator
                if ((ptr = FindColon(SwitchList[i])) == NULL)
                    ErrorExit(APE_InvalidSwitchArg);

                pw_username = ptr;

            //
            // Handle the /SMARTCARD switch
            //

            } else if ( !(_tcscmp(SwitchList[i], swtxt_SW_USE_SMARTCARD ))) {

                fSmartCard = TRUE;

            //
            // Handle the /SAVECRED switch
            //

            } else if ( !(_tcscmp(SwitchList[i], swtxt_SW_USE_SAVECRED )))  {

                fSaveCred = TRUE;


            //
            // Handle the /Delete switch
            //  (The parser really doesn't let this through.)
            //
            }
            else if ( !(_tcscmp(SwitchList[i], swtxt_SW_DELETE)) )
            {
                // what the heck? adding and deleting?
                ErrorExit(APE_ConflictingSwitches) ;
            }
            // ignore other switches
        }
    }

    // remember switch was not specified
    if (!fRememberSwitch)
    {
        if (QueryDefaultPersistence(&fRemember)!=NERR_Success)
            InfoPrint(APE_ProfileReadError);
    }

    //
    // /user and /savecred are mutually exclusive.
    //  This is because the auth packages don't call cred man if the user name
    //  is specified.  Therefore, the auth package didn't pass the target info to cred man.
    //  If there is no target info, the UI will save a server specific cred.
    //

    if ( pw_username != NULL && fSaveCred ) {
        ErrorExit(APE_ConflictingSwitches) ;
    }


    //
    // Handle /SMARTCARD switch.
    //      Prompt for smart card credentials.
    //

    if ( fSmartCard ) {

        //
        // We don't know how to save smartcard creds
        //

        if ( fSaveCred ) {
            ErrorExit(APE_ConflictingSwitches) ;
        }

        //
        // If a user name was specified,
        //  use it to select which smart card to use.
        //

        if ( pw_username != NULL ) {
            _tcscpy( UserBuffer, pw_username );
        } else {
            UserBuffer[0] = '\0';
        }

        //
        // If password is specified,
        //  use it as the default PIN

        if ( pass != NULL ) {

            // Consider "*" to be the same as "not specified"
            if (! _tcscmp(pass, TEXT("*"))) {
                pbuf[0] = '\0';
            } else {
                if (err = LUI_CanonPassword(pass)) {
                    ErrorExit(err);
                }
                _tcscpy( pbuf, pass );
            }

        } else {
            pbuf[0] = '\0';
        }



        //
        // Call the common UI.
        //
        // RtlZeroMemory( &UiInfo, sizeof(UiInfo) );
        // UiInfo.dwVersion = 1;

        ulErr = CredUICmdLinePromptForCredentialsW(
                    ServerNameBuffer,   // Target name
                    NULL,               // No context
                    NO_ERROR,           // No authentication error
                    UserBuffer,
                    CREDUI_MAX_USERNAME_LENGTH,
                    pbuf,
                    CREDUI_MAX_PASSWORD_LENGTH,
                    NULL,               // SaveFlag not allowed unless flag is specified
                    CREDUI_FLAGS_REQUIRE_SMARTCARD |
                        CREDUI_FLAGS_DO_NOT_PERSIST );

        if ( ulErr != NO_ERROR ) {
            ErrorExit(ulErr);
        }

        pw_username = UserBuffer;
        pw_pass = pbuf;


    //
    // Handle cases where the password is specified on the command line.
    //

    } else if (pass) {

        //
        // We don't know how to save creds we don't prompt for
        //

        if ( fSaveCred ) {
            ErrorExit(APE_ConflictingSwitches) ;
        }



        if (! _tcscmp(pass, TEXT("*")))
        {


            pass = pbuf;
            IStrings[0] = name;
            ReadPass(pass, PWLEN, 0, APE_UsePassPrompt, 1, FALSE);
            if (err = LUI_CanonPassword(pass))
                ErrorExit(err);
        }
        else
        {
            if (err = LUI_CanonPassword(pass))
                ErrorExit(err);
        }

        pw_pass = pass;
    }


    //
    // Loop handling assigning to the next drive letter
    //
    do {

        //if persistent, the check for clash with existing remembered connection
        bConnectFlags = 0 ;
        if (fRemember)
        {
            if (CheckIfWantUpdate(devicename, name))
                bConnectFlags |= CONNECT_UPDATE_PROFILE ;
        }

        //
        // Allow it to prompt for us if the credential aren't on the command line
        //
        if ( !pass && !fSmartCard) {
            bConnectFlags |= CONNECT_INTERACTIVE | CONNECT_COMMANDLINE;

            //
            // If the caller wants to save both username and password,
            //  create an enterprise peristed cred.
            //
            if ( fSaveCred ) {
                bConnectFlags |= CONNECT_CMD_SAVECRED;
            }
        }

        ulErr = WNetAddConnection2(&netresource,
                                   pw_pass,
                                   pw_username,
                                   bConnectFlags) ;

        switch(ulErr)
        {
            case WN_SUCCESS:
                if (fRememberSwitch)
                {
                    DWORD dwErr = SetDefaultPersistence(fRemember);

                    if (dwErr != NERR_Success)
                    {
                        ErrorExit(dwErr);
                    }
                }
                if (print_ok)
                {
                    if (IsWildCard(dev)) // if originally a wildcard
                    {
                        IStrings[0] = devicename;
                        IStrings[1] = name;
                        InfoPrintIns(APE_UseWildCardSuccess, 2) ;
                    }
                    InfoSuccess();
                }
                if (fExitCodeIsDrive)
                {
                    MyExit((int)devicename[0]);
                }
                return;

            case WN_BAD_PASSWORD:
            case WN_ACCESS_DENIED:
            case ERROR_LOGON_FAILURE:

                    WNetErrorExit(ulErr);

            case ERROR_ALREADY_ASSIGNED:
                if (!IsWildCard(dev))
                    ErrorExit(ERROR_ALREADY_ASSIGNED) ;

                // Get another drive letter
                (devicename[0])++;
                devicename = MapWildCard(TEXT("*"), devicename) ;
                if (!devicename)
                {
                    // this can only happen if no drives left
                    ErrorExit(APE_UseWildCardNoneLeft) ;
                }
                netresource.lpLocalName = devicename ;
                break;

            case WN_BAD_NETNAME:
                if (is_admin_dollar(name))
                    ErrorExit(APE_BadAdminConfig);
                // else drop thru

            default:
                WNetErrorExit(ulErr);
        }

    } while ( ulErr == ERROR_ALREADY_ASSIGNED );

}


VOID
use_set_remembered(
   VOID
   )
{
    PTCHAR ptr;
    BOOL fRemember ;

    // Find the /persistent switch
    if ((ptr = FindColon(SwitchList[0])) == NULL)
        ErrorExit(APE_InvalidSwitchArg);

    if ( !(_tcscmp(SwitchList[0], swtxt_SW_USE_PERSISTENT) ) )
    {
        DWORD  res;
        DWORD  answer;

        if ((res = LUI_ParseYesNo(ptr,&answer)) != 0)
        {
            ErrorExitInsTxt(APE_CmdArgIllegal,SwitchList[0]) ;
        }

        fRemember = (answer == LUI_YES_VAL) ;

        res = SetDefaultPersistence(fRemember);

        if (res != NERR_Success)
        {
            ErrorExit(res);
        }
    }
    else
    {
        ErrorExit(APE_InvalidSwitch);
    }


    InfoSuccess();
}


/***
 *  use_del()
 *      Delete a redirection
 *
 *  Args:
 *      dev - device OR unc-name to delete
 *      print_ok - print success message?
 *
 *  Returns:
 *      0 - success
 *      exit(2) - command failed
 */
VOID use_del(TCHAR * dev, BOOL deviceless, int print_ok)
{
    ULONG                   ulErr;              /* API return status */
    BOOL                    fRememberSwitch = FALSE ;
    ULONG                   bConnectFlags = 0L ;

    USHORT i;

    UseInit();

    // Find out if the /PERSISTENT switch is used
    for (i = 0; SwitchList[i]; i++)
    {
        if ( !(_tcscmp(SwitchList[i], swtxt_SW_USE_PERSISTENT)) )
            ErrorExit(APE_InvalidSwitch);
    }

    if (IsWildCard(dev))
    {
    use_del_all() ;
        goto gone;
    }

    bConnectFlags = CONNECT_UPDATE_PROFILE ;  // deletes always update

    if ((ulErr = WNetCancelConnection2( dev,
                                        bConnectFlags,
                                        FALSE)) != WN_SUCCESS)
    {
        if (ulErr != WN_OPEN_FILES)
            WNetErrorExit(ulErr);
    }
    else
        goto gone;

    InfoPrintInsTxt(APE_OpenHandles, dev);
    if (!YorN(APE_UseBlowAway, 0))
        NetcmdExit(2);


    if ((ulErr = WNetCancelConnection2( (LPWSTR)dev,
                                        bConnectFlags,
                                        TRUE )) != WN_SUCCESS)
        WNetErrorExit(ulErr);

gone:

    if (print_ok)
        if ( IsWildCard( dev ) )
            InfoSuccess();
        else
            InfoPrintInsTxt(APE_DelSuccess, dev);
}

/***
 *  use_del_all()
 *      Delete all redirections
 *
 *  Args:
 *  none
 *
 *  Returns:
 *      0 - success
 *      exit(2) - command failed
 */
VOID use_del_all()
{

    DWORD                   err = 0;              /* API return status */
    ULONG                   ulErr = 0;            /* WNet error */
    ULONG                   ulFirstErr = 0;       /* WNet error */
    DWORD                   num_read = 0;         /* num entries read by API */
    DWORD                   i = 0,j = 0;
    DWORD                   NetUseInfoCount = 0 ;
    NET_USE_INFO            *NetUseInfoBuffer = NULL ;
    NET_USE_INFO            *pNetUseInfo = NULL;
    ULONG                   bConnectFlags = 0L ;

    UseInit();

    if (err = MprUseEnum(&num_read, &NetUseInfoBuffer, &NetUseInfoCount))
        ErrorExit(err);

    if (err = UnavailUseAugment(&num_read, &NetUseInfoBuffer, &NetUseInfoCount))
        ErrorExit(err);

    if (err = LanmanUseAugment(num_read, NetUseInfoBuffer))
        ErrorExit(err);

    if (num_read == 0)
        EmptyExit();


    for (i = 0, pNetUseInfo = NetUseInfoBuffer;
        i < num_read; i++, pNetUseInfo++)
    {
        //
        // if we find at least one entry we will display, break
        //
        if (!(pNetUseInfo->fIsLanman)
            || (pNetUseInfo->dwStatus != USE_OK)
            || (pNetUseInfo->dwUseCount != 0)
            || (pNetUseInfo->dwRefCount != 0))
            break;
    }

    qsort(NetUseInfoBuffer,
             num_read,
             sizeof(NET_USE_INFO), CmpUseInfo);

    if (i != num_read)
    {
        InfoPrint(APE_KillDevList);

        for (i = 0, pNetUseInfo = NetUseInfoBuffer;
             i < num_read;
             i++, pNetUseInfo++)
        {
            if (pNetUseInfo->lpLocalName[0] != NULLC)
                WriteToCon(TEXT("    %Fws %Fws\r\n"),
                           PaddedString(15,pNetUseInfo->lpLocalName,NULL),
                           pNetUseInfo->lpRemoteName);
            else
                WriteToCon(TEXT("    %Fws %Fws\r\n"),
                           PaddedString(15,pNetUseInfo->lpLocalName,NULL),
                           pNetUseInfo->lpRemoteName);

        }

        InfoPrint(APE_KillCancel);
        if (!YorN(APE_ProceedWOp, 0))
            NetcmdExit(2);
    }

    bConnectFlags = CONNECT_UPDATE_PROFILE ;  // deletes always update

    ulErr = NO_ERROR;
    ulFirstErr = NO_ERROR;

    for (i = 0, pNetUseInfo = NetUseInfoBuffer;
         i < num_read;
         i++, pNetUseInfo++)
    {
        /* delete both local and UNC uses */
        if (pNetUseInfo->lpLocalName[0] != NULLC)
        {
            ulErr = WNetCancelConnection2( pNetUseInfo->lpLocalName,
                                                bConnectFlags,
                                                FALSE);
        }
        else
        {
           /*
            * Delete All UNC uses to use_entry->ui1_remote
            */
            if ( pNetUseInfo->dwUseCount == 0 )
            {
                pNetUseInfo->dwUseCount = 1;
            }
            for( j = 0; j < pNetUseInfo->dwUseCount; j++ )
            {
                ulErr = WNetCancelConnection2( pNetUseInfo->lpRemoteName,
                                               bConnectFlags,
                                               FALSE );
                if ( ulErr != NO_ERROR )
                    break;
            }
        }

        switch(ulErr)
        {
        case NO_ERROR:
        /* The use was returned by Enum, but is already gone */
        case WN_BAD_NETNAME:
        case WN_NOT_CONNECTED:
            break;

        case WN_OPEN_FILES:
            if (pNetUseInfo->lpLocalName[0] != NULLC)
                IStrings[0] = pNetUseInfo->lpLocalName;
            else
                IStrings[0] = pNetUseInfo->lpRemoteName;
            InfoPrintIns(APE_OpenHandles, 1);
            if (!YorN(APE_UseBlowAway, 0))
                continue;

            if (pNetUseInfo->lpLocalName[0] != NULLC)
            {
                ulErr = WNetCancelConnection2( pNetUseInfo->lpLocalName,
                                                bConnectFlags,
                                                TRUE ) ;
            }
            else
            {
                /*
                * Delete All UNC uses to use_entry->ui1_remote
                */
                for( j = 0; j < pNetUseInfo->dwUseCount; j++ )
                {
                    ulErr = WNetCancelConnection2( pNetUseInfo->lpRemoteName,
                                                   bConnectFlags,
                                                   TRUE );
                    if ( ulErr != NO_ERROR )
                        break;
                }
            }
            if (ulErr == NO_ERROR)
                break;
            // fall through

        default:
            ulFirstErr = ulErr;
        }
    }

    FreeMem((LPBYTE)NetUseInfoBuffer);

    if (ulFirstErr != NO_ERROR)
        WNetErrorExit( ulErr );

}



/***
 *  LanmanDisplayUse()
 *      Display info from a USE_INFO_1 struct
 *
 *  Args:
 *      use_entry - pointer to a USE_INFO_1 struct
 *
 *  Returns:
 *      0
 */

VOID
LanmanDisplayUse(
    LPUSE_INFO_1 use_entry
    )
{
    DWORD       maxLen;
    USHORT      status = APE2_GEN_UNKNOWN;
    USHORT      type   = APE2_GEN_UNKNOWN;

    switch(use_entry->ui1_asg_type)
    {
        case USE_DISKDEV:
            type = APE2_USE_TYPE_DISK;
            break;
        case USE_SPOOLDEV:
            type = APE2_USE_TYPE_PRINT;
            break;
        case USE_CHARDEV:
            type = APE2_USE_TYPE_COMM;
            break;
        case USE_IPC:
            type = APE2_USE_TYPE_IPC;
            break;
    }

    UseMsgList[USE_TYPE_TBD].msg_number = type;

    switch(use_entry->ui1_status)
    {
        case USE_OK:
            status = APE2_USE_STATUS_OK;
            break;
        case USE_PAUSED:
            status = APE2_USE_STATUS_PAUSED;
            break;
        case USE_SESSLOST:
            status = APE2_USE_STATUS_SESSION_LOST;
            break;
        case USE_NETERR:
            status = APE2_USE_STATUS_NET_ERROR;
            break;
        case USE_CONN:
            status = APE2_USE_STATUS_CONNECTING;
            break;
        case USE_RECONN:
            status = APE2_USE_STATUS_RECONNECTING;
            break;
    }

    UseMsgList[USE_STATUS_TBD].msg_number = status;

    GetMessageList(NUM_USE_MSGS, UseMsgList, &maxLen);
    maxLen += 5;

    WriteToCon(fmtPSZ,0,maxLen,
               PaddedString(maxLen, UseMsgList[USE_MSG_LOCAL].msg_text, NULL),
               use_entry->ui1_local);

    WriteToCon(fmtPSZ,0,maxLen,
               PaddedString(maxLen, UseMsgList[USE_MSG_REMOTE].msg_text, NULL),
               use_entry->ui1_remote);

    WriteToCon(fmtNPSZ,0,maxLen,
               PaddedString(maxLen, UseMsgList[USE_MSG_TYPE].msg_text, NULL),
               UseMsgList[USE_TYPE_TBD].msg_text);

    WriteToCon(fmtNPSZ,0,maxLen,
               PaddedString(maxLen, UseMsgList[USE_MSG_STATUS].msg_text, NULL),
               UseMsgList[USE_STATUS_TBD].msg_text);

    WriteToCon(fmtUSHORT,0,maxLen,
               PaddedString(maxLen, UseMsgList[USE_MSG_OPEN_COUNT].msg_text, NULL),
               use_entry->ui1_refcount);

    WriteToCon(fmtUSHORT,0,maxLen,
               PaddedString(maxLen, UseMsgList[USE_MSG_USE_COUNT].msg_text, NULL),
               use_entry->ui1_usecount);
}

/***
 *  use_add_home()
 *              Add a use for the user's home directory
 *
 *      Args:
 *              Dev - device to be used as the home directory
 *              Pass - password, or NULL if none supplied
 *
 *      Returns:
 *              0 - success
 *              exit(2) - command failed
 */

void
use_add_home(
    LPTSTR Dev,
    LPTSTR Pass
    )
{
    DWORD             dwErr;
    TCHAR             HomeDir[PATHLEN];
    TCHAR             Server[MAX_PATH + 1];
    TCHAR FAR         *SubPath;
    ULONG             Type;
    TCHAR             User[UNLEN + 1];
    TCHAR             *DeviceName = Dev ;
    LPWKSTA_INFO_1    info_entry_w;
    LPUSER_INFO_11    user_entry;

    //
    // If necessary, start the workstation and logon.
    //
    UseInit();

    //
    // Get the user name and the name of the server that logged the user on.
    //
    dwErr = MNetWkstaGetInfo(1, (LPBYTE*) &info_entry_w) ;

    if (dwErr)
    {
        ErrorExit(dwErr);
    }

    _tcscpy(User, info_entry_w->wki1_username);
    _tcscpy(Server, TEXT("\\\\")) ;
    _tcscat(Server, info_entry_w->wki1_logon_server);
    NetApiBufferFree((TCHAR FAR *) info_entry_w);

    /* Now get user information (ie. the home directory). If you were     */
    /* logged on STANDALONE, and the local machine is a STANDALONE        */
    /* server, this will still work.  Otherwise (eg., you are logged on   */
    /* STANDALONE on a DOS workstation), it will fail because there is    */
    /* no local UAS.                                                      */

    dwErr = NetUserGetInfo(Server, User, 11, (LPBYTE *) &user_entry);

    if (dwErr)
    {
        ErrorExit(APE_UseHomeDirNotDetermined);
    }

    _tcscpy(HomeDir, user_entry->usri11_home_dir);
    NetApiBufferFree((TCHAR FAR *) user_entry);

    /* If it is null string, return a "not set" error msg. */
    if (HomeDir[0] == NULLC)
        ErrorExit(APE_UseHomeDirNotSet);

    /* Make sure the home directory is a UNC name.  This does not       */
    /* insure that the sharename is usable under DOS, but the           */
    /* general policy on this issue is to make it the admin's           */
    /* responsibility to be aware of non-8.3 sharename implications,    */
    /* and "net share" does issue a warning.                            */
    dwErr = I_NetPathType(NULL, HomeDir, &Type, 0L);
    if (dwErr || Type != ITYPE_UNC)
        ErrorExitInsTxt(APE_UseHomeDirNotUNC, HomeDir);

    /* Split the home directory into a remote name and a subpath.       */
    /* After doing this, HomeDir points to the remote name, and         */
    /* SubPath points to a subpath, or a null string if there is        */
    /* no subpath.                                                      */

    /* Find the backslash between the computername and the sharename.   */
    SubPath = _tcschr(HomeDir + 2, '\\');

    /* Find the next backslash, if there is one. */
    SubPath = _tcschr(SubPath + 1, '\\');

    if (SubPath)
    {
        *SubPath = NULLC;
        SubPath++;
    }
    else
        SubPath = NULL_STRING;

    /* Map the wild cards as need */
    if (DeviceName)
    {
        DeviceName = MapWildCard(DeviceName, NULL) ;
        if (!DeviceName)
        {
            // this can only happen if no drives left
            ErrorExit(APE_UseWildCardNoneLeft) ;
        }
    }


    /* Do the use. If we return, we succeeded. */
    use_add(DeviceName, HomeDir, Pass, FALSE, FALSE);

    IStrings[0] = DeviceName;
    IStrings[1] = HomeDir;
    IStrings[2] = DeviceName;
    IStrings[3] = SubPath;

    InfoPrintIns(APE_UseHomeDirSuccess, 4);
    return;
}

int NEAR is_admin_dollar(TCHAR FAR * name)
{
    TCHAR FAR *              tfpC;

    tfpC = _tcspbrk(name + 2, TEXT("\\/"));
    if (tfpC == NULL)
        return(0);
    tfpC += 1;
    return(!_tcsicmp(ADMIN_DOLLAR, tfpC));
}


/***
 *  UseInit()
 *              Common initialization processing for all the use.c module entry
 *              points.
 *
 *      Args:           None.
 *
 *      Returns:        None.
 */

VOID NEAR
UseInit(VOID)
{

    LanmanProviderName = GetLanmanProviderName() ;
    if (LanmanProviderName == NULL)
        LanmanProviderName = TEXT("") ;
}


/*
 * query the user profile to see if connections are currently being remembered
 */
USHORT QueryDefaultPersistence(BOOL *pfRemember)
{
    // by adding the two, we are guaranteed to have enough
    TCHAR szAnswer[(sizeof(MPR_YES_VALUE)+sizeof(MPR_NO_VALUE))/sizeof(TCHAR)] ;
    ULONG iRes, len ;

    len = DIMENSION(szAnswer) ;
    iRes = GetProfileString(MPR_NETWORK_SECTION,
                            MPR_SAVECONNECTION_KEY,
                            MPR_YES_VALUE,           // default is yes
                            szAnswer,
                            len) ;

    if (iRes == len)  // error
        return(APE_ProfileReadError) ;

    *pfRemember = (_tcsicmp(szAnswer,MPR_YES_VALUE)==0) ;
    return (NERR_Success) ;
}

/*
 * set if connections are currently being remembered
 */
DWORD
SetDefaultPersistence(
    BOOL fRemember
    )
{
    BOOL fSuccess ;

    fSuccess = (WriteProfileString(MPR_NETWORK_SECTION,
                                   MPR_SAVECONNECTION_KEY,
                                   fRemember ? MPR_YES_VALUE : MPR_NO_VALUE ) != 0);

    return (fSuccess ? NERR_Success : APE_ProfileWriteError) ;
}




/*
 * WNetErrorExit()
 *      maps the Winnet error to NERR and error exits
 *
 * arguments:    ULONG win32 error code.
 * return value: none. this baby dont return
 */
VOID
WNetErrorExit(
    ULONG ulWNetErr
    )
{
    WCHAR w_ErrorText[256];
    WCHAR w_ProviderText[64];
    LONG  ulExtendedError ;
    DWORD err ;

    switch (ulWNetErr)
    {
        case WN_SUCCESS :
            return ;

        case WN_BAD_POINTER :
        case WN_BAD_VALUE :
            err = ERROR_INVALID_PARAMETER ;
            break ;

        case WN_BAD_USER :
            err = APE_BadUserContext ;
            break ;

        case WN_NO_NET_OR_BAD_PATH :
            err = ERROR_BAD_NET_NAME ;
            break ;

        case WN_NO_NETWORK :
            err = NERR_WkstaNotStarted ;
            break ;

        case WN_NOT_CONNECTED :
            err = NERR_UseNotFound ;
            break ;

        case WN_DEVICE_IN_USE :
            err = NERR_DevInUse ;
            break ;

        case WN_BAD_PROFILE :
        case WN_CANNOT_OPEN_PROFILE :
            err = APE_ProfileReadError ;
            break ;

        /*
         * these should not happen under the calls we currently make,
         * but for completeness, they are there.
         */
        case WN_BAD_PROVIDER :
        case WN_CONNECTION_CLOSED :
        case WN_NOT_CONTAINER :
        case WN_FUNCTION_BUSY :
        case WN_DEVICE_ERROR :
            err = ERROR_UNEXP_NET_ERR ;
            break ;

        /*
         * special case this one
         */
        case WN_EXTENDED_ERROR :
            // get the extended error
            ulWNetErr = WNetGetLastError(&ulExtendedError,
                                          (LPWSTR)w_ErrorText,
                                          DIMENSION(w_ErrorText),
                                          (LPWSTR)w_ProviderText,
                                          DIMENSION(w_ProviderText));

            // if we got it, print it out
            if (ulWNetErr == WN_SUCCESS)
            {
                TCHAR buf[16] ;

                IStrings[0] = _ultow(ulExtendedError, buf, 10);
                ErrorPrint(APE_OS2Error,1) ;
                WriteToCon(TEXT("%ws\r\n"), w_ErrorText) ;
                MyExit(2) ;
            }

            // otherwise report it as unexpected error
            err = ERROR_UNEXP_NET_ERR ;
            break ;

        default:
           // the the remainder dont need to be mapped.
           err = ulWNetErr ;
           break ;
    }

    ErrorExit(err) ;
}


/*
 * code to handle the situation where the user has a remembered
 * connection that is currently not used, and we need to figure out
 * if we need to delete it first.
 *
 * returns whether we need update profile.
 */
BOOL   CheckIfWantUpdate(TCHAR *dev, TCHAR *resource)
{
    WCHAR w_RemoteName[MAX_PATH];
    ULONG ulErr, cchRemoteName = DIMENSION(w_RemoteName);

    // if deviceless, no problem since never remembered anyway.
    if (dev == NULL)
        return FALSE ;

    // check out the device
    ulErr = WNetGetConnection( (LPWSTR)dev,
                                (LPWSTR)w_RemoteName,
                                &cchRemoteName );

    // device is really connected, bag out
    if (ulErr == WN_SUCCESS)
        ErrorExit(ERROR_ALREADY_ASSIGNED) ;

    // it is an unavail remembered device, so prompt as need
    if (ulErr == WN_CONNECTION_CLOSED)
    {
        // if the new and old are the same we just return FALSE
        // since the user effectively does not change his profile
        if (!_tcsicmp(w_RemoteName, resource))
        {
            return FALSE ;
        }

        // check if YES/NO switch is specified.
        if (YorN_Switch == 2)
        {
            // he specified /NO, so we tell him why we bag out
            IStrings[0] = dev ;
            IStrings[1] = w_RemoteName ;
            ErrorExitIns(APE_DeviceIsRemembered,2) ;
        }

        // nothing specified, so ask user
        if (YorN_Switch == 0)
        {
            IStrings[0] = dev ;
            IStrings[1] = w_RemoteName ;
            if (!LUI_YorNIns(IStrings,2,APE_OverwriteRemembered,1))
            {
                // he said no, so quit
                NetcmdExit(2) ;
            }
        }

        // remove the persistent connection,
        // we get here if the user specifies /YES, or didnt
        // specify anything but consented,
        if (WNetCancelConnection2( dev,
                                   CONNECT_UPDATE_PROFILE,
                                   FALSE) != WN_SUCCESS)

            ErrorExit(APE_ProfileWriteError) ;


    }

    // if we get here then all is cool, let the caller carry on.
    return TRUE ;
}



#define PROVIDER_NAME_LEN    256
#define PROVIDER_NAME_VALUE  L"Name"
#define PROVIDER_NAME_KEY    L"System\\CurrentControlSet\\Services\\LanmanWorkstation\\NetworkProvider"

/***
 *  GetLanmanProviderName()
 *      Reads the Lanman provider name from the registry.
 *      This is to make sure we only use the LM provider even
 *      if someone else supports UNC.
 *
 *  Args:
 *  none
 *
 *  Returns:
 *  pointer to provider name if success
 *      NULL if cannot read registry
 *  ErrorExit() for other errors.
 */
WCHAR *GetLanmanProviderName(void)
{
    LONG   Nerr;
    LPBYTE buffer ;
    HKEY   hKey ;
    DWORD  buffersize, datatype ;

    buffersize = PROVIDER_NAME_LEN * sizeof(WCHAR) ;
    datatype = REG_SZ ;
    if (Nerr = AllocMem(buffersize, &buffer))
        ErrorExit(Nerr) ;

    Nerr = RegOpenKeyExW(HKEY_LOCAL_MACHINE,
                        PROVIDER_NAME_KEY,
                        0L,
                        KEY_QUERY_VALUE,
                        &hKey) ;

    if (Nerr != ERROR_SUCCESS)
    {
        // if cannot read, we use NULL. this is more generous
        // than normal, but at least the command will still work if
        // we cannot get to this.
        return NULL ;
    }

    Nerr = RegQueryValueExW(hKey,
                           PROVIDER_NAME_VALUE,
                           0L,
                           &datatype,
                           (LPBYTE)buffer,
                           &buffersize) ;

    if (Nerr == ERROR_MORE_DATA)
    {
        if (Nerr = AllocMem(buffersize, &buffer))
        {
            RegCloseKey(hKey) ;  // ignore any error here. its harmless
                                 // and NET.EXE doesn't hang around.
            ErrorExit(Nerr);
        }

        Nerr = RegQueryValueExW(hKey,
                               PROVIDER_NAME_VALUE,
                               0L,
                               &datatype,
                               (LPBYTE)buffer,
                               &buffersize) ;

    }

    (void) RegCloseKey(hKey) ;  // ignore any error here. its harmless
                                // and NET.EXE doesnt hang around anyway.

    if (Nerr != ERROR_SUCCESS)
    {
        return(NULL) ;  // treat as cannot read
    }


    return ((WCHAR *) buffer);
}

/***
 *  MapWildCard()
 *      Maps the wildcard ASTERISK to next avail drive.
 *
 *  Args:
 *  dev - the input string. Must NOT be NULL.
 *
 *  Returns:
 *      dev unchanged if it is not the wildcard
 *      pointer to next avail drive id dev is wildcard
 *  NULL if there are no avail drives left
 */
LPTSTR
MapWildCard(
    LPTSTR dev,
    LPTSTR startdev
    )
{
    static TCHAR new_dev[DEVLEN+1] ;

    //
    // if not the wold card char, just return it unchanged
    //
    if (!IsWildCard(dev))
    {
        return dev ;
    }

    //
    // need find the next avail drive letter
    // note: the char advance does not need to be DBCS safe,
    // since we are only dealing with drive letters.
    //
    if ( startdev != NULL )
    {
        _tcscpy(new_dev, startdev);
    }
    else
    {
        _tcscpy(new_dev,TEXT("Z:\\")) ;
    }

    while ( TRUE )
    {
        if (GetDriveType(new_dev) == 1) // 1 means root not found
        {
            //
            // check if it's a remembered connection
            //
            DWORD status;
            TCHAR remote_name[40];  // length doesn't matter since we
                                    // check for WN_MORE_DATA
            DWORD length = sizeof(remote_name)/sizeof(TCHAR);

            new_dev[2] = 0 ;

            status = WNetGetConnection(new_dev, remote_name, &length);
            if (status == WN_CONNECTION_CLOSED ||
                status == WN_MORE_DATA ||
                status == WN_SUCCESS)
            {
                //
                // it's a remembered connection; try the next drive
                //
                new_dev[2] = TEXT('\\');
            }
            else
            {
                return (new_dev) ;
            }
        }

        if ( new_dev[0] == 'c' || new_dev[0] == 'C' )
        {
            break;
        }

        --new_dev[0] ;
    }

    //
    // if we got here, there were no drives left
    //
    return NULL ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netcmd\netuse\view.c ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1987-1992          **/
/********************************************************************/

/*
 *  view.c
 *      Commands for viewing what resources are available for use.
 *
 *  History:
 *      07/02/87, ericpe, initial coding.
 *      10/31/88, erichn, uses OS2.H instead of DOSCALLS
 *      01/04/89, erichn, filenames now MAXPATHLEN LONG
 *      05/02/89, erichn, NLS conversion
 *      05/19/89, erichn, NETCMD output sorting
 *      06/08/89, erichn, canonicalization sweep
 *      02/15/91, danhi,  convert to 16/32 mapping layer
 *      04/09/91, robdu,  LM21 bug fix 1502
 *      07/20/92, JohnRo, Use DEFAULT_SERVER equate.
 */

/* Include files */

#define INCL_NOCOMMON
#define INCL_DOSMEMMGR
#define INCL_DOSFILEMGR
#define INCL_ERRORS
#include <os2.h>
#include <search.h>
#include <lmcons.h>
#include <lmerr.h>
#include <lmapibuf.h>
#include <apperr.h>
#include <apperr2.h>
#include <lmshare.h>
#include <lmuse.h>
#include <dlserver.h>
#include "mserver.h"

#include "netcmds.h"
#include "nettext.h"
#include "msystem.h"

/* Forward declarations */

int __cdecl CmpSvrInfo1 ( const VOID FAR *, const VOID FAR * );
int __cdecl CmpShrInfo1 ( const VOID FAR *, const VOID FAR *);
int __cdecl CmpShrInfoGen ( const VOID FAR *, const VOID FAR *);

DWORD get_used_as ( LPWSTR, LPWSTR, DWORD );
void   display_other_net(TCHAR *net, TCHAR *node) ;
TCHAR * get_provider_name(TCHAR *net) ;
DWORD  enum_net_resource(LPNETRESOURCE, LPBYTE *, LPDWORD, LPDWORD) ;
DWORD list_nets(VOID);


#define VIEW_UNC            0
#define VIEW_MORE           (VIEW_UNC + 1)
#define USE_TYPE_DISK       (VIEW_MORE + 1)
#define USE_TYPE_COMM       (USE_TYPE_DISK + 1)
#define USE_TYPE_PRINT      (USE_TYPE_COMM + 1)
#define USE_TYPE_IPC        (USE_TYPE_PRINT + 1)
#define USE_TYPE_UNKNOWN    (USE_TYPE_IPC + 1)
#define VIEW_CACHED_MANUAL  (USE_TYPE_UNKNOWN + 1)
#define VIEW_CACHED_AUTO    (VIEW_CACHED_MANUAL+1)
#define VIEW_CACHED_VDO     (VIEW_CACHED_AUTO+1)
#define VIEW_CACHED_DISABLED (VIEW_CACHED_VDO+1)

static MESSAGE ViewMsgList[] = {
    { APE2_VIEW_UNC,            NULL },
    { APE2_VIEW_MORE,           NULL },
    { APE2_USE_TYPE_DISK,       NULL },
    { APE2_USE_TYPE_COMM,       NULL },
    { APE2_USE_TYPE_PRINT,      NULL },
    { APE2_USE_TYPE_IPC,        NULL },
    { APE2_GEN_UNKNOWN,         NULL },
    { APE2_GEN_CACHED_MANUAL,   NULL },
    { APE2_GEN_CACHED_AUTO,     NULL },
    { APE2_GEN_CACHED_VDO,      NULL },
    { APE2_GEN_CACHED_DISABLED, NULL },
};

#define NUM_VIEW_MSGS (sizeof(ViewMsgList)/sizeof(ViewMsgList[0]))

#define MAX_SHARE_LEN  (MAX_PATH + NNLEN + 4)

/***
 *  view_display()
 *
 *  Displays info as reqested through use of the Net View command.
 *
 *  Args:
 *      name - the name of the server for which info is desired.
 *             If NULL, the servers on the Net are enumerated.
 *
 *  Returns:
 *      nothing - success
 *      exit(1) - command completed with errors
 */
VOID
view_display ( TCHAR * name )
{
    DWORD            dwErr;
    LPTSTR           pEnumBuffer;
    LPTSTR           pGetInfoBuffer;
    DWORD            _read;        /* to receive # of entries read */
    DWORD            msgLen;      /* to hold max length of messages */
    LPTSTR           msgPtr;      /* message to print */
    LPSERVER_INFO_1  server_entry;
    LPSERVER_INFO_0  server_entry_0;
    LPSHARE_INFO_1   share_entry;

    SHORT            errorflag = 0;
    DWORD            i;
    LPTSTR           comment;
    LPWSTR           tname = NULL;
    USHORT           more_data = FALSE;
    LPTSTR           DollarPtr;

    TCHAR            *Domain = NULL;
    TCHAR            *Network = NULL;
    ULONG            Type = SV_TYPE_ALL;
    BOOLEAN          b501 = TRUE;
    BOOLEAN          bShowCache = FALSE;

    INT              iLongestShareName = 0;
    INT              iLongestType = 0;
    INT              iLongestUsedAs = 0;
    INT              iLongestCacheOrRemark = 0;

#define NEXT_SHARE_ENTRY(p) \
         p= (b501 ? (LPSHARE_INFO_1) (((LPSHARE_INFO_501) p) + 1) : ((LPSHARE_INFO_1) p) + 1)


    GetMessageList(NUM_VIEW_MSGS, ViewMsgList, &msgLen);

    for (i = 0; SwitchList[i]; i++) 
    {
        TCHAR *ptr;

        //
        // only have 2 switches, and they are not compatible
        //
        if (i > 0)
        {
            ErrorExit(APE_ConflictingSwitches);
        }

        ptr = FindColon(SwitchList[i]);

        if (!_tcscmp(SwitchList[i], swtxt_SW_DOMAIN)) 
        {

            //
            //  If no domain specified, then we want to enumerate domains,
            //  otherwise we want to enumerate the servers on the domain
            //  specified.
            //

            if (ptr == NULL) 
                Type = SV_TYPE_DOMAIN_ENUM;
            else 
                Domain = ptr;
        }
        else if (!_tcscmp(SwitchList[i], swtxt_SW_NETWORK)) 
        {
            //
            // enumerate top level of specific network. if none,
            // default to LM.
            //
            if (ptr && *ptr) 
               Network = ptr ;
        }
        else if( !_tcscmp(SwitchList[i], swtxt_SW_CACHE))
        {
            //
            // Show the cache setting for each share
            //
            bShowCache = TRUE;
        }
        else
        {
            ErrorExit(APE_InvalidSwitch);
        }
    }

    //
    // a specific net was requested. display_other_net does
    // not return. 
    //
    if (Network != NULL)
    {
        (void) display_other_net(Network,name) ;
    }


    if (name == NULL)
    {

        ULONG i;

        if ((dwErr = MNetServerEnum(DEFAULT_SERVER,
                                    (Type == SV_TYPE_DOMAIN_ENUM ? 100 : 101),
                                    (LPBYTE*)&pEnumBuffer,
                                    &_read,
                                    Type,
                                    Domain)) == ERROR_MORE_DATA)
        {
            more_data = TRUE;
        }
        else if (dwErr)
        {
            ErrorExit(dwErr);
        }

        if (_read == 0)
            EmptyExit();

        qsort(pEnumBuffer,
                 _read,
                 (Type == SV_TYPE_DOMAIN_ENUM ? sizeof(SERVER_INFO_0) : sizeof(SERVER_INFO_1)),
                 CmpSvrInfo1);

        if (Type == SV_TYPE_DOMAIN_ENUM)
            InfoPrint(APE2_VIEW_DOMAIN_HDR);
        else
            InfoPrint(APE2_VIEW_ALL_HDR);
        PrintLine();

        /* Print the listing */

        if (Type == SV_TYPE_DOMAIN_ENUM) {
            for (i=0, server_entry_0 =
                 (LPSERVER_INFO_0) pEnumBuffer; i < _read;
                i++, server_entry_0++)
            {
                WriteToCon(TEXT("%Fws "), PaddedString(20,server_entry_0->sv0_name,NULL));
                PrintNL();
            }
        } else {

            for (i=0, server_entry =
                 (LPSERVER_INFO_1) pEnumBuffer; i < _read;
                i++, server_entry++)
            {
                WriteToCon(TEXT("\\\\%Fws "), PaddedString(20,server_entry->sv1_name,NULL));
                PrintDependingOnLength(-56, server_entry->sv1_comment);
                PrintNL();
            }
        }
        NetApiBufferFree(pEnumBuffer);
    }
    else
    {
        DWORD avail ; 
        DWORD totAvail;

        if( bShowCache == TRUE ) {
            dwErr = NetShareEnum(name,
                                 501,
                                 (LPBYTE*)&pEnumBuffer,
                                 MAX_PREFERRED_LENGTH,
                                 &_read,
                                 &totAvail,
                                 NULL);
        }

        if( bShowCache == FALSE || (dwErr != NO_ERROR && dwErr != ERROR_BAD_NETPATH) ) {
            dwErr = NetShareEnum(name,
                                 1,
                                 (LPBYTE*)&pEnumBuffer,
                                 MAX_PREFERRED_LENGTH,
                                 &_read,
                                 &totAvail,
                                 NULL);
            b501 = FALSE;
        }

        if( dwErr == ERROR_MORE_DATA )
        {
            more_data = TRUE;
        }
        else if (dwErr)
        {
            ErrorExit(dwErr);
        }

        if (_read == 0)
        {
            EmptyExit();
        }

        /* Are there any shares that we will display? */

        for (i=0, share_entry = (LPSHARE_INFO_1) pEnumBuffer;
             i < _read;
             i++, NEXT_SHARE_ENTRY( share_entry ) )
        {
            DollarPtr = _tcsrchr(share_entry->shi1_netname, DOLLAR);

            //
            // If no DOLLAR in sharename, or last DOLLAR is nonterminal, it is a                    
            // valid share and we want to display it.  Find out the lengths of the
            // longest strings to display so that we can format the output in a
            // decent way
            //

            if (!DollarPtr || *(DollarPtr + 1))
            {
                int iTempLength = 0;

                //
                // Get the share name string that needs the most screen characters
                // to be displayed.
                //

                iTempLength = SizeOfHalfWidthString(share_entry->shi1_netname);

                if (iTempLength > iLongestShareName)
                {
                    iLongestShareName = iTempLength;
                }

                //
                // Get the share type string that needs the most screen characters
                // to be displayed.
                //
                switch ( share_entry->shi1_type & ~STYPE_SPECIAL )
                {
                    case STYPE_DISKTREE :
                        iTempLength = SizeOfHalfWidthString(ViewMsgList[USE_TYPE_DISK].msg_text);
                        break;
                    case STYPE_PRINTQ :
                        iTempLength = SizeOfHalfWidthString(ViewMsgList[USE_TYPE_PRINT].msg_text);
                        break;
                    case STYPE_DEVICE :
                        iTempLength = SizeOfHalfWidthString(ViewMsgList[USE_TYPE_COMM].msg_text);
                        break;
                    case STYPE_IPC :
                        iTempLength = SizeOfHalfWidthString(ViewMsgList[USE_TYPE_IPC].msg_text);
                        break;
                    default:
                        iTempLength = SizeOfHalfWidthString(ViewMsgList[USE_TYPE_UNKNOWN].msg_text);
                        break;
                }

                if (iTempLength > iLongestType)
                {
                    iLongestType = iTempLength;
                }

                //
                // Get the Used As string that needs the most screen characters
                // to be displayed.  Add 2 for a backslash and NUL character.
                //

                if (dwErr = AllocMem((wcslen(name) + wcslen(share_entry->shi1_netname) + 2) * sizeof(WCHAR),
                                     &tname))
                {
                    ErrorExit(dwErr);
                }

                _tcscpy(tname, name);
                _tcscat(tname, TEXT("\\"));
                _tcscat(tname, share_entry->shi1_netname);

                if (!get_used_as ( tname, Buffer, LITTLE_BUF_SIZE - 1 ))
                {
                    iTempLength = SizeOfHalfWidthString(Buffer);

                    if (iTempLength > iLongestUsedAs)
                    {
                        iLongestUsedAs = iTempLength;
                    }
                }

                FreeMem(tname);
                tname = NULL;

                //                    
                // Get the cache or remark string (depending on which one we
                // will end up displaying) that needs the most screen characters
                // to be displayed.
                //
                if( b501 == TRUE) 
                {
                    TCHAR *CacheString = NULL;

                    switch(((LPSHARE_INFO_501) share_entry)->shi501_flags & CSC_MASK) 
                    {
                        case CSC_CACHE_MANUAL_REINT:
                            iTempLength = SizeOfHalfWidthString(ViewMsgList[ VIEW_CACHED_MANUAL ].msg_text);
                            break;
                        case CSC_CACHE_AUTO_REINT:
                            iTempLength = SizeOfHalfWidthString(ViewMsgList[ VIEW_CACHED_AUTO ].msg_text);
                            break;
                        case CSC_CACHE_VDO:
                            iTempLength = SizeOfHalfWidthString(ViewMsgList[ VIEW_CACHED_VDO ].msg_text);
                            break;
                        case CSC_CACHE_NONE:
                            iTempLength = SizeOfHalfWidthString(ViewMsgList[ VIEW_CACHED_DISABLED ].msg_text);
                            break;
                    }                
                } 
                else 
                {
                    iTempLength = SizeOfHalfWidthString(share_entry->shi1_remark);                            
                }

                if (iTempLength > iLongestCacheOrRemark)
                {
                    iLongestCacheOrRemark = iTempLength;
                }
            }
        }

        if (!iLongestShareName)
        {
            //
            // No shares to display
            //
            EmptyExit();
        }

        qsort(pEnumBuffer,
                 _read,
                 b501 ? sizeof(SHARE_INFO_501) : sizeof(SHARE_INFO_1),
                 CmpShrInfo1);

        InfoPrintInsTxt(APE_ViewResourcesAt, name);

        if (dwErr = MNetServerGetInfo(name, 1, (LPBYTE*)&pGetInfoBuffer))
        {
            PrintNL();
        }
        else
        {
            server_entry = (LPSERVER_INFO_1) pGetInfoBuffer;
            comment = server_entry->sv1_comment;
            WriteToCon(TEXT("%Fws\r\n\r\n"), comment);
            NetApiBufferFree(pGetInfoBuffer);
        }

        //
        // Print the header
        //
        iLongestShareName = FindColumnWidthAndPrintHeader(iLongestShareName, 
                                                          APE2_VIEW_SVR_HDR_NAME,
                                                          2);
        
        iLongestType = FindColumnWidthAndPrintHeader(iLongestType, 
                                                     APE2_VIEW_SVR_HDR_TYPE,
                                                     2);

        iLongestUsedAs = FindColumnWidthAndPrintHeader(iLongestUsedAs, 
                                                       APE2_VIEW_SVR_HDR_USEDAS,
                                                       2);

        iLongestCacheOrRemark = FindColumnWidthAndPrintHeader(iLongestCacheOrRemark, 
                                                              APE2_VIEW_SVR_HDR_CACHEORREMARK,
                                                              2);
        PrintNL();

        //
        // Bail out on failure
        //

        if (iLongestShareName == -1 || iLongestType == -1 ||
            iLongestUsedAs == -1 || iLongestCacheOrRemark == -1)
        {
            ErrorExit(ERROR_INVALID_PARAMETER);
        }

        PrintNL();
        PrintLine();

        /* Print the listing */

        for (i=0, share_entry = (LPSHARE_INFO_1) pEnumBuffer;
             i < _read;
             i++, NEXT_SHARE_ENTRY(share_entry))
        {
            /* if the name end in $, do not print it */

            DollarPtr = _tcsrchr(share_entry->shi1_netname, DOLLAR);

            if (DollarPtr && *(DollarPtr + 1) == NULLC)
            {
                continue;
            }
     
            PrintDependingOnLength(iLongestShareName, share_entry->shi1_netname);

            // mask out the non type related bits
            switch ( share_entry->shi1_type & ~STYPE_SPECIAL )
            {
                case STYPE_DISKTREE :
                    msgPtr = ViewMsgList[USE_TYPE_DISK].msg_text;
                    break;
                case STYPE_PRINTQ :
                    msgPtr = ViewMsgList[USE_TYPE_PRINT].msg_text;
                    break;
                case STYPE_DEVICE :
                    msgPtr = ViewMsgList[USE_TYPE_COMM].msg_text;
                    break;
                case STYPE_IPC :
                    msgPtr = ViewMsgList[USE_TYPE_IPC].msg_text;
                    break;
                default:
                    msgPtr = ViewMsgList[USE_TYPE_UNKNOWN].msg_text;
                    break;
            }

            PrintDependingOnLength(iLongestType, msgPtr);

            if (dwErr = AllocMem((wcslen(name) + wcslen(share_entry->shi1_netname) + 2) * sizeof(WCHAR),
                                 &tname))
            {
                ErrorExit(dwErr);
            }
            
            _tcscpy(tname, name);
            _tcscat(tname, TEXT("\\"));
            _tcscat(tname, share_entry->shi1_netname);

            if (dwErr = get_used_as ( tname, Buffer, LITTLE_BUF_SIZE - 1 ))
            {
                errorflag = TRUE;
            }
            else
            {
                PrintDependingOnLength(iLongestUsedAs, Buffer);
            }

            FreeMem(tname);
            tname = NULL;

            //
            // Print out the cache settings for the share, if we're supposed to
            //
            if( b501 == TRUE )
            {
                TCHAR *CacheString = NULL;

                switch (((LPSHARE_INFO_501) share_entry)->shi501_flags & CSC_MASK)
                {
                    case CSC_CACHE_MANUAL_REINT:
                        CacheString = ViewMsgList[ VIEW_CACHED_MANUAL ].msg_text;
                        break;
                    case CSC_CACHE_AUTO_REINT:
                        CacheString = ViewMsgList[ VIEW_CACHED_AUTO ].msg_text;
                        break;
                    case CSC_CACHE_VDO:
                        CacheString = ViewMsgList[ VIEW_CACHED_VDO ].msg_text;
                        break;
                    case CSC_CACHE_NONE:
                        CacheString = ViewMsgList[ VIEW_CACHED_DISABLED ].msg_text;
                        break;
                }

                PrintDependingOnLength(iLongestCacheOrRemark, CacheString ? CacheString : TEXT(""));
            }
            else
            {
                PrintDependingOnLength(iLongestCacheOrRemark, share_entry->shi1_remark);
            }
            PrintNL();
        }
        NetApiBufferFree(pEnumBuffer);
    }

    if ( errorflag )
    {
        InfoPrint(APE_CmdComplWErrors);
        NetcmdExit(1);
    }

    if ( more_data )
        InfoPrint( APE_MoreData);
    else
        InfoSuccess();
}


/***
 *  cmpsvinfo1(sva,svb)
 *
 *  Compares two SERVER_INFO_1 structures and returns a relative
 *  lexical value, suitable for using in qsort.
 *
 */

int __cdecl CmpSvrInfo1(const VOID FAR * sva, const VOID FAR * svb)
{
    return _tcsicmp(((LPSERVER_INFO_1) sva)->sv1_name,
                    ((LPSERVER_INFO_1) svb)->sv1_name);
}


/***
 *  CmpShrInfo1(share1,share2)
 *
 *  Compares two SHARE_INFO_1 structures and returns a relative
 *  lexical value, suitable for using in qsort.
 *
 */

int __cdecl CmpShrInfo1(const VOID FAR * share1, const VOID FAR * share2)
{
    return _tcsicmp(((LPSHARE_INFO_1) share1)->shi1_netname,
                    ((LPSHARE_INFO_1) share2)->shi1_netname);
}

/***
 *  CmpShrInfoGen(share1,share2)
 *
 *  Compares two NETRESOURCE structures and returns a relative
 *  lexical value, suitable for using in qsort.
 *
 */

int __cdecl CmpShrInfoGen(const VOID FAR * share1, const VOID FAR * share2)
{
    return _wcsicmp ( (*((LPNETRESOURCE *) share1))->lpRemoteName,
                      (*((LPNETRESOURCE *) share2))->lpRemoteName );
}



/*
 *      Note- get_used_as assumes the message list has been loaded.
 */
DWORD
get_used_as(
    LPTSTR unc,
    LPTSTR outbuf,
    DWORD  cchBuf
    )
{
    DWORD         dwErr;
    DWORD         cTotalAvail;
    LPTSTR        pBuffer;
    LPUSE_INFO_0  pUseInfo;
    DWORD         i;
    DWORD         eread;
    BOOL          fMatch = FALSE;
    LPTSTR        tname = NULL;

    outbuf[0] = 0;

    if (dwErr = NetUseEnum(DEFAULT_SERVER, 0, (LPBYTE*)&pBuffer, MAX_PREFERRED_LENGTH,
                           &eread, &cTotalAvail, NULL))
    {
        return dwErr;
    }

    pUseInfo = (LPUSE_INFO_0) pBuffer;

    for (i = 0; i < eread; i++)
    {
        if ( (!_tcsicmp(unc, pUseInfo[i].ui0_remote)))
        {
            fMatch = TRUE;
        }
        else
        {
            //
            // <unc> didn't match -- try \\<unc> since we allow
            // "net view <server>" as well as "net view \\<server>"
            //

            if (tname == NULL)
            {
                if (dwErr = AllocMem((wcslen(unc) + 3) * sizeof(WCHAR), &tname))
                {
                    return dwErr;
                }

                tname[0] = tname[1] = L'\\';
            }

            wcscpy(tname + 2, unc);

            if ( (!_tcsicmp(tname, pUseInfo[i].ui0_remote)))
            {
                fMatch = TRUE;
            }
        }

        if (fMatch)
        {
            if (_tcslen(pUseInfo[i].ui0_local) > 0)
            {
                wcsncpy(outbuf, pUseInfo[i].ui0_local, cchBuf);
            }
            else
            {
                wcsncpy(outbuf, ViewMsgList[VIEW_UNC].msg_text, cchBuf);
            }

            break;
        }
    }

    NetApiBufferFree(pBuffer);

    if (tname != NULL)
    {
        FreeMem(tname);
    }

    return 0;
}

/*
 * Displays resources for another network (other than Lanman). This
 * function does not return.
 *
 *  Args:
 *      net  - the shortname of the network we are interested in
 *      node - the starting point of the enumeration.
 */
void display_other_net(TCHAR *net, TCHAR *node) 
{
    LPNETRESOURCE *lplpNetResource ;
    NETRESOURCE    NetResource ;
    HANDLE         Handle ;

    BYTE           TopLevelBuffer[4096] ;
    DWORD          TopLevelBufferSize = sizeof(TopLevelBuffer) ;
    LPBYTE         ResultBuffer ;
    DWORD          ResultBufferSize ;
    DWORD          i, dwErr, TopLevelCount, ResultCount = 0 ;
    TCHAR *        ProviderName = get_provider_name(net) ;

    //
    // Check that we can get provider name and alloc the results
    // buffer. Netcmd normally does not free memory it allocates,
    // as it exits immediately.
    //
    if (!ProviderName)
    {
        DWORD  dwErr = list_nets();

        if (dwErr != NERR_Success)
        {
            ErrorPrint(dwErr, 0);
        }

        NetcmdExit(1) ;
    }

    if (dwErr = AllocMem(ResultBufferSize = 8192, &ResultBuffer))
    {
        ErrorExit(dwErr);
    }

    if (!node)
    {
        BOOL found = FALSE ;

        //
        // no node, so must be top level. enum the top and find
        // matching provider.
        //
        dwErr = WNetOpenEnum(RESOURCE_GLOBALNET, 0, 0, NULL, &Handle) ;

        if (dwErr != WN_SUCCESS)
        {
            ErrorExit (dwErr) ;
        }
        do 
        {
            TopLevelCount = 0xFFFFFFFF ;

            dwErr = WNetEnumResource(Handle, 
                                     &TopLevelCount, 
                                     TopLevelBuffer, 
                                     &TopLevelBufferSize) ;
    
            if (dwErr == WN_SUCCESS || dwErr == WN_NO_MORE_ENTRIES)
            {
                LPNETRESOURCE lpNet ;
                DWORD i ;
    
                //
                // go thru looking for the right provider
                //
                lpNet = (LPNETRESOURCE) TopLevelBuffer ;
                for ( i = 0;  i < TopLevelCount;  i++, lpNet++ )
                {
                    DWORD dwEnumErr ; 
                    if (!_tcsicmp(lpNet->lpProvider, ProviderName))
                    {
                        //
                        // found it!
                        //
                        found = TRUE ;

                        //
                        // now go enumerate that network.
                        //
                        dwEnumErr = enum_net_resource(lpNet, 
                                                      &ResultBuffer, 
                                                      &ResultBufferSize, 
                                                      &ResultCount) ;
                        if  (dwEnumErr)
                        {
                            // dont report any errors here
                            WNetCloseEnum(Handle); 
                            ErrorExit(dwEnumErr);
                        }

                        break ;
                    }
                }
            }
            else
            {
                //
                // error occured. 
                //
                WNetCloseEnum(Handle); // dont report any errors here
                ErrorExit(dwErr);
            }
     
        } while ((dwErr == WN_SUCCESS) && !found) ;
    
        WNetCloseEnum(Handle) ;  // dont report any errors here

        if (!found)
        {
            ErrorExit(ERROR_BAD_PROVIDER);
        }
    }
    else
    {
        //
        // node is provided, lets start there.
        //
        NETRESOURCE NetRes ;
        DWORD dwEnumErr ; 

        memset(&NetRes, 0, sizeof(NetRes)) ;

        NetRes.lpProvider = ProviderName ;
        NetRes.lpRemoteName = node ;

        dwEnumErr = enum_net_resource(&NetRes, 
                             &ResultBuffer, 
                             &ResultBufferSize, 
                             &ResultCount) ;
        if (dwEnumErr)
        {
            ErrorExit(dwEnumErr);
        }
    }
    
    if (ResultCount == 0)
    {
        EmptyExit();
    }

    //
    // By the time we get here, we have a buffer of pointers that
    // point to NETRESOURCE structures. We sort the pointers, and then
    // print them out.
    //

    qsort(ResultBuffer, ResultCount, sizeof(LPNETRESOURCE), CmpShrInfoGen);
     
    lplpNetResource = (LPNETRESOURCE *)ResultBuffer ;

    if (node)
    {
        TCHAR *TypeString ;

        InfoPrintInsTxt(APE_ViewResourcesAt, node);
        PrintLine();

        for (i = 0; i < ResultCount; i++, lplpNetResource++)
        {
            switch ((*lplpNetResource)->dwType)
            {
                case RESOURCETYPE_DISK:
                    TypeString = ViewMsgList[USE_TYPE_DISK].msg_text;
                    break ;
                case RESOURCETYPE_PRINT:
                    TypeString = ViewMsgList[USE_TYPE_PRINT].msg_text;
                    break ;
                default:
                    TypeString = L"" ;
                    break ;
            }
            WriteToCon(TEXT("%Fs %s\r\n"), 
                       PaddedString(12,TypeString,NULL),
                       (*lplpNetResource)->lpRemoteName) ;
        }
    }
    else
    {
        InfoPrintInsTxt(APE2_VIEW_OTHER_HDR, ProviderName);
        PrintLine();

        for (i = 0; i < ResultCount; i++, lplpNetResource++)
        {
            WriteToCon(TEXT("%s\r\n"), (*lplpNetResource)->lpRemoteName) ;
        }
    }

    InfoSuccess();
    NetcmdExit(0);
}


/*
 * Enumerates resources for a network starting at a specific point.
 *
 *  Args:
 *      lpNetResourceStart - Where to start the enumeration
 *      ResultBuffer       - Used to return array of pointers to NETRESOURCEs.
 *                           May be reallocated as need.
 *      ResultBufferSize   - Buffer size, also used to return final size.
 *      ResultCount        - Used to return number of entries in buffer.
 */
DWORD
enum_net_resource(
    LPNETRESOURCE lpNetResourceStart,
    LPBYTE        *ResultBuffer, 
    LPDWORD       ResultBufferSize,
    LPDWORD       ResultCount
    )
{
    DWORD          dwErr ;
    HANDLE         EnumHandle ;
    DWORD          Count ;
    DWORD          err ;
    LPBYTE         Buffer ;
    DWORD          BufferSize ;
    BOOL           fDisconnect = FALSE ;
    LPNETRESOURCE *lpNext = (LPNETRESOURCE *)*ResultBuffer ;
 
    //
    // allocate memory and open the enumeration
    //
    if (err = AllocMem(BufferSize = 8192, &Buffer))
    {
        return err;
    }

    dwErr = WNetOpenEnum(RESOURCE_GLOBALNET, 
                         0, 
                         0, 
                         lpNetResourceStart, 
                         &EnumHandle) ;

    if (dwErr == ERROR_NOT_AUTHENTICATED)
    {
        //
        // try connecting with default credentials. we need this because 
        // Win95 changed the behaviour of the API to fail if we are not 
        // already logged on. below will attempt a logon with default 
        // credentials, but will fail if that doesnt work.
        //
        dwErr = WNetAddConnection2(lpNetResourceStart, NULL, NULL, 0) ;

        if (dwErr == NERR_Success)
        {
            dwErr = WNetOpenEnum(RESOURCE_GLOBALNET,  // redo the enum
                                 0, 
                                 0, 
                                 lpNetResourceStart, 
                                 &EnumHandle) ;

            if (dwErr == NERR_Success)
            {
                fDisconnect = TRUE ;   // remember to disconnect
            }
            else
            {
                //
                // disconnect now
                //
                WNetCancelConnection2(lpNetResourceStart->lpRemoteName,
                                      0, 
                                      FALSE) ;
            }
        }
        else
        {
            dwErr = ERROR_NOT_AUTHENTICATED ;  // use original error
        }
    }

    if (dwErr != WN_SUCCESS)
    {
        return dwErr;
    }

    do
    {
        Count = 0xFFFFFFFF ;
        dwErr = WNetEnumResource(EnumHandle, &Count, Buffer, &BufferSize) ;

        if (((dwErr == WN_SUCCESS) || (dwErr == WN_NO_MORE_ENTRIES)) &&
            (Count != 0xFFFFFFFF))  

        // NOTE - the check for FFFFFFFF is workaround for another bug in API.
 
        {
            LPNETRESOURCE lpNetResource ;
            DWORD i ;
            lpNetResource = (LPNETRESOURCE) Buffer ;

            //
            // stick the entries into the MyUseInfoBuffer 
            //
            for ( i = 0; 
                  i < Count; 
                  i++,lpNetResource++ )
            {
                *lpNext++ = lpNetResource ;
                ++(*ResultCount) ;
                if ((LPBYTE)lpNext >= (*ResultBuffer + *ResultBufferSize))
                {
                    DWORD err;

                    *ResultBufferSize *= 2 ; 
                    if (err = ReallocMem(*ResultBufferSize,ResultBuffer))
                    {
                        ErrorExit(err);
                    }

                    lpNext = (LPNETRESOURCE *) *ResultBuffer ;
                    lpNext += *ResultCount ;
                }
            }

            //
            // allocate a new buffer for next set, since we still need
            // data in the old one, we dont free it. Netcmd always lets the
            // system clean up when it exits. 
            //
            if (dwErr == WN_SUCCESS)
            {
                if (err = AllocMem(BufferSize, &Buffer))
                {
                    if (fDisconnect)
                    {
                        WNetCancelConnection2(lpNetResourceStart->lpRemoteName,
                                              0,
                                              FALSE);
                    }

                    ErrorExit(err);
                }
            }
        }
        else
        {
            if (dwErr == WN_NO_MORE_ENTRIES)
                dwErr = WN_SUCCESS ;

            WNetCloseEnum(EnumHandle) ;  // dont report any errors here

            if (fDisconnect)
            {
                WNetCancelConnection2(lpNetResourceStart->lpRemoteName,
                                      0, 
                                      FALSE);

            }
            return dwErr;
        }
    }
    while (dwErr == WN_SUCCESS);

    WNetCloseEnum(EnumHandle) ;  // we dont report any errors here

    if (fDisconnect)
    {
        WNetCancelConnection2(lpNetResourceStart->lpRemoteName,
                              0, 
                              FALSE) ;
    }

    return NERR_Success ;
}


#define SHORT_NAME_KEY    L"System\\CurrentControlSet\\Control\\NetworkProvider\\ShortName"

/*
 * Given a short name for a network, find the real name (stored in registry).
 *
 *  Args:
 *      net - the short name
 *
 *  Returns:
 *      Pointer to static data containing the looked up name if successful,
 *      NULL otherwise.
 */
TCHAR * get_provider_name(TCHAR *net) 
{
    DWORD  err ;
    static TCHAR buffer[256] ;
    HKEY   hKey ;
    DWORD  buffersize, datatype ;

    buffersize = sizeof(buffer) ;
    datatype = REG_SZ ;

    err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                       SHORT_NAME_KEY,
                       0L,
                       KEY_QUERY_VALUE,
                       &hKey) ;

    if (err != ERROR_SUCCESS)
        return NULL ;
 
    err = RegQueryValueEx(hKey,
                          net,
                          0L,
                          &datatype,
                          (LPBYTE) buffer,
                          &buffersize) ;

    (void) RegCloseKey(hKey) ;  // ignore any error here. its harmless
                                // and NET.EXE doesnt hang around anyway.

    if (err != ERROR_SUCCESS)
        return(NULL) ;  // treat as cannot read
                  
    return ( buffer ) ;
}

/*
 * Print out the installed nets
 *
 *  Args:
 *      none
 *
 *  Returns:
 *      NERR_Success if success
 *      error code otherwise.
 */
DWORD
list_nets(
    VOID
    )
{
    DWORD  err ;
    TCHAR  value_name[256] ;
    TCHAR  value_data[512] ;
    HKEY   hKey ;
    BOOL   fProviderFound = FALSE ;
    DWORD  iValue, value_name_size, value_data_size ;

    err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                       SHORT_NAME_KEY,
                       0L,
                       KEY_QUERY_VALUE,
                       &hKey) ;

    if (err != ERROR_SUCCESS)
    {
        if (err == ERROR_FILE_NOT_FOUND)
        {
            err = ERROR_BAD_PROVIDER;
        }

        return err;
    }

    iValue = 0 ;

    do {
        value_name_size = sizeof(value_name)/sizeof(value_name[0]) ;
        value_data_size = sizeof(value_data) ;
        err = RegEnumValue(hKey,
                           iValue,
                           value_name,
                           &value_name_size,
                           NULL,
                           NULL,
                           (LPBYTE) value_data,
                           &value_data_size) ;

        if (err == NO_ERROR)
        {
            if (!fProviderFound)
            {
                PrintNL();
                InfoPrint(APE2_VIEW_OTHER_LIST) ;
                fProviderFound = TRUE;
            }

            WriteToCon(TEXT("\t%s - %s\r\n"),value_name, value_data) ;
        }

        iValue++ ;

    } while (err == NO_ERROR) ;

    RegCloseKey(hKey) ;  // ignore any error here. its harmless
                                // and NET.EXE doesnt hang around anyway.

    if (err == ERROR_NO_MORE_ITEMS)
    {
        if (!fProviderFound)
        {
            return ERROR_BAD_PROVIDER;
        }

        return NO_ERROR;
    }
                  
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netdom\ldap.cxx ===
/*++

Copyright (C) 1998 - 2001  Microsoft Corporation

Module Name:

    ldap.c

Abstract:

    Handles the various functions for LDAP

--*/
#include "pch.h"
#pragma hdrstop
#include <netdom.h>



DWORD
NetDompLdapBind(
    IN LPWSTR DC,
    IN LPWSTR Domain,
    IN LPWSTR User,
    IN LPWSTR Password,
    IN ULONG BindType,
    OUT PLDAP *Ldap
    )
/*++

Routine Description:

    Binds to the named server using the given credentials

Arguments:

    DC -- DC to connect to
    User -- User name to bind with
    Password -- Password to use for bind
    Ldap -- Where the connection handle is returned

Returns:

    ERROR_SUCCESS -- Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    SEC_WINNT_AUTH_IDENTITY_W AuthIdent = {0}, *AuthPtr = NULL;

    if ( User ) {

        AuthIdent.User = User;
        AuthIdent.UserLength = wcslen(User);

        AuthIdent.Domain = Domain;
        AuthIdent.DomainLength = (Domain) ? wcslen(Domain) : 0;

        AuthIdent.Password = Password;
        AuthIdent.PasswordLength = (Password) ? wcslen(Password) : 0;

        AuthIdent.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

        AuthPtr = &AuthIdent;
    }

    if ( Win32Err == ERROR_SUCCESS ) {

        LOG_VERBOSE(( MSG_VERBOSE_LDAP_BIND, DC ));

        //
        // Open a connection
        //
        *Ldap = ldap_open( DC, LDAP_PORT);

        if ( *Ldap ) {

            //
            // Do the bind
            //
            Win32Err = LdapMapErrorToWin32( ldap_bind_s( *Ldap,
                                                         NULL,
                                                         ( PWSTR )AuthPtr,
                                                         BindType ) );

        } else {

            Win32Err = GetLastError();
        }

    }

    return( Win32Err );
}



DWORD
NetDompLdapUnbind(
    IN PLDAP Ldap
    )
/*++

Routine Description:

    Unbinds a current ldap connection

Arguments:

    Ldap -- Connection to be severed

Returns:

    ERROR_SUCCESS -- Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;

    if ( Ldap != NULL ) {

        LOG_VERBOSE(( MSG_VERBOSE_LDAP_UNBIND ));
        Win32Err = LdapMapErrorToWin32( ldap_unbind( Ldap ) );

    }

    return( Win32Err );
}


DWORD
NetDompLdapReadOneAttribute(
    IN PLDAP Ldap,
    IN PWSTR ObjectPath,
    IN PWSTR Attribute,
    OUT PWSTR *ReadAttribute
    )
{
    DWORD Win32Err = ERROR_SUCCESS;
    PWSTR Attrib[2] = {
        Attribute,
        NULL
        };
    PWSTR *Values = NULL;
    LDAPMessage *Message = NULL, *Entry;
    ULONG Items, i;

    Win32Err = LdapMapErrorToWin32( ldap_search_s( Ldap,
                                                   ObjectPath,
                                                   LDAP_SCOPE_BASE,
                                                   L"(ObjectClass=*)",
                                                   Attrib,
                                                   0,
                                                   &Message ) );
    if ( Win32Err == ERROR_SUCCESS ) {

        Entry = ldap_first_entry( Ldap, Message );

        if ( Entry ) {

            //
            // Now, we'll have to get the values
            //
            Values = ldap_get_values( Ldap,
                                      Entry,
                                      Attrib[ 0 ] );

            if ( Values ) {

                Win32Err = NetApiBufferAllocate( ( wcslen( Values[ 0 ] ) + 1 ) * sizeof( WCHAR ),
                                                  ( PVOID *)ReadAttribute );

                if ( Win32Err == ERROR_SUCCESS ) {

                    wcscpy( *ReadAttribute, Values[ 0 ] );

                }

                ldap_value_free( Values );

            } else {

                Win32Err = LdapMapErrorToWin32( Ldap->ld_errno );
            }

        } else {

            Win32Err = LdapMapErrorToWin32( Ldap->ld_errno );
        }
    }

    ldap_msgfree( Message );

    return( Win32Err );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netdom\parserutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:      parserutil.h
//
//  Contents:  Helpful functions for manipulating and validating 
//             generic command line arguments
//
//  History:   07-Sep-2000 JeffJon  Created
//             
//
//--------------------------------------------------------------------------

#ifndef _PARSEUTIL_H_
#define _PARSEUTIL_H_

DWORD GetPasswdStr(LPTSTR  buf,
                   DWORD   buflen,
                   PDWORD  len);
DWORD ValidateAdminPassword(PVOID pArg);
DWORD ValidateUserPassword(PVOID pArg);
DWORD ValidateYesNo(PVOID pArg);
DWORD ValidateGroupScope(PVOID pArg);
DWORD ValidateNever(PVOID pArg);

//+----------------------------------------------------------------------------
//
//  Function:   ParseNullSeparatedString
//
//  Synopsis:   Parses a '\0' separated list that ends in "\0\0" into a string
//              array
//
//  Arguments:  [psz - IN]     : '\0' separated string to be parsed
//              [pszArr - OUT] : the array to receive the parsed strings
//              [pnArrEntries - OUT] : the number of strings parsed from the list
//
//  Returns:    
//
//  History:    18-Sep-2000   JeffJon   Created
//
//-----------------------------------------------------------------------------
void ParseNullSeparatedString(PTSTR psz,
								      PTSTR** ppszArr,
								      UINT* pnArrEntries);

#endif // _PARSEUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netdom\pch.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 2001
//
//  File:       pch.h
//
//--------------------------------------------------------------------------

#ifndef _pch_h
#define _pch_h

#ifdef __cplusplus
extern "C"
{
#endif
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#ifdef __cplusplus
}
#endif
#include <windows.h>
#include <winbase.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <assert.h>
#include <lm.h>
#include <lmjoin.h>
#include <rpc.h>
#include <stdlib.h>
#include <dsgetdc.h>
#include <ntdsapi.h>
extern "C"
{
#include <netsetp.h>
#include <w32timep.h>
#include <joinp.h>
#include <cryptdll.h>
}
#include <winldap.h>
#include <windns.h>
#include <icanon.h>
#include <dsrole.h>
#include <wincrypt.h>
#include <winreg.h>
#include <string.h>
#define SECURITY_WIN32
#include <security.h>   // General definition of a Security Support Provider
#include <lmsname.h>
#include <locale.h>
#include "strings.h"
//#include "parserutil.h"
#include "varg.h"
#include "cmdtable.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netdom\netdom.h ===
/*++

Microsoft Windows

Copyright (C) Microsoft Corporation, 1998 - 2001

Module Name:

    netdom.h

Abstract:

    Common includes and definitions to be used in netdom5

--*/
#ifndef __NETDOM_H__
#define __NETDOM_H__

#include <netdom5.h>

extern HINSTANCE g_hInstance;

#define FLAG_ON(flag,bits)        ((flag) & (bits))

#define LOG_VERBOSE( __x__ )  { if ( Verbose ) { NetDompDisplayMessage __x__ ; } }
#define ERROR_VERBOSE( __error__) { if ( Verbose && __error__ != ERROR_SUCCESS ) { \
                                                NetDompDisplayErrorMessage( __error__); } }
#if DBG == 1
#define DBG_VERBOSE( __x__ )  { if ( Verbose ) { printf __x__ ;} }
#define CHECK_WIN32(err, cmd) \
    if (ERROR_SUCCESS != err) \
    {                         \
        if (Verbose)          \
        {                     \
            printf("Error %d at line %d in file %s\n", err, __LINE__, __FILE__); \
        }                     \
        cmd;                  \
    }
#else
#define DBG_VERBOSE( __x__ )
#define CHECK_WIN32(err, cmd) \
    if (ERROR_SUCCESS != err) \
    {                         \
        cmd;                  \
    }
#endif

#define NETDOM_STR_LEN  64

extern BOOL Verbose;

typedef struct _ND5_AUTH_INFO {
    PWSTR User;
    PWSTR Password;
    PWSTR pwzUserWoDomain;
    PWSTR pwzUsersDomain;

} ND5_AUTH_INFO, *PND5_AUTH_INFO;

#define NETDOM_TRUST_FLAG_DOMAIN_NOT_FOUND  1
#define NETDOM_TRUST_FLAG_PARENT            2
#define NETDOM_TRUST_FLAG_CHILD             4
#define NETDOM_TRUST_PDC_REQUIRED           8
#define NETDOM_TRUST_TYPE_MIT               10
#define NETDOM_TRUST_TYPE_INDIRECT          20

typedef struct _ND5_TRUST_INFO {

    PWSTR Server;
    PUNICODE_STRING DomainName;
    PUNICODE_STRING FlatName;
    PSID Sid;
    LSA_HANDLE LsaHandle;   // LSA Policy handle
    LSA_HANDLE TrustHandle; // TDO handle
    ULONG Flags;
    BOOL Uplevel;
    BOOL Connected;
    PVOID BlobToFree;
    BOOL fWasDownlevel;

} ND5_TRUST_INFO, *PND5_TRUST_INFO;

bool
CmdFlagOn(ARG_RECORD * rgNetDomArgs, NETDOM_ARG_ENUM eArgIndex);

DWORD
NetDompGetTrustDirection(
    IN PND5_TRUST_INFO TrustingInfo,
    IN PND5_TRUST_INFO TrustedInfo,
    IN OUT PDWORD Direction
    );

//
// From ndutil.cxx
//
DWORD
NetDompValidateSecondaryArguments(ARG_RECORD * rgNetDomArgs,
                                  NETDOM_ARG_ENUM eFirstValidParam, ...);

DWORD
NetDompGetUserAndPasswordForOperation(ARG_RECORD * rgNetDomArgs,
                                      NETDOM_ARG_ENUM eUserType,
                                      PWSTR DefaultDomain,
                                      PND5_AUTH_INFO AuthIdent);

VOID
NetDompFreeAuthIdent(
    IN PND5_AUTH_INFO AuthIdent
    );

DWORD
NetDompGetDomainForOperation(ARG_RECORD * rgNetDomArgs,
                             PWSTR Server OPTIONAL,
                             BOOL CanDefaultToCurrent,
                             PWSTR *DomainName);

DWORD
NetDompGetArgumentString(ARG_RECORD * rgNetDomArgs,
                         NETDOM_ARG_ENUM eArgToGet,
                         PWSTR *ArgString);

BOOL
NetDompGetArgumentBoolean(ARG_RECORD * rgNetDomArgs,
                          NETDOM_ARG_ENUM eArgToGet);

DWORD
NetDompControlService(
    IN PWSTR Server,
    IN PWSTR Service,
    IN DWORD ServiceOptions
    );

DWORD
NetDompRestartAsRequired(ARG_RECORD * rgNetDomArgs,
                         PWSTR Machine,
                         PWSTR User,
                         DWORD PreliminaryStatus,
                         DWORD MsgID);

DWORD
NetDompCheckDomainMembership(
    IN PWSTR Server,
    IN PND5_AUTH_INFO AuthInfo,
    IN BOOL EstablishSessionIfRequried,
    IN OUT BOOL * DomainMember
    );

DWORD
NetDompGenerateRandomPassword(
    IN PWSTR Buffer,
    IN ULONG Length
    );

BOOL
NetDompGetUserConfirmation(
    IN DWORD PromptResId,
    IN PWSTR pwzName
    );

//
// From netdom5.cxx
//
VOID
DisplayHelp(NETDOM_ARG_ENUM HelpOp);

VOID
NetDompDisplayMessage(
    IN DWORD MessageId,
    ...
    );

VOID
NetDompDisplayMessageAndError(
    IN DWORD MessageId,
    IN DWORD Error,
    IN PWSTR String OPTIONAL
    );

VOID
NetDompDisplayUnexpectedParameter(
    IN PWSTR UnexpectedParameter
    );

VOID
NetDompDisplayErrorMessage(
    IN DWORD Error
    );


//
// From join.cxx
//
DWORD
NetDompHandleAdd(ARG_RECORD * rgNetDomArgs);

DWORD
NetDompHandleRemove(ARG_RECORD * rgNetDomArgs);

DWORD
NetDompHandleJoin(ARG_RECORD * rgNetDomArgs, BOOL AllowMove);

DWORD
NetDompHandleMove(ARG_RECORD * rgNetDomArgs);

DWORD
NetDompHandleReset(ARG_RECORD * rgNetDomArgs);

DWORD
NetDompHandleResetPwd(ARG_RECORD * rgNetDomArgs);

DWORD
NetDompHandleVerify(ARG_RECORD * rgNetDomArgs);

DWORD
NetDompVerifyServerSC(
    IN PWSTR Domain,
    IN PWSTR Server,
    IN PND5_AUTH_INFO AuthInfo,
    IN ULONG OkMessageId,
    IN ULONG FailedMessageId
    );

DWORD
NetDompResetServerSC(
    IN PWSTR Domain,
    IN PWSTR Server,
    IN PWSTR DomainController, OPTIONAL
    IN PND5_AUTH_INFO AuthInfo,
    IN ULONG OkMessageId,
    IN ULONG FailedMessageId
    );


//
// From trust.cxx
//
DWORD
NetDompHandleTrust(ARG_RECORD * rgNetDomArgs);

DWORD
NetDompTrustGetDomInfo(
    IN PWSTR Domain,
    IN PWSTR DomainController  OPTIONAL,
    IN PND5_AUTH_INFO AuthInfo,
    IN OUT PND5_TRUST_INFO TrustInfo,
    IN BOOL ManageTrust,
    IN BOOL Force,
    IN BOOL fUseNullSession
    );

VOID
NetDompFreeDomInfo(
    IN OUT PND5_TRUST_INFO TrustInfo
    );

DWORD
NetDompVerifyTrust(
    IN PND5_TRUST_INFO TrustingInfo,
    IN PND5_TRUST_INFO TrustedInfo,
    BOOL fShowResults
    );

DWORD
NetDompResetTrustPasswords(
    IN PWSTR TrustingDomain,
    IN PWSTR TrustedDomain,
    IN PND5_AUTH_INFO TrustingCreds,
    IN PND5_AUTH_INFO TrustedCreds
    );

DWORD
NetDompSetMitTrustPW(
    IN PWSTR TrustingDomain,
    IN PWSTR TrustedDomain,
    IN PND5_AUTH_INFO TrustingCreds,
    IN PND5_AUTH_INFO TrustedCreds,
    IN PWSTR pwzNewTrustPW
    );


DWORD
NetDompIsParentChild(
    IN PND5_TRUST_INFO pFirstDomainInfo,
    IN PND5_TRUST_INFO pSecondDomainName,
    OUT BOOL * pfParentChild
    );

//
// From query.cxx
//
DWORD
NetDompHandleQuery(ARG_RECORD * rgNetDomArgs);

//
// From time.cxx
//
DWORD
NetDompHandleTime(ARG_RECORD * rgNetDomArgs);

//
// From rename.cxx
//
DWORD
NetDompHandleRename(ARG_RECORD * rgNetDomArgs);

DWORD
NetDompHandleRenameComputer(ARG_RECORD * rgNetDomArgs);

//
// From ldap.cxx
//
DWORD
NetDompLdapBind(
    IN LPWSTR DC,
    IN LPWSTR Domain,
    IN LPWSTR User,
    IN LPWSTR Password,
    IN ULONG BindType,
    OUT PLDAP *Ldap
    );


DWORD
NetDompLdapUnbind(
    IN PLDAP Ldap
    );

DWORD
NetDompLdapReadOneAttribute(
    IN PLDAP Ldap,
    IN PWSTR ObjectPath,
    IN PWSTR Attribute,
    OUT PWSTR *ReadAttribute
    );

BOOL
IsLocalMachine( LPWSTR Machine );

DWORD
NetDompJoinDownlevel(
    IN PWSTR Server,
    IN PWSTR Account,
    IN PWSTR Password,
    IN PWSTR Dc,
    IN ULONG DcFlags,
    IN BOOL AllowMove
    );

DWORD
NetDompManageGroupMembership(
    IN PWSTR Server,
    IN PSID DomainSid,
    IN BOOL Delete
    );

DWORD
NetDompManageMachineSecret(
    IN  LSA_HANDLE  PolicyHandle,
    IN  LPWSTR      lpPassword,
    IN  INT         fControl
    );

#endif //ifndef __NETDOM_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netdom\netdom5.cxx ===
/*++

Microsoft Windows

Copyright (C) Microsoft Corporation, 1998 - 2001

Module Name:

    netdom5.cxx

Abstract:

    Command line utility for taking care of all the desired net operations

--*/
#include "pch.h"
#pragma hdrstop
#include "netdom.h"
#include "CompName.h"

HINSTANCE g_hInstance = NULL;

BOOL Verbose = FALSE;

//+----------------------------------------------------------------------------
//
//  Function:  GetPrimaryArg
//
//  Synopsis:  The second argument of the command line should be the primary
//             command (the first is the program name).
//
//  Arguments: [rgNetDomArgs] - The command line argument array.
//             [pTokens] - the token array.
//             [PriCmd] - the out parameter reference.
//
//  Returns:   Success or error.
//
//-----------------------------------------------------------------------------
DWORD
GetPrimaryArg(ARG_RECORD * rgNetDomArgs, CToken * pTokens, 
              NETDOM_ARG_ENUM & PriCmd)
{
   PWSTR str = (pTokens + 1)->GetToken();

   if (!str) return ERROR_INVALID_PARAMETER;

   if ((pTokens + 1)->IsSwitch())
   {
      str++;
   }

   for (int i = eArgBegin; i < ePriEnd; i += 1)
   {
      if (rgNetDomArgs[i].strArg1 && !_wcsicmp(str, rgNetDomArgs[i].strArg1) ||
          rgNetDomArgs[i].strArg2 && !_wcsicmp(str, rgNetDomArgs[i].strArg2))
      {
         PriCmd = (NETDOM_ARG_ENUM)i;
         return ERROR_SUCCESS;
      }
   }

   return ERROR_INVALID_PARAMETER;
}

//+----------------------------------------------------------------------------
//
//  Function:  GetHelpTarget
//
//  Synopsis:  If the second argument of the command line is help, the next
//             arg can be either SYNTAX or a primary command.
//
//  Arguments: [rgNetDomArgs] - The command line argument array.
//             [pTokens] - the token array.
//             [argc] - the count of arguments.
//
//-----------------------------------------------------------------------------
void
GetHelpTarget(ARG_RECORD * rgNetDomArgs, CToken * pTokens, int argc)
{
   if (argc < 3)
   {
      DisplayHelp(ePriHelp);
      return;
   }

   PWSTR str = (pTokens + 2)->GetToken();

   if (!str)
   {
      DisplayHelp(ePriHelp);
      return;
   }

   if ((pTokens + 2)->IsSwitch())
   {
      str++;
   }

   if (rgNetDomArgs[eHelpSyntax].strArg1 &&
       !_wcsicmp(str, rgNetDomArgs[eHelpSyntax].strArg1))
   {
      DisplayHelp(eHelpSyntax);
   }

   for (int i = eArgBegin; i < ePriEnd; i += 1)
   {
      if (rgNetDomPriArgs[i].strArg1 && !_wcsicmp(str, rgNetDomPriArgs[i].strArg1))
      {
         DisplayHelp((NETDOM_ARG_ENUM)i);
         return;
      }
   }

   DisplayHelp(ePriHelp);
}


VOID
NetDompDisplayMessage(
    IN DWORD MessageId,
    ...
    )
/*++

Routine Description:

    Loads the resource out of the executable and displays it.

Arguments:

    MessageId - Id of the message to load
    ... - Optional list of parameters

Return Value:

    VOID

--*/
{
    PWSTR MessageDisplayString;
    va_list ArgList;
    ULONG Length;

    va_start( ArgList, MessageId );

    Length = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                            NULL,
                            MessageId,
                            0,
                            ( PWSTR )&MessageDisplayString,
                            0,
                            &ArgList );

    if ( Length != 0 ) {

        printf( "%ws", MessageDisplayString );
        LocalFree( MessageDisplayString );

#if DBG
    } else {

        printf( "Failed to format buffer for %lu: %lu\n", MessageId, GetLastError() );
#endif
    }

    va_end( ArgList );
}


VOID
NetDompDisplayMessageAndError(
    IN DWORD MessageId,
    IN DWORD Error,
    IN PWSTR String OPTIONAL
    )
/*++

Routine Description:

    Loads the resource out of the executable and displays it.

Arguments:

    MessageId - Id of the message to load
    Error - Error message to display

Return Value:

    VOID

--*/
{
#if DBG
    DWORD Win32Err = ERROR_SUCCESS;
#endif
    PWSTR ErrorString, Lop;
    ULONG Length;



    Length = FormatMessageW( FORMAT_MESSAGE_FROM_SYSTEM |
                                FORMAT_MESSAGE_ALLOCATE_BUFFER,
                             NULL,
                             Error,
                             0,
                             ( PWSTR )&ErrorString,
                             0,
                             NULL );
    if ( Length == 0 ) {

#if DBG
        Win32Err = GetLastError();
#endif

    } else {

        Lop = wcsrchr( ErrorString, L'\n' );
        if ( Lop ) {

            *Lop = UNICODE_NULL;

            if ( Lop != ErrorString ) {

                *(Lop - 1 ) = UNICODE_NULL;
            }
        }
        NetDompDisplayMessage( MessageId, String, ErrorString );
        LocalFree( ErrorString );
    }
}



VOID
NetDompDisplayErrorMessage(
    IN DWORD Error
    )
/*++

Routine Description:

    This function display the error string for the given error status

Arguments:

    Error - Status to display the message for

Return Value:

    VOID

--*/
{
    HMODULE NetMsgHandle = NULL;
    ULONG Size = 0;
    PWSTR DisplayString = NULL;
    ULONG Options = FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM;

    //
    // Load and display the net errors, if that is what we were given
    //
    if ( Error >=  2100 && Error <= 3000 ) {

        //
        // If it fails to load, it's not the end of the world.  We just won't be able
        // to map the message
        //
        NetMsgHandle = LoadLibraryEx( L"netmsg.dll", NULL, LOAD_LIBRARY_AS_DATAFILE );
        if ( NetMsgHandle ) {

            Options |= FORMAT_MESSAGE_FROM_HMODULE;
        }
    }

    Size = FormatMessage( Options,
                          ( LPCVOID )NetMsgHandle,
                          Error,
                          MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT ),
                          ( LPTSTR )&DisplayString,
                          0,
                          NULL );

    if ( Size != 0 ) {

        printf( "%ws\n", DisplayString );
        LocalFree( DisplayString );

#if DBG
    } else {

        printf( "Failed to map %lu: %lu\n", Error, GetLastError() );
#endif
    }

    if ( NetMsgHandle ) {

        FreeLibrary( NetMsgHandle );
    }
}


VOID
NetDompDisplayUnexpectedParameter(
    IN PWSTR UnexpectedParameter
    )
{
   NetDompDisplayMessage(MSG_NETDOM5_UNEXPECTED, UnexpectedParameter);
}


VOID
DisplayHelp(NETDOM_ARG_ENUM HelpOp)
/*++

Routine Description:

    This function displays the help associated with a given operation

--*/
{
    NetDompDisplayMessage( MSG_NETDOM5_SYNTAX );

    switch (HelpOp)
    {
    case ePriHelp:
        NetDompDisplayMessage( MSG_NETDOM5_COMMAND_USAGE );
        break;

    case eHelpSyntax:
        NetDompDisplayMessage( MSG_NETDOM5_HELP_SYNTAX );
        break;

    case ePriAdd:
        NetDompDisplayMessage( MSG_NETDOM5_HELP_ADD );
        NetDompDisplayMessage( MSG_NETDOM5_HELP_MORE );
        break;

    case ePriCompName:
        NetDompDisplayMessage( MSG_NETDOM5_HELP_COMPUERNAME );
        NetDompDisplayMessage( MSG_NETDOM5_HELP_MORE );
        break;

    case ePriJoin:
        NetDompDisplayMessage( MSG_NETDOM5_HELP_JOIN );
        NetDompDisplayMessage( MSG_NETDOM5_HELP_MORE );
        break;

    case ePriMove:
        NetDompDisplayMessage( MSG_NETDOM5_HELP_MOVE );
        NetDompDisplayMessage( MSG_NETDOM5_HELP_MORE );
        break;

    case ePriQuery:
        NetDompDisplayMessage( MSG_NETDOM5_HELP_QUERY );
        NetDompDisplayMessage( MSG_NETDOM5_HELP_MORE );
        break;

    case ePriRemove:
        NetDompDisplayMessage( MSG_NETDOM5_HELP_REMOVE );
        NetDompDisplayMessage( MSG_NETDOM5_HELP_MORE );
        break;

    case ePriRename:
        NetDompDisplayMessage( MSG_NETDOM5_HELP_RENAME );
        NetDompDisplayMessage( MSG_NETDOM5_HELP_MORE );
        break;

    case ePriRenameComputer:
        NetDompDisplayMessage( MSG_NETDOM5_HELP_RENAMECOMPUTER );
        NetDompDisplayMessage( MSG_NETDOM5_HELP_MORE );
        break;

    case ePriReset:
        NetDompDisplayMessage( MSG_NETDOM5_HELP_RESET );
        NetDompDisplayMessage( MSG_NETDOM5_HELP_MORE );
        break;

    case ePriResetPwd:
        NetDompDisplayMessage( MSG_NETDOM5_HELP_RESETPWD );
        NetDompDisplayMessage( MSG_NETDOM5_HELP_MORE );
        break;

    case ePriTrust:
        NetDompDisplayMessage( MSG_NETDOM5_HELP_TRUST );
        NetDompDisplayMessage( MSG_NETDOM5_HELP_MORE );
        break;

    case ePriVerify:
        NetDompDisplayMessage( MSG_NETDOM5_HELP_VERIFY );
        NetDompDisplayMessage( MSG_NETDOM5_HELP_MORE );
        break;

//    case ePriTime:
//        NetDompDisplayMessage( MSG_NETDOM5_HELP_TIME );
//        NetDompDisplayMessage( MSG_NETDOM5_HELP_MORE );
//        break;

    default:
        NetDompDisplayMessage( MSG_NETDOM5_COMMAND_USAGE );
        break;
    }

}

int __cdecl _tmain(VOID)
{
   DWORD Win32Err = ERROR_SUCCESS;

   g_hInstance = GetModuleHandle(NULL);

   setlocale(LC_CTYPE, "");

   //
   // Parse the command line
   //
   int argc = 0;
   CToken * pTokens = NULL;
   PARSE_ERROR Error = {0};

   Win32Err = GetCommandInput(&argc, &pTokens);

   if (ERROR_SUCCESS != Win32Err)
   {
      NetDompDisplayErrorMessage(Win32Err);
      goto Netdom5Exit;
   }

   //
   // Display the help.
   //
   if (argc < 2)
   {
      NetDompDisplayMessage(MSG_NETDOM5_SYNTAX);
      NetDompDisplayMessage(MSG_NETDOM5_USAGE);
      goto Netdom5Exit;
   }

   NETDOM_ARG_ENUM ePrimaryCmd = ePriHelp;
      
   if (!LoadCmd(rgNetDomArgs) || !LoadCmd(rgNetDomPriArgs))
   {
      Win32Err = ERROR_NOT_ENOUGH_MEMORY;
      goto Netdom5Exit;
   }

   Win32Err = GetPrimaryArg(rgNetDomPriArgs, pTokens, ePrimaryCmd);

   if (ERROR_SUCCESS != Win32Err)
   {
      PWSTR wzTok = (pTokens + 1)->GetToken();
      if (wzTok)
      {
         NetDompDisplayUnexpectedParameter(wzTok);
      }
      goto Netdom5Exit;
   }

   //
   // Handle the help case
   //
   if (ePriHelp == ePrimaryCmd || ePriHelp2 == ePrimaryCmd)
   {
      GetHelpTarget(rgNetDomArgs, pTokens, argc);
      goto Netdom5Exit;
   }

   if (argc < 3)
   {
      // All commands require at least one argument after the primary command.
      //
      DisplayHelp(ePrimaryCmd);
      goto Netdom5Exit;
   }

   bool fSkipObject = false;
   //
   // The QUERY and RESETPWD commands don't take an "object" parameter.
   //
   if (ePriQuery == ePrimaryCmd || ePriResetPwd == ePrimaryCmd)
   {
      fSkipObject = true;
   }

   if (!ParseCmd(rgNetDomArgs,
                 argc - 2,   // skip the program name and primary arg.
                 pTokens + 2,
                 fSkipObject,
                 &Error))
   {
      if (Error.Error == PARSE_ERROR_HELP_SWITCH)
      {
         DisplayHelp(ePrimaryCmd);
      }
      else
      {
         //
         // Display the usage text
         //
         NetDompDisplayMessage(MSG_NETDOM5_SYNTAX);
         NetDompDisplayMessage(MSG_NETDOM5_USAGE);
         Win32Err = ERROR_INVALID_PARAMETER;
      }
      goto Netdom5Exit;
   }

   if (CmdFlagOn(rgNetDomArgs, eCommHelp) || CmdFlagOn(rgNetDomArgs, eCommQHelp))
   {
      DisplayHelp(ePrimaryCmd);
      goto Netdom5Exit;
   }

   //
   // Make sure the object name followed the primary command. The query and
   // ResetPwd primary operations don't use the object param.
   //
   if (!fSkipObject && !rgNetDomArgs[eObject].strValue)
   {
      if (argc > 2)
      {
         PWSTR wzTok = (pTokens + 2)->GetToken();
         if (wzTok)
         {
            NetDompDisplayUnexpectedParameter(wzTok);
         }
      }
      NetDompDisplayMessage(MSG_NETDOM5_SYNTAX);
      NetDompDisplayMessage(MSG_NETDOM5_USAGE);
      Win32Err = ERROR_INVALID_PARAMETER;
      goto Netdom5Exit;
   }

   Verbose = CmdFlagOn(rgNetDomArgs, eCommVerbose);

   switch (ePrimaryCmd)
   {
   case ePriAdd:
      Win32Err = NetDompHandleAdd(rgNetDomArgs);
       break;

   case ePriCompName:
       Win32Err = NetDomComputerNames(rgNetDomArgs);
       break;

   case ePriJoin:
       Win32Err = NetDompHandleJoin(rgNetDomArgs, FALSE);
       break;

   case ePriMove:
       Win32Err = NetDompHandleMove(rgNetDomArgs);
       break;

   case ePriQuery:
       Win32Err = NetDompHandleQuery(rgNetDomArgs);
       break;

   case ePriRemove:
       Win32Err = NetDompHandleRemove(rgNetDomArgs);
       break;

//   case ePriTime:
//       Win32Err = NetDompHandleTime(rgNetDomArgs);
//       break;

   case ePriRename:
       Win32Err = NetDompHandleRename(rgNetDomArgs);
       break;

   case ePriRenameComputer:
       Win32Err = NetDompHandleRenameComputer(rgNetDomArgs);
       break;

   case ePriReset:
       Win32Err = NetDompHandleReset(rgNetDomArgs);
       break;

   case ePriResetPwd:
       Win32Err = NetDompHandleResetPwd(rgNetDomArgs);
       break;

   case ePriTrust:
       Win32Err = NetDompHandleTrust(rgNetDomArgs);
       break;

   case ePriVerify:
       Win32Err = NetDompHandleVerify(rgNetDomArgs);
       break;

   default:
       Win32Err = ERROR_INVALID_PARAMETER;
       break;
   }

Netdom5Exit:

   if (pTokens)
   {
      delete [] pTokens;
   }

   FreeCmd(rgNetDomArgs);
   FreeCmd(rgNetDomPriArgs);

   if (Win32Err == ERROR_SUCCESS)
   {
      NetDompDisplayMessage( MSG_NETDOM5_SUCCESS );
   }
   else
   {
      if (ERROR_INVALID_PARAMETER == Win32Err)
      {
         NetDompDisplayMessage(MSG_NETDOM5_HELPHINT);
      }
      else
      {
         NetDompDisplayMessage(MSG_NETDOM5_FAILURE);
      }
   }

   return(Win32Err);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netdom\parserutil.cxx ===
//+----------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001
//
//  File:      parserutil.cpp
//
//  Contents:  Helpful functions for manipulating and validating 
//             generic command line arguments
//
//  History:   07-Sep-2000 JeffJon  Created
//             
//
//-----------------------------------------------------------------------------


#include "pch.h"
#include "iostream.h"

//+----------------------------------------------------------------------------
//
//  Function:   GetPasswdStr
//
//  Synopsis:   Reads a password string from stdin without echoing the keystrokes
//
//  Arguments:  [buf - OUT]    : buffer to put string in
//              [buflen - IN]  : size of the buffer
//              [&len - OUT]   : length of the string placed into the buffer
//
//  Returns:    DWORD : 0 or ERROR_INSUFFICIENT_BUFFER if user typed too much.
//                      Buffer contents are only valid on 0 return.
//
//  History:    07-Sep-2000   JeffJon   Created
//
//-----------------------------------------------------------------------------
#define CR              0xD
#define BACKSPACE       0x8

DWORD GetPasswdStr(LPTSTR  buf,
                   DWORD   buflen,
                   PDWORD  len)
{
    TCHAR	ch;
    TCHAR	*bufPtr = buf;
    DWORD	c;
    int		err;
    DWORD   mode;

    buflen -= 1;    /* make space for null terminator */
    *len = 0;               /* GP fault probe (a la API's) */
    GetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), &mode);
    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE),
                   (~(ENABLE_ECHO_INPUT|ENABLE_LINE_INPUT)) & mode);

    while (TRUE) 
    {
	    err = ReadConsole(GetStdHandle(STD_INPUT_HANDLE), &ch, 1, &c, 0);
	    if (!err || c != 1)
	        ch = 0xffff;

        if ((ch == CR) || (ch == 0xffff))       /* end of the line */
            break;

        if (ch == BACKSPACE) 
        {  /* back up one or two */
           /*
           * IF bufPtr == buf then the next two lines are
           * a no op.
           */
           if (bufPtr != buf) 
           {
                    bufPtr--;
                    (*len)--;
           }
        }
        else 
        {
                *bufPtr = ch;

                if (*len < buflen) 
                    bufPtr++ ;                   /* don't overflow buf */
                (*len)++;                        /* always increment len */
        }
    }

    SetConsoleMode(GetStdHandle(STD_INPUT_HANDLE), mode);
    *bufPtr = TEXT('\0');         /* null terminate the string */
    putwchar(TEXT('\n'));

    return ((*len <= buflen) ? 0 : ERROR_INSUFFICIENT_BUFFER);
}


//+--------------------------------------------------------------------------
//
//  Function:   ValidatePassword
//
//  Synopsis:   Password validation function called by parser
//
//  Arguments:  [pArg - IN]    : pointer argument structure which contains
//                               the value to be validated
//
//  Returns:    DWORD : ERROR_INVALID_PARAMETER if the argument record or
//                          the value it contains is not valid
//                      ERROR_NOT_ENOUGH_MEMORY
//                      ERROR_SUCCESS if everything succeeded and it is a
//                          valid password
//                      Otherwise it is an error condition returned from
//                          GetPasswdStr
//
//  History:    07-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
DWORD ValidatePassword(PVOID pArg, UINT IdStr)
{
    PARG_RECORD pRec = (PARG_RECORD)pArg;
    if(!pRec || !pRec->strValue)
        return ERROR_INVALID_PARAMETER;
    
    if(wcscmp(pRec->strValue, L"*") != 0 )
        return ERROR_SUCCESS;

    CComBSTR sbstrPrompt;
    if(sbstrPrompt.LoadString(::GetModuleHandle(NULL),IdStr))
    {
        DisplayOutput(sbstrPrompt);
    }
    else
        DisplayOutput(L"Enter Password\n");    
        
    WCHAR buffer[MAX_PASSWORD_LENGTH];
    DWORD len = 0;
    DWORD dwErr = GetPasswdStr(buffer,MAX_PASSWORD_LENGTH,&len);
    if(dwErr != ERROR_SUCCESS)
        return dwErr;
            
    LocalFree(pRec->strValue);
    pRec->strValue = (LPWSTR)LocalAlloc(LPTR,sizeof(WCHAR)*(len+1));
    if(!pRec->strValue)
        return ERROR_NOT_ENOUGH_MEMORY;
    else
    {
        wcscpy(pRec->strValue,buffer);
        return ERROR_SUCCESS;                                                                
    }                
}

//+--------------------------------------------------------------------------
//
//  Function:   ValidateAdminPassword
//
//  Synopsis:   Password validation function called by parser for Admin
//
//  Arguments:  [pArg - IN]    : pointer argument structure which contains
//                               the value to be validated
//
//  Returns:    DWORD : ERROR_INVALID_PARAMETER if the argument record or
//                          the value it contains is not valid
//                      ERROR_SUCCESS if everything succeeded and it is a
//                          valid password
//
//  History:    07-Sep-2000   Hiteshr Created
//
//---------------------------------------------------------------------------
DWORD ValidateAdminPassword(PVOID pArg)
{
    return ValidatePassword(pArg,IDS_ADMIN_PASSWORD_PROMPT);
}

//+--------------------------------------------------------------------------
//
//  Function:   ValidateUserPassword
//
//  Synopsis:   Password validation function called by parser for Admin
//
//  Arguments:  [pArg - IN]    : pointer argument structure which contains
//                               the value to be validated
//
//  Returns:    DWORD : Same as ValidatePassword
//
//  History:    07-Sep-2000   Hiteshr Created
//
//---------------------------------------------------------------------------
DWORD ValidateUserPassword(PVOID pArg)
{
    return ValidatePassword(pArg, IDS_USER_PASSWORD_PROMPT);
}

//+--------------------------------------------------------------------------
//
//  Function:   ValidateYesNo
//
//  Synopsis:   Password validation function called by parser for Admin
//
//  Arguments:  [pArg - IN]    : pointer argument structure which contains
//                               the value to be validated
//
//  Returns:    DWORD : Same as ValidatePassword
//
//  History:    07-Sep-2000   Hiteshr Created
//
//---------------------------------------------------------------------------

DWORD ValidateYesNo(PVOID pArg)
{
    PARG_RECORD pRec = (PARG_RECORD)pArg;
    if(!pRec || !pRec->strValue)
        return ERROR_INVALID_PARAMETER;

    CComBSTR sbstrYes;
    CComBSTR sbstrNo;
    CComBSTR sbstrInput;

    if(!sbstrYes.LoadString(::GetModuleHandle(NULL),IDS_YES))
    {
        return ERROR_RESOURCE_DATA_NOT_FOUND;
    }
    if(!sbstrNo.LoadString(::GetModuleHandle(NULL), IDS_NO))
    {
        return ERROR_RESOURCE_DATA_NOT_FOUND;
    }
    sbstrYes.ToLower();
    sbstrNo.ToLower();
    sbstrInput = pRec->strValue;
    sbstrInput.ToLower();
    if( sbstrInput == sbstrYes )
    {
        LocalFree(pRec->strValue);
        pRec->bValue = TRUE;
    }
    else if( sbstrInput == sbstrNo )
    {
        LocalFree(pRec->strValue);
        pRec->bValue = FALSE;
    }
    else
        return ERROR_INVALID_PARAMETER;

    //
    // Have to set this to bool or else
    // FreeCmd will try to free the string
    // which AVs when the bool is true
    //
    pRec->fType = ARG_TYPE_BOOL;
    return ERROR_SUCCESS;
}

//+--------------------------------------------------------------------------
//
//  Function:   ValidateNever
//
//  Synopsis:   Password validation function called by parser for Admin
//              Verifies the value contains digits or "NEVER"
//
//  Arguments:  [pArg - IN]    : pointer argument structure which contains
//                               the value to be validated
//
//  Returns:    DWORD : Same as ValidatePassword
//
//  History:    07-Sep-2000   JeffJon Created
//
//---------------------------------------------------------------------------

DWORD ValidateNever(PVOID pArg)
{
    PARG_RECORD pRec = (PARG_RECORD)pArg;
    if(!pRec)
        return ERROR_INVALID_PARAMETER;

    if (pRec->fType == ARG_TYPE_STR)
    {
       CComBSTR sbstrInput;
       sbstrInput = pRec->strValue;
       if( _wcsicmp(sbstrInput, g_bstrNever) )
       {
          return ERROR_INVALID_PARAMETER;
       }
    }
    return ERROR_SUCCESS;
}

//+--------------------------------------------------------------------------
//
//  Function:   ValidateGroupScope
//
//  Synopsis:   Makes sure that the value following the -scope switch is one
//              of (l/g/u)
//
//  Arguments:  [pArg - IN]    : pointer argument structure which contains
//                               the value to be validated
//
//  Returns:    DWORD : Same as ValidatePassword
//
//  History:    18-Sep-2000   JeffJon Created
//
//---------------------------------------------------------------------------

DWORD ValidateGroupScope(PVOID pArg)
{
    DWORD dwReturn = ERROR_SUCCESS;
    PARG_RECORD pRec = (PARG_RECORD)pArg;
    if(!pRec || !pRec->strValue)
        return ERROR_INVALID_PARAMETER;

    CComBSTR sbstrInput;
    sbstrInput = pRec->strValue;
    sbstrInput.ToLower();
    if(sbstrInput == _T("l") ||
       sbstrInput == _T("g") ||
       sbstrInput == _T("u"))
    {
        dwReturn = ERROR_SUCCESS;
    }
    else
    {
        dwReturn = ERROR_INVALID_PARAMETER;
    }

    return dwReturn;
}

//+--------------------------------------------------------------------------
//
//  Function:   ParseNullSeparatedString
//
//  Synopsis:   Parses a '\0' separated list that ends in "\0\0" into a string
//              array
//
//  Arguments:  [psz - IN]     : '\0' separated string to be parsed
//              [pszArr - OUT] : the array to receive the parsed strings
//              [pnArrEntries - OUT] : the number of strings parsed from the list
//
//  Returns:    
//
//  History:    18-Sep-2000   JeffJon   Created
//
//---------------------------------------------------------------------------
void ParseNullSeparatedString(PTSTR psz,
								      PTSTR** ppszArr,
								      UINT* pnArrEntries)
{
   //
   // Verify parameters
   //
   if (!psz ||
       !ppszArr ||
       !pnArrEntries)
   {
      ASSERT(psz);
      ASSERT(ppszArr);
      ASSERT(pnArrEntries);

      return;
   }

   //
   // Count the number of strings
   //
   UINT nCount = 0;
   PTSTR pszTemp = psz;
   while (true)
   {
      if (pszTemp[0] == _T('\0') && 
          pszTemp[1] == _T('\0'))
      {
         nCount++;
         break;
      }
      else if (pszTemp[0] == _T('\0') &&
               pszTemp[1] != _T('\0'))
      {
         nCount++;
         pszTemp++;
      }
      else
      {
         pszTemp++;
      }
   }

   *pnArrEntries = nCount;

   //
   // Allocate the array
   //
   *ppszArr = (PTSTR*)LocalAlloc(LPTR, nCount * sizeof(PTSTR));
   if (*ppszArr)
   {
      //
      // Copy the string pointers into the array
      //
      UINT nIdx = 0;
      pszTemp = psz;
      (*ppszArr)[nIdx] = pszTemp;
      nIdx++;

      while (true)
      {
         if (pszTemp[0] == _T('\0') && 
             pszTemp[1] == _T('\0'))
         {
            break;
         }
         else if (pszTemp[0] == _T('\0') &&
                  pszTemp[1] != _T('\0'))
         {
            (*ppszArr)[nIdx] = &(pszTemp[1]);
            nIdx++;
            pszTemp++;
         }
         else
         {
            pszTemp++;
         }
      }
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netdom\ndutil.cxx ===
/*++

Microsoft Windows

Copyright (C) Microsoft Corporation, 1998 - 2001

Module Name:

    ndutil.cxx

Abstract:

    Common functions to be shared between the netdom features

--*/
#include "pch.h"
#pragma hdrstop
#include <netdom.h>

bool
CmdFlagOn(ARG_RECORD * rgNetDomArgs, NETDOM_ARG_ENUM eArgIndex)
{
   if (!rgNetDomArgs || eArgIndex >= eArgEnd)
   {
      ASSERT(FALSE);
      return false;
   }

   return rgNetDomArgs[eArgIndex].bDefined == TRUE;
}
 
BOOL
NetDompGetUserConfirmation(
    IN DWORD PromptResId,
    IN PWSTR pwzName
    )
/*++

Routine Description:

    Prompt the user to press the y or n button.

Arguments:

    PrompteResId - Resource ID of the prompt to be displayed
    pwzName - Optional name to put in the prompt string

Return Value:

    TRUE if the user pressed y or Y, FALSE otherwise.

--*/
{
    WCHAR wzBuf[MAX_PATH], wzTitle[30];
    PWSTR pwzMsg;
    int nRet;

    if (!LoadString(g_hInstance, PromptResId, wzBuf, MAX_PATH))
    {
        printf("LoadString FAILED!\n");
        return FALSE;
    }

    if (!LoadString(g_hInstance, IDS_PROMPT_TITLE, wzTitle, 30))
    {
        printf("LoadString FAILED!\n");
        return FALSE;
    }

    if (pwzName)
    {
        if (NetApiBufferAllocate((wcslen(wzBuf) + wcslen(pwzName) + 1) * sizeof(WCHAR),
                                 (PVOID*)&pwzMsg) != ERROR_SUCCESS)
        {
            printf("Memory allocation FAILED!\n");
            return FALSE;
        }

        wsprintf(pwzMsg, wzBuf, pwzName);
    }
    else
    {
        pwzMsg = wzBuf;
    }

    nRet = MessageBox(GetFocus(),
                      pwzMsg,
                      wzTitle,
                      MB_YESNO | 
                          MB_ICONEXCLAMATION |
                          MB_DEFAULT_DESKTOP_ONLY |
                          MB_SETFOREGROUND |
                          MB_DEFBUTTON2);
    if (pwzName)
    {
        NetApiBufferFree(pwzMsg);
    }

    return (nRet == IDYES);
}


DWORD
NetDompGetPasswordString(
    DWORD PromptResId,
    PWSTR Buffer,
    ULONG BufferLength
    )
/*++

Routine Description:

    This function will get the password string for an account object.  It reads it from
    the user input

Arguments:

    PrompteResId - Resource ID of the prompt to be displayed

    Buffer - The buffer in which to return the password

    BufferLength - Length of the buffer (in characters)

Return Value:

    ERROR_SUCCESS - The call succeeded

    NERR_BufTooSmall - The password entered was larger than would fit in the buffer

--*/
{
    ULONG Win32Err = ERROR_SUCCESS;
    DWORD CurrentMode, Read, Length = 0;
    HANDLE InputHandle = GetStdHandle( STD_INPUT_HANDLE );
    WCHAR CurrentChar;
    PWSTR CurrentBufPtr = Buffer;

    //
    // Display the password prompt, if specified
    //
    if ( PromptResId != 0 ) {

        NetDompDisplayMessage( PromptResId );
    }

    BufferLength -= 1;    /* make space for null terminator */

    //
    // Turn off echo
    //
    if (!GetConsoleMode( InputHandle,
                         &CurrentMode )) {
       return GetLastError();
    }

    SetConsoleMode( InputHandle,
		            ( ~( ENABLE_ECHO_INPUT | ENABLE_LINE_INPUT ) ) & CurrentMode );

    //
    // Read from the console
    //
    while ( TRUE ) {

        if ( ReadConsole( InputHandle,
                          &CurrentChar,
                          1,
                          &Read,
                          NULL ) == FALSE ) {
            Win32Err = GetLastError();
            break;
        }

        if ( Read != 1 || CurrentChar == 0xd ) {

            break;
        }

        //
        // Process the backspace
        //
        if ( CurrentChar == 0x8 ) {

            if ( CurrentBufPtr != Buffer ) {

                CurrentBufPtr--;
                Length--;
            }

        } else {

            if ( Length == BufferLength ) {

                Win32Err = NERR_BufTooSmall;
                break;
            }

            *CurrentBufPtr = CurrentChar;
            Length++;
            CurrentBufPtr++;

        }
    }

    //
    // Null terminate
    //
    *CurrentBufPtr = L'\0';
    SetConsoleMode( InputHandle,
                    CurrentMode );

    //
    // Clear the line for the next prompt
    //
    if ( PromptResId ) {

        printf( "\n" );
    }

    return( Win32Err );
}



DWORD
NetDompGetDomainForOperation(ARG_RECORD * rgNetDomArgs,
                             PWSTR Server OPTIONAL,
                             BOOL CanDefaultToCurrent,
                             PWSTR *DomainName)
/*++

Routine Description:

    This function will get name of the domain for the current operation.  It does this
    by parsing the command line parameters.  If no argument is found, it uses the default
    domain for that machine

Arguments:

    Args - List of arguments, can be NULL if CanDefaultToCurrent is true

    Server - Optional name of servre for which we wish to have the default domain

    CanDefaultToCurrent - if TRUE and the domain name not specified on the command line,
                          use the current domain for the specified machine

    DomainName - Where the domain name is returned.  Freed via NetApiBufferFree().

Return Value:

    ERROR_SUCCESS - The call succeeded

    ERROR_INVALID_PARAMETER - The domain name was not specified and it was requried

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    ULONG i;
    NETSETUP_JOIN_STATUS JoinStatus;

    *DomainName = NULL;

    //
    // See the name is specifed
    //
    if (rgNetDomArgs && CmdFlagOn(rgNetDomArgs, eCommDomain)) {

        Win32Err = NetDompGetArgumentString(rgNetDomArgs,
                                            eCommDomain,
                                            DomainName);
    }

    //
    // If so, convert it
    //
    if ( Win32Err == ERROR_SUCCESS || CanDefaultToCurrent) {

        if ( *DomainName == NULL ) {

            if ( CanDefaultToCurrent ) {

                //
                // See if we can use the current domain
                //
                Win32Err = NetGetJoinInformation( Server,
                                                  DomainName,
                                                  &JoinStatus );

                if ( Win32Err == ERROR_SUCCESS ) {

                    if ( JoinStatus != NetSetupDomainName ) {

                        NetApiBufferFree( *DomainName );
                        NetDompDisplayMessage( MSG_NETDOM5_DOMAIN_REQUIRED );
                        Win32Err = ERROR_INVALID_PARAMETER;
                    }
                }

            } else {

                NetDompDisplayMessage( MSG_NETDOM5_DOMAIN_REQUIRED );
                Win32Err = ERROR_INVALID_PARAMETER;
            }
        }

    } else {

        //
        // Hmm, guess we don't have what we need
        //
        NetDompDisplayMessage( MSG_NETDOM5_DOMAIN_REQUIRED );
        Win32Err = ERROR_INVALID_PARAMETER;
    }

    return( Win32Err );
}


typedef struct _ND5_USER_FLAG_MAP {

    NETDOM_ARG_ENUM UserFlag;
    NETDOM_ARG_ENUM PasswordFlag;
    ULONG PasswordPromptId;

}  ND5_USER_FLAG_MAP, *PND5_USER_FLAG_MAP;


DWORD
NetDompGetUserAndPasswordForOperation(ARG_RECORD * rgNetDomArgs,
                                      NETDOM_ARG_ENUM eUserType,
                                      PWSTR DefaultDomain,
                                      PND5_AUTH_INFO AuthIdent)
/*++

Routine Description:

    This function will get the user name and password from the command line, as required.  If
    necessary, the function will cause a prompt for the password to be displayed and processed

Arguments:

    eUserType - Whether to prompt for object or domain user

    DefaultDomain - Default domain for the operation, in case a relative name was supplied

    AuthIdent - Structure to initialize with the user name and password

Return Value:

    ERROR_SUCCESS - The call succeeded

    ERROR_INVALID_PARAMETER - The domain name was not specified and it was requried

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    ULONG Length;
    ULONG i, PasswordPrompt;
    PWSTR SpecifiedUser = NULL, SpecifiedPassword = NULL;
    PWSTR pwzUserWoDomain, pwzUsersDomain;
    size_t cchDomain;
    ND5_USER_FLAG_MAP FlagMap[] = {
        { eCommUserNameD, eCommPasswordD, MSG_NETDOM5_USERD_PWD },
        { eCommUserNameO, eCommPasswordO, MSG_NETDOM5_USERO_PWD },
        { eMoveUserNameF, eMovePasswordF, MSG_NETDOM5_USERF_PWD },
        };

    if (!AuthIdent)
    {
       return ERROR_INVALID_PARAMETER;
    }

    RtlZeroMemory( AuthIdent, sizeof( ND5_AUTH_INFO ) );

    //
    // Return success if the name wasn't supplied
    //
    if (!CmdFlagOn(rgNetDomArgs, eUserType))
    {
        return(ERROR_SUCCESS);
    }

    //
    // See the name is specifed
    //
    SpecifiedUser = rgNetDomArgs[eUserType].strValue;

    //
    // If so, use it
    //
    if ( SpecifiedUser ) {

        if ( wcschr( SpecifiedUser, L'\\' ) || wcschr( SpecifiedUser, L'@' ) ) {

            Win32Err = NetApiBufferAllocate((wcslen(SpecifiedUser ) + 1) * sizeof(WCHAR),
                                            (PVOID*)&(AuthIdent->User));
            if ( Win32Err == ERROR_SUCCESS && AuthIdent->User) {

                wcscpy(AuthIdent->User, SpecifiedUser);
            }
            else
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }

        } else {

            if (wcslen(SpecifiedUser) < 1) {

                Win32Err = NetApiBufferAllocate(sizeof(WCHAR), (PVOID*)&(AuthIdent->User));

                if (ERROR_SUCCESS == Win32Err && AuthIdent->User) {

                    *(AuthIdent->User) = L'\0';
                }
                else
                {
                    return ERROR_NOT_ENOUGH_MEMORY;
                }

            } else {

                if ( !DefaultDomain ) {

                    return ERROR_INVALID_PARAMETER;

                } else {

                    Length = wcslen(DefaultDomain) + 1 + wcslen(SpecifiedUser) + 1;
                    Win32Err = NetApiBufferAllocate((Length + 1) * sizeof(WCHAR),
                                                     (PVOID*)&(AuthIdent->User));

                    if ( Win32Err == ERROR_SUCCESS ) {

                        wcscpy( AuthIdent->User, DefaultDomain );
                        wcscat( AuthIdent->User, L"\\" );
                        wcscat( AuthIdent->User, SpecifiedUser);
                    }
                }
            }
        }

        if (pwzUserWoDomain = wcschr(AuthIdent->User, L'\\')) {

            cchDomain = pwzUserWoDomain - AuthIdent->User;

            Win32Err = NetApiBufferAllocate((cchDomain + 1) * sizeof(WCHAR),
                                            (PVOID*)&(AuthIdent->pwzUsersDomain));

            if ( Win32Err == ERROR_SUCCESS ) {

                wcsncpy(AuthIdent->pwzUsersDomain, AuthIdent->User, cchDomain);

                AuthIdent->pwzUsersDomain[cchDomain] = L'\0';

                pwzUserWoDomain++;

                if (pwzUserWoDomain) {

                    Win32Err = NetApiBufferAllocate((wcslen(pwzUserWoDomain) + 1) * sizeof(WCHAR),
                                                    (PVOID*)&(AuthIdent->pwzUserWoDomain));

                    if ( Win32Err == ERROR_SUCCESS ) {

                        wcscpy(AuthIdent->pwzUserWoDomain, pwzUserWoDomain);
                    }
                }
            }
        }

    } else {

        Win32Err = ERROR_INVALID_PARAMETER;
    }

    //
    // Now, the password if it exists
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        NETDOM_ARG_ENUM ePasswordArg;

        for ( i = 0; i < sizeof( FlagMap ) / sizeof( ND5_USER_FLAG_MAP ); i++ ) {

            if ( eUserType == FlagMap[ i ].UserFlag ) {

                ePasswordArg = FlagMap[ i ].PasswordFlag;
                PasswordPrompt = FlagMap[ i ].PasswordPromptId;
                break;
            }
        }

        ASSERT( ePasswordArg != eArgBegin );

        //
        // Now, get the password
        //
        SpecifiedPassword = rgNetDomArgs[ePasswordArg].strValue;

        if ( !wcscmp( SpecifiedPassword, L"*" ) ) {

            //
            // Prompt for it...
            //
            Win32Err = NetApiBufferAllocate( ( PWLEN + 1 ) * sizeof( WCHAR ),
                                             (PVOID*)&( AuthIdent->Password ) );

            if ( Win32Err == ERROR_SUCCESS  && AuthIdent->Password) {

                Win32Err = NetDompGetPasswordString( PasswordPrompt,
                                                     AuthIdent->Password,
                                                     PWLEN );
            }
            else
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }

        } else {

            //
            // It's a password, so go with it..
            //
            Win32Err = NetApiBufferAllocate((wcslen(SpecifiedPassword) + 1) * sizeof(WCHAR),
                                            (PVOID*)&(AuthIdent->Password));

            if ( Win32Err == ERROR_SUCCESS  && AuthIdent->Password) {

                wcscpy(AuthIdent->Password, SpecifiedPassword);
            }
            else
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }
        }

        // Password not specified, create an empty one.
        //
        if( AuthIdent->Password == NULL )
        {
           Win32Err = NetApiBufferAllocate(sizeof(WCHAR), (PVOID*)&(AuthIdent->Password));

           if ( Win32Err == ERROR_SUCCESS && AuthIdent->Password) {

               *AuthIdent->Password = L'\0';
           }
           else
           {
               return ERROR_NOT_ENOUGH_MEMORY;
           }
        }
    }

    if ( Win32Err != ERROR_SUCCESS ) {

        NetDompFreeAuthIdent( AuthIdent );
    }

    return( Win32Err );
}


DWORD
NetDompGetArgumentString(ARG_RECORD * rgNetDomArgs,
                         NETDOM_ARG_ENUM eArgToGet,
                         PWSTR *ArgString)
/*++

Routine Description:

    This function will get the string associated with a command line parameter, if it exists.

Arguments:

    Args - List of arguments

    ArgToGet - Argument to get the string for

    ArgString - Where the arg string is returned if found.  Freed via NetApiBufferFree

Return Value:

    ERROR_SUCCESS - The call succeeded

--*/
{
   DWORD Win32Err = ERROR_SUCCESS;

   *ArgString = NULL;

   if (eArgToGet >= eArgEnd)
   {
      return ERROR_INVALID_PARAMETER;
   }

   if (!rgNetDomArgs[eArgToGet].strValue)
   {
      // Allow null strings.
      //
      return ERROR_SUCCESS;
   }

   Win32Err = NetApiBufferAllocate((wcslen(rgNetDomArgs[eArgToGet].strValue) + 1) *
                                                                       sizeof(WCHAR),
                                   (PVOID*)ArgString);

   if ( Win32Err == ERROR_SUCCESS ) {

      wcscpy(*ArgString, rgNetDomArgs[eArgToGet].strValue);
   }

   return( Win32Err );
}


BOOL
NetDompGetArgumentBoolean(ARG_RECORD * rgNetDomArgs,
                          NETDOM_ARG_ENUM eArgToGet)
/*++

Routine Description:

    This function will determine whether the given command line argument was present on the
    command line or not.

Arguments:

    Args - List of arguments

    ArgToGet - Argument to get the string for

Return Value:

    TRUE - The argument was found

    FALSE - The argument wasn't found

--*/
{
   if (eArgToGet >= eArgEnd)
   {
      ASSERT(FALSE);
      return FALSE;
   }

   return rgNetDomArgs[eArgToGet].bDefined;
}



DWORD
NetDompControlService(
    IN PWSTR Server,
    IN PWSTR Service,
    IN DWORD ServiceOptions
    )
/*++

Routine Description:

    This function will control the given service on the given machine.

Arguments:

    Server - Machine on which to control the service

    Service - Service to control

    ServiceOptions - What do with the service.  Uses standard SvcCtrl bits

Return Value:

    ERROR_SUCCESS - The operation succeeded

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    SC_HANDLE ScMgr, Svc;
    DWORD OpenMode;

    //
    // Open the service control manager
    //
    ScMgr = OpenSCManager( Server,
                           SERVICES_ACTIVE_DATABASE,
                           GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE );

    if ( ScMgr == NULL ) {

        Win32Err = GetLastError();

    } else {

        //
        // Set the open mode
        //
        if( FLAG_ON( ServiceOptions, SERVICE_STOP ) ) {

            LOG_VERBOSE(( MSG_VERBOSE_SVC_STOP, Service ));
            OpenMode = SERVICE_STOP                     |
                           SERVICE_ENUMERATE_DEPENDENTS |
                           SERVICE_QUERY_STATUS         |
                           SERVICE_CHANGE_CONFIG;

        } else if( FLAG_ON( ServiceOptions, SERVICE_START ) ) {

            LOG_VERBOSE(( MSG_VERBOSE_SVC_START, Service ));
            OpenMode = SERVICE_START;

        } else {

            LOG_VERBOSE(( MSG_VERBOSE_SVC_CONFIG, Service ));
            OpenMode = SERVICE_CHANGE_CONFIG | SERVICE_QUERY_CONFIG;

        }

        if ( FLAG_ON( ServiceOptions, SERVICE_STOP ) ) {

            Win32Err = NetpStopService( Service,
                                        ScMgr );

        }

        if ( Win32Err == ERROR_SUCCESS ) {

            //
            // Open the service
            //
            Svc = OpenService( ScMgr,
                               Service,
                               OpenMode );

            if ( Svc == NULL ) {

                Win32Err = GetLastError();

            } else {

                if ( FLAG_ON( ServiceOptions, SERVICE_START ) ) {

                    //
                    // See about changing its state
                    //
                    if ( StartService( Svc, 0, NULL  ) == FALSE ) {

                        Win32Err = GetLastError();

                        if ( Win32Err == ERROR_SERVICE_ALREADY_RUNNING ) {

                            Win32Err = ERROR_SUCCESS;

                        }

                    }


                } else {

                    if ( ChangeServiceConfig( Svc,
                                              SERVICE_NO_CHANGE,
                                              ServiceOptions,
                                              SERVICE_NO_CHANGE,
                                              NULL, NULL, 0, NULL, NULL, NULL,
                                              NULL ) == FALSE ) {

                        Win32Err = GetLastError();
                    }
                }

                CloseServiceHandle( Svc );
            }
        }

        CloseServiceHandle( ScMgr );
    }

    return( Win32Err );
}


DWORD
EnableShutDownPrivilege()
{
HANDLE hToken;              // handle to process token 
TOKEN_PRIVILEGES tkp;       // pointer to token structure 
 
 
   // Get the current process token handle so we can get shutdown 
   // privilege. 
 
   if (!OpenProcessToken( GetCurrentProcess(), 
                          TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, 
                          &hToken )) 
      return GetLastError();
    
 
   // Get the LUID for shutdown privilege. 
 
   if( !LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, 
        &tkp.Privileges[0].Luid) )
      return GetLastError();
 
   tkp.PrivilegeCount = 1;  // one privilege to set    
   tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED; 
 
   // Get shutdown privilege for this process. 
 
   AdjustTokenPrivileges(hToken, FALSE, &tkp, 0, 
                     (PTOKEN_PRIVILEGES) NULL, 0);
     
   // Cannot test the return value of AdjustTokenPrivileges. 
 
   if ( GetLastError() != ERROR_SUCCESS ) 
      return GetLastError();

   return ERROR_SUCCESS;

}

DWORD
NetDompRestartAsRequired(ARG_RECORD * rgNetDomArgs,
                         PWSTR Machine,
                         PWSTR User,
                         DWORD PreliminaryStatus,
                         DWORD MsgID)
/*++

Routine Description:

    This function will (remotely) shutdown a machine if the command line arguments indicate
    that it should

Arguments:

    Args - List of arguments

    ArgCount - Number of arguments in the list

    Machine - Machine which should be restarted

    User - The user who connected to the machine, doing whatever operation needed a reboot.
           If NULL is specified, the current user is used.

    PreliminaryStatus - Status from the operation.  If it's not SUCCESS, the restart isn't
                        attempted

    MsgID - Message ID of string to display on system being shut down.

Return Value:

    ERROR_SUCCESS - The operation succeeded

--*/
{
    DWORD Win32Err = PreliminaryStatus;
    BOOL Restart = FALSE;
    PWSTR UserName = NULL, DisplayString = NULL, Delay, End;
    ULONG Length = 0, RestartDelay = 30;

    if ( PreliminaryStatus != ERROR_SUCCESS ) {

        return( PreliminaryStatus );
    }

    //
    // See if the argument is specified
    //
    Restart = NetDompGetArgumentBoolean(rgNetDomArgs,
                                        eCommRestart);

    if ( Restart ) {

        //
        // Get the delay time
        //
        RestartDelay = rgNetDomArgs[eCommRestart].nValue;

        //
        // Get the user display name
        //
        if ( User ) {

            UserName = User;

        } else {

            Length = 0;
            GetUserName( NULL, &Length );
            Win32Err = NetApiBufferAllocate( Length * sizeof( WCHAR ),
                                             (PVOID*)&UserName );

            if ( Win32Err == ERROR_SUCCESS ) {

                if ( !GetUserName( UserName, &Length ) ) {

                    Win32Err = GetLastError();
                }
            }
        }

        //
        // Build the message to display, and schedule the shutdown
        //
        if ( Win32Err == ERROR_SUCCESS ) {

            Length = FormatMessageW( FORMAT_MESSAGE_FROM_HMODULE |
                                        FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                        FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                     NULL,
                                     MsgID,
                                     0,
                                     ( PWSTR )&DisplayString,
                                     0,
                                     ( va_list * )&UserName );
            if ( Length == 0 ) {

                Win32Err = GetLastError();

            } else {

                LOG_VERBOSE(( MSG_VERBOSE_REBOOTING, Machine ));
                //If Machine is localMachine, Enable SE_SHUTDOWN_NAME privilege
                if( IsLocalMachine( Machine ) ){
                     if( ( Win32Err = EnableShutDownPrivilege() ) == ERROR_SUCCESS ){

                        if ( InitiateSystemShutdown( Machine,
                                                   DisplayString,
                                                   RestartDelay,
                                                   TRUE,
                                                   TRUE ) == FALSE ) {

                           Win32Err = GetLastError();
                        }
                     }
                }
                else if ( InitiateSystemShutdown( Machine,
                                                  DisplayString,
                                                  RestartDelay,
                                                  TRUE,
                                                  TRUE ) == FALSE ) {

                           Win32Err = GetLastError();
                        }

            }
        }
    }

    if ( Win32Err != ERROR_SUCCESS ) {

        NetDompDisplayMessage( MSG_NO_RESTART );
        NetDompDisplayErrorMessage( Win32Err );
    }

    LocalFree( DisplayString );


    if ( UserName != User ) {

        NetApiBufferFree( UserName );
    }

    return( Win32Err );
}



DWORD
NetDompCheckDomainMembership(
    IN PWSTR Server,
    IN PND5_AUTH_INFO AuthInfo,
    IN BOOL EstablishSessionIfRequried,
    IN OUT BOOL * DomainMember
    )
/*++

Routine Description:

    This function will determine whether the specified machine is a member of a domain or not

Arguments:

    Server - Machine in question

    AuthInfo - User name and password used to connect to the machine if necessary

    EstablishSessionIfRequired - Establish an authenticated session to the machine if necessary

    DomainMember - Gets set to TRUE if the machine is a domain member.  Otherwise, it's FALSE.

Return Value:

    ERROR_SUCCESS - The operation succeeded

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    NTSTATUS Status;
    LSA_HANDLE LsaHandle = NULL;
    PPOLICY_PRIMARY_DOMAIN_INFO PolicyPDI = NULL;
    OBJECT_ATTRIBUTES OA;
    UNICODE_STRING ServerU;


    *DomainMember = FALSE;

    //
    // Establish a session, if necessary
    //
    if ( Server && EstablishSessionIfRequried ) {

        LOG_VERBOSE(( MSG_VERBOSE_ESTABLISH_SESSION, Server ));
        Win32Err = NetpManageIPCConnect( Server,
                                         AuthInfo->User,
                                         AuthInfo->Password,
                                         NETSETUPP_CONNECT_IPC );
    }

    //
    // See if it's a domain member.  Use the LSA apis, since this might be an
    // NT4 box.
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        if ( Server ) {

            RtlInitUnicodeString( &ServerU, Server );
        }

        InitializeObjectAttributes( &OA, NULL, 0, NULL, NULL );

        Status = LsaOpenPolicy( Server ? &ServerU : NULL,
                                &OA,
                                MAXIMUM_ALLOWED,
                                &LsaHandle );

        if ( NT_SUCCESS( Status ) ) {

            Status = LsaQueryInformationPolicy( LsaHandle,
                                                PolicyPrimaryDomainInformation,
                                                ( PVOID * )&PolicyPDI );

            if ( NT_SUCCESS( Status ) ) {

                if ( PolicyPDI->Sid ) {

                    *DomainMember = TRUE;
                }

                LsaFreeMemory( PolicyPDI );
            }

            LsaClose( LsaHandle );
        }

        Win32Err = RtlNtStatusToDosError( Status );
    }


    //
    // Tear down the session
    //
    if ( Server && EstablishSessionIfRequried ) {

        LOG_VERBOSE(( MSG_VERBOSE_DELETE_SESSION, Server ));
        NetpManageIPCConnect( Server,
                              AuthInfo->User,
                              AuthInfo->Password,
                              NETSETUPP_DISCONNECT_IPC );

    }

    return( Win32Err );
}


DWORD
NetDompValidateSecondaryArguments(ARG_RECORD * rgNetDomArgs,
                                  NETDOM_ARG_ENUM eFirstValidParam, ...)
    //PND5_ARG Args,
/*++

Routine Description:

    This function will determine whether the supplied command line options are
    valid for this operation or not

Return Value:

    ERROR_SUCCESS - The operation succeeded

    ERROR_INVALID_PARAMETER - A bad parameter was specified

--*/
{
   DWORD Win32Err = ERROR_SUCCESS;
   va_list ArgList;

   for (int i = eArgBegin; i < eArgEnd; i++)
   {
      if (rgNetDomArgs[i].bDefined)
      {
         int j = eFirstValidParam;
         bool fFound = false;
         va_start(ArgList, eFirstValidParam);

         while (j != eArgEnd)
         {
            if (i == j)
            {
               fFound = true;
               break;
            }
            j = va_arg(ArgList, int);
         }

         if (!fFound)
         {
            NetDompDisplayUnexpectedParameter(rgNetDomArgs[i].strArg1);
            return ERROR_INVALID_PARAMETER;
         }
      }
   }

   va_end(ArgList);
   return(Win32Err);
}



DWORD
NetDompGenerateRandomPassword(
    IN PWSTR Buffer,
    IN ULONG Length
    )
/*++

Routine Description:

    This function will generate a random password of the specified length

Arguments:

    Buffer - Place to put the randomly generated password

    Length - Length of the password (in characters) to generate


Return Value:

    ERROR_SUCCESS - The operation succeeded

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    HCRYPTPROV CryptProvider = 0;
    LARGE_INTEGER Time;
    ULONG Seed, i;
    UCHAR Filler;

    NtQuerySystemTime( &Time );
    Seed = ( ( PLONG )( &Time ) )[ 0 ] ^ ( ( PLONG )( &Time ) )[ 1 ];

    Filler = ( UCHAR )( RtlRandom( &Seed ) % ( 254 ) + 1 );  // Generate a fill character to use

    //
    // Generate a random password.
    //
    if ( CryptAcquireContext( &CryptProvider,
                              NULL,
                              NULL,
                              PROV_RSA_FULL,
                              CRYPT_VERIFYCONTEXT ) ) {

        if ( CryptGenRandom( CryptProvider,
                              Length * sizeof( WCHAR ),
                              ( LPBYTE )Buffer ) ) {

            Buffer[ Length ] = UNICODE_NULL;

            //
            // Make sure there are no NULL's in the middle of the list
            //
            for ( i = 0; i < Length; i++ ) {

                if ( Buffer[ i ] == UNICODE_NULL ) {

                    Buffer[ i ] = Filler;
                }
            }

        } else {

            Win32Err = GetLastError();
        }

        CryptReleaseContext( CryptProvider, 0 );


    } else {

        Win32Err = GetLastError();
    }

    return( Win32Err );
}

VOID
NetDompFreeAuthIdent(
    IN PND5_AUTH_INFO pAuthIdent
    )
{
    if (pAuthIdent->User)
        NetApiBufferFree(pAuthIdent->User);
    if (pAuthIdent->Password)
        NetApiBufferFree(pAuthIdent->Password);
    if (pAuthIdent->pwzUserWoDomain)
        NetApiBufferFree(pAuthIdent->pwzUserWoDomain);
    if (pAuthIdent->pwzUsersDomain)
        NetApiBufferFree(pAuthIdent->pwzUsersDomain);
}

BOOL IsLocalMachine( LPWSTR Machine )
{
   WCHAR szLocalComputer[MAX_COMPUTERNAME_LENGTH + 1];
   DWORD nSize = MAX_COMPUTERNAME_LENGTH + 1 ;

   if( !GetComputerName( szLocalComputer, &nSize ) )
      return FALSE;

   if( _wcsicmp( Machine, szLocalComputer ) == 0 )
      return TRUE;
   else
      return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netdom\query.cxx ===
/*++

Microsoft Windows

Copyright (C) Microsoft Corporation, 1998 - 2001

Module Name:

    query.c

Abstract:

    Handles the various functions for the QUERY command

--*/
#include "pch.h"
#pragma hdrstop
#include <netdom.h>

#define VERIFY_QUERY_ONLY   0xFFFFFFFF

typedef enum _ND5_ACCOUNT_TYPE {

    TypeWorkstation,
    TypeServer,
    TypeDomainController,
    TypePDC,
    TypeUnknown

} ND5_ACCOUNT_TYPE;

typedef enum _ND5_ACCOUNT_OPERATION {

    OperationDisplay,
    OperationVerify,
    OperationReset
} ND5_ACCOUNT_OPERATION;

typedef struct _ND5_TRANS_TREE_NODE {

    PDS_DOMAIN_TRUSTS DomainInfo;
    ULONG ListIndex;
    ULONG Children;
    struct _ND5_TRANS_TREE_NODE *ChildList;
    struct _ND5_TRANS_TREE_NODE *Parent;

} ND5_TRANS_TREE_NODE, *PND5_TRANS_TREE_NODE;


VOID
NetDompFreeBuiltTrustInfo(
    IN PTRUSTED_DOMAIN_INFORMATION_EX TDInfoEx,
    IN ULONG Count
    )
{
    ULONG i;

    for ( i = 0; i < Count; i++ ) {

        NetApiBufferFree( TDInfoEx[ i ].Name.Buffer );
    }

    NetApiBufferFree( TDInfoEx );
}

VOID
NetDompDumpTrustInfo(
    IN PWSTR Domain,
    IN PTRUSTED_DOMAIN_INFORMATION_EX TrustInfo
    )
/*++

Routine Description:

    This function will display the specified trusted domain info

Arguments:

    Domain - Domain to be dumped

    TrustInfo - Trust info the domain

Return Value:

    VOID

--*/
{
    ULONG Message, Type;

    //
    // Display the direction & name
    //
    Type = TrustInfo->TrustDirection & TRUST_DIRECTION_BIDIRECTIONAL;

    switch ( Type ) {
    case TRUST_DIRECTION_BIDIRECTIONAL:

        Message = MSG_TRUST_BOTH_ARROW;
        break;

    case TRUST_DIRECTION_INBOUND:

        Message = MSG_TRUST_IN_ARROW;
        break;

    case TRUST_DIRECTION_OUTBOUND:

        Message = MSG_TRUST_OUT_ARROW;
        break;
    }

    NetDompDisplayMessage( Message,
                           TrustInfo->Name.Buffer );

    //
    // Then, the type
    //
    switch ( TrustInfo->TrustType ) {

    case TRUST_TYPE_DOWNLEVEL:
    case TRUST_TYPE_UPLEVEL:

        Message = MSG_TRUST_TYPE_WINDOWS;
        break;

    case TRUST_TYPE_MIT:

        Message = MSG_TRUST_TYPE_MIT;
        break;

    default:

        Message = MSG_TRUST_TYPE_OTHER;
        break;
    }

    NetDompDisplayMessage( Message );

    printf( "\n" );
}

//+----------------------------------------------------------------------------
//
//  Function:   GetTrustInfo
//
//  Synopsis:   Reads the trust info from the local TDO for the named domain.
//
//-----------------------------------------------------------------------------
DWORD
GetTrustInfo(PWSTR pwzDomain,
             PND5_TRUST_INFO pLocalInfo,
             PND5_TRUST_INFO pTrustInfo,
             DWORD * pdwVerifyErr)
{
    DWORD Win32Err = ERROR_SUCCESS;
    NTSTATUS Status = STATUS_SUCCESS;
    PTRUSTED_DOMAIN_INFORMATION_EX pTDIEx = NULL;
    UNICODE_STRING usDomainName;
    LSA_HANDLE hTrust;

    *pdwVerifyErr = ERROR_ACCESS_DENIED;

    RtlInitUnicodeString(&usDomainName, pwzDomain);

    Status = LsaOpenTrustedDomainByName(pLocalInfo->LsaHandle,
                                        &usDomainName,
                                        TRUSTED_READ,
                                        &hTrust);
    if (!NT_SUCCESS(Status))
    {
        *pdwVerifyErr = LsaNtStatusToWinError(Status);
        return *pdwVerifyErr;
    }

    Status = LsaQueryInfoTrustedDomain(hTrust,
                                       TrustedDomainInformationEx,
                                       (PVOID*)&pTDIEx);

    if (!NT_SUCCESS(Status))
    {
        *pdwVerifyErr = LsaNtStatusToWinError(Status);
        return *pdwVerifyErr;
    }

    pTrustInfo->TrustHandle = hTrust;
    pTrustInfo->DomainName = &pTDIEx->Name;
    pTrustInfo->FlatName   = &pTDIEx->FlatName;
    pTrustInfo->Sid        = pTDIEx->Sid;
    pTrustInfo->BlobToFree = pTDIEx;

    if (pTDIEx->TrustType >= TRUST_TYPE_MIT)
    {
        pTrustInfo->Uplevel = FALSE;
        pTrustInfo->Flags   = NETDOM_TRUST_TYPE_MIT;
        *pdwVerifyErr = ERROR_SUCCESS;
    }
    else
    {
        PDOMAIN_CONTROLLER_INFO pDcInfo = NULL;
        PPOLICY_DNS_DOMAIN_INFO pPolicyDDI = NULL;
        OBJECT_ATTRIBUTES OA;
        UNICODE_STRING ServerU, DomainNameU;

        // Get a DC name for the domain.
        //
        Win32Err = DsGetDcName(NULL,
                               pwzDomain,
                               NULL,
                               NULL,
                               DS_DIRECTORY_SERVICE_PREFERRED,
                               &pDcInfo );

        if (ERROR_SUCCESS != Win32Err)
        {
            pTrustInfo->Flags = NETDOM_TRUST_FLAG_DOMAIN_NOT_FOUND;
            *pdwVerifyErr = Win32Err;
            return ERROR_SUCCESS;
        }

        // Save off the DC name.
        //
        Win32Err = NetApiBufferAllocate((wcslen(pDcInfo->DomainControllerName) + 1) * sizeof(WCHAR),
                                        (PVOID*)&(pTrustInfo->Server));

        if (ERROR_SUCCESS != Win32Err)
        {
            NetApiBufferFree(pDcInfo);
            return Win32Err;
        }

        wcscpy(pTrustInfo->Server, pDcInfo->DomainControllerName);

        NetApiBufferFree(pDcInfo);

        Win32Err = NetpManageIPCConnect(pTrustInfo->Server,
                                        L"",
                                        L"",
                                        NETSETUPP_NULL_SESSION_IPC);
        if (ERROR_SUCCESS == Win32Err)
        {
            pTrustInfo->Connected = TRUE;
        }

        RtlInitUnicodeString(&ServerU, pTrustInfo->Server);

        InitializeObjectAttributes( &OA, NULL, 0, NULL, NULL );

        Status = LsaOpenPolicy(&ServerU,
                               &OA,
                               POLICY_VIEW_LOCAL_INFORMATION | POLICY_LOOKUP_NAMES,
                               &(pTrustInfo->LsaHandle));

        if (NT_SUCCESS(Status))
        {
            // Find out if this is an uplevel or downlevel domain.
            //
            Status = LsaQueryInformationPolicy(pTrustInfo->LsaHandle,
                                               PolicyDnsDomainInformation,
                                               (PVOID *)&pPolicyDDI);
            if (NT_SUCCESS(Status))
            {
                LsaFreeMemory(pPolicyDDI);
                pTrustInfo->Uplevel = TRUE;
                pTrustInfo->fWasDownlevel = FALSE;
            }
            else
            {
                if (RPC_NT_PROCNUM_OUT_OF_RANGE == Status)
                {
                    pTrustInfo->Uplevel = pTrustInfo->fWasDownlevel = FALSE;
                    Status = STATUS_SUCCESS;
                }
            }
        }

        if (ERROR_NO_SUCH_DOMAIN == (*pdwVerifyErr = RtlNtStatusToDosError(Status)) ||
            RPC_S_SERVER_UNAVAILABLE == *pdwVerifyErr)
        {
            pTrustInfo->Flags = NETDOM_TRUST_FLAG_DOMAIN_NOT_FOUND;
        }

        if (*pdwVerifyErr != ERROR_SUCCESS && pTrustInfo->Connected)
        {
            NetpManageIPCConnect(pTrustInfo->Server,
                                 NULL,
                                 NULL,
                                 NETSETUPP_DISCONNECT_IPC);
            pTrustInfo->Connected = FALSE;
        }
    }

    return S_OK;
}


DWORD
NetDompQueryDirectTrust(

    IN PWSTR Domain,
    IN PND5_TRUST_INFO TrustInfo
    )
/*++

Routine Description:

    This function will get the trustinfo for the specified domain

Arguments:

    Domain - Domain to get the trust info for

    TrustInfo - Trust info to be obtained

Return Value:

    ERROR_SUCCESS - The function succeeded

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    NTSTATUS Status = STATUS_SUCCESS;
    LSA_ENUMERATION_HANDLE EnumerationContext = 0;
    PTRUSTED_DOMAIN_INFORMATION_EX TDInfoEx = NULL, TempTDIEx = NULL;
    PLSA_TRUST_INFORMATION TDInfo = NULL;
    ULONG Count, i, TotalCount = 0, UserCount, j;
    BOOL DisplayHeader = TRUE;
    LPUSER_INFO_0 UserList = NULL;
    ULONG ResumeHandle = 0;
    PWSTR Lop, FullServer = NULL;

    //
    // Handle the uplevel case differently
    //
    if ( TrustInfo->Uplevel ) {

        do {

            Status = LsaEnumerateTrustedDomainsEx( TrustInfo->LsaHandle,
                                                   &EnumerationContext,
                                                   (PVOID*)&TDInfoEx,
                                                   0x1000,
                                                   &Count );

            if ( NT_SUCCESS( Status ) ||  Status == STATUS_NO_MORE_ENTRIES ) {

                if ( DisplayHeader ) {

                    NetDompDisplayMessage( MSG_TRUST_DIRECT_HEADER );
                    DisplayHeader = FALSE;
                }

                for ( i = 0; i < Count; i++ ) {

                    NetDompDumpTrustInfo( TrustInfo->DomainName->Buffer,
                                          &TDInfoEx[ i ] );
                }
            }

            LsaFreeMemory( TDInfoEx );
            TDInfoEx = NULL;

        } while ( Status == STATUS_MORE_ENTRIES );

    } else {

        //
        // We'll have to do this the old fashioned way. That means that we'll enumerate all of
        // the trust directly, save them off in a list, and then go through and enumerate all
        // of the interdomain trust accounts and merge those into the list.
        //
        do {
             Status = LsaEnumerateTrustedDomains( TrustInfo->LsaHandle,
                                                  &EnumerationContext,
                                                  (PVOID*)&TDInfo,
                                                  0x1000,
                                                  &Count );

            if ( NT_SUCCESS( Status ) ||  Status == STATUS_NO_MORE_ENTRIES ) {


                Win32Err = NetApiBufferAllocate( ( Count + TotalCount ) *
                                                          sizeof( TRUSTED_DOMAIN_INFORMATION_EX ),
                                                 (PVOID*)&TempTDIEx );

                if ( Win32Err != ERROR_SUCCESS ) {

                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    break;
                }

                RtlZeroMemory( TempTDIEx, ( Count + TotalCount ) *
                                                        sizeof( TRUSTED_DOMAIN_INFORMATION_EX ) );
                RtlCopyMemory( TempTDIEx,
                               TDInfoEx,
                               TotalCount * sizeof( TRUSTED_DOMAIN_INFORMATION_EX ) );

                for ( i = 0; i < Count; i++ ) {

                    TempTDIEx[ TotalCount + i ].TrustType = TRUST_TYPE_DOWNLEVEL;
                    TempTDIEx[ TotalCount + i ].TrustDirection = TRUST_DIRECTION_OUTBOUND;
                    Win32Err = NetApiBufferAllocate( TDInfo[ i ].Name.MaximumLength,
                                                     (PVOID*)&( TempTDIEx[ TotalCount + i ].Name.Buffer ) );

                    if ( Win32Err != ERROR_SUCCESS ) {

                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        break;
                    }

                    RtlCopyMemory( TempTDIEx[ TotalCount + i ].Name.Buffer,
                                   TDInfo[ i ].Name.Buffer,
                                   TDInfo[ i ].Name.MaximumLength );
                    TempTDIEx[ TotalCount + i ].Name.Length = TDInfo[ i ].Name.Length;
                    TempTDIEx[ TotalCount + i ].Name.MaximumLength =
                                                                TDInfo[ i ].Name.MaximumLength;

                }

                if ( NT_SUCCESS( Status ) ) {

                    NetApiBufferFree( TDInfoEx );

                    TDInfoEx = TempTDIEx;
                    TotalCount += Count;

                } else {

                    for ( j = 0; j < i; j++ ) {

                        NetApiBufferFree( TempTDIEx[ TotalCount + j ].Name.Buffer );
                        TempTDIEx[ TotalCount + j ].Name.Buffer = NULL;
                    }
                    NetApiBufferFree( TempTDIEx );
                }
            }

        } while ( Status == STATUS_MORE_ENTRIES );

        //
        // Now, let's add in the user accounts
        //
        if ( NT_SUCCESS( Status ) ) {


               if ( TrustInfo->Server && *( TrustInfo->Server ) != L'\\' ) {

                    Win32Err = NetApiBufferAllocate( ( wcslen( TrustInfo->Server ) + 3 ) * sizeof( WCHAR ),
                                                     ( PVOID * )&FullServer );

                    if ( Win32Err == ERROR_SUCCESS ) {

                        swprintf( FullServer, L"\\\\%ws", TrustInfo->Server );

                    }

                } else {

                    FullServer = TrustInfo->Server;
                }

                if ( Win32Err == ERROR_SUCCESS ) {

                    do {

                    Win32Err = NetUserEnum( FullServer,
                                            0,
                                            FILTER_INTERDOMAIN_TRUST_ACCOUNT,
                                            ( LPBYTE * )&UserList,
                                            MAX_PREFERRED_LENGTH,
                                            &Count,
                                            &UserCount,
                                            &ResumeHandle );

                    if ( Win32Err == ERROR_SUCCESS || Win32Err == ERROR_MORE_DATA ) {

                        for ( i = 0; i < Count; i++ ) {


                            Lop = wcsrchr( UserList[ i ].usri0_name, L'$' );
                            if ( Lop ) {

                                *Lop = UNICODE_NULL;
                            }

                            for ( j = 0; j < TotalCount; j++ ) {

                                if ( _wcsicmp( UserList[ i ].usri0_name,
                                               TDInfoEx[ j ].Name.Buffer ) == 0 ) {

                                    TDInfoEx[ j ].TrustDirection |= TRUST_DIRECTION_INBOUND;
                                    break;
                                }
                            }

                            //
                            // If it wasn't found, add it...
                            //
                            if ( j == TotalCount ) {

                                Win32Err = NetApiBufferAllocate( ( 1 + TotalCount ) *
                                                                      sizeof( TRUSTED_DOMAIN_INFORMATION_EX ),
                                                                 (PVOID*)&TempTDIEx );

                                if ( Win32Err != ERROR_SUCCESS ) {

                                    Status = STATUS_INSUFFICIENT_RESOURCES;
                                    break;
                                }

                                RtlZeroMemory( TempTDIEx,
                                               ( 1 + TotalCount ) *
                                                            sizeof( TRUSTED_DOMAIN_INFORMATION_EX ) );
                                RtlCopyMemory( TempTDIEx,
                                               TDInfoEx,
                                               TotalCount * sizeof( TRUSTED_DOMAIN_INFORMATION_EX ) );

                                TempTDIEx[ TotalCount ].TrustType = TRUST_TYPE_DOWNLEVEL;
                                TempTDIEx[ TotalCount ].TrustDirection = TRUST_DIRECTION_INBOUND;

                                Win32Err = NetApiBufferAllocate(
                                               ( wcslen( UserList[ i ].usri0_name ) + 1 ) *
                                                                                    sizeof( WCHAR ) ,
                                               (PVOID*)&( TempTDIEx[ TotalCount ].Name.Buffer ) );

                                if ( Win32Err != ERROR_SUCCESS ) {

                                    Status = STATUS_INSUFFICIENT_RESOURCES;
                                    break;
                                }


                                wcscpy( TempTDIEx[ TotalCount ].Name.Buffer,
                                        UserList[ i ].usri0_name );
                                RtlInitUnicodeString( &TempTDIEx[ TotalCount ].Name,
                                                       TempTDIEx[ TotalCount ].Name.Buffer );



                                if ( NT_SUCCESS( Status ) ) {

                                    NetApiBufferFree( TDInfoEx );

                                    TDInfoEx = TempTDIEx;
                                    TotalCount++;

                                } else {

                                    NetApiBufferFree( TempTDIEx );
                                }
                            }

                            if ( Lop ) {

                                *Lop = L'$';
                            }
                        }

                        NetApiBufferFree( UserList );
                    }

                } while ( Win32Err == ERROR_MORE_DATA );
                if( FullServer != TrustInfo->Server )
                  NetApiBufferFree( FullServer );
            }

            //
            // If everything worked, then dump them all
            //
            if ( Win32Err == ERROR_SUCCESS ) {

                if ( TotalCount > 0 ) {

                    NetDompDisplayMessage( MSG_TRUST_DIRECT_HEADER );
                }

                for ( i = 0; i < TotalCount; i++ ) {

                    NetDompDumpTrustInfo( TrustInfo->DomainName->Buffer,
                                          &TDInfoEx[ i ] );

                }

            }

            NetDompFreeBuiltTrustInfo( TDInfoEx, TotalCount );

        } else {

            Win32Err = RtlNtStatusToDosError( Status );
        }


    }

    if ( Status == STATUS_NO_MORE_ENTRIES ) {

        Status = STATUS_SUCCESS;
    }

    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = RtlNtStatusToDosError( Status );
    }
    return( Win32Err );
}



DWORD
NetDompFindChildrenForNode(
    IN PWSTR LocalDomain,
    IN ULONG DomainCount,
    IN PDS_DOMAIN_TRUSTS DomainList,
    IN OUT PND5_TRANS_TREE_NODE TreeNode,
    IN OUT PND5_TRANS_TREE_NODE *DomainNode
    )
/*++

Routine Description:

    This recursive function will find all of the children for a given node in the trust list

Arguments:

    LocalDomain - Domain to find the children for

    DomainCount - Number of domains in the list

    DomainList - List of domains

    TreeNode - Tree to insert into

    DomainNode - Pointer to the LocalDomain's node, if encountered

Return Value:

    ERROR_SUCCESS - The function succeeded

    ERROR_INVALID_PARAMETER - No server, workstation or machine was specified

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    ULONG i, Count = 0;
    BOOL HandleDirect = FALSE;

    //
    // See how many
    //
    for ( i = 0; i < DomainCount; i++ ) {

        if ( DomainList[ i ].ParentIndex == TreeNode->ListIndex &&
             FLAG_ON( DomainList[ i ].Flags, DS_DOMAIN_IN_FOREST ) &&
             !FLAG_ON( DomainList[ i ].Flags, DS_DOMAIN_TREE_ROOT)) {

            Count++;
        }
    }

    //
    // If we have the current node, then make sure we get the direct trusts as well
    //
    if ( ( TreeNode->DomainInfo->DnsDomainName &&
           _wcsicmp( LocalDomain, TreeNode->DomainInfo->DnsDomainName ) == 0 ) ||
          _wcsicmp( LocalDomain, TreeNode->DomainInfo->NetbiosDomainName ) == 0 ) {

        HandleDirect = TRUE;
        *DomainNode = TreeNode;
        for ( i = 0; i < DomainCount; i++ ) {

            if ( FLAG_ON( DomainList[ i ].Flags, (DS_DOMAIN_DIRECT_OUTBOUND | DS_DOMAIN_DIRECT_INBOUND) ) &&
                 !FLAG_ON( DomainList[ i ].Flags, DS_DOMAIN_IN_FOREST ) &&
                 DomainList[ i ].ParentIndex == 0 ) {

                Count++;
            }
        }
    }

    //
    // Add 'em to the list
    //
    if ( Count ) {

        Win32Err = NetApiBufferAllocate( Count * sizeof( ND5_TRANS_TREE_NODE ),
                                         (PVOID*)&( TreeNode->ChildList ) );

        if ( Win32Err == ERROR_SUCCESS ) {

            RtlZeroMemory( TreeNode->ChildList, Count * sizeof( ND5_TRANS_TREE_NODE ) );
            for ( i = 0; i < DomainCount && Win32Err == ERROR_SUCCESS; i++ ) {

                if ( DomainList[ i ].ParentIndex == TreeNode->ListIndex &&
                     FLAG_ON( DomainList[ i ].Flags, DS_DOMAIN_IN_FOREST ) &&
                     !FLAG_ON( DomainList[ i ].Flags, DS_DOMAIN_TREE_ROOT) ) {

                    TreeNode->ChildList[ TreeNode->Children ].DomainInfo = &DomainList[ i ];
                    TreeNode->ChildList[ TreeNode->Children ].ListIndex = i;
                    TreeNode->ChildList[ TreeNode->Children ].Parent = TreeNode;
                    Win32Err = NetDompFindChildrenForNode( LocalDomain,
                                                           DomainCount,
                                                           DomainList,
                                                           &TreeNode->ChildList[ TreeNode->Children ],
                                                           DomainNode );
                    TreeNode->Children++;
                    DomainList[ i ].ParentIndex = 0xFFFFFFFF;
                }
            }

            //
            // Now, the other local entries
            //
            if ( Win32Err == ERROR_SUCCESS && HandleDirect ) {

                for ( i = 0; i < DomainCount; i++ ) {

                    if ( FLAG_ON( DomainList[ i ].Flags, (DS_DOMAIN_DIRECT_OUTBOUND | DS_DOMAIN_DIRECT_INBOUND) ) &&
                         !FLAG_ON( DomainList[ i ].Flags, DS_DOMAIN_IN_FOREST ) &&
                         DomainList[ i ].ParentIndex == 0 ) {

                        TreeNode->ChildList[ TreeNode->Children ].DomainInfo = &DomainList[ i ];
                        TreeNode->ChildList[ TreeNode->Children ].ListIndex = i;
                        TreeNode->Children++;
                        DomainList[ i ].ParentIndex = 0xFFFFFFFF;
                    }
                }
            }
        }
    }

    return( Win32Err );
}


DWORD
NetDompBuildTransTrustTree(
    IN PWSTR LocalDomain,
    IN ULONG DomainCount,
    IN PDS_DOMAIN_TRUSTS DomainList,
    OUT PND5_TRANS_TREE_NODE *TreeRoot,
    OUT PND5_TRANS_TREE_NODE *CurrentDomainNode
    )
/*++

Routine Description:

    This function will build the transative trust tree for the given trust list

Arguments:


    LocalDomain - Current domain

    DomainCount - Number of domains in the list

    DomainList - List of domains

    TreeRoot - Tree root

    CurrentDomainNode - Pointer to the LocalDomain's node

Return Value:

    ERROR_SUCCESS - The function succeeded

    ERROR_INVALID_PARAMETER - No server, workstation or machine was specified

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    PND5_TRANS_TREE_NODE Root = NULL, Temp = NULL, DomainNode = NULL;
    PDS_DOMAIN_TRUSTS TDRoot = NULL;
    ULONG i, Index;

    //
    // First, find the tree root.
    //
    for ( i = 0; i < DomainCount; i++ ) {

        if ( DomainList[ i ].ParentIndex == 0 &&
             FLAG_ON( DomainList[ i ].Flags, DS_DOMAIN_TREE_ROOT ) ) {

            TDRoot = &DomainList[ i ];
            Index = i;
            break;
        }
    }

    if ( TDRoot == NULL ) {

        //
        // Find ourselves, and make us the root
        //
        for ( i = 0; i < DomainCount; i++ ) {

            if ( ( DomainList[ i ].DnsDomainName &&
                   _wcsicmp( LocalDomain, DomainList[ i ].DnsDomainName ) == 0 ) ||
                  _wcsicmp( LocalDomain, DomainList[ i ].NetbiosDomainName ) == 0 ) {

                TDRoot = &DomainList[ i ];
                Index = i;
                break;
            }
        }
    }

    //
    // If we still don't have one, bail...
    //
    if ( TDRoot == NULL) {

        Win32Err = ERROR_INVALID_DOMAIN_STATE;
        goto BuildTransExit;

    }

    Win32Err = NetApiBufferAllocate( sizeof( ND5_TRANS_TREE_NODE ), (PVOID*)&Root );

    if ( Win32Err != ERROR_SUCCESS ) {

        goto BuildTransExit;
    }

    RtlZeroMemory( Root, sizeof( ND5_TRANS_TREE_NODE ) );
    Root->DomainInfo = TDRoot;
    Root->ListIndex = Index;
    TDRoot->ParentIndex = 0xFFFFFFFF;

    Win32Err = NetDompFindChildrenForNode( LocalDomain,
                                           DomainCount,
                                           DomainList,
                                           Root,
                                           &DomainNode );

BuildTransExit:

    if ( Win32Err == ERROR_SUCCESS ) {

        *TreeRoot = Root;
        *CurrentDomainNode = DomainNode;
    }

    return( Win32Err );
}



DWORD
NetDompGetTrustDirection(
    IN PND5_TRUST_INFO TrustingInfo,
    IN PND5_TRUST_INFO TrustedInfo,
    IN OUT PDWORD Direction
    )
/*++

Routine Description:

    This function will get the direction of the trust between the 2 specified domains

Arguments:


    TrustingInfo - Domain #1

    TrustedInfo - Domain #2

    Direction - Where the trust direction is returned

Return Value:

    ERROR_SUCCESS - The function succeeded

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    NTSTATUS Status;
    LSA_HANDLE TrustedDomain;
    PTRUSTED_DOMAIN_INFORMATION_EX TDIEx = NULL;
    PUSER_INFO_1 UI1 = NULL;
    WCHAR AccountName[ UNLEN + 1 ];


    if ( TrustingInfo->Uplevel ) {

        Status = LsaQueryTrustedDomainInfoByName( TrustingInfo->LsaHandle,
                                                  TrustedInfo->DomainName,
                                                  TrustedDomainInformationEx,
                                                  (PVOID*)&TDIEx );

        if (STATUS_OBJECT_NAME_NOT_FOUND == Status && TrustedInfo->Uplevel)
        {
            // Pre-existing TDOs for domains upgraded from NT4 to NT5 will continue to
            // have a flat name.
            //
            TrustedInfo->fWasDownlevel = TRUE;

            Status = LsaQueryTrustedDomainInfoByName( TrustingInfo->LsaHandle,
                                                      TrustedInfo->FlatName,
                                                      TrustedDomainInformationEx,
                                                      (PVOID*)&TDIEx );
        }
        if ( NT_SUCCESS( Status ) ) {

            DBG_VERBOSE(("Trust to domain %ws has direction %d\n", TrustedInfo->DomainName->Buffer,
                         TDIEx->TrustDirection));
            *Direction = TDIEx->TrustDirection;
            LsaFreeMemory( TDIEx );
        }

        Win32Err = RtlNtStatusToDosError( Status );

    } else {

        *Direction = 0;
        Status = LsaOpenTrustedDomain( TrustingInfo->LsaHandle,
                                       TrustedInfo->Sid,
                                       MAXIMUM_ALLOWED,
                                       &TrustedDomain );

        if ( Status != STATUS_OBJECT_NAME_NOT_FOUND ) {

            *Direction = TRUST_DIRECTION_OUTBOUND;
        }

        if ( NT_SUCCESS( Status ) ) {

            LsaClose( TrustedDomain );
        }

        if ( TrustedInfo->FlatName->Length > DNLEN * sizeof( WCHAR ) ) {

            Win32Err = ERROR_INVALID_DOMAINNAME;

        } else {


            //
            // Build the account name...
            //
            swprintf( AccountName, L"%ws$", TrustedInfo->FlatName->Buffer );

            Win32Err = NetUserGetInfo( TrustingInfo->Server,
                                       AccountName,
                                       1,
                                       ( LPBYTE * )&UI1 );

            if ( Win32Err != ERROR_NO_SUCH_USER ) {

                *Direction |= TRUST_DIRECTION_INBOUND;
            }

            if ( Win32Err == ERROR_SUCCESS ) {

                NetApiBufferFree( UI1 );
            }

        }

    }


    return( Win32Err );
}


/*++
DWORD
NetDompFindChildNode(
    IN PUNICODE_STRING ChildToFind,
    IN PND5_TRANS_TREE_NODE Current,
    IN PND5_TRANS_TREE_NODE Skip,
    IN ULONG Display,
    BOOL IncludeParent
    )

Routine Description:

    This function will find the child of the current node

Arguments:


    ChildToFind - Child domain to find

    Current - Where we are in the tree

    Skip - Node to not process if we are coming from our parent

    Display - Resource id of string to display

    IncludeParent - If TRUE, work up the tree as well as down

Return Value:

    ERROR_SUCCESS - The function succeeded

    ERROR_INVALID_PARAMETER - No server, workstation or machine was specified
{
    DWORD Win32Err = ERROR_NOT_FOUND;
    ULONG i;
    UNICODE_STRING CurrentDomain;
    BOOL Found = FALSE;

    if ( !Current ) {

        return( Win32Err );
    }



    for ( i = 0; i < Current->Children && !Found && Win32Err == ERROR_NOT_FOUND; i++ ) {

        RtlInitUnicodeString( &CurrentDomain,
                              Current->ChildList[ i ].DomainInfo->DnsDomainName ?
                                            Current->ChildList[ i ].DomainInfo->DnsDomainName :
                                            Current->ChildList[ i ].DomainInfo->NetbiosDomainName );
        if ( RtlCompareUnicodeString( &CurrentDomain,
                                      ChildToFind,
                                      TRUE ) == 0 ) {

            Found = TRUE;
            break;

        } else {

            if ( Skip != &Current->ChildList[ i ] ) {

                Win32Err = NetDompFindChildNode( ChildToFind,
                                                 &Current->ChildList[ i ],
                                                 NULL,
                                                 Display,
                                                 FALSE );
                if ( Win32Err == ERROR_SUCCESS ) {

                    break;

                }
            }
        }
    }

    if ( Win32Err == ERROR_NOT_FOUND && IncludeParent ) {

        if ( Current->Parent && !Found ) {

            RtlInitUnicodeString( &CurrentDomain,
                                  Current->Parent->DomainInfo->DnsDomainName ?
                                            Current->Parent->DomainInfo->DnsDomainName :
                                            Current->Parent->DomainInfo->NetbiosDomainName );
            if ( RtlCompareUnicodeString( &CurrentDomain,
                                          ChildToFind,
                                          TRUE ) == 0 ) {
                Found = TRUE;
            }
        }

        if ( !Found ) {

            Win32Err = NetDompFindChildNode( ChildToFind,
                                             Current->Parent,
                                             Current,
                                             Display,
                                             TRUE );
        }
    }

    if ( Win32Err == ERROR_SUCCESS && Display ) {

        NetDompDisplayMessage( Display,
                               CurrentDomain.Buffer );
    }

    if ( Found ) {

        Win32Err = ERROR_SUCCESS;

    }


    return( Win32Err );
}
--*/


DWORD
NetDompDisplayTransTrustStatus(
    IN PND5_TRUST_INFO TrustInfo,
    IN PWSTR DomainName,
    //IN PND5_TRANS_TREE_NODE CurrentDomain,
    IN DWORD Direction,
    IN DWORD TrustStatus
    )
/*++

Routine Description:

    This function will display the status for a trust

Arguments:

    TrustInfo - Trust info to display the status for

    DomainName - Name of the domain (if TrustInfo isn't available)

    CurrentDomain - Current domain node pointer

    Direction - Direction of the trust

    TrustStatus - Status code from verifying the trust

Return Value:

    ERROR_SUCCESS - The function succeeded

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    ULONG Message, Type;

    //
    // Display the direction & name
    //
    Type = Direction & TRUST_DIRECTION_BIDIRECTIONAL;

    switch ( Type ) {
    case 0:
        Message = MSG_TRUST_TRANS_NO_ARROW;
        break;

    case TRUST_DIRECTION_BIDIRECTIONAL:

        Message = MSG_TRUST_TRANS_BOTH_ARROW;
        break;

    case TRUST_DIRECTION_INBOUND:

        Message = MSG_TRUST_TRANS_IN_ARROW;
        break;

    case TRUST_DIRECTION_OUTBOUND:

        Message = MSG_TRUST_TRANS_OUT_ARROW;
        break;
    }

    NetDompDisplayMessage( Message, TrustInfo ? TrustInfo->DomainName->Buffer : DomainName );

    //
    // Then, the type
    //
    if (TrustInfo && TrustInfo->Flags & NETDOM_TRUST_TYPE_INDIRECT)
    {
        Message = MSG_TRUST_TYPE_INDIRECT;
    }
    else
    {
        if (TrustInfo && TrustInfo->Flags & NETDOM_TRUST_TYPE_MIT)
        {
            Message = MSG_TRUST_TYPE_MIT;
        }
        else
        {
            Message = MSG_TRUST_TYPE_WINDOWS;
        }
    }

    NetDompDisplayMessage( Message );

    //
    // Finally, the status.
    //
    if (TrustInfo && TrustInfo->Flags & NETDOM_TRUST_FLAG_DOMAIN_NOT_FOUND)
    {
        TrustStatus = ERROR_NO_SUCH_DOMAIN;
    }

    switch ( TrustStatus ) {
    case ERROR_SUCCESS:
        NetDompDisplayMessage( MSG_TRUST_VERIFIED );
        break;

    case ERROR_NO_SUCH_DOMAIN:
        NetDompDisplayMessage( MSG_TRUST_NO_DOMAIN );
        break;

    case ERROR_ACCESS_DENIED:
        NetDompDisplayMessage( MSG_TRUST_ACCESS_DENIED );
        break;

    case VERIFY_QUERY_ONLY:
        printf( "\n" );
        break;

    default:
        NetDompDisplayMessage( MSG_TRUST_BROKEN );
        break;

    }

    /* this doesn't work.
    if ( TrustInfo ) {

        Win32Err = NetDompFindChildNode( TrustInfo->DomainName,
                                         CurrentDomain,
                                         NULL,
                                         MSG_TRUST_VIA,
                                         TRUE );
    } */
    return( Win32Err );
}



DWORD
NetDompQueryTrust(
    IN PWSTR Domain,
    IN PND5_AUTH_INFO AuthInfo,
    IN PWSTR pwzServer,
    IN BOOL Direct,
    IN BOOL Verify
    )
/*++

Routine Description:

    This function will get the list of trusts for a domain

Arguments:

    Domain - Domain to get the trust for

    AuthInfo - Username and password to use to connect to the machine

    pwzServer - Server specified on command line, if any

    Direct - if TRUE, get only the DIRECTLY trusted domains

    Verify - If TRUE, verify that the trusts are valid

Return Value:

    ERROR_SUCCESS - The function succeeded

    ERROR_INVALID_PARAMETER - No server, workstation or machine was specified

--*/
{
    DWORD Win32Err = ERROR_SUCCESS, VerifyErr;
    ND5_TRUST_INFO TrustInfo, OtherInfo;
    ULONG Count = 0, i;
    PDS_DOMAIN_TRUSTS rgTrustedDomains = NULL;
    ULONG Message, Type, Direction;
    //PND5_TRANS_TREE_NODE TreeRoot = NULL, CurrentDomainNode;
    PWSTR CurrentDomain;
    RtlZeroMemory( &TrustInfo, sizeof( ND5_TRUST_INFO ) );

    Win32Err = NetDompTrustGetDomInfo( Domain,
                                       pwzServer,
                                       AuthInfo,
                                       &TrustInfo,
                                       FALSE,
                                       FALSE,
                                       FALSE);

    if ( Win32Err == ERROR_SUCCESS ) {

        if ( Direct || !TrustInfo.Uplevel ) {

            Win32Err = NetDompQueryDirectTrust( Domain,
                                                &TrustInfo );

        } else {

            Win32Err = DsEnumerateDomainTrusts(TrustInfo.Server,
                                               DS_DOMAIN_IN_FOREST | DS_DOMAIN_DIRECT_OUTBOUND | DS_DOMAIN_DIRECT_INBOUND,
                                               &rgTrustedDomains,
                                               &Count);

            if ( Win32Err == ERROR_SUCCESS ) {

                if ( Count ) {

                    NetDompDisplayMessage((Verify) ? MSG_TRUST_TRANS_HEADER_VERIFY :
                                                     MSG_TRUST_TRANS_HEADER);
                }

                /* this doesn't work.
                Win32Err = NetDompBuildTransTrustTree( Domain,
                                                       Count,
                                                       rgTrustedDomains,
                                                       &TreeRoot,
                                                       &CurrentDomainNode ); */

                if ( Win32Err == ERROR_SUCCESS ) {

                    for ( i = 0; i < Count; i++ ) {

                        //
                        // Make sure we aren't connecting to ourselves...
                        //
                        CurrentDomain = rgTrustedDomains[ i ].DnsDomainName ?
                                            rgTrustedDomains[ i ].DnsDomainName :
                                            rgTrustedDomains[ i ].NetbiosDomainName;
                        if ( !_wcsicmp( CurrentDomain, TrustInfo.DomainName->Buffer ) ) {

                            continue;
                        }

                        RtlZeroMemory(&OtherInfo, sizeof(ND5_TRUST_INFO));

                        if (rgTrustedDomains[i].Flags & DS_DOMAIN_DIRECT_OUTBOUND ||
                            rgTrustedDomains[i].Flags & DS_DOMAIN_DIRECT_INBOUND)
                        {
                            // There is a direct trust to the domain, therefore a TDO
                            // exists, so read the domain data locally.
                            //
                            Win32Err = GetTrustInfo(CurrentDomain,
                                                    &TrustInfo,
                                                    &OtherInfo,
                                                    &VerifyErr);

                            if (ERROR_SUCCESS == Win32Err)
                            {
                                VerifyErr = NetDompGetTrustDirection(&TrustInfo,
                                                                     &OtherInfo,
                                                                     &Direction);
                            }
                            else
                            {
                                Direction = 0;
                            }
                        }
                        else
                        {
                            Win32Err = NetDompTrustGetDomInfo(CurrentDomain,
                                                              NULL,
                                                              AuthInfo,
                                                              &OtherInfo,
                                                              FALSE,
                                                              FALSE, TRUE);
                            VerifyErr = Win32Err;
                            OtherInfo.Flags |= NETDOM_TRUST_TYPE_INDIRECT;
                            //
                            // If the trust is indirect, it must be a forest trust.
                            // Enterprise trusts always have a bi-di path.
                            //
                            Direction = TRUST_DIRECTION_BIDIRECTIONAL;
                        }

                        if (ERROR_SUCCESS == VerifyErr)
                        {
                            if (Verify
                                && !(NETDOM_TRUST_TYPE_MIT & OtherInfo.Flags)
                                && (DS_DOMAIN_DIRECT_OUTBOUND & rgTrustedDomains[i].Flags))
                            {
                                // Verify only direct, outbound, non-MIT trusts.
                                // Can't verify incoming without creds to the other
                                // domain.
                                //
                                VerifyErr = NetDompVerifyTrust(&TrustInfo,
                                                               &OtherInfo,
                                                               FALSE);
                            }
                            else
                            {
                                VerifyErr = VERIFY_QUERY_ONLY;
                            }

                            NetDompDisplayTransTrustStatus( &OtherInfo,
                                                            NULL,
                                                            //CurrentDomainNode,
                                                            Direction,
                                                            VerifyErr );

                            NetDompFreeDomInfo( &OtherInfo );

                        } else {

                            if ( !Verify ) {

                                VerifyErr = VERIFY_QUERY_ONLY;
                            }

                            NetDompDisplayTransTrustStatus( NULL,
                                                            rgTrustedDomains[ i ].DnsDomainName ?
                                                                rgTrustedDomains[ i ].DnsDomainName :
                                                                rgTrustedDomains[ i ].NetbiosDomainName,
                                                            //CurrentDomainNode,
                                                            Direction,
                                                            VerifyErr );
                        }
                    }
                }

                NetApiBufferFree( rgTrustedDomains );
            }
        }

        NetDompFreeDomInfo( &TrustInfo );
    }

    return( Win32Err );
}



DWORD
NetDompQueryDisplayOus(
    IN PWSTR Domain,
    IN PND5_AUTH_INFO AuthInfo
    )
/*++

Routine Description:

    This function will list the OUs under which the specified user can create a computer object

Arguments:

    Domain - Domain to connect to

    AuthInfo - Username and password to connect to the domain with

Return Value:

    ERROR_SUCCESS - The function succeeded

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    PWSTR *OuList;
    ULONG OuCount = 0, i;

    //
    // Get the list and display it
    //
    LOG_VERBOSE(( MSG_VERBOSE_DETERMINE_OU ));
    Win32Err = NetGetJoinableOUs( NULL,
                                  Domain,
                                  AuthInfo->User,
                                  AuthInfo->Password,
                                  &OuCount,
                                  &OuList );

    if ( Win32Err == ERROR_SUCCESS ) {

        NetDompDisplayMessage( MSG_OU_LIST );
        for ( i = 0; i < OuCount; i++ ) {

            printf( "%ws\n", OuList[ i ] );
        }
        NetApiBufferFree( OuList );
    }

    return( Win32Err );
}



DWORD
NetDompQueryFsmo(
    IN PWSTR Domain,
    IN PND5_AUTH_INFO AuthInfo
    )
/*++

Routine Description:

    This function will list the machines holding the various FSMO roles

Arguments:

    Domain - Domain to connect to

    AuthInfo - Username and password to connect to the domain with

Return Value:

    ERROR_SUCCESS - The function succeeded

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    PWSTR User = NULL, Separator = NULL, pwzDomain = NULL, FsmoServer = NULL, ServerPath;
    PDOMAIN_CONTROLLER_INFO DcInfo = NULL;
    HANDLE DsHandle = NULL;
    RPC_AUTH_IDENTITY_HANDLE AuthHandle;
    PDS_NAME_RESULT DsRoles = NULL;
    PLDAP Ldap = NULL;
    ULONG i;
    ULONG DisplayMap[ ] = {
        MSG_FSMO_SCHEMA,
        MSG_FSMO_DOMAIN,
        MSG_FSMO_PDC,
        MSG_FSMO_RID,
        MSG_FSMO_INFRASTRUCTURE
        };

    //
    // Find a domain controller
    //
    LOG_VERBOSE(( MSG_VERBOSE_FIND_DC, Domain ));
    Win32Err = DsGetDcName( NULL,
                            Domain,
                            NULL,
                            NULL,
                            DS_DIRECTORY_SERVICE_REQUIRED,
                            &DcInfo );

    if ( Win32Err == ERROR_SUCCESS ) {

        if ( AuthInfo->User ) {

            Separator = wcschr( AuthInfo->User, L'\\' );

            if ( Separator ) {

                *Separator = UNICODE_NULL;
                User = Separator + 1;

                if (!*User) {

                    return ERROR_INVALID_PARAMETER;
                }

                pwzDomain = AuthInfo->User;

            } else {

                User = AuthInfo->User;

                pwzDomain = Domain;
            }
        }

        Win32Err = DsMakePasswordCredentials( User,
                                              pwzDomain,
                                              AuthInfo->Password,
                                              &AuthHandle );

        if ( Win32Err == ERROR_SUCCESS ) {

            Win32Err = DsBindWithCred( DcInfo->DomainControllerName,
                                       NULL,
                                       AuthHandle,
                                       &DsHandle );

            DsFreePasswordCredentials( AuthHandle );
        }


        //
        // Now, start getting the info
        //
        if ( Win32Err == ERROR_SUCCESS ) {

            Win32Err = DsListRoles( DsHandle,
                                    &DsRoles );

            if ( Win32Err == ERROR_SUCCESS ) {

                ASSERT( sizeof( DisplayMap ) / sizeof( ULONG ) == DsRoles->cItems );
                for ( i = 0; i < sizeof( DisplayMap ) / sizeof( ULONG ); i++ ) {

                    ULONG Type = 0;
                    //
                    // Skip items that may not exist
                    //
                    if ( DsRoles->rItems[ i ].status != DS_NAME_NO_ERROR ) {

                        continue;
                    }

                    ServerPath = wcschr( DsRoles->rItems[ i ].pName, L',' );
                    if ( ServerPath ) {

                        ServerPath++;

                    } else {

                        ServerPath = DsRoles->rItems[ i ].pName;
                    }

                    if ( !Ldap ) {

                        Win32Err = NetDompLdapBind( DcInfo->DomainControllerName + 2,
                                                    User == AuthInfo->User ? NULL : AuthInfo->User,
                                                    User,
                                                    AuthInfo->Password,
                                                    LDAP_AUTH_SSPI,
                                                    &Ldap );
                    }

                    if ( Win32Err == ERROR_SUCCESS ) {

                        Win32Err = NetDompLdapReadOneAttribute( Ldap,
                                                                ServerPath,
                                                                L"dNSHostName",
                                                                &FsmoServer );

                        if ( Win32Err == ERROR_SUCCESS ) {

                            NetDompDisplayMessage( DisplayMap[ i ], FsmoServer );
                            NetApiBufferFree( FsmoServer );
                        }
                    }
                }
            }
        }

    }

    if ( DsHandle ) {

        DsUnBind( &DsHandle );
    }

    if ( DsRoles ) {

        DsFreeNameResult( DsRoles );
    }

    if ( Separator ) {

        *Separator = L'\\';
    }

    NetApiBufferFree( DcInfo );
    return( Win32Err );
}



DWORD
NetDompDisplayMachineByType(
    IN PWSTR AccountName,
    IN PND5_AUTH_INFO AuthInfo,
    IN ND5_ACCOUNT_TYPE DesiredType,
    IN ND5_ACCOUNT_TYPE KnownType,
    IN BOOL DisplayOnError
    )
/*++

Routine Description:

    This function display machines of the specified type that are joined to the domain

Arguments:

    AccountName - Name of the machine to get the info from

    AuthInfo - Username and password to connect to the domain with

    DesiredType - Type of machine to get

    KnownType - Whether the machine type is known or not

    DisplayOnError - If TRUE, display a message if an error is encountered

Return Value:

    ERROR_SUCCESS - The function succeeded

    ERROR_UNSUPPORTED_TYPE - An unknown type was encountered

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    PSERVER_INFO_101 SrvInfo = NULL;
    PWSTR AccountChar;


    AccountChar = wcsrchr( AccountName, L'$' );
    if ( AccountChar ) {

        *AccountChar = UNICODE_NULL;
    }

    //
    // See if we have to get the type or not
    //
    if ( KnownType == TypeUnknown ) {

        Win32Err = NetpManageIPCConnect( AccountName,
                                         AuthInfo->User,
                                         AuthInfo->Password,
                                         NETSETUPP_CONNECT_IPC );

        if ( Win32Err == ERROR_SUCCESS ) {

            Win32Err = NetServerGetInfo( AccountName,
                                         101,
                                         ( LPBYTE * )&SrvInfo );

            NetpManageIPCConnect( AccountName,
                                  AuthInfo->User,
                                  AuthInfo->Password,
                                  NETSETUPP_DISCONNECT_IPC );
        }

        if ( Win32Err == ERROR_SUCCESS ) {

            if ( FLAG_ON( SrvInfo->sv101_type, SV_TYPE_DOMAIN_BAKCTRL ) ) {

                KnownType = TypeDomainController;

            } else if ( FLAG_ON( SrvInfo->sv101_type, SV_TYPE_DOMAIN_CTRL ) ) {

                if ( DesiredType == TypeDomainController ) {

                    KnownType = TypeDomainController;

                } else {

                    KnownType = TypePDC;
                }

            } else if ( FLAG_ON( SrvInfo->sv101_type, SV_TYPE_WORKSTATION ) ) {

                KnownType = TypeWorkstation;

            } else {

                Win32Err = ERROR_UNSUPPORTED_TYPE;
            }


        } else {

            LOG_VERBOSE(( MSG_VERBOSE_FAIL_MACH_TYPE, AccountName ));
            ERROR_VERBOSE(( Win32Err ));

            if ( DisplayOnError ) {

                KnownType = DesiredType;

            }
        }

    }

    if ( KnownType == DesiredType && ( Win32Err == ERROR_SUCCESS || DisplayOnError ) ) {

        if ( Win32Err != ERROR_SUCCESS ) {

            NetDompDisplayMessage( MSG_WKSTA_OR_SERVER, AccountName );
            Win32Err = ERROR_SUCCESS;

        } else {

            printf( "%ws\n", AccountName );
        }
    }

    return( Win32Err );
}


DWORD
NetDompQueryMachines(
    IN ND5_ACCOUNT_OPERATION Operation,
    IN PWSTR Domain,
    IN PND5_AUTH_INFO AuthInfo,
    IN PWSTR pwzServer,
    IN ND5_ACCOUNT_TYPE AccountType,
    IN ULONG MessageId
    )
/*++

Routine Description:

    This function will list the machines in a domian

Arguments:

    Operation - Whether to display/verify/reset the machines

    Domain - Domain to connect to

    AuthInfo - Username and password to connect to the domain with

    pwzServer - Optional server name specified on command line, must be NULL for PDC operation.

    AccountType - Type of accounts to display

    MessageId - Resource ID of string to display

Return Value:

    ERROR_SUCCESS - The function succeeded

--*/
{
    DWORD Win32Err = ERROR_SUCCESS, Win32Err2;
    PWSTR pwzUncServer = NULL, Lop, pwzUser = NULL, pwzDomain = NULL;
    BOOL Connected = FALSE, fDsDcInfoAllocated = FALSE, fFreeServer = FALSE;
    ULONG Type = 0;
    PDOMAIN_CONTROLLER_INFO DcInfo = NULL;
    ULONG AccountTypeMap[] = {
        FILTER_WORKSTATION_TRUST_ACCOUNT,
        FILTER_WORKSTATION_TRUST_ACCOUNT,
        FILTER_SERVER_TRUST_ACCOUNT,
        FILTER_SERVER_TRUST_ACCOUNT,
        FILTER_WORKSTATION_TRUST_ACCOUNT
        };
    LPUSER_INFO_0 UserList = NULL;
    ULONG ResumeHandle = 0, Count = 0, TotalCount = 0, i;
    ULONG DsGetDcOptions = DS_DIRECTORY_SERVICE_PREFERRED;
    PDS_DOMAIN_CONTROLLER_INFO_1 pDsDcInfo;

    if ( AccountType == TypeUnknown ) {

        return( ERROR_INVALID_PARAMETER );
    }

    if (!pwzServer)
    {
        if ( AccountType == TypePDC ) {

            DsGetDcOptions |= DS_PDC_REQUIRED;
        }

        LOG_VERBOSE(( MSG_VERBOSE_FIND_DC, Domain ));
        Win32Err = DsGetDcName( NULL,
                                Domain,
                                NULL,
                                NULL,
                                DsGetDcOptions,
                                &DcInfo );

        if (ERROR_SUCCESS != Win32Err)
        {
            return Win32Err;
        }

        if (AccountType == TypePDC)
        {
            NetDompDisplayMessage( MessageId );
            NetDompDisplayMachineByType( DcInfo->DomainControllerName + 2,
                                         AuthInfo,
                                         TypePDC,
                                         TypePDC,
                                         TRUE );
            goto QueryMachinesExit;
        }

        pwzUncServer = DcInfo->DomainControllerName;
    }
    else
    {
        // Server supplied on the command line. See if it has the needed backslashes.
        //
        if (L'\\' == *pwzServer)
        {
            if (wcslen(pwzServer) < 3 || L'\\' != pwzServer[1])
            {
                return ERROR_INVALID_PARAMETER;
            }

            pwzUncServer = pwzServer;
        }
        else
        {
            Win32Err = NetApiBufferAllocate((wcslen(pwzServer) + 3) * sizeof(WCHAR),
                                            (PVOID*)&pwzUncServer);

            if (ERROR_SUCCESS != Win32Err)
            {
                return Win32Err;
            }

            wsprintf(pwzUncServer, L"\\\\%s", pwzServer);

            fFreeServer = TRUE;
        }
    }

    LOG_VERBOSE(( MSG_VERBOSE_ESTABLISH_SESSION, pwzUncServer ));
    Win32Err = NetpManageIPCConnect( pwzUncServer,
                                     AuthInfo->User,
                                     AuthInfo->Password,
                                     NETSETUPP_CONNECT_IPC );

    if ( Win32Err == ERROR_SUCCESS ) {

        Connected = TRUE;
    }
    else {

        goto QueryMachinesExit;
    }

    NetDompDisplayMessage( MessageId );

    //
    // Now, do the enumeration
    //

    if (TypeDomainController == AccountType) {
        HANDLE hDS;
        RPC_AUTH_IDENTITY_HANDLE hID;

        if (AuthInfo->User) {

            pwzUser = wcschr(AuthInfo->User, L'\\');

            if (pwzUser) {
                //
                // backslash found, replace with NULL and point to next char.
                //
                *pwzUser = UNICODE_NULL;

                pwzUser++;

                if (!*pwzUser) {

                    return ERROR_INVALID_PARAMETER;
                }

                pwzDomain = AuthInfo->User;
            }
            else {

                pwzUser = AuthInfo->User;

                pwzDomain = Domain;
            }
        }

        Win32Err = DsMakePasswordCredentials( pwzUser,
                                              pwzDomain,
                                              AuthInfo->Password,
                                              &hID);
        if ( Win32Err != ERROR_SUCCESS ) {
            goto QueryMachinesExit;
        }

        Win32Err = DsBindWithCred(pwzUncServer, NULL, hID, &hDS);

        DsFreePasswordCredentials(hID);

        if ( Win32Err == ERROR_SUCCESS ) {

            Win32Err = DsGetDomainControllerInfo(hDS, Domain, 1, &Count, (PVOID*)&pDsDcInfo);

            DsUnBind(&hDS);

            if ( Win32Err != ERROR_SUCCESS ) {
                goto QueryMachinesExit;
            }

            fDsDcInfoAllocated = TRUE;

            for ( i = 0; i < Count; i++ ) {

                switch ( Operation ) {
                case OperationDisplay:

                    //
                    // Ignore errors from this function
                    //
                    NetDompDisplayMachineByType( pDsDcInfo[ i ].NetbiosName,
                                                 AuthInfo,
                                                 TypeDomainController,
                                                 TypeDomainController,
                                                 TRUE );
                    break;

                case OperationVerify:

                    Win32Err2 = NetDompVerifyServerSC( Domain,
                                                       pDsDcInfo[ i ].NetbiosName,
                                                       AuthInfo,
                                                       MSG_QUERY_VERIFY_OK,
                                                       0 );
                    if ( Win32Err2 != ERROR_SUCCESS ) {

                        NetDompDisplayMessageAndError( MSG_QUERY_VERIFY_BAD,
                                                       Win32Err2,
                                                       pDsDcInfo[ i ].NetbiosName );
                    }
                    break;

                case OperationReset:

                    Win32Err2 = NetDompResetServerSC( Domain,
                                                      pDsDcInfo[ i ].NetbiosName,
                                                      NULL,
                                                      AuthInfo,
                                                      MSG_QUERY_VERIFY_OK,
                                                      0 );
                    if ( Win32Err2 != ERROR_SUCCESS ) {

                        NetDompDisplayMessageAndError( MSG_QUERY_VERIFY_BAD,
                                                       Win32Err2,
                                                       pDsDcInfo[ i ].NetbiosName );
                    }
                    break;

                default:
                    Win32Err2 = ERROR_INVALID_PARAMETER;
                    break;
                }
            }

            goto QueryMachinesExit;
        }
        else {
            // DsBind will return EPT_S_NOT_REGISTERED if a downlevel DC is targetted.
            // If so, fall through to the NetUserEnum code.
            //
            if (EPT_S_NOT_REGISTERED != Win32Err) {
                goto QueryMachinesExit;
            }
        }
    }

    do {

        Win32Err = NetUserEnum( pwzUncServer,
                                0,
                                AccountTypeMap[ AccountType ],
                                ( LPBYTE * )&UserList,
                                MAX_PREFERRED_LENGTH,
                                &Count,
                                &TotalCount,
                                &ResumeHandle );

        if ( Win32Err == ERROR_SUCCESS || Win32Err == ERROR_MORE_DATA ) {

            for ( i = 0; i < Count; i++ ) {

                switch ( Operation ) {
                case OperationDisplay:

                    //
                    // Ignore errors from this function
                    //
                    NetDompDisplayMachineByType( UserList[ i ].usri0_name,
                                                 AuthInfo,
                                                 AccountType,
                                                 TypeUnknown,
                                                 TRUE );
                    break;

                case OperationVerify:

                    Lop = wcsrchr( UserList[ i ].usri0_name, L'$' );
                    if ( Lop ) {

                        *Lop = UNICODE_NULL;
                    }
                    Win32Err2 = NetDompVerifyServerSC( Domain,
                                                       UserList[ i ].usri0_name,
                                                       AuthInfo,
                                                       MSG_QUERY_VERIFY_OK,
                                                       0 );
                    if ( Win32Err2 != ERROR_SUCCESS ) {

                        NetDompDisplayMessageAndError( MSG_QUERY_VERIFY_BAD,
                                                       Win32Err2,
                                                       UserList[ i ].usri0_name );
                    }

                    if ( Lop ) {

                        *Lop = L'$';
                    }
                    break;

                case OperationReset:
                    Lop = wcsrchr( UserList[ i ].usri0_name, L'$' );
                    if ( Lop ) {

                        *Lop = UNICODE_NULL;
                    }
                    Win32Err2 = NetDompResetServerSC( Domain,
                                                      UserList[ i ].usri0_name,
                                                      NULL,
                                                      AuthInfo,
                                                      MSG_QUERY_VERIFY_OK,
                                                      0 );
                    if ( Win32Err2 != ERROR_SUCCESS ) {

                        NetDompDisplayMessageAndError( MSG_QUERY_VERIFY_BAD,
                                                       Win32Err2,
                                                       UserList[ i ].usri0_name );
                    }

                    if ( Lop ) {

                        *Lop = L'$';
                    }
                    break;

                default:
                    Win32Err2 = ERROR_INVALID_PARAMETER;
                    break;

                }

            }

            NetApiBufferFree( UserList );
        }

    } while ( Win32Err == ERROR_MORE_DATA );

QueryMachinesExit:

    if ( Connected ) {

        LOG_VERBOSE(( MSG_VERBOSE_DELETE_SESSION, pwzUncServer ));
        NetpManageIPCConnect( pwzUncServer,
                              NULL,
                              NULL,
                              NETSETUPP_DISCONNECT_IPC );

    }

    if (fFreeServer)
    {
        NetApiBufferFree(pwzUncServer);
    }
    if (fDsDcInfoAllocated)
    {
        DsFreeDomainControllerInfo(1, Count, pDsDcInfo);
    }
    if (DcInfo)
    {
        NetApiBufferFree(DcInfo);
    }
    return( Win32Err );
}



DWORD
NetDompHandleQuery(ARG_RECORD * rgNetDomArgs)
/*++

Routine Description:

    This function will move a machine from one domain to another

Arguments:

    Args - List of command line arguments

Return Value:

    ERROR_INVALID_PARAMETER - No object name was supplied

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    PWSTR Domain = NULL, Server = NULL;
    ND5_AUTH_INFO DomainUser;
    ND5_ACCOUNT_OPERATION Operation = OperationDisplay;
    ULONG DisplayFlag = 0;

    RtlZeroMemory( &DomainUser, sizeof( ND5_AUTH_INFO ) );

    Win32Err = NetDompValidateSecondaryArguments(rgNetDomArgs,
                                                 eQueryPDC,
                                                 eQueryServer,
                                                 eQueryWksta,
                                                 eQueryDC,
                                                 eQueryOU,
                                                 eQueryFSMO,
                                                 eQueryTrust,
                                                 eCommDomain,
                                                 eCommUserNameD,
                                                 eCommPasswordD,
                                                 eCommServer,
                                                 eCommReset,
                                                 eQueryDirect,
                                                 eCommVerbose,
                                                 eCommVerify,
                                                 eArgEnd);
    if ( Win32Err != ERROR_SUCCESS ) {

        DisplayHelp(ePriQuery);
        return Win32Err;
    }

    //
    // Get the server name
    //
    Win32Err = NetDompGetArgumentString(rgNetDomArgs,
                                        eCommServer,
                                        &Server);
    if ( Win32Err != ERROR_SUCCESS ) {

        goto HandleQueryExit;
    }


    //
    // Ok, make sure that we have a specified domain...
    //
    Win32Err = NetDompGetDomainForOperation(rgNetDomArgs,
                                            Server,
                                            TRUE,
                                            &Domain);

    if ( Win32Err != ERROR_SUCCESS ) {

        goto HandleQueryExit;
    }

    //
    // Get the password and user if it exists
    //
    if ( CmdFlagOn(rgNetDomArgs, eCommUserNameD) ) {

        Win32Err = NetDompGetUserAndPasswordForOperation(rgNetDomArgs,
                                                         eCommUserNameD,
                                                         Domain,
                                                         &DomainUser);

        if ( Win32Err != ERROR_SUCCESS ) {

            goto HandleQueryExit;
        }
    }

    //
    // Find the query sub command.
    //
    NETDOM_ARG_ENUM eQuery = eArgNull;

    for (int i = eQueryBegin; i <= eQueryEnd; i++)
    {
        if (CmdFlagOn(rgNetDomArgs, static_cast<NETDOM_ARG_ENUM>(i)))
        {
            if (eArgNull != eQuery)
            {
               ASSERT(rgNetDomArgs[i].strArg1);
               NetDompDisplayUnexpectedParameter(rgNetDomArgs[i].strArg1);
               DisplayHelp(ePriQuery);
               Win32Err = ERROR_INVALID_PARAMETER;
               goto HandleQueryExit;
            }
            eQuery = static_cast<NETDOM_ARG_ENUM>(i);
        }
    }

    if (eArgNull == eQuery)
    {
        DisplayHelp(ePriQuery);
        Win32Err = ERROR_INVALID_PARAMETER;
        goto HandleQueryExit;
    }

    if ( CmdFlagOn(rgNetDomArgs, eCommVerify) ) {

        Operation = OperationVerify;
        DisplayFlag = MSG_QUERY_VERIFY;

    }

    if ( CmdFlagOn(rgNetDomArgs, eCommReset) ) {

        if ( Operation == OperationVerify ) {

            Win32Err = ERROR_INVALID_PARAMETER;
            goto HandleQueryExit;

        } else {

            Operation = OperationReset;
            DisplayFlag = MSG_QUERY_RESET;
        }
    }

    switch (eQuery)
    {
    case eQueryOU:

        Win32Err = NetDompQueryDisplayOus( Domain,
                                           &DomainUser );
        break;

    case eQueryWksta:

        Win32Err = NetDompQueryMachines( Operation,
                                         Domain,
                                         &DomainUser,
                                         Server,
                                         TypeWorkstation,
                                         DisplayFlag ? DisplayFlag : MSG_WORKSTATION_LIST );
        break;

    case eQueryServer:

        Win32Err = NetDompQueryMachines( Operation,
                                         Domain,
                                         &DomainUser,
                                         Server,
                                         TypeServer,
                                         DisplayFlag ? DisplayFlag : MSG_SERVER_LIST );
        break;

    case eQueryDC:

        Win32Err = NetDompQueryMachines( Operation,
                                         Domain,
                                         &DomainUser,
                                         Server,
                                         TypeDomainController,
                                         DisplayFlag ? DisplayFlag : MSG_DC_LIST );
        break;

    case eQueryPDC:

        Win32Err = NetDompQueryMachines( Operation,
                                         Domain,
                                         &DomainUser,
                                         NULL,
                                         TypePDC,
                                         MSG_PDC_LIST );
        break;

    case eQueryFSMO:

        Win32Err = NetDompQueryFsmo( Domain,
                                     &DomainUser );
        break;

    case eQueryTrust:

        if (CmdFlagOn(rgNetDomArgs, eQueryDirect) &&
            CmdFlagOn(rgNetDomArgs, eCommVerify))
        {
            DisplayHelp(ePriQuery);
            Win32Err = ERROR_INVALID_PARAMETER;
            goto HandleQueryExit;
        }

        Win32Err = NetDompQueryTrust( Domain,
                                      &DomainUser,
                                      Server,
                                      CmdFlagOn(rgNetDomArgs, eQueryDirect),
                                      CmdFlagOn(rgNetDomArgs, eCommVerify));
        break;

    default:
        Win32Err = ERROR_INVALID_PARAMETER;
        break;
    }



HandleQueryExit:
    NetApiBufferFree( Domain );
    NetApiBufferFree( Server );
    NetDompFreeAuthIdent( &DomainUser );

    if (NO_ERROR != Win32Err)
    {
        NetDompDisplayErrorMessage(Win32Err);
    }

    return( Win32Err );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netdom\varg.cxx ===
/*****************************************************************************\

    Author: Hiteshr
    Copyright (c) 1998-2000 Microsoft Corporation
    Change History:
    Adapted From Parser Implemenation of Corey Morgan
\*****************************************************************************/

#include "pch.h"
#pragma hdrstop
#include <netdom.h>

BOOL ValidateCommands(IN ARG_RECORD *Commands,OUT PPARSE_ERROR pError);

//General Utility Functions
DWORD ResizeByTwo(PTSTR *ppBuffer, LONG *pSize);
BOOL StringCopy(PWSTR *ppDest, PCWSTR pSrc);

LONG ReadFromIn(PWSTR *ppBuffer);

#define INIT_SIZE 1024

#define FILL_ERROR(pError,source,error_code,rec_index,argv_index) \
pError->ErrorSource = source;         \
pError->Error = error_code;           \
pError->ArgRecIndex = rec_index;      \
pError->ArgvIndex = argv_index;

BOOL IsCmd( PARG_RECORD arg, LPTOKEN pToken)
{
    if (!arg || !pToken)
        return FALSE;    
    
    LPWSTR str = pToken->GetToken();

    if (!str)
        return FALSE;

    if (pToken->IsSwitch())
    {
       if (arg->fFlag & ARG_FLAG_VERB)
       {
          // Verbs do not have a switch.
          //
          return FALSE;
       }
       str++;
    }
    else
    {
       if ((arg->fFlag & ARG_FLAG_OBJECT) && !arg->bDefined)
       {
          return TRUE;
       }
       if (!(arg->fFlag & ARG_FLAG_VERB))
       {
          // Non-verbs must have a switch except for the object arg.
          //
          return FALSE;
       }
    }

    if ( ( arg->strArg1 && !_wcsicmp( str, arg->strArg1 ) )
        ||(arg->strArg2 && !_wcsicmp( str, arg->strArg2 )) )
    {
       return TRUE;
    }
    return FALSE;
}



void FreeCmd(ARG_RECORD *Commands)
{
    int i;
    for(i=0;Commands[i].fType != ARG_TYPE_LAST;i++)
    {
        if((Commands[i].fType == ARG_TYPE_STR || 
            Commands[i].fType == ARG_TYPE_MSZ ) && 
            Commands[i].bDefined )
        {                       
            LocalFree( Commands[i].strValue );
            Commands[i].strValue = NULL;
        }
        if( Commands[i].idArg1 && Commands[i].strArg1 != NULL )
        {
            LocalFree(Commands[i].strArg1);
        }
        if( Commands[i].idArg2 && Commands[i].strArg2 != NULL )
        {
            LocalFree( Commands[i].strArg2  );
        }
        Commands[i].bDefined = FALSE;
    }
}

BOOL LoadCmd(ARG_RECORD *Commands)
{
    int i;
    BOOL bRet = TRUE;
    for (i=0; Commands[i].fType!=ARG_TYPE_LAST; i++)
    {
        if (Commands[i].idArg1 !=0)
            if (!LoadStringAlloc(&Commands[i].strArg1, NULL, Commands[i].idArg1))
            {
                bRet = FALSE;
                break;   
            }                
        if (Commands[i].idArg2 !=0 && Commands[i].idArg2 != ID_ARG2_NULL)
            if (!LoadStringAlloc(&Commands[i].strArg2, NULL, Commands[i].idArg2))
            {
                bRet = FALSE;
                break;
            }
    }   
    return bRet;
}
           
BOOL
ValidateCommands(ARG_RECORD *Commands, PPARSE_ERROR pError)
{
    int i = 0;
    LONG cReadFromStdin = 0;
    ARG_RECORD *CommandsIn = NULL;
    LPWSTR pBuffer=NULL;    
    LONG BufferLen = 0;
    LPTOKEN pToken = NULL;   
    int argc=0;
    BOOL bRet = FALSE;

    bool bAtLeastOne = false;
    bool bAtLeastOneDefined = false;

    if(!Commands || !pError)
        goto exit_gracefully;
    
    for(i=0; Commands[i].fType != ARG_TYPE_LAST;i++)
    {
        if( (Commands[i].fFlag & ARG_FLAG_REQUIRED) && !Commands[i].bDefined)
        {
            if(Commands[i].fFlag & ARG_FLAG_STDIN)
            {
                cReadFromStdin++;
            }
            else
            {
                FILL_ERROR(pError,
                           ERROR_FROM_PARSER,
                           PARSE_ERROR_SWITCH_NOTDEFINED,
                           i,
                           -1);
                goto exit_gracefully;
            }
        }

        if (Commands[i].fFlag & ARG_FLAG_ATLEASTONE)
        {
            bAtLeastOne = true;
 
            if (Commands[i].bDefined)
            {
                bAtLeastOneDefined = true;
            }
        }
    }

    if (bAtLeastOne && !bAtLeastOneDefined)
    {
       FILL_ERROR(pError, ERROR_FROM_PARSER,
                  PARSE_ERROR_ATLEASTONE_NOTDEFINED, -1, -1)
       goto exit_gracefully;
    }

    if(!cReadFromStdin)
    {   
        bRet = TRUE;
        goto exit_gracefully;
    }

    //Read From STDIN
    BufferLen = ReadFromIn(&pBuffer);  
    if(BufferLen == -1)
    {
        FILL_ERROR(pError,
                   ERROR_WIN32_ERROR,
                   GetLastError(),
                   -1,
                   -1);
        goto exit_gracefully;
    }

    if(BufferLen == 0)
    {
        for(i=0; Commands[i].fType != ARG_TYPE_LAST;i++)
        {
            if( (Commands[i].fFlag & ARG_FLAG_REQUIRED) && !Commands[i].bDefined)
            {
                FILL_ERROR(pError,
                           ERROR_FROM_PARSER,
                           PARSE_ERROR_SWITCH_NOTDEFINED,
                           i,
                           -1);
                goto exit_gracefully;
            }
        }
    }
    
    if(BufferLen)
    {
        //Tokenize what you have read from STDIN
        DWORD dwErr;
        WCHAR szDelimiters[] = L": \n\t";
        dwErr = Tokenize(pBuffer,
                         BufferLen,
                         szDelimiters,
                         &pToken,
                         &argc);
        if( dwErr != ERROR_SUCCESS )
        {
            FILL_ERROR(pError,
                       ERROR_WIN32_ERROR,
                       dwErr,
                       -1,
                       -1);
            goto exit_gracefully;
        }

        //Prepare a CommandArray for them
        CommandsIn = (ARG_RECORD*)LocalAlloc(LPTR,sizeof(ARG_RECORD)*(cReadFromStdin+1));
        if(!CommandsIn)
        {
            FILL_ERROR(pError,
                       ERROR_WIN32_ERROR,
                       ERROR_NOT_ENOUGH_MEMORY,
                       -1,
                       -1);
            goto exit_gracefully;
        }
        int j;
        j = 0;
        for(i=0; Commands[i].fType != ARG_TYPE_LAST;i++)
        {
            if((Commands[i].fFlag & ARG_FLAG_REQUIRED) && 
               (Commands[i].fFlag & ARG_FLAG_STDIN) &&
               !Commands[i].bDefined)
            {
                CommandsIn[j++] = Commands[i];        
            }
        }
        //Copy the Last One
        CommandsIn[j] = Commands[i];


        if(!ParseCmd(CommandsIn,
                    argc,
                    pToken,
                    false,
                    pError,
                    FALSE))
        {        
            goto exit_gracefully;
        }
       
        //Copy the values back to Commands
        j=0;
        for(i=0; Commands[i].fType != ARG_TYPE_LAST;i++)
        {
            if((Commands[i].fFlag & ARG_FLAG_REQUIRED) && 
               (Commands[i].fFlag & ARG_FLAG_STDIN) &&
               !Commands[i].bDefined)
            {
                Commands[i] = CommandsIn[j++];        
            }
        }
        
        //Validate Commands
        for(i=0; Commands[i].fType != ARG_TYPE_LAST;i++)
        {
            if( (Commands[i].fFlag & ARG_FLAG_REQUIRED) && !Commands[i].bDefined)
            {
                FILL_ERROR(pError,
                           ERROR_FROM_PARSER,
                           PARSE_ERROR_SWITCH_NOTDEFINED,
                           i,
                           -1);
                goto exit_gracefully;
            }
        }

    }   
    bRet = TRUE;
exit_gracefully:
    if(CommandsIn)
        LocalFree(CommandsIn);
    if(pBuffer)
        LocalFree(pBuffer);
    if(pToken)
    {
       delete []pToken;
    }
    return bRet;
}


BOOL ParseCmd(IN ARG_RECORD *Commands,
              IN int argc, 
              IN LPTOKEN pToken,
              IN bool fSkipObject, 
              OUT PPARSE_ERROR pError,
              IN BOOL bValidate)
{
    int i = 0;
    BOOL bFound = FALSE;
    int argCount = 0;
    DWORD dwErr = ERROR_SUCCESS;

    if (!Commands || argc == 0 || !pToken || !pError)
        return FALSE;

    argCount = argc;

    while (argc > 0)
    {
        bFound = FALSE;

        for (i = 0; Commands[i].fType != ARG_TYPE_LAST && (!bFound); i++)
        {
            if (fSkipObject && Commands[i].fFlag & ARG_FLAG_OBJECT)
            {
               continue;
            }
            if (IsCmd(&Commands[i], pToken))
            {
                if (Commands[i].bDefined)
                {
                    FILL_ERROR(pError,
                               ERROR_FROM_PARSER,
                               PARSE_ERROR_MULTIPLE_DEF,
                               i,
                               -1);
                    return FALSE;
                }

                if (pToken->IsSwitch())
                {
                    pToken++;
                    argc--;
                }

                bFound = TRUE;

                Commands[i].bDefined = TRUE;

                switch( Commands[i].fType )
                {
                case ARG_TYPE_HELP:
                    Commands[i].bValue = TRUE;
                    if( Commands[i].fntValidation != NULL )
                    {
                        Commands[i].fntValidation( Commands + i );
                    }
                    FILL_ERROR(pError,
                               ERROR_FROM_PARSER,
                               PARSE_ERROR_HELP_SWITCH,
                               i,
                               -1);
                    return FALSE;
                    break;

                case ARG_TYPE_INT:
                    if( argc > 0 && !pToken->IsSwitch())
                    {
                        PWSTR pszToken = pToken->GetToken();
                        Commands[i].nValue = _wtoi( pszToken);
                        if (Commands[i].nValue == 0 &&
                            !iswdigit(pszToken[0]))
                        {
                           FILL_ERROR(pError,
                                      ERROR_FROM_PARSER,
                                      PARSE_ERROR_SWITCH_VALUE,
                                      i,
                                      argCount - argc);
                           return FALSE;
                        }
                        pToken++;
                        argc--;
                    }
                    else if ( !(Commands[i].fFlag & ARG_FLAG_DEFAULTABLE) )
                    {
                        FILL_ERROR(pError,
                                   ERROR_FROM_PARSER,
                                   PARSE_ERROR_SWITCH_VALUE,
                                   i,
                                   argCount - argc);
                        return FALSE;
                    }
                    break;

                case ARG_TYPE_VERB:
                    //
                    // Verbs are not proceeded by a switch character.
                    //
                    pToken++;
                    argc--;
                    // fall through.
                case ARG_TYPE_BOOL:
                    //
                    // Bools are proceeded by a switch char (and had the token
                    // pointer advanced above).
                    //
                    Commands[i].bValue = TRUE;
                    break;

                case ARG_TYPE_MSZ:
                    if (argc > 0 && !pToken->IsSwitch())
                    {
                        PWSTR buffer = (PWSTR)LocalAlloc(LPTR, MAXSTR*sizeof(WCHAR));
                        LONG maxSize = MAXSTR;
                        LONG currentSize = 0;
                        LONG len = 0;
                        if (!buffer)
                        {
                            FILL_ERROR(pError,
                                       ERROR_WIN32_ERROR,
                                       ERROR_NOT_ENOUGH_MEMORY,
                                       -1,
                                       argCount - argc);
                            return FALSE;
                        }
                        LPCTSTR pszTemp = pToken->GetToken();
                        len = wcslen(pszTemp);
                        //-2 as last string is delimited by two null
                        while ((currentSize + len) > (maxSize - 2))
                        {                            
                            dwErr = ResizeByTwo(&buffer, &maxSize);
                            if (dwErr != ERROR_SUCCESS)
                            {
                                FILL_ERROR(pError,
                                           ERROR_WIN32_ERROR,
                                           dwErr,
                                           i,
                                           -1);
                                return FALSE;
                            }
                        }
                        wcscpy((buffer + currentSize), pszTemp);
                        currentSize += len;
                        //Null Terminate, buffer is initialized to zero
                        currentSize++;
                        pToken++;
                        argc--;
                        while (argc > 0 && !pToken->IsSwitch())
                        {
                            pszTemp = pToken->GetToken();
                            len = wcslen(pszTemp);
                            while ((currentSize + len) > (maxSize - 2))
                            {                            
                                dwErr = ResizeByTwo(&buffer, &maxSize);
                                if(dwErr != ERROR_SUCCESS)
                                {
                                    FILL_ERROR(pError,
                                               ERROR_WIN32_ERROR,
                                               dwErr,
                                               i,
                                               -1);
                                    return FALSE;
                                }
                            }
                            wcscat((buffer + currentSize), pszTemp);
                            currentSize += len;
                            //Null Terminate, buffer is initialized to zero
                            currentSize++;
                            pToken++;
                            argc--;
                        }
                        Commands[i].strValue = buffer;
                    }
                    else if (Commands[i].fFlag & ARG_FLAG_DEFAULTABLE )
                    {
                        PWSTR strValue = Commands[i].strValue;
                        Commands[i].strValue = (PWSTR)LocalAlloc(LPTR, (wcslen(strValue)+1) * sizeof(WCHAR));
                        if (Commands[i].strValue != NULL )
                        {
                            wcscpy(Commands[i].strValue, strValue);
                        }
                    }
                    else
                    {
                        FILL_ERROR(pError,
                                   ERROR_FROM_PARSER,
                                   PARSE_ERROR_SWICH_NO_VALUE,
                                   i,
                                   -1);
                        return FALSE;
                    }
                    break;

                case ARG_TYPE_STR:
                    if (argc > 0)
                    {
                        if (!pToken->IsSwitch())
                        {
                           Commands[i].strValue = (PWSTR)LocalAlloc(LPTR, (wcslen(pToken->GetToken())+2) * sizeof(WCHAR));
                           if (Commands[i].strValue != NULL)
                           {
                              wcscpy(Commands[i].strValue, pToken->GetToken());
                           }
                           pToken++;
                           argc--;
                        }
                        else if (ARG_FLAG_OPTIONAL & Commands[i].fFlag)
                        {
                            // The current switch doesn't have a value.
                            // An arg value is optional, so parse the next switch
                            // token.
                            //
                            break;
                        }
                    }
                    else if (Commands[i].fFlag & ARG_FLAG_DEFAULTABLE)
                    {
                        PWSTR strValue = Commands[i].strValue;
                        Commands[i].strValue = (PWSTR)LocalAlloc(LPTR, (wcslen(strValue)+2) * sizeof(WCHAR));
                        if (Commands[i].strValue != NULL)
                        {
                            wcscpy(Commands[i].strValue, strValue);
                        }
                    }
                    else if (ARG_FLAG_OPTIONAL & Commands[i].fFlag)
                    {
                        // The current switch doesn't have a value and is the
                        // last token, so we are done.
                        //
                        break;
                    }
                    else
                    {
                        FILL_ERROR(pError,
                                   ERROR_FROM_PARSER,
                                   PARSE_ERROR_SWICH_NO_VALUE,
                                   i,
                                   -1);
                        return FALSE;
                    }
                    break;

                case ARG_TYPE_INTSTR:
                    //
                    // We use IsSlash here instead of IsSwitch because we want to allow
                    // negative numbers
                    //
                    if (argc > 0 && !pToken->IsSlash())
                    {
                        PWSTR pszToken = pToken->GetToken();
                        size_t strLen = wcslen(pszToken);
                        
                        Commands[i].nValue = _wtoi( pszToken);
                        Commands[i].fType = ARG_TYPE_INT;
                        if (Commands[i].nValue == 0 &&
                            !iswdigit(pszToken[0]))
                        {
                           //
                           // Then treat as a string
                           //
                           Commands[i].strValue = (PWSTR)LocalAlloc(LPTR, (wcslen(pToken->GetToken())+2) * sizeof(WCHAR) );
                           if (Commands[i].strValue != NULL )
                           {
                              wcscpy( Commands[i].strValue, pToken->GetToken() );
                              Commands[i].fType = ARG_TYPE_STR;
                           }
                        }
                        pToken++;
                        argc--;
                    }
                    else if (!(Commands[i].fFlag & ARG_FLAG_DEFAULTABLE))
                    {
                        FILL_ERROR(pError,
                                   ERROR_FROM_PARSER,
                                   PARSE_ERROR_SWITCH_VALUE,
                                   i,
                                   argCount - argc);
                        return FALSE;
                    }
                    break;
                }

                if (Commands[i].bDefined && Commands[i].fntValidation != NULL)
                {
                    dwErr = Commands[i].fntValidation(Commands + i);
                    if (dwErr != ERROR_SUCCESS)
                    {
                        FILL_ERROR(pError,
                                   ERROR_FROM_VLDFN,
                                   dwErr,
                                   i,
                                   -1);
                        return FALSE;
                    }
                }

            }
        }

        if (!bFound)
        {
            FILL_ERROR(pError,
                       ERROR_FROM_PARSER,
                       PARSE_ERROR_UNKNOWN_INPUT_PARAMETER,
                       -1,
                       argCount - argc);
            return FALSE;
        }
    }

    if (bValidate)    
        return ValidateCommands(Commands, pError);

    return TRUE;
}

//This Function reads from the Command Line, 
//return it in tokenized format.
DWORD GetCommandInput( OUT int *pargc,           //Number of Tokens
                       OUT LPTOKEN *ppToken)    //Array of CToken
{
    
    LPWSTR pBuffer = NULL;
    DWORD dwErr = ERROR_SUCCESS;
    WCHAR szDelimiters[] = L": \n\t";
    
    *pargc = 0;
    //Read the commandline input
    pBuffer = GetCommandLine();
    if(pBuffer)
        dwErr = Tokenize(pBuffer, 
                         wcslen(pBuffer),
                         szDelimiters,
                         ppToken,
                         pargc);

    return dwErr;
}

BOOL IsDelimiter(WCHAR ch, LPWSTR pszDelimiters)
{
    while(*pszDelimiters)
        if((WCHAR)*pszDelimiters++ == ch)
            return TRUE;

    return FALSE;
}

/*
This Function Tokenize the input buffer. It needs to be called in two step.
First time you call it, provide pBuf and Buflen. First Call will return 
the first token. To get next token, call the function with NULL for pBuf and
0 for Buflen.
Output: pbQuote is true if this token was enclosed in a quote.
        ppToken: Token string. Call LocalFree to free it.
Return Value:Length of Token if token found.
             0 if no token found.
             -1 in case of error. Call GetLastError to get the error.
*/
LONG GetToken(IN LPWSTR pBuf,
              IN LONG BufLen,
              IN LPWSTR pszDelimiters,
              OUT BOOL *pbQuote,
              OUT LPWSTR *ppToken)
{
    static LPWSTR pBuffer;
    static LONG BufferLen;

    DWORD dwErr = ERROR_SUCCESS;
    if(pbQuote)
        *pbQuote = FALSE;

    if(ppToken)
        *ppToken = NULL;

    LONG MaxSize = INIT_SIZE;
    LONG pos = 0;
 

    if(pBuf)
        pBuffer = pBuf;

    if(BufLen)
        BufferLen = BufLen;

    if(!BufferLen)
        return pos;
 
    do
    {
        BOOL bQuoteBegin = FALSE;
        PWSTR pItem = NULL;
        //Find the begining of Next Token
//        while( pBuffer[0] == L' '  ||
//               pBuffer[0] == L'\t' ||
//               pBuffer[0] == L'\n'  && BufferLen)
        while(BufferLen && IsDelimiter(pBuffer[0],pszDelimiters) )
        {
            ++pBuffer;--BufferLen;
        }
       
        if(!BufferLen)
            break;
        
        //Does Token Start with '"'
        if( pBuffer[0] == L'"' )
        {
            if(pbQuote)
                *pbQuote = TRUE;
            bQuoteBegin = TRUE;
            pBuffer++; --BufferLen;
        }
        if(!BufferLen)
            break;
        if(ppToken)
        {
            pItem = (PWSTR)LocalAlloc(LPTR,sizeof(WCHAR)*INIT_SIZE);
            if(!pItem)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return -1;
            }
        }
        
        //Now get the end
        WCHAR ch;
        while( BufferLen )
        {
            BOOL bChar = TRUE;
            if( BufferLen >= 2 && *pBuffer == L'\\' && *(pBuffer+1) == L'"')
            {
                ch = L'"';
                pBuffer +=2; BufferLen -=2;
            }
            else if(pBuffer[0] == L'"')
            {
                //A Matching Quote Found.
                if(bQuoteBegin)
                {
                    ++pBuffer;
                    --BufferLen;
                    if(BufferLen)
                    {
                        //If next char is whitespace endof token
                        //Ex "ABC" "xyz" . after C its endof token
                        //if(pBuffer[0] == L' '  ||
                        //   pBuffer[0] == L'\t' || 
                        //   pBuffer[0] == L'\n')
                        if(IsDelimiter(pBuffer[0],pszDelimiters) )
                            break;
                        else
                        {
                            //Ex "ABC"xyz 
                            if(pBuffer[0] != L'"')
                                bQuoteBegin = FALSE;
                            //"ABC""xyz"
                            else
                            {    
                                ++pBuffer;
                                --BufferLen;                                
                            }
                        }
                    }
                    bChar = FALSE;
                    //
                    // Don't break because "" means that we want to clear the field out
                    //
//                    else
//                        break;
                }
                //ABC" xyz" will get one token 'ABC xyz'
                else
                {
                    bQuoteBegin = TRUE;
                    ++pBuffer;
                    --BufferLen;
                    bChar = FALSE;
                }

            }
//            else if(!bQuoteBegin && (pBuffer[0] == L' '  ||
//                                     pBuffer[0] == L'\t' || 
//                                     pBuffer[0] == L'\n'))
            else if(!bQuoteBegin && IsDelimiter(pBuffer[0],pszDelimiters))
            {
                ++pBuffer;
                --BufferLen;
                break;
            }
            else
            {
                ch = pBuffer[0];
                ++pBuffer;
                --BufferLen;
            }
            if(bChar && ppToken)
            {
                if(pos == MaxSize -1)
                    if(ERROR_SUCCESS != ResizeByTwo(&pItem,&MaxSize))
                    {
                        LocalFree(pItem);
                        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                        return -1;
                    }            
                pItem[pos] = ch;
            }
            if(bChar)   
                ++pos;
        }
        if(pos ||
           (!pos && bQuoteBegin))
        {
            if(ppToken)
            {
                pItem[pos] = '\0';
                *ppToken = pItem;
            }
            ++pos;
        }
    }while(0);
    return pos;
}

/*
Function to convert string an array of CTokens.
INPUT: pBuf Input Buffer
       BufLen   Length of bBuf
OUTPUT:ppToken  Gets Pointer to array of CToken
       argc     Lenght of array of CToken
Return Value: WIN32 Error

*/
DWORD Tokenize(IN LPWSTR pBuf,
               IN LONG BufLen,
               LPWSTR szDelimiters,
               OUT CToken **ppToken,
               OUT int *argc)
{
    *argc = 0;
    CToken *pToken = NULL;
    DWORD dwErr = ERROR_SUCCESS;
    BOOL bQuote;
    LPWSTR pszItem = NULL;
    //Get First Token
    LONG ret = GetToken(pBuf,
                        BufLen,
                        szDelimiters,
                        &bQuote,
                        NULL);
    if(ret == -1)
    {
        dwErr = GetLastError();
        goto exit_gracefully;
    }

    while(ret)
    {
        ++(*argc);
        ret = GetToken(NULL,
                       NULL,
                       szDelimiters,
                       &bQuote,
                       NULL);
        if(ret == -1)
        {
            dwErr = GetLastError();
            goto exit_gracefully;
        }
    }

    if(*argc)
    {
        int i =0;
        pToken = new CToken[*argc];
        if(!pToken)
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            goto exit_gracefully;
        }
        ret = GetToken(pBuf,
                       BufLen,
                       szDelimiters,
                       &bQuote,
                       &pszItem);
        if(ret == -1)
        {
            dwErr = GetLastError();
            goto exit_gracefully;
        }
            
        while(ret)
        {
            if (!pToken[i++].Init(pszItem,bQuote))
            {
               dwErr = ERROR_OUTOFMEMORY;
               goto exit_gracefully;
            }
            if(pszItem)
                LocalFree(pszItem);                                       
            pszItem = NULL;


            ret = GetToken(NULL,
                           NULL,
                           szDelimiters,
                           &bQuote,
                           &pszItem);
            if(ret == -1)
            {
                dwErr = GetLastError();
                goto exit_gracefully;
            }

        }
    }

exit_gracefully:
    if(dwErr != ERROR_SUCCESS)
    {
        if(pToken)
        {
            delete [] pToken ;
        }       
        return dwErr;
    }
    *ppToken = pToken;
    return dwErr;
}

/*
Function to display the parsing errors. If function cannot 
handle some error, it will return False and calling function
must handle that error.
*/
BOOL DisplayParseError(IN PPARSE_ERROR pError,
                       IN ARG_RECORD *Commands,
                       IN CToken *pToken)
{

    if(!pError)
        return FALSE;

    VOID *parg1 = NULL;
    VOID *parg2 = NULL;

    UINT idStr = 0;

    switch(pError->ErrorSource)
    {
        case ERROR_FROM_PARSER:
        {
            switch(pError->Error)
            {
                case PARSE_ERROR_SWITCH_VALUE:
                {
                }
                break;
                
                case PARSE_ERROR_UNKNOWN_INPUT_PARAMETER:   
                {
                }
                break;
                
                case PARSE_ERROR_SWITCH_NOTDEFINED:   
                {
                    idStr = IDS_PARSE_ERROR_SWITCH_NOTDEFINED;
                    parg1 = Commands[pError->ArgRecIndex].strArg1;
                }
                break;
                case PARSE_ERROR_MULTIPLE_DEF:
                {
                }        
                    break;
                case ERROR_READING_FROM_STDIN:        
                {
                }
                    break;
            }
        }
        break;
        
        case ERROR_FROM_VLDFN:
        {

        }
        break;
        
        case ERROR_WIN32_ERROR:
        {


        }
        break;
    }

    if(idStr)
    {
        //Format the string
        LPWSTR pBuffer = NULL;
        FormatStringID(&pBuffer,
                        NULL,
                        idStr,
                        parg1,
                        parg2);

        //Display it
        if(pBuffer)
            DisplayError(pBuffer);

        LocalFreeString(&pBuffer);
        return TRUE;
    }
    else
        return FALSE;
}

VOID DisplayError(LPWSTR pszError)
{
    if(pszError)
        WriteStandardError(L"%s\n",pszError);
}

VOID DisplayOutput(LPWSTR pszOutput)
{
    if(pszOutput)
        WriteStandardOut(L"%s\n",pszOutput);
}

VOID DisplayOutputNoNewline(LPWSTR pszOutput)
{
    if(pszOutput)
        WriteStandardOut(L"%s",pszOutput);
}

/*******************************************************************

    NAME:       DisplayMessage

    SYNOPSIS:   Loads Message from Message Table and Formats its
    IN          Indent - Number of tabs to indent
                MessageId - Id of the message to load
                ... - Optional list of parameters

    RETURNS:    NONE

********************************************************************/
VOID DisplayMessage(DWORD MessageId,...)
{
    PWSTR MessageDisplayString;
    va_list ArgList;
    ULONG Length;

    va_start( ArgList, MessageId );

    Length = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                            NULL,
                            MessageId,
                            0,
                            (PWSTR)&MessageDisplayString,
                            0,
                            &ArgList );

    if ( Length != 0 ) {

        WriteStandardError(L"%s",MessageDisplayString);
        LocalFree( MessageDisplayString );
    }

    va_end( ArgList );
}


/*
Class CToken

*/
CToken::CToken(PCWSTR psz, BOOL bQuote)
{
        StringCopy(&m_pszToken,psz);
        m_bInitQuote = bQuote;
}

CToken::CToken() : m_bInitQuote(FALSE), m_pszToken(NULL) {}

CToken::~CToken()
{
   LocalFree(m_pszToken);
}

BOOL CToken::Init(PCWSTR psz, BOOL bQuote)
{
   if (!StringCopy(&m_pszToken,psz))
   {
      return FALSE;
   }
   m_bInitQuote = bQuote;
   return TRUE;
}
    
PWSTR CToken::GetToken() const {return m_pszToken;}
    
BOOL CToken::IsSwitch() const
{
    //Assert(m_pszToken);
    if(!m_pszToken)
        return FALSE;
    if(m_bInitQuote)
        return FALSE;
    if(m_pszToken[0] == L'/' ||
        m_pszToken[0] == L'-')
        return TRUE;
        
    return FALSE;
}

BOOL CToken::IsSlash() const
{
   if (!m_pszToken)
      return FALSE;
   if (m_bInitQuote)
      return FALSE;
   if (m_pszToken[0] == L'/')
      return TRUE;
   return FALSE;
}




// Copied from JSchwart

BOOL
FileIsConsole(
    HANDLE fp
    )
{
    unsigned htype;

    htype = GetFileType(fp);
    htype &= ~FILE_TYPE_REMOTE;
    return htype == FILE_TYPE_CHAR;
}


void
MyWriteConsole(
    HANDLE  fp,
    LPWSTR  lpBuffer,
    DWORD   cchBuffer
    )
{
    //
    // Jump through hoops for output because:
    //
    //    1.  printf() family chokes on international output (stops
    //        printing when it hits an unrecognized character)
    //
    //    2.  WriteConsole() works great on international output but
    //        fails if the handle has been redirected (i.e., when the
    //        output is piped to a file)
    //
    //    3.  WriteFile() works great when output is piped to a file
    //        but only knows about bytes, so Unicode characters are
    //        printed as two Ansi characters.
    //

    if (FileIsConsole(fp))
    {
        WriteConsole(fp, lpBuffer, cchBuffer, &cchBuffer, NULL);
    }
    else
    {
        LPSTR  lpAnsiBuffer = (LPSTR) LocalAlloc(LMEM_FIXED, cchBuffer * sizeof(WCHAR));

        if (lpAnsiBuffer != NULL)
        {
            cchBuffer = WideCharToMultiByte(CP_OEMCP,
                                            0,
                                            lpBuffer,
                                            cchBuffer,
                                            lpAnsiBuffer,
                                            cchBuffer * sizeof(WCHAR),
                                            NULL,
                                            NULL);

            if (cchBuffer != 0)
            {
                WriteFile(fp, lpAnsiBuffer, cchBuffer, &cchBuffer, NULL);
            }

            LocalFree(lpAnsiBuffer);
        }
    }
}


void
WriteStandardOut(PCWSTR pszFormat, ...)
{
   static HANDLE standardOut = GetStdHandle(STD_OUTPUT_HANDLE);

   //
   // Verify parameters
   //
   if (!pszFormat)
   {
      return;
   }

	va_list args;
	va_start(args, pszFormat);

	int nBuf;
	WCHAR szBuffer[4 * MAX_PATH];
   ZeroMemory(szBuffer, sizeof(szBuffer));

	nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer)/sizeof(WCHAR), pszFormat, args);

   //
   // Output the results
   //
   if (nBuf > 0)
   {
      MyWriteConsole(standardOut,
                     szBuffer,
                     nBuf);
   }
   va_end(args);
}

void
WriteStandardError(PCWSTR pszFormat, ...)
{
   static HANDLE standardErr = GetStdHandle(STD_ERROR_HANDLE);

   //
   // Verify parameters
   //
   if (!pszFormat)
   {
      return;
   }

	va_list args;
	va_start(args, pszFormat);

	int nBuf;
	WCHAR szBuffer[100 * MAX_PATH];
   ZeroMemory(szBuffer, sizeof(szBuffer));

	nBuf = _vsnwprintf(szBuffer, sizeof(szBuffer)/sizeof(WCHAR), pszFormat, args);

   //
   // Output the results
   //
   if (nBuf > 0)
   {
      MyWriteConsole(standardErr,
                     szBuffer,
                     nBuf);
   }
   va_end(args);
}

//Read From Stdin
//Return Value:
//  Number of WCHAR read if successful 
//  -1 in case of Failure. Call GetLastError to get the error.
LONG ReadFromIn(OUT LPWSTR *ppBuffer)
{
    LPWSTR pBuffer = NULL;
    DWORD dwErr = ERROR_SUCCESS;
    pBuffer = (LPWSTR)LocalAlloc(LPTR,INIT_SIZE*sizeof(WCHAR));        
    if(!pBuffer)
    {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return -1;
    }

    LONG Pos = 0;
    LONG MaxSize = INIT_SIZE;
    wint_t ch;
    while((ch = getwchar()) != WEOF)
    {
        if(Pos == MaxSize -1 )
        {
            if(ERROR_SUCCESS != ResizeByTwo(&pBuffer,&MaxSize))
            {
                LocalFree(pBuffer);
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                return -1;
            }
        }
        pBuffer[Pos++] = (WCHAR)ch;
    }
    pBuffer[Pos] = L'\0';
    *ppBuffer = pBuffer;
    return Pos;
}

//General Utility Functions
DWORD ResizeByTwo( PWSTR *ppBuffer,
                   LONG *pSize )
{
    LPWSTR pTempBuffer = (LPWSTR)LocalAlloc(LPTR,(*pSize)*2*sizeof(WCHAR));        
    if(!pTempBuffer)
        return ERROR_NOT_ENOUGH_MEMORY;

    memcpy(pTempBuffer,*ppBuffer,*pSize*sizeof(WCHAR));
    LocalFree(*ppBuffer);
    *ppBuffer = pTempBuffer;
    *pSize *=2;
    return ERROR_SUCCESS;
}

BOOL StringCopy(PWSTR *ppDest, PCWSTR pSrc)
{
    *ppDest = NULL;
    if(!pSrc)
        return TRUE;

    *ppDest = (LPWSTR)LocalAlloc(LPTR, (wcslen(pSrc) + 1)*sizeof(WCHAR));
    if(!*ppDest)
        return FALSE;
    wcscpy(*ppDest,pSrc);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netdom\strings.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       strings.cpp
//
//  Useful string manipulation functions.
//
//--------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include <netdom.h>

#define StringByteSize(sz)                          \
        ((lstrlen(sz)+1)*sizeof(TCHAR))

/*-----------------------------------------------------------------------------
/ LocalAllocString
/ ------------------
/   Allocate a string, and initialize it with the specified contents.
/
/ In:
/   ppResult -> recieves pointer to the new string
/   pString -> string to initialize with
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT LocalAllocString(LPTSTR* ppResult, LPCTSTR pString)
{
    if ( !ppResult || !pString )
        return E_INVALIDARG;

    *ppResult = (LPTSTR)LocalAlloc(LPTR, StringByteSize(pString) );

    if ( !*ppResult )
        return E_OUTOFMEMORY;

    lstrcpy(*ppResult, pString);
    return S_OK;                          //  success
}


/*----------------------------------------------------------------------------
/ LocalAllocStringLen
/ ---------------------
/   Given a length return a buffer of that size.
/
/ In:
/   ppResult -> receives the pointer to the string
/   cLen = length in characters to allocate
/
/ Out:
/   HRESULT
/----------------------------------------------------------------------------*/
HRESULT LocalAllocStringLen(LPTSTR* ppResult, UINT cLen)
{
    if ( !ppResult || cLen == 0 )
        return E_INVALIDARG;

    *ppResult = (LPTSTR)LocalAlloc(LPTR, (cLen+1) * sizeof(TCHAR));

    return *ppResult ? S_OK:E_OUTOFMEMORY; 

}


/*-----------------------------------------------------------------------------
/ LocalFreeString
/ -----------------
/   Release the string pointed to be *ppString (which can be null) and
/   then reset the pointer back to NULL.   
/
/ In:
/   ppString -> pointer to string pointer to be free'd
/
/ Out:
/   -
/----------------------------------------------------------------------------*/
void LocalFreeString(LPTSTR* ppString)
{
    if ( ppString )
    {
        if ( *ppString )
            LocalFree((HLOCAL)*ppString);

        *ppString = NULL;
    }
}


//*************************************************************
//
//  SizeofStringResource
//
//  Purpose:    Find the length (in chars) of a string resource
//
//  Parameters: HINSTANCE hInstance - module containing the string
//              UINT idStr - ID of string
//
//
//  Return:     UINT - # of chars in string, not including NULL
//
//  Notes:      Based on code from user32.
//
//*************************************************************
UINT
SizeofStringResource(HINSTANCE hInstance,
                     UINT idStr)
{
    UINT cch = 0;
    HRSRC hRes = FindResource(hInstance, (LPTSTR)((LONG_PTR)(((USHORT)idStr >> 4) + 1)), RT_STRING);
    if (NULL != hRes)
    {
        HGLOBAL hStringSeg = LoadResource(hInstance, hRes);
        if (NULL != hStringSeg)
        {
            LPWSTR psz = (LPWSTR)LockResource(hStringSeg);
            if (NULL != psz)
            {
                idStr &= 0x0F;
                while(true)
                {
                    cch = *psz++;
                    if (idStr-- == 0)
                        break;
                    psz += cch;
                }
            }
        }
    }
    return cch;
}


//*************************************************************
//
//  LoadStringAlloc
//
//  Purpose:    Loads a string resource into an alloc'd buffer
//
//  Parameters: ppszResult - string resource returned here
//              hInstance - module to load string from
//              idStr - string resource ID
//
//  Return:     same as LoadString
//
//  Notes:      On successful return, the caller must
//              LocalFree *ppszResult
//
//*************************************************************
int
LoadStringAlloc(LPTSTR *ppszResult, HINSTANCE hInstance, UINT idStr)
{
    int nResult = 0;
    UINT cch = SizeofStringResource(hInstance, idStr);
    if (cch)
    {
        cch++; // for NULL
        *ppszResult = (LPTSTR)LocalAlloc(LPTR, cch * sizeof(TCHAR));
        if (*ppszResult)
            nResult = LoadString(hInstance, idStr, *ppszResult, cch);
    }
    return nResult;
}


//*************************************************************
//
//  String formatting functions
//
//*************************************************************

DWORD
FormatStringID(LPTSTR *ppszResult, HINSTANCE hInstance, UINT idStr, ...)
{
    DWORD dwResult;
    va_list args;
    va_start(args, idStr);
    dwResult = vFormatStringID(ppszResult, hInstance, idStr, &args);
    va_end(args);
    return dwResult;
}

DWORD
FormatString(LPTSTR *ppszResult, LPCTSTR pszFormat, ...)
{
    DWORD dwResult;
    va_list args;
    va_start(args, pszFormat);
    dwResult = vFormatString(ppszResult, pszFormat, &args);
    va_end(args);
    return dwResult;
}

DWORD
vFormatStringID(LPTSTR *ppszResult, HINSTANCE hInstance, UINT idStr, va_list *pargs)
{
    DWORD dwResult = 0;
    LPTSTR pszFormat = NULL;
    if (LoadStringAlloc(&pszFormat, hInstance, idStr))
    {
        dwResult = vFormatString(ppszResult, pszFormat, pargs);
        LocalFree(pszFormat);
    }
    return dwResult;
}

DWORD
vFormatString(LPTSTR *ppszResult, LPCTSTR pszFormat, va_list *pargs)
{
    return FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                         pszFormat,
                         0,
                         0,
                         (LPTSTR)ppszResult,
                         1,
                         pargs);
}


//*************************************************************
//
//  GetSystemErrorText
//
//  Purpose:    Retrieve error text for a win32 error value
//
//  Parameters: ppszResult - string resource returned here
//              dwErr - error ID
//
//  Return:     same as FormatMessage
//
//  Notes:      On successful return, the caller must
//              LocalFree *ppszResult
//
//*************************************************************
DWORD
GetSystemErrorText(LPTSTR *ppszResult, DWORD dwErr)
{
    return FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                         NULL,
                         dwErr,
                         0,
                         (LPTSTR)ppszResult,
                         0,
                         NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netdom\strings.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       strings.h
//
//--------------------------------------------------------------------------

#ifndef __strings_h
#define __strings_h

HRESULT LocalAllocString(LPTSTR* ppResult, LPCTSTR pString);
HRESULT LocalAllocStringLen(LPTSTR* ppResult, UINT cLen);
void    LocalFreeString(LPTSTR* ppString);

UINT SizeofStringResource(HINSTANCE hInstance, UINT idStr);
int LoadStringAlloc(LPTSTR *ppszResult, HINSTANCE hInstance, UINT idStr);

// String formatting functions - *ppszResult must be LocalFree'd
DWORD FormatStringID(LPTSTR *ppszResult, HINSTANCE hInstance, UINT idStr, ...);
DWORD FormatString(LPTSTR *ppszResult, LPCTSTR pszFormat, ...);
DWORD vFormatStringID(LPTSTR *ppszResult, HINSTANCE hInstance, UINT idStr, va_list *pargs);
DWORD vFormatString(LPTSTR *ppszResult, LPCTSTR pszFormat, va_list *pargs);

DWORD GetSystemErrorText(LPTSTR *ppszResult, DWORD dwErr);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netdom\varg.h ===
/*****************************************************************************\

    Author: Corey Morgan (coreym)
            
    Copyright (c) 1998-2001 Microsoft Corporation
    
 
\*****************************************************************************/

#ifndef _VARG_H_012599_
#define _VARG_H_012599_

#define MAXSTR                   1025


//Class CToken
//It represents a Single Token.
class CToken
{
public:
    CToken(PCWSTR psz, BOOL bQuote);
    CToken();
    ~CToken();
    BOOL Init(PCWSTR psz, BOOL bQuote);   
    PWSTR GetToken() const;    
    BOOL IsSwitch() const;
    BOOL IsSlash() const;
private:
    LPWSTR m_pszToken;
    BOOL   m_bInitQuote;
};
typedef CToken * LPTOKEN;


#define ARG_TYPE_INT             0
#define ARG_TYPE_BOOL            1
#define ARG_TYPE_STR             2
#define ARG_TYPE_HELP            3
#define ARG_TYPE_DEBUG           4
#define ARG_TYPE_MSZ             5
#define ARG_TYPE_INTSTR          6
#define ARG_TYPE_VERB            7  // Verbs are not preceeded by a switch character
#define ARG_TYPE_LAST            8


#define ARG_FLAG_OPTIONAL        0x00000001
#define ARG_FLAG_REQUIRED        0x00000002
#define ARG_FLAG_DEFAULTABLE     0x00000004
//#define ARG_FLAG_NOFLAG          0x00000008     // unused.
#define ARG_FLAG_HIDDEN          0x00000010
#define ARG_FLAG_VERB            0x00000020     // For operation and sub-operation params that do not have a switch char.
                                                // Verbs are two state: present or not present; they do not have qualifers such as a user-entered string.
#define ARG_FLAG_STDIN           0x00000040     // This must be Required. If not sepcified read from standard input
#define ARG_FLAG_ATLEASTONE      0x00000080     // If this flag is specified on one or more switch, at
                                                //   least one of those switches must be defined
#define ARG_FLAG_OBJECT          0x00000100     // The object arg is the 3rd param for most commands.


#define ARG_TERMINATOR           0,NULL,0,NULL,ARG_TYPE_LAST,0,(CMD_TYPE)0,FALSE,NULL
#define ID_ARG2_NULL             (LONG)-1

#define CMD_TYPE    void*

typedef struct _ARG_RECORD
{
    LONG    idArg1;
    LPTSTR  strArg1;
    LONG    idArg2;
    LPTSTR  strArg2;
    int     fType;
    DWORD   fFlag;
    union{
        void*   vValue;
        LPTSTR  strValue;
        int     nValue;
        BOOL    bValue;
    };
    BOOL	bDefined;
    DWORD (*fntValidation)(PVOID pArg);
} ARG_RECORD, *PARG_RECORD;


//Error Source
#define ERROR_FROM_PARSER   1
#define ERROR_FROM_VLDFN    2
#define ERROR_WIN32_ERROR   3

//Parse Errors for when ERROR_SOURCE is ERROR_FROM_PARSER
/*
SWITCH value is incorrect.
ArgRecIndex is index of record.
ArgvIndex is index of token.
*/
#define PARSE_ERROR_SWITCH_VALUE        1
/*No Value is given for a swich when one is expected.
ArgRecIndex is index of record.
ArgvIndex is -1.
*/
#define PARSE_ERROR_SWICH_NO_VALUE      2
/*
Invalid Input
ArgRecIndex is -1, 
ArgvIndex is index of token.
*/
#define PARSE_ERROR_UNKNOWN_INPUT_PARAMETER   3
/*
Required switch is not defined. 
ArgRecIndex is index of record.
ArgvIndex is -1.
*/
#define PARSE_ERROR_SWITCH_NOTDEFINED   4
/*
Switch or Parameter is defined twice.
ArgRecIndex is index of record.
ArgvIndex is -1
*/
#define PARSE_ERROR_MULTIPLE_DEF        5
/*
Error Reading From STDIN.
ArgRecIndex is -1.
ArgvIndex is -1.
*/
#define ERROR_READING_FROM_STDIN        6
/*
Parser Encountered Help Switch
ArgRecIndex is index of record.
ArgvIndex is -1
*/
#define PARSE_ERROR_HELP_SWITCH         7
/*
The ARG_FLAG_ATLEASTONE flag was
defined on one or more switch yet
none of these switches were defined
ArgRecIndex is -1
ArgvIndex is -1
*/
#define PARSE_ERROR_ATLEASTONE_NOTDEFINED 8


//Parse Errors for when ERROR_SOURCE is VLDFN

/*
Use this error code when Validation Function has handled the error and
Shown appropriate error message.
*/
#define VLDFN_ERROR_NO_ERROR    1


//Error is returned by Parser in PARSE_ERROR structure
//ErrorSource: Source of Error. Parser or Validation Function
//Error This is the actual error code. Its value depend on ErrorSource value.
//  if( ErrorSource == PARSE_ERROR )
//      possible values are   ERROR_FROM_PARSER ERROR_FROM_VLDFN       
//  if( ErrorSource == ERROR_FROM_VLDFN )
//      depends on the function
//  ArgRecIndex is appropriate index in the ARG_RECORD, if applicable else -1
//  ArgvIndex is approproate index in the agrv array, if applicable else -1
typedef struct _PARSE_ERROR
{
    INT ErrorSource;
    DWORD Error;
    INT ArgRecIndex;
    INT ArgvIndex;
} PARSE_ERROR, *PPARSE_ERROR;

BOOL ParseCmd(IN ARG_RECORD *Commands,
              IN int argc, 
              IN CToken *pToken,
              IN bool fSkipObject, 
              OUT PPARSE_ERROR pError,
              IN BOOL bValidate = FALSE);

void FreeCmd(ARG_RECORD *Commands);

DWORD GetCommandInput(OUT int *pargc,           //Number of Tokens
                      OUT LPTOKEN *ppToken);    //Array of CToken

BOOL LoadCmd(ARG_RECORD *Commands);

DWORD Tokenize(IN LPWSTR pBuf,
               IN LONG BufLen,
               IN LPWSTR pszDelimiters,
               OUT CToken **ppToken,
               OUT int *argc);

LONG GetToken(IN LPWSTR pBuf,
              IN LONG BufLen,
              IN LPWSTR pszDelimiters,
              OUT BOOL *bQuote,
              OUT LPWSTR *ppToken);

BOOL DisplayParseError(IN PPARSE_ERROR pError,
                       IN ARG_RECORD *Commands,
                       IN CToken *pToken);


//Function to display string to STDERR
VOID DisplayError(IN LPWSTR pszError);
//Function to display string to STDOUT, appending newline
VOID DisplayOutput(IN LPWSTR pszOut);
//Function to display string to STDOUT, without newline
VOID DisplayOutputNoNewline(IN LPWSTR pszOut);
//Function to display Message to Standard Error.
VOID DisplayMessage(DWORD MessageId,...);



// Copied from JSchwart on 2/19/2001

void
MyWriteConsole(
    HANDLE  fp,
    LPWSTR  lpBuffer,
    DWORD   cchBuffer
    );

void
WriteStandardOut(PCWSTR pszFormat, ...);

void
WriteStandardError(PCWSTR pszFormat, ...);

#endif //_VARG_H_012599_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netdom\rename.cxx ===
/*++

Microsoft Windows

Copyright (C) Microsoft Corporation, 1998 - 2001

Module Name:

    rename.c

Abstract:

    Handles the various functions for renaming computers/domains

--*/
#include "pch.h"
#pragma hdrstop
#include <netdom.h>


DWORD
NetDompHandleRename(ARG_RECORD * rgNetDomArgs)
/*++

Routine Description:

    This function will rename the domain a BDC is in

Arguments:

    Args - List of command line arguments

Return Value:

    ERROR_INVALID_PARAMETER - No object name was supplied

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    PWSTR Domain = NULL;
    PDOMAIN_CONTROLLER_INFO DcInfo = NULL;
    LSA_HANDLE PdcHandle = NULL, BdcHandle = NULL;
    NTSTATUS Status;
    UNICODE_STRING Server;
    OBJECT_ATTRIBUTES OA;
    PPOLICY_PRIMARY_DOMAIN_INFO PdcPolicyPDI = NULL, BdcPolicyPDI = NULL;
    PPOLICY_ACCOUNT_DOMAIN_INFO PdcPolicyADI = NULL;

    PWSTR Object = rgNetDomArgs[eObject].strValue;

    if ( !Object ) {

        DisplayHelp(ePriRename);
        return( ERROR_INVALID_PARAMETER );
    }

    Win32Err = NetDompValidateSecondaryArguments(rgNetDomArgs,
                                                 eObject,
                                                 eCommDomain,
                                                 eCommRestart,
                                                 eCommVerbose,
                                                 eArgEnd);
    if ( Win32Err != ERROR_SUCCESS )
    {
        DisplayHelp(ePriRename);
        return Win32Err;
    }

    //
    // Ok, make sure that we have a specified domain...
    //
    Win32Err = NetDompGetDomainForOperation(rgNetDomArgs,
                                            Object,
                                            TRUE,
                                            &Domain);

    if ( Win32Err != ERROR_SUCCESS ) {

        goto HandleRenameExit;
    }

    //
    // Get the name of a domain controller
    //
    Win32Err = DsGetDcName( NULL,
                            Domain,
                            NULL,
                            NULL,
                            DS_PDC_REQUIRED,
                            &DcInfo );

    if ( Win32Err != ERROR_SUCCESS ) {

        goto HandleRenameExit;
    }


    InitializeObjectAttributes( &OA, NULL, 0, NULL, NULL );

    RtlInitUnicodeString( &Server, DcInfo->DomainControllerName );
    Status = LsaOpenPolicy( &Server,
                            &OA,
                            POLICY_VIEW_LOCAL_INFORMATION,
                            &PdcHandle );

    if ( NT_SUCCESS( Status ) ) {

        Status = LsaQueryInformationPolicy( PdcHandle,
                                            PolicyPrimaryDomainInformation,
                                            ( PVOID * )&PdcPolicyPDI );

        if ( NT_SUCCESS( Status ) ) {

            Status = LsaQueryInformationPolicy( PdcHandle,
                                                PolicyAccountDomainInformation,
                                                ( PVOID * )&PdcPolicyADI );

            if ( NT_SUCCESS( Status ) ) {

                RtlInitUnicodeString( &Server, Object );
                Status = LsaOpenPolicy( &Server,
                                        &OA,
                                        POLICY_VIEW_LOCAL_INFORMATION,
                                        &BdcHandle );

                if ( NT_SUCCESS( Status ) ) {

                    Status = LsaQueryInformationPolicy( BdcHandle,
                                                        PolicyPrimaryDomainInformation,
                                                        ( PVOID * )&BdcPolicyPDI );
                }
            }
        }
    }

    if ( !NT_SUCCESS( Status ) ) {

        Win32Err = RtlNtStatusToDosError( Status );
        goto HandleRenameExit;
    }

    //
    // See if they are the same domain
    //
    if ( !PdcPolicyPDI->Sid || !BdcPolicyPDI->Sid ||
         !RtlEqualSid( BdcPolicyPDI->Sid, PdcPolicyPDI->Sid ) ) {

         Win32Err = ERROR_INVALID_DOMAIN_STATE;
         goto HandleRenameExit;
    }

    //
    // If they have the same name, do nothing...
    //
    if ( RtlCompareUnicodeString( &PdcPolicyPDI->Name, &BdcPolicyPDI->Name, TRUE ) ) {

        goto HandleRenameExit;
    }

    //
    // Otherwise, set it..
    //
    Status = LsaSetInformationPolicy( BdcHandle,
                                      PolicyPrimaryDomainInformation,
                                      ( PVOID )PdcPolicyPDI );

    if ( NT_SUCCESS( Status ) ) {

        Status = LsaSetInformationPolicy( BdcHandle,
                                          PolicyAccountDomainInformation,
                                          ( PVOID )PdcPolicyADI );

        //
        // Restore the original, if possible
        //
        if ( !NT_SUCCESS( Status ) ) {

            NTSTATUS Status2 = LsaSetInformationPolicy( BdcHandle,
                                                        PolicyPrimaryDomainInformation,
                                                        ( PVOID )BdcPolicyPDI );

            if ( !NT_SUCCESS( Status2 ) ) {


                NetDompDisplayMessage( MSG_FAIL_RENAME_RESTORE, Object );
                NetDompDisplayErrorMessage( RtlNtStatusToDosError( Status2 ) );
            }
        }
    }

    if ( !NT_SUCCESS( Status ) ) {

        Win32Err = RtlNtStatusToDosError( Status );
        goto HandleRenameExit;
    }

    //
    // Finally, reboot if necessary
    //
    NetDompRestartAsRequired(rgNetDomArgs,
                             Object,
                             NULL,
                             Win32Err,
                             MSG_DOMAIN_CHANGE_RESTART_MSG);

HandleRenameExit:
    NetApiBufferFree( Domain );
    NetApiBufferFree( DcInfo );

    if ( PdcHandle ) {

        LsaClose( PdcHandle );
    }

    if ( BdcHandle ) {

        LsaClose( BdcHandle );
    }

    LsaFreeMemory( PdcPolicyPDI );
    LsaFreeMemory( PdcPolicyADI );
    LsaFreeMemory( BdcPolicyPDI );

    if (NO_ERROR != Win32Err)
    {
        NetDompDisplayErrorMessage(Win32Err);
    }

    return( Win32Err );
}

//+----------------------------------------------------------------------------
//
//  Function:  CheckNewName
//
//  Synopsis:  Validate the new computer name performing the same checks as
//             NetID
//
//-----------------------------------------------------------------------------
DWORD CheckNewName(PWSTR pwzNewName)
{
   DWORD dwErr = ERROR_SUCCESS;
   int cchName, i;
   DWORD size = CNLEN + 1;
   WCHAR wzNBname[CNLEN + 1] = {0};
   WORD rgwCharType[CNLEN + 1] = {0};
   BOOL fNumber = TRUE;

   //
   // Validate the computer name (logic same as NetID).
   //

   cchName = (int)wcslen( pwzNewName ); // cheap test first

   if ( DNS_MAX_LABEL_LENGTH < cchName )
   {
      NetDompDisplayMessage( MSG_DNS_LABEL_TOO_LONG, pwzNewName, DNS_MAX_LABEL_LENGTH );
      dwErr = ERROR_INVALID_PARAMETER;
      return dwErr;
   }

   cchName = WideCharToMultiByte( CP_UTF8,
                                  0,
                                  pwzNewName,
                                  cchName,
                                  0,
                                  0,
                                  0,
                                  0 );

   if ( DNS_MAX_LABEL_LENGTH < cchName )
   {
      NetDompDisplayMessage( MSG_DNS_LABEL_TOO_LONG, pwzNewName, DNS_MAX_LABEL_LENGTH );
      dwErr = ERROR_INVALID_PARAMETER;
      return dwErr;
   }

   dwErr = DnsValidateName( pwzNewName, DnsNameHostnameLabel );

   switch ( dwErr )
   {
   case ERROR_INVALID_NAME:
   case DNS_ERROR_INVALID_NAME_CHAR:
   case DNS_ERROR_NUMERIC_NAME:
      NetDompDisplayMessage( MSG_DNS_LABEL_SYNTAX, pwzNewName );
      return dwErr;

   case DNS_ERROR_NON_RFC_NAME:
      //
      // Not an error, print warning message.
      //
      NetDompDisplayMessage( MSG_DNS_LABEL_WARN_RFC, pwzNewName );
      dwErr = NO_ERROR;
      break;

   case ERROR_SUCCESS:
      break;
   }

   if ( !DnsHostnameToComputerName( pwzNewName, wzNBname, &size ) )
   {
      dwErr = GetLastError();
      NetDompDisplayMessage( MSG_CONVERSION_TO_NETBIOS_NAME_FAILED, pwzNewName );
      return dwErr;
   }

   if ( ( cchName = (int)wcslen( wzNBname ) ) == 0 )
   {
      dwErr = ERROR_INVALID_COMPUTERNAME;
      NetDompDisplayMessage( MSG_CONVERSION_TO_NETBIOS_NAME_FAILED, pwzNewName );
      return dwErr;
   }

   if ( !GetStringTypeEx( LOCALE_USER_DEFAULT,
                          CT_CTYPE1,
                          wzNBname,
                          cchName,
                          rgwCharType ) )
   {
      dwErr = GetLastError();
      return dwErr;
   }

   for ( i = 0; i < cchName; i++ )
   {
      if ( !( rgwCharType[i] & C1_DIGIT ) )
      {
         fNumber = FALSE;
         break;
      }
   }

   if ( fNumber )
   {
      dwErr = ERROR_INVALID_COMPUTERNAME;
      NetDompDisplayMessage( MSG_NETBIOS_NAME_NUMERIC, wzNBname, CNLEN );
      return dwErr;
   }

   // The NetID code does further NetBIOS name validation which is repeated here.
   // This test is probably not necessary since the DNS name syntax is actually
   // more restrictive than NetBIOS and errors would be caught above by DnsValidateName.
   //

   if ( I_NetNameValidate( 0, wzNBname, NAMETYPE_COMPUTER, LM2X_COMPATIBLE ) != NERR_Success )
   {
      dwErr = ERROR_INVALID_COMPUTERNAME;
      NetDompDisplayMessage( MSG_BAD_NETBIOS_CHARACTERS );
      return dwErr;
   }

   if ( cchName < (int)wcslen( pwzNewName ) )
   {
      NetDompDisplayMessage( MSG_NAME_TRUNCATED, CNLEN, wzNBname );
   }

   return dwErr;
}

//+----------------------------------------------------------------------------
//
// Function:   OkToRename
//
// Synopsis:   Return failure code if the machine is a CA server or if in the
//             middle of DCPromo or a role change.
//
//-----------------------------------------------------------------------------
DWORD OkToRename( PWSTR pwzComputer )
{
   PDSROLE_OPERATION_STATE_INFO pRoleState;
   PDSROLE_UPGRADE_STATUS_INFO pRoleUpgrade;
   DWORD dwErr;
   SC_HANDLE hSc, hCA;

   // Is the machine a DC in the middle of an upgrade?

   dwErr = DsRoleGetPrimaryDomainInformation( pwzComputer,
                                              DsRoleUpgradeStatus,
                                              (PBYTE *) &pRoleUpgrade );
   if ( ERROR_SUCCESS != dwErr )
   {
      NetDompDisplayMessage( MSG_ROLE_READ_FAILED, pwzComputer, dwErr );
      return dwErr;
   }

   if ( pRoleUpgrade->OperationState & DSROLE_UPGRADE_IN_PROGRESS )
   {
      DsRoleFreeMemory( pRoleUpgrade );
      NetDompDisplayMessage( MSG_MUST_COMPLETE_DCPROMO );
      return ERROR_DS_UNWILLING_TO_PERFORM;
   }
   DsRoleFreeMemory( pRoleUpgrade );

   // Is the machine in the midst of changing its role?

   dwErr = DsRoleGetPrimaryDomainInformation( pwzComputer,
                                              DsRoleOperationState,
                                              (PBYTE *) &pRoleState );
   if ( ERROR_SUCCESS != dwErr )
   {
      NetDompDisplayMessage( MSG_ROLE_READ_FAILED, pwzComputer, dwErr );
      return dwErr;
   }

   if ( DsRoleOperationIdle != pRoleState->OperationState )
   {
      NetDompDisplayMessage( (DsRoleOperationActive == pRoleState->OperationState) ? 
                                 MSG_ROLE_CHANGE_IN_PROGRESS : MSG_ROLE_CHANGE_NEEDS_REBOOT );
      DsRoleFreeMemory( pRoleState );
      return ERROR_DS_UNWILLING_TO_PERFORM;
   }
   DsRoleFreeMemory( pRoleState );

   // Is CertSvc installed?

   hSc = OpenSCManager( pwzComputer, SERVICES_ACTIVE_DATABASE, GENERIC_READ );

   if ( NULL == hSc )
   {
      dwErr = GetLastError();
      NetDompDisplayMessage( MSG_SC_OPEN_FAILED, pwzComputer, dwErr );
      return dwErr;
   }

   hCA = OpenService( hSc, L"SertSvc", SERVICE_QUERY_STATUS );

   CloseServiceHandle( hSc );

   if ( hCA )
   {
      NetDompDisplayMessage( MSG_CANT_RENAME_CERT_SVC );
      CloseServiceHandle( hCA );
      return ERROR_DS_UNWILLING_TO_PERFORM;
   }

   return ERROR_SUCCESS;
}

DWORD
NetDompHandleRenameComputer(ARG_RECORD * rgNetDomArgs)
/*++

Routine Description:

    This function will rename a computer

Arguments:

    Args - List of command line arguments

Return Value:

    ERROR_INVALID_PARAMETER - No object name was supplied

--*/
{
   DWORD dwErr = ERROR_SUCCESS;
   ND5_AUTH_INFO ComputerUser, DomainUser;
   PWSTR pwzNewName = NULL;
   WKSTA_INFO_100 * pInfo = NULL;
   int cchName;
   BOOL fForce = CmdFlagOn(rgNetDomArgs, eCommForce );

   RtlZeroMemory( &ComputerUser, sizeof( ND5_AUTH_INFO ) );
   RtlZeroMemory( &DomainUser, sizeof( ND5_AUTH_INFO ) );

   PWSTR pwzComputer = rgNetDomArgs[eObject].strValue;

   if ( !pwzComputer )
   {
      DisplayHelp(ePriRenameComputer);
      return( ERROR_INVALID_PARAMETER );
   }

   dwErr = NetDompValidateSecondaryArguments(rgNetDomArgs,
                                             eObject,
                                             eRenCompNewName,
                                             eCommUserNameD,
                                             eCommPasswordD,
                                             eCommUserNameO,
                                             eCommPasswordO,
                                             eCommForce,
                                             eCommRestart,
                                             eCommVerbose,
                                             eArgEnd);
   if ( ERROR_SUCCESS != dwErr )
   {
      DisplayHelp(ePriRenameComputer);
      return dwErr;
   }

   dwErr = NetDompGetArgumentString(rgNetDomArgs,
                                    eRenCompNewName,
                                    &pwzNewName);

   if ( ERROR_SUCCESS != dwErr )
   {
      NetDompDisplayErrorMessage(dwErr);
      return dwErr;
   }

   if ( !pwzNewName || !_wcsicmp( pwzComputer, pwzNewName ) )
   {
      DisplayHelp(ePriRenameComputer);
      return( ERROR_INVALID_PARAMETER );
   }

   //
   // Validate the computer name (logic same as NetID).
   //

   if ( ( dwErr = CheckNewName(pwzNewName) ) != ERROR_SUCCESS )
   {
      goto RenameComputerExit;
   }

   //
   // Get the computer user and password
   //

   dwErr = NetDompGetUserAndPasswordForOperation(rgNetDomArgs,
                                                 eCommUserNameO,
                                                 pwzComputer,
                                                 &ComputerUser);
   if ( ERROR_SUCCESS != dwErr )
   {
      goto RenameComputerExit;
   }

   if ( ComputerUser.User )
   {
      LOG_VERBOSE(( MSG_VERBOSE_ESTABLISH_SESSION, pwzComputer ));
      dwErr = NetpManageIPCConnect( pwzComputer,
                                    ComputerUser.User,
                                    ComputerUser.Password,
                                    NETSETUPP_CONNECT_IPC );

      if ( ERROR_SUCCESS != dwErr )
      {
         LOG_VERBOSE(( MSG_VERBOSE_SESSION_FAILED, pwzComputer ));
         ERROR_VERBOSE( dwErr );
         goto RenameComputerExit;
      }
   }

   //
   // Get the domain user and password
   //

   dwErr = NetWkstaGetInfo( pwzComputer, 100, (PBYTE *)&pInfo );

   if ( ERROR_SUCCESS != dwErr )
   {
      NetDompDisplayMessage( MSG_COMPUTER_NOT_FOUND, pwzComputer, dwErr );
      goto RenameComputerExit;
   }

   // DBG_VERBOSE(( "%ws domain: %ws\n", pwzComputer, pInfo->wki100_langroup ));

   dwErr = NetDompGetUserAndPasswordForOperation(rgNetDomArgs,
                                                 eCommUserNameD,
                                                 pInfo->wki100_langroup,
                                                 &DomainUser );
   if ( ERROR_SUCCESS != dwErr )
   {
      goto RenameComputerExit;
   }

   //
   // Check for conditions that should prevent a computer rename. This is done
   // after the IPC$ connection is made to the computer.
   //

   if ( (dwErr = OkToRename( pwzComputer ) ) != ERROR_SUCCESS )
   {
      goto RenameComputerExit;
   }

   //
   // Get confirmation if necessary.
   //


   if ( fForce )
   {
      LOG_VERBOSE(( MSG_ATTEMPT_RENAME_COMPUTER, pwzComputer, pwzNewName ));
   }
   else
   {
      NetDompDisplayMessage( MSG_ATTEMPT_RENAME_COMPUTER, pwzComputer, pwzNewName );
      NetDompDisplayMessage( MSG_RENAME_COMPUTER_WARNING, pwzComputer );

      if ( !NetDompGetUserConfirmation( IDS_PROMPT_PROCEED, NULL ) )
      {
         goto RenameComputerExit;
      }
   }

   //
   // Do the rename.
   //

   dwErr = NetRenameMachineInDomain( pwzComputer, 
                                     pwzNewName,
                                     DomainUser.User, 
                                     DomainUser.Password, 
                                     NETSETUP_ACCT_CREATE );

   if ( ERROR_SUCCESS != dwErr )
   {
      LOG_VERBOSE(( MSG_VERBOSE_RENAME_COMPUTER_FAILED, dwErr ));
   }

   //
   // Reboot if necessary
   //

   NetDompRestartAsRequired(rgNetDomArgs,
                            pwzComputer,
                            NULL,
                            dwErr,
                            MSG_COMPUTER_RENAME_RESTART_MSG);

   if ( ComputerUser.User )
   {
      LOG_VERBOSE(( MSG_VERBOSE_DELETE_SESSION, pwzComputer ));
      NetpManageIPCConnect( pwzComputer,
                            ComputerUser.User,
                            ComputerUser.Password,
                            NETSETUPP_DISCONNECT_IPC );
   }

RenameComputerExit:

   NetApiBufferFree( pwzNewName );
   if ( pInfo )
   {
      NetApiBufferFree( pInfo );
   }
   NetDompFreeAuthIdent( &ComputerUser );
   NetDompFreeAuthIdent( &DomainUser );

    if (NO_ERROR != dwErr)
    {
        NetDompDisplayErrorMessage(dwErr);
    }

   return dwErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netdom\trust.cxx ===
/*++

Microsoft Windows

Copyright (C) Microsoft Corporation, 1998 - 2001

Module Name:

    trust.cxx

Abstract:

    Handles the various functions for managing domain trust.

--*/
#include "pch.h"
#pragma hdrstop
#include <netdom.h>


VOID
NetDompFreeDomInfo(
    IN OUT PND5_TRUST_INFO TrustInfo
    )
{

    if ( TrustInfo->Connected ) {

        LOG_VERBOSE(( MSG_VERBOSE_DELETE_SESSION, TrustInfo->Server ));
        NetpManageIPCConnect( TrustInfo->Server,
                              NULL,
                              NULL,
                              NETSETUPP_DISCONNECT_IPC );
    }

    NetApiBufferFree( TrustInfo->Server );

    if (TrustInfo->BlobToFree)
    {
        LsaFreeMemory( TrustInfo->BlobToFree );
    }
    else
    {
        if (TrustInfo->DomainName && TrustInfo->DomainName->Buffer)
        {
            NetApiBufferFree(TrustInfo->DomainName->Buffer);
            NetApiBufferFree(TrustInfo->DomainName);
        }
    }

    if ( TrustInfo->LsaHandle ) {

        LsaClose( TrustInfo->LsaHandle );
    }

    if ( TrustInfo->TrustHandle ) {

        LsaClose( TrustInfo->TrustHandle );
    }

}


DWORD
NetDompTrustGetDomInfo(
    IN PWSTR Domain,
    IN PWSTR DomainController  OPTIONAL,
    IN PND5_AUTH_INFO AuthInfo,
    IN OUT PND5_TRUST_INFO TrustInfo,
    IN BOOL ManageTrust,
    IN BOOL fForce,
    IN BOOL fUseNullSession
    )
/*++

Routine Description:

    This function will connect to the domain controller for a given domain and determine the
    appropriate information required for managing trusts.

Arguments:

    Domain - Domain to connect to

    DomainController - Optional name of a dc within the domain to connect to

    TrustInfo - Trusted domain info to accumulate

    ManageTrust - Determines how the Lsa is opened. Also if true, and DomainController is NULL,
                  find a writable DC

    fForce - If true, set the name info even if the domain can't be contacted.

Return Value:

    ERROR_SUCCESS - Success
    ERROR_INVALID_PARAMETER - No object name was supplied

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    PDOMAIN_CONTROLLER_INFO DcInfo = NULL;
    PPOLICY_PRIMARY_DOMAIN_INFO PolicyPDI = NULL;
    PPOLICY_DNS_DOMAIN_INFO PolicyDDI = NULL;
    OBJECT_ATTRIBUTES OA;
    PWSTR pwzDomainName;
    UNICODE_STRING ServerU, DomainNameU;
    NTSTATUS Status;
    ULONG DsGetDcOptions = DS_DIRECTORY_SERVICE_PREFERRED, LsaOptions;


    if ( !DomainController ) {

        if ( ManageTrust ) {

            DsGetDcOptions |= DS_WRITABLE_REQUIRED;
        }

        if (TrustInfo->Flags & NETDOM_TRUST_PDC_REQUIRED)
        {
            DsGetDcOptions |= DS_PDC_REQUIRED;
        }

        Win32Err = DsGetDcName( NULL,
                                Domain,
                                NULL,
                                NULL,
                                DsGetDcOptions,
                                &DcInfo );

        if ( Win32Err == ERROR_SUCCESS ) {

            DomainController = DcInfo->DomainControllerName;
        }
    }

    //
    // Save off the server name
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = NetApiBufferAllocate( ( wcslen( DomainController ) + 1 ) * sizeof( WCHAR ),
                                         (PVOID*)&( TrustInfo->Server ) );

        if ( Win32Err == ERROR_SUCCESS ) {

            wcscpy( TrustInfo->Server, DomainController );
        }
    }

    //
    // Connect to the machine
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        LOG_VERBOSE(( MSG_VERBOSE_ESTABLISH_SESSION, DomainController ));
        Win32Err = NetpManageIPCConnect( DomainController,
                                         (fUseNullSession) ? L"" : AuthInfo->User,
                                         (fUseNullSession) ? L"" : AuthInfo->Password,
                                         (fUseNullSession) ? 
                                            NETSETUPP_NULL_SESSION_IPC : NETSETUPP_CONNECT_IPC);
        if ( Win32Err == ERROR_SUCCESS ) {

            TrustInfo->Connected = TRUE;
        }

        if (ERROR_SESSION_CREDENTIAL_CONFLICT == Win32Err)
        {
            if (fUseNullSession)
            {
                // Ignore conflict of creds.
                //
                Win32Err = ERROR_SUCCESS;
            }
            else
            {
                NetDompDisplayMessage(MSG_ALREADY_CONNECTED, DomainController);
            }
        }

        if (ERROR_LOGON_FAILURE == Win32Err)
        {
            NetApiBufferFree( DcInfo );
            return Win32Err;
        }
    }

    //
    // Get the domain information
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        RtlInitUnicodeString( &ServerU, DomainController );

        InitializeObjectAttributes( &OA, NULL, 0, NULL, NULL );

        LOG_VERBOSE(( MSG_VERBOSE_GET_LSA ));

        LsaOptions = POLICY_VIEW_LOCAL_INFORMATION | POLICY_LOOKUP_NAMES;

        if ( ManageTrust ) {

            LsaOptions |= POLICY_CREATE_SECRET | POLICY_TRUST_ADMIN;
        }

        Status = LsaOpenPolicy( &ServerU,
                                &OA,
                                LsaOptions,
                                &( TrustInfo->LsaHandle ) );

        if ( NT_SUCCESS( Status ) ) {

            Status = LsaQueryInformationPolicy( TrustInfo->LsaHandle,
                                                PolicyDnsDomainInformation,
                                                ( PVOID * )&PolicyDDI );
            if ( NT_SUCCESS( Status ) ) {

                TrustInfo->DomainName = &PolicyDDI->DnsDomainName;
                TrustInfo->FlatName = &PolicyDDI->Name;
                TrustInfo->Sid = PolicyDDI->Sid;
                TrustInfo->BlobToFree = ( PVOID )PolicyDDI;
                TrustInfo->Uplevel = TRUE;
                TrustInfo->fWasDownlevel = FALSE;

            } else if ( Status == RPC_NT_PROCNUM_OUT_OF_RANGE ) {

                Status = LsaQueryInformationPolicy( TrustInfo->LsaHandle,
                                                    PolicyPrimaryDomainInformation,
                                                    ( PVOID * )&PolicyPDI );
                if ( NT_SUCCESS( Status ) ) {

                    TrustInfo->DomainName = &PolicyPDI->Name;
                    TrustInfo->FlatName = &PolicyPDI->Name;
                    TrustInfo->Sid = PolicyPDI->Sid;
                    TrustInfo->BlobToFree = ( PVOID )PolicyPDI;
                    TrustInfo->Uplevel = TrustInfo->fWasDownlevel = FALSE;
                }
            }
        }

        Win32Err = RtlNtStatusToDosError( Status );

        if ( Win32Err != ERROR_SUCCESS ) {
            LOG_VERBOSE(( MSG_VERBOSE_DELETE_SESSION, DomainController ));
            NetpManageIPCConnect( DomainController,
                                  NULL,
                                  NULL,
                                  NETSETUPP_DISCONNECT_IPC );
            TrustInfo->Connected = FALSE;
        }

    } else if (fForce) {

        LOG_VERBOSE(( MSG_VERBOSE_DOMAIN_NOT_FOUND, Domain ));

        TrustInfo->Flags = NETDOM_TRUST_FLAG_DOMAIN_NOT_FOUND;

        // Allocate space to save the user-entered domain name.
        
        Win32Err = NetApiBufferAllocate((wcslen(Domain) + 1) * sizeof(WCHAR), (PVOID*)&pwzDomainName);

        if ( Win32Err == ERROR_SUCCESS ) {

            Win32Err = NetApiBufferAllocate(sizeof(UNICODE_STRING), (PVOID*)&TrustInfo->DomainName);

            if ( Win32Err == ERROR_SUCCESS ) {

                wcscpy( pwzDomainName, Domain );

                RtlInitUnicodeString( TrustInfo->DomainName, pwzDomainName );

                TrustInfo->FlatName = TrustInfo->DomainName;
            }
        }
    }
    else
    {
        LOG_VERBOSE((MSG_DOMAIN_NOT_FOUND, Domain));
    }

    NetApiBufferFree( DcInfo );
    return( Win32Err );
}




DWORD
NetDompTrustRemoveIncomingDownlevelObject(
    IN PND5_TRUST_INFO TrustingInfo,
    IN PND5_TRUST_INFO TrustedInfo
    )
/*++

Routine Description:

    This function removes the interdomain trust account object on
    the trusted domain.

Arguments:

    TrustingInfo - Info on the trusting domain

    TrustedInfo - Info on the trusted domain

Return Value:

    ERROR_INVALID_PARAMETER - No object name was supplied

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    WCHAR AccountName[ UNLEN + 1 ];
    PWSTR FullServer = NULL;

    if ( TrustingInfo->FlatName->Length > DNLEN * sizeof( WCHAR ) ) {

        return( ERROR_INVALID_DOMAINNAME );
    }

    if ( TrustedInfo->Server && *( TrustedInfo->Server ) != L'\\' ) {

        Win32Err = NetApiBufferAllocate( ( wcslen( TrustedInfo->Server ) + 3 ) * sizeof( WCHAR ),
                                         ( PVOID * )&FullServer );

        if ( Win32Err == ERROR_SUCCESS ) {

            swprintf( FullServer, L"\\\\%ws", TrustedInfo->Server );
        }

    } else {

        FullServer = TrustedInfo->Server;
    }

    //
    // Build the account name...
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        swprintf( AccountName, L"%ws$", TrustingInfo->FlatName->Buffer );

        LOG_VERBOSE(( MSG_VERBOSE_DELETE_TACCT, AccountName ));
        Win32Err = NetUserDel( FullServer,
                               AccountName );
    }

    if ( FullServer != TrustedInfo->Server ) {

        NetApiBufferFree( FullServer );
    }

    return( Win32Err );
}


DWORD
NetDompTrustRemoveOutgoingDownlevelObject(
    IN PND5_TRUST_INFO TrustingInfo,
    IN PND5_TRUST_INFO TrustedInfo
    )
/*++

Routine Description:

    This function deletes the trust object/secret on the trusting domain.

Arguments:

    TrustingInfo - Info on the trusting domain

    TrustedInfo - Info on the trusted domain

Return Value:

    ERROR_INVALID_PARAMETER - No object name was supplied

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    WCHAR SecretName[ DNLEN + 4 ];
    LSA_HANDLE TrustedDomain, SecretHandle;
    NTSTATUS Status;
    UNICODE_STRING Secret;

    if ( TrustedInfo->FlatName->Length > DNLEN * sizeof( WCHAR ) ) {

        return( ERROR_INVALID_DOMAINNAME );
    }

    if ( !TrustedInfo->Sid ) {

        // Must be an orphaned trust, nothing we can do.
        return NO_ERROR;
    }

    //
    // Build the secret name
    //
    swprintf( SecretName, L"%ws$%ws", LSA_GLOBAL_SECRET_PREFIX, TrustedInfo->FlatName->Buffer );

    //
    // Ok, first, delete the trust object.  It's ok if the trust object is deleted but the
    // secret is not
    //
    LOG_VERBOSE(( MSG_VERBOSE_OPEN_TRUST, TrustedInfo->DomainName->Buffer ));
    Status = LsaOpenTrustedDomain( TrustingInfo->LsaHandle,
                                   TrustedInfo->Sid,
                                   DELETE,
                                   &TrustedDomain );

    if ( NT_SUCCESS( Status ) ) {

        LOG_VERBOSE(( MSG_VERBOSE_DELETE_TRUST, TrustedInfo->DomainName->Buffer ));
        Status = LsaDelete( TrustedDomain );

        if ( !NT_SUCCESS( Status ) ) {

            LsaClose( TrustedDomain );
        }
    }

    //
    // Now, the same with the secret
    //
    if ( NT_SUCCESS( Status ) ) {

        RtlInitUnicodeString( &Secret, SecretName );

        LOG_VERBOSE(( MSG_VERBOSE_OPEN_SECRET, Secret.Buffer ));
        Status = LsaOpenSecret( TrustingInfo->LsaHandle,
                                &Secret,
                                DELETE,
                                &SecretHandle );
        if ( NT_SUCCESS( Status ) ) {
            LOG_VERBOSE(( MSG_VERBOSE_DELETE_SECRET, Secret.Buffer ));
            Status = LsaDelete( SecretHandle );

            if ( !NT_SUCCESS( Status ) ) {

                LsaClose( SecretHandle );
            }
        }
    }

    Win32Err = RtlNtStatusToDosError( Status );

    return( Win32Err );
}


DWORD
NetDompTrustSetPasswordSam(
    IN PWSTR Server,
    IN PWSTR AccountName,
    IN PWSTR Password
    )
/*++

Routine Description:

    This function will set the password on a SAM trust object

Arguments:

    Server - Server that holds the account object

    AccountName - Name of the account

    Password - Password to set

Return Value:

    ERROR_SUCCESS - The function succeeded

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    USER_INFO_1 UI1, *ReadUI1 = NULL;
    PWSTR FullServer = NULL;

    if ( Server && *( Server ) != L'\\' ) {

        Win32Err = NetApiBufferAllocate( ( wcslen( Server ) + 3 ) * sizeof( WCHAR ),
                                         ( PVOID * )&FullServer );

        if ( Win32Err == ERROR_SUCCESS ) {

            swprintf( FullServer, L"\\\\%ws", Server );
        }

    } else {

        FullServer = Server;
    }


    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = NetUserGetInfo( FullServer,
                                   AccountName,
                                   1,
                                   ( LPBYTE * )&ReadUI1 );

        if ( Win32Err == ERROR_SUCCESS ) {

            if ( !FLAG_ON( ReadUI1->usri1_flags, UF_INTERDOMAIN_TRUST_ACCOUNT ) ) {

                Win32Err = ERROR_SPECIAL_ACCOUNT;

            } else {

                ReadUI1->usri1_password = Password;
                ReadUI1->usri1_flags = UF_INTERDOMAIN_TRUST_ACCOUNT | UF_SCRIPT;
                Win32Err = NetUserSetInfo( FullServer,
                                           AccountName,
                                           1,
                                           ( LPBYTE )ReadUI1,
                                           NULL );
            }

            NetApiBufferFree( ReadUI1 );
        }
    }

    if ( FullServer != Server ) {

        NetApiBufferFree( FullServer );
    }

    return( Win32Err );
}


DWORD
NetDompTrustAddIncomingDownlevelObject(
    IN PND5_TRUST_INFO TrustingInfo,
    IN PND5_TRUST_INFO TrustedInfo,
    IN PWSTR TrustPassword,
    IN ULONG PasswordLength
    )
/*++

Routine Description:

    This function creates the interdomain trust account object on
    the trusted domain.

Arguments:

    TrustingInfo - Info on the trusting domain

    TrustedInfo - Info on the trusted domain

Return Value:

    ERROR_INVALID_PARAMETER - No object name was supplied

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    WCHAR AccountName[ UNLEN + 1 ];
    USER_INFO_1 UI1;
    PWSTR FullServer = NULL;

    if ( TrustingInfo->FlatName->Length > DNLEN * sizeof( WCHAR ) ) {

        return( ERROR_INVALID_DOMAINNAME );
    }

    //
    // Build the account name...
    //
    swprintf( AccountName, L"%ws$", TrustingInfo->FlatName->Buffer );

    LOG_VERBOSE(( MSG_VERBOSE_ADD_TACCT, AccountName ));

    UI1.usri1_name = AccountName;
    UI1.usri1_password = TrustPassword;
    UI1.usri1_password_age = 0;
    UI1.usri1_priv = USER_PRIV_USER;
    UI1.usri1_home_dir = NULL;
    UI1.usri1_comment = NULL;
    UI1.usri1_flags = UF_INTERDOMAIN_TRUST_ACCOUNT | UF_SCRIPT;
    UI1.usri1_script_path = NULL;

    if ( TrustedInfo->Server && *( TrustedInfo->Server ) != L'\\' ) {

        Win32Err = NetApiBufferAllocate( ( wcslen( TrustedInfo->Server ) + 3 ) * sizeof( WCHAR ),
                                         ( PVOID * )&FullServer );

        if ( Win32Err == ERROR_SUCCESS ) {

            swprintf( FullServer, L"\\\\%ws", TrustedInfo->Server );

        }

    } else {

        FullServer = TrustedInfo->Server;
    }

    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = NetUserAdd( FullServer,
                               1,
                               ( LPBYTE )&UI1,
                               NULL );

        if ( Win32Err == NERR_UserExists ) {

            Win32Err = NetDompTrustSetPasswordSam( FullServer,
                                                   AccountName,
                                                   TrustPassword );
        }
    }

    if ( FullServer != TrustedInfo->Server ) {

        NetApiBufferFree( FullServer );
    }

    return( Win32Err );
}


DWORD
NetDompTrustAddOutgoingDownlevelObject(
    IN PND5_TRUST_INFO TrustingInfo,
    IN PND5_TRUST_INFO TrustedInfo,
    IN PWSTR TrustPassword,
    IN ULONG PasswordLength
    )
/*++

Routine Description:

    This function creates the trust secret on the trusting domain.

Arguments:

    TrustingInfo - Info on the trusting domain

    TrustedInfo - Info on the trusted domain

Return Value:

    ERROR_INVALID_PARAMETER - No object name was supplied

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    WCHAR SecretName[ DNLEN + 4 ];
    LSA_HANDLE TrustedDomain = NULL, SecretHandle = NULL;
    NTSTATUS Status;
    UNICODE_STRING Secret, Password;
    BOOL DeleteSecret = FALSE;
    LSA_TRUST_INFORMATION TrustInfo;

    if ( TrustedInfo->FlatName->Length > DNLEN * sizeof( WCHAR ) ) {

        return( ERROR_INVALID_DOMAINNAME );
    }

    //
    // Build the secret name
    //
    swprintf( SecretName, L"%ws$%ws", LSA_GLOBAL_SECRET_PREFIX, TrustedInfo->FlatName->Buffer );

    //
    // Ok, first, create the secret,  It's ok if the secret is created but the
    // trust object is not
    //
    RtlInitUnicodeString( &Secret, SecretName );
    LOG_VERBOSE(( MSG_VERBOSE_CREATE_SECRET, Secret.Buffer ));

    Status = LsaCreateSecret( TrustingInfo->LsaHandle,
                              &Secret,
                              SECRET_SET_VALUE,
                              &SecretHandle );

    if ( NT_SUCCESS( Status ) ) {

        DeleteSecret = TRUE;

    } else if ( Status == STATUS_OBJECT_NAME_COLLISION ) {

        LOG_VERBOSE(( MSG_VERBOSE_OPEN_SECRET, Secret.Buffer ));
        Status = LsaOpenSecret( TrustingInfo->LsaHandle,
                                &Secret,
                                SECRET_SET_VALUE,
                                &SecretHandle );
    }

    if ( NT_SUCCESS( Status ) ) {

        RtlInitUnicodeString( &Password, TrustPassword );
        Status = LsaSetSecret( SecretHandle,
                               &Password,
                               NULL );
    }

    //
    // Ok, now create the trust object
    //
    if ( NT_SUCCESS( Status ) ) {

        TrustInfo.Sid = TrustedInfo->Sid;
        RtlCopyMemory( &TrustInfo.Name, TrustedInfo->FlatName, sizeof( UNICODE_STRING ) );

        LOG_VERBOSE(( MSG_VERBOSE_CREATE_TRUST, TrustInfo.Name.Buffer ));
        Status = LsaCreateTrustedDomain( TrustingInfo->LsaHandle,
                                         &TrustInfo,
                                         TRUSTED_QUERY_DOMAIN_NAME,
                                         &TrustedDomain );

        if ( Status == STATUS_OBJECT_NAME_COLLISION ) {

            Status = STATUS_SUCCESS;
        }
    }

    if ( !NT_SUCCESS( Status ) && DeleteSecret ) {

        LsaDelete( SecretHandle );
        SecretHandle = NULL;
    }

    Win32Err = RtlNtStatusToDosError( Status );

    if ( SecretHandle ) {

        LsaClose( SecretHandle );
    }

    if ( TrustedDomain ) {

        LsaClose( TrustedDomain );
    }

    return( Win32Err );
}


DWORD
NetDompAddOnTrustingSide(
    IN PND5_TRUST_INFO TrustedInfo,
    IN PND5_TRUST_INFO TrustingInfo,
    IN PWSTR TrustPassword,
    IN ULONG Direction,
    IN BOOL Mit
    )
/*++

Routine Description:

    This function creates the trust object on the trusting domain.

Arguments:

    TrustedInfo - Info on the trusted domain

    TrustingInfo - Info on the trusting domain

    Direction - The direction of the trust

    Mit - If true, this is an MIT style trust

Return Value:

    ERROR_INVALID_PARAMETER - No object name was supplied

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    TRUSTED_DOMAIN_INFORMATION_EX TDIEx;
    PTRUSTED_DOMAIN_FULL_INFORMATION pFullInfo;
    TRUSTED_DOMAIN_AUTH_INFORMATION TDAI;
    LSA_AUTH_INFORMATION AuthData;
    ULONG PasswordLength = wcslen(TrustPassword);
    NTSTATUS Status;
    BOOL fSidSet = FALSE;
    PLSA_UNICODE_STRING pName;

    if (TrustingInfo->Flags & NETDOM_TRUST_FLAG_DOMAIN_NOT_FOUND)
    {
        if (Mit)
        {
            return ERROR_SUCCESS;
        }
        else
        {
            return ERROR_INVALID_PARAMETER;
        }
    }

    if ( TrustingInfo->Uplevel ) {

        RtlCopyMemory( &TDIEx.Name, TrustedInfo->DomainName, sizeof( UNICODE_STRING ) );
        TDIEx.Sid = TrustedInfo->Sid;
        TDIEx.TrustDirection = Direction;

        if ( Mit ) {

            TDIEx.TrustType = TRUST_TYPE_MIT;
            TDIEx.TrustAttributes = TRUST_ATTRIBUTE_NON_TRANSITIVE;
            RtlCopyMemory( &TDIEx.FlatName, TrustedInfo->DomainName, sizeof( UNICODE_STRING ) );

        } else {

            TDIEx.TrustType = TrustedInfo->Uplevel ? TRUST_TYPE_UPLEVEL : TRUST_TYPE_DOWNLEVEL;
            TDIEx.TrustAttributes = 0;
            RtlCopyMemory( &TDIEx.FlatName, TrustedInfo->FlatName, sizeof( UNICODE_STRING ) );
        }

        Status  = NtQuerySystemTime( &AuthData.LastUpdateTime );

        if ( NT_SUCCESS( Status ) ) {

            AuthData.AuthType = TRUST_AUTH_TYPE_CLEAR;
            AuthData.AuthInfoLength = PasswordLength * sizeof( WCHAR );
            AuthData.AuthInfo = ( PUCHAR )TrustPassword;

            TDAI.OutgoingAuthInfos = 1;
            TDAI.OutgoingAuthenticationInformation = &AuthData;
            TDAI.OutgoingPreviousAuthenticationInformation = NULL;

            if ( FLAG_ON( Direction, TRUST_DIRECTION_INBOUND ) ) {

                TDAI.IncomingAuthInfos = 1;
                TDAI.IncomingAuthenticationInformation = &AuthData;
                TDAI.IncomingPreviousAuthenticationInformation = NULL;

            } else {

                TDAI.IncomingAuthInfos = 0;
                TDAI.IncomingAuthenticationInformation = NULL;
                TDAI.IncomingPreviousAuthenticationInformation = NULL;
            }

            Status = LsaCreateTrustedDomainEx( TrustingInfo->LsaHandle,
                                               &TDIEx,
                                               &TDAI,
                                               TRUSTED_ALL_ACCESS,
                                               &( TrustingInfo->TrustHandle ) );

            //
            // If the object already exists, morph our info into it.
            //
            if ( Status == STATUS_OBJECT_NAME_COLLISION ) {

                pName = &TDIEx.Name;

                Status = LsaQueryTrustedDomainInfoByName(TrustingInfo->LsaHandle,
                                                         pName,
                                                         TrustedDomainFullInformation,
                                                         (PVOID*)&pFullInfo);

                if (STATUS_OBJECT_NAME_NOT_FOUND == Status)
                {
                    // Now try by flat name; can get here if a downlevel domain
                    // is upgraded to NT5. The name used above was the DNS name
                    // but the TDO would be named after the flat name.
                    //
                    pName = TrustingInfo->FlatName;

                    Status = LsaQueryTrustedDomainInfoByName(TrustedInfo->LsaHandle,
                                                             pName,
                                                             TrustedDomainFullInformation,
                                                             (PVOID*)&pFullInfo);
                }

                if ( NT_SUCCESS( Status ) ) {

                    if ( pFullInfo->Information.TrustDirection == Direction ) {

                        Status = STATUS_OBJECT_NAME_COLLISION;

                    } else {

                        pFullInfo->Information.TrustDirection = TRUST_DIRECTION_BIDIRECTIONAL;
                        pFullInfo->AuthInformation.OutgoingAuthInfos = 1;
                        pFullInfo->AuthInformation.OutgoingAuthenticationInformation = &AuthData;
                        pFullInfo->AuthInformation.OutgoingPreviousAuthenticationInformation = NULL;

                        // Check for a NULL domain SID. The SID can be NULL if the
                        // trust was created when the domain was still NT4.
                        //

                        if (!pFullInfo->Information.Sid)
                        {
                           pFullInfo->Information.Sid = TrustedInfo->Sid;
                           fSidSet = TRUE;
                        }

                        Status = LsaSetTrustedDomainInfoByName(TrustingInfo->LsaHandle,
                                                               pName,
                                                               TrustedDomainFullInformation,
                                                               pFullInfo);
                    }
                }

                if (fSidSet)
                {
                   // Sid memory is owned by the TrustingInfo struct, so don't free
                   // it here.
                   //
                   pFullInfo->Information.Sid = NULL;
                }
                LsaFreeMemory( pFullInfo );
            }
        }

        Win32Err = RtlNtStatusToDosError( Status );

    } else {

        //
        // Doing downlevel
        //
        if ( Mit ) {

            Win32Err = ERROR_INVALID_PARAMETER;

        } else {

            Win32Err = NetDompTrustAddOutgoingDownlevelObject( TrustingInfo,
                                                               TrustedInfo,
                                                               TrustPassword,
                                                               PasswordLength );

            if ( Win32Err == ERROR_SUCCESS &&
                 Direction == TRUST_DIRECTION_BIDIRECTIONAL ) {

                Win32Err = NetDompTrustAddIncomingDownlevelObject( TrustedInfo,
                                                                   TrustingInfo,
                                                                   TrustPassword,
                                                                   PasswordLength );

                if ( Win32Err != ERROR_SUCCESS ) {

                    Win32Err = NetDompTrustRemoveOutgoingDownlevelObject( TrustingInfo,
                                                                          TrustedInfo );

                }
            }

        }
    }

    if (ERROR_SUCCESS == Win32Err)
    {
        LOG_VERBOSE((MSG_VERBOSE_CREATED_TRUST, TrustedInfo->DomainName->Buffer,
                     TrustingInfo->DomainName->Buffer));
    }

    return( Win32Err );
}


DWORD
NetDompAddOnTrustedSide(
    IN PND5_TRUST_INFO TrustedInfo,
    IN PND5_TRUST_INFO TrustingInfo,
    IN PWSTR TrustPassword,
    IN ULONG Direction,
    IN BOOL Mit
    )
/*++

Routine Description:

    This function creates the trust object on the trusted domain.

Arguments:

    TrustedInfo - Info on the trusted domain

    TrustingInfo - Info on the trusting domain

    Direction - The direction of the trust

    Mit - If true, this is an MIT style trust

Return Value:

    ERROR_INVALID_PARAMETER - No object name was supplied

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    TRUSTED_DOMAIN_INFORMATION_EX TDIEx;
    PTRUSTED_DOMAIN_FULL_INFORMATION pFullInfo;
    LSA_AUTH_INFORMATION AuthData;
    TRUSTED_DOMAIN_AUTH_INFORMATION TDAI;
    ULONG PasswordLength = wcslen(TrustPassword);
    NTSTATUS Status;
    BOOL fSidSet = FALSE;
    PLSA_UNICODE_STRING pName;

    if (TrustedInfo->Flags & NETDOM_TRUST_FLAG_DOMAIN_NOT_FOUND)
    {
        if (Mit)
        {
            return ERROR_SUCCESS;
        }
        else
        {
            return ERROR_INVALID_PARAMETER;
        }
    }

    if ( TrustedInfo->Uplevel) {

        RtlCopyMemory( &TDIEx.Name, TrustingInfo->DomainName, sizeof( UNICODE_STRING ) );
        TDIEx.Sid = TrustingInfo->Sid;
        TDIEx.TrustDirection = Direction;

        if ( Mit ) {

            TDIEx.TrustType = TRUST_TYPE_MIT;
            TDIEx.TrustAttributes = TRUST_ATTRIBUTE_NON_TRANSITIVE;
            RtlCopyMemory( &TDIEx.FlatName, TrustingInfo->DomainName, sizeof( UNICODE_STRING ) );

        } else {

            TDIEx.TrustType = TrustingInfo->Uplevel ? TRUST_TYPE_UPLEVEL : TRUST_TYPE_DOWNLEVEL;
            TDIEx.TrustAttributes = 0;
            RtlCopyMemory( &TDIEx.FlatName, TrustingInfo->FlatName, sizeof( UNICODE_STRING ) );
        }

        Status  = NtQuerySystemTime( &AuthData.LastUpdateTime );

        if ( NT_SUCCESS( Status ) ) {

            AuthData.AuthType = TRUST_AUTH_TYPE_CLEAR;
            AuthData.AuthInfoLength = PasswordLength * sizeof( WCHAR );
            AuthData.AuthInfo = ( PUCHAR )TrustPassword;

            TDAI.IncomingAuthInfos = 1;
            TDAI.IncomingAuthenticationInformation = &AuthData;
            TDAI.IncomingPreviousAuthenticationInformation = &AuthData;

            if ( FLAG_ON( Direction, TRUST_DIRECTION_OUTBOUND ) ) {

                TDAI.OutgoingAuthInfos = 1;
                TDAI.OutgoingAuthenticationInformation = &AuthData;
                TDAI.OutgoingPreviousAuthenticationInformation = NULL;

            } else {

                TDAI.OutgoingAuthInfos = 0;
                TDAI.OutgoingAuthenticationInformation = NULL;
                TDAI.OutgoingPreviousAuthenticationInformation = NULL;
            }

            Status = LsaCreateTrustedDomainEx( TrustedInfo->LsaHandle,
                                               &TDIEx,
                                               &TDAI,
                                               TRUSTED_ALL_ACCESS,
                                               &( TrustedInfo->TrustHandle ) );

            //
            // If the object already exists, morph our info into it.
            //
            if ( Status == STATUS_OBJECT_NAME_COLLISION ) {

                pName = &TDIEx.Name;

                Status = LsaQueryTrustedDomainInfoByName(TrustedInfo->LsaHandle,
                                                         pName,
                                                         TrustedDomainFullInformation,
                                                         (PVOID*)&pFullInfo);

                if (STATUS_OBJECT_NAME_NOT_FOUND == Status)
                {
                    // Now try by flat name; can get here if a downlevel domain
                    // is upgraded to NT5. The name used above was the DNS name
                    // but the TDO would be named after the flat name.
                    //
                    pName = TrustingInfo->FlatName;

                    Status = LsaQueryTrustedDomainInfoByName(TrustedInfo->LsaHandle,
                                                             pName,
                                                             TrustedDomainFullInformation,
                                                             (PVOID*)&pFullInfo);
                }

                if ( NT_SUCCESS( Status ) ) {

                    if ( pFullInfo->Information.TrustDirection == Direction ) {

                        Status = STATUS_OBJECT_NAME_COLLISION;

                    } else {

                        pFullInfo->Information.TrustDirection = TRUST_DIRECTION_BIDIRECTIONAL;
                        pFullInfo->AuthInformation.IncomingAuthInfos = 1;
                        pFullInfo->AuthInformation.IncomingAuthenticationInformation = &AuthData;
                        pFullInfo->AuthInformation.IncomingPreviousAuthenticationInformation = NULL;

                        // Check for a NULL domain SID. The SID can be NULL if the
                        // trust was created when the domain was still NT4.
                        //

                        if (!pFullInfo->Information.Sid)
                        {
                           pFullInfo->Information.Sid = TrustingInfo->Sid;
                           fSidSet = TRUE;
                        }

                        Status = LsaSetTrustedDomainInfoByName(TrustedInfo->LsaHandle,
                                                               pName,
                                                               TrustedDomainFullInformation,
                                                               pFullInfo);
                    }
                }

                if (fSidSet)
                {
                   // Sid memory is owned by the TrustingInfo struct, so don't free
                   // it here.
                   //
                   pFullInfo->Information.Sid = NULL;
                }
                LsaFreeMemory( pFullInfo );
            }
        }

        Win32Err = RtlNtStatusToDosError( Status );

    } else {

        //
        // Doing downlevel
        //
        if ( Mit ) {

            Win32Err = ERROR_INVALID_PARAMETER;

        } else {

            Win32Err = NetDompTrustAddIncomingDownlevelObject( TrustingInfo,
                                                               TrustedInfo,
                                                               TrustPassword,
                                                               PasswordLength );

            if ( Win32Err == ERROR_SUCCESS && 
                FLAG_ON( Direction, TRUST_DIRECTION_OUTBOUND ) ) {

                Win32Err = NetDompTrustAddOutgoingDownlevelObject( TrustedInfo,
                                                                   TrustingInfo,
                                                                   TrustPassword,
                                                                   PasswordLength );

                if ( Win32Err != ERROR_SUCCESS ) {

                    Win32Err = NetDompTrustRemoveIncomingDownlevelObject( TrustingInfo,
                                                                          TrustedInfo );

                }
            }
        }
    }

    if (ERROR_SUCCESS == Win32Err)
    {
        LOG_VERBOSE((MSG_VERBOSE_CREATED_TRUST, TrustingInfo->DomainName->Buffer,
                     TrustedInfo->DomainName->Buffer));
    }

    return( Win32Err );
}


DWORD
NetDompResetTrustSC(
    IN PND5_TRUST_INFO TrustingInfo,
    IN PND5_TRUST_INFO TrustedInfo
    )
/*++

Routine Description:

    This function will reset the secure channel between two domains

Arguments:

    TrustingInfo - Information on the trusting side of the domain

    TrustedInfo - Information on the trusted side of the domain

Return Value:

    ERROR_SUCCESS - The function succeeded

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    PWSTR ScDomain = NULL;
    PNETLOGON_INFO_2 NetlogonInfo2 = NULL;
    PWSTR FullServer = NULL, pwzDomName = NULL;

    if (!TrustingInfo->Server)
    {
        return ERROR_INVALID_PARAMETER;
    }

    Win32Err = NetApiBufferAllocate( TrustedInfo->DomainName->Length + sizeof( WCHAR ) +
                                     ( wcslen( TrustedInfo->Server ) * sizeof( WCHAR ) ) +
                                     sizeof( WCHAR ),
                                     (PVOID*)&ScDomain );

    if (ERROR_SUCCESS != Win32Err)
    {
        return Win32Err;
    }

    if (*(TrustingInfo->Server) == L'\\')
    {
        FullServer = TrustingInfo->Server;
    }
    else
    {
        Win32Err = NetApiBufferAllocate((wcslen(TrustingInfo->Server) + 3) * sizeof(WCHAR),
                                        (PVOID *)&FullServer);

        if (ERROR_SUCCESS != Win32Err)
        {
            return Win32Err;
        }

        swprintf(FullServer, L"\\\\%ws", TrustingInfo->Server);
    }

    if (TrustedInfo->fWasDownlevel)
    {
        pwzDomName = TrustedInfo->FlatName->Buffer;
    }
    else
    {
        pwzDomName = TrustedInfo->DomainName->Buffer;
    }

    if (*(TrustedInfo->Server) == L'\\')
    {
        swprintf(ScDomain, L"%ws%ws", pwzDomName, TrustedInfo->Server + 1);
    }
    else
    {
        swprintf(ScDomain, L"%ws\\%ws", pwzDomName, TrustedInfo->Server);
    }

    if ( Win32Err == ERROR_SUCCESS ) {

        LOG_VERBOSE(( MSG_VERBOSE_RESET_SC, ScDomain ));
        Win32Err = I_NetLogonControl2( FullServer,
                                       NETLOGON_CONTROL_REDISCOVER,
                                       2,
                                       ( LPBYTE )&ScDomain,
                                       ( LPBYTE *)&NetlogonInfo2 );

        if ( Win32Err == ERROR_NO_SUCH_DOMAIN || Win32Err == ERROR_INVALID_PARAMETER ) {

            LOG_VERBOSE(( MSG_VERBOSE_RETRY_RESET_SC, ScDomain, TrustedInfo->DomainName->Buffer ));

            //
            // Must be using an downlevel domain, so try it again with out the server
            //
            Win32Err = I_NetLogonControl2( FullServer,
                                           NETLOGON_CONTROL_REDISCOVER,
                                           2,
                                           ( LPBYTE )&( TrustedInfo->DomainName->Buffer ),
                                           ( LPBYTE *)&NetlogonInfo2 );

            if ( Win32Err == ERROR_SUCCESS ) {

                LOG_VERBOSE(( MSG_VERBOSE_RESET_NOT_NAMED, TrustedInfo->Server ));
            }
        }
    }

    NetApiBufferFree( ScDomain );
    if (FullServer != TrustingInfo->Server)
    {
        NetApiBufferFree(FullServer);
    }

    return( Win32Err );
}



DWORD
NetDompTrustRemoveObject(
    IN PND5_TRUST_INFO LocalDomainInfo,
    IN PND5_TRUST_INFO TrustDomainInfo,
    IN ULONG Direction,
    IN BOOL fForce,
    IN PND5_AUTH_INFO pAuthInfo
    )
/*++

Routine Description:

    This function removes the specified trust

Arguments:

    LocalDomainInfo - Info on the domain where the operation is being performed

    TrustDomainInfo - Info on the trusted/trusting domain

    Direction - The direction of the trust

    fForce - If true, remove even if a child.

Return Value:

    ERROR_INVALID_PARAMETER - No object name was supplied

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    NTSTATUS Status = STATUS_SUCCESS;
    PTRUSTED_DOMAIN_INFORMATION_EX ReadTDIEx = NULL;
    BOOL fChild = (TrustDomainInfo->Flags & NETDOM_TRUST_FLAG_CHILD);
    PLDAP pLdap;
    HANDLE hDS;
    PWSTR pwzConfigPath, pwzPartitionsPath, pwzFSMORoleOwner, pwzServerPath,
          pwzServerDNSname, pwzDomainName, pwzNcName, pwzServerObjDN, pwzSettingsDN,
          pwzFilter;
    WCHAR wzPartition[] = L"CN=Partitions,";
    WCHAR wzFilterFormat[] = L"(&(objectClass=nTDSDSA)(hasMasterNCs=%s))";
    RPC_AUTH_IDENTITY_HANDLE AuthHandle;
    PDS_NAME_RESULT pNameResult;
    LDAPMessage *Message = NULL, *Entry;
    PWSTR Attrib[2] = {
        L"foo",
        NULL
    };

    ASSERT(!(fChild && !fForce));
    ASSERT(!(TrustDomainInfo->Flags & NETDOM_TRUST_FLAG_PARENT));

    if ( LocalDomainInfo->Uplevel ) {

        LOG_VERBOSE(( MSG_VERBOSE_OPEN_TRUST, TrustDomainInfo->DomainName->Buffer ));

        if ( !LocalDomainInfo->TrustHandle ) {

            Status = LsaOpenTrustedDomainByName( LocalDomainInfo->LsaHandle,
                                                 TrustDomainInfo->DomainName,
                                                 TRUSTED_ALL_ACCESS, // DELETE | TRUSTED_QUERY_DOMAIN_NAME,
                                                 &( LocalDomainInfo->TrustHandle ) );
        }

        if (STATUS_OBJECT_NAME_NOT_FOUND == Status && TrustDomainInfo->Uplevel) {
            
            // Pre-existing TDOs for domains upgraded from NT4 to NT5 will continue to
            // have a flat name.
            //
            TrustDomainInfo->fWasDownlevel = TRUE;

            Status = LsaOpenTrustedDomainByName( LocalDomainInfo->LsaHandle,
                                                 TrustDomainInfo->FlatName,
                                                 TRUSTED_ALL_ACCESS, // DELETE | TRUSTED_QUERY_DOMAIN_NAME,
                                                 &( LocalDomainInfo->TrustHandle ) );
        }

        if ( NT_SUCCESS( Status ) ) {

            if ( Direction == TRUST_DIRECTION_BIDIRECTIONAL ) {

                LOG_VERBOSE(( MSG_VERBOSE_DELETE_TRUST, TrustDomainInfo->DomainName->Buffer ));

                Status = LsaDelete( LocalDomainInfo->TrustHandle );

                if ( NT_SUCCESS( Status ) ) {

                    LocalDomainInfo->TrustHandle = NULL;
                }

            } else {

                LOG_VERBOSE(( MSG_VERBOSE_GET_TRUST, TrustDomainInfo->DomainName->Buffer ));

                Status = LsaQueryInfoTrustedDomain( LocalDomainInfo->TrustHandle,
                                                    TrustedDomainInformationEx,
                                                    (PVOID*)&ReadTDIEx );

                if ( NT_SUCCESS( Status ) ) {

                    ReadTDIEx->TrustDirection &= ~Direction;

                    if ( 0 == ReadTDIEx->TrustDirection ) {
                            
                        LOG_VERBOSE(( MSG_VERBOSE_DELETE_TRUST, TrustDomainInfo->DomainName->Buffer ));

                        Status = LsaDelete( LocalDomainInfo->TrustHandle );

                        if ( NT_SUCCESS( Status ) ) {

                            LocalDomainInfo->TrustHandle = NULL;
                        }
                    }
                    else {

                        LOG_VERBOSE(( MSG_VERBOSE_SET_TRUST, TrustDomainInfo->DomainName->Buffer ));

                        Status = LsaSetInformationTrustedDomain( LocalDomainInfo->TrustHandle,
                                                                 TrustedDomainInformationEx,
                                                                 ReadTDIEx );
                    }

                    LsaFreeMemory( ReadTDIEx );
                }
            }
        }
        else {

            if (STATUS_OBJECT_NAME_NOT_FOUND == Status) {

                LOG_VERBOSE(( MSG_VERBOSE_TDO_NOT_FOUND, TrustDomainInfo->DomainName->Buffer ));
            }
        }

        Win32Err = LsaNtStatusToWinError(Status);

        DBG_VERBOSE(("Return code from LsaOpen: %d (LSA: %x)\n", Win32Err, Status));

        if (fChild) {

            // Remove the cross ref object. To do that, locate and bind to the naming
            // FSMO DC.
            //
            LOG_VERBOSE((MSG_VERBOSE_DELETE_CROSS_REF, TrustDomainInfo->DomainName->Buffer));

            Win32Err = NetDompLdapBind(LocalDomainInfo->Server + 2, // skip the backslashes
                                       (pAuthInfo->pwzUsersDomain) ?
                                                pAuthInfo->pwzUsersDomain : NULL,
                                       (pAuthInfo->pwzUserWoDomain) ?
                                                pAuthInfo->pwzUserWoDomain : pAuthInfo->User,
                                       pAuthInfo->Password,
                                       LDAP_AUTH_SSPI,
                                       &pLdap);

            if (Win32Err != ERROR_SUCCESS)
            {
                return Win32Err;
            }

            DBG_VERBOSE(("bind succeeded\n"));

            Win32Err = NetDompLdapReadOneAttribute(pLdap,
                                                   NULL, //L"RootDSE",
                                                   L"configurationNamingContext",
                                                   &pwzConfigPath);

            if (Win32Err != ERROR_SUCCESS)
            {
                NetDompLdapUnbind(pLdap);
                return Win32Err;
            }

            Win32Err = NetApiBufferAllocate((wcslen(pwzConfigPath) + wcslen(wzPartition) + 1) * sizeof(WCHAR),
                                            (PVOID*)&pwzPartitionsPath);

            if (Win32Err != ERROR_SUCCESS)
            {
                NetApiBufferFree(pwzConfigPath);
                NetDompLdapUnbind(pLdap);
                return Win32Err;
            }

            wsprintf(pwzPartitionsPath, L"%s%s", wzPartition, pwzConfigPath);

            DBG_VERBOSE(("path: %ws\n", pwzPartitionsPath));

            Win32Err = NetDompLdapReadOneAttribute(pLdap,
                                                   pwzPartitionsPath,
                                                   L"fSMORoleOwner",
                                                   &pwzFSMORoleOwner);
            NetApiBufferFree(pwzPartitionsPath);

            if (Win32Err != ERROR_SUCCESS)
            {
                NetApiBufferFree(pwzConfigPath);
                NetDompLdapUnbind(pLdap);
                return Win32Err;
            }

            DBG_VERBOSE(("fSMORoleOwner: %ws\n", pwzFSMORoleOwner));

            pwzServerPath = wcschr(pwzFSMORoleOwner, L',');

            if (!pwzServerPath)
            {
                NetApiBufferFree(pwzConfigPath);
                NetApiBufferFree(pwzFSMORoleOwner);
                NetDompLdapUnbind(pLdap);
                return ERROR_INVALID_DATA;
            }

            pwzServerPath++;

            Win32Err = NetDompLdapReadOneAttribute(pLdap,
                                                   pwzServerPath,
                                                   L"dNSHostName",
                                                   &pwzServerDNSname);
            NetApiBufferFree(pwzFSMORoleOwner);

            if (Win32Err != ERROR_SUCCESS)
            {
                NetApiBufferFree(pwzConfigPath);
                NetDompLdapUnbind(pLdap);
                return Win32Err;
            }

            DBG_VERBOSE(("Role owner server DNS name: %ws\n", pwzServerDNSname));

            Win32Err = DsMakePasswordCredentials((pAuthInfo->pwzUserWoDomain) ?
                                                    pAuthInfo->pwzUserWoDomain : pAuthInfo->User,
                                                 (pAuthInfo->pwzUsersDomain) ?
                                                    pAuthInfo->pwzUsersDomain : NULL,
                                                 pAuthInfo->Password,
                                                 &AuthHandle);
            if (Win32Err != ERROR_SUCCESS)
            {
                NetApiBufferFree(pwzConfigPath);
                NetApiBufferFree(pwzServerDNSname);
                return Win32Err;
            }

            Win32Err = DsBindWithCred(pwzServerDNSname, NULL, AuthHandle, &hDS);

            NetApiBufferFree(pwzServerDNSname);
            DsFreePasswordCredentials(AuthHandle);

            if (Win32Err != ERROR_SUCCESS)
            {
                NetApiBufferFree(pwzConfigPath);
                return Win32Err;
            }

            DBG_VERBOSE(("DsBind Succeeded, getting domain NC name.\n"));

            Win32Err = NetApiBufferAllocate((wcslen(TrustDomainInfo->DomainName->Buffer) + 2) * sizeof(WCHAR),
                                            (PVOID*)&pwzDomainName);
            if (Win32Err != ERROR_SUCCESS)
            {
                NetApiBufferFree(pwzConfigPath);
                NetDompLdapUnbind(pLdap);
                DsUnBind(&hDS);
                return Win32Err;
            }

            //
            // Get the domain Naming Context DN to use for the removal of the cross-ref.
            // On the first try to get the domain NC DN, assume that the domain name is
            // an NT4 flat name. A backslash must be appended.
            //
            wcscpy(pwzDomainName, TrustDomainInfo->DomainName->Buffer);
            wcscat(pwzDomainName, L"\\");

            DBG_VERBOSE(("Name passed to DsCrackNames is %ws.\n", pwzDomainName));

            Win32Err = DsCrackNames(hDS,
                                    DS_NAME_NO_FLAGS,
                                    DS_NT4_ACCOUNT_NAME,
                                    DS_FQDN_1779_NAME,
                                    1,
                                    &pwzDomainName,
                                    &pNameResult);

            if (Win32Err != ERROR_SUCCESS)
            {
                NetApiBufferFree(pwzConfigPath);
                NetApiBufferFree(pwzDomainName);
                NetDompLdapUnbind(pLdap);
                DsUnBind(&hDS);
                return Win32Err;
            }

            ASSERT(pNameResult);
            ASSERT(pNameResult->cItems == 1);

            if (DS_NAME_NO_ERROR != pNameResult->rItems->status)
            {
                // Try again, this time assume that it might be a DNS name. Replace
                // the back slash with a forward slash.
                //
                pwzDomainName[wcslen(pwzDomainName) -1] = L'/';

                DsFreeNameResultW(pNameResult);

                DBG_VERBOSE(("Try again, name passed to DsCrackNames is %ws.\n", pwzDomainName));

                Win32Err = DsCrackNames(hDS,
                                        DS_NAME_NO_FLAGS,
                                        DS_CANONICAL_NAME,
                                        DS_FQDN_1779_NAME,
                                        1,
                                        &pwzDomainName,
                                        &pNameResult);

                if (Win32Err != ERROR_SUCCESS)
                {
                    NetApiBufferFree(pwzConfigPath);
                    NetApiBufferFree(pwzDomainName);
                    NetDompLdapUnbind(pLdap);
                    DsUnBind(&hDS);
                    return Win32Err;
                }
                ASSERT(pNameResult);
                ASSERT(pNameResult->cItems == 1);
            }

            NetApiBufferFree(pwzDomainName);

            if (DS_NAME_NO_ERROR != pNameResult->rItems->status)
            {
                NetApiBufferFree(pwzConfigPath);
                DsFreeNameResultW(pNameResult);
                NetDompLdapUnbind(pLdap);
                DsUnBind(&hDS);
                return ERROR_NO_SUCH_DOMAIN;
            }

            //
            // Delete the Server object for the domain. Get the name of the server
            // object by searching for the NTDS-Settings object that references the
            // domain NC.
            //
            Win32Err = NetApiBufferAllocate((wcslen(wzFilterFormat) + wcslen(pNameResult->rItems->pName) + 1) * sizeof(WCHAR),
                                            (PVOID*)&pwzFilter);

            if (Win32Err != ERROR_SUCCESS)
            {
                DsFreeNameResultW(pNameResult);
                NetApiBufferFree(pwzConfigPath);
                NetDompLdapUnbind(pLdap);
                DsUnBind(&hDS);
                return Win32Err;
            }

            swprintf(pwzFilter, wzFilterFormat, pNameResult->rItems->pName);

            DBG_VERBOSE(("search filter: %ws\n", pwzFilter));

            Win32Err = LdapMapErrorToWin32(ldap_search_s(pLdap,
                                                         pwzConfigPath,
                                                         LDAP_SCOPE_SUBTREE,
                                                         pwzFilter,
                                                         Attrib,
                                                         0,
                                                         &Message));

            if (Win32Err != ERROR_SUCCESS)
            {
                DBG_VERBOSE(("search for Settings object failed with error %d\n", Win32Err));
                NetApiBufferFree(pwzConfigPath);
                DsFreeNameResultW(pNameResult);
                NetDompLdapUnbind(pLdap);
                DsUnBind(&hDS);
                return Win32Err;
            }

            Entry = ldap_first_entry(pLdap, Message);

            if (Entry) {

                pwzSettingsDN = ldap_get_dnW(pLdap, Entry);

                DBG_VERBOSE(("NTDS Settings object DN: %ws\n", pwzSettingsDN));

                if (pwzSettingsDN) {

                    pwzServerObjDN = wcschr(pwzSettingsDN, L',');

                    if (pwzServerObjDN) {

                        pwzServerObjDN++;

                        Win32Err = DsRemoveDsServerW(hDS,
                                                     pwzServerObjDN,
                                                     NULL,
                                                     NULL,
                                                     TRUE);

                        if (Win32Err == ERROR_SUCCESS)
                        {
                            LOG_VERBOSE((MSG_VERBOSE_NTDSDSA_DELETED, pwzServerObjDN));
                        }
                        else
                        {
                            DBG_VERBOSE(("DsRemoveDsServer failed with error %d\n", Win32Err));

                            LOG_VERBOSE((MSG_VERBOSE_NTDSDSA_NOT_REMOVED, pwzServerObjDN));
                        }
                    }
                }

                ldap_memfree(pwzSettingsDN);
            } else {

                Win32Err = LdapMapErrorToWin32(pLdap->ld_errno);
                DBG_VERBOSE(("search results for Settings object failed with error %d\n", Win32Err));
            }
            ldap_msgfree(Message);

            NetDompLdapUnbind(pLdap); // add to error returns above.
            NetApiBufferFree(pwzConfigPath);

            //
            // Now remove the cross-ref object.
            //
            DBG_VERBOSE(("About to remove the cross-ref for NC %ws.\n", pNameResult->rItems->pName));

            Win32Err = DsRemoveDsDomainW(hDS, pNameResult->rItems->pName);

            if (Win32Err == ERROR_SUCCESS)
            {
                LOG_VERBOSE((MSG_VERBOSE_CROSS_REF_DELETED, pNameResult->rItems->pName));
            }
            else
            {
                DBG_VERBOSE(("DsRemoveDsDomain returned %d.\n", Win32Err));

                if (ERROR_DS_NO_CROSSREF_FOR_NC == Win32Err)
                {
                    LOG_VERBOSE((MSG_VERBOSE_CROSS_REF_NOT_FOUND, pNameResult->rItems->pName));
                }
            }

            DsFreeNameResultW(pNameResult);
            DsUnBind(&hDS);
        }

    } else {

        if ( FLAG_ON( Direction, TRUST_DIRECTION_INBOUND ) ) {

            Win32Err = NetDompTrustRemoveIncomingDownlevelObject( TrustDomainInfo,
                                                                  LocalDomainInfo );
            if ( Win32Err == NERR_UserNotFound ) {

                Win32Err = ERROR_SUCCESS;
            }
        }

        if ( Win32Err == ERROR_SUCCESS && FLAG_ON( Direction, TRUST_DIRECTION_OUTBOUND ) ) {

            Win32Err = NetDompTrustRemoveOutgoingDownlevelObject( LocalDomainInfo,
                                                                  TrustDomainInfo );
        }
    }

    return( Win32Err );
}


DWORD
NetDompCreateTrustObject(
    IN ARG_RECORD * rgNetDomArgs,
    IN PWSTR TrustingDomain,
    IN PWSTR TrustedDomain,
    IN PND5_AUTH_INFO pTrustingCreds,
    IN PND5_AUTH_INFO pTrustedCreds,
    IN PWSTR pwzTrustPW,
    IN PWSTR pwzWhichSide
    )
/*++

Routine Description:

    This function will handle the adding of a trusted domain object

Arguments:

    rgNetDomArgs - List of arguments present in the Args list

    TrustingDomain - Trusting side of the trust

    TrustedDomain - Trusted side of the trust

    pTrustingCreds - Credentials to use when connecting to a domain controller in the
                     trusting domain

    pTrustedCreds - Credentials to use when connecting to a domain controller in the
                    trusted domain

    pwzTrustPW    - Required for creating MIT trust.

    pwzWhichSide  - Required for creating one-side-only, names the side.

Return Value:

    ERROR_INVALID_PARAMETER - No object name was supplied

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    ND5_TRUST_INFO TrustingInfo, TrustedInfo;
    WCHAR TrustPassword[ LM20_PWLEN + 1 ];
    PWSTR pwzPW = NULL;
    WCHAR wzTrusted[NETDOM_STR_LEN], wzTrusting[NETDOM_STR_LEN];
    BOOL fCreateOnTrusted = FALSE, fCreateOnTrusting = FALSE;

    RtlZeroMemory( &TrustingInfo, sizeof( TrustingInfo ) );
    RtlZeroMemory( &TrustedInfo, sizeof( TrustedInfo ) );

    if (CmdFlagOn(rgNetDomArgs, eTrustOneSide))
    {
        if (!LoadString(g_hInstance, IDS_ONESIDE_TRUSTED, wzTrusted, NETDOM_STR_LEN) ||
            !LoadString(g_hInstance, IDS_ONESIDE_TRUSTING, wzTrusting, NETDOM_STR_LEN))
        {
            printf("LoadString FAILED!\n");
            return ERROR_RESOURCE_NAME_NOT_FOUND;
        }

        // Determine on which domain the trust should be created.
        //
        if (_wcsicmp(pwzWhichSide, wzTrusted) == 0)
        {
            fCreateOnTrusted = TRUE;
        }
        else if (_wcsicmp(pwzWhichSide, wzTrusting) == 0)
        {
            fCreateOnTrusting = TRUE;
        }
        else
        {
            NetDompDisplayMessage(MSG_ONESIDE_ARG_STRING);
            return ERROR_INVALID_PARAMETER;
        }
    }

    Win32Err = NetDompTrustGetDomInfo( TrustingDomain,
                                       NULL,
                                       pTrustingCreds,
                                       &TrustingInfo,
                                       !fCreateOnTrusted,
                                       CmdFlagOn(rgNetDomArgs, eTrustRealm),
                                       fCreateOnTrusted);

    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = NetDompTrustGetDomInfo( TrustedDomain,
                                           NULL,
                                           pTrustedCreds,
                                           &TrustedInfo,
                                           !fCreateOnTrusting,
                                           CmdFlagOn(rgNetDomArgs, eTrustRealm),
                                           fCreateOnTrusting);
    }

    if ( Win32Err != ERROR_SUCCESS ) {

        goto TrustAddExit;
    }

    if (CmdFlagOn(rgNetDomArgs, eTrustRealm))
    {
        if (!(TrustingInfo.Flags & NETDOM_TRUST_FLAG_DOMAIN_NOT_FOUND) && 
            !(TrustedInfo.Flags & NETDOM_TRUST_FLAG_DOMAIN_NOT_FOUND))
        {
            // Both domains found (both are Windows domains), can't establish an MIT trust.
            //
            NetDompDisplayMessage(MSG_RESET_MIT_TRUST_NOT_MIT);
            Win32Err = ERROR_INVALID_PARAMETER;
            goto TrustAddExit;
        }

        pwzPW = pwzTrustPW;
    }
    else if (CmdFlagOn(rgNetDomArgs, eTrustOneSide))
    {
        // Create the trust on only one of the two domains.
        //
        if (fCreateOnTrusted)
        {
            Win32Err = NetDompAddOnTrustedSide(&TrustedInfo,
                                               &TrustingInfo,
                                               pwzTrustPW,
                                               CmdFlagOn(rgNetDomArgs, eTrustTwoWay) ?
                                                    TRUST_DIRECTION_BIDIRECTIONAL :
                                                    TRUST_DIRECTION_INBOUND,
                                               FALSE);
        }
        else
        {
            Win32Err = NetDompAddOnTrustingSide(&TrustedInfo,
                                                &TrustingInfo,
                                                pwzTrustPW,
                                                CmdFlagOn(rgNetDomArgs, eTrustTwoWay) ?
                                                    TRUST_DIRECTION_BIDIRECTIONAL :
                                                    TRUST_DIRECTION_OUTBOUND,
                                                FALSE);
        }
        goto TrustAddExit;
    }
    else
    {
        Win32Err = NetDompGenerateRandomPassword( TrustPassword,
                                                  LM20_PWLEN );

        if ( Win32Err != ERROR_SUCCESS ) {

            goto TrustAddExit;
        }

        pwzPW = TrustPassword;
    }

    //
    // Ok, now that we have the password, let's create the trust
    //
    Win32Err = NetDompAddOnTrustedSide( &TrustedInfo,
                                        &TrustingInfo,
                                        pwzPW,
                                        CmdFlagOn(rgNetDomArgs, eTrustTwoWay) ?
                                                  TRUST_DIRECTION_BIDIRECTIONAL :
                                                  TRUST_DIRECTION_INBOUND,
                                        CmdFlagOn(rgNetDomArgs, eTrustRealm));

    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = NetDompAddOnTrustingSide( &TrustedInfo,
                                             &TrustingInfo,
                                             pwzPW,
                                             CmdFlagOn(rgNetDomArgs, eTrustTwoWay) ?
                                                       TRUST_DIRECTION_BIDIRECTIONAL :
                                                       TRUST_DIRECTION_OUTBOUND,
                                             CmdFlagOn(rgNetDomArgs, eTrustRealm));
    }
TrustAddExit:

    NetDompFreeDomInfo( &TrustedInfo );
    NetDompFreeDomInfo( &TrustingInfo );

    return( Win32Err );
}


DWORD
NetDompRemoveTrustObject(
    IN ARG_RECORD * rgNetDomArgs,
    IN PWSTR TrustingDomain,
    IN PWSTR TrustedDomain,
    IN PND5_AUTH_INFO pTrustingCreds,
    IN PND5_AUTH_INFO pTrustedCreds
    )
/*++

Routine Description:

    This function will handle the removal of a trusted domain object

Arguments:

    rgNetDomArgs - List of arguments present in the Args list

    TrustingDomain - Trusting side of the trust

    TrustedDomain - Trusted side of the trust

    pTrustingCreds - Credentials to use when connecting to a domain controller in the
                     trusting domain

    pTrustedCreds - Credentials to use when connecting to a domain controller in the
                    trusted domain

Return Value:

    ERROR_INVALID_PARAMETER - No object name was supplied

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    ND5_TRUST_INFO TrustingInfo, TrustedInfo;
    BOOL fForce = CmdFlagOn(rgNetDomArgs, eCommForce);
    BOOL TwoWay = CmdFlagOn(rgNetDomArgs, eTrustTwoWay);
    BOOL fParentChild = FALSE, fVerifyChildDelete = FALSE;

    RtlZeroMemory( &TrustingInfo, sizeof( TrustingInfo ) );
    RtlZeroMemory( &TrustedInfo, sizeof( TrustedInfo ) );

    Win32Err = NetDompTrustGetDomInfo( TrustingDomain,
                                       NULL,
                                       pTrustingCreds,
                                       &TrustingInfo,
                                       TRUE,
                                       fForce, FALSE );

    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = NetDompTrustGetDomInfo( TrustedDomain,
                                           NULL,
                                           pTrustedCreds,
                                           &TrustedInfo,
                                           TRUE,
                                           fForce, FALSE );
    }

    if ( Win32Err != ERROR_SUCCESS ) {

        if (ERROR_NO_SUCH_DOMAIN == Win32Err) {

            NetDompDisplayMessage(MSG_TRUST_DOMAIN_NOT_FOUND);
        }

        goto TrustRemoveExit;
    }

    Win32Err = NetDompIsParentChild(&TrustingInfo,
                                    &TrustedInfo,
                                    &fParentChild);

    if ( Win32Err != ERROR_SUCCESS ) {

        goto TrustRemoveExit;
    }

    if (fParentChild)
    {
        // Enforce rules for parent-child trust.
        //
        if (TrustingInfo.Flags & NETDOM_TRUST_FLAG_DOMAIN_NOT_FOUND)
        {
            if (TrustingInfo.Flags & NETDOM_TRUST_FLAG_PARENT)
            {
                // The domain that wasn't found was the parent, deletion not allowed.
                //
                NetDompDisplayMessage(MSG_CANT_DELETE_PARENT);
                printf("\n");
                Win32Err = ERROR_NOT_SUPPORTED;
                goto TrustRemoveExit;
            }
            else
            {
                if (!fForce)
                {
                    // Force flag required to delete non-existant child.
                    //
                    NetDompDisplayMessage(MSG_DELETE_CHILD_FORCE_REQ);
                    printf("\n");
                    Win32Err = ERROR_NOT_SUPPORTED;
                    goto TrustRemoveExit;
                }
                else
                {
                    fVerifyChildDelete = TRUE;
                }
            }
        }
        else {
            if (TrustedInfo.Flags & NETDOM_TRUST_FLAG_DOMAIN_NOT_FOUND)
            {
                if (TrustedInfo.Flags & NETDOM_TRUST_FLAG_PARENT)
                {
                    // The domain that wasn't found was the parent, deletion not allowed.
                    //
                    NetDompDisplayMessage(MSG_CANT_DELETE_PARENT);
                    printf("\n");
                    Win32Err = ERROR_NOT_SUPPORTED;
                    goto TrustRemoveExit;
                }
                else
                {
                    if (!fForce)
                    {
                        // Force flag required to delete non-existant child.
                        //
                        NetDompDisplayMessage(MSG_DELETE_CHILD_FORCE_REQ);
                        printf("\n");
                        Win32Err = ERROR_NOT_SUPPORTED;
                        goto TrustRemoveExit;
                    }
                    else
                    {
                        fVerifyChildDelete = TRUE;
                    }
                }
            }
            else
            {
                // Both domains were found, don't allow deletion.
                //
                NetDompDisplayMessage(MSG_CANT_DELETE_PARENT_CHILD);
                printf("\n");
                Win32Err = ERROR_NOT_SUPPORTED;
                goto TrustRemoveExit;
            }
        }
    }

    if (fVerifyChildDelete)
    {
        // Put up a message box asking for confirmation of the deletion.
        //
        PWSTR pwzDomain = (TrustingInfo.Flags & NETDOM_TRUST_FLAG_DOMAIN_NOT_FOUND) ?
                            TrustingInfo.DomainName->Buffer :
                            TrustedInfo.DomainName->Buffer;

        if (!NetDompGetUserConfirmation(IDS_PROMPT_DEL_TRUST, pwzDomain))
        {
            goto TrustRemoveExit;
        }
    }

    if (!(TrustingInfo.Flags & NETDOM_TRUST_FLAG_DOMAIN_NOT_FOUND))
    {
        Win32Err = NetDompTrustRemoveObject( &TrustingInfo,
                                             &TrustedInfo,
                                             (TwoWay || fForce) ?
                                                        TRUST_DIRECTION_BIDIRECTIONAL :
                                                        TRUST_DIRECTION_OUTBOUND,
                                             fForce,
                                             pTrustingCreds );
    }

    if ((Win32Err == ERROR_SUCCESS && !CmdFlagOn(rgNetDomArgs, eTrustRealm)) &&
        !(TrustedInfo.Flags & NETDOM_TRUST_FLAG_DOMAIN_NOT_FOUND)) {

        Win32Err = NetDompTrustRemoveObject( &TrustedInfo,
                                             &TrustingInfo,
                                             (TwoWay || fForce) ?
                                                        TRUST_DIRECTION_BIDIRECTIONAL :
                                                        TRUST_DIRECTION_INBOUND,
                                             fForce,
                                             pTrustedCreds );
    }

TrustRemoveExit:

    NetDompFreeDomInfo( &TrustedInfo );
    NetDompFreeDomInfo( &TrustingInfo );

    return( Win32Err );
}


DWORD
NetDompSetTrustPW(
    IN PND5_TRUST_INFO pDomain1Info,
    IN PND5_TRUST_INFO pDomain2Info,
    IN PWSTR pwzNewTrustPW,
    OUT PDWORD pDirection
    )
/*++

Routine Description:

    This function will set the trust password on Domain1.

Arguments:

    pDomain1Info - Domain on which to set the trust passwords

    pDomain2Info - Domain whose TDO should be set.

    pwzNewTrustPW - new trust password to use.

Return Value:

    ERROR_INVALID_PARAMETER - No object name was supplied

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    PTRUSTED_DOMAIN_FULL_INFORMATION pOldDomain1TDFInfo = NULL;
    TRUSTED_DOMAIN_FULL_INFORMATION NewDomain1TDFInfo;
    LSA_AUTH_INFORMATION NewAuthInfo;
    LARGE_INTEGER ft;
    NTSTATUS Status = STATUS_SUCCESS;

    LOG_VERBOSE((MSG_VERBOSE_GET_TRUST, pDomain1Info->DomainName->Buffer));

    if (pDomain2Info->Sid)
    {
        Status = LsaQueryTrustedDomainInfo(pDomain1Info->LsaHandle,
                                           pDomain2Info->Sid,
                                           TrustedDomainFullInformation,
                                           (PVOID *)&pOldDomain1TDFInfo);
    }
    else
    {
        Status = LsaQueryTrustedDomainInfoByName(pDomain1Info->LsaHandle,
                                                 pDomain2Info->DomainName,
                                                 TrustedDomainFullInformation,
                                                 (PVOID *)&pOldDomain1TDFInfo);
    }

    Win32Err = LsaNtStatusToWinError(Status);

    CHECK_WIN32(Win32Err, goto TrustPwSetExit);

    if (pDirection)
    {
        *pDirection = pOldDomain1TDFInfo->Information.TrustDirection;
    }

    GetSystemTimeAsFileTime((PFILETIME)&ft);

    //
    // Set the current password data.
    //
    NewAuthInfo.LastUpdateTime = ft;
    NewAuthInfo.AuthType = TRUST_AUTH_TYPE_CLEAR;
    NewAuthInfo.AuthInfoLength = wcslen(pwzNewTrustPW) * sizeof(WCHAR);
    NewAuthInfo.AuthInfo = (PUCHAR)pwzNewTrustPW;

    ZeroMemory(&NewDomain1TDFInfo, sizeof(TRUSTED_DOMAIN_FULL_INFORMATION));

    if (pOldDomain1TDFInfo->Information.TrustDirection & TRUST_DIRECTION_INBOUND)
    {
        NewDomain1TDFInfo.AuthInformation.IncomingAuthInfos = 1;
        NewDomain1TDFInfo.AuthInformation.IncomingAuthenticationInformation = &NewAuthInfo;
        NewDomain1TDFInfo.AuthInformation.IncomingPreviousAuthenticationInformation = NULL;
        NewDomain1TDFInfo.Information = pOldDomain1TDFInfo->Information;
    }

    if (pOldDomain1TDFInfo->Information.TrustDirection & TRUST_DIRECTION_OUTBOUND)
    {
        NewDomain1TDFInfo.AuthInformation.OutgoingAuthInfos = 1;
        NewDomain1TDFInfo.AuthInformation.OutgoingAuthenticationInformation = &NewAuthInfo;
        NewDomain1TDFInfo.AuthInformation.OutgoingPreviousAuthenticationInformation = NULL;
        NewDomain1TDFInfo.Information = pOldDomain1TDFInfo->Information;
    }

    LOG_VERBOSE((MSG_VERBOSE_SET_TRUST, pDomain1Info->DomainName->Buffer));

    // Save changes.
    //
    Status = LsaSetTrustedDomainInfoByName(pDomain1Info->LsaHandle,
                                           pDomain2Info->DomainName,
                                           TrustedDomainFullInformation,
                                           &NewDomain1TDFInfo);

    if (STATUS_OBJECT_NAME_NOT_FOUND == Status && pDomain2Info->Uplevel)
    {
        // Pre-existing TDOs for domains upgraded from NT4 to NT5 will continue to
        // have a flat name.
        //
        pDomain2Info->fWasDownlevel = TRUE;

        Status = LsaSetTrustedDomainInfoByName(pDomain1Info->LsaHandle,
                                               pDomain2Info->FlatName,
                                               TrustedDomainFullInformation,
                                               &NewDomain1TDFInfo);
    }

    Win32Err = LsaNtStatusToWinError(Status);

    CHECK_WIN32(Win32Err, goto TrustPwSetExit);

TrustPwSetExit:

    if (pOldDomain1TDFInfo)
        LsaFreeMemory(pOldDomain1TDFInfo);

    return Win32Err;
}


DWORD
NetDompResetTrustPasswords(
    IN PWSTR pwzDomain1,
    IN PWSTR pwzDomain2,
    IN PND5_AUTH_INFO pDomain1Creds,
    IN PND5_AUTH_INFO pDomain2Creds
    )
/*++

Routine Description:

    This function will handle the password reset of the trusted domain objects

Arguments:

    pwzDomain1, pwzDomain2 - Names of domains with trust.

    pDomain1Creds, pDomain2Creds - Credentials to use when connecting to a domain controller
                                   in the domain
--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    NTSTATUS Status = STATUS_SUCCESS;
    ND5_TRUST_INFO Domain1Info, Domain2Info;
    WCHAR wzNewPw[MAX_COMPUTERNAME_LENGTH];
    ULONG Length, i;
    LARGE_INTEGER ft;
    DWORD Direction;

    RtlZeroMemory( &Domain1Info, sizeof( Domain1Info ) );
    RtlZeroMemory( &Domain2Info, sizeof( Domain2Info ) );

    Win32Err = NetDompTrustGetDomInfo( pwzDomain1,
                                       NULL,
                                       pDomain1Creds,
                                       &Domain1Info,
                                       TRUE,
                                       FALSE, FALSE );

    if (Win32Err == ERROR_SUCCESS)
    {
        Win32Err = NetDompTrustGetDomInfo( pwzDomain2,
                                           NULL,
                                           pDomain2Creds,
                                           &Domain2Info,
                                           TRUE,
                                           FALSE, FALSE );
    }

    CHECK_WIN32(Win32Err, goto TrustResetExit);

    if (Domain1Info.Uplevel && Domain2Info.Uplevel)
    {
        NetDompDisplayMessage(MSG_RESET_TRUST_STARTING, pwzDomain1, pwzDomain2);
    }
    else
    {
        NetDompDisplayMessage(MSG_RESET_TRUST_NOT_UPLEVEL);

        goto TrustResetExit;
    }

    //
    // Build a random password
    //
    CDGenerateRandomBits((PUCHAR)wzNewPw, sizeof(wzNewPw));

    // Terminate the password
    Length = MAX_COMPUTERNAME_LENGTH;
    Length--;
    wzNewPw[Length] = L'\0';
    // Make sure there aren't any NULL's in the password
    for (i = 0; i < Length; i++)
    {
        if (wzNewPw[i] == L'\0')
        {
            // arbitrary letter
            wzNewPw[i] = L'c';
        }
    }

    Win32Err = NetDompSetTrustPW(&Domain1Info,
                                 &Domain2Info,
                                 wzNewPw,
                                 &Direction);

    CHECK_WIN32(Win32Err, goto TrustResetExit);

    Win32Err = NetDompSetTrustPW(&Domain2Info,
                                 &Domain1Info,
                                 wzNewPw,
                                 NULL);

    CHECK_WIN32(Win32Err, goto TrustResetExit);

    //
    // Verify the repaired trust.
    //
    if (Direction & TRUST_DIRECTION_OUTBOUND)
    {
        Win32Err = NetDompResetTrustSC( &Domain1Info, &Domain2Info );

        CHECK_WIN32(Win32Err, goto TrustResetExit);
    }

    if (Direction & TRUST_DIRECTION_INBOUND)
    {
        Win32Err = NetDompResetTrustSC( &Domain2Info, &Domain1Info );

        CHECK_WIN32(Win32Err, goto TrustResetExit);
    }

    NetDompDisplayMessage(MSG_RESET_TRUST_OK, pwzDomain1, pwzDomain2);

TrustResetExit:

    NetDompFreeDomInfo( &Domain2Info );
    NetDompFreeDomInfo( &Domain1Info );

    return( Win32Err );
}


DWORD
NetDompSetMitTrustPW(
    IN PWSTR pwzDomain1,
    IN PWSTR pwzDomain2,
    IN PND5_AUTH_INFO pDomain1Creds,
    IN PND5_AUTH_INFO pDomain2Creds,
    IN PWSTR pwzNewTrustPW
    )
/*++

Routine Description:

    This function will handle the password reset of an MIT trusted domain object

Arguments:

    pwzDomain1, pwzDomain2 - Trusted domains

    pDomain1Creds - Credentials to use when connecting to a domain controller in
                    domain21

    pDomain2Creds - Credentials to use when connecting to a domain controller in
                    domain 2

    pwzNewTrustPW - new trust password to use.

Return Value:

    ERROR_INVALID_PARAMETER - No object name was supplied

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    ND5_TRUST_INFO Domain1Info, Domain2Info;
    PND5_TRUST_INFO pDomFoundInfo, pMitDomInfo;

    RtlZeroMemory( &Domain1Info, sizeof( Domain1Info ) );
    RtlZeroMemory( &Domain2Info, sizeof( Domain2Info ) );

    Win32Err = NetDompTrustGetDomInfo( pwzDomain1,
                                       NULL,
                                       pDomain1Creds,
                                       &Domain1Info,
                                       TRUE,
                                       TRUE, FALSE );

    CHECK_WIN32(Win32Err, goto MitTrustPwSetExit);

    Win32Err = NetDompTrustGetDomInfo( pwzDomain2,
                                       NULL,
                                       pDomain2Creds,
                                       &Domain2Info,
                                       TRUE,
                                       TRUE, FALSE );

    CHECK_WIN32(Win32Err, goto MitTrustPwSetExit);

    if ((Domain1Info.Flags & NETDOM_TRUST_FLAG_DOMAIN_NOT_FOUND) &&
        (Domain2Info.Flags & NETDOM_TRUST_FLAG_DOMAIN_NOT_FOUND))
    {
        // at least one must be found.
        //
        Win32Err = ERROR_NO_SUCH_DOMAIN;
        goto MitTrustPwSetExit;
    }

    if (Domain1Info.Flags & NETDOM_TRUST_FLAG_DOMAIN_NOT_FOUND)
    {
        pMitDomInfo = &Domain1Info;
        pDomFoundInfo = &Domain2Info;
    }
    else
    {
        if (Domain2Info.Flags & NETDOM_TRUST_FLAG_DOMAIN_NOT_FOUND)
        {
            pMitDomInfo = &Domain2Info;
            pDomFoundInfo = &Domain1Info;
        }
        else
        {
            NetDompDisplayMessage(MSG_RESET_MIT_TRUST_NOT_MIT);
            Win32Err = ERROR_INVALID_PARAMETER;
            goto MitTrustPwSetExit;
        }
    }

    NetDompDisplayMessage(MSG_RESET_MIT_TRUST_STARTING, pDomFoundInfo->DomainName->Buffer,
                          pMitDomInfo->DomainName->Buffer);

    Win32Err = NetDompSetTrustPW(pDomFoundInfo,
                                 pMitDomInfo,
                                 pwzNewTrustPW,
                                 NULL);

    CHECK_WIN32(Win32Err, goto MitTrustPwSetExit);

    NetDompDisplayMessage(MSG_RESET_MIT_TRUST_OK, pMitDomInfo->DomainName->Buffer);

MitTrustPwSetExit:

    NetDompFreeDomInfo( &Domain2Info );
    NetDompFreeDomInfo( &Domain1Info );

    return( Win32Err );
}


DWORD
NetDomTransitivity(PWSTR pwzTransArg,
                   PWSTR pwzDomain1,
                   PWSTR pwzDomain2,
                   PND5_AUTH_INFO pDomain1Creds,
                   PND5_AUTH_INFO pDomain2Creds)
/*++

Routine Description:

	This routine will display or change the transitivity of a trust.

Arguments:

    pwzTransArg   -- Either blank (display the transitivity) or one of
                     yes or no (change the transitivity).

    pwzDomain1    -- Name of one domain

    pwzDomain2    -- Name of the other domain

    pDomain1Creds -- Credentials of the user of domain1

    pDomain2Creds -- Credentials of the user of domain2
	
Return Value:

    STATUS_SUCCESS -- Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL fDisplayOnly = FALSE;
    BOOL fTransOn = FALSE;
    ND5_TRUST_INFO Domain1Info, Domain2Info;
    PND5_TRUST_INFO pDomFoundInfo, pMitDomInfo;
    PTRUSTED_DOMAIN_INFORMATION_EX pTDIx = NULL;
    WCHAR wzYes[NETDOM_STR_LEN], wzNo[NETDOM_STR_LEN];

    RtlZeroMemory( &Domain1Info, sizeof( Domain1Info ) );
    RtlZeroMemory( &Domain2Info, sizeof( Domain2Info ) );

    Win32Err = NetDompTrustGetDomInfo( pwzDomain1,
                                       NULL,
                                       pDomain1Creds,
                                       &Domain1Info,
                                       TRUE,
                                       TRUE, FALSE );

    CHECK_WIN32(Win32Err, goto TrustSetTransExit);

    Win32Err = NetDompTrustGetDomInfo( pwzDomain2,
                                       NULL,
                                       pDomain2Creds,
                                       &Domain2Info,
                                       TRUE,
                                       TRUE, FALSE );

    CHECK_WIN32(Win32Err, goto TrustSetTransExit);

    if ((Domain1Info.Flags & NETDOM_TRUST_FLAG_DOMAIN_NOT_FOUND) &&
        (Domain2Info.Flags & NETDOM_TRUST_FLAG_DOMAIN_NOT_FOUND))
    {
        // at least one must be found.
        //
        Win32Err = ERROR_NO_SUCH_DOMAIN;
        goto TrustSetTransExit;
    }

    if (Domain1Info.Flags & NETDOM_TRUST_FLAG_DOMAIN_NOT_FOUND)
    {
        pMitDomInfo = &Domain1Info;
        pDomFoundInfo = &Domain2Info;
    }
    else
    {
        if (Domain2Info.Flags & NETDOM_TRUST_FLAG_DOMAIN_NOT_FOUND)
        {
            pMitDomInfo = &Domain2Info;
            pDomFoundInfo = &Domain1Info;
        }
        else
        {
            NetDompDisplayMessage(MSG_RESET_MIT_TRUST_NOT_MIT);
            Win32Err = ERROR_INVALID_PARAMETER;
            goto TrustSetTransExit;
        }
    }

    if (NULL == pwzTransArg)
    {
        fDisplayOnly = TRUE;
    }
    else
    {
        if (!LoadString(g_hInstance, IDS_YES, wzYes, NETDOM_STR_LEN) ||
            !LoadString(g_hInstance, IDS_NO, wzNo, NETDOM_STR_LEN))
        {
            printf("LoadString FAILED!\n");
            Win32Err = ERROR_RESOURCE_NAME_NOT_FOUND;
            goto TrustSetTransExit;
        }

        if (_wcsicmp(wzYes, pwzTransArg) == 0)
        {
            fTransOn = TRUE;
        }
        else
        {
            if (_wcsicmp(wzNo, pwzTransArg) != 0)
            {
                fDisplayOnly = TRUE;
            }
        }
    }

    LOG_VERBOSE((MSG_VERBOSE_GET_TRUST, pDomFoundInfo->DomainName->Buffer));

    if (pMitDomInfo->Sid)
    {
        Status = LsaQueryTrustedDomainInfo(pDomFoundInfo->LsaHandle,
                                           pMitDomInfo->Sid,
                                           TrustedDomainInformationEx,
                                           (PVOID *)&pTDIx);
    }
    else
    {
        Status = LsaQueryTrustedDomainInfoByName(pDomFoundInfo->LsaHandle,
                                                 pMitDomInfo->DomainName,
                                                 TrustedDomainInformationEx,
                                                 (PVOID *)&pTDIx);
    }

    Win32Err = LsaNtStatusToWinError(Status);

    CHECK_WIN32(Win32Err, goto TrustSetTransExit);

    if (TRUST_TYPE_MIT != pTDIx->TrustType)
    {
        NetDompDisplayMessage(MSG_RESET_MIT_TRUST_NOT_MIT);
        Win32Err = ERROR_INVALID_PARAMETER;
        goto TrustSetTransExit;
    }

    if (fDisplayOnly)
    {
        NetDompDisplayMessage((pTDIx->TrustAttributes & TRUST_ATTRIBUTE_NON_TRANSITIVE) ?
                              MSG_TRUST_NON_TRANSITIVE : MSG_TRUST_TRANSITIVE);
        
        goto TrustSetTransExit;
    }


    if (fTransOn)
    {
        if (pTDIx->TrustAttributes & TRUST_ATTRIBUTE_NON_TRANSITIVE)
        {
            NetDompDisplayMessage(MSG_TRUST_SET_TRANSITIVE);
            pTDIx->TrustAttributes &= ~(TRUST_ATTRIBUTE_NON_TRANSITIVE);
        }
        else
        {
            NetDompDisplayMessage(MSG_TRUST_ALREADY_TRANSITIVE);
            goto TrustSetTransExit;
        }
    }
    else
    {
        if (pTDIx->TrustAttributes & TRUST_ATTRIBUTE_NON_TRANSITIVE)
        {
            NetDompDisplayMessage(MSG_TRUST_ALREADY_NON_TRANSITIVE);
            goto TrustSetTransExit;
        }
        else
        {
            NetDompDisplayMessage(MSG_TRUST_SET_NON_TRANSITIVE);
            pTDIx->TrustAttributes |= TRUST_ATTRIBUTE_NON_TRANSITIVE;
        }
    }

    LOG_VERBOSE((MSG_VERBOSE_SET_TRUST, pDomFoundInfo->DomainName->Buffer));

    Status = LsaSetTrustedDomainInfoByName(pDomFoundInfo->LsaHandle,
                                           pMitDomInfo->DomainName,
                                           TrustedDomainInformationEx,
                                           pTDIx);

    Win32Err = LsaNtStatusToWinError(Status);

    CHECK_WIN32(Win32Err, goto TrustSetTransExit);

TrustSetTransExit:

    NetDompFreeDomInfo( &Domain2Info );
    NetDompFreeDomInfo( &Domain1Info );
    if (pTDIx)
        LsaFreeMemory(pTDIx);

    return Win32Err;
}


DWORD
NetDomFilterSID(PWSTR pwzFilterArg,
                PWSTR pwzTrustingDomain,
                PWSTR pwzTrustedDomain,
                PND5_AUTH_INFO pTrustingDomainCreds,
                PND5_AUTH_INFO pDomain2Creds)
/*++

Routine Description:

	This routine will display or change the SID filtering state of a trust.

Arguments:

    pwzFilterArg -- Either blank (display the filtering state) or one of
                    yes or no (change the filtering state).

    pwzTrustingDomain -- Name of the trusting domain domain

    pwzTrustedDomain  -- Name of the trusted domain

    pTrustingDomainCreds -- Credentials of the user of the trusting domain

    pDomain2Creds -- Credentials of the user of domain2 BUGBUG not needed?
	
Return Value:

    STATUS_SUCCESS -- Success

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    NTSTATUS Status = STATUS_SUCCESS;
    BOOL fDisplayOnly = FALSE;
    BOOL fFilterOn = FALSE;
    ND5_TRUST_INFO TrustingDomainInfo, TrustedDomainInfo;
    PTRUSTED_DOMAIN_INFORMATION_EX pTDIx = NULL;
    WCHAR wzYes[NETDOM_STR_LEN], wzNo[NETDOM_STR_LEN];

    RtlZeroMemory(&TrustingDomainInfo, sizeof(TrustingDomainInfo));
    RtlZeroMemory(&TrustedDomainInfo, sizeof(TrustedDomainInfo));

    Win32Err = NetDompTrustGetDomInfo(pwzTrustingDomain,
                                      NULL,
                                      pTrustingDomainCreds,
                                      &TrustingDomainInfo,
                                      TRUE,
                                      FALSE, FALSE);

    CHECK_WIN32(Win32Err, goto TrustSetFilterExit);

    Win32Err = NetDompTrustGetDomInfo(pwzTrustedDomain,
                                      NULL,
                                      NULL,
                                      &TrustedDomainInfo,
                                      FALSE,
                                      TRUE, TRUE);

    CHECK_WIN32(Win32Err, goto TrustSetFilterExit);

    if (TrustingDomainInfo.Flags & NETDOM_TRUST_FLAG_DOMAIN_NOT_FOUND)
    {
        Win32Err = ERROR_NO_SUCH_DOMAIN;
        goto TrustSetFilterExit;
    }

    if (NULL == pwzFilterArg)
    {
        fDisplayOnly = TRUE;
    }
    else
    {
        if (!LoadString(g_hInstance, IDS_YES, wzYes, NETDOM_STR_LEN) ||
            !LoadString(g_hInstance, IDS_NO, wzNo, NETDOM_STR_LEN))
        {
            printf("LoadString FAILED!\n");
            Win32Err = ERROR_RESOURCE_NAME_NOT_FOUND;
            NetApiBufferFree(pwzFilterArg);
            goto TrustSetFilterExit;
        }

        if (_wcsicmp(wzYes, pwzFilterArg) == 0)
        {
            fFilterOn = TRUE;
        }
        else
        {
            if (_wcsicmp(wzNo, pwzFilterArg) != 0)
            {
                fDisplayOnly = TRUE;
            }
        }
        NetApiBufferFree(pwzFilterArg);
    }

    LOG_VERBOSE((MSG_VERBOSE_GET_TRUST, TrustingDomainInfo.DomainName->Buffer));

    if (TrustedDomainInfo.Sid)
    {
        Status = LsaQueryTrustedDomainInfo(TrustingDomainInfo.LsaHandle,
                                           TrustedDomainInfo.Sid,
                                           TrustedDomainInformationEx,
                                           (PVOID *)&pTDIx);
    }
    else
    {
        Status = LsaQueryTrustedDomainInfoByName(TrustingDomainInfo.LsaHandle,
                                                 TrustedDomainInfo.DomainName,
                                                 TrustedDomainInformationEx,
                                                 (PVOID *)&pTDIx);
    }

    Win32Err = LsaNtStatusToWinError(Status);

    CHECK_WIN32(Win32Err, goto TrustSetFilterExit);

    if (!(pTDIx->TrustDirection & TRUST_DIRECTION_OUTBOUND))
    {
        NetDompDisplayMessage(MSG_TRUST_FILTER_SIDS_WRONG_DIR, pwzTrustingDomain);
        goto TrustSetFilterExit;
    }

    if (fDisplayOnly)
    {
        NetDompDisplayMessage((pTDIx->TrustAttributes & TRUST_ATTRIBUTE_FILTER_SIDS) ?
                              MSG_TRUST_FILTER_SIDS : MSG_TRUST_DONT_FILTER_SIDS);
        
        goto TrustSetFilterExit;
    }

    if (fFilterOn)
    {
        if (pTDIx->TrustAttributes & TRUST_ATTRIBUTE_FILTER_SIDS)
        {
            NetDompDisplayMessage(MSG_TRUST_ALREADY_FILTER_SIDS);
            goto TrustSetFilterExit;
        }
        else
        {
            NetDompDisplayMessage(MSG_TRUST_SET_FILTER_SIDS);
            pTDIx->TrustAttributes |= TRUST_ATTRIBUTE_FILTER_SIDS;
        }
    }
    else
    {
        if (pTDIx->TrustAttributes & TRUST_ATTRIBUTE_FILTER_SIDS)
        {
            NetDompDisplayMessage(MSG_TRUST_SET_DONT_FILTER_SIDS);
            pTDIx->TrustAttributes &= ~(TRUST_ATTRIBUTE_FILTER_SIDS);
        }
        else
        {
            NetDompDisplayMessage(MSG_TRUST_ALREADY_DONT_FILTER_SIDS);
            goto TrustSetFilterExit;
        }
    }

    LOG_VERBOSE((MSG_VERBOSE_SET_TRUST, TrustingDomainInfo.DomainName->Buffer));

    Status = LsaSetTrustedDomainInfoByName(TrustingDomainInfo.LsaHandle,
                                           TrustedDomainInfo.DomainName,
                                           TrustedDomainInformationEx,
                                           pTDIx);

    Win32Err = LsaNtStatusToWinError(Status);

    CHECK_WIN32(Win32Err, goto TrustSetFilterExit);

TrustSetFilterExit:

    NetDompFreeDomInfo( &TrustedDomainInfo );
    NetDompFreeDomInfo( &TrustingDomainInfo );
    if (pTDIx)
        LsaFreeMemory(pTDIx);

    return Win32Err;
}


typedef INT_PTR (*DSPROP_DumpFTInfos)(PCWSTR pwzDcName, PCWSTR pwzTrust,
                                      PCWSTR pwzUser, PCWSTR pwzPw);

typedef INT_PTR (*DSPROP_ToggleFTName)(PCWSTR pwzLocalDc, PWSTR pwzTrust, ULONG iSel,
                                       PCWSTR pwzUser, PCWSTR pwzPW);

DWORD
NetDomForestSuffix(PWSTR pwzTrustPartnerArg,
                   ULONG iSel,
                   PWSTR pwzLocalDomain,
                   PND5_AUTH_INFO pLocalDomainCreds)
/*++

Routine Description:

   This routine will toggle the status of a name suffix claimed by a forest trust domain
   or if iSel is zero will display the name suffixes claimed by a forest trust domain.

Arguments:

   pwzTrustPartnerArg -- the domain whose TDO will be read for the name suffixes
                         attribute (ms-DS-Trust-Forest-Trust-Info).

   iSel -- the one-based index of the name to toggle (if zero, display the names).

   pwzLocalDomain -- Name of the domain on which the TDO resides.

   pLocalDomainCreds -- Credentials of the user of the local domain

Return Value:

   STATUS_SUCCESS -- Success

--*/
{
   DWORD Win32Err = ERROR_SUCCESS;
   PDOMAIN_CONTROLLER_INFO pDcInfo = NULL;
   PWSTR pwzDcName = NULL;
   NTSTATUS Status = STATUS_SUCCESS;
   HMODULE hm = NULL;
   DSPROP_DumpFTInfos pDumpFTInfos = NULL;
   DSPROP_ToggleFTName pToggleFTName = NULL;

   ASSERT(pwzTrustPartnerArg && pwzLocalDomain && pLocalDomainCreds);

   Win32Err = DsGetDcName(NULL,
                          pwzLocalDomain,
                          NULL,
                          NULL,
                          DS_PDC_REQUIRED,
                          &pDcInfo );

   CHECK_WIN32(Win32Err, return Win32Err);

   ASSERT(pDcInfo);

   pwzDcName = pDcInfo->DomainControllerName;

   hm = LoadLibrary(L"adprop.dll");
   if (!hm)
   {
      Win32Err = GetLastError();
      NetApiBufferFree(pDcInfo);
      return Win32Err;
   }

   if (0 == iSel)
   {
      pDumpFTInfos = (DSPROP_DumpFTInfos)GetProcAddress(hm, "DSPROP_DumpFTInfos");
   }
   else
   {
      pToggleFTName = (DSPROP_ToggleFTName)GetProcAddress(hm, "DSPROP_ToggleFTName");
   }

   if (!pDumpFTInfos && !pToggleFTName)
   {
      Win32Err = GetLastError();
      NetApiBufferFree(pDcInfo);
      NetDompDisplayMessage(MSG_WRONG_DSPROP_DLL);
      return Win32Err;
   }

   if (0 == iSel)
   {
      Win32Err = (DWORD)(*pDumpFTInfos)(pwzDcName, pwzTrustPartnerArg,
                                        pLocalDomainCreds->User, pLocalDomainCreds->Password);
   }
   else
   {
      Win32Err = (DWORD)(*pToggleFTName)(pwzDcName, pwzTrustPartnerArg, iSel,
                                         pLocalDomainCreds->User, pLocalDomainCreds->Password);
   }

   NetApiBufferFree(pDcInfo);
   return Win32Err;
}


DWORD
NetDompVerifyIndividualTrustKerberos(
    IN PWSTR TrustingDomain,
    IN PWSTR TrustedDomain,
    IN PND5_AUTH_INFO pTrustingCreds,
    IN PND5_AUTH_INFO pTrustedCreds
    )
/*++

Routine Description:

	This routine will verify a single trust in the one direction only.

Arguments:

    TrustingDomain -- Name of the domain on the outbound side

    TrustedDomain  -- Name of the domain on the inbound side

    pTrustingCreds -- Credentials of the user on the outbound side

    pTrustedCreds  -- Credentials of the user on the inbound side
	
Return Value:

    STATUS_SUCCESS -- Success

--*/
{
    //
    // Copy the relevant info into local pointers so that I don't have 
    // to rewrite the rest of the function.
    //
    PWSTR PackageName       = NULL;
    PWSTR UserNameU         = pTrustedCreds->pwzUserWoDomain;
    PWSTR DomainNameU       = pTrustedCreds->pwzUsersDomain;
    PWSTR PasswordU         = pTrustedCreds->Password;
    PWSTR ServerUserNameU   = pTrustingCreds->pwzUserWoDomain;
    PWSTR ServerDomainNameU = pTrustingCreds->pwzUsersDomain;
    PWSTR ServerPasswordU   = pTrustingCreds->Password;
    ULONG ContextReq        = 0;
    ULONG CredFlags         = 0;

    SECURITY_STATUS SecStatus;
    SECURITY_STATUS AcceptStatus;
    SECURITY_STATUS InitStatus;
    CredHandle CredentialHandle2;
    CtxtHandle ClientContextHandle;
    CtxtHandle ServerContextHandle;
    TimeStamp Lifetime;
    ULONG ContextAttributes;
    ULONG PackageCount;
    PSecPkgInfo PackageInfo = NULL;
    ULONG ClientFlags;
    ULONG ServerFlags;
    BOOLEAN AcquiredServerCred = FALSE;
    LPWSTR DomainName = NULL;
    LPWSTR UserName = NULL;
    TCHAR TargetName[256];
    PSEC_WINNT_AUTH_IDENTITY_EXW AuthIdentity = NULL;
    PSEC_WINNT_AUTH_IDENTITY_W ServerAuthIdentity = NULL;
    PUCHAR Where;
    ULONG CredSize;

    SecBufferDesc NegotiateDesc;
    SecBuffer NegotiateBuffer;
    SecBufferDesc ChallengeDesc;
    SecBuffer ChallengeBuffer;
    SecBufferDesc AuthenticateDesc;
    SecBuffer AuthenticateBuffer;

    SecPkgCredentials_Names CredNames;

    CredHandle ServerCredHandleStorage;
    PCredHandle ServerCredHandle = NULL;

    //
    // Set the package to wide-char
    //
    if (PackageName == NULL)
    {
        PackageName = MICROSOFT_KERBEROS_NAME_W;
    }

    //
    // Allocate the Authentication Identity for the outbound trust
    //
    if ((UserNameU != NULL) || (DomainNameU != NULL) || (PasswordU != NULL) || (CredFlags != 0))
    {
        CredSize = (((UserNameU != NULL) ? wcslen(UserNameU) + 1 : 0) +
                    ((DomainNameU != NULL) ? wcslen(DomainNameU) + 1 : 0 ) +
                    ((PasswordU != NULL) ? wcslen(PasswordU) + 1 : 0) ) * sizeof(WCHAR) +
                    sizeof(SEC_WINNT_AUTH_IDENTITY_EXW);
        AuthIdentity = (PSEC_WINNT_AUTH_IDENTITY_EXW) LocalAlloc(LMEM_ZEROINIT,CredSize);

        if (!AuthIdentity)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        AuthIdentity->Version = SEC_WINNT_AUTH_IDENTITY_VERSION;
        Where = (PUCHAR) (AuthIdentity + 1);

        if (UserNameU != NULL)
        {
            AuthIdentity->UserLength = wcslen(UserNameU);
            AuthIdentity->User = (LPWSTR) Where;
            wcscpy(
                (LPWSTR) Where,
                UserNameU
                );
            Where += (wcslen(UserNameU) + 1) * sizeof(WCHAR);
        }

        if (DomainNameU != NULL)
        {
            AuthIdentity->DomainLength = wcslen(DomainNameU);
            AuthIdentity->Domain = (LPWSTR) Where;
            wcscpy(
                (LPWSTR) Where,
                DomainNameU
                );
            Where += (wcslen(DomainNameU) + 1) * sizeof(WCHAR);
        }

        if (PasswordU != NULL)
        {
            AuthIdentity->PasswordLength = wcslen(PasswordU);
            AuthIdentity->Password = (LPWSTR) Where;
            wcscpy(
                (LPWSTR) Where,
                PasswordU
                );
            Where += (wcslen(PasswordU) + 1) * sizeof(WCHAR);
        }
        AuthIdentity->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE | CredFlags;
    }

    //
    // Allocate the Authentication Identity for the outbound trust
    //
    if ((ServerUserNameU != NULL) || (ServerDomainNameU != NULL) || (ServerPasswordU != NULL))
    {
        CredSize = (((ServerUserNameU != NULL) ? wcslen(ServerUserNameU) + 1 : 0) +
                    ((ServerDomainNameU != NULL) ? wcslen(ServerDomainNameU) + 1 : 0 ) +
                    ((ServerPasswordU != NULL) ? wcslen(ServerPasswordU) + 1 : 0) ) * sizeof(WCHAR) +
                    sizeof(SEC_WINNT_AUTH_IDENTITY);
        ServerAuthIdentity = (PSEC_WINNT_AUTH_IDENTITY_W) LocalAlloc(LMEM_ZEROINIT,CredSize);

        if (!ServerAuthIdentity)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        Where = (PUCHAR) (ServerAuthIdentity + 1);

        if (ServerUserNameU != NULL)
        {
            ServerAuthIdentity->UserLength = wcslen(ServerUserNameU);
            ServerAuthIdentity->User = (LPWSTR) Where;
            wcscpy(
                (LPWSTR) Where,
                ServerUserNameU
                );
            Where += (wcslen(ServerUserNameU) + 1) * sizeof(WCHAR);
        }

        if (ServerDomainNameU != NULL)
        {
            ServerAuthIdentity->DomainLength = wcslen(ServerDomainNameU);
            ServerAuthIdentity->Domain = (LPWSTR) Where;
            wcscpy(
                (LPWSTR) Where,
                ServerDomainNameU
                );
            Where += (wcslen(ServerDomainNameU) + 1) * sizeof(WCHAR);
        }

        if (ServerPasswordU != NULL)
        {
            ServerAuthIdentity->PasswordLength = wcslen(ServerPasswordU);
            ServerAuthIdentity->Password = (LPWSTR) Where;
            wcscpy(
                (LPWSTR) Where,
                ServerPasswordU
                );
            Where += (wcslen(ServerPasswordU) + 1) * sizeof(WCHAR);
        }
        ServerAuthIdentity->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE | SEC_WINNT_AUTH_IDENTITY_MARSHALLED;

    }

    CredNames.sUserName = NULL;
    NegotiateBuffer.pvBuffer = NULL;
    ChallengeBuffer.pvBuffer = NULL;
    AuthenticateBuffer.pvBuffer = NULL;


    DomainName = _wgetenv(L"USERDOMAIN");
    UserName = _wgetenv(L"USERNAME");

    //
    // Get info about the security packages.
    //
    SecStatus = EnumerateSecurityPackages( &PackageCount, &PackageInfo );

    if ( SecStatus != STATUS_SUCCESS ) 
    {
        NetDompDisplayMessage( MSG_KERBEROS_TRUST_FAILED, 
                               TrustingDomain, 
                               TrustedDomain );
        return SecStatus;
    }

    //
    // Get info about the security packages.
    //
    SecStatus = QuerySecurityPackageInfo( PackageName, &PackageInfo );

    if ( SecStatus != STATUS_SUCCESS ) 
    {
        NetDompDisplayMessage( MSG_KERBEROS_TRUST_FAILED, 
                               TrustingDomain, 
                               TrustedDomain );
        return SecStatus;
    }


    //
    // Acquire a credential handle for the server side
    //
    if (ServerCredHandle == NULL)
    {

        ServerCredHandle = &ServerCredHandleStorage;
        AcquiredServerCred = TRUE;

        SecStatus = AcquireCredentialsHandle(
                        NULL,
                        PackageName,
                        SECPKG_CRED_INBOUND,
                        NULL,
                        ServerAuthIdentity,
                        NULL,
                        NULL,
                        ServerCredHandle,
                        &Lifetime );

        if ( SecStatus != STATUS_SUCCESS ) 
        {
            NetDompDisplayMessage( MSG_KERBEROS_TRUST_FAILED, 
                                   TrustingDomain, 
                                   TrustedDomain );
            return SecStatus;
        }
    }

    //
    // Acquire a credential handle for the client side
    //
    SecStatus = AcquireCredentialsHandle(
                    NULL,           // New principal
                    PackageName,
                    SECPKG_CRED_OUTBOUND,
                    NULL,
                    AuthIdentity,
                    NULL,
                    NULL,
                    &CredentialHandle2,
                    &Lifetime );

    if ( SecStatus != STATUS_SUCCESS ) 
    {
        NetDompDisplayMessage( MSG_KERBEROS_TRUST_FAILED, 
                               TrustingDomain, 
                               TrustedDomain );
        return SecStatus;
    }

    //
    // Query some cred attributes
    //
    SecStatus = QueryCredentialsAttributes(
                    &CredentialHandle2,
                    SECPKG_CRED_ATTR_NAMES,
                    &CredNames );

    if ( SecStatus != STATUS_SUCCESS ) 
    {
        if ( !NT_SUCCESS(SecStatus) ) 
        {
            NetDompDisplayMessage( MSG_KERBEROS_TRUST_FAILED, 
                                   TrustingDomain, 
                                   TrustedDomain );
            return SecStatus;
        }
    }
    else
    {
        FreeContextBuffer(CredNames.sUserName);
    }

    //
    // Do the same for the client
    //
    SecStatus = QueryCredentialsAttributes(
                    ServerCredHandle,
                    SECPKG_CRED_ATTR_NAMES,
                    &CredNames );

    if ( SecStatus != STATUS_SUCCESS ) 
    {
        if ( !NT_SUCCESS(SecStatus) ) 
        {
            NetDompDisplayMessage( MSG_KERBEROS_TRUST_FAILED, 
                                   TrustingDomain, 
                                   TrustedDomain );
            return SecStatus;
        }
    } 
    else 
    {
        FreeContextBuffer(CredNames.sUserName);
    }


    //
    // Get the NegotiateMessage (ClientSide)
    //
    NegotiateDesc.ulVersion = 0;
    NegotiateDesc.cBuffers = 1;
    NegotiateDesc.pBuffers = &NegotiateBuffer;

    NegotiateBuffer.cbBuffer = PackageInfo->cbMaxToken;
    NegotiateBuffer.BufferType = SECBUFFER_TOKEN;
    NegotiateBuffer.pvBuffer = LocalAlloc( 0, NegotiateBuffer.cbBuffer );
    if ( NegotiateBuffer.pvBuffer == NULL ) 
    {
        DWORD dwError = GetLastError();
        NetDompDisplayMessage( MSG_KERBEROS_TRUST_FAILED, 
                               TrustingDomain, 
                               TrustedDomain );
        return dwError;
    }

    if (ContextReq == 0)
    {
        ClientFlags = ISC_REQ_MUTUAL_AUTH | ISC_REQ_REPLAY_DETECT | ISC_REQ_CONFIDENTIALITY; // USE_DCE_STYLE | ISC_REQ_MUTUAL_AUTH | ISC_REQ_USE_SESSION_KEY; //  | ISC_REQ_DATAGRAM;
    }
    else
    {
        ClientFlags = ContextReq;
    }

    if (ServerUserNameU != NULL && ServerDomainNameU != NULL)
    {
        
        wcscpy(
            TargetName,
            ServerUserNameU
            );
        wcscat(
            TargetName,
            L"@"
            );
        wcscat(
            TargetName,
            ServerDomainNameU
            );
    }

    InitStatus = InitializeSecurityContext(
                    &CredentialHandle2,
                    NULL,               // No Client context yet
                    TargetName,  // Faked target name
                    ClientFlags,
                    0,                  // Reserved 1
                    SECURITY_NATIVE_DREP,
                    NULL,                  // No initial input token
                    0,                  // Reserved 2
                    &ClientContextHandle,
                    &NegotiateDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( InitStatus != STATUS_SUCCESS ) 
    {
        if ( !NT_SUCCESS(InitStatus) ) 
        {
            NetDompDisplayMessage( MSG_KERBEROS_TRUST_FAILED, 
                                   TrustingDomain, 
                                   TrustedDomain );
            return InitStatus;
        }
    }


    //
    // Get the ChallengeMessage (ServerSide)
    //
    NegotiateBuffer.BufferType |= SECBUFFER_READONLY;
    ChallengeDesc.ulVersion = 0;
    ChallengeDesc.cBuffers = 1;
    ChallengeDesc.pBuffers = &ChallengeBuffer;

    ChallengeBuffer.cbBuffer = PackageInfo->cbMaxToken;
    ChallengeBuffer.BufferType = SECBUFFER_TOKEN;
    ChallengeBuffer.pvBuffer = LocalAlloc( 0, ChallengeBuffer.cbBuffer );
    if ( ChallengeBuffer.pvBuffer == NULL ) 
    {
        DWORD dwError = GetLastError();
        NetDompDisplayMessage( MSG_KERBEROS_TRUST_FAILED, 
                               TrustingDomain, 
                               TrustedDomain );
        return dwError;
    }
    ServerFlags = ASC_REQ_EXTENDED_ERROR;

    AcceptStatus = AcceptSecurityContext(
                    ServerCredHandle,
                    NULL,               // No Server context yet
                    &NegotiateDesc,
                    ServerFlags,
                    SECURITY_NATIVE_DREP,
                    &ServerContextHandle,
                    &ChallengeDesc,
                    &ContextAttributes,
                    &Lifetime );

    if ( AcceptStatus != STATUS_SUCCESS ) 
    {
        if ( !NT_SUCCESS(AcceptStatus) ) 
        {
            NetDompDisplayMessage( MSG_KERBEROS_TRUST_FAILED, 
                                   TrustingDomain, 
                                   TrustedDomain );
            return AcceptStatus;
        }
    }

    while (InitStatus != STATUS_SUCCESS)
    {

        //
        // Get the AuthenticateMessage (ClientSide)
        //
        ChallengeBuffer.BufferType |= SECBUFFER_READONLY;
        AuthenticateDesc.ulVersion = 0;
        AuthenticateDesc.cBuffers = 1;
        AuthenticateDesc.pBuffers = &AuthenticateBuffer;

        AuthenticateBuffer.cbBuffer = PackageInfo->cbMaxToken;
        AuthenticateBuffer.BufferType = SECBUFFER_TOKEN;
        if (AuthenticateBuffer.pvBuffer == NULL) 
        {
            AuthenticateBuffer.pvBuffer = LocalAlloc( 0, AuthenticateBuffer.cbBuffer );
            if ( AuthenticateBuffer.pvBuffer == NULL ) 
            {
                DWORD dwError = GetLastError();
                NetDompDisplayMessage( MSG_KERBEROS_TRUST_FAILED, 
                                       TrustingDomain, 
                                       TrustedDomain );
                return dwError;
            }
        }

        InitStatus = InitializeSecurityContext(
                        NULL,
                        &ClientContextHandle,
                        TargetName,
                        ClientFlags,
                        0,                      // Reserved 1
                        SECURITY_NATIVE_DREP,
                        &ChallengeDesc,
                        0,                  // Reserved 2
                        &ClientContextHandle,
                        &AuthenticateDesc,
                        &ContextAttributes,
                        &Lifetime );

        if ( InitStatus != STATUS_SUCCESS ) 
        {
            if ( !NT_SUCCESS(InitStatus) ) 
            {
                NetDompDisplayMessage( MSG_KERBEROS_TRUST_FAILED, 
                                       TrustingDomain, 
                                       TrustedDomain );
                return InitStatus;
            }
        }

        if (AcceptStatus != STATUS_SUCCESS)
        {
            //
            // Finally authenticate the user (ServerSide)
            //
            AuthenticateBuffer.BufferType |= SECBUFFER_READONLY;

            ChallengeBuffer.BufferType = SECBUFFER_TOKEN;
            ChallengeBuffer.cbBuffer = PackageInfo->cbMaxToken;

            AcceptStatus = AcceptSecurityContext(
                            NULL,
                            &ServerContextHandle,
                            &AuthenticateDesc,
                            ServerFlags,
                            SECURITY_NATIVE_DREP,
                            &ServerContextHandle,
                            &ChallengeDesc,
                            &ContextAttributes,
                            &Lifetime );

            if ( AcceptStatus != STATUS_SUCCESS ) 
            {
                if ( !NT_SUCCESS(AcceptStatus) ) 
                {
                    NetDompDisplayMessage( MSG_KERBEROS_TRUST_FAILED, 
                                           TrustingDomain, 
                                           TrustedDomain );
                    return AcceptStatus;
                }
            }
        }
    }
    NetDompDisplayMessage( MSG_KERBEROS_TRUST_SUCCEEDED, TrustedDomain, TrustingDomain );

    return AcceptStatus;
}


DWORD
NetDompVerifyTrust(
    IN PND5_TRUST_INFO pTrustingInfo, // outbound
    IN PND5_TRUST_INFO pTrustedInfo,  // inbound
    BOOL fShowResults
    )
/*++

Routine Description:

    This function will verify a trust connection

Arguments:

    TrustingInfo - Information on the trusting (outbound) side of the domain

    TrustedInfo - Information on the trusted (inbound) side of the domain

Return Value:

    ERROR_SUCCESS - The function succeeded

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    DWORD SidBuff[ sizeof( SID ) / sizeof( DWORD ) + 5 ];
    PSID DomAdminSid = ( PSID )SidBuff;
    PLSA_REFERENCED_DOMAIN_LIST Domains = NULL;
    PLSA_TRANSLATED_NAME Names = NULL;
    NET_API_STATUS NetStatus;
    PNETLOGON_INFO_2 NetlogonInfo2 = NULL;
    PWSTR pwzDomSvr = pTrustedInfo->DomainName->Buffer;
    PWSTR pwzTrustedDomain = pTrustedInfo->DomainName->Buffer;
    BOOL fBufferAlloced = FALSE;

    ASSERT( RtlValidSid( pTrustedInfo->Sid ) );

    if ( !RtlValidSid( pTrustedInfo->Sid ) ) {

        return( ERROR_INVALID_SID );
    }

    if (!pTrustingInfo->Uplevel)
    {
        pwzTrustedDomain = pwzDomSvr = pTrustedInfo->FlatName->Buffer;
    }

    //
    // Check netlogon's secure channel
    //
    NetStatus = I_NetLogonControl2(pTrustingInfo->Server,
                                   NETLOGON_CONTROL_TC_VERIFY,
                                   2,
                                   (LPBYTE)&pwzTrustedDomain,
                                   (LPBYTE *)&NetlogonInfo2);

    if (ERROR_NO_SUCH_DOMAIN == NetStatus && pTrustingInfo->Uplevel)
    {
        // Pre-existing TDOs for domains upgraded from NT4 to NT5 will continue to
        // have a flat name.
        //
        pwzTrustedDomain = pwzDomSvr = pTrustedInfo->FlatName->Buffer;
        pTrustedInfo->fWasDownlevel = TRUE;

        NetStatus = I_NetLogonControl2(pTrustingInfo->Server,
                                       NETLOGON_CONTROL_TC_VERIFY,
                                       2,
                                       (LPBYTE)&pwzTrustedDomain,
                                       (LPBYTE *)&NetlogonInfo2);
    }

    if (ERROR_NOT_SUPPORTED == NetStatus)
    {
        // Must be remoted to a Win2k/NT4 DC that doesn't support SC verify.
        //
        NetStatus = I_NetLogonControl2(pTrustingInfo->Server,
                                       NETLOGON_CONTROL_TC_QUERY,
                                       2,
                                       (LPBYTE)&pwzTrustedDomain,
                                       (LPBYTE *)&NetlogonInfo2);
    }

    if (NERR_Success == NetStatus)
    {
        NetStatus = NetlogonInfo2->netlog2_tc_connection_status;

        if (NERR_Success == NetStatus)
        {
            if (pTrustingInfo->Uplevel)
            {
                // Form the name domain\DC so a reset can done against the same
                // DC that is currently being used for the secure channel.
                //
                NetStatus =  NetApiBufferAllocate((wcslen(NetlogonInfo2->netlog2_trusted_dc_name) +
                                                   wcslen(pwzTrustedDomain) + 1) * sizeof(WCHAR),
                                                  (PVOID*)&pwzDomSvr);
                if (NERR_Success != NetStatus)
                {
                    NetApiBufferFree( NetlogonInfo2 );
                    return ERROR_NOT_ENOUGH_MEMORY;
                }

                fBufferAlloced = TRUE;

                wsprintf(pwzDomSvr, L"%s\\%s", pwzTrustedDomain,
                         (L'\\' == *NetlogonInfo2->netlog2_trusted_dc_name) ?
                             NetlogonInfo2->netlog2_trusted_dc_name + 2 :
                             NetlogonInfo2->netlog2_trusted_dc_name);
            }
        }
        else
        {
            if (fShowResults)
            {
                // Report Query failure.
                //
                NetDompDisplayMessage(MSG_VERIFY_TRUST_QUERY_FAILED, pTrustingInfo->Server, pwzTrustedDomain);
                NetDompDisplayErrorMessage(NetStatus);
            }
        }

        NetApiBufferFree( NetlogonInfo2 );
    }
    else
    {
        if (fShowResults)
        {
            // Report I_NetLogonControl2 error.
            //
            NetDompDisplayMessage(MSG_VERIFY_TRUST_NLQUERY_FAILED, pTrustingInfo->Server, pwzTrustedDomain);
            NetDompDisplayErrorMessage(NetStatus);
            return NetStatus;
        }
    }

    NetStatus = I_NetLogonControl2(pTrustingInfo->Server,
                                   NETLOGON_CONTROL_REDISCOVER,
                                   2,
                                   (LPBYTE)&pwzDomSvr,
                                   (LPBYTE *)&NetlogonInfo2 );

    if (fBufferAlloced)
    {
        NetApiBufferFree(pwzDomSvr);
    }

    if (NERR_Success == NetStatus)
    {
        NetStatus = NetlogonInfo2->netlog2_tc_connection_status;

        if (NERR_Success != NetStatus)
        {
            if (fShowResults)
            {
                // Report Reset failure.
                //
                NetDompDisplayMessage(MSG_VERIFY_TRUST_RESET_FAILED, pTrustingInfo->Server, pwzTrustedDomain);
                NetDompDisplayErrorMessage(NetStatus);
            }
            NetApiBufferFree( NetlogonInfo2 );
            return NetStatus;
        }
        NetApiBufferFree( NetlogonInfo2 );
    }
    else
    {
        if (fShowResults)
        {
            // Report failure
            //
            NetDompDisplayMessage(MSG_VERIFY_TRUST_NLRESET_FAILED, pTrustingInfo->Server, pwzTrustedDomain);
            NetDompDisplayErrorMessage(NetStatus);
        }
        return NetStatus;
    }

    //
    // Now, try a lookup
    //
    if (ERROR_SUCCESS == NetStatus)
    {
        //
        // Build the domain admins sid for the inbound side of the trust
        //
        RtlCopyMemory( DomAdminSid,
                       pTrustedInfo->Sid,
                       RtlLengthSid( pTrustedInfo->Sid ) );

        ( ( PISID )( DomAdminSid ) )->SubAuthorityCount++;
        *( RtlSubAuthoritySid( DomAdminSid,
                               *( RtlSubAuthorityCountSid( pTrustedInfo->Sid ) ) ) ) =
                                                                        DOMAIN_GROUP_RID_ADMINS;
        //
        // Now, we'll simply do a remote lookup, and ensure that we get back success
        //
        Status = LsaLookupSids( pTrustingInfo->LsaHandle,
                                1,
                                &DomAdminSid,
                                &Domains,
                                &Names );

        if ( NT_SUCCESS( Status ) )
        {
            LsaFreeMemory( Domains );
            LsaFreeMemory( Names );
            NetStatus = ERROR_SUCCESS;
        }
        else
        {
            if ( Status == STATUS_NONE_MAPPED )
            {
                NetStatus = ERROR_TRUSTED_DOMAIN_FAILURE;
            }
            else
            {
                NetStatus = RtlNtStatusToDosError( Status );
            }

            if (fShowResults)
            {
                // Report failure
                //
                NetDompDisplayMessage(MSG_VERIFY_TRUST_LOOKUP_FAILED, pTrustingInfo->Server, pwzTrustedDomain);
                NetDompDisplayErrorMessage(NetStatus);
            }
        }
    }

    return NetStatus;
}


DWORD
NetDompVerifyTrustObject(
    IN ARG_RECORD * rgNetDomArgs,
    IN PWSTR pwzDomain1,
    IN PWSTR pwzDomain2,
    IN PND5_AUTH_INFO pDomain1Creds,
    IN PND5_AUTH_INFO pDomain2Creds
    )
/*++

Routine Description:

    This function will handle the adding of a trusted domain object

Arguments:

    rgNetDomArgs - List of arguments present in the Args list

    pwzDomain1, pwzDomain2 - domains with trust

    pDomain1Creds, pDomain2Creds - Credentials to use when connecting to
                    the domain controllers

Return Value:

    ERROR_INVALID_PARAMETER - No object name was supplied

--*/
{
    DWORD Win32Err, Win32Err1;
    ND5_TRUST_INFO TrustInfo1, TrustInfo2;
    PND5_TRUST_INFO pTrustInfoUplevel, pTrustInfoOther;
    DWORD Direction;

    if (CmdFlagOn(rgNetDomArgs, eTrustRealm))
    {
        return ERROR_INVALID_PARAMETER;
    }

    RtlZeroMemory( &TrustInfo1, sizeof( TrustInfo1 ) );
    RtlZeroMemory( &TrustInfo2, sizeof( TrustInfo2 ) );

    Win32Err = NetDompTrustGetDomInfo( pwzDomain1,
                                       NULL,
                                       pDomain1Creds,
                                       &TrustInfo1,
                                       TRUE,
                                       FALSE, FALSE );

    if (ERROR_SUCCESS == Win32Err) {

        Win32Err = NetDompTrustGetDomInfo( pwzDomain2,
                                           NULL,
                                           pDomain2Creds,
                                           &TrustInfo2,
                                           TRUE,
                                           FALSE, FALSE );
    }

    if (ERROR_SUCCESS != Win32Err)
    {
        goto TrustVerifyExit;
    }

    Win32Err = NetDompGetTrustDirection(&TrustInfo1,
                                        &TrustInfo2,
                                        &Direction);
    if (ERROR_SUCCESS != Win32Err)
    {
        goto TrustVerifyExit;
    }

    if (TRUST_DIRECTION_DISABLED == Direction)
    {
        NetDompDisplayMessage(MSG_VERIFY_TRUST_DISABLED);
        goto TrustVerifyExit;
    }

    if (Direction & TRUST_DIRECTION_OUTBOUND)
    {
        LOG_VERBOSE((MSG_VERBOSE_VERIFY_TRUST, pwzDomain1, pwzDomain2));

        Win32Err = NetDompVerifyTrust(&TrustInfo1,
                                      &TrustInfo2,
                                      TRUE);
    }

    if (Direction & TRUST_DIRECTION_INBOUND)
    {
        LOG_VERBOSE((MSG_VERBOSE_VERIFY_TRUST, pwzDomain2, pwzDomain1));

        Win32Err1 = NetDompVerifyTrust(&TrustInfo2,
                                       &TrustInfo1,
                                       TRUE);
    }

    if (ERROR_SUCCESS == Win32Err && ERROR_SUCCESS == Win32Err1)
    {
        NetDompDisplayMessage(MSG_VERIFY_TRUST_OK, pwzDomain1, pwzDomain2);
    }

TrustVerifyExit:

    NetDompFreeDomInfo( &TrustInfo2 );
    NetDompFreeDomInfo( &TrustInfo1 );

    return( Win32Err );
}



DWORD
NetDompHandleTrust(ARG_RECORD * rgNetDomArgs)
/*++

Routine Description:

    This function manages inter-domain trust

Arguments:

    Args - List of command line arguments

Return Value:

    ERROR_INVALID_PARAMETER - No object name was supplied

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    ULONG Ops = 0, i;
    NETDOM_ARG_ENUM BadOp = eArgBegin;
    PWSTR TrustedDomain = NULL, pwzArgValue = NULL, pwzArgValue2 = NULL;
    ND5_AUTH_INFO TrustedDomainUser, TrustingDomainUser;

    RtlZeroMemory( &TrustedDomainUser, sizeof( ND5_AUTH_INFO ) );
    RtlZeroMemory( &TrustingDomainUser, sizeof( ND5_AUTH_INFO ) );

    PWSTR TrustingDomain = rgNetDomArgs[eObject].strValue;

    if ( !TrustingDomain ) {

        DisplayHelp(ePriTrust);
        return( ERROR_INVALID_PARAMETER );
    }

    Win32Err = NetDompValidateSecondaryArguments(rgNetDomArgs,
                                                 eObject,
                                                 eCommDomain,
                                                 eCommUserNameO,
                                                 eCommPasswordO,
                                                 eCommUserNameD,
                                                 eCommPasswordD,
                                                 eTrustRealm,
                                                 eTrustPasswordT,
                                                 eCommAdd,
                                                 eCommRemove,
                                                 eTrustTwoWay,
                                                 eTrustKerberos,
                                                 eTrustTransitive,
                                                 eTrustOneSide,
                                                 eTrustNameSuffixes,
                                                 eTrustToggleSuffixes,
                                                 eTrustFilterSIDs,
                                                 eCommVerify,
                                                 eCommReset,
                                                 eCommForce,
                                                 eCommVerbose,
                                                 eArgEnd);
    if ( Win32Err != ERROR_SUCCESS ) {

        DisplayHelp(ePriTrust);
        return Win32Err;
    }

    //
    // See if we are doing an add, remove, or verify
    //
    if ( CmdFlagOn(rgNetDomArgs, eCommAdd) ) {

        Ops++;

        if (CmdFlagOn(rgNetDomArgs, eTrustTransitive))
        {
            BadOp = eTrustTransitive;
        }
    }

    if ( CmdFlagOn(rgNetDomArgs, eCommRemove) ) {

        if ( Ops ) {

            BadOp = eCommRemove;

        } else {

            Ops++;
        }

        if ( CmdFlagOn(rgNetDomArgs, eTrustRealm) ) {

            BadOp = eTrustRealm;
        }
    }

    if ( CmdFlagOn(rgNetDomArgs, eCommVerify) ) {

        if ( Ops ) {

            BadOp = eCommVerify;

        } else {

            Ops++;
        }
    }

    if (BadOp != eArgBegin) {

        Win32Err = ERROR_INVALID_PARAMETER;
        NetDompDisplayUnexpectedParameter(rgNetDomArgs[BadOp].strArg1);

        goto HandleTrustExit;
    }

    if (!CmdFlagOn(rgNetDomArgs, eTrustNameSuffixes)) {
       //
       // Make sure that we have a specified domain (if not listing claimed names).
       //
       Win32Err = NetDompGetDomainForOperation(rgNetDomArgs,
                                               NULL,      // no server specified
                                               FALSE,     // don't default to current domain.
                                               &TrustedDomain);

       if ( Win32Err != ERROR_SUCCESS ) {

           goto HandleTrustExit;
       }
    }

    //
    // Get the password and user if it exists
    //
    if ( CmdFlagOn(rgNetDomArgs, eCommUserNameD) ) {

        Win32Err = NetDompGetUserAndPasswordForOperation(rgNetDomArgs,
                                                         eCommUserNameD,
                                                         TrustedDomain,
                                                         &TrustedDomainUser );

        if ( Win32Err != ERROR_SUCCESS ) {

            goto HandleTrustExit;
        }
    }

    if ( CmdFlagOn(rgNetDomArgs, eCommUserNameO) ) {

        Win32Err = NetDompGetUserAndPasswordForOperation(rgNetDomArgs,
                                                         eCommUserNameO,
                                                         TrustingDomain,
                                                         &TrustingDomainUser );

        if ( Win32Err != ERROR_SUCCESS ) {

            goto HandleTrustExit;
        }
    }

    if ( CmdFlagOn(rgNetDomArgs, eCommAdd) ) {

        if (CmdFlagOn(rgNetDomArgs, eTrustRealm))
        {
            // Get the trust PW.
            //
            Win32Err = NetDompGetArgumentString(rgNetDomArgs,
                                                eTrustPasswordT,
                                                &pwzArgValue2);
            if (ERROR_SUCCESS != Win32Err)
            {
                goto HandleTrustExit;
            }

            if (pwzArgValue2)
            {
                Win32Err = NetDompCreateTrustObject( rgNetDomArgs,
                                                     TrustingDomain,
                                                     TrustedDomain,
                                                     &TrustingDomainUser,
                                                     &TrustedDomainUser,
                                                     pwzArgValue2,
                                                     NULL);
                NetApiBufferFree(pwzArgValue2);
            }
            else
            {
                NetDompDisplayMessage(MSG_TRUST_PW_MISSING);
                Win32Err = ERROR_INVALID_PARAMETER;
            }
        }
        else if (CmdFlagOn(rgNetDomArgs, eTrustOneSide))
        {
            // Get the trust PW.
            //
            Win32Err = NetDompGetArgumentString(rgNetDomArgs,
                                                eTrustPasswordT,
                                                &pwzArgValue2);
            if (ERROR_SUCCESS != Win32Err)
            {
                goto HandleTrustExit;
            }

            if (!pwzArgValue2)
            {
                NetDompDisplayMessage(MSG_TRUST_PW_MISSING);
                Win32Err = ERROR_INVALID_PARAMETER;
                goto HandleTrustExit;
            }

            // Get the side on which to create the trust.
            //
            Win32Err = NetDompGetArgumentString(rgNetDomArgs,
                                                eTrustOneSide,
                                                &pwzArgValue);
            if (ERROR_SUCCESS != Win32Err)
            {
                NetApiBufferFree(pwzArgValue2);
                goto HandleTrustExit;
            }

            if (!pwzArgValue)
            {
                NetDompDisplayMessage(MSG_ONESIDE_ARG_STRING);
                Win32Err = ERROR_INVALID_PARAMETER;
                NetApiBufferFree(pwzArgValue2);
                goto HandleTrustExit;
            }

            Win32Err = NetDompCreateTrustObject( rgNetDomArgs,
                                                 TrustingDomain,
                                                 TrustedDomain,
                                                 &TrustingDomainUser,
                                                 &TrustedDomainUser,
                                                 pwzArgValue2,
                                                 pwzArgValue);
            NetApiBufferFree(pwzArgValue2);
        }
        else
        {
            Win32Err = NetDompCreateTrustObject( rgNetDomArgs,
                                                 TrustingDomain,
                                                 TrustedDomain,
                                                 &TrustingDomainUser,
                                                 &TrustedDomainUser,
                                                 NULL, NULL);
        }

    } else if ( CmdFlagOn(rgNetDomArgs, eCommRemove) ) {

        Win32Err = NetDompRemoveTrustObject( rgNetDomArgs,
                                             TrustingDomain,
                                             TrustedDomain,
                                             &TrustingDomainUser,
                                             &TrustedDomainUser );

    } else if ( CmdFlagOn(rgNetDomArgs, eCommReset) ) {

        //
        // See if a password is specifed
        //
        if (CmdFlagOn(rgNetDomArgs, eTrustPasswordT))
        {
            Win32Err = NetDompGetArgumentString(rgNetDomArgs,
                                                eTrustPasswordT,
                                                &pwzArgValue2);
            if (ERROR_SUCCESS != Win32Err)
            {
                goto HandleTrustExit;
            }

            if (pwzArgValue2)
            {
                Win32Err = NetDompSetMitTrustPW(TrustingDomain,
                                                TrustedDomain,
                                                &TrustingDomainUser,
                                                &TrustedDomainUser,
                                                pwzArgValue2);
                NetApiBufferFree(pwzArgValue2);
            }
            else
            {
                Win32Err = ERROR_INVALID_PARAMETER;
            }
        }
        else
        {
            Win32Err = NetDompResetTrustPasswords(TrustingDomain,
                                                  TrustedDomain,
                                                  &TrustingDomainUser,
                                                  &TrustedDomainUser);
        }

    } else if ( CmdFlagOn(rgNetDomArgs, eCommVerify ) ) {

        Win32Err = NetDompVerifyTrustObject( rgNetDomArgs,
                                             TrustingDomain,
                                             TrustedDomain,
                                             &TrustingDomainUser,
                                             &TrustedDomainUser );

    } else if ( CmdFlagOn(rgNetDomArgs, eTrustKerberos) ) {

        Win32Err = NetDompVerifyIndividualTrustKerberos( TrustingDomain,
                                                         TrustedDomain,
                                                         &TrustingDomainUser,
                                                         &TrustedDomainUser );

    } else if (CmdFlagOn(rgNetDomArgs, eTrustTransitive)) {

        //
        // Get the transitivity parameter
        //
        Win32Err = NetDompGetArgumentString(rgNetDomArgs,
                                            eTrustTransitive,
                                            &pwzArgValue);
        if (ERROR_SUCCESS != Win32Err)
        {
            goto HandleTrustExit;
        }

        Win32Err = NetDomTransitivity(pwzArgValue,
                                      TrustingDomain,
                                      TrustedDomain,
                                      &TrustingDomainUser,
                                      &TrustedDomainUser );

    } else if (CmdFlagOn(rgNetDomArgs, eTrustFilterSIDs)) {

        //
        // Get the transitivity parameter
        //
        Win32Err = NetDompGetArgumentString(rgNetDomArgs,
                                            eTrustFilterSIDs,
                                            &pwzArgValue);
        if (ERROR_SUCCESS != Win32Err)
        {
            goto HandleTrustExit;
        }

        Win32Err = NetDomFilterSID(pwzArgValue,
                                   TrustingDomain,
                                   TrustedDomain,
                                   &TrustingDomainUser,
                                   &TrustedDomainUser );

    } else if (CmdFlagOn(rgNetDomArgs, eTrustNameSuffixes)) {

        //
        // Get the name of the domain whose name is to be toggled.
        //
        Win32Err = NetDompGetArgumentString(rgNetDomArgs,
                                            eTrustNameSuffixes,
                                            &pwzArgValue);
        if (ERROR_SUCCESS != Win32Err)
        {
            goto HandleTrustExit;
        }

        if (CmdFlagOn(rgNetDomArgs, eTrustToggleSuffixes))
        {
           //
           // Get the number of the name to toggle.
           //
           Win32Err = NetDompGetArgumentString(rgNetDomArgs,
                                               eTrustToggleSuffixes,
                                               &pwzArgValue2);
           if (ERROR_SUCCESS != Win32Err)
           {
               goto HandleTrustExit;
           }

           if (!pwzArgValue2)
           {
               NetDompDisplayMessage(MSG_SUFFIX_INDEX_MISSING);
               Win32Err = ERROR_INVALID_PARAMETER;
               goto HandleTrustExit;
           }

           i = wcstoul(pwzArgValue2, L'\0', 10);

           NetApiBufferFree(pwzArgValue2);
           pwzArgValue2 = NULL;

           if (1 > i)
           {
               NetDompDisplayMessage(MSG_SUFFIX_INDEX_BOUNDS);
               Win32Err = ERROR_INVALID_PARAMETER;
               goto HandleTrustExit;
           }

           Win32Err = NetDomForestSuffix(pwzArgValue,
                                         i,
                                         TrustingDomain,
                                         &TrustingDomainUser);
        }
        else
        {
           Win32Err = NetDomForestSuffix(pwzArgValue,
                                         0,
                                         TrustingDomain,
                                         &TrustingDomainUser);
        }

    } else {

        Win32Err = ERROR_INVALID_PARAMETER;
    }

HandleTrustExit:
    if (pwzArgValue)
    {
        NetApiBufferFree(pwzArgValue);
    }
    NetApiBufferFree( TrustedDomain );
    NetDompFreeAuthIdent( &TrustedDomainUser );
    NetDompFreeAuthIdent( &TrustingDomainUser );

    if (NO_ERROR != Win32Err)
    {
        NetDompDisplayErrorMessage(Win32Err);
    }

    return( Win32Err );
}


DWORD
NetDompIsParentChild(
    IN PND5_TRUST_INFO pFirstDomainInfo,
    IN PND5_TRUST_INFO pSecondDomainInfo,
    OUT BOOL * pfParentChild)
/*++

Routine Description:

    Is the domain named by the second argument a child or parent of the first argument domain.

    The Parent or Child bits of the trust-info Flags element is set as appropriate.

--*/
{
    DWORD Win32Err;
    PDS_DOMAIN_TRUSTS rgDomains = NULL;
    ULONG ulCount = 0, i, ulLocalDomainIdx = (ULONG)-1, ulOtherDomainIdx = (ULONG)-1;
    ULONG ulLocalDomainParent = (ULONG)-1, ulOtherDomainParent = (ULONG)-1;
    PWSTR pwzServer, pwzOtherDomainDnsName, pwzOtherDomainNetbiosName;
    BOOL fFirstIsLocal = TRUE;

    *pfParentChild = FALSE;

    // The domain which is used as the starting point for the enumeration is
    // called the "local" domain and the remaining domain is the "other" domain.
    //
    if (pFirstDomainInfo->Flags & NETDOM_TRUST_FLAG_DOMAIN_NOT_FOUND)
    {
        // The first domain does not exist, so use the second domain's server
        // as the starting point for the domain enumeration.
        //
        pwzServer = pSecondDomainInfo->Server;
        ASSERT(!(pSecondDomainInfo->Flags & NETDOM_TRUST_FLAG_DOMAIN_NOT_FOUND));
        pwzOtherDomainDnsName = pFirstDomainInfo->DomainName->Buffer;
        pwzOtherDomainNetbiosName = pFirstDomainInfo->DomainName->Buffer;
        fFirstIsLocal = FALSE;
    }
    else
    {
        // The first domain exists, so use its server as the starting point
        // for the domain enumeration.
        //
        pwzServer = pFirstDomainInfo->Server;
        pwzOtherDomainDnsName = pSecondDomainInfo->DomainName->Buffer;
        pwzOtherDomainNetbiosName = (pSecondDomainInfo->Flags & NETDOM_TRUST_FLAG_DOMAIN_NOT_FOUND) ?
            pSecondDomainInfo->DomainName->Buffer : pSecondDomainInfo->FlatName->Buffer;
    }

    ASSERT(pwzServer);

    // Specifying DS_DOMAIN_IN_FOREST will eliminate any external trusts
    // in the result set.
    //
    Win32Err = DsEnumerateDomainTrusts(pwzServer,
                                       DS_DOMAIN_IN_FOREST,
                                       &rgDomains,
                                       &ulCount);

    if (Win32Err != ERROR_SUCCESS)
    {
        return Win32Err;
    }

    for (i = 0; i < ulCount; i++)
    {
        ASSERT(rgDomains[i].TrustType & TRUST_TYPE_UPLEVEL);

        if (rgDomains[i].Flags & DS_DOMAIN_PRIMARY)
        {
            ulLocalDomainIdx = i;
            DBG_VERBOSE(("%2d: Local domain: %ws (%ws)\n", i, rgDomains[i].DnsDomainName, rgDomains[i].NetbiosDomainName))
            if (!(rgDomains[i].Flags & DS_DOMAIN_TREE_ROOT))
            {
                DBG_VERBOSE(("\tParent index of above domain: %d\n", rgDomains[i].ParentIndex))
                ulLocalDomainParent = rgDomains[i].ParentIndex;
            }
            else
            {
                DBG_VERBOSE(("\tThis domain is a tree root\n"))
            }
            continue;
        }

#if DBG == 1
        DBG_VERBOSE(("%2d: Domain: %ws (%ws)\n", i, rgDomains[i].DnsDomainName, rgDomains[i].NetbiosDomainName))
        if (rgDomains[i].Flags & DS_DOMAIN_TREE_ROOT) DBG_VERBOSE(("\tThis domain is a tree root\n"))
        else DBG_VERBOSE(("\tParent index of above domain: %d\n", rgDomains[i].ParentIndex))
#endif

        if ((rgDomains[i].NetbiosDomainName && _wcsicmp(rgDomains[i].NetbiosDomainName, pwzOtherDomainNetbiosName) == 0) ||
            (rgDomains[i].DnsDomainName && _wcsicmp(rgDomains[i].DnsDomainName, pwzOtherDomainDnsName) == 0))
        {
            ulOtherDomainIdx = i;
            DBG_VERBOSE(("\tThis domain is the second domain\n"))
            if (!(rgDomains[i].Flags & DS_DOMAIN_TREE_ROOT))
            {
                ulOtherDomainParent = rgDomains[i].ParentIndex;
            }
            continue;
        }

#if DBG == 1
        if (!(rgDomains[i].Flags & DS_DOMAIN_DIRECT_OUTBOUND))
        {
            DBG_VERBOSE(("%2d: Indirectly trusted domain: %ws (%ws)\n", i, rgDomains[i].DnsDomainName, rgDomains[i].NetbiosDomainName))
        }
#endif
    }

    if (rgDomains)
    {
        NetApiBufferFree(rgDomains);
    }

    // Determine the relationship between the two domains. One of three
    // situations will apply:
    // 1. The local domain is the parent of the other domain. If true, then
    //    the parent index of the other domain will point to the local domain.
    //    In addition, the other domain cannot be a tree root.
    // 2. The local domain is the child of the other domain. If true, then
    //    the parent index of the local domain will point to the other domain.
    //    The local domain then cannot be a tree root.
    // 3. The two domains don't have a parent-child relationship. It must be
    //    a shortcut or external trust.
    //
    if (ulOtherDomainIdx == (ULONG)-1)
    {
        // Other domain not found, it must be a shortcut trust (case 3 above).
        //
        DBG_VERBOSE(("\n"))
        return ERROR_SUCCESS;
    }

    if (ulLocalDomainParent == ulOtherDomainIdx)
    {
        // Case 2, the local domain is the child of the other domain.
        //
        if (fFirstIsLocal)
        {
            pFirstDomainInfo->Flags |= NETDOM_TRUST_FLAG_CHILD;
            pSecondDomainInfo->Flags |= NETDOM_TRUST_FLAG_PARENT;
        }
        else
        {
            pSecondDomainInfo->Flags |= NETDOM_TRUST_FLAG_CHILD;
            pFirstDomainInfo->Flags |= NETDOM_TRUST_FLAG_PARENT;
        }
    }
    else
    {
        //
        // Case 1 above, the local domain is the parent of the other domain.
        //
        if (fFirstIsLocal)
        {
            pFirstDomainInfo->Flags |= NETDOM_TRUST_FLAG_PARENT;
            pSecondDomainInfo->Flags |= NETDOM_TRUST_FLAG_CHILD;
        }
        else
        {
            pSecondDomainInfo->Flags |= NETDOM_TRUST_FLAG_PARENT;
            pFirstDomainInfo->Flags |= NETDOM_TRUST_FLAG_CHILD;
        }
    }

    *pfParentChild = TRUE;
    DBG_VERBOSE(("\tpfParentChild set to TRUE\n\n"))

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netdom\time.cxx ===
/*++

Microsoft Windows

Copyright (C) Microsoft Corporation, 1998 - 2001

Module Name:

    time.c

Abstract:

    Handles the various functions for the time functionality of netdom

--*/
#include "pch.h"
#pragma hdrstop
#include <netdom.h>


DWORD
NetDompTimeGetDc(
    IN PWSTR Domain,
    IN PWSTR DestServer,
    IN PND5_AUTH_INFO AuthInfo,
    OUT PWSTR *Dc
    )
/*++

Routine Description:

    This function will find the DC to use as a time source for the given machine

Arguments:

    Domain - Domain to get a time source from

    DestServer - Server for which we need a time source

    AuthInfo - Auth info to connect to the destination server for

    Dc - Where the dc name is returned.  Freed via NetApiBufferFree

Return Value:

    ERROR_INVALID_PARAMETER - No object name was supplied

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    PDOMAIN_CONTROLLER_INFO DcInfo = NULL;
    BOOL Retry = FALSE;
    WCHAR FlatName[ CNLEN + 1 ];
    ULONG Len = CNLEN + 1;

    //
    // Get a server name
    //
    Win32Err = DsGetDcName( NULL,
                            Domain,
                            NULL,
                            NULL,
                            DS_GOOD_TIMESERV_PREFERRED,
                            &DcInfo );

    //
    // If we have a destination server specified, make sure that we
    // aren't talking to ourselves... That would kind of defeat the purpose
    //
    if ( Win32Err == ERROR_SUCCESS && DestServer ) {

        if ( !_wcsicmp( DcInfo->DomainControllerName + 2, DestServer ) ) {

            Retry = TRUE;

        } else {

            //
            // Handle the case where we have a Dns dc name and a netbios server name
            //
            if ( wcslen( DestServer ) <= CNLEN && FLAG_ON( DcInfo->Flags, DS_IS_DNS_NAME ) ) {

                if ( !DnsHostnameToComputerName( DcInfo->DomainControllerName + 2,
                                                 FlatName,
                                                 &Len ) ) {

                    Win32Err = GetLastError();

                } else {

                    if ( !_wcsicmp( FlatName, DestServer ) ) {

                        Retry = TRUE;
                    }
                }
            }
        }
    }

    //
    // We have a dc name specified, so connect to that machine, and try it again, with
    // the AvoidSelf flag.  If we can't (like this is an NT4 PDC) then return that we
    // can't find a dc
    //
    if ( Win32Err == ERROR_SUCCESS && Retry ) {

        NetApiBufferFree( DcInfo );
        DcInfo = NULL;

        Win32Err = NetpManageIPCConnect( DestServer,
                                         AuthInfo->User,
                                         AuthInfo->Password,
                                         NETSETUPP_CONNECT_IPC );

        if ( Win32Err == ERROR_SUCCESS ) {

            Win32Err = DsGetDcName( DestServer,
                                    Domain,
                                    NULL,
                                    NULL,
                                    DS_GOOD_TIMESERV_PREFERRED | DS_AVOID_SELF,
                                    &DcInfo );

            NetpManageIPCConnect( DestServer,
                                  AuthInfo->User,
                                  AuthInfo->Password,
                                  NETSETUPP_DISCONNECT_IPC );
        }


    }


    //
    // Copy the name if everything worked
    //
    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = NetApiBufferAllocate( ( wcslen( DcInfo->DomainControllerName + 2 ) + 1 ) *
                                                                                sizeof( WCHAR ),
                                         (PVOID*)Dc );
        if ( Win32Err == ERROR_SUCCESS ) {

            wcscpy( *Dc, DcInfo->DomainControllerName + 2 );
        }
    }

    NetApiBufferFree( DcInfo );

    return( Win32Err );
}



DWORD
NetDompEnableSystimePriv(
    VOID
    )
/*++

Routine Description:

    This function will enable the systemtime privilege for the current thread

Arguments:

    VOID

Return Value:

    ERROR_INVALID_PARAMETER - No object name was supplied

--*/
{
    NTSTATUS Status;
    HANDLE ThreadToken;
    TOKEN_PRIVILEGES Enabled, Previous;
    DWORD PreviousSize;

    Status = NtOpenThreadToken( NtCurrentThread(),
                                TOKEN_READ | TOKEN_WRITE,
                                TRUE,
                                &ThreadToken );

    if ( Status == STATUS_NO_TOKEN ) {

        Status = NtOpenProcessToken( NtCurrentProcess(),
                                     TOKEN_WRITE | TOKEN_READ,
                                     &ThreadToken );
    }

    if ( NT_SUCCESS( Status ) ) {

        Enabled.PrivilegeCount = 1;
        Enabled.Privileges[0].Luid.LowPart = SE_SYSTEMTIME_PRIVILEGE;
        Enabled.Privileges[0].Luid.HighPart = 0;
        Enabled.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
        PreviousSize = sizeof( Previous );

        Status = NtAdjustPrivilegesToken( ThreadToken,
                                          FALSE,
                                          &Enabled,
                                          sizeof( Enabled ),
                                          &Previous,
                                          &PreviousSize );
    }

    return( RtlNtStatusToDosError( Status ) );
}



DWORD
NetDompGetTimeTripLength(
    IN PWSTR Server,
    IN OUT PDWORD TripLength
    )
/*++

Routine Description:

    This function will get an approximate elapsed time for getting the time from a domain
    controller

Arguments:

    Server - Server to get the elapsed trip time for

    TripLength - Number of ticks it takes to get the time

Return Value:

    ERROR_SUCCESS - The function succeeded

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    ULONG StartTime, EndTime, ElapsedTime = 0, i;
    PTIME_OF_DAY_INFO TOD;
#define NETDOMP_NUM_TRIPS 2

    //
    // Get the average from several time trips
    //
    for ( i = 0; i < NETDOMP_NUM_TRIPS && Win32Err == ERROR_SUCCESS; i++ ) {

        StartTime = GetTickCount();
        Win32Err = NetRemoteTOD( Server, ( LPBYTE * )&TOD );
        EndTime = GetTickCount();
        ElapsedTime += ( EndTime - StartTime );

        NetApiBufferFree( TOD );
    }

    if ( Win32Err == ERROR_SUCCESS ) {

        *TripLength = ElapsedTime / NETDOMP_NUM_TRIPS;
    }


    return( Win32Err );
}


DWORD
NetDompResetSingleClient(
    IN PWSTR Server,
    IN PWSTR Dc,
    IN PND5_AUTH_INFO ObjectAuthInfo,
    IN DWORD DcDelay
    )
/*++

Routine Description:

    This function sync the time between and NT5 client and the specified domain controller

Arguments:

    Server - Server to reset the time for

    Dc - Domain controller to sync the time against

    ObjectAuthInfo - User info to connect to the server as

    DcDelay - The amount of time it takes to talk to the dc

Return Value:

    ERROR_SUCCESS - The function succeeded

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    BOOL Connected = FALSE;
    //PSTR ServerA = NULL;

    //
    // Set up a connection to the client machine
    //
    Win32Err =  NetpManageIPCConnect( Server,
                                      ObjectAuthInfo->User,
                                      ObjectAuthInfo->Password,
                                      NETSETUPP_CONNECT_IPC );
    if ( Win32Err == ERROR_SUCCESS ) {

        Connected = TRUE;

    } else {

        goto ResetSingleError;
    }

    //if ( Server ) {
    //
    //    Win32Err = NetApiBufferAllocate( wcstombs( NULL, Server, wcslen( Server ) + 1 ) + 3,
    //                                     &ServerA );
    //    if ( Win32Err != ERROR_SUCCESS ) {
    //
    //        goto ResetSingleError;
    //    }
    //
    //    if ( *Server == L'\\' ) {
    //
    //        strcpy( ServerA, "\\\\" );
    //        wcstombs( ServerA + 2, Server, wcslen( Server ) + 1 );
    //
    //    } else {
    //
    //        wcstombs( ServerA, Server, wcslen( Server ) + 1 );
    //    }
    //}

    Win32Err = W32TimeSyncNow( Server,
                           FALSE,  // no wait
                           TimeSyncFlag_HardResync );

ResetSingleError:

    if ( Connected ) {

        NetpManageIPCConnect( Server,
                              ObjectAuthInfo->User,
                              ObjectAuthInfo->Password,
                              NETSETUPP_DISCONNECT_IPC );
    }

    //NetApiBufferFree( ServerA );
    return( Win32Err );
}


DWORD
NetDompVerifySingleClient(
    IN PWSTR Server,
    IN PWSTR Dc,
    IN PND5_AUTH_INFO ObjectAuthInfo,
    IN DWORD DcDelay,
    IN BOOL * InSync
    )
/*++

Routine Description:

    This function will verify that the time between the specified server and domain controller
    is within the acceptable skew

Arguments:

    Server - Server to verify the time for

    Dc - Domain controller to verify the time against

    ObjectAuthInfo - User and password to connect to the client as

    DcDelay - How long does it take to get the time from the domain controller

    InSync - Where the results are returned.

Return Value:

    ERROR_SUCCESS - The function succeeded

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    SYSTEMTIME StartTime, EndTime;
    PTIME_OF_DAY_INFO DcTOD = NULL, ClientTOD = NULL;
    BOOL Connected = FALSE;
    FILETIME StartFile, EndFile;
    LARGE_INTEGER ElapsedTime, TimeDifference, DcTime, ClientTime, UpdatedDcTime, TimeSkew,
                  AllowedSkew;
    TIME_FIELDS TimeFields;
    LARGE_INTEGER SystemTime;

    //
    // Set the allowable time skew.  600,000,000L is the number of 100 nanoseconds in a minute
    //
#define NETDOMP_VERIFY_SKEW 0xB2D05E00

    //
    // Assume the clocks are fine
    //
    *InSync = TRUE;

    //
    // Set up a connection to the client machine
    //
    Win32Err =  NetpManageIPCConnect( Server,
                                      ObjectAuthInfo->User,
                                      ObjectAuthInfo->Password,
                                      NETSETUPP_CONNECT_IPC );
    if ( Win32Err == ERROR_SUCCESS ) {

        Connected = TRUE;

    } else {

        goto VerifySingleError;
    }

    //
    // Ok, first, we get the time on the dc, then we get the time on the client, keeping in mind
    // how long that takes,
    //
    Win32Err = NetRemoteTOD( Dc, ( LPBYTE * )&DcTOD );

    if ( Win32Err == ERROR_SUCCESS ) {

        Win32Err = NetRemoteTOD( Server, ( LPBYTE * )&ClientTOD );

    }

    if ( Win32Err != ERROR_SUCCESS ) {

        goto VerifySingleError;
    }

    //
    // Ok, now we've gotten all the info we need, assemble it... Note that we are only computing
    // the difference in time here...
    //
    SystemTimeToFileTime( &StartTime, &StartFile );
    SystemTimeToFileTime( &EndTime, &EndFile );


    ElapsedTime = RtlLargeIntegerSubtract( *( PLARGE_INTEGER )&EndFile,
                                           *( PLARGE_INTEGER )&StartFile );


    TimeFields.Hour = ( WORD )DcTOD->tod_hours;
    TimeFields.Minute = ( WORD )DcTOD->tod_mins;
    TimeFields.Second = ( WORD )DcTOD->tod_secs;
    TimeFields.Milliseconds = ( WORD )DcTOD->tod_hunds * 10;
    TimeFields.Day = ( WORD )DcTOD->tod_day;
    TimeFields.Month = ( WORD )DcTOD->tod_month;
    TimeFields.Year = ( WORD )DcTOD->tod_year;

    if ( !RtlTimeFieldsToTime( &TimeFields, &DcTime ) ) {

        Win32Err = ERROR_INVALID_PARAMETER;
    }

    TimeFields.Hour = ( WORD )ClientTOD->tod_hours;
    TimeFields.Minute = ( WORD )ClientTOD->tod_mins;
    TimeFields.Second = ( WORD )ClientTOD->tod_secs;
    TimeFields.Milliseconds = ( WORD )ClientTOD->tod_hunds * 10;
    TimeFields.Day = ( WORD )ClientTOD->tod_day;
    TimeFields.Month = ( WORD )ClientTOD->tod_month;
    TimeFields.Year = ( WORD )ClientTOD->tod_year;

    if ( !RtlTimeFieldsToTime( &TimeFields, &ClientTime ) ) {

        Win32Err = ERROR_INVALID_PARAMETER;
    }

    //
    // Add the time it takes to get the time from the dc.
    //
    UpdatedDcTime = RtlLargeIntegerAdd( DcTime, ElapsedTime );

    //
    // Compute the difference in time
    //
    if ( RtlLargeIntegerGreaterThan( UpdatedDcTime, ClientTime  ) ) {

        TimeSkew = RtlLargeIntegerSubtract( UpdatedDcTime,
                                            ClientTime );
    } else {

        TimeSkew = RtlLargeIntegerSubtract( ClientTime,
                                            UpdatedDcTime );
    }

    //
    // Now, see if there is a time difference greater than the allowable skew
    //
    AllowedSkew = RtlConvertUlongToLargeInteger( NETDOMP_VERIFY_SKEW );

    if ( RtlLargeIntegerGreaterThan( TimeSkew, AllowedSkew ) ) {

        *InSync = FALSE;
    }




VerifySingleError:

    if ( Connected ) {

        NetpManageIPCConnect( Server,
                              ObjectAuthInfo->User,
                              ObjectAuthInfo->Password,
                              NETSETUPP_DISCONNECT_IPC );
    }

    NetApiBufferFree( ClientTOD );
    NetApiBufferFree( DcTOD );
    return( Win32Err );
}



VOID
NetDompDisplayTimeVerify(
    IN PWSTR Server,
    IN DWORD Results,
    IN BOOL InSync
    )
/*++

Routine Description:

    This function will display the results of the time verification

Arguments:

    Server - Server which had the time verified

    Results - The error code of the verification attempt

    InSync - Whether the clocks are within the skew.  Only valid if Results is ERROR_SUCCESS

Return Value:

    VOID

--*/
{
    NetDompDisplayMessage( MSG_TIME_COMPUTER, Server );
    if ( Results != ERROR_SUCCESS ) {

        NetDompDisplayErrorMessage( Results );

    } else {

        NetDompDisplayMessage( InSync ? MSG_TIME_SUCCESS : MSG_TIME_FAILURE );
    }
}



DWORD
NetDompVerifyTime(
    IN PWSTR Domain,
    IN PWSTR Server, OPTIONAL
    IN PND5_AUTH_INFO DomainAuthInfo,
    IN PND5_AUTH_INFO ObjectAuthInfo,
    IN PWSTR Dc,
    IN BOOL AllWorkstation,
    IN BOOL AllServer
    )
/*++

Routine Description:

    This function will verify the time between some or all of the servers/workstations in a
    domain against the specified domain controller

Arguments:

    Domain - Domain containing the servers/workstations

    Server - Name of a specific machine to verify the time for

    DomainAuthInfo - User and password for the domain controller

    ObjectAuthInfo - User and password for the servers/workstations

    Dc - Name of a domain controller in the domain to use as a time source

    AllWorkstation - If TRUE, verify the time for all the workstations

    AllServer - If TRUE, verify the time for all the servers

Return Value:

    ERROR_SUCCESS - The function succeeded

    ERROR_INVALID_PARAMETER - No server, workstation or machine was specified

--*/
{
    DWORD Win32Err = ERROR_SUCCESS, Err2;
    BOOL DcSession = FALSE, InSync;
    DWORD DcDelay;
    LPUSER_INFO_0 UserList = NULL;
    PWSTR FullDc = NULL, Lop;
    ULONG ResumeHandle = 0, Count = 0, TotalCount = 0, i, j;
    ULONG Types[] = {
        FILTER_WORKSTATION_TRUST_ACCOUNT,
        FILTER_SERVER_TRUST_ACCOUNT
    };
    BOOL ProcessType[ sizeof( Types ) / sizeof( ULONG ) ];

    ProcessType[ 0 ] = AllWorkstation;
    ProcessType[ 1 ] = AllServer;

    //
    // Make sure that there is something to do
    //
    if ( !Server && !AllWorkstation && !AllServer ) {

        return( ERROR_INVALID_PARAMETER );
    }

    //
    // Build a full machine name
    //
    if ( Dc && *Dc != L'\\' ) {

         Win32Err = NetApiBufferAllocate( ( wcslen( Dc ) + 3 ) * sizeof( WCHAR ),
                                          ( PVOID * )&FullDc );

         if ( Win32Err == ERROR_SUCCESS ) {

             swprintf( FullDc, L"\\\\%ws", Dc );
         }

     } else {

         FullDc = Dc;
     }


    //
    // Set up a session
    //
    Win32Err = NetpManageIPCConnect( FullDc,
                                     DomainAuthInfo->User,
                                     DomainAuthInfo->Password,
                                     NETSETUPP_CONNECT_IPC );
    if ( Win32Err == ERROR_SUCCESS ) {

        DcSession = FALSE;
    }

    //
    // See how long it takes to get to the dc
    //
    if ( Win32Err == ERROR_SUCCESS  ) {

        Win32Err = NetDompGetTimeTripLength( Dc,
                                             &DcDelay );
    }

    if ( Win32Err != ERROR_SUCCESS ) {

        goto VerifyTimeError;
    }


    NetDompDisplayMessage( MSG_TIME_VERIFY );

    //
    // Verify a single machine
    //
    if ( Server ) {

        Win32Err = NetDompVerifySingleClient( Server,
                                              Dc,
                                              ObjectAuthInfo,
                                              DcDelay,
                                              &InSync );
        NetDompDisplayTimeVerify( Server,
                                  Win32Err,
                                  InSync );
    }

    //
    // Verify all the workstations/servers, if requested.
    //
    for ( i = 0; i < sizeof( Types ) / sizeof( ULONG ); i++ ) {

        if ( !ProcessType[ i ] ) {

            continue;
        }

        do {

            Win32Err = NetUserEnum( FullDc,
                                    0,
                                    Types[ i ],
                                    ( LPBYTE * )&UserList,
                                    MAX_PREFERRED_LENGTH,
                                    &Count,
                                    &TotalCount,
                                    &ResumeHandle );

            if ( Win32Err == ERROR_SUCCESS || Win32Err == ERROR_MORE_DATA ) {

                for ( j = 0; j < Count; j++ ) {

                    Lop = wcsrchr( UserList[ j ].usri0_name, L'$' );
                    if ( Lop ) {

                        *Lop = UNICODE_NULL;
                    }

                    Err2 = NetDompVerifySingleClient( UserList[ j ].usri0_name,
                                                      Dc,
                                                      ObjectAuthInfo,
                                                      DcDelay,
                                                      &InSync );
                    NetDompDisplayTimeVerify( UserList[ j ].usri0_name,
                                              Err2,
                                              InSync );

                }
                NetApiBufferFree( UserList );
            }

        } while ( Win32Err == ERROR_MORE_DATA );

    }

VerifyTimeError:

    if ( DcSession ) {

        NetpManageIPCConnect( FullDc,
                              DomainAuthInfo->User,
                              DomainAuthInfo->Password,
                              NETSETUPP_DISCONNECT_IPC );
    }

    if ( FullDc != Dc ) {

        NetApiBufferFree( FullDc );
    }

    return( Win32Err );
}



DWORD
NetDompResetTime(
    IN PWSTR Domain,
    IN PWSTR Server, OPTIONAL
    IN PND5_AUTH_INFO DomainAuthInfo,
    IN PND5_AUTH_INFO ObjectAuthInfo,
    IN PWSTR Dc,
    IN BOOL AllWorkstation,
    IN BOOL AllServer
    )
/*++

Routine Description:

    This function will reset the time between some or all of the servers/workstations in a
    domain against the specified domain controller

Arguments:

    Domain - Domain containing the servers/workstations

    Server - Name of a specific machine to reset the time for

    DomainAuthInfo - User and password for the domain controller

    ObjectAuthInfo - User and password for the servers/workstations

    Dc - Name of a domain controller in the domain to use as a time source

    AllWorkstation - If TRUE, reset the time for all the workstations

    AllServer - If TRUE, reset the time for all the servers

Return Value:

    ERROR_SUCCESS - The function succeeded

    ERROR_INVALID_PARAMETER - No server, workstation or machine was specified

--*/
{
    DWORD Win32Err = ERROR_SUCCESS, Err2;
    BOOL DcSession = FALSE, InSync;
    DWORD DcDelay;
    LPUSER_INFO_0 UserList = NULL;
    PWSTR FullDc = NULL, Lop;
    ULONG ResumeHandle = 0, Count = 0, TotalCount = 0, i, j;
    ULONG Types[] = {
        FILTER_WORKSTATION_TRUST_ACCOUNT,
        FILTER_SERVER_TRUST_ACCOUNT
    };
    BOOL ProcessType[ sizeof( Types ) / sizeof( ULONG ) ];

    ProcessType[ 0 ] = AllWorkstation;
    ProcessType[ 1 ] = AllServer;

    //
    // Make sure that there is something to do
    //
    if ( !Server && !AllWorkstation && !AllServer ) {

        return( ERROR_INVALID_PARAMETER );
    }

    if ( Dc && *Dc != L'\\' ) {

         Win32Err = NetApiBufferAllocate( ( wcslen( Dc ) + 3 ) * sizeof( WCHAR ),
                                          ( PVOID * )&FullDc );

         if ( Win32Err == ERROR_SUCCESS ) {

             swprintf( FullDc, L"\\\\%ws", Dc );
         }

     } else {

         FullDc = Dc;
     }



    Win32Err = NetpManageIPCConnect( FullDc,
                                     DomainAuthInfo->User,
                                     DomainAuthInfo->Password,
                                     NETSETUPP_CONNECT_IPC );
    if ( Win32Err == ERROR_SUCCESS ) {

        DcSession = FALSE;
    }

    //
    // Get the trip time to the dc
    //
    if ( Win32Err == ERROR_SUCCESS  ) {

        Win32Err = NetDompGetTimeTripLength( Dc,
                                             &DcDelay );
    }

    if ( Win32Err != ERROR_SUCCESS ) {

        goto ResetTimeError;
    }


    NetDompDisplayMessage( MSG_TIME_VERIFY );

    //
    // Reset the client, if needed
    //
    if ( Server ) {

        Win32Err = NetDompVerifySingleClient( Server,
                                              Dc,
                                              ObjectAuthInfo,
                                              DcDelay,
                                              &InSync );
        if ( Win32Err == ERROR_SUCCESS && !InSync ) {

            Win32Err = NetDompResetSingleClient( Server,
                                                 Dc,
                                                 ObjectAuthInfo,
                                                 DcDelay );
        }
    }

    //
    // Do all the workstations/servers, if required
    //
    for ( i = 0; i < sizeof( Types ) / sizeof( ULONG ); i++ ) {

        if ( !ProcessType[ i ] ) {

            continue;
        }

        do {

            Win32Err = NetUserEnum( FullDc,
                                    0,
                                    Types[ i ],
                                    ( LPBYTE * )&UserList,
                                    MAX_PREFERRED_LENGTH,
                                    &Count,
                                    &TotalCount,
                                    &ResumeHandle );

            if ( Win32Err == ERROR_SUCCESS || Win32Err == ERROR_MORE_DATA ) {

                for ( j = 0; j < Count; j++ ) {

                    Lop = wcsrchr( UserList[ j ].usri0_name, L'$' );
                    if ( Lop ) {

                        *Lop = UNICODE_NULL;
                    }

                    Err2 = NetDompVerifySingleClient( UserList[ j ].usri0_name,
                                                      Dc,
                                                      ObjectAuthInfo,
                                                      DcDelay,
                                                      &InSync );

                    if ( Err2 == ERROR_SUCCESS && !InSync ) {

                        Err2 = NetDompResetSingleClient( UserList[ j ].usri0_name,
                                                         Dc,
                                                         ObjectAuthInfo,
                                                         DcDelay );
                    }
                }
                NetApiBufferFree( UserList );
            }

        } while ( Win32Err == ERROR_MORE_DATA );

    }

ResetTimeError:

    if ( DcSession ) {

        NetpManageIPCConnect( FullDc,
                              DomainAuthInfo->User,
                              DomainAuthInfo->Password,
                              NETSETUPP_DISCONNECT_IPC );
    }

    if ( FullDc != Dc ) {

        NetApiBufferFree( FullDc );
    }

    return( Win32Err );
}


DWORD
NetDompHandleTime(ARG_RECORD * rgNetDomArgs)
/*++

Routine Description:

    This function will handle the NETDOM TIME requirements

Arguments:

    Args - List of command line arguments

Return Value:

    ERROR_INVALID_PARAMETER - No object name was supplied

--*/
{
    DWORD Win32Err = ERROR_SUCCESS;
    PWSTR Domain = NULL, Dc = NULL;
    ND5_AUTH_INFO DomainUser, ObjectUser;
    ULONG i;

    PWSTR Object = rgNetDomArgs[eObject].strValue;

    if (!Object)
    {
        DisplayHelp(ePriTime);
        return( ERROR_INVALID_PARAMETER );
    }

    RtlZeroMemory( &DomainUser, sizeof( ND5_AUTH_INFO ) );
    RtlZeroMemory( &ObjectUser, sizeof( ND5_AUTH_INFO ) );

    //
    // Validate the args
    //
    Win32Err = NetDompValidateSecondaryArguments(rgNetDomArgs,
                                                 eObject,
                                                 eCommDomain,
                                                 eCommUserNameO,
                                                 eCommPasswordO,
                                                 eCommUserNameD,
                                                 eCommPasswordD,
                                                 eQueryServer,
                                                 eQueryWksta,
                                                 eCommVerify,
                                                 eCommReset,
                                                 eCommVerbose,
                                                 eArgEnd);
    if ( Win32Err != ERROR_SUCCESS ) {

        DisplayHelp(ePriTime);
        goto HandleTimeExit;
    }


    //
    // Verify that we don't have too many arguments
    //
    if ( CmdFlagOn(rgNetDomArgs, eCommVerify) &&
         CmdFlagOn(rgNetDomArgs, eCommReset) ) {

        NetDompDisplayUnexpectedParameter(rgNetDomArgs[eCommReset].strArg1);

        Win32Err = ERROR_INVALID_PARAMETER;
        goto HandleTimeExit;
    }

    //
    // Ok, make sure that we have a specified domain...
    //
    Win32Err = NetDompGetDomainForOperation(rgNetDomArgs,
                                            Object,
                                            TRUE,
                                            &Domain);

    if ( Win32Err != ERROR_SUCCESS ) {

        goto HandleTimeExit;
    }

    //
    // Get the password and user if it exists
    //
    if ( CmdFlagOn(rgNetDomArgs, eCommUserNameD) ) {

        Win32Err = NetDompGetUserAndPasswordForOperation(rgNetDomArgs,
                                                         eCommUserNameD,
                                                         Domain,
                                                         &DomainUser);

        if ( Win32Err != ERROR_SUCCESS ) {

            goto HandleTimeExit;
        }
    }

    if ( CmdFlagOn(rgNetDomArgs, eCommUserNameO) ) {

        Win32Err = NetDompGetUserAndPasswordForOperation(rgNetDomArgs,
                                                         eCommUserNameO,
                                                         Object,
                                                         &ObjectUser );

        if ( Win32Err != ERROR_SUCCESS ) {

            goto HandleTimeExit;
        }
    }

    //
    // Get the name of a domain controller
    //
    Win32Err = NetDompTimeGetDc( Domain,
                                 Object,
                                 &ObjectUser,
                                 &Dc );

    if ( Win32Err != ERROR_SUCCESS ) {

        goto HandleTimeExit;
    }

    //
    // Now, see what we are supposed to do
    //
    if ( CmdFlagOn(rgNetDomArgs, eCommVerify) ) {

        Win32Err = NetDompVerifyTime( Domain,
                                      Object,
                                      &DomainUser,
                                      &ObjectUser,
                                      Dc,
                                      CmdFlagOn(rgNetDomArgs, eQueryWksta),
                                      CmdFlagOn(rgNetDomArgs, eQueryServer) );

    }

    if ( CmdFlagOn(rgNetDomArgs, eCommReset) ) {

        Win32Err = NetDompResetTime( Domain,
                                     Object,
                                     &DomainUser,
                                     &ObjectUser,
                                     Dc,
                                     CmdFlagOn(rgNetDomArgs, eQueryWksta),
                                     CmdFlagOn(rgNetDomArgs, eQueryServer) );

    }


HandleTimeExit:

    NetApiBufferFree( Domain );
    NetApiBufferFree( Dc );

    NetDompFreeAuthIdent( &DomainUser );
    NetDompFreeAuthIdent( &ObjectUser );

    if (NO_ERROR != Win32Err)
    {
        NetDompDisplayErrorMessage(Win32Err);
    }

    return( Win32Err );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\accessp.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    accessp.c

Abstract:

    Internal routines shared by NetUser API and Netlogon service.  These
    routines convert from SAM specific data formats to UAS specific data
    formats.

Author:

    Cliff Van Dyke (cliffv) 29-Aug-1991

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    22-Oct-1991 JohnRo
        Made changes suggested by PC-LINT.
    04-Dec-1991 JohnRo
        Trying to get around a weird MIPS compiler bug.
--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#undef DOMAIN_ALL_ACCESS // defined in both ntsam.h and ntwinapi.h
#include <ntsam.h>

#include <windef.h>
#include <lmcons.h>

#include <accessp.h>
#include <debuglib.h>
#include <lmaccess.h>
#include <netdebug.h>
#include <netsetp.h>


#if(_WIN32_WINNT >= 0x0500)

NET_API_STATUS
NET_API_FUNCTION
NetpSetDnsComputerNameAsRequired(
    IN PWSTR DnsDomainName
    )
/*++

Routine Description:

    Determines if the machine is set to update the machine Dns computer name based on changes
    to the Dns domain name.  If so, the new value is set.  Otherwise, no action is taken.

Arguments:

    DnsDomainName - New Dns domain name of this machine

Return Value:

    NERR_Success -- Success

--*/
{
    NET_API_STATUS NetStatus = NERR_Success;
    HKEY SyncKey;
    DWORD ValueType, Value, Length;
    BOOLEAN SetName = FALSE;
    PWCHAR AbsoluteSignifier = NULL;

    if ( DnsDomainName == NULL ) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // See if we should be doing the name change
    //
    NetStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                              L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters",
                              0,
                              KEY_QUERY_VALUE,
                              &SyncKey );

    if ( NetStatus == NERR_Success ) {

        Length = sizeof( ULONG );
        NetStatus = RegQueryValueEx( SyncKey,
                                     L"SyncDomainWithMembership",
                                     NULL,
                                     &ValueType,
                                     ( LPBYTE )&Value,
                                     &Length );
        if ( NetStatus == NERR_Success) {

            if ( Value == 1 ) {

                SetName = TRUE;
            }

        } else if ( NetStatus == ERROR_FILE_NOT_FOUND ) {

            NetStatus = NERR_Success;
            SetName = TRUE;
        }

        RegCloseKey( SyncKey );

    }

    if ( NetStatus == NERR_Success && SetName == TRUE ) {

        //
        // If we've got an absolute Dns domain name, shorten it up...
        //
        if ( wcslen(DnsDomainName) > 0 ) {
            AbsoluteSignifier = &DnsDomainName[ wcslen( DnsDomainName ) - 1 ];
            if ( *AbsoluteSignifier == L'.'  ) {

                *AbsoluteSignifier = UNICODE_NULL;

            } else {

                AbsoluteSignifier = NULL;
            }
        }

        if ( !SetComputerNameEx( ComputerNamePhysicalDnsDomain, DnsDomainName ) ) {
            NetStatus = GetLastError();
        }

        if ( AbsoluteSignifier ) {

            *AbsoluteSignifier = L'.';
        }

    }

    return( NetStatus );
}

#endif


VOID
NetpGetAllowedAce(
    IN PACL Dacl,
    IN PSID Sid,
    OUT PVOID *Ace
    )
/*++

Routine Description:

    Given a DACL, find an AccessAllowed ACE containing a particuar SID.

Arguments:

    Dacl - A pointer to the ACL to search.

    Sid - A pointer to the Sid to search for.

    Ace - Returns a pointer to the specified ACE.  Returns NULL if there
        is no such ACE

Return Value:

    None.

--*/
{
    NTSTATUS Status;

    ACL_SIZE_INFORMATION AclSize;
    DWORD AceIndex;

    //
    // Determine the size of the DACL so we can copy it
    //

    Status = RtlQueryInformationAcl(
                        Dacl,
                        &AclSize,
                        sizeof(AclSize),
                        AclSizeInformation );

    if ( ! NT_SUCCESS( Status ) ) {
        IF_DEBUG( ACCESSP ) {
            NetpKdPrint((
                "NetpGetDacl: RtlQueryInformationAcl returns %lX\n",
                Status ));
        }
        *Ace = NULL;
        return;
    }


    //
    // Loop through the ACEs looking for an ACCESS_ALLOWED ACE with the
    // right SID.
    //

    for ( AceIndex=0; AceIndex<AclSize.AceCount; AceIndex++ ) {

        Status = RtlGetAce( Dacl, AceIndex, (PVOID *)Ace );

        if ( ! NT_SUCCESS( Status ) ) {
            *Ace = NULL;
            return;
        }

        if ( ((PACE_HEADER)*Ace)->AceType != ACCESS_ALLOWED_ACE_TYPE ) {
            continue;
        }

        if ( RtlEqualSid( Sid,
                          (PSID)&((PACCESS_ALLOWED_ACE)(*Ace))->SidStart )
                        ){
            return;
        }
    }

    //
    // Couldn't find any such ACE.
    //

    *Ace = NULL;
    return;

}



DWORD
NetpAccountControlToFlags(
    IN DWORD UserAccountControl,
    IN PACL UserDacl
    )
/*++

Routine Description:

    Convert a SAM UserAccountControl field and the Discretionary ACL for
    the user into the NetUser API usriX_flags field.

Arguments:

    UserAccountControl - The SAM UserAccountControl field for the user.

    UserDacl - The Discretionary ACL for the user.

Return Value:

    Returns the usriX_flags field for the user.

--*/
{
    SID_IDENTIFIER_AUTHORITY WorldSidAuthority = SECURITY_WORLD_SID_AUTHORITY;
    DWORD WorldSid[sizeof(SID)/sizeof(DWORD) + SID_MAX_SUB_AUTHORITIES ];
    PACCESS_ALLOWED_ACE Ace;
    DWORD Flags = UF_SCRIPT;

    //
    // Build a copy of the world SID for later comparison.
    //

    RtlInitializeSid( (PSID) WorldSid, &WorldSidAuthority, 1 );
    *(RtlSubAuthoritySid( (PSID)WorldSid,  0 )) = SECURITY_WORLD_RID;

    //
    // Determine if the UF_PASSWD_CANT_CHANGE bit should be returned
    //
    // Return UF_PASSWD_CANT_CHANGE unless the world can change the
    // password.
    //

    //
    // If the user has no DACL, the password can change
    //

    if ( UserDacl != NULL ) {

        //
        // Find the WORLD grant ACE
        //

        NetpGetAllowedAce( UserDacl, (PSID) WorldSid, (PVOID *)&Ace );

        if ( Ace == NULL ) {
            Flags |= UF_PASSWD_CANT_CHANGE;
        } else {
            if ( (Ace->Mask & USER_CHANGE_PASSWORD) == 0 ) {
                Flags |= UF_PASSWD_CANT_CHANGE;
            }
        }

    }

    //
    // Set all other bits as a function of the SAM UserAccountControl
    //

    if ( UserAccountControl & USER_ACCOUNT_DISABLED ) {
        Flags |= UF_ACCOUNTDISABLE;
    }
    if ( UserAccountControl & USER_HOME_DIRECTORY_REQUIRED ){
        Flags |= UF_HOMEDIR_REQUIRED;
    }
    if ( UserAccountControl & USER_PASSWORD_NOT_REQUIRED ){
        Flags |= UF_PASSWD_NOTREQD;
    }
    if ( UserAccountControl & USER_DONT_EXPIRE_PASSWORD ){
        Flags |= UF_DONT_EXPIRE_PASSWD;
    }
    if ( UserAccountControl & USER_ACCOUNT_AUTO_LOCKED ){
        Flags |= UF_LOCKOUT;
    }
    if ( UserAccountControl & USER_MNS_LOGON_ACCOUNT ){
        Flags |= UF_MNS_LOGON_ACCOUNT;
    }

    if ( UserAccountControl & USER_ENCRYPTED_TEXT_PASSWORD_ALLOWED ){
        Flags |= UF_ENCRYPTED_TEXT_PASSWORD_ALLOWED;
    }

    if ( UserAccountControl & USER_SMARTCARD_REQUIRED ){
        Flags |= UF_SMARTCARD_REQUIRED;
    }
    if ( UserAccountControl & USER_TRUSTED_FOR_DELEGATION ){
        Flags |= UF_TRUSTED_FOR_DELEGATION;
    }

    if ( UserAccountControl & USER_NOT_DELEGATED ){
        Flags |= UF_NOT_DELEGATED;
    }

    if ( UserAccountControl & USER_USE_DES_KEY_ONLY ){
        Flags |= UF_USE_DES_KEY_ONLY;
    }
    if ( UserAccountControl & USER_DONT_REQUIRE_PREAUTH) {
        Flags |= UF_DONT_REQUIRE_PREAUTH;
    }
    if ( UserAccountControl & USER_PASSWORD_EXPIRED) {
        Flags |= UF_PASSWORD_EXPIRED;
    }
    if ( UserAccountControl & USER_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION) {
        Flags |= UF_TRUSTED_TO_AUTHENTICATE_FOR_DELEGATION;
    }
    


    //
    // set account type bit.
    //

    //
    // account type bit are exculsive and precisely only one
    // account type bit is set. So, as soon as an account type bit is set
    // in the following if sequence we can return.
    //


    if( UserAccountControl & USER_TEMP_DUPLICATE_ACCOUNT ) {
        Flags |= UF_TEMP_DUPLICATE_ACCOUNT;

    } else if( UserAccountControl & USER_NORMAL_ACCOUNT ) {
        Flags |= UF_NORMAL_ACCOUNT;

    } else if( UserAccountControl & USER_INTERDOMAIN_TRUST_ACCOUNT ) {
        Flags |= UF_INTERDOMAIN_TRUST_ACCOUNT;

    } else if( UserAccountControl & USER_WORKSTATION_TRUST_ACCOUNT ) {
        Flags |= UF_WORKSTATION_TRUST_ACCOUNT;

    } else if( UserAccountControl & USER_SERVER_TRUST_ACCOUNT ) {
        Flags |= UF_SERVER_TRUST_ACCOUNT;

    } else {

        //
        // There is no known account type bit set in UserAccountControl.
        // ?? Flags |= UF_NORMAL_ACCOUNT;

        // NetpAssert( FALSE );
    }

    return Flags;

}


ULONG
NetpDeltaTimeToSeconds(
    IN LARGE_INTEGER DeltaTime
    )

/*++

Routine Description:

    Convert an NT delta time specification to seconds

Arguments:

    DeltaTime - Specifies the NT Delta time to convert.  NT delta time is
        a negative number of 100ns units.

Return Value:

    Returns the number of seconds. Any invalid or too large input
        returns TIMEQ_FOREVER.

--*/

{
    LARGE_INTEGER LargeSeconds;

    //
    //  These are the magic numbers needed to do our extended division by
    //      10,000,000 = convert 100ns tics to one second tics
    //

    LARGE_INTEGER Magic10000000 = { (ULONG) 0xe57a42bd, (LONG) 0xd6bf94d5};
#define SHIFT10000000                    23

    //
    // Special case zero.
    //

    if ( DeltaTime.HighPart == 0 && DeltaTime.LowPart == 0 ) {
        return( 0 );
    }

    //
    // Convert the Delta time to a Large integer seconds.
    //

    LargeSeconds = RtlExtendedMagicDivide(
                        DeltaTime,
                        Magic10000000,
                        SHIFT10000000 );

#ifdef notdef
    NetpKdPrint(( "NetpDeltaTimeToSeconds: %lx %lx %lx %lx\n",
                    DeltaTime.HighPart,
                    DeltaTime.LowPart,
                    LargeSeconds.HighPart,
                    LargeSeconds.LowPart ));
#endif // notdef

    //
    // Return too large a number or a positive number as TIMEQ_FOREVER
    //

    if ( LargeSeconds.HighPart != -1 ) {
        return TIMEQ_FOREVER;
    }

    return ( (ULONG)(- ((LONG)(LargeSeconds.LowPart))) );

} // NetpDeltaTimeToSeconds


LARGE_INTEGER
NetpSecondsToDeltaTime(
    IN ULONG Seconds
    )

/*++

Routine Description:

    Convert a number of seconds to an NT delta time specification

Arguments:

    Seconds - a positive number of seconds

Return Value:

    Returns the NT Delta time.  NT delta time is a negative number
        of 100ns units.

--*/

{
    LARGE_INTEGER DeltaTime;
    LARGE_INTEGER LargeSeconds;
    LARGE_INTEGER Answer;

    //
    // Special case TIMEQ_FOREVER (return a full scale negative)
    //

    if ( Seconds == TIMEQ_FOREVER ) {
        DeltaTime.LowPart = 0;
        DeltaTime.HighPart = (LONG) 0x80000000;

    //
    // Convert seconds to 100ns units simply by multiplying by 10000000.
    //
    // Convert to delta time by negating.
    //

    } else {

        LargeSeconds = RtlConvertUlongToLargeInteger( Seconds );

        Answer = RtlExtendedIntegerMultiply( LargeSeconds, 10000000 );

          if ( Answer.QuadPart < 0 ) {
            DeltaTime.LowPart = 0;
            DeltaTime.HighPart = (LONG) 0x80000000;
        } else {
            DeltaTime.QuadPart = -Answer.QuadPart;
        }

    }

    return DeltaTime;

} // NetpSecondsToDeltaTime


VOID
NetpAliasMemberToPriv(
    IN ULONG AliasCount,
    IN PULONG AliasMembership,
    OUT LPDWORD Priv,
    OUT LPDWORD AuthFlags
    )

/*++

Routine Description:

    Converts membership in Aliases to LANMAN 2.0 style Priv and AuthFlags.

Arguments:

    AliasCount - Specifies the number of Aliases in the AliasMembership array.

    AliasMembership - Specifies the Aliases that are to be converted to Priv
        and AuthFlags.  Each element in the array specifies the RID of an
        alias in the BuiltIn domain.

    Priv - Returns the Lanman 2.0 Privilege level for the specified aliases.

    AuthFlags - Returns the Lanman 2.0 Authflags for the specified aliases.


Return Value:

    None.

--*/

{
    DWORD j;
    BOOLEAN IsAdmin = FALSE;
    BOOLEAN IsUser = FALSE;


    //
    // Loop through the aliases finding any special aliases.
    //
    // If this user is the member of multiple operator aliases,
    //      just "or" the appropriate bits in.
    //
    // If this user is the member of multiple "privilege" aliases,
    //      just report the one with the highest privilege.
    //      Report the user is a member of the Guest aliases by default.
    //

    *AuthFlags = 0;

    for ( j=0; j < AliasCount; j++ ) {

        switch ( AliasMembership[j] ) {
        case DOMAIN_ALIAS_RID_ADMINS:
            IsAdmin = TRUE;
            break;

        case DOMAIN_ALIAS_RID_USERS:
            IsUser = TRUE;
            break;

        case DOMAIN_ALIAS_RID_ACCOUNT_OPS:
            *AuthFlags |= AF_OP_ACCOUNTS;
            break;

        case DOMAIN_ALIAS_RID_SYSTEM_OPS:
            *AuthFlags |= AF_OP_SERVER;
            break;

        case DOMAIN_ALIAS_RID_PRINT_OPS:
            *AuthFlags |= AF_OP_PRINT;
            break;

        }
    }

    if ( IsAdmin ) {
        *Priv = USER_PRIV_ADMIN;

    } else if ( IsUser ) {
        *Priv = USER_PRIV_USER;

    } else {
        *Priv = USER_PRIV_GUEST;
    }
}


DWORD
NetpGetElapsedSeconds(
    IN PLARGE_INTEGER Time
    )

/*++

Routine Description:

    Computes the elapsed time in seconds since the time specified.
    Returns 0 on error.

Arguments:

    Time - Time (typically in the past) to compute the elapsed time from.


Return Value:

    0: on error.

    Number of seconds.

--*/

{
    LARGE_INTEGER CurrentTime;
    DWORD Current1980Time;
    DWORD Prior1980Time;
    NTSTATUS Status;

    //
    // Compute the age of the password
    //

    Status = NtQuerySystemTime( &CurrentTime );
    if( !NT_SUCCESS(Status) ) {
        return 0;
    }

    if ( !RtlTimeToSecondsSince1980( &CurrentTime, &Current1980Time) ) {
        return 0;
    }

    if ( !RtlTimeToSecondsSince1980( Time, &Prior1980Time ) ) {
        return 0;
    }

    if ( Current1980Time <= Prior1980Time ) {
        return 0;
    }

    return Current1980Time - Prior1980Time;

}




VOID
NetpConvertWorkstationList(
    IN OUT PUNICODE_STRING WorkstationList
    )
/*++

Routine Description:

    Convert the list of workstations from a comma separated list to
    a blank separated list.  Any workstation name containing a blank is
    silently removed.

Arguments:

    WorkstationList - List of workstations to convert

Return Value:

    None

--*/
{
    LPWSTR Source;
    LPWSTR Destination;
    LPWSTR EndOfBuffer;
    LPWSTR BeginningOfName;
    BOOLEAN SkippingName;
    ULONG NumberOfCharacters;

    //
    // Handle the trivial case.
    //

    if ( WorkstationList->Length == 0 ) {
        return;
    }

    //
    // Initialization.
    //

    Destination = Source = WorkstationList->Buffer;
    EndOfBuffer = Source + WorkstationList->Length/sizeof(WCHAR);

    //
    // Loop handling special characters
    //

    SkippingName = FALSE;
    BeginningOfName = Destination;


    while ( Source < EndOfBuffer ) {

        switch ( *Source ) {
        case ',':

            if ( !SkippingName ) {
                *Destination = ' ';
                Destination++;
            }

            SkippingName = FALSE;
            BeginningOfName = Destination;
            break;

        case ' ':
            SkippingName = TRUE;
            Destination = BeginningOfName;
            break;

        default:
            if ( !SkippingName ) {
                *Destination = *Source;
                Destination ++;
            }
            break;
        }

        Source ++;
    }

    //
    // Remove any trailing delimiter
    //

    NumberOfCharacters = (ULONG)(Destination - WorkstationList->Buffer);

    if ( NumberOfCharacters > 0 &&
         WorkstationList->Buffer[NumberOfCharacters-1] == ' ' ) {

        NumberOfCharacters--;
    }

    WorkstationList->Length = (USHORT) (NumberOfCharacters * sizeof(WCHAR));


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\alrtinfo.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    AlrtInfo.c

Abstract:

    This file contains NetpAlertStructureInfo().

Author:

    John Rogers (JohnRo) 08-Apr-1992

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    08-Apr-1992 JohnRo
        Created.

--*/

// These must be included first:

#include <windef.h>     // IN, DWORD, etc.
#include <lmcons.h>     // LM20_ equates, NET_API_STATUS, etc.

// These may be included in any order:

#include <debuglib.h>   // IF_DEBUG().
#include <lmerr.h>      // NO_ERROR, ERROR_ and NERR_ equates.
#include <lmalert.h>    // ALERT_xxx_EVENT equates.
#include <netdebug.h>   // NetpKdPrint(()), FORMAT_ equates.
#include <netlib.h>     // NetpSetOptionalArg().
#include <rxp.h>        // MAX_TRANSACT_ equates.
#include <strucinf.h>   // My prototype.
#include <tstr.h>       // STRICMP().
#include <winbase.h>    // INFINITE

NET_API_STATUS
NetpAlertStructureInfo(
    IN LPTSTR AlertType,      // ALERT_xxx_EVENT string (see <lmalert.h>).
    OUT LPDWORD MaxSize OPTIONAL,
    OUT LPDWORD FixedSize OPTIONAL
    )

{
    //
    // AlertType is a required parameter.
    //
    if (AlertType == NULL) {
        return (NERR_NoSuchAlert);
    } else if ( (*AlertType) == TCHAR_EOS ) {
        return (NERR_NoSuchAlert);
    }

    //
    // For some alerts, any amount of variable-length data is OK.
    // Set MaxSize to INFINITE for those.
    //
    if (STRICMP( AlertType, ALERT_ADMIN_EVENT ) == 0) {

        NetpSetOptionalArg( FixedSize, sizeof(ADMIN_OTHER_INFO) );
        NetpSetOptionalArg( MaxSize, INFINITE );

    } else if (STRICMP( AlertType, ALERT_ERRORLOG_EVENT ) == 0) {

        NetpSetOptionalArg( FixedSize, sizeof(ERRLOG_OTHER_INFO) );
        NetpSetOptionalArg( MaxSize, sizeof(ERRLOG_OTHER_INFO) );

    } else if (STRICMP( AlertType, ALERT_MESSAGE_EVENT ) == 0) {

        NetpSetOptionalArg( FixedSize, 0 );
        NetpSetOptionalArg( MaxSize, INFINITE );

    } else if (STRICMP( AlertType, ALERT_PRINT_EVENT ) == 0) {

        NetpSetOptionalArg( FixedSize, sizeof(PRINT_OTHER_INFO) );
        NetpSetOptionalArg( MaxSize, INFINITE );

    } else if (STRICMP( AlertType, ALERT_USER_EVENT ) == 0) {

        NetpSetOptionalArg( FixedSize, sizeof(USER_OTHER_INFO) );
        NetpSetOptionalArg( MaxSize,
                            sizeof(USER_OTHER_INFO)
                                + ((UNLEN+1 + MAX_PATH+1) * sizeof(TCHAR)) );

    } else {
        return (NERR_NoSuchAlert);
    }

    return (NO_ERROR);

} // NetpAlertStructureInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\confclos.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    ConfClos.c

Abstract:

    This module contains NetpCloseConfigData.  This is one of the new net
    config helpers.

Author:

    John Rogers (JohnRo) 26-Nov-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    26-Nov-1991 JohnRo
        Created this routine, to prepare for revised config handlers.
    11-Feb-1992 JohnRo
        Added support for using the real Win32 registry.
        Added support for FAKE_PER_PROCESS_RW_CONFIG handling.
    25-Feb-1993 JohnRo
        RAID 12914: _tell caller if they never opened handle.

--*/


// These must be included first:

#include <nt.h>                 // NT definitions
#include <ntrtl.h>              // NT Rtl structures
#include <nturtl.h>             // NT Rtl structures

#include <windows.h>            // Needed by <configp.h> and <winreg.h>
#include <lmcons.h>             // LAN Manager common definitions
#include <netdebug.h>           // (Needed by config.h)

// These may be included in any order:

#include <config.h>             // My prototype, LPNET_CONFIG_HANDLE.
#include <configp.h>            // NET_CONFIG_HANDLE.
#include <lmerr.h>              // NERR_Success.
#include <netlib.h>             // NetpMemoryAllocate(), etc.


NET_API_STATUS
NetpCloseConfigData(
    IN OUT LPNET_CONFIG_HANDLE ConfigHandle
    )

/*++

Routine Description:

    This function closes the system configuration file.

    WARNING: Closing the same config handle twice can be nasty.  There
    is no way to detect this at the moment.

Arguments:

    ConfigHandle - Is the handle returned from NetpOpenConfigData().

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/

{
    NET_CONFIG_HANDLE * MyHandle = ConfigHandle;  // conv from opaque type

    // Did caller forget to open?
    if (ConfigHandle == NULL)
    {
        return (ERROR_INVALID_PARAMETER);
    }


    {
        LONG RegStatus;
        
        RegStatus = RegCloseKey( MyHandle->WinRegKey );
        NetpAssert( RegStatus == ERROR_SUCCESS );

    }

    NetpMemoryFree( MyHandle );

    return (NERR_Success);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\confdel.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ConfDel.c

Abstract:

    This module contains NetpDeleteConfigKeyword().

Author:

    John Rogers (JohnRo) 11-Feb-1992

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    11-Feb-1992 JohnRo
        Created this routine.
    14-Mar-1992 JohnRo
        The Win32 registry version should call RegDeleteValue(), not
        RegDeleteKey().
    22-Mar-1992 JohnRo
        Match revised return code (ERROR_CANTOPEN) from RegDeleteKey().
        Added a little debug output if the delete fails (WinReg version).
    21-May-1992 JohnRo
        RAID 9826: Match revised winreg error codes.
        Use PREFIX_ equates.

--*/

// These must be included first:

#include <nt.h>         // NT definitions
#include <ntrtl.h>      // NT Rtl structures
#include <nturtl.h>     // NT Rtl structures
#include <windows.h>    // Needed by <configp.h> and <winreg.h>
#include <lmcons.h>     // NET_API_STATUS.
#include <netdebug.h>   // (Needed by config.h)


// These may be included in any order:

#include <config.h>     // My prototype, LPNET_CONFIG_HANDLE.
#include <configp.h>    // NET_CONFIG_HANDLE.
#include <lmerr.h>      // NERR_, ERROR_, and NO_ERROR equates.
#include <prefix.h>     // PREFIX_ equates.
#include <tstr.h>       // TCHAR_EOS.
#include <winreg.h>


// Delete a keyword and its value.
// Return NERR_CfgParamNotFound if the keyword isn't present.
NET_API_STATUS
NetpDeleteConfigKeyword (
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    IN LPTSTR Keyword
    )
{
    NET_CONFIG_HANDLE * MyHandle = (LPVOID) ConfigHandle;

    if (MyHandle == NULL) {
       return (ERROR_INVALID_PARAMETER);
    }
    if ( (Keyword == NULL) || (*Keyword == TCHAR_EOS) ) {
       return (ERROR_INVALID_PARAMETER);
    }

    {
        LONG Error;
        Error = RegDeleteValue (
            MyHandle->WinRegKey,           // section (key) handle
            Keyword );                     // value name
        if (Error == ERROR_FILE_NOT_FOUND) {
            return (NERR_CfgParamNotFound);
        }

        if (Error != ERROR_SUCCESS) {
            NetpKdPrint(( PREFIX_NETLIB
                    "NetpConfigDeleteKeyword: unexpected status "
                    FORMAT_LONG ".\n", Error ));

            NetpAssert( Error == ERROR_SUCCESS );
        }

        return Error;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\allocstr.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    AllocStr.c

Abstract:

    This module contains routines to allocate copies of strings (and convert
    character sets in the process if necessary).

Author:

    John Rogers (JohnRo) 02-Dec-1991

Environment:

    Only runs under NT; has an NT-specific interface (with Win32 types).
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    02-Dec-1991 JohnRo
        Created.
    10-Mar-1992 rfirth
        Added NetpAllocWStrFromWStr

    06-Jan-1992 JohnRo
        Added NetpAlloc{type}From{type} routines and macros.
        (Got NetpAllocStrFromWStr from CliffV's NetpLogonAnsiToUnicode; got
        NetpAllocWStrFromStr from his NetpLogonUnicodeToAnsi.)  Thanks Cliff!
        Corrected Abstract and added Environment to this file.
    13-Mar-1992 JohnRo
        Added NetpAllocStringFromTStr() for NetpGetDomainID().
    29-Apr-1992 JohnRo
        Fixed NetpAllocTStrFromString() in UNICODE build.
    03-Aug-1992 JohnRo
        RAID 1895: Net APIs and svcs should use OEM char set.
        Avoid compiler warnings.
    13-Feb-1995 FloydR
        Deleted NetpAllocStringFromTStr() - unused

--*/


// These must be included first:

#include <nt.h>                 // IN, LPVOID, PSTRING, etc.
#include <windef.h>             // Win32 type definitions
#include <lmcons.h>             // NET_API_STATUS.

// These may be included in any order:

#include <align.h>              // ALIGN_ macros.
#include <lmapibuf.h>           // NetApiBufferAllocate(), etc.
#include <netdebug.h>           // NetpAssert().
#include <netlib.h>             // NetpPointerPlusSomeBytes().
#include <netlibnt.h>           // Some of my prototypes.
#include <ntrtl.h>
#include <tstring.h>            // NetpNCopyStrToTStr(), some of my prototypes.
#include <winerror.h>           // NO_ERROR.


LPSTR
NetpAllocStrFromWStr (
    IN LPWSTR Unicode
    )

/*++

Routine Description:

    Convert an UNICODE (zero terminated) string to the corresponding OEM
    string.

Arguments:

    Unicode - Specifies the UNICODE zero terminated string to convert.


Return Value:

    NULL - There was some error in the conversion.

    Otherwise, it returns a pointer to the zero terminated OEM string in
    an allocated buffer.  The buffer must be freed using NetApiBufferFree.

--*/

{
    OEM_STRING OemString;
    NET_API_STATUS ApiStatus;
    UNICODE_STRING UnicodeString;

    RtlInitUnicodeString( &UnicodeString, Unicode );

    OemString.MaximumLength =
        (USHORT) RtlUnicodeStringToOemSize( &UnicodeString );

    ApiStatus = NetApiBufferAllocate(
            OemString.MaximumLength,
            (LPVOID *) (LPVOID) & OemString.Buffer );
    if (ApiStatus != NO_ERROR) {
        NetpAssert( ApiStatus == ERROR_NOT_ENOUGH_MEMORY );
        return (NULL);
    }

    NetpAssert( OemString.Buffer != NULL );

    if(!NT_SUCCESS( RtlUnicodeStringToOemString( &OemString,
                                                  &UnicodeString,
                                                  FALSE))){
        (void) NetApiBufferFree( OemString.Buffer );
        return NULL;
    }

    return OemString.Buffer;

} // NetpAllocStrFromWStr


LPWSTR
NetpAllocWStrFromStr(
    IN LPSTR Oem
    )

/*++

Routine Description:

    Convert an Oem (zero terminated) string to the corresponding UNICODE
    string.

Arguments:

    Oem - Specifies the Oem zero terminated string to convert.


Return Value:

    NULL - There was some error in the conversion.

    Otherwise, it returns a pointer to the zero terminated UNICODE string in
    an allocated buffer.  The buffer must be freed using NetApiBufferFree.

--*/

{
    OEM_STRING OemString;
    NET_API_STATUS ApiStatus;
    UNICODE_STRING UnicodeString;

    RtlInitString( &OemString, Oem );

    UnicodeString.MaximumLength =
        (USHORT) RtlOemStringToUnicodeSize( &OemString );

    ApiStatus = NetApiBufferAllocate(
            UnicodeString.MaximumLength,
            (LPVOID *) & UnicodeString.Buffer );
    if (ApiStatus != NO_ERROR) {
        return (NULL);
    }
    NetpAssert(UnicodeString.Buffer != NULL);

    if(!NT_SUCCESS( RtlOemStringToUnicodeString( &UnicodeString,
                                                  &OemString,
                                                  FALSE))){
        (void) NetApiBufferFree( UnicodeString.Buffer );
        return NULL;
    }

    return UnicodeString.Buffer;

} // NetpAllocWStrFromStr


LPWSTR
NetpAllocWStrFromWStr(
    IN LPWSTR Unicode
    )

/*++

Routine Description:

    Allocate and copy unicode string (wide character strdup)

Arguments:

    Unicode - pointer to wide character string to make copy of


Return Value:

    NULL - There was some error in the conversion.

    Otherwise, it returns a pointer to the zero terminated UNICODE string in
    an allocated buffer.  The buffer must be freed using NetApiBufferFree.

--*/

{
    NET_API_STATUS status;
    DWORD   size;
    LPWSTR  ptr;

    size = WCSSIZE(Unicode);
    status = NetApiBufferAllocate(size, (LPVOID *) (LPVOID) &ptr);
    if (status != NO_ERROR) {
        return NULL;
    }
    RtlCopyMemory(ptr, Unicode, size);
    return ptr;
} // NetpAllocWStrFromWStr


LPWSTR
NetpAllocWStrFromAStr(
    IN LPCSTR Ansi
    )

/*++

Routine Description:

    Convert an Oem (zero terminated) string to the corresponding UNICODE
    string.

Arguments:

    Oem - Specifies the Oem zero terminated string to convert.


Return Value:

    NULL - There was some error in the conversion.

    Otherwise, it returns a pointer to the zero terminated UNICODE string in
    an allocated buffer.  The buffer must be freed using NetApiBufferFree.

--*/

{
    ANSI_STRING AnsiString;
    NET_API_STATUS ApiStatus;
    UNICODE_STRING UnicodeString;

    RtlInitString( &AnsiString, Ansi );

    UnicodeString.MaximumLength =
        (USHORT) RtlAnsiStringToUnicodeSize( &AnsiString );

    ApiStatus = NetApiBufferAllocate(
            UnicodeString.MaximumLength,
            (LPVOID *) & UnicodeString.Buffer );
    if (ApiStatus != NO_ERROR) {
        return (NULL);
    }
    NetpAssert(UnicodeString.Buffer != NULL);

    if(!NT_SUCCESS( RtlAnsiStringToUnicodeString( &UnicodeString,
                                                  &AnsiString,
                                                  FALSE))){
        (void) NetApiBufferFree( UnicodeString.Buffer );
        return NULL;
    }

    return UnicodeString.Buffer;

} // NetpAllocWStrFromAStr

LPSTR
NetpAllocAStrFromWStr (
    IN LPCWSTR Unicode
    )

/*++

Routine Description:

    Convert an UNICODE (zero terminated) string to the corresponding ANSI
    string.

Arguments:

    Unicode - Specifies the UNICODE zero terminated string to convert.


Return Value:

    NULL - There was some error in the conversion.

    Otherwise, it returns a pointer to the zero terminated ANSI string in
    an allocated buffer.  The buffer must be freed using NetApiBufferFree.

--*/

{
    ANSI_STRING AnsiString;
    NET_API_STATUS ApiStatus;
    UNICODE_STRING UnicodeString;

    RtlInitUnicodeString( &UnicodeString, Unicode );

    AnsiString.MaximumLength =
        (USHORT) RtlUnicodeStringToAnsiSize( &UnicodeString );

    ApiStatus = NetApiBufferAllocate(
            AnsiString.MaximumLength,
            (LPVOID *) (LPVOID) & AnsiString.Buffer );
    if (ApiStatus != NO_ERROR) {
        NetpAssert( ApiStatus == ERROR_NOT_ENOUGH_MEMORY );
        return (NULL);
    }

    NetpAssert( AnsiString.Buffer != NULL );

    if(!NT_SUCCESS( RtlUnicodeStringToAnsiString( &AnsiString,
                                                  &UnicodeString,
                                                  FALSE))){
        (void) NetApiBufferFree( AnsiString.Buffer );
        return NULL;
    }

    return AnsiString.Buffer;

} // NetpAllocStrFromWStr
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\confenum.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    ConfEnum.c

Abstract:

    This module contains helper routines to _read fields out of the NT
    configuration files.  This is for temporary use until the Configuration
    Registry is available.

Author:

    John Rogers (JohnRo) 27-Nov-1991

Revision History:

    27-Nov-1991 JohnRo
        Prepare for revised config handlers.  (Actually swiped the NtRtl
        version of this code from RitaW.)
    12-Mar-1992 JohnRo
        Added support for using the real Win32 registry.
        Added support for FAKE_PER_PROCESS_RW_CONFIG handling.
    01-Apr-1992 JohnRo
        Use NetApiBufferAllocate() instead of private version.
    06-May-1992 JohnRo
        REG_SZ now implies a UNICODE string, so we can't use REG_USZ anymore.
    13-Jun-1992 JohnRo
        Title index parm is defunct (now lpReserved).
        Use PREFIX_ equates.
    13-Apr-1993 JohnRo
        RAID 5483: server manager: wrong path given in repl dialog.
        Made changes suggested by PC-LINT 5.0

--*/


// These must be included first:

#include <nt.h>         // NT definitions
#include <ntrtl.h>      // NT Rtl structures
#include <nturtl.h>     // NT Rtl structures
#include <windows.h>    // Needed by <configp.h> and <winreg.h>
#include <lmcons.h>     // LAN Manager common definitions
#include <netdebug.h>   // (Needed by config.h)

// These may be included in any order:

#include <config.h>     // My prototype, LPNET_CONFIG_HANDLE, etc.
#include <configp.h>    // NET_CONFIG_HANDLE.
#include <debuglib.h>   // IF_DEBUG()
#include <lmapibuf.h>   // NetApiBufferAllocate(), NetApiBufferFree().
#include <lmerr.h>      // LAN Manager network error definitions
#include <prefix.h>     // PREFIX_ equates.


NET_API_STATUS
NetpEnumConfigSectionValues(
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    OUT LPTSTR * KeywordBuffer,          // Must be freed by NetApiBufferFree().
    OUT LPTSTR * ValueBuffer,            // Must be freed by NetApiBufferFree().
    IN BOOL FirstTime
    )

/*++

Routine Description:

    This function gets the keyword value string from the configuration file.

Arguments:

    ConfigHandle - Supplies a handle from NetpOpenConfigData for the
        appropriate section of the config data.

    KeywordBuffer - Returns the string of the keyword value which is
        copied into this buffer.  This string will be allocated by this routine
        and must be freed by NetApiBufferFree().

    ValueBuffer - Returns the string of the keyword value which is
        copied into this buffer.  This string will be allocated by this routine
        and must be freed by NetApiBufferFree().

    FirstTime - TRUE if caller wants to start at first keyword for this section.
        FALSE if caller wants to continue a previous enum on this handle.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.
        (NERR_CfgParamNotFound if no other values exist for this section.)

--*/
{
    NET_CONFIG_HANDLE * lpnetHandle = ConfigHandle;  // conv from opaque type
    NET_API_STATUS ApiStatus;

    NetpAssert( KeywordBuffer != NULL );
    NetpAssert( ValueBuffer != NULL );
    NetpAssert( (FirstTime==TRUE) || (FirstTime==FALSE) );

    //
    // Assume error until proven otherwise.
    //

    *KeywordBuffer = NULL;
    *ValueBuffer = NULL;

    {
        DWORD dwType;
        LONG Error;
        DWORD MaxKeywordSize, MaxValueSize;
        DWORD NumberOfKeywords;
        LPTSTR ValueT;

        //
        // Find number of keys in this section.
        //
        ApiStatus = NetpNumberOfConfigKeywords (
                lpnetHandle,
                & NumberOfKeywords );
        NetpAssert( ApiStatus == NO_ERROR );
        if (NumberOfKeywords == 0) {
            return (NERR_CfgParamNotFound);
        }

        //
        // Set our index to something reasonable.  Note that some other
        // process might have deleted a keyword since we last did an enum,
        // so don't worry if the index gets larger than the number of keys.
        //

        if (FirstTime) {
            lpnetHandle->LastEnumIndex = 0;
        } else {

            DWORD MaxKeyIndex = NumberOfKeywords - 1;  // Indices start at 0.
            if (MaxKeyIndex < (lpnetHandle->LastEnumIndex)) {

                // Bug or someone deleted.  No way to tell, so assume latter.
                return (NERR_CfgParamNotFound);

            } else if (MaxKeyIndex == (lpnetHandle->LastEnumIndex)) {

                // This is how we normally exit at end of list.
                return (NERR_CfgParamNotFound);

            } else {

                // Normal bump to next entry.
                ++(lpnetHandle->LastEnumIndex);

            }
        }

        //
        // Compute sizes and allocate (maximum) buffers.
        //
        ApiStatus = NetpGetConfigMaxSizes (
                lpnetHandle,
                & MaxKeywordSize,
                & MaxValueSize );
        NetpAssert( ApiStatus == NO_ERROR );

        NetpAssert( MaxKeywordSize > 0 );
        NetpAssert( MaxValueSize   > 0 );

        ApiStatus = NetApiBufferAllocate(
                MaxValueSize,
                (LPVOID *) & ValueT);
        if (ApiStatus != NO_ERROR) {
            return (ApiStatus);
        }
        NetpAssert( ValueT != NULL);

        ApiStatus = NetApiBufferAllocate(
                MaxKeywordSize,
                (LPVOID *) KeywordBuffer);
        if (ApiStatus != NO_ERROR) {
            (void) NetApiBufferFree( ValueT );
            return (ApiStatus);
        }
        NetpAssert( (*KeywordBuffer) != NULL);

        //
        // Get the keyword name and the value.
        // (Win32 reg APIs convert from TCHARs to UNICODE for us.)
        //
        IF_DEBUG(CONFIG) {
            NetpKdPrint(( PREFIX_NETLIB
                    "NetpEnumConfigSectionValues: getting entry "
                    FORMAT_DWORD "...\n", lpnetHandle->LastEnumIndex ));
        }
        Error = RegEnumValue (
                lpnetHandle->WinRegKey,         // handle to key (section)
                lpnetHandle->LastEnumIndex,     // index of value name
                * KeywordBuffer,                // value name (keyword)
                & MaxKeywordSize,               // value name len (updated)
                NULL,                           // reserved
                & dwType,
                (LPVOID) ValueT,                // TCHAR value
                & MaxValueSize );               // value size (updated)

        IF_DEBUG(CONFIG) {
            NetpKdPrint(( PREFIX_NETLIB
                    "NetpEnumConfigSectionValues: RegEnumValue() ret "
                    FORMAT_LONG ".\n", Error ));
        }

        if ( Error != ERROR_SUCCESS )
        {
            NetpAssert( Error == ERROR_SUCCESS );
            NetApiBufferFree( ValueT );
            return (Error);
        }

        if (dwType == REG_SZ) {
            *ValueBuffer = ValueT;
            ApiStatus = NO_ERROR;
        } else if (dwType == REG_EXPAND_SZ) {
            LPTSTR UnexpandedString = ValueT;
            LPTSTR ExpandedString = NULL;

            // Expand string, using remote environment if necessary.
            ApiStatus = NetpExpandConfigString(
                    lpnetHandle->UncServerName, // server name (or null char)
                    UnexpandedString,
                    &ExpandedString );          // expanded: alloc and set ptr

            if (ApiStatus != NO_ERROR) {
                NetpKdPrint(( PREFIX_NETLIB
                        "NetpEnumConfigSectionValues: NetpExpandConfigString "
                        " returned API status " FORMAT_API_STATUS ".\n",
                        ApiStatus ));
                ExpandedString = NULL;
            }

            (VOID) NetApiBufferFree( UnexpandedString );
            *ValueBuffer = ExpandedString;

        } else {

            // Unexpected data type.

            NetpAssert( dwType == REG_SZ );
            *ValueBuffer = NULL;
            (VOID) NetApiBufferFree( ValueT );
            ApiStatus = ERROR_INVALID_DATA;
        }

    }

    return (ApiStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\confexp.c ===
/*++

Copyright (c) 1992-1993  Microsoft Corporation

Module Name:

    ConfExp.c

Abstract:

    This module contains NetpExpandConfigString().

Author:

    JR (John Rogers, JohnRo@Microsoft) 26-May-1992

Revision History:

    26-May-1992 JohnRo
        Created.  [but didn't use until April '93  --JR]
    13-Apr-1993 JohnRo
        RAID 5483: server manager: wrong path given in repl dialog.

--*/


// These must be included first:

#include <nt.h>         // NT_SUCCESS(), etc.
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>    // IN, LPCTSTR, OPTIONAL, etc.
#include <lmcons.h>     // NET_API_STATUS.

// These may be included in any order:

#include <config.h>     // My prototype.
#include <configp.h>    // NetpGetWinRegConfigMaxSizes().
#include <confname.h>   // ENV_KEYWORD_SYSTEMROOT, etc.
#include <debuglib.h>   // IF_DEBUG()
#include <lmerr.h>      // NO_ERROR, ERROR_ and NERR_ equates.
#include <netdebug.h>   // NetpKdPrint().
#include <netlib.h>     // NetpMemoryAllocate(), etc.
#include <netlibnt.h>   // NetpNtStatusToApiStatus().
#include <prefix.h>     // PREFIX_ equates.
#include <tstring.h>    // NetpAlloc{type}From{type}, STRSIZE(), TCHAR_EOS, etc.


#define DEFAULT_ROOT_KEY        HKEY_LOCAL_MACHINE

#define REG_PATH_TO_ENV         (LPTSTR) \
    TEXT("System\\CurrentControlSet\\Control\\Session Manager")

#define REG_PATH_TO_SYSROOT     (LPTSTR) \
    TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion")

#ifndef TCHAR_PERCENT
#define TCHAR_PERCENT   TEXT('%')
#endif


DBGSTATIC NET_API_STATUS
NetpAddValueToTempEnvironment(
    IN OUT PVOID   TemporaryEnvironment,
    IN     LPCTSTR KeywordW,
    IN     LPCTSTR ValueW
    )
{
    NET_API_STATUS ApiStatus = NO_ERROR;
    UNICODE_STRING KeywordString;
    NTSTATUS       NtStatus;
    UNICODE_STRING ValueString;

    RtlInitUnicodeString(
            &KeywordString,     // dest
            KeywordW );  // src

    RtlInitUnicodeString(
            &ValueString,       // dest
            ValueW );    // src

    NtStatus = RtlSetEnvironmentVariable(
            &TemporaryEnvironment,
            &KeywordString,     // name
            &ValueString );     // value
    if ( !NT_SUCCESS( NtStatus ) ) {
        ApiStatus = NetpNtStatusToApiStatus( NtStatus );
        NetpAssert( ApiStatus != NO_ERROR );
        goto Cleanup;
    }

    ApiStatus = NO_ERROR;

Cleanup:

    return (ApiStatus);
    
} // NetpAddValueToTempEnvironment


NET_API_STATUS
NetpExpandConfigString(
    IN  LPCTSTR  UncServerName OPTIONAL,
    IN  LPCTSTR  UnexpandedString,
    OUT LPTSTR * ValueBufferPtr         // Must be freed by NetApiBufferFree().
    )
/*++

Routine Description:

    This function expands a value string (which may include references to
    environment variables).  For instance, an unexpanded string might be:

        %SystemRoot%\System32\Repl\Export

    This could be expanded to:

        c:\nt\System32\Repl\Export

    The expansion makes use of environment variables on UncServerName,
    if given.  This allows remote administration of the directory
    replicator.

Arguments:

    UncServerName - assumed to NOT BE EXPLICIT LOCAL SERVER NAME.

    UnexpandedString - points to source string to be expanded.

    ValueBufferPtr - indicates a pointer which will be set by this routine.
        This routine will allocate memory for a null-terminated string.
        The caller must free this with NetApiBufferFree() or equivalent.


Return Value:

    NET_API_STATUS

--*/
{
    NET_API_STATUS ApiStatus = NO_ERROR;
    LPTSTR         ExpandedString = NULL;
    DWORD          LastAllocationSize = 0;
    NTSTATUS       NtStatus;
    LPTSTR         RandomKeywordW = NULL;
    DWORD          RandomValueSize;
    LPTSTR         RandomValueW = NULL;
    HKEY           RootKey = DEFAULT_ROOT_KEY;
    HKEY           SectionKey = DEFAULT_ROOT_KEY;
    PVOID          TemporaryEnvironment = NULL;

    NetpAssert( sizeof(DWORD) == sizeof(ULONG) );  // Mixing win32 and NT APIs.

    //
    // Check for caller errors.
    //


    if (ValueBufferPtr == NULL) {
        // Can't goto Cleanup here, as it assumes this pointer is valid.
        return (ERROR_INVALID_PARAMETER);
    }
    *ValueBufferPtr = NULL;     // assume error until proven otherwise.
    if ( (UnexpandedString == NULL) || ((*UnexpandedString) == TCHAR_EOS ) ) {
        ApiStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }


    //
    // This is probably just a constant string.  Can we do it the easy way?
    //

    if (STRCHR( UnexpandedString, TCHAR_PERCENT ) == NULL) {

        // Just need to allocate a copy of the input string.
        ExpandedString = NetpAllocWStrFromWStr( (LPTSTR) UnexpandedString );
        if (ExpandedString == NULL) {
            ApiStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        // That's all, folks!
        ApiStatus = NO_ERROR;


    //
    // Otherwise, is this local?  Maybe we can
    // handle local expansion the easy (fast) way: using win32 API.
    //

    } else if ( (UncServerName==NULL) || ((*UncServerName)==TCHAR_EOS) ) {

        DWORD CharsRequired = STRLEN( UnexpandedString )+1;
        NetpAssert( CharsRequired > 1 );

        do {

            // Clean up from previous pass.
            if (ExpandedString != NULL) {
                NetpMemoryFree( ExpandedString );
                ExpandedString = NULL;
            }

            // Allocate the memory.
            NetpAssert( CharsRequired > 1 );
            ExpandedString = NetpMemoryAllocate( CharsRequired * sizeof(TCHAR));
            if (ExpandedString == NULL) {
                ApiStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }
            LastAllocationSize = CharsRequired * sizeof(TCHAR);

            IF_DEBUG( CONFIG ) {
                NetpKdPrint(( PREFIX_NETLIB
                        "NetpExpandConfigString: expanding"
                        " '" FORMAT_LPTSTR "' locally into " FORMAT_LPVOID
                        ", alloc'ed size " FORMAT_DWORD ".\n",
                        UnexpandedString, (LPVOID) ExpandedString,
                        LastAllocationSize ));
            }

            // Expand string using local env vars.

            CharsRequired = ExpandEnvironmentStrings(
                    UnexpandedString,           // src
                    ExpandedString,             // dest
                    LastAllocationSize / sizeof(TCHAR) ); // dest max char count
            if (CharsRequired == 0) {
                ApiStatus = (NET_API_STATUS) GetLastError();
                NetpKdPrint(( PREFIX_NETLIB
                      "NetpExpandConfigString: "
                      "ExpandEnvironmentStringsW failed, API status="
                      FORMAT_API_STATUS ".\n", ApiStatus ));
                NetpAssert( ApiStatus != NO_ERROR );
                goto Cleanup;
            }

        } while ((CharsRequired*sizeof(TCHAR)) > LastAllocationSize);

        IF_DEBUG( CONFIG ) {
            NetpKdPrint(( PREFIX_NETLIB
                    "NetpExpandConfigString: expanded '"
                    FORMAT_LPTSTR "' to '" FORMAT_LPTSTR "'.\n",
                    UnexpandedString, ExpandedString ));
        }
        ApiStatus = NO_ERROR;


    //
    // Oh well, remote expansion required.
    //

    } else {

        DWORD          DataType;
        LONG           Error;
        UNICODE_STRING ExpandedUnicode;
        DWORD          SizeRequired;
        UNICODE_STRING UnexpandedUnicode;

        //
        // Connect to remote registry.
        //

        Error = RegConnectRegistry(
                (LPTSTR) UncServerName,
                DEFAULT_ROOT_KEY,
                & RootKey );        // result key

        if (Error != ERROR_SUCCESS) {
            NetpKdPrint(( PREFIX_NETLIB
                    "NetpExpandConfigString: RegConnectRegistry(machine '"
                    FORMAT_LPTSTR "') ret error " FORMAT_LONG ".\n",
                    UncServerName, Error ));
            ApiStatus = (NET_API_STATUS) Error;
            NetpAssert( ApiStatus != NO_ERROR );
            goto Cleanup;
        }
        NetpAssert( RootKey != DEFAULT_ROOT_KEY );


        //
        // Create a temporary environment, which we'll fill in and let RTL
        // routines do the expansion for us.
        //

        NtStatus = RtlCreateEnvironment(
                (BOOLEAN) FALSE,  // don't clone current env
                &TemporaryEnvironment );
        if ( !NT_SUCCESS( NtStatus ) ) {
            ApiStatus = NetpNtStatusToApiStatus( NtStatus );

            NetpKdPrint(( PREFIX_NETLIB
                   "NetpExpandConfigString: RtlCreateEnvironment failed, "
                   "NT status=" FORMAT_NTSTATUS
                   ", API status=" FORMAT_API_STATUS ".\n",
                   NtStatus, ApiStatus ));
            NetpAssert( ApiStatus != NO_ERROR );
            goto Cleanup;
        }
        NetpAssert( TemporaryEnvironment != NULL );

        //
        // Start by populating the temporary environment with SystemRoot.
        //
        Error = RegOpenKeyEx(
                RootKey,
                REG_PATH_TO_SYSROOT,
                REG_OPTION_NON_VOLATILE,
                KEY_READ,               // desired access
                & SectionKey );
        if (Error == ERROR_FILE_NOT_FOUND) {
            ApiStatus = NERR_CfgCompNotFound;
            goto Cleanup;
        } else if (Error != ERROR_SUCCESS) {
            ApiStatus = (NET_API_STATUS) Error;
            NetpAssert( ApiStatus != NO_ERROR );
            goto Cleanup;
        }
        NetpAssert( SectionKey != DEFAULT_ROOT_KEY );

        ApiStatus = NetpGetWinRegConfigMaxSizes(
               SectionKey,
               NULL,                    // don't need keyword size
               &RandomValueSize );      // set max value size.
        if (ApiStatus != NO_ERROR) {
            goto Cleanup;
        }
        NetpAssert( RandomValueSize > 0 );

        RandomValueW = NetpMemoryAllocate( RandomValueSize );
        if (RandomValueW == NULL) {
            ApiStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        Error = RegQueryValueEx(
                SectionKey,
                (LPTSTR) ENV_KEYWORD_SYSTEMROOT,
                NULL,                   // reserved
                & DataType,
                (LPVOID) RandomValueW,  // out: value string (TCHARs).
                & RandomValueSize );
        if (Error != ERROR_SUCCESS) {
            ApiStatus = (NET_API_STATUS) Error;
            goto Cleanup;
        }
        if (DataType != REG_SZ) {
            NetpKdPrint(( PREFIX_NETLIB
                   "NetpExpandConfigString: unexpected data type "
                   FORMAT_DWORD ".\n", DataType ));
            ApiStatus = ERROR_INVALID_DATA;
            goto Cleanup;
        }
        if ( (RandomValueSize == 0)
                || ((RandomValueSize % sizeof(TCHAR)) != 0) ) {

            NetpKdPrint(( PREFIX_NETLIB
                   "NetpExpandConfigString: unexpected data size "
                   FORMAT_DWORD ".\n", RandomValueSize ));
            ApiStatus = ERROR_INVALID_DATA;
            goto Cleanup;
        }
        ApiStatus = NetpAddValueToTempEnvironment(
                TemporaryEnvironment,
                (LPTSTR) ENV_KEYWORD_SYSTEMROOT,
                RandomValueW );
        if (ApiStatus != NO_ERROR) {
            goto Cleanup;
        }

        //
        // Loop until we have enough storage.
        // Expand the string.
        //
        SizeRequired = STRSIZE( UnexpandedString ); // First pass, try same size
        RtlInitUnicodeString(
                &UnexpandedUnicode,             // dest
                (PCWSTR) UnexpandedString );    // src

        do {

            // Clean up from previous pass.
            if (ExpandedString != NULL) {
                NetpMemoryFree( ExpandedString );
                ExpandedString = NULL;
            }

            // Allocate the memory.
            NetpAssert( SizeRequired > 0 );
            ExpandedString = NetpMemoryAllocate( SizeRequired );
            if (ExpandedString == NULL) {
                ApiStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }
            LastAllocationSize = SizeRequired;

            ExpandedUnicode.MaximumLength = (USHORT)SizeRequired;
            ExpandedUnicode.Buffer = ExpandedString;

            IF_DEBUG( CONFIG ) {
                NetpKdPrint(( PREFIX_NETLIB
                        "NetpExpandConfigString: expanding"
                        " '" FORMAT_LPTSTR "' remotely into " FORMAT_LPVOID
                        ", alloc'ed size " FORMAT_DWORD ".\n",
                        UnexpandedString, (LPVOID) ExpandedString,
                        SizeRequired ));
            }

            NtStatus = RtlExpandEnvironmentStrings_U(
                    TemporaryEnvironment,       // env to use
                    &UnexpandedUnicode,         // source
                    &ExpandedUnicode,           // dest
                    (PULONG) &SizeRequired );   // dest size needed next time.

            if ( NtStatus == STATUS_BUFFER_TOO_SMALL ) {
                NetpAssert( SizeRequired > LastAllocationSize );
                continue;  // try again with larger buffer.

            } else if ( !NT_SUCCESS( NtStatus ) ) {
                ApiStatus = NetpNtStatusToApiStatus( NtStatus );

                NetpKdPrint(( PREFIX_NETLIB
                       "NetpExpandConfigString: "
                       "RtlExpandEnvironmentStrings_U failed, "
                       "NT status=" FORMAT_NTSTATUS
                       ", API status=" FORMAT_API_STATUS ".\n",
                       NtStatus, ApiStatus ));
                NetpAssert( ApiStatus != NO_ERROR );
                goto Cleanup;

            } else {
                NetpAssert( NT_SUCCESS( NtStatus ) );
                break;  // All done.
            }

        } while (SizeRequired > LastAllocationSize);

        ApiStatus = NO_ERROR;
    }


Cleanup:

    IF_DEBUG( CONFIG ) {
        NetpKdPrint(( PREFIX_NETLIB
               "NetpExpandConfigString: returning, API status="
               FORMAT_API_STATUS ".\n", ApiStatus ));
    }

    if (ApiStatus == NO_ERROR) {
        NetpAssert( ExpandedString != NULL );
        *ValueBufferPtr = ExpandedString;
    } else {
        *ValueBufferPtr = NULL;

        if (ExpandedString != NULL) {
            NetpMemoryFree( ExpandedString );
        }
    }

    if (RandomKeywordW != NULL) {
        NetpMemoryFree( RandomKeywordW );
    }

    if (RandomValueW != NULL) {
        NetpMemoryFree( RandomValueW );
    }

    if (RootKey != DEFAULT_ROOT_KEY) {
        (VOID) RegCloseKey( RootKey );
    }

    if (SectionKey != DEFAULT_ROOT_KEY) {
        (VOID) RegCloseKey( SectionKey );
    }

    if (TemporaryEnvironment != NULL) {
        (VOID) RtlDestroyEnvironment( TemporaryEnvironment );
    }

    return (ApiStatus);

} // NetpExpandConfigString
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\canon.c ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    canon.c

Abstract:

    Code to 'canonicalize' a path name. This code may be replaced by OS or FS
    code sometime in the future, so keep it separate from the rest of the net
    canonicalization code.

    We do not canonicalize a path with reference to a specific drive. Therefore,
    we can't use rules about the number of characters or format of a path
    component (eg. FAT filename rules). We leave this up to the file system. The
    CanonicalizePathName function in this module will make a path name look
    presentable, nothing more

    Contents:

        CanonicalizePathName
        (ConvertPathCharacters)
        (ParseLocalDevicePrefix)
        (ConvertPathMacros)
        (BackUpPath)

Author:

    Richard L Firth (rfirth) 02-Jan-1992

Revision History:

--*/

#include "nticanon.h"
#include <tstring.h>    // NetpInitOemString().

const TCHAR   text_AUX[]  = TEXT("AUX");
const TCHAR   text_COM[]  = TEXT("COM");
const TCHAR   text_DEV[]  = TEXT("DEV");
const TCHAR   text_LPT[]  = TEXT("LPT");
const TCHAR   text_PRN[]  = TEXT("PRN");

//
// prototypes
//

STATIC
VOID
ConvertPathCharacters(
    IN  LPTSTR  Path
    );

STATIC
BOOL
ConvertDeviceName(
    IN OUT  LPTSTR  PathName
    );

STATIC
BOOL
ParseLocalDevicePrefix(
    IN OUT  LPTSTR* DeviceName
    );

STATIC
BOOL
ConvertPathMacros(
    IN OUT  LPTSTR  Path
    );

STATIC
LPTSTR
BackUpPath(
    IN  LPTSTR  Stopper,
    IN  LPTSTR  Path
    );

//
// routines
//

NET_API_STATUS
CanonicalizePathName(
    IN  LPTSTR  PathPrefix OPTIONAL,
    IN  LPTSTR  PathName,
    OUT LPTSTR  Buffer,
    IN  DWORD   BufferSize,
    OUT LPDWORD RequiredSize OPTIONAL
    )

/*++

Routine Description:

    Given a path name, this function will 'canonicalize' it - that is, convert
    it to a standard form. We attempt to accomplish here what path canonicalization
    accomplished in LANMAN. The following is done:

        * all macros in the input filename (\., .\, \.., ..\) are removed and
          replaced by path components

        * any required translations are performed on the path specification:

            * unix-style / converted to dos-style \

            * specific transliteration. NOTE: the input case is NOT converted.
              The underlying file system may be case insensitive. Just pass
              through the path as presented by the caller

            * device names (ie name space controlled by us) is canonicalized by
              converting device names to UPPER CASE and removing trailing colon
              in all but disk devices

    What is NOT done:
        * starts with a drive specifier (eg. D:) or a sharepoint specifier
          (eg \\computername\sharename)

        * all path components required to fully specify the required path or
          file are included in the output path specification

    NOTES:  1. This function only uses local naming rules. It does not gurantee
               to 'correctly' canonicalize a remote path name

            2. Character validation is not done - this is left to the underlying
               file system

Arguments:

    PathPrefix  - an OPTIONAL parameter. If non-NULL, points to a string which
                  is to be prepended to PathName before canonicalization of
                  the concatenated strings. This will typically be another
                  drive or path

    PathName    - input path to canonicalize. May be already fully qualified,
                  or may be one of the following:
                    - relative local path name (eg foo\bar)
                    - remote path name (eg \\computer\share\foo\bar\filename.ext)
                    - device name (eg LPT1:)

    Buffer      - place to store the canonicalized name

    BufferSize  - size (in bytes) of Buffer

    RequiredSize- OPTIONAL parameter. If supplied AND Buffer was not sufficient
                  to hold the results of the canonicalization then will contain
                  the size of buffer necessary to retrieve canonicalized version
                  of PathName (optionally prefixed by PathPrefix)

Return Value:

    DWORD
        Success - NERR_Success

        Failure - ERROR_INVALID_NAME
                    There is a fundamental problem with PathName (like too
                    many ..\ macros) or the name is too long

                  NERR_BufTooSmall
                    Buffer is too small to hold the canonicalized path
--*/

{
    TCHAR   pathBuffer[MAX_PATH*2 + 1];
    DWORD   prefixLen;
    DWORD   pathLen;

    if (ARGUMENT_PRESENT(PathPrefix)) {
        prefixLen = STRLEN(PathPrefix);
        if (prefixLen) {
            // Make sure we don't overrun our buffer
            if (prefixLen > MAX_PATH*2 ) {
                return ERROR_INVALID_NAME;
            }
            STRCPY(pathBuffer, PathPrefix);
            if (!IS_PATH_SEPARATOR(pathBuffer[prefixLen - 1])) {
                STRCAT(pathBuffer, TEXT("\\"));
                ++prefixLen;
            }
            if (IS_PATH_SEPARATOR(*PathName)) {
                ++PathName;
            }
        }
    } else {
        prefixLen = 0;
        pathBuffer[0] = 0;
    }

    pathLen = STRLEN(PathName);
    if (pathLen + prefixLen > MAX_PATH*2 - 1) {
        return ERROR_INVALID_NAME;
    }

    STRCAT(pathBuffer, PathName);
    ConvertPathCharacters(pathBuffer);

    if (!ConvertDeviceName(pathBuffer)) {
        if (!ConvertPathMacros(pathBuffer)) {
            return ERROR_INVALID_NAME;
        }
    }

    pathLen = STRSIZE(pathBuffer);
    if (pathLen > BufferSize) {
        if (ARGUMENT_PRESENT(RequiredSize)) {
            *RequiredSize = pathLen;
        }
        return NERR_BufTooSmall;
    }

    STRCPY(Buffer, pathBuffer);
    return NERR_Success;
}

STATIC
VOID
ConvertPathCharacters(
    IN  LPTSTR  Path
    )

/*++

Routine Description:

    Converts non-standard path component characters to their canonical
    counterparts. Currently all this routine does is convert / to \. It may
    be enhanced in future to perform case conversion

Arguments:

    Path    - pointer to path buffer to transform. Performs conversion in place

Return Value:

    None.

--*/

{
    while (*Path) {
        if (*Path == TCHAR_FWDSLASH) {
            *Path = TCHAR_BACKSLASH;
        }
        ++Path;
    }
}

STATIC
BOOL
ConvertDeviceName(
    IN OUT  LPTSTR  PathName
    )

/*++

Routine Description:

    If PathBuffer contains a device name of AUX or PRN (case insensitive),
    convert to COM1 and LPT1 resp. If PathBuffer is a device and has a local
    device prefix (\dev\ (LM20 style) or \\.\) then skips it, but leaves the
    prefix in the buffer.

    Device names (including DISK devices) will be UPPERCASEd, whatever that
    means for other locales.

    ASSUMES:    Disk Device is single CHARACTER, followed by ':' (optionally
                followed by rest of path)

Arguments:

    PathName    - pointer to buffer containing possible device name. Performs
                  conversion in place

Return Value:

    BOOL
        TRUE    - PathName is a DOS device name
        FALSE   - PathName not a DOS device

--*/

{
    BOOL    isDeviceName = FALSE;

#ifndef UNICODE

    UNICODE_STRING  PathName_U;
    OEM_STRING PathName_A;
    PWSTR   PathName_W;

    NetpInitOemString(&PathName_A, PathName);
    RtlOemStringToUnicodeString(&PathName_U, &PathName_A, TRUE);
    PathName_W = PathName_U.Buffer;
    if (RtlIsDosDeviceName_U(PathName_W)) {
        LPTSTR  deviceName = PathName;
        DWORD   deviceLength;

        ParseLocalDevicePrefix(&deviceName);
        deviceLength = STRLEN(deviceName) - 1;
        if (deviceName[deviceLength] == TCHAR_COLON) {
            deviceName[deviceLength] = 0;
            --deviceLength;
        }
        if (!STRICMP(deviceName, text_PRN)) {
            STRCPY(deviceName, text_LPT);
            STRCAT(deviceName, TEXT("1"));
        } else if (!STRICMP(deviceName, text_AUX)) {
            STRCPY(deviceName, text_COM);
            STRCAT(deviceName, TEXT("1"));
        }
        isDeviceName = TRUE;
        STRUPR(deviceName);
    } else {
        switch (RtlDetermineDosPathNameType_U(PathName_W)) {
        case RtlPathTypeDriveRelative:
        case RtlPathTypeDriveAbsolute:
            *PathName = TOUPPER(*PathName);
        }
    }
    RtlFreeUnicodeString(&PathName_U);

#else

    if (RtlIsDosDeviceName_U(PathName)) {
        LPTSTR  deviceName = PathName;
        DWORD   deviceLength;

        ParseLocalDevicePrefix(&deviceName);
        deviceLength = STRLEN(deviceName) - 1;
        if (deviceName[deviceLength] == TCHAR_COLON) {
            deviceName[deviceLength] = 0;
            --deviceLength;
        }
        if (!STRICMP(deviceName, text_PRN)) {
            STRCPY(deviceName, text_LPT);
            STRCAT(deviceName, TEXT("1"));
        } else if (!STRICMP(deviceName, text_AUX)) {
            STRCPY(deviceName, text_COM);
            STRCAT(deviceName, TEXT("1"));
        }
        isDeviceName = TRUE;
        STRUPR(deviceName);
    } else {
        switch (RtlDetermineDosPathNameType_U(PathName)) {
        case RtlPathTypeDriveRelative:
        case RtlPathTypeDriveAbsolute:
            *PathName = TOUPPER(*PathName);
        }
    }

#endif

    return isDeviceName;
}

STATIC
BOOL
ParseLocalDevicePrefix(
    IN OUT  LPTSTR* DeviceName
    )

/*++

Routine Description:

    If a device name starts with a local device name specifier - "\\.\" or
    "\DEV\" - then move DeviceName past the prefix and return TRUE, else FALSE

Arguments:

    DeviceName  - pointer to string containing potential local device name,
                  prefixed by "\\.\" or "\DEV\". If the local device prefix
                  is present the string pointer is advanced past it to the
                  device name proper

Return Value:

    BOOL
        TRUE    - DeviceName has a local device prefix. DeviceName now points at
                  the name after the prefix

        FALSE   - DeviceName doesn't have a local device prefix

--*/

{
    LPTSTR  devName = *DeviceName;

    if (IS_PATH_SEPARATOR(*devName)) {
        ++devName;
        if (!STRNICMP(devName, text_DEV, 3)) {
            devName += 3;
        } else if (IS_PATH_SEPARATOR(*devName)) {
            ++devName;
            if (*devName == TCHAR_DOT) {
                ++devName;
            } else {
                return FALSE;
            }
        } else {
            return FALSE;
        }
        if (IS_PATH_SEPARATOR(*devName)) {
            ++devName;
            *DeviceName = devName;
            return TRUE;
        }
    }
    return FALSE;
}

STATIC
BOOL
ConvertPathMacros(
    IN OUT  LPTSTR  Path
    )

/*++

Routine Description:

    Removes path macros (\.. and \.) and replaces them with the correct level
    of path components. This routine expects path macros to appear in a path
    like this:

        <path>\.
        <path>\.\<more-path>
        <path>\..
        <path>\..\<more-path>

    I.e. a macro will either be terminated by the End-Of-String character (\0)
    or another path separator (\).

    Assumes Path has \ for path separator, not /

Arguments:

    Path    - pointer to a string containing a path to convert. Path must
              contain all the path components that will appear in the result
              E.g. Path = "d:\alpha\beta\gamma\..\delta\..\..\zeta\foo\bar"
              will result in Path = "d:\zeta\foo\bar"

              Path should contain back slashes (\) for path separators if the
              correct results are to be produced

Return Value:

    TRUE    - Path converted
    FALSE   - Path contained an error

--*/

{
    LPTSTR  ptr = Path;
    LPTSTR  lastSlash = NULL;
    LPTSTR  previousLastSlash = NULL;
    TCHAR   ch;

    //
    // if this path is UNC then move the pointer past the computer name to the
    // start of the (supposed) share name. Treat the remnants as a relative path
    //

    if (IS_PATH_SEPARATOR(Path[0]) && IS_PATH_SEPARATOR(Path[1])) {
        Path += 2;
        while (!IS_PATH_SEPARATOR(*Path) && *Path) {
            ++Path;
        }
        if (!*Path) {
            return FALSE;   // we had \\computername which is bad
        }
        ++Path; // past \ into share name
        if (IS_PATH_SEPARATOR(*Path)) {
            return FALSE;   // we had \\computername\\ which is bad
        }
    }

    ptr = Path;

    //
    // remove all \., .\, \.. and ..\ from path
    //

    while ((ch = *ptr) != TCHAR_EOS) {
        if (ch == TCHAR_BACKSLASH) {
            if (lastSlash == ptr - 1) {
                return FALSE;
            }
            previousLastSlash = lastSlash;
            lastSlash = ptr;
        } else if ((ch == TCHAR_DOT) && ((lastSlash == ptr - 1) || (ptr == Path))) {
            TCHAR   nextCh = *(ptr + 1);

            if (nextCh == TCHAR_DOT) {
                TCHAR   nextCh = *(ptr + 2);

                if ((nextCh == TCHAR_BACKSLASH) || (nextCh == TCHAR_EOS)) {
                    if (!previousLastSlash) {
                        return FALSE;
                    }
                    STRCPY(previousLastSlash, ptr + 2);
                    if (nextCh == TCHAR_EOS) {
                        break;
                    }
                    ptr = lastSlash = previousLastSlash;
                    previousLastSlash = BackUpPath(Path, ptr - 1);
                }
            } else if (nextCh == TCHAR_BACKSLASH) {
                LPTSTR  src = lastSlash ? ptr + 1 : ptr + 2;
                LPTSTR  dst = lastSlash ? lastSlash : ptr;

                STRCPY(dst, src);
                continue;   // at current character position
            } else if (nextCh == TCHAR_EOS) {
                *(lastSlash ? lastSlash : ptr) = TCHAR_EOS;
                break;
            }
        }
        ++ptr;
    }

    //
    // path may be empty
    //

    return TRUE;
}

STATIC
LPTSTR
BackUpPath(
    IN  LPTSTR  Stopper,
    IN  LPTSTR  Path
    )

/*++

Routine Description:

    Searches backwards in a string for a path separator character (back-slash)

Arguments:

    Stopper - pointer past which Path cannot be backed up
    Path    - pointer to path to back up

Return Value:

    Pointer to backed-up path, or NULL if an error occurred

--*/

{
    while ((*Path != TCHAR_BACKSLASH) && (Path != Stopper)) {
        --Path;
    }
    return (*Path == TCHAR_BACKSLASH) ? Path : NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\conffail.c ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    ConfFail.c

Abstract:

    This routine is only used by the NetConfig API DLL stubs.
    See Net/API/ConfStub.c for more info.

Author:

    John Rogers (JohnRo) 26-Nov-1991

Environment:

    User Mode - Win32
    Only runs under NT; has an NT-specific interface (with Win32 types).
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    26-Nov-1991 JohnRo
        Implement local NetConfig APIs.
    07-Jan-1992 JohnRo
        Handle wksta not started better.
    09-Mar-1992 JohnRo
        Fixed a bug or two.

--*/


// These must be included first:

#include <nt.h>                 // IN, etc.  (Only needed by temporary config.h)
#include <ntrtl.h>              // (Only needed by temporary config.h)
#include <windef.h>             // LPVOID, etc.
#include <lmcons.h>             // NET_API_STATUS, etc.
#include <netdebug.h>           // (Needed by config.h)

// These may be included in any order:

#include <config.h>             // My prototype.
#include <debuglib.h>           // IF_DEBUG().
#include <lmerr.h>              // NERR_Success, etc.
#include <lmremutl.h>           // NetpRemoteComputerSupports(), SUPPORTS_ stuff
#include <lmsname.h>            // SERVICE_ equates.
#include <netlib.h>             // NetpIsServiceStarted().


#define UnexpectedConfigMsg( debugString ) \
    { \
        NetpKdPrint(( FORMAT_LPDEBUG_STRING ": unexpected situation... " \
                debugString "; original api status is " FORMAT_API_STATUS \
                ".\n", DebugName, OriginalApiStatus )); \
    }

NET_API_STATUS
NetpHandleConfigFailure(
    IN LPDEBUG_STRING DebugName,  // Used by UnexpectedConfigMsg().
    IN NET_API_STATUS OriginalApiStatus,    // Used by UnexpectedConfigMsg().
    IN LPTSTR ServerNameValue OPTIONAL,
    OUT LPBOOL TryDownlevel
    )

{
    DWORD OptionsSupported = 0;
    NET_API_STATUS TempApiStatus;

    *TryDownlevel = FALSE;        // Be pesimistic until we know for sure.

    switch (OriginalApiStatus) {
    case NERR_CfgCompNotFound    : /*FALLTHROUGH*/
    case NERR_CfgParamNotFound   : /*FALLTHROUGH*/
    case ERROR_INVALID_PARAMETER : /*FALLTHROUGH*/
    case ERROR_INVALID_LEVEL     : /*FALLTHROUGH*/
        *TryDownlevel = FALSE;
        return (OriginalApiStatus);
    }

    NetpAssert( OriginalApiStatus != NERR_Success );

    //
    // Learn about the machine.  This is fairly easy since the
    // NetRemoteComputerSupports also handles the local machine (whether
    // or not a server name is given).
    //
    TempApiStatus = NetRemoteComputerSupports(
            ServerNameValue,
            SUPPORTS_RPC | SUPPORTS_LOCAL,  // options wanted
            &OptionsSupported);

    if (TempApiStatus != NERR_Success) {
        // This is where machine not found gets handled.
        return (TempApiStatus);
    }

    if (OptionsSupported & SUPPORTS_LOCAL) {

        // We'll get here if ServerNameValue is NULL
        UnexpectedConfigMsg( "local, can't connect" );
        return (OriginalApiStatus);

    } else { // remote machine

        //
        // Local workstation is not started?  (It must be in order to
        // remote APIs to the other system.)
        //
        if (! NetpIsServiceStarted( (LPTSTR) SERVICE_WORKSTATION) ) {

            return (NERR_WkstaNotStarted);

        } else { // local wksta is started

            //
            // Remote registry call failed.  Try call to downlevel.
            //
            IF_DEBUG(CONFIG) {
                NetpKdPrint((FORMAT_LPDEBUG_STRING
                        ": Remote registry call failed.\n", DebugName));
            }

            //
            // See if the machine supports RPC.  If it does, we do not
            // try the downlevel calls, but just return the error.
            //
            if (OptionsSupported & SUPPORTS_RPC) {

                UnexpectedConfigMsg( "machine supports RPC, or other error." );

                return (OriginalApiStatus);

            } else { // need to call downlevel

                // NetpKdPrint((FORMAT_LPDEBUG_STRING
                //         ": call downlevel.\n", DebugName));

                // Tell caller to try calling downlevel routine.

                *TryDownlevel = TRUE;

                return (ERROR_NOT_SUPPORTED);  // any error code will do.

            } // need to call downlevel

            /*NOTREACHED*/

        } // local wksta is started

        /*NOTREACHED*/

    } // remote machine

    /*NOTREACHED*/


} // NetpHandleConfigFailure
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\confget.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    ConfGet.c

Abstract:

    This module contains helper routines to _read fields out of the NT
    configuration files.  This is for temporary use until the Configuration
    Registry is available.

Author:

    John Rogers (JohnRo) 27-Nov-1991

Revision History:

    27-Nov-1991 JohnRo
        Prepare for revised config handlers.  (Actually swiped the NtRtl
        version of this code from RitaW.)
    03-Dec-1991 JohnRo
        Fixed MIPS build problem.
    11-Mar-1992 JohnRo
        Added some error checking on caller's args.
        Added support for using the real Win32 registry.
        Added support for FAKE_PER_PROCESS_RW_CONFIG handling.
    07-May-1992 JohnRo
        REG_SZ now implies a UNICODE string, so we can't use REG_USZ anymore.
    08-May-1992 JohnRo
        Use <prefix.h> equates.
    10-May-1992 JohnRo
        Get winreg APIs to expand environment variables for us.
    21-May-1992 JohnRo
        RAID 9826: Match revised winreg error codes.
        Got rid of a few compiler warnings under UNICODE.
    29-May-1992 JohnRo
        RAID 10447: NetpGetConfigValue() passes *byte* values to
        ExpandEnvironmentStrings() (ChadS found the bug and the fix).
    04-Jun-1992 JohnRo
        ExpandEnvironmentStrings() returns a character count as well.
    08-Jun-1992 JohnRo
        Winreg title index parm is defunct.
        Made changes suggested by PC-LINT.
    13-Apr-1993 JohnRo
        RAID 5483: server manager: wrong path given in repl dialog.

--*/


// These must be included first:

#include <nt.h>         // NT definitions
#include <ntrtl.h>      // NT Rtl structures
#include <nturtl.h>     // NT Rtl structures
#include <windows.h>    // Needed by <configp.h> and <winreg.h>
#include <lmcons.h>     // LAN Manager common definitions
#include <netdebug.h>   // (Needed by config.h)

// These may be included in any order:

#include <config.h>     // My prototype, LPNET_CONFIG_HANDLE, etc.
#include <configp.h>    // NET_CONFIG_HANDLE.
#include <debuglib.h>   // IF_DEBUG()
#include <lmerr.h>      // LAN Manager network error definitions
#include <netlib.h>     // NetpMemoryAllocate(), etc.
#include <netlibnt.h>   // NetpAllocTStrFromString().
#include <prefix.h>     // PREFIX_ equates.
#include <tstring.h>    // NetpAllocWStrFromTStr(), TCHAR_EOS.


NET_API_STATUS
NetpGetConfigValue(
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    IN LPTSTR lptstrKeyword,
    OUT LPTSTR * ValueBufferPtr         // Must be freed by NetApiBufferFree().
    )
/*++

Routine Description:

    This function gets the keyword value string from the configuration file.

Arguments:

    SectionPointer - Supplies the pointer to a specific section in the config
        file.

    lptstrKeyword - Supplies the string of the keyword within the specified
        section to look for.

    ValueBufferPtr - Returns the string of the keyword value which is
        copied into this buffer.  This string will be allocated by this routine
        and must be freed by NetApiBufferFree().  Environment variables will
        be automagically expanded in this buffer.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS ApiStatus;
    NET_CONFIG_HANDLE * MyHandle = ConfigHandle;  // conv from opaque type
    LPTSTR lptstrValue;

    NetpAssert( ValueBufferPtr != NULL );
    *ValueBufferPtr = NULL;     // assume error until proven otherwise.

    if ( (lptstrKeyword == NULL) || ((*lptstrKeyword) == TCHAR_EOS ) ) {
        return (ERROR_INVALID_PARAMETER);
    }

    {
        DWORD dwType;
        LONG Error;
        DWORD ValueSize;

        // Find out what max value length is.
        ApiStatus = NetpGetConfigMaxSizes (
                MyHandle,
                NULL,  // Don't need max keyword size.
                & ValueSize);  // Get max value length.

        if (ApiStatus != NO_ERROR) {
            NetpAssert( ApiStatus == NO_ERROR );
            return ApiStatus;
        }

        if (ValueSize == 0) {
            return (NERR_CfgParamNotFound);
        }

        // Alloc space for the value.
        lptstrValue = NetpMemoryAllocate( ValueSize );
        if (lptstrValue == NULL) {
            return (ERROR_NOT_ENOUGH_MEMORY);
        }

        //
        // Get the actual value.
        // (This does not expand REG_EXPAND_SZ for us; we'll do that below.)
        //
        Error = RegQueryValueEx(
                MyHandle->WinRegKey,
                lptstrKeyword,
                NULL,         // reserved
                & dwType,
                (LPVOID) lptstrValue,    // out: value string (TCHARs).
                & ValueSize
                );
        IF_DEBUG(CONFIG) {
            NetpKdPrint(( PREFIX_NETLIB "NetpGetConfigValue: RegQueryValueEx("
                    FORMAT_LPTSTR ") returned " FORMAT_LONG ".\n",
                    lptstrKeyword, Error ));
        }
        if (Error == ERROR_FILE_NOT_FOUND) {
            NetpMemoryFree( lptstrValue );
            return (NERR_CfgParamNotFound);
        } else if ( Error != ERROR_SUCCESS ) {
            NetpMemoryFree( lptstrValue );
            return ( (NET_API_STATUS) Error );
        } else if (dwType == REG_EXPAND_SZ) {
            LPTSTR UnexpandedString = lptstrValue;
            LPTSTR ExpandedString = NULL;

            // Expand string, using remote environment if necessary.
            ApiStatus = NetpExpandConfigString(
                    MyHandle->UncServerName,    // server name (or null char)
                    UnexpandedString,
                    &ExpandedString );          // expanded: alloc and set ptr

            IF_DEBUG( CONFIG ) {
                NetpKdPrint(( PREFIX_NETLIB
                        "NetpGetConfigValue: done expanding '"
                        FORMAT_LPTSTR "' to '" FORMAT_LPTSTR "'.\n",
                        UnexpandedString, ExpandedString ));
            }
            if (ApiStatus != NO_ERROR) {
                NetpKdPrint(( PREFIX_NETLIB
                        "NetpGetConfigValue: ERROR EXPANDING '"
                        FORMAT_LPTSTR "' to '" FORMAT_LPTSTR "', API status="
                        FORMAT_API_STATUS ".\n",
                        UnexpandedString, ExpandedString, ApiStatus ));

                NetpMemoryFree( lptstrValue );
                if (ExpandedString != NULL) {
                    NetpMemoryFree( ExpandedString );
                }
                return (ApiStatus);
            }

            NetpMemoryFree( UnexpandedString );
            lptstrValue = ExpandedString;

        } else if (dwType != REG_SZ) {
            NetpMemoryFree( lptstrValue );
            IF_DEBUG(CONFIG) {
                NetpKdPrint(( PREFIX_NETLIB
                        "NetpGetConfigValue: read unexpected reg type "
                        FORMAT_DWORD ":\n", dwType ));
                NetpDbgHexDump( (LPVOID) lptstrValue, ValueSize );
            }
            return (ERROR_INVALID_DATA);
        }

    }

    NetpAssert( lptstrValue != NULL );

    IF_DEBUG(CONFIG) {
        NetpKdPrint(( PREFIX_NETLIB "NetpGetConfigValue: value for '"
                FORMAT_LPTSTR "' is '" FORMAT_LPTSTR "'.\n",
                lptstrKeyword, lptstrValue));
    }

    *ValueBufferPtr = lptstrValue;
    return NERR_Success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\confgeta.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ConfGetA.c

Abstract:

    This module just contains NetpGetConfigTStrArray().

Author:

    John Rogers (JohnRo) 08-May-1992

Revision History:

    08-May-1992 JohnRo
        Created.
    08-May-1992 JohnRo
        Use <prefix.h> equates.
    09-May-1992 JohnRo
        Handle max size zero (i.e. no keys at all with winreg APIs).
    21-May-1992 JohnRo
        RAID 9826: Match revised winreg error codes.
    05-Jun-1992 JohnRo
        Winreg title index parm is defunct.

--*/


// These must be included first:

#include <nt.h>         // NT definitions
#include <ntrtl.h>      // NT Rtl structures
#include <nturtl.h>     // NT Rtl structures
#include <windows.h>    // Needed by <configp.h> and <winreg.h>
#include <lmcons.h>     // LAN Manager common definitions
#include <netdebug.h>   // (Needed by config.h)

// These may be included in any order:

#include <config.h>     // My prototype, LPNET_CONFIG_HANDLE.
#include <configp.h>    // USE_WIN32_CONFIG (if defined), etc.
#include <debuglib.h>   // IF_DEBUG()
#include <lmerr.h>      // LAN Manager network error definitions
#include <netlib.h>     // NetpMemoryAllocate(), etc.
#include <netlibnt.h>   // NetpAllocTStrFromString().
#include <prefix.h>     // PREFIX_ equates.
#include <strarray.h>   // LPTSTR_ARRAY, some TStr macros and funcs.
#include <tstring.h>    // NetpAllocWStrFromTStr(), TCHAR_EOS.


// Return null-null array of strings.
// Return NERR_CfgParamNotFound if the keyword isn't present.
NET_API_STATUS
NetpGetConfigTStrArray(
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    IN LPTSTR Keyword,
    OUT LPTSTR_ARRAY * ValueBuffer      // Must be freed by NetApiBufferFree().
    )
/*++

Routine Description:

    This function gets the keyword value string from the configuration file.

Arguments:

    SectionPointer - Supplies the pointer to a specific section in the config
        file.

    Keyword - Supplies the string of the keyword within the specified
        section to look for.

    ValueBuffer - Returns the string of the keyword value which is
        copied into this buffer.  This string will be allocated by this routine
        and must be freed by NetApiBufferFree().

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS ApiStatus;
    NET_CONFIG_HANDLE * MyHandle = ConfigHandle;  // conv from opaque type
    LPTSTR_ARRAY ArrayStart;

    NetpAssert( ValueBuffer != NULL );
    *ValueBuffer = NULL;     // assume error until proven otherwise.

    if ( (Keyword == NULL) || ((*Keyword) == TCHAR_EOS ) ) {
        return (ERROR_INVALID_PARAMETER);
    }

    {
        DWORD dwType;
        LONG Error;
        DWORD ValueSize;

        // Find out what max value length is.
        ApiStatus = NetpGetConfigMaxSizes (
                MyHandle,
                NULL,  // Don't need max keyword size.
                & ValueSize);  // Get max value length.

        if (ApiStatus != NO_ERROR) {
            NetpAssert( ApiStatus == NO_ERROR );
            return ApiStatus;
        }

        // If max size is zero (no entries), then skip out.
        if (ValueSize == 0) {
            return (NERR_CfgParamNotFound);
        }

        // Alloc space for the value.
        ArrayStart = NetpMemoryAllocate( ValueSize );
        if (ArrayStart == NULL) {
            return (ERROR_NOT_ENOUGH_MEMORY);
        }

        // Get the actual value.
        Error = RegQueryValueEx (
                MyHandle->WinRegKey,
                Keyword,
                NULL,         // reserved
                & dwType,
                (LPVOID) ArrayStart,    // out: value string (TCHARs).
                & ValueSize
                );
        IF_DEBUG(CONFIG) {
            NetpKdPrint(( PREFIX_NETLIB
                    "NetpGetConfigTStrArray: RegQueryValueEx("
                    FORMAT_LPTSTR ") returned " FORMAT_LONG ".\n",
                    Keyword, Error ));
        }
        if (Error == ERROR_FILE_NOT_FOUND) {
            NetpMemoryFree( ArrayStart );
            return (NERR_CfgParamNotFound);
        } else if ( Error != ERROR_SUCCESS ) {
            NetpMemoryFree( ArrayStart );
            return (Error);
        } else if (dwType != REG_MULTI_SZ) {
            NetpMemoryFree( ArrayStart );
            IF_DEBUG(CONFIG) {
                NetpKdPrint(( PREFIX_NETLIB
                        "NetpGetConfigTStrArray: got unexpected reg type "
                        FORMAT_DWORD ".\n", dwType ));
            }
            return (ERROR_INVALID_DATA);
        }
        NetpAssert( ValueSize >= sizeof(TCHAR) );

    }
    NetpAssert( ArrayStart != NULL );

    IF_DEBUG(CONFIG) {
        NetpKdPrint(( PREFIX_NETLIB "NetpGetConfigTStrArray: value for '"
                FORMAT_LPTSTR "':\n", Keyword));
        NetpDisplayTStrArray( ArrayStart );
    }

    *ValueBuffer = ArrayStart;
    return NERR_Success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\confname.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ConfName.c

Abstract:

    This module contains NetpAllocConfigName().

Author:

    John Rogers (JohnRo) 14-May-1992

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    14-May-1992 JohnRo
        Extracted and generalized this code from NetLib/ConfOpen.c.

--*/


// These must be included first:

#include <windows.h>
#include <winsvc.h>     // SERVICES_ equates, etc.
#include <lmcons.h>     // LAN Manager common definitions
#include <netdebug.h>   // (Needed by config.h)

// These may be included in any order:

#include <confname.h>   // My prototype.
#include <debuglib.h>   // IF_DEBUG().
#include <lmerr.h>      // LAN Manager network error definitions
#include <netlib.h>     // NetpMemoryAllocate(), etc.
#include <prefix.h>     // PREFIX_ equates.
#include <tstring.h>    // NetpAlloc{type}From{type}, STRICMP(), etc.


#define SUBKEY_SERVICES_ACTIVE \
            TEXT("System\\CurrentControlSet\\Services\\")

#define DEFAULT_AREA_UNDER_SERVICE      TEXT("Parameters")


NET_API_STATUS
NetpAllocConfigName(
    IN LPTSTR DatabaseName,              // SERVICES_xxx_DATABASE from winsvc.h.
    IN LPTSTR ServiceName,               // SERVICE_ name equate from lmsname.h
    IN LPTSTR AreaUnderServiceName OPTIONAL,  // defaults to "Parameters"
    OUT LPTSTR *FullConfigName           // free with NetApiBufferFree.
    )

/*++

Routine Description:

    Allocates a buffer for and builds up the path to the Parameters subkey for
    the given service's key under HKLM\System\CurrentControlSet\Services

Return Value:

    NET_API_STATUS - NO_ERROR or reason for failure.

--*/

{
    LPTSTR AreaToUse;
    DWORD FullPathSize;
    LPTSTR FullPath;
    LPTSTR SubkeyUnderLocalMachine;

    //
    // Check for caller errors and set defaults.
    //
    if ( (ServiceName == NULL) || (*ServiceName == TCHAR_EOS) ) {
        return (ERROR_INVALID_PARAMETER);
    } else if (FullConfigName == NULL) {
        return (ERROR_INVALID_PARAMETER);
    }

    if (AreaUnderServiceName != NULL) {
       AreaToUse = AreaUnderServiceName;
    } else {
       AreaToUse = DEFAULT_AREA_UNDER_SERVICE;
    }

    if (DatabaseName == NULL) {
       SubkeyUnderLocalMachine = SUBKEY_SERVICES_ACTIVE;
    } else if (STRICMP(DatabaseName, SERVICES_ACTIVE_DATABASE) == 0) {
       SubkeyUnderLocalMachine = SUBKEY_SERVICES_ACTIVE;
    } else {
        return (ERROR_INVALID_PARAMETER);
    }

    //
    // Compute size of name.
    //
    FullPathSize = ( STRLEN(SubkeyUnderLocalMachine)
                   + STRLEN(ServiceName)
                   + 1                  // backslash
                   + STRLEN(AreaToUse)
                   + 1 )                // trailing null
                 * sizeof(TCHAR);

    //
    // Allocate space for the name.
    //
    FullPath = NetpMemoryAllocate( FullPathSize );
    if (FullPath == NULL) {
        return (ERROR_NOT_ENOUGH_MEMORY);
    }

    //
    // Build the name.
    //
    STRCPY( FullPath, SubkeyUnderLocalMachine );  // ends w/ backslash.
    STRCAT( FullPath, ServiceName );
    STRCAT( FullPath, TEXT("\\") );   // one backslash to separate.
    STRCAT( FullPath, AreaToUse );

    //
    // Tell caller how things went.
    //
    *FullConfigName = FullPath;

    IF_DEBUG( CONFIG ) {
        NetpKdPrint((  PREFIX_NETLIB
                "NetpAllocConfigName: built name '" FORMAT_LPTSTR "'.\n",
                FullPath ));
    }

    return (NO_ERROR);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\confgetb.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ConfGetB.c

Abstract:

    This module contains NetpGetConfigBool().

Author:

    John Rogers (JohnRo) 13-Mar-1992

Revision History:

    13-Mar-1992 JohnRo
        Created.
    08-May-1992 JohnRo
        Enable win32 registry for NET tree by allowing REG_DWORD and REG_SZ.
        Allow net config helpers for NetLogon by allowing 'YES' and 'NO'.
        Use <prefix.h> equates.
    21-May-1992 JohnRo
        RAID 9826: Match revised winreg error codes.
    09-Jun-1992 JohnRo
        RAID 11582: Winreg title index parm is defunct.
        RAID 11784: repl svc doesn't default some config parms anymore.
    13-Jun-1992 JohnRo
        Net config helpers should allow empty section.

--*/


// These must be included first:

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>    // Needed by <configp.h> and <winreg.h>
#include <lmcons.h>     // NET_API_STATUS.

// These may be included in any order:

#include <config.h>     // My prototype, LPNET_CONFIG_HANDLE.
#include <configp.h>    // USE_WIN32_CONFIG (if defined).
#include <confname.h>   // KEYWORD_ equates.
#include <debuglib.h>   // IF_DEBUG()
#include <lmapibuf.h>   // NetApiBufferFree().
#include <lmerr.h>      // NERR_, ERROR_, NO_ERROR equates.
#include <netdebug.h>   // NetpKdPrint(()), FORMAT_ equates.
#include <netlib.h>     // NetpMemoryFree(), etc.
#include <prefix.h>     // PREFIX_ equates.
#include <tstr.h>       // STRNCMP().


// Get a boolean (true/false) flag.  Return ERROR_INVALID_DATA if value isn't
// boolean.
NET_API_STATUS
NetpGetConfigBool(
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    IN LPTSTR KeyWanted,
    IN BOOL DefaultValue,
    OUT LPBOOL ValueBuffer
    )

/*++

Routine Description:

    This function gets the keyword value from the configuration file.
    This value is converted from a string to a BOOL.

Arguments:

    SectionPointer - Supplies the pointer to a specific section in the config
        file.

    KeyWanted - Supplies the string of the keyword within the specified
        section to look for.

    DefaultValue - Gives a default value to use if KeyWanted isn't present
        in the section or if KeyWanted exists but no value is in the config
        data.

    ValueBuffer - Returns the numeric value of the keyword.

Return Value:

    NET_API_STATUS - NERR_Success, ERROR_INVALID_DATA (if string wasn't a
    valid true/false value), or other error code.

--*/

{
    NET_API_STATUS ApiStatus;
    BOOL TempBool = DefaultValue;
    LPTSTR ValueString;

    //
    // Error check the caller somewhat.
    //
    if (ValueBuffer == NULL) {
        return (ERROR_INVALID_PARAMETER);
    }

    //
    // Check for GP fault and set default value.
    //
    *ValueBuffer = DefaultValue;

    if (ConfigHandle == NULL) {
        return (ERROR_INVALID_PARAMETER);
    }

    {
        //
        // Win reg stuff allows REG_DWORD and REG_SZ for boolean.
        //
        DWORD dwType;
        LONG Error;
        NET_CONFIG_HANDLE * MyHandle = ConfigHandle;  // conv from opaque type
        DWORD ValueLength;

        // Find out what max value length is.
        ApiStatus = NetpGetConfigMaxSizes (
                MyHandle,
                NULL,  // Don't need max keyword size.
                & ValueLength);  // Get max value length.

        if (ApiStatus != NO_ERROR) {
            NetpAssert( ApiStatus == NO_ERROR );
            return (ApiStatus);
        }

        // Handle empty section.
        if (ValueLength == 0 ) {
            return (NO_ERROR);  // Default already set, so we're done.  Ok!
        }

        // Alloc space for the value.
        ValueString = NetpMemoryAllocate( ValueLength );
        if (ValueString == NULL) {
            return (ERROR_NOT_ENOUGH_MEMORY);
        }

        // Get the actual value.
        Error = RegQueryValueEx (
                MyHandle->WinRegKey,
                KeyWanted,
                NULL,            // reserved
                & dwType,
                (LPVOID) ValueString,    // out: value string (TCHARs).
                & ValueLength
                );
        IF_DEBUG(CONFIG) {
            NetpKdPrint(( PREFIX_NETLIB "NetpGetConfigBool: RegQueryValueEx("
                    FORMAT_LPTSTR ") returned " FORMAT_LONG ".\n",
                    KeyWanted, Error ));
        }
        if (Error == ERROR_FILE_NOT_FOUND) {
            NetpMemoryFree( ValueString );
            return (NO_ERROR);  // Default already set, so we're done.  Ok!
        } else if ( Error != ERROR_SUCCESS ) {
            NetpMemoryFree( ValueString );
            return (Error);
        }

        NetpAssert( ValueString != NULL );
        if (dwType == REG_SZ) {

            goto ParseString;   // Type is good, go parse the string.

        } else if (dwType == REG_DWORD) {

            NetpAssert( ValueLength == sizeof(DWORD) );
            TempBool = * (LPBOOL) (LPVOID) ValueString;

            goto GotValue;

        } else {
            NetpMemoryFree( ValueString );
            IF_DEBUG(CONFIG) {
                NetpKdPrint(( PREFIX_NETLIB
                        "NetpGetConfigBool: read unexpected reg type "
                        FORMAT_DWORD ".\n", dwType ));
            }
            return (ERROR_INVALID_DATA);
        }

    }

ParseString:

    NetpAssert( ValueString != NULL );
    IF_DEBUG(CONFIG) {
        NetpKdPrint((PREFIX_NETLIB "NetpGetConfigBool: string for "
                FORMAT_LPTSTR " is '" FORMAT_LPTSTR "',\n",
                KeyWanted, ValueString));
    }

    //
    // Analyze the value string.
    //
    if (STRICMP(ValueString, KEYWORD_TRUE) == 0) {
        TempBool = TRUE;
        ApiStatus = NO_ERROR;
    } else if (STRICMP(ValueString, KEYWORD_YES) == 0) {
        TempBool = TRUE;
        ApiStatus = NO_ERROR;
    } else if (STRICMP(ValueString, KEYWORD_FALSE) == 0) {
        TempBool = FALSE;
        ApiStatus = NO_ERROR;
    } else if (STRICMP(ValueString, KEYWORD_NO) == 0) {
        TempBool = FALSE;
        ApiStatus = NO_ERROR;
    } else if (STRLEN(ValueString) == 0) {
        //
        // If "key=" line exists (but no value), return default and say
        // NO_ERROR.
        //
        ApiStatus = NO_ERROR;
    } else {

        NetpKdPrint(( PREFIX_NETLIB
                "NetpGetConfigBool: invalid string for keyword "
                FORMAT_LPTSTR " is '" FORMAT_LPTSTR "'...\n",
                KeyWanted, ValueString ));

        ApiStatus = ERROR_INVALID_DATA;
    }

GotValue:

    IF_DEBUG(CONFIG) {
        NetpKdPrint((PREFIX_NETLIB "NetpGetConfigBool: boolean value for "
                FORMAT_LPTSTR " is '" FORMAT_DWORD "',\n",
                KeyWanted, (DWORD) TempBool));
        NetpKdPrint(("  returning ApiStatus " FORMAT_API_STATUS ".\n",
                ApiStatus ));
    }

    (void) NetApiBufferFree( ValueString );

    //
    // Tell caller how things went.
    //
    * ValueBuffer = TempBool;
    return (ApiStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\confgetd.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ConfGetD.c

Abstract:

    This module contains NetpGetConfigDword().

Author:

    John Rogers (JohnRo) 24-Jan-1992

Revision History:

    24-Jan-1992 JohnRo
        Created.
    14-Feb-1992 JohnRo
        Fixed bug handling default.
    08-May-1992 JohnRo
        Allow DWORD to be in win32 registry as REG_SZ or REG_DWORD.
    21-May-1992 JohnRo
        RAID 9826: Match revised winreg error codes.
        Use PREFIX_ equates.
    09-Jun-1992 JohnRo
        RAID 11582: Winreg title index parm is defunct.
        RAID 11784: repl svc doesn't default some config parms anymore.
    13-Jun-1992 JohnRo
        Net config helpers should allow empty section.

--*/


// These must be included first:

#include <nt.h>         // NT definitions
#include <ntrtl.h>      // NT Rtl structures
#include <nturtl.h>     // NT Rtl structures
#include <windows.h>    // Win32 type definitions
#include <lmcons.h>     // NET_API_STATUS.
#include <netdebug.h>   // (Needed by config.h)

// These may be included in any order:

#include <config.h>     // My prototype, LPNET_CONFIG_HANDLE.
#include <configp.h>    // USE_WIN32_CONFIG (if defined).
#include <debuglib.h>   // IF_DEBUG()
#include <lmapibuf.h>   // NetApiBufferFree().
#include <lmerr.h>      // NERR_, ERROR_, NO_ERROR equates.
#include <netlib.h>     // NetpMemoryAllocate(), etc.
#include <prefix.h>     // PREFIX_ equates.
#include <stddef.h>     // ptrdiff_t
#include <tstr.h>       // ATOL(), STRLEN(), STRSPN().


// Get an unsigned numeric value.  Return ERROR_INVALID_DATA if value isn't
// numeric.
NET_API_STATUS
NetpGetConfigDword(
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    IN LPTSTR KeyWanted,
    IN DWORD DefaultValue,
    OUT LPDWORD ValueBuffer
    )

/*++

Routine Description:

    This function gets the keyword value from the configuration file.
    This value is converted from a string to a DWORD (unsigned).

Arguments:

    SectionPointer - Supplies the pointer to a specific section in the config
        file.

    KeyWanted - Supplies the string of the keyword within the specified
        section to look for.

    DefaultValue - Gives a default value to use if KeyWanted isn't present
        in the section or if KeyWanted exists but no value is in the config
        data.

    ValueBuffer - Returns the numeric value of the keyword.

Return Value:

    NET_API_STATUS - NERR_Success, ERROR_INVALID_DATA (if string wasn't a
    valid unsigned number), or other error code.

--*/

{
    NET_API_STATUS ApiStatus;
    DWORD CharCount;                 // Count of TCHARs, not including null.
    DWORD TempDword = DefaultValue;
    LPTSTR ValueString;

    //
    // Error check the caller somewhat.
    //
    if (ValueBuffer == NULL) {
        return (ERROR_INVALID_PARAMETER);
    }

    //
    // Check for GP fault and set default value.
    //
    *ValueBuffer = DefaultValue;

    if (ConfigHandle == NULL) {
        return (ERROR_INVALID_PARAMETER);
    }

    {
        DWORD dwType;
        LONG Error;
        NET_CONFIG_HANDLE * MyHandle = ConfigHandle;  // conv from opaque type
        DWORD ValueLength;

        // Find out what max value length is.
        ApiStatus = NetpGetConfigMaxSizes (
                MyHandle,
                NULL,  // Don't need max keyword size.
                & ValueLength);  // Get max value length.

        if (ApiStatus != NO_ERROR) {
            return (ApiStatus);
        }

        // Handle empty section.
        if (ValueLength == 0 ) {
            return (NO_ERROR);  // Default already set, so we're done.  Ok!
        }

        // Alloc space for the value.
        ValueString = NetpMemoryAllocate( ValueLength );
        if (ValueString == NULL) {
            return (ERROR_NOT_ENOUGH_MEMORY);
        }

        // Get the actual value.
        Error = RegQueryValueEx (
                MyHandle->WinRegKey,
                KeyWanted,
                NULL,      // reserved
                & dwType,
                (LPVOID) ValueString,    // out: value string (TCHARs).
                & ValueLength
                );
        IF_DEBUG(CONFIG) {
            NetpKdPrint(( PREFIX_NETLIB "NetpGetConfigDword: RegQueryValueEx("
                    FORMAT_LPTSTR ") returned " FORMAT_LONG ".\n",
                    KeyWanted, Error ));
        }
        if (Error == ERROR_FILE_NOT_FOUND) {
            NetpMemoryFree( ValueString );
            return (NO_ERROR);  // Default already set, so we're done.  Ok!
        } else if ( Error != ERROR_SUCCESS ) {
            NetpMemoryFree( ValueString );
            return (Error);
        }

        NetpAssert( ValueString != NULL );
        if (dwType == REG_SZ) {

            goto ParseString;   // Type is good, go parse the string.

        } else if (dwType == REG_DWORD) {

            NetpAssert( ValueLength == sizeof(DWORD) );
            TempDword = * (LPDWORD) (LPVOID) ValueString;
            goto GotValue;

        } else {
            NetpMemoryFree( ValueString );
            IF_DEBUG(CONFIG) {
                NetpKdPrint(( PREFIX_NETLIB
                        "NetpGetConfigDword: read unexpected reg type "
                        FORMAT_DWORD ".\n", dwType ));
            }
            return (ERROR_INVALID_DATA);
        }

    }

    NetpAssert( ValueString != NULL );

ParseString:

    //
    // Do some error checking on the value string.
    //

    CharCount = STRLEN( ValueString );

    if ( CharCount == 0 ) {

        //
        // If "key=" line exists (but no value), return default and say
        // NO_ERROR.
        //
        ApiStatus = NO_ERROR;

    } else if ( _wcsnicmp( ValueString, L"0x", 2 ) == 0 ) {
        LPWSTR end;

        TempDword = wcstoul( ValueString, &end, 16 );

        if ( end - ValueString == (ptrdiff_t) CharCount ) {
            ApiStatus = NO_ERROR;
        } else {
            NetpKdPrint(( PREFIX_NETLIB
                    "NetpGetConfigDword: invalid string for keyword "
                    FORMAT_LPTSTR " is '" FORMAT_LPTSTR "'...\n",
                    KeyWanted, ValueString ));

            ApiStatus = ERROR_INVALID_DATA;
        }

    } else if ( STRSPN( ValueString, TEXT("0123456789") ) != CharCount ) {

        NetpKdPrint(( PREFIX_NETLIB
                "NetpGetConfigDword: invalid string for keyword "
                FORMAT_LPTSTR " is '" FORMAT_LPTSTR "'...\n",
                KeyWanted, ValueString ));

        ApiStatus = ERROR_INVALID_DATA;

    } else {

        //
        // Convert the string to a numeric value.
        //
        TempDword = (DWORD) ATOL( ValueString );

        ApiStatus = NO_ERROR;

    }

    IF_DEBUG(CONFIG) {
        NetpKdPrint(( PREFIX_NETLIB "NetpGetConfigDword: string for "
                FORMAT_LPTSTR " is '" FORMAT_LPTSTR "'...\n",
                KeyWanted, ValueString));
    }

GotValue:

    IF_DEBUG(CONFIG) {
        NetpKdPrint(( PREFIX_NETLIB "NetpGetConfigDword: numeric value is "
                FORMAT_DWORD ",\n", TempDword ));
        NetpKdPrint(("  returning ApiStatus " FORMAT_API_STATUS ".\n",
                ApiStatus ));
    }

    (void) NetApiBufferFree( ValueString );

    //
    // Tell caller how things went.
    //
    * ValueBuffer = TempDword;
    return (ApiStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\confmax.c ===
/*++

Copyright (c) 1992-1993  Microsoft Corporation

Module Name:

    ConfMax.c

Abstract:

    This module contains NetpGetConfigMaxSizes() and
    NetpGetWinRegConfigMaxSizes().

Author:

    John Rogers (JohnRo) 13-Feb-1992

Revision History:

    13-Feb-1992 JohnRo
        Created.
    06-Mar-1992 JohnRo
        Avoid compiler warnings in RTL and fake versions.
    20-Mar-1992 JohnRo
        Update to DaveGi's proposed WinReg API changes.
    07-May-1992 JohnRo
        Enable win32 registry for NET tree.
    08-May-1992 JohnRo
        Use <prefix.h> equates.
    09-May-1992 JohnRo
        Avoid assert when number of keys is zero.
    05-Jun-1992 JohnRo
        Winreg title index parm is defunct.
        Handle RegQueryInfoKey bad return codes better.
    13-Jun-1992 JohnRo
        Net config helpers should allow empty section.
    08-Dec-1992 JohnRo
        RAID 4304: ReqQueryInfoKeyW returns sizes twice as big as actual.
    19-Apr-1993 JohnRo
        RAID 5483: server manager: wrong path given in repl dialog.

--*/


// These must be included first:

#include <nt.h>         // NT definitions
#include <ntrtl.h>      // NT Rtl structures
#include <nturtl.h>     // NT Rtl structures
#include <windows.h>    // Needed by <configp.h> and <winreg.h>
#include <lmcons.h>     // LAN Manager common definitions

// These may be included in any order:

#include <configp.h>    // NET_CONFIG_HANDLE
#include <debuglib.h>   // IF_DEBUG()
#include <netdebug.h>   // NetpKdPrint(()), etc.
#include <netlib.h>     // NetpSetOptionalArg().
#include <prefix.h>     // PREFIX_ equates.
#include <winerror.h>   // NO_ERROR.


NET_API_STATUS
NetpGetWinRegConfigMaxSizes (
    IN  HKEY    WinRegHandle,
    OUT LPDWORD MaxKeywordSize OPTIONAL,
    OUT LPDWORD MaxValueSize OPTIONAL
    )
{
    LONG Error;
    TCHAR ClassName[ MAX_CLASS_NAME_LENGTH ];
    DWORD ClassNameLength;
    DWORD NumberOfSubKeys;
    DWORD MaxSubKeyLength;
    DWORD MaxClassLength;
    DWORD NumberOfValues;
    DWORD MaxValueNameLength;
    DWORD MaxValueDataLength;
    DWORD SecurityDescriptorSize;
    FILETIME LastWriteTime;

    ClassNameLength = MAX_CLASS_NAME_LENGTH;

    Error = RegQueryInfoKey(
            WinRegHandle,
            ClassName,
            &ClassNameLength,
            NULL,         // reserved
            &NumberOfSubKeys,
            &MaxSubKeyLength,
            &MaxClassLength,
            &NumberOfValues,
            &MaxValueNameLength,
            &MaxValueDataLength,
#ifndef REG_FILETIME
            &SecurityDescriptorSize,
#endif
            &LastWriteTime
            );
    IF_DEBUG(CONFIG) {
        NetpKdPrint(( PREFIX_NETLIB
                "NetpGetWinRegConfigMaxSizes: RegQueryInfoKey returned "
                FORMAT_LONG ", key size " FORMAT_DWORD ", data size "
                FORMAT_DWORD ".\n",
                Error, MaxValueNameLength, MaxValueDataLength ));
    }
    if (Error != ERROR_SUCCESS) {
        NetpKdPrint(( PREFIX_NETLIB
                "NetpGetWinRegConfigMaxSizes: bad status " FORMAT_LONG
                " from RegQueryInfoKey, handle was " FORMAT_LPVOID
                ".\n", Error, WinRegHandle ));
        return ( (NET_API_STATUS) Error );
    }

    if (NumberOfValues > 0) {
        NetpAssert( MaxValueDataLength > 0 );
        NetpAssert( MaxValueNameLength > 0 );
    } else {
        // Handle empty section correctly too.
        NetpAssert( MaxValueDataLength == 0 );
        NetpAssert( MaxValueNameLength == 0 );
    }

    //
    // MaxValueNameLength is a count of TCHARs.
    // MaxValueDataLength is a count of bytes already.
    //
    MaxValueNameLength = (MaxValueNameLength + 1) * sizeof(TCHAR);

    NetpSetOptionalArg( MaxKeywordSize, MaxValueNameLength );
    NetpSetOptionalArg( MaxValueSize,   MaxValueDataLength );

    return (NO_ERROR);

} // NetpGetWinRegConfigMaxSizes



NET_API_STATUS
NetpGetConfigMaxSizes (
    IN NET_CONFIG_HANDLE * ConfigHandle,
    OUT LPDWORD MaxKeywordSize OPTIONAL,
    OUT LPDWORD MaxValueSize OPTIONAL
    )

/*++

Routine Description:

    Checks parameters and calls NetpGetWinRegConfigMaxSizes

Arguments:



Return Value:

    NET_API_STATUS - NO_ERROR or reason for failure.

--*/
{
    NET_CONFIG_HANDLE * lpnetHandle = ConfigHandle;  // conv from opaque type
    NET_API_STATUS ApiStatus;

    //
    // Check for other invalid pointers, and make error handling code simpler.
    //
    if (MaxKeywordSize != NULL) {
        *MaxKeywordSize = 0;
    }
    if (MaxValueSize != NULL) {
        *MaxValueSize = 0;
    }

    //
    // Check for simple caller's errors.
    //
    if (ConfigHandle == NULL) {
        return (ERROR_INVALID_PARAMETER);
    }

    ApiStatus = NetpGetWinRegConfigMaxSizes(
            lpnetHandle->WinRegKey,
            MaxKeywordSize,
            MaxValueSize );


    return (ApiStatus);

} // NetpGetConfigMaxSizes
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\confnum.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ConfNum.c

Abstract:

    Return number of keywords for a given section of the config data.

Author:

    John Rogers (JohnRo) 30-Jan-1992

Environment:

    User Mode - Win32

Revision History:

    30-Jan-1992 JohnRo
        Created.
    13-Feb-1992 JohnRo
        Added support for using the real Win32 registry.
    06-Mar-1992 JohnRo
        Fixed NT RTL version.
    12-Mar-1992 JohnRo
        Fixed bug in Win32 version (was using wrong variable).
    20-Mar-1992 JohnRo
        Update to DaveGi's proposed WinReg API changes.
    05-Jun-1992 JohnRo
        Winreg title index parm is defunct.
        Use PREFIX_ equates.

--*/


// These must be included first:

#include <nt.h>         // NT definitions (temporary)
#include <ntrtl.h>      // NT Rtl structure definitions (temporary)
#include <nturtl.h>     // NT Rtl structures (temporary)

#include <windows.h>    // Needed by <configp.h> and <winreg.h>
#include <lmcons.h>     // NET_API_STATUS, etc.

// These may be included in any order:

#include <config.h>     // LPNET_CONFIG_HANDLE, Netp config routines.
#include <configp.h>    // private config stuff.
#include <debuglib.h>   // IF_DEBUG().
#include <netdebug.h>   // NetpKdPrint(()), etc.
#include <prefix.h>     // PREFIX_ equates.
#include <strarray.h>   // NetpTStrArrayEntryCount().
#include <winerror.h>   // ERROR_ equates, NO_ERROR.
#include <winreg.h>     // RegQueryKey(), etc.



NET_API_STATUS
NetpNumberOfConfigKeywords (
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    OUT LPDWORD CountPtr
    )

{
    NET_API_STATUS ApiStatus;
    DWORD Count;
    NET_CONFIG_HANDLE * lpnetHandle = ConfigHandle;  // Conv from opaque type.

    if (CountPtr == NULL) {
        return (ERROR_INVALID_PARAMETER);
    }
    *CountPtr = 0;  // Don't confuse caller on error.
    if (lpnetHandle == NULL) {
        return (ERROR_INVALID_PARAMETER);
    }

    {
        LONG Error;
        TCHAR ClassName[ MAX_CLASS_NAME_LENGTH ];
        DWORD ClassNameLength;
        DWORD NumberOfSubKeys;
        DWORD MaxSubKeyLength;
        DWORD MaxClassLength;
        DWORD NumberOfValues;
        DWORD MaxValueNameLength;
        DWORD MaxValueDataLength;
        DWORD SecurityDescriptorSize;
        FILETIME LastWriteTime;

        ClassNameLength = MAX_CLASS_NAME_LENGTH;

        Error = RegQueryInfoKey(
                lpnetHandle->WinRegKey,
                ClassName,
                &ClassNameLength,
                NULL,                // reserved
                &NumberOfSubKeys,
                &MaxSubKeyLength,
                &MaxClassLength,
                &NumberOfValues,
                &MaxValueNameLength,
                &MaxValueDataLength,
#ifndef REG_FILETIME
                &SecurityDescriptorSize,
#endif
                &LastWriteTime
                );
        IF_DEBUG(CONFIG) {
            NetpKdPrint(( PREFIX_NETLIB
                    "NetpNumberOfConfigKeywords: RegQueryInfoKey ret "
                    FORMAT_LONG "; " FORMAT_DWORD " values and " FORMAT_DWORD
                    " subkeys.\n", Error, NumberOfValues, NumberOfSubKeys ));
        }

        if (Error != ERROR_SUCCESS) {
            NetpAssert( Error == ERROR_SUCCESS );
            return (Error);
        }

        NetpAssert( NumberOfSubKeys == 0 );
        Count = NumberOfValues;

        ApiStatus = NO_ERROR;
    }

    *CountPtr = Count;

    IF_DEBUG(CONFIG) {
        NetpKdPrint(( PREFIX_NETLIB
                "NetpNumberOfConfigKeywords: returning " FORMAT_DWORD
                " for number of keywords.\n", Count ));
    }

    return (ApiStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\confopen.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    ConfOpen.c

Abstract:

    This module contains:

        NetpOpenConfigData
        NetpOpenConfigDataEx

Author:

    John Rogers (JohnRo) 02-Dec-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    02-Dec-1991 JohnRo
        Created this routine, to prepare for revised config handlers.
        (Actually, I swiped some of this code from RitaW.)
    06-Jan-1992 JohnRo
        Added support for FAKE_PER_PROCESS_RW_CONFIG handling.
    09-Jan-1992 JohnRo
        Try workaround for lib/linker problem with NetpIsRemote().
    22-Mar-1992 JohnRo
        Added support for using the real Win32 registry.
        Added debug code to print the fake array.
        Fixed a UNICODE bug which PC-LINT caught.
        Fixed double _close of RTL config file.
        Fixed memory _access error in setting fake end of array.
        Use DBGSTATIC where applicable.
    05-May-1992 JohnRo
        Reflect movement of keys to under System\CurrentControlSet\Services.
    08-May-1992 JohnRo
        Use <prefix.h> equates.
    21-May-1992 JohnRo
        RAID 9826: Match revised winreg error codes.
    08-Jul-1992 JohnRo
        RAID 10503: srv mgr: repl dialog doesn't come up.
        Added more debug output to track down bad error code during logoff.
    23-Jul-1992 JohnRo
        RAID 2274: repl svc should impersonate caller.
    22-Sep-1992 JohnRo
        Avoid GP fault printing first part of winreg handle.
    28-Oct-1992 JohnRo
        RAID 10136: NetConfig APIs don't work to remote NT server.
    12-Apr-1993 JohnRo
        RAID 5483: server manager: wrong path given in repl dialog.

--*/


// These must be included first:

#include <nt.h>         // NT definitions
#include <ntrtl.h>      // NT Rtl structures
#include <nturtl.h>     // NT config Rtl routines

#include <windows.h>    // Needed by <configp.h> and <winreg.h>
#include <lmcons.h>     // LAN Manager common definitions
#include <netdebug.h>   // (Needed by config.h)

// These may be included in any order:

#include <config.h>     // My prototype, LPNET_CONFIG_HANDLE.
#include <configp.h>    // NET_CONFIG_HANDLE, etc.
#include <debuglib.h>   // IF_DEBUG().
#include <icanon.h>     // NetpIsRemote(), etc.
#include <lmerr.h>      // LAN Manager network error definitions
#include <netlib.h>     // NetpMemoryAllocate(), etc.
#include <netlibnt.h>   // NetpNtStatusToApiStatus
#include <prefix.h>     // PREFIX_ equates.
#include <tstring.h>    // NetpAlloc{type}From{type}, STRICMP(), etc.


#define DEFAULT_AREA    TEXT("Parameters")

#define DEFAULT_ROOT_KEY        HKEY_LOCAL_MACHINE


DBGSTATIC NET_API_STATUS
NetpSetupConfigSection (
    IN NET_CONFIG_HANDLE * ConfigHandle,
    IN LPTSTR SectionName
    );



NET_API_STATUS
NetpOpenConfigData(
    OUT LPNET_CONFIG_HANDLE *ConfigHandle,
    IN LPTSTR UncServerName OPTIONAL,
    IN LPTSTR SectionName,
    IN BOOL ReadOnly
    )

/*++

Routine Description:

    This function opens the system configuration file.

Arguments:

    ConfigHandle - Points to a pointer which will be set to point to a
        net config handle for this section name.  ConfigHandle will be set to
        NULL if any  error occurs.

    SectionName - Points to the new (NT) section name to be opened.

    ReadOnly - Indicates whether all access through this net config handle is
        to be read only.

Return Value:

    NET_API_STATUS - NO_ERROR or reason for failure.

--*/

{
    return ( NetpOpenConfigDataEx(
            ConfigHandle,
            UncServerName,
            SectionName,              // Must be a SECT_NT_ name.
            DEFAULT_AREA,
            ReadOnly) );

} // NetpOpenConfigData


// NetpOpenConfigDataEx opens any area of a given service.
NET_API_STATUS
NetpOpenConfigDataEx(
    OUT LPNET_CONFIG_HANDLE *ConfigHandle,
    IN LPTSTR UncServerName OPTIONAL,
    IN LPTSTR SectionName,              // Must be a SECT_NT_ name.
    IN LPTSTR AreaUnderSection OPTIONAL,
    IN BOOL ReadOnly
    )
{

    NET_API_STATUS ApiStatus;
    DWORD               LocalOrRemote;    // Will be set to ISLOCAL or ISREMOTE.
    NET_CONFIG_HANDLE * MyHandle = NULL;
    LONG Error;
    HKEY RootKey = DEFAULT_ROOT_KEY;

    NetpAssert( ConfigHandle != NULL );
    *ConfigHandle = NULL;  // Assume error until proven innocent.

    if ( (SectionName == NULL) || (*SectionName == TCHAR_EOS) ) {
        return (ERROR_INVALID_PARAMETER);
    }
    NetpAssert( (ReadOnly==TRUE) || (ReadOnly==FALSE) );

    if ( (UncServerName != NULL ) && ((*UncServerName) != TCHAR_EOS) ) {

        if( STRLEN(UncServerName) > MAX_PATH ) {
            return (ERROR_INVALID_PARAMETER);
        }

        //
        // Name was given.  Canonicalize it and check if it's remote.
        //
        ApiStatus = NetpIsRemote(
            UncServerName,      // input: uncanon name
            & LocalOrRemote,    // output: local or remote flag
            NULL,               // dont need output (canon name)
            0);                 // flags: normal
        IF_DEBUG(CONFIG) {
            NetpKdPrint(( PREFIX_NETLIB "NetpOpenConfigDataEx: canon status is "
                    FORMAT_API_STATUS ", Lcl/rmt=" FORMAT_HEX_DWORD ".\n",
                    ApiStatus, LocalOrRemote));
        }
        if (ApiStatus != NO_ERROR) {
            return (ApiStatus);
        }

        if (LocalOrRemote == ISREMOTE) {

            //
            // Explicit remote name given.
            //

            Error = RegConnectRegistry(
                    UncServerName,
                    DEFAULT_ROOT_KEY,
                    & RootKey );        // result key

            if (Error != ERROR_SUCCESS) {
                NetpKdPrint((  PREFIX_NETLIB
                        "NetpOpenConfigDataEx: RegConnectRegistry(machine '"
                        FORMAT_LPTSTR "') ret error " FORMAT_LONG ".\n",
                        UncServerName, Error ));
                return ((NET_API_STATUS) Error);
            }
            NetpAssert( RootKey != DEFAULT_ROOT_KEY );

        }
    }
    else {

        LocalOrRemote = ISLOCAL;

    }

    MyHandle = NetpMemoryAllocate( sizeof(NET_CONFIG_HANDLE) );
    if (MyHandle == NULL) {

        if (RootKey != DEFAULT_ROOT_KEY) {
            (VOID) RegCloseKey( RootKey );
        }

        return (ERROR_NOT_ENOUGH_MEMORY);
    }

    {
        LPTSTR AreaToUse = DEFAULT_AREA;
        DWORD DesiredAccess;
        DWORD SubKeySize;
        LPTSTR SubKeyString;
        HKEY SectionKey;

#define LM_SUBKEY_UNDER_LOCAL_MACHINE  \
            TEXT("System\\CurrentControlSet\\Services\\")

        if (AreaUnderSection != NULL) {
            if ((*AreaUnderSection) != TCHAR_EOS) {
                AreaToUse = AreaUnderSection;
            }
        }

        SubKeySize = ( STRLEN(LM_SUBKEY_UNDER_LOCAL_MACHINE)
                       + STRLEN(SectionName)
                       + 1      // backslash
                       + STRLEN(AreaToUse)
                       + 1 )    // trailing null
                     * sizeof(TCHAR);
        SubKeyString = NetpMemoryAllocate( SubKeySize );
        if (SubKeyString == NULL) {
            if (MyHandle != NULL) {
                NetpMemoryFree( MyHandle );
                MyHandle = NULL;
            }
            return (ERROR_NOT_ENOUGH_MEMORY);
        }

        (void) STRCPY( SubKeyString, LM_SUBKEY_UNDER_LOCAL_MACHINE );
        (void) STRCAT( SubKeyString, SectionName );
        (void) STRCAT( SubKeyString, TEXT("\\") );
        (void) STRCAT( SubKeyString, AreaToUse );

        if ( ReadOnly ) {
            DesiredAccess = KEY_READ;
        } else {
            DesiredAccess = KEY_READ | KEY_WRITE;
            // DesiredAccess = KEY_ALL_ACCESS; // Everything but SYNCHRONIZE.
        }

        Error = RegOpenKeyEx (
                RootKey,
                SubKeyString,
                REG_OPTION_NON_VOLATILE,
                DesiredAccess,
                & SectionKey );
        IF_DEBUG(CONFIG) {
            NetpKdPrint((  PREFIX_NETLIB
                    "NetpOpenConfigDataEx: RegOpenKeyEx(subkey '"
                    FORMAT_LPTSTR "') ret " FORMAT_LONG ", win reg handle at "
                    FORMAT_LPVOID " is " FORMAT_LPVOID ".\n",
                    SubKeyString, Error, (LPVOID) &(MyHandle->WinRegKey),
                    SectionKey ));
        }
        if (Error == ERROR_FILE_NOT_FOUND) {
            ApiStatus = NERR_CfgCompNotFound;
            // Code below will free MyHandle, etc., based on ApiStatus.
        } else if (Error != ERROR_SUCCESS) {
            ApiStatus = (NET_API_STATUS) Error;
            // Code below will free MyHandle, etc., based on ApiStatus.
        } else {
            ApiStatus = NO_ERROR;
        }

        NetpMemoryFree( SubKeyString );

        if (RootKey != DEFAULT_ROOT_KEY) {
            (VOID) RegCloseKey( RootKey );
        }

        MyHandle->WinRegKey = SectionKey;
    }


    if (ApiStatus != NO_ERROR) {
        NetpMemoryFree( MyHandle );
        MyHandle = NULL;
    }

    if (MyHandle != NULL) {
        if (LocalOrRemote == ISREMOTE) {

            (VOID) STRCPY(
                    MyHandle->UncServerName,    // dest
                    UncServerName );            // src

        } else {

            MyHandle->UncServerName[0] = TCHAR_EOS;
        }
    }

    *ConfigHandle = MyHandle;   // Points to private handle, or is NULL on err.
    return (ApiStatus);

} // NetpOpenConfigDataEx
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\confopn2.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    ConfOpen.c

Abstract:

    This module contains:

        NetpOpenConfigDataWithPath
        NetpOpenConfigDataWithPathEx

Author:

    John Rogers (JohnRo) 02-Dec-1991
    Mike Swift (MikeSw) 30-Aug-1996

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    02-Dec-1991 JohnRo
        Created this routine, to prepare for revised config handlers.
        (Actually, I swiped some of this code from RitaW.)
    06-Jan-1992 JohnRo
        Added support for FAKE_PER_PROCESS_RW_CONFIG handling.
    09-Jan-1992 JohnRo
        Try workaround for lib/linker problem with NetpIsRemote().
    22-Mar-1992 JohnRo
        Added support for using the real Win32 registry.
        Added debug code to print the fake array.
        Fixed a UNICODE bug which PC-LINT caught.
        Fixed double _close of RTL config file.
        Fixed memory _access error in setting fake end of array.
        Use DBGSTATIC where applicable.
    05-May-1992 JohnRo
        Reflect movement of keys to under System\CurrentControlSet\Services.
    08-May-1992 JohnRo
        Use <prefix.h> equates.
    21-May-1992 JohnRo
        RAID 9826: Match revised winreg error codes.
    08-Jul-1992 JohnRo
        RAID 10503: srv mgr: repl dialog doesn't come up.
        Added more debug output to track down bad error code during logoff.
    23-Jul-1992 JohnRo
        RAID 2274: repl svc should impersonate caller.
    22-Sep-1992 JohnRo
        Avoid GP fault printing first part of winreg handle.
    28-Oct-1992 JohnRo
        RAID 10136: NetConfig APIs don't work to remote NT server.
    12-Apr-1993 JohnRo
        RAID 5483: server manager: wrong path given in repl dialog.
    30-Aug-1996 MikeSw
        Copied from NetpOpenConfigData to allow configuring non-services

--*/


// These must be included first:

#include <nt.h>         // NT definitions
#include <ntrtl.h>      // NT Rtl structures
#include <nturtl.h>     // NT config Rtl routines

#include <windows.h>    // Needed by <configp.h> and <winreg.h>
#include <lmcons.h>     // LAN Manager common definitions
#include <netdebug.h>   // (Needed by config.h)

// These may be included in any order:

#include <config.h>     // My prototype, LPNET_CONFIG_HANDLE.
#include <configp.h>    // NET_CONFIG_HANDLE, etc.
#include <debuglib.h>   // IF_DEBUG().
#include <icanon.h>     // NetpIsRemote(), etc.
#include <lmerr.h>      // LAN Manager network error definitions
#include <netlib.h>     // NetpMemoryAllocate(), etc.
#include <netlibnt.h>   // NetpNtStatusToApiStatus
#include <prefix.h>     // PREFIX_ equates.
#include <tstring.h>    // NetpAlloc{type}From{type}, STRICMP(), etc.


#define DEFAULT_AREA    TEXT("Parameters")

#define DEFAULT_ROOT_KEY        HKEY_LOCAL_MACHINE



DBGSTATIC NET_API_STATUS
NetpSetupConfigSection (
    IN NET_CONFIG_HANDLE * ConfigHandle,
    IN LPTSTR SectionName
    );



NET_API_STATUS
NetpOpenConfigDataWithPath(
    OUT LPNET_CONFIG_HANDLE *ConfigHandle,
    IN LPTSTR UncServerName OPTIONAL,
    IN LPTSTR SectionName,
    IN BOOL ReadOnly
    )

/*++

Routine Description:

    This function opens the system configuration file.

Arguments:

    ConfigHandle - Points to a pointer which will be set to point to a
        net config handle for this section name.  ConfigHandle will be set to
        NULL if any  error occurs.

    SectionName - Points to the new (NT) section name to be opened.

    ReadOnly - Indicates whether all access through this net config handle is
        to be read only.

Return Value:

    NET_API_STATUS - NO_ERROR or reason for failure.

--*/

{
    return ( NetpOpenConfigDataWithPathEx(
            ConfigHandle,
            UncServerName,
            SectionName,              // Must be a SECT_NT_ name.
            DEFAULT_AREA,
            ReadOnly) );

} // NetpOpenConfigData


// NetpOpenConfigDataEx opens any area of a given service.
NET_API_STATUS
NetpOpenConfigDataWithPathEx(
    OUT LPNET_CONFIG_HANDLE *ConfigHandle,
    IN LPTSTR UncServerName OPTIONAL,
    IN LPTSTR SectionName,              // Must be a SECT_NT_ name.
    IN LPTSTR AreaUnderSection OPTIONAL,
    IN BOOL ReadOnly
    )
{

    NET_API_STATUS ApiStatus;
    DWORD               LocalOrRemote;    // Will be set to ISLOCAL or ISREMOTE.
    NET_CONFIG_HANDLE * MyHandle = NULL;
    LONG Error;
    HKEY RootKey = DEFAULT_ROOT_KEY;

    NetpAssert( ConfigHandle != NULL );
    *ConfigHandle = NULL;  // Assume error until proven innocent.

    if ( (SectionName == NULL) || (*SectionName == TCHAR_EOS) ) {
        return (ERROR_INVALID_PARAMETER);
    }
    NetpAssert( (ReadOnly==TRUE) || (ReadOnly==FALSE) );

    if ( (UncServerName != NULL ) && ((*UncServerName) != TCHAR_EOS) ) {

        if( STRLEN(UncServerName) > MAX_PATH ) {
            return (ERROR_INVALID_PARAMETER);
        }

        //
        // Name was given.  Canonicalize it and check if it's remote.
        //
        ApiStatus = NetpIsRemote(
            UncServerName,      // input: uncanon name
            & LocalOrRemote,    // output: local or remote flag
            NULL,               // dont need output (canon name)
            0);                 // flags: normal
        IF_DEBUG(CONFIG) {
            NetpKdPrint(( PREFIX_NETLIB "NetpOpenConfigDataEx: canon status is "
                    FORMAT_API_STATUS ", Lcl/rmt=" FORMAT_HEX_DWORD ".\n",
                    ApiStatus, LocalOrRemote));
        }
        if (ApiStatus != NO_ERROR) {
            return (ApiStatus);
        }

        if (LocalOrRemote == ISREMOTE) {

            //
            // Explicit remote name given.
            //

            Error = RegConnectRegistry(
                    UncServerName,
                    DEFAULT_ROOT_KEY,
                    & RootKey );        // result key

            if (Error != ERROR_SUCCESS) {
                NetpKdPrint((  PREFIX_NETLIB
                        "NetpOpenConfigDataEx: RegConnectRegistry(machine '"
                        FORMAT_LPTSTR "') ret error " FORMAT_LONG ".\n",
                        UncServerName, Error ));
                return ((NET_API_STATUS) Error);
            }
            NetpAssert( RootKey != DEFAULT_ROOT_KEY );

        }
    }
    else {

        LocalOrRemote = ISLOCAL;

    }

    MyHandle = NetpMemoryAllocate( sizeof(NET_CONFIG_HANDLE) );
    if (MyHandle == NULL) {

        if (RootKey != DEFAULT_ROOT_KEY) {
            (VOID) RegCloseKey( RootKey );
        }

        return (ERROR_NOT_ENOUGH_MEMORY);
    }

    {
        LPTSTR AreaToUse = DEFAULT_AREA;
        DWORD DesiredAccess;
        DWORD SubKeySize;
        LPTSTR SubKeyString;
        HKEY SectionKey;

#define LM_SUBKEY_UNDER_LOCAL_MACHINE  \
            TEXT("System\\CurrentControlSet\\Services\\")

        if (AreaUnderSection != NULL) {
            if ((*AreaUnderSection) != TCHAR_EOS) {
                AreaToUse = AreaUnderSection;
            }
        }

        SubKeySize = (  STRLEN(SectionName)
                       + 1      // backslash
                       + STRLEN(AreaToUse)
                       + 1 )    // trailing null
                     * sizeof(TCHAR);
        SubKeyString = NetpMemoryAllocate( SubKeySize );
        if (SubKeyString == NULL) {
            if (MyHandle != NULL) {
                NetpMemoryFree( MyHandle );
                MyHandle = NULL;
            }
            return (ERROR_NOT_ENOUGH_MEMORY);
        }

        (void) STRCPY( SubKeyString, SectionName );
        (void) STRCAT( SubKeyString, TEXT("\\") );
        (void) STRCAT( SubKeyString, AreaToUse );

        if ( ReadOnly ) {
            DesiredAccess = KEY_READ;
        } else {
            DesiredAccess = KEY_READ | KEY_WRITE;
            // DesiredAccess = KEY_ALL_ACCESS; // Everything but SYNCHRONIZE.
        }

        Error = RegOpenKeyEx (
                RootKey,
                SubKeyString,
                REG_OPTION_NON_VOLATILE,
                DesiredAccess,
                & SectionKey );
        IF_DEBUG(CONFIG) {
            NetpKdPrint((  PREFIX_NETLIB
                    "NetpOpenConfigDataEx: RegOpenKeyEx(subkey '"
                    FORMAT_LPTSTR "') ret " FORMAT_LONG ", win reg handle at "
                    FORMAT_LPVOID " is " FORMAT_LPVOID ".\n",
                    SubKeyString, Error, (LPVOID) &(MyHandle->WinRegKey),
                    SectionKey ));
        }
        if (Error == ERROR_FILE_NOT_FOUND) {
            ApiStatus = NERR_CfgCompNotFound;
            // Code below will free MyHandle, etc., based on ApiStatus.
        } else if (Error != ERROR_SUCCESS) {
            ApiStatus = (NET_API_STATUS) Error;
            // Code below will free MyHandle, etc., based on ApiStatus.
        } else {
            ApiStatus = NO_ERROR;
        }

        NetpMemoryFree( SubKeyString );

        if (RootKey != DEFAULT_ROOT_KEY) {
            (VOID) RegCloseKey( RootKey );
        }

        MyHandle->WinRegKey = SectionKey;
    }

    if (ApiStatus != NO_ERROR) {
        NetpMemoryFree( MyHandle );
        MyHandle = NULL;
    }

    if (MyHandle != NULL) {
        if (LocalOrRemote == ISREMOTE) {

            (VOID) STRCPY(
                    MyHandle->UncServerName,    // dest
                    UncServerName );            // src

        } else {

            MyHandle->UncServerName[0] = TCHAR_EOS;
        }
    }

    *ConfigHandle = MyHandle;   // Points to private handle, or is NULL on err.
    return (ApiStatus);

} // NetpOpenConfigDataEx
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\data.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    Data.c

Abstract:

    Global data for NetLib routines.  (Debug only, so no security problems.)

Author:

    John Rogers (JohnRo) 03-Apr-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    03-Apr-1991 JohnRo
        Created.
--*/


// These must be included first:
#include <windef.h>             // DWORD, etc.

// These may be included in any order:
#include <debuglib.h>           // extern for NetlibpTrace.

DWORD NetlibpTrace = 0;

// That's all, folks!
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\confset.c ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    ConfSet.c

Abstract:

    This header file defines the function prototypes of the temporary
    helper routines to get configuration information from the NT
    configuration files.

Author:

    John Rogers (JohnRo) 26-Nov-1991

Environment:

    Only runs under NT.

Revision History:

    26-Nov-1991 JohnRo
        Created.
    13-Feb-1992 JohnRo
        Added support for using the real Win32 registry.
        Added support for FAKE_PER_PROCESS_RW_CONFIG handling.
    12-Mar-1992 JohnRo
        Changed to only store UNICODE strings in registry.
    31-Mar-1992 JohnRo
        Flush the registry after each create/_write.
    06-May-1992 JohnRo
        REG_SZ now implies a UNICODE string, so we can't use REG_USZ anymore.

--*/

#include <nt.h>                 // NT definitions
#include <ntrtl.h>              // NT Rtl structures
#include <nturtl.h>             // NT Rtl structures
#include <windows.h>            // Needed by <configp.h> and <winreg.h>
#include <lmcons.h>             // NET_API_STATUS.
#include <netdebug.h>           // (Needed by config.h)

#include <config.h>             // My prototype, LPNET_CONFIG_HANDLE.
#include <configp.h>            // NET_CONFIG_HANDLE.
#include <debuglib.h>           // IF_DEBUG().
#include <lmapibuf.h>           // NetApiBufferFree().
#include <netlib.h>             // NetpMemoryAllocate(), etc.
#include <tstring.h>            // STRSIZE(), TCHAR_EOS, WCSSIZE(), etc.
#include <stdlib.h>             // wcslen().
#include <winerror.h>           // ERROR_NOT_SUPPORTED, NO_ERROR, etc.


NET_API_STATUS
NetpSetConfigValue(
    IN LPNET_CONFIG_HANDLE ConfigHandle,
    IN LPTSTR KeyWanted,
    IN LPTSTR Value
    )
{
    NET_CONFIG_HANDLE * lpnetHandle = ConfigHandle;  // conv from opaque type

    NetpAssert( lpnetHandle != NULL );
    NetpAssert( KeyWanted != NULL );
    NetpAssert( *KeyWanted != TCHAR_EOS );
    NetpAssert( Value != NULL );
    NetpAssert( *Value != TCHAR_EOS );

    {
        LONG Error;

        //
        // Set the value in the registry.  (In memory, at least.)
        //
        Error = RegSetValueEx(
                lpnetHandle->WinRegKey,   // open handle (to section)
                KeyWanted,                // subkey
                0,
                REG_SZ,                   // type (zero-terminated TCHARs)
                (LPVOID) Value,           // data
                STRSIZE(Value) );         // byte count for data (null char too)
        IF_DEBUG(CONFIG) {
            NetpKdPrint(( "NetpSetConfigValue: RegSetValueEx(" FORMAT_LPTSTR
                    ") to TCHAR '" FORMAT_LPTSTR "' returned " FORMAT_LONG
                    ".\n", KeyWanted, Value, Error ));
        }

        if ( Error != ERROR_SUCCESS ) {
            NetpAssert( Error == ERROR_SUCCESS );
            return (Error);
        }

        //
        // Flush the registry to force stuff to disk immediately.
        //
        Error = RegFlushKey( lpnetHandle->WinRegKey );
        NetpAssert( Error == ERROR_SUCCESS );

        return (NO_ERROR);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\copystr.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    CopyStr.c

Abstract:

    This module contains the main two functions for copying and converting
    strings between the default codepage for the LAN and wide characters
    (i.e. UNICODE).

Author:

    John Rogers (JohnRo) 24-Sep-1991

Environment:

    Only runs under NT, although the interface is portable (Win/32).
    Requires ANSI C extensions: slash-slash comments, long external names.

Note:

    These functions assume that the machine's default codepage is the same
    as the LAN's default codepage.

Revision History:

    24-Sep-1991 JohnRo
        Created.
    04-Oct-1991 JohnRo
        Fixed buffer length bug in CopyStrToWStr().
    24-Oct-1991 JohnRo
        Corrected Environment comments above.
    21-Nov-1991 JohnRo
        Added some alignment assertions.
    26-Nov-1991 JohnRo
        Added NetpNCopy routines (used by new net config helpers).
    03-Jan-1992 JohnRo
        Added NetpCopyStringToTStr() for FAKE_PER_PROCESS_RW_CONFIG handling.
    29-Apr-1992 JohnRo
        Fixed NetpNCopyStrToWStr() under UNICODE.  Ditto NetpNCopyWStrToStr.
        Made a few changes suggested by PC-LINT.
    21-May-1992 JohnRo
        Removed bogus assert in NetpNCopyStrToWStr().

--*/


// These must be included first:

#include <nt.h>         // Must be first.  IN, VOID, etc.
#include <windef.h>     // LPWSTR.
#include <lmcons.h>     // (Needed by NetLibNt.h)

// These can be in any order:

#include <align.h>      // ROUND_UP_POINTER(), ALIGN_WCHAR.
#include <lmapibuf.h>   // NetApiBufferFree().
#include <netdebug.h>   // NetpAssert(), etc.
#include <ntrtl.h>      // RtlUnicodeStringToOemString(), etc.
#include <string.h>     // strlen().
#include <tstring.h>    // Most of my prototypes.
#include <stdlib.h>      // wcslen(), wcsncpy().
#include <winerror.h>   // NO_ERROR, ERROR_NOT_ENOUGH_MEMORY.


VOID
NetpCopyWStrToStr(
    OUT LPSTR  Dest,
    IN  LPWSTR Src
    )

/*++

Routine Description:

    NetpCopyWStrToStr copies characters from a source string
    to a destination, converting as it copies them.

Arguments:

    Dest - is an LPSTR indicating where the converted characters are to go.
        This string will be in the default codepage for the LAN.

    Src - is in LPWSTR indicating the source string.

Return Value:

    None.

--*/

{
    OEM_STRING DestAnsi;
    NTSTATUS NtStatus;
    UNICODE_STRING SrcUnicode;

    NetpAssert( Dest != NULL );
    NetpAssert( Src != NULL );
    NetpAssert( ((LPVOID)Dest) != ((LPVOID)Src) );
    NetpAssert( ROUND_UP_POINTER( Src, ALIGN_WCHAR ) == Src );

    *Dest = '\0';

    NetpInitOemString(
        & DestAnsi,             // output: struct
        Dest);                  // input: null terminated

    //
    // Tell RTL routines there's enough memory out there.
    // Note that using a max length in characters is by
    // design as this is what this routine's callers
    // expect (the max length should normally be in bytes).
    //
    DestAnsi.MaximumLength = (USHORT) (wcslen(Src)+1);

    RtlInitUnicodeString(
        & SrcUnicode,           // output: struct
        Src);                   // input: null terminated

    NtStatus = RtlUnicodeStringToOemString(
        & DestAnsi,             // output: struct
        & SrcUnicode,           // input: struct
        (BOOLEAN) FALSE);       // don't allocate string.

    NetpAssert( NT_SUCCESS(NtStatus) );

} // NetpCopyWStrToStr




VOID
NetpCopyStrToWStr(
    OUT LPWSTR Dest,
    IN  LPSTR  Src
    )

/*++

Routine Description:

    NetpCopyStrToWStr copies characters from a source string
    to a destination, converting as it copies them.

Arguments:

    Dest - is an LPWSTR indicating where the converted characters are to go.

    Src - is in LPSTR indicating the source string.  This must be a string in
        the default codepage of the LAN.

Return Value:

    None.

--*/

{
    UNICODE_STRING DestUnicode;
    NTSTATUS NtStatus;
    OEM_STRING SrcAnsi;

    NetpAssert( Dest != NULL );
    NetpAssert( Src != NULL );
    NetpAssert( ((LPVOID)Dest) != ((LPVOID)Src) );
    NetpAssert( ROUND_UP_POINTER( Dest, ALIGN_WCHAR ) == Dest );

    *Dest = L'\0';

    NetpInitOemString(
        & SrcAnsi,              // output: struct
        Src);                   // input: null terminated

    RtlInitUnicodeString(
        & DestUnicode,          // output: struct
        Dest);                  // input: null terminated

    // Tell RTL routines there's enough memory out there.
    DestUnicode.MaximumLength = (USHORT)
        ((USHORT) (strlen(Src)+1)) * (USHORT) sizeof(wchar_t);

    NtStatus = RtlOemStringToUnicodeString(
        & DestUnicode,          // output: struct
        & SrcAnsi,              // input: struct
        (BOOLEAN) FALSE);       // don't allocate string.

    NetpAssert( NT_SUCCESS(NtStatus) );

} // NetpCopyStrToWStr


NET_API_STATUS
NetpNCopyStrToWStr(
    OUT LPWSTR Dest,
    IN  LPSTR  Src,             // string in default LAN codepage
    IN  DWORD  CharCount
    )
{
    LPWSTR TempW;

    NetpAssert( Dest != NULL );
    NetpAssert( Src != NULL );
    NetpAssert( ((LPVOID)Dest) != ((LPVOID)Src) );
    NetpAssert( ROUND_UP_POINTER( Dest, ALIGN_WCHAR ) == Dest );

    // Allocate a copy of the full string, and convert to UNICODE.
    TempW = NetpAllocWStrFromStr( Src );
    if (TempW == NULL) {
        // Out of memory!
        return (ERROR_NOT_ENOUGH_MEMORY);
    }

    // Copy portion of array.  Append with nulls if necessary.
    // (Thank god for the C runtime library!  --JR)
    (VOID) wcsncpy( Dest, TempW, CharCount );

    // Free our temporary string.
    (VOID) NetApiBufferFree( TempW );

    return (NO_ERROR);

} // NetpNCopyStrToWStr


NET_API_STATUS
NetpNCopyWStrToStr(
    OUT LPSTR  Dest,            // string in default LAN codepage
    IN  LPWSTR Src,
    IN  DWORD  CharCount
    )
{
    LPSTR TempStr;

    NetpAssert( Dest != NULL );
    NetpAssert( Src != NULL );
    NetpAssert( ((LPVOID)Dest) != ((LPVOID)Src) );
    NetpAssert( ROUND_UP_POINTER( Src, ALIGN_WCHAR ) == Src );

    // Allocate a copy of the full string, and convert to UNICODE.
    TempStr = NetpAllocStrFromWStr( Src );
    if (TempStr == NULL) {
        return (ERROR_NOT_ENOUGH_MEMORY);
    }

    // Copy N chars, pad with nulls, etc.
    (VOID) strncpy( Dest, TempStr, CharCount );

    // Free our temporary data.
    (VOID) NetApiBufferFree( TempStr );

    return (NO_ERROR);

} // NetpNCopyWStrToStr

// NetpCopyStrToStr that assumes Dest <= wcslen(SRC)+1 * sizeof(WCHAR)
// This will be called whereever we have made sure that the proper
// buffer size has been allocated.  Eventually we can replace
// NetpCopStrToStr with this entirely once all calling functions
// have been fixed up.

VOID NetpCopyWStrToStrDBCS(
    OUT LPSTR  Dest,
    IN  LPWSTR Src
    )

/*++

Routine Description:

    NetpCopyWStrToStr copies characters from a source string
    to a destination, converting as it copies them.

Arguments:

    Dest - is an LPSTR indicating where the converted characters are to go.
        This string will be in the default codepage for the LAN.

    Src - is in LPWSTR indicating the source string.


Return Value:

    None.

--*/

{
    NTSTATUS NtStatus;
    LONG Index;
    ULONG DestLen = NetpUnicodeToDBCSLen( Src )+1;

    NetpAssert( Dest != NULL );
    NetpAssert( Src != NULL );
    NetpAssert( ((LPVOID)Dest) != ((LPVOID)Src) );
    NetpAssert( ROUND_UP_POINTER( Src, ALIGN_WCHAR ) == Src );

    NtStatus = RtlUnicodeToOemN(
        Dest,                             // Destination string
        DestLen,                          // Destination string length
        &Index,                           // Last char in translated string
        Src,                              // Source string
        wcslen(Src)*sizeof(WCHAR)         // Length of source string
    );

    Dest[Index] = '\0';

    NetpAssert( NT_SUCCESS(NtStatus) );

} // NetpCopyWStrToStr


ULONG
NetpUnicodeToDBCSLen(
    IN  LPWSTR Src
)
{
    UNICODE_STRING SrcUnicode;

    RtlInitUnicodeString(
        & SrcUnicode,           // output: struct
        Src);                   // input: null terminated

    return( RtlUnicodeStringToOemSize( &SrcUnicode ) -1 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\convwks.c ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    ConvWks.c

Abstract:

    32 bit version of mapping routines for NetWkstaGet/SetInfo API

Author:

    Dan Hinsley    (danhi)  06-Jun-1991

Environment:

    User Mode - Win32

Revision History:

    24-Apr-1991     danhi
        Created

    06-Jun-1991     Danhi
        Sweep to conform to NT coding style

    18-Aug-1991 JohnRo
        Implement downlevel NetWksta APIs.  (Moved DanHi's NetCmd/Map32/MWksta
        conversion stuff to NetLib.)
        Got rid of _DH hacks.
        Changed to use NET_API_STATUS.
        Started changing to UNICODE.

    21-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.
    03-Apr-1992 JohnRo
        Fixed heuristics field, which caused binding cache UNICODE problems.

--*/

//
// INCLUDES
//


// These must be included first:

#include <windef.h>             // IN, LPVOID, etc.
#include <lmcons.h>             // NET_API_STATUS, CNLEN, etc.

// These may be included in any order:

#include <debuglib.h>           // IF_DEBUG(CONVWKS).
#include <dlwksta.h>            // Old info levels, MAX_ equates, my prototypes.
#include <lmapibuf.h>           // NetapipBufferAllocate().
#include <lmerr.h>              // NERR_ and ERROR_ equates.
#include <lmwksta.h>            // New info level structures.
#include <mapsupp.h>            // NetpMoveStrings().
#include <netdebug.h>           // NetpAssert(), etc.
#include <netlib.h>             // NetpPointerPlusSomeBytes().
#include <tstring.h>            // STRLEN().

#define Nullstrlen(psz)  ((psz) ? STRLEN(psz)+1 : 0)


// Note: MOVESTRING structures (NetpWksta0_101, etc) are declared in DLWksta.h
// and initialized in NetLib/MapData.c.


NET_API_STATUS
NetpConvertWkstaInfo (
    IN DWORD FromLevel,
    IN LPVOID FromInfo,
    IN BOOL FromNative,
    IN DWORD ToLevel,
    OUT LPVOID ToInfo,
    IN DWORD ToFixedSize,
    IN DWORD ToStringSize,
    IN BOOL ToNative,
    IN OUT LPTSTR * ToStringTopPtr OPTIONAL
    )
{
    BOOL CopyOK;
    LPBYTE ToFixedEnd;
    // DWORD ToInfoSize;
    LPTSTR ToStringTop;

    NetpAssert(FromNative);
    NetpAssert(ToNative);

    // Set up pointers for use by NetpCopyStringsToBuffer.
    if (ToStringTopPtr != NULL) {
        ToStringTop = *ToStringTopPtr;
    } else {
        ToStringTop = (LPTSTR)
                NetpPointerPlusSomeBytes(ToInfo, ToFixedSize+ToStringSize);
    }
    // ToInfoSize = ToFixedSize + ToStringSize;
    ToFixedEnd = NetpPointerPlusSomeBytes(ToInfo, ToFixedSize);


#define COPY_STRING( InLevel, InField, OutLevel, OutField ) \
    { \
        NetpAssert( dest != NULL); \
        NetpAssert( src != NULL); \
        NetpAssert( (src -> wki##InLevel##_##InField) != NULL); \
        CopyOK = NetpCopyStringToBuffer ( \
            src->wki##InLevel##_##InField, \
            STRLEN(src->wki##InLevel##_##InField), \
            ToFixedEnd, \
            & ToStringTop, \
            & dest->wki##OutLevel##_##OutField); \
        NetpAssert(CopyOK); \
    }

    switch (ToLevel) {

    case 102 :
        {
            LPWKSTA_INFO_102 dest = ToInfo;
            // LPWKSTA_INFO_1   src  = FromInfo;
            NetpAssert( (FromLevel == 0) || (FromLevel == 1) );

            dest->wki102_logged_on_users = 1;
        }

        /* FALLTHROUGH */  // Level 101 is subset of level 102.

    case 101 :
        {
            LPWKSTA_INFO_101 dest = ToInfo;
            LPWKSTA_INFO_0   src  = FromInfo;
            NetpAssert( (FromLevel == 0) || (FromLevel == 1) );

            COPY_STRING(0, root, 101, lanroot);
        }

        /* FALLTHROUGH */  // Level 100 is subset of level 101.

    case 100 :

        {
            LPWKSTA_INFO_100 dest = ToInfo;
            dest->wki100_platform_id = PLATFORM_ID_OS2;

            if (FromLevel == 10) {
                LPWKSTA_INFO_10 src = FromInfo;

                COPY_STRING(10, computername, 100, computername);
                COPY_STRING(10, langroup,     100, langroup);
                dest->wki100_ver_major = src->wki10_ver_major;
                dest->wki100_ver_minor = src->wki10_ver_minor;
            } else if ( (FromLevel == 0) || (FromLevel == 1) ) {
                LPWKSTA_INFO_1 src = FromInfo;

                COPY_STRING(1, computername, 100, computername);
                COPY_STRING(1, langroup,     100, langroup);
                dest->wki100_ver_major = src->wki1_ver_major;
                dest->wki100_ver_minor = src->wki1_ver_minor;
            } else {
                NetpAssert( FALSE );
            }
        }
        break;

    case 402 :
        {
            LPWKSTA_INFO_402 dest = ToInfo;
            LPWKSTA_INFO_1   src  = FromInfo;
            NetpAssert( FromLevel == 1 );

            dest->wki402_char_wait = src->wki1_charwait;
            dest->wki402_collection_time = src->wki1_chartime;
            dest->wki402_maximum_collection_count = src->wki1_charcount;
            dest->wki402_keep_conn = src->wki1_keepconn;
            dest->wki402_keep_search = src->wki1_keepsearch;
            dest->wki402_max_cmds = src->wki1_maxcmds;
            dest->wki402_num_work_buf = src->wki1_numworkbuf;
            dest->wki402_siz_work_buf = src->wki1_sizworkbuf;
            dest->wki402_max_wrk_cache = src->wki1_maxwrkcache;
            dest->wki402_sess_timeout = src->wki1_sesstimeout;
            dest->wki402_siz_error = src->wki1_sizerror;
            dest->wki402_num_alerts = src->wki1_numalerts;
            dest->wki402_num_services = src->wki1_numservices;
            dest->wki402_errlog_sz = src->wki1_errlogsz;
            dest->wki402_print_buf_time = src->wki1_printbuftime;
            dest->wki402_num_char_buf = src->wki1_numcharbuf;
            dest->wki402_siz_char_buf = src->wki1_sizcharbuf;
            COPY_STRING(1, wrkheuristics, 402, wrk_heuristics);
            dest->wki402_mailslots = src->wki1_mailslots;
            dest->wki402_num_dgram_buf = src->wki1_numdgrambuf;
            dest->wki402_max_threads = src->wki1_maxthreads;
        }
        break;

    default :
       NetpAssert( FALSE );
       return (ERROR_INVALID_LEVEL);
    }

    return (NERR_Success);

} // NetpConvertWkstaInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\convsrv.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    ConvSrv.c

Abstract:

    This file contains routines to convert between old and new server
    info levels.

Author:

    John Rogers (JohnRo) 02-May-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    02-May-1991 JohnRo
        Created.
    11-May-1991 JohnRo
        Added level 402,403 support.  Use PLATFORM_ID equates from lncons.h.
    19-May-1991 JohnRo
        Clean up LPBYTE vs. LPTSTR handling, as suggested by PC-LINT.
    05-Jun-1991 JohnRo
        Added level 101 to 1 conversion.  Also 100 to 0 and 102 to 2.
        Added support for sv403_autopath.
        Added more debug output when we fail.
    07-Jun-1991 JohnRo
        Really added 102 to 2 conversion.
    14-Jun-1991 JohnRo
        For debug, display the entire incoming structure.
    18-Jun-1991 JohnRo
        Added svX_licenses support.
    08-Aug-1991 JohnRo
        Implement downlevel NetWksta APIs.  (Moved DanHi's NetCmd/Map32/MServer
        stuff here.)
    21-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.
    05-May-1993 JohnRo
        RAID 8720: bad data from WFW can cause RxNetServerEnum GP fault.
        Avoid compiler warnings.
        Minor debug output changes.
        Use PREFIX_ equates.
        Made changes suggested by PC-LINT 5.0

--*/


// These must be included first:

#include <windef.h>     // IN, LPVOID, etc.
#include <lmcons.h>     // NET_API_STATUS, CNLEN, etc.

// These may be included in any order:

#include <debuglib.h>   // IF_DEBUG(CONVSRV).
#include <dlserver.h>   // Old info levels, MAX_ equates, my prototype.
#include <lmapibuf.h>   // NetapipBufferAllocate().
#include <lmerr.h>      // NERR_ and ERROR_ equates.
#include <lmserver.h>   // New info level structures & conv routines.
#include <mapsupp.h>    // NetpMoveStrings().
#include <netdebug.h>   // NetpKdPrint(()), FORMAT_ equates, etc.
#include <netlib.h>     // NetpPointerPlusSomeBytes().
#include <prefix.h>     // PREFIX_ equates.
#include <tstr.h>       // STRLEN().
#include <xsdef16.h>    // xactsrv defaults for values not supported on NT


NET_API_STATUS
NetpConvertServerInfo (
    IN DWORD FromLevel,
    IN LPVOID FromInfo,
    IN BOOL FromNative,
    IN DWORD ToLevel,
    OUT LPVOID ToInfo,
    IN DWORD ToFixedSize,
    IN DWORD ToStringSize,
    IN BOOL ToNative,
    IN OUT LPTSTR * ToStringTopPtr OPTIONAL
    )

/*++

Routine Description:

    NetpConvertServerInfo handles "old" (LanMan 2.x) and "new" (portable
    LanMan, including NT/LAN) server info levels.  Only certain pairs of
    conversions are allowed:

        0 to 100
        1 to 101
        2 to 102
        2 to 402
        3 to 403
        100 to 0
        101 to 1
        102 to 2

Arguments:

    FromLevel - a DWORD which gives the info level being converted from.

    FromInfo - the actual data being converted.

    FromNative - a BOOLEAN indicating whether or not FromInfo is in native
        (local machine) format, as opposed to "RAP" format.

    ToLevel - a DWORD which gives the info level being converted to.

    ToInfo - Points to an area which will contain the converted
        info structure.

    ToFixedSize - Size of the ToInfo fixed area, in bytes.

    ToStringSize - Size of the ToStringTopPtr string area, in bytes.

    ToNative - a BOOLEAN indicating whether or not the "to" info is to be
        in native (local machine) format, as opposed to "RAP" format.

    ToStringTopPtr - optionally points a pointer to the top of the area to be
        used for variable-length items.  If ToStringTopPtr is NULL, then
        NetpConvertServerInfo will use ToInfo+ToFixedSize as this area.
        Otherwise, this routine will update *ToStringTopPtr.  This allows
        this routine to be used to convert arrays of entries.

Return Value:

    NET_API_STATUS - NERR_Success, ERROR_INVALID_LEVEL, etc.

--*/

{
    BOOL CopyOK;
    LPBYTE ToFixedEnd;
    DWORD ToInfoSize;
    LPTSTR ToStringTop;

    //
    // These parameters are not used in non-debug code for the moment.
    // ToLevel might be used in the future, if we allow more combinations of
    // level conversions.  FromNative and ToNative will eventually be used
    // by RapConvertSingleEntry.
    //
    DBG_UNREFERENCED_PARAMETER(CopyOK);  // debug only
    NetpAssert(FromNative == TRUE);
    DBG_UNREFERENCED_PARAMETER(FromNative);
    DBG_UNREFERENCED_PARAMETER(ToLevel);
    NetpAssert(ToNative == TRUE);
    DBG_UNREFERENCED_PARAMETER(ToNative);

    // Check caller's parameters for null pointers.
    if (FromInfo==NULL) {
        NetpKdPrint(( PREFIX_NETLIB
                "NetpConvertServerInfo: invalid FromInfo pointer.\n" ));
        return (ERROR_INVALID_PARAMETER);
    } else if (ToInfo==NULL) {
        NetpKdPrint(( PREFIX_NETLIB
                "NetpConvertServerInfo: invalid ToInfo pointer.\n" ));
        return (ERROR_INVALID_PARAMETER);
    }

    // Set up pointers for use by NetpCopyStringsToBuffer.
    if (ToStringTopPtr != NULL) {
        ToStringTop = *ToStringTopPtr;
    } else {
        ToStringTop = (LPTSTR)
                NetpPointerPlusSomeBytes(ToInfo, ToFixedSize+ToStringSize);
    }
    ToInfoSize = ToFixedSize + ToStringSize;
    ToFixedEnd = NetpPointerPlusSomeBytes(ToInfo, ToFixedSize);

    // Make sure info levels are OK and caller didn't mess up otherwise.
    NetpAssert(ToInfoSize > 0);
    switch (FromLevel) {

        case 0 :
            NetpAssert(ToLevel == 100);
            break;

        case 1 :
            NetpAssert(ToLevel == 101);
            break;

        case 2 :
            NetpAssert( (ToLevel == 102) || (ToLevel == 402) );
            break;

        case 3 :
            NetpAssert(ToLevel == 403);
            break;

        case 100 :
            NetpAssert(ToLevel == 0);
            break;

        case 101 :
            NetpAssert(ToLevel == 1);
            break;

        case 102 :
            NetpAssert(ToLevel == 2);
            break;

        default :
            NetpKdPrint((  PREFIX_NETLIB
                    "NetpConvertServerInfo: invalid FromLevel ("
                    FORMAT_DWORD ").\n", FromLevel ));
            return (ERROR_INVALID_LEVEL);
    }



    // Convert fields.  This is done with a "switch" that takes advantage
    // of the fact that certain info levels are subsets of other ones.
    switch (FromLevel) {

        case 102 :
            {
                LPSERVER_INFO_2   psv2   = ToInfo;
                LPSERVER_INFO_102 psv102 = FromInfo;

                // Do unique fields for level 1.
                psv2->sv2_users = psv102->sv102_users;
                psv2->sv2_disc = psv102->sv102_disc;
                if (psv102->sv102_hidden) {
                    psv2->sv2_hidden = SV_HIDDEN;
                } else {
                    psv2->sv2_hidden = SV_VISIBLE;
                }
                psv2->sv2_announce = psv102->sv102_announce;
                psv2->sv2_anndelta = psv102->sv102_anndelta;
                psv2->sv2_licenses = psv102->sv102_licenses;

                NetpAssert(psv102->sv102_userpath != NULL); // Avoid STRLEN err.
                CopyOK = NetpCopyStringToBuffer (
                        psv102->sv102_userpath,          // in string
                        STRLEN(psv102->sv102_userpath),  // input string length
                        ToFixedEnd,                // fixed data end
                        & ToStringTop,             // var area end (ptr updated)
                        & psv2->sv2_userpath);     // output string pointer
                NetpAssert(CopyOK);

                // Make sure it's OK to use level 101 => level 1 code.
                CHECK_SERVER_OFFSETS(  1,   2, version_major);
                CHECK_SERVER_OFFSETS(101, 102, version_major);
                CHECK_SERVER_OFFSETS(  1,   2, version_minor);
                CHECK_SERVER_OFFSETS(101, 102, version_minor);
                CHECK_SERVER_OFFSETS(  1,   2, type);
                CHECK_SERVER_OFFSETS(101, 102, type);
                CHECK_SERVER_OFFSETS(  1,   2, comment);
                CHECK_SERVER_OFFSETS(101, 102, comment);
            }
            /* FALLTHROUGH */

        case 101 :
            {
                LPSERVER_INFO_1   psv1   = ToInfo;
                LPSERVER_INFO_101 psv101 = FromInfo;

                // Do unique fields for level 1.
                psv1->sv1_version_major = psv101->sv101_version_major;
                psv1->sv1_version_minor = psv101->sv101_version_minor;
                psv1->sv1_type = psv101->sv101_type;

                NetpAssert(psv101->sv101_comment != NULL);  // Avoid STRLEN err.
                CopyOK = NetpCopyStringToBuffer (
                        psv101->sv101_comment,            // in string
                        STRLEN(psv101->sv101_comment),    // input string length
                        ToFixedEnd,                // fixed data end
                        & ToStringTop,             // var area end (ptr updated)
                        & psv1->sv1_comment);     // output string pointer
                NetpAssert(CopyOK);

                // Make sure it's OK to use level 100 => level 0 code.
                CHECK_SERVER_OFFSETS(  0,   1, name);
                CHECK_SERVER_OFFSETS(100, 101, name);
            }
            /* FALLTHROUGH */

        case 100 :
            {
                LPSERVER_INFO_0   psv0   = ToInfo;
                LPSERVER_INFO_100 psv100 = FromInfo;

                // All fields are unique for level 0.
                NetpAssert(psv100->sv100_name != NULL);  // Avoid STRLEN err.
                CopyOK = NetpCopyStringToBuffer (
                        psv100->sv100_name,            // in string
                        STRLEN(psv100->sv100_name),    // input string length
                        ToFixedEnd,                // fixed data end
                        & ToStringTop,             // var area end (ptr updated)
                        & psv0->sv0_name);     // output string pointer
                NetpAssert(CopyOK);

            }
            break;

        case 3 :
            {
                LPSERVER_INFO_3   psv3   = FromInfo;
                LPSERVER_INFO_403 psv403 = ToInfo;

                // Do unique fields for level 403.
                psv403->sv403_auditedevents = psv3->sv3_auditedevents;
                psv403->sv403_autoprofile = psv3->sv3_autoprofile;

                NetpAssert(psv3->sv3_autopath != NULL); // avoid STRLEN err.
                CopyOK = NetpCopyStringToBuffer (
                        psv3->sv3_autopath,     // in string
                        STRLEN(psv3->sv3_autopath), // input string length
                        ToFixedEnd,             // fixed data end
                        & ToStringTop,         // var area end (ptr updated)
                        & psv403->sv403_autopath);  // output string pointer
                NetpAssert(CopyOK);

                // Make sure it's OK to fall through to next level conv.
                CHECK_SERVER_OFFSETS(  2,   3, ulist_mtime);
                CHECK_SERVER_OFFSETS(  2,   3, glist_mtime);
                CHECK_SERVER_OFFSETS(  2,   3, alist_mtime);
                CHECK_SERVER_OFFSETS(  2,   3, alerts);
                CHECK_SERVER_OFFSETS(  2,   3, security);
                CHECK_SERVER_OFFSETS(  2,   3, numadmin);
                CHECK_SERVER_OFFSETS(  2,   3, lanmask);
                CHECK_SERVER_OFFSETS(  2,   3, guestacct);
                CHECK_SERVER_OFFSETS(  2,   3, chdevs);
                CHECK_SERVER_OFFSETS(  2,   3, chdevq);
                CHECK_SERVER_OFFSETS(  2,   3, chdevjobs);
                CHECK_SERVER_OFFSETS(  2,   3, connections);
                CHECK_SERVER_OFFSETS(  2,   3, shares);
                CHECK_SERVER_OFFSETS(  2,   3, openfiles);
                CHECK_SERVER_OFFSETS(  2,   3, sessopens);
                CHECK_SERVER_OFFSETS(  2,   3, sessvcs);
                CHECK_SERVER_OFFSETS(  2,   3, sessreqs);
                CHECK_SERVER_OFFSETS(  2,   3, opensearch);
                CHECK_SERVER_OFFSETS(  2,   3, activelocks);
                CHECK_SERVER_OFFSETS(  2,   3, numreqbuf);
                CHECK_SERVER_OFFSETS(  2,   3, sizreqbuf);
                CHECK_SERVER_OFFSETS(  2,   3, numbigbuf);
                CHECK_SERVER_OFFSETS(  2,   3, numfiletasks);
                CHECK_SERVER_OFFSETS(  2,   3, alertsched);
                CHECK_SERVER_OFFSETS(  2,   3, erroralert);
                CHECK_SERVER_OFFSETS(  2,   3, logonalert);
                CHECK_SERVER_OFFSETS(  2,   3, accessalert);
                CHECK_SERVER_OFFSETS(  2,   3, diskalert);
                CHECK_SERVER_OFFSETS(  2,   3, netioalert);
                CHECK_SERVER_OFFSETS(  2,   3, maxauditsz);
                CHECK_SERVER_OFFSETS(  2,   3, srvheuristics);

                CHECK_SERVER_OFFSETS(402, 403, ulist_mtime);
                CHECK_SERVER_OFFSETS(402, 403, glist_mtime);
                CHECK_SERVER_OFFSETS(402, 403, alist_mtime);
                CHECK_SERVER_OFFSETS(402, 403, alerts);
                CHECK_SERVER_OFFSETS(402, 403, security);
                CHECK_SERVER_OFFSETS(402, 403, numadmin);
                CHECK_SERVER_OFFSETS(402, 403, lanmask);
                CHECK_SERVER_OFFSETS(402, 403, guestacct);
                CHECK_SERVER_OFFSETS(402, 403, chdevs);
                CHECK_SERVER_OFFSETS(402, 403, chdevq);
                CHECK_SERVER_OFFSETS(402, 403, chdevjobs);
                CHECK_SERVER_OFFSETS(402, 403, connections);
                CHECK_SERVER_OFFSETS(402, 403, shares);
                CHECK_SERVER_OFFSETS(402, 403, openfiles);
                CHECK_SERVER_OFFSETS(402, 403, sessopens);
                CHECK_SERVER_OFFSETS(402, 403, sessvcs);
                CHECK_SERVER_OFFSETS(402, 403, sessreqs);
                CHECK_SERVER_OFFSETS(402, 403, opensearch);
                CHECK_SERVER_OFFSETS(402, 403, activelocks);
                CHECK_SERVER_OFFSETS(402, 403, numreqbuf);
                CHECK_SERVER_OFFSETS(402, 403, sizreqbuf);
                CHECK_SERVER_OFFSETS(402, 403, numbigbuf);
                CHECK_SERVER_OFFSETS(402, 403, numfiletasks);
                CHECK_SERVER_OFFSETS(402, 403, alertsched);
                CHECK_SERVER_OFFSETS(402, 403, erroralert);
                CHECK_SERVER_OFFSETS(402, 403, logonalert);
                CHECK_SERVER_OFFSETS(402, 403, accessalert);
                CHECK_SERVER_OFFSETS(402, 403, diskalert);
                CHECK_SERVER_OFFSETS(402, 403, netioalert);
                CHECK_SERVER_OFFSETS(402, 403, maxauditsz);
                CHECK_SERVER_OFFSETS(402, 403, srvheuristics);

            }
            /* FALLTHROUGH */

        case 2 :
            {
                LPSERVER_INFO_2   psv2   = FromInfo;
                LPSERVER_INFO_102 psv102 = ToInfo;
                LPSERVER_INFO_402 psv402 = ToInfo;

                switch (ToLevel) {
                case 402 : /*FALLTHROUGH*/
                case 403 :
                    psv402->sv402_ulist_mtime = psv2->sv2_ulist_mtime;
                    psv402->sv402_glist_mtime = psv2->sv2_glist_mtime;
                    psv402->sv402_alist_mtime = psv2->sv2_alist_mtime;

                    NetpAssert(psv2->sv2_alerts != NULL); // avoid STRLEN err.
                    CopyOK = NetpCopyStringToBuffer (
                            psv2->sv2_alerts,     // in string
                            STRLEN(psv2->sv2_alerts), // input string length
                            ToFixedEnd,             // fixed data end
                            & ToStringTop,         // var area end (ptr updated)
                            & psv402->sv402_alerts);  // output string pointer
                    NetpAssert(CopyOK);

                    psv402->sv402_security = psv2->sv2_security;
                    psv402->sv402_numadmin = psv2->sv2_numadmin;
                    psv402->sv402_lanmask = psv2->sv2_lanmask;

                    NetpAssert(psv2->sv2_guestacct != NULL); // Protect STRLEN.
                    CopyOK = NetpCopyStringToBuffer (
                            psv2->sv2_guestacct,     // in string
                            STRLEN(psv2->sv2_guestacct), // input string length
                            ToFixedEnd,             // fixed data end
                            & ToStringTop,         // var area end (ptr updated)
                            & psv402->sv402_guestacct);  // output string ptr
                    NetpAssert(CopyOK);

                    psv402->sv402_chdevs = psv2->sv2_chdevs;
                    psv402->sv402_chdevq = psv2->sv2_chdevq;
                    psv402->sv402_chdevjobs = psv2->sv2_chdevjobs;
                    psv402->sv402_connections = psv2->sv2_connections;
                    psv402->sv402_shares = psv2->sv2_shares;
                    psv402->sv402_openfiles = psv2->sv2_openfiles;
                    psv402->sv402_sessopens = psv2->sv2_sessopens;
                    psv402->sv402_sessvcs = psv2->sv2_sessvcs;
                    psv402->sv402_sessreqs = psv2->sv2_sessreqs;
                    psv402->sv402_opensearch = psv2->sv2_opensearch;
                    psv402->sv402_activelocks = psv2->sv2_activelocks;
                    psv402->sv402_numreqbuf = psv2->sv2_numreqbuf;
                    psv402->sv402_sizreqbuf = psv2->sv2_sizreqbuf;
                    psv402->sv402_numbigbuf = psv2->sv2_numbigbuf;
                    psv402->sv402_numfiletasks = psv2->sv2_numfiletasks;
                    psv402->sv402_alertsched = psv2->sv2_alertsched;
                    psv402->sv402_erroralert = psv2->sv2_erroralert;
                    psv402->sv402_logonalert = psv2->sv2_logonalert;
                    psv402->sv402_accessalert = psv2->sv2_accessalert;
                    psv402->sv402_diskalert = psv2->sv2_diskalert;
                    psv402->sv402_netioalert = psv2->sv2_netioalert;
                    psv402->sv402_maxauditsz = psv2->sv2_maxauditsz;

                    NetpAssert(psv2->sv2_srvheuristics != NULL); // Prot STRLEN.
                    CopyOK = NetpCopyStringToBuffer (
                            psv2->sv2_srvheuristics,     // in string
                            STRLEN(psv2->sv2_srvheuristics), // input str len
                            ToFixedEnd,             // fixed data end
                            & ToStringTop,   // var area end (ptr updated)
                            & psv402->sv402_srvheuristics);  // output str ptr
                    NetpAssert(CopyOK);
                    goto Done;  // In nested switch, so "break" won't work.

                case 102 : // 2 to 102.

                    // Set unique fields for levels 2 and 102.
                    NetpAssert(ToLevel == 102);
                    psv102->sv102_users    = psv2->sv2_users;
                    psv102->sv102_disc     = psv2->sv2_disc;

                    if (psv2->sv2_hidden == SV_HIDDEN) {;
                        psv102->sv102_hidden = TRUE;
                    } else {
                        psv102->sv102_hidden = FALSE;
                    }

                    psv102->sv102_announce = psv2->sv2_announce;
                    psv102->sv102_anndelta = psv2->sv2_anndelta;
                    psv102->sv102_licenses = psv2->sv2_licenses;

                    NetpAssert(psv2->sv2_userpath != NULL);
                    CopyOK = NetpCopyStringToBuffer (
                            psv2->sv2_userpath,     // in string
                            STRLEN(psv2->sv2_userpath), // input string length
                            ToFixedEnd,             // fixed data end
                            & ToStringTop,         // var area end (ptr updated)
                            & psv102->sv102_userpath);  // output string pointer
                    NetpAssert(CopyOK);

                    // Make sure it's OK to fall through to next level conv.
                    CHECK_SERVER_OFFSETS(  1,   2, name);
                    CHECK_SERVER_OFFSETS(  1,   2, version_major);
                    CHECK_SERVER_OFFSETS(  1,   2, version_minor);
                    CHECK_SERVER_OFFSETS(  1,   2, type);
                    CHECK_SERVER_OFFSETS(  1,   2, comment);
                    CHECK_SERVER_OFFSETS(101, 102, platform_id);
                    CHECK_SERVER_OFFSETS(101, 102, name);
                    CHECK_SERVER_OFFSETS(101, 102, version_major);
                    CHECK_SERVER_OFFSETS(101, 102, version_minor);
                    CHECK_SERVER_OFFSETS(101, 102, type);
                    CHECK_SERVER_OFFSETS(101, 102, comment);
                    break;
                default:
                    NetpAssert( FALSE );     // Can't happen.
                }
            }
            /* FALLTHROUGH */


        case 1 :
            {
                DWORD CommentSize;
                LPSERVER_INFO_1   psv1   = FromInfo;
                LPSERVER_INFO_101 psv101 = ToInfo;

                psv101->sv101_version_major = psv1->sv1_version_major;
                psv101->sv101_version_minor = psv1->sv1_version_minor;
                psv101->sv101_type          = psv1->sv1_type;

                // Copy comment string.  Note that null ptr and ptr to null
                // char are both allowed here.
                if (psv1->sv1_comment != NULL) {
                    CommentSize = STRLEN(psv1->sv1_comment);
                } else {
                    CommentSize = 0;
                }
                CopyOK = NetpCopyStringToBuffer (
                        psv1->sv1_comment,         // in string
                        CommentSize,             // input string length
                        ToFixedEnd,                // fixed data end
                        & ToStringTop,            // var area end (ptr updated)
                        & psv101->sv101_comment);  // output string pointer
                NetpAssert(CopyOK);

                // Make sure it's OK to use level 0 => level 100 code.
                CHECK_SERVER_OFFSETS(  0,   1, name);
                CHECK_SERVER_OFFSETS(100, 101, name);
                CHECK_SERVER_OFFSETS(100, 101, platform_id);
            }
            /* FALLTHROUGH */


        case 0 :
            {
                LPSERVER_INFO_0   psv0   = FromInfo;
                LPSERVER_INFO_100 psv100 = ToInfo;

                if (FromLevel != 0) {
                    LPSERVER_INFO_101 psv101 = ToInfo;

                    if (psv101->sv101_type & SV_TYPE_NT) {
                        psv100->sv100_platform_id = PLATFORM_ID_NT;
                    } else {
                        psv100->sv100_platform_id = PLATFORM_ID_OS2;
                    }
                } else {
                    psv100->sv100_platform_id = PLATFORM_ID_OS2;
                }

                NetpAssert(psv0->sv0_name != NULL);  // or STRLEN() will fail.
                CopyOK = NetpCopyStringToBuffer (
                        psv0->sv0_name,            // in string
                        STRLEN(psv0->sv0_name),    // input string length
                        ToFixedEnd,                // fixed data end
                        & ToStringTop,             // var area end (ptr updated)
                        & psv100->sv100_name);     // output string pointer
                NetpAssert(CopyOK);
                break;
            }

        default :
            NetpKdPrint(( PREFIX_NETLIB
                    "NetpConvertServerInfo: unexpected error.\n" ));
            return (NERR_InternalError);
    }

Done:

    // Done converting.

    NetpAssert(ToInfo != NULL);

    NetpSetOptionalArg(ToStringTopPtr, ToStringTop);
    return (NERR_Success);

} // NetpConvertServerInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\debug.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    Debug.c

Abstract:

    This file contains routines to insulate more networking code from
    the actual NT debug routines.

Author:

    John Rogers (JohnRo) 16-Apr-1991

Environment:

    Interface is portable to any flat, 32-bit environment.  (Uses Win32
    typedefs.)  Requires ANSI C extensions: slash-slash comments, long
    external names.  Code itself only runs under NT.

Revision History:

    16-Apr-1991 JohnRo
        Created.  (Borrowed some code from LarryO's NetapipPrintf.)
    19-May-1991 JohnRo
        Make LINT-suggested changes.
    20-Aug-1991 JohnRo
        Another change suggested by PC-LINT.
    17-Sep-1991 JohnRo
        Correct UNICODE use.
    10-May-1992 JohnRo
        Correct a NetpDbgPrint bug when printing percent signs.

--*/


// These must be included first:

#include <nt.h>              // IN, LPVOID, etc.

// These may be included in any order:

#include <netdebug.h>           // My prototypes.
#include <nt.h>
#include <ntrtl.h>              // RtlAssert().
#include <nturtl.h>
#include <stdarg.h>             // va_list, etc.
#include <stdio.h>              // vsprintf().
#include <prefix.h>             // PREFIX_ equates.
#include <windows.h>

//
// Critical section used to control access to the log
//
RTL_CRITICAL_SECTION    NetpLogCritSect;

//
// These routines are exported from netapi32.dll.  We want them to still
// be there in the free build, so checked binaries will run on a free
// build.  The following undef's are to get rid of the macros that cause
// these to not be called in free builds.
//
#define DEBUG_DIR           L"\\debug"

#if !DBG
#undef NetpAssertFailed
#undef NetpHexDump
#endif

VOID
NetpAssertFailed(
    IN LPDEBUG_STRING FailedAssertion,
    IN LPDEBUG_STRING FileName,
    IN DWORD LineNumber,
    IN LPDEBUG_STRING Message OPTIONAL
    )

{
#if DBG
    RtlAssert(
            FailedAssertion,
            FileName,
            (ULONG) LineNumber,
            (PCHAR) Message);
#endif
    /* NOTREACHED */

} // NetpAssertFailed



#define MAX_PRINTF_LEN 1024        // Arbitrary.

VOID
NetpDbgPrint(
    IN LPDEBUG_STRING Format,
    ...
    )

{
    va_list arglist;

    va_start(arglist, Format);
    vKdPrintEx((DPFLTR_NETAPI_ID, DPFLTR_INFO_LEVEL, Format, arglist));
    va_end(arglist);
    return;
} // NetpDbgPrint



VOID
NetpHexDump(
    LPBYTE Buffer,
    DWORD BufferSize
    )
/*++

Routine Description:

    This function dumps the contents of the buffer to the debug screen.

Arguments:

    Buffer - Supplies a pointer to the buffer that contains data to be dumped.

    BufferSize - Supplies the size of the buffer in number of bytes.

Return Value:

    None.

--*/
{
#define NUM_CHARS 16

    DWORD i, limit;
    TCHAR TextBuffer[NUM_CHARS + 1];

    //
    // Hex dump of the bytes
    //
    limit = ((BufferSize - 1) / NUM_CHARS + 1) * NUM_CHARS;

    for (i = 0; i < limit; i++) {

        if (i < BufferSize) {

            (VOID) DbgPrint("%02x ", Buffer[i]);

            if (Buffer[i] == TEXT('\r') ||
                Buffer[i] == TEXT('\n')) {
                TextBuffer[i % NUM_CHARS] = '.';
            }
            else if (Buffer[i] == '\0') {
                TextBuffer[i % NUM_CHARS] = ' ';
            }
            else {
                TextBuffer[i % NUM_CHARS] = (TCHAR) Buffer[i];
            }

        }
        else {

            (VOID) DbgPrint("   ");
            TextBuffer[i % NUM_CHARS] = ' ';

        }

        if ((i + 1) % NUM_CHARS == 0) {
            TextBuffer[NUM_CHARS] = 0;
            (VOID) DbgPrint("  %s     \n", TextBuffer);
        }

    }

    (VOID) DbgPrint("\n");
}


#undef NetpBreakPoint
VOID
NetpBreakPoint(
    VOID
    )
{
#if DBG
    DbgBreakPoint();
#endif

} // NetpBreakPoint





//
// NOTICE
// The debug log code was blatantly stolen from net\svcdlls\netlogon\server\nlp.c
//

//
// Generalized logging support is provided below.  The proper calling procedure is:
//
//  NetpInitializeLogFile() - Call this once per process/log lifespan
//  NetpOpenDebugFile() - Call this to open a log file instance
//  NetpDebugDumpRoutine() / NetpLogPrintRoutine() - Call this every time you wish to
//          write data to the log.  This can be done.  Mutli-threaded safe.
//  NetpCloseDebugFile() - Call this to close a log instance
//  NetpShutdownLogFile() - Call this once per process/log lifespan
//
//  NetpResetLog() - This support routine is provided to reset a log file pointer to
//      the end of the file.  Usefull if the log is being shared.
//
//
// Notes: NetpInitializeLogFile need only be called once per logging process instance,
//      meaning that a given logging process (such as netlogon, which does not exist as
//      a separate NT process, but does logging from multiple threads within a NT process).
//      Likewise, it would only call NetpShutdownLogFile once.  This logging process can then
//      open and close the debug log as many times as it desires.  Or, if there is only going
//      to be one instance of a log operating at any given moment, the Initialize and Shutdown
//      calls can wrap the Open and Close calls.
//
//      The CloseDebugFile does a flush before closing the handle
//

VOID
NetpInitializeLogFile(
    VOID
    )
/*++

Routine Description:

    Initializes the process for logging

Arguments:

    None

Return Value:

    None

--*/
{
    InitializeCriticalSection( &NetpLogCritSect );

}




VOID
NetpShutdownLogFile(
    VOID
    )
/*++

Routine Description:

    The opposite of the former function

Arguments:

    None

Return Value:

    None

--*/
{
    DeleteCriticalSection( &NetpLogCritSect );

}

HANDLE
NetpOpenDebugFile(
    IN LPWSTR DebugLog,
    IN BOOLEAN ReopenFlag
    )
/*++

Routine Description:

    Opens or re-opens the debug file

    This code blatantly stolen from net\svcdlls\netlogon\server\nlp.c

Arguments:

    ReopenFlag - TRUE to indicate the debug file is to be closed, renamed,
        and recreated.

    DebugLog - Root name of the debug log.  The given name will have a .LOG appeneded to it

Return Value:

    None

--*/
{
    WCHAR LogFileName[MAX_PATH+1];
    WCHAR BakFileName[MAX_PATH+1];
    DWORD FileAttributes;
    DWORD PathLength, LogLen;
    DWORD WinError;
    HANDLE DebugLogHandle = NULL;

    //
    // make debug directory path first, if it is not made before.
    //
    if ( !GetWindowsDirectoryW(
            LogFileName,
            sizeof(LogFileName)/sizeof(WCHAR) ) ) {
        NetpKdPrint((PREFIX_NETLIB "Window Directory Path can't be retrieved, %lu.\n",
                 GetLastError() ));
        return( DebugLogHandle );
    }

    //
    // check debug path length.
    //
    LogLen = 1 + wcslen( DebugLog ) + 4;  // 1 is for the \\ and 4 is for the .LOG or .BAK
    PathLength = wcslen(LogFileName) * sizeof(WCHAR) +
                    sizeof(DEBUG_DIR) + sizeof(WCHAR);

    if( (PathLength + ( ( LogLen + 1 ) * sizeof(WCHAR) ) > sizeof(LogFileName) )  ||
        (PathLength + ( ( LogLen + 1 ) * sizeof(WCHAR) ) > sizeof(BakFileName) ) ) {

        NetpKdPrint((PREFIX_NETLIB "Debug directory path (%ws) length is too long.\n",
                    LogFileName));
        goto ErrorReturn;
    }

    wcscat(LogFileName, DEBUG_DIR);

    //
    // Check this path exists.
    //

    FileAttributes = GetFileAttributesW( LogFileName );

    if( FileAttributes == 0xFFFFFFFF ) {

        WinError = GetLastError();
        if( WinError == ERROR_FILE_NOT_FOUND ) {

            //
            // Create debug directory.
            //

            if( !CreateDirectoryW( LogFileName, NULL) ) {
                NetpKdPrint((PREFIX_NETLIB "Can't create Debug directory (%ws), %lu.\n",
                         LogFileName, GetLastError() ));
                goto ErrorReturn;
            }

        }
        else {
            NetpKdPrint((PREFIX_NETLIB "Can't Get File attributes(%ws), %lu.\n",
                     LogFileName, WinError ));
            goto ErrorReturn;
        }
    }
    else {

        //
        // if this is not a directory.
        //

        if(!(FileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {

            NetpKdPrint((PREFIX_NETLIB "Debug directory path (%ws) exists as file.\n",
                         LogFileName));
            goto ErrorReturn;
        }
    }

    //
    // Create the name of the old and new log file names
    //
    swprintf( BakFileName, L"%ws\\%ws.BAK", LogFileName, DebugLog );

    (VOID) wcscat( LogFileName, L"\\" );
    (VOID) wcscat( LogFileName, DebugLog );
    (VOID) wcscat( LogFileName, L".LOG" );


    //
    // If this is a re-open,
    //  delete the backup file,
    //  rename the current file to the backup file.
    //

    if ( ReopenFlag ) {

        if ( !DeleteFile( BakFileName ) ) {
            WinError = GetLastError();
            if ( WinError != ERROR_FILE_NOT_FOUND ) {
                NetpKdPrint((PREFIX_NETLIB "Cannot delete %ws (%ld)\n",
                    BakFileName,
                    WinError ));
                NetpKdPrint((PREFIX_NETLIB "   Try to re-open the file.\n"));
                ReopenFlag = FALSE;     // Don't truncate the file
            }
        }
    }

    if ( ReopenFlag ) {

        if ( !MoveFile( LogFileName, BakFileName ) ) {
            NetpKdPrint((PREFIX_NETLIB "Cannot rename %ws to %ws (%ld)\n",
                    LogFileName,
                    BakFileName,
                    GetLastError() ));
            NetpKdPrint((PREFIX_NETLIB "   Try to re-open the file.\n"));
            ReopenFlag = FALSE;     // Don't truncate the file
        }
    }

    //
    // Open the file.
    //
    DebugLogHandle = CreateFileW( LogFileName,
                                  GENERIC_WRITE,
                                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  NULL,
                                  ReopenFlag ? CREATE_ALWAYS : OPEN_ALWAYS,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL );


    if ( DebugLogHandle == INVALID_HANDLE_VALUE ) {

        DebugLogHandle = NULL;
        NetpKdPrint((PREFIX_NETLIB  "cannot open %ws \n",
                    LogFileName ));
        goto ErrorReturn;

    } else {
        // Position the log file at the end
        (VOID) SetFilePointer( DebugLogHandle,
                               0,
                               NULL,
                               FILE_END );
    }

    return( DebugLogHandle );;

ErrorReturn:
    NetpKdPrint((PREFIX_NETLIB " Debug output will be written to debug terminal.\n"));
    return( DebugLogHandle );
}


VOID
NetpDebugDumpRoutine(
    IN HANDLE LogHandle,
    IN PDWORD OpenLogThreadId OPTIONAL,
    IN LPSTR Format,
    va_list arglist
    )
/*++

Routine Description:

    Writes a formatted output string to the debug log

Arguments:

    LogHandle -- Handle to the open log

    OpenLogThreadId -- The ID of the thread (obtained from
        GetCurrentThreadId) that explicitly opened the log.
        If not equal to the current thread ID, the current
        thread ID will be output in the log.

    Format -- printf style format string

    arglist -- List of arguments to dump

Return Value:

    None

--*/
{
    char OutputBuffer[2049];
    ULONG length;
    DWORD BytesWritten;
    SYSTEMTIME SystemTime;
    static BeginningOfLine = TRUE;

    //
    // If we don't have an open log file, just bail
    //
    if ( LogHandle == NULL ) {

        return;
    }

    EnterCriticalSection( &NetpLogCritSect );

    length = 0;

    //
    // Handle the beginning of a new line.
    //
    //

    if ( BeginningOfLine ) {

        //
        // Put the timestamp at the begining of the line.
        //
        GetLocalTime( &SystemTime );
        length += (ULONG) sprintf( &OutputBuffer[length],
                                   "%02u/%02u %02u:%02u:%02u ",
                                   SystemTime.wMonth,
                                   SystemTime.wDay,
                                   SystemTime.wHour,
                                   SystemTime.wMinute,
                                   SystemTime.wSecond );

        //
        // If the current thread is not the one which opened
        //  the log, output the current thread ID
        //
        if ( OpenLogThreadId != NULL ) {
            DWORD CurrentThreadId = GetCurrentThreadId();
            if ( CurrentThreadId != *OpenLogThreadId ) {
                length += sprintf(&OutputBuffer[length], "[%08lx] ", CurrentThreadId);
            }
        }
    }

    //
    // Put the information requested by the caller onto the line
    //
    length += (ULONG) vsprintf(&OutputBuffer[length], Format, arglist);
    BeginningOfLine = (length > 0 && OutputBuffer[length-1] == '\n' );
    if ( BeginningOfLine ) {

        OutputBuffer[length-1] = '\r';
        OutputBuffer[length] = '\n';
        OutputBuffer[length+1] = '\0';
        length++;
    }

    ASSERT( length <= sizeof( OutputBuffer ) / sizeof( CHAR ) );


    //
    // Write the debug info to the log file.
    //
    if ( LogHandle ) {

        if ( !WriteFile( LogHandle,
                         OutputBuffer,
                         length,
                         &BytesWritten,
                         NULL ) ) {

            NetpKdPrint((PREFIX_NETLIB "Log write of %s failed with %lu\n",
                             OutputBuffer,
                             GetLastError() ));
        }
    } else {

        NetpKdPrint((PREFIX_NETLIB "[LOGWRITE]%s\n", OutputBuffer));

    }

    LeaveCriticalSection( &NetpLogCritSect );
}


VOID
NetpLogPrintRoutine(
    IN HANDLE LogHandle,
    IN LPSTR Format,
    ...
    )
/*++

Routine Description:

    Writes a formatted output string to the debug log

Arguments:

    LogHandle -- Handle to the open log

    Format -- printf style format string

    ... -- List of arguments to dump

Return Value:

    None

--*/
{
    va_list arglist;

    if ( !LogHandle )
    {
        return;
    }

    va_start(arglist, Format);

    NetpLogPrintRoutineV(LogHandle, Format, arglist);

    va_end(arglist);
}

VOID
NetpLogPrintRoutineVEx(
    IN HANDLE LogHandle,
    IN PDWORD OpenLogThreadId OPTIONAL,
    IN LPSTR Format,
    IN va_list arglist
    )
/*++

Routine Description:

    Writes a formatted output string to the debug log

Arguments:

    LogHandle -- Handle to the open log

    OpenLogThreadId -- The ID of the thread (obtained from
        GetCurrentThreadId) that explicitly opened the log.
        If not equal to the current thread ID, the current
        thread ID will be output in the log.

    Format -- printf style format string

    arglist -- List of arguments to dump

Return Value:

    None

--*/
{
    if ( !LogHandle )
    {
        return;
    }

    EnterCriticalSection( &NetpLogCritSect );

    NetpDebugDumpRoutine( LogHandle, OpenLogThreadId, Format, arglist );

    LeaveCriticalSection( &NetpLogCritSect );
}

VOID
NetpLogPrintRoutineV(
    IN HANDLE LogHandle,
    IN LPSTR Format,
    IN va_list arglist
    )
/*++

Routine Description:

    Writes a formatted output string to the debug log

Arguments:

    LogHandle -- Handle to the open log

    Format -- printf style format string

    arglist -- List of arguments to dump

Return Value:

    None

--*/
{
    NetpLogPrintRoutineVEx( LogHandle, NULL, Format, arglist );
}

VOID
NetpResetLog(
    IN HANDLE LogHandle
    )
/*++

Routine Description:

    Seeks to the end of the log file

Arguments:

    LogHandle -- Handle to the open log

Returns:

    ERROR_SUCCESS - Success

--*/
{

    if ( LogHandle ) {

        if( SetFilePointer( LogHandle,
                            0, 0,
                            FILE_END ) == 0xFFFFFFFF ) {

            NetpKdPrint((PREFIX_NETLIB "Seek to end of debug log failed with %lu\n",
                         GetLastError() ));
        }

    }

    return;

}

VOID
NetpCloseDebugFile(
    IN HANDLE LogHandle
    )
/*++

Routine Description:

    Closes the output log

Arguments:

    LogHandle -- Handle to the open log

Return Value:

    None

--*/
{
    if ( LogHandle ) {

        if( FlushFileBuffers( LogHandle ) == FALSE ) {

            NetpKdPrint((PREFIX_NETLIB "Flush of debug log failed with %lu\n",
                         GetLastError() ));
        }

        CloseHandle( LogHandle );

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\disp.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    Disp.c

Abstract:

    This file contains routines which display low-level data items in
    a consistent manner.  The output is done in a fixed-width-column
    fashion, similar to some of the NET.EXE outputs.  These routines are
    part of the RxTest program.

Author:

    John Rogers (JohnRo) 03-May-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    03-May-1991 JohnRo
        Created.
    15-May-1991 JohnRo
        Prevent possible errors in DisplayString if string has % in it.
        Added DisplayWord(), DisplayWordHex().
    13-Jun-1991 JohnRo
        Moved from RxTest to NetLib; changed routine names.
    05-Jul-1991 JohnRo
        Avoid FORMAT_WORD name (used by MIPS header files).
    10-Sep-1991 JohnRo
        Made changes suggested by PC-LINT.  (LmCons.h isn't needed.)
    13-Sep-1991 JohnRo
        Use LPDEBUG_STRING instead of LPTSTR, to avoid UNICODE problems.
    07-Jan-1992 JohnRo
        Added NetpDbgDisplayTStr() and NetpDbgDisplayWStr().
    19-Jul-1992 JohnRo
        RAID 464 (old RAID 10324): net print vs. UNICODE.
    17-Aug-1992 JohnRo
        RAID 2920: Support UTC timezone in net code.
    05-Jan-1993 JohnRo
        Repl WAN support (get rid of repl name list limits).
        Avoid stack overflow on very long strings.

--*/


// These must be included first:

#include <windef.h>             // IN, DWORD, etc.

// These may be included in any order:

#include <netdebug.h>           // FORMAT_ equates, NetpDbg routines.
#include <tstr.h>       // STRCAT(), ULTOA(), etc.


// NT debug routines seem to die at around 255 chars.
#define PARTIAL_NAME_LIST_LEN           250
#define PARTIAL_NAME_LIST_FORMAT_A  "%-.250s"
#define PARTIAL_NAME_LIST_FORMAT_W  "%-.250ws"


#define EMPTY_STRING       "(none)"

#define FIXED_WIDTH_STRING         "%-30s: "
#define PARTIAL_FIXED_WIDTH_STRING "%-20s (partial): "

#define INDENT "  "


#if DBG


DBGSTATIC VOID
NetpDbgDisplayTagForPartial(
    IN LPDEBUG_STRING Tag
    );


DBGSTATIC VOID
NetpDbgDisplayAnyStringType(
    IN LPDEBUG_STRING Tag,
    IN LPVOID Value,
    IN BOOL InputIsUnicode
    )
{
    LPDEBUG_STRING Format;
    DWORD ValueLength;

    if (Value != NULL) {

        if (InputIsUnicode) {
            ValueLength = wcslen( Value );
            Format = FORMAT_LPWSTR;
        } else {
            ValueLength = strlen( Value );
            Format = FORMAT_LPSTR;
        }

        if ( ValueLength < PARTIAL_NAME_LIST_LEN ) {   // normal

            NetpDbgDisplayTag( Tag );
            NetpKdPrint(( Format, Value ));

        } else {  // string too long; just display partial...

            NetpDbgDisplayTagForPartial( Tag );

            if (InputIsUnicode) {
                Format = PARTIAL_NAME_LIST_FORMAT_W;
            } else {
                Format = PARTIAL_NAME_LIST_FORMAT_A;
            }

            NetpKdPrint(( Format, Value ));  // print truncated version
        }
    } else {

        NetpDbgDisplayTag( Tag );
        NetpKdPrint(( EMPTY_STRING ));
    }

    NetpKdPrint(( "\n" ));

} // NetpDbgDisplayAnyStringType


#endif // DBG

#undef NetpDbgDisplayDword

VOID
NetpDbgDisplayDword(
    IN LPDEBUG_STRING Tag,
    IN DWORD Value
    )
{

#if DBG
    NetpDbgDisplayTag( Tag );
    NetpKdPrint((FORMAT_DWORD, Value));
    NetpKdPrint(("\n"));
#endif // DBG

} // NetpDbgDisplayDword

#if DBG

VOID
NetpDbgDisplayLong(
    IN LPDEBUG_STRING Tag,
    IN LONG Value
    )
{
    NetpDbgDisplayTag( Tag );
    NetpKdPrint((FORMAT_LONG, Value));
    NetpKdPrint(("\n"));

} // NetpDbgDisplayLong


VOID
NetpDbgDisplayString(
    IN LPDEBUG_STRING Tag,
    IN LPTSTR Value
    )
{
    NetpDbgDisplayAnyStringType(
            Tag,
            Value,
#ifndef UNICODE
            FALSE );                    // input is not UNICODE
#else
            TRUE );                     // input is UNICODE
#endif


} // NetpDbgDisplayString


VOID
NetpDbgDisplayTag(
    IN LPDEBUG_STRING Tag
    )
{
    NetpAssert( Tag != NULL );
    NetpKdPrint((INDENT FIXED_WIDTH_STRING, Tag));

} // NetpDbgDisplayTag


DBGSTATIC VOID
NetpDbgDisplayTagForPartial(
    IN LPDEBUG_STRING Tag
    )
{
    NetpAssert( Tag != NULL );
    NetpKdPrint(( INDENT PARTIAL_FIXED_WIDTH_STRING, Tag ));

} // NetpDbgDisplayTagForPartial


#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\disptime.c ===
/*++

Copyright (c) 1991-1993 Microsoft Corporation

Module Name:

    DispTime.c

Abstract:

    This file contains;

        NetpDbgDisplayFileTime
        NetpDbgDisplayFileIntegerTime
        NetpDbgDisplayTimestamp
        NetpDbgDisplayTod

Author:

    John Rogers (JohnRo) 25-Mar-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

    This code assumes that time_t is expressed in seconds since 1970 (GMT).
    ANSI C does not require this, although POSIX (IEEE 1003.1) does.

Revision History:

    25-Mar-1991 JohnRo
        Created as part of RpcXlate TOD (time of day) tests.
    26-Feb-1992 JohnRo
        Extracted this routine for general use.
    27-Feb-1992 JohnRo
        Improved handling of times 0 and -1.
    20-Aug-1992 JohnRo
        RAID 2920: Support UTC timezone in net code.
    01-Oct-1992 JohnRo
        RAID 3556: Avoid failure if ctime() returns NULL.
    04-Mar-1993 JohnRo
        RAID 12237: replicator tree depth exceeded (add display of FILETIME
        and LARGE_INTEGER time).
    16-Apr-1993 JohnRo
        Fixed infinite loop in NetpDbgDisplayFileTime().

--*/


// These must be included first:

#include <nt.h>         // NtOpenFile(), ULONG, etc.
#include <ntrtl.h>      // PLARGE_INTEGER, TIME_FIELDS, etc.
#include <nturtl.h>     // Needed for ntrtl.h and windows.h to co-exist.

#include <windows.h>    // GetLastError(), LPFILETIME, CompareFileTime(), etc.
#include <windef.h>     // IN, DWORD, etc.
#include <lmcons.h>     // NET_API_STATUS, etc.

// These may be included in any order:

#include <lmremutl.h>   // LPTIME_OF_DAY_INFO.
#include <netdebug.h>   // My prototypes, NetpAssert(), FORMAT_ equates, etc.
#include <string.h>     // strlen().
#include <time.h>       // ctime().


#undef NetpDbgDisplayTimestamp
VOID
NetpDbgDisplayTimestamp(
    IN LPDEBUG_STRING Tag,
    IN DWORD Time               // Seconds since 1970.
    )
{
#if DBG
    NetpAssert( Tag != NULL );

    if (Time == 0) {

        NetpDbgDisplayDword( Tag, (DWORD) 0 );

    } else if (Time == (DWORD) -1) {

        NetpDbgDisplayString( Tag, TEXT("-1") );

    } else {
        LPSTR TimeStringPtr;

        NetpAssert( sizeof(time_t) == sizeof(DWORD) );

        TimeStringPtr = (LPSTR) ctime( (time_t *) &Time );
        if (TimeStringPtr == NULL) {
                         //  1234567890123456789012345
            TimeStringPtr = "*********INVALID********\n";
        }

        NetpDbgDisplayTag( Tag );
        // TimeStringPtr points to str ending with "\n\0".
        NetpAssert( strlen(TimeStringPtr) == 25 );  // string is
        NetpKdPrint(( "%24s  (" FORMAT_DWORD ")\n", TimeStringPtr, Time ));
    }
#endif // DBG

}

#undef NetpDbgDisplayTod
VOID
NetpDbgDisplayTod(
    IN LPDEBUG_STRING Tag,
    IN LPVOID TimePtr           // LPTIME_OF_DAY_INFO.
    )
{
#if DBG
    LPTIME_OF_DAY_INFO Tod = TimePtr;

    NetpAssert( Tag != NULL );
    NetpAssert( Tod != NULL );

    NetpKdPrint(( "  " FORMAT_LPDEBUG_STRING "\n", Tag ));

    NetpDbgDisplayTimestamp( "    (from elapsed time)", Tod->tod_elapsedt );

    NetpDbgDisplayTag( "    (from other fields)" );
    NetpKdPrint((
            "%04ld-%02ld-%02ld %02ld:%02ld:%02ld\n",
            Tod->tod_year, Tod->tod_month, Tod->tod_day,
            Tod->tod_hours, Tod->tod_mins, Tod->tod_secs ));

    NetpDbgDisplayLong( "    (timezone)", Tod->tod_timezone );
#endif // DBG

} // NetpDbgDisplayTod
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\fileinfo.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    FileInfo.c

Abstract:

    This file contains NetpFileStructureInfo().

Author:

    John Rogers (JohnRo) 15-Aug-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    15-Aug-1991 JohnRo
        Implement downlevel NetFile APIs.
    20-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.
    13-Dec-1991 JohnRo
        Quiet debug output by default.

--*/

// These must be included first:

#include <windef.h>             // IN, DWORD, etc.
#include <lmcons.h>             // LM20_ equates, NET_API_STATUS, etc.
#include <rap.h>                // LPDESC, needed by <strucinf.h>.

// These may be included in any order:

#include <lmerr.h>              // ERROR_ and NERR_ equates.
#include <lmshare.h>            // FILE_INFO_2, etc.
#include <netlib.h>             // NetpSetOptionalArg().
#include <netdebug.h>           // NetpAssert().
#include <remdef.h>             // REM16_, REM32_, REMSmb_ equates.
#include <strucinf.h>           // My prototype.


#define MAX_FILE_2_STRING_LENGTH \
        (0)
#define MAX_FILE_2_STRING_SIZE \
        (MAX_FILE_2_STRING_LENGTH * sizeof(TCHAR))
#define MAX_FILE_2_TOTAL_SIZE \
        (MAX_FILE_2_STRING_SIZE + sizeof(FILE_INFO_2))

#define MAX_FILE_3_STRING_LENGTH \
        (LM20_PATHLEN+1 + LM20_UNLEN+1)
#define MAX_FILE_3_STRING_SIZE \
        (MAX_FILE_3_STRING_LENGTH * sizeof(TCHAR))
#define MAX_FILE_3_TOTAL_SIZE \
        (MAX_FILE_3_STRING_SIZE + sizeof(FILE_INFO_3))


NET_API_STATUS
NetpFileStructureInfo (
    IN DWORD Level,
    IN DWORD ParmNum,  // Use PARMNUM_ALL if not applicable.
    IN BOOL Native,    // Should sizes be native or RAP?
    OUT LPDESC * DataDesc16 OPTIONAL,
    OUT LPDESC * DataDesc32 OPTIONAL,
    OUT LPDESC * DataDescSmb OPTIONAL,
    OUT LPDWORD MaxSize OPTIONAL,
    OUT LPDWORD FixedSize OPTIONAL,
    OUT LPDWORD StringSize OPTIONAL
    )

{
    DBG_UNREFERENCED_PARAMETER(ParmNum);

    NetpAssert( Native );

    //
    // Decide what to do based on the info level.
    //
    switch (Level) {

#define SetSizes(fixed,variable) \
    { \
        NetpSetOptionalArg( MaxSize, (fixed) + (variable) ); \
        NetpSetOptionalArg( FixedSize, (fixed) ); \
        NetpSetOptionalArg( StringSize, (variable) ); \
    }

    case 2 :
        NetpSetOptionalArg( DataDesc16, REM16_file_info_2 );
        NetpSetOptionalArg( DataDesc32, REM32_file_info_2 );
        NetpSetOptionalArg( DataDescSmb, REMSmb_file_info_2 );
        SetSizes( sizeof(FILE_INFO_2), MAX_FILE_2_STRING_SIZE );
        break;

    case 3 :
        NetpSetOptionalArg( DataDesc16, REM16_file_info_3 );
        NetpSetOptionalArg( DataDesc32, REM32_file_info_3 );
        NetpSetOptionalArg( DataDescSmb, REMSmb_file_info_3 );
        SetSizes( sizeof(FILE_INFO_3), MAX_FILE_3_STRING_SIZE );
        break;

    default :
        return (ERROR_INVALID_LEVEL);
    }

    return (NERR_Success);

} // NetpFileStructureInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\dnssrv.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dnssrv.c

Abstract:

    Routines for processing SRV DNS records per RFC 2052.

Author:

    Cliff Van Dyke (cliffv) 28-Feb-1997

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/


//
// Common include files.
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <stdlib.h>     // qsort

#include <align.h>
#include <lmcons.h>     // General net defines
#include <winsock2.h>
#include <dnsapi.h>
#include <dnssrv.h>
#ifdef WIN32_CHICAGO
#include "ntcalls.h"
#endif // WIN32_CHICAGO


//
// Context describing the SRV records for a DNS name.
//
typedef struct _NETP_SRV_CONTEXT {

    //
    // Flags to pass to DNS Query.
    //

    ULONG DnsQueryFlags;

    //
    // Complete list of DNS records as returned from DnsQuery.
    //
    PDNS_RECORD DnsRecords;

    //
    // List of A DNS records
    //
    PDNS_RECORD ADnsRecords;

    //
    // The current priority that is being processed.
    //
    ULONG CurrentPriority;

    //
    // Sum of the weights of all the SRV records at the current priority.
    //
    ULONG TotalWeight;

    //
    // Index into SrvRecordArray of the next SRV record to be processed.
    //
    ULONG Index;

    //
    // Number of SrvRecords
    //
    ULONG SrvRecordCount;
    //
    // Array of DNS SRV records.
    //
    PDNS_RECORD SrvRecordArray[1];
    // This field must be the last field in the structure.

} NETP_SRV_CONTEXT, *PNETP_SRV_CONTEXT;

#if DNS_DEBUG
#include <stdio.h>
#define DnsPrint(_x_) printf _x_
#else // DNS_DEBUG
#define DnsPrint(_x_)
#endif // DNS_DEBUG



//
// Globals for doing random number generation.
//

ULONG NetpSrvSeed;
BOOLEAN NetpSrvRandomInitialized;

ULONG
__cdecl
NetpSrvComparePriority(
    const void * Param1,
    const void * Param2
    )
/*++

Routine Description:

    qsort/bsearch comparison routine for an array of SRV PDNS_RECORDs

Arguments:

Return Value:

--*/
{
    const PDNS_RECORD DnsRecord1 = *((PDNS_RECORD *)Param1);
    const PDNS_RECORD DnsRecord2 = *((PDNS_RECORD *)Param2);

    return DnsRecord1->Data.SRV.wPriority - DnsRecord2->Data.SRV.wPriority;
}


NET_API_STATUS
NetpSrvOpen(
    IN LPSTR DnsRecordName,
    IN DWORD DnsQueryFlags,
    OUT PHANDLE RetSrvContext
    )
/*++

Routine Description:

    Read the specified SRV record from DNS.

Arguments:

    DnsRecordName - DNS name of the SRV record to lookup

    DnsQueryFlags - Flags to pass to DNS query

    RetSrvContext - Returns an opaque context describing the SRV record.
        This context must be freed using NetpSrvClose.

Return Value:

    Status of the operation.

    NO_ERROR: SrvContext was returned successfully.

--*/

{
    NET_API_STATUS NetStatus;
    PNETP_SRV_CONTEXT SrvContext = NULL;
    PDNS_RECORD DnsRecords = NULL;
    PDNS_RECORD DnsRecord;
    PDNS_RECORD ADnsRecords = NULL;
    ULONG SrvRecordCount;
    ULONG SrvPriority;
    BOOLEAN SortByPriority = FALSE;
    ULONG Index;

    //
    // Seed the random number generator if it needs to be.
    //

    if ( !NetpSrvRandomInitialized ) {

#ifndef WIN32_CHICAGO
        union {
            LARGE_INTEGER time;
            UCHAR bytes[8];
        } u;
#else // WIN32_CHICAGO
        union {
            TimeStamp time;
            UCHAR bytes[8];
        } u;
#endif // WIN32_CHICAGO

        NetpSrvRandomInitialized = TRUE;

        (VOID) NtQuerySystemTime( &u.time );
        NetpSrvSeed = ((u.bytes[1] + 1) <<  0) |
               ((u.bytes[2] + 0) <<  8) |
               ((u.bytes[2] - 1) << 16) |
               ((u.bytes[1] + 0) << 24);
    }


    //
    // Initialization
    //

    *RetSrvContext = NULL;

    //
    // Get the SRV record from DNS.
    //

    NetStatus = DnsQuery_UTF8( DnsRecordName,
                            DNS_TYPE_SRV,
                            DnsQueryFlags,
                            NULL,   // No list of DNS servers
                            &DnsRecords,
                            NULL );

    if ( NetStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Count the number of Srv records returned
    //
    // The array returned is several SRV records followed by several A records.
    //

    SrvRecordCount = 0;
    SrvPriority = DnsRecords->Data.SRV.wPriority;
    for ( DnsRecord = DnsRecords;
          DnsRecord != NULL;
          DnsRecord = DnsRecord->pNext ) {

        if ( DnsRecord->wType == DNS_TYPE_SRV ) {
            SrvRecordCount ++;

            //
            // A zero weight is equivalent to a weight of one.
            //

            if ( DnsRecord->Data.SRV.wWeight == 0 ) {
                DnsRecord->Data.SRV.wWeight = 1;
            }

            //
            // Check if more than one priority is available.
            //

            if ( DnsRecord->Data.SRV.wPriority != SrvPriority ) {
                SortByPriority = TRUE;
            }

        } else if ( DnsRecord->wType == DNS_TYPE_A ) {
            ADnsRecords = DnsRecord;
            break;
        }
    }


    //
    // Allocate a context
    //

    SrvContext = LocalAlloc( LMEM_ZEROINIT,
                             sizeof(NETP_SRV_CONTEXT) +
                                SrvRecordCount * sizeof(PDNS_RECORD) );

    if ( SrvContext == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Fill in the context.
    //

    SrvContext->DnsRecords = DnsRecords;
    DnsRecords = NULL;
    SrvContext->SrvRecordCount = SrvRecordCount;
    SrvContext->ADnsRecords = ADnsRecords;
    SrvContext->DnsQueryFlags = DnsQueryFlags;

    //
    // Convert the linked list to an array.
    //

    Index = 0;
    for ( DnsRecord = SrvContext->DnsRecords;
          DnsRecord != NULL;
          DnsRecord = DnsRecord->pNext ) {

        if ( DnsRecord->wType == DNS_TYPE_SRV ) {
            SrvContext->SrvRecordArray[Index] = DnsRecord;
            Index++;
        } else if ( DnsRecord->wType == DNS_TYPE_A ) {
            break;
        }
    }

    //
    // Sort the array of SRV records into priority order.
    //

    if ( SortByPriority ) {
        qsort( SrvContext->SrvRecordArray,
               SrvContext->SrvRecordCount,
               sizeof(PDNS_RECORD),
               NetpSrvComparePriority );

    }

    //
    // Indicate that we're at the start of the list.
    //

    SrvContext->CurrentPriority = 0xFFFFFFFF;   // Invalid Priority
    SrvContext->Index = 0;


    //
    // Return the context to the caller.
    //

    *RetSrvContext = SrvContext;
    NetStatus = NO_ERROR;

    //
    // Cleanup
    //
Cleanup:
    if ( NetStatus != NO_ERROR ) {
        if ( SrvContext != NULL ) {
            NetpSrvClose( SrvContext );
        }
    }
    if ( DnsRecords != NULL ) {
            DnsRecordListFree(
                DnsRecords,
                DnsFreeRecordListDeep );
    }
    return NetStatus;
}


NET_API_STATUS
NetpSrvProcessARecords(
    IN PDNS_RECORD DnsARecords,
    IN LPSTR DnsHostName OPTIONAL,
    IN ULONG Port,
    OUT PULONG SockAddressCount,
    OUT LPSOCKET_ADDRESS *SockAddresses
    )
/*++

Routine Description:

    Returns the next logical SRV record for the name opened by NetpSrvOpen.
    The returned record takes into account the weights and priorities specified
    in the SRV records.

Arguments:

    DnsARecords - A list of DNS A records that may (or may not) be for the
        host in question.

    DnsHostName - DNS Host name of the host to return A records for.
        If null, all A records are to be used.
        (Passing NULL seems bogus.  Perhaps this routine should mandate that the matched
        A records are in the "answer" section.)

    Port - Port number to return in the SockAddress structures.

    SockAddressCount - Returns the number of Addresses in SockAddresses.
        If NULL, addresses will not be looked up.

    SockAddresses - Returns an array SOCKET_ADDRESS structures for the server.
        The returned sin_port field contains port from the SRV record.
        This buffer should be freed using LocalFree().

Return Value:

    NO_ERROR: IpAddresses were returned

    DNS_ERROR_RCODE_NAME_ERROR: No A records are available.


--*/
{
    ULONG RecordCount;
    ULONG ByteCount;

    PDNS_RECORD DnsRecord;

    LPBYTE Where;
    PSOCKADDR_IN SockAddr;
    ULONG Size;

    LPSOCKET_ADDRESS LocalSockAddresses = NULL;

    //
    // Count the A and AAAA records.
    //

    RecordCount = 0;
    ByteCount = 0;
    for ( DnsRecord = DnsARecords;
          DnsRecord != NULL;
          DnsRecord = DnsRecord->pNext ) {

        if ( ( DnsRecord->wType == DNS_TYPE_A ||
               DnsRecord->wType == DNS_TYPE_AAAA ) &&
             ( DnsHostName == NULL ||
               DnsNameCompare_UTF8(DnsHostName, (LPSTR)DnsRecord->pName) ) ) {

            RecordCount ++;
            ByteCount += sizeof(SOCKET_ADDRESS);
            if ( DnsRecord->wType == DNS_TYPE_A ) {
                ByteCount += sizeof(SOCKADDR_IN);
            } else {
                ByteCount += sizeof(SOCKADDR_IN)+16;  // Originally guess large
                // ByteCount += sizeof(SOCKADDR_IN6); // ?? not checked in yet
            }
            ByteCount = ROUND_UP_COUNT( ByteCount, ALIGN_WORST );
        }

    }

    //
    // If there are no matching records,
    //  tell the caller.
    //

    if ( RecordCount == 0 ) {
        return DNS_ERROR_RCODE_NAME_ERROR;
    }


    //
    // Allocate the return buffer.
    //

    LocalSockAddresses = LocalAlloc( 0, ByteCount );

    if ( LocalSockAddresses == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    Where = ((LPBYTE)LocalSockAddresses)+ RecordCount * sizeof(SOCKET_ADDRESS);

    //
    // Copy the Addresses into the allocated buffer.
    //

    RecordCount = 0;
    for ( DnsRecord = DnsARecords;
          DnsRecord != NULL;
          DnsRecord = DnsRecord->pNext ) {

        // ?? Until I really know how to translate.
        if ( DnsRecord->wType == DNS_TYPE_AAAA ) {
            continue;
        }

        if ( (DnsRecord->wType == DNS_TYPE_A ||
              DnsRecord->wType == DNS_TYPE_AAAA ) &&
             ( DnsHostName == NULL ||
               DnsNameCompare_UTF8( DnsHostName, (LPSTR)DnsRecord->pName ) ) ) {

            SockAddr = (PSOCKADDR_IN) Where;
            LocalSockAddresses[RecordCount].lpSockaddr = (LPSOCKADDR) SockAddr;


            if ( DnsRecord->wType == DNS_TYPE_A ) {

                Size = sizeof(SOCKADDR_IN);
                RtlZeroMemory( Where, Size );   // Allow addresses to be compared

                SockAddr->sin_family = AF_INET;
                SockAddr->sin_port = htons((WORD)Port);
                SockAddr->sin_addr.S_un.S_addr = DnsRecord->Data.A.IpAddress;

            } else {
                SockAddr->sin_family = AF_INET6;

                Size = sizeof(SOCKADDR_IN)+16;  // Originally guess large
                // Size = sizeof(SOCKADDR_IN6); // ?? not checked in yet
                // ??
            }


            LocalSockAddresses[RecordCount].iSockaddrLength = Size;
            Where += ROUND_UP_COUNT(Size, ALIGN_WORST);

            RecordCount ++;
        }

    }

    *SockAddressCount = RecordCount;
    *SockAddresses = LocalSockAddresses;
    return NO_ERROR;
}

NET_API_STATUS
NetpSrvNext(
    IN HANDLE SrvContextHandle,
    OUT PULONG SockAddressCount OPTIONAL,
    OUT LPSOCKET_ADDRESS *SockAddresses OPTIONAL,
    OUT LPSTR *DnsHostName OPTIONAL
    )
/*++

Routine Description:

    Returns the next logical SRV record for the name opened by NetpSrvOpen.
    The returned record takes into account the weights and priorities specified
    in the SRV records.

Arguments:

    SrvContextHandle - An opaque context describing the SRV records.

    SockAddressCount - Returns the number of Addresses in SockAddresses.
        If NULL, addresses will not be looked up.

    SockAddresses - Returns an array SOCKET_ADDRESS structures for the server.
        The returned sin_port field contains port from the SRV record.
        This buffer should be freed using LocalFree().

    DnsHostName - Returns a pointer to the DnsHostName in the SRV record.
        This buffer need not be freed.
        The buffer is valid until the call to NetpSrvClose.

Return Value:

    NO_ERROR: IpAddresses were returned

    ERROR_NO_MORE_ITEMS: No more SRV records are available.

    Any other errors returned are those detected while trying to find the A
        records associated with the host of the SRV record.  The caller can
        note the error (perhaps so the caller can return this status to
        his caller if no usefull server was found) then call NetpSrvNext
        again to get the next SRV record.  The caller can inspect this error
        and return immediately if the caller deems the error serious.

    The following interesting errors might be returned:

    DNS_ERROR_RCODE_NAME_ERROR: No A records are available for this SRV record.


--*/
{
    NET_API_STATUS NetStatus = NO_ERROR;

    PNETP_SRV_CONTEXT SrvContext = (PNETP_SRV_CONTEXT) SrvContextHandle;
    PDNS_RECORD *DnsArray;
    PDNS_RECORD SrvDnsRecord;
    PDNS_RECORD DnsARecords = NULL;

    ULONG Index;
    ULONG RandomWeight;
    ULONG PreviousWeights;

    //
    // If we're at the end of the list,
    //  tell the caller.
    //

    if ( SrvContext->Index >= SrvContext->SrvRecordCount ) {
        return ERROR_NO_MORE_ITEMS;
    }

    //
    // If we're at the end of a priority,
    //  computes the collective weights for the next priority.
    //

    DnsArray = SrvContext->SrvRecordArray;
    if ( DnsArray[SrvContext->Index]->Data.SRV.wPriority != SrvContext->CurrentPriority ) {

        //
        // Set the current priority.
        //

        SrvContext->CurrentPriority = DnsArray[SrvContext->Index]->Data.SRV.wPriority;

        //
        // Loop through all of the entries for this priority adding up the weight.
        //
        // This won't overflow since we're adding USHORTs into a ULONG.
        //

        SrvContext->TotalWeight = 0;
        for ( Index=SrvContext->Index; Index<SrvContext->SrvRecordCount; Index++ ) {
           if ( DnsArray[Index]->Data.SRV.wPriority == SrvContext->CurrentPriority ) {
               SrvContext->TotalWeight += DnsArray[Index]->Data.SRV.wWeight;
           }
        }

    }


    //
    // Pick one of the records at weighted random.
    //

    RandomWeight = (RtlUniform( &NetpSrvSeed ) % SrvContext->TotalWeight) + 1;
    DnsPrint(( "%ld in %ld chance\n", RandomWeight, SrvContext->TotalWeight ));

    PreviousWeights = 0;
    for ( Index=SrvContext->Index; Index<SrvContext->SrvRecordCount; Index++ ) {
       ASSERTMSG( NULL, DnsArray[Index]->Data.SRV.wPriority == SrvContext->CurrentPriority );

       PreviousWeights += DnsArray[Index]->Data.SRV.wWeight;
       DnsPrint(( "  Prev %ld %s\n", PreviousWeights, DnsArray[Index]->Data.SRV.pNameTarget ));

       //
       // If the randomly picked weight includes this entry,
       //   use this entry.
       //

       if ( PreviousWeights >= RandomWeight ) {

           //
           // Move the picked entry to the current position in the array.
           //

           if ( Index != SrvContext->Index ) {
               PDNS_RECORD TempDnsRecord;

               TempDnsRecord = DnsArray[Index];
               DnsArray[Index] = DnsArray[SrvContext->Index];
               DnsArray[SrvContext->Index] = TempDnsRecord;

           }

           break;
       }
    }

    //
    // Move to the next entry for the next iteration.
    //
    // TotalWeight is the total weight of the remaining records
    // for this priority.
    //
    SrvDnsRecord = DnsArray[SrvContext->Index];
    SrvContext->TotalWeight -= SrvDnsRecord->Data.SRV.wWeight;
    SrvContext->Index ++;
    if ( ARGUMENT_PRESENT( DnsHostName )) {
        *DnsHostName = (LPSTR) SrvDnsRecord->Data.SRV.pNameTarget;
    }

    //
    // If the caller isn't interested in socket addresses,
    //  we are done.
    //

    if ( SockAddresses == NULL || SockAddressCount == NULL ) {
        goto Cleanup;
    }

    //
    // If A records were returned along with the SRV records,
    //  see if the A records for this host were returned.
    //

    if ( SrvContext->ADnsRecords != NULL ) {
        NetStatus = NetpSrvProcessARecords( SrvContext->ADnsRecords,
                                            (LPSTR)SrvDnsRecord->Data.SRV.pNameTarget,
                                            SrvDnsRecord->Data.SRV.wPort,
                                            SockAddressCount,
                                            SockAddresses );

        if ( NetStatus != DNS_ERROR_RCODE_NAME_ERROR ) {
            goto Cleanup;
        }
    }

    //
    // Try getting the A records from DNS.
    //

    NetStatus = DnsQuery_UTF8(
                            (LPSTR) SrvDnsRecord->Data.SRV.pNameTarget,
                            DNS_TYPE_A,
                            // Indicate the name is fully quealified to avoid name devolution
                            SrvContext->DnsQueryFlags | DNS_QUERY_TREAT_AS_FQDN,
                            NULL,   // No list of DNS servers
                            &DnsARecords,
                            NULL );

    if ( NetStatus != NO_ERROR ) {
        //
        // Ignore the real status.  The SRV record might have a bogus host name.  We'd
        // rather ignore the SRV record and press on than error out early.
        //
        NetStatus = DNS_ERROR_RCODE_NAME_ERROR;
        goto Cleanup;
    }

    NetStatus = NetpSrvProcessARecords( DnsARecords,
                                        (LPSTR)SrvDnsRecord->Data.SRV.pNameTarget,
                                        SrvDnsRecord->Data.SRV.wPort,
                                        SockAddressCount,
                                        SockAddresses );


Cleanup:
    if ( DnsARecords != NULL ) {
        DnsRecordListFree(
            DnsARecords,
            DnsFreeRecordListDeep );
    }
    return NetStatus;

}


VOID
NetpSrvClose(
    IN HANDLE SrvContextHandle
    )
/*++

Routine Description:

    Free the context allocated by NetpSrvOpen

Arguments:

    SrvContextHandle - An opaque context describing the SRV records.

Return Value:

    Status of the operation.

    NO_ERROR: SrvContext was returned successfully.

--*/

{
    PNETP_SRV_CONTEXT SrvContext = (PNETP_SRV_CONTEXT) SrvContextHandle;

    if ( SrvContext != NULL ) {

        //
        // Free the RR set.
        //

        DnsRecordListFree(
            SrvContext->DnsRecords,
            DnsFreeRecordListDeep );

        //
        // Free the context itself
        //
        LocalFree( SrvContext );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\domainid.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    DomainId.c

Abstract:

    This file contains NetpGetLocalDomainId().  This will eventually
    replace NetpGetDomainId().

Author:

    John Rogers (JohnRo) 06-May-1992

Environment:

    Interface is portable to any flat, 32-bit environment.  (Uses Win32
    typedefs.)  Requires ANSI C extensions: slash-slash comments, long
    external names.  Code itself only runs under NT.

Revision History:

    06-May-1992 JohnRo
        Created.  (Borrowed most code from DanHi's SDKTools/AddUser/AddUser.c.
    08-May-1992 JohnRo
        Use <prefix.h> equates.
    09-Jun-1992 JohnRo
        RAID 10139: PortUAS should add to admin group/alias.

--*/


// These must be included first:

#include <nt.h>         // IN, LPVOID, etc.
#include <ntsam.h>
#include <ntlsa.h>
#include <ntrtl.h>
#include <nturtl.h>     // (Needed for ntrtl.h and windows.h to coexist.)
#include <windows.h>    // LocalAlloc(), LMEM_ equates, etc.
#include <lmcons.h>     // NET_API_STATUS, needed by <netlibnt.h>

// These may be included in any order:

#include <debuglib.h>   // IF_DEBUG().
#include <lmerr.h>      // NO_ERROR, ERROR_, and NERR_ equates.
#include <netdebug.h>   // NetpAssert, FORMAT_ equates, etc.
#include <netlib.h>     // LOCAL_DOMAIN_TYPE, my prototype.
#include <netlibnt.h>   // NetpNtStatusToApiStatus().
#include <prefix.h>     // PREFIX_ equates.


static SID_IDENTIFIER_AUTHORITY NetpBuiltinIdentifierAuthority
        = SECURITY_NT_AUTHORITY;


NET_API_STATUS
NetpGetLocalDomainId (
    IN LOCAL_DOMAIN_TYPE TypeWanted,
    OUT PSID *RetDomainId
    )

/*++

Routine Description:

    This routine obtains the domain id from LSA for the local domain.
    The routine is a superset of NetpGetDomainId().

Arguments:

    TypeWanted - Indicates which type of local domain ID is wanted:
        the primary one or the accounts one.

    RetDomainId - This is a pointer to the location where the pointer
        to the domain id is to be placed.  This must be freed via LocalFree().

Return Value:

    NERR_Success - If the operation was successful.

    It will return assorted Net or Win32 error messages if not.

--*/
{
    NET_API_STATUS ApiStatus;
    LSA_HANDLE LsaHandle = NULL;
    NTSTATUS NtStatus;
    LPVOID PolicyInfo = NULL;
    DWORD SidSize;

    if (RetDomainId == NULL) {
        ApiStatus = ERROR_INVALID_PARAMETER;
        goto cleanupandexit;
    }
    *RetDomainId = NULL;   // make error paths easy to code.

    //
    // The type of domain the caller wants determines the information class
    // we have to get LSA to deal with.  So use one to get the other.
    //
    switch (TypeWanted) {

    case LOCAL_DOMAIN_TYPE_ACCOUNTS : /*FALLTHROUGH*/
    case LOCAL_DOMAIN_TYPE_PRIMARY :
        {
            OBJECT_ATTRIBUTES ObjectAttributes;
            POLICY_INFORMATION_CLASS PolicyInfoClass;
            LPVOID SourceDomainId;

            if (TypeWanted == LOCAL_DOMAIN_TYPE_ACCOUNTS) {
                PolicyInfoClass = PolicyAccountDomainInformation;
            } else {
                PolicyInfoClass = PolicyPrimaryDomainInformation;
            }
            //
            // Get LSA to open its local policy database.
            //

            InitializeObjectAttributes( &ObjectAttributes, NULL, 0, 0, NULL );
            NtStatus = LsaOpenPolicy(
                    NULL,
                    &ObjectAttributes,
                    POLICY_VIEW_LOCAL_INFORMATION,
                    &LsaHandle);
            if ( !NT_SUCCESS(NtStatus)) {
                ApiStatus = NetpNtStatusToApiStatus( NtStatus );
                IF_DEBUG( DOMAINID ) {
                    NetpKdPrint((PREFIX_NETLIB "NetpGetLocalDomainId:\n"
                            "  Couldn't _open Lsa Policy database, nt status = "
                            FORMAT_NTSTATUS "\n", NtStatus));
                }
                NetpAssert( ApiStatus != NO_ERROR );
                goto cleanupandexit;
            }
            NetpAssert( LsaHandle != NULL );

            //
            // Get the appropriate domain SID from LSA
            //
            NtStatus = LsaQueryInformationPolicy(
                    LsaHandle,
                    PolicyInfoClass,
                    &PolicyInfo);
            if ( !NT_SUCCESS(NtStatus)) {
                ApiStatus = NetpNtStatusToApiStatus( NtStatus );
                IF_DEBUG( DOMAINID ) {
                    NetpKdPrint((PREFIX_NETLIB "NetpGetLocalDomainId:\n"
                            "  Couldn't query Lsa Policy database, nt status = "
                            FORMAT_NTSTATUS "\n", NtStatus));
                }
                NetpAssert( ApiStatus != NO_ERROR );
                goto cleanupandexit;
            }

            //
            // Find source domain ID in the appropriate structure.
            //
            if (TypeWanted == LOCAL_DOMAIN_TYPE_ACCOUNTS) {
                PPOLICY_ACCOUNT_DOMAIN_INFO PolicyAccountDomainInfo
                        = PolicyInfo;
                SourceDomainId = PolicyAccountDomainInfo->DomainSid;
                NetpAssert( SourceDomainId != NULL );
                NetpAssert( RtlValidSid( SourceDomainId ) );
            } else {

                PPOLICY_PRIMARY_DOMAIN_INFO PolicyPrimaryDomainInfo
                        = PolicyInfo;
                NetpAssert( TypeWanted == LOCAL_DOMAIN_TYPE_PRIMARY );
                SourceDomainId = PolicyPrimaryDomainInfo->Sid;
                if ( SourceDomainId != NULL ) {
                    NetpAssert( RtlValidSid( SourceDomainId ) );
                }
            }

            //
            // If there was a domain ID, copy it now
            //

            if (SourceDomainId != NULL) {

                //
                // Compute size and alloc destination SID.
                //

                NetpAssert( sizeof(ULONG) <= sizeof(DWORD) );

                SidSize = (DWORD) RtlLengthSid( SourceDomainId );
                NetpAssert( SidSize != 0 );

                *RetDomainId = LocalAlloc( LMEM_FIXED, SidSize );

                if ( *RetDomainId == NULL ) {
                    IF_DEBUG( DOMAINID ) {
                        NetpKdPrint((PREFIX_NETLIB "NetpGetLocalDomainId:\n"
                                "  not enough memory (need " FORMAT_DWORD
                                ")\n", SidSize));
                    }
                    ApiStatus = ERROR_NOT_ENOUGH_MEMORY;
                    goto cleanupandexit;
                }

                //
                // Copy the SID (domain ID).
                //

                NtStatus = RtlCopySid(
                        SidSize,            // dest size in bytes
                        *RetDomainId,       // dest sid
                        SourceDomainId);    // src sid
                if ( !NT_SUCCESS(NtStatus)) {
                    ApiStatus = NetpNtStatusToApiStatus( NtStatus );
                    IF_DEBUG( DOMAINID ) {
                        NetpKdPrint((PREFIX_NETLIB "NetpGetLocalDomainId:\n"
                                "  RtlCopySid failed, nt status = "
                                FORMAT_NTSTATUS "\n", NtStatus));
                    }
                    NetpAssert( ApiStatus != NO_ERROR );
                    goto cleanupandexit;
                }

                NetpAssert( RtlValidSid( SourceDomainId ) );
                NetpAssert( RtlEqualSid( SourceDomainId, *RetDomainId ) );
            } else {
                //
                // Just return the NULL domain id.
                //

                *RetDomainId = NULL;
            }

        }
        break;

    case LOCAL_DOMAIN_TYPE_BUILTIN :

#define SUBAUTHORITIES_FOR_BUILTIN_DOMAIN   1

        SidSize = (DWORD)
                RtlLengthRequiredSid( SUBAUTHORITIES_FOR_BUILTIN_DOMAIN );
        NetpAssert( SidSize != 0 );

        *RetDomainId = LocalAlloc( LMEM_FIXED, SidSize );

        if ( *RetDomainId == NULL ) {
            IF_DEBUG( DOMAINID ) {
                NetpKdPrint((PREFIX_NETLIB "NetpGetLocalDomainId:\n"
                        "  not enough memory (need " FORMAT_DWORD
                        ")\n", SidSize));
                }
            ApiStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto cleanupandexit;
        }

        NtStatus = RtlInitializeSid(
                *RetDomainId,                     // SID being built
                &NetpBuiltinIdentifierAuthority,  // identifier authority
                (UCHAR)SUBAUTHORITIES_FOR_BUILTIN_DOMAIN ); // subauth. count
        NetpAssert( NT_SUCCESS( NtStatus ) );


        NetpAssert( SUBAUTHORITIES_FOR_BUILTIN_DOMAIN == 1 );
        *(RtlSubAuthoritySid(*RetDomainId, 0)) = SECURITY_BUILTIN_DOMAIN_RID;

        NetpAssert( RtlValidSid( *RetDomainId ) );
        break;

    default :
        ApiStatus = ERROR_INVALID_PARAMETER;
        goto cleanupandexit;
    }



    ApiStatus = NO_ERROR;

cleanupandexit:

    //
    // Clean up (either error or success).
    //

    if (PolicyInfo) {
        (VOID) LsaFreeMemory(PolicyInfo);
    }
    if (LsaHandle) {
        (VOID) LsaClose(LsaHandle);
    }
    if ((ApiStatus!=NO_ERROR) && (RetDomainId!=NULL) && (*RetDomainId!=NULL)) {
        (VOID) LocalFree( *RetDomainId );
        *RetDomainId = NULL;
    }

    return (ApiStatus);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\domname.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    DomName.c

Abstract:

    This file contains NetpGetDomainName().

Author:

    John Rogers (JohnRo) 09-Jan-1992

Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    09-Jan-1992 JohnRo
        Created.
    13-Feb-1992 JohnRo
        Moved section name equates to ConfName.h.
    13-Mar-1992 JohnRo
        Get rid of old config helper callers.

--*/


#include <nt.h>                 // NT definitions (temporary)
#include <ntrtl.h>              // NT Rtl structure definitions (temporary)
#include <ntlsa.h>

#include <windef.h>             // Win32 type definitions

#include <lmcons.h>             // LAN Manager common definitions
#include <lmerr.h>              // LAN Manager error code
#include <lmapibuf.h>           // NetApiBufferAllocate()
#include <netdebug.h>           // LPDEBUG_STRING typedef.

#include <config.h>             // NetpConfig helpers.
#include <confname.h>           // SECT_NT_ equates.
#include <debuglib.h>           // IF_DEBUG().
#include <netlib.h>             // My prototype.

#include <winerror.h>           // ERROR_ equates, NO_ERROR.


NET_API_STATUS
NetpGetDomainNameExExEx (
    OUT LPTSTR *DomainNamePtr,
    OUT LPTSTR *DnsDomainNamePtr OPTIONAL,
    OUT LPTSTR *DnsForestNamePtr OPTIONAL,
    OUT GUID **DomainGuidPtr OPTIONAL,
    OUT PBOOLEAN IsWorkgroupName
    )

/*++

Routine Description:

    Returns the name of the domain or workgroup this machine belongs to.

Arguments:

    DomainNamePtr - The name of the domain or workgroup
        Free the returned buffer user NetApiBufferFree.

    DnsDomainNamePtr - Returns the DNS name of the domain this machine is
        a member of.  NULL is returned if the machine is not a member of
        a domain or if that domain has no DNS name.
        Free the returned buffer user NetApiBufferFree.

    DnsForestNamePtr - Returns the DNS forest name of the forest this
        machine is in.  NULL is returned if the machine is not a member of
        a domain or if that domain has no DNS name.
        Free the returned buffer user NetApiBufferFree.

    DomainGuidPtr - Returns the domain GUID of the domain this machine is
        a member of.  NULL is return if the machine is not a member of
        a domain or if that domain has no domain GUID.
        Free the returned buffer user NetApiBufferFree.

    IsWorkgroupName - Returns TRUE if the name is a workgroup name.
        Returns FALSE if the name is a domain name.

Return Value:

   NERR_Success - Success.
   NERR_CfgCompNotFound - There was an error determining the domain name

--*/
{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;
    LSA_HANDLE PolicyHandle = NULL;
    PPOLICY_DNS_DOMAIN_INFO PrimaryDomainInfo = NULL;
    OBJECT_ATTRIBUTES ObjAttributes;


    //
    // Check for caller's errors.
    //
    if (DomainNamePtr == NULL) {
        return ERROR_INVALID_PARAMETER;
    }
    *DomainNamePtr = NULL;
    if ( ARGUMENT_PRESENT(DnsDomainNamePtr)) {
        *DnsDomainNamePtr = NULL;
    }
    if ( ARGUMENT_PRESENT(DnsForestNamePtr)) {
        *DnsForestNamePtr = NULL;
    }
    if ( ARGUMENT_PRESENT(DomainGuidPtr)) {
        *DomainGuidPtr = NULL;
    }

    //
    // Open a handle to the local security policy.  Initialize the
    // objects attributes structure first.
    //
    InitializeObjectAttributes(
        &ObjAttributes,
        NULL,
        0L,
        NULL,
        NULL
        );

    Status = LsaOpenPolicy(
                   NULL,
                   &ObjAttributes,
                   POLICY_VIEW_LOCAL_INFORMATION,
                   &PolicyHandle
                   );

    if (! NT_SUCCESS(Status)) {
        NetpKdPrint(("NetpGetDomainName: LsaOpenPolicy returned " FORMAT_NTSTATUS
                     "\n", Status));
        NetStatus = NERR_CfgCompNotFound;
        goto Cleanup;
    }

    //
    // Get the name of the primary domain from LSA
    //
    Status = LsaQueryInformationPolicy(
                   PolicyHandle,
                   PolicyDnsDomainInformation,
                   (PVOID *) &PrimaryDomainInfo
                   );

    if (! NT_SUCCESS(Status)) {
        NetpKdPrint(("NetpGetDomainName: LsaQueryInformationPolicy failed "
               FORMAT_NTSTATUS "\n", Status));
        NetStatus = NERR_CfgCompNotFound;
        goto Cleanup;
    }


    //
    // Copy the Netbios domain name.
    //
    if ((NetStatus = NetApiBufferAllocate(
                      PrimaryDomainInfo->Name.Length + sizeof(WCHAR),
                      DomainNamePtr
                      )) != NERR_Success) {
        goto Cleanup;
    }

    memcpy(
        *DomainNamePtr,
        PrimaryDomainInfo->Name.Buffer,
        PrimaryDomainInfo->Name.Length
        );
    (*DomainNamePtr)[PrimaryDomainInfo->Name.Length/sizeof(WCHAR)] = L'\0';

    //
    // Copy the DNS domain name.
    //

    if ( ARGUMENT_PRESENT(DnsDomainNamePtr) &&
         PrimaryDomainInfo->DnsDomainName.Length != 0 ) {

        if ((NetStatus = NetApiBufferAllocate(
                          PrimaryDomainInfo->DnsDomainName.Length + sizeof(WCHAR),
                          DnsDomainNamePtr
                          )) != NERR_Success) {
            goto Cleanup;
        }

        memcpy(
            *DnsDomainNamePtr,
            PrimaryDomainInfo->DnsDomainName.Buffer,
            PrimaryDomainInfo->DnsDomainName.Length
            );
        (*DnsDomainNamePtr)[PrimaryDomainInfo->DnsDomainName.Length/sizeof(WCHAR)] = L'\0';
    }

    //
    // Copy the DNS forest name.
    //

    if ( ARGUMENT_PRESENT(DnsForestNamePtr) &&
         PrimaryDomainInfo->DnsForestName.Length != 0 ) {

        if ((NetStatus = NetApiBufferAllocate(
                          PrimaryDomainInfo->DnsForestName.Length + sizeof(WCHAR),
                          DnsForestNamePtr
                          )) != NERR_Success) {
            goto Cleanup;
        }

        memcpy(
            *DnsForestNamePtr,
            PrimaryDomainInfo->DnsForestName.Buffer,
            PrimaryDomainInfo->DnsForestName.Length
            );
        (*DnsForestNamePtr)[PrimaryDomainInfo->DnsForestName.Length/sizeof(WCHAR)] = L'\0';
    }

    //
    // Copy the domain GUID.
    //

    if ( ARGUMENT_PRESENT(DomainGuidPtr) &&
         RtlCompareMemoryUlong( &PrimaryDomainInfo->DomainGuid,
                                sizeof(GUID),
                                0 ) != sizeof(GUID) ) {

        if ((NetStatus = NetApiBufferAllocate(
                          sizeof(GUID),
                          DomainGuidPtr
                          )) != NERR_Success) {
            goto Cleanup;
        }

        memcpy( *DomainGuidPtr, &PrimaryDomainInfo->DomainGuid, sizeof(GUID));

    }



    *IsWorkgroupName = (PrimaryDomainInfo->Sid == NULL);

    IF_DEBUG(CONFIG) {
        NetpKdPrint(("NetpGetDomainName got " FORMAT_LPTSTR "\n",
            *DomainNamePtr));
    }

    NetStatus = NO_ERROR;

Cleanup:
    if ( NetStatus != NO_ERROR ) {
        if ( *DomainNamePtr != NULL ) {
            NetApiBufferFree( *DomainNamePtr );
            *DomainNamePtr = NULL;
        }
        if ( ARGUMENT_PRESENT(DnsDomainNamePtr)) {
            if ( *DnsDomainNamePtr != NULL ) {
                NetApiBufferFree( *DnsDomainNamePtr );
                *DnsDomainNamePtr = NULL;
            }
        }
        if ( ARGUMENT_PRESENT(DnsForestNamePtr)) {
            if ( *DnsForestNamePtr != NULL ) {
                NetApiBufferFree( *DnsForestNamePtr );
                *DnsForestNamePtr = NULL;
            }
        }
        if ( ARGUMENT_PRESENT(DomainGuidPtr)) {
            if ( *DomainGuidPtr != NULL ) {
                NetApiBufferFree( *DomainGuidPtr );
                *DomainGuidPtr = NULL;
            }
        }
    }
    if ( PrimaryDomainInfo != NULL ) {
        (void) LsaFreeMemory((PVOID) PrimaryDomainInfo);
    }
    if ( PolicyHandle != NULL ) {
        (void) LsaClose(PolicyHandle);
    }

    return NetStatus;

}

NET_API_STATUS
NetpGetDomainNameExEx (
    OUT LPTSTR *DomainNamePtr,
    OUT LPTSTR *DnsDomainNamePtr OPTIONAL,
    OUT PBOOLEAN IsWorkgroupName
    )

/*++

Routine Description:

    Returns the name of the domain or workgroup this machine belongs to.

Arguments:

    DomainNamePtr - The name of the domain or workgroup
        Free the returned buffer user NetApiBufferFree.

    DnsDomainNamePtr - Returns the DNS name of the domain this machine is
        is member of.  NULL is returned if the machine is not a member of
        a domain or for that domain has no DNS name.
        Free the returned buffer user NetApiBufferFree.

    IsWorkgroupName - Returns TRUE if the name is a workgroup name.
        Returns FALSE if the name is a domain name.

Return Value:

   NERR_Success - Success.
   NERR_CfgCompNotFound - There was an error determining the domain name

--*/
{
    return NetpGetDomainNameExExEx( DomainNamePtr, DnsDomainNamePtr, NULL, NULL, IsWorkgroupName );
}

NET_API_STATUS
NetpGetDomainNameEx (
    OUT LPTSTR *DomainNamePtr, // alloc and set ptr (free with NetApiBufferFree)
    OUT PBOOLEAN IsWorkgroupName
    )

/*++

Routine Description:

    Returns the name of the domain or workgroup this machine belongs to.

Arguments:

    DomainNamePtr - The name of the domain or workgroup

    IsWorkgroupName - Returns TRUE if the name is a workgroup name.
        Returns FALSE if the name is a domain name.

Return Value:

   NERR_Success - Success.
   NERR_CfgCompNotFound - There was an error determining the domain name

--*/
{
    return NetpGetDomainNameExExEx( DomainNamePtr, NULL, NULL, NULL, IsWorkgroupName );
}



NET_API_STATUS
NetpGetDomainName (
    IN LPTSTR *DomainNamePtr  // alloc and set ptr (free with NetApiBufferFree)
    )
{
    BOOLEAN IsWorkgroupName;

    return NetpGetDomainNameExExEx( DomainNamePtr, NULL, NULL, NULL, &IsWorkgroupName );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\eventlog.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    eventlog.c

Abstract:

    This module provides support routines for eventlogging.

Author:

    Madan Appiah (madana) 27-Jul-1992

Environment:

    Contains NT specific code.

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>             // DWORD.
#include <winbase.h>            // event log apis
#include <winerror.h>           // NO_ERROR
#include <lmcons.h>             // NET_API_STATUS.
#include <lmalert.h>            // Alert defines
#include <netlib.h>             // These routines
#include <netlogon.h>           // needed by logonp.h
#include <logonp.h>             // NetpLogon routines
#include <tstr.h>               // ultow()

//
// Structure describing the entire list of logged events.
//

typedef struct _NL_EVENT_LIST {
    CRITICAL_SECTION EventListCritSect;
    LIST_ENTRY EventList;

    // Number of milli-seconds to keep EventList entry for.
    ULONG DuplicateEventlogTimeout;

    // Event source
    LPWSTR Source;
} NL_EVENT_LIST, *PNL_EVENT_LIST;

//
// Structure describing an event that has already been logged.
//

typedef struct _NL_EVENT_ENTRY {
    LIST_ENTRY Next;
    LARGE_INTEGER FirstLogTime;
    DWORD EventId;
    DWORD EventType;
    DWORD EventCategory;
    LPBYTE RawDataBuffer;
    DWORD RawDataSize;
    LPWSTR *StringArray;
    DWORD StringCount;
    DWORD EventsLogged; // total times event encountered.
} NL_EVENT_ENTRY, *PNL_EVENT_ENTRY;



DWORD
NetpWriteEventlogEx(
    LPWSTR Source,
    DWORD EventID,
    DWORD EventType,
    DWORD EventCategory,
    DWORD NumStrings,
    LPWSTR *Strings,
    DWORD DataLength,
    LPVOID Data
    )
/*++

Routine Description:

    This function writes the specified (EventID) log at the end of the
    eventlog.

Arguments:

    Source - Points to a null-terminated string that specifies the name
             of the module referenced. The node must exist in the
             registration database, and the module name has the
             following format:

                \EventLog\System\Lanmanworkstation

    EventID - The specific event identifier. This identifies the
                message that goes with this event.

    EventType - Specifies the type of event being logged. This
                parameter can have one of the following

                values:

                    Value                       Meaning

                    EVENTLOG_ERROR_TYPE         Error event
                    EVENTLOG_WARNING_TYPE       Warning event
                    EVENTLOG_INFORMATION_TYPE   Information event

    NumStrings - Specifies the number of strings that are in the array
                    at 'Strings'. A value of zero indicates no strings
                    are present.

    Strings - Points to a buffer containing an array of null-terminated
                strings that are merged into the message before
                displaying to the user. This parameter must be a valid
                pointer (or NULL), even if cStrings is zero.

    DataLength - Specifies the number of bytes of event-specific raw
                    (binary) data to write to the log. If cbData is
                    zero, no event-specific data is present.

    Data - Buffer containing the raw data. This parameter must be a
            valid pointer (or NULL), even if cbData is zero.


Return Value:

    Returns the WIN32 extended error obtained by GetLastError().

    NOTE : This function works slow since it calls the open and close
            eventlog source everytime.

--*/
{
    HANDLE EventlogHandle;
    DWORD ReturnCode;


    //
    // open eventlog section.
    //

    EventlogHandle = RegisterEventSourceW(
                    NULL,
                    Source
                    );

    if (EventlogHandle == NULL) {

        ReturnCode = GetLastError();
        goto Cleanup;
    }


    //
    // Log the error code specified
    //

    if( !ReportEventW(
            EventlogHandle,
            (WORD)EventType,
            (WORD)EventCategory,        // event category
            EventID,
            NULL,
            (WORD)NumStrings,
            DataLength,
            Strings,
            Data
            ) ) {

        ReturnCode = GetLastError();
        goto Cleanup;
    }

    ReturnCode = NO_ERROR;

Cleanup:

    if( EventlogHandle != NULL ) {

        DeregisterEventSource(EventlogHandle);
    }

    return ReturnCode;
}



DWORD
NetpWriteEventlog(
    LPWSTR Source,
    DWORD EventID,
    DWORD EventType,
    DWORD NumStrings,
    LPWSTR *Strings,
    DWORD DataLength,
    LPVOID Data
    )
{
    return NetpWriteEventlogEx(
                        Source,
                        EventID,
                        EventType,
                        0,
                        NumStrings,
                        Strings,
                        DataLength,
                        Data
                        );
}


DWORD
NetpRaiseAlert(
    IN LPWSTR ServiceName,
    IN DWORD alert_no,
    IN LPWSTR *string_array
    )
/*++

Routine Description:

    Raise NETLOGON specific Admin alerts.

Arguments:

    alert_no - The alert to be raised, text in alertmsg.h

    string_array - array of strings terminated by NULL string.

Return Value:

    None.

--*/
{
    NET_API_STATUS NetStatus;
    LPWSTR *SArray;
    PCHAR Next;
    PCHAR End;

    char    message[ALERTSZ + sizeof(ADMIN_OTHER_INFO)];
    PADMIN_OTHER_INFO admin = (PADMIN_OTHER_INFO) message;

    //
    // Build the variable data
    //
    admin->alrtad_errcode = alert_no;
    admin->alrtad_numstrings = 0;

    Next = (PCHAR) ALERT_VAR_DATA(admin);
    End = Next + ALERTSZ;

    //
    // now take care of (optional) char strings
    //

    for( SArray = string_array; *SArray != NULL; SArray++ ) {
        DWORD StringLen;

        StringLen = (wcslen(*SArray) + 1) * sizeof(WCHAR);

        if( Next + StringLen < End ) {

            //
            // copy next string.
            //

            RtlCopyMemory(Next, *SArray, StringLen);
            Next += StringLen;
            admin->alrtad_numstrings++;
        } else {
            return ERROR_BUFFER_OVERFLOW;
        }
    }

    //
    // Call alerter.
    //

    NetStatus = NetAlertRaiseEx(
                    ALERT_ADMIN_EVENT,
                    message,
                    (DWORD)((PCHAR)Next - (PCHAR)message),
                    ServiceName );

    return NetStatus;
}

HANDLE
NetpEventlogOpen (
    IN LPWSTR Source,
    IN ULONG DuplicateEventlogTimeout
    )
/*++

Routine Description:

    This routine open a context that keeps track of events that have been logged
    in the recent past.

Arguments:

    Source - Name of the service opening the eventlog

    DuplicateEventlogTimeout - Number of milli-seconds to keep EventList entry for.

Return Value:

    Handle to be passed to related routines.

    NULL: if memory could not be allocated.

--*/
{
    PNL_EVENT_LIST EventList;
    LPBYTE Where;

    //
    // Allocate a buffer to keep the context in.
    //

    EventList = LocalAlloc( 0,
                            sizeof(NL_EVENT_LIST) +
                                wcslen(Source) * sizeof(WCHAR) + sizeof(WCHAR) );

    if ( EventList == NULL ) {
        return NULL;
    }


    //
    // Initialize the critical section
    //

    try {
        InitializeCriticalSection( &EventList->EventListCritSect );
    } except( EXCEPTION_EXECUTE_HANDLER ) {
        LocalFree( EventList );
        return NULL;
    }

    //
    // Initialize the buffer
    //

    InitializeListHead( &EventList->EventList );
    EventList->DuplicateEventlogTimeout = DuplicateEventlogTimeout;

    //
    // Copy the service name into the buffer
    //
    Where = (LPBYTE)(EventList + 1);
    wcscpy( (LPWSTR)Where, Source );
    EventList->Source = (LPWSTR) Where;

    return EventList;
}



DWORD
NetpEventlogWriteEx (
    IN HANDLE NetpEventHandle,
    IN DWORD EventType,
    IN DWORD EventCategory,
    IN DWORD EventId,
    IN DWORD StringCount,
    IN DWORD RawDataSize,
    IN LPWSTR *StringArray,
    IN LPVOID pvRawDataBuffer OPTIONAL
    )
/*++

Routine Description:

    Stub routine for calling writing Event Log and skipping duplicates

Arguments:

    NetpEventHandle - Handle from NetpEventlogOpen

    EventId - event log ID.

    EventType - Type of event.

    RawDataBuffer - Data to be logged with the error.

    numbyte - Size in bytes of "RawDataBuffer"

    StringArray - array of null-terminated strings.

    StringCount - number of zero terminated strings in "StringArray".  The following
        flags can be OR'd in to the count:

        NETP_LAST_MESSAGE_IS_NTSTATUS
        NETP_LAST_MESSAGE_IS_NETSTATUS
        NETP_ALLOW_DUPLICATE_EVENTS
        NETP_RAISE_ALERT_TOO

Return Value:

    Win 32 status of the operation.

    ERROR_ALREAY_EXISTS: Success status indicating the message was already logged

--*/
{
    DWORD ErrorCode;
    DWORD AlertErrorCode = NO_ERROR;
    WCHAR ErrorNumberBuffer[25];
    PLIST_ENTRY ListEntry;
    ULONG StringIndex;
    BOOLEAN AllowDuplicateEvents;
    BOOLEAN RaiseAlertToo;
    PNL_EVENT_ENTRY EventEntry;
    PNL_EVENT_LIST EventList = (PNL_EVENT_LIST)NetpEventHandle;
    LPBYTE RawDataBuffer = (LPBYTE)pvRawDataBuffer;

    //
    // Remove sundry flags
    //

    EnterCriticalSection( &EventList->EventListCritSect );
    AllowDuplicateEvents = (StringCount & NETP_ALLOW_DUPLICATE_EVENTS) != 0;
    StringCount &= ~NETP_ALLOW_DUPLICATE_EVENTS;
    RaiseAlertToo = (StringCount & NETP_RAISE_ALERT_TOO) != 0;
    StringCount &= ~NETP_RAISE_ALERT_TOO;

    //
    // If an NT status code was passed in,
    //  convert it to a net status code.
    //

    if ( StringCount & NETP_LAST_MESSAGE_IS_NTSTATUS ) {
        StringCount &= ~NETP_LAST_MESSAGE_IS_NTSTATUS;

        //
        // Do the "better" error mapping when eventviewer ParameterMessageFile
        // can be a list of files.  Then, add netmsg.dll to the list.
        //
        // StringArray[((StringCount&NETP_STRING_COUNT_MASK)-1] = (LPWSTR) NetpNtStatusToApiStatus( (NTSTATUS) StringArray[(StringCount&NETP_STRING_COUNT_MASK)-1] );
        StringArray[(StringCount&NETP_STRING_COUNT_MASK)-1] = (LPWSTR) (ULONG_PTR) RtlNtStatusToDosError( (NTSTATUS) ((ULONG_PTR)StringArray[(StringCount&NETP_STRING_COUNT_MASK)-1]) );

        StringCount |= NETP_LAST_MESSAGE_IS_NETSTATUS;
    }

    //
    // If a net/windows status code was passed in,
    //  convert to the the %%N format the eventviewer knows.
    //

    if ( StringCount & NETP_LAST_MESSAGE_IS_NETSTATUS ) {
        StringCount &= ~NETP_LAST_MESSAGE_IS_NETSTATUS;

        wcscpy( ErrorNumberBuffer, L"%%" );
        ultow( (ULONG) ((ULONG_PTR)StringArray[(StringCount&NETP_STRING_COUNT_MASK)-1]), ErrorNumberBuffer+2, 10 );
        StringArray[(StringCount&NETP_STRING_COUNT_MASK)-1] = ErrorNumberBuffer;

    }

    //
    // Check to see if this problem has already been reported.
    //

    if ( !AllowDuplicateEvents ) {
        for ( ListEntry = EventList->EventList.Flink ;
              ListEntry != &EventList->EventList ;
              ) {

            EventEntry =
                CONTAINING_RECORD( ListEntry, NL_EVENT_ENTRY, Next );
            // Entry might be freed (or moved) below
            ListEntry = ListEntry->Flink;

            //
            // If the entry is too old,
            //  ditch it.
            //

            if ( NetpLogonTimeHasElapsed( EventEntry->FirstLogTime,
                                          EventList->DuplicateEventlogTimeout ) ) {
                // NlPrint((NL_MISC, "Ditched a duplicate event. %ld\n", EventEntry->EventId ));
                RemoveEntryList( &EventEntry->Next );
                LocalFree( EventEntry );
                continue;
            }

            //
            // Compare this event to the one being logged.
            //

            if ( EventEntry->EventId == EventId &&
                 EventEntry->EventType == EventType &&
                 EventEntry->EventCategory == EventCategory &&
                 EventEntry->RawDataSize == RawDataSize &&
                 EventEntry->StringCount == StringCount ) {

                if ( RawDataSize != 0 &&
                     !RtlEqualMemory( EventEntry->RawDataBuffer, RawDataBuffer, RawDataSize ) ) {
                    continue;
                }

                for ( StringIndex=0; StringIndex < StringCount; StringIndex ++ ) {
                    if ( EventEntry->StringArray[StringIndex] == NULL) {
                        if ( StringArray[StringIndex] != NULL ) {
                            break;
                        }
                    } else {
                        if ( StringArray[StringIndex] == NULL ) {
                            break;
                        }
                        if ( wcscmp( EventEntry->StringArray[StringIndex],
                                     StringArray[StringIndex] ) != 0 ) {
                            break;
                        }
                    }
                }

                //
                // If the event has already been logged,
                //  skip this one.
                //

                if ( StringIndex == StringCount ) {
                    RemoveEntryList( &EventEntry->Next );
                    InsertHeadList( &EventList->EventList, &EventEntry->Next );

                    ErrorCode = ERROR_ALREADY_EXISTS;

                    //
                    // update count of events logged.
                    //

                    EventEntry->EventsLogged ++;
                    goto Cleanup;
                }

            }

        }
    }

    //
    // Raise an alert if one is needed.
    //

    if ( RaiseAlertToo ) {
        ASSERT( StringArray[StringCount] == NULL );
        if ( StringArray[StringCount] == NULL ) {
            AlertErrorCode = NetpRaiseAlert( EventList->Source, EventId, StringArray );
        }
    }

    //
    // write event
    //

    ErrorCode = NetpWriteEventlogEx(
                    EventList->Source,
                    EventId,
                    EventType,
                    EventCategory,
                    StringCount,
                    StringArray,
                    RawDataSize,
                    RawDataBuffer);


    if( ErrorCode != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Save the event for later
    //  (Only cache events while the service is starting or running.)
    //

    if ( !AllowDuplicateEvents ) {
        ULONG EventEntrySize;

        //
        // Compute the size of the allocated block.
        //
        EventEntrySize = sizeof(NL_EVENT_ENTRY) + RawDataSize;

        for ( StringIndex=0; StringIndex < StringCount; StringIndex ++ ) {
            EventEntrySize += sizeof(LPWSTR);
            if ( StringArray[StringIndex] != NULL ) {
                EventEntrySize += wcslen(StringArray[StringIndex]) * sizeof(WCHAR) + sizeof(WCHAR);
            }
        }

        //
        // Allocate a block for the entry
        //

        EventEntry = LocalAlloc( 0, EventEntrySize );

        //
        // Copy the description of this event into the allocated block.
        //

        if ( EventEntry != NULL ) {
            LPBYTE Where;

            EventEntry->EventId = EventId;
            EventEntry->EventType = EventType;
            EventEntry->EventCategory = EventCategory;
            EventEntry->RawDataSize = RawDataSize;
            EventEntry->StringCount = StringCount;
            EventEntry->EventsLogged = 1;
            GetSystemTimeAsFileTime( (PFILETIME)&EventEntry->FirstLogTime );

            Where = (LPBYTE)(EventEntry+1);

            EventEntry->StringArray = (LPWSTR *)Where;
            Where += StringCount * sizeof(LPWSTR);

            for ( StringIndex=0; StringIndex < StringCount; StringIndex ++ ) {
                if ( StringArray[StringIndex] == NULL ) {
                    EventEntry->StringArray[StringIndex] = NULL;
                } else {
                    EventEntry->StringArray[StringIndex] = (LPWSTR) Where;
                    wcscpy( (LPWSTR)Where, StringArray[StringIndex] );
                    Where += wcslen( StringArray[StringIndex] ) * sizeof(WCHAR) + sizeof(WCHAR);
                }
            }

            if ( RawDataSize != 0 ) {
                EventEntry->RawDataBuffer = Where;
                RtlCopyMemory( Where, RawDataBuffer, RawDataSize );
            }

            InsertHeadList( &EventList->EventList, &EventEntry->Next );

        }


    }

Cleanup:
    LeaveCriticalSection( &EventList->EventListCritSect );
    return (ErrorCode == NO_ERROR) ? AlertErrorCode : ErrorCode;
}


DWORD
NetpEventlogWrite (
    IN HANDLE NetpEventHandle,
    IN DWORD EventId,
    IN DWORD EventType,
    IN LPBYTE RawDataBuffer OPTIONAL,
    IN DWORD RawDataSize,
    IN LPWSTR *StringArray,
    IN DWORD StringCount
    )
{

    return NetpEventlogWriteEx (
                        NetpEventHandle,
                        EventType,  // wType
                        0,          // wCategory
                        EventId,    // dwEventID
                        StringCount,
                        RawDataSize,
                        StringArray,
                        RawDataBuffer
                        );

}

VOID
NetpEventlogClearList (
    IN HANDLE NetpEventHandle
    )
/*++

Routine Description:

    This routine clears the list of events that have already been logged.

Arguments:

    NetpEventHandle - Handle from NetpEventlogOpen

Return Value:

    None.

--*/
{
    PNL_EVENT_LIST EventList = (PNL_EVENT_LIST)NetpEventHandle;

    EnterCriticalSection(&EventList->EventListCritSect);
    while (!IsListEmpty(&EventList->EventList)) {

        PNL_EVENT_ENTRY EventEntry = CONTAINING_RECORD(EventList->EventList.Flink, NL_EVENT_ENTRY, Next);
        RemoveEntryList( &EventEntry->Next );
        LocalFree( EventEntry );
    }
    LeaveCriticalSection(&EventList->EventListCritSect);
}

VOID
NetpEventlogSetTimeout (
    IN HANDLE NetpEventHandle,
    IN ULONG DuplicateEventlogTimeout
    )
/*++

Routine Description:

    This routine sets a new timeout for logged events

Arguments:

    NetpEventHandle - Handle from NetpEventlogOpen

    DuplicateEventlogTimeout - Number of milli-seconds to keep EventList entry for.

Return Value:

    None.

--*/
{
    PNL_EVENT_LIST EventList = (PNL_EVENT_LIST)NetpEventHandle;

    EventList->DuplicateEventlogTimeout = DuplicateEventlogTimeout;
}

VOID
NetpEventlogClose (
    IN HANDLE NetpEventHandle
    )
/*++

Routine Description:

    This routine closes the handle returned from NetpEventlogOpen

Arguments:

    NetpEventHandle - Handle from NetpEventlogOpen

Return Value:

    None.

--*/
{
    PNL_EVENT_LIST EventList = (PNL_EVENT_LIST)NetpEventHandle;

    //
    // Clear the list of logged events.
    //

    NetpEventlogClearList( NetpEventHandle );

    //
    // Delete the critsect
    //

    DeleteCriticalSection( &EventList->EventListCritSect );

    //
    // Free the allocated buffer.
    //

    LocalFree( EventList );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\ftnfoctx.c ===
/*++

Copyright (c) 1987-2001  Microsoft Corporation

Module Name:

    ftnfoctx.c

Abstract:

    Utility routines to manipulate the forest trust context

Author:

    27-Jul-00 (cliffv)

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <netdebug.h>
#include <ntlsa.h>
#include <ftnfoctx.h>
#include <align.h>    // ROUND_UP_POINTER
#include <rpcutil.h>  // MIDL_user_free
#include <stdlib.h>   // qsort


VOID
NetpInitFtinfoContext(
    OUT PNL_FTINFO_CONTEXT FtinfoContext
    )

/*++

Routine Description:

    Routine to initialize the Ftinfo context structure.

Arguments:

    FtinfoContext - Context to initialize

Return Value:

    None

--*/
{
    RtlZeroMemory( FtinfoContext, sizeof(*FtinfoContext) );
    InitializeListHead( &FtinfoContext->FtinfoList );
}


VOID
NetpMarshalFtinfoEntry (
    IN PLSA_FOREST_TRUST_RECORD InFtinfoRecord,
    OUT PLSA_FOREST_TRUST_RECORD OutFtinfoRecord,
    IN OUT LPBYTE *WherePtr
    )

/*++

Routine Description:

    Routine to marshalls a single Ftinfo entry

Arguments:

    InFtinfoRecord - Template to copy into InFtinfoRecord

    OutFtinfoRecord - Entry to fill in
        On input, points to a zeroed buffer.

    WherePtr - On input, specifies where to marshal to.
        On output, points to the first byte past the marshalled data.

Return Value:

    TRUE - Success

    FALSE - if no memory can be allocated

--*/
{
    LPBYTE Where = *WherePtr;
    ULONG Size;
    ULONG SidSize;
    ULONG NameSize;

    NetpAssert( Where == ROUND_UP_POINTER( Where, ALIGN_WORST ));

    //
    // Copy the fixed size data
    //

    OutFtinfoRecord->ForestTrustType = InFtinfoRecord->ForestTrustType;
    OutFtinfoRecord->Flags = InFtinfoRecord->Flags;
    OutFtinfoRecord->Time = InFtinfoRecord->Time;


    //
    // Fill in a domain entry
    //

    switch( InFtinfoRecord->ForestTrustType ) {

    case ForestTrustDomainInfo:

        //
        // Copy the DWORD aligned data
        //

        if ( InFtinfoRecord->ForestTrustData.DomainInfo.Sid != NULL ) {
            SidSize = RtlLengthSid( InFtinfoRecord->ForestTrustData.DomainInfo.Sid );

            OutFtinfoRecord->ForestTrustData.DomainInfo.Sid = (PISID) Where;
            RtlCopyMemory( Where, InFtinfoRecord->ForestTrustData.DomainInfo.Sid, SidSize );
            Where += SidSize;

        }

        //
        // Copy the WCHAR aligned data
        //

        NameSize = InFtinfoRecord->ForestTrustData.DomainInfo.DnsName.Length;
        if ( NameSize != 0 ) {

            OutFtinfoRecord->ForestTrustData.DomainInfo.DnsName.Buffer = (LPWSTR) Where;
            OutFtinfoRecord->ForestTrustData.DomainInfo.DnsName.MaximumLength = (USHORT) (NameSize+sizeof(WCHAR));
            OutFtinfoRecord->ForestTrustData.DomainInfo.DnsName.Length = (USHORT)NameSize;

            RtlCopyMemory( Where, InFtinfoRecord->ForestTrustData.DomainInfo.DnsName.Buffer, NameSize );
            Where += NameSize;

            *((LPWSTR)Where) = L'\0';
            Where += sizeof(WCHAR);
        }

        NameSize = InFtinfoRecord->ForestTrustData.DomainInfo.NetbiosName.Length;
        if ( NameSize != 0 ) {

            OutFtinfoRecord->ForestTrustData.DomainInfo.NetbiosName.Buffer = (LPWSTR) Where;
            OutFtinfoRecord->ForestTrustData.DomainInfo.NetbiosName.MaximumLength = (USHORT) (NameSize+sizeof(WCHAR));
            OutFtinfoRecord->ForestTrustData.DomainInfo.NetbiosName.Length = (USHORT)NameSize;

            RtlCopyMemory( Where, InFtinfoRecord->ForestTrustData.DomainInfo.NetbiosName.Buffer, NameSize );
            Where += NameSize;

            *((LPWSTR)Where) = L'\0';
            Where += sizeof(WCHAR);
        }

        break;

    //
    // Fill in a TLN entry
    //

    case ForestTrustTopLevelName:
    case ForestTrustTopLevelNameEx:

        //
        // Copy the WCHAR aligned data
        //

        NameSize = InFtinfoRecord->ForestTrustData.TopLevelName.Length;
        if ( NameSize != 0 ) {

            OutFtinfoRecord->ForestTrustData.TopLevelName.Buffer = (LPWSTR) Where;
            OutFtinfoRecord->ForestTrustData.TopLevelName.MaximumLength = (USHORT) (NameSize+sizeof(WCHAR));
            OutFtinfoRecord->ForestTrustData.TopLevelName.Length = (USHORT)NameSize;

            RtlCopyMemory( Where, InFtinfoRecord->ForestTrustData.TopLevelName.Buffer, NameSize );
            Where += NameSize;

            *((LPWSTR)Where) = L'\0';
            Where += sizeof(WCHAR);
        }

        break;

    default:
        NetpAssert( FALSE );
    }

    Where = ROUND_UP_POINTER( Where, ALIGN_WORST );
    *WherePtr = Where;
}



VOID
NetpCompareHelper (
    IN PUNICODE_STRING Name,
    IN OUT PULONG Index,
    OUT PUNICODE_STRING CurrentLabel
    )

/*++

Routine Description:

    This routine is a helper routine for finding the next rightmost label in a string.


Arguments:

    Name - The input dns name.  The dns name should not have a trailing .

    Index - On input, should contain the value returned by the previous call to this routine.
        On input for the first call, should be set to Name->Length/sizeof(WCHAR).
        On output, zero is returned to indicate that this is the last of the name.  The
            caller should not call again.  Any other value output is a context for the next
            call to this routine.

    CurrentLabel - Returns a descriptor describing the substring which is the next label.

Return Value:

    None.

--*/
{
    ULONG PreviousIndex = *Index;
    ULONG CurrentIndex = *Index;
    ULONG LabelIndex;

    NetpAssert( CurrentIndex != 0 );

    //
    // Find the beginning of the next label
    //

    while ( CurrentIndex > 0 ) {
        CurrentIndex--;
        if ( Name->Buffer[CurrentIndex] == L'.' ) {
            break;
        }
    }

    if ( CurrentIndex == 0 ) {
        LabelIndex = CurrentIndex;
    } else {
        LabelIndex = CurrentIndex + 1;
    }

    //
    // Return it to the caller
    //

    CurrentLabel->Buffer = &Name->Buffer[LabelIndex];
    CurrentLabel->Length = (USHORT)((PreviousIndex - LabelIndex) * sizeof(WCHAR));
    CurrentLabel->MaximumLength = CurrentLabel->Length;

    *Index = CurrentIndex;

}


int
NetpCompareDnsNameWithSortOrder(
    IN PUNICODE_STRING Name1,
    IN PUNICODE_STRING Name2
    )

/*++

Routine Description:

    Routine to compare two DNS names.  The DNS names must not have a trailing "."

    Labels are compare right to left to present a pleasent viewing order.

Arguments:

    Name1 - First name to compare.

    Name2 - Second name to compare.

Return Value:

    Signed value that gives the results of the comparison:

        Zero - String1 equals String2

        < Zero - String1 less than String2

        > Zero - String1 greater than String2

--*/
{
    ULONG Index1 = Name1->Length/sizeof(WCHAR);
    ULONG Index2 = Name2->Length/sizeof(WCHAR);

    UNICODE_STRING Label1;
    UNICODE_STRING Label2;

    LONG Result;


    //
    // Loop comparing labels
    //

    while ( Index1 != 0 && Index2 != 0 ) {

        //
        // Get the next label from each string
        //

        NetpCompareHelper ( Name1, &Index1, &Label1 );
        NetpCompareHelper ( Name2, &Index2, &Label2 );

        //
        // If the labels are different,
        //  return that result to the caller.
        //

        Result = RtlCompareUnicodeString( &Label1, &Label2, TRUE );

        if ( Result != 0 ) {
            return (int)Result;
        }

    }

    //
    // ASSERT: one label is a (proper) substring of the other
    //
    // If the first name is longer, indicate it is greater than the second
    //

    return Index1-Index2;

}




int __cdecl NetpCompareFtinfoEntryDns(
        const void *String1,
        const void *String2
    )
/*++

Routine Description:

    qsort comparison routine for Dns string in Ftinfo entries

Arguments:

    String1: First string to compare

    String2: Second string to compare

Return Value:

    Signed value that gives the results of the comparison:

        Zero - String1 equals String2

        < Zero - String1 less than String2

        > Zero - String1 greater than String2

--*/
{
    PLSA_FOREST_TRUST_RECORD Entry1 = *((PLSA_FOREST_TRUST_RECORD *)String1);
    PLSA_FOREST_TRUST_RECORD Entry2 = *((PLSA_FOREST_TRUST_RECORD *)String2);

    PUNICODE_STRING Name1;
    PUNICODE_STRING Name2;

    int Result;

    //
    // Get the name from the entry
    //

    switch ( Entry1->ForestTrustType ) {
    case ForestTrustTopLevelName:
    case ForestTrustTopLevelNameEx:
        Name1 = &Entry1->ForestTrustData.TopLevelName;
        break;
    case ForestTrustDomainInfo:
        Name1 = &Entry1->ForestTrustData.DomainInfo.DnsName;
        break;
    default:
        //
        // If Entry2 can be recognized,
        //  then entry 2 is less than this one.
        //
        switch ( Entry2->ForestTrustType ) {
        case ForestTrustTopLevelName:
        case ForestTrustTopLevelNameEx:
        case ForestTrustDomainInfo:
            return 1;       // This name is greater than the other
        }

        //
        // Otherwise simply leave them in the same order
        //
        if ((Entry1 - Entry2) < 0 ) {
            return -1;
        } else if ((Entry1 - Entry2) > 0 ) {
            return 1;
        } else {
            return 0;
        }
    }

    switch ( Entry2->ForestTrustType ) {
    case ForestTrustTopLevelName:
    case ForestTrustTopLevelNameEx:
        Name2 = &Entry2->ForestTrustData.TopLevelName;
        break;
    case ForestTrustDomainInfo:
        Name2 = &Entry2->ForestTrustData.DomainInfo.DnsName;
        break;
    default:
        //
        // Since Entry1 is a recognized type,
        //  this Entry2 is greater.
        //
        return -1;       // This name is greater than the other
    }


    //
    // If the labels are different,
    //  return the difference to the caller.
    //

    Result = NetpCompareDnsNameWithSortOrder( Name1, Name2 );

    if ( Result != 0 ) {
        return Result;
    }

    //
    // If the labels are the same,
    //  indicate TLNs are before domain info records.
    //

    return Entry1->ForestTrustType - Entry2->ForestTrustType;

}



int
NetpCompareSid(
    PSID Sid1,
    PSID Sid2
    )
/*++

Routine description:

    SID comparison routine that actually indicates if one sid is greater than another

Arguments:

    Sid1 - First Sid

    Sid2 - Second Sid

Returns:

    Signed value that gives the results of the comparison:

        Zero - String1 equals String2

        < Zero - String1 less than String2

        > Zero - String1 greater than String2

--*/
{
    DWORD Size1;
    DWORD Size2;
    LPBYTE Byte1;
    LPBYTE Byte2;
    ULONG i;

    NetpAssert( Sid1 && RtlValidSid( Sid1 ));
    NetpAssert( Sid2 && RtlValidSid( Sid2 ));

    //
    // The NULL SID is smaller
    //

    if ( Sid1 == NULL ) {
        if ( Sid2 != NULL ) {
            return -1;
        } else {
            return 0;
        }
    }

    if ( Sid2 == NULL ) {
        if ( Sid1 != NULL ) {
            return 1;
        } else {
            return 0;
        }
    }

    //
    // The longer sid is greater
    //

    Size1 = RtlLengthSid( Sid1 );
    Size2 = RtlLengthSid( Sid2 );

    if ( Size1 != Size2 ) {
        return Size1 - Size2;
    }

    //
    // Otherwise compare the bytes
    //

    Byte1 = (LPBYTE)Sid1;
    Byte2 = (LPBYTE)Sid2;

    for ( i=0; i<Size1; i++ ) {

        if ( Byte1[i] != Byte2[i] ) {
            return Byte1[i] - Byte2[i];
        }
    }

    return 0;

}



int __cdecl NetpCompareFtinfoEntrySid(
        const void *String1,
        const void *String2
    )
/*++

Routine Description:

    qsort comparison routine for Sid string in Ftinfo entries

Arguments:

    String1: First string to compare

    String2: Second string to compare

Return Value:

    Signed value that gives the results of the comparison:

        Zero - String1 equals String2

        < Zero - String1 less than String2

        > Zero - String1 greater than String2

--*/
{
    PLSA_FOREST_TRUST_RECORD Entry1 = *((PLSA_FOREST_TRUST_RECORD *)String1);
    PLSA_FOREST_TRUST_RECORD Entry2 = *((PLSA_FOREST_TRUST_RECORD *)String2);

    PSID Sid1;
    PSID Sid2;

    int Result;

    //
    // Get the Sid from the entry
    //

    switch ( Entry1->ForestTrustType ) {
    case ForestTrustDomainInfo:
        Sid1 = Entry1->ForestTrustData.DomainInfo.Sid;
        break;
    default:
        //
        // If Entry2 can be recognized,
        //  then entry 2 is less than this one.
        //
        switch ( Entry2->ForestTrustType ) {
        case ForestTrustDomainInfo:
            return 1;       // This name is greater than the other
        }

        //
        // Otherwise simply leave them in the same order
        //
        if ((Entry1 - Entry2) < 0 ) {
            return -1;
        } else if ((Entry1 - Entry2) > 0 ) {
            return 1;
        } else {
            return 0;
        }
    }

    switch ( Entry2->ForestTrustType ) {
    case ForestTrustDomainInfo:
        Sid2 = Entry2->ForestTrustData.DomainInfo.Sid;
        break;
    default:
        //
        // Since Entry1 is a recognized type,
        //  this Entry2 is greater.
        //
        return -1;       // This name is greater than the other
    }


    //
    // Simply return the different of the sids.
    //

    return NetpCompareSid( Sid1, Sid2 );

}



int __cdecl NetpCompareFtinfoEntryNetbios(
        const void *String1,
        const void *String2
    )
/*++

Routine Description:

    qsort comparison routine for Netbios name in Ftinfo entries

Arguments:

    String1: First string to compare

    String2: Second string to compare

Return Value:

    Signed value that gives the results of the comparison:

        Zero - String1 equals String2

        < Zero - String1 less than String2

        > Zero - String1 greater than String2

--*/
{
    PLSA_FOREST_TRUST_RECORD Entry1 = *((PLSA_FOREST_TRUST_RECORD *)String1);
    PLSA_FOREST_TRUST_RECORD Entry2 = *((PLSA_FOREST_TRUST_RECORD *)String2);

    PUNICODE_STRING Name1;
    PUNICODE_STRING Name2;

    int Result;

    //
    // Get the Sid from the entry
    //

    switch ( Entry1->ForestTrustType ) {
    case ForestTrustDomainInfo:
        Name1 = &Entry1->ForestTrustData.DomainInfo.NetbiosName;
        if ( Name1->Length != 0 && Name1->Buffer != NULL ) {
            break;
        }
    default:
        //
        // If Entry2 can be recognized,
        //  then entry 2 is less than this one.
        //
        switch ( Entry2->ForestTrustType ) {
        case ForestTrustDomainInfo:
            return 1;       // This name is greater than the other
        }

        //
        // Otherwise simply leave them in the same order
        //
        if ((Entry1 - Entry2) < 0 ) {
            return -1;
        } else if ((Entry1 - Entry2) > 0 ) {
            return 1;
        } else {
            return 0;
        }
    }

    switch ( Entry2->ForestTrustType ) {
    case ForestTrustDomainInfo:
        Name2 = &Entry2->ForestTrustData.DomainInfo.NetbiosName;
        if ( Name2->Length != 0 && Name2->Buffer != NULL ) {
            break;
        }
    default:
        //
        // Since Entry1 is a recognized type,
        //  this Entry2 is greater.
        //
        return -1;       // This name is greater than the other
    }


    //
    // Simply return the difference of the names
    //

    return RtlCompareUnicodeString( Name1, Name2, TRUE );

}



PLSA_FOREST_TRUST_INFORMATION
NetpCopyFtinfoContext(
    IN PNL_FTINFO_CONTEXT FtinfoContext
    )

/*++

Routine Description:

    Routine to allocate an FTinfo array from an FTinfo context.

Arguments:

    FtinfoContext - Context to use
        The caller must have previously called NetpInitFtinfoContext

Return Value:

    FTinfo array.  The caller should free this array using MIDL_user_free.

    If NULL, not enough memory was available.

--*/
{
    PNL_FTINFO_ENTRY FtinfoEntry;
    PLIST_ENTRY ListEntry;

    PLSA_FOREST_TRUST_INFORMATION LocalForestTrustInfo;
    LPBYTE Where;
    ULONG Size;
    ULONG i;
    PLSA_FOREST_TRUST_RECORD Entries;

    //
    // Allocate a structure to return to the caller.
    //

    Size = ROUND_UP_COUNT( sizeof( *LocalForestTrustInfo ), ALIGN_WORST) +
           ROUND_UP_COUNT( FtinfoContext->FtinfoCount * sizeof(LSA_FOREST_TRUST_RECORD), ALIGN_WORST) +
           ROUND_UP_COUNT( FtinfoContext->FtinfoCount * sizeof(PLSA_FOREST_TRUST_RECORD), ALIGN_WORST) +
           FtinfoContext->FtinfoSize;

    LocalForestTrustInfo = MIDL_user_allocate( Size );

    if ( LocalForestTrustInfo == NULL ) {

        return NULL;
    }

    RtlZeroMemory( LocalForestTrustInfo, Size );
    Where = (LPBYTE)(LocalForestTrustInfo+1);
    Where = ROUND_UP_POINTER( Where, ALIGN_WORST );

    //
    // Fill it in
    //

    LocalForestTrustInfo->RecordCount = FtinfoContext->FtinfoCount;

    //
    // Grab a huge chunk of ALIGN_WORST
    //  (We fill it in during the loop below.)
    //

    Entries = (PLSA_FOREST_TRUST_RECORD) Where;
    Where = (LPBYTE)(&Entries[FtinfoContext->FtinfoCount]);
    Where = ROUND_UP_POINTER( Where, ALIGN_WORST );

    //
    // Grab a huge chunk of dword aligned
    //  (We fill it in during the loop below.)
    //

    LocalForestTrustInfo->Entries = (PLSA_FOREST_TRUST_RECORD *) Where;
    Where = (LPBYTE)(&LocalForestTrustInfo->Entries[FtinfoContext->FtinfoCount]);
    Where = ROUND_UP_POINTER( Where, ALIGN_WORST );

    //
    // Fill in the individual entries
    //

    i = 0;

    for ( ListEntry = FtinfoContext->FtinfoList.Flink ;
          ListEntry != &FtinfoContext->FtinfoList ;
          ListEntry = ListEntry->Flink) {

        FtinfoEntry = CONTAINING_RECORD( ListEntry, NL_FTINFO_ENTRY, Next );

        LocalForestTrustInfo->Entries[i] = &Entries[i];

        NetpMarshalFtinfoEntry (
                        &FtinfoEntry->Record,
                        &Entries[i],
                        &Where );

        i++;
    }

    NetpAssert( i == FtinfoContext->FtinfoCount );
    NetpAssert( Where == ((LPBYTE)LocalForestTrustInfo) + Size );

    //
    // Sort them into alphabetical order
    //

    qsort( LocalForestTrustInfo->Entries,
           LocalForestTrustInfo->RecordCount,
           sizeof(PLSA_FOREST_TRUST_RECORD),
           NetpCompareFtinfoEntryDns );


    //
    // Return the allocated buffer to the caller.
    //

    return LocalForestTrustInfo;
}


VOID
NetpCleanFtinfoContext(
    IN PNL_FTINFO_CONTEXT FtinfoContext
    )

/*++

Routine Description:

    Routine to cleanup the Ftinfo context structure.

Arguments:

    FtinfoContext - Context to clean
        The caller must have previously called NetpInitFtinfoContext

Return Value:

    None

--*/
{
    PLIST_ENTRY ListEntry;
    PNL_FTINFO_ENTRY FtinfoEntry;

    //
    // Loop freeing the entries
    //

    while ( !IsListEmpty( &FtinfoContext->FtinfoList ) ) {

        //
        // Delink an entry
        //

        ListEntry = RemoveHeadList( &FtinfoContext->FtinfoList );

        FtinfoEntry = CONTAINING_RECORD( ListEntry, NL_FTINFO_ENTRY, Next );

        FtinfoContext->FtinfoCount -= 1;
        FtinfoContext->FtinfoSize -= FtinfoEntry->Size;
        RtlFreeHeap( RtlProcessHeap(), 0, FtinfoEntry );
    }
    NetpAssert( FtinfoContext->FtinfoCount == 0 );
    NetpAssert( FtinfoContext->FtinfoSize == 0 );
}


PLSA_FOREST_TRUST_RECORD
NetpAllocFtinfoEntry2 (
    IN PNL_FTINFO_CONTEXT FtinfoContext,
    IN PLSA_FOREST_TRUST_RECORD InFtinfoRecord
    )

/*++

Routine Description:

    Same as NetpAllocFtinfoEntry except takes a template of an FTinfo entry on input.

Arguments:

    FtinfoContext - Context to link the entry onto.

    InFtinfoRecord - Template to copy into InFtinfoRecord

Return Value:

    Returns the address of the allocated forest trust record.

    The caller should not and cannot deallocate this buffer.  It has a header and is
    linked into the FtinfoContext.


    Returns NULL if no memory can be allocated.

--*/
{
    PNL_FTINFO_ENTRY FtinfoEntry;
    ULONG Size = ROUND_UP_COUNT(sizeof(NL_FTINFO_ENTRY), ALIGN_WORST);
    ULONG DataSize = 0;
    LPBYTE Where;

    //
    // Compute the size of the entry.
    //

    switch( InFtinfoRecord->ForestTrustType ) {

    case ForestTrustDomainInfo:

        if ( InFtinfoRecord->ForestTrustData.DomainInfo.Sid != NULL ) {
            DataSize += RtlLengthSid( InFtinfoRecord->ForestTrustData.DomainInfo.Sid );
        }
        if ( InFtinfoRecord->ForestTrustData.DomainInfo.DnsName.Length != 0 ) {
            DataSize += InFtinfoRecord->ForestTrustData.DomainInfo.DnsName.Length + sizeof(WCHAR);
        }
        if ( InFtinfoRecord->ForestTrustData.DomainInfo.NetbiosName.Length != 0 ) {
            DataSize += InFtinfoRecord->ForestTrustData.DomainInfo.NetbiosName.Length + sizeof(WCHAR);
        }

        break;

    case ForestTrustTopLevelName:
    case ForestTrustTopLevelNameEx:

        if ( InFtinfoRecord->ForestTrustData.TopLevelName.Length != 0 ) {
            DataSize += InFtinfoRecord->ForestTrustData.TopLevelName.Length + sizeof(WCHAR);
        }

        break;

    default:

        NetpAssert( FALSE );
        return NULL;
    }

    DataSize = ROUND_UP_COUNT(DataSize, ALIGN_WORST);

    //
    // Allocate an entry
    //

    Size += DataSize;
    FtinfoEntry = RtlAllocateHeap( RtlProcessHeap(), 0, Size );

    if ( FtinfoEntry == NULL ) {
        return NULL;
    }

    RtlZeroMemory( FtinfoEntry, Size );
    Where = (LPBYTE)(FtinfoEntry+1);

    //
    // Fill it in.
    //

    FtinfoEntry->Size = DataSize;

    NetpMarshalFtinfoEntry ( InFtinfoRecord,
                            &FtinfoEntry->Record,
                            &Where );

    NetpAssert( Where == ((LPBYTE)FtinfoEntry) + Size )

    //
    // Link it onto the list
    //

    InsertHeadList( &FtinfoContext->FtinfoList, &FtinfoEntry->Next );
    FtinfoContext->FtinfoSize += FtinfoEntry->Size;
    FtinfoContext->FtinfoCount += 1;

    return &FtinfoEntry->Record;
}


BOOLEAN
NetpAllocFtinfoEntry (
    IN PNL_FTINFO_CONTEXT FtinfoContext,
    IN LSA_FOREST_TRUST_RECORD_TYPE ForestTrustType,
    IN PUNICODE_STRING Name,
    IN PSID Sid,
    IN PUNICODE_STRING NetbiosName
    )

/*++

Routine Description:

    Routine to allocate a single Ftinfo entry and link it onto the context.

Arguments:

    FtinfoContext - Context to link the entry onto.

    ForestTypeType - Specifies the type of record to allocate.  This must be
        ForestTrustTopLevelName or ForestTrustDomainInfo.

    Name - Specifies the name for the record.

    Sid - Specifies the SID for the record.  (Ignored for ForestTrustTopLevelName.)

    NetbiosName - Specifies the netbios name for the record.  (Ignored for ForestTrustTopLevelName.)


Return Value:

    TRUE - Success

    FALSE - if no memory can be allocated

--*/
{
    LSA_FOREST_TRUST_RECORD FtinfoRecord = {0};

    //
    // Initialize the template Ftinfo entry
    //

    FtinfoRecord.ForestTrustType = ForestTrustType;

    switch( ForestTrustType ) {

    case ForestTrustDomainInfo:

        FtinfoRecord.ForestTrustData.DomainInfo.Sid = Sid;
        FtinfoRecord.ForestTrustData.DomainInfo.DnsName = *Name;
        FtinfoRecord.ForestTrustData.DomainInfo.NetbiosName = *NetbiosName;

        break;

    case ForestTrustTopLevelName:
    case ForestTrustTopLevelNameEx:

        FtinfoRecord.ForestTrustData.TopLevelName = *Name;

        break;

    default:

        NetpAssert( FALSE );
        return FALSE;
    }

    //
    // Call the routine that takes a template and does the rest of the job
    //

    return (NetpAllocFtinfoEntry2( FtinfoContext, &FtinfoRecord ) != NULL);
}

BOOLEAN
NetpIsSubordinate(
    IN const UNICODE_STRING * Subordinate,
    IN const UNICODE_STRING * Superior,
    IN BOOLEAN EqualReturnsTrue
    )
/*++

Routine Description:

    Determines if Subordinate string is indeed subordinate to Superior
    For example, "NY.acme.com" is subordinate to "acme.com", but
    "NY.acme.com" is NOT subordinate to "me.com" or "NY.acme.com"

Arguments:

    Subordinate    name to test for subordinate status

    Superior       name to test for superior status

    EqualReturnsTrue - TRUE if equal names should return TRUE also

Returns:

    TRUE is Subordinate is subordinate to Superior

    FALSE otherwise

--*/
{
    USHORT SubIndex, SupIndex;
    UNICODE_STRING Temp;

    ASSERT( Subordinate && Subordinate->Buffer );
    ASSERT( Superior && Superior->Buffer );

    //
    // If equal names are to be considered subordinate,
    //  compare the names for equality.
    //

    if ( EqualReturnsTrue &&
         RtlEqualUnicodeString( Subordinate, Superior, TRUE )) {

        return TRUE;
    }

    //
    // A subordinate name must be longer than the superior name
    //

    if ( Subordinate->Length <= Superior->Length ) {

        return FALSE;
    }

    //
    // Subordinate name must be separated from the superior part by a period
    //

    if ( Subordinate->Buffer[( Subordinate->Length - Superior->Length ) / sizeof( WCHAR ) - 1] != L'.' ) {

        return FALSE;
    }

    //
    // Ensure the trailing part of the two names are the same.
    //

    Temp = *Subordinate;
    Temp.Buffer += ( Subordinate->Length - Superior->Length ) / sizeof( WCHAR );
    Temp.Length = Superior->Length;
    Temp.MaximumLength = Temp.Length;

    if ( !RtlEqualUnicodeString( &Temp, Superior, TRUE )) {

        return FALSE;
    }

    return TRUE;
}


BOOLEAN
NetpAddTlnFtinfoEntry (
    IN PNL_FTINFO_CONTEXT FtinfoContext,
    IN PUNICODE_STRING Name
    )

/*++

Routine Description:

    Routine to add a TLN Ftinfo entry to the list.

    If there is already a TLN that is equal to or superior to this one, this TLN is
    ignored. (e.g., a TLN of a.acme.com is ignored of acme.com already exists in the list.)

    If there is already a TLN that is inferior to this one, the inferior TLN is
    removed and this one is added.  (e.g., a TLN of acme.com causes an existing TLN of
    a.acme.com to be replaced by the new entry.)

Arguments:

    FtinfoContext - Context to link the entry onto.

    Name - Specifies the name for the record.

Return Value:

    TRUE - Success

    FALSE - if no memory can be allocated

--*/
{
    PNL_FTINFO_ENTRY FtinfoEntry;
    PLIST_ENTRY ListEntry;


    //
    // Loop through the list of existing entries
    //

    for ( ListEntry = FtinfoContext->FtinfoList.Flink ;
          ListEntry != &FtinfoContext->FtinfoList ;
          ) {

        FtinfoEntry = CONTAINING_RECORD( ListEntry, NL_FTINFO_ENTRY, Next );
        ListEntry = ListEntry->Flink;

        //
        // Ignore entries that aren't TLNs.
        //

        if ( FtinfoEntry->Record.ForestTrustType != ForestTrustTopLevelName ) {
            continue;
        }

        //
        // If the new name is subordinate (or equal to) to one already in the list,
        //  ignore the new name.
        //

        if ( NetpIsSubordinate( Name,
                            &FtinfoEntry->Record.ForestTrustData.TopLevelName,
                            TRUE ) ) {
            return TRUE;
        }

        //
        // If the existing name is subordinate to the new name,
        //  remove the existing name.
        //

        if ( NetpIsSubordinate( &FtinfoEntry->Record.ForestTrustData.TopLevelName,
                            Name,
                            FALSE ) ) {

            RemoveEntryList( &FtinfoEntry->Next );
            FtinfoContext->FtinfoCount -= 1;
            FtinfoContext->FtinfoSize -= FtinfoEntry->Size;
            RtlFreeHeap( RtlProcessHeap(), 0, FtinfoEntry );

            // continue looping since there may be more names to remove
        }

    }

    //
    // Add the new entry to the list
    //

    return NetpAllocFtinfoEntry( FtinfoContext,
                                ForestTrustTopLevelName,
                                Name,
                                NULL,   // No sid
                                NULL ); // No Netbios name

}



VOID
NetpMergeFtinfoHelper(
    IN PLSA_FOREST_TRUST_INFORMATION NewForestTrustInfo,
    IN PLSA_FOREST_TRUST_INFORMATION OldForestTrustInfo,
    IN OUT PULONG NewIndex,
    IN OUT PULONG OldIndex,
    OUT PLSA_FOREST_TRUST_RECORD *NewEntry,
    OUT PLSA_FOREST_TRUST_RECORD *OldEntry,
    OUT PULONG OldFlags,
    IN int (__cdecl *Routine) (const void *, const void *)
    )
/*++

Routine Description:

    This routine walks a pair of FTinfo arrays in sorted order and returns the next
    entry.  If both entries are the same in the sort order, this routine returns an entry
    from both arrays

Arguments:

    NewForestTrustInfo - Pointer to the first array
    OldForestTrustInfo - Pointer to the second array

    NewIndex - Current index into the first sorted array
    OldIndex - Current index into the second sorted array
        Before calling this routine the first time, the caller should set these parameters to zero.
        Both indices zero triggers this routine to qsort the arrays.
        The caller should *not* call this routine if both NewIndex and OldIndex are greater
        than the corresponding record count.

    NewEntry - Returns a pointer to an entry to be processed from the first sorted array.
    OldEntry - Returns a pointer to an entry to be processed from the second sorted array.
        Returns NULL if no entry is to be processed from the corresponding array.

    OldFlags - Returns the Flags field that corresponds to OldEntry.
        If there are duplicates of OldEntry, those duplicates are silently ignored by
        this routine.  This field returns the logical OR of the Flags field of those entries.

    Routine - Comparison routine to passed to qsort to sort the FTinfo arrays.

Return Value:

    None.

--*/
{
    int RetVal;

    //
    // Sort the arrays
    //

    if ( *NewIndex == 0 && *OldIndex == 0 ) {

        qsort( NewForestTrustInfo->Entries,
               NewForestTrustInfo->RecordCount,
               sizeof(PLSA_FOREST_TRUST_RECORD),
               Routine );

        qsort( OldForestTrustInfo->Entries,
               OldForestTrustInfo->RecordCount,
               sizeof(PLSA_FOREST_TRUST_RECORD),
               Routine );
    }

    //
    // Compare the first entry at the front of each list to determine which list
    // to consume an entry from.
    //

    *NewEntry = NULL;
    *OldEntry = NULL;
    *OldFlags = 0;

    if ( *NewIndex < NewForestTrustInfo->RecordCount ) {

        //
        // If neither list is empty,
        //  compare the entries to determine which is next.
        //

        if ( *OldIndex < OldForestTrustInfo->RecordCount ) {

            RetVal = (*Routine)(
                            &NewForestTrustInfo->Entries[*NewIndex],
                            &OldForestTrustInfo->Entries[*OldIndex] );

            //
            // If the new entry is less than or equal to the old entry,
            //  consume the new entry.
            //

            if ( RetVal <= 0 ) {
                *NewEntry = NewForestTrustInfo->Entries[*NewIndex];
                (*NewIndex) ++;
            }

            //
            // If the old entry is less than or equal to the new entry,
            //  consume the old entry.
            //

            if ( RetVal >= 0 ) {
                *OldEntry = OldForestTrustInfo->Entries[*OldIndex];
                (*OldIndex) ++;
            }

        //
        // If the old list is empty and the new list isn't,
        //  consume an entry from the new list.
        //

        } else {
            *NewEntry = NewForestTrustInfo->Entries[*NewIndex];
            (*NewIndex) ++;
        }

    } else {

        //
        // If the new list is empty and the old list isn't,
        //  consume an entry from the old list.
        //
        if ( *OldIndex < OldForestTrustInfo->RecordCount ) {

            *OldEntry = OldForestTrustInfo->Entries[*OldIndex];
            (*OldIndex) ++;

        }
    }

    //
    // If we're returning an "OldEntry",
    //  weed out all duplicates of that OldEntry.
    //


    if ( *OldEntry != NULL ) {

        *OldFlags |= (*OldEntry)->Flags;
        while ( *OldIndex < OldForestTrustInfo->RecordCount ) {

            //
            // Stop as soon as we hit an entry that isn't a duplicate.
            //

            RetVal = (*Routine)(
                            OldEntry,
                            &OldForestTrustInfo->Entries[*OldIndex] );

            if ( RetVal != 0 ) {
                break;
            }

            *OldFlags |= (*OldEntry)->Flags;
        }

    }
}



NTSTATUS
NetpMergeFtinfo(
    IN PUNICODE_STRING TrustedDomainName,
    IN PLSA_FOREST_TRUST_INFORMATION InNewForestTrustInfo,
    IN PLSA_FOREST_TRUST_INFORMATION InOldForestTrustInfo OPTIONAL,
    OUT PLSA_FOREST_TRUST_INFORMATION *MergedForestTrustInfo
    )
/*++

Routine Description:

    This function merges the changes from a new FTinfo into an old FTinfo and
    produces the resultant FTinfo.

    The merged FTinfo records are a combinition of the new and old records.
    Here's where the merged records come from:

    * The TLN exclusion records are copied from the TDO intact.
    * The TLN record from the trusted domain that maps to the dns domain name of the
      TDO is copied enabled.  This reflects the LSA requirement that such a TLN not
      be disabled.  For instance, if the TDO is for a.acme.com and there is a TLN for
      a.acme.com that TLN will be enabled.  Also, if the TDO is for a.acme.com and
      there is a TLN for acme.com, that TLN will be enabled.
    * All other TLN records from the trusted domain are copied disabled with the
      following exceptions.  If there is an enabled TLN on the TDO, all TLNs from the
      trusted domain that equal (or are subordinate to) the TDO TLN are marked as
      disabled.  This follows the philosophy that new TLNs are imported as enabled.
      For instance, if the TDO had an enabled TLN for a.acme.com that TLN will still
      be enabled after the automatic update.  If the TDO had an enabled TLN for
      acme.com and the trusted forest now has a TLN for a.acme.com, the resultant
      FTinfo will have an enabled TLN for a.acme.com.
    * The domain records from the trusted domain are copied enabled with the
      following exceptions.  If there is a disabled domain record on the TDO whose
      dns domain name, or domain sid exactly matches the domain record, then the domain
      remains disabled.  If there is a domain record on the TDO whose netbios name is
      disabled and whose netbios name exactly matches the netbios name on a domain
      record, then the netbios name is disabled.


Arguments:

    TrustedDomainName - Trusted domain that is to be updated.

    NewForestTrustInfo - Specified the new array of FTinfo records as returned from the
        TrustedDomainName.
        The Flags field and Time field of the TLN entries are ignored.

    OldForestTrustInfo - Specified the array of FTinfo records as returned from the
        TDO.  This field may be NULL if there is no existing records.

    MergedForestTrustInfo - Returns the resulant FTinfo records.
        The caller should free this buffer using MIDL_user_free.

Return Value:

    STATUS_SUCCESS: Success.

    STATUS_INVALID_PARAMETER: One of the following happened:
        * There was no New TLN that TrustedDomainName is subordinate to.

--*/
{
    NTSTATUS Status;

    LSA_FOREST_TRUST_INFORMATION OldForestTrustInfo;
    LSA_FOREST_TRUST_INFORMATION NewForestTrustInfo;
    LSA_FOREST_TRUST_INFORMATION NetbiosForestTrustInfo;

    NL_FTINFO_CONTEXT FtinfoContext;
    ULONG NewIndex;
    ULONG OldIndex;
    ULONG OldFlags;
    PLSA_FOREST_TRUST_RECORD NewEntry;
    PLSA_FOREST_TRUST_RECORD PreviousNewEntry;
    PLSA_FOREST_TRUST_RECORD OldEntry;
    BOOLEAN DomainTlnFound = FALSE;


    PLSA_FOREST_TRUST_RECORD OldTlnPrefix;

    //
    // Initialization
    //

    *MergedForestTrustInfo = NULL;
    NetpInitFtinfoContext( &FtinfoContext );
    RtlZeroMemory( &OldForestTrustInfo, sizeof(OldForestTrustInfo) );
    RtlZeroMemory( &NewForestTrustInfo, sizeof(NewForestTrustInfo) );
    RtlZeroMemory( &NetbiosForestTrustInfo, sizeof(NetbiosForestTrustInfo) );

    //
    // Make a copy of the data that'll be qsorted so that we don't modify the caller's buffer.
    //

    if ( InOldForestTrustInfo != NULL ) {
        OldForestTrustInfo.RecordCount = InOldForestTrustInfo->RecordCount;
        OldForestTrustInfo.Entries = RtlAllocateHeap( RtlProcessHeap(), 0, OldForestTrustInfo.RecordCount * sizeof(PLSA_FOREST_TRUST_RECORD) );
        if ( OldForestTrustInfo.Entries == NULL ) {
            Status = STATUS_NO_MEMORY;
            goto Cleanup;
        }

        RtlCopyMemory( OldForestTrustInfo.Entries,
                       InOldForestTrustInfo->Entries,
                       OldForestTrustInfo.RecordCount * sizeof(PLSA_FOREST_TRUST_RECORD) );
    }

    NewForestTrustInfo.RecordCount = InNewForestTrustInfo->RecordCount;
    NewForestTrustInfo.Entries = RtlAllocateHeap( RtlProcessHeap(), 0, NewForestTrustInfo.RecordCount * sizeof(PLSA_FOREST_TRUST_RECORD) );
    if ( NewForestTrustInfo.Entries == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    RtlCopyMemory( NewForestTrustInfo.Entries,
                   InNewForestTrustInfo->Entries,
                   NewForestTrustInfo.RecordCount * sizeof(PLSA_FOREST_TRUST_RECORD) );

    //
    // Allocate a temporary Ftinfo array containing all of the domain entries.
    //  Allocate it a worst case size.
    //

    NetbiosForestTrustInfo.Entries = RtlAllocateHeap(
                RtlProcessHeap(),
                0,
                (OldForestTrustInfo.RecordCount+NewForestTrustInfo.RecordCount) * sizeof(PLSA_FOREST_TRUST_RECORD) );

    if ( NetbiosForestTrustInfo.Entries == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }





    //
    // Loop through each list in DNS canonical order processing the least entry.
    //
    // This loop handles TLN and TLNEX entries only
    //

    NewIndex = 0;
    OldIndex = 0;
    OldTlnPrefix = NULL;
    PreviousNewEntry = NULL;

    while ( NewIndex < NewForestTrustInfo.RecordCount ||
            OldIndex < OldForestTrustInfo.RecordCount ) {


        //
        // Grab the next entry from each of the sorted arrays
        //

        NetpMergeFtinfoHelper( &NewForestTrustInfo,
                              &OldForestTrustInfo,
                              &NewIndex,
                              &OldIndex,
                              &NewEntry,
                              &OldEntry,
                              &OldFlags,
                              NetpCompareFtinfoEntryDns );




        //
        // Process the old entry
        //

        if ( OldEntry != NULL ) {

            //
            // Remember to most recent TLN record from the old array.
            //

            if ( OldEntry->ForestTrustType == ForestTrustTopLevelName ) {

                OldTlnPrefix = OldEntry;


            //
            // TLN exclusion records are taken from the old entries
            //

            } else if ( OldEntry->ForestTrustType == ForestTrustTopLevelNameEx ) {

                if ( NetpAllocFtinfoEntry2( &FtinfoContext, OldEntry ) == NULL ) {
                    Status = STATUS_NO_MEMORY;
                    goto Cleanup;
                }
            }
        }

        //
        // Process the new entry
        //

        if ( NewEntry != NULL ) {

            //
            // Handle TLN entries
            //

            if ( NewEntry->ForestTrustType == ForestTrustTopLevelName  ) {
                BOOLEAN SetTlnNewFlag;
                LSA_FOREST_TRUST_RECORD NewEntryCopy;

                //
                // Make a copy of the new entry.
                //
                // We modify the entry to get the time and flags right.  We don't want
                // to modify the callers buffer.
                //

                NewEntryCopy = *NewEntry;

                //
                // Ignore duplicate new entries
                //
                // If the name of this new entry is subordinate to the previous new entry,
                //  then this TLN can be quietly dropped.
                //
                // This is the case where the trusted domain sent us a TLN for both
                // acme.com and a.acme.com.  The second entry is a duplicate.
                //

                if ( PreviousNewEntry != NULL &&
                     PreviousNewEntry->ForestTrustType == ForestTrustTopLevelName ) {

                    if ( NetpIsSubordinate( &NewEntry->ForestTrustData.TopLevelName,
                                        &PreviousNewEntry->ForestTrustData.TopLevelName,
                                        TRUE ) ) {
                        continue;

                    }

                }

                //
                // By default any TLN from the new list should be marked as new.
                //

                SetTlnNewFlag = TRUE;

                //
                // Set the flags and timestamp on the new entry.
                //
                // If we're processing an entry from both lists,
                //  grab the flags and timestamp from the old entry.
                //

                if ( OldEntry != NULL ) {
                    NewEntryCopy.Flags = OldFlags;
                    NewEntryCopy.Time = OldEntry->Time;

                    // This entry isn't 'new'.
                    SetTlnNewFlag = FALSE;

                //
                // Otherwise indicate that we have no information
                //

                } else {
                    NewEntryCopy.Flags = 0;
                    NewEntryCopy.Time.QuadPart = 0;
                }


                //
                // If this new entry is subordinate to the most recent old TLN record,
                //  use the flag bits from that most recent old TLN record.
                //

                if ( OldTlnPrefix != NULL &&
                     NetpIsSubordinate( &NewEntryCopy.ForestTrustData.TopLevelName,
                                    &OldTlnPrefix->ForestTrustData.TopLevelName,
                                    FALSE ) ) {

                    //
                    // If the old TLN was disabled by the admin,
                    //  so should the new entry.
                    //

                    if ( OldTlnPrefix->Flags & LSA_TLN_DISABLED_ADMIN ) {
                        NewEntryCopy.Flags |= LSA_TLN_DISABLED_ADMIN;
                        SetTlnNewFlag = FALSE;

                    //
                    // If the old TLN was enabled,
                    //  so should the new entry.
                    //

                    } else if ( (OldTlnPrefix->Flags & LSA_FTRECORD_DISABLED_REASONS) == 0 ) {
                        SetTlnNewFlag = FALSE;
                    }


                }

                //
                // If the name of the forest is subordinate of or equal to the TLN name,
                //  enable the entry.
                //

                if ( NetpIsSubordinate( TrustedDomainName,
                                    &NewEntryCopy.ForestTrustData.TopLevelName,
                                    TRUE )) {
                    SetTlnNewFlag = FALSE;
                    DomainTlnFound = TRUE;
                }

                //
                // If this is a new TLN,
                //  mark it as such.
                //

                if ( SetTlnNewFlag ) {
                    NewEntryCopy.Flags |= LSA_TLN_DISABLED_NEW;
                }

                //
                // Merge the new entry into the list
                //

                if ( NetpAllocFtinfoEntry2( &FtinfoContext, &NewEntryCopy ) == NULL ) {
                    Status = STATUS_NO_MEMORY;
                    goto Cleanup;
                }

                //
                // Remember this previous entry for the next iteration.
                //
                PreviousNewEntry = NewEntry;

            }

        }

    }



    //
    // Loop through each list in SID canonical order processing the least entry.
    //
    // This loop handles DOMAIN entries only
    //
    // This is in a separate loop since we want to process domain entries in SID order
    // to ensure the correct disabled bits are merged from the old list even though the
    // DNS domain name changes.
    //

    NewIndex = 0;
    OldIndex = 0;
    PreviousNewEntry = NULL;

    while ( NewIndex < NewForestTrustInfo.RecordCount ||
            OldIndex < OldForestTrustInfo.RecordCount ) {


        //
        // Grab the next entry from each of the sorted arrays
        //

        NetpMergeFtinfoHelper( &NewForestTrustInfo,
                              &OldForestTrustInfo,
                              &NewIndex,
                              &OldIndex,
                              &NewEntry,
                              &OldEntry,
                              &OldFlags,
                              NetpCompareFtinfoEntrySid );

        //
        // Ignore the netbios bits for now (We'll get them on the next pass through the data.)
        //

        OldFlags &= ~(LSA_NB_DISABLED_ADMIN|LSA_NB_DISABLED_CONFLICT);


        //
        // Process the old entry
        //

        if ( OldEntry != NULL ) {

            //
            // Don't let the lack of a new entry allow an admin disabled entry to be deleted.
            //

            if ( OldEntry->ForestTrustType == ForestTrustDomainInfo &&
                 (OldFlags & LSA_SID_DISABLED_ADMIN) != 0 &&
                 NewEntry == NULL ) {

                //
                // Make a copy of the entry to ensure we don't modify the caller's buffer
                //

                LSA_FOREST_TRUST_RECORD OldEntryCopy;

                OldEntryCopy = *OldEntry;
                OldEntryCopy.Flags = OldFlags;


                //
                // Allocate entry.
                //
                //  Remember the address of the entry for the netbios pass.
                //

                NetbiosForestTrustInfo.Entries[NetbiosForestTrustInfo.RecordCount] =
                    NetpAllocFtinfoEntry2( &FtinfoContext, &OldEntryCopy );


                if ( NetbiosForestTrustInfo.Entries[NetbiosForestTrustInfo.RecordCount] == NULL ) {
                    Status = STATUS_NO_MEMORY;
                    goto Cleanup;
                }

                NetbiosForestTrustInfo.RecordCount++;

            }
        }


        //
        // Process the new entry
        //

        if ( NewEntry != NULL ) {

            //
            // Handle domain entries
            //

            if ( NewEntry->ForestTrustType == ForestTrustDomainInfo  ) {
                LSA_FOREST_TRUST_RECORD NewEntryCopy;

                //
                // Make a copy of the new entry.
                //
                // We modify the entry to get the time and flags right.  We don't want
                // to modify the callers buffer.
                //

                NewEntryCopy = *NewEntry;

                //
                // Ignore duplicate new entries
                //
                // If the name of this new entry is subordinate to the previous new entry,
                //  then this entry can be quietly dropped.
                //
                // We arbitrarily drop the second entry even though the other fields of the
                // triple might be different.
                //

                if ( PreviousNewEntry != NULL &&
                     PreviousNewEntry->ForestTrustType == ForestTrustDomainInfo ) {

                    if ( RtlEqualSid( NewEntryCopy.ForestTrustData.DomainInfo.Sid,
                                      PreviousNewEntry->ForestTrustData.DomainInfo.Sid ) ) {
                        continue;

                    }

                }

                //
                // Set the flags and timestamp on the new entry.
                //
                // If we're processing an entry from both lists,
                //  grab the flags and timestamp from the old entry.
                //

                if ( OldEntry != NULL ) {
                    NewEntryCopy.Flags = OldFlags;
                    NewEntryCopy.Time = OldEntry->Time;


                //
                // Otherwise indicate that we have no information
                //

                } else {
                    NewEntryCopy.Flags = 0;
                    NewEntryCopy.Time.QuadPart = 0;
                }


                //
                // Merge the new entry into the list
                //
                //  Remember the address of the entry for the netbios pass.
                //

                NetbiosForestTrustInfo.Entries[NetbiosForestTrustInfo.RecordCount] =
                    NetpAllocFtinfoEntry2( &FtinfoContext, &NewEntryCopy );


                if ( NetbiosForestTrustInfo.Entries[NetbiosForestTrustInfo.RecordCount] == NULL ) {
                    Status = STATUS_NO_MEMORY;
                    goto Cleanup;
                }

                NetbiosForestTrustInfo.RecordCount++;

                //
                // Ensure there is a TLN for this domain entry
                //

                if ( !NetpAddTlnFtinfoEntry ( &FtinfoContext,
                                             &NewEntryCopy.ForestTrustData.DomainInfo.DnsName ) ) {
                    Status = STATUS_NO_MEMORY;
                    goto Cleanup;
                }


                //
                // Remember this previous entry for the next iteration.
                //
                PreviousNewEntry = NewEntry;

            }

        }

    }



    //
    // Loop through each list in Netbios canonical order processing the least entry.
    //
    // This loop handle the Netbios name in the domain entries.
    //
    // This is in a separate loop since we want to process domain entries in Netbios order
    // to ensure the correct disabled bits are merged from the old list even though the
    // DNS domain name or domain sid changes.
    //
    // This iteration is fundamentally different than the previous two.  This iteration
    // uses NetbiosForestTrustInfo as the 'new' array.  It is a psuedo ftinfo array that
    // is built as the list of all the domain entries that have been copied into FtinfoContext.
    // So, this iteration simply has to find that pre-existing entry and set the flags
    // appropriately.
    //

    NewIndex = 0;
    OldIndex = 0;
    PreviousNewEntry = NULL;

    while ( NewIndex < NetbiosForestTrustInfo.RecordCount ||
            OldIndex < OldForestTrustInfo.RecordCount ) {


        //
        // Grab the next entry from each of the sorted arrays
        //

        NetpMergeFtinfoHelper( &NetbiosForestTrustInfo,
                              &OldForestTrustInfo,
                              &NewIndex,
                              &OldIndex,
                              &NewEntry,
                              &OldEntry,
                              &OldFlags,
                              NetpCompareFtinfoEntryNetbios );

        //
        // Ignore everything except the netbios bits.
        //
        // Everything else was processed on the previous iteration.
        //

        OldFlags &= (LSA_NB_DISABLED_ADMIN|LSA_NB_DISABLED_CONFLICT);


        //
        // This loop preserves the netbios disabled bits.
        // If there is no old entry, there's nothing to preserve.
        //

        if ( OldEntry == NULL ) {
            continue;
        }

        //
        // If there is no new entry,
        //  ensure the *admin* disabled bit it preserved anyway.
        //

        if ( NewEntry == NULL ) {

            //
            // Don't let the lack of a new entry allow an admin disabled entry to be deleted.
            //
            // Note that the newly added entry might have a duplicate DNS name or SID.
            //

            if ( OldEntry->ForestTrustType == ForestTrustDomainInfo &&
                 (OldFlags & LSA_NB_DISABLED_ADMIN) != 0 ) {

                //
                // Make a copy of the entry to ensure we don't modify the caller's buffer
                //

                LSA_FOREST_TRUST_RECORD OldEntryCopy;

                OldEntryCopy = *OldEntry;
                OldEntryCopy.Flags = OldFlags;

                if ( !NetpAllocFtinfoEntry2( &FtinfoContext, &OldEntryCopy ) ) {
                    Status = STATUS_NO_MEMORY;
                    goto Cleanup;
                }

            }


        //
        // Copy any netbios disabled bits to the existing new entry.
        //

        } else {


            //
            // The NetbiosForestTrustInfo array only has domain entries.
            // And the entries are equal so both must be domain entries.
            //

            NetpAssert( NewEntry->ForestTrustType == ForestTrustDomainInfo );
            NetpAssert( OldEntry->ForestTrustType == ForestTrustDomainInfo );


            NewEntry->Flags |= OldFlags;

        }

    }

    //
    // Ensure there is a TLN that DomainName is subordinate to
    //

    if ( !DomainTlnFound ) {

        Status = STATUS_INVALID_PARAMETER;
        goto Cleanup;
    }



    //
    // Return the collected entries to the caller.
    //

    *MergedForestTrustInfo = NetpCopyFtinfoContext( &FtinfoContext );

    if ( *MergedForestTrustInfo == NULL ) {
        Status = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    Status = STATUS_SUCCESS;

Cleanup:

    //
    // Clean FtInfoContext
    //

    NetpCleanFtinfoContext( &FtinfoContext );

    if ( OldForestTrustInfo.Entries != NULL ) {
        RtlFreeHeap( RtlProcessHeap(), 0, OldForestTrustInfo.Entries );
    }

    if ( NewForestTrustInfo.Entries != NULL ) {
        RtlFreeHeap( RtlProcessHeap(), 0, NewForestTrustInfo.Entries );
    }

    if ( NetbiosForestTrustInfo.Entries != NULL ) {
        RtlFreeHeap( RtlProcessHeap(), 0, NetbiosForestTrustInfo.Entries );
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\initoem.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    InitOem.c

Abstract:

    This module contains NetpInitOemString().  This is a wrapper for
    RtlInitOemString(), which may or may not exist depending on who
    wins the current argument on that.

Author:

    John Rogers (JohnRo) 03-Aug-1992

Environment:

    Only runs under NT.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    03-Aug-1992 JohnRo
        Created for RAID 1895: Net APIs and svcs should use OEM char set.

--*/


// These must be included first:

#include <nt.h>         // Must be first.  IN, VOID, etc.
#include <ntrtl.h>      // RtlInitAnsiString().
#include <windef.h>     // DWORD (needed by tstr.h/tstring.h)

// These can be in any order:

#include <tstring.h>    // NetpInitOemString().


VOID
NetpInitOemString(
    POEM_STRING DestinationString,
    PCSZ SourceString
    )
{
    RtlInitAnsiString(
            (PANSI_STRING) DestinationString,
            SourceString);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\gettoken.c ===
/*++

Copyright (c) 1989-91  Microsoft Corporation

Module Name:

    gettoken.c

Abstract:

    The GetToken() function, which takes a pathname splits it into
    individual tokens.  This function is a lexical analyzer which
    is called by the parsing routines of NetpPathType.

Author:

    Danny Glasser (dannygl) 19 June 1989

Notes:

    For efficiency, there is code here which is different for the
    DBCS and non-DBCS environments.  This allows us to take advantage
    of short cuts which are not valid in the DBCS world (such as
    scanning a string from right to left).

    See the comments below for a detailed description of the behavior
    of this function.

Revision History:

    27-Sep-1991 JohnRo
        Changed TEXT macro usage to allow UNICODE.

    06 May 1991 rfirth
        32-bit version

--*/



#include "nticanon.h"
#include "winnls.h"


#define TEXT_LENGTH(s)  ((sizeof(s)/sizeof(TCHAR)) - 1)



static  TCHAR   szAUXName[]             = TEXT("AUX");
static  TCHAR   szCOMMName[]            = TEXT("COMM");
static  TCHAR   szCONName[]             = TEXT("CON");
static  TCHAR   szDEVName[]             = TEXT("DEV");
static  TCHAR   szMAILSLOTName[]        = TEXT("MAILSLOT");
static  TCHAR   szNULName[]             = TEXT("NUL");
static  TCHAR   szPIPEName[]            = TEXT("PIPE");
static  TCHAR   szPRINTName[]           = TEXT("PRINT");
static  TCHAR   szPRNName[]             = TEXT("PRN");
static  TCHAR   szQUEUESName[]          = TEXT("QUEUES");
static  TCHAR   szSEMName[]             = TEXT("SEM");
static  TCHAR   szSHAREMEMName[]        = TEXT("SHAREMEM");
static  TCHAR   szLPTName[]             = TEXT("LPT");
static  TCHAR   szCOMName[]             = TEXT("COM");

#define LPT_TOKEN_LEN   TEXT_LENGTH(szLPTName)
#define COM_TOKEN_LEN   TEXT_LENGTH(szCOMName)

static  TCHAR   szWildcards[]           = TEXT("*?");
static  TCHAR   szIllegalChars[]        = ILLEGAL_CHARS;
static  TCHAR   szNonComponentChars[]   = NON_COMPONENT_CHARS ILLEGAL_CHARS;

static  TCHAR   _text_SingleDot[]       = TEXT(".");



typedef struct {
    LPTSTR  pszTokenName;
    DWORD   cbTokenLen;
    DWORD   flTokenType;
} STRING_TOKEN;



//
// IMPORTANT:  In order for the binary table traversal to work, the strings
//             in this table MUST be in lexically-sorted order.  Please
//             bear this in mind when adding strings to the table.
//

STATIC STRING_TOKEN StringTokenTable[] = {
    szDEVName,         TEXT_LENGTH(szDEVName),      TOKEN_TYPE_DEV
};

#define NUM_STRING_TOKENS   (sizeof(StringTokenTable) / sizeof(*StringTokenTable))



STATIC DWORD    TrailingDotsAndSpaces(LPTSTR pszToken, DWORD cbTokenLen );
STATIC BOOL     IsIllegalCharacter(LPTSTR pszString);



DWORD
GetToken(
    IN  LPTSTR  pszBegin,
    OUT LPTSTR* ppszEnd,
    OUT LPDWORD pflTokenType,
    IN  DWORD   flFlags
    )

/*++

Routine Description:

    GetToken attempts to locate and type the next token.  It takes the
    beginning of the token and determines the end of the token (i.e.
    the beginning of the next token, so that it can be called again).
    It also sets the TOKEN_TYPE_* bits for all of the token types which
    are appropriate to the specified type.

Arguments:

    pszBegin    - A pointer to the first character in the token.

    ppszEnd     - A pointer to the location in which to store the end of
                  the current token (actually, the first character of the
                  next token).

    pflTokenType- The place to store the token type.  Token types are
                  defined in TOKEN.H.

    flFlags     - Flags to determine operation.  Currently MBZ.

Return Value:

    DWORD
        Success - 0
        Failure - ERROR_INVALID_PARAMETER
                  ERROR_INVALID_NAME
                  ERROR_FILENAME_EXCED_RANGE

--*/

{
    register    TCHAR   chFirstChar;
    register    DWORD   cbTokenLen;
                BOOL    fComputernameOnly = FALSE;
                DWORD   usNameError = 0;
                DWORD   cbTrailingDotSpace;
                DWORD   iLow, iHigh, iMid;
                LONG    iCmpVal;
                LCID    lcid  = GetThreadLocale();
                BOOL    bDBCS = (PRIMARYLANGID( LANGIDFROMLCID(lcid)) == LANG_JAPANESE) ||
                                (PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_KOREAN) ||
                                (PRIMARYLANGID(LANGIDFROMLCID(lcid)) == LANG_CHINESE);

    extern      DWORD   cbMaxPathCompLen;

    //
    // This macro is used to make sure that the error value is set only
    // once in the computername-only case.
    //

#define SET_COMPUTERNAMEONLY(err)   if (! fComputernameOnly)            \
                                    {                                   \
                                        fComputernameOnly = TRUE;       \
                                        usNameError = err;              \
                                    }

    if (flFlags & GTF_RESERVED) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Initialize the token type to 0
    //

    *pflTokenType = 0;

    //
    // Store the first character
    //

    chFirstChar = *pszBegin;

    //
    // Return immediately if the string is a null string
    //

    if (chFirstChar == TCHAR_EOS) {
        *ppszEnd = pszBegin;
        *pflTokenType = TOKEN_TYPE_EOS;
#ifdef DEVDEBUG
        DbgPrint("GetToken - returning TOKEN_TYPE_EOS\n");
#endif
        return 0;
    }

    //
    // Handle single-character, non-component tokens
    //

    if ((chFirstChar == TCHAR_BACKSLASH) || (chFirstChar == TCHAR_FWDSLASH)) {
        *pflTokenType = TOKEN_TYPE_SLASH;
    } else if (chFirstChar == TCHAR_COLON) {
        *pflTokenType = TOKEN_TYPE_COLON;
    }

    //
    // If we get here and the token type is non-zero, we have a single
    // character token.  We set <ppszEnd> and return 0.
    //

    if (*pflTokenType) {
        *ppszEnd = pszBegin + 1;
#ifdef DEVDEBUG
        DbgPrint("GetToken - *pflTokenType=%x\n", *pflTokenType);
#endif
        return 0;
    }

    //
    // If we get here, the token is a component, find the end of the
    // component by looking for the first character in the string which
    // isn't a valid component character.
    //
    // IMPORTANT:  There are certain names which are not valid component
    //             names but which may be valid computernames.  If we hit
    //             such a name, we set the <fComputernameOnly> flag.  Later
    //             on, we check to see if the name is a valid computername.
    //             If it is, we allow it; otherwise, we return an error.
    //

    cbTokenLen = STRCSPN(pszBegin, szNonComponentChars);

    //
    // We return an error if the first character is not a valid component
    // character, if the component is too long, or if the first
    // non-component character in the string is an illegal character.
    //

    if (cbTokenLen == 0) {
#ifdef DEVDEBUG
        DbgPrint("GetToken - returning ERROR_INVALID_NAME (token len = 0)\n");
#endif
        return ERROR_INVALID_NAME;
    }

    if (cbTokenLen > cbMaxPathCompLen) {
        SET_COMPUTERNAMEONLY(ERROR_FILENAME_EXCED_RANGE);
    }

    if (IsIllegalCharacter(pszBegin + cbTokenLen)) {
#ifdef DEVDEBUG
        DbgPrint("GetToken - returning ERROR_INVALID_NAME (illegal char)\n");
#endif
        return ERROR_INVALID_NAME;
    }

    //
    // Now we need to determine where the trailing dots and spaces begin,
    // and make sure that the component name contains something other
    // than dots and spaces, unless it's "." or ".."
    //
    // NOTE: If there are not trailing dots or spaces, <cbTrailingDotSpace>
    //       is set to <cbTokenLen>.
    //

    cbTrailingDotSpace = TrailingDotsAndSpaces(pszBegin, cbTokenLen );

    //
    // See if the token has only trailing dots and spaces
    //

    if (cbTrailingDotSpace == 0) {

        //
        // Return an error if the length of the token is greater than 2.
        //

        if (cbTokenLen > 2) {
            SET_COMPUTERNAMEONLY(ERROR_INVALID_NAME);
        }

        //
        // Return an error if the first character is not a dot or if the
        // token length is 2 and the second character is not a dot.
        //

        if ((chFirstChar != TCHAR_DOT) || ((cbTokenLen == 2) && (pszBegin[1] != TCHAR_DOT))) {
            SET_COMPUTERNAMEONLY(ERROR_INVALID_NAME);
        }

        //
        // Now we're OK, since the token is either "." or ".."
        //
    }

    //
    // WE HAVE A VALID COMPONENT
    //

    *pflTokenType = TOKEN_TYPE_COMPONENT;

    //
    // Now we determine if this token matches any of the component-based
    // types.
    //


    //
    // Is it a drive?
    //

    if (IS_DRIVE(chFirstChar) && (cbTokenLen == 1)) {
        *pflTokenType |= TOKEN_TYPE_DRIVE;
    }

    //
    // Is it "." or ".." ?
    //
    // Since we've already validated this string, we know that if it
    // contains nothing but dots and spaces it must be one of these
    // two.
    //

    if (cbTrailingDotSpace == 0) {
        *pflTokenType |= cbTokenLen == 1 ? TOKEN_TYPE_DOT : TOKEN_TYPE_DOTDOT;
    }

    //
    // If the 8.3 flag is specified, we also have to check that the
    // component is in 8.3 format.  We determine this as follows:
    //
    // Find the first dot in the token (or the end of the token).
    // Verify that at least 1 and at most 8 characters precede it.
    // Verify that at most 3 characters follow it.
    // Verify that none of the characters which follow it are dots.
    //
    // The exceptions to this are "." and "..".  Therefore, we don't check
    // this until after we've already determined that this component is
    // neither of those.
    //

    if ((cbTrailingDotSpace != 0) && (flFlags & GTF_8_DOT_3)) {
        DWORD   cbFirstDot;
        BOOL    fNoDot;

        cbFirstDot = STRCSPN(pszBegin, _text_SingleDot);

        if (fNoDot = cbFirstDot >= cbTokenLen) {
            cbFirstDot = cbTokenLen;
        }

        if (cbFirstDot == 0
            || cbFirstDot > 8
            || cbTokenLen - cbFirstDot > 4
            || (! fNoDot && STRCSPN(pszBegin + cbFirstDot + 1, _text_SingleDot)
                            < cbTokenLen - (cbFirstDot + 1))) {
            SET_COMPUTERNAMEONLY(ERROR_INVALID_NAME);
	    }

        if( bDBCS ) {
            //
            // In case of MBCS, We also need to check the string is valid in MBCS
            // because Unicode character count is not eqaul MBCS byte count

            CHAR szCharToken[13]; // 8 + 3 + dot + null
            int  cbConverted = 0;
            BOOL bDefaultUsed = FALSE;

            // Convert Unicode string to Mbcs.
            cbConverted = WideCharToMultiByte( CP_OEMCP,  0,
                                               pszBegin, -1,
                                               szCharToken, sizeof(szCharToken),
                                               NULL, &bDefaultUsed );

            // If the converted langth is larger than the buffer, or the WideChar string
            // contains some character that is can not be repesented by MultiByte code page,
            // set error.

            if( cbConverted == FALSE || bDefaultUsed == TRUE ) {
                SET_COMPUTERNAMEONLY(ERROR_INVALID_NAME);
            } else {
                cbConverted -= 1; // Remove NULL;

                cbFirstDot = strcspn(szCharToken, ".");

                if (fNoDot = cbFirstDot >= (DWORD)cbConverted) {
                    cbFirstDot = cbConverted;
                }

                if (cbFirstDot == 0
                    || cbFirstDot > 8
                    || cbConverted - cbFirstDot > 4
                    || (! fNoDot && strcspn(szCharToken + cbFirstDot + 1, ".")
                                    < cbConverted - (cbFirstDot + 1))) {
                    SET_COMPUTERNAMEONLY(ERROR_INVALID_NAME);
                }
            }
	    }
    }

    //
    // Does it contain wildcards?
    //
    // If so, set the appropriate flag(s).
    //
    // If not, it may be a valid computername.
    //

    if (STRCSPN(pszBegin, szWildcards) < cbTokenLen) {

        *pflTokenType |= TOKEN_TYPE_WILDCARD;

        //
        // Special case the single '*' token
        //

        if (cbTokenLen == 1 && chFirstChar == TCHAR_STAR) {
            *pflTokenType |= TOKEN_TYPE_WILDONE;
        }
    } else {
        if( cbTokenLen <= MAX_PATH ) {
            *pflTokenType |= TOKEN_TYPE_COMPUTERNAME;
        }
    }

    //
    // IMPORTANT:  Now we've determined if the token is a valid computername.
    //             If the <fComputernameOnly> flag is set and it's a valid
    //             computername, then we turn off all other bits.  If it's
    //             not a valid computername, we return the stored error.
    //             If the flag isn't set, we continue with the component name
    //             processing.
    //

    if (fComputernameOnly) {
        if (*pflTokenType & TOKEN_TYPE_COMPUTERNAME) {
            *pflTokenType = TOKEN_TYPE_COMPUTERNAME;
        } else {
#ifdef DEVDEBUG
        DbgPrint("GetToken - returning usNameError (%u)\n", usNameError);
#endif
            return usNameError;
        }
    } else {

        //
        // Is this an LPT[1-9] token?
        //

        if (STRNICMP(pszBegin, szLPTName, LPT_TOKEN_LEN) == 0
            && IS_NON_ZERO_DIGIT(pszBegin[LPT_TOKEN_LEN])
            && cbTrailingDotSpace == LPT_TOKEN_LEN + 1) {
            *pflTokenType |= TOKEN_TYPE_LPT;
        }

        //
        // Is this an COM[1-9] token?
        //

        if (STRNICMP(pszBegin, szCOMName, COM_TOKEN_LEN) == 0
            && IS_NON_ZERO_DIGIT(pszBegin[COM_TOKEN_LEN])
            && cbTrailingDotSpace == COM_TOKEN_LEN + 1) {
            *pflTokenType |= TOKEN_TYPE_COM;
        }

        //
        // The remainder of the component-based token types are determined
        // by string comparisons.  In order to speed things up, we store
        // these strings in sorted order and do a binary search on them,
        // which reduces the worst-case number of comparisons from N to
        // log N (where N is the number of strings).
        //

        iLow = (ULONG)-1;
        iHigh = NUM_STRING_TOKENS;

        while (iHigh - iLow > 1) {
            iMid = (iLow + iHigh) / 2;

            //
            // We do the comparison up to the length of the longer of the
            // two strings.  This guarantees us a valid non-zero value for
            // iCmpVal if they don't match.  It also means that they won't
            // match unless they're the same length.
            //

            iCmpVal = STRNICMP(pszBegin,
                                StringTokenTable[iMid].pszTokenName,
                                max(StringTokenTable[iMid].cbTokenLen,
                                    cbTrailingDotSpace) );

            if (iCmpVal < 0) {
                iHigh = iMid;
            } else if (iCmpVal > 0) {
                iLow = iMid;
            } else {

                //
                // We have a match!
                //

                *pflTokenType |= StringTokenTable[iMid].flTokenType;

                //
                // We can only match one, so don't bother continuing
                //

                break;
            }
        }
    }

    //
    // We're done; set the end pointer and return with success
    //

    *ppszEnd = pszBegin + cbTokenLen;
#ifdef DEVDEBUG
        DbgPrint("GetToken - returning success\n");
#endif
    return 0;
}

STATIC DWORD TrailingDotsAndSpaces(LPTSTR pszToken, DWORD cbTokenLen )
{
    LPTSTR pszDotSpace = pszToken + cbTokenLen - 1;

    //
    // Scan the token until we reach the beginning or we find a
    // non-dot/space.
    //

    while (pszDotSpace >= pszToken
        && (*pszDotSpace == TCHAR_DOT || *pszDotSpace == TCHAR_SPACE)) {
        pszDotSpace--;
    }

    //
    // Increment pszDotSpace so that it points to the beginning of
    // the trailing dots and spaces (or one past the end of the token
    // if there are no trailing dots or spaces).
    //

    pszDotSpace++;

    //
    // Return the index of the first trailing dot or space (or the length
    // of the token if there were none).
    //

    return (DWORD)(pszDotSpace - pszToken);
}


STATIC BOOL IsIllegalCharacter(LPTSTR pszString)
{
//    TCHAR   chTemp;
//    BOOL    fRetVal;

    //
    // Return FALSE immediately for a null character
    //

    if (*pszString == TCHAR_EOS) {
        return FALSE;
    }

    //
    // If the character is a single-byte character, we can simply see if
    // it's illegal by calling strchrf() on the illegal character array.
    // If it's a double-byte character, we have to do it the slower way
    // (with strcspnf).
    //

//    if (!IS_LEAD_BYTE(*pszString)) {
        return (STRCHR(szIllegalChars, *pszString) != NULL);
//    } else {
//
//        //
//        // We set the character after the double-byte character to the
//        // null character, to speed things up.
//        //
//
//        chTemp = pszString[2];
//        pszString[2] = TCHAR_EOS;
//        fRetVal = STRCSPN(pszString, szIllegalChars) == 0;
//        pszString[2] = chTemp;
//
//        return fRetVal;
//    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\getconfg.c ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    getconfg.c

Abstract:

    This module contains routines for manipulating configuration
    information.  The following functions available are:

        NetpGetComputerName
        NetpGetDomainId

    Currently configuration information is kept in NT.CFG.
    Later it will be kept by the configuration manager.

Author:

    Dan Lafferty (danl)     09-Apr-1991

Environment:

    User Mode -Win32

Revision History:

    09-Apr-1991     danl
        created
    27-Sep-1991 JohnRo
        Fixed somebody's attempt to do UNICODE.
    20-Mar-1992 JohnRo
        Get rid of old config helper callers.
        Fixed NTSTATUS vs. NET_API_STATUS bug.
    07-May-1992 JohnRo
        Enable win32 registry for NET tree by calling GetComputerName().
        Avoid DbgPrint if possible.
    08-May-1992 JohnRo
        Use <prefix.h> equates.
    08-May-1992 JohnRo
        Added conditional debug output of computer name.

--*/


// These must be included first:

#include <nt.h>         // (temporary for config.h)
#include <ntrtl.h>      // (temporary for config.h)
#include <nturtl.h>     // (temporary for config.h)
#include <windef.h>     // IN, VOID, etc.
#include <lmcons.h>     // NET_API_STATUS.

// These may be included in any order:

#include <config.h>     // LPNET_CONFIG_HANDLE, NetpOpenConfigData, etc.
#include <confname.h>   // SECT_NT_WKSTA, etc.
#include <debuglib.h>   // IF_DEBUG().
#include <lmapibuf.h>   // NetApiBufferFree().
#include <lmerr.h>      // NO_ERROR, NERR_ and ERROR_ equates.
#include <netdebug.h>   // NetpAssert().
#include <netlib.h>     // LOCAL_DOMAIN_TYPE_PRIMARY
#include <prefix.h>     // PREFIX_ equates.
#include <tstr.h>       // ATOL(), STRLEN(), TCHAR_SPACE, etc.
#include <winbase.h>    // LocalAlloc().


/****************************************************************************/
NET_API_STATUS
NetpGetComputerName (
    IN  LPWSTR   *ComputerNamePtr
    )

/*++

Routine Description:

    This routine obtains the computer name from a persistent database.
    Currently that database is the NT.CFG file.

    This routine makes no assumptions on the length of the computername.
    Therefore, it allocates the storage for the name using NetApiBufferAllocate.
    It is necessary for the user to free that space using NetApiBufferFree when
    finished.

Arguments:

    ComputerNamePtr - This is a pointer to the location where the pointer
        to the computer name is to be placed.

Return Value:

    NERR_Success - If the operation was successful.

    It will return assorted Net or Win32 error messages if not.

--*/
{
    return NetpGetComputerNameEx( ComputerNamePtr, FALSE );
}


/****************************************************************************/
NET_API_STATUS
NetpGetComputerNameEx (
    IN  LPWSTR   *ComputerNamePtr,
    IN  BOOL PhysicalNetbiosName
    )

/*++

Routine Description:

    This routine obtains the computer name from a persistent database.
    Currently that database is the NT.CFG file.

    This routine makes no assumptions on the length of the computername.
    Therefore, it allocates the storage for the name using NetApiBufferAllocate.
    It is necessary for the user to free that space using NetApiBufferFree when
    finished.

Arguments:

    ComputerNamePtr - This is a pointer to the location where the pointer
        to the computer name is to be placed.

Return Value:

    NERR_Success - If the operation was successful.

    It will return assorted Net or Win32 error messages if not.

--*/
{
    NET_API_STATUS ApiStatus;
    DWORD NameSize = MAX_COMPUTERNAME_LENGTH + 1;   // updated by win32 API.

    //
    // Check for caller's errors.
    //
    if (ComputerNamePtr == NULL) {
        return (ERROR_INVALID_PARAMETER);
    }

    //
    // Allocate space for computer name.
    //
    ApiStatus = NetApiBufferAllocate(
            (MAX_COMPUTERNAME_LENGTH + 1) * sizeof(WCHAR),
            (LPVOID *) ComputerNamePtr);
    if (ApiStatus != NO_ERROR) {
        return (ApiStatus);
    }
    NetpAssert( *ComputerNamePtr != NULL );

    //
    // Ask system what current computer name is.
    //
    if ( !GetComputerNameEx(
            PhysicalNetbiosName ?
                ComputerNamePhysicalNetBIOS :
                ComputerNameNetBIOS,
            *ComputerNamePtr,
            &NameSize ) ) {

        ApiStatus = (NET_API_STATUS) GetLastError();
        NetpAssert( ApiStatus != NO_ERROR );
        (VOID) NetApiBufferFree( *ComputerNamePtr );
        *ComputerNamePtr = NULL;
        return (ApiStatus);
    }
    NetpAssert( STRLEN( *ComputerNamePtr ) <= MAX_COMPUTERNAME_LENGTH );

    //
    // All done.
    //
    IF_DEBUG( CONFIG ) {
        NetpKdPrint(( PREFIX_NETLIB "NetpGetComputerName: name is "
                FORMAT_LPWSTR ".\n", *ComputerNamePtr ));
    }

    return (NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\hexdump.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    HexDump.c

Abstract:

    This module performs debug hex dumps.

Author:

    John Rogers (JohnRo) 25-Apr-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    25-Apr-1991 JohnRo
        Created procedure version from macro in <netdebug.h>.
    19-May-1991 JohnRo
        Make LINT-suggested changes.
    12-Jun-1991 JohnRo
        Improved output readability.
--*/


// These must be included first:

#include <windef.h>             // IN, LPBYTE, LPVOID, NULL, etc.

// These may be included in any order:

#include <ctype.h>              // isprint().
#include <netdebug.h>           // My prototype, NetpKdPrint(()).


#if DBG

#ifndef MIN
#define MIN(a,b)    ( ( (a) < (b) ) ? (a) : (b) )
#endif


#define DWORDS_PER_LINE  4
#define BYTES_PER_LINE   (DWORDS_PER_LINE * sizeof(DWORD))

#define SPACE_BETWEEN_BYTES    NetpKdPrint((" "))
#define SPACE_BETWEEN_DWORDS   NetpKdPrint((" "))


DBGSTATIC VOID
NetpDbgHexDumpLine(
    IN LPBYTE StartAddr,
    IN DWORD BytesInThisLine
    )
{
    LPBYTE BytePtr;
    DWORD BytesDone;
    DWORD HexPosition;

    NetpKdPrint((FORMAT_LPVOID " ", (LPVOID) StartAddr));

    BytePtr = StartAddr;
    BytesDone = 0;
    while (BytesDone < BytesInThisLine) {
        NetpKdPrint(("%02X", *BytePtr));  // space for "xx" (see pad below).
        SPACE_BETWEEN_BYTES;
        ++BytesDone;
        if ( (BytesDone % sizeof(DWORD)) == 0) {
            SPACE_BETWEEN_DWORDS;
        }
        ++BytePtr;
    }

    HexPosition = BytesDone;
    while (HexPosition < BYTES_PER_LINE) {
        NetpKdPrint(("  "));  // space for "xx" (see byte above).
        SPACE_BETWEEN_BYTES;
        ++HexPosition;
        if ( (HexPosition % sizeof(DWORD)) == 0) {
            SPACE_BETWEEN_DWORDS;
        }
    }

    BytePtr = StartAddr;
    BytesDone = 0;
    while (BytesDone < BytesInThisLine) {
        if (isprint(*BytePtr)) {
            NetpKdPrint(( FORMAT_CHAR, (CHAR) *BytePtr ));
        } else {
            NetpKdPrint(( "." ));
        }
        ++BytesDone;
        ++BytePtr;
    }
    NetpKdPrint(("\n"));

} // NetpDbgHexDumpLine

#endif // DBG

// NetpDbgHexDump: do a hex dump of some number of bytes to the debug
// terminal or whatever.  This is a no-op in a nondebug build.

#undef NetpDbgHexDump
VOID
NetpDbgHexDump(
    IN LPBYTE StartAddr,
    IN DWORD Length
    )

{
#if DBG
    DWORD BytesLeft = Length;
    LPBYTE LinePtr = StartAddr;
    DWORD LineSize;

    while (BytesLeft > 0) {
        LineSize = MIN(BytesLeft, BYTES_PER_LINE);
        NetpDbgHexDumpLine( LinePtr, LineSize );
        BytesLeft -= LineSize;
        LinePtr += LineSize;
    }
#endif // DBG

} // NetpDbgHexDump
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\getpriv.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    GETPRIV.C

Abstract:

    Contains functions for obtaining and relinquishing privileges

Author:

    Dan Lafferty (danl)     20-Mar-1991

Environment:

    User Mode -Win32

Revision History:

    20-Mar-1991     danl
        created

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <netdebug.h>
#include <debuglib.h>


#define PRIVILEGE_BUF_SIZE  512


DWORD
NetpGetPrivilege(
    IN  DWORD       numPrivileges,
    IN  PULONG      pulPrivileges
    )
/*++

Routine Description:

    This function alters the privilege level for the current thread.

    It does this by duplicating the token for the current thread, and then
    applying the new privileges to that new token, then the current thread
    impersonates with that new token.

    Privileges can be relinquished by calling NetpReleasePrivilege().

Arguments:

    numPrivileges - This is a count of the number of privileges in the
        array of privileges.

    pulPrivileges - This is a pointer to the array of privileges that are
        desired.  This is an array of ULONGs.

Return Value:

    NO_ERROR - If the operation was completely successful.

    Otherwise, it returns mapped return codes from the various NT
    functions that are called.

--*/
{
    DWORD                       status;
    NTSTATUS                    ntStatus;
    HANDLE                      ourToken;
    HANDLE                      newToken;
    OBJECT_ATTRIBUTES           Obja;
    SECURITY_QUALITY_OF_SERVICE SecurityQofS;
    ULONG                       bufLen;
    ULONG                       returnLen;
    PTOKEN_PRIVILEGES           pPreviousState;
    PTOKEN_PRIVILEGES           pTokenPrivilege = NULL;
    DWORD                       i;

    //
    // Initialize the Privileges Structure
    //
    pTokenPrivilege = LocalAlloc(LMEM_FIXED, sizeof(TOKEN_PRIVILEGES) +
                        (sizeof(LUID_AND_ATTRIBUTES) * numPrivileges));

    if (pTokenPrivilege == NULL) {
        status = GetLastError();
        IF_DEBUG(SECURITY) {
            NetpKdPrint(("NetpGetPrivilege:LocalAlloc Failed %d\n", status));
        }
        return(status);
    }
    pTokenPrivilege->PrivilegeCount  = numPrivileges;
    for (i=0; i<numPrivileges ;i++ ) {
        pTokenPrivilege->Privileges[i].Luid = RtlConvertUlongToLuid(
                                                pulPrivileges[i]);
        pTokenPrivilege->Privileges[i].Attributes = SE_PRIVILEGE_ENABLED;

    }

    //
    // Initialize Object Attribute Structure.
    //
    InitializeObjectAttributes(&Obja,NULL,0L,NULL,NULL);

    //
    // Initialize Security Quality Of Service Structure
    //
    SecurityQofS.Length = sizeof(SECURITY_QUALITY_OF_SERVICE);
    SecurityQofS.ImpersonationLevel = SecurityImpersonation;
    SecurityQofS.ContextTrackingMode = FALSE;     // Snapshot client context
    SecurityQofS.EffectiveOnly = FALSE;

    Obja.SecurityQualityOfService = &SecurityQofS;

    //
    // Allocate storage for the structure that will hold the Previous State
    // information.
    //
    pPreviousState = LocalAlloc(LMEM_FIXED, PRIVILEGE_BUF_SIZE);
    if (pPreviousState == NULL) {

        status = GetLastError();

        IF_DEBUG(SECURITY) {
            NetpKdPrint(("NetpGetPrivilege: LocalAlloc Failed "FORMAT_DWORD"\n",
            status));
        }

        LocalFree(pTokenPrivilege);
        return(status);

    }

    //
    // Open our own Token
    //
    ntStatus = NtOpenProcessToken(
                NtCurrentProcess(),
                TOKEN_DUPLICATE,
                &ourToken);

    if (!NT_SUCCESS(ntStatus)) {
        IF_DEBUG(SECURITY) {
            NetpKdPrint(( "NetpGetPrivilege: NtOpenThreadToken Failed "
                "FORMAT_NTSTATUS" "\n", ntStatus));
        }

        LocalFree(pPreviousState);
        LocalFree(pTokenPrivilege);
        return(RtlNtStatusToDosError(ntStatus));
    }

    //
    // Duplicate that Token
    //
    ntStatus = NtDuplicateToken(
                ourToken,
                TOKEN_IMPERSONATE | TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                &Obja,
                FALSE,                  // Duplicate the entire token
                TokenImpersonation,     // TokenType
                &newToken);             // Duplicate token

    if (!NT_SUCCESS(ntStatus)) {
        IF_DEBUG(SECURITY) {
            NetpKdPrint(( "NetpGetPrivilege: NtDuplicateToken Failed "
                "FORMAT_NTSTATUS" "\n", ntStatus));
        }

        LocalFree(pPreviousState);
        LocalFree(pTokenPrivilege);
        NtClose(ourToken);
        return(RtlNtStatusToDosError(ntStatus));
    }

    //
    // Add new privileges
    //
    bufLen = PRIVILEGE_BUF_SIZE;
    ntStatus = NtAdjustPrivilegesToken(
                newToken,                   // TokenHandle
                FALSE,                      // DisableAllPrivileges
                pTokenPrivilege,            // NewState
                bufLen,                     // bufferSize for previous state
                pPreviousState,             // pointer to previous state info
                &returnLen);                // numBytes required for buffer.

    if (ntStatus == STATUS_BUFFER_TOO_SMALL) {

        LocalFree(pPreviousState);

        bufLen = returnLen;

        pPreviousState = LocalAlloc(LMEM_FIXED, bufLen);


        ntStatus = NtAdjustPrivilegesToken(
                    newToken,               // TokenHandle
                    FALSE,                  // DisableAllPrivileges
                    pTokenPrivilege,        // NewState
                    bufLen,                 // bufferSize for previous state
                    pPreviousState,         // pointer to previous state info
                    &returnLen);            // numBytes required for buffer.

    }
    if (!NT_SUCCESS(ntStatus)) {
        IF_DEBUG(SECURITY) {
            NetpKdPrint(( "NetpGetPrivilege: NtAdjustPrivilegesToken Failed "
                "FORMAT_NTSTATUS" "\n", ntStatus));
        }

        LocalFree(pPreviousState);
        LocalFree(pTokenPrivilege);
        NtClose(ourToken);
        NtClose(newToken);
        return(RtlNtStatusToDosError(ntStatus));
    }

    //
    // Begin impersonating with the new token
    //
    ntStatus = NtSetInformationThread(
                NtCurrentThread(),
                ThreadImpersonationToken,
                (PVOID)&newToken,
                (ULONG)sizeof(HANDLE));

    if (!NT_SUCCESS(ntStatus)) {
        IF_DEBUG(SECURITY) {
            NetpKdPrint(( "NetpGetPrivilege: NtAdjustPrivilegesToken Failed "
                "FORMAT_NTSTATUS" "\n", ntStatus));
        }

        LocalFree(pPreviousState);
        LocalFree(pTokenPrivilege);
        NtClose(ourToken);
        NtClose(newToken);
        return(RtlNtStatusToDosError(ntStatus));
    }

    LocalFree(pPreviousState);
    LocalFree(pTokenPrivilege);
    NtClose(ourToken);
    NtClose(newToken);

    return(NO_ERROR);
}

DWORD
NetpReleasePrivilege(
    VOID
    )
/*++

Routine Description:

    This function relinquishes privileges obtained by calling NetpGetPrivilege().

Arguments:

    none

Return Value:

    NO_ERROR - If the operation was completely successful.

    Otherwise, it returns mapped return codes from the various NT
    functions that are called.


--*/
{
    NTSTATUS    ntStatus;
    HANDLE      NewToken;


    //
    // Revert To Self.
    //
    NewToken = NULL;

    ntStatus = NtSetInformationThread(
                NtCurrentThread(),
                ThreadImpersonationToken,
                (PVOID)&NewToken,
                (ULONG)sizeof(HANDLE));

    if ( !NT_SUCCESS(ntStatus) ) {
        return(RtlNtStatusToDosError(ntStatus));
    }


    return(NO_ERROR);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\joincrypt.c ===
/*++

Copyright (c) 1987-1996  Microsoft Corporation

Module Name:

    joincrypt.c

Abstract:

    Authentication related functions required by netjoin

Author:

    kumarp 29-May-1999

Notes:
    The functions in this file used to be made avaialbe by
    including net\svcdlls\logonsrv\server\ssiauth.c. This led to several
    problems due to which, the functions are now copied from that file
    into this separate file.

--*/


#pragma hdrstop

#define WKSTA_NETLOGON
#define NETSETUP_JOIN

#include <netsetp.h>
#include <crypt.h>
#include <ntsam.h>
#include <logonmsv.h>
#include <lmshare.h>
#include <wincrypt.h>
#include <netlogon.h>
#include <logonp.h>
#include <logonmsv.h>
#include <ssi.h>
#include <wchar.h>
#include "joinp.h"

LONG NlGlobalSessionCounter = 0;
HCRYPTPROV NlGlobalCryptProvider = (HCRYPTPROV)NULL;


#define NlPrint(x)
#define NlpDumpBuffer(x,y,z)

BOOLEAN
NlGenerateRandomBits(
    PUCHAR Buffer,
    ULONG  BufferLen
    );
#define NlQuerySystemTime( _Time ) GetSystemTimeAsFileTime( (LPFILETIME)(_Time) )


VOID
NlComputeChallenge(
    OUT PNETLOGON_CREDENTIAL Challenge
    );

VOID
NlComputeCredentials(
    IN PNETLOGON_CREDENTIAL Challenge,
    OUT PNETLOGON_CREDENTIAL Credential,
    IN PNETLOGON_SESSION_KEY SessionKey
    );



NTSTATUS
NlMakeSessionKey(
    IN ULONG NegotiatedFlags,
    IN PNT_OWF_PASSWORD CryptKey,
    IN PNETLOGON_CREDENTIAL ClientChallenge,
    IN PNETLOGON_CREDENTIAL ServerChallenge,
    OUT PNETLOGON_SESSION_KEY SessionKey
    )
/*++

Routine Description:

      Build an encryption key for use in authentication for
      this RequestorName.

Arguments:

      NegotiatedFlags - Determines the strength of the key.

      CryptKey -- The OWF password of the user account being used.

      ClientChallenge --  8 byte (64 bit) number generated by caller

      ServerChallenge -- 8 byte (64 bit) number generated by primary

      SessionKey --  16 byte (128 bit) number generated at both ends
        If the key strength is weak, the last 64 bits will be zero.

Return Value:

    TRUE: Success
    FALSE: Failure

    NT status code.

--*/
{
    NTSTATUS Status;
    BLOCK_KEY BlockKey;
    NETLOGON_SESSION_KEY TempSessionKey;

#ifndef NETSETUP_JOIN
    PCHECKSUM_BUFFER CheckBuffer = NULL;
    PCHECKSUM_FUNCTION Check;
#endif // NETSETUP_JOIN

    //
    // Start with a zero key
    //
    RtlZeroMemory(SessionKey, sizeof(NETLOGON_SESSION_KEY));

#ifdef NETSETUP_JOIN
    UNREFERENCED_PARAMETER( NegotiatedFlags );
#else // NETSETUP_JOIN
    //
    // If the caller wants a strong key,
    //  Compute it.
    //
    if ( NegotiatedFlags & NETLOGON_SUPPORTS_STRONG_KEY ) {

        // PCRYPTO_SYSTEM CryptSystem;

        UCHAR LocalChecksum[sizeof(*SessionKey)];
        // ULONG OutputSize;

        //
        // Initialize the checksum routines.
        //

        Status = CDLocateCheckSum( KERB_CHECKSUM_MD5_HMAC, &Check);
        if (!NT_SUCCESS(Status)) {
            NlPrint(( NL_CRITICAL,"NlMakeSessionKey: Failed to load checksum routines: 0x%x\n", Status));
            goto Cleanup;
        }

        ASSERT(Check->CheckSumSize <= sizeof(LocalChecksum));

        Status = Check->InitializeEx(
                    (LPBYTE)CryptKey,
                    sizeof( *CryptKey ),
                    0,              // no message type
                    &CheckBuffer );

        if (!NT_SUCCESS(Status)) {
            NlPrint(( NL_CRITICAL,"NlMakeSessionKey: Failed to initialize checksum routines: 0x%x\n", Status));
            goto Cleanup;
        }


        //
        // Sum in the client challenge, a constant, and the server challenge
        //

        Check->Sum( CheckBuffer,
                    sizeof(*ClientChallenge),
                    (PUCHAR)ClientChallenge );

        Check->Sum( CheckBuffer,
                    sizeof(*ServerChallenge),
                    (PUCHAR)ServerChallenge );

        //
        // Finish the checksum
        //

        (void) Check->Finalize(CheckBuffer, LocalChecksum);


        //
        // Copy the checksum into the message.
        //

        ASSERT( sizeof(LocalChecksum) >= sizeof(*SessionKey) );
        RtlCopyMemory( SessionKey, LocalChecksum, sizeof(*SessionKey) );


    //
    // Compute weaker (but backward compatible key)
    //
    } else {
#endif // NETSETUP_JOIN

        //
        // we will have a 128 bit key (64 bit encrypted rest padded with 0s)
        //
        // SessionKey = C + P  (arithmetic sum ignore carry)
        //

        *((unsigned long * ) SessionKey) =
            *((unsigned long * ) ClientChallenge) +
            *((unsigned long * ) ServerChallenge);

        *((unsigned long * )((LPBYTE)SessionKey + 4)) =
            *((unsigned long * )((LPBYTE)ClientChallenge + 4)) +
            *((unsigned long * )((LPBYTE)ServerChallenge + 4));


        //
        // CryptKey is our 16 byte key to be used as described in codespec
        // use first 7 bytes of CryptKey for first encryption
        //

        RtlCopyMemory( &BlockKey, CryptKey, BLOCK_KEY_LENGTH );

        Status = RtlEncryptBlock(
                    (PCLEAR_BLOCK) SessionKey,   // Clear text
                    &BlockKey,                  // Key
                    (PCYPHER_BLOCK) &TempSessionKey);    // Cypher Block

        if ( !NT_SUCCESS( Status ) ) {
            goto Cleanup;
        }


        //
        // Further encrypt the encrypted "SessionKey" using upper 7 bytes
        //

        ASSERT( LM_OWF_PASSWORD_LENGTH == 2*BLOCK_KEY_LENGTH+2 );

        RtlCopyMemory( &BlockKey,
                       ((PUCHAR)CryptKey) + 2 + BLOCK_KEY_LENGTH,
                       BLOCK_KEY_LENGTH );

        Status = RtlEncryptBlock(
                    (PCLEAR_BLOCK) &TempSessionKey,   // Clear text
                    &BlockKey,                  // Key
                    (PCYPHER_BLOCK) SessionKey);    // Cypher Block

        if ( !NT_SUCCESS( Status ) ) {
            goto Cleanup;
        }
#ifndef NETSETUP_JOIN
    }
#endif // NETSETUP_JOIN

Cleanup:
#ifndef NETSETUP_JOIN
    if (CheckBuffer != NULL) {
        Status = Check->Finish(&CheckBuffer);

        if (!NT_SUCCESS(Status)) {
            NlPrint(( NL_CRITICAL,"NlMakeSessionKey: Failed to finish checksum: 0x%x\n", Status));
        }
    }
#endif // NETSETUP_JOIN

    return Status;
}


VOID
NlComputeChallenge(
    OUT PNETLOGON_CREDENTIAL Challenge
    )

/*++

Routine Description:

    Generates a 64 bit challenge

Arguments:

    Challenge - Returns the computed challenge

Return Value:

    None.

--*/
{

    //
    // Use an ideal random bit generator.
    //

    if (!NlGenerateRandomBits( (LPBYTE)Challenge, sizeof(*Challenge) )) {
        NlPrint((NL_CRITICAL, "Can't NlGenerateRandomBits\n" ));
    }

    return;
}

VOID
NlComputeCredentials(
    IN PNETLOGON_CREDENTIAL Challenge,
    OUT PNETLOGON_CREDENTIAL Credential,
    IN PNETLOGON_SESSION_KEY SessionKey
    )
/*++

Routine Description:

    Calculate the credentials by encrypting the 8 byte
    challenge with first 7 bytes of sessionkey and then
    further encrypting it by next 7 bytes of sessionkey.

Arguments:

    Challenge  - Supplies the 8 byte (64 bit) challenge

    Credential - Returns the 8  byte (64 bit) number generated

    SessionKey - Supplies 14 byte (112 bit) encryption key
        The buffer is 16 bytes (128 bits) long.  For a weak key, the trailing 8 bytes
        are zero.  For a strong key, this routine ingored that trailing 2 bytes of
        useful key.

Return Value:

    NONE

--*/
{
    NTSTATUS Status;
    BLOCK_KEY BlockKey;
    CYPHER_BLOCK IntermediateBlock;

    RtlZeroMemory(Credential, sizeof(*Credential));

    //
    // use first 7 bytes of SessionKey for first encryption
    //

    RtlCopyMemory( &BlockKey, SessionKey, BLOCK_KEY_LENGTH );

    Status = RtlEncryptBlock( (PCLEAR_BLOCK) Challenge, // Cleartext
                              &BlockKey,                // Key
                              &IntermediateBlock );     // Cypher Block

    ASSERT( NT_SUCCESS(Status) );

    //
    // further encrypt the encrypted Credential using next 7 bytes
    //

    RtlCopyMemory( &BlockKey,
                   ((PUCHAR)SessionKey) + BLOCK_KEY_LENGTH,
                   BLOCK_KEY_LENGTH );

    Status = RtlEncryptBlock( (PCLEAR_BLOCK) &IntermediateBlock, // Cleartext
                              &BlockKey,                // Key
                              Credential );             // Cypher Block

    ASSERT( NT_SUCCESS(Status) );

    return;

}

BOOLEAN
NlGenerateRandomBits(
    PUCHAR Buffer,
    ULONG  BufferLen
    )
/*++

Routine Description:

    Generates random bits

Arguments:

    pBuffer - Buffer to fill

    cbBuffer - Number of bytes in buffer

Return Value:

    Status of the operation.

--*/

{
    if( !CryptGenRandom( NlGlobalCryptProvider, BufferLen, ( LPBYTE )Buffer ) )
    {
        NlPrint((NL_CRITICAL, "CryptGenRandom failed with %lu\n", GetLastError() ));
        return FALSE;
    }

    return TRUE;
}



NET_API_STATUS
NET_API_FUNCTION
NetpValidateMachineAccount(
    IN  LPWSTR      lpDc,
    IN  LPWSTR      lpDomain,
    IN  LPWSTR      lpMachine,
    IN  LPWSTR      lpPassword
    )
/*++

Routine Description:

    Performs validation that the machine account exists and has the same password we expect

    The internals of this function were lifted completely from SimulateFullSync() in
    ..\svcdlls\logonsrv\server\nltest.c,

Arguments:

    lpDc -- Name of the Dc
    lpDomain -- Name of the domain
    lpMachine -- Current machine
    lpPassword -- Password that should be on the account.


Returns:

    NERR_Success -- Success

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;

    NETLOGON_CREDENTIAL ServerChallenge;
    NETLOGON_CREDENTIAL ClientChallenge;
    NETLOGON_CREDENTIAL ComputedServerCredential;
    NETLOGON_CREDENTIAL ReturnedServerCredential;
    NETLOGON_CREDENTIAL AuthenticationSeed;
    NETLOGON_SESSION_KEY SessionKey;
    WCHAR AccountName[SSI_ACCOUNT_NAME_LENGTH+1];
    UNICODE_STRING Password;
    NT_OWF_PASSWORD NtOwfPassword;

    UNREFERENCED_PARAMETER( lpDomain );

    ASSERT( lpPassword );

    //
    // initialize Crypto Provider.
    // (required for NlComputeChallenge).
    //

    if ( !CryptAcquireContext(
                    &NlGlobalCryptProvider,
                    NULL,
                    NULL,
                    PROV_RSA_FULL,
                    CRYPT_VERIFYCONTEXT
                    ))
    {
        NlGlobalCryptProvider = (HCRYPTPROV)NULL;
        return (NET_API_STATUS)GetLastError();
    }

    //
    // Prepare our challenge
    //

    NlComputeChallenge( &ClientChallenge );

    //
    // free cryptographic service provider.
    //
    if ( NlGlobalCryptProvider ) {
        CryptReleaseContext( NlGlobalCryptProvider, 0 );
        NlGlobalCryptProvider = (HCRYPTPROV)NULL;
    }


    //
    // Get the primary's challenge
    //

    Status = I_NetServerReqChallenge(lpDc,
                                     lpMachine,
                                     &ClientChallenge,
                                     &ServerChallenge );

    if ( !NT_SUCCESS( Status ) ) {

        goto ValidateMachineAccountError;
    }


    Password.Length = Password.MaximumLength = wcslen(lpPassword) * sizeof(WCHAR);
    Password.Buffer = lpPassword;

    //
    // Compute the NT OWF password for this user.
    //

    Status = RtlCalculateNtOwfPassword( &Password, &NtOwfPassword );

    if ( !NT_SUCCESS( Status ) ) {

        goto ValidateMachineAccountError;

    }


    //
    // Actually compute the session key given the two challenges and the
    // password.
    //

    NlMakeSessionKey(
#if(_WIN32_WINNT >= 0x0500)
                      0,
#endif
                      &NtOwfPassword,
                      &ClientChallenge,
                      &ServerChallenge,
                      &SessionKey );

    //
    // Prepare credentials using our challenge.
    //

    NlComputeCredentials( &ClientChallenge,
                          &AuthenticationSeed,
                          &SessionKey );

    //
    // Send these credentials to primary. The primary will compute
    // credentials using the challenge supplied by us and compare
    // with these. If both match then it will compute credentials
    // using its challenge and return it to us for verification
    //

    wcscpy( AccountName, lpMachine );
    wcscat( AccountName, SSI_ACCOUNT_NAME_POSTFIX);

    Status = I_NetServerAuthenticate( lpDc,
                                      AccountName,
                                      WorkstationSecureChannel,
                                      lpMachine,
                                      &AuthenticationSeed,
                                      &ReturnedServerCredential );

    if ( !NT_SUCCESS( Status ) ) {

        goto ValidateMachineAccountError;

    }


    //
    // The DC returned a server credential to us,
    //  ensure the server credential matches the one we would compute.
    //

    NlComputeCredentials( &ServerChallenge,
                          &ComputedServerCredential,
                          &SessionKey);


    if (RtlCompareMemory( &ReturnedServerCredential,
                          &ComputedServerCredential,
                          sizeof(ReturnedServerCredential)) !=
                          sizeof(ReturnedServerCredential)) {

        Status =  STATUS_ACCESS_DENIED;
    }


ValidateMachineAccountError:

    if ( Status == STATUS_ACCESS_DENIED ) {

        Status = STATUS_LOGON_FAILURE;
    }

    if ( !NT_SUCCESS( Status ) ) {

        NetpLog(( "Failed to validate machine account for %ws against %ws: 0x%lx\n",
                  lpMachine, lpDc, Status ));
    }



    return( RtlNtStatusToDosError( Status ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\joinp.h ===
/*++

Copyright (c) 1997 - 1997  Microsoft Corporation

Module Name:

    joinp.h

Abstract:

    Private definitions and prototypes of helper functions for netjoin.
    This file is intended to be included only be netjoin.c & joinutl.c.

Author:

    kumarp 17-May-1999

--*/

#ifndef __JOINP_H__
#define __JOINP_H__

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef __cplusplus
extern "C" {
#endif


LPWSTR
GetStrPtr(IN LPWSTR szString OPTIONAL);

LPWSTR
GetStrPtr(IN LPWSTR szString OPTIONAL);

NET_API_STATUS
NET_API_FUNCTION
NetpDuplicateString(IN  LPCWSTR szSrc,
                    IN  LONG    cchSrc,
                    OUT LPWSTR* pszDst);


NET_API_STATUS
NET_API_FUNCTION
NetpGeneratePassword(
    IN  LPCWSTR szMachine,
    IN  BOOL    fRandomPwdPreferred,
    IN  LPCWSTR szDcName,
    IN  BOOL    fIsNt4Dc,
    OUT LPWSTR  szPassword
    );

NET_API_STATUS
NET_API_FUNCTION
NetpGenerateRandomPassword(
    OUT LPWSTR szPassword
    );

void
NetpGenerateDefaultPassword(
    IN  LPCWSTR szMachine,
    OUT LPWSTR szPassword
    );

BOOL
NetpIsDefaultPassword(
    IN  LPCWSTR szMachine,
    IN  LPWSTR  szPassword
    );


NET_API_STATUS
NET_API_FUNCTION
NetpGetNt4RefusePasswordChangeStatus(
    IN  LPCWSTR Nt4Dc,
    OUT BOOL* RefusePasswordChangeSet
    );


NET_API_STATUS
NET_API_FUNCTION
NetpGetComputerNameAllocIfReqd(
    OUT LPWSTR* ppwszMachine,
    IN  UINT    cLen
    );

NTSTATUS
NetpGetLsaHandle(
    IN  LPWSTR      lpServer,     OPTIONAL
    IN  LSA_HANDLE  PolicyHandle, OPTIONAL
    OUT PLSA_HANDLE pPolicyHandle
    );

NET_API_STATUS
NET_API_FUNCTION
NetpConcatStrings(IN  LPCWSTR szSrc1,
                  IN  LONG    cchSrc1,
                  IN  LPCWSTR szSrc2,
                  IN  LONG    cchSrc2,
                  OUT LPWSTR* pszDst);

NET_API_STATUS
NET_API_FUNCTION
NetpConcatStrings3(IN  LPCWSTR szSrc1,
                   IN  LONG    cchSrc1,
                   IN  LPCWSTR szSrc2,
                   IN  LONG    cchSrc2,
                   IN  LPCWSTR szSrc3,
                   IN  LONG    cchSrc3,
                   OUT LPWSTR* pszDst);

NET_API_STATUS
NET_API_FUNCTION
NetpVerifyStrOemCompatibleOnMachine(
    IN  LPCWSTR  szRemoteMachine,
    IN  LPCWSTR  szString
    );



#define NJA_UpdateNetlogonCache      0x00001
#define NJA_SetPolicyDomainInfo      0x00002
#define NJA_AddToLocalGroups         0x00004
#define NJA_RemoveFromLocalGroups    0x00008
#define NJA_SetNetlogonState         0x00010
#define NJA_SetTimeSvcJoin           0x00020
#define NJA_SetTimeSvcUnjoin         0x00040
#define NJA_RecordDcInfo             0x00080
#define NJA_GenMachinePassword       0x00100
#define NJA_SetMachinePassword       0x00200
#define NJA_CreateAccount            0x00400
#define NJA_UseSpecifiedOU           0x00800
#define NJA_GetPolicyDomainInfo      0x01000
#define NJA_RandomPwdPreferred       0x02000
#define NJA_ValidateMachineAccount   0x04000
#define NJA_DeleteAccount            0x08000
#define NJA_DeleteMachinePassword    0x10000
#define NJA_RemoveDnsRegistrations   0x20000
#define NJA_IgnoreErrors             0x40000
#define NJA_RollbackOnFailure        0x80000
#define NJA_SetAutoenrolSvcJoin      0x100000
#define NJA_SetAutoenrolSvcUnjoin    0x200000

#define NJA_NeedDc (NJA_RecordDcInfo |\
                    NJA_SetMachinePassword |\
                    NJA_CreateAccount |\
                    NJA_DeleteAccount |\
                    NJA_GetPolicyDomainInfo |\
                    NJA_ValidateMachineAccount \
                    )

typedef struct _NET_JOIN_STATE
{
    LPCWSTR szOU;
    LPCWSTR szDomainName;
    POLICY_PRIMARY_DOMAIN_INFO* pPolicyPDI;
    POLICY_DNS_DOMAIN_INFO* pPolicyDDI;

    LPCWSTR szMachinePassword;

    USHORT  uiNetlogonStartType;
    USHORT  uiNetlogonState;
} NET_JOIN_STATE;

NET_API_STATUS
NET_API_FUNCTION
NetpApplyJoinState(
    IN  NET_JOIN_STATE* pJoinState,
    IN  DWORD           dwJoinAction,
    IN  LPWSTR          szMachineName,   OPTIONAL
    IN  LPWSTR          szUser,          OPTIONAL
    IN  LPWSTR          szUserPassword,  OPTIONAL
    IN  LPWSTR          szPreferredDc    OPTIONAL
    );

#ifdef __cplusplus
}
#endif

NET_API_STATUS
NET_API_FUNCTION
NetpWaitForNetlogonSc(
    IN LPCWSTR szDomainName
    );

NET_API_STATUS
NET_API_FUNCTION
NetpUpdateW32timeConfig(
    IN PCSTR szW32timeJoinConfigFuncName
    );

NET_API_STATUS
NET_API_FUNCTION
NetpUpdateAutoenrolConfig(
    IN BOOL UnjoinDomain
    );

#endif // __JOINP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\joinutl.c ===
/*++

Copyright (c) 1998 - 1998  Microsoft Corporation

Module Name:

    ldapjoin.c

Abstract:

    NetJoin support functions for accessing the DS via LDAP, validating names, and handling LSA
    functionality

Author:

    Mac McLain   (MacM)     27-Jan-1998  Name validation code based on ui\common\lmobj\lmobj code
                                         by ThomasPa

Environment:

    User mode only.

Revision History:

--*/
// Netlib uses DsGetDcName AND is linked into netapi32 where DsGetDcName is
// implemented. So define that we aren't importing the API.
#define _DSGETDCAPI_

#include <netsetp.h>
#include <lmaccess.h>
#include <wincrypt.h>

#define WKSTA_NETLOGON
#define NETSETUP_JOIN

#include <confname.h>
#include <winldap.h>
#include <nb30.h>
#include <msgrutil.h>
#include <lmaccess.h>
#include <lmuse.h>
#include <lmwksta.h>
#include <stdio.h>
#include <ntddbrow.h>
#include <netlibnt.h>
#include <ntddnfs.h>
#include <remboot.h>
#include <dns.h>
#include <ntsam.h>
#include <rpc.h>
#include <ntdsapi.h>
#include <netlogon.h>
#include <logonp.h>
#include <wchar.h>
#include <icanon.h>     // NetpNameCanonicalize
#include <tstring.h>    // STRLEN
#include <autoenr.h>    // Autoenrol routine

#include "joinp.h"


#define NETSETUPP_WINLOGON_PATH L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\"
#define NETSETUPP_WINLOGON_CAD  L"DisableCAD"

#define NETSETUPP_ALL_FILTER    L"(ObjectClass=*)"
#define NETSETUPP_OU_FILTER     L"(ObjectClass=OrganizationalUnit)"
#define NETSETUPP_RETURNED_ATTR L"AllowedChildClassesEffective"
#define NETSETUPP_DN_ATTR       L"DistinguishedName"
#define NETSETUPP_WELL_KNOWN    L"WellKnownObjects"
#define NETSETUPP_COMPUTER_OBJECT   L"Computer"
#define NETSETUPP_OBJ_PREFIX    L"CN="
#define NETSETUPP_ACCNT_TYPE_ENABLED  L"4096"
#define NETSETUPP_ACCNT_TYPE_DISABLED L"4098"

//
// DNS registration removal function prototype
//

typedef DWORD (APIENTRY *DNS_REGISTRATION_REMOVAL_FN) ( VOID );

//
// Locally defined macros
//
#define clearncb(x)     memset((char *)x,'\0',sizeof(NCB))


NTSTATUS
NetpGetLsaHandle(
    IN  LPWSTR      lpServer,     OPTIONAL
    IN  LSA_HANDLE  PolicyHandle, OPTIONAL
    OUT PLSA_HANDLE pPolicyHandle
    )
/*++

Routine Description:

    Either returns the given LSA handle if it's valid, or opens a new one

Arguments:

    lpServer      -- server name : NULL == local policy
    PolicyHandle  -- Potentially open policy handle
    pPolicyHandle -- Open policy handle returned here

Returns:

    STATUS_SUCCESS -- Success

--*/
{
    NTSTATUS Status = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES OA;
    UNICODE_STRING      Server, *pServer = NULL;

    if ( PolicyHandle == NULL )
    {
        if ( lpServer != NULL )
        {
            RtlInitUnicodeString( &Server, lpServer );
            pServer = &Server;
        }

        //
        // Open the local policy
        //
        InitializeObjectAttributes( &OA, NULL, 0, NULL, NULL );

        Status = LsaOpenPolicy( pServer, &OA, MAXIMUM_ALLOWED, pPolicyHandle );

        if ( !NT_SUCCESS( Status ) )
        {
            NetpLog((  "NetpGetLsaHandle: LsaOpenPolicy on %ws failed: 0x%lx\n",
                                GetStrPtr(lpServer), Status ));
        }
    }
    else
    {
        *pPolicyHandle = PolicyHandle;
    }

    return( Status );
}


VOID
NetpSetLsaHandle(
    IN  LSA_HANDLE  PassedHandle,
    IN  LSA_HANDLE  OpenHandle,
    OUT PLSA_HANDLE pReturnedHandle
    )
/*++

Routine Description:

    Either closes the opened handle or returns it

Arguments:

    PassedHandle    -- Handle passed to the original API call
    OpenHandle      -- Handle returned from NetpGetLsaHandle
    pReturnedHandle -- handle is passed back to the caller if requested

Returns:

    VOID

--*/
{
    if ( pReturnedHandle == NULL )
    {
        if ((PassedHandle == NULL) && (OpenHandle != NULL))
        {
            LsaClose( OpenHandle );
        }
    }
    else
    {
        *pReturnedHandle = OpenHandle;
    }
}




NET_API_STATUS
NET_API_FUNCTION
NetpSetLsaPrimaryDomain(
    IN  LSA_HANDLE  PolicyHandle,   OPTIONAL
    IN  LPWSTR      lpDomain,
    IN  PSID        pDomainSid,     OPTIONAL
    IN  PPOLICY_DNS_DOMAIN_INFO pPolicyDns,  OPTIONAL
    OUT PLSA_HANDLE pPolicyHandle   OPTIONAL
    )
/*++

Routine Description:

    Sets the primary domain in the local LSA policy

Arguments:

    PolicyHandle  -- Handle to the open policy
    lpDomain      -- Name of the domain to join
    pDomainSid    -- Primary domain sid to be set
    pPolicyDns    -- DNS domain info
    pPolicyHandle -- handle returned if non-null

Returns:

    NERR_Success -- Success

--*/
{
    NTSTATUS                    Status = STATUS_SUCCESS;
    LSA_HANDLE                  LocalPolicy = NULL;
    POLICY_PRIMARY_DOMAIN_INFO  PolicyPDI;


    Status = NetpGetLsaHandle( NULL, PolicyHandle, &LocalPolicy );

    //
    // Now, build the primary domain info, and set it
    //
    if ( NT_SUCCESS( Status ) )
    {
        RtlInitUnicodeString( &(PolicyPDI.Name), lpDomain );
        PolicyPDI.Sid = pDomainSid;

        Status = LsaSetInformationPolicy( LocalPolicy,
                                          PolicyPrimaryDomainInformation,
                                          ( PVOID )&PolicyPDI );

        if ( NT_SUCCESS( Status ) && pPolicyDns )
        {
            Status = LsaSetInformationPolicy( LocalPolicy,
                                              PolicyDnsDomainInformation,
                                              ( PVOID )pPolicyDns );
        }
    }

    NetpSetLsaHandle( PolicyHandle, LocalPolicy, pPolicyHandle );

    NetpLog((  "NetpSetLsaPrimaryDomain: for '%ws' status: 0x%lx\n", GetStrPtr(lpDomain), Status ));

    return( RtlNtStatusToDosError( Status ) );
}




NET_API_STATUS
NET_API_FUNCTION
NetpGetLsaPrimaryDomain(
    IN  LSA_HANDLE                      PolicyHandle,  OPTIONAL
    IN  LPWSTR                          lpServer,      OPTIONAL
    OUT PPOLICY_PRIMARY_DOMAIN_INFO    *ppPolicyPDI,
    OUT PPOLICY_DNS_DOMAIN_INFO        *ppPolicyDns,
    OUT PLSA_HANDLE                     pPolicyHandle  OPTIONAL
    )
/*++

Routine Description:

    Gets the primary domain info in the local LSA policy

Arguments:

    PolicyHandle  -- Handle to the open policy.  If NULL, a new handle is
                     opened.
    lpServer      -- Optional server name on which to read the policy
    ppPolicyPDI   -- Primary domain policy returned here
    ppPolicyDNS   -- Dns domain information is returned here if it exists
    pPolicyHandle -- Optional.  Policy handle returned here if not null

Returns:

    NERR_Success -- Success

--*/
{
    NTSTATUS            Status = STATUS_SUCCESS;
    LSA_HANDLE          LocalPolicy = NULL;
    UNICODE_STRING      Server, *pServer = NULL;

    //
    // Initialization
    //

    *ppPolicyPDI = NULL;
    *ppPolicyDns = NULL;

    if ( lpServer != NULL )
    {
        RtlInitUnicodeString( &Server, lpServer );
        pServer = &Server;
    }

    Status = NetpGetLsaHandle( lpServer, PolicyHandle, &LocalPolicy );

    //
    // Now, get the primary domain info
    //
    if ( NT_SUCCESS( Status ) )
    {
        Status = LsaQueryInformationPolicy( LocalPolicy,
                                            PolicyDnsDomainInformation,
                                            ( PVOID * )ppPolicyDns );

        if ( Status == RPC_NT_PROCNUM_OUT_OF_RANGE )
        {
            Status = STATUS_SUCCESS;
            *ppPolicyDns = NULL;
        }

        if ( NT_SUCCESS( Status ) )
        {
            Status = LsaQueryInformationPolicy( LocalPolicy,
                                                PolicyPrimaryDomainInformation,
                                                (PVOID *)ppPolicyPDI);

            if ( !NT_SUCCESS( Status ) && (*ppPolicyDns) != NULL )
            {
                LsaFreeMemory( *ppPolicyDns );
                *ppPolicyDns = NULL;
            }
        }
    }

    NetpSetLsaHandle( PolicyHandle, LocalPolicy, pPolicyHandle );

    NetpLog((  "NetpGetLsaPrimaryDomain: status: 0x%lx\n", Status ));

    return( RtlNtStatusToDosError( Status ) );
}




NET_API_STATUS
NET_API_FUNCTION
NetpGetLsaDcRole(
    IN  LPWSTR      lpMachine,
    OUT BOOL       *pfIsDC

    )
/*++

Routine Description:

    Gets the role of the DC in the domain

Arguments:

    lpMachine -- Machine to connect to
    pfIsDC -- If TRUE, this is a DC.

Returns:

    NERR_Success -- Success

--*/
{
    NTSTATUS                     Status = STATUS_SUCCESS;
    PBYTE                        pBuff;
    LSA_HANDLE                   hPolicy;

    Status = NetpGetLsaHandle( lpMachine, NULL, &hPolicy );



    //
    // Now, get the server role info
    //
    if ( NT_SUCCESS( Status ) ) {


        Status = LsaQueryInformationPolicy( hPolicy,
                                            PolicyLsaServerRoleInformation,
                                            &pBuff);

        if ( *(PPOLICY_LSA_SERVER_ROLE)pBuff == PolicyServerRoleBackup ||
             *(PPOLICY_LSA_SERVER_ROLE)pBuff == PolicyServerRolePrimary ) {

            *pfIsDC = TRUE;

        } else {

            *pfIsDC = FALSE;
        }


        LsaFreeMemory( pBuff );
        LsaClose( hPolicy );
    }

    if ( !NT_SUCCESS( Status ) ) {

        NetpLog((  "NetpGetLsaDcRole failed with 0x%lx\n", Status ));
    }


    return( RtlNtStatusToDosError( Status ) );
}

NTSTATUS
NetpLsaOpenSecret(
    IN LSA_HANDLE      hLsa,
    IN PUNICODE_STRING pusSecretName,
    IN ACCESS_MASK     DesiredAccess,
    OUT PLSA_HANDLE    phSecret
    )
/*++

Routine Description:

    Open the specified LSA secret as self.

    LsaQuerySecret fails for a network client whent the client is not
    trusted (see lsa\server\dbsecret.c). This causes remote join
    operation to fail. To get around this, this function temporarily
    un-impersonates, opens the secrets and impersonates again.
    Thus the open secret occurrs in LocalSystem context.

    $ REVIEW  kumarp 15-July-1999
    This is obviously not a good design. This should be changed post NT5.

Arguments:

    same as those for LsaOpenSecret

Returns:

    NTSTATUS, see help for LsaOpenSecret

--*/
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    HANDLE hToken=NULL;

    __try
    {
        if (OpenThreadToken(GetCurrentThread(), TOKEN_IMPERSONATE,
                            TRUE, &hToken))
        {
            if (SetThreadToken(NULL, NULL))
            {
                Status = LsaOpenSecret(hLsa, pusSecretName,
                                       DesiredAccess, phSecret);
            }
        }
    }
    __finally
    {
        if (hToken)
        {
            SetThreadToken(NULL, hToken);
        }
    }

    NetpLog((  "NetpLsaOpenSecret: status: 0x%lx\n", Status ));

    return Status;
}




//$ REVIEW  kumarp 13-May-1999
//  the fDelete param is used as uint but is declared as BOOL


NET_API_STATUS
NET_API_FUNCTION
NetpManageMachineSecret(
    IN  LSA_HANDLE  PolicyHandle, OPTIONAL
    IN  LPWSTR      lpMachine,
    IN  LPWSTR      lpPassword,
    IN  BOOL        fDelete,
    IN  BOOL        UseDefaultForOldPwd,
    OUT PLSA_HANDLE pPolicyHandle OPTIONAL
    )
/*++

Routine Description:

    Create/delete the machine secret


Arguments:

    PolicyHandle  -- Optional open handle to the policy
    lpMachine     -- Machine to add/delete the secret for
    lpPassword    -- Machine password to use.
    fDelete       -- if TRUE, the secret is removed
    UseDefaultForOldPwd - if TRUE, the default password should be set
                     for the old password value. Used only if
                     secret is created.
    pPolicyHandle -- If present, the opened policy handle is returned here

Returns:

    NERR_Success -- Success

--*/
{
    NTSTATUS            Status = STATUS_SUCCESS;
    LSA_HANDLE          LocalPolicy = NULL, SecretHandle = NULL;
    UNICODE_STRING      Key, Data, *CurrentValue = NULL;
    BOOLEAN             SecretCreated = FALSE;
    WCHAR MachinePasswordBuffer[PWLEN + 1];
    UNICODE_STRING MachinePassword;
    BOOLEAN FreeCurrentValue = FALSE;

    if( fDelete == FALSE )
    {
        ASSERT( lpPassword );
    }

    Status = NetpGetLsaHandle( NULL, PolicyHandle, &LocalPolicy );

    //
    // open/create the secret
    //
    if ( NT_SUCCESS( Status ) )
    {
        RtlInitUnicodeString( &Key, L"$MACHINE.ACC" );
        RtlInitUnicodeString( &Data, lpPassword );

        Status = NetpLsaOpenSecret( LocalPolicy, &Key,
                                    fDelete == NETSETUPP_CREATE ?
                                    SECRET_SET_VALUE | SECRET_QUERY_VALUE : DELETE,
                                    &SecretHandle );

        if ( Status == STATUS_OBJECT_NAME_NOT_FOUND )
        {
            if ( fDelete )
            {
                Status = STATUS_SUCCESS;
            }
            else
            {
                Status = LsaCreateSecret( LocalPolicy, &Key,
                                          SECRET_SET_VALUE, &SecretHandle );

                if ( NT_SUCCESS( Status ) )
                {
                    SecretCreated = TRUE;
                }
            }
        }

        if ( !NT_SUCCESS( Status ) )
        {
            NetpLog((  "NetpManageMachineSecret: Open/Create secret failed: 0x%lx\n", Status ));
        }

        if ( NT_SUCCESS( Status ) )
        {
            if ( fDelete == NETSETUPP_CREATE )
            {
                //
                // First, read the current value, so we can save it as the old value
                //

                if ( !UseDefaultForOldPwd ) {
                    if ( SecretCreated )
                    {
                        CurrentValue = &Data;
                    }
                    else
                    {
                        Status = LsaQuerySecret( SecretHandle, &CurrentValue,
                                                 NULL, NULL, NULL );
                        FreeCurrentValue = TRUE;
                    }

                //
                // If we are to use the default value for old password,
                // generate the default value
                //

                } else {
                    NetpGenerateDefaultPassword(lpMachine, MachinePasswordBuffer);
                    RtlInitUnicodeString( &MachinePassword, MachinePasswordBuffer );
                    CurrentValue = &MachinePassword;
                }

                if ( NT_SUCCESS( Status ) )
                {
                    //
                    // Now, store both the new password and the old
                    //
                    Status = LsaSetSecret( SecretHandle, &Data, CurrentValue );

                    if ( FreeCurrentValue )
                    {
                        LsaFreeMemory( CurrentValue );
                    }
                }
            }
            else
            {
                //
                // No secret handle means we failed earlier in
                // some intermediate state.  That's ok, just press on.
                //
                if ( SecretHandle != NULL )
                {
                    Status = LsaDelete( SecretHandle );

                    if ( NT_SUCCESS( Status ) )
                    {
                        SecretHandle = NULL;
                    }
                }
            }
        }

        if ( SecretHandle )
        {
            LsaClose( SecretHandle );
        }
    }

    NetpSetLsaHandle( PolicyHandle, LocalPolicy, pPolicyHandle );

    if ( !NT_SUCCESS( Status ) )
    {
        NetpLog(( "NetpManageMachineSecret: '%s' operation failed: 0x%lx\n",
                  fDelete == NETSETUPP_CREATE ? "CREATE" : "DELETE", Status ));
    }

    return( RtlNtStatusToDosError( Status ) );
}



NET_API_STATUS
NET_API_FUNCTION
NetpReadCurrentSecret(
    IN LSA_HANDLE PolicyHandle, OPTIONAL
    OUT LPWSTR *lpCurrentSecret,
    OUT PLSA_HANDLE pPolicyHandle OPTIONAL
    )
/*++

Routine Description:

    Reads the value of the current secret


Arguments:

    PolicyHandle -- Optional open handle to the policy
    lpCurrentSecret -- Where the current secret is returned
    pPolicyHandle -- If present, the opened policy handle is returned here

Returns:

    NERR_Success -- Success

--*/
{
    NTSTATUS            Status = STATUS_SUCCESS;
    LSA_HANDLE          LocalPolicy = NULL, SecretHandle;
    UNICODE_STRING      Secret, *Data;

    Status = NetpGetLsaHandle( NULL, PolicyHandle, &LocalPolicy );

    //
    // Now, read the secret
    //
    if ( NT_SUCCESS( Status ) ) {

        RtlInitUnicodeString( &Secret, L"$MACHINE.ACC" );

        // Status = LsaRetrievePrivateData( LocalPolicy, &Key, &Data );

        Status = NetpLsaOpenSecret( LocalPolicy,
                                    &Secret,
                                    SECRET_QUERY_VALUE,
                                    &SecretHandle );

        if ( NT_SUCCESS(Status) ) {
            Status = LsaQuerySecret( SecretHandle,
                                     &Data,
                                     NULL,
                                     NULL,
                                     NULL );

            LsaClose( SecretHandle );
        }

        if ( NT_SUCCESS( Status ) ) {

            if( NetApiBufferAllocate( Data->Length + sizeof( WCHAR ),
                                      ( PBYTE * )lpCurrentSecret ) != NERR_Success ) {

                Status = STATUS_INSUFFICIENT_RESOURCES;

            } else {

                RtlCopyMemory( ( PVOID )*lpCurrentSecret,
                               Data->Buffer,
                               Data->Length );

                ( *lpCurrentSecret )[ Data->Length / sizeof( WCHAR ) ] = UNICODE_NULL;
            }
        }
    }

    NetpSetLsaHandle( PolicyHandle, LocalPolicy, pPolicyHandle );

    if ( !NT_SUCCESS( Status ) ) {

        NetpLog(( "NetpReadCurrentSecret: failed: 0x%lx\n", Status ));
    }


    return( RtlNtStatusToDosError( Status ) );
}


NET_API_STATUS
NET_API_FUNCTION
NetpSetNetlogonDomainCache(
    IN  LPWSTR lpDc
    )
/*++

Routine Description:

    Initializes NetLogons trusted domain cache, using the trusted
    domain list on the DC.


Arguments:

    lpDc -- Name of a DC in the domain
            The caller should already have an valid connection to IPC$

Returns:

    NERR_Success -- Success

--*/
{
    DWORD dwErr = ERROR_SUCCESS;

    PDS_DOMAIN_TRUSTSW TrustedDomains=NULL;
    ULONG TrustedDomainCount=0;


    //
    // Get the trusted domain list from the DC.
    //
    dwErr = DsEnumerateDomainTrustsW( lpDc, DS_DOMAIN_VALID_FLAGS,
                            &TrustedDomains, &TrustedDomainCount );

    //
    // If the server does not support returning all trust types
    // (i.e. the server is an NT4 machine) ask for only those
    // which it can return.
    //
    if ( dwErr == ERROR_NOT_SUPPORTED )
    {
        dwErr = DsEnumerateDomainTrustsW(
                                lpDc,
                                DS_DOMAIN_PRIMARY | DS_DOMAIN_DIRECT_OUTBOUND,
                                &TrustedDomains,
                                &TrustedDomainCount );
        if ( dwErr == ERROR_NOT_SUPPORTED )
        {
            //
            // looks like the DC is running NT3.51. In this case, we do not want
            // to fail the join operation because we could not write
            // the netlogon cache. reset the error code.
            //
            // see bug "359684 Win2k workstation unable to join NT3.51Domain"
            //
            NetpLog(( "NetpSetNetlogonDomainCache: DsEnumerateDomainTrustsW failed with ERROR_NOT_SUPPORTED, this looks like a NT3.51 DC. The failure was ignored. dc list not written to netlogon cache.\n"));
            dwErr = ERROR_SUCCESS;
        }
    }


    if ( ( dwErr == NO_ERROR ) && TrustedDomainCount )
    {
        //
        // Write the trusted domain list to a file where netlogon will find it.
        //

        dwErr = NlWriteFileForestTrustList (
                           NL_FOREST_BINARY_LOG_FILE_JOIN,
                           TrustedDomains,
                           TrustedDomainCount );

    }
    else
    {
        NetpLog(( "NetpSetNetlogonDomainCache: NlWriteFileForestTrustList failed: 0x%lx\n", dwErr ));
    }

    //
    // Disable the no Ctrl-Alt-Del from the winlogon side of things
    //
    if ( dwErr == ERROR_SUCCESS ) {
        HKEY hWinlogon;

        dwErr = RegOpenKey( HKEY_LOCAL_MACHINE,
                            NETSETUPP_WINLOGON_PATH, &hWinlogon );

        if ( dwErr == ERROR_SUCCESS ) {
            DWORD Value;

            Value = 0;
            dwErr = RegSetValueEx( hWinlogon, NETSETUPP_WINLOGON_CAD, 0,
                                   REG_DWORD, (PBYTE)&Value, sizeof( ULONG ) );

            RegCloseKey( hWinlogon );
        }

        //
        // Failing to set this never causes failure
        //
        if ( dwErr != ERROR_SUCCESS ) {

            NetpLog(( "Setting Winlogon DisableCAD failed with %lu\n", dwErr ));
            dwErr = ERROR_SUCCESS;
        }

    }

    //
    // Free locally used resources
    //

    if ( TrustedDomains != NULL ) {
        NetApiBufferFree( TrustedDomains );
    }

    return dwErr;

}



/*++

Routine Description:
    Is this a terminal-server-application-server?

Arguments:

    Args - none

Return Value:

    TRUE or FALSE

--*/
BOOL IsAppServer(void)
{
    OSVERSIONINFOEX osVersionInfo;
    DWORDLONG dwlConditionMask = 0;
    BOOL fIsWTS;

    osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    fIsWTS = GetVersionEx((OSVERSIONINFO *)&osVersionInfo) &&
             (osVersionInfo.wSuiteMask & VER_SUITE_TERMINAL) &&
             !(osVersionInfo.wSuiteMask & VER_SUITE_SINGLEUSERTS);

    return fIsWTS;

}



NET_API_STATUS
NET_API_FUNCTION
NetpManageLocalGroups(
    IN  PSID    pDomainSid,
    IN  BOOL    fDelete
    )
/*++

Routine Description:

    Performs SAM account handling to either add or remove the DomainAdmins,
    etc groups from the local groups.


Arguments:

    pDomainSid -- SID of the domain being joined/left
    fDelete    -- Whether to add or remove the admin alias

Returns:

    NERR_Success -- Success

--*/
{
    NET_API_STATUS  NetStatus = NERR_Success;
    //
    // Keep these in synch with the rids and Sids below
    //
    ULONG LocalRids[] =
    {
        DOMAIN_ALIAS_RID_ADMINS,
        DOMAIN_ALIAS_RID_USERS,
        DOMAIN_ALIAS_RID_REMOTE_DESKTOP_USERS   // this LAST item is only used on TS-App-Servers
    };

    PWSTR   ppwszLocalGroups[ sizeof( LocalRids ) / sizeof( ULONG )] =
    {
        NULL,
        NULL,
        NULL
    };

    ULONG Rids[] =
    {
        DOMAIN_GROUP_RID_ADMINS,
        DOMAIN_GROUP_RID_USERS,
        DOMAIN_GROUP_RID_USERS  // this LAST item is only used on TS-App-Servers

    };

    BOOLEAN GroupMustExist[ sizeof( LocalRids ) / sizeof( ULONG )] =
    {
        TRUE,
        TRUE,
        TRUE,
    };

    static  SID_IDENTIFIER_AUTHORITY BultinAuth = SECURITY_NT_AUTHORITY;
    DWORD   Sids[sizeof( SID )/sizeof( DWORD ) + SID_MAX_SUB_AUTHORITIES][sizeof(Rids) / sizeof(ULONG)];
    DWORD   cDSidSize, *pLastSub, i, j;
    PUCHAR  pSubAuthCnt;
    PWSTR   LocalGroupName = NULL;
    PWCHAR  DomainName = NULL;
    ULONG   Size, DomainSize;
    SID_NAME_USE SNE;
    ULONG   numOfGroups;


    cDSidSize = RtlLengthSid( pDomainSid );

    // number of groups to process
    numOfGroups = sizeof(Rids) / sizeof(ULONG);

    // if we are NOT on an app server, we ignore the last entry
    if ( ! IsAppServer() )
    {
        numOfGroups -= 1;
    }

    for ( i = 0 ; i <  numOfGroups && NetStatus == NERR_Success; i++)
    {
        Size = 0;
        DomainSize = 0;

        if ( DomainName != NULL ) {
            NetApiBufferFree( DomainName );
            DomainName = NULL;
        }

        //
        // Get the name of the local group first...
        //
        RtlInitializeSid( ( PSID )Sids[ i ], &BultinAuth, 2 );

        *(RtlSubAuthoritySid(( PSID )Sids[ i ], 0)) = SECURITY_BUILTIN_DOMAIN_RID;
        *(RtlSubAuthoritySid(( PSID )Sids[ i ], 1)) = LocalRids[ i ];

        LookupAccountSidW( NULL, ( PSID )Sids[ i ], NULL, &Size,
                           DomainName, &DomainSize, &SNE );

        if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
        {
            NetStatus = NetApiBufferAllocate(  Size * sizeof(WCHAR),
                                               &LocalGroupName );

            if ( NetStatus == NERR_Success ) {
                NetStatus = NetApiBufferAllocate( DomainSize * sizeof(WCHAR),
                                                  &DomainName );
            }

            if ( NetStatus == NERR_Success )
            {
                if ( !LookupAccountSid( NULL, ( PSID )Sids[ i ], LocalGroupName,
                                        &Size, DomainName, &DomainSize, &SNE ) )
                {
                    NetStatus = GetLastError();

                    if ( NetStatus == ERROR_NONE_MAPPED && GroupMustExist[ i ] == FALSE )
                    {
                        NetStatus = NERR_Success;
                        continue;

                    }
                    else
                    {
#ifdef NETSETUP_VERBOSE_LOGGING
                        UNICODE_STRING DisplaySid;
                        NTSTATUS Status2;
                        RtlZeroMemory( &DisplaySid, sizeof( UNICODE_STRING ) );

                        Status2 = RtlConvertSidToUnicodeString( &DisplaySid,
                                                                ( PSID )Sids[ i ], TRUE );

                        if ( NT_SUCCESS( Status2 ) )
                        {
                            NetpLog((  "LookupAccounSid on %wZ failed with %lu\n",
                                                &DisplaySid,
                                                NetStatus ));
                            RtlFreeUnicodeString(&DisplaySid);

                        }
                        else
                        {
                            NetpLog((  "LookupAccounSid on <undisplayable sid> "
                                                "[Rid 0x%lx] failed with %lu\n",
                                                NetStatus ));
                        }
#endif
                    }
                }
                else
                {
                    ppwszLocalGroups[ i ] = LocalGroupName;
                }

            }
            else
            {
                break;
            }
        }

        RtlCopyMemory( (PBYTE)Sids[i], pDomainSid, cDSidSize );

        //
        // Now, add the new domain relative rid
        //
        pSubAuthCnt = GetSidSubAuthorityCount( (PSID)Sids[i] );

        (*pSubAuthCnt)++;

        pLastSub = GetSidSubAuthority( (PSID)Sids[i], (*pSubAuthCnt) - 1 );

        *pLastSub = Rids[i];


        if ( fDelete == NETSETUPP_CREATE)
        {
            NetStatus = NetLocalGroupAddMember( NULL,
                                                ppwszLocalGroups[i],
                                                (PSID)Sids[i] );

            if ( NetStatus == ERROR_MEMBER_IN_ALIAS )
            {
                NetStatus = NERR_Success;
            }

        }
        else
        {
            NetStatus = NetLocalGroupDelMember( NULL,
                                                ppwszLocalGroups[i],
                                                (PSID)Sids[i] );

            if ( NetStatus == ERROR_MEMBER_NOT_IN_ALIAS )
            {
                NetStatus = NERR_Success;
            }
        }
    }

    //
    // If something failed, try to restore what was deleted
    //
    if ( NetStatus != NERR_Success )
    {
        for ( j = 0;  j < i; j++ ) {

            if ( fDelete == NETSETUPP_DELETE)
            {
                NetLocalGroupAddMember( NULL,
                                        ppwszLocalGroups[j],
                                        (PSID)Sids[j] );
            }
            else
            {
                NetLocalGroupDelMember( NULL,
                                        ppwszLocalGroups[j],
                                        (PSID)Sids[j] );
            }
        }
    }

    if ( DomainName != NULL ) {
        NetApiBufferFree( DomainName );
    }

    for ( i = 0; i < numOfGroups ; i++ )
    {
        if ( ppwszLocalGroups[ i ] )
        {
            NetApiBufferFree( ppwszLocalGroups[ i ] );
        }
    }

    if ( NetStatus != NERR_Success )
    {
        NetpLog(( "NetpManageLocalGroups failed with %lu\n", NetStatus ));
    }

    return( NetStatus );
}


NET_API_STATUS
NET_API_FUNCTION
NetpHandleJoinedStateInfo(
    IN  LSA_HANDLE                  PolicyHandle,  OPTIONAL
    IN  PNETSETUP_SAVED_JOIN_STATE  SavedState,
    IN  BOOLEAN                     Save,
    OUT PLSA_HANDLE                 ReturnedPolicyHandle OPTIONAL
    )
/*++

Routine Description:

    Saves or restores the join state info.

Arguments:

    PolicyHandle -- Local LSA policy handle.
                    If not supplied, this fn. opens it

    SavedState   -- join state info
                    This includes:
                    - machine account secret value
                    - primary domain info
                    - dns domain info

    Save         -- TRUE == save state, FALSE == restore state

    ReturnedPolicyHandle -- local LSA handle returned in this

Returns:

    NERR_Success -- Success

--*/
{
    NTSTATUS    Status = STATUS_SUCCESS;
    LSA_HANDLE  LocalPolicy = NULL, SecretHandle;
    UNICODE_STRING Secret;

    if ( Save )
    {
        RtlZeroMemory( SavedState, sizeof( NETSETUP_SAVED_JOIN_STATE ) );
    }

    //
    // get handle to local LSA policy
    //
    Status = NetpGetLsaHandle( NULL, PolicyHandle, &LocalPolicy );

    if ( NT_SUCCESS( Status ) )
    {
        //
        // First, read the machine account secret
        //
        RtlInitUnicodeString( &Secret, L"$MACHINE.ACC" );

        Status = NetpLsaOpenSecret( LocalPolicy,
                                    &Secret,
                                    SECRET_QUERY_VALUE | SECRET_SET_VALUE,
                                    &SecretHandle );

        if ( NT_SUCCESS( Status ) )
        {
            if ( Save )
            {
                SavedState->MachineSecret = TRUE;
                Status = LsaQuerySecret( SecretHandle,
                                         &( SavedState->CurrentValue ),
                                         NULL,
                                         &( SavedState->PreviousValue ),
                                         NULL );

            }
            else
            {
                if ( SavedState ->MachineSecret  )
                {
                    Status = LsaSetSecret( SecretHandle,
                                           SavedState->CurrentValue,
                                           SavedState->PreviousValue );
                }
            }
            LsaClose( SecretHandle );
        }

        //
        // If machine secret is not present, it is not an error.
        //
        if ( Status == STATUS_OBJECT_NAME_NOT_FOUND )
        {
            if ( Save )
            {
                SavedState->MachineSecret = FALSE;
            }
            Status = STATUS_SUCCESS;
        }

        //
        // Now, save/restore the policy information
        //
        if ( NT_SUCCESS( Status ) )
        {
            if ( Save )
            {
                Status  = NetpGetLsaPrimaryDomain( LocalPolicy, NULL,
                                                   &( SavedState->PrimaryDomainInfo ),
                                                   &( SavedState->DnsDomainInfo ),
                                                   NULL );
            }
            else
            {
                Status = LsaSetInformationPolicy( LocalPolicy,
                                                  PolicyPrimaryDomainInformation,
                                                  SavedState->PrimaryDomainInfo );

                if ( NT_SUCCESS( Status ) )
                {
                    Status = LsaSetInformationPolicy( LocalPolicy,
                                                      PolicyDnsDomainInformation,
                                                      SavedState->DnsDomainInfo );
                }
            }
        }
    }

    NetpSetLsaHandle( PolicyHandle, LocalPolicy, ReturnedPolicyHandle );

    if ( !NT_SUCCESS( Status ) )
    {
        NetpLog((
                            "NetpHandleJoinedStateInfo: '%s' operation failed: 0x%lx\n",
                            Save ? "Save" : "Restore", Status ));
    }


    return( RtlNtStatusToDosError( Status ) );
}


NET_API_STATUS
MsgFmtNcbName(
    OUT PCHAR   DestBuf,
    IN  LPTSTR  Name,
    IN  DWORD   Type)

/*++

Routine Description:

    FmtNcbName - format a name NCB-style

    Given a name, a name type, and a destination address, this
    function copies the name and the type to the destination in
    the format used in the name fields of a Network Control
    Block.


    SIDE EFFECTS

    Modifies 16 bytes starting at the destination address.

Arguments:

    DestBuf - Pointer to the destination buffer.

    Name - Unicode NUL-terminated name string

    Type - Name type number (0, 3, 5, or 32) (3=NON_FWD, 5=FWD)



Return Value:

    NERR_Success - The operation was successful

    Translated Return Code from the Rtl Translate routine.

--*/

  {
    DWORD           i;                // Counter
    NTSTATUS        ntStatus;
    NET_API_STATUS  status;
    OEM_STRING     ansiString;
    UNICODE_STRING  unicodeString;
    PCHAR           pAnsiString;


    //
    // Force the name to be upper case.
    //
    status = NetpNameCanonicalize(
                NULL,
                Name,
                Name,
                STRSIZE(Name),
                NAMETYPE_MESSAGEDEST,
                0);
    if (status != NERR_Success) {
        return(status);
    }

    //
    // Convert the unicode name string into an ansi string - using the
    // current locale.
    //
#ifdef UNICODE
    unicodeString.Length = (USHORT)(STRLEN(Name)*sizeof(WCHAR));
    unicodeString.MaximumLength = (USHORT)((STRLEN(Name)+1) * sizeof(WCHAR));
    unicodeString.Buffer = Name;

    ntStatus = RtlUnicodeStringToOemString(
                &ansiString,
                &unicodeString,
                TRUE);          // Allocate the ansiString Buffer.

    if (!NT_SUCCESS(ntStatus))
    {
        NetpLog(( "FmtNcbName: RtlUnicodeStringToOemString failed 0x%lx\n",
                  ntStatus ));

        return NetpNtStatusToApiStatus(ntStatus);
    }

    pAnsiString = ansiString.Buffer;
    *(pAnsiString+ansiString.Length) = '\0';
#else
    UNUSED(ntStatus);
    UNUSED(unicodeString);
    UNUSED(ansiString);
    pAnsiString = Name;
#endif  // UNICODE

    //
    // copy each character until a NUL is reached, or until NCBNAMSZ-1
    // characters have been copied.
    //
    for (i=0; i < NCBNAMSZ - 1; ++i) {
        if (*pAnsiString == '\0') {
            break;
        }

        //
        // Copy the Name
        //

        *DestBuf++ = *pAnsiString++;
    }



    //
    // Free the buffer that RtlUnicodeStringToOemString created for us.
    // NOTE:  only the ansiString.Buffer portion is free'd.
    //

#ifdef UNICODE
    RtlFreeOemString( &ansiString);
#endif // UNICODE

    //
    // Pad the name field with spaces
    //
    for(; i < NCBNAMSZ - 1; ++i) {
        *DestBuf++ = ' ';
    }

    //
    // Set the name type.
    //
    NetpAssert( Type!=5 );          // 5 is not valid for NT.

    *DestBuf = (CHAR) Type;     // Set name type

    return(NERR_Success);
  }


NET_API_STATUS
NET_API_FUNCTION
NetpCheckNetBiosNameNotInUse(
    IN LPWSTR pszName,
    IN BOOLEAN MachineName,
    IN BOOLEAN Unique
    )
{
    NCB              ncb;
    LANA_ENUM        lanaBuffer;
    unsigned char    i;
    unsigned char    nbStatus;
    NET_API_STATUS   NetStatus = NERR_Success;
    WCHAR            szMachineNameBuf[MAX_COMPUTERNAME_LENGTH + 1];
    LPWSTR           szMachineName=szMachineNameBuf;


    //
    // Find the number of networks by sending an enum request via Netbios.
    //

    clearncb(&ncb);
    ncb.ncb_command = NCBENUM;          // Enumerate LANA nums (wait)
    ncb.ncb_buffer = (PUCHAR)&lanaBuffer;
    ncb.ncb_length = sizeof(LANA_ENUM);

    nbStatus = Netbios (&ncb);
    if (nbStatus != NRC_GOODRET)
    {
        NetStatus = NetpNetBiosStatusToApiStatus( nbStatus );
        goto Cleanup;
    }

    clearncb(&ncb);

    NetStatus = MsgFmtNcbName( (char *)ncb.ncb_name, pszName,
                               MachineName ? 0 : 0x1c );

    if ( NetStatus != NERR_Success )
    {
        goto Cleanup;
    }

    //
    // Move the Adapter Numbers (lana) into the array that will contain them.
    //
    for ( i = 0; i < lanaBuffer.length && NetStatus == NERR_Success; i++ )
    {
        NetpNetBiosReset( lanaBuffer.lana[i] );

        if ( Unique )
        {
            ncb.ncb_command = NCBADDNAME;
        }
        else
        {
            ncb.ncb_command = NCBADDGRNAME;
        }

        ncb.ncb_lana_num = lanaBuffer.lana[i];
        nbStatus = Netbios( &ncb );

        switch ( nbStatus )
        {
            case NRC_DUPNAME:
                // NRC_DUPNAME ==
                // "A duplicate name existed in the local name table"
                //
                // In this case, we need to check if the name being checked
                // is the same as the local computer name. If so,
                // the name is expected to be in the local table therefore
                // we convert this errcode to a success code
                //
                NetStatus = NetpGetComputerNameAllocIfReqd(
                    &szMachineName, MAX_COMPUTERNAME_LENGTH+1);

                if (NetStatus == NERR_Success)
                {
                    if (!_wcsicmp(szMachineName, pszName))
                    {
                        NetStatus = NERR_Success;
                    }
                    else
                    {
                        NetStatus = ERROR_DUP_NAME;
                    }
                }
                break;

            case NRC_INUSE:
                NetStatus = ERROR_DUP_NAME;
                break;

            case NRC_GOODRET:
                // Delete the name
                ncb.ncb_command = NCBDELNAME;
                ncb.ncb_lana_num = lanaBuffer.lana[i];
                // Not much we can do if this fails.
                Netbios( &ncb );
                // fall through

            default:
                NetStatus = NetpNetBiosStatusToApiStatus( nbStatus );
                break;
        }

    }

Cleanup:
    if ( NetStatus != NERR_Success )
    {
        NetpLog(( "NetpCheckNetBiosNameNotInUse: for '%ws' returned: 0x%lx\n",
                  pszName, NetStatus ));
    }

    if (szMachineName != szMachineNameBuf)
    {
        NetApiBufferFree(szMachineName);
    }

    return( NetStatus );
}


NET_API_STATUS
NET_API_FUNCTION
NetpIsValidDomainName(
    IN  LPWSTR  lpName,
    IN  LPWSTR  lpServer,
    IN  LPWSTR  lpAccount,
    IN  LPWSTR  lpPassword
    )
/*++

Routine Description:

    Determines if a name is a DC name or not.  Copied from
    ui\net\common\src\lmboj\lmobj\lmodom.cxx

Arguments:

    lpName -- Name to check
    lpServer -- Name of a server within that domain

Returns:

    NERR_Success -- Success
    ERROR_DUP_NAME -- The domain name is in use

--*/
{
    NET_API_STATUS  NetStatus = NERR_Success;
    PWKSTA_INFO_100 pWKI100  = NULL;
    BOOL            fIsDC;
    POLICY_LSA_SERVER_ROLE  Role;

    NetStatus = NetpManageIPCConnect( lpServer, lpAccount,
                                      lpPassword,
                                      NETSETUPP_CONNECT_IPC | NETSETUPP_NULL_SESSION_IPC );

    if ( NetStatus == NERR_Success ) {

        //
        // Now, get the info from the server
        //
        NetStatus = NetWkstaGetInfo( lpServer, 100, (LPBYTE  *)&pWKI100 );

        if ( NetStatus == NERR_Success ) {

            if (_wcsicmp( lpName, pWKI100->wki100_langroup ) == 0 ) {

                //
                // Ok, it's a match...  Determine the domain role.
                //
                NetStatus = NetpGetLsaDcRole( lpServer, &fIsDC );

                if ( ( NetStatus == NERR_Success ) && ( fIsDC == FALSE ) )
                {
                    NetStatus = NERR_DCNotFound;
                }
            }
        }

        NetpManageIPCConnect( lpServer, lpAccount,
                              lpPassword, NETSETUPP_DISCONNECT_IPC );

    }

    if ( NetStatus != NERR_Success ) {

        NetpLog((
                            "NetpIsValidDomainName for %ws returned 0x%lx\n",
                            lpName, NetStatus ));
    }

    return( NetStatus );
}




NET_API_STATUS
NET_API_FUNCTION
NetpCheckDomainNameIsValid(
    IN  LPWSTR  lpName,
    IN  LPWSTR  lpAccount,
    IN  LPWSTR  lpPassword,
    IN  BOOL    fShouldExist
    )
/*++

Routine Description:

    Checks to see if the given name is in use by a domain

Arguments:

    lpName -- Name to check

Returns:

    NERR_Success -- The domain is found and valid
    ERROR_NO_SUCH_DOMAIN    -- Domain name not found

--*/
{
    NET_API_STATUS  NetStatus;
    PBYTE           pbDC;
    DWORD           cDCs, i, j;
    PUNICODE_STRING pDCList;
    LPWSTR          pwszDomain;
#if(_WIN32_WINNT >= 0x0500)
    PDOMAIN_CONTROLLER_INFO     pDCInfo = NULL;
#else
    PBYTE pDCInfo = NULL;
#endif

    UNREFERENCED_PARAMETER( lpAccount );
    UNREFERENCED_PARAMETER( lpPassword );

    //
    // Start with NetGetAnyDCName
    //
#if(_WIN32_WINNT >= 0x0500)
    NetStatus = DsGetDcName( NULL, lpName, NULL, NULL,
                             DS_FORCE_REDISCOVERY, &pDCInfo );

#else

    NetStatus  = NetGetAnyDCName( NULL,
                                  ( LPCWSTR )lpName,
                                  &pDCInfo );

#endif
    if ( NetStatus != NERR_Success ) {

        if ( NetStatus == ERROR_NO_SUCH_USER ) {

            NetStatus = NERR_Success;
        }

    } else {

        NetApiBufferFree( pDCInfo );
    }


    //
    // Map our error codes so we only return success if we validated the
    // domain name
    //
    if ( fShouldExist ) {

        if ( NetStatus == NERR_Success || NetStatus == ERROR_NO_LOGON_SERVERS ) {

            NetStatus = NERR_Success;

        } else {

            NetStatus = ERROR_NO_SUCH_DOMAIN;

        }

    } else {

        if ( NetStatus == NERR_Success || NetStatus == ERROR_NO_LOGON_SERVERS ) {

            NetStatus = ERROR_DUP_NAME;

        } else if ( NetStatus == NERR_DCNotFound || NetStatus == ERROR_NO_SUCH_DOMAIN ) {

            NetStatus = NERR_Success;
        }
    }

    if ( NetStatus != NERR_Success ) {

        NetpLog(( "NetpCheckDomainNameIsValid for %ws returned 0x%lx\n",
                  lpName, NetStatus ));
    }

    return( NetStatus );
}



NET_API_STATUS
NET_API_FUNCTION
NetpManageIPCConnect(
    IN  LPWSTR  lpServer,
    IN  LPWSTR  lpAccount,
    IN  LPWSTR  lpPassword,
    IN  ULONG   fOptions
    )
/*++

Routine Description:

    Manages the connections to the servers IPC share

Arguments:

    lpServer   -- Server to connect to
    lpAccount  -- Account to use
    lpPassword -- Password to use.  The password has been NOT been encoded
    fOptions   -- Flags to determine operation/connect/disconnect

Returns:

    NERR_Success -- The domain is found and valid

--*/
{
    NET_API_STATUS  NetStatus;
#if(_WIN32_WINNT >= 0x0500)
    WCHAR           wszPath[2 + DNS_MAX_NAME_LENGTH + 1 + NNLEN + 1];
#else
    WCHAR           wszPath[2 + 256 + 1 + NNLEN + 1];
#endif
    PWSTR           pwszPath = wszPath;
    USE_INFO_2      NetUI2;
    PWSTR           pwszUser, pwszDomain, pwszReset;
    DWORD           BadParm = 0;
    DWORD           ForceLevel = USE_NOFORCE;

    //
    // Build the path...
    //
    if (*lpServer != L'\\') {

        wcscpy(wszPath, L"\\\\");
        pwszPath += 2;

    }

    if ( FLAG_ON( fOptions, NETSETUPP_USE_LOTS_FORCE ) )
    {
        ASSERT( FLAG_ON(fOptions, NETSETUPP_DISCONNECT_IPC ) );
        ForceLevel = USE_LOTS_OF_FORCE;
    }

    swprintf( pwszPath, L"%ws\\IPC$", lpServer );
    pwszPath = wszPath;

    if ( FLAG_ON( fOptions, NETSETUPP_DISCONNECT_IPC )  )
    {
        NetStatus = NetUseDel( NULL, pwszPath, ForceLevel );

        if ( NetStatus != NERR_Success )
        {
            NetpKdPrint(( PREFIX_NETJOIN "NetUseDel on %ws failed with %d\n", pwszPath, NetStatus ));
            NetpLog((  "NetUseDel on %ws failed with %d\n", pwszPath, NetStatus ));

            if ( (NetStatus != NERR_UseNotFound)
              && (ForceLevel != USE_LOTS_OF_FORCE)  )
            {
                NetStatus = NetUseDel( NULL, pwszPath, USE_LOTS_OF_FORCE );

                if ( NetStatus != NERR_Success )
                {
                    ASSERT( NetStatus == NERR_Success );
                    NetpKdPrint(( PREFIX_NETJOIN "NetUseDel with force on %ws failed with %d\n",
                                  pwszPath, NetStatus ));
                    NetpLog((  "NetUseDel with force on %ws failed with %d\n",
                                        pwszPath, NetStatus ));
                }
            }
        }

    }
    else
    {
        if ( lpAccount != NULL )
        {
            pwszReset = wcschr( lpAccount, L'\\' );

            if (pwszReset != NULL)
            {
                pwszUser = pwszReset + 1;
                pwszDomain = lpAccount;
                *pwszReset = UNICODE_NULL;
            }
            else
            {
                pwszUser = lpAccount;
                //
                // First, assume it's a UPN, so we pass in an empty string
                //
                pwszDomain = L"";
            }

        }
        else
        {
            pwszUser   = NULL;
            pwszDomain = NULL;
            pwszReset  = NULL;
        }

        RtlZeroMemory(&NetUI2, sizeof(USE_INFO_2) );
        NetUI2.ui2_local      = NULL;
        NetUI2.ui2_remote     = pwszPath;
        NetUI2.ui2_asg_type   = USE_IPC;
        NetUI2.ui2_username   = pwszUser;
        NetUI2.ui2_domainname = pwszDomain;
        NetUI2.ui2_password   = lpPassword;

        NetStatus = NetUseAdd( NULL, 2, (PBYTE)&NetUI2, &BadParm );

        if ( NetStatus == ERROR_LOGON_FAILURE )
        {
            //
            // If we passed in an empty domain name, try it again with a NULL one
            //
            if ( pwszReset == NULL && pwszUser != NULL )
            {
                NetUI2.ui2_domainname = NULL;
                NetStatus = NetUseAdd( NULL, 2, (PBYTE)&NetUI2, &BadParm );
            }
        }

        if ( NetStatus != NERR_Success )
        {
            NetpKdPrint((PREFIX_NETJOIN "NetUseAdd to %ws returned %lu\n", pwszPath, NetStatus ));
            NetpLog((  "NetUseAdd to %ws returned %lu\n", pwszPath, NetStatus ));

            if ( NetStatus == ERROR_INVALID_PARAMETER && BadParm != 0 )
            {
                NetpLog((  "NetUseAdd bad parameter is %lu\n", BadParm ));
            }

        }


        if ( pwszReset != NULL )
        {
            *pwszReset = L'\\';
        }

        if ( ( NetStatus == ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT ||
               NetStatus == ERROR_NOLOGON_SERVER_TRUST_ACCOUNT ||
               NetStatus == ERROR_SESSION_CREDENTIAL_CONFLICT ||
               NetStatus == ERROR_ACCESS_DENIED ||
               NetStatus == ERROR_LOGON_FAILURE ) &&
               FLAG_ON( fOptions, NETSETUPP_NULL_SESSION_IPC ) )
        {
            NetpLog((  "Trying add to  %ws using NULL Session\n", pwszPath ));

            //
            // Try it again with the null session
            //
            NetUI2.ui2_username   = L"";
            NetUI2.ui2_domainname = L"";
            NetUI2.ui2_password   = L"";
            NetStatus = NetUseAdd( NULL, 2, (PBYTE)&NetUI2, NULL );

            if ( NetStatus != NERR_Success ) {

                NetpLog(( "NullSession NetUseAdd to %ws returned %lu\n",
                          pwszPath, NetStatus ));

            }
        }
    }

    return( NetStatus );
}



NET_API_STATUS
NetpBrowserCheckDomain(
    IN LPWSTR NewDomainName
    )
/*++

Routine Description:

    Tell the browser to check a domain/workgroup name

Arguments:

    NewDomainName - new name of the domain.

Return Value:

    Status of the operation.

--*/
{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;

    UNICODE_STRING DeviceName;

    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE BrowserHandle = NULL;
    LPBYTE Where;
    DWORD BytesReturned;

    UCHAR PacketBuffer[sizeof(LMDR_REQUEST_PACKET)+2*(DNLEN+1)*sizeof(WCHAR)];
    PLMDR_REQUEST_PACKET RequestPacket = (PLMDR_REQUEST_PACKET)PacketBuffer;


    //
    // Open the browser driver.
    //


    //
    // Open the browser device.
    //
    RtlInitUnicodeString(&DeviceName, DD_BROWSER_DEVICE_NAME_U);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &DeviceName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenFile(
                   &BrowserHandle,
                   SYNCHRONIZE,
                   &ObjectAttributes,
                   &IoStatusBlock,
                   0,
                   0
                   );

    if (NT_SUCCESS(Status)) {
        Status = IoStatusBlock.Status;
    }

    if (!NT_SUCCESS(Status)) {
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }

    //
    // Build the request packet.
    //
    RequestPacket->Version = LMDR_REQUEST_PACKET_VERSION_DOM;
    RtlInitUnicodeString( &RequestPacket->TransportName, NULL );
    RequestPacket->Parameters.DomainRename.ValidateOnly = TRUE;
    RtlInitUnicodeString( &RequestPacket->EmulatedDomainName, NULL );


    //
    // Copy the new domain name into the packet.
    //

    Where = (LPBYTE) RequestPacket->Parameters.DomainRename.DomainName;
    RequestPacket->Parameters.DomainRename.DomainNameLength = wcslen( NewDomainName ) * sizeof(WCHAR);
    wcscpy( (LPWSTR)Where, NewDomainName );
    Where += RequestPacket->Parameters.DomainRename.DomainNameLength + sizeof(WCHAR);



    //
    // Send the request to the Datagram Receiver device driver.
    //

    if ( !DeviceIoControl(
                   BrowserHandle,
                   IOCTL_LMDR_RENAME_DOMAIN,
                   RequestPacket,
                   (DWORD)(Where - (LPBYTE)RequestPacket),
                   NULL,
                   0,
                   &BytesReturned,
                   NULL )) {

        NetStatus = GetLastError();
        goto Cleanup;
    }


    NetStatus = NO_ERROR;
Cleanup:
    if ( BrowserHandle != NULL ) {
        NtClose( BrowserHandle );
    }
    return NetStatus;

}


NET_API_STATUS
NET_API_FUNCTION
NetpCreateAuthIdentForCreds(
    IN PWSTR Account,
    IN PWSTR Password,
    OUT SEC_WINNT_AUTH_IDENTITY *AuthIdent
    )
/*++

Routine Description:

    Internal routine to create an AuthIdent structure for the given creditentials

Arguments:

    Account - Account name

    Password - Password for the account

    AuthIdent - AuthIdentity struct to fill in


Returns:

    ERROR_SUCCESS - Success

    ERROR_NOT_ENOUGH_MEMORY - A memory allocation failed.

--*/
{
    NET_API_STATUS NetStatus = NERR_Success;
    PWSTR UserCredentialString = NULL;
    PWSTR szUser=NULL;
    PWSTR szDomain=NULL;

    RtlZeroMemory( AuthIdent, sizeof( SEC_WINNT_AUTH_IDENTITY ) );

    //
    // If there are no creds, just return
    //
    if ( Account == NULL )
    {
        return NERR_Success;
    }

    NetStatus = NetpSeparateUserAndDomain(Account, &szUser, &szDomain);

    if ( NetStatus == NERR_Success )
    {
        if ( szUser )
        {
            AuthIdent->User = szUser;
            AuthIdent->UserLength = wcslen( szUser );
        }

        if ( szDomain )
        {
            AuthIdent->Domain = szDomain;
            AuthIdent->DomainLength = wcslen( szDomain );
        }

        if ( Password )
        {
            AuthIdent->Password = Password;
            AuthIdent->PasswordLength = wcslen( Password );
        }

        AuthIdent->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;
    }


    return( NetStatus );
}

NET_API_STATUS
NET_API_FUNCTION
NetpGetSeparatedSubstrings(
    IN  LPCWSTR szString,
    IN  WCHAR   chSeparator,
    OUT LPWSTR* pszS1,
    OUT LPWSTR* pszS2
    )
{
    NET_API_STATUS NetStatus = ERROR_FILE_NOT_FOUND;
    LPWSTR szT=NULL;
    LPWSTR szS1=NULL;
    LPWSTR szS2=NULL;

    *pszS1 = NULL;
    *pszS2 = NULL;

    if (szString && wcschr( szString, chSeparator ))
    {
        NetStatus = NetpDuplicateString(szString, -1, &szS1);

        if ( NetStatus == NERR_Success )
        {
            szT = wcschr( szS1, chSeparator );

            *szT = UNICODE_NULL;
            szT++;

            NetStatus = NetpDuplicateString(szT, -1, &szS2);
            if (NetStatus == NERR_Success)
            {
                *pszS1 = szS1;
                *pszS2 = szS2;
            }
        }
    }

    if (NetStatus != NERR_Success)
    {
        NetApiBufferFree(szS1);
        NetApiBufferFree(szS2);
    }

    return NetStatus;

}

NET_API_STATUS
NET_API_FUNCTION
NetpSeparateUserAndDomain(
    IN  LPCWSTR  szUserAndDomain,
    OUT LPWSTR*  pszUser,
    OUT LPWSTR*  pszDomain
    )
{
    NET_API_STATUS NetStatus = NERR_Success;

    *pszUser   = NULL;
    *pszDomain = NULL;

    //
    // check for domain\user format
    //
    NetStatus = NetpGetSeparatedSubstrings(szUserAndDomain, L'\\',
                                           pszDomain, pszUser);

    if (NetStatus == ERROR_FILE_NOT_FOUND)
    {
        //
        // check for user@domain format
        //
        //NetStatus = NetpGetSeparatedSubstrings(szUserAndDomain, L'@',
        //                                       pszUser, pszDomain);
        //if (NetStatus == ERROR_FILE_NOT_FOUND)
        //{
            //
            // domain not specified,  szUserAndDomain specifies a user
            //  (may be in the UPN format)
            //
            NetStatus = NetpDuplicateString(szUserAndDomain, -1, pszUser);
        //}
    }

    return NetStatus;
}


VOID
NET_API_FUNCTION
NetpFreeAuthIdentForCreds(
    IN  PSEC_WINNT_AUTH_IDENTITY AuthIdent
    )
/*++

Routine Description:

    Free the authident structure allocated above

Arguments:

    AuthIdent - AuthIdentity struct to free


Returns:

    VOID

--*/
{
    if ( AuthIdent )
    {
        NetApiBufferFree( AuthIdent->User );
        NetApiBufferFree( AuthIdent->Domain );
    }
}


NET_API_STATUS
NET_API_FUNCTION
NetpLdapUnbind(
    IN PLDAP Ldap
    )
/*++

Routine Description:

    Unbinds a current ldap connection

Arguments:

    Ldap -- Connection to be severed

Returns:

    NERR_Success -- Success

--*/
{
    NET_API_STATUS NetStatus = NERR_Success;

    if ( Ldap != NULL ) {

        NetStatus = LdapMapErrorToWin32( ldap_unbind( Ldap ) );

    }

    NetpLog((  "ldap_unbind status: 0x%lx\n", NetStatus ));

    return( NetStatus );
}


NET_API_STATUS
NET_API_FUNCTION
NetpLdapBind(
    IN LPWSTR szUncDcName,
    IN LPWSTR szUser,
    IN LPWSTR szPassword,
    OUT PLDAP *pLdap
    )
/*++

Routine Description:

    Binds to the named server using the given credentials

Arguments:

    szUncDcName -- DC to connect to
    szUser      -- User name to bind with
    szPassword  -- Password to use for bind
    pLdap       -- Where the connection handle is returned

Returns:

    NERR_Success -- Success

--*/
{
    NET_API_STATUS NetStatus = NERR_Success;
    SEC_WINNT_AUTH_IDENTITY AuthId, *pAuthId = NULL;
    LONG LdapOption;
    ULONG LdapStatus = LDAP_SUCCESS;

    //
    // Initialization
    //

    *pLdap = NULL;

    if ( szUser ) {
        NetStatus = NetpCreateAuthIdentForCreds( szUser, szPassword, &AuthId );
        pAuthId = &AuthId;
    }

    if ( NetStatus == NERR_Success ) {

        //
        // Open an LDAP connection to the DC and set useful options
        //

        *pLdap = ldap_initW( szUncDcName + 2, LDAP_PORT );

        if ( *pLdap ) {

            //
            // Tell LDAP we are passing an explicit DC name
            //  to avoid the DC discovery
            //
            LdapOption = PtrToLong( LDAP_OPT_ON );
            LdapStatus = ldap_set_optionW( *pLdap,
                                           LDAP_OPT_AREC_EXCLUSIVE,
                                           &LdapOption );

            if ( LdapStatus != LDAP_SUCCESS ) {
                NetpLog(( "NetpLdapBind: ldap_set_option LDAP_OPT_AREC_EXCLUSIVE failed on %ws: %ld: %s\n",
                          szUncDcName,
                          LdapStatus,
                          ldap_err2stringA(LdapStatus) ));
                NetStatus = LdapMapErrorToWin32( LdapStatus );

            //
            // Do the bind
            //
            } else {
                LdapStatus = ldap_bind_sW( *pLdap,
                                           NULL,
                                           (PWSTR) pAuthId,
                                           LDAP_AUTH_NEGOTIATE );

                if ( LdapStatus != LDAP_SUCCESS ) {
                    NetpLog(( "NetpLdapBind: ldap_bind failed on %ws: %ld: %s\n",
                              szUncDcName,
                              LdapStatus,
                              ldap_err2stringA(LdapStatus) ));
                    NetStatus = LdapMapErrorToWin32( LdapStatus );
                }
            }

            if ( NetStatus != NERR_Success ) {
                NetpLdapUnbind( *pLdap );
                *pLdap = NULL;
            }

        } else {
            LdapStatus = LdapGetLastError();
            NetpLog(( "NetpLdapBind: ldap_init to %ws failed: %lu\n",
                      szUncDcName,
                      LdapStatus ));
            NetStatus = LdapMapErrorToWin32( LdapStatus );
        }

        NetpFreeAuthIdentForCreds( pAuthId );
    }

    return( NetStatus );
}

NET_API_STATUS
NET_API_FUNCTION
NetpGetNCRoot(
    IN PLDAP Ldap,
    OUT LPWSTR *NCRoot,
    OUT PBOOLEAN SupportsPageable
    )
/*++

Routine Description:

    This routine determines the DS root for the given domain and determines whether this
    server supports pageable searches

Arguments:

    Ldap -- Connection to the server
    NCRoot -- Where the root is returned.  Must be freed via NetApiBufferFree
    SupportsPageable -- if TRUE, this server supports pageable searches

Returns:

    NERR_Success -- Success

--*/
{
    NET_API_STATUS NetStatus = NERR_Success;
    PWSTR Attribs[3] = {
        L"defaultNamingContext",
        L"supportedControl",
        NULL
        };
    PWSTR *Values = NULL;
    LDAPMessage *Message=NULL, *Entry;
    ULONG Items, i;


    NetStatus = LdapMapErrorToWin32( ldap_search_s( Ldap, NULL, LDAP_SCOPE_BASE,
                                     NETSETUPP_ALL_FILTER, Attribs, 0, &Message ) );

    if ( NetStatus == NERR_Success ) {

        Entry = ldap_first_entry( Ldap, Message );

        if ( Entry ) {

            //
            // Now, we'll have to get the values
            //
            Values = ldap_get_values( Ldap, Entry, Attribs[ 0 ] );

            if ( Values ) {

                NetStatus = NetpDuplicateString(Values[ 0 ], -1, NCRoot);
                ldap_value_free( Values );

            } else {

                NetStatus = LdapMapErrorToWin32( Ldap->ld_errno );

            }

            //
            // Now, see if we have the right control bits to do pageable stuff
            //
            if ( NetStatus == NERR_Success ) {

                Values = ldap_get_values( Ldap, Entry, Attribs[ 1 ] );

                if ( Values ) {

                    Items = ldap_count_values( Values );

                    for ( i = 0; i < Items ; i++ ) {

                        if ( _wcsicmp( Values[ i ], LDAP_PAGED_RESULT_OID_STRING_W ) == 0 ) {

                            *SupportsPageable = TRUE;
                            break;
                        }
                    }

                    ldap_value_free( Values );

                } else {

                    NetStatus = LdapMapErrorToWin32( Ldap->ld_errno );

                }

            }


        } else {

            NetStatus = LdapMapErrorToWin32( Ldap->ld_errno );
        }
    }

    if ( NetStatus != NERR_Success ) {

        NetpLog((  "Failed to find the root NC: %lu\n", NetStatus ));
    }

//Cleanup:
    if (Message)
    {
        ldap_msgfree( Message );
    }

    return( NetStatus );

}


NET_API_STATUS
NET_API_FUNCTION
NetpGetDefaultJoinableOu(
    IN LPWSTR Root,
    IN PLDAP Ldap,
    OUT PWSTR *DefaultOu
    )
/*++

Routine Description:

    This routine searches for all the OUs under the given domain root under which the bound
    user has the rights to create a computer object

    This routine does pageable searches

Arguments:

    Root -- Root NC path
    Ldap -- Connection to the server
    DefaultOu - Where the default joinable ou is returned.  NULL if no default joinable ou was
                found

Returns:

    NERR_Success -- Success

--*/
{
    NET_API_STATUS NetStatus = NERR_Success;
    PWSTR Attribs[] = {
        NETSETUPP_WELL_KNOWN,
        NULL
        };
    ULONG Count, Status, i, StringLength;
    PWSTR *WKOs = NULL, *Classes = NULL;
    LDAPMessage *Message = NULL, *Entry, *Message2 = NULL, *Entry2;
    PWSTR ParseString, End, DN;
    BOOLEAN MatchFound = FALSE;

    *DefaultOu = NULL;

    NetpLog((  "Default OU search\n" ));

    //
    // Ok, first, read the list of WellKnownObjects off of the root
    //
    Status = ldap_search_s( Ldap,
                            Root,
                            LDAP_SCOPE_BASE,
                            NETSETUPP_ALL_FILTER,
                            Attribs,
                            0,
                            &Message );

    if ( Message ) {

        Entry = ldap_first_entry( Ldap, Message );

        while ( Status == LDAP_SUCCESS && Entry ) {

            //
            // Read the list of objects that the current user is allowed to
            // create under this OU and make sure that we can create a computer
            // object
            //
            WKOs = ldap_get_values( Ldap, Entry, Attribs[ 0 ] );

            if ( WKOs ) {

                i = 0;
                while ( WKOs[ i ] ) {

                    if ( !toupper( WKOs[ i ][ 0 ] ) == L'B' ) {

                        NetpLog((  "Unexpected object string %ws\n",
                                            WKOs[ i ] ));
                        i++;
                        continue;
                    }

                    ParseString = WKOs[ i ] + 2;

                    StringLength = wcstoul( ParseString, &End, 10 );

                    ParseString = End + 1; // Skip over the ':'

                    if ( _wcsnicmp( ParseString,
                                    L"AA312825768811D1ADED00C04FD8D5CD",
                                    StringLength ) == 0 ) {

                        MatchFound = TRUE;
                        ParseString += StringLength + 1;

                        //
                        // Now, see if it is accessible or not
                        //
                        Attribs[ 0 ] = NETSETUPP_RETURNED_ATTR;

                        Status = ldap_search_s( Ldap,
                                                Root,
                                                LDAP_SCOPE_BASE,
                                                NETSETUPP_ALL_FILTER,
                                                Attribs,
                                                0,
                                                &Message2 );


                        if ( Message2 ) {

                            Entry2 = ldap_first_entry( Ldap, Message2 );

                            while ( Status == LDAP_SUCCESS && Entry2 ) {

                                //
                                // Read the list of objects that the current user is allowed to
                                // create under this OU and make sure that we can create a computer
                                // object
                                //
                                Classes = ldap_get_values( Ldap, Entry2, Attribs[ 0 ] );

                                if ( Classes ) {

                                    i = 0;
                                    while ( Classes[ i ] ) {

                                        if ( _wcsicmp( Classes[ i ],
                                                       NETSETUPP_COMPUTER_OBJECT ) == 0 ) {

                                            DN = ldap_get_dn( Ldap, Entry2 );

                                            NetStatus = NetpDuplicateString(DN, -1,
                                                                            DefaultOu);
                                            break;
                                        }

                                        i++;
                                    }

                                    ldap_value_free( Classes );
                                }

                                Entry2 = ldap_next_entry( Ldap, Entry2 );

                            }

                            Status = Ldap->ld_errno;
                            ldap_msgfree( Message2 );

                        }

                        if ( NetStatus != NERR_Success || MatchFound ) {

                            break;
                        }

                    }

                    i++;
                }

                ldap_value_free( WKOs );
            }

            Entry = ldap_next_entry( Ldap, Entry );

        }

        Status = Ldap->ld_errno;
        ldap_msgfree( Message );

    }

    if ( NetStatus == NERR_Success ) {

        NetStatus = LdapMapErrorToWin32( Status );
    }

    return( NetStatus );
}


NET_API_STATUS
NET_API_FUNCTION
NetpGetListOfJoinableOUsPaged(
    IN LPWSTR Root,
    IN PLDAP Ldap,
    OUT PULONG OUCount,
    OUT PWSTR **OUs
    )
/*++

Routine Description:

    This routine searches for all the OUs under the given domain root under which the bound
    user has the rights to create a computer object

    This routine does pageable searches

Arguments:

    Root -- Root NC path
    Ldap -- Connection to the server
    OUCount -- Where the count of strings is returned
    OUs -- Where the list of OUs is returned

Returns:

    NERR_Success -- Success

--*/
{
    NET_API_STATUS NetStatus = NERR_Success;
    PLDAPSearch SearchHandle = NULL;
    PWSTR Attribs[] = {
        NETSETUPP_RETURNED_ATTR,
        NULL
        };
    ULONG Count, i;
    ULONG Status = LDAP_SUCCESS;
    PWSTR *Classes = NULL;
    LDAPMessage *Message = NULL, *Entry;
    PWSTR DN;
    PWSTR *DnList = NULL, *NewList = NULL;
    ULONG CurrentIndex = 0, ListCount = 0;
    PWSTR DefaultOu = NULL;

    NetpLog((  "PAGED OU search\n" ));

    //
    // Initialize the pageable search
    //
    SearchHandle = ldap_search_init_pageW( Ldap,
                                           Root,
                                           LDAP_SCOPE_SUBTREE,
                                           NETSETUPP_OU_FILTER,
                                           Attribs,
                                           FALSE,
                                           NULL,
                                           NULL,
                                           0,
                                           2000,
                                           NULL );

    if ( SearchHandle == NULL ) {

        NetStatus = LdapMapErrorToWin32( LdapGetLastError( ) );

    } else {

        while ( NetStatus == NERR_Success ) {

            Count = 0;
            //
            // Get the next page
            //
            Status = ldap_get_next_page_s( Ldap,
                                           SearchHandle,
                                           NULL,
                                           100,
                                           &Count,
                                           &Message );

            if ( Message ) {

                //
                // Process all of the entries
                //
                Entry = ldap_first_entry( Ldap, Message );

                while ( Status == LDAP_SUCCESS && Entry ) {

                    //
                    // Read the list of classes that the current user is allowed to
                    // create under this OU and make sure that we can create a computer
                    // object
                    //
                    Classes = ldap_get_values( Ldap, Entry, Attribs[ 0 ] );

                    if ( Classes ) {

                        i = 0;
                        while ( Classes[ i ] ) {

                            if ( _wcsicmp( Classes[ i ], NETSETUPP_COMPUTER_OBJECT ) == 0 ) {

                                DN = ldap_get_dn( Ldap, Entry );

                                NetpKdPrint(( PREFIX_NETJOIN "DN = %ws\n", DN ));

                                //
                                // We'll allocate the return list in blocks of 10 to cut
                                // down on the number of allocations
                                //
                                if ( CurrentIndex >= ListCount ) {

                                    if ( NetApiBufferAllocate( ( ListCount + 10 ) * sizeof( PWSTR ),
                                                               ( PVOID * )&NewList ) != NERR_Success ) {

                                        Status = LDAP_NO_MEMORY;

                                     } else {

                                        RtlCopyMemory( NewList,
                                                       DnList,
                                                       ListCount * sizeof( PWSTR ) );
                                        ListCount += 10;
                                        DnList = NewList;
                                    }

                                }

                                //
                                // Copy the string
                                //
                                if ( Status == LDAP_SUCCESS ) {

                                    if (NERR_Success ==
                                        NetpDuplicateString(DN, -1,
                                                            &NewList[CurrentIndex]))
                                    {
                                        CurrentIndex++;
                                    }
                                    else
                                    {
                                        Status = LDAP_NO_MEMORY;
                                    }
                                }

                                ldap_memfree( DN );
                                break;
                            }
                            i++;
                        }

                        ldap_value_free( Classes );
                    }

                    Entry = ldap_next_entry( Ldap, Entry );

                }

                Status = Ldap->ld_errno;
                ldap_msgfree( Message );
                Message = NULL;

            }

            if ( Status == LDAP_NO_RESULTS_RETURNED ) {

                Status = LDAP_SUCCESS;
                break;
            }

        }

        ldap_search_abandon_page( Ldap,
                                  SearchHandle );

        NetStatus = LdapMapErrorToWin32( Status );
    }


    //
    // Check the computers container
    //
    if ( NetStatus == NERR_Success ) {

        NetStatus = NetpGetDefaultJoinableOu( Root,
                                              Ldap,
                                              &DefaultOu );

        if ( NetStatus == NERR_Success && DefaultOu ) {

            //
            // We'll allocate the return list in blocks of 10 to cut
            // down on the number of allocations
            //
            if ( CurrentIndex >= ListCount ) {

                if ( NetApiBufferAllocate( ( ListCount + 10 ) * sizeof( PWSTR ),
                                           ( PVOID * )&NewList ) != NERR_Success ) {

                    Status = LDAP_NO_MEMORY;

                 } else {

                    RtlCopyMemory( NewList,
                                   DnList,
                                   ListCount * sizeof( PWSTR ) );
                    ListCount += 10;
                    DnList = NewList;
                }

            }

            //
            // Copy the string
            //
            if ( Status == LDAP_SUCCESS ) {

                if (NERR_Success ==
                    NetpDuplicateString(DefaultOu, -1, &NewList[CurrentIndex]))
                {
                    CurrentIndex++;
                }
                else
                {
                    Status = LDAP_NO_MEMORY;
                }
            }

            NetApiBufferFree( DefaultOu );
        }
    }


    //
    // If there was an error, free everyting
    //
    if ( NetStatus != NERR_Success ) {

        for ( i = 0; i < ListCount; i++ ) {

            NetApiBufferFree( DnList[ i ] );
        }

        NetApiBufferFree( DnList );

    } else {

        *OUs = DnList;
        *OUCount = CurrentIndex;
    }

    if ( NetStatus == NERR_Success ) {

        NetpLog((  "Found %lu OUs\n", *OUs ));

    } else {

        NetpLog((  "Failed to obtain the list of joinable OUs: %lu\n",
                            NetStatus ));

    }
    return( NetStatus );
}


NET_API_STATUS
NET_API_FUNCTION
NetpGetListOfJoinableOUsNonPaged(
    IN LPWSTR Root,
    IN PLDAP Ldap,
    OUT PULONG OUCount,
    OUT PWSTR **OUs
    )
/*++

Routine Description:

    This routine searches for all the OUs under the given domain root under which the bound
    user has the rights to create a computer object

    This routine does not use pageable searchs and will return only the max_search count
    of entries

Arguments:

    Root -- Root NC path
    Ldap -- Connection to the server
    OUCount -- Where the count of strings is returned
    OUs -- Where the list of OUs is returned

Returns:

    NERR_Success -- Success

--*/
{

    NET_API_STATUS NetStatus = NERR_Success;
    PWSTR Attribs[] = {
        NETSETUPP_RETURNED_ATTR,
        NULL
        };
    ULONG Count, Status, i;
    PWSTR *Classes = NULL;
    LDAPMessage *Message = NULL, *Entry;
    PWSTR DN;
    PWSTR *DnList = NULL, *NewList = NULL;
    ULONG CurrentIndex = 0, ListCount = 0;
    PWSTR DefaultOu = NULL;

    NetpLog((  "Normal OU search\n" ));

    Status = ldap_search_s( Ldap,
                            Root,
                            LDAP_SCOPE_SUBTREE,
                            NETSETUPP_OU_FILTER,
                            Attribs,
                            0,
                            &Message );

    if ( Message ) {

        Entry = ldap_first_entry( Ldap, Message );

        while ( Status == LDAP_SUCCESS && Entry ) {

            //
            // Read the list of classes that the current user is allowed to
            // create under this OU and make sure that we can create a computer
            // object
            //
            Classes = ldap_get_values( Ldap, Entry, Attribs[ 0 ] );

            if ( Classes ) {

                i = 0;
                while ( Classes[ i ] ) {

                    if ( _wcsicmp( Classes[ i ], NETSETUPP_COMPUTER_OBJECT ) == 0 ) {

                        DN = ldap_get_dn( Ldap, Entry );

                        //
                        // We'll allocate the return list in blocks of 10 to cut
                        // down on the number of allocations
                        //
                        if ( CurrentIndex >= ListCount ) {

                            if ( NetApiBufferAllocate( ( ListCount + 10 ) * sizeof( PWSTR ),
                                                       ( PVOID * )&NewList ) != NERR_Success ) {

                                Status = LDAP_NO_MEMORY;

                             } else {

                                RtlCopyMemory( NewList,
                                               DnList,
                                               ListCount * sizeof( PWSTR ) );
                                ListCount += 10;
                                DnList = NewList;
                            }

                        }

                        //
                        // Copy the string
                        //
                        if ( Status == LDAP_SUCCESS ) {

                            if (NERR_Success ==
                                NetpDuplicateString(DN, -1, &NewList[CurrentIndex]))
                            {
                                CurrentIndex++;
                            }
                            else
                            {
                                Status = LDAP_NO_MEMORY;
                            }
                        }

                        ldap_memfree( DN );
                        break;
                    }
                    i++;
                }

                ldap_value_free( Classes );
            }

            Entry = ldap_next_entry( Ldap, Entry );

        }

        Status = Ldap->ld_errno;
        ldap_msgfree( Message );

    }

    NetStatus = LdapMapErrorToWin32( Status );

    //
    // Check the computers container
    //
    if ( NetStatus == NERR_Success ) {

        NetStatus = NetpGetDefaultJoinableOu( Root,
                                              Ldap,
                                              &DefaultOu );

        if ( NetStatus == NERR_Success && DefaultOu ) {

            //
            // We'll allocate the return list in blocks of 10 to cut
            // down on the number of allocations
            //
            if ( CurrentIndex >= ListCount ) {

                if ( NetApiBufferAllocate( ( ListCount + 10 ) * sizeof( PWSTR ),
                                           ( PVOID * )&NewList ) != NERR_Success ) {

                    Status = LDAP_NO_MEMORY;

                 } else {

                    RtlCopyMemory( NewList,
                                   DnList,
                                   ListCount * sizeof( PWSTR ) );
                    ListCount += 10;
                    DnList = NewList;
                }

            }

            //
            // Copy the string
            //
            if ( Status == LDAP_SUCCESS ) {

                if (NERR_Success ==
                    NetpDuplicateString(DefaultOu, -1, &NewList[CurrentIndex]))
                {
                    CurrentIndex++;
                }
                else
                {
                    Status = LDAP_NO_MEMORY;
                }
            }

            NetApiBufferFree( DefaultOu );
        }
    }

    //
    // If there was an error, free everyting
    //
    if ( NetStatus != NERR_Success ) {

        for ( i = 0; i < ListCount; i++ ) {

            NetApiBufferFree( DnList[ i ] );
        }

        NetApiBufferFree( DnList );

    } else {

        *OUs = DnList;
        *OUCount = CurrentIndex;
    }

    if ( NetStatus == NERR_Success ) {

        NetpLog((  "Found %lu OUs\n", *OUs ));

    } else {

        NetpLog((  "Failed to obtain the list of joinable OUs: %lu\n",
                            NetStatus ));

    }


    return( NetStatus );
}


NET_API_STATUS
NET_API_FUNCTION
NetpGetListOfJoinableOUs(
    IN LPWSTR Domain,
    IN LPWSTR Account,
    IN LPWSTR Password,
    OUT PULONG Count,
    OUT PWSTR **OUs
    )
/*++

Routine Description:

    This routine searches for all the OUs under the given domain root under which the bound
    user has the rights to create a computer object

Arguments:

    Domain -- Domain under which to find all of the OUs under which a computer object can be
        created
    Account -- Account to use for the LDAP bind
    Password -- Password to used for the bind.  The password is encoded.  The first WCHAR of the
                password is the seed.
    OUCount -- Where the count of strings is returned
    OUs -- Where the list of OUs is returned

Returns:

    NERR_Success -- Success
    NERR_DefaultJoinRequired -- The servers for this domain do not support the DS so the computer
        account can only be created under the default container (for NT4, this is the SAM account
        database)

--*/
{
    NET_API_STATUS NetStatus = NERR_Success;
    PWSTR DomainControllerName = NULL;
    ULONG DcFlags = 0;
    PLDAP Ldap = NULL;
    PWSTR NCRoot;
    BOOLEAN Pageable = FALSE;
    UCHAR Seed;
    UNICODE_STRING EncodedPassword;

    NetSetuppOpenLog();

    if ( Password ) {

        if ( wcslen( Password ) < 1 ) {

            return( ERROR_INVALID_PARAMETER );
        }

        Seed = ( UCHAR )*Password;
        RtlInitUnicodeString( &EncodedPassword, Password + 1 );

    } else {

        RtlZeroMemory( &EncodedPassword, sizeof( UNICODE_STRING ) );
        Seed = 0;
    }

    //
    // First, find a DC in the destination domain
    //
    NetStatus = NetpDsGetDcName( NULL,
                                 Domain,
                                 NULL,
                                 NETSETUPP_DSGETDC_FLAGS,
                                 &DcFlags,
                                 &DomainControllerName
                                 ,NULL
                                 );

    if ( NetStatus == NERR_Success ) {

        //
        // Try and bind to the server
        //
        RtlRunDecodeUnicodeString( Seed, &EncodedPassword );
        NetStatus = NetpLdapBind( DomainControllerName,
                                  Account,
                                  EncodedPassword.Buffer,
                                  &Ldap );
        RtlRunEncodeUnicodeString( &Seed, &EncodedPassword );

        if ( NetStatus == NERR_Success ) {


            //
            // Get the X500 domain name
            //
            NetStatus = NetpGetNCRoot( Ldap,
                                       &NCRoot,
                                       &Pageable );

            if ( NetStatus == NERR_Success ) {

                //
                // Get the list of OUs
                //
                if ( Pageable ) {

                    NetStatus = NetpGetListOfJoinableOUsPaged( NCRoot,
                                                               Ldap,
                                                               Count,
                                                               OUs );
                } else {

                    NetStatus = NetpGetListOfJoinableOUsNonPaged( NCRoot,
                                                                  Ldap,
                                                                  Count,
                                                                  OUs );

                }

                NetApiBufferFree( NCRoot );
            }

            NetpLdapUnbind( Ldap );

        } else if ( NetStatus == ERROR_BAD_NET_RESP ) {

            NetStatus = NERR_DefaultJoinRequired;
        }

        NetApiBufferFree( DomainControllerName );
    }

    if ( NetStatus != NERR_Success ) {

        NetpLog((  "NetpGetListOfJoinableOUs failed with %lu\n",
                            NetStatus ));

    }

    NetSetuppCloseLog( );

    return( NetStatus );
}

NET_API_STATUS
NetpGetDnsHostName(
    IN LPWSTR PassedHostName OPTIONAL,
    IN PUNICODE_STRING DnsDomainName,
    OUT LPWSTR *DnsHostName
    )
/*++

Routine Description:

    This routine determines the value of DnsHostName attribute to be set on the
    computer object in the DS. DnsHostName is <HostName.PrimaryDnsSuffix>.
    Here HostName is a computer name which may be different from the Netbios name;
    Netbios name is at most 15 characters of HostName.  PrimaryDnsSuffix can be
    set through Policy or through the UI or can be defaulted to the DNS name of the
    domain being joined; policy setting takes preference.

    This routine determines *new* values for HostName and PrimaryDnsSuffix which
    will be applied after the reboot. Thus DnsHostName will have the correct value
    after the machine reboots.

Arguments:

    PassedHostName - The host name of this machine (can be longer than 15 chars).
        If NULL, the host name is read from the registry.

    DnsDomainName - DNS name of the domain being joined

    DnsHostname - Returns the value of DnsHostName. Must be freed by calling
        NetApiBufferFree.

Returns:

    NO_ERROR - Success

    ERROR_NOT_ENOUGH_MEMORY - There was not enough memory to read the data from
        registry

    ERROR_INVALID_COMPUTERNAME - It was not possible to determine DnsHostName from
        the registry
--*/
{
    LONG RegStatus;
    HKEY Key = NULL;
    DWORD Type;
    NET_API_STATUS NetStatus;
    PWSTR HostName = NULL;
    PWSTR PrimaryDnsSuffix = NULL;
    LPWSTR LocalDnsHostName;
    DWORD Size = 0;

    //
    // First detemine HostName.
    //
    // If it's passed, use it
    //

    if ( PassedHostName != NULL ) {
        HostName = PassedHostName;

    //
    // Otherwise, read it from teh registry
    //
    } else {

        RegStatus = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                                   L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters",
                                   0,
                                   KEY_QUERY_VALUE,
                                   &Key );

        //
        // Not having host name is critical -- error out in such case
        //

        if ( RegStatus != ERROR_SUCCESS ) {
            NetpLog(( "NetpGetDnsHostName: Cannot open TCPIP parameters: 0x%lx\n", RegStatus ));

        } else {

            //
            // First try to read the new value
            //
            RegStatus = RegQueryValueExW( Key,
                                          L"NV Hostname",
                                          0,
                                          &Type,
                                          NULL,
                                          &Size );

            if ( RegStatus == ERROR_SUCCESS && Size != 0 ) {

                HostName = LocalAlloc( 0, Size );
                if ( HostName == NULL ) {
                    NetStatus = ERROR_NOT_ENOUGH_MEMORY;
                    goto Cleanup;
                }

                RegStatus = RegQueryValueExW( Key,
                                              L"NV Hostname",
                                              0,
                                              &Type,
                                              (PUCHAR) HostName,
                                              &Size );

                if ( RegStatus != ERROR_SUCCESS ) {
                    NetpLog(( "NetpGetDnsHostName: Cannot read NV Hostname: 0x%lx\n", RegStatus ));
                    NetStatus = ERROR_INVALID_COMPUTERNAME;
                    goto Cleanup;
                } else {
                    NetpLog(( "NetpGetDnsHostName: Read NV Hostname: %ws\n", HostName ));
                }
            }

            //
            // If the new value does not exist for some reason,
            // try to read the currently active one
            //
            if ( HostName == NULL ) {
                RegStatus = RegQueryValueExW( Key,
                                              L"Hostname",
                                              0,
                                              &Type,
                                              NULL,
                                              &Size );

                if ( RegStatus == ERROR_SUCCESS && Size != 0 ) {
                    HostName = LocalAlloc( 0, Size );
                    if ( HostName == NULL ) {
                        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
                        goto Cleanup;
                    }

                    RegStatus = RegQueryValueExW( Key,
                                                  L"Hostname",
                                                  0,
                                                  &Type,
                                                  (PUCHAR) HostName,
                                                  &Size );

                    if ( RegStatus != ERROR_SUCCESS ) {
                        NetpLog(( "NetpGetDnsHostName: Cannot read Hostname: 0x%lx\n", RegStatus ));
                        NetStatus = ERROR_INVALID_COMPUTERNAME;
                        goto Cleanup;
                    } else {
                        NetpLog(( "NetpGetDnsHostName: Read Hostname: %ws\n", HostName ));
                    }
                }
            }
        }
    }

    //
    // If we couldn't get HostName, something's really bad
    //

    if ( HostName == NULL ) {
        NetpLog(( "NetpGetDnsHostName: Could not get Hostname\n" ));
        NetStatus = ERROR_INVALID_COMPUTERNAME;
        goto Cleanup;
    }

    if ( Key != NULL ) {
        RegCloseKey( Key );
        Key = NULL;
    }

    //
    // Second read primary DNS suffix of this machine.
    //
    // Try the suffix that comes down through policy first
    //

    RegStatus = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                               L"Software\\Policies\\Microsoft\\System\\DNSclient",
                               0,
                               KEY_QUERY_VALUE,
                               &Key );

    if ( RegStatus == 0 ) {

        //
        // Read only the new value; if it doesn't exist the
        // current value will be deleted after the reboot
        //
        RegStatus = RegQueryValueExW( Key,
                                      L"NV PrimaryDnsSuffix",
                                      0,
                                      &Type,
                                      NULL,
                                      &Size );

        if ( RegStatus == ERROR_SUCCESS && Size != 0 ) {

            PrimaryDnsSuffix = LocalAlloc( 0, Size );
            if ( PrimaryDnsSuffix == NULL ) {
                NetStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }

            RegStatus = RegQueryValueExW( Key,
                                          L"NV PrimaryDnsSuffix",
                                          0,
                                          &Type,
                                          (PUCHAR) PrimaryDnsSuffix,
                                          &Size );

            if ( RegStatus != ERROR_SUCCESS ) {
                NetpLog(( "NetpGetDnsHostName: Cannot read NV PrimaryDnsSuffix: 0x%lx\n", RegStatus ));
                NetStatus = ERROR_INVALID_COMPUTERNAME;
                goto Cleanup;
            } else {
                NetpLog(( "NetpGetDnsHostName: Read NV PrimaryDnsSuffix: %ws\n", PrimaryDnsSuffix ));
            }
        }
    }

    //
    // If there is no policy setting for PrimaryDnsSuffix,
    // get it from the TCPIP setting
    //

    if ( Key != NULL ) {
        RegCloseKey( Key );
        Key = NULL;
    }

    if ( PrimaryDnsSuffix == NULL ) {

        RegStatus = RegOpenKeyExW( HKEY_LOCAL_MACHINE,
                                   L"System\\CurrentControlSet\\Services\\Tcpip\\Parameters",
                                   0,
                                   KEY_QUERY_VALUE,
                                   &Key );

        if ( RegStatus == ERROR_SUCCESS ) {
            ULONG SyncValue;

            Size = sizeof( ULONG );
            RegStatus = RegQueryValueEx( Key,
                                         L"SyncDomainWithMembership",
                                         0,
                                         &Type,
                                         (PUCHAR)&SyncValue,
                                         &Size );

            //
            // If we are not to sync DNS suffix with the name of the
            // domain that we join, get the configured suffix
            //
            if ( RegStatus == ERROR_SUCCESS && SyncValue == 0 ) {

                //
                // Read the new value
                //
                RegStatus = RegQueryValueExW( Key,
                                              L"NV Domain",
                                              0,
                                              &Type,
                                              NULL,
                                              &Size );

                if ( RegStatus == ERROR_SUCCESS && Size != 0 ) {

                    PrimaryDnsSuffix = LocalAlloc( 0, Size );
                    if ( PrimaryDnsSuffix == NULL ) {
                        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
                        goto Cleanup;
                    }

                    RegStatus = RegQueryValueExW( Key,
                                                  L"NV Domain",
                                                  0,
                                                  &Type,
                                                  (PUCHAR) PrimaryDnsSuffix,
                                                  &Size );

                    if ( RegStatus != ERROR_SUCCESS ) {
                        NetpLog(( "NetpGetDnsHostName: Cannot read NV Domain: 0x%lx\n", RegStatus ));
                        NetStatus = ERROR_INVALID_COMPUTERNAME;
                        goto Cleanup;
                    } else {
                        NetpLog(( "NetpGetDnsHostName: Read NV Domain: %ws\n", PrimaryDnsSuffix ));
                    }
                }

                //
                // If the new value does not exist for some reason,
                // read the currently active one
                //

                if ( PrimaryDnsSuffix == NULL ) {
                    RegStatus = RegQueryValueExW( Key,
                                                  L"Domain",
                                                  0,
                                                  &Type,
                                                  NULL,
                                                  &Size );

                    if ( RegStatus == ERROR_SUCCESS && Size != 0 ) {

                        PrimaryDnsSuffix = LocalAlloc( 0, Size );
                        if ( PrimaryDnsSuffix == NULL ) {
                            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
                            goto Cleanup;
                        }

                        RegStatus = RegQueryValueExW( Key,
                                                      L"Domain",
                                                      0,
                                                      &Type,
                                                      (PUCHAR) PrimaryDnsSuffix,
                                                      &Size );

                        if ( RegStatus != ERROR_SUCCESS ) {
                            NetpLog(( "NetpGetDnsHostName: Cannot read Domain: 0x%lx\n", RegStatus ));
                            NetStatus = ERROR_INVALID_COMPUTERNAME;
                            goto Cleanup;
                        } else {
                            NetpLog(( "NetpGetDnsHostName: Read Domain: %ws\n", PrimaryDnsSuffix ));
                        }
                    }
                }
            }
        }
    }

    //
    // If we still have no PrimaryDnsSuffix, use DNS name of the domain we join
    //

    if ( PrimaryDnsSuffix == NULL ) {
        NetpLog(( "NetpGetDnsHostName: PrimaryDnsSuffix defaulted to DNS domain name: %wZ\n", DnsDomainName ));

        PrimaryDnsSuffix = LocalAlloc( 0, DnsDomainName->Length + sizeof(WCHAR) );
        if ( PrimaryDnsSuffix == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        RtlCopyMemory( PrimaryDnsSuffix,
                       DnsDomainName->Buffer,
                       DnsDomainName->Length );

        PrimaryDnsSuffix[ (DnsDomainName->Length)/sizeof(WCHAR) ] = UNICODE_NULL;
    }

    //
    // Now we have Hostname and Primary DNS suffix.
    // Connect them with . to form DnsHostName.
    //

    NetStatus = NetApiBufferAllocate(
                          (wcslen(HostName) + 1 + wcslen(PrimaryDnsSuffix) + 1) * sizeof(WCHAR),
                          &LocalDnsHostName );

    if ( NetStatus != NO_ERROR ) {
        goto Cleanup;
    }

    wcscpy( LocalDnsHostName, HostName );
    wcscat( LocalDnsHostName, L"." );
    wcscat( LocalDnsHostName, PrimaryDnsSuffix );

    //
    // If we are here, it's a success
    //

    *DnsHostName = LocalDnsHostName;
    NetStatus = NO_ERROR;

Cleanup:

    if ( Key != NULL ) {
        RegCloseKey( Key );
    }

    if ( HostName != NULL && HostName != PassedHostName ) {
        LocalFree( HostName );
    }

    if ( PrimaryDnsSuffix != NULL ) {
        LocalFree( PrimaryDnsSuffix );
    }

    return NetStatus;
}

VOID
NetpRemoveDuplicateStrings(
    IN     PWCHAR *Source,
    IN OUT PWCHAR *Target
    )
/*++

Routine Description:

    This routine accepts two pointer arrays and removes those entries
    from the target array which point to strings that are identical to
    one of the strings pointed to by the entries in the source array.
    On return, the target array entries which precede the NULL terminator
    will point to strings which are different from any of the strings
    pointed to by the source array elements.

Arguments:

    Source -- The NULL terminated array of pointes to source strings.
        For example:
            Source[0] = L"abc";
            Source[1] = L"def";
            Source[2] = NULL;

    Target -- The NULL terminated array of pointes to target strings.
        For example:
            Target[0] = L"abc";
            Target[1] = L"ghi";
            Target[2] = L"def";
            Target[3] = NULL;

        On return, the Target array will be, for our example:
            Target[0] = L"ghi";
            Target[1] = NULL;
            Target[2] = L"def";
            Target[3] = NULL;

        Note that, on return, the target array has size of 1 and
            contains only one valid pointer.

Returns:

    VOID

--*/
{
    PWCHAR *TargetPtr, *TargetNextPtr, *SourcePtr;
    BOOL KeepEntry;

    //
    // Sanity check
    //

    if ( Source == NULL || *Source == NULL ||
         Target == NULL || *Target == NULL ) {
        return;
    }

    //
    // Loop through the target and compare with the source
    //

    for ( TargetPtr = TargetNextPtr = Target;
          *TargetNextPtr != NULL;
          TargetNextPtr++ ) {

        KeepEntry = TRUE;
        for ( SourcePtr = Source; *SourcePtr != NULL; SourcePtr++ ) {
            if ( _wcsicmp( *SourcePtr, *TargetNextPtr ) == 0 ) {
                KeepEntry = FALSE;
                break;
            }
        }

        if ( KeepEntry ) {
            *TargetPtr = *TargetNextPtr;
            TargetPtr ++;
        }
    }

    //
    // Terminate the target array
    //

    *TargetPtr = NULL;
    return;
}

DWORD
NetpCrackNamesStatus2Win32Error(
    DWORD dwStatus
)
{
    switch (dwStatus) {
        case DS_NAME_ERROR_RESOLVING:
            return ERROR_DS_NAME_ERROR_RESOLVING;

        case DS_NAME_ERROR_NOT_FOUND:
            return ERROR_DS_NAME_ERROR_NOT_FOUND;

        case DS_NAME_ERROR_NOT_UNIQUE:
            return ERROR_DS_NAME_ERROR_NOT_UNIQUE;

        case DS_NAME_ERROR_NO_MAPPING:
            return ERROR_DS_NAME_ERROR_NO_MAPPING;

        case DS_NAME_ERROR_DOMAIN_ONLY:
            return ERROR_DS_NAME_ERROR_DOMAIN_ONLY;

        case DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING:
            return ERROR_DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING;
    }

    return ERROR_FILE_NOT_FOUND;
}

//
// Machine account attributes in the DS
//

#define NETSETUPP_OBJECTCLASS          L"objectClass"
#define NETSETUPP_SAMACCOUNTNAME       L"SamAccountName"
#define NETSETUPP_DNSHOSTNAME          L"DnsHostName"
#define NETSETUPP_SERVICEPRINCIPALNAME L"ServicePrincipalName"
#define NETSETUPP_USERACCOUNTCONTROL   L"userAccountControl"
#define NETSETUPP_UNICODEPWD           L"unicodePwd"
#define NETSETUPP_ORGANIZATIONALUNIT   L"OrganizationalUnit"
#define NETSETUPP_HOST_SPN_PREFIX      L"HOST/"
#define NETSETUPP_COMP_OBJ_ATTR_COUNT  6
#define NETSETUPP_MULTIVAL_ATTRIB      0x01
#define NETSETUPP_COMPUTER_CONTAINER_GUID_IN_B32_FORM L"B:32:" GUID_COMPUTRS_CONTAINER_W L":"

typedef struct _NETSETUPP_MACH_ACC_ATTRIBUTE {
    PWSTR AttribType;      // Type of the attribute
    ULONG AttribFlags;     // Attribute flags
    PWSTR *AttribValues;   // Values of the attribute
} NETSETUPP_MACH_ACC_ATTRIBUTE, *PNETSETUPP_MACH_ACC_ATTRIBUTE;

NET_API_STATUS
NET_API_FUNCTION
NetpGetComputerObjectDn(
    IN  PDOMAIN_CONTROLLER_INFO DcInfo,
    IN  LPWSTR Account,
    IN  LPWSTR Password,
    IN  PLDAP  Ldap,
    IN  LPWSTR ComputerName,
    IN  LPWSTR OU  OPTIONAL,
    OUT LPWSTR *ComputerObjectDn
    )
/*++

Routine Description:

    Get the DN for the computer account in the specified OU.
        The algorithm is as follows.

        First try to get the DN of the pre-existing account (if any)
    by cracking the account name into a DN. If that succeeds, verify
    that the passed OU (if any) matches the cracked DN. If the OU
    matches, return success, otherwise return error (ERROR_FILE_EXISTS).
    If no OU is not passed, simply return the cracked DN.

        If the account does not exist, verify that the passed OU
    (if any) exists. If so, build the DN from the computer name and
    the OU and return it. If no OU is passed, get the default computer
    container name (by reading the WellKnownObjects attribute) and build
    the DN using the computer name and the default computer container DN.

Arguments:

    DcInfo - Domain controller on which to create the object

    Account - Account to use for the LDAP bind

    Password - Password to used for the bind

    Ldap - Ldap binding to the DC

    ComputerName - Name of the computer being joined

    OU - OU under which to create the object.
        The name must be a fully qualified name
        e.g.: "ou=test,dc=ntdev,dc=microsoft,dc=com"
        NULL indicates to use the default computer container

    ComputerObjectDn - Returns the DN of the computer object.
        The retuned buffer must be freed using NetApiBufferFree

Returns:

    NO_ERROR -- Success

    ERROR_DS_NAME_ERROR_NOT_UNIQUE -- One of names being cracked
        (the Netbios domain name or the pre-existing account name
        or the root DN) is not unique.

    ERROR_FILE_EXISTS -- The OU passed does not match the cracked DN
        of the pre-existing account.

    ERROR_FILE_NOT_FOUND -- The specified OU does not exist or
        Could not get/read the WellKnownObjects attribute or
        Could not get the default computer container name from the
         WellKnownObjects attribute.

    ERROR_NOT_ENOUGH_MEMORY -- Could not allocated memory required.

    One of the errors returned by DsCrackNames.
        (see NetpCrackNamesStatus2Win32Error())

--*/
{
    NET_API_STATUS NetStatus = NO_ERROR;
    ULONG LdapStatus;
    HANDLE hDs = NULL;
    PWCHAR AccountUserName = NULL;
    PWCHAR AccountDomainName = NULL;
    LPWSTR NetbiosDomainNameWithBackslash = NULL;
    PWCHAR ComputerContainerDn = NULL;
    PWCHAR NameToCrack = NULL;
    RPC_AUTH_IDENTITY_HANDLE AuthId = 0;
    PDS_NAME_RESULTW CrackedName = NULL;
    PWCHAR WellKnownObjectsAttr[2];
    PWSTR *WellKnownObjectValues = NULL;
    LDAPMessage *LdapMessage = NULL, *LdapEntry = NULL;
    LPWSTR LocalComputerObjectDn = NULL;
    ULONG Index;

    //
    // First check whether the account already exists for the computer
    //
    // If account is passed, prepare the corresponding credentials.
    //  Otherwise, use the default creds of the user running this routine.
    //

    if ( Account != NULL ) {
        NetStatus = NetpSeparateUserAndDomain( Account, &AccountUserName, &AccountDomainName );
        if ( NetStatus != NERR_Success ) {
            NetpLog(( "NetpGetComputerObjectDn: Cannot NetpSeparateUserAndDomain 0x%lx\n", NetStatus ));
            goto Cleanup;
        }

        NetStatus = DsMakePasswordCredentials( AccountUserName,
                                               AccountDomainName,
                                               Password,
                                               &AuthId);
        if ( NetStatus != NERR_Success ) {
            NetpLog(( "NetpGetComputerObjectDn: Cannot DsMakePasswordCredentials 0x%lx\n", NetStatus ));
            goto Cleanup;
        }
    }

    //
    // Bind to the DS on the DC.
    //

    NetStatus = DsBindWithCredW( DcInfo->DomainControllerName, NULL, AuthId, &hDs);

    if ( NetStatus != NO_ERROR ) {
        NetpLog(( "NetpGetComputerObjectDn: Unable to bind to DS on '%ws': 0x%lx\n",
                  DcInfo->DomainControllerName, NetStatus ));
        goto Cleanup ;
    }

    //
    // Attempt to crack the account name into a DN.
    //
    //  We need to have the Netbios domain name to
    //  form an NT4 style account name since DsCrackNames
    //  doesn't accept DNS domain names for cracking accounts.
    //  So, if we have a DNS domain name, we need to crack it
    //  into a Netbios domain name first.
    //

    if ( (DcInfo->Flags & DS_DNS_DOMAIN_FLAG) == 0 ) {

        NetbiosDomainNameWithBackslash = LocalAlloc( 0, (wcslen(DcInfo->DomainName) + 2) * sizeof(WCHAR) );
        if ( NetbiosDomainNameWithBackslash == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        swprintf( NetbiosDomainNameWithBackslash, L"%ws\\", DcInfo->DomainName );

    } else {

        NameToCrack = LocalAlloc( 0, (wcslen(DcInfo->DomainName) + 1 + 1) * sizeof(WCHAR) );

        if ( NameToCrack == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        swprintf( NameToCrack, L"%ws/", DcInfo->DomainName );

        //
        // Be verbose
        //
        NetpLog(( "NetpGetComputerObjectDn: Cracking DNS domain name %ws into Netbios on %ws\n",
                  NameToCrack,
                  DcInfo->DomainControllerName ));

        if ( CrackedName != NULL ) {
            DsFreeNameResultW( CrackedName );
            CrackedName = NULL;
        }

        //
        // Crack the DNS domain name into a Netbios domain name
        //
        NetStatus = DsCrackNamesW( hDs,
                                   0,
                                   DS_CANONICAL_NAME,
                                   DS_NT4_ACCOUNT_NAME,
                                   1,
                                   &NameToCrack,
                                   &CrackedName );

        if ( NetStatus != NO_ERROR ) {
            NetpLog(( "NetpGetComputerObjectDn: CrackNames failed for %ws: 0x%lx\n",
                      NameToCrack,
                      NetStatus ));
            goto Cleanup ;
        }

        //
        // Check for consistency
        //
        if ( CrackedName->cItems != 1 ) {
            NetStatus = ERROR_DS_NAME_ERROR_NOT_UNIQUE;
            NetpLog(( "NetpGetComputerObjectDn: Cracked Name %ws is not unique: %lu\n",
                      NameToCrack,
                      CrackedName->cItems ));
            goto Cleanup ;
        }

        if ( CrackedName->rItems[0].status != DS_NAME_NO_ERROR ) {
            NetpLog(( "NetpGetComputerObjectDn: CrackNames failed for %ws: substatus 0x%lx\n",
                      NameToCrack,
                      CrackedName->rItems[0].status ));
            NetStatus = NetpCrackNamesStatus2Win32Error( CrackedName->rItems[0].status );
            goto Cleanup ;
        }

        //
        // Be verbose
        //
        NetpLog(( "NetpGetComputerObjectDn: Crack results: \tname = %ws\n",
                  CrackedName->rItems[0].pName ));

        //
        // We've got the Netbios domain name
        //  (the cracked name already includes the trailing backslash)
        //

        NetbiosDomainNameWithBackslash = LocalAlloc( 0, (wcslen(CrackedName->rItems[0].pName) + 1) * sizeof(WCHAR) );
        if ( NetbiosDomainNameWithBackslash == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        wcscpy( NetbiosDomainNameWithBackslash, CrackedName->rItems[0].pName );
    }

    //
    // Form the NT4 account name given the Netbios domain name
    //

    if ( NameToCrack != NULL ) {
        LocalFree( NameToCrack );
        NameToCrack = NULL;
    }

    NameToCrack = LocalAlloc( 0,
                  (wcslen(NetbiosDomainNameWithBackslash) + wcslen(ComputerName) + 1 + 1) * sizeof(WCHAR) );
    if ( NameToCrack == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    swprintf( NameToCrack, L"%ws%ws$", NetbiosDomainNameWithBackslash, ComputerName );

    //
    // Crack the account name into a DN
    //

    if ( CrackedName != NULL ) {
        DsFreeNameResultW( CrackedName );
        CrackedName = NULL;
    }

    //
    // Be verbose
    //

    NetpLog(( "NetpGetComputerObjectDn: Cracking account name %ws on %ws\n",
              NameToCrack,
              DcInfo->DomainControllerName ));

    NetStatus = DsCrackNamesW( hDs,
                               0,
                               DS_NT4_ACCOUNT_NAME,
                               DS_FQDN_1779_NAME,
                               1,
                               &NameToCrack,
                               &CrackedName );

    if ( NetStatus != NO_ERROR ) {
        NetpLog(( "NetpGetComputerObjectDn: CrackNames failed for %ws: 0x%lx\n",
                  NameToCrack,
                  NetStatus ));
        goto Cleanup ;
    }

    //
    // Check for consistency
    //

    if ( CrackedName->cItems > 1 ) {
        NetStatus = ERROR_DS_NAME_ERROR_NOT_UNIQUE;
        NetpLog(( "NetpGetComputerObjectDn: Cracked Name %ws is not unique: %lu\n",
                  NameToCrack,
                  CrackedName->cItems ));
        goto Cleanup ;
    }

    //
    // If the account alredy exists, verify that the passed OU (if any)
    //  matches that of the account DN
    //

    if ( CrackedName->rItems[0].status == DS_NAME_NO_ERROR ) {
        ULONG DnSize;

        NetpLog(( "NetpGetComputerObjectDn: Crack results: \t(Account already exists) DN = %ws\n",
                  CrackedName->rItems[0].pName ));

        DnSize = ( wcslen(CrackedName->rItems[0].pName) + 1 ) * sizeof(WCHAR);

        //
        // Allocate storage for the computer object DN
        //
        NetStatus = NetApiBufferAllocate( DnSize, &LocalComputerObjectDn );
        if ( NetStatus != NO_ERROR ) {
            goto Cleanup;
        }

        //
        // If the OU is passed, verify that it matches the cracked name
        //
        if ( OU != NULL ) {
            ULONG DnSizeFromOu;

            DnSizeFromOu = ( wcslen(NETSETUPP_OBJ_PREFIX) +
                             wcslen(ComputerName) + 1 + wcslen(OU) + 1 ) * sizeof(WCHAR);

            if ( DnSizeFromOu != DnSize ) {
                NetpLog(( "NetpGetComputerObjectDn: Passed OU doesn't match in size cracked DN: %lu %lu\n",
                          DnSizeFromOu,
                          DnSize ));
                NetStatus = ERROR_FILE_EXISTS;
                goto Cleanup;
            }

            swprintf( LocalComputerObjectDn, L"%ws%ws,%ws", NETSETUPP_OBJ_PREFIX, ComputerName, OU );

            if ( _wcsicmp(LocalComputerObjectDn, CrackedName->rItems[0].pName) != 0 ) {
                NetpLog(( "NetpGetComputerObjectDn: Passed OU doesn't match cracked DN: %ws %ws\n",
                          LocalComputerObjectDn,
                          CrackedName->rItems[0].pName ));

                NetStatus = ERROR_FILE_EXISTS;
                goto Cleanup;
            }

        //
        // Otherwise, just use the cracked name
        //
        } else {
            wcscpy( LocalComputerObjectDn, CrackedName->rItems[0].pName );
        }

        //
        // We've got the computer object DN from the existing account
        //
        NetStatus = NO_ERROR;
        goto Cleanup;
    }

    //
    // Be verbose
    //

    NetpLog(( "NetpGetComputerObjectDn: Crack results: \tAccount does not exist\n" ));


    //
    // At this point, we know that the account does not exist
    //  If OU is passed, simply verify it
    //

    if ( OU != NULL ) {
        LdapStatus = ldap_compare_s( Ldap,
                                     OU,
                                     NETSETUPP_OBJECTCLASS,
                                     NETSETUPP_ORGANIZATIONALUNIT );

        if ( LdapStatus == LDAP_COMPARE_FALSE ) {
            NetStatus = ERROR_FILE_NOT_FOUND;
            NetpLog(( "NetpGetComputerObjectDn: Specified path '%ws' is not an OU\n", OU ));
            goto Cleanup;
        } else if ( LdapStatus != LDAP_COMPARE_TRUE ) {
            NetStatus = LdapMapErrorToWin32( LdapStatus );
            NetpLog(( "NetpGetComputerObjectDn: ldap_compare_s failed: 0x%lx 0x%lx\n",
                      LdapStatus, NetStatus ));
            goto Cleanup;
        }

        //
        // OU has been verified.
        //  Allocate the computer object DN.
        //

        NetStatus = NetApiBufferAllocate(
                      ( wcslen(NETSETUPP_OBJ_PREFIX) +
                        wcslen(ComputerName) + 1 + wcslen(OU) + 1 ) * sizeof(WCHAR),
                      &LocalComputerObjectDn );

        if ( NetStatus != NO_ERROR ) {
            goto Cleanup;
        }

        //
        // We've got the computer object DN from the OU passed
        //
        swprintf( LocalComputerObjectDn, L"%ws%ws,%ws", NETSETUPP_OBJ_PREFIX, ComputerName, OU );
        NetpLog(( "NetpGetComputerObjectDn: Got DN %ws from the passed OU\n", LocalComputerObjectDn ));
        NetStatus = NO_ERROR;
        goto Cleanup;
    }


    //
    // At this point, the account does not exist
    //  and no OU was specified. So get the default
    //  computer container DN.
    //

    if ( CrackedName != NULL ) {
        DsFreeNameResultW( CrackedName );
        CrackedName = NULL;
    }

    //
    // Be verbose
    //

    NetpLog(( "NetpGetComputerObjectDn: Cracking Netbios domain name %ws into root DN on %ws\n",
              NetbiosDomainNameWithBackslash,
              DcInfo->DomainControllerName ));

    NetStatus = DsCrackNamesW( hDs,
                               0,
                               DS_NT4_ACCOUNT_NAME,
                               DS_FQDN_1779_NAME,
                               1,
                               &NetbiosDomainNameWithBackslash,
                               &CrackedName );

    if ( NetStatus != NO_ERROR ) {
        NetpLog(( "NetpGetComputerObjectDn: CrackNames failed for %ws: 0x%lx\n",
                  NetbiosDomainNameWithBackslash,
                  NetStatus ));
        goto Cleanup ;
    }

    //
    // Check for consistency
    //

    if ( CrackedName->cItems != 1 ) {
        NetStatus = ERROR_DS_NAME_ERROR_NOT_UNIQUE;
        NetpLog(( "NetpGetComputerObjectDn: Cracked Name %ws is not unique: %lu\n",
                  NetbiosDomainNameWithBackslash,
                  CrackedName->cItems ));
        goto Cleanup ;
    }

    if ( CrackedName->rItems[0].status != DS_NAME_NO_ERROR ) {
        NetpLog(( "NetpGetComputerObjectDn: CrackNames failed for %ws: substatus 0x%lx\n",
                  NetbiosDomainNameWithBackslash,
                  CrackedName->rItems[0].status ));
        NetStatus = NetpCrackNamesStatus2Win32Error( CrackedName->rItems[0].status );
        goto Cleanup ;
    }

    //
    // Be verbose
    //

    NetpLog(( "NetpGetComputerObjectDn: Crack results: \tname = %ws\n",
              CrackedName->rItems[0].pName ));

    //
    // Now get the computer container DN given the root DN.
    // The DN of the computer container is part of the wellKnownObjects
    // attribute in the root of the domain. So, look it up.
    //

    WellKnownObjectsAttr[0] = L"wellKnownObjects";
    WellKnownObjectsAttr[1] = NULL;

    LdapStatus = ldap_search_s( Ldap,
                                CrackedName->rItems[0].pName, // Root DN
                                LDAP_SCOPE_BASE,
                                L"objectclass=*",
                                WellKnownObjectsAttr,
                                0,
                                &LdapMessage);

    if ( LdapStatus != LDAP_SUCCESS ) {
        NetStatus = LdapMapErrorToWin32( LdapStatus );
        NetpLog(( "NetpGetComputerObjectDn: ldap_search_s failed 0x%lx 0x%lx\n",
                  LdapStatus,
                  NetStatus ));
        goto Cleanup;
    }

    if ( ldap_count_entries(Ldap, LdapMessage) == 0 ) {
        NetStatus = ERROR_FILE_NOT_FOUND;
        NetpLog(( "NetpGetComputerObjectDn: ldap_search_s returned no entries\n" ));
        goto Cleanup;
    }

    LdapEntry = ldap_first_entry( Ldap, LdapMessage );

    if ( LdapEntry == NULL ) {
        NetStatus = ERROR_FILE_NOT_FOUND;
        NetpLog(( "NetpGetComputerObjectDn: ldap_first_entry returned NULL\n" ));
        goto Cleanup;
    }

    WellKnownObjectValues = ldap_get_valuesW( Ldap,
                                              LdapEntry,
                                              L"wellKnownObjects" );
    if ( WellKnownObjectValues == NULL ) {
        NetStatus = ERROR_FILE_NOT_FOUND;
        NetpLog(( "NetpGetComputerObjectDn: ldap_get_valuesW returned NULL\n" ));
        goto Cleanup;
    }

    //
    // Lookup the default computer container
    //

    for ( Index = 0; WellKnownObjectValues[Index] != NULL; Index++ ) {

        //
        // The structure of this particular field is:
        // L"B:32:GUID:DN" where GUID is AA312825768811D1ADED00C04FD8D5CD
        //
        if ( _wcsnicmp( WellKnownObjectValues[Index],
                        NETSETUPP_COMPUTER_CONTAINER_GUID_IN_B32_FORM,
                        wcslen(NETSETUPP_COMPUTER_CONTAINER_GUID_IN_B32_FORM) ) == 0 ) {

            ComputerContainerDn = WellKnownObjectValues[Index] +
                wcslen(NETSETUPP_COMPUTER_CONTAINER_GUID_IN_B32_FORM);

            break;
        }
    }

    //
    // If we couldn't get the computer container DN, error out
    //

    if ( ComputerContainerDn == NULL || *ComputerContainerDn == L'\0' ) {
        NetpLog(( "NetpGetComputerObjectDn: Couldn't get computer container DN\n" ));
        NetStatus = ERROR_FILE_NOT_FOUND;
        goto Cleanup;
    }

    //
    // Allocate the computer object DN
    //

    NetStatus = NetApiBufferAllocate(
                  ( wcslen(NETSETUPP_OBJ_PREFIX) +
                    wcslen(ComputerName) + 1 + wcslen(ComputerContainerDn) + 1 ) * sizeof(WCHAR),
                  &LocalComputerObjectDn );

    if ( NetStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // We've got the computer object DN from the default computer container
    //

    swprintf( LocalComputerObjectDn, L"%ws%ws,%ws", NETSETUPP_OBJ_PREFIX, ComputerName, ComputerContainerDn );
    NetpLog(( "NetpGetComputerObjectDn: Got DN %ws from the default computer container\n", LocalComputerObjectDn ));
    NetStatus = NO_ERROR;

    //
    // Free locally used resources
    //

Cleanup:

    if ( hDs ) {
        DsUnBind( &hDs );
    }

    if ( CrackedName ) {
        DsFreeNameResultW( CrackedName );
    }

    if ( AuthId ) {
        DsFreePasswordCredentials( AuthId );
    }

    if ( WellKnownObjectValues != NULL ) {
        ldap_value_free( WellKnownObjectValues );
    }

    if ( NameToCrack != NULL ) {
        LocalFree( NameToCrack );
    }

    if ( AccountUserName != NULL ) {
        NetApiBufferFree( AccountUserName );
    }

    if ( AccountDomainName != NULL ) {
        NetApiBufferFree( AccountDomainName );
    }

    if ( NetbiosDomainNameWithBackslash != NULL ) {
        LocalFree( NetbiosDomainNameWithBackslash );
    }

    if ( LdapMessage != NULL ) {
        ldap_msgfree( LdapMessage );
    }

    if ( NetStatus == NO_ERROR ) {
        *ComputerObjectDn = LocalComputerObjectDn;
    } else if ( LocalComputerObjectDn != NULL ) {
        NetApiBufferFree( LocalComputerObjectDn );
    }

    return NetStatus;
}

NET_API_STATUS
NET_API_FUNCTION
NetpModifyComputerObjectInDs(
    IN LPWSTR DC,
    IN PLDAP  Ldap,
    IN LPWSTR ComputerName,
    IN LPWSTR ComputerObjectDn,
    IN ULONG  NumberOfAttributes,
    IN OUT PNETSETUPP_MACH_ACC_ATTRIBUTE Attrib
    )
/*++

Routine Description:

    Create a computer account in the specified OU.

Arguments:

    DC              -- Domain controller on which to create the object
    Ldap               -- Ldap binding to the DC
    ComputerName    -- Name of the computer being joined
    ComputerObjectDn   -- DN of computer object being modified
    NumberOfAttributes -- Number of attributes passed
    Attrib             -- List of attribute structures. The list may
                          be modified on return so that only those entries
                          that were not already set in the DS will be preserved.

    NOTE: If the machine password (unicodePwd) is passed as one of the attributes,
          it must be the last entry in the attribute list because this order is assumed
          by the fail-over code below.

Returns:

    NERR_Success -- Success

--*/
{
    NET_API_STATUS NetStatus = NERR_Success;
    ULONG LdapStatus;

    PWSTR *AttribTypesList = NULL;
    LDAPMod *ModList = NULL;
    PLDAPMod *Mods = NULL;
    LDAPMessage *Message = NULL, *Entry;
    ULONG Index;
    ULONG ModIndex = 0;
    BOOL NewAccount = FALSE;

    PWSTR SamAccountName = NULL;
    USER_INFO_1 *CurrentUI1 = NULL;

    //
    // Allocate storage for the attribute list and the modifications block
    //

    NetStatus = NetApiBufferAllocate( (NumberOfAttributes+1)*sizeof(PWSTR),
                                      (PVOID *) &AttribTypesList );
    if ( NetStatus != NO_ERROR ) {
        goto Cleanup;
    }

    NetStatus = NetApiBufferAllocate( NumberOfAttributes * sizeof(LDAPMod),
                                      (PVOID *) &ModList );
    if ( NetStatus != NO_ERROR ) {
        goto Cleanup;
    }

    NetStatus = NetApiBufferAllocate( (NumberOfAttributes+1)*sizeof(PLDAPMod),
                                      (PVOID *) &Mods );
    if ( NetStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Build modification list given the list of attributes
    //

    NetpLog(( "NetpModifyComputerObjectInDs: Initial attribute values:\n" ));
    for ( Index = 0; Index < NumberOfAttributes; Index++ ) {
        ModList[Index].mod_op     = LDAP_MOD_ADD;  // Set to add. We may adjust this below.
        ModList[Index].mod_type   = Attrib[Index].AttribType;
        ModList[Index].mod_values = Attrib[Index].AttribValues;

        //
        // Be verbose - output all values of each attribute
        //
        NetpLog(( "\t\t%ws  =", Attrib[Index].AttribType ));

        //
        // Don't leak sensitive info!
        //
        if ( _wcsicmp( Attrib[Index].AttribType, NETSETUPP_UNICODEPWD ) == 0 ) {
            NetpLog(( "  <SomePassword>" ));
        } else {
            PWSTR *CurrentValues;

            for ( CurrentValues = Attrib[Index].AttribValues; *CurrentValues != NULL; CurrentValues++ ) {
                NetpLog(( "  %ws", *CurrentValues ));
            }
        }
        NetpLog(( "\n" ));
    }

    //
    // Now check which attribute values are already set in the DS
    //

    for ( Index = 0; Index < NumberOfAttributes; Index++ ) {
        AttribTypesList[Index] = Attrib[Index].AttribType;
    }
    AttribTypesList[Index] = NULL;  // Terminate the list

    LdapStatus = ldap_search_s( Ldap,
                                ComputerObjectDn,
                                LDAP_SCOPE_BASE,
                                NULL,
                                AttribTypesList,
                                0,
                                &Message );

    //
    // If the computer object does not exist,
    //  we need to add all attributes
    //

    if ( LdapStatus == LDAP_NO_SUCH_OBJECT ) {
        NetpLog(( "NetpModifyComputerObjectInDs: Computer Object does not exist in OU\n" ));
        NewAccount = TRUE;

        for ( ModIndex = 0; ModIndex < NumberOfAttributes; ModIndex++ ) {
            Mods[ModIndex] = &ModList[ModIndex];
        }

        //
        // Terminate the modification list
        //
        Mods[ModIndex] = NULL;

    //
    // Otherwise see which attribute values need modification
    //

    } else if ( LdapStatus == LDAP_SUCCESS ) {
        NetpLog(( "NetpModifyComputerObjectInDs: Computer Object already exists in OU:\n" ));

        //
        // Get the first entry (there should be only one)
        //
        Entry = ldap_first_entry( Ldap, Message );

        //
        // Loop through the attributes and weed out those values
        // which are already set.
        //
        for ( Index = 0; Index < NumberOfAttributes; Index++ ) {
            PWSTR *AttribValueRet = NULL;

            //
            // Be verbose - output the values returned for each type
            //
            NetpLog(( "\t\t%ws  =", Attrib[Index].AttribType ));

            AttribValueRet = ldap_get_values( Ldap, Entry, Attrib[Index].AttribType );

            if ( AttribValueRet != NULL ) {

                //
                // Don't leak sensitive info!
                //
                if ( _wcsicmp( Attrib[Index].AttribType, NETSETUPP_UNICODEPWD ) == 0 ) {
                    NetpLog(( "  <SomePassword>" ));
                } else {
                    PWSTR *CurrentValueRet;

                    for ( CurrentValueRet = AttribValueRet; *CurrentValueRet != NULL; CurrentValueRet++ ) {
                        NetpLog(( "  %ws", *CurrentValueRet ));
                    }
                }

                //
                // Remove those values from the modification which are alredy set
                //
                NetpRemoveDuplicateStrings( AttribValueRet, Attrib[Index].AttribValues );

                ldap_value_free( AttribValueRet );

                //
                // If this is a single valued attribute, we need to
                //  replace (not add) its value since it already exists in the DS
                //
                if ( (Attrib[Index].AttribFlags & NETSETUPP_MULTIVAL_ATTRIB) == 0 ) {
                    ModList[Index].mod_op = LDAP_MOD_REPLACE;
                }
            }
            NetpLog(( "\n" ));

            //
            // If there are any attribute values which are
            // not already set, add them to the modification.
            //
            if ( *(Attrib[Index].AttribValues) != NULL ) {
                Mods[ModIndex] = &ModList[Index];
                ModIndex ++;
            }

        }

        //
        // Terminate the modification list
        //
        Mods[ModIndex] = NULL;

    //
    // Otherwise, error out
    //

    } else {
        NetStatus = LdapMapErrorToWin32( LdapStatus );
        NetpLog(( "NetpModifyComputerObjectInDs: ldap_search_s failed: 0x%lx 0x%lx\n",
                  LdapStatus, NetStatus ));
        goto Cleanup;
    }

    //
    // If there are no modifications to do
    //  we are done.
    //

    if ( ModIndex == 0 ) {
        NetpLog(( "NetpModifyComputerObjectInDs: There are _NO_ modifications to do\n" ));
        NetStatus = NERR_Success;
        goto Cleanup;
    }

    //
    // Be verbose - output the attribute values to be set
    //
    NetpLog(( "NetpModifyComputerObjectInDs: Attribute values to set:\n" ));
    for ( Index = 0; Mods[Index] != NULL; Index++ ) {
        NetpLog(( "\t\t%ws  =", (*(Mods[Index])).mod_type ));

        //
        // Don't leak sensitive info!
        //
        if ( _wcsicmp( (*(Mods[Index])).mod_type, NETSETUPP_UNICODEPWD ) == 0 ) {
            NetpLog(( "  <SomePassword>" ));
        } else {
            ULONG ValIndex;

            for ( ValIndex = 0; ((*(Mods[Index])).mod_values)[ValIndex] != NULL; ValIndex++ ) {
                NetpLog(( "  %ws", ((*(Mods[Index])).mod_values)[ValIndex] ));
            }
        }
        NetpLog(( "\n" ));
    }


    //
    // Now, add the missing attributes
    //

    if ( NewAccount ) {
        LdapStatus = ldap_add_s( Ldap, ComputerObjectDn, Mods );
    } else {
        LdapStatus = ldap_modify_s( Ldap, ComputerObjectDn, Mods );
    }

    //
    // If we tried to create against a server that doesn't support 128 bit encryption,
    // we get LDAP_UNWILLING_TO_PERFORM back from the server. So, we'll create the
    // account again without the password, and then reset it using NetApi.
    //

    if ( LdapStatus == LDAP_UNWILLING_TO_PERFORM ) {
        LPWSTR MachinePassword;

        NetpLog(( "NetpModifyComputerObjectInDs: ldap_modify_s (1) returned"
                  " LDAP_UNWILLING_TO_PERFORM. Trying to recover.\n" ));

        //
        // If we didn't try to set a password, there is no legitimate reason
        // for the add to fail.
        //
        if ( _wcsicmp( (*(Mods[ModIndex-1])).mod_type, NETSETUPP_UNICODEPWD ) != 0 ) {
            NetpLog(( "NetpModifyComputerObjectInDs: ldap_modify_s retuned LDAP_UNWILLING_TO_PERFORM"
                      " but password was not being set\n" ));
            NetStatus = LdapMapErrorToWin32( LdapStatus );
            goto Cleanup;

        }

        MachinePassword = *((*(Mods[ModIndex-1])).mod_values);

        //
        // If there are other entries besides the password, retry to add them
        //
        if ( ModIndex > 1 ) {
            Mods[ModIndex-1] = NULL;

            if ( NewAccount ) {
                LdapStatus = ldap_add_s( Ldap, ComputerObjectDn, Mods );
            } else{
                LdapStatus = ldap_modify_s( Ldap, ComputerObjectDn, Mods );
            }

            if ( LdapStatus != LDAP_SUCCESS ) {
                NetStatus = LdapMapErrorToWin32( LdapStatus );
                NetpLog(( "NetpModifyComputerObjectInDs: ldap_modify_s (2) failed: 0x%lx 0x%lx\n",
                          LdapStatus, NetStatus ));
                goto Cleanup;
            }
        }

        //
        // Reset the password
        //

        NetStatus = NetpGetMachineAccountName( ComputerName, &SamAccountName );
        if ( NetStatus != NO_ERROR ) {
            goto Cleanup;
        }

        NetStatus = NetUserGetInfo( DC, SamAccountName, 1, ( PBYTE * )&CurrentUI1 );

        if ( NetStatus == NERR_Success ) {
            CurrentUI1->usri1_password = MachinePassword;

            if ( !FLAG_ON( CurrentUI1->usri1_flags, UF_WORKSTATION_TRUST_ACCOUNT ) ) {
                CurrentUI1->usri1_flags = UF_WORKSTATION_TRUST_ACCOUNT | UF_SCRIPT;
            }

            NetStatus = NetUserSetInfo( DC, SamAccountName, 1, ( PBYTE )CurrentUI1, NULL );

            if ( NetStatus != NERR_Success ) {
                NetpLog(( "NetpModifyComputerObjectInDs: NetUserSetInfo failed on '%ws' for '%ws': 0x%lx."
                          " Deleting the account.\n",
                          DC, SamAccountName, NetStatus ));

            }
        } else {
            NetpLog(( "NetpModifyComputerObjectInDs: NetUserGetInfo failed on '%ws' for '%ws': 0x%lx."
                      " Deleting the account.\n",
                      DC, SamAccountName, NetStatus ));
        }

        //
        // Delete the user if it fails
        //
        if ( NetStatus != NERR_Success )  {
            LdapStatus = ldap_delete_s( Ldap, ComputerObjectDn );
            if ( LdapStatus != LDAP_SUCCESS ) {
                NetpLog(( "NetpModifyComputerObjectInDs: Failed to delete '%ws': 0x%lx 0x%lx\n",
                          ComputerObjectDn, LdapStatus, LdapMapErrorToWin32( LdapStatus ) ));
            }
            goto Cleanup;
        }

    } else if ( LdapStatus != LDAP_SUCCESS ) {

        //
        // Return the error code the user understands
        //
        if ( LdapStatus == LDAP_ALREADY_EXISTS ) {
            NetStatus = NERR_UserExists;
        } else {
            NetStatus = LdapMapErrorToWin32( LdapStatus );
        }
        NetpLog(( "NetpModifyComputerObjectInDs: ldap_modify_s (1) failed: 0x%lx 0x%lx\n",
                  LdapStatus, NetStatus ));
        goto Cleanup;
    }

    //
    // Toggle the account type property. See comment in
    // NetpSetMachineAccountPasswordAndTypeEx() for an
    // explanation of why this is needed. (Search for USN).
    //

    Mods[0] = NULL;
    for ( Index = 0; Index < NumberOfAttributes; Index++ ) {
        if ( _wcsicmp( ModList[Index].mod_type, NETSETUPP_USERACCOUNTCONTROL ) == 0 ) {
            Mods[0] = &ModList[Index];

            //
            // If this is a single valued attribute, we need to
            //  replace (not add) its value since it already exists in the DS
            //
            if ( (Attrib[Index].AttribFlags & NETSETUPP_MULTIVAL_ATTRIB) == 0 ) {
                ModList[Index].mod_op = LDAP_MOD_REPLACE;
            }
            break;
        }
    }
    Mods[1] = NULL;

    if ( Mods[0] != NULL ) {

        //
        // Disable the account
        //
        *(Mods[0]->mod_values) = NETSETUPP_ACCNT_TYPE_DISABLED;
        LdapStatus = ldap_modify_s( Ldap, ComputerObjectDn, Mods );
        if ( LdapStatus != LDAP_SUCCESS ) {
            NetStatus = LdapMapErrorToWin32( LdapStatus );
            NetpLog(( "NetpModifyComputerObjectInDs: set UserAccountControl (1) on '%ws' failed: 0x%lx 0x%lx\n",
                      ComputerObjectDn, LdapStatus, NetStatus ));
            goto Cleanup;
        }

        //
        // Re-enable the account
        //
        *(Mods[0]->mod_values) = NETSETUPP_ACCNT_TYPE_ENABLED;
        LdapStatus = ldap_modify_s( Ldap, ComputerObjectDn, Mods );
        if ( LdapStatus != LDAP_SUCCESS ) {
            NetStatus = LdapMapErrorToWin32( LdapStatus );
            NetpLog(( "NetpModifyComputerObjectInDs: set UserAccountControl (2) on '%ws' failed: 0x%lx 0x%lx\n",
                      ComputerObjectDn, LdapStatus, NetStatus ));
            goto Cleanup;
        }

        NetpLog(( "NetpModifyComputerObjectInDs: Toggled UserAccountControl successfully\n" ));
    }


    //
    // If we've made up to this point, it's success!
    //

    NetStatus = NERR_Success;

    //
    // REVIEW: On error, consider using ldap_get_option to retrieve
    // a human readable string describing the error that happend.
    // Use LDAP_OPT_SERVER_ERROR as the option value. Return the
    // string to the caller who may want to expose it to the user.
    //

Cleanup:

    if ( AttribTypesList != NULL ) {
        NetApiBufferFree( AttribTypesList );
    }

    if ( ModList != NULL ) {
        NetApiBufferFree( ModList );
    }

    if ( Mods != NULL ) {
        NetApiBufferFree( Mods );
    }

    if ( Message != NULL ) {
        ldap_msgfree( Message );
    }

    if ( SamAccountName != NULL ) {
        NetApiBufferFree( SamAccountName );
    }

    if ( CurrentUI1 != NULL ) {
        NetApiBufferFree( CurrentUI1 );
    }

    return NetStatus;
}

NET_API_STATUS
NET_API_FUNCTION
NetpCreateComputerObjectInDs(
    IN PDOMAIN_CONTROLLER_INFO DcInfo,
    IN LPWSTR Account OPTIONAL,
    IN LPWSTR Password OPTIONAL,
    IN LPWSTR ComputerName,
    IN LPWSTR MachinePassword OPTIONAL,
    IN LPWSTR DnsHostName OPTIONAL,
    IN LPWSTR OU OPTIONAL
    )
/*++

Routine Description:

    Create a computer account in the specified OU.

Arguments:

    DcInfo          -- Domain controller on which to create the object
    Account         -- Account to use for the LDAP and DS binds.
                         If NULL, the default creds of the current user
                         context are used.
    Password        -- Password to used for the binds. Ignored if
                         Account is NULL.
    ComputerName    -- (Netbios) Name of the computer being joined
    MachinePassword -- Password to set on the machine object
    DnsHostName     -- DNS host name of the computer being joined
    OU              -- OU under which to create the object.
                       The name must be a fully qualified name
                       e.g.: "ou=test,dc=ntdev,dc=microsoft,dc=com"

Returns:

    NERR_Success -- Success

--*/
{
    NET_API_STATUS NetStatus;
    PLDAP Ldap = NULL;
    PWSTR ComputerObjectDn = NULL;
    PWSTR SamAccountName = NULL;
    PWSTR DnsSpn = NULL;
    PWSTR NetbiosSpn = NULL;
    ULONG AttribCount;

    PWSTR ClassValues[ 2 ];
    PWSTR AccntNameValues[ 2 ];
    PWSTR DnsHostNameValues[ 2 ];
    PWSTR SpnValues[ 3 ];
    PWSTR PasswordValues[ 2 ];
    PWSTR AccntTypeValues[ 2 ];
    NETSETUPP_MACH_ACC_ATTRIBUTE Attributes[NETSETUPP_COMP_OBJ_ATTR_COUNT];

    USER_INFO_1 *CurrentUI1 = NULL;

    //
    // Validate parameters
    //

    if ( DcInfo == NULL ) {
        NetpLog(( "NetpCreateComputerObjectInDs: No DcInfo passed\n" ));
        NetStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if ( ComputerName == NULL ) {
        NetpLog(( "NetpCreateComputerObjectInDs: No ComputerName passed\n" ));
        NetStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Verify that the DC runs DS
    //

    if ( (DcInfo->Flags & DS_DS_FLAG) == 0 ||
         (DcInfo->Flags & DS_WRITABLE_FLAG) == 0 ) {
        NetpLog(( "NetpCreateComputerObjectInDs: DC passed '%ws' doesn't have writable DS 0x%lx\n",
                  DcInfo->DomainControllerName,
                  DcInfo->Flags ));
        NetStatus = ERROR_NOT_SUPPORTED;
        goto Cleanup;
    }

    //
    // First, try to bind to the server
    //

    NetStatus = NetpLdapBind( DcInfo->DomainControllerName, Account, Password, &Ldap );

    if ( NetStatus != NO_ERROR ) {
        NetpLog(( "NetpCreateComputerObjectInDs: NetpLdapBind failed: 0x%lx\n", NetStatus ));
        goto Cleanup;
    }

    //
    // Next get the computer object DN
    //

    NetStatus = NetpGetComputerObjectDn( DcInfo,
                                         Account,
                                         Password,
                                         Ldap,
                                         ComputerName,
                                         OU,
                                         &ComputerObjectDn );

    if ( NetStatus != NO_ERROR ) {
        NetpLog(( "NetpCreateComputerObjectInDs: NetpGetComputerObjectDn failed: 0x%lx\n", NetStatus ));

        //
        // Return meaningful error
        //
        if ( NetStatus == ERROR_FILE_EXISTS ) {
            NetStatus = NERR_UserExists;
        }
        goto Cleanup;
    }

    //
    // Get SAM account name
    //

    NetStatus = NetpGetMachineAccountName( ComputerName, &SamAccountName );
    if ( NetStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Build SPN values
    //

    if ( DnsHostName != NULL ) {
        DnsSpn = LocalAlloc( 0, (wcslen(NETSETUPP_HOST_SPN_PREFIX) + wcslen(DnsHostName) + 1) * sizeof(WCHAR) );
        if ( DnsSpn == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
        swprintf( DnsSpn, L"%ws%ws", NETSETUPP_HOST_SPN_PREFIX, DnsHostName );

        NetbiosSpn = LocalAlloc( 0, (wcslen(NETSETUPP_HOST_SPN_PREFIX) + wcslen(ComputerName) + 1) * sizeof(WCHAR) );
        if ( Netbios == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }
        swprintf( NetbiosSpn, L"%ws%ws", NETSETUPP_HOST_SPN_PREFIX, ComputerName );
    }

    //
    // Prepare the list of attributes that need to be set in the DS
    //
    // Always keep unicodePwd as the last entry because this order is
    // assumed by the API called below.
    //

    AttribCount = 0;

    Attributes[AttribCount].AttribType   = NETSETUPP_OBJECTCLASS;              //
    Attributes[AttribCount].AttribFlags  = NETSETUPP_MULTIVAL_ATTRIB;          //
    Attributes[AttribCount].AttribValues = ClassValues;                        // ObjectClass
    ClassValues[ 0 ] = NETSETUPP_COMPUTER_OBJECT;                              //
    ClassValues[ 1 ] = NULL;                                                   //

    AttribCount ++;

    Attributes[AttribCount].AttribType   = NETSETUPP_SAMACCOUNTNAME;           //
    Attributes[AttribCount].AttribFlags  = 0;                                  //
    Attributes[AttribCount].AttribValues = AccntNameValues;                    // SamAccountName
    AccntNameValues[ 0 ] = SamAccountName;                                     //
    AccntNameValues[ 1 ] = NULL;                                               //

    AttribCount ++;

    Attributes[AttribCount].AttribType   = NETSETUPP_USERACCOUNTCONTROL;       //
    Attributes[AttribCount].AttribFlags  = 0;                                  //
    Attributes[AttribCount].AttribValues = AccntTypeValues;                    // userAccountControl
    AccntTypeValues[ 0 ] = NETSETUPP_ACCNT_TYPE_ENABLED;                       //
    AccntTypeValues[ 1 ] = NULL;                                               //

    AttribCount ++;

    if ( DnsHostName != NULL ) {
        Attributes[AttribCount].AttribType   = NETSETUPP_DNSHOSTNAME;          //
        Attributes[AttribCount].AttribFlags  = 0;                              //
        Attributes[AttribCount].AttribValues = DnsHostNameValues;              // DnsHostName
        DnsHostNameValues[ 0 ] = DnsHostName;                                  //
        DnsHostNameValues[ 1 ] = NULL;                                         //

        AttribCount ++;

        Attributes[AttribCount].AttribType   = NETSETUPP_SERVICEPRINCIPALNAME; //
        Attributes[AttribCount].AttribFlags  = NETSETUPP_MULTIVAL_ATTRIB;      //
        Attributes[AttribCount].AttribValues = SpnValues;                      // ServicePrincipalName
        SpnValues[ 0 ] = DnsSpn;                                               //
        SpnValues[ 1 ] = NetbiosSpn;                                           //
        SpnValues[ 2 ] = NULL;                                                 //

        AttribCount ++;
    }

    //
    // The following attribute is the machine password. We avoid
    // updating it though ldap because it is hard to ensure that
    // the ldap session uses the 128-bit encryption required by
    // SAM on the DC for password updates.
    //
    // To enforce the encryption, we would need to set an option
    // LDAP_OPT_ENCRYPT via a ldap_set_option call following ldap_open
    // before calling ldap_bind_s. However, there is no guarantee that
    // the established connection will use 128 bit encryption; it may
    // use 56 bit encryption if either side does not support strong
    // encryption. We could, in principle, find out the resulting encryption
    // strength using some QueryContextAttribute call, but it's just too much
    // trouble. So, we will just create the account without the password and
    // we will then update the password using good old Net/SAM API.
    //
#if 0
    Attributes[AttribCount].AttribType   = NETSETUPP_UNICODEPWD;               //
    Attributes[AttribCount].AttribFlags  = 0;                                  //
    Attributes[AttribCount].AttribValues = PasswordValues;                     // unicodePwd
    PasswordValues[ 0 ] = MachinePassword;                                     //
    PasswordValues[ 1 ] = NULL;                                                //

    AttribCount ++;
#endif

    //
    // Modify the computer object given the list of attributes
    //

    NetStatus = NetpModifyComputerObjectInDs( DcInfo->DomainControllerName,
                                              Ldap,
                                              ComputerName,
                                              ComputerObjectDn,
                                              AttribCount,
                                              Attributes );

    if ( NetStatus != NO_ERROR ) {
        NetpLog(( "NetpCreateComputerObjectInDs: NetpModifyComputerObjectInDs failed: 0x%lx\n", NetStatus ));
        goto Cleanup;
    }

    //
    // Now set the password using good old Net/SAM API.
    //  First get the current account info.
    //

    NetStatus = NetUserGetInfo( DcInfo->DomainControllerName,
                                SamAccountName,
                                1,
                                ( PBYTE * )&CurrentUI1 );

    //
    // Update the password and reset it
    //

    if ( NetStatus == NO_ERROR ) {
        CurrentUI1->usri1_password = MachinePassword;

        if ( !FLAG_ON( CurrentUI1->usri1_flags, UF_WORKSTATION_TRUST_ACCOUNT ) ) {
            CurrentUI1->usri1_flags = UF_WORKSTATION_TRUST_ACCOUNT | UF_SCRIPT;
        }

        NetStatus = NetUserSetInfo( DcInfo->DomainControllerName,
                                    SamAccountName,
                                    1,
                                    ( PBYTE )CurrentUI1,
                                    NULL );

        if ( NetStatus != NERR_Success ) {
            NetpLog(( "NetpCreateComputerObjectInDs: NetUserSetInfo failed on '%ws' for '%ws': 0x%lx."
                      " Deleting the account.\n",
                      DcInfo->DomainControllerName,
                      SamAccountName,
                      NetStatus ));
        }

    } else {
        NetpLog(( "NetpCreateComputerObjectInDs: NetUserGetInfo failed on '%ws' for '%ws': 0x%lx."
                  " Deleting the account.\n",
                  DcInfo->DomainControllerName,
                  SamAccountName,
                  NetStatus ));
    }

    //
    // Delete the account if we couldn't set the password.
    // Ignore the failure if we cannot delete the account for some reason.
    //

    if ( NetStatus != NO_ERROR ) {
        ULONG LdapStatus;

        LdapStatus = ldap_delete_s( Ldap, ComputerObjectDn );

        if ( LdapStatus != LDAP_SUCCESS ) {
            NetpLog(( "NetpCreateComputerObjectInDs: Failed to delete '%ws': 0x%lx 0x%lx\n",
                      ComputerObjectDn, LdapStatus, LdapMapErrorToWin32( LdapStatus ) ));
        }
    }

    //
    // Tell Netlogon that it should avoid setting
    //  DnsHostName and SPN until the reboot
    //

    if ( NetStatus == NO_ERROR && DnsHostName != NULL ) {
        NetpAvoidNetlogonSpnSet( TRUE );
    }

Cleanup:

    if ( Ldap != NULL ) {
        NetpLdapUnbind( Ldap );
    }

    if ( ComputerObjectDn != NULL ) {
        NetApiBufferFree( ComputerObjectDn );
    }

    if ( SamAccountName != NULL ) {
        NetApiBufferFree( SamAccountName );
    }

    if ( DnsSpn != NULL ) {
        LocalFree( DnsSpn );
    }

    if ( NetbiosSpn != NULL ) {
        LocalFree( NetbiosSpn );
    }

    if ( CurrentUI1 != NULL ) {
        NetApiBufferFree( CurrentUI1 );
    }

    return NetStatus;
}

NET_API_STATUS
NET_API_FUNCTION
NetpSetDnsHostNameAndSpn(
    IN PDOMAIN_CONTROLLER_INFO DcInfo,
    IN LPWSTR Account,
    IN LPWSTR Password,
    IN LPWSTR ComputerName,
    IN LPWSTR DnsHostName
    )
/*++

Routine Description:

    Set DnsHostName and HOST SPN (ServicePrincipalName) attributes on the
    computer object in the DS.

Arguments:

    DcInfo          -- Domain controller on which to create the object
    Account         -- Account to use for the LDAP bind
    Password        -- Password to used for the bind
    ComputerName    -- Name of the computer being joined
    DnsHostName     -- DNS host name of the machine

Returns:

    NERR_Success -- Success

--*/
{
    NET_API_STATUS NetStatus;
    HANDLE hToken = NULL;
    PLDAP Ldap = NULL;
    PWSTR ComputerObjectDn = NULL;

    PWSTR DnsHostNameValues[ 2 ];
    PWSTR SpnValues[ 3 ] = {NULL};

    NETSETUPP_MACH_ACC_ATTRIBUTE Attributes[ 2 ];


    //
    // REVIEW:  Kerberos has a bug such that if this server is joined remotely
    //  and the impersonated client connected to this server using NTLM (as is
    //  the case if this server is not a member of a domain before the join),
    //  explicit credentials supplied to ldap_bind or DsBindWithCredW will not
    //  work (AcquireCredentialsHandle call will fail). To get around this, we
    //  temporarily un-impersonates, bind to the DC, and then impersonate again
    //  at the end of this routine.
    //

    if ( OpenThreadToken( GetCurrentThread(),
                          TOKEN_IMPERSONATE,
                          TRUE,
                          &hToken ) ) {

        if ( RevertToSelf() == 0 ) {
            NetpLog(( "NetpSetDnsHostNameAndSpn: RevertToSelf failed: 0x%lx\n",
                      GetLastError() ));
        }

    } else {
        NetpLog(( "NetpSetDnsHostNameAndSpn: OpenThreadToken failed: 0x%lx\n",
                  GetLastError() ));
    }

    //
    // Bind to the DC
    //

    NetStatus = NetpLdapBind( DcInfo->DomainControllerName, Account, Password, &Ldap );

    if ( NetStatus != NO_ERROR ) {
        NetpLog(( "NetpSetDnsHostNameAndSpn: NetpLdapBind failed: 0x%lx\n", NetStatus ));
        goto Cleanup;
    }

    //
    // Next get the computer object DN
    //

    NetStatus = NetpGetComputerObjectDn( DcInfo,
                                         Account,
                                         Password,
                                         Ldap,
                                         ComputerName,
                                         NULL,  // Default computer container
                                         &ComputerObjectDn );

    if ( NetStatus != NO_ERROR ) {
        NetpLog(( "NetpSetDnsHostNameAndSpn: NetpGetComputerObjectDn failed: 0x%lx\n", NetStatus ));

        //
        // Return meaningful error
        //
        if ( NetStatus == ERROR_FILE_EXISTS ) {
            NetStatus = NERR_UserExists;
        }
        goto Cleanup;
    }

    //
    // Build DnsHostName values
    //

    DnsHostNameValues[ 0 ] = DnsHostName;
    DnsHostNameValues[ 1 ] = NULL;

    //
    // Build SPN values
    //

    SpnValues[0] = LocalAlloc( 0,
                    (wcslen(NETSETUPP_HOST_SPN_PREFIX) + wcslen(DnsHostName) + 1) * sizeof(WCHAR) );
    if ( SpnValues[0] == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    swprintf( SpnValues[0], L"%ws%ws", NETSETUPP_HOST_SPN_PREFIX, DnsHostName );

    SpnValues[1] = LocalAlloc( 0,
                    (wcslen(NETSETUPP_HOST_SPN_PREFIX) + wcslen(ComputerName) + 1) * sizeof(WCHAR) );
    if ( SpnValues[1] == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }
    swprintf( SpnValues[1], L"%ws%ws", NETSETUPP_HOST_SPN_PREFIX, ComputerName );

    SpnValues[2] = NULL;

    //
    // Prepare the list of attributes that need to be set in the DS
    //

    Attributes[0].AttribType   = NETSETUPP_DNSHOSTNAME;          //
    Attributes[0].AttribFlags  = 0;                              // DnsHostName
    Attributes[0].AttribValues = DnsHostNameValues;              //

    Attributes[1].AttribType   = NETSETUPP_SERVICEPRINCIPALNAME; //
    Attributes[1].AttribFlags  = NETSETUPP_MULTIVAL_ATTRIB;      // ServicePrincipalName
    Attributes[1].AttribValues = SpnValues;                      //

    //
    // Modify the computer object given the list of attributes
    //

    NetStatus = NetpModifyComputerObjectInDs( DcInfo->DomainControllerName,
                                              Ldap,
                                              ComputerName,
                                              ComputerObjectDn,
                                              2,
                                              Attributes );

    //
    // Tell Netlogon that it should avoid setting
    //  DnsHostName and SPN until the reboot
    //

    if ( NetStatus == NO_ERROR ) {
        NetpAvoidNetlogonSpnSet( TRUE );
    }

Cleanup:

    if ( Ldap != NULL ) {
        NetpLdapUnbind( Ldap );
    }

    //
    // REVIEW: Revert the impersonation
    //

    if ( hToken != NULL ) {
        if ( SetThreadToken( NULL, hToken ) == 0 ) {
            NetpLog(( "NetpSetDnsHostNameAndSpn: SetThreadToken failed: 0x%lx\n",
                      GetLastError() ));
        }
        CloseHandle( hToken );
    }

    //
    // Free locally allocated memory
    //

    if ( ComputerObjectDn != NULL ) {
        NetApiBufferFree( ComputerObjectDn );
    }

    if ( SpnValues[0] != NULL ) {
        LocalFree( SpnValues[0] );
    }

    if ( SpnValues[1] != NULL ) {
        LocalFree( SpnValues[1] );
    }

    return NetStatus;
}

NET_API_STATUS
NET_API_FUNCTION
NetpCreateComputerObjectInOU(
    IN LPWSTR DC,
    IN LPWSTR OU,
    IN LPWSTR ComputerName,
    IN LPWSTR Account,
    IN LPWSTR Password,
    IN LPWSTR MachinePassword
    )
/*++

Routine Description:

    Create a computer account in the specified OU.

Arguments:

    DC              -- Domain controller on which to create the object
    OU              -- OU under which to create the object.
                       The name must be a fully qualified name
                       e.g.: "ou=test,dc=ntdev,dc=microsoft,dc=com"
    ComputerName    -- Name of the computer being joined
    Account         -- Account to use for the LDAP bind
    Password        -- Password to used for the bind
    MachinePassword -- Password to set on the machine object

Returns:

    NERR_Success -- Success

--*/
{
    NET_API_STATUS NetStatus = NERR_Success;
    ULONG LdapStatus;
    PWSTR ObjectName = NULL, SamAccountName = NULL;
    PLDAP Ldap = NULL;
    PWSTR ClassValues[ 2 ];
    PWSTR AccntNameValues[ 2 ];
    PWSTR PasswordValues[ 2 ];
    PWSTR AccntTypeValues[ 2 ];

    PWSTR AttribTypes[NETSETUPP_COMP_OBJ_ATTR_COUNT];
    ULONG AttribFlags[NETSETUPP_COMP_OBJ_ATTR_COUNT];
    PWSTR *AttribValues[NETSETUPP_COMP_OBJ_ATTR_COUNT];
    LDAPMod ModList[NETSETUPP_COMP_OBJ_ATTR_COUNT];
    PLDAPMod Mods[NETSETUPP_COMP_OBJ_ATTR_COUNT + 1];
    LDAPMessage *Message = NULL, *Entry;
    USER_INFO_1 *CurrentUI1;
    ULONG Index;
    ULONG ModIndex = 0;
    BOOL NewAccount = FALSE;


    //
    // First, try to bind to the server
    //

    NetStatus = NetpLdapBind( DC, Account, Password, &Ldap );

    if ( NetStatus != NO_ERROR ) {
        NetpLog(( "NetpCreateComputerObjectInOU: NetpLdapBind failed: 0x%lx\n", NetStatus ));
        goto Cleanup;
    }

    //
    // Next verify that the OU exists
    //

    LdapStatus = ldap_compare_s( Ldap,
                                 OU,
                                 NETSETUPP_OBJECTCLASS,
                                 NETSETUPP_ORGANIZATIONALUNIT );

    if ( LdapStatus == LDAP_COMPARE_FALSE ) {
        NetStatus = ERROR_FILE_NOT_FOUND;
        NetpLog(( "NetpCreateComputerObjectInOU: Specified path '%ws' is not an OU\n", OU ));
        goto Cleanup;
    } else if ( LdapStatus != LDAP_COMPARE_TRUE ) {
        NetStatus = LdapMapErrorToWin32( LdapStatus );
        NetpLog(( "NetpCreateComputerObjectInOU: ldap_compare_s failed: 0x%lx 0x%lx\n",
                  LdapStatus, NetStatus ));
        goto Cleanup;
    }

    //
    // Allocate the object name
    //

    NetStatus = NetApiBufferAllocate(
                 sizeof( NETSETUPP_OBJ_PREFIX ) + ( wcslen( OU ) + wcslen( ComputerName ) + 1 ) * sizeof( WCHAR ),
                 ( PVOID * ) &ObjectName );

    if ( NetStatus != NO_ERROR ) {
        goto Cleanup;
    }

    swprintf( ObjectName, L"%ws%ws,%ws", NETSETUPP_OBJ_PREFIX, ComputerName, OU );
    NetStatus = NetpGetMachineAccountName(ComputerName, &SamAccountName);

    if ( NetStatus != NO_ERROR ) {
        goto Cleanup;
    }

    //
    // Build attribute values. Always keep unicodePwd as the last entry
    // because this order is assumed by the fail-over code below.
    //

    AttribTypes[ 0 ]  = NETSETUPP_OBJECTCLASS;            //
    AttribFlags[ 0 ]  = NETSETUPP_MULTIVAL_ATTRIB;        //
    AttribValues[ 0 ] = ClassValues;                      // ObjectClass
    ClassValues[ 0 ] = NETSETUPP_COMPUTER_OBJECT;         //
    ClassValues[ 1 ] = NULL;                              //

    AttribTypes[ 1 ]  = NETSETUPP_SAMACCOUNTNAME;         //
    AttribFlags[ 1 ]  = 0;                                //
    AttribValues[ 1 ] = AccntNameValues;                  // SamAccountName
    AccntNameValues[ 0 ] = SamAccountName;                //
    AccntNameValues[ 1 ] = NULL;                          //

    AttribTypes[ 2 ]  = NETSETUPP_USERACCOUNTCONTROL;     //
    AttribFlags[ 2 ]  = 0;                                //
    AttribValues[ 2 ] = AccntTypeValues;                  // userAccountControl
    AccntTypeValues[ 0 ] = NETSETUPP_ACCNT_TYPE_ENABLED;  //
    AccntTypeValues[ 1 ] = NULL;                          //

    AttribTypes[ 3 ]  = NETSETUPP_UNICODEPWD;             //
    AttribFlags[ 3 ]  = 0;                                //
    AttribValues[ 3 ] = PasswordValues;                   // unicodePwd
    PasswordValues[ 0 ] = MachinePassword;                //
    PasswordValues[ 1 ] = NULL;                           //

    //
    // Build modification list given the list of attributes
    //

    NetpLog(( "NetpCreateComputerObjectInOU: Initial attribute values:\n" ));
    for ( Index = 0; Index < NETSETUPP_COMP_OBJ_ATTR_COUNT; Index++ ) {
        ModList[Index].mod_op     = LDAP_MOD_ADD;  // Set to add. We may adjust this below.
        ModList[Index].mod_type   = AttribTypes[Index];
        ModList[Index].mod_values = AttribValues[Index];

        //
        // Be verbose - output all values of each attribute
        //
        NetpLog(( "\t\t%ws  =", AttribTypes[Index] ));

        //
        // Don't leak sensitive info!
        //
        if ( _wcsicmp( AttribTypes[Index], NETSETUPP_UNICODEPWD ) == 0 ) {
            NetpLog(( "  <SomePassword>" ));
        } else {
            ULONG ValIndex;

            for ( ValIndex = 0; AttribValues[Index][ValIndex] != NULL; ValIndex++ ) {
                NetpLog(( "  %ws", AttribValues[Index][ValIndex] ));
            }
        }
        NetpLog(( "\n" ));
    }

    //
    // Now check which attribute values are already set in the DS
    //

    LdapStatus = ldap_search_s( Ldap,
                                ObjectName,
                                LDAP_SCOPE_BASE,
                                NULL,
                                AttribTypes,
                                0,
                                &Message );

    //
    // If the computer object does not exist,
    //  we need to add all attributes
    //

    if ( LdapStatus == LDAP_NO_SUCH_OBJECT ) {
        NetpLog(( "NetpCreateComputerObjectInOU: Computer Object does not exist in OU\n" ));
        NewAccount = TRUE;

        for ( ModIndex = 0; ModIndex < NETSETUPP_COMP_OBJ_ATTR_COUNT; ModIndex++ ) {
            Mods[ModIndex] = &ModList[ModIndex];
        }

        //
        // Terminate the modification list
        //
        Mods[ModIndex] = NULL;

    //
    // Otherwise see which attribute values need modification
    //

    } else if ( LdapStatus == LDAP_SUCCESS ) {
        NetpLog(( "NetpCreateComputerObjectInOU: Computer Object already exists in OU:\n" ));

        //
        // Get the first entry (there should be only one)
        //
        Entry = ldap_first_entry( Ldap, Message );

        //
        // Loop through the attributes and weed out those values
        // which are already set.
        //
        for ( Index = 0; Index < NETSETUPP_COMP_OBJ_ATTR_COUNT; Index++ ) {
            PWSTR *AttribValueRet = NULL;

            //
            // Be verbose - output the values returned for each type
            //
            NetpLog(( "\t\t%ws  =", AttribTypes[Index] ));

            AttribValueRet = ldap_get_values( Ldap, Entry, AttribTypes[Index] );

            if ( AttribValueRet != NULL ) {

                //
                // Don't leak sensitive info!
                //
                if ( _wcsicmp( AttribTypes[Index], NETSETUPP_UNICODEPWD ) == 0 ) {
                    NetpLog(( "  <SomePassword>" ));
                } else {
                    ULONG ValIndex;

                    for ( ValIndex = 0; AttribValueRet[ValIndex] != NULL; ValIndex++ ) {
                        NetpLog(( "  %ws", AttribValueRet[ValIndex] ));
                    }
                }

                //
                // Remove those values from the modification which are alredy set
                //
                NetpRemoveDuplicateStrings( AttribValueRet, AttribValues[Index] );

                ldap_value_free( AttribValueRet );

                //
                // If this is a single valued attribute, we need to
                //  replace (not add) its value since it already exists in the DS
                //
                if ( (AttribFlags[Index] & NETSETUPP_MULTIVAL_ATTRIB) == 0 ) {
                    ModList[Index].mod_op = LDAP_MOD_REPLACE;
                }
            }
            NetpLog(( "\n" ));

            //
            // If there are any attribute values which are
            // not already set, add them to the modification.
            //
            if ( *AttribValues[Index] != NULL ) {
                Mods[ModIndex] = &ModList[Index];
                ModIndex ++;
            }

        }

        //
        // Terminate the modification list
        //
        Mods[ModIndex] = NULL;

    //
    // Otherwise, error out
    //

    } else {
        NetStatus = LdapMapErrorToWin32( LdapStatus );
        NetpLog(( "NetpCreateComputerObjectInOU: ldap_search_s failed: 0x%lx 0x%lx\n",
                  LdapStatus, NetStatus ));
        goto Cleanup;
    }

    //
    // If there are no modifications to do
    //  we are done.
    //

    if ( ModIndex == 0 ) {
        NetpLog(( "NetpCreateComputerObjectInOU: There are _NO_ modifications to do\n" ));
        NetStatus = NERR_Success;
        goto Cleanup;
    }

    //
    // Be verbose - output the attribute values to be set
    //
    NetpLog(( "NetpCreateComputerObjectInOU: Attribute values to set:\n" ));
    for ( Index = 0; Mods[Index] != NULL; Index++ ) {
        NetpLog(( "\t\t%ws  =", (*(Mods[Index])).mod_type ));

        //
        // Don't leak sensitive info!
        //
        if ( _wcsicmp( (*(Mods[Index])).mod_type, NETSETUPP_UNICODEPWD ) == 0 ) {
            NetpLog(( "  <SomePassword>" ));
        } else {
            ULONG ValIndex;

            for ( ValIndex = 0; ((*(Mods[Index])).mod_values)[ValIndex] != NULL; ValIndex++ ) {
                NetpLog(( "  %ws", ((*(Mods[Index])).mod_values)[ValIndex] ));
            }
        }
        NetpLog(( "\n" ));
    }


    //
    // Now, add the missing attributes
    //

    if ( NewAccount ) {
        LdapStatus = ldap_add_s( Ldap, ObjectName, Mods );
    } else {
        LdapStatus = ldap_modify_s( Ldap, ObjectName, Mods );
    }

    //
    // If we tried to create against a server that doesn't support 128 bit encryption,
    // we get LDAP_UNWILLING_TO_PERFORM back from the server. So, we'll create the
    // account again without the password, and then reset it using NetApi.
    //

    if ( LdapStatus == LDAP_UNWILLING_TO_PERFORM ) {

        NetpLog(( "NetpCreateComputerObjectInOU: ldap_modify_s (1) returned"
                  " LDAP_UNWILLING_TO_PERFORM. Trying to recover.\n" ));

        //
        // If we didn't try to set a password, there is no legitimate reason
        // for the add to fail.
        //
        if ( _wcsicmp( (*(Mods[ModIndex-1])).mod_type, NETSETUPP_UNICODEPWD ) != 0 ) {
            NetpLog(( "NetpCreateComputerObjectInOU: ldap_modify_s retuned LDAP_UNWILLING_TO_PERFORM"
                      " but password was not being set\n" ));
            NetStatus = LdapMapErrorToWin32( LdapStatus );
            goto Cleanup;

        }

        //
        // If there are other entries besides the password, retry to add them
        //
        if ( ModIndex > 1 ) {
            Mods[ModIndex-1] = NULL;

            if ( NewAccount ) {
                LdapStatus = ldap_add_s( Ldap, ObjectName, Mods );
            } else{
                LdapStatus = ldap_modify_s( Ldap, ObjectName, Mods );
            }

            if ( LdapStatus != LDAP_SUCCESS ) {
                NetStatus = LdapMapErrorToWin32( LdapStatus );
                NetpLog(( "NetpCreateComputerObjectInOU: ldap_modify_s (2) failed: 0x%lx 0x%lx\n",
                          LdapStatus, NetStatus ));
                goto Cleanup;
            }
        }

        //
        // Reset the password
        //
        NetStatus = NetUserGetInfo( DC, SamAccountName, 1, ( PBYTE * )&CurrentUI1 );

        if ( NetStatus == NERR_Success ) {
            CurrentUI1->usri1_password = MachinePassword;

            if ( !FLAG_ON( CurrentUI1->usri1_flags, UF_WORKSTATION_TRUST_ACCOUNT ) ) {
                CurrentUI1->usri1_flags = UF_WORKSTATION_TRUST_ACCOUNT | UF_SCRIPT;
            }

            NetStatus = NetUserSetInfo( DC, SamAccountName, 1, ( PBYTE )CurrentUI1, NULL );

            if ( NetStatus != NERR_Success ) {
                NetpLog(( "NetpCreateComputerObjectInOU: NetUserSetInfo failed on '%ws' for '%ws': 0x%lx."
                          " Deleting the account.\n",
                          DC, SamAccountName, NetStatus ));

            }
            NetApiBufferFree( CurrentUI1 );

        } else {
            NetpLog(( "NetpCreateComputerObjectInOU: NetUserGetInfo failed on '%ws' for '%ws': 0x%lx.",
                      " Deleting the account.\n",
                      DC, SamAccountName, NetStatus ));
        }

        //
        // Delete the user if it fails
        //
        if ( NetStatus != NERR_Success )  {
            LdapStatus = ldap_delete_s( Ldap, ObjectName );
            if ( LdapStatus != LDAP_SUCCESS ) {
                NetpLog(( "NetpCreateComputerObjectInOU: Failed to delete '%ws': 0x%lx 0x%lx\n",
                          ObjectName, LdapStatus, LdapMapErrorToWin32( LdapStatus ) ));
            }
            goto Cleanup;
        }

    } else if ( LdapStatus != LDAP_SUCCESS ) {
        NetStatus = LdapMapErrorToWin32( LdapStatus );
        NetpLog(( "NetpCreateComputerObjectInOU: ldap_modify_s (1) failed: 0x%lx 0x%lx\n",
                  LdapStatus, NetStatus ));
        goto Cleanup;
    }

    //
    // Toggle the account type property. See comment in
    // NetpSetMachineAccountPasswordAndTypeEx() for an
    // explanation of why this is needed. (Search for USN).
    //

    Mods[0] = NULL;
    for ( Index = 0; Index < NETSETUPP_COMP_OBJ_ATTR_COUNT; Index++ ) {
        if ( _wcsicmp( ModList[Index].mod_type, NETSETUPP_USERACCOUNTCONTROL ) == 0 ) {
            Mods[0] = &ModList[Index];
            break;
        }
    }
    Mods[1] = NULL;

    if ( Mods[0] != NULL ) {

        //
        // Disable the account
        //
        AccntTypeValues[0] = NETSETUPP_ACCNT_TYPE_DISABLED;
        LdapStatus = ldap_modify_s( Ldap, ObjectName, Mods );
        if ( LdapStatus != LDAP_SUCCESS ) {
            NetStatus = LdapMapErrorToWin32( LdapStatus );
            NetpLog(( "NetpCreateComputerObjectInOU: set UserAccountControl (1) on '%ws' failed: 0x%lx 0x%lx\n",
                      ObjectName, LdapStatus, NetStatus ));
            goto Cleanup;
        }

        //
        // Re-enable the account
        //
        AccntTypeValues[0] = NETSETUPP_ACCNT_TYPE_ENABLED;
        LdapStatus = ldap_modify_s( Ldap, ObjectName, Mods );
        if ( LdapStatus != LDAP_SUCCESS ) {
            NetStatus = LdapMapErrorToWin32( LdapStatus );
            NetpLog(( "NetpCreateComputerObjectInOU: set UserAccountControl (2) on '%ws' failed: 0x%lx 0x%lx\n",
                      ObjectName, LdapStatus, NetStatus ));
            goto Cleanup;
        }

    } else {
        NetpLog(( "NetpCreateComputerObjectInOU: UserAccountControl was not in the list\n" ));
    }

    //
    // If we've made up to this point, it's success!
    //

    NetStatus = NERR_Success;

Cleanup:

    if ( Ldap != NULL ) {
        NetpLdapUnbind( Ldap );
    }

    if ( ObjectName != NULL ) {
        NetApiBufferFree( ObjectName );
    }

    if ( SamAccountName != NULL ) {
        NetApiBufferFree( SamAccountName );
    }

    if ( Message != NULL ) {
        ldap_msgfree( Message );
    }

    return( NetStatus );
}

NET_API_STATUS
NET_API_FUNCTION
NetpDeleteComputerObjectInOU(
    IN LPWSTR DC,
    IN LPWSTR OU,
    IN LPWSTR ComputerName,
    IN LPWSTR Account,
    IN LPWSTR Password
    )
/*++

Routine Description:

    This routine will actually create a computer account in the specified OU.

Arguments:

    DC -- Domain controller on which to create the object
    OU -- OU under which to create the object
    ComputerName -- Name of the computer being joined
    Account -- Account to use for the LDAP bind
    Password -- Password to used for the bind

Returns:

    NERR_Success -- Success

--*/
{
    NET_API_STATUS NetStatus = NERR_Success;
    PWSTR ObjectName = NULL, SamAccountName = NULL;
    PLDAP Ldap = NULL;
    ULONG Len;

    Len = wcslen( ComputerName );

    NetStatus = NetApiBufferAllocate( sizeof( NETSETUPP_OBJ_PREFIX ) + ( wcslen( OU ) + Len + 1 ) * sizeof( WCHAR ),
                                      ( PVOID * ) &ObjectName );

    if ( NetStatus == NERR_Success ) {

        swprintf( ObjectName, L"%ws%ws,%ws", NETSETUPP_OBJ_PREFIX, ComputerName, OU );

        NetStatus = NetApiBufferAllocate( ( Len + 2 ) * sizeof( WCHAR ),
                                          ( PVOID * )&SamAccountName );

        if ( NetStatus == NERR_Success ) {

            swprintf( SamAccountName, L"%ws$", ComputerName );
        }

    }


    if ( NetStatus == NERR_Success ) {

        //
        // Try and bind to the server
        //
        NetStatus = NetpLdapBind( DC,
                                  Account,
                                  Password,
                                  &Ldap );

        if ( NetStatus == NERR_Success ) {

            //
            // Now, do the delete..
            //
            NetStatus = LdapMapErrorToWin32( ldap_delete_s( Ldap, ObjectName ) );

            NetpLdapUnbind( Ldap );
        }


    }

    if ( NetStatus != NERR_Success ) {

        NetpLog((  "NetpCreateComputerObjectInOU failed with %lu\n",
                            NetStatus ));

    }

    NetApiBufferFree( ObjectName );
    NetApiBufferFree( SamAccountName );

    if ( NetStatus != NERR_Success ) {

        NetpLog((  "NetpDeleteComputerObjectInOU failed with %lu\n",
                            NetStatus ));

    }

    return( NetStatus );
}


#if defined(REMOTE_BOOT)

NET_API_STATUS
NetpGetRemoteBootMachinePassword(
    OUT LPWSTR Password
    )
/*++

Routine Description:

    Determine if this is a remote boot client, and if so return
    the machine account password.
    This information is obtained via an IOCTL to the redirector.

Arguments:

    Password - returns the password. Should be at least PWLEN WCHARs long.

Return Value:

    NERR_Success if the password is found.
    An error if this is not a remote boot machine.

--*/
{
    NET_API_STATUS NetStatus;
    NTSTATUS Status;

    UNICODE_STRING DeviceName;

    IO_STATUS_BLOCK IoStatusBlock;
    OBJECT_ATTRIBUTES ObjectAttributes;
    HANDLE RedirHandle = NULL;

    UCHAR PacketBuffer[sizeof(ULONG)+64];
    PLMMR_RB_CHECK_FOR_NEW_PASSWORD RequestPacket = (PLMMR_RB_CHECK_FOR_NEW_PASSWORD)PacketBuffer;

    //
    // Open the redirector device.
    //
    RtlInitUnicodeString(&DeviceName, DD_NFS_DEVICE_NAME_U);

    InitializeObjectAttributes(
        &ObjectAttributes,
        &DeviceName,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );

    Status = NtOpenFile(
                   &RedirHandle,
                   SYNCHRONIZE,
                   &ObjectAttributes,
                   &IoStatusBlock,
                   0,
                   0
                   );

    if (NT_SUCCESS(Status)) {
        Status = IoStatusBlock.Status;
    }

    if (!NT_SUCCESS(Status)) {
        NetpLog((  "Could not open redirector device %lx\n",
                            Status ));
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }

    //
    // Send the request to the redir.
    //

    Status = NtFsControlFile(
                    RedirHandle,
                    NULL,
                    NULL,
                    NULL,
                    &IoStatusBlock,
                    FSCTL_LMMR_RB_CHECK_FOR_NEW_PASSWORD,
                    NULL,  // no input buffer
                    0,
                    PacketBuffer,
                    sizeof(PacketBuffer));

    if (NT_SUCCESS(Status)) {
        Status = IoStatusBlock.Status;
    }

    //
    // We expect this to work on a disked machine, since we need the password
    // to join.
    //

    if ( !NT_SUCCESS( Status ) )
    {
        NetpLog((  "Could not open FSCTL_LMMR_RB_CHECK_FOR_NEW_PASSWORD %lx\n",
                            Status ));
        NetStatus = NetpNtStatusToApiStatus( Status );
        goto Cleanup;
    }

    //
    // Copy the result back to the caller's buffer.
    //

    RtlCopyMemory(Password, RequestPacket->Data, RequestPacket->Length);
    Password[RequestPacket->Length / 2] = L'\0';

    NetStatus = NO_ERROR;

Cleanup:
    if ( RedirHandle != NULL ) {
        NtClose( RedirHandle );
    }
    return NetStatus;

}
#endif // REMOTE_BOOT



NET_API_STATUS
NET_API_FUNCTION
NetpSetMachineAccountPasswordAndType(
    IN  LPWSTR lpDcName,
    IN  PSID   DomainSid,
    IN  LPWSTR lpAccountName,
    IN  LPWSTR lpPassword
    )
{
    return( NetpSetMachineAccountPasswordAndTypeEx(
                lpDcName,
                DomainSid,
                lpAccountName,
                lpPassword,
                0,
                TRUE
                ) );
}

NET_API_STATUS
NET_API_FUNCTION
NetpSetMachineAccountPasswordAndTypeEx(
    IN      LPWSTR          lpDcName,
    IN      PSID            DomainSid,
    IN      LPWSTR          lpAccountName,
    IN OUT  OPTIONAL LPWSTR lpPassword,
    IN      OPTIONAL UCHAR  AccountState,
    IN      BOOL            fIsNt4Dc
    )
/*++

Routine Description:

    Due to a few strange reasons, we cannot use the supported, documented Net apis for
    managing the machine account, so we have to use the undocumented Sam apis.  This routine
    will set the password and account type on an account that alread exists.

Arguments:

    lpDcName      - Name of the DC on which the account lives

    DomainSid     - Sid of the domain on which the account lives

    lpAccountName - Name of the account

    lpPassword    - Password to be set on the account.
                    This function gets a strong password to begin with.
                    If the dc refuses to accept this password, this fn
                    can weaken the password by making it shorter.
                    The caller of this function should check if the length
                    of the supplied password was changed.
                    This function should preferably return a BOOL to
                    indicate this.

    AccountState  - if specified, the account will be set to this state.
                    possible values:
                    ACCOUNT_STATE_ENABLED, ACCOUNT_STATE_DISABLED

    fIsNt4Dc      - TRUE if the DC is NT4 or earlier.

Return Value:

    NERR_Success -- Success

--*/
{
    NET_API_STATUS NetStatus=NERR_Success;
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING DcName, AccountName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    SAM_HANDLE SamHandle = NULL, DomainHandle = NULL, AccountHandle = NULL;
    ULONG UserRid;
    PULONG RidList = NULL;
    PSID_NAME_USE NameUseList = NULL;
    PUSER_CONTROL_INFORMATION UserAccountControl = NULL;
    USER_SET_PASSWORD_INFORMATION PasswordInfo;
    ULONG OldUserInfo;
    BOOL fAccountControlModified = FALSE;
    LPWSTR lpSamAccountName=lpAccountName;
    ULONG AccountNameLen=0;

    AccountNameLen = wcslen( lpAccountName );

    //
    // if caller has not passed in sam-account name,
    // generate it from machine name ==> append $ at the end
    //
    if (lpAccountName[AccountNameLen-1] != L'$')
    {
        NetStatus = NetpGetMachineAccountName(lpAccountName,
                                              &lpSamAccountName);

        if (NetStatus != NERR_Success)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto SetPasswordError;
        }
    }


    RtlInitUnicodeString( &DcName, lpDcName );
    RtlZeroMemory( &ObjectAttributes, sizeof( OBJECT_ATTRIBUTES ) );

    Status = SamConnect( &DcName,
                         &SamHandle,
                         SAM_SERVER_CONNECT | SAM_SERVER_LOOKUP_DOMAIN,
                         &ObjectAttributes );

    if ( !NT_SUCCESS( Status ) ) {

        NetpLog(( "SamConnect to %wZ failed with 0x%lx\n", &DcName, Status ));

        goto SetPasswordError;

    }

    //
    // Open the domain
    //
    Status = SamOpenDomain( SamHandle,
                            DOMAIN_LOOKUP,
                            DomainSid,
                            &DomainHandle );


    if ( !NT_SUCCESS( Status ) ) {

#ifdef NETSETUP_VERBOSE_LOGGING

        UNICODE_STRING DisplaySid;
        NTSTATUS Status2;
        RtlZeroMemory( &DisplaySid, sizeof( UNICODE_STRING ) );

        Status2 = RtlConvertSidToUnicodeString( &DisplaySid, DomainSid, TRUE );

        if ( NT_SUCCESS( Status2 ) ) {

            NetpLog(( "SamOpenDomain on %wZ failed with 0x%lx\n",
                      &DisplaySid, Status ));

            RtlFreeUnicodeString(&DisplaySid);

        } else {

            NetpLog(( "SamOpenDomain on <undisplayable sid> failed with 0x%lx\n",
                      Status ));
        }
#endif

        goto SetPasswordError;

    }

    //
    // Get the RID of the user account
    //
    RtlInitUnicodeString( &AccountName, lpSamAccountName );
    Status = SamLookupNamesInDomain( DomainHandle,
                                     1,
                                     &AccountName,
                                     &RidList,
                                     &NameUseList );

    if ( !NT_SUCCESS( Status ) ) {

        NetpLog(( "SamLookupNamesInDomain on %wZ failed with 0x%lx\n",
                  &AccountName, Status ));

        goto SetPasswordError;
    }

    UserRid = RidList[ 0 ];
    SamFreeMemory( RidList );
    SamFreeMemory( NameUseList );

    //
    // Finally, open the user account
    //
    Status = SamOpenUser( DomainHandle,
                          USER_FORCE_PASSWORD_CHANGE | USER_READ_ACCOUNT | USER_WRITE_ACCOUNT,
                          UserRid,
                          &AccountHandle );

    if ( !NT_SUCCESS( Status ) ) {

        Status = SamOpenUser( DomainHandle,
                              USER_FORCE_PASSWORD_CHANGE | USER_READ_ACCOUNT,
                              UserRid,
                              &AccountHandle );

        if ( !NT_SUCCESS( Status ) ) {

            NetpLog((  "SamOpenUser on %lu failed with 0x%lx\n",
                                UserRid,
                                Status ));

            goto SetPasswordError;
        }
    }

    //
    // Now, read the current user account type and see if it needs to be modified
    //
    Status = SamQueryInformationUser( AccountHandle,
                                      UserControlInformation,
                                      ( PVOID * )&UserAccountControl );
    if ( !NT_SUCCESS( Status ) ) {

        NetpLog(( "SamQueryInformationUser for UserControlInformation "
                  "failed with 0x%lx\n", Status ));

        goto SetPasswordError;
    }

    OldUserInfo = UserAccountControl->UserAccountControl;

    if ( !FLAG_ON( UserAccountControl->UserAccountControl, USER_WORKSTATION_TRUST_ACCOUNT ) ) {

        fAccountControlModified = TRUE;
        UserAccountControl->UserAccountControl |= USER_WORKSTATION_TRUST_ACCOUNT;
        UserAccountControl->UserAccountControl &= ~( USER_INTERDOMAIN_TRUST_ACCOUNT |
                                                     USER_SERVER_TRUST_ACCOUNT );

    }

    //
    // Determine if the account control changes. If the account is being enabled,
    // we want to perform the following sequence of operations for NT5: enable, disable,
    // and enable again. This is needed to increase the USN (Universal Sequence
    // Number) of this attribute so that the enabled value will win if the DS
    // replication resolves colliding changes, as the following example shows.
    // Suppose we have two DCs in the domain we join, A abd B. Suppose the account
    // is currently disabled on A (because the user unjoined using that DC),
    // but it is still enabled on B (because the replication hasn't happened yet).
    // Suppose the user performs now joining to the domain.  Then we have discovered
    // B and so we proceed with setting up the changes to the existing account. If
    // we don't toggle the account control attribute, then the USN of this attribute
    // will not change on B (since attribute's value doesn't change) while it was
    // incremented on A as the result of unjoin. At the replication time the data
    // from A will rule and the account will be incorrectly marked as diabled.
    //
    // NOTE:  This design may fail for the case of unjoining a domain that has
    // three (or more) DCs, A, B, and C if the following sequence of operations
    // happens. Suppose that the account is originally enabled on all DCs (state [1]
    // in the bellow diagram). Then the user unjoins using DC A (state [2]). Then the
    // user joins using B where the account is still enabled (state [3]). Then the user
    // unjoins using C where the account is still enabled (state [4]). The final
    // operation is unjoin, so the user expects that his account is disabled. We've
    // assumed here that for some reason no replication was happening when these
    // operations were performed. Then at the replication time the value from B will
    // win (because of the additional toggling performed at the join time). But the
    // account state on B is Enabled, so the final result will be that the account is
    // enabled on all DCs which is not what the user expects.
    //
    //          A               B                                  C
    //       Enabled  [1]    Enabled [1]                        Enabled  [1]
    //       Disabled [2]    Enabled (no-op)+Disabled (1 op)    Disabled [4]
    //                       Enabled [3]
    //

    if ( AccountState != ACCOUNT_STATE_IGNORE ) {

        if ( ( AccountState == ACCOUNT_STATE_ENABLED ) &&
             ( (OldUserInfo & USER_ACCOUNT_DISABLED) || !fIsNt4Dc ) ) {

            fAccountControlModified = TRUE;
            UserAccountControl->UserAccountControl &= ~USER_ACCOUNT_DISABLED;
        }

        if ( ( AccountState == ACCOUNT_STATE_DISABLED ) &&
             !( OldUserInfo & USER_ACCOUNT_DISABLED ) ) {

            fAccountControlModified = TRUE;
            UserAccountControl->UserAccountControl |= USER_ACCOUNT_DISABLED;
        }
    }

    if ( fAccountControlModified == FALSE ) {

        SamFreeMemory( UserAccountControl );
        UserAccountControl = NULL;
    }

    //
    // First, set the account type if required
    //
    if ( UserAccountControl ) {

        Status = SamSetInformationUser( AccountHandle,
                                        UserControlInformation,
                                        ( PVOID )UserAccountControl );
        if ( !NT_SUCCESS( Status ) ) {

            NetpLog(( "SamSetInformationUser for UserControlInformation "
                      "failed with 0x%lx\n", Status ));

            goto SetPasswordError;

        //
        // If we are enabling the account, disable and re-enable it to
        // make the two additional account state toggles.
        //
        } else if ( AccountState == ACCOUNT_STATE_ENABLED ) {

            UserAccountControl->UserAccountControl |= USER_ACCOUNT_DISABLED;
            Status = SamSetInformationUser( AccountHandle,
                                            UserControlInformation,
                                            ( PVOID )UserAccountControl );
            if ( !NT_SUCCESS(Status) ) {
                NetpLog(( "SamSetInformationUser (second) for UserControlInformation "
                          "failed with 0x%lx\n", Status ));
                goto SetPasswordError;
            }

            UserAccountControl->UserAccountControl &= ~USER_ACCOUNT_DISABLED;
            Status = SamSetInformationUser( AccountHandle,
                                            UserControlInformation,
                                            ( PVOID )UserAccountControl );
            if ( !NT_SUCCESS(Status) ) {
                NetpLog(( "SamSetInformationUser (third) for UserControlInformation "
                          "failed with 0x%lx\n", Status ));
                goto SetPasswordError;
            }
        }
    }

    //
    // If requested, set the password on the account
    //
    if ( lpPassword != NULL )
    {
        RtlInitUnicodeString( &PasswordInfo.Password, lpPassword );
        PasswordInfo.PasswordExpired = FALSE;

        //
        // Ok, then, set the password on the account
        //
        // The caller has passed in a strong password, try that first
        // NT5 dcs will always accept a strong password.
        //
        Status = SamSetInformationUser( AccountHandle,
                                        UserSetPasswordInformation,
                                        ( PVOID )&PasswordInfo );
        if ( !NT_SUCCESS( Status ) )
        {
            if ( (Status == STATUS_PASSWORD_RESTRICTION) &&
                 !NetpIsDefaultPassword( lpAccountName, lpPassword ))
            {
                NetpLog(( "NetpSetMachineAccountPasswordAndTypeEx: STATUS_PASSWORD_RESTRICTION error setting password. retrying...\n" ));
                //
                // SAM did not accpet a long password, try LM20_PWLEN
                //
                // This is probably because the dc is NT4 dc.
                // NT4 dcs will not accept a password longer than LM20_PWLEN
                //
                lpPassword[LM20_PWLEN] = UNICODE_NULL;
                RtlInitUnicodeString( &PasswordInfo.Password, lpPassword );
                Status = SamSetInformationUser( AccountHandle,
                                                UserSetPasswordInformation,
                                                ( PVOID )&PasswordInfo );
                if ( Status == STATUS_PASSWORD_RESTRICTION )
                {
                    NetpLog(( "NetpSetMachineAccountPasswordAndTypeEx: STATUS_PASSWORD_RESTRICTION error setting password. retrying...\n" ));
                    //
                    // SAM did not accpet a LM20_PWLEN password, try shorter one
                    //
                    // SAM uses RtlUpcaseUnicodeStringToOemString internally.
                    // In this process it is possible that in the worst case,
                    // n unicode char password will get mapped to 2*n dbcs
                    // char password. This will make it exceed LM20_PWLEN.
                    // To guard against this worst case, try a password
                    // with LM20_PWLEN/2 length
                    //
                    // One might say that LM20_PWLEN/2 length password
                    // is not really secure. I agree, but it is definitely
                    // better than the default password which we will have
                    // to fall back to otherwise.
                    //
                    lpPassword[LM20_PWLEN/2] = UNICODE_NULL;
                    RtlInitUnicodeString( &PasswordInfo.Password, lpPassword );
                    Status = SamSetInformationUser( AccountHandle,
                                                    UserSetPasswordInformation,
                                                    ( PVOID )&PasswordInfo );
                    if ( Status == STATUS_PASSWORD_RESTRICTION )
                    {
                        //
                        // SAM did not accpet a short pwd, try default pwd
                        //
                        NetpLog(( "NetpSetMachineAccountPasswordAndTypeEx: STATUS_PASSWORD_RESTRICTION error setting password. retrying...\n" ));

                        NetpGenerateDefaultPassword(lpAccountName, lpPassword);
                        RtlInitUnicodeString( &PasswordInfo.Password, lpPassword );
                        Status = SamSetInformationUser( AccountHandle,
                                                        UserSetPasswordInformation,
                                                        ( PVOID )&PasswordInfo );
                    }
                }
            }

            if ( NT_SUCCESS( Status ) )
            {
                NetpLog(( "NetpGenerateDefaultPassword: successfully set password\n" ));
            }
            else
            {
                NetpLog(( "NetpSetMachineAccountPasswordAndTypeEx: SamSetInformationUser for UserSetPasswordInformation failed: 0x%lx\n", Status ));

                //
                // Make sure we try to restore the account control
                //
                if ( UserAccountControl )
                {
                    NTSTATUS Status2;

                    UserAccountControl->UserAccountControl = OldUserInfo;
                    Status2 = SamSetInformationUser( AccountHandle,
                                                     UserControlInformation,
                                                     ( PVOID )UserAccountControl );
                    if ( !NT_SUCCESS( Status2 ) )
                    {
                        NetpLog(( "SamSetInformationUser for UserControlInformation (RESTORE) failed with 0x%lx\n", Status2 ));
                    }
                }
                goto SetPasswordError;
            }
        }
    }

SetPasswordError:

    if ( lpSamAccountName != lpAccountName )
    {
        NetApiBufferFree( lpSamAccountName );
    }

    if ( AccountHandle ) {

        SamCloseHandle( AccountHandle );
    }

    if ( DomainHandle ) {

        SamCloseHandle( DomainHandle );
    }

    if ( SamHandle ) {

        SamCloseHandle( SamHandle );
    }

    NetStatus = RtlNtStatusToDosError( Status );

    SamFreeMemory( UserAccountControl );

    return( NetStatus );
}


NET_API_STATUS
NET_API_FUNCTION
NetpRemoveDnsRegistrations (
   VOID
   )
/*++

Routine Description:

    This function removes DNS registration entries via an entrypoint defined
    in DHCPCSVC.DLL called DhcpRemoveDNSRegistrations

Return Value:

    NERR_Success -- Success

--*/
{
    HMODULE                     hModule = NULL;
    DNS_REGISTRATION_REMOVAL_FN pfn = NULL;

    hModule = LoadLibraryW( L"dhcpcsvc.dll" );
    if ( hModule != NULL )
    {
        pfn = (DNS_REGISTRATION_REMOVAL_FN)GetProcAddress(
                                              hModule,
                                              "DhcpRemoveDNSRegistrations"
                                              );

        if ( pfn != NULL )
        {
            ( *pfn )();
        }

        FreeLibrary( hModule );
    }

    return( NERR_Success );
}

//
// Helper functions
//
LPWSTR
GetStrPtr(IN LPWSTR szString OPTIONAL)
{
    return szString ? szString : L"(NULL)";
}

NET_API_STATUS
NET_API_FUNCTION
NetpDuplicateString(IN  LPCWSTR szSrc,
                    IN  LONG    cchSrc,
                    OUT LPWSTR* pszDst)
{
    NET_API_STATUS NetStatus;
    if (cchSrc < 0)
    {
        cchSrc = wcslen(szSrc);
    }

    ++cchSrc;

    NetStatus = NetApiBufferAllocate(cchSrc * sizeof( WCHAR ),
                                     pszDst);
    if ( NetStatus == NERR_Success )
    {
        wcsncpy(*pszDst, szSrc, cchSrc);
    }

    return NetStatus;
}

NET_API_STATUS
NET_API_FUNCTION
NetpConcatStrings(IN  LPCWSTR szSrc1,
                  IN  LONG    cchSrc1,
                  IN  LPCWSTR szSrc2,
                  IN  LONG    cchSrc2,
                  OUT LPWSTR* pszDst)
{
    NET_API_STATUS NetStatus;

    if (cchSrc1 < 0)
    {
        cchSrc1 = wcslen(szSrc1);
    }

    if (cchSrc2 < 0)
    {
        cchSrc2 = wcslen(szSrc2);
    }

    NetStatus = NetApiBufferAllocate((cchSrc1 + cchSrc2 + 1) * sizeof( WCHAR ),
                                     pszDst);
    if ( NetStatus == NERR_Success )
    {
        wcsncpy(*pszDst, szSrc1, cchSrc1);
        wcsncpy(*pszDst + cchSrc1, szSrc2, cchSrc2+1);
    }

    return NetStatus;
}

NET_API_STATUS
NET_API_FUNCTION
NetpConcatStrings3(IN  LPCWSTR szSrc1,
                   IN  LONG    cchSrc1,
                   IN  LPCWSTR szSrc2,
                   IN  LONG    cchSrc2,
                   IN  LPCWSTR szSrc3,
                   IN  LONG    cchSrc3,
                   OUT LPWSTR* pszDst)
{
    NET_API_STATUS NetStatus;

    if (cchSrc1 < 0)
    {
        cchSrc1 = wcslen(szSrc1);
    }

    if (cchSrc2 < 0)
    {
        cchSrc2 = wcslen(szSrc2);
    }

    if (cchSrc3 < 0)
    {
        cchSrc3 = wcslen(szSrc3);
    }

    NetStatus = NetApiBufferAllocate((cchSrc1 + cchSrc2 + cchSrc3 + 1) *
                                     sizeof( WCHAR ), pszDst);
    if ( NetStatus == NERR_Success )
    {
        wcsncpy(*pszDst, szSrc1, cchSrc1);
        wcsncpy(*pszDst + cchSrc1, szSrc2, cchSrc2);
        wcsncpy(*pszDst + cchSrc1 + cchSrc2, szSrc3, cchSrc3+1);
    }

    return NetStatus;
}

NET_API_STATUS
NET_API_FUNCTION
NetpGetMachineAccountName(
    IN  LPCWSTR  szMachineName,
    OUT LPWSTR*  pszMachineAccountName
    )
/*++

Routine Description:

    Get machine account name from machine name.

Arguments:

    szMachineName         -- name of a computer
    pszMachineAccountName -- receives the name of computer account

Returns:

    NERR_Success -- Success

Notes:

    Caller must free the allocated memory using NetApiBufferFree.

--*/
{
    NET_API_STATUS  NetStatus;
    ULONG ulLen;
    LPWSTR szMachineAccountName;

    ulLen = wcslen(szMachineName);

    NetStatus = NetApiBufferAllocate( (ulLen + 2) * sizeof(WCHAR),
                                      (PBYTE *) &szMachineAccountName );
    if ( NetStatus == NERR_Success )
    {
        wcscpy(szMachineAccountName, szMachineName);
        _wcsupr(szMachineAccountName);
        szMachineAccountName[ulLen] = L'$';
        szMachineAccountName[ulLen+1] = UNICODE_NULL;
        *pszMachineAccountName = szMachineAccountName;
    }

    return NetStatus;
}

NET_API_STATUS
NET_API_FUNCTION
NetpGeneratePassword(
    IN  LPCWSTR szMachine,
    IN  BOOL    fRandomPwdPreferred,
    IN  LPCWSTR szDcName,
    IN  BOOL    fIsNt4Dc,
    OUT LPWSTR  szPassword
    )
/*++

Routine Description:



Arguments:

    szMachine  -- name of a computer

    szPassword -- receives the generated password this buffer must be
                  atleast PWLEN+1 char long.

Returns:

    NERR_Success -- Success

--*/
{
    NET_API_STATUS NetStatus = NERR_Success;
    BOOL fUseDefaultPwd = FALSE;

    // The default password is used if we are joining an NT4 DC
    // that has RefusePasswordChange set. This is determined by
    // remotely reading the appropriate netlogon regval.
    // If the key cannot be read, it is assumed that the value is not set
    //
    if ( fIsNt4Dc )
    {
        //
        // we are joining an NT4 domain, see if RefusePasswordChange is set
        //
        NetStatus = NetpGetNt4RefusePasswordChangeStatus( szDcName,
                                                          &fUseDefaultPwd );
    }

    if ( NetStatus == NERR_Success )
    {
        //
        // if we are explicitly asked to use a default password, generate one
        //
        if ( fUseDefaultPwd )
        {
            NetpGenerateDefaultPassword(szMachine, szPassword);
        }
        //
        // otherwise if the caller prefers a random password, generate one
        //
        else if ( fRandomPwdPreferred )
        {
            NetStatus = NetpGenerateRandomPassword(szPassword);
        }
#if defined(REMOTE_BOOT)
        //
        // If it's a remote boot machine, then this will return the
        // current machine account password, so use that.
        //
        else if (NERR_Success ==
                 NetpGetRemoteBootMachinePassword(szPassword))
        {
            // do nothing since the above already generated the password
        }
#endif
        else
        {
            //
            // if none of the above apply,
            // we end up generating a default password
            //
            NetpGenerateDefaultPassword(szMachine, szPassword);
            NetStatus = NERR_Success;
        }
    }

    return NetStatus;
}


void
NetpGenerateDefaultPassword(
    IN  LPCWSTR szMachine,
    OUT LPWSTR szPassword
    )
/*++

Routine Description:

    Generate the default password from machine name.
    This is simply the first 14 characters of the machine name lower cased.

Arguments:

    szMachine  -- name of a computer
    szPassword -- receives the generated password

Returns:

    NERR_Success -- Success

--*/
{
    wcsncpy( szPassword, szMachine, LM20_PWLEN );
    szPassword[LM20_PWLEN] = UNICODE_NULL;
    _wcslwr( szPassword );
}

BOOL
NetpIsDefaultPassword(
    IN  LPCWSTR szMachine,
    IN  LPWSTR  szPassword
    )
/*++

Routine Description:

    Determine if szPassword is the default password for szMachine

Arguments:

    szMachine  -- name of a computer
    szPassword -- machine password

Returns:

    TRUE if szPassword is the default password,
    FALSE otherwise

--*/
{
    WCHAR szPassword2[LM20_PWLEN+1];

    NetpGenerateDefaultPassword(szMachine, szPassword2);

    return (wcscmp(szPassword, szPassword2) == 0);
}

NET_API_STATUS
NET_API_FUNCTION
NetpGenerateRandomPassword(
    OUT LPWSTR szPassword
    )
{
    NET_API_STATUS  NetStatus=NERR_Success;
    ULONG           Length, i;
    BYTE            n;
    HCRYPTPROV      CryptProvider = 0;
    LPWSTR          szPwd=szPassword;
    BOOL            fStatus;

#define PWD_CHAR_MIN 32   // ' ' space
#define PWD_CHAR_MAX 122  // 'z'

    //
    // there is a reason behind this number
    //
    Length = 120;
    szPassword[Length] = UNICODE_NULL;

    //
    // Generate a random password.
    //
    // the password is made of english printable chars. when w2k client
    // joins NT4 dc. SAM on the dc calls RRtlUpcaseUnicodeStringToOemString
    // the password length will remain unchanged. If we do not do this,
    // the dc returns STATUS_PASSWORD_RESTRICTION and we have to
    // fall back to default password.
    //
    if ( CryptAcquireContext( &CryptProvider, NULL, NULL,
                              PROV_RSA_FULL, CRYPT_VERIFYCONTEXT ) )
    {
        for ( i = 0; i < Length; i++, szPwd++ )
        {
            //
            // the method we use here is not very efficient.
            // This does not matter much in the context of NetJoin apis
            // but it should not be used where perf is a criterion
            //
            while ( ( fStatus = CryptGenRandom( CryptProvider, sizeof(BYTE),
                                                (LPBYTE) &n ) ) &&
                    ( ( n < PWD_CHAR_MIN ) || ( n > PWD_CHAR_MAX ) ) )
            {
                // try till we get a non-zero random number
            }

            if ( fStatus )
            {
                *szPwd = (WCHAR) n;
            }
            else
            {
                NetStatus = GetLastError();
                break;
            }
        }
        CryptReleaseContext( CryptProvider, 0 );
    }
    else
    {
        NetStatus = GetLastError();
    }

    if ( NetStatus != NERR_Success )
    {
        NetpLog((  "NetpGenerateRandomPassword: failed: 0x%lx\n", NetStatus ));
    }

    return NetStatus;
}


NET_API_STATUS
NET_API_FUNCTION
NetpStoreIntialDcRecord(
    IN PDOMAIN_CONTROLLER_INFO   DcInfo
    )
/*++

Routine Description:

    This function will cache the name of the domain controller on which we successfully
    created/modified the machine account, so that the auth packages will know which dc to
    try first

Arguments:

    lpDcName - Name of the DC on which the account was created/modified

    CreateNetlogonStoppedKey - If TRUE, a volatile key will be created
        in the Netlogon registry section.  The presence of this key
        will instruct the client side of DsGetDcName( ) and the MSV1
        package not to wait on netlogon to start.

Return Value:

    NERR_Success -- Success

--*/
{
    NET_API_STATUS NetStatus = NERR_Success;
    HKEY hNetLogon, hJoinKey = NULL;
    ULONG Disp;

    NetStatus = RegOpenKey( HKEY_LOCAL_MACHINE,
                            NETSETUPP_NETLOGON_JD_PATH,
                            &hNetLogon );

    if ( NetStatus == NERR_Success ) {

        NetStatus = RegCreateKeyEx( hNetLogon,
                                    NETSETUPP_NETLOGON_JD,
                                    0,
                                    NULL,
                                    REG_OPTION_NON_VOLATILE,
                                    KEY_WRITE,
                                    NULL,
                                    &hJoinKey,
                                    &Disp );

        //
        // Now, start creating all of the values.  Ignore any failures, and don't write out
        // NULL values
        //
        if ( NetStatus == NERR_Success ) {

            PWSTR String = DcInfo->DomainControllerName;

            //
            // DomainControllerName
            //
            if ( String ) {

                NetStatus = RegSetValueEx( hJoinKey,
                                           NETSETUPP_NETLOGON_JD_DC,
                                           0,
                                           REG_SZ,
                                           ( const PBYTE )String,
                                           ( wcslen( String ) + 1 ) * sizeof( WCHAR ) );
                if ( NetStatus != NERR_Success ) {

                    NetpLog(( "Set of value %ws to %ws failed with %lu\n",
                              NETSETUPP_NETLOGON_JD_DC, String, NetStatus ));
                }
            }


            //
            // DomainControllerAddress
            //
            String = DcInfo->DomainControllerAddress;
            if ( String ) {

                NetStatus = RegSetValueEx( hJoinKey,
                                           NETSETUPP_NETLOGON_JD_DCA,
                                           0,
                                           REG_SZ,
                                           ( const PBYTE )String,
                                           ( wcslen( String ) + 1 ) * sizeof( WCHAR ) );
                if ( NetStatus != NERR_Success ) {

                    NetpLog(( "Set of value %ws to %ws failed with %lu\n",
                              NETSETUPP_NETLOGON_JD_DCA, String, NetStatus ));
                }
            }

            //
            // DomainControllerType
            //
            NetStatus = RegSetValueEx( hJoinKey,
                                       NETSETUPP_NETLOGON_JD_DCAT,
                                       0,
                                       REG_DWORD,
                                       ( const PBYTE )&DcInfo->DomainControllerAddressType,
                                       sizeof( ULONG ) );
            if ( NetStatus != NERR_Success ) {

                NetpLog(( "Set of value %ws to %lu failed with %lu\n",
                          NETSETUPP_NETLOGON_JD_DCAT,
                          DcInfo->DomainControllerAddressType, NetStatus ));

            }

            //
            // DomainControllerType
            //
            NetStatus = RegSetValueEx( hJoinKey,
                                       NETSETUPP_NETLOGON_JD_DG,
                                       0,
                                       REG_BINARY,
                                       ( const PBYTE )&DcInfo->DomainGuid,
                                       sizeof( GUID ) );
            if ( NetStatus != NERR_Success ) {

                NetpLog(( "Set of value %ws failed with %lu\n",
                          NETSETUPP_NETLOGON_JD_DG, NetStatus ));

            }


            //
            // DomainName
            //
            String = DcInfo->DomainName;
            if ( String ) {

                NetStatus = RegSetValueEx( hJoinKey,
                                           NETSETUPP_NETLOGON_JD_DN,
                                           0,
                                           REG_SZ,
                                           ( const PBYTE )String,
                                           ( wcslen( String ) + 1 ) * sizeof( WCHAR ) );
                if ( NetStatus != NERR_Success ) {

                    NetpLog(( "Set of value %ws to %ws failed with %lu\n",
                              NETSETUPP_NETLOGON_JD_DN, String, NetStatus ));

                }
            }

            //
            // DnsForestName
            //
            String = DcInfo->DnsForestName;
            if ( String ) {

                NetStatus = RegSetValueEx( hJoinKey,
                                           NETSETUPP_NETLOGON_JD_DFN,
                                           0,
                                           REG_SZ,
                                           ( const PBYTE )String,
                                           ( wcslen( String ) + 1 ) * sizeof( WCHAR ) );
                if ( NetStatus != NERR_Success ) {

                    NetpLog(( "Set of value %ws to %ws failed with %lu\n",
                              NETSETUPP_NETLOGON_JD_DFN, String, NetStatus ));

                }
            }

            //
            // Flags
            //
            NetStatus = RegSetValueEx( hJoinKey,
                                       NETSETUPP_NETLOGON_JD_F,
                                       0,
                                       REG_DWORD,
                                       ( const PBYTE )&DcInfo->Flags,
                                       sizeof( ULONG ) );
            if ( NetStatus != NERR_Success ) {

                NetpLog(( "Set of value %ws to %lu failed with %lu\n",
                          NETSETUPP_NETLOGON_JD_F, DcInfo->Flags, NetStatus ));

            }

            //
            // DcSiteName
            //
            String = DcInfo->DcSiteName;
            if ( String ) {

                NetStatus = RegSetValueEx( hJoinKey,
                                           NETSETUPP_NETLOGON_JD_DSN,
                                           0,
                                           REG_SZ,
                                           ( const PBYTE )String,
                                           ( wcslen( String ) + 1 ) * sizeof( WCHAR ) );
                if ( NetStatus != NERR_Success ) {

                    NetpLog(( "Set of value %ws to %ws failed with %lu\n",
                              NETSETUPP_NETLOGON_JD_DSN, String, NetStatus ));

                }
            }

            //
            // DcSiteName
            //
            String = DcInfo->ClientSiteName;
            if ( String ) {

                NetStatus = RegSetValueEx( hJoinKey,
                                           NETSETUPP_NETLOGON_JD_CSN,
                                           0,
                                           REG_SZ,
                                           ( const PBYTE )String,
                                           ( wcslen( String ) + 1 ) * sizeof( WCHAR ) );
                if ( NetStatus != NERR_Success ) {

                    NetpLog(( "Set of value %ws to %ws failed with %lu\n",
                              NETSETUPP_NETLOGON_JD_CSN, String, NetStatus ));

                }
            }

            RegCloseKey( hJoinKey );
        }

        RegCloseKey( hNetLogon );

    }

    return( NetStatus );
}

VOID
NetpAvoidNetlogonSpnSet(
    BOOL AvoidSet
    )
/*++

Routine Description:

    This function will write into Netlogon reg key to instruct Netlogon
    not to register DnsHostName and SPNs.  This is needed because
    Netlogon could otherwise set incorrect values based on the old computer
    name.  The registry key that this function writes is volatile so that
    Netlogon will notice it before the reboot but it will not exist after
    the reboot when Netlogon will have the new computer name.

Arguments:

    AvoidSet - If TRUE, this routine will inform netlogon to not write SPNs
        Otherwise, it will delete the reg key which we may have set previously.

Return Value:

    None

--*/
{
    NET_API_STATUS NetStatus = NERR_Success;
    HKEY hNetLogon = NULL;
    HKEY hNetLogonAvoidSpnSet = NULL;
    ULONG Disp;

    NetStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                              NETSETUPP_NETLOGON_JD_PATH,
                              0,
                              KEY_ALL_ACCESS,
                              &hNetLogon );

    if ( NetStatus == NERR_Success ) {

        //
        // If we are to avoid SPN setting by netlogon,
        //  write the appropriate reg key to inform Netlogon accordingly
        //
        if ( AvoidSet ) {
            NetStatus = RegCreateKeyEx( hNetLogon,
                                        NETSETUPP_NETLOGON_AVOID_SPN,
                                        0,
                                        NULL,
                                        REG_OPTION_VOLATILE,
                                        KEY_WRITE,
                                        NULL,
                                        &hNetLogonAvoidSpnSet,
                                        &Disp );

            if ( NetStatus == NERR_Success ) {
                RegCloseKey( hNetLogonAvoidSpnSet );
            }

        //
        // Otherwise, delete the reg key which we may have set previously.
        //
        } else {
            RegDeleteKey( hNetLogon,
                          NETSETUPP_NETLOGON_AVOID_SPN );
        }

        RegCloseKey( hNetLogon );
    }
}

LONG cNetsetupLogRefCount=0;
LONG LogWriterCount=0;
HANDLE hDebugLog = NULL;
BOOL LogFileInitialized = FALSE;
BOOL LogShutdownInProgress = FALSE;
DWORD NetpOpenLogThreadId = 0;

void
NetSetuppOpenLog()
{
    //
    // Increment the ref count atomically
    //

    LONG LocalLogRefCount = InterlockedIncrement( &cNetsetupLogRefCount );

    //
    // If we are the first thread to access the log,
    //  initialize the log and open it
    //

    if ( LocalLogRefCount == 1 ) {

        //
        // It's possible that the log hasn't been
        //  shut down yet by the last thread leaving
        //  the log, so wait until it is.
        //
        while ( LogFileInitialized || LogShutdownInProgress ) {
            Sleep(100);
        }
        NetpInitializeLogFile();

        NetpOpenLogThreadId = GetCurrentThreadId();

        //
        // Now open the log and mark the start of the output
        //
        hDebugLog = NetpOpenDebugFile( L"NetSetup", FALSE );
        LogFileInitialized = TRUE;

        NetpLog(("-----------------------------------------------------------------\n" ));

    //
    // If we are not the first one, it's possible
    //  that the log hasn't been initilized by the
    //  first thread yet, so wait until it is
    //

    } else {
        while ( !LogFileInitialized ) {
            Sleep(100);
        }
    }
}

void
NetSetuppCloseLog()
{
    LONG LocalLogRefCount;

    //
    // We can walk into this routine only if
    //  we previously initialized the log
    //

    ASSERT( cNetsetupLogRefCount > 0 );
    ASSERT( LogFileInitialized == TRUE );

    //
    // Decrement the ref count atomically
    //

    LocalLogRefCount = InterlockedDecrement( &cNetsetupLogRefCount );

    //
    // If we are the last thread to close the log,
    //  shut the log down
    //

    if ( LocalLogRefCount == 0 ) {

        //
        // Inform writers we are shutting the log down
        //
        LogShutdownInProgress = TRUE;

        //
        // Wait until all writers leave the log
        //
        while ( LogWriterCount > 0 ) {
            Sleep(100);
        }

        //
        // Close the log
        //
        NetpCloseDebugFile( hDebugLog );
        hDebugLog = NULL;
        NetpOpenLogThreadId = 0;
        NetpShutdownLogFile();
        LogFileInitialized = FALSE;

        //
        // We are done with log shutdown
        //
        LogShutdownInProgress = FALSE;
    }
}

void
NetpLogPrintHelper(
    IN LPCSTR Format,
    ...)
{
    va_list arglist;

    //
    // Don't go any further if the file isn't ready
    //

    if ( !LogFileInitialized || LogShutdownInProgress ) {
        return;
    }

    //
    // Increment the number of log writers to prevent
    //  the log from shutting down behind our back
    //

    InterlockedIncrement( &LogWriterCount );

    //
    // Now that we have our writer reference,
    //  it's safe to write into the log if
    //  it is ready at this point
    //

    if ( LogFileInitialized && !LogShutdownInProgress ) {
        va_start(arglist, Format);
        NetpLogPrintRoutineVEx(hDebugLog, &NetpOpenLogThreadId, (LPSTR) Format, arglist);
        va_end(arglist);
    }

    //
    // Remove our reference
    //

    InterlockedDecrement( &LogWriterCount );
}

NET_API_STATUS
NET_API_FUNCTION
NetpWaitForNetlogonSc(
    IN LPCWSTR szDomainName
    )
{
    NET_API_STATUS NetStatus = NERR_Success;
    NTSTATUS NlSubStatus=STATUS_SUCCESS;
    LPBYTE pNetlogonInfo=NULL;
    UINT cAttempts=0;
    BOOLEAN fScSetup=FALSE;
    PNETLOGON_INFO_2  pNetlogonInfo2;


#define NL_SC_WAIT_INTERVAL 2000
#define NL_SC_WAIT_NUM_ATTEMPTS 60

    NetpLog(( "NetpWaitForNetlogonSc: waiting for netlogon secure channel setup...\n"));

    while (!fScSetup && (cAttempts < NL_SC_WAIT_NUM_ATTEMPTS))
    {
        cAttempts++;
        NetStatus = I_NetLogonControl2( NULL, NETLOGON_CONTROL_TC_QUERY,
                                        2, (LPBYTE) &szDomainName,
                                        (LPBYTE *) &pNetlogonInfo );
        if (NetStatus == NERR_Success)
        {
            pNetlogonInfo2 = (PNETLOGON_INFO_2) pNetlogonInfo;
            NlSubStatus = pNetlogonInfo2->netlog2_tc_connection_status;
            fScSetup = NlSubStatus == NERR_Success;
            NetApiBufferFree(pNetlogonInfo);
        }

        if (!fScSetup)
        {
            Sleep(NL_SC_WAIT_INTERVAL);
        }
    }

    NetpLog(( "NetpWaitForNetlogonSc: status: 0x%lx, sub-status: 0x%lx\n",
              NetStatus, NlSubStatus));

    return NetStatus;

}


NET_API_STATUS
NET_API_FUNCTION
NetpDsSetSPN2(
    IN LPCWSTR szComputerName,
    IN LPCWSTR szDnsDomainName,
    IN LPCWSTR szUncDcName,
    IN LPCWSTR szUser,
    IN LPCWSTR szUserPassword
    )
/*++

Routine Description:

Arguments:


Return Value:

    ignored - this is a thread pool worker function.

--*/
{
    DWORD NetStatus=NERR_Success;
    ULONG LdapStatus;

    LPWSTR Spn = NULL;
    LPWSTR SpnNetbios = NULL;
    LPWSTR SamName = NULL;
    LPWSTR SamAccountName = NULL;

    HANDLE hDs = NULL;
    LDAP *hLdap = NULL;
    PDS_NAME_RESULTW CrackedName = NULL;
    LPWSTR DnOfAccount;

    LONG LdapOption;

    LPWSTR DnsHostName = NULL;
    LPWSTR DnsHostNameValues[2];
    LDAPModW DnsHostNameAttr;
    LDAPModW *Mods[2];
    RPC_AUTH_IDENTITY_HANDLE AuthId = 0;

    WCHAR szComputerNetbiosName[MAX_COMPUTERNAME_LENGTH+1];
    LPWSTR szUserName=NULL;
    LPWSTR szDomainName=NULL;
    LPWSTR szNetbiosDomainName=NULL;
    LPWSTR szT;

    ULONG  uLen;

    static WCHAR c_szHostPrefix[] = L"HOST/";

    NetStatus = NetpSeparateUserAndDomain(szUser, &szUserName, &szDomainName);
    if (NetStatus == NERR_Success)
    {
        NetStatus = DsMakePasswordCredentials(szUserName, szDomainName,
                                              szUserPassword, &AuthId);
        if (NetStatus != NERR_Success)
        {
            goto Cleanup;
        }
    }

    //
    // first build various names
    //

    //
    // build Netbios domain name
    //
    uLen = wcslen(szDnsDomainName);
    NetStatus = NetpDuplicateString(szDnsDomainName, uLen, &szNetbiosDomainName);

    if (NetStatus == NERR_Success)
    {
        if (uLen > MAX_COMPUTERNAME_LENGTH)
        {
            szNetbiosDomainName[MAX_COMPUTERNAME_LENGTH] = UNICODE_NULL;
        }

        szT = wcschr(szNetbiosDomainName, L'.');
        if (szT)
        {
            *szT = UNICODE_NULL;
        }
    }

    //
    // build SamAccountName
    //
    NetStatus = NetpGetMachineAccountName(szComputerName,
                                          &SamAccountName);

    if (NetStatus == NERR_Success)
    {
        //
        // build SamName
        //
        NetStatus = NetpConcatStrings3(szNetbiosDomainName, -1,
                                       L"\\", 1,
                                       SamAccountName, -1,
                                       &SamName);
        if (NetStatus == NERR_Success)
        {
            wcsncpy(szComputerNetbiosName,
                    szComputerName, MAX_COMPUTERNAME_LENGTH);
            szComputerNetbiosName[MAX_COMPUTERNAME_LENGTH] = UNICODE_NULL;

            //
            // build DnsHostName
            //
            NetStatus = NetpConcatStrings3( szComputerNetbiosName,
                                            -1,
                                            L".", 1,
                                            szDnsDomainName, -1,
                                            &DnsHostName );
            if (NetStatus == NERR_Success)
            {
                //
                // build SPN
                //
                NetStatus = NetpConcatStrings(c_szHostPrefix,
                                              (sizeof( c_szHostPrefix )/
                                               sizeof(WCHAR) ) - 1,
                                              DnsHostName, -1,
                                              &Spn);
                if (NetStatus == NERR_Success)
                {
                    //
                    // build NebBios SPN
                    //
                    NetStatus = NetpConcatStrings(c_szHostPrefix,
                                                  (sizeof( c_szHostPrefix )/
                                                   sizeof(WCHAR) ) - 1,
                                                  szComputerNetbiosName, -1,
                                                  &SpnNetbios);
                }
            }
        }
    }

    if (NetStatus != NERR_Success)
    {
        goto Cleanup;
    }

    //
    // Bind to the DS on the DC.
    //
    NetStatus = DsBindWithCredW(szUncDcName, NULL, AuthId, &hDs);

    if ( NetStatus != NO_ERROR )
    {
        NetpLog(("NetpDsSetSPN: Unable to bind to DS on '%ws': 0x%lx\n",
                  szUncDcName, NetStatus ));
        goto Cleanup ;
    }

    //
    // Crack the sam account name into a DN:
    //

    NetStatus = DsCrackNamesW( hDs, 0, DS_NT4_ACCOUNT_NAME, DS_FQDN_1779_NAME,
                               1, &SamName, &CrackedName );

    if ( ( NetStatus != NO_ERROR ) ||
         ( CrackedName->cItems != 1 ) )
    {
        NetpLog(( "NetpDsSetSPN: CrackNames failed on '%ws' for '%ws': 0x%lx\n",
                  szUncDcName, SamName, NetStatus ));
        goto Cleanup ;
    }

    if ( CrackedName->rItems[ 0 ].status != 0 )
    {
        //$ kumarp 15-July-1999
        //
        //  we dont change NetStatus here thus treat this failure as success
        //  and end up not setting the DnsHostName/SPN
        //
        NetpLog(( "NetpDsSetSPN: CrackNames failed on %ws for %ws: substatus 0x%lx\n",
                  szUncDcName, SamName, CrackedName->rItems[ 0 ].status ));
        goto Cleanup ;
    }

    DnOfAccount = CrackedName->rItems[0].pName;


    NetStatus = NetpLdapBind( (LPWSTR) szUncDcName,
                              (LPWSTR) szUser,
                              (LPWSTR) szUserPassword, &hLdap );

    if (NetStatus == NERR_Success)
    {
        //
        // Write the DNS host name
        //
        DnsHostNameValues[0] = DnsHostName;
        DnsHostNameValues[1] = NULL;

        DnsHostNameAttr.mod_op = LDAP_MOD_REPLACE;
        DnsHostNameAttr.mod_type = L"DnsHostName";
        DnsHostNameAttr.mod_values = DnsHostNameValues;

        Mods[0] = &DnsHostNameAttr;
        Mods[1] = NULL;

        NetpLog (("NetpDsSetSPN: Setting DnsHostName '%ws' on '%ws'\n", DnsHostName, DnOfAccount));

        LdapStatus = ldap_modify_sW( hLdap, DnOfAccount, Mods );

        if ( LdapStatus != LDAP_SUCCESS )
        {
            NetStatus = LdapMapErrorToWin32(LdapStatus);
            NetpLog(( "NetpDsSetSPN: ldap_modify_s failed on '%ws' for '%ws': '%s' : 0x%lx\n",
                      szUncDcName, SamName, ldap_err2stringA( LdapStatus ),
                      NetStatus));
            goto Cleanup;
        }
    }

    if (NetStatus == NERR_Success)
    {
        //
        // Write the SPN.
        //
        NetpLog (("NetpDsSetSPN: Setting SPN '%ws' on '%ws'\n", Spn, DnOfAccount));

        NetStatus = DsWriteAccountSpn( hDs, DS_SPN_ADD_SPN_OP,
                                       DnOfAccount, 1, &Spn );

        if (NetStatus == NERR_Success)
        {
            NetpLog (("NetpDsSetSPN: Setting SPN '%ws' on '%ws'\n", SpnNetbios, DnOfAccount));
            NetStatus = DsWriteAccountSpn( hDs, DS_SPN_ADD_SPN_OP,
                                           DnOfAccount, 1, &SpnNetbios );
        }

        if ( NetStatus != NO_ERROR )
        {
            NetpLog(( "NetpDsSetSPN: DsWriteAccountSpn failed on '%ws' for '%ws': 0x%lx\n", szUncDcName, SamName, NetStatus ));
        }
    }


Cleanup:

    if ( hDs )
    {
        DsUnBind( &hDs );
    }

    if ( CrackedName )
    {
        DsFreeNameResultW( CrackedName );
    }

    if ( hLdap != NULL )
    {
        ldap_unbind_s( hLdap );
    }

    if ( AuthId )
    {
        DsFreePasswordCredentials( AuthId );
    }

    NetApiBufferFree( Spn );
    NetApiBufferFree( SpnNetbios );
    NetApiBufferFree( SamAccountName );
    NetApiBufferFree( SamName );

    NetApiBufferFree( szNetbiosDomainName );
    NetApiBufferFree( szDomainName );
    NetApiBufferFree( szUserName );

    return NetStatus ;
}

NET_API_STATUS
NET_API_FUNCTION
NetpGetDefaultLcidOnMachine(
    IN  LPCWSTR  szMachine,
    OUT LCID*    plcidMachine
    )
{
    NET_API_STATUS NetStatus = NERR_Success;
    HKEY hkeyRemoteMachine, hkeyLanguage;
    WCHAR szLocale[16];
    DWORD dwLocaleSize=0;
    DWORD dwType;

    static WCHAR c_szRegKeySystemLanguage[] =
      L"System\\CurrentControlSet\\Control\\Nls\\Locale";
    static WCHAR c_szRegValDefault[] = L"(Default)";

    //
    // Connect to the remote registry
    //
    if ( NetStatus == NERR_Success )
    {
        NetStatus = RegConnectRegistry( szMachine,
                                        HKEY_LOCAL_MACHINE,
                                        &hkeyRemoteMachine );
        //
        // Now, open the system language key
        //
        if ( NetStatus == NERR_Success )
        {
            NetStatus = RegOpenKeyEx( hkeyRemoteMachine,
                                      c_szRegKeySystemLanguage,
                                      0, KEY_READ, &hkeyLanguage);
            //
            // get default locale
            //
            if ( NetStatus == NERR_Success )
            {
                dwLocaleSize = sizeof( szLocale );
                NetStatus = RegQueryValueEx( hkeyLanguage,
                                             c_szRegValDefault,
                                             NULL, &dwType,
                                             (LPBYTE) szLocale,
                                             &dwLocaleSize );
                if ( NetStatus == NERR_Success)
                {
                    if ((dwType == REG_SZ) &&
                        (swscanf(szLocale, L"%lx", plcidMachine) != 1))
                    {
                        //$ REVIEW  kumarp 29-May-1999
                        //  better errorcode?
                        NetStatus = ERROR_INVALID_PARAMETER;
                    }
                }
                RegCloseKey( hkeyLanguage );
            }
            RegCloseKey( hkeyRemoteMachine );
        }
    }

    return NetStatus;
}

NET_API_STATUS
NET_API_FUNCTION
NetpVerifyStrOemCompatibleInLocale(
    IN  LPCWSTR  szString,
    IN  LCID     lcidRemote
    )
{
    NET_API_STATUS NetStatus = NERR_Success;
    NTSTATUS NtStatus=STATUS_SUCCESS;
    OEM_STRING osLocal = { 0 };
    OEM_STRING osRemote = { 0 };
    UNICODE_STRING sString;
    LCID lcidLocal;

    lcidLocal = GetThreadLocale();

    RtlInitUnicodeString(&sString, szString);
    NtStatus = RtlUnicodeStringToOemString(&osLocal, &sString, TRUE);

    __try
    {
        if (NtStatus == STATUS_SUCCESS)
        {
            if (SetThreadLocale(lcidRemote))
            {
                NtStatus = RtlUnicodeStringToOemString(&osRemote,
                                                       &sString, TRUE);
                if (NtStatus == STATUS_SUCCESS)
                {
                    if (!RtlEqualMemory(osLocal.Buffer, osRemote.Buffer,
                                        osLocal.Length))
                    {
                        NetStatus = NERR_NameUsesIncompatibleCodePage;
                    }
                }
                else
                {
                    NetStatus = RtlNtStatusToDosError(NtStatus);
                }
            }
            else
            {
                NetStatus = GetLastError();
            }

        }
        else
        {
            NetStatus = RtlNtStatusToDosError(NtStatus);
        }
    }

    __finally
    {
        if (!SetThreadLocale(lcidLocal))
        {
            NetStatus = GetLastError();
        }
        // RtlFreeOemString checks for NULL Buffer
        RtlFreeOemString(&osLocal);
        RtlFreeOemString(&osRemote);
    }

    return NetStatus;
}

NET_API_STATUS
NET_API_FUNCTION
NetpVerifyStrOemCompatibleOnMachine(
    IN  LPCWSTR  szRemoteMachine,
    IN  LPCWSTR  szString
    )
{
    NET_API_STATUS NetStatus = NERR_Success;
    LCID lcidRemoteMachine;

    NetStatus = NetpGetDefaultLcidOnMachine(szRemoteMachine,
                                            &lcidRemoteMachine);
    if (NetStatus == NERR_Success)
    {
        NetStatus = NetpVerifyStrOemCompatibleInLocale(szString,
                                                       lcidRemoteMachine);
    }

    return NetStatus;
}



#define NETP_NETLOGON_PATH  L"System\\CurrentControlSet\\services\\Netlogon\\parameters\\"
#define NETP_NETLOGON_RPC   L"RefusePasswordChange"

NET_API_STATUS
NET_API_FUNCTION
NetpGetNt4RefusePasswordChangeStatus(
    IN  LPCWSTR Nt4Dc,
    OUT BOOL* RefusePasswordChangeSet
    )
/*++

Routine Description:

    Read the regkey NETP_NETLOGON_PATH\NETP_NETLOGON_RPC on Nt4Dc.
    Return the value read in the out parameter.

Arguments:

    Nt4Dc                   -- name of machine to read reg. from
    RefusePasswordChangeSet -- value returned

Returns:

    NERR_Success -- Success

--*/
{
    NET_API_STATUS NetStatus = NERR_Success;
    PWSTR FullComputerName = NULL;
    HKEY NetlogonRootKey, DcKey;
    ULONG Length, Type;
    DWORD Value;

    *RefusePasswordChangeSet = FALSE;

    //
    // Build the full computer name if necessary
    //
    if ( *Nt4Dc != L'\\' )
    {
        NetStatus = NetApiBufferAllocate( ( wcslen( Nt4Dc ) + 3 ) * sizeof( WCHAR ),
                                          ( LPVOID * )&FullComputerName );
        if ( NetStatus == NERR_Success )
        {
            swprintf( FullComputerName, L"\\\\%ws", Nt4Dc );
        }
    }
    else
    {
        FullComputerName = (LPWSTR) Nt4Dc;
    }

    NetpLog(( "NetpGetNt4RefusePasswordChangeStatus: trying to read from '%ws'\n", FullComputerName));

    //
    // Connect to the remote registry
    //
    if ( NetStatus == NERR_Success )
    {
        NetStatus = RegConnectRegistry( FullComputerName,
                                        HKEY_LOCAL_MACHINE,
                                        &DcKey );
        //
        // Now, open the netlogon parameters section
        //
        if ( NetStatus == NERR_Success )
        {
            NetStatus = RegOpenKeyEx( DcKey,
                                      NETP_NETLOGON_PATH,
                                      0,
                                      KEY_READ,
                                      &NetlogonRootKey);

            //
            // Now, see if the key actually exists...
            //
            if ( NetStatus == NERR_Success )
            {
                Length = sizeof( Value );
                NetStatus = RegQueryValueEx( NetlogonRootKey,
                                             NETP_NETLOGON_RPC,
                                             NULL,
                                             &Type,
                                             ( LPBYTE )&Value,
                                             &Length );
                if ( NetStatus == NERR_Success)
                {
                    NetpLog(( "NetpGetNt4RefusePasswordChangeStatus: RefusePasswordChange == %d\n", Value));

                    if ( Value != 0 )
                    {
                        *RefusePasswordChangeSet = TRUE;
                    }

                }
                RegCloseKey( NetlogonRootKey );
            }
            RegCloseKey( DcKey );
        }
    }

    if ( FullComputerName != Nt4Dc )
    {
        NetApiBufferFree( FullComputerName );
    }

    //
    // If anything went wrong, ignore it...
    //
    if ( NetStatus != NERR_Success )
    {
        NetpLog(( "NetpGetNt4RefusePasswordChangeStatus: failed but ignored the failure: 0x%lx\n", NetStatus ));
        NetStatus = NERR_Success;
    }

    return( NetStatus );
}

NET_API_STATUS
NET_API_FUNCTION
NetpGetComputerNameAllocIfReqd(
    OUT LPWSTR* ppwszMachine,
    IN  UINT    cLen
    )
/*++

Routine Description:

    Get name of the computer on which this runs. Alloc a buffer
    if the name is longer than cLen.

Arguments:

    ppwszMachine -- pointer to buffer. this receives a buffer if allocated.
    cLen         -- length of buffer pointed to by *ppwszMachine.
                    If the computer name to be returned is longer than this
                    a new buffer is allocated.

Returns:

    NERR_Success -- Success

--*/
{
    NET_API_STATUS NetStatus=NERR_Success;

    if ( GetComputerName( *ppwszMachine, &cLen ) == FALSE )
    {
        NetStatus = GetLastError();

        if ( (NetStatus == ERROR_INSUFFICIENT_BUFFER) ||
             (NetStatus == ERROR_BUFFER_OVERFLOW) )
        {
            // allocate an extra char for the append-$ case
            NetStatus = NetApiBufferAllocate( (cLen + 1 + 1) * sizeof(WCHAR),
                                              (PBYTE *) ppwszMachine );
            if ( NetStatus == NERR_Success )
            {
                if ( GetComputerName( *ppwszMachine, &cLen ) == FALSE )
                {
                    NetStatus = GetLastError();
                }
            }
        }
    }

    return NetStatus;
}

// ======================================================================
//
// Note: all code below this has been added as helper code for
//       NetpSetComputerAccountPassword. this function is used by
//       netdom.exe to fix a dc that was rendered unusable because
//       of a ds restore resulting into 2+ password mismatch on
//       machine account.
//
//       This entire code is temporary and should be removed and
//       rewritten post w2k.
//

static
NET_API_STATUS
NET_API_FUNCTION
NetpEncodePassword(
    IN LPWSTR lpPassword,
    IN OUT PUCHAR Seed,
    OUT LPWSTR *EncodedPassword,
    OUT PULONG EncodedPasswordLength
    )
{
    NET_API_STATUS status = NERR_Success;
    UNICODE_STRING EncodedPasswordU;
    PWSTR PasswordPart;
    ULONG PwdLen;

    *EncodedPassword = NULL;
    *EncodedPasswordLength = 0;

    if ( lpPassword  ) {

        PwdLen = wcslen( ( LPWSTR )lpPassword ) * sizeof( WCHAR );

        PwdLen += sizeof( WCHAR ) + sizeof( WCHAR );

        status = NetApiBufferAllocate( PwdLen,
                                       ( PVOID * )EncodedPassword );

        if ( status == NERR_Success ) {

            //
            // We'll put the encode byte as the first character in the string
            //
            PasswordPart = ( *EncodedPassword ) + 1;
            wcscpy( PasswordPart, ( LPWSTR )lpPassword );
            RtlInitUnicodeString( &EncodedPasswordU, PasswordPart );

            *Seed = 0;
            RtlRunEncodeUnicodeString( Seed, &EncodedPasswordU );

            *( PWCHAR )( *EncodedPassword ) = ( WCHAR )*Seed;

            //
            // Encode the old password as well...
            //
            RtlInitUnicodeString( &EncodedPasswordU, lpPassword );
            RtlRunEncodeUnicodeString( Seed, &EncodedPasswordU );
            *EncodedPasswordLength = PwdLen;

        }

    }

    return( status );
}


NTSTATUS
NetpLsaOpenSecret2(
    IN LSA_HANDLE      hLsa,
    IN PUNICODE_STRING pusSecretName,
    IN ACCESS_MASK     DesiredAccess,
    OUT PLSA_HANDLE    phSecret
    )
{
    NTSTATUS Status = STATUS_UNSUCCESSFUL;
    HANDLE hToken=NULL;

    __try
    {
        if (OpenThreadToken(GetCurrentThread(), TOKEN_IMPERSONATE,
                            TRUE, &hToken))
        {
            if (SetThreadToken(NULL, NULL))
            {
                Status = STATUS_SUCCESS;
            }
        }
        else
        {
            if (GetLastError() == ERROR_NO_TOKEN)
            {
                Status = STATUS_SUCCESS;
            }
        }

        if ( NT_SUCCESS(Status) )
        {
            Status = LsaOpenSecret(hLsa, pusSecretName,
                                   DesiredAccess, phSecret);
        }
    }
    __finally
    {
        if (hToken)
        {
            SetThreadToken(NULL, hToken);
        }
    }

    NetpLog((  "NetpLsaOpenSecret: status: 0x%lx\n", Status ));

    return Status;
}

NET_API_STATUS
NET_API_FUNCTION
NetpManageMachineSecret2(
    IN  LSA_HANDLE  PolicyHandle, OPTIONAL
    IN  LPWSTR      lpMachine,
    IN  LPWSTR      lpPassword,
    IN  BOOL        fDelete,
    OUT PLSA_HANDLE pPolicyHandle OPTIONAL
    )
{
    NTSTATUS            Status = STATUS_SUCCESS;
    LSA_HANDLE          LocalPolicy = NULL, SecretHandle = NULL;
    UNICODE_STRING      Key, Data, *CurrentValue = NULL;
    BOOLEAN             SecretCreated = FALSE;

    if( fDelete == FALSE )
    {
        ASSERT( lpPassword );
    }

    UNREFERENCED_PARAMETER( lpMachine );

    Status = NetpGetLsaHandle( NULL, PolicyHandle, &LocalPolicy );

    //
    // open/create the secret
    //
    if ( NT_SUCCESS( Status ) )
    {
        RtlInitUnicodeString( &Key, L"$MACHINE.ACC" );
        RtlInitUnicodeString( &Data, lpPassword );

        Status = NetpLsaOpenSecret2( LocalPolicy, &Key,
                                     fDelete == NETSETUPP_CREATE ?
                                     SECRET_SET_VALUE | SECRET_QUERY_VALUE : DELETE,
                                     &SecretHandle );

        if ( Status == STATUS_OBJECT_NAME_NOT_FOUND )
        {
            if ( fDelete )
            {
                Status = STATUS_SUCCESS;
            }
            else
            {
                Status = LsaCreateSecret( LocalPolicy, &Key,
                                          SECRET_SET_VALUE, &SecretHandle );

                if ( NT_SUCCESS( Status ) )
                {
                    SecretCreated = TRUE;
                }
            }
        }

        if ( !NT_SUCCESS( Status ) )
        {
            NetpLog((  "NetpManageMachineSecret: Open/Create secret failed: 0x%lx\n", Status ));
        }

        if ( NT_SUCCESS( Status ) )
        {
            if ( fDelete == NETSETUPP_CREATE )
            {
                //
                // First, read the current value, so we can save it as the old value
                //
                if ( SecretCreated )
                {
                    CurrentValue = &Data;
                }
                else
                {
                    Status = LsaQuerySecret( SecretHandle, &CurrentValue,
                                             NULL, NULL, NULL );
                }

                if ( NT_SUCCESS( Status ) )
                {
                    //
                    // Now, store both the new password and the old
                    //
                    Status = LsaSetSecret( SecretHandle, &Data, CurrentValue );

                    if ( !SecretCreated )
                    {
                        LsaFreeMemory( CurrentValue );
                    }
                }
            }
            else
            {
                //
                // No secret handle means we failed earlier in
                // some intermediate state.  That's ok, just press on.
                //
                if ( SecretHandle != NULL )
                {
                    Status = LsaDelete( SecretHandle );

                    if ( NT_SUCCESS( Status ) )
                    {
                        SecretHandle = NULL;
                    }
                }
            }
        }

        if ( SecretHandle )
        {
            LsaClose( SecretHandle );
        }
    }

    NetpSetLsaHandle( PolicyHandle, LocalPolicy, pPolicyHandle );

    if ( !NT_SUCCESS( Status ) )
    {
        NetpLog(( "NetpManageMachineSecret: '%s' operation failed: 0x%lx\n",
                  fDelete == NETSETUPP_CREATE ? "CREATE" : "DELETE", Status ));
    }

    return( RtlNtStatusToDosError( Status ) );
}


NET_API_STATUS
NET_API_FUNCTION
NetpSetMachineAccountPasswordAndTypeEx2(
    IN      LPWSTR          lpDcName,
    IN      PSID            DomainSid,
    IN      LPWSTR          lpAccountName,
    IN OUT  OPTIONAL LPWSTR lpPassword,
    IN      OPTIONAL UCHAR  AccountState
    )
{
    NET_API_STATUS NetStatus=NERR_Success;
    NTSTATUS Status = STATUS_SUCCESS;
    UNICODE_STRING DcName, AccountName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    SAM_HANDLE SamHandle = NULL, DomainHandle = NULL, AccountHandle = NULL;
    ULONG UserRid;
    PULONG RidList = NULL;
    PSID_NAME_USE NameUseList = NULL;
    PUSER_CONTROL_INFORMATION UserAccountControl = NULL;
    USER_SET_PASSWORD_INFORMATION PasswordInfo;
    ULONG OldUserInfo;
    BOOL fAccountControlModified = FALSE;
    LPWSTR lpSamAccountName=lpAccountName;
    ULONG AccountNameLen=0;

    AccountNameLen = wcslen( lpAccountName );

    //
    // if caller has not passed in sam-account name,
    // generate it from machine name ==> append $ at the end
    //
    if (lpAccountName[AccountNameLen-1] != L'$')
    {
        NetStatus = NetpGetMachineAccountName(lpAccountName,
                                              &lpSamAccountName);

        if (NetStatus != NERR_Success)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            goto SetPasswordError;
        }
    }


    RtlInitUnicodeString( &DcName, lpDcName );
    RtlZeroMemory( &ObjectAttributes, sizeof( OBJECT_ATTRIBUTES ) );

    Status = SamConnect( &DcName,
                         &SamHandle,
                         SAM_SERVER_CONNECT | SAM_SERVER_LOOKUP_DOMAIN,
                         &ObjectAttributes );

    if ( !NT_SUCCESS( Status ) ) {

        NetpLog(( "SamConnect to %wZ failed with 0x%lx\n", &DcName, Status ));

        goto SetPasswordError;

    }

    //
    // Open the domain
    //
    Status = SamOpenDomain( SamHandle,
                            DOMAIN_LOOKUP,
                            DomainSid,
                            &DomainHandle );


    if ( !NT_SUCCESS( Status ) ) {

#ifdef NETSETUP_VERBOSE_LOGGING

        UNICODE_STRING DisplaySid;
        NTSTATUS Status2;
        RtlZeroMemory( &DisplaySid, sizeof( UNICODE_STRING ) );

        Status2 = RtlConvertSidToUnicodeString( &DisplaySid, DomainSid, TRUE );

        if ( NT_SUCCESS( Status2 ) ) {

            NetpLog(( "SamOpenDomain on %wZ failed with 0x%lx\n",
                      &DisplaySid, Status ));

            RtlFreeUnicodeString(&DisplaySid);

        } else {

            NetpLog(( "SamOpenDomain on <undisplayable sid> failed with 0x%lx\n",
                      Status ));
        }
#endif

        goto SetPasswordError;

    }

    //
    // Get the RID of the user account
    //
    RtlInitUnicodeString( &AccountName, lpSamAccountName );
    Status = SamLookupNamesInDomain( DomainHandle,
                                     1,
                                     &AccountName,
                                     &RidList,
                                     &NameUseList );

    if ( !NT_SUCCESS( Status ) ) {

        NetpLog(( "SamLookupNamesInDomain on %wZ failed with 0x%lx\n",
                  &AccountName, Status ));

        goto SetPasswordError;
    }

    UserRid = RidList[ 0 ];
    SamFreeMemory( RidList );
    SamFreeMemory( NameUseList );

    //
    // Finally, open the user account
    //
    Status = SamOpenUser( DomainHandle,
                          USER_FORCE_PASSWORD_CHANGE | USER_READ_ACCOUNT | USER_WRITE_ACCOUNT,
                          UserRid,
                          &AccountHandle );

    if ( !NT_SUCCESS( Status ) ) {

        Status = SamOpenUser( DomainHandle,
                              USER_FORCE_PASSWORD_CHANGE | USER_READ_ACCOUNT,
                              UserRid,
                              &AccountHandle );

        if ( !NT_SUCCESS( Status ) ) {

            NetpLog((  "SamOpenUser on %lu failed with 0x%lx\n",
                                UserRid,
                                Status ));

            goto SetPasswordError;
        }
    }

    //
    // Now, read the current user account type and see if it needs to be modified
    //
    Status = SamQueryInformationUser( AccountHandle,
                                      UserControlInformation,
                                      ( PVOID * )&UserAccountControl );
    if ( !NT_SUCCESS( Status ) ) {

        NetpLog(( "SamQueryInformationUser for UserControlInformation "
                  "failed with 0x%lx\n", Status ));

        goto SetPasswordError;
    }

    OldUserInfo = UserAccountControl->UserAccountControl;


    //
    // Determine if the account control changes. If the account is being enabled,
    // we want to perform the following sequence of operations: enable, disable,
    // and enable again. This is needed to increase the USN (Universal Sequence
    // Number) of this attribute so that the enabled value will win if the DS
    // replication resolves colliding changes, as the following example shows.
    // Suppose we have two DCs in the domain we join, A abd B. Suppose the account
    // is currently disabled on A (because the user unjoined using that DC),
    // but it is still enabled on B (because the replication hasn't happened yet).
    // Suppose the user performs now joining to the domain.  Then we have discovered
    // B and so we proceed with setting up the changes to the existing account. If
    // we don't toggle the account control attribute, then the USN of this attribute
    // will not change on B (since attribute's value doesn't change) while it was
    // incremented on A as the result of unjoin. At the replication time the data
    // from A will rule and the account will be incorrectly marked as diabled.
    //
    // NOTE:  This design may fail for the case of unjoining a domain that has
    // three (or more) DCs, A, B, and C if the following sequence of operations
    // happens. Suppose that the account is originally enabled on all DCs (state [1]
    // in the bellow diagram). Then the user unjoins using DC A (state [2]). Then the
    // user joins using B where the account is still enabled (state [3]). Then the user
    // unjoins using C where the account is still enabled (state [4]). The final
    // operation is unjoin, so the user expects that his account is disabled. We've
    // assumed here that for some reason no replication was happening when these
    // operations were performed. Then at the replication time the value from B will
    // win (because of the additional toggling performed at the join time). But the
    // account state on B is Enabled, so the final result will be that the account is
    // enabled on all DCs which is not what the user expects.
    //
    //          A               B                                  C
    //       Enabled  [1]    Enabled [1]                        Enabled  [1]
    //       Disabled [2]    Enabled (no-op)+Disabled (1 op)    Disabled [4]
    //                       Enabled [3]
    //

    if ( AccountState != ACCOUNT_STATE_IGNORE ) {

        if ( AccountState == ACCOUNT_STATE_ENABLED ) {

            fAccountControlModified = TRUE;
            UserAccountControl->UserAccountControl &= ~USER_ACCOUNT_DISABLED;
        }

        if ( ( AccountState == ACCOUNT_STATE_DISABLED ) &&
             !( OldUserInfo & USER_ACCOUNT_DISABLED ) ) {

            fAccountControlModified = TRUE;
            UserAccountControl->UserAccountControl |= USER_ACCOUNT_DISABLED;
        }
    }

    if ( fAccountControlModified == FALSE ) {

        SamFreeMemory( UserAccountControl );
        UserAccountControl = NULL;
    }

    //
    // First, set the account type if required
    //
    if ( UserAccountControl ) {

        Status = SamSetInformationUser( AccountHandle,
                                        UserControlInformation,
                                        ( PVOID )UserAccountControl );
        if ( !NT_SUCCESS( Status ) ) {

            NetpLog(( "SamSetInformationUser for UserControlInformation "
                      "failed with 0x%lx\n", Status ));

            goto SetPasswordError;

        //
        // If we are enabling the account, disable and re-enable it to
        // make the two additional account state toggles.
        //
        } else if ( AccountState == ACCOUNT_STATE_ENABLED ) {

            UserAccountControl->UserAccountControl |= USER_ACCOUNT_DISABLED;
            Status = SamSetInformationUser( AccountHandle,
                                            UserControlInformation,
                                            ( PVOID )UserAccountControl );
            if ( !NT_SUCCESS(Status) ) {
                NetpLog(( "SamSetInformationUser (second) for UserControlInformation "
                          "failed with 0x%lx\n", Status ));
                goto SetPasswordError;
            }

            UserAccountControl->UserAccountControl &= ~USER_ACCOUNT_DISABLED;
            Status = SamSetInformationUser( AccountHandle,
                                            UserControlInformation,
                                            ( PVOID )UserAccountControl );
            if ( !NT_SUCCESS(Status) ) {
                NetpLog(( "SamSetInformationUser (third) for UserControlInformation "
                          "failed with 0x%lx\n", Status ));
                goto SetPasswordError;
            }
        }
    }

    //
    // If requested, set the password on the account
    //
    if ( lpPassword != NULL )
    {
        RtlInitUnicodeString( &PasswordInfo.Password, lpPassword );
        PasswordInfo.PasswordExpired = FALSE;

        //
        // Ok, then, set the password on the account
        //
        // The caller has passed in a strong password, try that first
        // NT5 dcs will always accept a strong password.
        //
        Status = SamSetInformationUser( AccountHandle,
                                        UserSetPasswordInformation,
                                        ( PVOID )&PasswordInfo );
        if ( !NT_SUCCESS( Status ) )
        {
            if ( (Status == STATUS_PASSWORD_RESTRICTION) &&
                 !NetpIsDefaultPassword( lpAccountName, lpPassword ))
            {
                NetpLog(( "NetpSetMachineAccountPasswordAndTypeEx: STATUS_PASSWORD_RESTRICTION error setting password. retrying...\n" ));
                //
                // SAM did not accpet a long password, try LM20_PWLEN
                //
                // This is probably because the dc is NT4 dc.
                // NT4 dcs will not accept a password longer than LM20_PWLEN
                //
                lpPassword[LM20_PWLEN] = UNICODE_NULL;
                RtlInitUnicodeString( &PasswordInfo.Password, lpPassword );
                Status = SamSetInformationUser( AccountHandle,
                                                UserSetPasswordInformation,
                                                ( PVOID )&PasswordInfo );
                if ( Status == STATUS_PASSWORD_RESTRICTION )
                {
                    NetpLog(( "NetpSetMachineAccountPasswordAndTypeEx: STATUS_PASSWORD_RESTRICTION error setting password. retrying...\n" ));
                    //
                    // SAM did not accpet a LM20_PWLEN password, try shorter one
                    //
                    // SAM uses RtlUpcaseUnicodeStringToOemString internally.
                    // In this process it is possible that in the worst case,
                    // n unicode char password will get mapped to 2*n dbcs
                    // char password. This will make it exceed LM20_PWLEN.
                    // To guard against this worst case, try a password
                    // with LM20_PWLEN/2 length
                    //
                    // One might say that LM20_PWLEN/2 length password
                    // is not really secure. I agree, but it is definitely
                    // better than the default password which we will have
                    // to fall back to otherwise.
                    //
                    lpPassword[LM20_PWLEN/2] = UNICODE_NULL;
                    RtlInitUnicodeString( &PasswordInfo.Password, lpPassword );
                    Status = SamSetInformationUser( AccountHandle,
                                                    UserSetPasswordInformation,
                                                    ( PVOID )&PasswordInfo );
                    if ( Status == STATUS_PASSWORD_RESTRICTION )
                    {
                        //
                        // SAM did not accpet a short pwd, try default pwd
                        //
                        NetpLog(( "NetpSetMachineAccountPasswordAndTypeEx: STATUS_PASSWORD_RESTRICTION error setting password. retrying...\n" ));

                        NetpGenerateDefaultPassword(lpAccountName, lpPassword);
                        RtlInitUnicodeString( &PasswordInfo.Password, lpPassword );
                        Status = SamSetInformationUser( AccountHandle,
                                                        UserSetPasswordInformation,
                                                        ( PVOID )&PasswordInfo );
                    }
                }
            }

            if ( NT_SUCCESS( Status ) )
            {
                NetpLog(( "NetpGenerateDefaultPassword: successfully set password\n" ));
            }
            else
            {
                NetpLog(( "NetpSetMachineAccountPasswordAndTypeEx: SamSetInformationUser for UserSetPasswordInformation failed: 0x%lx\n", Status ));

                //
                // Make sure we try to restore the account control
                //
                if ( UserAccountControl )
                {
                    NTSTATUS Status2;

                    UserAccountControl->UserAccountControl = OldUserInfo;
                    Status2 = SamSetInformationUser( AccountHandle,
                                                     UserControlInformation,
                                                     ( PVOID )UserAccountControl );
                    if ( !NT_SUCCESS( Status2 ) )
                    {
                        NetpLog(( "SamSetInformationUser for UserControlInformation (RESTORE) failed with 0x%lx\n", Status2 ));
                    }
                }
                goto SetPasswordError;
            }
        }
    }

SetPasswordError:

    if ( lpSamAccountName != lpAccountName )
    {
        NetApiBufferFree( lpSamAccountName );
    }

    if ( AccountHandle ) {

        SamCloseHandle( AccountHandle );
    }

    if ( DomainHandle ) {

        SamCloseHandle( DomainHandle );
    }

    if ( SamHandle ) {

        SamCloseHandle( SamHandle );
    }

    NetStatus = RtlNtStatusToDosError( Status );

    SamFreeMemory( UserAccountControl );

    return( NetStatus );
}

NET_API_STATUS
NET_API_FUNCTION
NetpSetComputerAccountPassword(
    IN   PWSTR szMachine,
    IN   PWSTR szDomainController,
    IN   PWSTR szUser,
    IN   PWSTR szUserPassword,
    IN   PVOID Reserved
    )
{
    NET_API_STATUS NetStatus=NERR_Success;
    NET_API_STATUS NetStatus2=NERR_Success;
    BOOL fIpcConnected = FALSE;
    BYTE bSeed;
    PPOLICY_PRIMARY_DOMAIN_INFO pPolicyPDI = NULL;
    PPOLICY_DNS_DOMAIN_INFO     pPolicyDns = NULL;
    LSA_HANDLE hLsa = NULL, hDC = NULL;
    WCHAR szMachinePassword[ PWLEN + 1];
    WCHAR szMachineNameBuf[MAX_COMPUTERNAME_LENGTH + 1];
    PWSTR szMachineName=szMachineNameBuf;

    NetSetuppOpenLog();
    NetpLog(( "NetpSetComputerAccountPassword: for '%ws' on '%ws' using '%ws' creds\n", GetStrPtr(szMachine), GetStrPtr(szDomainController), GetStrPtr(szUser) ));

    if ( ( szDomainController == NULL ) ||
         ( szUser             == NULL ) ||
         ( szUserPassword     == NULL ) )
    {
        NetStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if ( szMachine == NULL )
    {
        NetStatus = NetpGetComputerNameAllocIfReqd(&szMachineName,
                                                   MAX_COMPUTERNAME_LENGTH);
    }
    else
    {
        szMachineName = szMachine;
    }

    NetStatus = NetpManageIPCConnect( szDomainController,
                                      szUser, szUserPassword,
                                      NETSETUPP_CONNECT_IPC );
    RtlZeroMemory( szUserPassword, wcslen( szUserPassword ) * sizeof(WCHAR) );

    NetpLog(( "NetpSetComputerAccountPassword: status of connecting to dc '%ws': 0x%lx\n", szDomainController, NetStatus ));

    //
    // get the lsa domain info on the DC
    //
    if ( NetStatus == NERR_Success )
    {
        fIpcConnected = TRUE;
        NetStatus = NetpGetLsaPrimaryDomain(NULL, szDomainController,
                                            &pPolicyPDI, &pPolicyDns, &hDC);
    }

    if (NetStatus == NERR_Success)
    {
        //
        // Generate the password to use on the machine account.
        //
        NetStatus = NetpGeneratePassword( szMachineName,
                                          TRUE, // fRandomPwdPreferred
                                          szDomainController,
                                          FALSE, // fIsNt4Dc
                                          szMachinePassword );
        NetpLog(( "NetpSetComputerAccountPassword: status of generating machine password: 0x%lx\n", NetStatus ));
    }

    if (NetStatus == NERR_Success)
    {
        NetStatus = NetpSetMachineAccountPasswordAndTypeEx2(
            szDomainController, pPolicyPDI->Sid,
            szMachineName, szMachinePassword,
            ACCOUNT_STATE_IGNORE
            );
        NetpLog(( "NetpSetComputerAccountPassword: status of setting machine password on %ws: 0x%lx\n", GetStrPtr(szDomainController), NetStatus ));
    }

    if (NetStatus == NERR_Success)
    {
        // if we are not creating the machine account,
        // just set the password
        NetStatus = NetpSetMachineAccountPasswordAndTypeEx2(
            szMachineName, pPolicyPDI->Sid,
            szMachineName, szMachinePassword,
            ACCOUNT_STATE_IGNORE
            );
        NetpLog(( "NetpSetComputerAccountPassword: status of setting machine password on %ws: 0x%lx\n", GetStrPtr(szMachineName), NetStatus ));
    }

    //
    // set the local machine secret
    //
    if ( NetStatus == NERR_Success )
    {
        NetStatus = NetpGetLsaHandle( NULL, NULL, &hLsa );

        if ( NetStatus == NERR_Success )
        {
            NetStatus = NetpManageMachineSecret2( NULL, szMachineName,
                                                  szMachinePassword,
                                                  NETSETUPP_CREATE, &hLsa );
            LsaClose( hLsa );
        }
        NetpLog(( "NetpSetComputerAccountPassword: status of setting local secret: 0x%lx\n", NetStatus ));
    }


    //
    // Now, we no longer need our session to our dc
    //
    if ( fIpcConnected )
    {
        //RtlRunDecodeUnicodeString( bSeed, &usEncodedPassword );
        NetStatus2 = NetpManageIPCConnect( szDomainController, szUser,
                                           //usEncodedPassword.Buffer,
                                           NULL,
                                           NETSETUPP_DISCONNECT_IPC );
        //RtlRunEncodeUnicodeString( &bSeed, &usEncodedPassword );
        NetpLog(( "NetpJoinDomain: status of disconnecting from '%ws': 0x%lx\n", szDomainController, NetStatus2));
    }


Cleanup:
    if ( (szMachineName != szMachine) &&
         (szMachineName != szMachineNameBuf) )
    {
        NetApiBufferFree( szMachineName );
    }

    NetpLog(( "NetpSetComputerAccountPassword: status: 0x%lx\n", NetStatus ));

    NetSetuppCloseLog();

    return NetStatus;
}

NET_API_STATUS
NET_API_FUNCTION
NetpUpdateW32timeConfig(
    IN PCSTR szW32timeJoinConfigFuncName
    )
/*++

Routine Description:

    Call entry point in w32time service so that it can update
    its internal info after a domain join/unjoin

Arguments:

    szW32timeJoinConfigFuncName - name of entry point to call
        (must be W32TimeVerifyJoinConfig or W32TimeVerifyUnjoinConfig)

Return Value:

    NERR_Success -- on Success
    otherwise win32 error codes returned by LoadLibrary, GetProcAddress

Notes:

--*/
{
    NET_API_STATUS NetStatus = NERR_Success;
    HANDLE hDll = NULL;
    typedef VOID (*PW32TimeUpdateJoinConfig)( VOID );

    PW32TimeUpdateJoinConfig pfnW32timeUpdateJoinConfig = NULL;

    //
    // Call into the time service to allow it initialize itself properly
    //

    hDll = LoadLibraryA( "w32Time" );

    if ( hDll != NULL )
    {
        pfnW32timeUpdateJoinConfig =
            (PW32TimeUpdateJoinConfig) GetProcAddress(hDll,
                                                      szW32timeJoinConfigFuncName);

        if ( pfnW32timeUpdateJoinConfig != NULL )
        {
            pfnW32timeUpdateJoinConfig();
        }
        else
        {
            NetStatus = GetLastError();

            NetpLog(( "NetpUpdateW32timeConfig: Failed to get proc address for %s: 0x%lx\n", szW32timeJoinConfigFuncName, NetStatus ));
        }

    }
    else
    {
        NetStatus = GetLastError();

        NetpLog(( "NetpUpdateW32timeConfig: Failed to load w32time: 0x%lx\n", NetStatus ));
    }

    if ( hDll != NULL )
    {
        FreeLibrary( hDll );
    }

    NetpLog(( "NetpUpdateW32timeConfig: 0x%lx\n", NetStatus ));

    return NetStatus;
}

NET_API_STATUS
NET_API_FUNCTION
NetpUpdateAutoenrolConfig(
    IN BOOL UnjoinDomain
    )
/*++

Routine Description:

    Call entry point in pautoenr service so that it can update
    its internal info after a domain join/unjoin

Arguments:

    UnjoinDomain - If TRUE, we are unjoining from a domain.
        Otherwise, we are roling back from unsuccessful domain
        unjoin.

Return Value:

    NERR_Success -- on Success
    otherwise win32 error codes returned by LoadLibrary, GetProcAddress

Notes:

--*/
{
    NET_API_STATUS NetStatus = NERR_Success;
    HANDLE hDll = NULL;
    ULONG Flags = 0;

    typedef BOOL (*PCertAutoRemove)( DWORD );

    PCertAutoRemove pfnCertAutoRemove = NULL;

    //
    // Prepare the flags to pass to autoenrol routine
    //

    if ( UnjoinDomain ) {
        Flags = CERT_AUTO_REMOVE_COMMIT;
    } else {
        Flags = CERT_AUTO_REMOVE_ROLL_BACK;
    }

    //
    // Call into the time service to allow it initialize itself properly
    //

    hDll = LoadLibraryA( "pautoenr" );

    if ( hDll != NULL ) {

        pfnCertAutoRemove =
            (PCertAutoRemove) GetProcAddress( hDll, "CertAutoRemove" );

        if ( pfnCertAutoRemove != NULL ) {
            if ( !pfnCertAutoRemove(Flags) ) {
                NetStatus = GetLastError();
                NetpLog(( "NetpUpdateAutoenrolConfig: CertAutoRemove failed 0x%lx\n",
                          NetStatus ));
            }
        } else {
            NetStatus = GetLastError();
            NetpLog(( "NetpUpdateAutoenrolConfig: Failed to get CertAutoRemove proc address 0x%lx\n",
                      NetStatus ));
        }

    } else {
        NetStatus = GetLastError();
        NetpLog(( "NetpUpdateAutoenrolConfig: Failed to load w32time: 0x%lx\n", NetStatus ));
    }

    if ( hDll != NULL ) {
        FreeLibrary( hDll );
    }

    return NetStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\logonp.c ===
/*++

Copyright (c) 1987-1992  Microsoft Corporation

Module Name:

    logonp.c

Abstract:

    Private Netlogon service routines useful by both the Netlogon service
    and others that pass mailslot messages to/from the Netlogon service.

Author:

    Cliff Van Dyke (cliffv) 7-Jun-1991

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntsam.h>      // Needed by netlogon.h

#include <windef.h>
#include <winbase.h>

#include <lmcons.h>     // General net defines

#include <align.h>      // ROUND_UP_POINTER ...
#include <debuglib.h>   // IF_DEBUG()
#include <lmerr.h>      // System Error Log definitions
#include <lmapibuf.h>   // NetapipBufferAllocate
#include <netdebug.h>   // DBGSTATIC ...
#include <netlib.h>     // NetpMemoryAllcate(
#include <netlogon.h>   // Definition of mailslot messages
#include <stdlib.h>     // C library functions (rand, etc)
#include <logonp.h>     // These routines
#include <time.h>       // time() function from C runtime

#ifdef WIN32_CHICAGO
#include "ntcalls.h"
#endif // WIN32_CHICAGO

BOOLEAN SeedRandomGen = FALSE;


VOID
NetpLogonPutOemString(
    IN LPSTR String,
    IN DWORD MaxStringLength,
    IN OUT PCHAR * Where
    )

/*++

Routine Description:

    Put an ascii string into a mailslot buffer.

Arguments:

    String - Zero terminated ASCII string to put into the buffer.

    MaxStringLength - Maximum number of bytes to copy to the buffer (including
        the zero byte).  If the string is longer than this, it is silently
        truncated.

    Where - Indirectly points to the current location in the buffer.  The
        'String' is copied to the current location.  This current location is
        updated to point to the byte following the zero byte.

Return Value:

    None.

--*/

{
    while ( *String != '\0' && MaxStringLength-- > 0 ) {
        *((*Where)++) = *(String++);
    }
    *((*Where)++) = '\0';
}


VOID
NetpLogonPutUnicodeString(
    IN LPWSTR String OPTIONAL,
    IN DWORD MaxStringLength,
    IN OUT PCHAR * Where
    )

/*++

Routine Description:

    Put a UNICODE string into a mailslot buffer.

    UNICODE strings always appear at a 2-byte boundary in the message.

Arguments:

    String - Zero terminated UNICODE string to put into the buffer.
        If not specified, a zero length string will be put into the buffer.

    MaxStringLength - Maximum number of bytes to copy to the buffer (including
        the zero byte).  If the string is longer than this, it is silently
        truncated.

    Where - Indirectly points to the current location in the buffer.  The
        current location is first adjusted to a 2-byte boundary. The 'String'
        is then copied to the current location.  This current location is
        updated to point to the byte following the zero character.

Return Value:

    None.

--*/

{
    LPWSTR Uwhere;

    //
    // Convert NULL to a zero length string.
    //

    if ( String == NULL ) {
        String = L"";
    }

    //
    // Align the unicode string on a WCHAR boundary.
    //     All message structure definitions account for this alignment.
    //

    Uwhere = ROUND_UP_POINTER( *Where, ALIGN_WCHAR );
    if ( (PCHAR)Uwhere != *Where ) {
        **Where = '\0';
    }

    while ( *String != '\0' && MaxStringLength-- > 0 ) {
        *(Uwhere++) = *(String++);
    }
    *(Uwhere++) = '\0';

    *Where = (PCHAR) Uwhere;
}


VOID
NetpLogonPutDomainSID(
    IN PCHAR Sid,
    IN DWORD SidLength,
    IN OUT PCHAR * Where
    )

/*++

Routine Description:

    Put a Domain SID into a message buffer.

    Domain SID always appears at a 4-byte boundary in the message.

Arguments:

    Sid - pointer to the sid to be placed in the buffer.

    SidLength - length of the SID.

    Where - Indirectly points to the current location in the buffer.  The
        current location is first adjusted to a 4-byte boundary. The
        'Sid' is then copied to the current location.  This current location
        is updated to point to the location just following the Sid.

Return Value:

    None.

--*/

{
    PCHAR Uwhere;

    //
    // Avoid aligning the data if there is no SID,
    //

    if ( SidLength == 0 ) {
        return;
    }

    //
    // Align the current location to point 4-byte boundary.
    //

    Uwhere = ROUND_UP_POINTER( *Where, ALIGN_DWORD );

    //
    // fill up void space.
    //

    while ( Uwhere > *Where ) {
        *(*Where)++ = '\0';
    }

    //
    // copy SID into the buffer
    //

    RtlMoveMemory( *Where, Sid, SidLength );

    *Where += SidLength;
}


VOID
NetpLogonPutBytes(
    IN LPVOID Data,
    IN DWORD Size,
    IN OUT PCHAR * Where
    )

/*++

Routine Description:

    Put binary data into a mailslot buffer.

Arguments:

    Data - Pointer to the data to be put into the buffer.

    Size - Number of bytes to copy to the buffer.

    Where - Indirectly points to the current location in the buffer.  The
        'Data' is copied to the current location.  This current location is
        updated to point to the byte following the end of the data.

Return Value:

    None.

--*/

{
    while ( Size-- > 0 ) {
        *((*Where)++) = *(((LPBYTE)(Data))++);
    }
}



DWORD
NetpLogonGetMessageVersion(
    IN PVOID Message,
    IN PDWORD MessageSize,
    OUT PULONG Version
    )

/*++

Routine Description:

    Determine the version of the message.

    The last several bytes of the message are inspected for a LM 2.0 and LM NT
    token.

    Message size is reduced to remove the token from message after
    version check.

Arguments:

    Message - Points to a buffer containing the message.

    MessageSize - When called this has the number of bytes in the
        message buffer including the token bytes. On return this size will
        be "Token bytes" less.

    Version - Returns the "version" bits from the message.

Return Value:

    LMUNKNOWN_MESSAGE - Neither a LM 2.0 nor LM NT message of known
                            version.

    LNNT_MESSAGE - Message is from LM NT.

    LM20_MESSAGE - Message is from LM 2.0.

--*/

{
    PUCHAR End = ((PUCHAR)Message) + *MessageSize - 1;
    ULONG VersionFlag;

    if ( (*MessageSize > 2) &&
            (*End == LM20_TOKENBYTE) &&
                (*(End-1) == LM20_TOKENBYTE) ) {

        if ( (*MessageSize > 4) &&
                (*(End-2) == LMNT_TOKENBYTE) &&
                        (*(End-3) == LMNT_TOKENBYTE) ) {

            if ( *MessageSize < (4 + sizeof(ULONG)) ) {

                *MessageSize -= 4;
                *Version = 0;
                return LMUNKNOWNNT_MESSAGE;
            }

            *MessageSize -= 8;

            //
            // get the version flag from message
            //

            VersionFlag = SmbGetUlong( (End - 3 - sizeof(ULONG)) );
            *Version = VersionFlag;

            //
            // if NETLOGON_NT_VERSION_1 bit is set in the version flag
            // then this version of software can process this message.
            // otherwise it can't so return error.
            //

            if( VersionFlag & NETLOGON_NT_VERSION_1) {
                return LMNT_MESSAGE;
            }

            return LMUNKNOWNNT_MESSAGE;

        } else {
            *MessageSize -= 2;
            *Version = 0;
            return LM20_MESSAGE;
        }
    //
    // Detect the token placed in the next to last byte of the PRIMARY_QUERY
    // message from newer (8/8/94) WFW and Chicago clients.  This byte (followed
    // by a LM20_TOKENBYTE) indicates the client is WAN-aware and sends the
    // PRIMARY_QUERY to the DOMAIN<1B> name.  As such, BDC on the same subnet need
    // not respond to this query.
    //
    } else if ( (*MessageSize > 2) &&
            (*End == LM20_TOKENBYTE) &&
                (*(End-1) == LMWFW_TOKENBYTE) ) {
        *MessageSize -= 2;
        *Version = 0;
        return LMWFW_MESSAGE;
    }


    *Version = 0;
    return LMUNKNOWN_MESSAGE;
}



BOOL
NetpLogonGetOemString(
    IN PVOID Message,
    IN DWORD MessageSize,
    IN OUT PCHAR *Where,
    IN DWORD MaxStringLength,
    OUT LPSTR *String
    )

/*++

Routine Description:

    Determine if an ASCII string in a message buffer is valid.

Arguments:

    Message - Points to a buffer containing the message.

    MessageSize - The number of bytes in the message buffer.

    Where - Indirectly points to the current location in the buffer.  The
        string at the current location is validated (i.e., checked to ensure
        its length is within the bounds of the message buffer and not too
        long).  If the string is valid, this current location is updated
        to point to the byte following the zero byte in the message buffer.

    MaxStringLength - Maximum length (in bytes) of the string including
        the zero byte.  If the string is longer than this, an error is returned.

    String - Returns a pointer to the validated string.

Return Value:

    TRUE - the string is valid.

    FALSE - the string is invalid.

--*/

{
    //
    // Validate that the current location is within the buffer
    //

    if ( ((*Where) < (PCHAR)Message) ||
         (MessageSize <= (DWORD)((*Where) - (PCHAR)Message)) ) {
        return FALSE;
    }

    //
    // Limit the string to the number of bytes remaining in the message buffer.
    //

    if ( MessageSize - ((*Where) - (PCHAR)Message) < MaxStringLength ) {
        MaxStringLength = MessageSize - (DWORD)((*Where) - (PCHAR)Message);
    }

    //
    // Loop try to find the end of string.
    //

    *String = *Where;

    while ( MaxStringLength-- > 0 ) {
        if ( *((*Where)++) == '\0' ) {
            return TRUE;
        }
    }
    return FALSE;

}


BOOL
NetpLogonGetUnicodeString(
    IN PVOID Message,
    IN DWORD MessageSize,
    IN OUT PCHAR *Where,
    IN DWORD MaxStringSize,
    OUT LPWSTR *String
    )

/*++

Routine Description:

    Determine if a UNICODE string in a message buffer is valid.

    UNICODE strings always appear at a 2-byte boundary in the message.

Arguments:

    Message - Points to a buffer containing the message.

    MessageSize - The number of bytes in the message buffer.

    Where - Indirectly points to the current location in the buffer.  The
        string at the current location is validated (i.e., checked to ensure
        its length is within the bounds of the message buffer and not too
        long).  If the string is valid, this current location is updated
        to point to the byte following the zero byte in the message buffer.

    MaxStringSize - Maximum size (in bytes) of the string including
        the zero byte.  If the string is longer than this, an error is
        returned.

    String - Returns a pointer to the validated string.

Return Value:

    TRUE - the string is valid.

    FALSE - the string is invalid.

--*/

{
    LPWSTR Uwhere;
    DWORD MaxStringLength;

    //
    // Align the unicode string on a WCHAR boundary.
    //

    *Where = ROUND_UP_POINTER( *Where, ALIGN_WCHAR );

    //
    // Validate that the current location is within the buffer
    //

    if ( ((*Where) < (PCHAR)Message) ||
         (MessageSize <= (DWORD)((*Where) - (PCHAR)Message)) ) {
        return FALSE;
    }

    //
    // Limit the string to the number of bytes remaining in the message buffer.
    //

    if ( MessageSize - ((*Where) - (PCHAR)Message) < MaxStringSize ) {
        MaxStringSize = MessageSize - (DWORD)((*Where) - (PCHAR)Message);
    }

    //
    // Loop try to find the end of string.
    //

    Uwhere = (LPWSTR) *Where;
    MaxStringLength = MaxStringSize / sizeof(WCHAR);
    *String = Uwhere;

    while ( MaxStringLength-- > 0 ) {
        if ( *(Uwhere++) == '\0' ) {
            *Where = (PCHAR) Uwhere;
            return TRUE;
        }
    }
    return FALSE;

}

#ifndef WIN32_CHICAGO

BOOL
NetpLogonGetDomainSID(
    IN PVOID Message,
    IN DWORD MessageSize,
    IN OUT PCHAR *Where,
    IN DWORD SIDSize,
    OUT PCHAR *Sid
    )

/*++

Routine Description:

    Determine if a Domain SID in a message buffer is valid and return
    the pointer that is pointing to the SID.

    Domain SID always appears at a 4-byte boundary in the message.

Arguments:

    Message - Points to a buffer containing the message.

    MessageSize - The number of bytes in the message buffer.

    Where - Indirectly points to the current location in the buffer.  The
        string at the current location is validated (i.e., checked to ensure
        its length is within the bounds of the message buffer and not too
        long).  If the string is valid, this current location is updated
        to point to the byte following the zero byte in the message buffer.

    SIDSize - size (in bytes) of the SID. If there is not
        enough bytes in the buffer remaining, an error is returned.
        SIDSize should be non-zero.

    String - Returns a pointer to the validated SID.

Return Value:

    TRUE - the SID is valid.

    FALSE - the SID is invalid.

--*/

{
    DWORD LocalSIDSize;

    //
    // Align the current pointer to a DWORD boundary.
    //

    *Where = ROUND_UP_POINTER( *Where, ALIGN_DWORD );

    //
    // Validate that the current location is within the buffer
    //

    if ( ((*Where) < (PCHAR)Message) ||
         (MessageSize <= (DWORD)((*Where) - (PCHAR)Message)) ) {
        return FALSE;
    }

    //
    // If there are less bytes in the message buffer left than we
    // anticipate, return error.
    //

    if ( MessageSize - ((*Where) - (PCHAR)Message) < SIDSize ) {
        return(FALSE);
    }

    //
    // validate SID.
    //

    LocalSIDSize = RtlLengthSid( *Where );

    if( LocalSIDSize != SIDSize ) {
        return(FALSE);
    }

    *Sid = *Where;
    *Where += LocalSIDSize;

    return(TRUE);

}
#endif // WIN32_CHICAGO


BOOL
NetpLogonGetBytes(
    IN PVOID Message,
    IN DWORD MessageSize,
    IN OUT PCHAR *Where,
    IN DWORD DataSize,
    OUT LPVOID Data
    )

/*++

Routine Description:

    Copy binary data from  a message buffer.

Arguments:

    Message - Points to a buffer containing the message.

    MessageSize - The number of bytes in the message buffer.

    Where - Indirectly points to the current location in the buffer.  The
        data at the current location is validated (i.e., checked to ensure
        its length is within the bounds of the message buffer and not too
        long).  If the data is valid, this current location is updated
        to point to the byte following the data in the message buffer.

    DataSize - Size (in bytes) of the data.

    Data - Points to a location to return the valid data.

Return Value:

    TRUE - the data is valid.

    FALSE - the data is invalid (e.g., DataSize is too big for the buffer.

--*/

{
    //
    // Validate that the current location is within the buffer
    //

    if ( ((*Where) < (PCHAR)Message) ||
         (MessageSize <= (DWORD)((*Where) - (PCHAR)Message)) ) {
        return FALSE;
    }

    //
    // Ensure the entire data fits in the byte remaining in the message buffer.
    //

    if ( MessageSize - ((*Where) - (PCHAR)Message) < DataSize ) {
        return FALSE;
    }

    //
    // Copy the data from the message to the caller's buffer.
    //

    while ( DataSize-- > 0 ) {
        *(((LPBYTE)(Data))++) = *((*Where)++);
    }

    return TRUE;

}


BOOL
NetpLogonGetDBInfo(
    IN PVOID Message,
    IN DWORD MessageSize,
    IN OUT PCHAR *Where,
    OUT PDB_CHANGE_INFO Data
)
/*++

Routine Description:

    Get Database info structure from mailsolt buffer.

Arguments:

    Message - Points to a buffer containing the message.

    MessageSize - The number of bytes in the message buffer.

    Where - Indirectly points to the current location in the buffer.  The
        data at the current location is validated (i.e., checked to ensure
        its length is within the bounds of the message buffer and not too
        long).  If the data is valid, this current location is updated
        to point to the byte following the data in the message buffer.

    Data - Points to a location to return the database info structure.

Return Value:

    TRUE - the data is valid.

    FALSE - the data is invalid (e.g., DataSize is too big for the buffer.

--*/
{
    //
    // Validate that the current location is within the buffer
    //

    if ( ((*Where) < (PCHAR)Message) ||
         (MessageSize <= (DWORD)((*Where) - (PCHAR)Message)) ) {
        return FALSE;
    }

    //
    // Ensure the entire data fits in the byte remaining in the message buffer.
    //

    if ( ( MessageSize - ((*Where) - (PCHAR)Message) ) <
                    sizeof( DB_CHANGE_INFO ) ) {
        return FALSE;
    }

    if( NetpLogonGetBytes( Message,
                        MessageSize,
                        Where,
                        sizeof(Data->DBIndex),
                        &(Data->DBIndex) ) == FALSE ) {

        return FALSE;

    }

    if( NetpLogonGetBytes( Message,
                        MessageSize,
                        Where,
                        sizeof(Data->LargeSerialNumber),
                        &(Data->LargeSerialNumber) ) == FALSE ) {

        return FALSE;

    }

    return ( NetpLogonGetBytes( Message,
                        MessageSize,
                        Where,
                        sizeof(Data->NtDateAndTime),
                        &(Data->NtDateAndTime) ) );



}


#ifndef WIN32_CHICAGO

LPWSTR
NetpLogonOemToUnicode(
    IN LPSTR Ansi
    )

/*++

Routine Description:

    Convert an ASCII (zero terminated) string to the corresponding UNICODE
    string.

Arguments:

    Ansi - Specifies the ASCII zero terminated string to convert.


Return Value:

    NULL - There was some error in the conversion.

    Otherwise, it returns a pointer to the zero terminated UNICODE string in
    an allocated buffer.  The buffer can be freed using NetpMemoryFree.

--*/

{
    OEM_STRING AnsiString;
    UNICODE_STRING UnicodeString;

    RtlInitString( &AnsiString, Ansi );

    UnicodeString.MaximumLength =
        (USHORT) RtlOemStringToUnicodeSize( &AnsiString );

    UnicodeString.Buffer = NetpMemoryAllocate( UnicodeString.MaximumLength );

    if ( UnicodeString.Buffer == NULL ) {
        return NULL;
    }

    if(!NT_SUCCESS( RtlOemStringToUnicodeString( &UnicodeString,
                                                  &AnsiString,
                                                  FALSE))){
        NetpMemoryFree( UnicodeString.Buffer );
        return NULL;
    }

    return UnicodeString.Buffer;

}


LPSTR
NetpLogonUnicodeToOem(
    IN LPWSTR Unicode
    )

/*++

Routine Description:

    Convert an UNICODE (zero terminated) string to the corresponding ASCII
    string.

Arguments:

    Unicode - Specifies the UNICODE zero terminated string to convert.


Return Value:

    NULL - There was some error in the conversion.

    Otherwise, it returns a pointer to the zero terminated ASCII string in
    an allocated buffer.  The buffer can be freed using NetpMemoryFree.

--*/

{
    OEM_STRING AnsiString;
    UNICODE_STRING UnicodeString;

    RtlInitUnicodeString( &UnicodeString, Unicode );

    AnsiString.MaximumLength =
        (USHORT) RtlUnicodeStringToOemSize( &UnicodeString );

    AnsiString.Buffer = NetpMemoryAllocate( AnsiString.MaximumLength );

    if ( AnsiString.Buffer == NULL ) {
        return NULL;
    }

    if(!NT_SUCCESS( RtlUpcaseUnicodeStringToOemString( &AnsiString,
                                                       &UnicodeString,
                                                       FALSE))){
        NetpMemoryFree( AnsiString.Buffer );
        return NULL;
    }

    return AnsiString.Buffer;

}
#endif // WIN32_CHICAGO


NET_API_STATUS
NetpLogonWriteMailslot(
    IN LPWSTR MailslotName,
    IN LPVOID Buffer,
    IN DWORD BufferSize
    )

/*++

Routine Description:

    Write a message to a named mailslot

Arguments:

    MailslotName - Unicode name of the mailslot to write to.

    Buffer - Data to write to the mailslot.

    BufferSize - Number of bytes to write to the mailslot.

Return Value:

    NT status code for the operation

--*/

{
    NET_API_STATUS NetStatus;
    HANDLE MsHandle;
    DWORD BytesWritten;

#ifdef WIN32_CHICAGO
    UNICODE_STRING UnicodeName;
    ANSI_STRING AnsiName;
    NTSTATUS Status;
#endif // WIN32_CHICAGO
    //
    //  Open the mailslot
    //

    IF_DEBUG( LOGON ) {
#ifndef WIN32_CHICAGO
        NetpKdPrint(( "[NetpLogonWriteMailslot] OpenFile of '%ws'\n",
                      MailslotName ));
#endif // WIN32_CHICAGO
    }

    //
    // make sure that the mailslot name is of the form \\server\mailslot ..
    //

    NetpAssert( (wcsncmp( MailslotName, L"\\\\", 2) == 0) );

#ifndef WIN32_CHICAGO
    MsHandle = CreateFileW(
                        MailslotName,
                        GENERIC_WRITE,
                        FILE_SHARE_WRITE | FILE_SHARE_READ,
                        NULL,                   // Supply better security ??
                        OPEN_ALWAYS,            // Create if it doesn't exist
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );                 // No template
#else // WIN32_CHICAGO

    MyRtlInitUnicodeString(&UnicodeName, MailslotName);
    AnsiName.Buffer = NULL;
    Status = MyRtlUnicodeStringToAnsiString(&AnsiName, &UnicodeName, TRUE);

    IF_DEBUG( LOGON ) {
#ifdef WIN32_CHICAGO
    if ( Status == STATUS_SUCCESS ) {
        NlPrint(( NL_MAILSLOT, "[NetpLogonWriteMailslot] OpenFile of '%s'\n",
                      AnsiName.Buffer));
    } else {
        NlPrint(( NL_MAILSLOT, "[NetpLogonWriteMailslot] Cannot create AnsiName\n" ));
    }
#endif // WIN32_CHICAGO
    }

    if ( Status != STATUS_SUCCESS ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    MsHandle = CreateFile(
                        AnsiName.Buffer,
                        GENERIC_WRITE,
                        FILE_SHARE_WRITE | FILE_SHARE_READ,
                        NULL,                   // Supply better security ??
                        OPEN_ALWAYS,            // Create if it doesn't exist
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );                 // No template

    if ( AnsiName.Buffer != NULL ) {
        MyRtlFreeAnsiString( &AnsiName );
    }
#endif // WIN32_CHICAGO

    if ( MsHandle == (HANDLE) -1 ) {
        NetStatus = GetLastError();
        IF_DEBUG( LOGON ) {
#ifndef WIN32_CHICAGO
            NetpKdPrint(( "[NetpLogonWriteMailslot] OpenFile failed %ld\n",
                          NetStatus ));
#else // WIN32_CHICAGO
            NlPrint(( NL_MAILSLOT, "[NetpLogonWriteMailslot] OpenFile failed %ld\n",
                          NetStatus ));
#endif // WIN32_CHICAGO
        }

        //
        // Map the generic status code to something more reasonable.
        //
        if ( NetStatus == ERROR_FILE_NOT_FOUND ||
             NetStatus == ERROR_PATH_NOT_FOUND ) {
            NetStatus = NERR_NetNotStarted;
        }
        return NetStatus;
    }

    //
    // Write the message to it.
    //

    if ( !WriteFile( MsHandle, Buffer, BufferSize, &BytesWritten, NULL)){
        NetStatus = GetLastError();
        IF_DEBUG( LOGON ) {
#ifndef WIN32_CHICAGO
            NetpKdPrint(( "[NetpLogonWriteMailslot] WriteFile failed %ld\n",
                          NetStatus ));
#else // WIN32_CHICAGO
            NlPrint(( NL_MAILSLOT, "[NetpLogonWriteMailslot] WriteFile failed %ld\n",
                          NetStatus ));
#endif // WIN32_CHICAGO
        }
        (VOID)CloseHandle( MsHandle );
        return NetStatus;
    }

    if (BytesWritten < BufferSize) {
        IF_DEBUG( LOGON ) {
#ifndef WIN32_CHICAGO
            NetpKdPrint((
                "[NetpLogonWriteMailslot] WriteFile byte written %ld %ld\n",
                BytesWritten,
                BufferSize));
#else // WIN32_CHICAGO
            NlPrint((
                NL_MAILSLOT, "[NetpLogonWriteMailslot] WriteFile byte written %ld %ld\n",
                BytesWritten,
                BufferSize));
#endif // WIN32_CHICAGO
        }
        (VOID)CloseHandle( MsHandle );
        return ERROR_UNEXP_NET_ERR;
    }

    //
    // Close the handle
    //

    if ( !CloseHandle( MsHandle ) ) {
        NetStatus = GetLastError();
        IF_DEBUG( LOGON ) {
#ifndef WIN32_CHICAGO
            NetpKdPrint(( "[NetpLogonWriteMailslot] CloseHandle failed %ld\n",
                          NetStatus ));
#else // WIN32_CHICAGO
            NlPrint(( NL_MAILSLOT, "[NetpLogonWriteMailslot] CloseHandle failed %ld\n",
                          NetStatus ));
#endif // WIN32_CHICAGO
        }
        return NetStatus;
    }

    return NERR_Success;
}

#define RESPONSE_MAILSLOT_PREFIX  "\\MAILSLOT\\NET\\GETDCXXX"
#define RESP_PRE_LEN         sizeof(RESPONSE_MAILSLOT_PREFIX)

// Amount of time to wait for a response
#define READ_MAILSLOT_TIMEOUT 5000  // 5 seconds
// number of broadcastings to get DC before reporting DC not found error
#define MAX_DC_RETRIES  3


NET_API_STATUS
NetpLogonCreateRandomMailslot(
    IN LPSTR path,
    OUT PHANDLE MsHandle
    )
/*++

Routine Description:

    Create a unique mailslot and return the handle to it.

Arguments:

    path - Returns the full path mailslot name

    MsHandle - Returns an open handle to the mailslot that was made.

Return Value:

    NERR_SUCCESS - Success, path contains the path to a unique mailslot.
    otherwise,  Unable to create a unique mailslot.

--*/
{
    DWORD i;
    DWORD play;
    char    *   ext_ptr;
    NET_API_STATUS NetStatus;
    CHAR LocalPath[RESP_PRE_LEN+4]; // 4 bytes for local mailslot prefix
    DWORD LastOneToTry;


    //
    // We are creating a name of the form \mailslot\net\getdcXXX,
    // where XXX are numbers that are "randomized" to allow
    // multiple mailslots to be opened.
    //

    lstrcpyA(path, RESPONSE_MAILSLOT_PREFIX);

    //
    // Compute the first number to use
    //

    if( SeedRandomGen == FALSE ) {

        //
        // SEED random generator
        //

        srand( (unsigned)time( NULL ) );
        SeedRandomGen = TRUE;

    }

    LastOneToTry = rand() % 1000;

    //
    // Now try and create a unique filename
    // Cannot use current_loc or back up from that and remain DBCS compat.
    //

    ext_ptr = path + lstrlenA(path) - 3;

    for ( i = LastOneToTry + 1;  i != LastOneToTry ; i++) {

        //
        // Wrap back to zero if we reach 1000
        //

        if ( i == 1000 ) {
            i = 0;
        }

        //
        // Convert the number to ascii
        //

        play = i;
        ext_ptr[0] = (char)((play / 100) + '0');
        play -= (play / 100) * 100;

        ext_ptr[1] = (char)((play / 10) + '0');
        ext_ptr[2] = (char)((play % 10) + '0');

        //
        // Try to create the mailslot.
        // Fail the create if the mailslot already exists.
        //

        lstrcpyA( LocalPath, "\\\\." );
        lstrcatA( LocalPath, path );

        *MsHandle = CreateMailslotA( LocalPath,
                                    MAX_RANDOM_MAILSLOT_RESPONSE,
                                    READ_MAILSLOT_TIMEOUT,
                                    NULL );     // security attributes

        //
        // If success,
        //  return the handle to the caller.
        //

        if ( *MsHandle != INVALID_HANDLE_VALUE ) {

            return(NERR_Success);
        }

        //
        // If there is any error other than the mailsloat already exists,
        //  return that error to the caller.
        //

        NetStatus = GetLastError();

        if ( NetStatus != ERROR_ALREADY_EXISTS) {
            return(NetStatus);
        }

    }
    return(NERR_InternalError); // !!! All 999 mailslots exist
}


BOOLEAN
NetpLogonTimeHasElapsed(
    IN LARGE_INTEGER StartTime,
    IN DWORD Timeout
    )
/*++

Routine Description:

    Determine if "Timeout" milliseconds has has elapsed since StartTime.

Arguments:

    StartTime - Specifies an absolute time when the event started (100ns units).

    Timeout - Specifies a relative time in milliseconds.  0xFFFFFFFF indicates
        that the time will never expire.

Return Value:

    TRUE -- iff Timeout milliseconds have elapsed since StartTime.

--*/
{
    LARGE_INTEGER TimeNow;
    LARGE_INTEGER ElapsedTime;
    LARGE_INTEGER Period;

    //
    // If the period to too large to handle (i.e., 0xffffffff is forever),
    //  just indicate that the timer has not expired.
    //
    // (0xffffffff is a little over 48 days).
    //

    if ( Timeout == 0xffffffff ) {
        return FALSE;
    }

    //
    // Compute the elapsed time since we last authenticated
    //

    GetSystemTimeAsFileTime( (PFILETIME)&TimeNow );
    ElapsedTime.QuadPart = TimeNow.QuadPart - StartTime.QuadPart;

    //
    // Compute Period from milliseconds into 100ns units.
    //

    Period.QuadPart = UInt32x32To64( Timeout, 10000 );


    //
    // If the elapsed time is negative (totally bogus) or greater than the
    //  maximum allowed, indicate that enough time has passed.
    //

    if ( ElapsedTime.QuadPart < 0 || ElapsedTime.QuadPart > Period.QuadPart ) {
        return TRUE;
    }

    return FALSE;
}

#ifndef WIN32_CHICAGO

NET_API_STATUS
NlWriteFileForestTrustList (
    IN LPWSTR FileSuffix,
    IN PDS_DOMAIN_TRUSTSW ForestTrustList,
    IN ULONG ForestTrustListCount
    )

/*++

Routine Description:

    Set the Forest Trust List into the binary file to save it across reboots.

Arguments:

    FileSuffix - Specifies the name of the file to write (relative to the
        Windows directory)

    ForestTrustList - Specifies a list of trusted domains.

    ForestTrustListCount - Number of entries in ForestTrustList

Return Value:

    Status of the operation.

--*/
{
    NET_API_STATUS NetStatus;
    PDS_DISK_TRUSTED_DOMAIN_HEADER RecordBuffer = NULL;
    PDS_DISK_TRUSTED_DOMAINS LogEntry;
    ULONG RecordBufferSize;
    ULONG Index;
    LPBYTE Where;

    //
    // Determine the size of the file
    //

    RecordBufferSize = ROUND_UP_COUNT( sizeof(PDS_DISK_TRUSTED_DOMAIN_HEADER), ALIGN_WORST );

    for ( Index=0; Index<ForestTrustListCount; Index++ ) {
        RecordBufferSize += sizeof( DS_DISK_TRUSTED_DOMAINS );

        if ( ForestTrustList[Index].DomainSid != NULL ) {
            RecordBufferSize += RtlLengthSid( ForestTrustList[Index].DomainSid );
        }

        if ( ForestTrustList[Index].NetbiosDomainName != NULL ) {
            RecordBufferSize += wcslen(ForestTrustList[Index].NetbiosDomainName) * sizeof(WCHAR) + sizeof(WCHAR);
        }

        if ( ForestTrustList[Index].DnsDomainName != NULL ) {
            RecordBufferSize += wcslen(ForestTrustList[Index].DnsDomainName) * sizeof(WCHAR) + sizeof(WCHAR);
        }

        RecordBufferSize = ROUND_UP_COUNT( RecordBufferSize, ALIGN_WORST );
    }

    //
    // Allocate a buffer
    //

    RecordBuffer = LocalAlloc( LMEM_ZEROINIT, RecordBufferSize );

    if ( RecordBuffer == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    Where = (LPBYTE)( RecordBuffer+1 );

    //
    // Copy the Forest Trust List to the buffer.
    //

    RecordBuffer->Version = DS_DISK_TRUSTED_DOMAIN_VERSION;
    LogEntry = (PDS_DISK_TRUSTED_DOMAINS)ROUND_UP_POINTER( (RecordBuffer + 1), ALIGN_WORST );

    for ( Index=0; Index<ForestTrustListCount; Index++ ) {
        ULONG CurrentSize;
        LPBYTE Where;
        ULONG DomainSidSize;
        ULONG NetbiosDomainNameSize;
        ULONG DnsDomainNameSize;


        //
        // Compute the size of this entry.
        //

        CurrentSize = sizeof( DS_DISK_TRUSTED_DOMAINS );

        if ( ForestTrustList[Index].DomainSid != NULL ) {
            DomainSidSize = RtlLengthSid( ForestTrustList[Index].DomainSid );
            CurrentSize += DomainSidSize;
        }

        if ( ForestTrustList[Index].NetbiosDomainName != NULL ) {
            NetbiosDomainNameSize = wcslen(ForestTrustList[Index].NetbiosDomainName) * sizeof(WCHAR) + sizeof(WCHAR);
            CurrentSize += NetbiosDomainNameSize;
        }

        if ( ForestTrustList[Index].DnsDomainName != NULL ) {
            DnsDomainNameSize = wcslen(ForestTrustList[Index].DnsDomainName) * sizeof(WCHAR) + sizeof(WCHAR);
            CurrentSize += DnsDomainNameSize;
        }

        CurrentSize = ROUND_UP_COUNT( CurrentSize, ALIGN_WORST );


        //
        // Put the constant size fields in the buffer.
        //

        LogEntry->EntrySize = CurrentSize;
        LogEntry->Flags = ForestTrustList[Index].Flags;
        LogEntry->ParentIndex = ForestTrustList[Index].ParentIndex;
        LogEntry->TrustType = ForestTrustList[Index].TrustType;
        LogEntry->TrustAttributes = ForestTrustList[Index].TrustAttributes;
        LogEntry->DomainGuid = ForestTrustList[Index].DomainGuid;

        //
        // Copy the variable length entries.
        //

        Where = (LPBYTE) (LogEntry+1);
        if ( ForestTrustList[Index].DomainSid != NULL ) {
            RtlCopyMemory( Where, ForestTrustList[Index].DomainSid, DomainSidSize );
            Where += DomainSidSize;
            LogEntry->DomainSidSize = DomainSidSize;
        }

        if ( ForestTrustList[Index].NetbiosDomainName != NULL ) {
            RtlCopyMemory( Where, ForestTrustList[Index].NetbiosDomainName, NetbiosDomainNameSize );
            Where += NetbiosDomainNameSize;
            LogEntry->NetbiosDomainNameSize = NetbiosDomainNameSize;
        }

        if ( ForestTrustList[Index].DnsDomainName != NULL ) {
            RtlCopyMemory( Where, ForestTrustList[Index].DnsDomainName, DnsDomainNameSize );
            Where += DnsDomainNameSize;
            LogEntry->DnsDomainNameSize = DnsDomainNameSize;
        }

        Where = ROUND_UP_POINTER( Where, ALIGN_WORST );

        ASSERT( (ULONG)(Where-(LPBYTE)LogEntry) == CurrentSize );
        ASSERT( (ULONG)(Where-(LPBYTE)RecordBuffer) <=RecordBufferSize );

        //
        // Move on to the next entry.
        //

        LogEntry = (PDS_DISK_TRUSTED_DOMAINS)Where;

    }

    //
    // Write the buffer to the file.
    //


    NetStatus = NlWriteBinaryLog(
                    FileSuffix,
                    (LPBYTE) RecordBuffer,
                    RecordBufferSize );

    if ( NetStatus != NO_ERROR ) {
#ifdef _NETLOGON_SERVER
        LPWSTR MsgStrings[2];

        MsgStrings[0] = FileSuffix,
        MsgStrings[1] = (LPWSTR) NetStatus;

        NlpWriteEventlog (NELOG_NetlogonFailedFileCreate,
                          EVENTLOG_ERROR_TYPE,
                          (LPBYTE) &NetStatus,
                          sizeof(NetStatus),
                          MsgStrings,
                          2 | NETP_LAST_MESSAGE_IS_NETSTATUS );
#endif // _NETLOGON_SERVER
        goto Cleanup;
    }


    //
    // Be tidy.
    //
Cleanup:
    if ( RecordBuffer != NULL ) {
        LocalFree( RecordBuffer );
    }

    return NetStatus;

}


NET_API_STATUS
NlWriteBinaryLog(
    IN LPWSTR FileSuffix,
    IN LPBYTE Buffer,
    IN ULONG BufferSize
    )
/*++

Routine Description:

    Write a buffer to a file.

Arguments:

    FileSuffix - Specifies the name of the file to write (relative to the
        Windows directory)

    Buffer - Buffer to write

    BufferSize - Size (in bytes) of buffer

Return Value:

    None.

--*/
{
    NET_API_STATUS NetStatus;

    LPWSTR FileName = NULL;

    UINT WindowsDirectoryLength;
    HANDLE FileHandle = INVALID_HANDLE_VALUE;
    ULONG BytesWritten;

    ULONG CurrentSize;


    //
    // Allocate a block to build the file name in
    //

    FileName = LocalAlloc( LMEM_ZEROINIT, sizeof(WCHAR) * (MAX_PATH+1) );

    if ( FileName == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }


    //
    // Build the name of the log file
    //

    WindowsDirectoryLength = GetSystemWindowsDirectoryW(
                                FileName,
                                sizeof(WCHAR) * (MAX_PATH+1) );

    if ( WindowsDirectoryLength == 0 ) {

        NetStatus = GetLastError();
        NetpKdPrint(( "NlWriteBinaryLog: Unable to GetWindowsDirectoryW (%ld)\n",
                  NetStatus ));
        goto Cleanup;
    }

    if ( WindowsDirectoryLength + wcslen( FileSuffix ) + 1 >= MAX_PATH ) {

        NetpKdPrint(( "NlWriteBinaryLog: file name length is too long \n" ));
        NetStatus = ERROR_INVALID_NAME;
        goto Cleanup;

    }

    wcscat( FileName, FileSuffix );

    //
    // Create a file to write to.
    //  If it exists already then truncate it.
    //

    FileHandle = CreateFileW(
                        FileName,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ,        // allow backups and debugging
                        NULL,                   // Supply better security ??
                        CREATE_ALWAYS,          // Overwrites always
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );                 // No template

    if ( FileHandle == INVALID_HANDLE_VALUE) {

        NetStatus = GetLastError();
        NetpKdPrint(( "NlWriteBinaryLog: %ws: Unable to create file: %ld \n",
                 FileName,
                 NetStatus));

        goto Cleanup;
    }

    if ( !WriteFile( FileHandle,
                     Buffer,
                     BufferSize,
                     &BytesWritten,
                     NULL ) ) {  // Not Overlapped

        NetStatus = GetLastError();
        NetpKdPrint(( "NlWriteBinaryLog: %ws: Unable to WriteFile. %ld\n",
                  FileName,
                  NetStatus ));

        goto Cleanup;
    }

    if ( BytesWritten !=  BufferSize) {
        NetpKdPrint(( "NlWriteBinaryLog: %ws: Write bad byte count %ld s.b. %ld\n",
                FileName,
                BytesWritten,
                BufferSize ));

        NetStatus = ERROR_INSUFFICIENT_BUFFER;
        goto Cleanup;
    }

    NetStatus = NO_ERROR;


    //
    // Be tidy.
    //
Cleanup:
    if ( FileName != NULL ) {
        LocalFree( FileName );
    }
    if ( FileHandle != INVALID_HANDLE_VALUE ) {
        CloseHandle( FileHandle );
    }
    return NetStatus;

}
#endif // WIN32_CHICAGO
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\listfunc.c ===
/*++

Copyright (c) 1989-91 Microsoft Corporation

Module Name:

    listfunc.c

Abstract:

    This module contains functions which canonicalize and traverse lists.
    The following functions are defined:

        NetpwListCanonicalize
        NetpwListTraverse
        (FixupAPIListElement)

Author:

    Danny Glasser (dannygl) 14 June 1989

Notes:

    There are currently four types of lists supported by these
    functions:

        UI/Service input list - Leading and trailing delimiters
            are allowed, multiple delimiters are allowed between
            elements, and the full set of delimiter characters is
            allowed (space, tab, comma, and semicolon).  Note that
            elements which contain a delimiter character must be
            quoted.  Unless explicitly specified otherwise, all UIs
            and services must accept all input lists in this format.

        API list - Leading and trailing delimiters are not allowed,
            multiple delimiters are not allowed between elements,
            and there is only one delimiter character (space).  Elements
            which contain a delimiter character must be quoted.
            Unless explicitly specified otherwise, all lists provided
            as input to API functions must be in this format, and all
            lists generated as output by API functions will be in this
            format.

        Search-path list - The same format as an API list, except that
            the delimiter is a semicolon.  This list is designed as
            input to the DosSearchPath API.

        Null-null list - Each element is terminated by a null
            byte and the list is terminated by a null string
            (that is, a null byte immediately following the null
            byte which terminates the last element).  Clearly,
            multiple, leading, and trailing delimiters are not
            supported.  Elements do not need to be quoted.  An empty
            null-null list is simply a null string.  This list format
            is designed for internal use.

    NetpListCanonicalize() accepts all UI/Service, API, and null-null
    lists on input and produces API, search-path, and null-null lists
    on output.  NetpListTraverse() supports null-null lists only.

Revision History:

--*/

#include "nticanon.h"

//
// prototypes
//

STATIC
DWORD
FixupAPIListElement(
    IN  LPTSTR  Element,
    IN  LPTSTR* pElementTerm,
    IN  LPTSTR  BufferEnd,
    IN  TCHAR   cDelimiter
    );

//
// routines
//


NET_API_STATUS
NetpwListCanonicalize(
    IN  LPTSTR  List,
    IN  LPTSTR  Delimiters OPTIONAL,
    OUT LPTSTR  Outbuf,
    IN  DWORD   OutbufLen,
    OUT LPDWORD OutCount,
    OUT LPDWORD PathTypes,
    IN  DWORD   PathTypesLen,
    IN  DWORD   Flags
    )

/*++

Routine Description:

    NetpListCanonicalize produces the specified canonical version of
    the list, validating and/or canonicalizing the individual list
    elements as specified by <Flags>.

Arguments:

    List        - The list to canonicalize.

    Delimiters  - A string of valid delimiters for the input list.
                  A null pointer or null string indicates that the
                  input list is in null-null format.

    Outbuf      - The place to store the canonicalized version of the list.

    OutbufLen   - The size, in bytes, of <Outbuf>.

    OutCount    - The place to store the number of elements in the
                  canonicalized list.

    PathTypes   - The array in which to store the types of each of the paths
                  in the canonicalized list.  This parameter is only used if
                  the NAMETYPE portion of the flags parameter is set to
                  NAMETYPE_PATH.

    PathTypesLen- The number of elements in <pflPathTypes>.

    Flags       - Flags to determine operation.  Currently defined values are:

                    rrrrrrrrrrrrrrrrrrrrmcootttttttt

                  where:

                    r = Reserved.  MBZ.

                    m = If set, multiple, leading, and trailing delimiters are
                        allowed in the input list.

                    c = If set, each of the individual list elements are
                        validated and canonicalized.  If not set, each of the
                        individual list elements are validated only.  This
                        bit is ignored if the NAMETYPE portion of the flags is
                        set to NAMETYPE_COPYONLY.

                    o = Type of output list.  Currently defined types are
                        API, search-path, and null-null.

                    t = The type of the objects in the list, for use in
                        canonicalization or validation.  If this value is
                        NAMETYPE_COPYONLY, type is irrelevant; a canonical list
                        is generated but no interpretation of the list elements
                        is done.  If this value is NAMETYPE_PATH, the list
                        elements are assumed to be pathnames; NetpPathType is
                        run on each element, the results are stored in
                        <pflPathTypes>, and NetpPathCanonicalize is run on
                        each element (if appropriate).  Any other values for
                        this is considered to be the type of the list elements
                        and is passed to NetpName{Validate,Canonicalize} as
                        appropriate.

                  Manifest values for these flags are defined in NET\H\ICANON.H.

Return Value:

    0 if successful.
    The error number (> 0) if unsuccessful.

    Possible error returns include:

        ERROR_INVALID_PARAMETER
        NERR_TooManyEntries
        NERR_BufTooSmall

--*/

{
    NET_API_STATUS rc = 0;
    BOOL    NullInputDelimiter;
    LPTSTR  next_string;
    DWORD   len;
    DWORD   list_len = 0;           // cumulative input buffer length
    LPTSTR  Input;
    LPTSTR  OutPtr;
    LPTSTR  OutbufEnd;
    DWORD   OutElementCount;
    DWORD   DelimiterLen;
    LPTSTR  NextQuote;
    LPTSTR  ElementBegin;
    LPTSTR  ElementEnd;
    TCHAR   cElementEndBackup;
    LPTSTR  OutElementEnd;
    BOOL    DelimiterInElement;
    DWORD   OutListType;
    TCHAR   OutListDelimiter;


#ifdef CANONDBG
    DbgPrint("NetpwListCanonicalize\n");
#endif

    if (Flags & INLC_FLAGS_MASK_RESERVED) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Determine if our input list is in null-null format.  We do
    // this first because we need to use it to do proper GP-fault probing
    // on <List>.
    //

    NullInputDelimiter = !ARGUMENT_PRESENT(Delimiters) || (*Delimiters == TCHAR_EOS);

    //
    // Validate address parameters (i.e. GP-fault tests) and accumulate string
    // lengths (accumulate: now there's a word from a past I'd rather forget)
    //

    list_len = STRLEN(List) + 1;

    if (NullInputDelimiter) {

        //
        // This is a null-null list; stop when we find a null string.
        //

        next_string = List + list_len;
        do {

            //
            // Q: Is the compiler smart enough to do the right thing with
            // these +1s?
            //

            len = STRLEN(next_string);
            list_len += len + 1;
            next_string += len + 1;
        } while (len);
    }

    if (ARGUMENT_PRESENT(Delimiters)) {
        STRLEN(Delimiters);
    }

    if ((Flags & INLC_FLAGS_MASK_NAMETYPE) == NAMETYPE_PATH && PathTypesLen > 0) {
        PathTypes[0] = PathTypes[PathTypesLen - 1] = 0;
    }

    *OutCount = 0;

    //
    // Initialize variables
    //

    Input = List;
    OutPtr = Outbuf;
    OutbufEnd = Outbuf + OutbufLen;
    OutElementCount = 0;

    NullInputDelimiter = !ARGUMENT_PRESENT(Delimiters) || (*Delimiters == TCHAR_EOS);
    OutListType = Flags & INLC_FLAGS_MASK_OUTLIST_TYPE;

    //
    // Skip leading delimiters
    //
    // NOTE:  We don't have to both to do this for a null-null list,
    //        because if it has a leading delimiter then it's an
    //        empty list.
    //

    if (!NullInputDelimiter) {
        DelimiterLen = STRSPN(Input, Delimiters);

        if (DelimiterLen > 0 && !(Flags & INLC_FLAGS_MULTIPLE_DELIMITERS)) {
            return ERROR_INVALID_PARAMETER;
        }

        Input += DelimiterLen;
    }

    //
    // We validate the output list type here are store the delimiter
    // character.
    //
    // NOTE:  Later on, we rely on the fact that the delimiter character
    //        is not zero if the output list is either API or search-path.
    //

    if (OutListType == OUTLIST_TYPE_API) {
        OutListDelimiter = LIST_DELIMITER_CHAR_API;
    } else if (OutListType == OUTLIST_TYPE_SEARCHPATH) {
        OutListDelimiter = LIST_DELIMITER_CHAR_SEARCHPATH;
    } else if (OutListType == OUTLIST_TYPE_NULL_NULL) {
        OutListDelimiter = TCHAR_EOS;
    } else {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Loop until we've reached the end of the input list
    // OR until we encounter an error
    //

    while (*Input != TCHAR_EOS) {

        //
        // Find the beginning and ending characters of the list element
        //

        //
        // Handle quoted strings separately
        //

        if (!NullInputDelimiter && *Input == LIST_QUOTE_CHAR) {

            //
            // Find the next quote; return an error if there is none
            // or if it's the next character.
            //

            NextQuote = STRCHR(Input + 1, LIST_QUOTE_CHAR);

            if (NextQuote == NULL || NextQuote == Input + 1) {
                return ERROR_INVALID_PARAMETER;
            }

            ElementBegin = Input + 1;
            ElementEnd = NextQuote;
        } else {
            ElementBegin = Input;
            ElementEnd = Input
                            + (NullInputDelimiter
                                ? STRLEN(Input)
                                : STRCSPN(Input, Delimiters)
                              );
        }

        //
        // Set the end character to null so that we can treat the list
        // element as a string, saving its real value for later.
        //
        // WARNING:  Once we have done this, we should not return from
        //           this function until we've restored this character,
        //           since we don't want to trash the string the caller
        //           passed us.  If we are above the label
        //           <INLC_RestoreEndChar> and we encounter an error
        //           we should set <rc> to the error code and jump
        //           to that label (which will restore the character and
        //           return if the error is non-zero).
        //

        cElementEndBackup = *ElementEnd;
        *ElementEnd = TCHAR_EOS;

        //
        // Copy the list element to the output buffer, validating its
        // name or canonicalizing it as specified by the user.
        //

        switch(Flags & INLC_FLAGS_MASK_NAMETYPE) {
        case NAMETYPE_PATH:

            //
            // Make sure that that the <PathTypes> array is big enough
            //

            if (OutElementCount >= PathTypesLen) {
                rc = NERR_TooManyEntries;
                goto INLC_RestoreEndChar;
            }

            //
            // Determine if we only want to validate or if we also
            // want to canonicalize.
            //

            if (Flags & INLC_FLAGS_CANONICALIZE) {

                //
                // We need to set the type to 0 before calling
                // NetpwPathCanonicalize.
                //

                PathTypes[OutElementCount] = 0;

                //
                // Call NetICanonicalize and abort if it fails
                //

                rc = NetpwPathCanonicalize(
                        ElementBegin,
                        OutPtr,
                        (DWORD)(OutbufEnd - OutPtr),
                        NULL,
                        &PathTypes[OutElementCount],
                        0L
                        );
            } else {

                //
                // Just validate the name and determine its type
                //

                rc = NetpwPathType(
                        ElementBegin,
                        &PathTypes[OutElementCount],
                        0L
                        );

                //
                // If this succeeded, attempt to copy it into the buffer
                //

                if (rc == 0) {
                    if (OutbufEnd - OutPtr < ElementEnd - ElementBegin + 1) {
                        rc = NERR_BufTooSmall;
                    } else {
                        STRCPY(OutPtr, ElementBegin);
                    }
                }
            }

            if (rc) {
                goto INLC_RestoreEndChar;
            }

            //
            // Determine the end of the element (for use below)
            //

            OutElementEnd = STRCHR(OutPtr, TCHAR_EOS);

            //
            // Do fix-ups for API list format (enclose element in
            // quotes, if necessary, and replace terminating null
            // with the list delimiter).
            //

            if (OutListDelimiter != TCHAR_EOS) {
                rc = FixupAPIListElement(
                        OutPtr,
                        &OutElementEnd,
                        OutbufEnd,
                        OutListDelimiter
                        );
                if (rc) {
                    goto INLC_RestoreEndChar;
                }
            }
            break;

        case NAMETYPE_COPYONLY:

            //
            // Determine if this element needs to be quoted
            //

            DelimiterInElement = (OutListDelimiter != TCHAR_EOS)
                && (STRCHR(ElementBegin, OutListDelimiter) != NULL);

            //
            // See if there's enough room in the output buffer for
            // this element; abort if there isn't.
            //
            // (ElementEnd - ElementBegin) is the number of bytes
            // in the element.  We add 1 for the element separator and
            // an additional 2 if we need to enclose the element in quotes.
            //

            if (OutbufEnd - OutPtr < ElementEnd - ElementBegin + 1 + DelimiterInElement * 2) {
                rc = NERR_BufTooSmall;
                goto INLC_RestoreEndChar;
            }

            //
            // Start the copying; set pointer to output string
            //

            OutElementEnd = OutPtr;

            //
            // Put in leading quote, if appropriate
            //

            if (DelimiterInElement) {
                *OutElementEnd++ = LIST_QUOTE_CHAR;
            }

            //
            // Copy input to output and advance end pointer
            //

            STRCPY(OutElementEnd, ElementBegin);
            OutElementEnd += ElementEnd - ElementBegin;

            //
            // Put in trailing quote, if appropriate
            //

            if (DelimiterInElement) {
                *OutElementEnd++ = LIST_QUOTE_CHAR;
            }

            //
            // Store delimiter
            //

            *OutElementEnd = OutListDelimiter;
            break;

        default:

            //
            // If this isn't one of the special types, we assume that it's
            // a type with meaning to NetpwNameValidate and
            // NetpwNameCanonicalize.  We call the appropriate one of these
            // functions and let it validate the name type and the name,
            // passing back any error it returns.
            //

            //
            // Determine if we only want to validate or if we also
            // want to canonicalize.
            //

            if (Flags & INLC_FLAGS_CANONICALIZE) {
                rc = NetpwNameCanonicalize(
                        ElementBegin,
                        OutPtr,
                        (DWORD)(OutbufEnd - OutPtr),
                        Flags & INLC_FLAGS_MASK_NAMETYPE,
                        0L
                        );
            } else {
                rc = NetpwNameValidate(
                        ElementBegin,
                        Flags & INLC_FLAGS_MASK_NAMETYPE,
                        0L
                        );

                //
                // If this succeeded, attempt to copy it into the buffer
                //

                if (rc == 0) {
                    if (OutbufEnd - OutPtr < ElementEnd - ElementBegin + 1) {
                        rc = NERR_BufTooSmall;
                    } else {
                        STRCPY(OutPtr, ElementBegin);
                    }
                }
            }

            if (rc) {
                goto INLC_RestoreEndChar;
            }

            //
            // Determine the end of the element (for use below)
            //

            OutElementEnd = STRCHR(OutPtr, TCHAR_EOS);

            //
            // Do fix-ups for API list format (enclose element in
            // quotes, if necessary, and replace terminating null
            // with the list delimiter).
            //

            if (OutListDelimiter != TCHAR_EOS) {
                rc = FixupAPIListElement(
                        OutPtr,
                        &OutElementEnd,
                        OutbufEnd,
                        OutListDelimiter
                        );
                if (rc) {
                    goto INLC_RestoreEndChar;
                }
            }
            break;
        }

        //
        // End of switch statement
        //

INLC_RestoreEndChar:

        //
        // Restore the character at <ElementEnd>; return if one of the
        // above tasks failed.
        //

        *ElementEnd = cElementEndBackup;

        if (rc) {
            return rc;
        }

        //
        // Skip past the last input character if it's a quote character
        //

        if (*ElementEnd == LIST_QUOTE_CHAR) {
            ElementEnd++;
        }

        //
        // Skip delimiter(s)
        //

        if (!NullInputDelimiter) {

            //
            // Determine the number of delimiters and set the input
            // pointer to point past them.
            //

            DelimiterLen = STRSPN(ElementEnd, Delimiters);
            Input = ElementEnd + DelimiterLen;

            //
            // Return an error if:
            //
            // - there are multiple delimiters and the multiple delimiters
            //   flag isn't set
            // - we aren't at the end of the list and there are no
            //   delimiters
            // - we are at the end of the list, there is a delimiter
            //   and the multiple delimiters flag isn't set
            //

            if (DelimiterLen > 1 && !(Flags & INLC_FLAGS_MULTIPLE_DELIMITERS)) {
                return ERROR_INVALID_PARAMETER;
            }
            if (*Input != TCHAR_EOS && DelimiterLen == 0) {
                return ERROR_INVALID_PARAMETER;
            }
            if (*Input == TCHAR_EOS && DelimiterLen > 0 && !(Flags & INLC_FLAGS_MULTIPLE_DELIMITERS)) {
                return ERROR_INVALID_PARAMETER;
            }
        } else {

            //
            // Since this is a null-null list, we know we've already
            // found at least one delimiter.  We don't have to worry about
            // multiple delimiters, because a second delimiter indicates
            // the end of the list.
            //

            Input = ElementEnd + 1;
        }

        //
        // Update output list pointer and output list count
        //

        OutPtr = OutElementEnd + 1;
        OutElementCount++;
    }

    //
    // End of while loop
    //


    //
    // If the input list was empty, set the output buffer to be a null
    // string.  Otherwise, stick the list terminator at the end of the
    // output buffer.
    //

    if (OutElementCount == 0) {
        if (OutbufLen < 1) {
            return NERR_BufTooSmall;
        }
        *Outbuf = TCHAR_EOS;
    } else {
        if (OutListType == OUTLIST_TYPE_NULL_NULL) {

            //
            // Make sure there's room for one more byte
            //

            if (OutPtr >= OutbufEnd) {
                return NERR_BufTooSmall;
            }
            *OutPtr = TCHAR_EOS;
        } else {

            //
            // NOTE:  It's OK to move backwards in the string here because
            //        we know then OutPtr points one byte past the
            //        delimiter which follows the last element in the list.
            //        This does not violate DBCS as long as the delimiter
            //        is a single-byte character.
            //

            *(OutPtr - 1) = TCHAR_EOS;
        }
    }

    //
    // Set the count of elements in the list
    //

    *OutCount = OutElementCount;

    //
    // We're done; return with success
    //

    return 0;
}


LPTSTR
NetpwListTraverse(
    IN  LPTSTR  Reserved OPTIONAL,
    IN  LPTSTR* pList,
    IN  DWORD   Flags
    )

/*++

Routine Description:

    Traverse a list which has been converted to null-null form by
    NetpwListCanonicalize. NetpwListTraverse returns a pointer to the first
    element in the list, and modifies the list pointer parameter to point to the
    next element of the list.

Arguments:

    Reserved- A reserved far pointer.  Must be NULL.

    pList   - A pointer to the pointer to the beginning of the list. On return
              this will point to the next element in the list or NULL if we
              have reached the end

    Flags   - Flags to determine operation.  Currently MBZ.

Return Value:

    A pointer to the first element in the list, or NULL if the list
    is empty.

--*/

{
    LPTSTR  FirstElement;

    UNREFERENCED_PARAMETER(Reserved);
    UNREFERENCED_PARAMETER(Flags);

    //
    // Produce an assertion error if the reserved parameter is not NULL
    // or the flags parameter is no zero.
    //

    //
    // KEEP - This code is ifdef'd out because NETAPI.DLL won't build
    //        with the standard C version of assert().  This code
    //        should either be replaced or the #if 0 should be removed
    //        when we get a standard Net assert function.
    //

#ifdef CANONDBG
    NetpAssert((Reserved == NULL) && (Flags == 0));
#endif

    //
    // Return immediately if the pointer to the list pointer is NULL,
    // if the list pointer itself is NULL, or if the list is a null
    // string (which marks the end of the null-null list).
    //

    if (pList == NULL || *pList == NULL || **pList == TCHAR_EOS) {
        return NULL;
    }

    //
    // Save a pointer to the first element
    //

    FirstElement = *pList;

    //
    // Update the list pointer to point to the next element
    //

//    *pList += STRLEN(FirstElement) + 1;
    *pList = STRCHR(FirstElement, TCHAR_EOS) + 1;

    //
    // Return the pointer to the first element
    //

    return FirstElement;
}


STATIC
DWORD
FixupAPIListElement(
    IN  LPTSTR  Element,
    IN  LPTSTR* pElementTerm,
    IN  LPTSTR  BufferEnd,
    IN  TCHAR   DelimiterChar
    )

/*++

Routine Description:

    FixupAPIListElement Fixes-up a list element which has been copied into the
    output buffer so that it conforms to API list format.

    FixupAPIListElement takes an unquoted, null-terminated list element
    (normally, which has been copied into the output buffer by strcpy() or by
    Netpw{Name,Path}Canonicalize) and translates it into the format expected by
    API and search-path lists. Specifically, it surrounds the element with quote
    characters if it contains a list delimiter character, and it replaces the
    null terminator with the API list delimiter.

Arguments:
    Element     - A pointer to the beginning of the null-terminated element.

    pElementTerm- A pointer to the pointer to the element's (null) terminator.

    BufferEnd   - A pointer to the end of the output buffer (actually, one byte
                  past the end of the buffer).

    DelimiterChar- The list delimiter character.

Return Value:

    0 if successful.

    NERR_BufTooSmall if the buffer doesn't have room for the additional
    quote characters.

--*/

{
    //
    // See if the element contains a delimiter; if it does, it needs to
    // be quoted.
    //

    if (STRCHR(Element, DelimiterChar) != NULL) {

        //
        // Make sure that the output buffer has room for two more
        // characters (the quotes).
        //

        if (BufferEnd - *pElementTerm <= 2 * sizeof(*BufferEnd)) {
            return NERR_BufTooSmall;
        }

        //
        // Shift the string one byte to the right, stick quotes on either
        // side, and update the end pointer.  The element itself with be
        // stored in the range [Element + 1, *pElementTerm].
        //

        MEMMOVE(Element + sizeof(*Element), Element, (int)(*pElementTerm - Element));
        *Element = LIST_QUOTE_CHAR;
        *(*pElementTerm + 1) = LIST_QUOTE_CHAR;
        *pElementTerm += 2;
    }

    //
    // Put a delimiter at the end of the element
    //

    **pElementTerm = DelimiterChar;

    //
    // Return with success
    //

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\loghours.c ===
/*++

Copyright (c) 1987-1993  Microsoft Corporation

Module Name:

    loghours.c

Abstract:

    Private routines to support rotation of logon hours between local time
    and GMT time.

Author:

    Cliff Van Dyke (cliffv) 16-Mar-93

Environment:

    User mode only.
    Contains NT-specific code.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <winbase.h>

#include <limits.h>
#include <math.h>

#include <lmcons.h>
#include <lmaccess.h>
#include <loghours.h>



BOOLEAN
NetpRotateLogonHoursPhase1(
    IN BOOL  ConvertToGmt,
    OUT PULONG RotateCount
    )

/*++

Routine Description:

    Determine the amount to rotate the logon hours by to convert to/from GMT

Arguments:

    ConvertToGmt -
        True to convert the logon hours from local time to GMT relative
        False to convert the logon hours from GMT relative to local time

    RotateCount - Returns the number of bits to shift by.

Return Value:

    TRUE if the RotateCount could be computed
    FALSE if a RotateCount could not be computed

--*/
{
    RTL_TIME_ZONE_INFORMATION tzi;
    LONG BiasInHours;
    NTSTATUS Status;

    //
    // Get the timezone data from the registry
    //

    Status = RtlQueryTimeZoneInformation( &tzi );
    if ( !NT_SUCCESS(Status) ) {
        return FALSE;
    }

    //
    // Compute the amount to rotate the logon hours by
    //
    // Round the bias in minutes to the closest bias in hours.
    // Take into consideration that Bias can be negative.
    // Do this by forcing the Bias to be positive, rounding,
    // then adjusting it back negative again.
    //

    ASSERT( tzi.Bias > -(24*60) );
    BiasInHours = ((tzi.Bias + (24*60) + 30)/60) - 24;

    if ( !ConvertToGmt ) {
        BiasInHours = - BiasInHours;
    }

    *RotateCount = BiasInHours;
    return TRUE;

}


BOOLEAN
NetpRotateLogonHoursPhase2(
    IN PBYTE LogonHours,
    IN DWORD UnitsPerWeek,
    IN LONG  RotateCount
    )

/*++

Routine Description:

    Rotate the LogonHours bit mask by the required amount.


Arguments:

    LogonHours - Pointer to LogonHour bit mask

    UnitsPerWeek - Number of bits in the bit mask. Must be UNITS_PER_WEEK (168).

    RotateCount - Number of bits to rotate by.  Must be between 31 and -31.
        Negative means to rotate left.
        Positive means to rotate right.

Return Value:

    TRUE if the rotation succeeded.
    FALSE if a parameter was out of range

--*/
{
    //
    // Useful constants
    //

#define DWORDS_PER_WEEK ((UNITS_PER_WEEK+31)/32)
#define BYTES_PER_WEEK  (UNITS_PER_WEEK/8)

    DWORD AlignedLogonHours[DWORDS_PER_WEEK+1];
    LONG i;

    BOOLEAN RotateLeft;

    //
    // Ensure there are 8 bits per byte,
    //  32 bits per DWORD and
    //  units per week is even number of bytes.
    //

    ASSERT( CHAR_BIT == 8 );
    ASSERT( sizeof(DWORD) * CHAR_BIT == 32 );
    ASSERT( UNITS_PER_WEEK/8*8 == UNITS_PER_WEEK );


    //
    // Validate the input parameters
    //

    if ( UnitsPerWeek != UNITS_PER_WEEK ) {
        ASSERT( UnitsPerWeek == UNITS_PER_WEEK );
        return FALSE;
    }

    if ( RotateCount == 0 ) {
        return TRUE;
    }

    RotateLeft = (RotateCount < 0);
    RotateCount = labs( RotateCount );
    if ( RotateCount > 31 ) {
        ASSERT ( RotateCount <= 31 );
        return FALSE;
    }


    //
    // Do the left rotate.
    //

    if (RotateLeft) {


        //
        // Copy the logon hours to a DWORD aligned buffer.
        //
        //  Duplicate the first dword at the end of the buffer to make
        //  the rotation code trivial.
        //

        RtlCopyMemory(AlignedLogonHours, LogonHours, BYTES_PER_WEEK );

        RtlCopyMemory( ((PBYTE)AlignedLogonHours)+BYTES_PER_WEEK,
                        LogonHours,
                        sizeof(DWORD) );

        //
        // Actually rotate the data.
        //

        for ( i=0; i < DWORDS_PER_WEEK; i++ ) {
            AlignedLogonHours[i] =
                (AlignedLogonHours[i] >> RotateCount) |
                (AlignedLogonHours[i+1] << (32-RotateCount));
        }

        //
        // Copy the logon hours back to the input buffer.
        //

        RtlCopyMemory( LogonHours, AlignedLogonHours, BYTES_PER_WEEK );


    //
    // Do the right rotate.
    //

    } else {


        //
        // Copy the logon hours to a DWORD aligned buffer.
        //
        // Duplicate the last DWORD at the front of the buffer to make
        //  the rotation code trivial.
        //

        RtlCopyMemory( &AlignedLogonHours[1], LogonHours, BYTES_PER_WEEK );
        RtlCopyMemory( AlignedLogonHours,
                       &LogonHours[BYTES_PER_WEEK-4],
                        sizeof(DWORD));

        //
        // Actually rotate the data.
        //

        for ( i=DWORDS_PER_WEEK-1; i>=0; i-- ) {
            AlignedLogonHours[i+1] =
                (AlignedLogonHours[i+1] << RotateCount) |
                (AlignedLogonHours[i] >> (32-RotateCount));
        }

        //
        // Copy the logon hours back to the input buffer.
        //

        RtlCopyMemory( LogonHours, &AlignedLogonHours[1], BYTES_PER_WEEK );

    }

    //
    // Done
    //

    return TRUE;

}



BOOLEAN
NetpRotateLogonHours(
    IN PBYTE LogonHours,
    IN DWORD UnitsPerWeek,
    IN BOOL  ConvertToGmt
    )

/*++

Routine Description:

    Rotate the LogonHours bit mask to/from GMT relative time.


Arguments:

    LogonHours - Pointer to LogonHour bit mask

    UnitsPerWeek - Number of bits in the bit mask. Must be UNITS_PER_WEEK (168).

    ConvertToGmt -
        True to convert the logon hours from local time to GMT relative
        False to convert the logon hours from GMT relative to local time

Return Value:

    TRUE if the rotation succeeded.
    FALSE if a parameter was out of range

--*/
{
    ULONG RotateCount;

    //
    // Break the functionality into two phases so that if the caller is doing
    //  this multiple time, he just calls Phase 1 once and Phase 2 multiple
    //  times.
    //

    if ( !NetpRotateLogonHoursPhase1( ConvertToGmt, &RotateCount ) ) {
        return FALSE;
    }

    return NetpRotateLogonHoursPhase2( LogonHours, UnitsPerWeek, RotateCount );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\luidate.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    luidate.C

Abstract:

    Convert date/time parsing routines

Author:

    Dan Hinsley    (danhi)  06-Jun-1991

Environment:

    User Mode - Win32

Revision History:

    24-Apr-1991     danhi
	32 bit NT version

    06-Jun-1991     Danhi
	Sweep to conform to NT coding style

    01-Oct-1992 JohnRo
        RAID 3556: Added NetpSystemTimeToGmtTime() for DosPrint APIs.

    16-Feb-1993     chuckc
        fixed to _read internation info from system

    22-Feb-1993     yihsins
        Moved from netcmd\map32\pdate.c. And added LUI_ParseDateSinceStartOfDay.

    11-Jun-1998     mattt
        Fixed Y2K bug in parsing year entered as "00" (eg 6/11/00 gets parsed to 6/11/<current year>)

--*/

//
// INCLUDES
//

#include <windows.h>    // IN, LPTSTR, etc.
#include <winerror.h>

#include <stdio.h>		
#include <malloc.h>
#include <time.h>

#include <lmcons.h>
#include <apperr.h>
#include <apperr2.h>
#include <timelib.h>

#include <luidate.h>
#include <luiint.h>
#include <luitext.h>

/*-- manifests --*/

/* max number of fields for either date or time */
#define	PD_MAX_FIELDS		5

/* are we reading a NUMBER, AM/PM selector, MONTHS or YEAR */
#define	PD_END_MARKER		0
#define	PD_NUMBER		1
#define	PD_AMPM       		2
#define	PD_MONTHS       	3
#define PD_YEAR                 4

/* time formats */
#define	PD_24HR			0
#define	PD_AM			1
#define PD_PM			2

/* internal error code */
#define	PD_SUCCESS		0
#define	PD_ERROR_NO_MATCH	1
#define PD_ERROR_INTERNAL	2
#define PD_ERROR_END_OF_INPUT	3

/* indices */
#define DAYS			0
#define MONTHS			1
#define YEARS			2
#define HOURS			0
#define MINUTES			1
#define SECONDS			2
#define AMPM			3

#define WHITE_SPACE		" \t\n"
#define DIGITS			"0123456789"


/*-- types internal to this module --*/

/* describe how we expect to parse a field within a date or time */
typedef struct date_field_desc {
    CHAR *		sep ;		/* the separator before this field */
    CHAR *		fmt ;		/* format descriptor, scanf() style */
    UCHAR		typ ;		/* NUMBER or AMPM or MONTHS */
    UCHAR		pos ;		/* position - depends on country */
} date_fdesc ;

/* an array of short values, each corresponding to a field read */
typedef SHORT date_data[PD_MAX_FIELDS] ;

/*-- forward declarations --*/

/* type passed in to WParseDate */
#define SECONDS_SINCE_1970           0
#define SECONDS_SINCE_START_OF_DAY   1

static SHORT  WParseDate( date_fdesc **d_desc ,
		          date_fdesc **t_desc ,
			  CHAR	      *inbuf  ,
			  CHAR	     **nextchr,
			  time_t      *time,
                          USHORT       nTimeType   ) ;

static SHORT  setup_data( CHAR **bufferp ,
			  CHAR **freep,
		          USHORT slist_bufsiz ,
			  CHAR * * local_inbuf,
			  PCHAR inbuf,
		          SHORT country,
			  PUSHORT parselen ) ;

static SHORT  read_format( CHAR * *   inbuf,
		           date_fdesc *desc,
		           date_data  data ) ;

static SHORT  convert_to_secs( date_data  t_data,
			       time_t   *time) ;

static SHORT  convert_to_abs( date_data  d_data,
		              date_data  t_data,
			      time_t   *time) ;

static SHORT convert_to_24hr( date_data time ) ;

static VOID advance_date( date_data  d_data) ;

static time_t seconds_since_1970( date_data d_data,
		                date_data t_data ) ;

static time_t days_so_far( int d, int m, int y ) ;

/* international time/date info */

typedef struct _MY_COUNTRY_INFO
{
     CHAR   szDateSeparator[16] ;
     CHAR   szTimeSeparator[16] ;
     USHORT fsDateFmt ;
     CHAR   szAMString[16] ;
     CHAR   szPMString[16] ;
} MY_COUNTRY_INFO ;

void GetInternationalInfo(MY_COUNTRY_INFO *pcountry_info) ;

/*-- static data --*/

static searchlist_data ampm_data[] = {
    {APE2_GEN_TIME_AM1, PD_AM},
    {APE2_GEN_TIME_AM2, PD_AM},
    {APE2_GEN_TIME_AM3, PD_AM},
    {APE2_GEN_TIME_PM1, PD_PM},
    {APE2_GEN_TIME_PM2, PD_PM},
    {APE2_GEN_TIME_PM3, PD_PM},
    {0,0}
} ;

static searchlist_data months_data[] = {
    {APE2_TIME_JANUARY,		1},
    {APE2_TIME_FEBRUARY,	2},
    {APE2_TIME_MARCH,		3},
    {APE2_TIME_APRIL,		4},
    {APE2_TIME_MAY,		5},
    {APE2_TIME_JUNE,		6},
    {APE2_TIME_JULY,		7},
    {APE2_TIME_AUGUST,		8},
    {APE2_TIME_SEPTEMBER,	9},
    {APE2_TIME_OCTOBER,		10},
    {APE2_TIME_NOVEMBER,	11},
    {APE2_TIME_DECEMBER,	12},
    {APE2_TIME_JANUARY_ABBREV,	1},
    {APE2_TIME_FEBRUARY_ABBREV,	2},
    {APE2_TIME_MARCH_ABBREV,	3},
    {APE2_TIME_APRIL_ABBREV,	4},
    {APE2_TIME_MAY_ABBREV,	5},
    {APE2_TIME_JUNE_ABBREV,	6},
    {APE2_TIME_JULY_ABBREV,	7},
    {APE2_TIME_AUGUST_ABBREV,	8},
    {APE2_TIME_SEPTEMBER_ABBREV,9},
    {APE2_TIME_OCTOBER_ABBREV,	10},
    {APE2_TIME_NOVEMBER_ABBREV,	11},
    {APE2_TIME_DECEMBER_ABBREV,	12},
    {0,0}
} ;

#define MONTHS_IN_YEAR	(12)
#define NUM_AMPM_LIST 	(sizeof(ampm_data)/sizeof(ampm_data[0]))
#define NUM_MONTHS_LIST (sizeof(months_data)/sizeof(months_data[0]))
#define SLIST_BUFSIZ  	(640)

/*
 * The list containing valid am,pm strings
 */
static CHAR LUI_usr_am[16];
static CHAR LUI_usr_pm[16];

static searchlist 	ampm_list[NUM_AMPM_LIST + 4] = {
	{LUI_usr_am,PD_AM},	
	{LUI_usr_pm,PD_PM},	
	{LUI_txt_am,PD_AM},	
	{LUI_txt_pm,PD_PM},
    } ;	

/*
 * NOTE - we init the first 12 hardwired months
 * and get the rest from the message file
 */
static searchlist 	months_list[NUM_MONTHS_LIST + MONTHS_IN_YEAR] = {
	{LUI_txt_january,1},
	{LUI_txt_february,2},
	{LUI_txt_march,3},
	{LUI_txt_april,4},
	{LUI_txt_may,5},
	{LUI_txt_june,6},
	{LUI_txt_july,7},
	{LUI_txt_august,8},
	{LUI_txt_september,9},
	{LUI_txt_october,10},
	{LUI_txt_november,11},	
	{LUI_txt_december,12},
    } ;	

/*
 * built in formats for scanf - we will add to these strings as needed
 * when we read stuff from DosGetCtryInfo(). Note that a string is
 * defined to be anything which is not a known separator.
 */
static CHAR pd_fmt_null[1]	 = "" ;
static CHAR pd_fmt_d_sep1[8]	 = "/-" ;	/* date separator for NUMBERs */
static CHAR pd_fmt_d_sep2[8]	 = "/,- \t" ;	/* date separator for MONTHs  */
static CHAR pd_fmt_t_sep[8]	 = ":" ;	/* time separator */
static CHAR pd_fmt_number[8]	 = "%d" ;	/* a number */
static CHAR pd_fmt_string[16]	 = "%[^,- /:\t" ;  /* string, needs ] at end */

/*-- date descriptors (despite verbosity, not as big at it seems)  --*/

static date_fdesc d_desc1[] = {				     /* eg. 3-31-89 */
    {pd_fmt_null,     pd_fmt_number,   	PD_NUMBER,   	1 },
    {pd_fmt_d_sep1,   pd_fmt_number,   	PD_NUMBER,   	0 },
    {pd_fmt_d_sep1,   pd_fmt_number,   	PD_YEAR,   	2 },
    {pd_fmt_null,     pd_fmt_null,     	PD_END_MARKER, 	0 }
} ;

static date_fdesc d_desc2[] = {				     /* eg. 5 Jun 89 */
    {pd_fmt_null,     pd_fmt_number,   	PD_NUMBER,   	0 },
    {pd_fmt_d_sep2,   pd_fmt_string,	PD_MONTHS,   	1 },
    {pd_fmt_d_sep2,   pd_fmt_number,  	PD_YEAR,   	2 },
    {pd_fmt_null,     pd_fmt_null,     	PD_END_MARKER, 	0 }
} ;

static date_fdesc d_desc3[] = {				     /* eg. Jun 5 89 */
    {pd_fmt_null,     pd_fmt_string,	PD_MONTHS,   	1 },
    {pd_fmt_d_sep2,   pd_fmt_number,   	PD_NUMBER,   	0 },
    {pd_fmt_d_sep2,   pd_fmt_number,  	PD_YEAR,   	2 },
    {pd_fmt_null,     pd_fmt_null,     	PD_END_MARKER, 	0 }
} ;

static date_fdesc d_desc4[] = {				      /* eg. 3-31 */
    {pd_fmt_null,     pd_fmt_number,   	PD_NUMBER,   	1 },
    {pd_fmt_d_sep1,   pd_fmt_number,   	PD_NUMBER,   	0 },
    {pd_fmt_null,     pd_fmt_null,     	PD_END_MARKER, 	0 }
} ;

static date_fdesc d_desc5[] = {				      /* eg. 5 Jun */
    {pd_fmt_null,     pd_fmt_number,   	PD_NUMBER,   	0 },
    {pd_fmt_d_sep2,   pd_fmt_string,	PD_MONTHS,   	1 },
    {pd_fmt_null,     pd_fmt_null,     	PD_END_MARKER, 	0 }
} ;

static date_fdesc d_desc6[] = {				      /* eg. Jun 5 */
    {pd_fmt_null,     pd_fmt_string,	PD_MONTHS,   	1 },
    {pd_fmt_d_sep2,   pd_fmt_number,   	PD_NUMBER,   	0 },
    {pd_fmt_null,     pd_fmt_null,     	PD_END_MARKER, 	0 }
} ;

/*-- time descriptors --*/

static date_fdesc t_desc1[] = {				   /* eg. 1:00:00pm */
    {pd_fmt_null,   pd_fmt_number,   	PD_NUMBER,   	0 },
    {pd_fmt_t_sep,  pd_fmt_number,    	PD_NUMBER,   	1 },
    {pd_fmt_t_sep,  pd_fmt_number,    	PD_NUMBER,   	2 },
    {pd_fmt_null,   pd_fmt_string,     	PD_AMPM,   	3 },
    {pd_fmt_null,   pd_fmt_null,     	PD_END_MARKER, 	0 }
} ;

static date_fdesc t_desc2[] = {				   /* eg. 13:00:00 */
    {pd_fmt_null,   pd_fmt_number,   	PD_NUMBER,   	0 },
    {pd_fmt_t_sep,  pd_fmt_number,    	PD_NUMBER,   	1 },
    {pd_fmt_t_sep,  pd_fmt_number,    	PD_NUMBER,   	2 },
    {pd_fmt_null,   pd_fmt_null,     	PD_END_MARKER, 	0 }
} ;

static date_fdesc t_desc3[] = {				    /* eg. 1:00pm */
    {pd_fmt_null,   pd_fmt_number,   	PD_NUMBER,   	0 },
    {pd_fmt_t_sep,  pd_fmt_number,    	PD_NUMBER,   	1 },
    {pd_fmt_null,   pd_fmt_string,     	PD_AMPM,   	3 },
    {pd_fmt_null,   pd_fmt_null,     	PD_END_MARKER, 	0 }
} ;

static date_fdesc t_desc4[] = {				    /* eg. 13:00 */
    {pd_fmt_null,   pd_fmt_number,   	PD_NUMBER,   	0 },
    {pd_fmt_t_sep,  pd_fmt_number,    	PD_NUMBER,   	1 },
    {pd_fmt_null,   pd_fmt_null,     	PD_END_MARKER, 	0 }
} ;

static date_fdesc t_desc5[] = {				    /* eg. 1pm */
    {pd_fmt_null,   pd_fmt_number,  	PD_NUMBER,   	0 },
    {pd_fmt_null,   pd_fmt_string,     	PD_AMPM,   	3 },
    {pd_fmt_null,   pd_fmt_null,     	PD_END_MARKER, 	0 }
} ;

/*-- possible dates & times --*/

/*
 * NOTE - for all the below time/date descriptors, we
 * employ a greedy mechanism - always try longest match first.
 */

/* this is the order we try to parse a date */
static date_fdesc *possible_dates[] = {	
    d_desc1, d_desc2,
    d_desc3, d_desc4,
    d_desc5, d_desc6,
    NULL
    } ;

/* this is the order we try to parse a time */
static date_fdesc *possible_times[] = {
    t_desc1, t_desc2,
    t_desc3, t_desc4,
    t_desc5, NULL
    } ;

/* this is the order we try to parse a 12 hour time */
static date_fdesc *possible_times12[] = {
    t_desc1, t_desc3,
    t_desc5, NULL
    } ;

/* this is the order we try to parse a time */
static date_fdesc *possible_times24[] = {
    t_desc2, t_desc4,
    NULL
    } ;


/*-- exported routines --*/

/*
 * Name: 	LUI_ParseDateTime
 *			will parse the input string (null terminated) for a
 *			date & time or time & date combination. Valid dates
 *			include:
 *				2,June,1989    6/2/89      6/2
 *			Valid times include:
 *				2pm            14:00       2:00P.M.
 *			Full details of formats are documented in pdate.txt,
 *			note that Country Information will be used.
 *		
 * Args:	PCHAR inbuf - string to parse
 *		PLONG time  - will contain time in seconds since midnight 1/1/70
 *			      corresponding to the date if successfully parsed.
 *			      Undefined otherwise.
 *		PUSHORT parselen - length of string parsed
 *		USHORT reserved - not used for now, must be zero.
 *			
 * Returns:	0 if parse successfully,
 *		ERROR_BAD_ARGUMENTS - cannot parse illegal date/time format
 *		ERROR_GEN_FAILURE   - internal error
 * Globals: 	Indirectly, all date/time descriptors, month/year info in this
 *		file. No globals outside of this file is used. However, malloc
 *	   	is called to allocate memory.
 * Statics:	(none) - but see setup_data()
 * Remarks:	(none)
 * Updates:	(none)
 */
SHORT
LUI_ParseDateTime(
    PCHAR inbuf,
    time_t * time,
    PUSHORT parselen,
    USHORT reserved
    )
{
    CHAR *buffer, *local_inbuf, *nextchr ;
    CHAR *freep;			/* pointer to buffer malloc'd by
					   setup data */
    short res ;

    /* pacify compiler */
    if (reserved) ;

    /* will grab memory, setup d_desc, t_desc, local_inbuf */
    if (setup_data(&buffer,&freep,SLIST_BUFSIZ,&local_inbuf,inbuf,0,parselen)
		!= 0)
	return(ERROR_GEN_FAILURE) ;

    /* call the worker function */
    res = WParseDate(possible_dates,possible_times,local_inbuf,&nextchr,
	             (time_t *) time, SECONDS_SINCE_1970 ) ;
    *parselen += (USHORT)(nextchr - local_inbuf) ;
    free(freep) ;
    return(res) ;
}


/*
 * Name: 	LUI_ParseTimeSinceStartOfDay
 *			as LUI_ParseTime, except that the time returned
 *                      is the number of seconds since start of the day
 *                      i.e. 12 midnight.
 */
SHORT
LUI_ParseTimeSinceStartOfDay(
    PCHAR inbuf,
    time_t  * time,
    PUSHORT parselen,
    USHORT reserved
    )
{
    CHAR *buffer, *local_inbuf, *nextchr ;
    CHAR *freep;			/* pointer to buffer malloc'd by
					   setup data */
    short res ;

    /* pacify compiler */
    if (reserved) ;

    /* will grab memory, setup d_desc, t_desc, local_inbuf */
    if (setup_data(&buffer,&freep,SLIST_BUFSIZ,&local_inbuf,inbuf,0,parselen)
		!= 0)
	return(ERROR_GEN_FAILURE) ;

    /* call the worker function */
    res = WParseDate(NULL,possible_times,local_inbuf,&nextchr,time,
                     SECONDS_SINCE_START_OF_DAY ) ;
    *parselen += (USHORT)(nextchr - local_inbuf) ;
    free(freep) ;
    return(res) ;
}


/*-- internal routines for setting up & reading formats --*/

/*
 * setup the field descriptors for date and time,
 * using info from DosGetCtryInfo()
 *
 * we also grab memory here, & split it into 2 - first
 * part for the above, second part for our local copy of
 * the input string in inbuf.
 *
 * side effects - update bufferp, local_inbuf, parselen,
 *     		  and the allocated memory is initialised.
 */
static SHORT
setup_data(
    CHAR **bufferp,
    CHAR **freep,
    USHORT slist_bufsiz,
    CHAR ** local_inbuf,
    PCHAR inbuf,
    SHORT country,
    PUSHORT parselen
    )
{
    USHORT		bytesread ;
    static short 	first_time = TRUE ;
    MY_COUNTRY_INFO     country_info ;

    UNREFERENCED_PARAMETER(country);

    /* skip white space */
    inbuf += (*parselen = (USHORT) strspn(inbuf,WHITE_SPACE)) ;

    /* grab memory */
    if ( (*bufferp = malloc(SLIST_BUFSIZ+strlen(inbuf)+1)) == NULL )
	return(ERROR_GEN_FAILURE) ;

    *freep = *bufferp;

    /*
     * setup local_inbuf
     */
    *local_inbuf  = *bufferp + slist_bufsiz ;
    strcpy((PCHAR)*local_inbuf, inbuf) ;

    /*
     * Get strings for AM/PM
     */
    if (ILUI_setup_list(*bufferp,slist_bufsiz,4,&bytesread,ampm_data,ampm_list))
    {
	free(*bufferp) ;
	return(PD_ERROR_INTERNAL) ;
    }
    slist_bufsiz  -= bytesread ;
    *bufferp       += bytesread ;

    /*
     * Get strings for months
     */
    if (ILUI_setup_list(*bufferp,slist_bufsiz,MONTHS_IN_YEAR,&bytesread,
	months_data,months_list))
    {
	free(*bufferp);
	return(PD_ERROR_INTERNAL) ;
    }
	
    /*
     * no need to the rest if already done
     */
    if (!first_time)
	return(0) ;
    first_time = FALSE ;

    /*
     * Get country info.
     */
    GetInternationalInfo(&country_info) ;

    strcpy( LUI_usr_am, country_info.szAMString );
    strcpy( LUI_usr_pm, country_info.szPMString );

    /*
     * append date separator
     */
    if (strchr(pd_fmt_d_sep1,country_info.szDateSeparator[0]) == NULL)
   	strcat(pd_fmt_d_sep1,country_info.szDateSeparator) ;
    if (strchr(pd_fmt_d_sep2,country_info.szDateSeparator[0]) == NULL)
   	strcat(pd_fmt_d_sep2,country_info.szDateSeparator) ;
    if (strchr(pd_fmt_string,country_info.szDateSeparator[0]) == NULL)
   	strcat(pd_fmt_string,country_info.szDateSeparator) ;

    /*
     * append time separator
     */
    if (strchr(pd_fmt_t_sep,country_info.szTimeSeparator[0]) == NULL)
   	strcat(pd_fmt_t_sep,country_info.szTimeSeparator) ;
    if (strchr(pd_fmt_string,country_info.szTimeSeparator[0]) == NULL)
   	strcat(pd_fmt_string,country_info.szTimeSeparator) ;

    strcat(pd_fmt_string,"]") ;	/* terminate string format */

    /* swap order of fields as needed */
    switch (country_info.fsDateFmt)  {
  	case 0x0000:
  	    /* this is the initialised state */
  	    break ;
  	case 0x0001:
  	    d_desc1[0].pos = d_desc4[0].pos = 0 ;
  	    d_desc1[1].pos = d_desc4[1].pos = 1 ;
  	    break ;
  	case 0x0002:
  	    d_desc1[0].pos = d_desc2[0].pos = 2 ;
  	    d_desc1[1].pos = d_desc2[1].pos = 1 ;
  	    d_desc1[2].pos = d_desc2[2].pos = 0 ;
  	    break ;
  	default:
  	    break ;	/* assume USA */
    }
    return(0) ;
}


/*
 * try reading inbuf using the descriptors in d_desc & t_desc.
 * Returns 0 if ok, error code otherwise.
 *
 * inbuf   -> string to parse
 * d_desc  -> array of date descriptors
 * t_desc  -> array of time descriptors
 * nextchr -> will point to end of string parsed
 * time    -> will contain time parsed
 * nTimeType-> Determines what kind of time is returned.
 *             SECONDS_SINCE_1970 - the number of secs since 1/1/70
 *             SECONDS_SINCE_START_OF_DAY - the number of secs since midnight
 */
static SHORT
WParseDate(
    date_fdesc **d_desc,
    date_fdesc **t_desc,
    CHAR	*inbuf,
    CHAR       **nextchr,
    time_t        *time,
    USHORT       nTimeType
    )
{
    short 	d_index, t_index, res ;
    date_data 	d_data, t_data ;

    /*
     * initialise
     */
    *nextchr = inbuf ;
    memset((CHAR  *)d_data,0,sizeof(d_data)) ;
    memset((CHAR  *)t_data,0,sizeof(t_data)) ;

    /*
     * try all date followed by time combinations
     */
    if (d_desc != NULL)
	for (d_index = 0; d_desc[d_index] != NULL; d_index++)
	{
	    if ((res = read_format(nextchr,d_desc[d_index],d_data)) == 0)
	    {
		/* if time not required, quit here */
		if (t_desc == NULL)
		{
		    return ( convert_to_abs(d_data,t_data,time) ) ;
		}

		/* else we have match for date, see if we can do time */
		for (t_index = 0; t_desc[t_index] != NULL; t_index++)
		{
		    res = read_format(nextchr,t_desc[t_index],t_data) ;
		    if (res == 0 || res == PD_ERROR_END_OF_INPUT)
		    {
			return ( convert_to_abs(d_data,t_data,time) ) ;
		    }
		}
		/* exhausted times formats, backtrack & try next date format */
		*nextchr = inbuf ;
	    }
	}

    /*
     * reset & try all time followed by date combinations
     */
    *nextchr = inbuf ;
    memset((CHAR  *)d_data,0,sizeof(d_data)) ;
    if (t_desc != NULL)
	for (t_index = 0; t_desc[t_index] != NULL; t_index++)
	{
	    if ((res = read_format(nextchr,t_desc[t_index],t_data)) == 0)
	    {
		/* if date not required, quit here */
		if (d_desc == NULL)
		{
                    if (  ( nTimeType == SECONDS_SINCE_START_OF_DAY )
                       && d_desc == NULL )
                        return ( convert_to_secs( t_data, time ) ) ;
                    else
    		  	return ( convert_to_abs(d_data,t_data,time) ) ;
		}

		/* we have match for time, see if we can do date */
		for (d_index = 0; d_desc[d_index] != NULL; d_index++)
		{
		    res = read_format(nextchr,d_desc[d_index],d_data) ;
		    if (res == 0 || res == PD_ERROR_END_OF_INPUT)
		    {
                        if (  ( nTimeType == SECONDS_SINCE_START_OF_DAY )
                           && d_desc == NULL )
                            return ( convert_to_secs( t_data, time ) ) ;
                        else
    		     	    return ( convert_to_abs(d_data,t_data,time) ) ;
		    }
		}
		/* exhausted date formats, back track, try next time format */
		*nextchr = inbuf ;
	    }
	}
    *nextchr = inbuf ;
    return(ERROR_BAD_ARGUMENTS) ;	 /* we give up */
}

/*
 * try reading inbuf using the descriptor desc.
 * the fields read are stored in order in 'data'.
 * Returns 0 if ok, error code otherwise.
 */
static SHORT
read_format(
    CHAR * * inbuf,
    date_fdesc * desc,
    date_data  data
    )
{
    CHAR	buffer[128] ;
    CHAR	*ptr, *oldptr ;
    date_fdesc 	*entry ;
    SHORT	res, i, count ;

    /*
     * initialize & preliminary checks
     */
    if (*inbuf == NULL || **inbuf=='\0')
	return(PD_ERROR_END_OF_INPUT) ;
    memset((CHAR  *)data,0,sizeof(date_data)) ;
    ptr = *inbuf ;
    oldptr = NULL ;


    /*
     * for all fields => we break out when hit END_MARKER
     */
    for (i=0 ; ; i++)
    {
	SHORT value_read ;

	entry = &desc[i] ;
	if (entry->typ == PD_END_MARKER)
	    break ;  /* no more descriptors */

	/*
	 * find the separator  - the ptr may or may not have moved
	 * as a result of the last read operation. If we read a number,
	 * scanf() would have stopped at the first non-numeric char, which
	 * may not be the separator. We would in this case have moved the
	 * ptr ourselves after the scanf().
	 *
	 * In the case of a string like "JAN", scanf() would have stopped at a
	 * separator and we wouldnt have moved it ourselves after the scanf().
	 * So we advance it now to the separator.
	 */
	if (ptr == oldptr) /* ptr unmoved, we need to move it */
	{
	    if (entry->sep[0] == '\0')
	        return(PD_ERROR_INTERNAL) ;      /* cant have NULL separator */
	    if ((ptr = (CHAR *)strpbrk(ptr,entry->sep)) == NULL)
		return(PD_ERROR_NO_MATCH) ;	 /* cant find separator */
	    ptr++;
	}
	else   /* already moved */
	{
	    if (entry->sep[0] != '\0')      /* for NULL separator, do nothing */
	    {
		if (*ptr && !strchr(entry->sep,*ptr)) /* are we at separator */
		    return(PD_ERROR_NO_MATCH) ; /* cant find separator        */
		if (*ptr)
			ptr++;	/* advance past separator     */
	    }
	}

	/*
	 * if we get here, we are past the separator, can go read an item
	 */
	ptr += strspn(ptr,WHITE_SPACE) ;    /* skip white space       */
	if ((count = (USHORT) sscanf(ptr,entry->fmt,&buffer[0])) != 1)
	    return(PD_ERROR_NO_MATCH) ;

	/*
	 * successfully read an item, get value & update pointers
	 */
	res = 0 ;
	if (entry->typ == PD_AMPM)
	    res = ILUI_traverse_slist(buffer,ampm_list,&value_read) ;
	else if (entry->typ == PD_MONTHS)
	    res = ILUI_traverse_slist(buffer,months_list,&value_read) ;
	else
	    value_read = *(SHORT *)(&buffer[0]) ;
	if (res || value_read < 0)
	    return(PD_ERROR_NO_MATCH) ;

	data[entry->pos] = value_read ;


        if ((entry->typ == PD_YEAR) && (0x00 == value_read))
        {
           /* Year 2000 Bug  (Y2K)
              successfully parsed year value of 00 -- we must convert this to be 2000L
              so that convert_to_abs doesn't think explicit entry is missing since it uses
              0s as default markers. */

            data[entry->pos] = 2000L;
        }

	oldptr = ptr ;
	if ((entry->typ == PD_NUMBER) || (entry->typ == PD_YEAR))
	    ptr += strspn(ptr,DIGITS) ;  /* skip past number */
    }

    /*
     * no more descriptors, see if we are at end
     */
    if (ptr == oldptr) /* ptr unmoved, we need to move it */
    {
	/* need to advance to WHITE_SPACE or end */
	if ((ptr = (CHAR *)strpbrk(oldptr, WHITE_SPACE)) == NULL)
	{
	    ptr = (CHAR *)strchr(oldptr, '\0'); /* if not found, take end */
	}
    }

    ptr += strspn(ptr,WHITE_SPACE) ;	/* skip white space */
    *inbuf = ptr ;	/* update inbuf */
    return(0) ;		/* SUCCESSFUL   */
}


/*---- time conversion ----*/

#define IS_LEAP(y)         ((y % 4 == 0) && (y % 100 != 0 || y % 400 == 0))
#define DAYS_IN_YEAR(y)    (IS_LEAP(y) ? 366 : 365)
#define DAYS_IN_MONTH(m,y) (IS_LEAP(y) ? _days_month_leap[m] : _days_month[m])
#define SECS_IN_DAY	   (60L * 60L * 24L)
#define SECS_IN_HOUR	   (60L * 60L)
#define SECS_IN_MINUTE	   (60L)

static short _days_month_leap[] = { 31,29,31,30,31,30,31,31,30,31,30,31 } ;
static short _days_month[]      = { 31,28,31,30,31,30,31,31,30,31,30,31 } ;

/*
 * convert date & time in d_data & t_data (these in dd mm yy and
 * HH MM SS AMPM) to the number of seconds since 1/1/70.
 * The result is stored in timep.
 * Returns 0 if ok, error code otherwise.
 *
 * Note - date is either completely unset (all zero),
 * 	  or is fully set, or has day and months set with
 *	  year==0.
 */
static SHORT
convert_to_abs(
    date_data d_data,
    date_data t_data,
    time_t * timep
    )
{
    time_t total_secs, current_time ;
    struct tm time_struct;

    *timep = 0L ;
    if (convert_to_24hr(t_data) != 0)
	return(ERROR_BAD_ARGUMENTS) ;
    current_time = time_now() ;
    net_gmtime(&current_time, &time_struct);

    /* check for default values */
    if (d_data[DAYS] == 0 && d_data[MONTHS] == 0 && d_data[YEARS] == 0)
    {
	/* whole date's been left out */
	d_data[DAYS] = (USHORT) time_struct.tm_mday ;
	d_data[MONTHS] = (USHORT) time_struct.tm_mon + (USHORT) 1 ;
	d_data[YEARS] = (USHORT) time_struct.tm_year ;
	total_secs = seconds_since_1970(d_data,t_data) ;
	if (total_secs < 0)
	    return(ERROR_BAD_ARGUMENTS) ;
	if (total_secs < current_time)
	{
	    /*
	     * if the time parsed is earlier than the current time,
	     * and the date has been left out, we advance to the
	     * next day.
	     */
	    advance_date(d_data) ;
	    total_secs = seconds_since_1970(d_data,t_data) ;
	}
    }
    else if (d_data[YEARS] == 0 && d_data[MONTHS] != 0 && d_data[DAYS] != 0)
    {
	/* year's been left out */
	d_data[YEARS] = (USHORT) time_struct.tm_year ;
	total_secs = seconds_since_1970(d_data,t_data) ;
	if (total_secs < current_time)
	{
	    ++d_data[YEARS] ;
	    total_secs = seconds_since_1970(d_data,t_data) ;
	}
    }
    else
	total_secs = seconds_since_1970(d_data,t_data) ; /* no need defaults */

    if (total_secs < 0)
	return(ERROR_BAD_ARGUMENTS) ;
    *timep = total_secs ;
    return(0) ;
}

/*
 * convert time in t_data ( this HH MM SS AMPM) to the number of seconds
 * since midnight.
 * The result is stored in timep.
 * Returns 0 if ok, error code otherwise.
 *
 * Note - date is either completely unset (all zero),
 * 	  or is fully set, or has day and months set with
 *	  year==0.
 */
static SHORT
convert_to_secs(
    date_data t_data,
    time_t * timep
    )
{
    if (convert_to_24hr(t_data) != 0)
	return(ERROR_BAD_ARGUMENTS) ;

    *timep =  (time_t) t_data[HOURS] * SECS_IN_HOUR +
	      (time_t) t_data[MINUTES] * SECS_IN_MINUTE +
	      (time_t) t_data[SECONDS] ;

    return (0) ;
}

/*
 * count the total number of seconds since 1/1/70
 */
static time_t
seconds_since_1970(
    date_data d_data,
    date_data t_data
    )
{
    time_t days ;

    days = days_so_far(d_data[DAYS],d_data[MONTHS],d_data[YEARS]) ;
    if (days < 0)
	return(-1) ;
    return ( days * SECS_IN_DAY +
	     (time_t) t_data[HOURS] * SECS_IN_HOUR +
	     (time_t) t_data[MINUTES] * SECS_IN_MINUTE +
	     (time_t) t_data[SECONDS] ) ;
}

/*
 * given day/month/year, returns how many days
 * have passed since 1/1/70
 * Returns  -1 if there is an error.
 */
static time_t
days_so_far(
    int d,
    int m,
    int y
    )
{
    int tmp_year ;
    time_t count = 0 ;

    /* check for validity */
    if ((y < 0) || (y > 99 && y < 1970)) return(-1) ;
    if (m < 1 || m > 12) return(-1) ;
    if (d < 1 || d > DAYS_IN_MONTH(m-1,y)) return(-1) ;

    /* a bit of intelligence */
    if (y < 70)
	y += 2000  ;
    else if (y < 100)
	y += 1900 ;

    /* count the days due to years */
    tmp_year = y-1 ;
    while (tmp_year >= 1970)
    {
	count += DAYS_IN_YEAR(tmp_year) ;  /* agreed, this could be faster */
	--tmp_year ;
    }

    /* count the days due to months */
    while (m > 1)
    {
	count += DAYS_IN_MONTH(m-2,y) ;  /* agreed, this could be faster */
	--m ;
    }

    /* finally, the days */
    count += d - 1 ;
    return(count) ;
}

/*
 * convert time in t_data to the 24 hour format
 * returns 0 if ok, -1 otherwise.
 */
static SHORT
convert_to_24hr(
    date_data t_data
    )
{
    /* no negative values allowed */
    if (t_data[HOURS] < 0 || t_data[MINUTES] < 0 || t_data[SECONDS] < 0)
	return(-1) ;

    /* check minutes and seconds */
    if ( t_data[MINUTES] > 59 || t_data[SECONDS] > 59)
	return(-1) ;

    /* now check the hour & convert if need */
    if (t_data[AMPM] == PD_PM)
    {
	if (t_data[HOURS] > 12 || t_data[HOURS] < 1)
	    return(-1) ;
	t_data[HOURS] += 12 ;
	if (t_data[HOURS] == 24)
	    t_data[HOURS] = 12 ;
    }
    else if (t_data[AMPM] == PD_AM)
    {
	if (t_data[HOURS] > 12 || t_data[HOURS] < 1)
	    return(-1) ;
	if (t_data[HOURS] == 12)
	    t_data[HOURS] = 0 ;
    }
    else if (t_data[AMPM] == PD_24HR)
    {
	if (t_data[HOURS] > 23)
	    return(-1) ;
    }
    else
	return(-1) ;

    return( 0 ) ;
}

/*
 * advance the date in d_data by one day
 */
static VOID
advance_date(
    date_data d_data
    )
{
    /* assume all values already in valid range */
    if ( d_data[DAYS] != DAYS_IN_MONTH(d_data[MONTHS]-1,d_data[YEARS]) )
	++d_data[DAYS] ;		/* increase day */
    else				/* can't increase day */
    {
	d_data[DAYS] = 1 ;		/* set to 1st, try increase month */
	if (d_data[MONTHS] != 12)
	    ++d_data[MONTHS] ;		/* increase month */
	else				/* can't increase month */
	{
	    d_data[MONTHS] = 1 ;	/* set to Jan, and */
	    ++d_data[YEARS] ;		/* increase year   */
	}
    }
}

#define INTERNATIONAL_SECTION      "intl"
#define TIME_SEPARATOR_KEY         "sTime"
#define DATE_SEPARATOR_KEY         "sDate"
#define SHORT_DATE_FORMAT_KEY      "sShortDate"
#define AM_STRING_KEY              "s1159"
#define PM_STRING_KEY              "s2359"

/*
 * reads the time/date separators & date format info from
 * the system.
 */
void GetInternationalInfo(MY_COUNTRY_INFO *pcountry_info)
{
    CHAR  szDateFormat[256] = "";

    /*
     * get the time separator, ignore return val since we have default
     */
    (void)   GetProfileStringA(INTERNATIONAL_SECTION,
                               TIME_SEPARATOR_KEY,
                               ":",
                               pcountry_info->szTimeSeparator,
                               sizeof(pcountry_info->szTimeSeparator)) ;

    /*
     * get the date separator, ignore return val since we have default
     */
    (void)   GetProfileStringA(INTERNATIONAL_SECTION,
                               DATE_SEPARATOR_KEY,
                               "/",
                               pcountry_info->szDateSeparator,
                               sizeof(pcountry_info->szDateSeparator)) ;


    /*
     * get the AM string, ignore return val since we have default
     */
    (void)   GetProfileStringA(INTERNATIONAL_SECTION,
                               AM_STRING_KEY,
                               "AM",
                               pcountry_info->szAMString,
                               sizeof(pcountry_info->szAMString)) ;

    /*
     * get the PM string, ignore return val since we have default
     */
    (void)   GetProfileStringA(INTERNATIONAL_SECTION,
                               PM_STRING_KEY,
                               "PM",
                               pcountry_info->szPMString,
                               sizeof(pcountry_info->szPMString)) ;

    /*
     * get the date format, ignore return val since we have default
     */
    (void)   GetProfileStringA(INTERNATIONAL_SECTION,
                               SHORT_DATE_FORMAT_KEY,
                               "",
                               szDateFormat,
                               sizeof(szDateFormat)) ;

    pcountry_info->fsDateFmt = 0 ;
    if (szDateFormat[0])
    {
        CHAR *pDay, *pMonth, *pYear ;

        pDay   = strpbrk(szDateFormat,"dD") ;
        pMonth = strpbrk(szDateFormat,"mM") ;
        pYear  = strpbrk(szDateFormat,"yY") ;

        if (!pDay || !pMonth || !pYear)
            ;   // leave it as 0
        else if (pMonth < pDay && pDay < pYear)
            pcountry_info->fsDateFmt = 0 ;
        else if (pDay < pMonth && pMonth < pYear)
            pcountry_info->fsDateFmt = 1 ;
        else if (pYear < pMonth && pMonth < pDay)
            pcountry_info->fsDateFmt = 2 ;
        else
            ;   // leave it as 0
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\luiint.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    luiint.c

Abstract:

    This module provides routines for setting up search lists of string/value
    pairs using messages in the NET.MSG message file, and for traversing
    such a search list.

Author:

    Dan Hinsley    (danhi)  06-Jun-1991

Environment:

    User Mode - Win32

Revision History:

    10-Jul-1989     chuckc
	Created

    24-Apr-1991     danhi
	32 bit NT version

    06-Jun-1991     Danhi
	Sweep to conform to NT coding style

    01-Oct-1992     JohnRo
        RAID 3556: Added NetpSystemTimeToGmtTime() for DosPrint APIs.

    20-Feb-1993     YiHsinS
        Moved from netcmd\map32\search.c. And added LUI_GetMessageIns.
--*/

//
// INCLUDES
//

#include <windows.h>    // IN, LPTSTR, etc.

#include <lmcons.h>
#include <stdio.h>		
#include <lmerr.h>

#include <luiint.h>
#include <netlib.h>

/*-- routines proper --*/

/*
 * Name: 	ILUI_setup_list
 *			Given an array of 'search_list_data' (ie. msgno/value
 *			pairs), create a string/value pair using the messages
 *			in the message file.
 * Args:	char * buffer           - for holding the meesages retrieved
 *		USHORT bufsiz  		- size of the above buffer
 *		USHORT offset 		- the number of items already setup
 *					  in slist, we will offset our retrieved
 *					  string/value pais by this much.
 *		PUSHORT bytesread	- the number of bytes read into buffer
 *		searchlist_data sdata[] - input array of msgno/value pairs,
 *					  we stop when we hit a message number
 *					  of 0
 *		searchlist slist[]      - will receive the string/value pairs
 *				 	  (string will be pointers into buffer)
 * Returns:	0 if ok, NERR_BufTooSmall otherwise.
 * Globals: 	(none)
 * Statics:	(none)
 * Remarks:	WARNING! We assume the caller KNOWs that slist is big enough
 *		for the pairs to be retrieved. This can be determined statically
 *		while buffer size cannot. Hence we provide checks for the
 *		latter.
 * Updates:	(none)
 */
USHORT
ILUI_setup_list(
    CHAR *buffer,
    USHORT bufsiz,
    USHORT offset,
    PUSHORT bytesread,
    searchlist_data sdata[],
    searchlist slist[]
    )
{
    USHORT 		err ;
    unsigned int 	msglen ;
    int         	i ;

    *bytesread = 0 ;
    for ( i=0; sdata[i].msg_no != 0; i++)
    {
	if (err = LUI_GetMsgIns(NULL,0,buffer,bufsiz,sdata[i].msg_no,
	    (unsigned far *)&msglen))
		return(err) ;
	slist[i+offset].s_str = buffer ;
	slist[i+offset].val   = sdata[i].value ;
	buffer += msglen+1 ;
	bufsiz -= msglen+1 ;
	*bytesread += msglen+1 ;
    }

    return(0) ;
}



/*
 * Name: 	ILUI_traverse_slist
 * 			traverse a searchlist ('slist') of string/number pairs,
 * 			and return the number matching string 'str'.
 * Args:	char * 	     pszStr - the string to search for
 *		searchlist * slist  - pointer to head of a searchlist
 *		int *        pusVal - pointer to variable that receives
 *				      the vale retrieved
 * Returns:	0 if found, -1 otherwise.
 * Globals: 	(none)
 * Statics:	(none)
 * Remarks:	(none)
 * Updates:	(none)
 */
USHORT
ILUI_traverse_slist(
    PCHAR pszStr,
    searchlist * slist,
    SHORT * pusVal
    )
{
    if (!slist)
	return( (USHORT) -1) ;
    while (slist->s_str)
    {
	if (_stricmp(pszStr,slist->s_str) == 0)
	{
	    *pusVal = slist->val ;
	    return(0) ;
	}
	++slist ;
    }
    return( (USHORT) -1) ;
}

/*
 * Name:    LUI_GetMsgIns
 *          This routine is very similar to DOSGETMESSAGE,
 *          except it:
 *              1) looks for messages in specific files
 *                 in a specific order:
 *                 a) MESSAGE_FILE in <lanman_dir>
 *                 b) MESSAGE_FILENAME in DPATH
 *                 c) OS2MSG_FILENAME in DPATH
 *              2) guarantees a null terminates string
 *              3) will accept NULL for msglen (see below).
 * Args:    istrings : pointer to table of insert strings
 *          nstrings : number of insert strings
 *          msgbuf   : buffer to hold message retrieved
 *          bufsize  : size of buffer
 *          msgno    : message number
 *          msglen   : pointer to variable that will receive message length
 * Returns: zero if ok, the DOSGETMESSAGE error code otherwise
 * Globals: (none)
 * Statics: NetMsgFileName, OS2MsgFileName
 */
USHORT
LUI_GetMsgIns(
    PCHAR *istrings,
    USHORT nstrings,
    PSZ msgbuf,
    USHORT bufsize,
    ULONG msgno,
    unsigned int *msglen
    )
{
    USHORT result, tmplen ;
    static WCHAR NetMsgFileName[PATHLEN+1] = { 0 };
    static WCHAR OS2MsgFileName[PATHLEN+1] = { 0 };

    *msgbuf = '\0' ;

    /* make a path to the LANMAN message file */
    if (NetMsgFileName[0] == '\0') {
        wcscpy(NetMsgFileName, MESSAGE_FILENAME);
    }

    /* make a path to the OS/2 message file */
    if (OS2MsgFileName[0] == '\0') {
        wcscpy(OS2MsgFileName, OS2MSG_FILENAME);
    }

    result = DosGetMessage( istrings,
                            nstrings,
                            msgbuf,
                            (USHORT) (bufsize - 1),
                            (USHORT) msgno,
                            NetMsgFileName,
                            &tmplen);

    if (result == ERROR_MR_MID_NOT_FOUND)  { /* cannot find */
        /* try OS2 message file instead */
            result = DosGetMessage(istrings,
                                   nstrings,
                                   msgbuf,
                                   (USHORT) (bufsize - 1),
                                   (USHORT) msgno,
                                   OS2MsgFileName,
                                   &tmplen);
    }

    /*
     * in all DosGetMessage above we passed it bufsize-1, so we are
     * assure of at least one spare byte for the \0 terminator.
     */
    msgbuf[tmplen] = '\0' ;
    if (msglen != NULL) {
        *msglen = tmplen ;
    }

    return(result) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\luitext.c ===
/*++

Copyright (c) 1989-91  Microsoft Corporation

Module Name:

    LUITEXT.C

Abstract:

    Contains test strings fixed into the LUI library

Author:

    Dan Hinsley    (danhi)  06-Jun-1991

Environment:

    User Mode - Win32

Revision History:

    xx-Jul-1989     chuckc
	Created

    18-Apr-1991     danhi
	32 bit NT version

    06-Jun-1991     Danhi
	Sweep to conform to NT coding style

    22-Feb-1993     Yihsins
        Moved from netcmd\map32

--*/

//
// INCLUDES
//

#include <windef.h>

CHAR LUI_txt_yes[] =		"Yes" ;
CHAR LUI_txt_no[] =		"No" ;

CHAR LUI_txt_am[] =		"AM" ;
CHAR LUI_txt_pm[] =		"PM" ;

CHAR LUI_txt_net[] =		"NET" ;
CHAR LUI_txt_help[] =		"HELP" ;

CHAR LUI_txt_january[] =	"January" ;
CHAR LUI_txt_february[] =	"February" ;
CHAR LUI_txt_march[] =		"March" ;
CHAR LUI_txt_april[] =		"April" ;
CHAR LUI_txt_may[] =		"May" ;
CHAR LUI_txt_june[] =		"June" ;
CHAR LUI_txt_july[] =		"July" ;
CHAR LUI_txt_august[] = 	"August" ;
CHAR LUI_txt_september[] =	"September" ;
CHAR LUI_txt_october[] =	"October" ;
CHAR LUI_txt_november[] =	"November" ;
CHAR LUI_txt_december[] =	"December" ;

CHAR LUI_txt_monday[] = 	"Monday" ;
CHAR LUI_txt_tuesday[] =	"Tuesday" ;
CHAR LUI_txt_wednesday[] =	"Wednesday" ;
CHAR LUI_txt_thursday[] =	"Thursday" ;
CHAR LUI_txt_friday[] = 	"Friday" ;
CHAR LUI_txt_saturday[] =	"Saturday" ;
CHAR LUI_txt_sunday[] = 	"Sunday" ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\mapdata.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    MapData.c

Abstract:

    Data structures for mapping wksta and server info structures.

Author:

    Dan Hinsley    (danhi)  06-Jun-1991

Environment:

    User Mode - Win32

Revision History:

    24-Apr-1991     danhi
        Created

    06-Jun-1991     Danhi
        Sweep to conform to NT coding style

    18-Aug-1991 JohnRo
        Implement downlevel NetWksta APIs.  (Moved DanHi's NetCmd/Map32/MWksta
        conversion stuff to NetLib.)

--*/

//
// INCLUDES
//


// These must be included first:

//#include <ntos2.h>              // Only required to compile under NT.
#include <windef.h>             // IN, LPVOID, etc.
//#include <lmcons.h>             // NET_API_STATUS, CNLEN, etc.

// These may be included in any order:

//#include <debuglib.h>           // IF_DEBUG(CONVSRV).
#include <dlserver.h>           // Old server info levels.
#include <dlwksta.h>            // Old wksta info levels.
//#include <lmapibuf.h>           // NetapipBufferAllocate().
//#include <lmerr.h>              // NERR_ and ERROR_ equates.
#include <lmserver.h>           // New server info level structures.
#include <lmwksta.h>            // New wksta info level structures.
#include <mapsupp.h>            // MOVESTRING, my prototypes.
//#include <netdebug.h>           // NetpKdPrint(()), FORMAT_ equates, etc.
//#include <netlib.h>             // NetpPointerPlusSomeBytes().
//#include <tstring.h>            // STRLEN().
//#include <xsdef16.h> // xactsrv defaults for values not supported on NT

//#include <ntos2.h>
//#include <windef.h>
//#include <string.h>
//#include <malloc.h>
//#include <stddef.h>
//#include <lm.h>
//#include "port1632.h"
//#include "mapsupp.h"

//
// These structures are used by the NetpMoveStrings function, which copies
// strings between and old and new lanman structure.  The name describes
// the source and destination structure.  For example, Level2_101 tells
// NetpMoveStrings how to move the strings from a Level 101 to a Level 2.
//
// Each structure has pairs of entries, the first is the offset of the
// pointer source string in it's structure, the second is the offset of
// the pointer to the destination string in it's structure.
//
// See NetpMoveStrings in mapsupp.c for more details.
//



MOVESTRING NetpServer2_102[] = {
   offsetof(SERVER_INFO_102, sv102_name),
   offsetof(SERVER_INFO_2,   sv2_name),
   offsetof(SERVER_INFO_102, sv102_comment),
   offsetof(SERVER_INFO_2,   sv2_comment),
   offsetof(SERVER_INFO_102, sv102_userpath),
   offsetof(SERVER_INFO_2,   sv2_userpath),
   MOVESTRING_END_MARKER,    MOVESTRING_END_MARKER } ;

MOVESTRING NetpServer2_402[] = {
   offsetof(SERVER_INFO_402, sv402_guestacct),
   offsetof(SERVER_INFO_2,   sv2_guestacct),
   offsetof(SERVER_INFO_402, sv402_alerts),
   offsetof(SERVER_INFO_2,   sv2_alerts),
   offsetof(SERVER_INFO_402, sv402_srvheuristics),
   offsetof(SERVER_INFO_2,   sv2_srvheuristics),
   MOVESTRING_END_MARKER,    MOVESTRING_END_MARKER } ;


MOVESTRING NetpServer3_403[] = {
   offsetof(SERVER_INFO_403, sv403_autopath),
   offsetof(SERVER_INFO_3,   sv3_autopath),
   MOVESTRING_END_MARKER,    MOVESTRING_END_MARKER } ;

//
// Enhancement: These are the same as NetpServer2_102, except the two fields are
//                reversed, ie source<->destination.  Should I bother with
//                making NetpMoveStrings be able to work with a single structure
//                and a switch?
//

MOVESTRING NetpServer102_2[] = {
   offsetof(SERVER_INFO_2,   sv2_name),
   offsetof(SERVER_INFO_102, sv102_name),
   offsetof(SERVER_INFO_2,   sv2_comment),
   offsetof(SERVER_INFO_102, sv102_comment),
   offsetof(SERVER_INFO_2,   sv2_userpath),
   offsetof(SERVER_INFO_102, sv102_userpath),
   MOVESTRING_END_MARKER,    MOVESTRING_END_MARKER } ;

MOVESTRING NetpServer402_2[] = {
   offsetof(SERVER_INFO_2,   sv2_alerts),
   offsetof(SERVER_INFO_402, sv402_alerts),
   offsetof(SERVER_INFO_2,   sv2_guestacct),
   offsetof(SERVER_INFO_402, sv402_guestacct),
   offsetof(SERVER_INFO_2,   sv2_srvheuristics),
   offsetof(SERVER_INFO_402, sv402_srvheuristics),
   MOVESTRING_END_MARKER,    MOVESTRING_END_MARKER } ;

MOVESTRING NetpServer403_3[] = {
   offsetof(SERVER_INFO_3,   sv3_autopath),
   offsetof(SERVER_INFO_403, sv403_autopath),
   MOVESTRING_END_MARKER,    MOVESTRING_END_MARKER } ;



// To build wksta_info_10

MOVESTRING NetpWksta10_101[] = {
   offsetof(WKSTA_INFO_101, wki101_computername),
   offsetof(WKSTA_INFO_10,  wki10_computername),
   offsetof(WKSTA_INFO_101, wki101_langroup),
   offsetof(WKSTA_INFO_10,  wki10_langroup),
   MOVESTRING_END_MARKER,   MOVESTRING_END_MARKER } ;

MOVESTRING NetpWksta10_User_1[] = {
   offsetof(WKSTA_USER_INFO_1, wkui1_username),
   offsetof(WKSTA_INFO_10,     wki10_username),
   offsetof(WKSTA_USER_INFO_1, wkui1_logon_domain),
   offsetof(WKSTA_INFO_10,     wki10_logon_domain),
   offsetof(WKSTA_USER_INFO_1, wkui1_oth_domains),
   offsetof(WKSTA_INFO_10,     wki10_oth_domains),
   MOVESTRING_END_MARKER,      MOVESTRING_END_MARKER } ;

// To build wksta_info_0

MOVESTRING NetpWksta0_101[] = {
   offsetof(WKSTA_INFO_101, wki101_lanroot),
   offsetof(WKSTA_INFO_0,   wki0_root),
   offsetof(WKSTA_INFO_101, wki101_computername),
   offsetof(WKSTA_INFO_0,   wki0_computername),
   offsetof(WKSTA_INFO_101, wki101_langroup),
   offsetof(WKSTA_INFO_0,   wki0_langroup),
   MOVESTRING_END_MARKER,   MOVESTRING_END_MARKER } ;

MOVESTRING NetpWksta0_User_1[] = {
   offsetof(WKSTA_USER_INFO_1, wkui1_username),
   offsetof(WKSTA_INFO_0,      wki0_username),
   offsetof(WKSTA_USER_INFO_1, wkui1_logon_server),
   offsetof(WKSTA_INFO_0,      wki0_logon_server),
   MOVESTRING_END_MARKER,      MOVESTRING_END_MARKER } ;

MOVESTRING NetpWksta0_402[] = {
   offsetof(WKSTA_INFO_402, wki402_wrk_heuristics),
   offsetof(WKSTA_INFO_0,   wki0_wrkheuristics),
   MOVESTRING_END_MARKER,   MOVESTRING_END_MARKER } ;

// To build wksta_info_1 (incremental over wksta_info_0)

MOVESTRING NetpWksta1_User_1[] = {
   offsetof(WKSTA_USER_INFO_1, wkui1_logon_domain),
   offsetof(WKSTA_INFO_1,      wki1_logon_domain),
   offsetof(WKSTA_USER_INFO_1, wkui1_oth_domains),
   offsetof(WKSTA_INFO_1,      wki1_oth_domains),
   MOVESTRING_END_MARKER,      MOVESTRING_END_MARKER } ;

// To build wksta_info_101/302/402 from wksta_info_0

MOVESTRING NetpWksta101_0[] = {
   offsetof(WKSTA_INFO_0,   wki0_root),
   offsetof(WKSTA_INFO_101, wki101_lanroot),
   offsetof(WKSTA_INFO_0,   wki0_computername),
   offsetof(WKSTA_INFO_101, wki101_computername),
   offsetof(WKSTA_INFO_0,   wki0_langroup),
   offsetof(WKSTA_INFO_101, wki101_langroup),
   MOVESTRING_END_MARKER,   MOVESTRING_END_MARKER } ;

MOVESTRING NetpWksta402_0[] = {
   offsetof(WKSTA_INFO_0,   wki0_wrkheuristics),
   offsetof(WKSTA_INFO_402, wki402_wrk_heuristics),
   MOVESTRING_END_MARKER,   MOVESTRING_END_MARKER } ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\memalloc.c ===
#ifndef CDEBUG
#ifndef WIN32
    #define WIN32
#endif
#endif

/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    MemAlloc.c

Abstract:

    Memory allocation routines for per-process use.

    Note that the semantics of these routines are intended to be 100%
    compatible with the ANSI C routines malloc(), free(), and realloc().
    (That way, an implementation which can actually use the ANSI routines
    would just #define NetpMemoryAllocate as malloc.)

Author:

    John Rogers (JohnRo) 15-Mar-1991

Environment:

    Only runs under NT, although the interface is portable (Win/32).
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    15-Mar-91 JohnRo
        Created.
    16-Apr-1991 JohnRo
        Include <lmcons.h> for <netlib.h>.  Got rid of tabs in source file.
    13-Oct-1991 JohnRo
        Fix memory realloc problems.
    18-Nov-1991 JohnRo
        Make sure output areas are aligned for worst case use.
    12-Jan-1992 JohnRo
        Workaround a LocalReAlloc() bug where 2nd realloc messes up.
        (See WIN32_WORKAROUND code below.)
        Added NETLIB_LOCAL_ALLOCATION_FLAGS to make clearer what we're doing.
    10-May-1992 JohnRo
        Add some debug output.
--*/


// These must be included first:

#include <nt.h>         // Rtl routines, etc.  (Must be first.)

#include <windef.h>
#ifdef WIN32
#include <ntrtl.h>      // Needed for nturtl/winbase.h
#include <nturtl.h>     // Needed for winbase.h????
#include <winbase.h>    // LocalAlloc(), LMEM_ flags, etc.
#endif
#include <lmcons.h>     // NET_API_STATUS.

// These may be included in any order:

#include <align.h>      // ROUND_UP_POINTER(), ALIGN_WORST.
#include <debuglib.h>   // IF_DEBUG().
#include <netdebug.h>   // NetpAssert(), NetpKdPrint(()), FORMAT_ equates.
#include <netlib.h>     // My prototypes, NetpMoveMemory().
#include <prefix.h>     // PREFIX_ equates.
#ifdef CDEBUG
#include <stdlib.h>     // free(), malloc(), realloc().
#endif // def CDEBUG


// Define memory alloc/realloc flags.  We are NOT using movable or zeroed
// on allocation here.
#define NETLIB_LOCAL_ALLOCATION_FLAGS   LMEM_FIXED


LPVOID
NetpMemoryAllocate(
    IN DWORD Size
    )

/*++

Routine Description:

    NetpMemoryAllocate will allocate memory, or return NULL if not available.

Arguments:

    Size - Supplies number of bytes of memory to allocate.

Return Value:

    LPVOID - pointer to allocated memory.
    NULL - no memory is available.

--*/

{
    LPVOID NewAddress;

    if (Size == 0) {
        return (NULL);
    }
#ifdef WIN32
    {
        HANDLE hMem;
        hMem = LocalAlloc(
                        NETLIB_LOCAL_ALLOCATION_FLAGS,
                        Size);                  // size in bytes
        NewAddress = (LPVOID) hMem;
    }
#else // ndef WIN32
#ifndef CDEBUG
    NewAddress = RtlAllocateHeap(
                RtlProcessHeap( ), 0,              // heap handle
                Size ));                        // bytes wanted
#else // def CDEBUG
    NetpAssert( Size == (DWORD) (size_t) Size );
    NewAddress = malloc( (size_t) Size ));
#endif // def CDEBUG
#endif // ndef WIN32

    NetpAssert( ROUND_UP_POINTER( NewAddress, ALIGN_WORST) == NewAddress);
    return (NewAddress);

} // NetpMemoryAllocate


VOID
NetpMemoryFree(
    IN LPVOID Address OPTIONAL
    )

/*++

Routine Description:

    Free memory at Address (must have been gotten from NetpMemoryAllocate or
    NetpMemoryReallocate).  (Address may be NULL.)

Arguments:

    Address - points to an area allocated by NetpMemoryAllocate (or
        NetpMemoryReallocate).

Return Value:

    None.

--*/

{
    NetpAssert( ROUND_UP_POINTER( Address, ALIGN_WORST) == Address);

#ifdef WIN32
    if (Address == NULL) {
        return;
    }
    if (LocalFree(Address) != NULL) {
        NetpAssert(FALSE);
    }
#else // ndef WIN32
#ifndef CDEBUG
    if (Address == NULL) {
        return;
    }
    RtlFreeHeap(
                RtlProcessHeap( ), 0,              // heap handle
                Address);                       // addr of alloc'ed space.
#else // def CDEBUG
    free( Address );
#endif // def CDEBUG
#endif // ndef WIN32
} // NetpMemoryFree


LPVOID
NetpMemoryReallocate(
    IN LPVOID OldAddress OPTIONAL,
    IN DWORD NewSize
    )

/*++

Routine Description:

    NetpMemoryReallocate reallocates a block of memory to a different size.
    Contents of the block are copied if necessary.  Returns NULL if unable to
    allocate additional storage.

Arguments:

    OldAddress - Optionally gives address of a block which was allocated by
        NetpMemoryAllocate or NetpMemoryReallocate.

    NewSize - Gives the new size in bytes.

Return Value:

    LPVOID - Pointer to new (possibly moved) block of memory.  (Pointer may
        be NULL, in which case the old block is still allocated.)

--*/

{
    LPVOID NewAddress;  // may be NULL.

    NetpAssert( ROUND_UP_POINTER( OldAddress, ALIGN_WORST) == OldAddress);

    IF_DEBUG( MEMALLOC ) {
        NetpKdPrint(( PREFIX_NETLIB "NetpMemoryReallocate: called with ptr "
                FORMAT_LPVOID " and size " FORMAT_DWORD ".\n",
                (LPVOID) OldAddress, NewSize ));
    }

    // Special cases: something into nothing, or nothing into something.
    if (OldAddress == NULL) {

        NewAddress = NetpMemoryAllocate(NewSize);

    } else if (NewSize == 0) {

        NetpMemoryFree(OldAddress);
        NewAddress = NULL;

    } else {  // must be realloc of something to something else.

#if defined(WIN32)

        HANDLE hNewMem;                     // handle for new (may = old handle)
        HANDLE hOldMem;

#ifdef notdef // LocalHandle returns 0 for LMEM_FIXED block
        hOldMem = LocalHandle( (LPSTR) OldAddress);
#else
        hOldMem = (HANDLE) OldAddress;
#endif // notdef
        NetpAssert(hOldMem != NULL);

        hNewMem = LocalReAlloc(
                hOldMem,                        // old handle
                NewSize,                        // new size in bytes
                LMEM_MOVEABLE);                 // OK if new block is in new location

        if (hNewMem == NULL) {
            return (NULL);
        }

        NewAddress = (LPVOID) hNewMem;

#elif !defined(CDEBUG)  // not WIN32 or CDEBUG, must be NT

        DWORD OldSize;

        // Need size of old area to continue...
        OldSize = RtlSizeHeap(
                RtlProcessHeap( ), 0,              // heap handle
                OldAddress);                    // "base" address
        if (OldSize == NewSize) {
            NewAddress = OldAddress;            // Another special case.
        } else {

            // Normal case (something into something else).  Alloc new area.
            NewAddress = NetpMemoryAllocate(NewSize);
            if (NewAddress != NULL) {

                // Copy lesser of old and new sizes.
                NetpMoveMemory(
                        NewAddress,             // dest
                        OldAddress,             // src
                        (NewSize < OldSize) ? NewSize : OldSize);   // len

                NetpMemoryFree(OldAddress);
            }
        }

#else // must be CDEBUG

        NetpAssert(NewSize == (DWORD)(size_t)NewSize);
        NewAddress = realloc( OldAddress, NewSize );

#endif // CDEBUG

    } // must be realloc of something to something else

    IF_DEBUG( MEMALLOC ) {
        NetpKdPrint(( PREFIX_NETLIB "NetpMemoryReallocate: new address is "
                FORMAT_LPVOID ".\n", (LPVOID) OldAddress ));
    }

    NetpAssert( ROUND_UP_POINTER( NewAddress, ALIGN_WORST) == NewAddress);

    return (NewAddress);

} // NetpMemoryReallocate
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\midluser.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    MidlUser.c

Abstract:

    This file contains common functions and utilities that the API
    DLLs can use in making remote calls.  This includes the
    MIDL_USER_ALLOCATE functions.

    The following routines are called by MIDL-generated code and the
    NetApiBufferAllocate and NetApiBufferFree routines:

       MIDL_user_allocate
       MIDL_user_free

    The following routines are NOT called by MIDL-generated code; they are
    only called by the NetApiBufferReallocate and NetApiBufferSize routines:

       MIDL_user_reallocate
       MIDL_user_size

Author:

    Dan Lafferty    danl    06-Feb-1991

Environment:

    User Mode - Win32

Revision History:

    06-Feb-1991     danl
        Created
    25-Apr-1991 JohnRo
        Split out MIDL user (allocate,free) into seperate source file, so
        linker doesn't get confused.
    03-Dec-1991 JohnRo
        Added MIDL_user_reallocate and MIDL_user_size APIs.  (These are so we
        create the NetApiBufferAllocate, NetApiBufferReallocate, and
        NetApiBufferSize APIs.)
        Also check alignment of allocated data.
    12-Jan-1992 JohnRo
        Workaround a LocalReAlloc() bug where 2nd or 3rd realloc messes up.
        (See WIN32_WORKAROUND code below.)
    08-Jun-1992 JohnRo
        RAID 9258: return non-null pointer when allocating zero bytes.
        Also, SteveWo finally fixed LocalReAlloc() bug, so use it again.
        Avoid calling LocalFree() with null pointer, to avoid access viol.
    01-Dec-1992 JohnRo
        Fix MIDL_user_ func signatures.
        Avoid compiler warnings (const vs. volatile).


--*/

// These must be included first:

#include <windef.h>             // win32 typedefs
#include <rpc.h>                // rpc prototypes

// These may be included in any order:

#include <align.h>              // POINTER_IS_ALIGNED(), ALIGN_WORST.
#include <rpcutil.h>            // My prototypes.

#include <netdebug.h>           // NetpAssert().
#include <stdarg.h>             // memcpy().
#include <winbase.h>            // LocalAlloc(), LMEM_ flags, etc.


#define LOCAL_ALLOCATION_FLAGS  LMEM_FIXED


void __RPC_FAR * __RPC_API
MIDL_user_allocate(
    IN size_t NumBytes
    )

/*++

Routine Description:

    Allocates storage for RPC transactions.  The RPC stubs will either call
    MIDL_user_allocate when it needs to un-marshall data into a buffer
    that the user must free.  RPC servers will use MIDL_user_allocate to
    allocate storage that the RPC server stub will free after marshalling
    the data.

Arguments:

    NumBytes - The number of bytes to allocate.  (Note that NetApiBufferAllocate
        depends on being able to request that zero bytes be allocated and get
        back a non-null pointer.)

Return Value:

    Pointer to the allocated memory.


--*/

{
    LPVOID NewPointer;

    NewPointer = (LPVOID) LocalAlloc(
            LOCAL_ALLOCATION_FLAGS,
            NumBytes);

    NetpAssert( POINTER_IS_ALIGNED( NewPointer, ALIGN_WORST) );

    return (NewPointer);

} // MIDL_user_allocate



void __RPC_API
MIDL_user_free(
    IN void __RPC_FAR *MemPointer
    )

/*++

Routine Description:

    Frees storage used in RPC transactions.  The RPC client can call this
    function to free buffer space that was allocated by the RPC client
    stub when un-marshalling data that is to be returned to the client.
    The Client calls MIDL_user_free when it is finished with the data and
    desires to free up the storage.
    The RPC server stub calls MIDL_user_free when it has completed
    marshalling server data that is to be passed back to the client.

Arguments:

    MemPointer - This points to the memory block that is to be released.

Return Value:

    none.


--*/
{
    NetpAssert( POINTER_IS_ALIGNED( MemPointer, ALIGN_WORST) );
    if (MemPointer != NULL) {
        (void) LocalFree(MemPointer);
    }

} // MIDL_user_free


void *
MIDL_user_reallocate(
    IN void * OldPointer OPTIONAL,
    IN size_t NewByteCount
    )
{
    LPVOID NewPointer;  // may be NULL.

    NetpAssert( POINTER_IS_ALIGNED( OldPointer, ALIGN_WORST) );


    // Special cases: something into nothing, or nothing into something.
    if (OldPointer == NULL) {

        NewPointer = (LPVOID) LocalAlloc(
                LOCAL_ALLOCATION_FLAGS,
                NewByteCount);

    } else if (NewByteCount == 0) {

        (void) LocalFree( OldPointer );
        NewPointer = NULL;

    } else {  // must be realloc of something to something else.

        HANDLE hOldMem;
        HANDLE hNewMem;                     // handle for new (may = old handle)

        hOldMem = LocalHandle( (LPSTR) OldPointer);
        NetpAssert(hOldMem != NULL);

        hNewMem = LocalReAlloc(
                hOldMem,                        // old handle
                NewByteCount,                   // new size in bytes
                LOCAL_ALLOCATION_FLAGS |        // flags
                    LMEM_MOVEABLE);             //  (motion okay)

        if (hNewMem == NULL) {
            return (NULL);
        }
        NewPointer = (LPVOID) hNewMem;
    }

    NetpAssert( POINTER_IS_ALIGNED( NewPointer, ALIGN_WORST) );

    return (NewPointer);

} // MIDL_user_reallocate


unsigned long
MIDL_user_size(
    IN void * Pointer
    )
{
    DWORD ByteCount;
    HANDLE hMemory;

    NetpAssert( Pointer != NULL );
    NetpAssert( POINTER_IS_ALIGNED( Pointer, ALIGN_WORST ) );

    hMemory = LocalHandle( (LPSTR) Pointer );
    NetpAssert( hMemory != NULL );

    ByteCount = (DWORD)LocalSize( hMemory );

    NetpAssert( ByteCount > 0 );

    return (ByteCount);

} // MIDL_user_size
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\message.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    message.c

Abstract:

    This module provides support routines to map DosxxxMessage APIs to
    the FormatMessage syntax and semantics.

Author:

    Dan Hinsley (DanHi) 24-Sept-1991

Environment:

    Contains NT specific code.

Revision History:

--*/

#define ERROR_MR_MSG_TOO_LONG           316
#define ERROR_MR_UN_ACC_MSGF            318
#define ERROR_MR_INV_IVCOUNT            320

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#define     NOMINMAX       // Avoid windows vs. stdlib.h conflicts.
#include <windef.h>
#include <winbase.h>
#include <winnls.h>
#include <lmcons.h>
#include <lmerr.h>
#include <netdebug.h> // NetpKdPrint
#include <netlib.h>   // NetpMemory*
#include <netlibnt.h> // NetpNtStatusToApiStatus
#include <string.h>
#include <stdio.h>
#include <stdlib.h>   // itoa
#include <tstring.h>

//
// forward declare
//
DWORD MyAllocUnicode( LPSTR    pszAscii, LPWSTR * ppwszUnicode ) ;

DWORD MyAllocUnicodeVector( LPSTR * ppszAscii,
                            LPWSTR* ppwszUnicode,
                            UINT    cpwszUnicode ) ;

VOID MyFreeUnicode( LPWSTR pwszUnicode ) ;

VOID MyFreeUnicodeVector( LPWSTR * ppwsz, UINT     cpwsz ) ;


//
// 100 is plenty since FormatMessage only take 99 & old DosGetMessage 9.
//
#define MAX_INSERT_STRINGS (100)

WORD
DosGetMessage(
    IN LPSTR * InsertionStrings,
    IN WORD NumberofStrings,
    OUT LPBYTE Buffer,
    IN WORD BufferLength,
    IN WORD MessageId,
    IN LPTSTR FileName,
    OUT PWORD pMessageLength
    )
/*++

Routine Description:

    This maps the OS/2 DosGetMessage API to the NT FormatMessage API.

Arguments:

    InsertionStrings - Pointer to an array of strings that will be used
                       to replace the %n's in the message.

    NumberofStrings  - The number of insertion strings.

    Buffer           - The buffer to put the message into.

    BufferLength     - The length of the supplied buffer.

    MessageId        - The message number to retrieve.

    FileName         - The name of the message file to get the message from.

    pMessageLength   - A pointer to return the length of the returned message.

Return Value:

    NERR_Success
    ERROR_MR_MSG_TOO_LONG
    ERROR_MR_INV_IVCOUNT
    ERROR_MR_UN_ACC_MSGF
    ERROR_MR_MID_NOT_FOUND
    ERROR_INVALID_PARAMETER

--*/
{

    DWORD dwFlags = FORMAT_MESSAGE_ARGUMENT_ARRAY;
    DWORD Status, i;
    LPWSTR UnicodeIStrings[MAX_INSERT_STRINGS] ;
    LPWSTR UnicodeBuffer = NULL;
    LPWSTR UnicodeNumberString = NULL ;
    CHAR NumberString [18];

    static HANDLE lpSource = NULL ;
    static TCHAR CurrentMsgFile[MAX_PATH] = {0,} ;

    //
    // init clear the output string
    //
    Status = NERR_Success;
    if (BufferLength)
        Buffer[0] = '\0' ;
    if (pMessageLength)
        *pMessageLength = 0;

    //
    // make sure we are not over loaded & allocate
    // memory for the Unicode buffer
    //
    if (NumberofStrings > MAX_INSERT_STRINGS)
        return ERROR_INVALID_PARAMETER ;
    if (!(UnicodeBuffer = NetpMemoryAllocate(BufferLength * sizeof(WCHAR))))
        return ERROR_NOT_ENOUGH_MEMORY ;

    //
    // init the string table & map the strings to unicode
    //
    for (i = 0; i < MAX_INSERT_STRINGS; i++)
        UnicodeIStrings[i] = NULL ;
    Status = MyAllocUnicodeVector(InsertionStrings,
                                  UnicodeIStrings,
                                  NumberofStrings) ;
    if (Status)
        goto ExitPoint ;

    //
    // See if they want to get the message from the system message file.
    //

    if (! STRCMP(FileName, OS2MSG_FILENAME)) {
       dwFlags |= FORMAT_MESSAGE_FROM_SYSTEM;
    }
    else
    {
       //
       // They want it from a separate message file.  Get a handle to DLL
       // If its for the same file as before, dont reload.
       //
       if (!(lpSource && !STRCMP(CurrentMsgFile,FileName)))
       {
           if (lpSource)
           {
               FreeLibrary(lpSource) ;
           }
           STRCPY(CurrentMsgFile, FileName) ;
           lpSource = LoadLibraryEx(FileName, NULL, LOAD_LIBRARY_AS_DATAFILE);
           if (!lpSource)
           {
               Status = ERROR_MR_UN_ACC_MSGF;
               goto ExitPoint ;
           }
       }
       dwFlags |= FORMAT_MESSAGE_FROM_HMODULE;
    }

    //
    // If they just want to get the message back for later formatting,
    // ignore the insert strings.
    //
    if (NumberofStrings == 0)
    {
        dwFlags |= FORMAT_MESSAGE_IGNORE_INSERTS;
    }

    //
    // call the Unicode version
    //
    *pMessageLength = (WORD) FormatMessageW(dwFlags,
                                            (LPVOID) lpSource,
                                            (DWORD) MessageId,
                                            0,       // LanguageId defaulted
                                            UnicodeBuffer,
                                            (DWORD)BufferLength,
                                            (va_list *)UnicodeIStrings);

    //
    // If it failed get the return code and map it to an OS/2 equivalent
    //

    if (*pMessageLength == 0)
    {
        UnicodeBuffer[0] = 0 ;
        Status = GetLastError();
        if (Status == ERROR_MR_MID_NOT_FOUND)
        {
            //
            // get the message number in Unicode
            //
            _itoa(MessageId, NumberString, 16);
            Status = MyAllocUnicode(NumberString, &UnicodeNumberString) ;
            if (Status)
                goto ExitPoint ;

            //
            // re-setup to get it from the system. use the not found message
            //
            dwFlags = FORMAT_MESSAGE_ARGUMENT_ARRAY |
                      FORMAT_MESSAGE_FROM_SYSTEM;
            MessageId = ERROR_MR_MID_NOT_FOUND ;

            //
            // setup insert strings
            //
            MyFreeUnicodeVector(UnicodeIStrings, NumberofStrings) ;
            UnicodeIStrings[0] = UnicodeNumberString ;
            UnicodeIStrings[1] = FileName ;

            //
            // recall the API
            //
            *pMessageLength = (WORD) FormatMessageW(dwFlags,
                                            (LPVOID) lpSource,
                                            (DWORD) MessageId,
                                            0,       // LanguageId defaulted
                                            UnicodeBuffer,
                                            (DWORD)BufferLength,
                                            (va_list *)UnicodeIStrings);
            UnicodeIStrings[1] = NULL ;

            //
            // revert to original error
            //
            Status = ERROR_MR_MID_NOT_FOUND ;
        }
    }

    if (UnicodeBuffer[0])
    {
        BOOL  fUsedDefault;

        *pMessageLength = (WORD)WideCharToMultiByte(CP_OEMCP,
                                                0,
                                                UnicodeBuffer,
                                                -1,
                                                Buffer,
                                                BufferLength,
                                                NULL, // use system default char
                                                &fUsedDefault );
        if (*pMessageLength == 0)
        {
            Status = GetLastError() ;
            goto ExitPoint ;
        }

    }

ExitPoint:
    //
    // note: UnicodeNumberString dont need to be freed
    // since if used, they would be in the UnicodeIStrings which is whacked
    //
    if (UnicodeBuffer) NetpMemoryFree(UnicodeBuffer) ;
    MyFreeUnicodeVector(UnicodeIStrings, NumberofStrings) ;
    return (WORD)(Status);
}


/************** misc unicode helper routines *************************/


/*
 *  MyAllocUnicode
 *  Given a MBCS string, allocate a new Unicode translation of that string
 *
 *  IN
 *      pszAscii        - pointer to original MBCS string
 *      ppwszUnicode    - pointer to cell to hold new Unicode string addr
 *  OUT
 *      ppwszUnicode    - contains new Unicode string
 *
 *  RETURNS
 *      Error code, 0 if successful.
 *
 *  The client must free the allocated string with MyFreeUnicode.
 */

DWORD
MyAllocUnicode(
    LPSTR    pszAscii,
    LPWSTR * ppwszUnicode )
{
    UINT      count;
    BYTE *    pbAlloc;
    INT       cbAscii;

    if (pszAscii == NULL)
    {
        *ppwszUnicode = NULL;
        return NERR_Success;
    }

    // Calculate size of Unicode string.
    cbAscii = strlen(pszAscii)+1;
    pbAlloc = (BYTE *) NetpMemoryAllocate(sizeof(WCHAR) * cbAscii) ;
    if (!pbAlloc)
        return ERROR_NOT_ENOUGH_MEMORY ;

    *ppwszUnicode = (LPWSTR)pbAlloc;

    count = MultiByteToWideChar(CP_OEMCP,
                                MB_PRECOMPOSED,
                                pszAscii,
                                cbAscii,
                                *ppwszUnicode,
                                cbAscii);
    if (count == 0)
    {
        *ppwszUnicode = NULL;
        NetpMemoryFree(pbAlloc);
        return ( GetLastError() );
    }

    return NERR_Success;
}

/*
 *  MyAllocUnicode
 *  Given an array of MBCS strings, allocate a new array of Unicode strings
 *
 *  IN
 *      ppszAscii        - array of MBCS strings
 *      cpwszUnicode     - number of elements to translate
 *  OUT
 *      ppwszUnicode     - output array of UnicodeStrings
 *
 *  RETURNS
 *      Error code, 0 if successful.
 *
 */
DWORD
MyAllocUnicodeVector(
    LPSTR * ppszAscii,
    LPWSTR* ppwszUnicode,
    UINT    cpwszUnicode )
{
    DWORD    err;
    UINT    i;

    for (i = 0; i < cpwszUnicode; ++i)
    {
        err = MyAllocUnicode(ppszAscii[i], ppwszUnicode+i);
        if (err)
        {
            MyFreeUnicodeVector(ppwszUnicode,i);
            return err;
        }
    }

    return NERR_Success;
}


/*
 *  MyFreeUnicode
 *  Deallocates a Unicode string alloc'd by MyAllocUnicode (q.v.).
 *
 *  IN
 *      pwszUnicode - pointer to the alloc'd string
 */

VOID
MyFreeUnicode( LPWSTR pwszUnicode )
{
    if (pwszUnicode != NULL)
        NetpMemoryFree((LPBYTE)pwszUnicode);
}


/*
 *  MyFreeUnicodeVector
 *  Deallocates an array of Unicodes string alloc'd by MyAllocUnicodeVector.
 *
 *  IN
 *      pp - pointer to the array of strings
 */

VOID
MyFreeUnicodeVector(
    LPWSTR * ppwsz,
    UINT     cpwsz )
{
    while (cpwsz-- > 0)
    {
        MyFreeUnicode(*ppwsz);
        *ppwsz = NULL ;
        ppwsz++ ;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\msgrutil.c ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    msgrutil.c

Abstract:

    This file contains functions that are used by the messenger service
    and its API as well as the NetMessageSend API.

    This module contains the following helper routines:

        NetpNetBiosReset
        NetpNetBiosAddName
        NetpNetBiosDelName
        NetpNetBiosGetAdapterNumbers
        NetpNetBiosCall
        NetpNetBiosHangup
        NetpNetBiosReceive
        NetpNetBiosSend
        NetpStringToNetBiosName
        NetpNetBiosStatusToApiStatus
        NetpSmbCheck

    These function prototypes can be found in net\inc\msgrutil.h.

Authors:

    Rita Wong (ritaw) 26-July-1991
    Dan Lafferty (danl) 26-July-1991

Revision History:

    05-May-1992 JohnRo
        Quiet normal debug messages.
        Changed to use FORMAT_ equates for most things.
        Made changes suggested by PC-LINT.

--*/

#include <nt.h>         // NT definitions
#include <ntrtl.h>      // NT runtime library definitions
#include <nturtl.h>

#include <windows.h>    // Win32 constant definitions & error codes

#include <lmcons.h>     // LAN Manager common definitions
#include <lmerr.h>      // LAN Manager network error definitions

#include <debuglib.h>   // IF_DEBUG
#include <netdebug.h>   // NetpKdPrint(()), FORMAT_ equates.

#include <smbtypes.h>   // needed for smb.h
#include <smb.h>        // Server Message Block definitions
#include <nb30.h>       // NetBIOS 3.0 definitions

#include <string.h>     // strlen
#include <msgrutil.h>   // Function prototypes from this module
#include <icanon.h>     // I_NetNameCanonicalize()
#include <tstring.h>    // NetpAllocStrFromWStr(), STRLEN(), etc.
#include <lmapibuf.h>   // NetApiBufferFree().

static
NET_API_STATUS
NetpIssueCallWithRetries(
    IN  PNCB CallNcb,
    IN  UCHAR LanAdapterNumber
    );


NET_API_STATUS
NetpNetBiosReset(
    IN  UCHAR LanAdapterNumber
    )
/*++

Routine Description:

    This function resets LAN adapter.

Arguments:

    LanAdapterNumber - Supplies the number of the LAN adapter.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NCB Ncb;
    UCHAR NcbStatus;


    RtlZeroMemory((PVOID) &Ncb, sizeof(NCB));

    Ncb.ncb_command = NCBRESET;
    Ncb.ncb_lsn = 0;
    Ncb.ncb_callname[0] = 24;               // Max Num Sessions
    Ncb.ncb_callname[1] = 0;
    Ncb.ncb_callname[2] = 16;               // Max Num Names
    Ncb.ncb_callname[3] = 0;
    Ncb.ncb_lana_num = LanAdapterNumber;

    NcbStatus = Netbios(&Ncb);

    return NetpNetBiosStatusToApiStatus(NcbStatus);
}



NET_API_STATUS
NetpNetBiosAddName(
    IN  PCHAR NetBiosName,
    IN  UCHAR LanAdapterNumber,
    OUT PUCHAR NetBiosNameNumber OPTIONAL
    )
/*++

Routine Description:

    This function adds a NetBIOS name to the specified LAN adapter.

Arguments:

    NetBiosName - Supplies a NetBIOS name to be added.

    LanAdapterNumber - Supplies the number of the LAN adapter.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NCB Ncb;
    UCHAR NcbStatus;


    RtlZeroMemory((PVOID) &Ncb, sizeof(NCB));

    Ncb.ncb_command = NCBADDNAME;
    memcpy(Ncb.ncb_name, NetBiosName, NCBNAMSZ);
    Ncb.ncb_lana_num = LanAdapterNumber;

    NcbStatus = Netbios(&Ncb);

    if (NcbStatus == NRC_GOODRET) {

        IF_DEBUG(NETBIOS) {

            Ncb.ncb_name[NCBNAMSZ - 1] = '\0';
            NetpKdPrint(("[Netlib] Successfully added name " FORMAT_LPSTR ".  "
                    "Name number is " FORMAT_DWORD "\n",
                    Ncb.ncb_name, (DWORD) Ncb.ncb_num));
        }

        if (ARGUMENT_PRESENT(NetBiosNameNumber)) {
            *NetBiosNameNumber = Ncb.ncb_num;
        }

        return NERR_Success;
    }

    return NetpNetBiosStatusToApiStatus(NcbStatus);
}


NET_API_STATUS
NetpNetBiosDelName(
    IN  PCHAR NetBiosName,
    IN  UCHAR LanAdapterNumber
    )
/*++

Routine Description:

    This function adds a NetBIOS name to the specified LAN adapter.

Arguments:

    NetBiosName - Supplies a NetBIOS name to be added.

    LanAdapterNumber - Supplies the number of the LAN adapter.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NCB Ncb;
    UCHAR NcbStatus;


    RtlZeroMemory((PVOID) &Ncb, sizeof(NCB));

    Ncb.ncb_command = NCBDELNAME;
    memcpy(Ncb.ncb_name, NetBiosName, NCBNAMSZ);
    Ncb.ncb_lana_num = LanAdapterNumber;

    NcbStatus = Netbios(&Ncb);

    if (NcbStatus == NRC_GOODRET) {

        IF_DEBUG(NETBIOS) {

            Ncb.ncb_name[NCBNAMSZ - 1] = '\0';
            NetpKdPrint(("[Netlib] Successfully deleted name " FORMAT_LPSTR ".  "
                    "Name number is " FORMAT_DWORD "\n",
                    Ncb.ncb_name, (DWORD) Ncb.ncb_num));
        }

        return NERR_Success;
    }

    return NetpNetBiosStatusToApiStatus(NcbStatus);
}


NET_API_STATUS
NetpNetBiosGetAdapterNumbers(
    OUT PLANA_ENUM LanAdapterBuffer,
    IN  WORD LanAdapterBufferSize
    )
/*++

Routine Description:

Arguments:

    LanAdapterBuffer -  Returns LAN adapter numbers in this buffer.

    LanAdapterBufferSize - Supplies the size of the output buffer which LAN
        LAN adapter numbers will be written to.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NCB Ncb;


    RtlZeroMemory((PVOID) &Ncb, sizeof(NCB));

    Ncb.ncb_command = NCBENUM;
    Ncb.ncb_buffer = (char FAR *) LanAdapterBuffer;
    Ncb.ncb_length = LanAdapterBufferSize;

    return NetpNetBiosStatusToApiStatus(Netbios(&Ncb));
}


NET_API_STATUS
NetpStringToNetBiosName(
    OUT PCHAR NetBiosName,
    IN  LPTSTR String,
    IN  DWORD CanonicalizeType,
    IN  WORD Type
    )
/*++

Routine Description:

    This function converts a zero terminated string plus a specified NetBIOS
    name type into a 16-byte NetBIOS name:

          [ ANSI String ][ Space Padding ][Type]

    If the input string for the NetBIOS name is fewer than 15 characters,
    spaces will be used to pad the string to 15 characters.  The 16th byte
    designates the type of the NetBIOS name.

    Input strings that are longer than 15 characters will be truncated to
    15 characters.

Arguments:

    NetBiosName - Returns the formatted NetBIOS name.

    String - Supplies a pointer to a zero terminated string.

    CanonicalizeType - Supplies a value to determine how the string should be
        canonicalized.

    Type - Supplies the type of the NetBIOS name.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS Status = NERR_Success;
    DWORD i;
    DWORD SourceStringLen;
    LPSTR SourceString;

    SourceStringLen = STRLEN(String);

    Status = I_NetNameCanonicalize(
                 NULL,
                 String,
                 String,
                 (SourceStringLen + 1) * sizeof(TCHAR),
                 CanonicalizeType,
                 0
                 );

    if (Status != NERR_Success) {
        IF_DEBUG(NETBIOS) {
            NetpKdPrint(("[Netlib] Error canonicalizing message alias "
                    FORMAT_LPSTR " " FORMAT_API_STATUS "\n", String, Status));
        }
        return Status;
    }

    SourceString = NetpAllocStrFromWStr(String);

    if (SourceString == NULL) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Insure the string doesn't exceed the netbios name buffer.
    //

    if (SourceStringLen > NCBNAMSZ - 1) {
        SourceString[NCBNAMSZ - 1] = '\0';
    }
    (VOID) strncpy(NetBiosName, SourceString, NCBNAMSZ - 1);

    for (i = SourceStringLen; i < (NCBNAMSZ - 1); i++) {
        NetBiosName[i] = ' ';
    }

    NetBiosName[NCBNAMSZ - 1] = (CHAR) Type;

    (VOID) NetApiBufferFree(SourceString);

    return Status;
}


NET_API_STATUS
NetpNetBiosCall(
    IN  UCHAR LanAdapterNumber,
    IN  LPTSTR NameToCall,
    IN  LPTSTR Sender,
    OUT UCHAR *SessionNumber
    )
/*++

Routine Description:

    This function opens a session with the specified name to call.

Arguments:

    LanAdapterNumber - Supplies the number of the LAN adapter.

    NameToCall - Supplies the name to call.

    Sender - Supplies the name who makes the call.

    SessionNumber - Returns the session number of the session established.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS status;
    NCB Ncb;


    RtlZeroMemory((PVOID) &Ncb, sizeof(NCB));

    if ((status = NetpStringToNetBiosName(
                      Ncb.ncb_callname,
                      NameToCall,
                      NAMETYPE_MESSAGEDEST,
                      MESSAGE_ALIAS_TYPE
                      )) != NERR_Success) {
        return status;
    }

    if ((status = NetpStringToNetBiosName(
                      Ncb.ncb_name,
                      Sender,
                      NAMETYPE_MESSAGEDEST,
                      MESSAGE_ALIAS_TYPE
                      )) != NERR_Success) {
        return status;
    }

    Ncb.ncb_rto = 30;                   // Receives time out after 15 seconds
    Ncb.ncb_sto = 30;                   // Sends time out after 15 seconds
    Ncb.ncb_command = NCBCALL;          // Call (wait)
    Ncb.ncb_lana_num = LanAdapterNumber;

    //
    // Issue the NetBIOS call with retries
    //
    if (NetpIssueCallWithRetries(&Ncb, LanAdapterNumber) != NERR_Success) {
        return NERR_NameNotFound;
    }

    *SessionNumber = Ncb.ncb_lsn;

    return NERR_Success;
}



NET_API_STATUS
NetpNetBiosHangup(
    IN  UCHAR LanAdapterNumber,
    IN  UCHAR SessionNumber
    )
/*++

Routine Description:

    This function closes and opened session.

Arguments:

    LanAdapterNumber - Supplies the number of the LAN adapter.

    SessionNumber - Supplies the session number of the session to close.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NCB Ncb;
    UCHAR NcbStatus;


    RtlZeroMemory((PVOID) &Ncb, sizeof(NCB));

    Ncb.ncb_command = NCBHANGUP;
    Ncb.ncb_lana_num = LanAdapterNumber;
    Ncb.ncb_lsn = SessionNumber;

    NcbStatus = Netbios(&Ncb);

    if (NcbStatus == NRC_GOODRET) {

        IF_DEBUG(NETBIOS) {
            NetpKdPrint(("[Netlib] NetBIOS successfully hung up\n"));
        }

        return NERR_Success;
    }

    return NetpNetBiosStatusToApiStatus(NcbStatus);
}



NET_API_STATUS
NetpNetBiosSend(
    IN  UCHAR LanAdapterNumber,
    IN  UCHAR SessionNumber,
    IN  PCHAR SendBuffer,
    IN  WORD SendBufferSize
    )
/*++

Routine Description:

    This function sends data in SendBuffer to the session partner specified
    by SessionNumber.

Arguments:

    LanAdapterNumber - Supplies the number of the LAN adapter.

    SessionNumber - Supplies the session number of a session established with
        NetBIOS CALL and LISTEN commands.

    SendBuffer - Supplies a pointer to data to be sent.

    SendBufferSize - Supplies the size of the data in bytes.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NCB Ncb;
    UCHAR NcbStatus;


    RtlZeroMemory((PVOID) &Ncb, sizeof(NCB));

    Ncb.ncb_command = NCBSEND;
    Ncb.ncb_lana_num = LanAdapterNumber;
    Ncb.ncb_lsn = SessionNumber;
    Ncb.ncb_buffer = SendBuffer;
    Ncb.ncb_length = SendBufferSize;

    NcbStatus = Netbios(&Ncb);

    if (NcbStatus == NRC_GOODRET) {

        IF_DEBUG(NETBIOS) {
            NetpKdPrint(("[Netlib] NetBIOS successfully sent data\n"));
        }

        return NERR_Success;
    }

    return NetpNetBiosStatusToApiStatus(NcbStatus);
}


NET_API_STATUS
NetpNetBiosReceive(
    IN  UCHAR LanAdapterNumber,
    IN  UCHAR SessionNumber,
    OUT PUCHAR ReceiveBuffer,
    IN  WORD ReceiveBufferSize,
    IN  HANDLE EventHandle,
    OUT WORD *NumberOfBytesReceived
    )
/*++

Routine Description:

    This function posts a NetBIOS receive data request to the session
    partner specified by SessionNumber.

Arguments:

    LanAdapterNumber - Supplies the number of the LAN adapter.

    SessionNumber - Supplies the session number of a session established with
        NetBIOS CALL and LISTEN commands.

    ReceiveBuffer - Returns the received data in this buffer.

    ReceiveBufferSize - Supplies the size of the receive buffer.

    EventHandle - Supplies a handle to a Win32 event which will be signalled
        when an ASYNCH receive command completes.  If this value is zero,
        the receive command is synchronous.

    NumberOfBytesReceived - Returns the number of bytes of data received.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NCB Ncb;
    UCHAR NcbStatus;


    RtlZeroMemory((PVOID) &Ncb, sizeof(NCB));

    Ncb.ncb_command = NCBRECV;
    Ncb.ncb_lana_num = LanAdapterNumber;
    Ncb.ncb_lsn = SessionNumber;
    Ncb.ncb_buffer = ReceiveBuffer;
    Ncb.ncb_length = ReceiveBufferSize;

    IF_DEBUG(NETBIOS) {
        NetpKdPrint(("[Netlib] ncb_length before receive is " FORMAT_WORD_ONLY
                "\n", (WORD) Ncb.ncb_length));
    }

    Ncb.ncb_event = EventHandle;

    NcbStatus = Netbios(&Ncb);

    if (NcbStatus == NRC_GOODRET) {

        IF_DEBUG(NETBIOS) {
            NetpKdPrint(("[Netlib] NetBIOS successfully received data\n"));
            NetpKdPrint(("[Netlib] ncb_length after receive is "
                    FORMAT_WORD_ONLY "\n", (WORD) Ncb.ncb_length));
        }

        *NumberOfBytesReceived = Ncb.ncb_length;

        return NERR_Success;
    }


    return NetpNetBiosStatusToApiStatus(NcbStatus);
}





NET_API_STATUS
NetpNetBiosStatusToApiStatus(
    UCHAR NetBiosStatus
    )
{
    IF_DEBUG(NETBIOS) {
        NetpKdPrint(("[Netlib] Netbios status is x%02x\n", NetBiosStatus));
    }

    //
    // Slight optimization
    //
    if (NetBiosStatus == NRC_GOODRET) {
        return NERR_Success;
    }

    switch (NetBiosStatus) {
        case NRC_NORES:   return NERR_NoNetworkResource;

        case NRC_DUPNAME: return NERR_AlreadyExists;

        case NRC_NAMTFUL: return NERR_TooManyNames;

        case NRC_ACTSES:  return NERR_DeleteLater;

        case NRC_REMTFUL: return ERROR_REM_NOT_LIST;

        case NRC_NOCALL:  return NERR_NameNotFound;

        case NRC_NOWILD:
        case NRC_NAMERR:
                          return ERROR_INVALID_PARAMETER;

        case NRC_INUSE:
        case NRC_NAMCONF:
                          return NERR_DuplicateName;

        default:          return NERR_NetworkError;
    }

}


static
NET_API_STATUS
NetpIssueCallWithRetries(
    IN  PNCB CallNcb,
    IN  UCHAR LanAdapterNumber
    )
/*++

Routine Description:

    This function issues the NetBIOS call command with retries, just in case
    the receiving name is busy fielding a message at the moment.

Arguments:

    CallNcb - Supplies a pointer to the NCB which has been initialized with
        the proper values to submit an NetBIOS call command.

    LanAdapterNumber - Supplies the number of the LAN adapter.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{

#define NETP_MAX_CALL_RETRY   5

    NCB Ncb;
    WORD RetryCount = 0;
    UCHAR NetBiosStatus;
    NB30_ADAPTER_STATUS StatusBuffer;           // Adapter status buffer


    //
    // It is possible that the remote receiving name is present but is
    // currently receiving another message and so is not listening.
    // If the return code from the call is NRC_NOCALL then check to see if
    // the name is actually present by issuing an ASTAT call to the name.
    // If the ASTAT succeeds then sleep and retry the call.
    //

    NetBiosStatus = Netbios(CallNcb);

    while (NetBiosStatus == NRC_NOCALL && RetryCount < NETP_MAX_CALL_RETRY) {

        //
        // Initialize ASTAT NCB
        //
        RtlZeroMemory((PVOID) &Ncb, sizeof(NCB));

        memcpy(Ncb.ncb_callname, CallNcb->ncb_callname, NCBNAMSZ);

        Ncb.ncb_buffer = (char FAR *) &StatusBuffer;
        Ncb.ncb_length = sizeof(StatusBuffer);
        Ncb.ncb_command = NCBASTAT;              // Adapter status (wait)
        Ncb.ncb_lana_num = LanAdapterNumber;

        //
        // If failed, name is not present
        //
        if (Netbios(&Ncb) != NRC_GOODRET) {
            return NERR_NameNotFound;
        }

        Sleep(1000L);

        RetryCount++;

        NetBiosStatus = Netbios(CallNcb);
    }

    return NetpNetBiosStatusToApiStatus(NetBiosStatus);
}



int
NetpSmbCheck(
    IN LPBYTE  buffer,     // Buffer containing SMB
    IN USHORT  size,       // size of SMB buffer (in bytes)
    IN UCHAR   func,       // Function code
    IN int     parms,      // Parameter count
    IN LPSTR   fields      // Buffer fields dope vector
    )

/*++

Routine Description:

    Checks Server Message Block for syntactical correctness

    This function is called to verify that a Server Message Block
    is of the specified form.  The function returns zero if the
    SMB is correct; if an error is detected, a non-zero value
    indicating the nature of the error is returned.

    An SMB is a variable length structure whose exact size
    depends on the setting of certain fixed-offset fields
    and whose exact format cannot be determined except by
    examination of the whole structure.  Smbcheck checks to
    see that an SMB conforms to a set of specified conditions.
    The "fields" parameter is a dope vector that describes the
    individual fields to be found in the buffer section at the
    end of the SMB.  The vector is a null-terminated character
    string.  Currently, the elements of the string must be as
    follows:

     'b' - the next element in the buffer area should be
           a variable length buffer prefixed with a byte
           containing either 1 or 5 followed by two bytes
           containing the size of the buffer.
     'd' - the next element in the buffer area is a null-terminated
           string prefixed with a byte containing 2.
     'p' - the next element in the buffer area is a null-terminated
           string prefixed with a byte containing 3.
     's' - the next element in the buffer area is a null-terminated
           string prefixed with a byte containing 4.

Arguments:

    buffer - a pointer to the buffer containing the SMB

    size - the number of bytes in the buffer

    func - the expected SMB function code

    parms - the expected number of parameters

    fields - a dope vector describing the expected buffer fields
        within the SMB's buffer area (see below).


Return Value:

    an integer status code; zero indicates no errors.


--*/
{
    PSMB_HEADER     smb;        // SMB header pointer
    LPBYTE          limit;      // Upper limit


    smb = (PSMB_HEADER) buffer;         // Overlay header with buffer

    //
    // Must be long enough for header
    //
    if(size < sizeof(SMB_HEADER)) {
        return(2);
    }

    //
    // Message type must be 0xFF
    //
    if(smb->Protocol[0] != 0xff) {
        return(3);
    }

    //
    // Server must be "SMB"
    //
    if( smb->Protocol[1] != 'S'   ||
        smb->Protocol[2] != 'M'   ||
        smb->Protocol[3] != 'B')  {
        return(4);
    }

    //
    // Must have proper function code
    //
    if(smb->Command != func) {
        return(5);
    }

    limit = &buffer[size];              // Set upper limit of SMB

    buffer += sizeof(SMB_HEADER);       // Skip over header

    //
    // Parameter counts must match
    //
    if(*buffer++ != (BYTE)parms) {
        return(6);
    }

    //
    // Skip parameters and buffer size
    //
    buffer += (((SHORT)parms & 0xFF) + 1)*sizeof(SHORT);

    //
    // Check for overflow
    //
    if(buffer > limit) {
        return(7);
    }

    //
    // Loop to check buffer fields
    //
    while(*fields) {

        //
        // Switch on dope vector character
        //
        switch(*fields++)  {

        case 'b':       // Variable length data block

            if(*buffer != '\001' && *buffer != '\005') {
                return(8);
            }

            //
            // Check for block code
            //
            ++buffer;                                       // Skip over block code
            size =  (USHORT)*buffer++ & (USHORT)0xFF;       // Get low-byte size
            size += ((USHORT)*buffer++ & (USHORT)0xFF)<< 8; // Get high-byte of buffer size
            buffer += size;                                 // Increment pointer

            break;

        case 'd':       // Null-terminated dialect string

            if(*buffer++ != '\002') {           // Check for string code
                return(9);
            }
            buffer += strlen((LPVOID) buffer) + 1;       // Skip over the string
            break;

        case 'p':       // Null-terminated path string

            if(*buffer++ != '\003') {           // Check for string code
                return(10);
            }
            buffer += strlen((LPVOID) buffer) + 1;       // Skip over the string
            break;

        case 's':       // Null-terminated string

            if(*buffer++ != '\004') {           // Check for string code
                return(11);
            }
            buffer += strlen((LPVOID) buffer) + 1;       // Skip over the string
            break;
        }

        //
        // Check against end of block
        //

        if(buffer > limit) {
            return(12);
        }
    }
    return(buffer != limit);      // Should be false
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\movestr.c ===
/*++

Copyright (c) 1989-91  Microsoft Corporation

Module Name:

    mapsupp.c

Abstract:

    Support routines used by the LanMan 16/32 mapping routines.

Author:

    Dan Hinsley (danhi) 25-Mar-1991

Environment:

    User mode only.

Revision History:

    25-Mar-1991 DanHi
        Created.
    18-Aug-1991 JohnRo
        Implement downlevel NetWksta APIs.  (Moved this routine to NetLib for
        use by RpcXlate as well as NetCmd/Map32 stuff.)
        Changed to allow UNICODE.
        Changed name to NetpMoveStrings.
        Got rid of tabs in source file.

--*/


// These must be included first:

#include <windef.h>             // BOOL, IN, LPTSTR, etc.

// These may be included in any order:

#include <mapsupp.h>            // My prototype, LPMOVESTRING.
#include <tstring.h>            // STRCPY().



BOOL
NetpMoveStrings(
    IN OUT LPTSTR * Floor,
    IN LPTSTR pInputBuffer,
    OUT LPTSTR pOutputBuffer,
    IN LPMOVESTRING MoveStringArray,
    IN LPDWORD MoveStringLength
    )

/*++

Routine Description:

    This function is used to move a variable number of strings into a user's
    buffer, and to update pointers in a structure to point to the location
    where they are copied.  According to the semantics of the LM 2.0 API,
    each buffer is filled with fixed length structures from the top, while
    variable length strings are copied in from the bottom.

    There are two companion arrays, MoveStringArray and MoveStringLength.
    MoveStringArray contains the offset to the source string in the input
    buffer, and the offset of the pointers in the fixed structure from the
    beginning of the output buffer.

    MoveStringLength contains an entry for each entry in MoveStringArray,
    and this entry is the length of the source string in MoveStringArray.
    This was broken into two arrays so that MoveStringArray could be built
    at compile time and not be modified at run time.

Arguments:

    Floor  -  This is the bottom of the user's buffer, where the strings
              will be copied.  This must be updated to reflect the strings
              that are copied into the buffer

    pInputBuffer - The buffer which contains the source strings.
              MoveStringArray contains offsets into this buffer.

    pOutputBuffer - The buffer which contains the fixed portion of the info
              structure, which contains fields that need to be set to point
              to the string locations in the output buffer. MoveStringArray
              contains offsets into this buffer.

    MoveStringArray - This is an array of MOVESTRING entries, terminated
              by an entry with a source offset of MOVESTRING_END_MARKER.  Each
              entry describes a string, and the address of a variable which will
              hold the address where the string is copied.

    MoveStringLength - This is a companion array to MoveStringArray.
              Each entry contains the length of the matching source string
              from MoveStringArray.

Side Effects:

    There are pointers in the MoveStringArray that point to pointers in the
    fixed length portion of the structure.  These are updated with the
    location in the buffer where the string is copied.

Return Value:

    TRUE  if the strings were successfully copied,
    FALSE if the strings would not all fit in the buffer.

--*/

{

    //
    // Move them all in, and update Floor
    //

    while(MoveStringArray->Source != MOVESTRING_END_MARKER) {

        //
        // Since the following is a really gross piece of code, let me
        // explain:
        //    pInputBuffer is a pointer to the start of a lanman struct and
        //    MoveStringArray->Source is an offset from the start of that
        //    structure to a PSZ.
        //

        // If this is a 0 length string, just place NULL in the pointer and
        // press on.

        if (*MoveStringLength == 0) {
            *((LPTSTR *) (((LPBYTE) pOutputBuffer)
                                + MoveStringArray->Destination)) = NULL;
        }
        else {
            //
            // Back the pointer up since we're filling the buffer from the
            // bottom up, then do the copy
            //

            *Floor -= *MoveStringLength;

            (void) STRCPY(*Floor,
                *((LPTSTR*)((LPBYTE)pInputBuffer + MoveStringArray->Source)));

            //
            // Update the field in the structure which points to the string
            //
            //          pOutputBuffer is a pointer to the start of a lanman struct
            //          and MoveStringArray->Destination is an offset from the start
            //          of that structure to a PSZ that needs to have the address of
            //          the just copied string put into it.
            //

            *((LPTSTR*) ((LPBYTE)pOutputBuffer + MoveStringArray->Destination)) =
                *Floor;
        }

        //
        // Now let's do the next one
        //

        MoveStringArray++;
        MoveStringLength++;
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\namecan.c ===
/*++

Copyright (c) 1989-91  Microsoft Corporation

Module Name:

    namecan.c

Abstract:

    Net name canonicalization routines:

        NetpwNameCanonicalize

Author:

    Richard L Firth (rfirth) 06-Jan-1992
    Chandana Surlu (chandans) 19-Dec-1979 Modified to use this util on WIN9x

Revision History:

--*/

#ifdef WIN32_CHICAGO
// yes, this is strange, but all internal data for DsGetDcname are maintained
// in unicode but we don't define UNICODE globally. Therefore, this hack
//  -ChandanS
#define UNICODE 1
#endif // WIN32_CHICAGO
#include "nticanon.h"
#include <netlibnt.h> // NetpNtStatusToApiStatus


//
// data
//

static TCHAR szShareTrailChars[] = TEXT(". ");

//
// functions
//


NET_API_STATUS
NetpwNameCanonicalize(
    IN  LPTSTR  Name,
    OUT LPTSTR  Outbuf,
    IN  DWORD   OutbufLen,
    IN  DWORD   NameType,
    IN  DWORD   Flags
    )

/*++

Routine Description:

    NetpwNameCanonicalize converts a LANMAN object name to canonical
    form.  In the current implementation, that simply means converting
    the name to upper case (except for passwords).

    This function supports canonicalization in place because in the
    current world, canonicalization just consists of convert a name to
    upper case.  If in the future canonicalization becomes more
    sophisticated, this function will have to allocate a buffer
    internally to allow it to do canonicalization.

Arguments:

    Name        - The name to canonicalize.

    Outbuf      - The place to store the canonicalized version of the name.
                  Note that if <Name> and <Outbuf> are the same it will
                  canonicalize the name in place.

    OutbufLen   - The size, in bytes, of <Outbuf>.

    NameType    - The type of the LANMAN object names.  Valid values are
                  specified by NAMETYPE_* manifests in NET\H\ICANON.H.

    Flags       - Flags to determine operation.  Currently defined values are:

                    CrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrL

                  where:

                    C = LM2.x compatible name canonicalization

                    r = Reserved.  MBZ.

                    L = If set, the function requires the length of the output
                        buffer to be sufficient to hold any name of the specified
                        type (e.g. CNLEN+1 if the name type is NAMETYPE_COMPUTER).
                        Otherwise, the buffer length only needs to be large
                        enough to hold the canonicalized version of the input
                        name specified in this invocation of the function (e.g.
                        5, if the canonicalized name is "TEST").

Return Value:

    NET_API_STATUS
        Success - NERR_Success

        Failure - ERROR_INVALID_PARAMETER
                    Flags has a reserved bit on

                  ERROR_INVALID_NAME
                    Supplied name cannot be successfully canonicalized

                  NERR_BufTooSmall
                    Caller's output buffer not large enough to hold canonicalized
                    name, or maximum canonicalized name for type if L bit on in
                    Flags

--*/

{
    NET_API_STATUS  RetVal = 0;
    DWORD   NameLen;
    DWORD   MaxNameLen;
    BOOL    UpperCase = FALSE;      // default for NT names


#ifdef CANONDBG
    DbgPrint("NetpwNameCanonicalize\n");
#endif

    //
    // Parameter validation
    //

    if (Flags & INNCA_FLAGS_RESERVED) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Compute the length of the string
    //
    // Note that share names need special handling, because trailing
    // dots and spaces are not significant.
    //

#ifndef WIN32_CHICAGO

    if (NameType == NAMETYPE_SHARE) {
        NameLen = (DWORD)(strtail(Name, szShareTrailChars) - Name);
    } else {
        NameLen = STRLEN(Name);
    }

#else

        NameLen = STRLEN(Name);

#endif // WIN32_CHICAGO

    RetVal = NetpwNameValidate(Name, NameType, 0L);
    if (RetVal) {
        return RetVal;
    }

    //
    // Determine the size of the buffer needed and whether or not to
    // upper case the name.
    //

    switch (NameType) {
    case NAMETYPE_USER:
        if (Flags & LM2X_COMPATIBLE) {
            MaxNameLen = LM20_UNLEN;
            UpperCase = TRUE;
        } else {
            MaxNameLen = UNLEN;
        }
        break;

    case NAMETYPE_GROUP:
        if (Flags & LM2X_COMPATIBLE) {
            MaxNameLen = LM20_GNLEN;
            UpperCase = TRUE;
        } else {
            MaxNameLen = GNLEN;
        }
        break;

    case NAMETYPE_COMPUTER:
        if (Flags & LM2X_COMPATIBLE) {
            MaxNameLen = LM20_CNLEN;
            UpperCase = TRUE;
        } else {
            MaxNameLen = MAX_PATH-1;    // allow for null
        }
        break;

    case NAMETYPE_EVENT:    // Used only by the Alerter service
        MaxNameLen = EVLEN;
        UpperCase = TRUE;
        break;

    case NAMETYPE_DOMAIN:
        if (Flags & LM2X_COMPATIBLE) {
            MaxNameLen = LM20_DNLEN;
            UpperCase = TRUE;
        } else {
            MaxNameLen = DNLEN;
        }
        break;

    case NAMETYPE_SERVICE:
        if (Flags & LM2X_COMPATIBLE) {
            MaxNameLen = LM20_SNLEN;
            UpperCase = TRUE;
        } else {
            MaxNameLen = SNLEN;
        }
        break;

    case NAMETYPE_NET:
//#if DBG
//        DbgPrint("NAMETYPE_NET being used. Please notify rfirth. Hit 'i' to continue\n");
//       ASSERT(FALSE);
//#endif
        MaxNameLen = MAX_PATH - 1;  // allow for NULL
        UpperCase = TRUE;
        break;

    case NAMETYPE_SHARE:
        if (Flags & LM2X_COMPATIBLE) {
            MaxNameLen = LM20_NNLEN;
            UpperCase = TRUE;
        } else {
            MaxNameLen = NNLEN;
        }
        break;

    case NAMETYPE_PASSWORD:
        if (Flags & LM2X_COMPATIBLE) {
            MaxNameLen = LM20_PWLEN;
        } else {
            MaxNameLen = PWLEN;
        }
        break;

    case NAMETYPE_SHAREPASSWORD:
        MaxNameLen = SHPWLEN;
        break;

    case NAMETYPE_MESSAGE:
//#if DBG
//        DbgPrint("NAMETYPE_MESSAGE being used. Please notify rfirth. Hit 'i' to continue\n");
//        ASSERT(FALSE);
//#endif
        MaxNameLen = (MAX_PATH - 1);
        UpperCase = TRUE;
        break;

    case NAMETYPE_MESSAGEDEST:
        MaxNameLen = MAX_PATH - 1;  // allow for NULL
        UpperCase = TRUE;
        break;

    case NAMETYPE_WORKGROUP:
        if (Flags & LM2X_COMPATIBLE) {
            MaxNameLen = LM20_DNLEN;
            UpperCase = TRUE;
        } else {
            MaxNameLen = DNLEN;
        }
        break;

    default:

        //
        // The caller specified an invalid name type.
        //
        // NOTE:  This should already have been caught by
        //        NetpwNameValidate(), so this code should
        //        never be reached.
        //

        return ERROR_INVALID_PARAMETER;
    }

    //
    // Check the buffer is large enough, abort if it isn't
    //

    if (Flags & INNCA_FLAGS_FULL_BUFLEN) {
        NameLen = MaxNameLen;
    }
    if (OutbufLen < (NameLen + 1) * sizeof(TCHAR)) {
        return NERR_BufTooSmall;
    }

    //
    // If the input buffer and output buffer are not the same, copy
    // the name to the output buffer.
    //

    if (Name != Outbuf) {
        STRNCPY(Outbuf, Name, NameLen);
    }

    //
    // Note that we copy in a terminating null even if the input and
    // output buffer are the same.  This is to handle the case of
    // a share name from which trailing characters need to be stripped.
    //

    Outbuf[NameLen] = TCHAR_EOS;

#ifndef WIN32_CHICAGO
    // We never set Uppercase anyway. -ChandanS

    //
    // Upper-case the name, if appropriate
    //

    if (UpperCase) {

        NTSTATUS status;
        UNICODE_STRING stringOut;
        UNICODE_STRING stringIn;

        RtlInitUnicodeString(&stringIn, Name);
        stringOut.Buffer = Outbuf;
        stringOut.Length = 0;
        stringOut.MaximumLength = (USHORT)OutbufLen;
        status = RtlUpcaseUnicodeString(&stringOut, &stringIn, FALSE);
        if (!NT_SUCCESS(status)) {
            return NetpNtStatusToApiStatus(status);
        }
    }
#endif // WIN32_CHICAGO
    return NERR_Success;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\namecmp.c ===
/*++

Copyright (c) 1989-91  Microsoft Corporation

Module Name:

    namecmp.c

Abstract:

    Net name comparison functions:

        NetpwNameCompare
        CompareOemNames

Author:

    Richard L Firth (rfirth) 06-Jan-1992

Revision History:

--*/

#include "nticanon.h"

//
// prototypes
//

LONG
CompareOemNames(
    IN LPWSTR Name1,
    IN LPWSTR Name2,
    IN BOOL CaseInsensitive
    );

//
// data
//

static  TCHAR   szShareTrailChars[]     = TEXT(". ");

//
// routines
//


LONG
NetpwNameCompare(
    IN  LPTSTR  Name1,
    IN  LPTSTR  Name2,
    IN  DWORD   NameType,
    IN  DWORD   Flags
    )

/*++

Routine Description:

    Compares two LANMAN object names to see if they are the same. If the
    supplied names are not canonicalized this function will do the
    canonicalization of the names.

    This function does not do name validation.  It assumes that the two names
    have been validated separately.

    This function relies on the fact that the only difference between a
    canonicalized object name and an uncanonicalized object name is the case.

        (say what?...)

Arguments:

    Name1       - The first name to compare.

    Name2       - The second name to compare.

    NameType    - The type of the LANMAN object names.  Valid values are
                  specified by NAMETYPE_* manifests in ICANON.H.

    Flags       - Flags to determine operation.  Currently defined values are:

                    Xrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrc

                  where:

                    X = LM 2.x Compatibility

                    r = Reserved. MBZ.

                    c = should be set if both of the names have already been
                        canonicalized (using NetpwNameCanonicalize).

Return Value:

    0 if the two names match.

    Non-zero if they don't match, or if an invalid parameter is
    specified.

--*/

{
    LONG RetVal;
    NET_API_STATUS rc;
    TCHAR tName1[PATHLEN+1];
    TCHAR tName2[PATHLEN+1];

#ifdef CANONDBG
    DbgPrint("NetpwNameCompare\n");
#endif

    //
    // Parameter validation
    //

    if (Flags & INNC_FLAGS_RESERVED) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Determine which of the canonicalization functions to use.  We
    // use stricmp() if the names are not canonicalized and are not
    // case sensitive and strcmp() if the names are canonicalized or
    // if they are case sensitive.
    //

    switch (NameType) {

    //
    // Case insensitive name types
    //

    case NAMETYPE_USER:
    case NAMETYPE_GROUP:
    case NAMETYPE_COMPUTER:
    case NAMETYPE_EVENT:
    case NAMETYPE_DOMAIN:
    case NAMETYPE_SERVICE:
    case NAMETYPE_NET:
    case NAMETYPE_WORKGROUP:

        //
        // Use the case sensitive version if the names have been
        // canonicalized.
        //

        if (!(Flags & INNC_FLAGS_NAMES_CANONICALIZED)) {
            rc = NetpwNameCanonicalize(Name1,
                                       tName1,
                                       sizeof(tName1),
                                       NameType,
                                       Flags & LM2X_COMPATIBLE
                                       );
            if (rc != NERR_Success) {
                return rc;
            }
            rc = NetpwNameCanonicalize(Name2,
                                       tName2,
                                       sizeof(tName2),
                                       NameType,
                                       Flags & LM2X_COMPATIBLE
                                       );
            if (rc != NERR_Success) {
                return rc;
            }
        } else {
            LONG Name1Length, Name2Length;

            Name1Length = STRLEN(Name1);
            Name2Length = STRLEN(Name2);

            if ((Name1Length > PATHLEN) ||
                (Name2Length > PATHLEN)) {
                return ERROR_INVALID_PARAMETER;
            } else {
                STRCPY(tName1, Name1);
                STRCPY(tName2, Name2);
            }
        }
        if (Flags & (LM2X_COMPATIBLE)) {
            if (NameType == NAMETYPE_COMPUTER
            || NameType == NAMETYPE_DOMAIN
            || NameType == NAMETYPE_WORKGROUP) {
                return CompareOemNames(tName1, tName2, FALSE);
            } else {
                return STRCMP(tName1, tName2);
            }
        } else {
            if (NameType == NAMETYPE_COMPUTER
            || NameType == NAMETYPE_DOMAIN
            || NameType == NAMETYPE_WORKGROUP) {
                return CompareOemNames(tName1, tName2, TRUE);
            } else {
                return STRICMP(tName1, tName2);
            }
        }

    //
    // Case sensitive name types
    //

    case NAMETYPE_PASSWORD:
    case NAMETYPE_SHAREPASSWORD:
    case NAMETYPE_MESSAGE:
    case NAMETYPE_MESSAGEDEST:
        return STRCMP(Name1, Name2);

    //
    // Special handling for sharenames, since we mustn't consider
    // trailing dots and spaces in the comparison if the names haven't
    // been canonicalized.
    //

    case NAMETYPE_SHARE:
        if (Flags & INNC_FLAGS_NAMES_CANONICALIZED) {
            if (Flags & LM2X_COMPATIBLE) {
                return STRCMP(Name1, Name2);
            } else {
                return STRICMP(Name1, Name2);
            }
        } else {
            register DWORD RealLen1, RealLen2;

            RealLen1 = (DWORD)(strtail(Name1, szShareTrailChars) - Name1);
            RealLen2 = (DWORD)(strtail(Name2, szShareTrailChars) - Name2);

            //
            // If the lengths of the significant portions match, compare
            // these portions.  Otherwise, return non-zero based on this
            // length.
            //

            if (RealLen1 == RealLen2) {
                return STRNICMP(Name1, Name2, RealLen1);
            } else {
                return RealLen1 > RealLen2 ? 1 : -1;
            }
        }

    default:

        //
        // The caller specified an invalid name type
        //

        return ERROR_INVALID_PARAMETER;
    }
}


LONG
CompareOemNames(
    IN LPWSTR Name1,
    IN LPWSTR Name2,
    IN BOOL CaseInsensitive
    )

/*++

Routine Description:

    Converts 2 UNICODE name strings to corresponding OEM character set strings
    and then compares them

Arguments:

    Name1           -
    Name2           -
    CaseInsensitive - TRUE if compare without case

Return Value:

    LONG
        <0  Name1 less than Name2
         0  Names match
        >0  Name1 greater than Name2

--*/

{
    CHAR oemName1[PATHLEN + 1];
    ULONG oemByteLength1;
    ULONG name1Length;
    CHAR oemName2[PATHLEN + 1];
    ULONG oemByteLength2;
    ULONG name2Length;
    NTSTATUS ntStatus;

    name1Length = wcslen(Name1);
    name2Length = wcslen(Name2);

    //
    // only prepared to consider names within our upper length limit
    //

    if (name1Length >= sizeof(oemName1) || name2Length >= sizeof(oemName2)) {
        return -1;
    }

    //
    // convert UNICODE names to OEM
    //

    ntStatus = RtlUpcaseUnicodeToOemN(oemName1,
                                      sizeof(oemName1) - 1,
                                      &oemByteLength1,
                                      Name1,
                                      name1Length * sizeof(*Name1)
                                      );
    if (!NT_SUCCESS(ntStatus)) {
        return -1;
    } else {
        oemName1[oemByteLength1] = 0;
    }
    ntStatus = RtlUpcaseUnicodeToOemN(oemName2,
                                      sizeof(oemName2) - 1,
                                      &oemByteLength2,
                                      Name2,
                                      name2Length * sizeof(*Name2)
                                      );
    if (!NT_SUCCESS(ntStatus)) {
        return -1;
    } else {
        oemName2[oemByteLength2] = 0;
    }

    if (CaseInsensitive) {
        return _stricmp(oemName1, oemName2);
        }
    else {
        return strcmp(oemName1, oemName2);
        }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\nameval.c ===
/*++

Copyright (c) 1989-91  Microsoft Corporation

Module Name:

    nameval.c

Abstract:

    (Internal) net name validation functions:

        NetpwNameValidate

Author:

    Richard L Firth (rfirth) 06-Jan-1992
    Chandana Surlu (chandans) 19-Dec-1979 Modified to use this util on WIN9x

Revision History:

--*/

#ifdef WIN32_CHICAGO
// yes, this is strange, but all internal data for DsGetDcname are maintained
// in unicode but we don't define UNICODE globally. Therefore, this hack
//  -ChandanS
#define UNICODE 1
#endif // WIN32_CHICAGO
#include "nticanon.h"

const TCHAR szNull[]                   = TEXT("");
const TCHAR szStandardIllegalChars[]   = ILLEGAL_NAME_CHARS_STR TEXT("*");
const TCHAR szComputerIllegalChars[]   = ILLEGAL_NAME_CHARS_STR TEXT("*");
const TCHAR szDomainIllegalChars[]     = ILLEGAL_NAME_CHARS_STR TEXT("*") TEXT(" ");
const TCHAR szMsgdestIllegalChars[]    = ILLEGAL_NAME_CHARS_STR;

#include <winnls.h>


NET_API_STATUS
NetpwNameValidate(
    IN  LPTSTR  Name,
    IN  DWORD   NameType,
    IN  DWORD   Flags
    )

/*++

Routine Description:

    Validates a LANMAN object name for character set and length

Arguments:

    Name        - The name to validate.

    NameType    - The type of the LANMAN object names.  Valid values are
                  specified by NAMETYPE_* manifests in NET\H\ICANON.H.

    Flags       - Flags to determine operation.  Currently MBZ.

Return Value:

    0 if successful.
    The error number (> 0) if unsuccessful.

    Possible error returns include:

        ERROR_INVALID_PARAMETER
        ERROR_INVALID_NAME

--*/

{
    DWORD    status;
    DWORD    name_len;
    DWORD    max_name_len;
    DWORD    min_name_len = 1;
    LPCTSTR  illegal_chars = szStandardIllegalChars;
    BOOL    fNoDotSpaceOnly = TRUE;
    DWORD   oem_name_len;

#ifdef CANONDBG
    DbgPrint("NetpwNameValidate\n");
#endif

    //
    // Parameter validation
    //

    if (Flags & INNV_FLAGS_RESERVED) {
        return ERROR_INVALID_PARAMETER;
    }

    name_len = STRLEN(Name);

    //
    // oem_name_len : length in bytes in oem character set
    // name_len     : ifdef UNICODE 
    //                    character length in unicode
    //                else
    //                    length in bytes in oem character set
    // 
    {
        BOOL fUsedDefault;

        oem_name_len = WideCharToMultiByte( 
                         CP_OEMCP,       // UINT CodePage
                         0,              // DWORD dwFlags
                         Name,           // LPWSTR lpWideChar
                         name_len,       // int cchWideChar
                         NULL,           // LPSTR lpMultiByteStr
                         0,              // int cchMultiByte
                         NULL,           // use system default char
                         &fUsedDefault); // 
    }

    //
    // Determine the minimum and maximum allowable length of the name and
    // the set of illegal name characters.
    //

    switch (NameType) {
    case NAMETYPE_USER:
        max_name_len = (Flags & LM2X_COMPATIBLE) ? LM20_UNLEN : UNLEN;
        break;

    case NAMETYPE_GROUP:
        max_name_len = (Flags & LM2X_COMPATIBLE) ? LM20_GNLEN : GNLEN;
        break;

    case NAMETYPE_COMPUTER:
        max_name_len = MAX_PATH;
        illegal_chars = szComputerIllegalChars;

        //
        // Computer names can't have trailing or leading blanks
        //

        if ( name_len > 0 && (Name[0] == L' ' || Name[name_len-1] == L' ') ) {
            return ERROR_INVALID_NAME;
        }
        break;

    case NAMETYPE_EVENT:
        max_name_len = EVLEN;
        break;

    case NAMETYPE_DOMAIN:
        max_name_len = (Flags & LM2X_COMPATIBLE) ? LM20_DNLEN : DNLEN;
        illegal_chars = szDomainIllegalChars;
        break;

    case NAMETYPE_SERVICE:
        max_name_len = (Flags & LM2X_COMPATIBLE) ? LM20_SNLEN : SNLEN;
        break;

    case NAMETYPE_NET:
        max_name_len = MAX_PATH;
        break;

    case NAMETYPE_SHARE:
        max_name_len = (Flags & LM2X_COMPATIBLE) ? LM20_NNLEN : NNLEN;
        break;

    case NAMETYPE_PASSWORD:
        max_name_len = (Flags & LM2X_COMPATIBLE) ? LM20_PWLEN : PWLEN;
        min_name_len = 0;
        illegal_chars = szNull;
        fNoDotSpaceOnly = FALSE;
        break;

    case NAMETYPE_SHAREPASSWORD:
        max_name_len = SHPWLEN;
        min_name_len = 0;
        illegal_chars = szNull;
        fNoDotSpaceOnly = FALSE;
        break;

    case NAMETYPE_MESSAGE:
       max_name_len = NETBIOS_NAME_LEN - 1;
       break;

    case NAMETYPE_MESSAGEDEST:
       max_name_len = MAX_PATH;   
       illegal_chars = szMsgdestIllegalChars;
       break;

    case NAMETYPE_WORKGROUP:

        //
        // workgroup is the same as domain, but allows spaces
        //

        max_name_len = (Flags & LM2X_COMPATIBLE) ? LM20_DNLEN : DNLEN;
        break;

    default:
        return ERROR_INVALID_PARAMETER; // unknown name type
    }

    //
    // Check the length of the name; return an error if it's out of range
    //

    if ((oem_name_len < min_name_len) || (oem_name_len > max_name_len)) {
        return ERROR_INVALID_NAME;
    }

    //
    // Check for illegal characters; return an error if one is found
    //

    if (NameType != NAMETYPE_NET && STRCSPN(Name, illegal_chars) < name_len) {
        return ERROR_INVALID_NAME;
    }

    //
    // If <fNoDotSpaceOnly> is TRUE, return an error if the name contains
    // only dots and spaces.
    //

    if (fNoDotSpaceOnly && STRSPN(Name, DOT_AND_SPACE_STR) == name_len) {
        return ERROR_INVALID_NAME;
    }

    //
    // Special case checking for MESSAGEDEST names:  '*' is allowed only as
    // the last character, and names of the maximum length must contain a
    // trailing '*'.
    //

    if (NameType == NAMETYPE_MESSAGEDEST) {
        LPTSTR  pStar;

        pStar = STRCHR(Name, TCHAR_STAR);
        if (pStar != NULL) {
            if ((DWORD)(pStar - Name) != name_len - 1) {
                return ERROR_INVALID_NAME;
            }
        } else {
            if (oem_name_len == max_name_len) {
                return ERROR_INVALID_NAME;
            }
        }
    }


    //
    // If we get here, the name passed all of the tests, so it's valid
    //

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\netjoin.c ===
/*++

Copyright (c) 1997 - 1997  Microsoft Corporation

Module Name:

    netjoin.c

Abstract:

    Implementation of the private Net setup apis for joining/unjoinging
    domains.

Author:

    Mac McLain   (MacM)     19-Feb-1997

Environment:

    User mode only.

Revision History:

--*/

// Netlib uses DsGetDcName AND is linked into netapi32 where DsGetDcName is
// implemented. So define that we aren't importing the API.
#define _DSGETDCAPI_

#include <netsetp.h>
#include <lmaccess.h>
#include <lmsname.h>
#include <winreg.h>
#include <wincrypt.h>
#include <icanon.h>
#include <dnsapi.h>
#include <netlib.h>
#include <dsgetdcp.h>
#include <dsrole.h>
#include <names.h>
#include "joinp.h"


/* -----------------------------------------------------------------
   Joining a domain
   ----------------

   When a computer joins a domain, the following changes occur on
   the computer and the dc of that domain. The changes are not made
   in the order shown here.

   changes on client computer:
   ---------------------------
   NT4 & NT5
   ~~~~~~~~~
   - create a LSA secret named $MACHINE.ACC. The value of this
     secret is the password to be used for accessing the machine
     account for this computer on the dc.
   - set LSA PolicyPrimaryDomainInformation. this includes:
     - domain name
     - domain SID
   - add certain user groups in the new domain to local groups
   - enable and start netlogon service

   NT5 only
   ~~~~~~~~~
   - update the netlogon cache to indicate the new domain details
   - set LSA PolicyDnsDomainInformation. this includes:
     - domain name
     - domain SID
     - dns domain name
     - dns forest name
     - domain guid
   - set ComputerNamePhysicalDnsDomain if changed.
   - enable and start w32time service
   - for performance reasons, record locally info about the dc
     on which machine account is created.

   whistler only
   -------------
   - instead of starting w32time, call w32time!W32TimeVerifyJoinConfig
     (when unjoining, call w32time!W32TimeVerifyUnjoinConfig instead)


   changes on dc:
   --------------
   NT4 & NT5
   ~~~~~~~~~
   - create a computer object. the name of this object is generated by
     appending a '$' to the uppercased name of the client computer.
     This object is protected by a password that is stored in $MACHINE.ACC
     as explained earlier.

   NT5 only
   ~~~~~~~~~
   - create SPN of the computer object
     this is not directly created by the netjoin code. netjoin code
     waits on netlogon to perform this creation.
  ----------------------------------------------------------------- */



NET_API_STATUS
NET_API_FUNCTION
NetpJoinWorkgroup(
    IN  LPWSTR      lpMachine,
    IN  LPWSTR      lpWrkgrp
    )
/*++

Routine Description:

    Joins the machine to the specified workgroup

Arguments:

    lpMachine -- Name of the machine being run on
    lpWrkgrp  -- Workgroup to join

Returns:

    NERR_Success -- Success

--*/
{
    NET_API_STATUS  NetStatus = NERR_Success;


    NetSetuppOpenLog();

    NetpLog(( "NetpJoinWorkgroup: joining computer '%ws' to workgroup '%ws'\n",
                        lpMachine, lpWrkgrp ));

    //
    // First, check the name...
    //
    NetStatus = NetpValidateName( lpMachine, lpWrkgrp, NULL, NULL,
                                  NetSetupWorkgroup );

    if ( NetStatus == NERR_Success )
    {
        NetStatus = NetpSetLsaPrimaryDomain(NULL, lpWrkgrp, NULL, NULL, NULL);

        if ( NetStatus == NERR_Success )
        {
            NetStatus = NetpControlServices( NETSETUP_SVC_MANUAL,
                                             NETSETUPP_SVC_NETLOGON );

            if ( NetStatus == ERROR_SERVICE_DOES_NOT_EXIST )
            {
                NetStatus = STATUS_SUCCESS;
            }
        }
     }

    NetpLog(( "NetpJoinWorkgroup: status:  0x%lx\n",
                        NetStatus ));
    NetSetuppCloseLog();

    return( NetStatus );
}


NET_API_STATUS
NET_API_FUNCTION
NetpMachineValidToJoin(
    IN  LPWSTR      lpMachine,
	IN  BOOL        fJoiningDomain
    )
/*++

Routine Description:

    Determines whether it is valid for this machine to attempt to
    join a domain/workgroup

Arguments:

    lpMachine -- Name of the machine being run on

Returns:

    NERR_Success -- Success
    NERR_SetupAlreadyJoined -- The machine is already joined to a domain

--*/
{
    NET_API_STATUS               NetStatus = NERR_Success;
    PPOLICY_PRIMARY_DOMAIN_INFO  pPolicy;
    PPOLICY_DNS_DOMAIN_INFO      pDns;
    BOOL fIsDC=FALSE;
    NT_PRODUCT_TYPE              ProductType;


    if ( fJoiningDomain == TRUE )
	{
        //
        // Determine if we are running Personal SKU.  If so, return error (Personal SKU not allowed to join domain)
        //

        OSVERSIONINFOEXW osvi;

        osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXW);
        if(GetVersionExW((OSVERSIONINFOW*)&osvi))
		{
            if ( osvi.wProductType == VER_NT_WORKSTATION && (osvi.wSuiteMask & VER_SUITE_PERSONAL))
			{
                return NERR_PersonalSku;
			}
		}
    }
	

    NetpLog(( "NetpMachineValidToJoin: '%ws'\n", GetStrPtr(lpMachine) ));

    //
    // check to see if the machine being joined is a DC
    // if it is, we cannot let this join another domain/workgroup.
    //
    if (!RtlGetNtProductType(&ProductType))
    {
        NetStatus = GetLastError();
    }
    else if (ProductType == NtProductLanManNt)
    {
        NetStatus = NERR_SetupDomainController;
        NetpLog(( "NetpMachineValidToJoin: the specified machine is a domain controller.\n"));
    }


    if (NetStatus == NERR_Success)
    {
        NetStatus = NetpGetLsaPrimaryDomain(NULL, NULL, &pPolicy, &pDns, NULL);

        if ( NetStatus == NERR_Success )
        {
            //
            // See if we have a domain SID
            //
            if ( IS_CLIENT_JOINED(pPolicy) )
            {
                NetStatus = NERR_SetupAlreadyJoined;

                NetpLog(( "NetpMachineValidToJoin: the specified machine is already joined to '%wZ'!\n", &pPolicy->Name));
            }

            LsaFreeMemory( pPolicy );
            LsaFreeMemory( pDns );
        }
    }

    NetpLog(( "NetpMachineValidToJoin: status: 0x%lx\n", NetStatus));


    return( NetStatus );
}


void
NetpLogBuildInformation(
    VOID
    )
/*++

Routine Description:

    Logs information to the setup log regarding the OS version and build number

Arguments:

    VOID

Returns:

    VOID

--*/
{
#ifdef NETSETUP_VERBOSE_LOGGING
    OSVERSIONINFO   OsVersionInfo;

    OsVersionInfo.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );

    if ( GetVersionEx( &OsVersionInfo ) ) {

        NetpLog(( "\tOS Version: %lu.%lu\n",
                            OsVersionInfo.dwMajorVersion,
                            OsVersionInfo.dwMinorVersion ));
        NetpLog(( "\tBuild number: %lu\n",
                            OsVersionInfo.dwBuildNumber ));

        if ( OsVersionInfo.szCSDVersion[ 0 ] != L'\0' ) {

            NetpLog(( "\tServicePack: %ws\n",
                                OsVersionInfo.szCSDVersion ));
        }
    }

#endif
}

NET_API_STATUS
NetpQueryService(
    IN  LPWSTR ServiceName,
    OUT SERVICE_STATUS *ServiceStatus,
    OUT LPQUERY_SERVICE_CONFIG *ServiceConfig
    )

/*++

Routine Description:

    Query the status and the configuration of the specified service

Arguments:

    ServiceName   - The name of the service to query

    ServiceStatus - Returns the status of the service. The buffer
        pointed to by this parameter must be supplied by the caller.

    ServiceConfig - Returns the configuration of the service.
        Must be freed by the caller by calling LocalFree.

Return Status:

    NO_ERROR - Indicates service successfully queried.

    Otherwise, an error is returned.

--*/

{
    NET_API_STATUS NetStatus = NO_ERROR;
    SC_HANDLE ScManagerHandle = NULL;
    SC_HANDLE ServiceHandle = NULL;

    LPQUERY_SERVICE_CONFIG LocalServiceConfig = NULL;
    DWORD ServiceConfigSize = 0;

    //
    // Open a handle to the Service.
    //

    ScManagerHandle = OpenSCManager(
                          NULL,
                          NULL,
                          SC_MANAGER_CONNECT );

    if ( ScManagerHandle == NULL ) {
        NetStatus = GetLastError();
        NetpLog(( "NetpQueryService: %ws: OpenSCManager failed: %lu\n",
                   ServiceName,
                   NetStatus ));
        goto Cleanup;
    }

    ServiceHandle = OpenService(
                        ScManagerHandle,
                        ServiceName,
                        SERVICE_QUERY_STATUS | SERVICE_QUERY_CONFIG );

    if ( ServiceHandle == NULL ) {
        NetStatus = GetLastError();
        NetpLog(( "NetpQueryService: %ws: OpenService failed: %lu\n",
                   ServiceName,
                   NetStatus ));
        goto Cleanup;
    }

    //
    // Pre-allocate the service config struct since QueryServiceConfig
    //  won't allow a null pointer, yet.
    //

    LocalServiceConfig = LocalAlloc( 0, sizeof(*LocalServiceConfig) );
    if ( LocalServiceConfig == NULL ) {
        NetStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    if ( !QueryServiceConfig( ServiceHandle,
                              LocalServiceConfig,
                              sizeof(*LocalServiceConfig),
                              &ServiceConfigSize) ) {
        //
        // Handle the error
        //

        NetStatus = GetLastError();
        if ( NetStatus != ERROR_INSUFFICIENT_BUFFER ) {
            NetpLog(( "NetpQueryService: %ws: QueryServiceConfig failed: %lu\n",
                       ServiceName,
                       NetStatus ));
            goto Cleanup;
        }

        if ( LocalServiceConfig != NULL ) {
            LocalFree( LocalServiceConfig );
            LocalServiceConfig = NULL;
        }

        LocalServiceConfig = LocalAlloc( 0, ServiceConfigSize );

        if ( LocalServiceConfig == NULL ) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        if ( !QueryServiceConfig( ServiceHandle,
                                  LocalServiceConfig,
                                  ServiceConfigSize,
                                  &ServiceConfigSize) ) {

            NetStatus = GetLastError();
            NetpLog(( "NetpQueryService: %ws: QueryServiceConfig failed again: %lu\n",
                      ServiceName,
                      NetStatus ));
            goto Cleanup;
        }
    }

    //
    // Query the status of the service.
    //

    if ( !QueryServiceStatus(ServiceHandle, ServiceStatus) ) {
        NetStatus = GetLastError();
        NetpLog(( "NetpQueryService: %ws: QueryServiceStatus failed: %lu\n",
                  ServiceName,
                  NetStatus ));
        goto Cleanup;
    }

    //
    // Success
    //

    NetStatus = NO_ERROR;

Cleanup:

    if ( ScManagerHandle != NULL ) {
        (VOID) CloseServiceHandle(ScManagerHandle);
    }

    if ( ServiceHandle != NULL ) {
        (VOID) CloseServiceHandle(ServiceHandle);
    }

    if ( NetStatus == NO_ERROR ) {
        *ServiceConfig = LocalServiceConfig;
    } else if ( LocalServiceConfig != NULL ) {
        LocalFree( LocalServiceConfig );
    }

    return NetStatus;
}

NET_API_STATUS
NET_API_FUNCTION
NetpJoinDomain(
    IN  LPWSTR      lpMachine,
    IN  LPWSTR      lpDomainSpecifier,
    IN  LPWSTR      lpMachineAccountOU,  OPTIONAL
    IN  LPWSTR      lpAccount,
    IN  LPWSTR      lpPassword,
    IN  DWORD       fJoinOpts
    )
/*++

Routine Description:

    Joins the machine to the specified domain

Arguments:

    lpMachine          -- Name of the machine being joined
    lpDomainSpecifier  -- Domain to join.
                          syntax of the parameter is:
                          domain-name[\preferred-domain-controller-name]
                          e.g.:
                          ntdev\ntdsdc01 or ntdev

    lpMachineAccountOU -- Optional OU in which to create the machine account
    lpAccount          -- User account for validation
    lpPassword         -- Password to use for validation.
                          The password has been encoded and the
                          first WCHAR of the password buffer is the seed

    fJoinOptions       -- Options to employ when joining, see below
      NETSETUP_JOIN_DOMAIN            if set join domain otherwise join workgroup
      NETSETUP_ACCT_CREATE            Do the server side account creation/rename
      NETSETUP_ACCT_DELETE            Delete the account when a domain is left
      NETSETUP_WIN9X_UPGRADE          use only during upgrade of win9x to NT
      NETSETUP_DOMAIN_JOIN_IF_JOINED  Allow the client to join a new domain
                                      even if it is already joined to a domain
      NETSETUP_JOIN_UNSECURE          Performs an unsecure join
      NETSETUP_INSTALL_INVOCATION     use only during system install
                                      (not currently used)
      NETSETUP_MACHINE_PWD_PASSED     Indicates that the machine password is passed
                                      in lpPassword. Valid only for unsecure joins (i.e.
                                      NETSETUP_JOIN_UNSECURE must also be set). If set,
                                      the passed in password will be used for machine
                                      password and the user credentials will be assumed
                                      to be NULL (i.e. join will happen over null session
                                      to the DC which is the case for unsecure joins)

      NETSETUP_DEFER_SPN_SET          Specifies that writting SPN and DnsHostName
                                      attributes on the computer object should be
                                      defered until rename that will follow this join.
                                      This flag will be set bu the UI in case the user
                                      joins and renames the machine at the same time. In
                                      this case we don't want to set SPN at join time because
                                      the new computer name (as specified by "NV Domain" in
                                      System\\CurrentControlSet\\Services\\Tcpip\\Parameters
                                      registry) may contain the new value that doesn't
                                      correspond to the current SamAccountName.

Returns:

    NERR_Success -- Success

Notes:

--*/
{
    NET_API_STATUS              NetStatus = NERR_Success, NetStatus2;
    PWSTR                       DomainControllerName = NULL;
    ULONG                       DcFlags = 0;
    NETSETUP_SAVED_JOIN_STATE   SavedState;
    PPOLICY_PRIMARY_DOMAIN_INFO pPolicyPDI = NULL, pPolicyLocalPDI = NULL;
    PPOLICY_DNS_DOMAIN_INFO     pPolicyDns = NULL, pPolicyLocalDns = NULL;
    BOOLEAN                     SecretCreated = FALSE, AccountCreated = FALSE;
    BOOLEAN                     GroupsSet = FALSE, DomainInfoSet = FALSE;
    BOOLEAN                     IpcConnect = FALSE;
    LSA_HANDLE                  hLsa = NULL, hDC = NULL;
    WCHAR                       MachinePasswordBuffer[ PWLEN + 1], *lpMachinePassword = NULL;
    ULONG                       MachinePasswordLen=0;
    ULONG                       IPCConnectFlags = NETSETUPP_CONNECT_IPC;
    ULONG                       GetDcFlags = 0;
    UNICODE_STRING              EncodedPassword;
    UNICODE_STRING              EncodedMachinePassword = {0};
    UCHAR                       Seed, MachinePasswordSeed;
    BOOL                        UseDefaultPassword = FALSE;
    BOOL                        fIsNt4Dc=FALSE;
    BOOL                        fRandomPwdPreferred=TRUE;

    PDOMAIN_CONTROLLER_INFO     DcInfo = NULL;
    PDOMAIN_CONTROLLER_INFO     NetbiosDcInfo = NULL;

    LPWSTR                      DomainName = NULL;
    LPWSTR                      NetbiosDomainName = NULL;
    LPWSTR                      DnsHostName = NULL;
    LPWSTR                      SamAccountName = NULL;
    LPWSTR                      MachineAccount = NULL;
    BOOL                        DomainControllerPassed = FALSE;

    BOOLEAN                     SpnSet = FALSE;
    BOOLEAN                     NetlogonStopped = FALSE;
    BOOLEAN                     NetlogonStarted = FALSE;
    BOOLEAN                     NetlogonEnabled = FALSE;
    SERVICE_STATUS              OldNetlogonServiceStatus;
    LPQUERY_SERVICE_CONFIG      OldNetlogonServiceConfig = NULL;


    NetpLog(( "NetpJoinDomain\n" ));
    NetpLog(( "\tMachine: %ws\n", GetStrPtr(lpMachine)));
    NetpLog(( "\tDomain: %ws\n", GetStrPtr(lpDomainSpecifier)));
    NetpLog(( "\tMachineAccountOU: %ws\n",
                        GetStrPtr(lpMachineAccountOU)));
    NetpLog(( "\tAccount: %ws\n", GetStrPtr(lpAccount)));
    NetpLog(( "\tOptions: 0x%lx\n", fJoinOpts ));
    NetpLogBuildInformation();

    //
    // Process the special case when the machine password is passed
    //

    if ( FLAG_ON(fJoinOpts, NETSETUP_MACHINE_PWD_PASSED) ) {

        //
        // Verify that this is unsecure join
        //
        if ( !FLAG_ON(fJoinOpts, NETSETUP_JOIN_UNSECURE) ) {
            NetpLog(( "NetpJoinDomain: Machine password is passed for secure join.  Error out.\n" ));
            NetStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        //
        // Verify that the account name is not passed
        //
        if ( lpAccount != NULL ) {
            NetpLog(( "NetpJoinDomain: Machine password and the user account are passed.  Error out.\n" ));
            NetStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        //
        // Switch the passwords
        //
        lpMachinePassword = lpPassword;
        lpPassword = NULL;
        MachinePasswordLen = wcslen(lpMachinePassword);
        if ( MachinePasswordLen < 1 ) {
            NetStatus = ERROR_PASSWORD_RESTRICTION;
            goto Cleanup;
        }

        MachinePasswordSeed = ( UCHAR )*lpMachinePassword;
        RtlInitUnicodeString( &EncodedMachinePassword, lpMachinePassword + 1 );
        RtlRunDecodeUnicodeString( MachinePasswordSeed, &EncodedMachinePassword );

        //
        // Advance the pointer to the machine password
        //  passing the encode byte
        //
        lpMachinePassword ++;
        MachinePasswordLen --;
    }

    if ( lpPassword )
    {
        if ( wcslen( lpPassword ) < 1 )
        {
            NetStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }

        Seed = ( UCHAR )*lpPassword;
        RtlInitUnicodeString( &EncodedPassword, lpPassword + 1 );
    }
    else
    {
        RtlZeroMemory( &EncodedPassword, sizeof( UNICODE_STRING ) );
        Seed = 0;
    }

    RtlZeroMemory( &SavedState, sizeof( NETSETUP_SAVED_JOIN_STATE ) );

    if ( !FLAG_ON( fJoinOpts, NETSETUP_ACCT_CREATE ) )
    {
        IPCConnectFlags |= NETSETUPP_NULL_SESSION_IPC;
    }

    // check to see if a preferred-dc name is supplied by specifying
    // lpDomainSpecifier in the format 'domain\dc'
    NetStatus = NetpCrackDomainSpecifier( lpDomainSpecifier, &DomainName,
                                          &DomainControllerName );

    //
    // First, check the name of the domain to which we want to join
    //
    if ( NetStatus == NERR_Success )
    {
        //
        // Indicate that the DC name was passed
        //
        if ( DomainControllerName != NULL ) {
            DomainControllerPassed = TRUE;
        }

        RtlRunDecodeUnicodeString( Seed, &EncodedPassword );
        NetStatus = NetpValidateName( lpMachine, DomainName, lpAccount,
                                      EncodedPassword.Buffer, NetSetupDomain );
        RtlRunEncodeUnicodeString( &Seed, &EncodedPassword );

        if ( NetStatus == DNS_ERROR_NON_RFC_NAME )
        {
            NetStatus = NERR_Success;
        }
    }

    if ( NetStatus != NERR_Success )
    {
        goto Cleanup;
    }

    GetDcFlags = FLAG_ON( fJoinOpts, NETSETUP_ACCT_CREATE ) ?
        NETSETUPP_DSGETDC_FLAGS : NETSETUP_DSGETDC_FLAGS_ACCOUNT_EXISTS;


    //
    // If DC was not passed, discover one
    //
    if ( !DomainControllerPassed )
    {
        //
        // otherwise, find a DC in the domain using these steps:
        // - find a writable dc that has this machine account
        // - if we cannot find such dc, find any writable dc
        //
        NetStatus = NetpDsGetDcName( NULL,
                                     DomainName, lpMachine, GetDcFlags,
                                     &DcFlags, &DomainControllerName, &DcInfo );
    }

    //
    // First establish connection with the dc we found
    //
    if ( NetStatus == NERR_Success )
    {
        RtlRunDecodeUnicodeString( Seed, &EncodedPassword );
        NetStatus = NetpManageIPCConnect( DomainControllerName,
                                          lpAccount, EncodedPassword.Buffer,
                                          IPCConnectFlags );
        RtlRunEncodeUnicodeString( &Seed, &EncodedPassword );
        NetpLog(( "NetpJoinDomain: status of connecting to dc '%ws': 0x%lx\n", DomainControllerName, NetStatus ));

        if ( NetStatus == NERR_Success ) {
            IpcConnect = TRUE;
        }
    }

    //
    // If the DC is passed, execute DsGetDcName on that DC to get the
    // DC info. Do this after setting up a connection to avoid access
    // denied problems. Verify that the passed computer name is indeed
    // a DC by comparing the name that the computer returns with the one
    // passed to us.
    //
    if ( NetStatus == NERR_Success && DomainControllerPassed ) {
        BOOL NameVerified = FALSE;
        DNS_STATUS DnsStatus;

        //
        // If the passed DC name is valid DNS name, try getting
        //  the DNS name from that DC. Skipp \\ in the name.
        //
        DnsStatus = DnsValidateDnsName_W( DomainControllerName+2 );

        if ( DnsStatus == ERROR_SUCCESS ||
             DnsStatus == DNS_ERROR_NON_RFC_NAME ) {

            NetStatus = DsGetDcName( DomainControllerName,
                                     DomainName,
                                     NULL,
                                     NULL,
                                     DS_RETURN_DNS_NAME,
                                     &DcInfo );


            //
            // Check if this returned the info about the DC we wanted
            //
            if ( NetStatus == NERR_Success ) {
                if ( DnsNameCompare_W( DomainControllerName+2,
                                       DcInfo->DomainControllerName+2 ) ) {

                    NetpLog(( "NetpJoinDomain: Passed DC '%ws' verified as DNS name '%ws'\n",
                              DomainControllerName,
                              DcInfo->DomainControllerName ));
                    NameVerified = TRUE;
                } else {
                    NetpLog(( "NetpJoinDomain: Passed DC '%ws' NOT verified as DNS name '%ws'\n",
                              DomainControllerName,
                              DcInfo->DomainControllerName ));
                }

            //
            // If the DC runs NT4 and thus does not have the server part of DsGetDcName,
            //  passing the prefered DC name is not supported -- there is only one
            //  NT4.0 DC that can be used for join - the PDC.
            //
            } else if ( NetStatus == RPC_S_PROCNUM_OUT_OF_RANGE ) {
                NetpLog(( "NetpJoinDomain: Passed DC '%ws' is not NT5\n",
                          DomainControllerName ));
                NetStatus = ERROR_NOT_SUPPORTED;
                goto Cleanup;
            } else {
                NetpLog(( "NetpJoinDomain: DsGetDcName on passed DC '%ws' failed: 0x%lx\n",
                          DomainControllerName,
                          NetStatus ));
            }

        } else {
            NetpLog(( "NetpJoinDomain: Passed DC name '%ws' is not valid DNS name.\n",
                      DomainControllerName ));
        }

        //
        // If DNS didn't work, try Netbios name
        //
        if ( !NameVerified ) {

            //
            // Skipp \\ in the name.
            //
            if ( NetpIsComputerNameValid( DomainControllerName+2 ) ) {

                if ( DcInfo != NULL ) {
                    NetApiBufferFree( DcInfo );
                    DcInfo = NULL;
                }
                NetStatus = DsGetDcName( DomainControllerName,
                                         DomainName,
                                         NULL,
                                         NULL,
                                         DS_RETURN_FLAT_NAME,
                                         &DcInfo );

                //
                // Check if this returned the info about the DC we wanted
                //
                if ( NetStatus == NERR_Success ) {
                    if ( I_NetNameCompare( NULL,
                                           DomainControllerName+2,
                                           DcInfo->DomainControllerName+2,
                                           NAMETYPE_COMPUTER, 0 ) == 0 ) {

                        NetpLog(( "NetpJoinDomain: Passed DC '%ws' verified as Netbios name '%ws'\n",
                                  DomainControllerName,
                                  DcInfo->DomainControllerName ));
                        NameVerified = TRUE;
                    } else {
                        NetpLog(( "NetpJoinDomain: Passed DC '%ws' NOT verified as Netbios name '%ws'\n",
                                  DomainControllerName,
                                  DcInfo->DomainControllerName ));
                    }
                } else {
                    NetpLog(( "NetpJoinDomain: DsGetDcName on passed DC '%ws' failed: 0x%lx\n",
                              DomainControllerName,
                              NetStatus ));
                }

            } else {
                NetpLog(( "NetpJoinDomain: Passed DC name '%ws' is not valid Netbios name.\n",
                          DomainControllerName ));
            }
        }

        if ( !NameVerified || DcInfo == NULL ) {
            NetpLog(( "NetpJoinDomain: Passed DC '%ws' is not verified: 0x%lx\n",
                      DomainControllerName,
                      NetStatus ));
            NetStatus = ERROR_INVALID_DOMAIN_ROLE;
            goto Cleanup;
        }

        //
        // Name has been verified. Save the DC flags.
        //
        DcFlags = DcInfo->Flags;
    }

    //
    // REVIEW kahrent 03-March-00
    //  The design below doesn't work if a DC with different default
    //  locale exists but is not the one the join is using for join.
    //  The correct solution seems to be to use the locale insensitive
    //  string comparison in netlogon, DS, SAM.  The locale insensitive
    //  string comparison is bug 23108 in Windows Bugs.
    //
    //$ kumarp 02-June-1999
    //  the following requires admin access to the dc so that the
    //  right regkeys could be read to decide the default locale.
    //  We need to get a remoted API to get default locale
    //  on the dc.

    //
    // make sure that the machine name is OEM codepage compatible with
    // the default codepage being used on the dc. The way we determine this
    // is by translating the machine name to oem string using the
    // local code page and the dc code page and then binary comparing
    // the resultant strings. if the strings are different, we
    // will fail join.
    //
    // Note that this is not a limitation of join apis. netlogon uses
    // oem translated netbios machine name internally. the translation
    // is different if the code page on the dc and the local machine are
    // not compatible. this causes lack of access to net resources.
    //
    /*
    if (NetStatus == NERR_Success)
    {
        NetStatus = NetpVerifyStrOemCompatibleOnMachine(DomainControllerName,
                                                        lpMachine);
        NetpLog(( "NetpJoinDomain: status of verifying OEM compatibility of computer name: 0x%lx\n", NetStatus ));
    }
    */

    if (NetStatus != NERR_Success)
    {
        goto Cleanup;
    }

    fIsNt4Dc = !FLAG_ON( DcFlags, DS_DS_FLAG);

    //
    // If the OU is specified we must have an NT5 DC
    //

    if ( lpMachineAccountOU != NULL && fIsNt4Dc ) {
        NetpLog(( "NetpJoinDomain: OU is specified but couldn't get NT5 DC\n" ));
        NetStatus = ERROR_NO_SUCH_DOMAIN;
        goto Cleanup;
    }

    //
    // Ensure that the domain and machine names are different
    //  If we already have the Netbios domain info, just use it
    //
    // BLACKCOMB: Move this check into NetpGetComputerObjectDn
    //  where we carck the DNS domain name into the Netbios
    //  domain name as needed.
    //

    if ( (DcFlags & DS_DNS_DOMAIN_FLAG) == 0 ) {
        NetbiosDomainName = DcInfo->DomainName;

    //
    // Otherwise call DsGetDcName again to get the Netbios domain info.
    //  (This will return cached info unless the DC was passed to us)
    //
    } else {
        NetStatus = DsGetDcName( NULL,
                                 DomainName,
                                 NULL,
                                 NULL,
                                 DS_RETURN_FLAT_NAME,
                                 &NetbiosDcInfo );

        if ( NetStatus != NO_ERROR ) {
            NetpLog(( "NetpJoinDomain: DsGetDcName (for Netbios domain name) failed: 0x%lx\n",
                      NetStatus ));
            goto Cleanup;
        }

        NetbiosDomainName = NetbiosDcInfo->DomainName;
    }

    //
    // Verify that the computer name is not the Netbios domain name
    //

    if ( I_NetNameCompare( NULL,
                           lpMachine,
                           NetbiosDomainName,
                           NAMETYPE_COMPUTER, 0 ) == 0 ) {

        NetpLog(( "NetpJoinDomain: Computer name is same as Netbios domain name %ws %ws\n",
                  lpMachine,
                  NetbiosDomainName ));
        NetStatus = ERROR_INVALID_DOMAINNAME;
        goto Cleanup;
    }

    //
    // Get the lsa domain info on the DC
    //

    if ( NetStatus == NERR_Success )
    {
        NetStatus = NetpGetLsaPrimaryDomain(NULL, DomainControllerName,
                                            &pPolicyPDI, &pPolicyDns, &hDC);
    }

    //
    // Determine DnsHostName of this machine
    //

    if ( !fIsNt4Dc && pPolicyDns != NULL ) {
        NetStatus = NetpGetDnsHostName( NULL,  // read tne new host name from registry
                                        &pPolicyDns->DnsDomainName,
                                        &DnsHostName );
    }

    if (NetStatus == NERR_Success)
    {
        //
        // If we are joining an NT4 domain and we are not doing a machine
        // account creation, we'll treat this as a win95 upgrade
        //
        if ( fIsNt4Dc &&
             !FLAG_ON( fJoinOpts, NETSETUP_ACCT_CREATE ) )
        {
            fJoinOpts |= NETSETUP_JOIN_UNSECURE;
        }

        //
        // Generate the machine password if it was not passed
        //
        if ( lpMachinePassword == NULL ) {
            fRandomPwdPreferred = !( FLAG_ON( fJoinOpts, NETSETUP_WIN9X_UPGRADE ) ||
                                     FLAG_ON( fJoinOpts, NETSETUP_JOIN_UNSECURE ) );

            //
            // Generate the password to use on the machine account.
            // This can either be the default password
            // (the 1st 14 characters of the machine name, lower cased),
            // or a randomly generated password.
            //
            NetStatus = NetpGeneratePassword( lpMachine,
                                              fRandomPwdPreferred,
                                              DomainControllerName,
                                              fIsNt4Dc,
                                              MachinePasswordBuffer );

            if ( NetStatus == NERR_Success )
            {
                lpMachinePassword = MachinePasswordBuffer;
                MachinePasswordLen = wcslen(lpMachinePassword);
            }
        }
    }

    //
    // if we are already joined to a domain, save the join state.
    //
    if ((NetStatus == NERR_Success) &&
        FLAG_ON( fJoinOpts, NETSETUP_DOMAIN_JOIN_IF_JOINED))
    {
        NetStatus = NetpHandleJoinedStateInfo( hLsa, &SavedState,
                                               TRUE, &hLsa );
    }

    //
    // set the local machine secret, create if not already present
    //
    if ( NetStatus == NERR_Success )
    {
        //
        // If the machine password is passed, use the default
        // password (lowercased machine name) as the old password.
        // We do this because the passed in password is unsecure
        // since it is read from an unsecure unattend.txt file by
        // setup (that calls us). When netlogon starts, it will
        // detect that the old password is the default one, it will
        // set the new password to a new value it will generate, and
        // it will set the old value to the one which used to be the
        // new value (that was passed to us). The net effect is that
        // the password passed to us will be set as the old value
        // and the new value will be updated by netlogon.
        //
        NetStatus = NetpManageMachineSecret(
                                   NULL,
                                   lpMachine,
                                   lpMachinePassword,
                                   NETSETUPP_CREATE,
                                   FLAG_ON(fJoinOpts, NETSETUP_MACHINE_PWD_PASSED) ?
                                       TRUE :  // use the default for old password
                                       FALSE,
                                   &hLsa );
    }

    //
    // set the machine account on the dc, create if not present
    //
    if ( NetStatus == NERR_Success )
    {
        SecretCreated = TRUE;

        if ( FLAG_ON( fJoinOpts, NETSETUP_ACCT_CREATE ) )
        {

            //
            // if OU is specified, create the account in OU, otherwise
            // create it globally
            //
            if ( lpMachineAccountOU )
            {
                RtlRunDecodeUnicodeString( Seed, &EncodedPassword );
                NetStatus = NetpCreateComputerObjectInDs( DcInfo,
                                                          lpAccount,
                                                          EncodedPassword.Buffer,
                                                          lpMachine,
                                                          lpMachinePassword,
                                                          DnsHostName,
                                                          lpMachineAccountOU );

                RtlRunEncodeUnicodeString( &Seed, &EncodedPassword );
                NetpLog(( "NetpJoinDomain: status of creating account in OU: 0x%lx\n", NetStatus ));

                //
                // On success, indicate that we have set SPN
                //
                if ( NetStatus == NO_ERROR && DnsHostName != NULL ) {
                    SpnSet = TRUE;
                }
            }
            else
            {
                NetStatus = NetpManageMachineAccountWithSid( lpMachine,
                                                             NULL,
                                                             DomainControllerName,
                                                             lpMachinePassword,
                                                             pPolicyPDI->Sid,
                                                             NETSETUPP_CREATE,
                                                             fJoinOpts,
                                                             fIsNt4Dc );
                NetpLog(( "NetpJoinDomain: status of creating account: 0x%lx\n", NetStatus ));
            }

            if (( NetStatus == NERR_Success ) &&
                ( MachinePasswordLen != wcslen(lpMachinePassword) ))
            {
                //
                // the password was weakened by NetpManageMachineAccountWithSid
                // because the dc did not accpet strong password.
                // we need to update the local secret to reflect this.
                //
                NetStatus = NetpManageMachineSecret( NULL, lpMachine,
                                                     lpMachinePassword,
                                                     NETSETUPP_CREATE, FALSE, &hLsa );
                NetpLog(( "NetpJoinDomain: status of updating secret: 0x%lx\n",
                          NetStatus ));
            }
        }
        else if ( FLAG_ON( fJoinOpts, NETSETUP_WIN9X_UPGRADE ) ||
                  FLAG_ON( fJoinOpts, NETSETUP_JOIN_UNSECURE ) )
        {
            NetStatus = NetpValidateMachineAccount( DomainControllerName,
                                                    DomainName,
                                                    lpMachine,
                                                    lpMachinePassword );

            NetpLog(( "NetpJoinDomain: w9x: status of validating account: 0x%lx\n", NetStatus ));
        }
        else
        {
            // if we are not creating the machine account,
            // just set the password
            NetStatus = NetpSetMachineAccountPasswordAndTypeEx(
                            DomainControllerName, pPolicyPDI->Sid,
                            lpMachine, lpMachinePassword,
                            ACCOUNT_STATE_ENABLED,
                            fIsNt4Dc
                            );

            NetpLog(( "NetpJoinDomain: status of setting machine password: 0x%lx\n", NetStatus ));
        }

        if ( NetStatus == NERR_Success )
        {
            AccountCreated = TRUE;
        }

        //
        // If this is not an explicit OU case, we haven't yet set DnsHostName and SPN.
        //  Do it here.
        //
        // ISSUE: The original idea was to use the machine credentials (account=SamAccountName,
        // password=MachinePassword) since we may not have user credentials at this point (for
        // unsecure join). However problems with Kerberos authentication while binding to the
        // DC with machine credentials do not currently allow this behavior. So for now we will
        // set SPN here only if we have user credentials.
        //

        if ( NetStatus == NERR_Success &&
             !FLAG_ON(fJoinOpts, NETSETUP_DEFER_SPN_SET) &&
             !fIsNt4Dc &&
             lpMachineAccountOU == NULL &&
             DnsHostName != NULL &&
             lpAccount != NULL && lpPassword != NULL ) {

            //
            // Use the machine credentials (account=SamAccountName, password=MachinePassword)
            // since we may not have user credentials at this point (for unsecure join).
            //

            NetStatus = NetpGetMachineAccountName( lpMachine, &SamAccountName );
            if ( NetStatus != NO_ERROR ) {
                goto Cleanup;
            }

            NetStatus = NetApiBufferAllocate(
                            (wcslen(DomainName) + 1 + wcslen(SamAccountName) + 1) * sizeof(WCHAR),
                            &MachineAccount );
            if ( NetStatus != NO_ERROR ) {
                goto Cleanup;
            }

            swprintf( MachineAccount, L"%ws\\%ws", DomainName, SamAccountName );

            RtlRunDecodeUnicodeString( Seed, &EncodedPassword );
            NetStatus = NetpSetDnsHostNameAndSpn( DcInfo,
                                                  lpAccount,              // MachineAccount
                                                  EncodedPassword.Buffer, // lpMachinePassword
                                                  lpMachine,
                                                  DnsHostName );
            RtlRunEncodeUnicodeString( &Seed, &EncodedPassword );

            NetpLog(( "NetpJoinDomain: status of setting DnsHostName and SPN: 0x%lx\n", NetStatus ));

            //
            // If the problem was that values were invalid,
            // return a distinctive error indicating where that happened
            //

            if ( NetStatus == ERROR_INVALID_PARAMETER ) {
                NetStatus = ERROR_DS_COULDNT_UPDATE_SPNS;
            }

            //
            // On success, indicate that we have set SPN
            //
            if ( NetStatus == NO_ERROR ) {
                SpnSet = TRUE;
            }
        }
    }

    //
    // Read our old primary domain info in case we have to restore
    //

    if ( NetStatus == NERR_Success ) {
        NetStatus = NetpGetLsaPrimaryDomain( hLsa, NULL,
                                             &pPolicyLocalPDI,
                                             &pPolicyLocalDns,
                                             NULL );
    }

    //
    // Remember the current sevice states in case we have rollback on failure
    //

    if ( NetStatus == NERR_Success ) {
        NetStatus = NetpQueryService( SERVICE_NETLOGON,
                                      &OldNetlogonServiceStatus,
                                      &OldNetlogonServiceConfig );
    }

    //
    // Stop the Netlogon service if it's not alredy stopped
    //

    if ( NetStatus == NERR_Success &&
         OldNetlogonServiceStatus.dwCurrentState != SERVICE_STOPPED ) {
        NetStatus = NetpControlServices( NETSETUP_SVC_STOPPED,
                                         NETSETUPP_SVC_NETLOGON );
        if ( NetStatus == NERR_Success ) {
            NetlogonStopped = TRUE;
        }
    }

    //
    // Set the primary domain info from the Dc to the client
    //

    if ( NetStatus == NERR_Success ) {
        NetStatus = NetpSetLsaPrimaryDomain(hLsa,
                                            pPolicyPDI->Name.Buffer,
                                            pPolicyPDI->Sid,
                                            pPolicyDns,
                                            NULL);
        NetpLog(( "NetpJoinDomain: status of setting LSA pri. domain: 0x%lx\n", NetStatus ));
        if ( NetStatus == NERR_Success ) {
            DomainInfoSet = TRUE;
        }
    }

    //
    // Then we adjust our local group memberships
    //

    if ( NetStatus == NERR_Success )
    {
        NetStatus = NetpManageLocalGroups( pPolicyPDI->Sid, NETSETUPP_CREATE );
        NetpLog(( "NetpJoinDomain: status of managing local groups: 0x%lx\n", NetStatus ));

        if ( NetStatus == NERR_Success )
        {
            GroupsSet = TRUE;
        }
    }

    //
    // The netlogon cache needs to be initialized
    //

    if ( NetStatus == NERR_Success )
    {
        NetStatus = NetpSetNetlogonDomainCache( DomainControllerName );
        NetpLog(( "NetpJoinDomain: status of setting netlogon cache: 0x%lx\n", NetStatus ));
    }

    //
    // Save off the name of the initial domain controller we contacted
    //  if we successfully joined the domain. Ignore failure.
    //

    if ( NetStatus == NERR_Success && DcInfo != NULL ) {
        NET_API_STATUS TmpNetStatus = NetpStoreIntialDcRecord( DcInfo );

        if ( TmpNetStatus != NERR_Success ) {
            NetpLog(( "NetpJoinDomain: NON FATAL: failed to store the initial Dc record for '%ws': 0x%lx\n",
                      DomainControllerName,
                      TmpNetStatus ));
        }
    }



    //
    // Next, if the Dns domain name changed, we'll need to potentially update the
    // computer name as well...
    //

    if ( NetStatus == NERR_Success ) {

        //
        // If we have a new name, set it if it's different from the old one
        //
        if ( pPolicyDns != NULL ) {

            if ( pPolicyLocalDns == NULL ||
                 RtlCompareUnicodeString( &pPolicyLocalDns->DnsDomainName,
                                          &pPolicyDns->DnsDomainName,
                                          TRUE ) != 0 ) {

                NetStatus = NetpSetDnsComputerNameAsRequired( (PWSTR)pPolicyDns->DnsDomainName.Buffer );
                NetpLog(( "NetpJoinDomain: status of setting ComputerNamePhysicalDnsDomain to '%wZ': 0x%lx\n",
                          &pPolicyDns->DnsDomainName,
                          NetStatus ));
            }

        //
        // If we don't have a new name (must be an NT4 domain/DC),
        // clear the old name, if any.
        //
        // Note, if this is an NT5 domain but we simply don't have
        //  an NT5 DC at this time, netlogon will eventually discover
        //  an NT5 DC and netlogon will set the new name then.
        //
        } else if ( pPolicyLocalDns != NULL ) {

            NetStatus = NetpSetDnsComputerNameAsRequired( L"\0" );
            NetpLog(( "NetpJoinDomain: status of clearing ComputerNamePhysicalDnsDomain: 0x%lx\n",
                      NetStatus ));
        }
    }

    //
    // Then, the netlogon servic needs to be set to automatic
    //

    if ( NetStatus == NERR_Success &&
         OldNetlogonServiceConfig->dwStartType != SERVICE_AUTO_START ) {
        NetStatus = NetpControlServices( NETSETUP_SVC_ENABLED,
                                         NETSETUPP_SVC_NETLOGON );

        if ( NetStatus == NERR_Success ) {
            NetlogonEnabled = TRUE;
        } else {
            NetpLog(( "NetpJoinDomain: status of enabling Netlogon: 0x%lx\n", NetStatus ));
        }
    }

    //
    // Start netlogon
    //

    if ( NetStatus == NERR_Success ) {
        NetStatus = NetpControlServices( NETSETUP_SVC_STARTED,
                                         NETSETUPP_SVC_NETLOGON );

        if ( NetStatus == NERR_Success ) {
            NetlogonStarted = TRUE;
        }
    }

    //
    // call w32time!W32TimeVerifyJoinConfig so that it can update
    // its internal config to match the join state
    //

    if ( NetStatus == NERR_Success ) {
        NetpUpdateW32timeConfig( "W32TimeVerifyJoinConfig" );
    }


    // -----------------------------------------------------------------
    // the real work of netjoin is over, now do some misc. stuff
    // if this fails it does not cause a rollback
    // -----------------------------------------------------------------

    //
    // If we successfully added ourselves to a new domain while we were joined to the
    // old, then we'll remove the old domains group membership.  This is not a
    // catastrophic failure.  Note that we don't try and remove the machine account
    // if we are joining the domain we are already joined to...
    //
    if ( (NetStatus == NERR_Success) &&
         FLAG_ON( fJoinOpts, NETSETUP_DOMAIN_JOIN_IF_JOINED ) &&
         (SavedState.PrimaryDomainInfo != NULL) &&
         (SavedState.PrimaryDomainInfo->Sid != NULL) &&
         (pPolicyPDI != NULL) &&
         !RtlEqualSid( pPolicyPDI->Sid, SavedState.PrimaryDomainInfo->Sid ) &&
         (pPolicyPDI->Name.Buffer != NULL) &&
         (SavedState.PrimaryDomainInfo->Name.Buffer != NULL) &&
         _wcsicmp( pPolicyPDI->Name.Buffer,
                   SavedState.PrimaryDomainInfo->Name.Buffer ) )
    {

        NetStatus = NetpManageLocalGroups( SavedState.PrimaryDomainInfo->Sid,
                                           NETSETUPP_DELETE );

        NetpLog(( "NetpJoinDomain: status of removing groups related to domain '%wZ' from local groups: 0x%lx\n",
                            &SavedState.PrimaryDomainInfo->Name, NetStatus ));

        //
        // Try and remove the old domain's computer account as well
        //
        if ( FLAG_ON( fJoinOpts, NETSETUP_ACCT_DELETE ) )
        {
            PWSTR OldDomainControllerName = NULL;
            ULONG OldDomainControllerFlags = 0;
            //
            // Find a domain controller in the old domain
            //
            NetStatus = NetpDsGetDcName( NULL,
                                         SavedState.PrimaryDomainInfo->Name.Buffer,
                                         lpMachine, GetDcFlags,
                                         &OldDomainControllerFlags,
                                         &OldDomainControllerName, NULL );

            if ( NetStatus == NERR_Success )
            {
                NetStatus = NetpManageMachineAccount( lpMachine, NULL,
                                                      OldDomainControllerName,
                                                      NULL, NETSETUPP_DELETE,
                                                      fJoinOpts, fIsNt4Dc );
                NetApiBufferFree( OldDomainControllerName );
            }

            NetpLog(( "NetpJoinDomain: status of disabling account for '%ws' on old domain '%wZ': 0x%lx\n",
                      lpMachine,
                      &SavedState.PrimaryDomainInfo->Name,
                      NetStatus ));


        }

        //
        // Nothing in here is considered fatal if it fails
        //
        NetStatus = NERR_Success;
    }

    // ============== ROLLBACK CODE ====================================
    //
    // If something failed, we'll have to rollback.
    // Note that we ignore all error codes
    //
    if ( NetStatus != NERR_Success )
    {
        NetpLog(( "NetpJoinDomain: initiaing a rollback due to earlier errors\n"));

        //
        // Reset netlogon's start type
        //
        if ( NetlogonEnabled ) {
            DWORD SvcOpts = 0;

            if ( OldNetlogonServiceConfig->dwStartType == SERVICE_DISABLED ) {
                SvcOpts = NETSETUP_SVC_DISABLED;
            } else if ( OldNetlogonServiceConfig->dwStartType == SERVICE_DEMAND_START ) {
                SvcOpts = NETSETUP_SVC_MANUAL;
            }

            if ( SvcOpts != 0 ) {
                NetStatus2 = NetpControlServices( SvcOpts,
                                                  NETSETUPP_SVC_NETLOGON );
                NetpLog(( "NetpJoinDomain: rollback: status of setting netlogon start type to 0x%lx: 0x%lx\n",
                          SvcOpts,
                          NetStatus2));
            }
        }

        //
        // Restart netlogon
        //
        // Note that we don't need to worry abbout the time service
        //  state since we update it as the last non-critical operation.
        //
        if ( NetlogonStopped ) {
            DWORD SvcOpts = 0;

            if ( OldNetlogonServiceStatus.dwCurrentState == SERVICE_RUNNING ) {
                SvcOpts = NETSETUP_SVC_STARTED;
            }

            if ( SvcOpts != 0 ) {
                NetStatus2 = NetpControlServices( SvcOpts,
                                                  NETSETUPP_SVC_NETLOGON );
                NetpLog(( "NetpJoinDomain: rollback: status of starting netlogon: 0x%lx\n", NetStatus2));
            }
        }

        if ( NetlogonStarted ) {
            DWORD SvcOpts = 0;

            if ( OldNetlogonServiceStatus.dwCurrentState == SERVICE_STOPPED ) {
                SvcOpts = NETSETUP_SVC_STOPPED;
            }

            if ( SvcOpts != 0 ) {
                NetStatus2 = NetpControlServices( SvcOpts,
                                                  NETSETUPP_SVC_NETLOGON );
                NetpLog(( "NetpJoinDomain: rollback: status of stopping netlogon: 0x%lx\n", NetStatus2));
            }
        }

        //
        // Take back what we told Netlogon about SPN setting
        //

        if ( SpnSet ) {
            NetpAvoidNetlogonSpnSet( FALSE );
        }

        if ( GroupsSet )
        {
            NetStatus2 = NetpManageLocalGroups( pPolicyPDI->Sid,
                                                NETSETUPP_DELETE );
            NetpLog(( "NetpJoinDomain: rollback: local group management: 0x%lx\n", NetStatus2));
        }

        if ( DomainInfoSet )
        {
            //
            // Set a NULL domain sid
            //
            NetStatus2 =
            NetpSetLsaPrimaryDomain( hLsa, pPolicyLocalPDI->Name.Buffer,
                                     NULL, NULL, NULL );

            NetpLog(( "NetpJoinDomain: rollback: status of setting NULL domain sid: 0x%lx\n", NetStatus2));
        }

        if ( AccountCreated &&
             FLAG_ON( fJoinOpts, NETSETUP_ACCT_CREATE ) )
        {
            if ( lpMachineAccountOU )
            {
                RtlRunDecodeUnicodeString( Seed, &EncodedPassword );
                NetStatus2 = NetpDeleteComputerObjectInOU(
                    DomainControllerName, lpMachineAccountOU,
                    lpMachine, lpAccount, EncodedPassword.Buffer );
                RtlRunEncodeUnicodeString( &Seed, &EncodedPassword );
                NetpLog(( "NetpJoinDomain: rollback: status of deleting the computer account from OU: 0x%lx\n", NetStatus2));
            }
            else
            {
                RtlRunDecodeUnicodeString( Seed, &EncodedPassword );
                NetStatus2 = NetpManageMachineAccount(
                    lpMachine, NULL, DomainControllerName,
                    EncodedPassword.Buffer, NETSETUPP_DELETE, 0, fIsNt4Dc );
                RtlRunEncodeUnicodeString( &Seed, &EncodedPassword );
                NetpLog(( "NetpJoinDomain: rollback: status of deleting computer account: 0x%lx\n", NetStatus2));
            }
        }

        if ( SecretCreated )
        {
            if ( SavedState.MachineSecret )
            {
                NetStatus2 = NetpHandleJoinedStateInfo( hLsa, &SavedState,
                                                        FALSE, &hLsa );
                NetpLog(( "NetpJoinDomain: rollback: status of restoring secret: 0x%lx\n", NetStatus2));
            }
            else
            {
                NetStatus2 = NetpManageMachineSecret( NULL, lpMachine, NULL,
                                                      NETSETUPP_DELETE, FALSE, NULL );
                NetpLog(( "NetpJoinDomain: rollback: status of deleting secret: 0x%lx\n", NetStatus2));
            }
        }
    }
    // =================================================================

Cleanup:

    if ( pPolicyPDI != NULL ) {
        LsaFreeMemory( pPolicyPDI );
    }
    if ( pPolicyLocalPDI != NULL ) {
        LsaFreeMemory( pPolicyLocalPDI );
    }
    if ( pPolicyDns != NULL ) {
        LsaFreeMemory( pPolicyDns );
    }
    if ( pPolicyLocalDns != NULL ) {
        LsaFreeMemory( pPolicyLocalDns );
    }

    if ( hLsa != NULL )
    {
        LsaClose( hLsa );
    }

    if ( hDC != NULL )
    {
        LsaClose( hDC );
    }

    //
    // Now, we'll no longer need our session to our dc
    //
    if ( IpcConnect )
    {
        RtlRunDecodeUnicodeString( Seed, &EncodedPassword );
        NetStatus2 = NetpManageIPCConnect( DomainControllerName, lpAccount,
                                           EncodedPassword.Buffer,
                                           NETSETUPP_DISCONNECT_IPC );
        RtlRunEncodeUnicodeString( &Seed, &EncodedPassword );
        NetpLog(( "NetpJoinDomain: status of disconnecting from '%ws': 0x%lx\n", DomainControllerName, NetStatus2));
    }

    // Note: NetApiBufferFree checks for NULL
    NetApiBufferFree( DcInfo );
    NetApiBufferFree( DomainControllerName );
    NetApiBufferFree( DomainName );
    NetApiBufferFree( SamAccountName );
    NetApiBufferFree( MachineAccount );
    NetApiBufferFree( DnsHostName );
    NetApiBufferFree( NetbiosDcInfo );

    if ( OldNetlogonServiceConfig != NULL ) {
        LocalFree( OldNetlogonServiceConfig );
    }

    //
    // If the passed in machine password was decrypted,
    //  encrypt is back
    //
    if ( EncodedMachinePassword.Buffer != NULL ) {
        RtlRunEncodeUnicodeString( &MachinePasswordSeed, &EncodedMachinePassword );
    }

    return( NetStatus );
}

NET_API_STATUS
NET_API_FUNCTION
NetpCrackDomainSpecifier(
    IN LPWSTR DomainSpecifier,
    OUT LPWSTR* DomainName,
    OUT LPWSTR* DomainControllerName
    )
/*++

Routine Description:

   Parse DomainSpecifier and separate out DomainName / DomainControllerName.
   Caller must free the out arguments using NetApiBufferFree.

Arguments:

    lpDomainSpecifier   -- Domain to join.
                           syntax of the parameter is:
                           domain-name[\preferred-domain-controller-name]
                           e.g.:
                           ntdev\ntdsdc01 or ntdev

   DomainName           -- domain name extracted from lpDomainSpecifier

   DomainControllerName -- domain controller name extracted from lpDomainSpecifier

Returns:

   NERR_Success on success, otherwise NET_API_STATUS code

--*/
{
    NET_API_STATUS Status;
    LPWSTR         pwsz;
    LPWSTR         pwszSave;
    LPWSTR         pwszDomain = NULL;
    LPWSTR         pwszDC = NULL;

    pwszSave = pwsz = wcschr( DomainSpecifier, L'\\' );

    if ( pwsz != NULL )
    {
        //
        // Check if the passed DC name is NULL
        //
        if ( *(pwsz+1) == L'\0' ) {
            return ERROR_INVALID_PARAMETER;
        }

        *pwsz = L'\0';
    }

    Status = NetpDuplicateString(DomainSpecifier, -1, &pwszDomain);
    if ( Status == NERR_Success )
    {
        if ( pwsz != NULL )
        {
            pwsz++;

            Status = NetApiBufferAllocate(
                           ( wcslen( pwsz ) + 2 + 1 ) * sizeof( WCHAR ),
                           &pwszDC
                           );

            if ( Status == NERR_Success )
            {
                wcscpy( pwszDC, L"\\\\" );
                wcscat( pwszDC, pwsz );
            }
            else
            {
                NetApiBufferFree( pwszDomain );
                pwszDomain = NULL;
            }
        }
    }

    if ( pwszSave != NULL )
    {
        *pwszSave = L'\\';
    }

    *DomainName = pwszDomain;
    *DomainControllerName = pwszDC;

    return( Status );
}

NET_API_STATUS
NET_API_FUNCTION
NetpManageMachineAccountWithSid(
    IN  LPWSTR      lpMachine,
    IN  LPWSTR      lpOldMachine,
    IN  LPWSTR      lpDcName,
    IN  LPWSTR      lpPassword,
    IN  PSID        DomainSid,
    IN  ULONG       fControl,
    IN  ULONG       AccountOptions,
    IN  BOOL        fIsNt4Dc
    )
/*++

Routine Description:

    Manages the creation/deletion, and manipulation of the machine account

Arguments:

    lpMachine      -- Name of the current machine /
                      name of the new machine for rename
    lpOldMachine   -- Old machine name for rename
    lpDcName       -- Name of a DC in the domain
    lpPassword     -- Password to use for machine object.  If NULL, use the default.
    DomainSid      -- Sid for the domain holding the user account
    fControl       -- Whether to create/delete/rename
    AccountOptions -- Options to determine the particular behavior of the account creation
    fIsNt4Dc       -- TRUE if the DC is NT4 or earlier

Returns:

    NERR_Success -- Success
    ERROR_INVALID_PASSWORD -- The machine account could not have a random password set
                              on it, so it must resort to using the default password

--*/
{
    NET_API_STATUS  NetStatus = NERR_Success;
    LPWSTR          lpMachAcc = NULL, lpOldMachAcc = NULL;
    USER_INFO_1     NetUI1, *CurrentUI1;
    USER_INFO_0     NetUI0;
    DWORD           BadParam = 0;


    //
    // Build the machine account name
    //
    NetStatus = NetpGetMachineAccountName(lpMachine, &lpMachAcc);

    if ( NetStatus == NERR_Success )
    {
        if ( fControl == NETSETUPP_RENAME)
        {
            NetStatus = NetpGetMachineAccountName(lpOldMachine, &lpOldMachAcc);
        }
    }

    //
    // Now, either create or delete it
    //
    if ( NetStatus == NERR_Success )
    {
        if ( fControl == NETSETUPP_DELETE )
        {
            NetStatus = NetpSetMachineAccountPasswordAndTypeEx(
                            lpDcName, DomainSid, lpMachAcc,
                            NULL, ACCOUNT_STATE_DISABLED, fIsNt4Dc );

            NetpLog(( "NetpManageMachineAccountWithSid: status of disabling account '%ws' on '%ws': 0x%lx\n",
                                lpMachAcc, lpDcName, NetStatus ));
        }
        else if (fControl == NETSETUPP_CREATE )
        {
            RtlZeroMemory( &NetUI1, sizeof( NetUI1 ) );

            //
            // Initialize it..
            //
            NetUI1.usri1_name       = lpMachAcc;
            NetUI1.usri1_password   = lpPassword;
            NetUI1.usri1_flags      = UF_WORKSTATION_TRUST_ACCOUNT | UF_SCRIPT;
            NetUI1.usri1_priv       = USER_PRIV_USER;

            NetStatus = NetUserAdd( lpDcName, 1, (PBYTE)&NetUI1, &BadParam );

            if ( NetStatus != NERR_Success )
            {
                NetpLog(( "NetpManageMachineAccountWithSid: NetUserAdd on '%ws' for '%ws' failed: 0x%lx\n", lpDcName, lpMachAcc, NetStatus ));

                if ( NetStatus == NERR_PasswordTooShort )
                {
                    //
                    // SAM did not accpet a long password, try LM20_PWLEN
                    //
                    // Please refer to comments in NetpSetMachineAccountPasswordAndTypeEx
                    // regarding the reasons why we weaken the passwords in
                    // this order.
                    //
                    lpPassword[LM20_PWLEN] = UNICODE_NULL;

                    NetStatus = NetUserAdd( lpDcName, 1, (PBYTE)&NetUI1,
                                            &BadParam );

                    if ( NetStatus == NERR_PasswordTooShort )
                    {
                        NetpLog(( "NetpManageMachineAccountWithSid: NetUserAdd on '%ws' for '%ws' failed:2: 0x%lx\n", lpDcName, lpMachAcc, NetStatus ));

                        //
                        // SAM did not accpet a LM20_PWLEN password,
                        // try a shorter one
                        //
                        lpPassword[LM20_PWLEN/2] = UNICODE_NULL;
                        NetStatus = NetUserAdd( lpDcName, 1, (PBYTE)&NetUI1,
                                                &BadParam );
                        if ( NetStatus == NERR_PasswordTooShort )
                        {
                            NetpLog(( "NetpManageMachineAccountWithSid: NetUserAdd on '%ws' for '%ws' failed:3: 0x%lx\n", lpDcName, lpMachAcc, NetStatus ));
                            //
                            // SAM did not accpet a short pwd, try default pwd
                            //
                            NetpGenerateDefaultPassword(lpMachAcc, lpPassword);
                            NetStatus = NetUserAdd( lpDcName, 1, (PBYTE)&NetUI1,
                                                    &BadParam );
                        }
                    }

                    if (NetStatus == NERR_Success)
                    {
                        NetpLog(( "NetpManageMachineAccountWithSid: successfully created computer account\n" ));
                    }
                    else
                    {
                        NetpLog(( "NetpManageMachineAccountWithSid: NetUserAdd on '%ws' for '%ws' failed:4: 0x%lx\n", lpDcName, lpMachAcc, NetStatus ));
                    }
                }
                //
                // See if it exists and we just need to adjust the password
                //
                else if ( NetStatus == NERR_UserExists || NetStatus == ERROR_LOGON_FAILURE )
                {
                    NetStatus = NetpSetMachineAccountPasswordAndTypeEx(
                                    lpDcName,
                                    DomainSid,
                                    lpMachAcc,
                                    lpPassword,
                                    ACCOUNT_STATE_ENABLED,
                                    fIsNt4Dc );

                    NetpLog(( "NetpManageMachineAccountWithSid: status of attempting to set password on '%ws' for '%ws': 0x%lx\n", lpDcName, lpMachAcc, NetStatus ));
                }
            }

        } else if ( fControl == NETSETUPP_RENAME )
        {
            NetUI0.usri0_name = lpMachAcc;

            NetStatus = NetUserSetInfo( lpDcName, lpOldMachAcc,
                                        0, (PBYTE)&NetUI0, NULL );

            NetpLog(( "NetpManageMachineAccountWithSid: status of NetUserSetInfo on '%ws' for '%ws': 0x%lx\n", lpDcName, lpOldMachAcc, NetStatus ));

            //
            // Update the display name as well.
            //  Ignore error as this is not critical.
            //
            if ( NetStatus == NERR_Success ) {
                NET_API_STATUS TmpNetStatus;
                PUSER_INFO_10 usri10 = NULL;

                //
                // First get the current display name
                //
                TmpNetStatus = NetUserGetInfo( lpDcName, lpMachAcc,
                                               10, (PBYTE *)&usri10 );

                if ( TmpNetStatus != NERR_Success ) {
                    NetpLog(( "NetpManageMachineAccountWithSid: failed to get display name (ignored) 0x%lx\n", TmpNetStatus ));

                //
                // If the display name exists and is
                //  different from the new one, update it
                //
                } else if ( usri10->usri10_full_name != NULL &&
                            _wcsicmp(usri10->usri10_full_name, lpMachAcc) != 0 ) {

                    USER_INFO_1011 usri1011;

                    usri1011.usri1011_full_name = lpMachAcc;  // new name
                    TmpNetStatus = NetUserSetInfo( lpDcName, lpMachAcc,
                                                   1011, (PBYTE)&usri1011, NULL );
                    if ( TmpNetStatus != NERR_Success ) {
                        NetpLog(( "NetpManageMachineAccountWithSid: failed to update display name (ignored) 0x%lx\n", TmpNetStatus ));
                    }
                }

                //
                // Free the user info we got
                //
                if ( usri10 != NULL ) {
                    NetApiBufferFree( usri10 );
                }
            }
        }
        else if ( fControl == NETSETUPP_SET_PASSWORD )
        {
            NetStatus = NetpSetMachineAccountPasswordAndType( lpDcName, DomainSid,
                                                              lpMachAcc, lpPassword );
            NetpLog(( "NetpManageMachineAccountWithSid: status of setting password on '%ws' for '%ws': 0x%lx\n", lpDcName, lpMachAcc, NetStatus ));
        }
        else
        {
            NetStatus = ERROR_INVALID_PARAMETER;
        }
    }

    NetApiBufferFree( lpMachAcc );
    NetApiBufferFree( lpOldMachAcc );

    return( NetStatus );
}

NET_API_STATUS
NET_API_FUNCTION
NetpManageMachineAccount(
    IN  LPWSTR      lpMachine,
    IN  LPWSTR      lpOldMachine,
    IN  LPWSTR      lpDcName,
    IN  LPWSTR      lpPassword,
    IN  ULONG       fControl,
    IN  ULONG       AccountOptions,
    IN  BOOL        fIsNt4Dc
    )
/*++

Routine Description:

    Manages the creation/deletion, and manipulation of the machine account

Arguments:

    lpMachine      -- Name of the current machine /
                      name of the new machine for rename
    lpOldMachine   -- Old machine name for rename
    lpDcName       -- Name of a DC in the domain
    lpPassword     -- Password to use for machine object.  If NULL, use the default.
    fControl       -- Whether to create/delete/rename
    AccountOptions -- Options to determine the particular behavior of the account creation
    fIsNt4Dc       -- TRUE if the DC is NT4 or earlier

Returns:

    NERR_Success -- Success
    ERROR_INVALID_PASSWORD -- The machine account could not have a random password set
                              on it, so it must resort to using the default password

--*/
{
    NET_API_STATUS  NetStatus = NERR_Success;
    PPOLICY_PRIMARY_DOMAIN_INFO  pPolicy;
    PPOLICY_DNS_DOMAIN_INFO      pDns;

    NetStatus = NetpGetLsaPrimaryDomain( NULL, lpDcName, &pPolicy, &pDns, NULL );

    if ( NetStatus == NERR_Success )
    {
        NetStatus = NetpManageMachineAccountWithSid( lpMachine, lpOldMachine,
                                                     lpDcName, lpPassword,
                                                     pPolicy->Sid, fControl,
                                                     AccountOptions,
                                                     fIsNt4Dc );

        LsaFreeMemory( pPolicy );
        LsaFreeMemory( pDns );
    }

    return( NetStatus );
}


NET_API_STATUS
NET_API_FUNCTION
NetpUnJoinDomain(
    IN  PPOLICY_PRIMARY_DOMAIN_INFO pPolicyPDI,
    IN  LPWSTR                      lpAccount,
    IN  LPWSTR                      lpPassword,
    IN  DWORD                       fJoinOpts
    )
{
    NET_API_STATUS NetStatus = NERR_Success;
    NET_JOIN_STATE JoinState = { 0 };
    WCHAR  szMachineNameBuf[MAX_COMPUTERNAME_LENGTH + 1];
    LPWSTR szMachineName=szMachineNameBuf;
    DWORD dwJoinAction=0;
    POLICY_PRIMARY_DOMAIN_INFO PolicyPDI;
    NT_PRODUCT_TYPE ProductType;

    PolicyPDI = *pPolicyPDI;
    PolicyPDI.Sid = NULL;

    NetSetuppOpenLog();

    NetpLog(("NetpUnJoinDomain: unjoin from '%wZ' using '%ws' creds, options: 0x%lx\n", &pPolicyPDI->Name, lpAccount, fJoinOpts));
    NetpLogBuildInformation();

    //
    // check to see if the machine being joined is a DC
    // if it is, we cannot let this join another domain/workgroup.
    //
    if (!RtlGetNtProductType(&ProductType))
    {
        NetStatus = GetLastError();
    }
    else if (ProductType == NtProductLanManNt)
    {
        NetStatus = NERR_SetupDomainController;
        NetpLog(( "NetpUnJoinDomain: the specified machine is a domain controller.\n"));
    }

    if (NetStatus == NERR_Success)
    {
        //
        // get the computer name
        //
        NetStatus = NetpGetComputerNameAllocIfReqd(
            &szMachineName, MAX_COMPUTERNAME_LENGTH+1);
        NetpLog(( "NetpUnJoinDomain: status of getting computer name: 0x%lx\n", NetStatus ));

        if (NetStatus == NERR_Success)
        {
            dwJoinAction =
            NJA_SetNetlogonState       |
            NJA_SetTimeSvcUnjoin       |
            NJA_SetAutoenrolSvcUnjoin  |
            NJA_SetPolicyDomainInfo    |
            NJA_RemoveFromLocalGroups  |
            NJA_DeleteMachinePassword  |
            NJA_RemoveDnsRegistrations |
            NJA_RollbackOnFailure;

            if ( FLAG_ON( fJoinOpts, NETSETUP_ACCT_DELETE ) )
            {
                dwJoinAction |= NJA_DeleteAccount;
            }

            JoinState.szDomainName = pPolicyPDI->Name.Buffer;
            JoinState.pPolicyPDI   = &PolicyPDI;

            JoinState.uiNetlogonStartType = NETSETUP_SVC_MANUAL;
            JoinState.uiNetlogonState     = NETSETUP_SVC_STOPPED;

            NetStatus = NetpApplyJoinState(&JoinState, dwJoinAction,
                                           szMachineName,
                                           lpAccount, lpPassword, NULL);
        }
    }

    NetpLog(( "NetpUnJoinDomain: status: 0x%lx\n", NetStatus));

    NetSetuppCloseLog();

    if (szMachineName != szMachineNameBuf)
    {
        NetApiBufferFree(szMachineName);
    }

    return NetStatus;
}

NET_API_STATUS
NET_API_FUNCTION
NetpControlServices(
    IN  DWORD       SvcOpts,
    IN  DWORD       Services
    )
/*++

Routine Description:

    Controls the state of the netlogon service

Arguments:

    SvcOpts -- What to do to the service, such as start/stop or
               enable/disable
    Services -- Which services to control

Returns:

    NERR_Success -- Success

--*/
{
    NET_API_STATUS  NetStatus = NERR_Success;
    SC_HANDLE       hScMgr=NULL, hSvc=NULL;
    DWORD           i, OpenMode=0;

    PWSTR   ppwszServices[] = {
            SERVICE_NETLOGON
            };

    //
    // Open the service control manager
    //
    hScMgr = OpenSCManager( NULL,
                            SERVICES_ACTIVE_DATABASE,
                            GENERIC_READ | GENERIC_WRITE | GENERIC_EXECUTE );

    if ( hScMgr == NULL )
    {
        NetStatus = GetLastError();
        NetpLog(( "NetpControlServices: open SCManager failed: 0x%lx\n", NetStatus ));
    }
    else
    {
        i = 0;
        while ( Services != 0 )
        {
            if ( FLAG_ON( Services, 0x00000001 ) )
            {
                if ( i > sizeof( ppwszServices ) / sizeof( PWSTR ) )
                {
                    NetStatus = ERROR_INVALID_PARAMETER;
                    ASSERT( FALSE && "Invalid Service" );
                    break;
                }

                OpenMode = 0;

                //
                // Set the open mode
                //
                if( FLAG_ON( SvcOpts, NETSETUP_SVC_STOPPED ) )
                {
                    OpenMode = SERVICE_STOP | SERVICE_ENUMERATE_DEPENDENTS |
                                    SERVICE_QUERY_STATUS | SERVICE_CHANGE_CONFIG;

                } else if( FLAG_ON( SvcOpts, NETSETUP_SVC_STARTED ) )
                {
                    OpenMode = SERVICE_START;

                }

                if ( FLAG_ON( SvcOpts, NETSETUP_SVC_ENABLED |
                                       NETSETUP_SVC_DISABLED |
                                       NETSETUP_SVC_MANUAL ) )
                {
                    OpenMode |= SERVICE_CHANGE_CONFIG | SERVICE_QUERY_CONFIG;
                }

                if ( FLAG_ON( SvcOpts, NETSETUP_SVC_STOPPED ) )
                {
                    NetStatus = NetpStopService( ppwszServices[ i ], hScMgr );

                    if ( NetStatus != NERR_Success )
                    {
                        break;
                    }
                }

                //
                // Open the service
                //
                hSvc = OpenService( hScMgr, ppwszServices[i], OpenMode );

                if ( hSvc == NULL )
                {
                    NetStatus = GetLastError();
                    NetpLog(( "NetpControlServices: open service '%ws' failed: 0x%lx\n", ppwszServices[i], NetStatus ));

                }
                else
                {
                    if ( FLAG_ON( SvcOpts, NETSETUP_SVC_ENABLED  |
                                           NETSETUP_SVC_DISABLED |
                                           NETSETUP_SVC_MANUAL ) )
                    {
                        DWORD   StartControl = 0;

                        if ( FLAG_ON( SvcOpts, NETSETUP_SVC_ENABLED ) )
                        {
                            StartControl = SERVICE_AUTO_START;
                        }
                        else if ( FLAG_ON( SvcOpts, NETSETUP_SVC_DISABLED ) )
                        {
                            StartControl = SERVICE_DISABLED;
                        }
                        else if ( FLAG_ON( SvcOpts, NETSETUP_SVC_MANUAL ) )
                        {
                            StartControl = SERVICE_DEMAND_START;
                        }

                        if ( ChangeServiceConfig( hSvc, SERVICE_NO_CHANGE,
                                                  StartControl,
                                                  SERVICE_NO_CHANGE,
                                                  NULL, NULL, 0, NULL, NULL, NULL,
                                                  NULL ) == FALSE )
                        {
                            NetStatus = GetLastError();
                            NetpLog(( "NetpControlServices:  configuring service '%ws' [ 0x%lx ] failed: 0x%lx\n",
                                      ppwszServices[i], StartControl, NetStatus ));

                        }
                    }

                    if ( FLAG_ON( SvcOpts, NETSETUP_SVC_STARTED ) )
                    {
                        //
                        // See about changing its state
                        //
                        if ( StartService( hSvc, 0, NULL  ) == FALSE )
                        {
                            NetStatus = GetLastError();

                            if ( NetStatus == ERROR_SERVICE_ALREADY_RUNNING )
                            {
                                NetStatus = NERR_Success;
                            }
                            else
                            {
                                NetpLog(( "NetpControlServices: start service '%ws' failed: 0x%lx\n", ppwszServices[i], NetStatus ));
                            }
                        }

                    }
                    CloseServiceHandle( hSvc );
                }
            }
            i++;
            Services >>= 1;
        }

        CloseServiceHandle( hScMgr );
    }

    return(NetStatus);
}



NET_API_STATUS
NET_API_FUNCTION
NetpChangeMachineName(
    IN  LPWSTR      lpCurrentMachine,
    IN  LPWSTR      lpNewHostName,
    IN  LPWSTR      lpDomain,
    IN  LPWSTR      lpAccount,
    IN  LPWSTR      lpPassword,
    IN  DWORD       fOptions
)
/*++

Routine Description:

    Handles the machine rename case

Arguments:

    lpCurrentMachine -- The current Netbios machine name
    lpNewHostName -- The new (untruncated) machine name (may be longer than 15 chars)
    lpDomain     -- Domain the machine is a member of
    lpAccount    -- Account to use for machine account manipulation
    lpPassword   -- Password to use for machine account manipulation.
                    The password has been encoded and the first WCHAR
                    of the password buffer is the seed
    fOptions     -- Whether to mess with the machine account or not

Returns:

    NERR_Success -- Success

--*/
{
    NET_API_STATUS              NetStatus = NERR_Success;
    PWSTR                       DomainControllerName = NULL;
    ULONG                       DcFlags = 0;
    ULONG                       cLen;
    BOOLEAN                     IpcConnect = FALSE;
    UCHAR                       Seed;
    UNICODE_STRING              EncodedPassword;
    BOOL                        fIsOemCompatible=FALSE;

    WCHAR                       lpNewMachine[MAX_COMPUTERNAME_LENGTH + 1];
    PDOMAIN_CONTROLLER_INFO     DcInfo = NULL;
    PPOLICY_PRIMARY_DOMAIN_INFO pPolicyLocalPDI = NULL;
    PPOLICY_DNS_DOMAIN_INFO     pPolicyLocalDns = NULL;
    LPWSTR                      DnsHostName = NULL;
    NT_PRODUCT_TYPE             NtProductType;

    NetSetuppOpenLog();

    if ( lpPassword )
    {
        if ( wcslen( lpPassword ) < 1 )
        {
            return( ERROR_INVALID_PARAMETER );
        }

        Seed = ( UCHAR )*lpPassword;
        RtlInitUnicodeString( &EncodedPassword, lpPassword + 1 );

    }
    else
    {
        RtlZeroMemory( &EncodedPassword, sizeof( UNICODE_STRING ) );
        Seed = 0;
    }

    NetpLog(( "NetpChangeMachineName: from '%ws' to '%ws' using '%ws' [0x%lx]\n",
                        GetStrPtr(lpCurrentMachine),
                        GetStrPtr(lpNewHostName),
                        GetStrPtr(lpAccount), fOptions));
    //
    // Only do this if we have create/manage account specified
    //
    if ( FLAG_ON(fOptions, NETSETUP_ACCT_CREATE) )
    {
        //
        // Find a DC in that domain
        //
        NetStatus = NetpDsGetDcName( NULL,
                                     lpDomain,
                                     lpCurrentMachine,
                                     FLAG_ON( fOptions, NETSETUP_ACCT_CREATE ) ?
                                       NETSETUPP_DSGETDC_FLAGS :
                                       NETSETUP_DSGETDC_FLAGS_ACCOUNT_EXISTS,
                                     &DcFlags,
                                     &DomainControllerName,
                                     &DcInfo );

        //
        // If this is a DC, ensure we are using it.
        //  This is done to avoid cases when we modify our computer
        //  object on some other downlevel DC which doesn't update
        //  the server object in the config container. Besides, we
        //  don't really know how this DC would behave itself after
        //  its computer object gets updated on incoming replication
        //  change from some other DC.
        //
        if ( NetStatus == NERR_Success &&
             RtlGetNtProductType(&NtProductType) &&
             NtProductType == NtProductLanManNt ) {  // DC

            //
            // If we got Netbios name,
            //  compare it with the one we have
            //
            if ( (DcInfo->Flags & DS_DNS_DOMAIN_FLAG) == 0 ) {
                if ( I_NetNameCompare(NULL,
                                      lpCurrentMachine,
                                      DcInfo->DomainControllerName+2, // skip '\\'
                                      NAMETYPE_COMPUTER, 0) != 0 ) {

                    NetpLog(( "NetpChangeMachineName: Got other Netbios DC '%ws' than local machine '%ws'\n",
                              DcInfo->DomainControllerName+2,
                              lpCurrentMachine ));

                    NetStatus = ERROR_NO_SUCH_DOMAIN;
                }

            //
            // Otherwise, get the local DNS host name and
            //  compare it with the one from DC locator
            //
            } else {
                WCHAR LocalDnsHostName[DNS_MAX_NAME_BUFFER_LENGTH];
                ULONG LocalDnsHostNameLen = DNS_MAX_NAME_BUFFER_LENGTH;

                if ( GetComputerNameExW(ComputerNameDnsFullyQualified,
                                        LocalDnsHostName,
                                        &LocalDnsHostNameLen) ) {

                    if ( !DnsNameCompare_W(DcInfo->DomainControllerName+2,
                                           LocalDnsHostName) ) {

                        NetpLog(( "NetpChangeMachineName: Got other DNS DC '%ws' than local machine '%ws'\n",
                                  DcInfo->DomainControllerName+2,
                                  LocalDnsHostName ));

                        NetStatus = ERROR_NO_SUCH_DOMAIN;
                    }
                } else {
                    NetStatus = GetLastError();
                }
            }
        }

        //
        // Get the computer name from the host name (truncate as needed)
        //
        if ( NetStatus == NERR_Success ) {
            ULONG Size = MAX_COMPUTERNAME_LENGTH + 1;
            BOOL Result;

            Result = DnsHostnameToComputerNameW( lpNewHostName,
                                                 lpNewMachine,
                                                 &Size );

            if ( Result != TRUE ) {
                NetStatus = GetLastError();
                NetpLog(( "NetpChangeMachineName: DnsHostnameToComputerNameW failed: 0x%lx\n", NetStatus ));
            }
        }

        if ( NetStatus == NERR_Success )
        {
            RtlRunDecodeUnicodeString( Seed, &EncodedPassword );
            NetStatus = NetpManageIPCConnect( DomainControllerName,
                                              lpAccount, EncodedPassword.Buffer,
                                              NETSETUPP_CONNECT_IPC );
            RtlRunEncodeUnicodeString( &Seed, &EncodedPassword );

            NetpLog(( "NetpChangeMachineName: status of connecting to  dc '%ws': 0x%lx\n", DomainControllerName, NetStatus ));

            if ( NetStatus == NERR_Success )
            {
                IpcConnect = TRUE;

                //
                // REVIEW kahrent 03-March-00
                //  See review comment above with the same date
                //
                //$ kumarp 02-June-1999
                //  the following requires admin access to the dc so that the
                //  right regkeys could be read to decide the default locale.
                //  We need to get a remoted API to get default locale
                //  on the dc.

                //
                // make sure that the machine name is OEM codepage compatible with
                // the default codepage being used on the dc. We determine this
                // by translating the machine name to oem string using the
                // local code page and the dc code page and then binary comparing
                // the resultant strings. if the strings are different, we
                // will fail the rename.
                //
                // Note that this is not a limitation of join apis. netlogon uses
                // oem translated netbios machine name internally. the translation
                // is different if the code page on the dc and the local machine are
                // not compatible. This causes lack of access to net resources.
                //
                /*
                NetStatus = NetpVerifyStrOemCompatibleOnMachine(
                    DomainControllerName, lpNewMachine);
                NetpLog(( "NetpChangeMachineName: status of verifying OEM compatibility of computer name: 0x%lx\n", NetStatus ));
                */
            }
        }

        if ( NetStatus == NERR_Success )
        {
            NetStatus = NetpManageMachineAccount( lpNewMachine, lpCurrentMachine,
                                                  DomainControllerName,
                                                  NULL, NETSETUPP_RENAME, 0,
                                                  TRUE );  // NT4 DC; but doesn't really matter for rename
        }

        //
        // Set DnsHostName and SPN attributes
        //
        // First get the local DNS domain name to be used
        //  in case primary DNS suffix defaults to DNS domain name.
        //
        if ( NetStatus == NERR_Success ) {
            NetStatus = NetpGetLsaPrimaryDomain( NULL,
                                                 NULL,
                                                 &pPolicyLocalPDI,
                                                 &pPolicyLocalDns,
                                                 NULL );
        }

        //
        // Determine DnsHostName of this machine
        //
        if ( NetStatus == NERR_Success &&
             (DcFlags & DS_DS_FLAG) != 0 &&
             pPolicyLocalDns != NULL ) {
            NetStatus = NetpGetDnsHostName( lpNewHostName,
                                            &pPolicyLocalDns->DnsDomainName,
                                            &DnsHostName );
        }

        //
        // Now set DnsHostName and SPNs.
        //
        // (Comments in NetpJoinDomain where we call
        //  NetpSetDnsHostNameAndSpn all aply here, too)
        //
        if ( NetStatus == NERR_Success &&
             DnsHostName != NULL &&
             lpAccount != NULL && lpPassword != NULL ) {

            //
            // Tell netlogon that it should avoid
            //  setting DnsHostName and SPN until the reboot
            //

            NetpAvoidNetlogonSpnSet( TRUE );

            RtlRunDecodeUnicodeString( Seed, &EncodedPassword );
            NetStatus = NetpSetDnsHostNameAndSpn( DcInfo,
                                                  lpAccount,
                                                  EncodedPassword.Buffer,
                                                  lpNewMachine,
                                                  DnsHostName );
            RtlRunEncodeUnicodeString( &Seed, &EncodedPassword );

            NetpLog(( "NetpChangeMachineName: status of setting DnsHostName and SPN: 0x%lx\n", NetStatus ));

            //
            // If the problem was that values were invalid,
            // return a distinctive error indicating where that happened
            //

            if ( NetStatus == ERROR_INVALID_PARAMETER ) {
                NetStatus = ERROR_DS_COULDNT_UPDATE_SPNS;
            }

            //
            // On error, take back what we told Netlogon
            //

            if ( NetStatus != NO_ERROR ) {
                NetpAvoidNetlogonSpnSet( FALSE );
            }
        }

    }

    if ( IpcConnect )
    {
        RtlRunDecodeUnicodeString( Seed, &EncodedPassword );
        NetpManageIPCConnect( DomainControllerName, lpAccount,
                              EncodedPassword.Buffer, NETSETUPP_DISCONNECT_IPC );
        RtlRunEncodeUnicodeString( &Seed, &EncodedPassword );
    }

    //
    // Free up memory
    //

    NetApiBufferFree( DomainControllerName );
    NetApiBufferFree( DcInfo );
    NetApiBufferFree( DnsHostName );
    if ( pPolicyLocalPDI != NULL ) {
        LsaFreeMemory( pPolicyLocalPDI );
    }
    if ( pPolicyLocalDns != NULL ) {
        LsaFreeMemory( pPolicyLocalDns );
    }

    NetSetuppCloseLog( );

    return( NetStatus );
}




NET_API_STATUS
NET_API_FUNCTION
NetpDsGetDcName(
    IN LPWSTR ComputerName, OPTIONAL
    IN LPWSTR DomainName,
    IN LPWSTR MachineName,  OPTIONAL
    IN ULONG Flags,
    OUT PULONG DcFlags,
    OUT PWSTR *DcName,
    OUT PDOMAIN_CONTROLLER_INFO *DcInfo   OPTIONAL
)
/*++

Routine Description:

    Find a dc in the specified domain using the following steps:
    - get the machine account name
    - find a writable dc that has this machine account
    - if we cannot find such dc, find any writable dc

Arguments:

    ComputerName -- name of the remote server to process this function.
                    typically this is the name of the preferred dc.
    DomainName   -- Domain for which we want to find a dc
    MachineName  -- current machine name
    Flags        -- flags to be passed to DsGetDcName* functions
    DcFlags      -- flags returned by DsGetDcName* functions
    DcName       -- name of the DC found
    DcInfo       -- info about the DC found

Returns:

    NERR_Success -- Success

--*/
{
    NET_API_STATUS NetStatus = NERR_Success;
    PDOMAIN_CONTROLLER_INFO pDCInfo = NULL;
    WCHAR wszMachine[MAX_COMPUTERNAME_LENGTH + 2];
    PWSTR pwszMachine = wszMachine;
    ULONG Len;

    NetpLog(( "NetpDsGetDcName: trying to find DC in domain '%ws', flags: 0x%lx\n", DomainName, Flags ));

    //
    // generate the machine account name
    //
    if ( MachineName == NULL )
    {
        // note: NetpGetComputerNameAllocIfReqd allocates 1 extra
        //       char for the $
        NetStatus = NetpGetComputerNameAllocIfReqd(&pwszMachine,
                                                   MAX_COMPUTERNAME_LENGTH+1);
    }
    else
    {
        Len = wcslen( MachineName );

        if ( Len > MAX_COMPUTERNAME_LENGTH )
        {
            NetStatus = NetApiBufferAllocate( ( Len + 2 ) * sizeof(WCHAR),
                                              ( PBYTE * )&pwszMachine );
        }

        if ( NetStatus == NERR_Success )
        {
            wcscpy(pwszMachine, MachineName);
        }
    }

    if ( NetStatus == NERR_Success )
    {
        wcscat(pwszMachine, L"$");
    }
    MachineName = pwszMachine;

    //
    // Now that we have the machine account name, see if we can
    // find a dc that has this account
    //
    if ( NetStatus == NERR_Success )
    {
        NetStatus = DsGetDcNameWithAccountW( ComputerName, MachineName,
                                             UF_WORKSTATION_TRUST_ACCOUNT |
                                                  UF_SERVER_TRUST_ACCOUNT,
                                             DomainName,
                                             NULL, NULL, Flags, &pDCInfo );

        if ( NetStatus == ERROR_NO_SUCH_USER )
        {
            NetpLog(( "NetpDsGetDcName: failed to find a DC having account '%ws': 0x%lx\n",
                                MachineName, NetStatus ));

            //
            // we didnt find a dc with that account.
            // try to find any writable dc in that domain
            //
            NetStatus = DsGetDcName( ComputerName, DomainName,
                                     NULL, NULL, Flags, &pDCInfo );
        }

        //
        // on success, set the out parameters
        //
        if ( NetStatus == NERR_Success )
        {
            *DcFlags = pDCInfo->Flags;
            NetStatus = NetpDuplicateString(pDCInfo->DomainControllerName,
                                            -1, DcName);
            if ( DcInfo )
            {
                *DcInfo = pDCInfo;
            }
            else
            {
                NetApiBufferFree( pDCInfo );
            }
        }
    }

    if ( NetStatus == NERR_Success )
    {
        NetpLog(( "NetpDsGetDcName: found DC '%ws' in the specified domain\n",
                            *DcName));
    }
    else
    {
        NetpLog(( "NetpDsGetDcName: failed to find a DC in the specified domain: 0x%lx\n", NetStatus));
    }

    //
    // Free any memory we may have allocated
    //
    if ( pwszMachine != wszMachine )
    {
        NetApiBufferFree( pwszMachine );
    }

    return( NetStatus );
}


NET_API_STATUS
NET_API_FUNCTION
NetpStopService(
    IN LPWSTR       Service,
    IN SC_HANDLE    SCManager
    )
/*++

Routine Description:

    Stops the specified service and all of its depenendencies

Arguments:

    Service -- Name of the service to stop
    SCManager -- Open handle to the Service Controller

Returns:

    NERR_Success -- Success

--*/
{
    NET_API_STATUS NetStatus = NERR_Success;
    SERVICE_STATUS SvcStatus;
    SC_HANDLE Svc;
    LPENUM_SERVICE_STATUS DependentServices = NULL;
    ULONG DependSvcSize = 0, DependSvcCount = 0, i;

    //
    // Open the service
    //
    Svc = OpenService( SCManager,
                       Service,
                       SERVICE_STOP | SERVICE_ENUMERATE_DEPENDENTS | SERVICE_QUERY_STATUS );

    if ( Svc == NULL ) {

        NetStatus = GetLastError();
        NetpLog(( "Failed to open SCManager\n", NetStatus ));

    } else {


       //
       // Enumerate all of the dependent services first
       //
       if(EnumDependentServices( Svc,
                                 SERVICE_ACTIVE,
                                 NULL,
                                 0,
                                 &DependSvcSize,
                                 &DependSvcCount ) == FALSE ) {

           NetStatus = GetLastError();
       }



       if ( NetStatus == ERROR_MORE_DATA ) {

           NetStatus = NetApiBufferAllocate( DependSvcSize,
                                            (PBYTE *)&DependentServices );

           if ( NetStatus == NERR_Success ) {


               if( EnumDependentServices( Svc,
                                          SERVICE_ACTIVE,
                                          DependentServices,
                                          DependSvcSize,
                                          &DependSvcSize,
                                          &DependSvcCount ) == FALSE ) {

                   NetStatus = GetLastError();

               } else {

                   for ( i = 0; i < DependSvcCount; i++) {

                       NetStatus = NetpStopService( DependentServices[i].lpServiceName,
                                                    SCManager );

                       if ( NetStatus != NERR_Success ) {

                           break;
                       }

                   }
               }

               NetApiBufferFree( DependentServices );
           }

       }


       if ( NetStatus == NERR_Success ) {

           if ( ControlService( Svc,
                                SERVICE_CONTROL_STOP,
                                &SvcStatus ) == FALSE ) {

               NetStatus = GetLastError();

               //
               // It's not an error if the service wasn't running
               //
               if ( NetStatus == ERROR_SERVICE_NOT_ACTIVE ) {

                   NetStatus = ERROR_SUCCESS;

               } else {

                    NetpLog(( "Stop service on  '%ws' failed with 0x%lx\n",
                                        Service, NetStatus ));

               }

           } else {

               NetStatus = ERROR_SUCCESS;

               //
               // Wait for the service to stop
               //
               while ( TRUE ) {

                   if( QueryServiceStatus( Svc, &SvcStatus ) == FALSE ) {

                       NetStatus = GetLastError();
                   }

                   if ( NetStatus != ERROR_SUCCESS ||
                                       SvcStatus.dwCurrentState == SERVICE_STOPPED) {

                       break;
                   }

                   Sleep( 1000 );
               }

           }

        } else {

           NetpLog(( "Failed to enumerate dependentServices for '%ws': 0x%lx\n",
                               Service, NetStatus ));

        }
    }

    return( NetStatus );

}

NET_API_STATUS
NET_API_FUNCTION
NetpValidateName(
    IN  LPWSTR              lpMachine,
    IN  LPWSTR              lpName,
    IN  LPWSTR              lpAccount,      OPTIONAL
    IN  LPWSTR              lpPassword,     OPTIONAL
    IN  NETSETUP_NAME_TYPE  NameType
    )
/*++

Routine Description:

    Ensures that the given name is valid for a name of that type

Arguments:

    lpMachine -- Name of the machine being run on
    lpName -- Name to validate
    NameType -- Type of the name to validate

Returns:

    NERR_Success -- Name is valid
    ERROR_INVALID_PARAMETER -- A bad parameter was given
    NERR_InvalidComputer -- The name format given is bad
    ERROR_DUP_NAME -- The name is invalid for this type

--*/
{
    NET_API_STATUS  NetStatus = NERR_Success, ReturnStatus;
    PWSTR LocalComputerName = NULL;
    ULONG ValidateNameType;
    BOOLEAN NBNameFailed = FALSE;
    BOOLEAN NonRfcDnsName = FALSE;
    PSTR NameTypeString;
    WCHAR  szMachineNameBuf[MAX_COMPUTERNAME_LENGTH + 1];
    LPWSTR szMachineName=szMachineNameBuf;

    NetSetuppOpenLog();
    NetpLog(( "NetpValidateName: checking to see if '%ws' is valid as type %d name\n", GetStrPtr(lpName), (UINT) NameType ));

    if ((lpName == NULL) || (NameType == NetSetupUnknown))
    {
        NetStatus = ERROR_INVALID_PARAMETER;
    }

    //
    // Name valid as a Netbios or DNS name
    //
    if ( NameType != NetSetupDnsMachine )
    {
        switch ( NameType )
        {
            case NetSetupMachine:
                ValidateNameType = NAMETYPE_COMPUTER;
                ReturnStatus = NERR_InvalidComputer;
                NameTypeString = "machine";
                break;

            case NetSetupWorkgroup:
                ValidateNameType = NAMETYPE_WORKGROUP;
                ReturnStatus = NERR_InvalidWorkgroupName;
                NameTypeString = "workgroup";
                break;

            case NetSetupDomain:
            case NetSetupNonExistentDomain:
                ValidateNameType = NAMETYPE_DOMAIN;
                ReturnStatus = ERROR_INVALID_DOMAINNAME;
                NameTypeString = "domain";
                break;

            default:
                ReturnStatus = ERROR_INVALID_PARAMETER;
                break;
        }


        NetStatus = I_NetNameValidate( NULL, lpName, ValidateNameType,
                                       LM2X_COMPATIBLE );

        if ( NetStatus == NERR_Success &&
             NameType == NetSetupMachine &&
             wcslen( lpName ) > CNLEN )
        {
            NetStatus = NERR_InvalidComputer;
        }

        if ( NetStatus != NERR_Success )
        {
            NetpLog(( "NetpValidateName: '%ws' is not a valid NetBIOS %s name: 0x%lx\n", lpName, NameTypeString, NetStatus ));

            //
            // If we are checking for a domain name, we'll automaticly
            // pass it on to the Dns name validation.  This is because
            // the name has to only be valid for one name type
            //
            NetStatus = ReturnStatus;

            if ( NameType == NetSetupDomain ||
                 NameType == NetSetupNonExistentDomain )
            {
                NBNameFailed = TRUE;
                NetStatus = NERR_Success;
            }
        }
    }

    if ( NetStatus == NERR_Success )
    {
        NetStatus =  DnsValidateDnsName_W( lpName );

        if ( NetStatus != NERR_Success )
        {
            switch ( NameType )
            {
                case NetSetupMachine:
                case NetSetupWorkgroup:
                    NetStatus = NERR_Success;
                    break;

                case NetSetupDomain:
                case NetSetupNonExistentDomain:
                    /*
                       the following if stmt fixes bug #382695.
                       this bug was postponed therefore I am commenting out
                       the fix. Uncomment this after NT5 RTM

                       if (NetStatus == ERROR_INVALID_NAME)
                       {
                       NetStatus = ERROR_INVALID_DOMAINNAME;
                       }
                       */
                    break;

                case NetSetupDnsMachine:
                default:
                    break;
            }

            if ( NetStatus != NERR_Success )
            {
                NetpLog(( "NetpValidateName:  '%ws' is not a valid Dns %s name: 0x%lx\n", lpName, NameType == NetSetupMachine ? "machine" : "domain", NetStatus ));

                //
                // If the the NetBIOS domain name validation succeeded but
                // the Dns failed, consider it success.
                //
                if ( !NBNameFailed &&
                     ( NameType == NetSetupDomain ||
                       NameType == NetSetupNonExistentDomain ) )
                {
                    NetStatus = NERR_Success;
                }

                if (NetStatus == DNS_ERROR_NON_RFC_NAME)
                {
                    NonRfcDnsName = TRUE;
                    NetStatus = NERR_Success;
                }
            }
        }
    }


    //
    // Name unique from computer name
    //
    if ( NetStatus == NERR_Success && NameType == NetSetupWorkgroup )
    {
        if ( lpMachine == NULL )
        {
            NetStatus = NetpGetNewMachineName( &LocalComputerName );

            if ( NetStatus == NERR_Success )
            {
                lpMachine = LocalComputerName;
            }
        }

        if ( NetStatus == NERR_Success && lpMachine )
        {
            if ( _wcsicmp( lpName, lpMachine ) == 0 )
            {
                //
                // Not legal
                //
                NetpLog(( "NetpValidateName: Workgroup same as computer name\n" ));
                NetStatus = NERR_InvalidWorkgroupName;
            }
            else
            {
                NetStatus = NetpCheckNetBiosNameNotInUse( lpName, TRUE, FALSE );

                NetpLog(( "NetpCheckNetBiosNameNotInUse for '%ws' [ Workgroup as MACHINE]  returned 0x%lx\n",
                                   lpName, NetStatus ));

                //$ REVIEW  kumarp 25-May-1999
                //  this is absolutely the wrong thing to do!!
                //  the caller has to decide whether to treat
                //  NERR_NetworkError as error or not. The code
                //  below hides a fatal error.

                //
                // Handle the wkgrp name during setup before
                // networking is installed case.
                //
                if ( NetStatus == NERR_NetworkError )
                {
                    NetStatus = NERR_Success;
                }
            }
        }
    }

    //
    // Name not in use as a netbios name
    //
    // Do this by adding the <lpName>[00] name as a Netbios unique name.
    //
    if ( NetStatus == NERR_Success &&
         ( NameType == NetSetupMachine ||
           NameType == NetSetupNonExistentDomain ) )
    {
        NetStatus = NetpCheckNetBiosNameNotInUse(
            lpName, TRUE, (BOOLEAN) ( NameType == NetSetupMachine ));

        if ((NetStatus == NERR_Success) &&
            (NameType == NetSetupNonExistentDomain))
        {
            //
            // make sure that the domain name is not the same as the local
            // computer name
            //
            NetStatus = NetpGetComputerNameAllocIfReqd(
                &szMachineName, MAX_COMPUTERNAME_LENGTH+1);
            if (NetStatus == NERR_Success)
            {
                if (!_wcsicmp(szMachineName, lpName))
                {
                    NetStatus = ERROR_DUP_NAME;
                }
            }
        }
        NetpLog(( "NetpCheckNetBiosNameNotInUse for '%ws' [MACHINE] returned 0x%lx\n",
                           lpName, NetStatus ));
    }

    //
    // The idea behind the following block of code was to ensure
    // that if this was to be a new domain name or a new machine name,
    // we should check to see if the <lpName>[1C] name is registered or not.
    // If the name is indeed registered, then this cannot be a valid
    // machine/new domain name.  Unfortunately, it doesn't quite work.
    // The problem is that registering the name as a unique name causes
    // problems down the road (WINS??) when we actually try to register
    // this as a group name.  So, the only thing we can do is registry
    // it as a group name, but that doesn't do us any good.
    // So, the net result is that this call is useless.
    //
#if 0
    if ( NetStatus == NERR_Success &&
        ( NameType == NetSetupMachine ||
          NameType == NetSetupNonExistentDomain ) )
    {
        NetStatus = NetpCheckNetBiosNameNotInUse( lpName, FALSE, FALSE );
        NetpLog(( "NetpCheckNetBiosNameNotInUse for '%ws' [MACHINE/DOMAIN] returned 0x%lx\n",
                            lpName, NetStatus ));
    }
#endif

    //
    // Next, the valid domain name
    //
    if ( NetStatus == NERR_Success && NameType == NetSetupDomain )
    {
        if ( _wcsicmp( lpName, L"BUILTIN" ) == 0 )
        {
            NetStatus = NERR_InvalidComputer;
        }
        else
        {
            NetStatus = NetpCheckDomainNameIsValid( lpName, lpAccount,
                                                    lpPassword, TRUE );
        }
        NetpLog(( "NetpCheckDomainNameIsValid [ Exists ] for '%ws' returned 0x%lx\n",
                            lpName, NetStatus ));
    }


    //
    // Then, the invalid domain name
    //
    if ( NetStatus == NERR_Success && NameType == NetSetupNonExistentDomain )
    {
        if ( _wcsicmp( lpName, L"BUILTIN" ) == 0 )
        {
            NetStatus = NERR_InvalidComputer;
        }
        else
        {
            NetStatus = NetpCheckDomainNameIsValid( lpName, lpAccount,
                                                    lpPassword, FALSE );
        }
        NetpLog(( "NetpCheckDomainNameIsValid [ NON-Existant ]for '%ws' returned 0x%lx\n", lpName, NetStatus ));

        //$ REVIEW  kumarp 01-October-1999
        //
        // the if stmt below should be in an outer scope.
        // currently it only affects the NetSetupNonExistentDomain case.
        //
        //  we have verified that a domain with this name does not exist,
        //  restore the non-rfc error code if we got it earlier.
        //
        if ((NetStatus == NERR_Success) && NonRfcDnsName)
        {
            NetpLog(( "NetpValidateName: a domain with the specified non-RFC compliant name does not exist\n" ));
            NetStatus = DNS_ERROR_NON_RFC_NAME;
        }
    }

    if ( NetStatus == NERR_Success )
    {
        NetpLog(( "NetpValidateName: name '%ws' is valid for type %lu\n",
                  lpName, NameType ));
    }

    NetApiBufferFree( LocalComputerName );
    if (szMachineName != szMachineNameBuf)
    {
        NetApiBufferFree(szMachineName);
    }

    NetSetuppCloseLog( );

    return( NetStatus );
}



NET_API_STATUS
NET_API_FUNCTION
NetpGetJoinInformation(
    IN   LPWSTR                 lpServer OPTIONAL,
    OUT  LPWSTR                *lpNameBuffer,
    OUT  PNETSETUP_JOIN_STATUS  BufferType
    )
/*++

Routine Description:

    Gets information on the state of the workstation.  The information
    obtainable is whether the machine is joined to a workgroup or a domain,
    and optionally, the name of that workgroup/domain.

Arguments:

    lpServer     -- ignored, set to NULL
    lpNameBuffer -- Where the domain/workgroup name is returned.
                    memory allocated for this must be freed by the caller
                    by calling NetApiBufferFree
    BufferType   -- Whether the machine is joined to a workgroup or a domain

Returns:

    NERR_Success -- Name is valid
    ERROR_INVALID_PARAMETER -- A bad parameter was given
    ERROR_NOT_ENOUGH_MEMORY -- A memory allocation failed

--*/
{
    NET_API_STATUS              NetStatus = NERR_Success;
    PPOLICY_PRIMARY_DOMAIN_INFO pPolicyPDI=NULL;
    PPOLICY_DNS_DOMAIN_INFO     pPolicyDns=NULL;

    //
    // Check the parameters
    //
    if ( ( lpNameBuffer == NULL ) || ( BufferType == NULL ) )
    {
        return( ERROR_INVALID_PARAMETER );
    }

    //
    // Get the current domain information
    //
    NetStatus = NetpGetLsaPrimaryDomain( NULL, NULL, &pPolicyPDI,
                                         &pPolicyDns, NULL );
    if ( NetStatus == NERR_Success )
    {
        if ( pPolicyPDI->Sid == NULL )
        {
            if ( pPolicyPDI->Name.Length == 0 )
            {
                *BufferType = NetSetupUnjoined;
            }
            else
            {
                *BufferType = NetSetupWorkgroupName;
            }
        }
        else
        {
            if ( pPolicyPDI->Name.Length == 0 )
            {
                *BufferType = NetSetupUnjoined;
            }
            else
            {
                *BufferType = NetSetupDomainName;
            }
        }

        //
        // Copy the string
        //
        if ( *BufferType == NetSetupUnjoined || pPolicyPDI->Name.Length == 0 )
        {
            *lpNameBuffer = NULL;
        }
        else
        {
            NetStatus = NetpDuplicateString(pPolicyPDI->Name.Buffer,
                                            pPolicyPDI->Name.Length / sizeof(WCHAR),
                                            lpNameBuffer);
        }

        LsaFreeMemory( pPolicyPDI );
        LsaFreeMemory( pPolicyDns );
    }

    return( NetStatus );
}


NET_API_STATUS
NET_API_FUNCTION
NetpDoDomainJoin(
    IN  LPWSTR      lpServer,
    IN  LPWSTR      lpDomain,
    IN  LPWSTR      lpMachineAccountOU, OPTIONAL
    IN  LPWSTR      lpAccount,
    IN  LPWSTR      lpPassword,
    IN  DWORD       fOptions
    )
/*++

Routine Description:

    Joins the machine to the domain.

Arguments:

    lpServer -- Name of the machine being run on

    lpDomain -- Domain to join

    lpMachineAccountOU -- Optional OU under which to create the machine account

    lpAccount -- Account to use for join

    lpPassword -- Password matching the account.  The password has been encoded and the
                  first WCHAR of the password buffer is the seed

    fOptions -- Options to use when joining the domain

Returns:

    NERR_Success -- Success

    ERROR_INVALID_PARAMETER --  A bad parameter was given

--*/
{
    NET_API_STATUS  NetStatus = NERR_Success;
    LPTSTR ComputerName = NULL;

    NetSetuppOpenLog();

    NetpLog(( "NetpDoDomainJoin\n" ));

    //
    // Check the parameters we can
    //
    if (lpDomain == NULL )
    {
        NetStatus = ERROR_INVALID_PARAMETER;
    }

#if(_WIN32_WINNT < 0x0500)
    if ( lpMachineAccountOU != NULL )
    {
        NetStatus = ERROR_INVALID_PARAMETER;
    }
#endif

    //
    // If we have no machine name, get the current name
    //
    if ((NetStatus == NERR_Success) && (lpServer == NULL))
    {
        NetStatus = NetpGetNewMachineName( &ComputerName );

        if ( NetStatus == NERR_Success )
        {
            lpServer = ComputerName;
        }
    }

    //
    // Then, see about the join...
    //
    if ( NetStatus == NERR_Success )
    {
        if ( FLAG_ON( fOptions, NETSETUP_JOIN_DOMAIN ) )
        {
            //
            // A domain join
            //
            NetStatus = NetpMachineValidToJoin( lpServer, TRUE );

            if ((NERR_SetupAlreadyJoined == NetStatus) &&
                (FLAG_ON(fOptions, NETSETUP_IGNORE_JOIN) ||
                 FLAG_ON(fOptions, NETSETUP_DOMAIN_JOIN_IF_JOINED)))
            {
                NetStatus = NERR_Success;
            }

            if ( NetStatus == NERR_Success )
            {
                NetStatus = NetpJoinDomain( lpServer, lpDomain, lpMachineAccountOU,
                                            lpAccount, lpPassword, fOptions );
            }

        }
        else
        {
            //
            // Doing a workgroup join
            //
            NetStatus = NetpMachineValidToJoin( lpServer, FALSE );

            if ( NetStatus == NERR_Success )
            {
                NetStatus = NetpJoinWorkgroup( lpServer, lpDomain );
            }
        }
    }

    NetApiBufferFree( ComputerName );


    NetpLog(( "NetpDoDomainJoin: status: 0x%lx\n", NetStatus ));
    NetSetuppCloseLog( );

    return( NetStatus );
}



NET_API_STATUS
NET_API_FUNCTION
NetpSetMachineAccountPassword(
    IN  LPWSTR lpDc,
    IN  LPWSTR lpDomain,
    IN  LPWSTR lpMachine,
    IN  LPWSTR lpPassword
    )
/*++

Routine Description:

    Sets the password on the machine account object

Arguments:

    lpDcName   -- Name of a DC in the domain
    lpDomain   -- Name of the domain
    lpMachine  -- Current name of the machine
    lpPassword -- Password to use for machine object.

Returns:

    NERR_Success -- Success

--*/
{
    NET_API_STATUS  NetStatus = NERR_Success;
    LPWSTR          lpMachAcc = NULL;
    USER_INFO_1     *CurrentUI1;

    //
    // Build the machine account name
    //
    NetStatus = NetpGetMachineAccountName(lpMachine, &lpMachAcc);

    //
    // Now, either create or delete it
    //
    if ( NetStatus == NERR_Success )
    {
        //
        // Get the current info
        //
        NetStatus = NetUserGetInfo( lpDc, lpMachAcc, 1, (PBYTE*) &CurrentUI1 );

        if ( NetStatus == NERR_Success )
        {
            CurrentUI1->usri1_password = lpPassword;

            //$ REVIEW  kumarp 17-May-1999
            //  why??
            //
            if (!FLAG_ON( CurrentUI1->usri1_flags, UF_WORKSTATION_TRUST_ACCOUNT))
            {
                CurrentUI1->usri1_flags = UF_WORKSTATION_TRUST_ACCOUNT | UF_SCRIPT;
            }

            NetStatus = NetUserSetInfo( lpDc, lpMachAcc, 1, (PBYTE) CurrentUI1, NULL );

            if ( NetStatus != NERR_Success )
            {
                NetpLog(( "NetpSetMachineAccountPassword: NetUserSetInfo on '%ws' '%ws' failed: 0x%lx\n", lpDc, lpMachAcc, NetStatus ));
            }

            NetApiBufferFree( CurrentUI1 );
        }
        else
        {
            NetpLog(( "NetpSetMachineAccountPassword: NetUserGetInfo on '%ws' '%ws' failed: 0x%lx\n", lpDc, lpMachAcc, NetStatus ));
        }

        NetApiBufferFree( lpMachAcc );
    }

    return( NetStatus );
}




#define COMPUTERNAME_ROOT \
    L"System\\CurrentControlSet\\Control\\ComputerName\\ComputerName"
#define NEW_COMPUTERNAME_VALUE_NAME L"ComputerName"

NET_API_STATUS
NET_API_FUNCTION
NetpGetNewMachineName(
    OUT PWSTR *NewMachineName
    )
/*++

Routine Description:

    This function reads the new Machine name parameter from the registry.
    This values is what the computer name will be after the next reboot.

    The returned buffer must be freed via NetApiBufferFree

Arguments:

    NewMachineName -- Where the new machine name is returned

Returns:

    NERR_Success -- Success
    ERROR_NOT_ENOUGH_MEMORY -- A memory allocation failed

--*/
{
    NET_API_STATUS NetStatus = NERR_Success;
    HKEY ComputerNameRootKey;
    ULONG Length = 0;

    //
    // Open the registry key
    //
    NetStatus = RegOpenKeyEx( HKEY_LOCAL_MACHINE, COMPUTERNAME_ROOT,
                              0, KEY_READ, &ComputerNameRootKey);

    if ( NetStatus == ERROR_SUCCESS )
    {
        DWORD ValueType;

        //
        // Determine the size we need
        //
        NetStatus = RegQueryValueEx( ComputerNameRootKey,
                                     NEW_COMPUTERNAME_VALUE_NAME,
                                     0, &ValueType, NULL, &Length );

        if ( NetStatus == NERR_Success )
        {
            //
            // Allocate the buffer and re-read it.
            //
            NetStatus = NetApiBufferAllocate( Length,
                                              ( LPVOID * )NewMachineName );

            if ( NetStatus == NERR_Success )
            {
                NetStatus = RegQueryValueEx( ComputerNameRootKey,
                                             NEW_COMPUTERNAME_VALUE_NAME,
                                             0, &ValueType,
                                             ( PBYTE )*NewMachineName, &Length );
            }
        }
        RegCloseKey( ComputerNameRootKey );
    }

    return( NetStatus );
}




BOOL
IsNonEmptyUnicodeStr( IN UNICODE_STRING* ps )
{
    return ps && ps->Length && ps->Buffer && *(ps->Buffer);
}

NET_API_STATUS
NET_API_FUNCTION
NetpValidateJoinStateAndActions(
    IN  NET_JOIN_STATE* pJoinState,
    IN  DWORD           dwJoinAction
    )
{
    NET_API_STATUS NetStatus = NERR_Success;
    GUID guidNull = { 0 };

    /*
    //
    // validate POLICY_DNS_DOMAIN_INFO
    //
    if (dwJoinAction & NJA_SetPolicyDomainInfo)
    {
        if (!(IsNonEmptyUnicodeStr(&pJoinState->PolicyDDI.Name) &&
              IsNonEmptyUnicodeStr(&pJoinState->PolicyDDI.DnsDomainName) &&
              IsNonEmptyUnicodeStr(&pJoinState->PolicyDDI.DnsForestName) &&
              memcmp((PVOID) &guidNull,
                     (PVOID) &pJoinState->PolicyDDI.DomainGuid,
                     sizeof(GUID)) &&
              &pJoinState->PolicyDDI.Sid))
        {
            NetStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
    }
    */

    if (dwJoinAction & NJA_SetNetlogonState)
    {
        if (!(((pJoinState->uiNetlogonStartType == NETSETUP_SVC_ENABLED) ||
               (pJoinState->uiNetlogonStartType == NETSETUP_SVC_MANUAL)) &&
              ((pJoinState->uiNetlogonState == NETSETUP_SVC_STOPPED) ||
               (pJoinState->uiNetlogonState == NETSETUP_SVC_STARTED))))
        {
            NetStatus = ERROR_INVALID_PARAMETER;
            goto Cleanup;
        }
    }


Cleanup:
    return NetStatus;
}


NET_API_STATUS
NET_API_FUNCTION
NetpApplyJoinState(
    IN  NET_JOIN_STATE* pJoinState,
    IN  DWORD           dwJoinAction,
    IN  LPWSTR          szMachineName,   OPTIONAL
    IN  LPWSTR          szUser,          OPTIONAL
    IN  LPWSTR          szUserPassword,  OPTIONAL
    IN  LPWSTR          szPreferredDc    OPTIONAL
    )
{
    NET_API_STATUS              NetStatus = NERR_Success, NetStatus2;
    NET_API_STATUS              RetStatus = NERR_Success;
    PWSTR                       szDcName = NULL;
    PPOLICY_PRIMARY_DOMAIN_INFO pDcPolicyPDI = NULL, pLocalPolicyPDI = NULL;
    PPOLICY_DNS_DOMAIN_INFO     pDcPolicyDns = NULL, pLocalPolicyDns = NULL;
    BOOL                        fIpcConnected = FALSE;
    LSA_HANDLE                  hLsaLocal = NULL, hLsaDc = NULL;
    WCHAR                       szMachinePasswordBuf[ PWLEN + 1];
    ULONG                       ulIpcConnectFlags = NETSETUPP_CONNECT_IPC;
    ULONG                       ulDcFlags=0, ulGetDcFlags = 0;
    UNICODE_STRING              sUserPassword;
    UCHAR                       Seed;
    BOOL                        fIsNt4Dc=FALSE;
    BOOL                        fRandomPwdPreferred=TRUE;
    PDOMAIN_CONTROLLER_INFO     pDcInfo = NULL;
    PWSTR                       szDnsDomainName=NULL;
    NET_JOIN_STATE              RollbackState = { 0 };
    DWORD                       dwRollbackAction=0;
    BOOL                        fIgnoreErrors=FALSE;

    BOOL                        fSaveRollbackInfo=FALSE;
    PWSTR                       szCurrentMachinePassword = NULL;

    fIgnoreErrors = FLAG_ON ( dwJoinAction, NJA_IgnoreErrors );
    fSaveRollbackInfo = FLAG_ON ( dwJoinAction, NJA_RollbackOnFailure );

    NetpLog(( "NetpApplyJoinState: actions: 0x%lx\n", dwJoinAction ));

    if ( szUserPassword )
    {
        if ( wcslen( szUserPassword ) < 1 )
        {
            return ERROR_INVALID_PARAMETER;
        }
        Seed = ( UCHAR )*szUserPassword;
        RtlInitUnicodeString( &sUserPassword, szUserPassword + 1 );
    }
    else
    {
        RtlZeroMemory( &sUserPassword, sizeof( UNICODE_STRING ) );
        Seed = 0;
    }

    NetStatus = NetpValidateJoinStateAndActions(pJoinState, dwJoinAction);

    if ( NetStatus != NERR_Success )
    {
        return NetStatus;
    }

    //
    // connect to the DC only if required by at least on action
    //
    if ( FLAG_ON( dwJoinAction, NJA_NeedDc ) )
    {
        ulGetDcFlags = FLAG_ON( dwJoinAction, NJA_CreateAccount ) ?
        NETSETUPP_DSGETDC_FLAGS : NETSETUP_DSGETDC_FLAGS_ACCOUNT_EXISTS;

        //
        // Find a DC in the domain using these steps:
        // - find a writable dc that has this machine account
        // - if we cannot find such dc, find any writable dc
        //
        NetStatus = NetpDsGetDcName( szPreferredDc,
                                     (LPWSTR) pJoinState->szDomainName,
                                     szMachineName, ulGetDcFlags,
                                     &ulDcFlags, &szDcName, &pDcInfo );

        //
        // First establish connection with the dc we found
        //
        if ( NetStatus == NERR_Success )
        {
            fIsNt4Dc = !FLAG_ON( ulDcFlags, DS_DS_FLAG);

            if ( !FLAG_ON( dwJoinAction, NJA_CreateAccount ) )
            {
                ulIpcConnectFlags |= NETSETUPP_NULL_SESSION_IPC;
            }

            RtlRunDecodeUnicodeString( Seed, &sUserPassword );
            NetStatus = NetpManageIPCConnect( szDcName,
                                              szUser, sUserPassword.Buffer,
                                              ulIpcConnectFlags );
            RtlRunEncodeUnicodeString( &Seed, &sUserPassword );
            if ( NetStatus == NERR_Success )
            {
                fIpcConnected = TRUE;
            }
            NetpLog(( "NetpApplyJoinState: status of connecting to dc '%ws': 0x%lx\n", szDcName, NetStatus ));
        }
    }

    if (NetStatus != NERR_Success)
    {
        RetStatus = NetStatus;
    }

    //
    // stop netlogon service if specified
    //
    if ( FLAG_ON ( dwJoinAction, NJA_SetNetlogonState ) &&
         ( pJoinState->uiNetlogonState == NETSETUP_SVC_STOPPED ) &&
         ( fIgnoreErrors || ( NetStatus == NERR_Success ) ) )
    {
        NetStatus = NetpControlServices( pJoinState->uiNetlogonStartType |
                                         NETSETUP_SVC_STOPPED,
                                         NETSETUPP_SVC_NETLOGON );

        if (fSaveRollbackInfo && (NetStatus == NERR_Success))
        {
            RollbackState.uiNetlogonState     = NETSETUP_SVC_STARTED;
            RollbackState.uiNetlogonStartType = NETSETUP_SVC_ENABLED;
            dwRollbackAction |= NJA_SetNetlogonState;
        }

        NetpLog(( "NetpApplyJoinState: status of stopping and setting start type of Netlogon to %ld: 0x%lx\n", pJoinState->uiNetlogonStartType, NetStatus ));
    }

    if (NetStatus != NERR_Success)
    {
        RetStatus = NetStatus;
    }

    //
    // config w32time service if specified
    //
    if ( FLAG_ON ( dwJoinAction, NJA_SetTimeSvcJoin ) &&
         ( fIgnoreErrors || ( NetStatus == NERR_Success ) ) )
    {
        NetStatus = NetpUpdateW32timeConfig( "W32TimeVerifyJoinConfig" );

        if (fSaveRollbackInfo && (NetStatus == NERR_Success))
        {
            dwRollbackAction |= NJA_SetTimeSvcUnjoin;
        }
    }

    if (NetStatus != NERR_Success)
    {
        RetStatus = NetStatus;
    }

    if (fIgnoreErrors || (NetStatus == NERR_Success))
    {
        //
        // read our old primary domain info
        //
        NetStatus = NetpGetLsaPrimaryDomain( NULL, NULL,
                                             &pLocalPolicyPDI,
                                             &pLocalPolicyDns,
                                             &hLsaLocal );
        if (fSaveRollbackInfo && (NetStatus == NERR_Success))
        {
            RollbackState.pPolicyPDI = pLocalPolicyPDI;
            RollbackState.pPolicyDDI = pLocalPolicyDns;
        }
    }

    if (NetStatus != NERR_Success)
    {
        RetStatus = NetStatus;
    }

    if ( FLAG_ON ( dwJoinAction, NJA_GetPolicyDomainInfo ) && fIpcConnected &&
         (fIgnoreErrors || (NetStatus == NERR_Success)))
    {
        //
        // get the lsa domain info on the DC
        //
        NetStatus = NetpGetLsaPrimaryDomain(NULL, szDcName, &pDcPolicyPDI,
                                            &pDcPolicyDns, &hLsaDc);
        if (NetStatus == NERR_Success)
        {
            pJoinState->pPolicyPDI = pDcPolicyPDI;
            pJoinState->pPolicyDDI = pDcPolicyDns;
        }
    }

    if (NetStatus != NERR_Success)
    {
        RetStatus = NetStatus;
    }

    if ((fIgnoreErrors || (NetStatus == NERR_Success)) &&
        pJoinState->pPolicyDDI &&
        pJoinState->pPolicyDDI->DnsDomainName.Buffer)
    {
        //
        // make a copy of of DnsDomainName in the form of sz
        //
        NetStatus = NetpDuplicateString(
            pJoinState->pPolicyDDI->DnsDomainName.Buffer,
            pJoinState->pPolicyDDI->DnsDomainName.Length / sizeof(WCHAR),
            &szDnsDomainName);
    }

    if (NetStatus != NERR_Success)
    {
        RetStatus = NetStatus;
    }

    if ( FLAG_ON ( dwJoinAction, NJA_GenMachinePassword ) &&
         ( fIgnoreErrors || ( NetStatus == NERR_Success ) ) )
    {
        fRandomPwdPreferred = FLAG_ON ( dwJoinAction, NJA_RandomPwdPreferred );

        //
        // Generate the password to use on the machine account.
        // This can either be the default password
        // (the 1st 14 characters of the machine name, lower cased),
        // or a randomly generated password.
        //
        NetStatus = NetpGeneratePassword( szMachineName,
                                          fRandomPwdPreferred,
                                          szDcName, fIsNt4Dc,
                                          szMachinePasswordBuf );
        if (NetStatus == NERR_Success)
        {
            pJoinState->szMachinePassword = szMachinePasswordBuf;
        }
    }

    if (NetStatus != NERR_Success)
    {
        RetStatus = NetStatus;
    }

    if (fSaveRollbackInfo && (NetStatus == NERR_Success) &&
        FLAG_ON (dwJoinAction, (NJA_SetMachinePassword |
                                NJA_DeleteMachinePassword)))
    {
        NetStatus = NetpReadCurrentSecret( NULL, &szCurrentMachinePassword,
                                           &hLsaLocal );
        if (NetStatus == NERR_Success)
        {
            RollbackState.szMachinePassword = szCurrentMachinePassword;
        }
        else if (NetStatus == ERROR_FILE_NOT_FOUND)
        {
            NetpLog(( "NetpApplyJoinState: machine secret not found. join state seems to be inconsistent. this case is correctly handled by the code.\n" ));
            dwRollbackAction |=
              NJA_GenMachinePassword | NJA_RandomPwdPreferred;
            NetStatus = NERR_Success;
        }
    }

    if (NetStatus != NERR_Success)
    {
        RetStatus = NetStatus;
    }

    //
    // set the local machine secret, create if not already present
    //
    if ( FLAG_ON ( dwJoinAction, NJA_SetMachinePassword ) &&
         ( fIgnoreErrors || ( NetStatus == NERR_Success ) ) )
    {
        // this also opens the local LSA policy handle
        NetStatus = NetpManageMachineSecret(
            NULL, szMachineName,
            (LPWSTR) pJoinState->szMachinePassword,
            NETSETUPP_CREATE, FALSE, &hLsaLocal );
        if (fSaveRollbackInfo && (NetStatus == NERR_Success))
        {
            dwRollbackAction |= NJA_SetMachinePassword;
        }
    }

    if (NetStatus != NERR_Success)
    {
        RetStatus = NetStatus;
    }

    //
    // delete the local machine secret
    //
    if ( FLAG_ON ( dwJoinAction, NJA_DeleteMachinePassword ) &&
         ( fIgnoreErrors || ( NetStatus == NERR_Success ) ) )
    {
        // this also opens the local LSA policy handle
        NetStatus = NetpManageMachineSecret(
            NULL, szMachineName,
            (LPWSTR) pJoinState->szMachinePassword,
            NETSETUPP_DELETE, FALSE, &hLsaLocal );
        if (fSaveRollbackInfo && (NetStatus == NERR_Success))
        {
            dwRollbackAction |= NJA_SetMachinePassword;
        }
    }

    if (NetStatus != NERR_Success)
    {
        RetStatus = NetStatus;
    }

    //
    // kahrent 10-09-99 (adding comment)
    //
    // After this point we will be doing changes on the DC.
    // However, if we are not successful at this point, fail
    // over and rollback all the changes we've done locally.
    //
    if ((NetStatus != NERR_Success) && !fIgnoreErrors)
    {
        goto Cleanup;
    }

    //
    // create the machine account on the dc if specified
    //
    if ( FLAG_ON ( dwJoinAction, NJA_CreateAccount ) )
    {
        NetStatus = NetpManageMachineAccountWithSid(
            szMachineName, NULL, szDcName,
            (LPWSTR) pJoinState->szMachinePassword,
            pJoinState->pPolicyPDI->Sid, NETSETUPP_CREATE, 0, fIsNt4Dc );
        NetpLog(( "NetpApplyJoinState: status of creating account: 0x%lx\n", NetStatus ));

        if (fSaveRollbackInfo && (NetStatus == NERR_Success))
        {
            dwRollbackAction |= NJA_DeleteAccount;
        }
    }
    else if ( FLAG_ON ( dwJoinAction, NJA_DeleteAccount ) )
    {
        //
        // delete the machine account on the dc if specified
        //

        if (fIsNt4Dc)
        {
            NetpLog(( "NetpApplyJoinState: account not disabled since we are talking to NT4 dc\n" ));
        }
        else
        {
            NetStatus = NetpManageMachineAccountWithSid(
                szMachineName, NULL, szDcName,
                (LPWSTR) pJoinState->szMachinePassword,
                pLocalPolicyPDI->Sid, NETSETUPP_DELETE, 0, fIsNt4Dc );
            NetpLog(( "NetpApplyJoinState: status of disabling account: 0x%lx\n", NetStatus ));
            if (fSaveRollbackInfo && (NetStatus == NERR_Success))
            {
                dwRollbackAction |= NJA_CreateAccount;
            }
        }
    }

    if (NetStatus != NERR_Success)
    {
        RetStatus = NetStatus;
    }

    if ( FLAG_ON ( dwJoinAction, NJA_ValidateMachineAccount ) && fIpcConnected &&
         (fIgnoreErrors || (NetStatus == NERR_Success)))
    {
        NetStatus = NetpValidateMachineAccount(
            szDcName, (LPWSTR) pJoinState->szDomainName,
            szMachineName, (LPWSTR) pJoinState->szMachinePassword );
        NetpLog(( "NetpApplyJoinState: w9x: status of validating account: 0x%lx\n", NetStatus ));
    }

    if (NetStatus != NERR_Success)
    {
        RetStatus = NetStatus;
    }

    if ( FLAG_ON ( dwJoinAction, NJA_SetMachinePassword ) && fIpcConnected &&
         (fIgnoreErrors || (NetStatus == NERR_Success)))
    {
        NetStatus = NetpSetMachineAccountPassword(
            szDcName, (LPWSTR) pJoinState->szDomainName,
            szMachineName, (LPWSTR) pJoinState->szMachinePassword );
        NetpLog(( "NetpApplyJoinState: status of setting machine password: 0x%lx\n", NetStatus ));
    }

    if (NetStatus != NERR_Success)
    {
        RetStatus = NetStatus;
    }

    if ( FLAG_ON ( dwJoinAction, NJA_UpdateNetlogonCache ) && fIpcConnected &&
         (fIgnoreErrors || (NetStatus == NERR_Success)))
    {
        NetStatus = NetpSetNetlogonDomainCache( szDcName );
        NetpLog(( "NetpApplyJoinState: status of setting netlogon cache: 0x%lx\n", NetStatus ));
    }

    if (NetStatus != NERR_Success)
    {
        RetStatus = NetStatus;
    }

    //
    // Set the primary domain info from the Dc to the client
    //
    if ( FLAG_ON ( dwJoinAction, NJA_SetPolicyDomainInfo ) &&
         pJoinState->pPolicyPDI &&
         ( fIgnoreErrors || ( NetStatus == NERR_Success ) ) )
    {
        NetStatus = NetpSetLsaPrimaryDomain(hLsaLocal,
                                            pJoinState->pPolicyPDI->Name.Buffer,
                                            pJoinState->pPolicyPDI->Sid,
                                            pJoinState->pPolicyDDI,
                                            NULL);
        NetpLog(( "NetpApplyJoinState: status of setting LSA pri. domain: 0x%lx\n", NetStatus ));

        if (fSaveRollbackInfo && (NetStatus == NERR_Success))
        {
            dwRollbackAction |= NJA_SetPolicyDomainInfo;
        }
    }

    //
    // Set the new DNS computer name, as needed
    //
    if ( FLAG_ON(dwJoinAction, NJA_SetPolicyDomainInfo) &&
         (fIgnoreErrors || (NetStatus == NERR_Success)) ) {

        //
        // If we have a new name, set it if it's different from the old one
        //
        if ( pJoinState->pPolicyDDI != NULL ) {

            if ( pLocalPolicyDns == NULL ||
                 RtlCompareUnicodeString( &pLocalPolicyDns->DnsDomainName,
                                          &pJoinState->pPolicyDDI->DnsDomainName,
                                          TRUE ) != 0 ) {

                NetStatus = NetpSetDnsComputerNameAsRequired( pJoinState->pPolicyDDI->DnsDomainName.Buffer );
                NetpLog(( "NetpApplyJoinState: status of setting ComputerNamePhysicalDnsDomain to '%wZ': 0x%lx\n",
                          &pJoinState->pPolicyDDI->DnsDomainName,
                          NetStatus ));
            }

        //
        // If we don't have a new name (must be an NT4 domain/DC),
        // clear the old name, if any.
        //
        // Note, if this is an NT5 domain but we simply don't have
        //  an NT5 DC at this time, netlogon will eventually discover
        //  an NT5 DC and netlogon will set the new name then.
        //
        } else if ( pLocalPolicyDns != NULL ) {

            NetStatus = NetpSetDnsComputerNameAsRequired( L"\0" );
            NetpLog(( "NetpApplyJoinState: status of clearing ComputerNamePhysicalDnsDomain: 0x%lx\n",
                      NetStatus ));
        }
    }

    if (NetStatus != NERR_Success)
    {
        RetStatus = NetStatus;
    }

    //
    // add to local group memberships
    //
    if ( FLAG_ON ( dwJoinAction, NJA_AddToLocalGroups ) &&
         ( fIgnoreErrors || ( NetStatus == NERR_Success ) ) )
    {
        NetStatus = NetpManageLocalGroups( pJoinState->pPolicyPDI->Sid, NETSETUPP_CREATE );
        if (fSaveRollbackInfo && (NetStatus == NERR_Success))
        {
            dwRollbackAction |= NJA_RemoveFromLocalGroups;
        }

        NetpLog(( "NetpApplyJoinState: status of adding to local groups: 0x%lx\n", NetStatus ));
    }

    if (NetStatus != NERR_Success)
    {
        RetStatus = NetStatus;
    }

    //
    // remove from our local group memberships
    //
    if ( FLAG_ON ( dwJoinAction, NJA_RemoveFromLocalGroups ) &&
         ( fIgnoreErrors || ( NetStatus == NERR_Success ) ) )
    {
        NetStatus = NetpManageLocalGroups( pLocalPolicyPDI->Sid, NETSETUPP_DELETE );
        if (fSaveRollbackInfo && (NetStatus == NERR_Success))
        {
            dwRollbackAction |= NJA_AddToLocalGroups;
        }

        NetpLog(( "NetpApplyJoinState: status of removing from local groups: 0x%lx\n", NetStatus ));
    }

    if (NetStatus != NERR_Success)
    {
        RetStatus = NetStatus;
    }

    //
    // start netlogon service if specified
    //
    if ( FLAG_ON ( dwJoinAction, NJA_SetNetlogonState ) &&
         ( pJoinState->uiNetlogonState == NETSETUP_SVC_STARTED ) &&
         ( fIgnoreErrors || ( NetStatus == NERR_Success ) ) )
    {
        NetStatus = NetpControlServices( pJoinState->uiNetlogonStartType |
                                         NETSETUP_SVC_STARTED,
                                         NETSETUPP_SVC_NETLOGON );

        if (fSaveRollbackInfo && (NetStatus == NERR_Success))
        {
            RollbackState.uiNetlogonState     = NETSETUP_SVC_STOPPED;
            RollbackState.uiNetlogonStartType = NETSETUP_SVC_MANUAL;
            dwRollbackAction |= NJA_SetNetlogonState;
        }
        NetpLog(( "NetpApplyJoinState: status of starting and setting start type of Netlogon to %ld: 0x%lx\n", pJoinState->uiNetlogonStartType, NetStatus ));
    }

    if (NetStatus != NERR_Success)
    {
        RetStatus = NetStatus;
    }

    //
    // config w32time service if specified
    //
    if ( FLAG_ON ( dwJoinAction, NJA_SetTimeSvcUnjoin ) &&
         ( fIgnoreErrors || ( NetStatus == NERR_Success ) ) )
    {
        NetStatus = NetpUpdateW32timeConfig( "W32TimeVerifyUnjoinConfig" );

        if (fSaveRollbackInfo && (NetStatus == NERR_Success))
        {
            dwRollbackAction |= NJA_SetTimeSvcJoin;
        }
    }

    //
    // Config AutoEnrol service if specified.
    //
    // On join, do this after enabling the account in
    //  the DS because Autoenrol needs the account
    //  enabled to have the DS access. Also, do this
    //  after deleting the local secret to ensure we
    //  are running as local admin.
    //
    if ( FLAG_ON ( dwJoinAction, NJA_SetAutoenrolSvcJoin ) &&
         ( fIgnoreErrors || ( NetStatus == NERR_Success ) ) )
    {
        //
        // Ignore the failure since it's not critical
        //  but remember if we need to do anything on rollback
        //
        NET_API_STATUS TmpNetStatus = NetpUpdateAutoenrolConfig( FALSE );

        if (fSaveRollbackInfo && (TmpNetStatus == NERR_Success))
        {
            dwRollbackAction |= NJA_SetAutoenrolSvcUnjoin;
        }
    }

    if ( FLAG_ON ( dwJoinAction, NJA_SetAutoenrolSvcUnjoin ) &&
         ( fIgnoreErrors || ( NetStatus == NERR_Success ) ) )
    {
        //
        // Ignore the failure since it's not critical
        //  but remember if we need to do anything on rollback
        //
        NET_API_STATUS TmpNetStatus = NetpUpdateAutoenrolConfig( TRUE );

        if (fSaveRollbackInfo && (TmpNetStatus == NERR_Success))
        {
            dwRollbackAction |= NJA_SetAutoenrolSvcJoin;
        }
    }

    if (NetStatus != NERR_Success)
    {
        RetStatus = NetStatus;
    }

    //
    // Save off the name of the initial domain controller we contacted
    // if we successfully joined the domain
    //
    if ( FLAG_ON ( dwJoinAction, NJA_RecordDcInfo ) && fIpcConnected &&
         (fIgnoreErrors || (NetStatus == NERR_Success)))
    {
        //
        // A failure here is NON-FATAL, so we ignore the error code
        //
        NetStatus2 = NetpStoreIntialDcRecord( pDcInfo );

        if ( NetStatus2 != NERR_Success )
        {
            NetpLog(( "NetpApplyJoinState: NON FATAL: failed to store the initial Dc record for '%ws': 0x%lx\n", szDcName, NetStatus ));
        }
    }

    if (NetStatus != NERR_Success)
    {
        RetStatus = NetStatus;
    }

    //
    // Remove DNS registrations
    //
    if ( FLAG_ON ( dwJoinAction, NJA_RemoveDnsRegistrations ) &&
         ( fIgnoreErrors || ( NetStatus == NERR_Success ) ) )
    {
        NetStatus2 = NetpRemoveDnsRegistrations();
        NetpLog(( "NetpApplyJoinState: NON FATAL: status of removing DNS registrations: 0x%lx\n", NetStatus2 ));
    }


Cleanup:

    if (fSaveRollbackInfo && (NetStatus != NERR_Success))
    {
        // time to rollback. ignore all errors during rollback
        NetpLog(( "NetpApplyJoinState: initiating a rollback due to earlier errors\n"));
        dwRollbackAction |= NJA_IgnoreErrors;
        NetStatus2 = NetpApplyJoinState(&RollbackState, dwRollbackAction,
                                        szMachineName, szUser, szUserPassword,
                                        szDcName ? szDcName : szPreferredDc);
    }

    LsaFreeMemory( pDcPolicyPDI );
    LsaFreeMemory( pDcPolicyDns );
    LsaFreeMemory( pLocalPolicyPDI );
    LsaFreeMemory( pLocalPolicyDns );

    if ( hLsaLocal != NULL )
    {
        LsaClose( hLsaLocal );
    }

    if ( hLsaDc != NULL )
    {
        LsaClose( hLsaDc );
    }

    //
    // Now, we'll no longer need our session to our dc
    //
    if ( fIpcConnected )
    {
        RtlRunDecodeUnicodeString( Seed, &sUserPassword );
        NetStatus2 = NetpManageIPCConnect( szDcName, szUser,
                                           sUserPassword.Buffer,
                                           NETSETUPP_DISCONNECT_IPC );
        RtlRunEncodeUnicodeString( &Seed, &sUserPassword );
        NetpLog(( "NetpApplyJoinState: status of disconnecting from '%ws': 0x%lx\n", szDcName, NetStatus2));
    }

    // Note: NetApiBufferFree checks for NULL
    NetApiBufferFree( pDcInfo );
    NetApiBufferFree( szDcName );
    NetApiBufferFree( szDnsDomainName );
    NetApiBufferFree( szCurrentMachinePassword );

    if (RetStatus != NERR_Success)
    {
        NetStatus = RetStatus;
    }

    return( NetStatus );
}

NET_API_STATUS
NET_API_FUNCTION
NetpForceMachinePasswordChange(
    IN LPWSTR szDomainName
    )
{
    NET_API_STATUS NetStatus = NERR_Success;
    LPBYTE pNetlogonInfo=NULL;

    NetpLog(( "NetpForceMachinePasswordChange: on '%ws'\n",
              GetStrPtr(szDomainName)));

    NetStatus = I_NetLogonControl2( NULL,
                                    NETLOGON_CONTROL_CHANGE_PASSWORD,
                                    1, (LPBYTE) &szDomainName,
                                    (LPBYTE *) &pNetlogonInfo );
    if (NetStatus == NERR_Success)
    {
        NetApiBufferFree(pNetlogonInfo);
    }

    NetpLog(( "NetpForceMachinePasswordChange: status: 0x%lx\n", NetStatus));

    return NetStatus;
}


NET_API_STATUS
NET_API_FUNCTION
NetpUpgradePreNT5JoinInfo( VOID )
{
    NET_API_STATUS NetStatus =NERR_Success;
    WCHAR  szMachineNameBuf[MAX_COMPUTERNAME_LENGTH + 1];
    LPWSTR szMachineName=szMachineNameBuf;
    LPWSTR szDomainName=NULL;
    NETSETUP_JOIN_STATUS JoinStatus;
    NET_JOIN_STATE JoinState = { 0 };
    DWORD dwJoinAction=0;

    NetSetuppOpenLog();
    NetpLog(( "NetpUpgradePreNT5JoinInfo: upgrading join info\n" ));
    //
    // make sure we are joined to a domain
    //
    NetStatus = NetpGetJoinInformation(NULL, &szDomainName, &JoinStatus);
    if (NetStatus == NERR_Success)
    {
        if (JoinStatus == NetSetupDomainName)
        {
            //
            // get the computer name
            //
            NetStatus = NetpGetComputerNameAllocIfReqd(
                &szMachineName, MAX_COMPUTERNAME_LENGTH+1);
            NetpLog(( "NetpUpgradePreNT5JoinInfo: status of getting computer name: 0x%lx\n", NetStatus ));
        }
        else
        {
            //
            // machine is not joined to a domain,
            // no need to upgrade anything
            //
            NetStatus = NERR_SetupNotJoined;
            goto Cleanup;
        }
    }

    if (NetStatus == NERR_Success)
    {
        NetpLog(( "NetpUpgradePreNT5JoinInfo: upgrading join info for '%ws' in domain '%ws'\n",  szMachineName, szDomainName));

        dwJoinAction =
            NJA_UpdateNetlogonCache    |
            NJA_GetPolicyDomainInfo    |
            NJA_SetPolicyDomainInfo    |
            NJA_SetNetlogonState       |
            NJA_RecordDcInfo           |
            NJA_IgnoreErrors;

        JoinState.szDomainName        = szDomainName;
        JoinState.uiNetlogonStartType = NETSETUP_SVC_ENABLED;
        JoinState.uiNetlogonState     = NETSETUP_SVC_STARTED;

        NetStatus = NetpApplyJoinState(&JoinState, dwJoinAction,
                                       szMachineName, NULL, NULL, NULL);
        NetpLog(( "NetpUpgradePreNT5JoinInfo: status of NetpApplyJoinState: 0x%lx\n", NetStatus ));

        //
        // ignore earlier error, if any, and try to reset password
        //
        NetStatus = NetpWaitForNetlogonSc(szDomainName);
        if (NetStatus == NERR_Success)
        {
            NetStatus = NetpForceMachinePasswordChange( szDomainName );
        }
        else
        {
            NetpLog(( "NetpUpgradePreNT5JoinInfo: netlogon did not establish secure channel, machine password not updated. This is not a fatal error. netlogon will retry updating the password later.\n" ));
        }
    }


Cleanup:
    NetApiBufferFree(szDomainName);
    if (szMachineName != szMachineNameBuf)
    {
        NetApiBufferFree(szMachineName);
    }

    NetpLog(( "NetpUpgradePreNT5JoinInfo: status: 0x%lx\n", NetStatus ));

    NetSetuppCloseLog( );

    return NetStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\names.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    Names.c

Abstract:

    This module contains routines for dealing with network-related names.

Author:

    John Rogers (JohnRo) 25-Feb-1991

Environment:

    Portable to more or less any environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions:
        slash-slash comments
        long external names
        _stricmp(), _strnicmp()

Revision History:

    25-Feb-1991 JohnRo
        Created
    15-Mar-1991 JohnRo
        Fixed bug in NetpIsRemoteNameValid().  Some minor style changes.
    20-Mar-1991 RitaW
        Added NetpCanonRemoteName().
    09-Apr-1991 JohnRo
        ANSI-ize (use _stricmp instead of _stricmp).  Deleted tabs.
    19-Aug-1991 JohnRo
        Allow UNICODE use.
    30-Sep-1991 JohnRo
        More work toward UNICODE.
    20-Oct-1992 JohnRo
        RAID 9020: setup: PortUas fails ("prompt on conflicts" version).
        Do full syntax checks on computer name.
    26-Jan-1993 JohnRo
        RAID 8683: PortUAS should set primary group from Mac parms.
        Made changes suggested by PC-LINT 5.0
    08-Feb-1993 JohnRo
        RAID 10299: portuas: generate assert in netlib/names.c
    15-Apr-1993 JohnRo
        RAID 6167: avoid _access violation or assert with WFW print server.

--*/


// These must be included first:

#include <windows.h>    // IN, OUT, OPTIONAL, LPTSTR, etc.
#include <lmcons.h>     // NET_API_STATUS, CNLEN, RMLEN, etc.

// These may be included in any order:

#include <debuglib.h>   // IF_DEBUG().
#include <icanon.h>     // ITYPE_ equates, NetpNameCanonicalize(), etc.
#include <names.h>      // My prototypes, etc.
#include <netdebug.h>   // NetpKdPrint(()).
#include <prefix.h>     // PREFIX_ equates.
#include <tstring.h>    // ISALPHA(), NetpAlloc routines, TCHAR_EOS, etc.
#include <winerror.h>   // NO_ERROR.


//
// Canon routines don't have a print Q support, so we (like everyone else)
// have to treat them as share names.
//
#if (QNLEN != NNLEN)
# error QNLEN and NNLEN are not equal
#endif

#ifndef NAMETYPE_PRINTQ
#define NAMETYPE_PRINTQ NAMETYPE_SHARE
#endif



// This extracts a group name from "mGroup:" format.
// Note that other chars may appear after the colon; they are ignored.
NET_API_STATUS
NetpGetPrimaryGroupFromMacField(
    IN  LPCTSTR   MacPrimaryField,      // name in "mGroup:" format.
    OUT LPCTSTR * GroupNamePtr          // alloc and set ptr.
    )
{
    LPTSTR ColonPtr;
    DWORD  GroupLen;                    // Length of group (in characters).
    TCHAR  GroupName[LM20_GNLEN+1];
    LPTSTR GroupNameCopy;
    DWORD  StringLen;

    // Avoid confusing caller's cleanup code.
    if (GroupNamePtr == NULL) {
        return (ERROR_INVALID_PARAMETER);
    }
    *GroupNamePtr = NULL;

    // Check for other caller errors.
    if (MacPrimaryField==NULL) {
        return (ERROR_INVALID_PARAMETER);    // Empty field is not valid.
    } else if ( (*MacPrimaryField) != TEXT('m') ) {
        return (ERROR_INVALID_PARAMETER);    // Must start with lower case 'm'.
    }

    StringLen = STRLEN( MacPrimaryField );
    if (StringLen <= 2) {  // Must be room for 'm', group, ':' (at least 3).
        return (ERROR_INVALID_PARAMETER);
    }

    ColonPtr = STRCHR( MacPrimaryField, TCHAR_COLON );
    if (ColonPtr == NULL) {
        return (ERROR_INVALID_PARAMETER);    // No, not valid (must have colon).
    }

    // Compute group length in characters, without 'm' or ':'.
    GroupLen = (DWORD) ((ColonPtr - MacPrimaryField) - 1);
    if (GroupLen == 0) {
        return (ERROR_INVALID_PARAMETER);    // No, not valid (missing group).
    }
    if (GroupLen > LM20_GNLEN) {
        return (ERROR_INVALID_PARAMETER);    // No, not valid (too long).
    }

    (VOID) STRNCPY(
            GroupName,                  // dest
            &MacPrimaryField[1],        // src (after 'm')
            GroupLen );                 // char count
    GroupName[ GroupLen ] = TCHAR_EOS;

    if ( !NetpIsGroupNameValid( GroupName ) ) {
        return (ERROR_INVALID_PARAMETER);
    }

    GroupNameCopy = NetpAllocWStrFromWStr( GroupName );
    if (GroupNameCopy == NULL) {
        return (ERROR_NOT_ENOUGH_MEMORY);
    }

    *GroupNamePtr = GroupNameCopy;
    return (NO_ERROR);

} // NetpGetPrimaryGroupFromMacField



BOOL
NetpIsComputerNameValid(
    IN LPTSTR ComputerName
    )

/*++

Routine Description:

    NetpIsComputerNameValid checks for "server" (not "\\server") format.
    The name is only checked syntactically; no attempt is made to determine
    whether or not a server with that name actually exists.

Arguments:

    ComputerName - Supplies an alleged computer (server) name.

Return Value:

    BOOL - TRUE if name is syntactically valid, FALSE otherwise.

--*/

{
    NET_API_STATUS ApiStatus;
    TCHAR CanonBuf[MAX_PATH];

    if (ComputerName == (LPTSTR) NULL) {
        return (FALSE);
    }
    if ( (*ComputerName) == TCHAR_EOS ) {
        return (FALSE);
    }

    ApiStatus = NetpNameCanonicalize(
            NULL,                       // no server name
            ComputerName,               // name to validate
            CanonBuf,                   // output buffer
            sizeof( CanonBuf ),         // output buffer size
            NAMETYPE_COMPUTER,          // type
            0 );                        // flags: none

    IF_DEBUG( NAMES ) {
        if (ApiStatus != NO_ERROR) {
            NetpKdPrint(( PREFIX_NETLIB
                    "NetpIsComputerNameValid: err " FORMAT_API_STATUS
                    " after canon of '" FORMAT_LPTSTR "'.\n",
                    ApiStatus, ComputerName ));
        }
    }

    return (ApiStatus == NO_ERROR);

} // NetpIsComputerNameValid



BOOL
NetpIsDomainNameValid(
    IN LPTSTR DomainName
    )

/*++

Routine Description:

    NetpIsDomainNameValid checks for "domain" format.
    The name is only checked syntactically; no attempt is made to determine
    whether or not a domain with that name actually exists.

Arguments:

    DomainName - Supplies an alleged Domain name.

Return Value:

    BOOL - TRUE if name is syntactically valid, FALSE otherwise.

--*/

{
    NET_API_STATUS ApiStatus;
    TCHAR CanonBuf[DNLEN+1];

    if (DomainName == (LPTSTR) NULL) {
        return (FALSE);
    }
    if ( (*DomainName) == TCHAR_EOS ) {
        return (FALSE);
    }

    ApiStatus = NetpNameCanonicalize(
            NULL,                       // no server name
            DomainName,                 // name to validate
            CanonBuf,                   // output buffer
            (DNLEN+1) * sizeof(TCHAR), // output buffer size
            NAMETYPE_DOMAIN,           // type
            0 );                       // flags: none

    IF_DEBUG( NAMES ) {
        if (ApiStatus != NO_ERROR) {
            NetpKdPrint(( PREFIX_NETLIB
                    "NetpIsDomainNameValid: err " FORMAT_API_STATUS
                    " after canon of '" FORMAT_LPTSTR "'.\n",
                    ApiStatus, DomainName ));
        }
    }

    return (ApiStatus == NO_ERROR);

} // NetpIsDomainNameValid



BOOL
NetpIsShareNameValid(
    IN LPTSTR ShareName
    )

/*++

Routine Description:

    NetpIsShareNameValid checks for "share" format.
    The name is only checked syntactically; no attempt is made to determine
    whether or not a share with that name actually exists.

Arguments:

    ShareName - Supplies an alleged Share name.

Return Value:

    BOOL - TRUE if name is syntactically valid, FALSE otherwise.

--*/

{
    NET_API_STATUS ApiStatus;
    TCHAR CanonBuf[SNLEN+1];

    if (ShareName == (LPTSTR) NULL) {
        return (FALSE);
    }
    if ( (*ShareName) == TCHAR_EOS ) {
        return (FALSE);
    }

    ApiStatus = NetpNameCanonicalize(
            NULL,                      // no server name
            ShareName,                 // name to validate
            CanonBuf,                  // output buffer
            (SNLEN+1) * sizeof(TCHAR), // output buffer size
            NAMETYPE_SHARE,            // type
            0 );                       // flags: none

    IF_DEBUG( NAMES ) {
        if (ApiStatus != NO_ERROR) {
            NetpKdPrint(( PREFIX_NETLIB
                    "NetpIsShareNameValid: err " FORMAT_API_STATUS
                    " after canon of '" FORMAT_LPTSTR "'.\n",
                    ApiStatus, ShareName ));
        }
    }

    return (ApiStatus == NO_ERROR);

} // NetpIsShareNameValid


BOOL
NetpIsGroupNameValid(
    IN LPTSTR GroupName
    )
{
    NET_API_STATUS ApiStatus;
    TCHAR CanonBuf[UNLEN+1];

    if (GroupName == (LPTSTR) NULL) {
        return (FALSE);
    }
    if ( (*GroupName) == TCHAR_EOS ) {
        return (FALSE);
    }

    ApiStatus = NetpNameCanonicalize(
            NULL,                       // no server name
            GroupName,                  // name to validate
            CanonBuf,                   // output buffer
            (UNLEN+1) * sizeof(TCHAR),  // output buffer size
            NAMETYPE_GROUP,             // type
            0 );                        // flags: none

    IF_DEBUG( NAMES ) {
        if (ApiStatus != NO_ERROR) {
            NetpKdPrint(( PREFIX_NETLIB
                    "NetpIsGroupNameValid: err " FORMAT_API_STATUS
                    " after canon of '" FORMAT_LPTSTR "'.\n",
                    ApiStatus, GroupName ));
        }
    }

    return (ApiStatus == NO_ERROR);

} // NetpIsGroupNameValid



// This checks for "mGroup:" format.
// Note that other chars may appear after the colon; they are ignored.
BOOL
NetpIsMacPrimaryGroupFieldValid(
    IN LPCTSTR MacPrimaryField
    )
{
    LPTSTR ColonPtr;
    DWORD  GroupLen;   // Length of group (in characters).
    TCHAR  GroupName[LM20_GNLEN+1];
    DWORD  StringLen;

    if (MacPrimaryField==NULL) {
        return (FALSE);    // Empty field is not valid.
    } else if ( (*MacPrimaryField) != TEXT('m') ) {
        return (FALSE);    // Must start with lower case 'm'.
    }

    StringLen = STRLEN( MacPrimaryField );
    if (StringLen <= 2) {  // Must be room for 'm', group, ':' (at least 3).
        return (FALSE);
    }

    ColonPtr = STRCHR( MacPrimaryField, TCHAR_COLON );
    if (ColonPtr == NULL) {
        return (FALSE);    // No, not valid (must have colon).
    }

    // Compute group length in characters, without 'm' or ':'.
    GroupLen = (DWORD) ((ColonPtr - MacPrimaryField) - 1);
    if (GroupLen == 0) {
        return (FALSE);    // No, not valid (missing group).
    }
    if (GroupLen > LM20_GNLEN) {
        return (FALSE);    // No, not valid (too long).
    }

    (VOID) STRNCPY(
            GroupName,                  // dest
            &MacPrimaryField[1],        // src (after 'm')
            GroupLen );                 // char count
    GroupName[ GroupLen ] = TCHAR_EOS;

    return (NetpIsGroupNameValid( GroupName ));

} // NetpIsMacPrimaryGroupFieldValid



BOOL
NetpIsPrintQueueNameValid(
    IN LPCTSTR QueueName
    )
{
    NET_API_STATUS ApiStatus;
    TCHAR          CanonBuf[ MAX_PATH ];

    if (QueueName == NULL) {
        return (FALSE);
    }
    if ( (*QueueName) == TCHAR_EOS ) {
        return (FALSE);
    }

    ApiStatus = NetpNameCanonicalize(
            NULL,                       // no server name
            (LPTSTR) QueueName,         // name to validate
            CanonBuf,                   // output buffer
            sizeof( CanonBuf ),         // output buffer size
            NAMETYPE_PRINTQ,            // type
            0 );                        // flags: none

    IF_DEBUG( NAMES ) {
        if (ApiStatus != NO_ERROR) {
            NetpKdPrint(( PREFIX_NETLIB
                    "NetpIsPrintQueuNameValid: err " FORMAT_API_STATUS
                    " after canon of '" FORMAT_LPTSTR "'.\n",
                    ApiStatus, QueueName ));
        }
    }

    return (ApiStatus == NO_ERROR);

} // NetpIsPrintQueueNameValid



BOOL
NetpIsRemoteNameValid(
    IN LPTSTR RemoteName
    )

/*++

Routine Description:

    NetpIsRemoteNameValid checks for "\\server\share" format.  The name is
    only checked syntactically; no attempt is made to determine whether or
    not a server or share with that name actually exists.  Forward slashes
    are acceptable.

Arguments:

    RemoteName - Supplies an alleged remote name.

Return Value:

    BOOL - TRUE if name is syntactically valid, FALSE otherwise.

--*/

{
    if (RemoteName == (LPTSTR) NULL) {
        return (FALSE);
    }

    //
    // Shortest is \\x\y (5).
    //
    if ((STRLEN(RemoteName) < 5) || (STRLEN(RemoteName) > MAX_PATH )) {
        return (FALSE);
    }

    //
    // First two characters must be slashes.
    //
    if (((RemoteName[0] != '\\') && (RemoteName[0] != '/')) ||
        ((RemoteName[1] != '\\') && (RemoteName[1] != '/'))) {
        return (FALSE);
    }

    //
    // Three leading \ or / is illegal.
    //
    if ((RemoteName[2] == '\\') || (RemoteName[2] == '/')) {
        return (FALSE);
    }

    //
    // Must have a least 1 \ or / inside.
    //
    if ((STRCHR(&RemoteName[2], '\\') == NULL) &&
        (STRCHR(&RemoteName[2], '/') == NULL)) {
        return (FALSE);
    }

    return (TRUE);

} // NetpIsRemoteNameValid


BOOL
NetpIsUncComputerNameValid(
    IN LPTSTR ComputerName
    )

/*++

Routine Description:

    NetpIsUncComputerNameValid checks for "\\server" format.  The name is
    only checked syntactically; no attempt is made to determine whether or
    not a server with that name actually exists.

Arguments:

    ComputerName - Supplies an alleged computer (server) name.

Return Value:

    BOOL - TRUE if name is syntactically valid, FALSE otherwise.

--*/

{
    if (ComputerName == (LPTSTR) NULL) {
        return (FALSE);
    }
    if ( ! IS_PATH_SEPARATOR( ComputerName[0] ) ) {
        return (FALSE);
    }
    if ( ! IS_PATH_SEPARATOR( ComputerName[1] ) ) {
        return (FALSE);
    }

    return (NetpIsComputerNameValid( &ComputerName[2]) );


} // NetpIsUncComputerNameValid


BOOL
NetpIsUserNameValid(
    IN LPTSTR UserName
    )
{
    NET_API_STATUS ApiStatus;
    TCHAR CanonBuf[UNLEN+1];

    if (UserName == (LPTSTR) NULL) {
        return (FALSE);
    }
    if ( (*UserName) == TCHAR_EOS ) {
        return (FALSE);
    }

    ApiStatus = NetpNameCanonicalize(
            NULL,                       // no server name
            UserName,                   // name to validate
            CanonBuf,                   // output buffer
            (UNLEN+1) * sizeof(TCHAR),  // output buffer size
            NAMETYPE_USER,              // type
            0 );                        // flags: none

    IF_DEBUG( NAMES ) {
        if (ApiStatus != NO_ERROR) {
            NetpKdPrint(( PREFIX_NETLIB
                    "NetpIsUserNameValid: err " FORMAT_API_STATUS
                    " after canon of '" FORMAT_LPTSTR "'.\n",
                    ApiStatus, UserName ));
        }
    }

    return (ApiStatus == NO_ERROR);

} // NetpIsUserNameValid
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\netsetp.h ===
/*++

Copyright (c) 1997 - 1997  Microsoft Corporation

Module Name:

    netsetp.h

Abstract:

    Private definitions and prototypes for the Net setup apis

Author:

    Mac McLain   (MacM)     19-Feb-1997

Environment:

    User mode only.

Revision History:

--*/

#ifndef __NETSETP_H__
#define __NETSETP_H__

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include <windows.h>
#if(_WIN32_WINNT >= 0x0500)
  #include <dsgetdc.h>
#endif
#include <lmcons.h>
#include <lmapibuf.h>
#include <lmerr.h>
#include <lmjoin.h>
#include <netsetup.h>
#include <stdio.h>
#include <netdebug.h>


#define NETSETUPP_CONNECT_IPC       0x00000001
#define NETSETUPP_DISCONNECT_IPC    0x00000002
#define NETSETUPP_NULL_SESSION_IPC  0x00000010
#define NETSETUPP_USE_LOTS_FORCE    0x00000020

#define NETSETUPP_CREATE            0
#define NETSETUPP_DELETE            1
#define NETSETUPP_RENAME            2
#define NETSETUPP_SET_PASSWORD      3


#define NETSETUP_SVC_STOPPED    0x00000001
#define NETSETUP_SVC_STARTED    0x00000002
#define NETSETUP_SVC_ENABLED    0x00000004
#define NETSETUP_SVC_DISABLED   0x00000008
#define NETSETUP_SVC_MANUAL     0x00000010


#define NETSETUPP_SVC_NETLOGON  0x00000001
#define NETSETUPP_SVC_TIMESVC   0x00000002

#define NETSETUP_IGNORE_JOIN    0x80000000


#define NETSETUP_VERBOSE_LOGGING

extern HANDLE DebugLog;

//
// For debug output
//
#define PREFIX_NETJOIN          "[WKSSVC]NetJoin: "

//
// Flags passed to DsGetDcName
//
#if(_WIN32_WINNT >= 0x0500)

    #define NETSETUPP_DSGETDC_FLAGS                                         \
        (DS_DIRECTORY_SERVICE_PREFERRED | DS_WRITABLE_REQUIRED )

    #define NETSETUP_DSGETDC_FLAGS_ACCOUNT_EXISTS                           \
        ( DS_DIRECTORY_SERVICE_PREFERRED | DS_WRITABLE_REQUIRED )
#else
    #define NETSETUPP_DSGETDC_FLAGS                 0
    #define NETSETUP_DSGETDC_FLAGS_ACCOUNT_EXISTS   0

    #define DS_DS_FLAG  0x00000001

#endif

//
// Helpful macros
//

//
// Determines whether a bit flag is turned on or not
//
#define FLAG_ON(flag,bits)        ((flag) & (bits))

//
// Determine whether the client is joined to a domain or not given the LSAs
// primary domain information
//
#define IS_CLIENT_JOINED(plsapdinfo)                                        \
((plsapdinfo)->Sid != NULL && (plsapdinfo)->Name.Length != 0 ? TRUE : FALSE)

#ifdef NETSETUP_VERBOSE_LOGGING
//#define NetpLog(x) NetpLogPrintHelper x
#else
#define NetSetuppLogPrint(x)
#define NetSetuppOpenLog()
#define NetSetuppCloseLog()
#endif


typedef struct _NETSETUP_SAVED_JOIN_STATE {

    BOOLEAN MachineSecret;
    PUNICODE_STRING CurrentValue;
    PUNICODE_STRING PreviousValue;
    PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomainInfo;
#if(_WIN32_WINNT >= 0x0500)
    PPOLICY_DNS_DOMAIN_INFO DnsDomainInfo;
#endif

} NETSETUP_SAVED_JOIN_STATE, *PNETSETUP_SAVED_JOIN_STATE;


//
// netjoin.c functions
//

NET_API_STATUS
NET_API_FUNCTION
NetpManageMachineAccount(
    IN  LPWSTR      lpMachine,
    IN  LPWSTR      lpOldMachine,
    IN  LPWSTR      lpDcName,
    IN  LPWSTR      lpPassword,
    IN  ULONG       fControl,
    IN  ULONG       AccountOptions,
    IN  BOOL        fIsNt4Dc
    );

NET_API_STATUS
NET_API_FUNCTION
NetpManageMachineAccountWithSid(
    IN  LPWSTR      lpMachine,
    IN  LPWSTR      lpOldMachine,
    IN  LPWSTR      lpDcName,
    IN  LPWSTR      lpPassword,
    IN  PSID        DomainSid,
    IN  ULONG       fControl,
    IN  ULONG       AccountOptions,
    IN  BOOL        fIsNt4Dc
    );

//
// netplsa.c functions
//
NET_API_STATUS
NET_API_FUNCTION
NetpHandleJoinedStateInfo(
    IN  LSA_HANDLE                  PolicyHandle,  OPTIONAL
    IN  PNETSETUP_SAVED_JOIN_STATE  SavedState,
    IN  BOOLEAN                     Save,
    OUT PLSA_HANDLE                 ReturnedPolicyHandle OPTIONAL
    );


NET_API_STATUS
NET_API_FUNCTION
NetpSetLsaPrimaryDomain(
    IN  LSA_HANDLE      PolicyHandle,   OPTIONAL
    IN  LPWSTR          lpDomain,
    IN  PSID            pDomainSid,     OPTIONAL
#if(_WIN32_WINNT >= 0x0500)
    IN  PPOLICY_DNS_DOMAIN_INFO pPolicyDns, OPTIONAL
#endif
    OUT PLSA_HANDLE     pPolicyHandle   OPTIONAL
    );

NET_API_STATUS
NET_API_FUNCTION
NetpGetLsaPrimaryDomain(
    IN  LSA_HANDLE                          PolicyHandle,  OPTIONAL
    IN  LPWSTR                              lpServer,      OPTIONAL
    OUT PPOLICY_PRIMARY_DOMAIN_INFO        *ppPolicyPDI,
#if(_WIN32_WINNT >= 0x0500)
    OUT PPOLICY_DNS_DOMAIN_INFO            *ppPolicyDns,
#endif
    OUT PLSA_HANDLE                         pPolicyHandle  OPTIONAL
    );

NET_API_STATUS
NET_API_FUNCTION
NetpGetLsaDcRole(
    IN  LPWSTR                      lpMachine,
    OUT BOOL                       *pfIsDC
    );

NET_API_STATUS
NET_API_FUNCTION
NetpManageMachineSecret(
    IN  LSA_HANDLE  PolicyHandle, OPTIONAL
    IN  LPWSTR      lpMachine,
    IN  LPWSTR      lpPassword,
    IN  BOOL        fDelete,
    IN  BOOL        UseDefaultForOldPwd,
    OUT PLSA_HANDLE pPolicyHandle OPTIONAL
    );

NET_API_STATUS
NET_API_FUNCTION
NetpReadCurrentSecret(
    IN LSA_HANDLE PolicyHandle, OPTIONAL
    OUT LPWSTR *lpCurrentSecret,
    OUT PLSA_HANDLE pPolicyHandle OPTIONAL
    );

NET_API_STATUS
NET_API_FUNCTION
NetpSetNetlogonDomainCache(
    IN  LPWSTR          lpDc
    );

NET_API_STATUS
NET_API_FUNCTION
NetpManageLocalGroups(
    IN  PSID    pDomainSid,
    IN  BOOL    fDelete
    );

NET_API_STATUS
NET_API_FUNCTION
NetpValidateMachineAccount(
    IN  LPWSTR      lpDc,
    IN  LPWSTR      lpDomain,
    IN  LPWSTR      lpMachine,
    IN  LPWSTR      lpPassword
    );

NET_API_STATUS
NET_API_FUNCTION
NetpSetMachineAccountPassword(
    IN  LPWSTR      lpDc,
    IN  LPWSTR      lpDomain,
    IN  LPWSTR      lpMachine,
    IN  LPWSTR      lpPassword
    );

NET_API_STATUS
NET_API_FUNCTION
NetpStopService(
    IN LPWSTR       Service,
    IN SC_HANDLE    SCManager
    );

NET_API_STATUS
NET_API_FUNCTION
NetpSetTimeServiceParameters(
    VOID
    );

NET_API_STATUS
NET_API_FUNCTION
NetpDsGetDcName(
    IN LPWSTR ComputerName, OPTIONAL
    IN LPWSTR DomainName,
    IN LPWSTR AccountName, OPTIONAL
    IN ULONG Flags,
    IN OUT PULONG DcFlags,
    OUT PWSTR *DomainControllerName
#if(_WIN32_WINNT >= 0x0500)
    ,
    OUT PDOMAIN_CONTROLLER_INFO *DcInfo
#endif
    );

NET_API_STATUS
NET_API_FUNCTION
NetpCrackDomainSpecifier(
    IN LPWSTR DomainSpecifier,
    OUT LPWSTR* DomainName,
    OUT LPWSTR* DomainControllerName
    );

//
// joinutl.c
//
NET_API_STATUS
NET_API_FUNCTION
NetpCreateComputerObjectInOU(
    IN LPWSTR DC,
    IN LPWSTR OU,
    IN LPWSTR ComputerName,
    IN LPWSTR Account,
    IN LPWSTR Password,
    IN LPWSTR MachinePassword
    );

NET_API_STATUS
NetpGetDnsHostName(
    IN LPWSTR PassedHostName OPTIONAL,
    IN PUNICODE_STRING DnsDomainName,
    OUT LPWSTR *DnsHostName
    );

NET_API_STATUS
NET_API_FUNCTION
NetpCreateComputerObjectInDs(
    IN PDOMAIN_CONTROLLER_INFO DcInfo,
    IN LPWSTR Account,
    IN LPWSTR Password,
    IN LPWSTR ComputerName,
    IN LPWSTR MachinePassword,
    IN LPWSTR DnsHostName OPTIONAL,
    IN LPWSTR OU OPTIONAL
    );

NET_API_STATUS
NET_API_FUNCTION
NetpSetDnsHostNameAndSpn(
    IN PDOMAIN_CONTROLLER_INFO DcInfo,
    IN LPWSTR Account,
    IN LPWSTR Password,
    IN LPWSTR ComputerName,
    IN LPWSTR DnsHostName
    );

NET_API_STATUS
NET_API_FUNCTION
NetpDeleteComputerObjectInOU(
    IN LPWSTR DC,
    IN LPWSTR OU,
    IN LPWSTR ComputerName,
    IN LPWSTR Account,
    IN LPWSTR Password
    );

NET_API_STATUS
NET_API_FUNCTION
NetpSetMachineAccountPasswordAndType(
    IN  LPWSTR      lpDcName,
    IN  PSID        DomainSid,
    IN  LPWSTR      lpAccountName,
    IN  LPWSTR      lpPassword
    );

#define ACCOUNT_STATE_IGNORE   0
#define ACCOUNT_STATE_ENABLED  1
#define ACCOUNT_STATE_DISABLED 2

NET_API_STATUS
NET_API_FUNCTION
NetpSetMachineAccountPasswordAndTypeEx(
    IN  LPWSTR          lpDcName,
    IN  PSID            DomainSid,
    IN  LPWSTR          lpAccountName,
    IN  OPTIONAL LPWSTR lpPassword,
    IN  OPTIONAL UCHAR  AccountState,
    IN  BOOL            fIsNt4Dc
    );

#if defined(REMOTE_BOOT) && (_WIN32_WINNT >= 0x0500)
NET_API_STATUS
NET_API_FUNCTION
NetpGetRemoteBootMachinePassword(
    OUT LPWSTR Password
    );
#endif

NET_API_STATUS
NET_API_FUNCTION
NetpRemoveDnsRegistrations (
   VOID
   );

#if(_WIN32_WINNT >= 0x0500)
NET_API_STATUS
NET_API_FUNCTION
NetpStoreIntialDcRecord(
    IN PDOMAIN_CONTROLLER_INFO   DcInfo
    );
#endif

NET_API_STATUS
NET_API_FUNCTION
NetpSetComputerAccountPassword(
    IN   PWSTR szMachine,
    IN   PWSTR szDomainController,
    IN   PWSTR szUser,
    IN   PWSTR szUserPassword,
    IN   PVOID Reserved
    );

#endif // __NETSETP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\pathcan.c ===
/*++

Copyright (c) 1990-91  Microsoft Corporation

Module Name:

    pathcan.c

Abstract:

    Net path canonicalization routines:

        NetpwCanonicalize

Notes:

    The Nt versions of these routines are kept in the NetApi Dll and are
    (usually) called locally. If the caller specifies a remote computer
    name then we try to RPC the request. If that fails the wrapper routine
    which attempts RPC will call down-level.

    OLDPATHS support has been removed from this module in keeping with the
    N-1 (this product and its immediate predecessor) philosophy of NT.
    Therefore, we always expect a down-level server to be able to handle a
    remoted canonicalization request. We don't cover for Lan Manager 1.x

    Types of paths we expect to receive in this routine:

        - relative path
            e.g. foo\bar

        - absolute path (path specified from root, but no drive or computer name)
            e.g. \foo\bar

        - UNC path
            e.g. \\computer\share\foo

        - disk path (full path specified with disk drive)
            e.g. d:\foo\bar

Author:

    Richard L Firth (rfirth) 06-Jan-1992
        from an original script by danny glasser (dannygl)

Revision History:

--*/

#include "nticanon.h"

//
// routines
//


NET_API_STATUS
NetpwPathCanonicalize(
    IN  LPTSTR  PathName,
    IN  LPTSTR  Outbuf,
    IN  DWORD   OutbufLen,
    IN  LPTSTR  Prefix OPTIONAL,
    IN OUT LPDWORD PathType,
    IN  DWORD   Flags
    )

/*++

Routine Description:

    NetpPathCanonicalize produces the canonical version of the specified
    pathname.

    The canonical form of PRN is LPT1
    The canonical form of AUX is COM1

    If the value of <PathType> on entry has not been determined
    by a prior (successful) call to NetpPathType, it must be set to 0.
    Even if it is set to the correct non-zero value on entry, it may be
    changed by this function, since the canonicalized version of a name
    may be of a different type than the original version (e.g. if the
    prefix is used).

Arguments:

    PathName    - The pathname to canonicalize

    Outbuf      - The place to store the canonicalized version of the pathname

    OutbufLen   - The size, in bytes, of <Outbuf>

    Prefix      - Optional prefix to use when canonicalizing a relative pathname

    PathType    - The place to store the type.  If the type does not contain
                  zero on function entry, the function assumes that this type
                  has been determined already by a call to NetpPathType

    Flags       - Flags to determine operation. MBZ

Return Value:

    NET_API_STATUS
        Success - NERR_Success
        Failure - ERROR_INVALID_PARAMETER
                  ERROR_INVALID_NAME
                  NERR_BufTooSmall
--*/

{
    DWORD   rc = 0;
    BOOL    noPrefix = ((Prefix == NULL) || (*Prefix == TCHAR_EOS));
    DWORD   typeOfPrefix;
    DWORD   typeOfPath;

#ifdef CANONDBG
    NetpKdPrint(("NetpwPathCanonicalize\n"));
#endif

    typeOfPath = *PathType;

    if (Flags & INPCA_FLAGS_RESERVED) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // Determine type of pathname, if it hasn't been determined yet
    // Abort on error
    //

    if (!typeOfPath) {
        if (rc = NetpwPathType(PathName, &typeOfPath, 0)) {
            return rc;
        }
    }

    //
    // Validate prefix, if there is one
    // Abort on error
    //

    if (!noPrefix) {
        if (rc = NetpwPathType(Prefix, &typeOfPrefix, 0)) {
            return rc;
        }
    }

    //
    // Set the output buffer to the null string (or return with an error, if
    // it's zero length).  Note that we've already set the caller's
    // <PathType> parameter.
    //

    if (OutbufLen == 0) {
        return NERR_BufTooSmall;
    } else {
        *Outbuf = TCHAR_EOS;
    }

    rc = CanonicalizePathName(Prefix, PathName, Outbuf, OutbufLen, NULL);
    if (rc == NERR_Success) {
        rc = NetpwPathType(Outbuf, PathType, 0);
    }
    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\packstr.c ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    packstr.c

Abstract:

    Contains utilities for allocating and/or packing buffers that contain
    a fixed section and a variable (string) section.  The following
    functions are available:

        NetpPackString
        NetpCopyStringToBuffer
        NetpCopyDataToBuffer
        NetpAllocateEnumBuffer

Author:

    various

Environment:

    User Mode -Win32

Revision History:

    30-Apr-1991     danl
        NetpAllocateEnumBuffer:  Removed use of NetApiBufferFree.  It has
        been changed to use MIDL_user_allocate and MIDL_user_free.
        Also added NT-style headers where needed.
    16-Apr-1991 JohnRo
        Clarify UNICODE handling of pack and copy routines.  Got rid of tabs
        in source file.
    21-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.
    15-Apr-1992 JohnRo
        FORMAT_POINTER is obsolete.

--*/

// These must be included first:

#include <windef.h>     // IN, OUT, etc.
#include <lmcons.h>     // Needed by <netlib.h>.
#include <lmerr.h>      // NERR_*
#include <rpcutil.h>    // MIDL_user_allocate & MIDL_user_free

// These may be included in any order:

#include <align.h>      // ROUND_UP_COUNT().
#include <debuglib.h>   // IF_DEBUG().
#include <netdebug.h>   // NetpKdPrint(), FORMAT_ equates.
#include <netlib.h>     // My prototype.
#include <tstring.h>    // STRCPY(), STRLEN(), STRNCPY().


DWORD
NetpPackString(
    IN OUT LPTSTR * string,     // pointer by reference: string to be copied.
    IN LPBYTE dataend,          // pointer to end of fixed size data.
    IN OUT LPTSTR * laststring  // pointer by reference: top of string data.
    )

/*++

Routine Description:

    NetPackString is used to stuff variable-length data, which
    is pointed to by (surpise!) a pointer.  The data is assumed
    to be a nul-terminated string (ASCIIZ).  Repeated calls to
    this function are used to pack data from an entire structure.

    Upon first call, the laststring pointer should point to just
    past the end of the buffer.  Data will be copied into the buffer from
    the end, working towards the beginning.  If a data item cannot
    fit, the pointer will be set to NULL, else the pointer will be
    set to the new data location.

    Pointers which are passed in as NULL will be set to be pointer
    to and empty string, as the NULL-pointer is reserved for
    data which could not fit as opposed to data not available.

    See the test case for sample usage.  (tst/packtest.c)


Arguments:

    string - pointer by reference:  string to be copied.

    dataend - pointer to end of fixed size data.

    laststring - pointer by reference:  top of string data.

Return Value:

    0  - if it could not fit data into the buffer.  Or...

    sizeOfData - the size of data stuffed (guaranteed non-zero)

--*/

{
    DWORD size;

    IF_DEBUG(PACKSTR) {
        NetpKdPrint(("NetpPackString:\n"));
        NetpKdPrint(("  string=" FORMAT_LPVOID
                ", *string=" FORMAT_LPVOID
                ", **string='" FORMAT_LPSTR "'\n",
                (LPVOID) string, (LPVOID) *string, *string));
        NetpKdPrint(("  end=" FORMAT_LPVOID "\n", (LPVOID) dataend));
        NetpKdPrint(("  last=" FORMAT_LPVOID
                ", *last=" FORMAT_LPVOID
                ", **last='" FORMAT_LPSTR "'\n",
                (LPVOID) laststring, (LPVOID) *laststring, *laststring));
    }

    //
    //  convert NULL ptr to pointer to NULL string
    //

    if (*string == NULL) {
        // BUG 20.1160 - replaced (dataend +1) with dataend
        // to allow for a NULL ptr to be packed
        // (as a NULL string) with one byte left in the
        // buffer. - ERICPE
        //

        if ( *laststring > (LPTSTR)dataend ) {
            *(--(*laststring)) = 0;
            *string = *laststring;
            return 1;
        } else {
            return 0;
        }
    }

    //
    //  is there room for the string?
    //

    size = STRLEN(*string) + 1;
    if ( ((DWORD)(*laststring - (LPTSTR)dataend)) < size) {
        *string = NULL;
        return(0);
    } else {
        *laststring -= size;
        STRCPY(*laststring, *string);
        *string = *laststring;
        return(size);
    }
} // NetpPackString


BOOL
NetpCopyStringToBuffer (
    IN LPTSTR String OPTIONAL,
    IN DWORD CharacterCount,
    IN LPBYTE FixedDataEnd,
    IN OUT LPTSTR *EndOfVariableData,
    OUT LPTSTR *VariableDataPointer
    )

/*++

Routine Description:

    This routine puts a single variable-length string into an output buffer.
    The string is not written if it would overwrite the last fixed structure
    in the buffer.

    The code is swiped from svcsupp.c written by DavidTr.

    Sample usage:

            LPBYTE FixedDataEnd = OutputBuffer + sizeof(WKSTA_INFO_202);
            LPTSTR EndOfVariableData = OutputBuffer + OutputBufferSize;

            //
            // Copy user name
            //

            NetpCopyStringToBuffer(
                UserInfo->UserName.Buffer;
                UserInfo->UserName.Length;
                FixedDataEnd,
                &EndOfVariableData,
                &WkstaInfo->wki202_username
                );

Arguments:

    String - Supplies a pointer to the source string to copy into the
        output buffer.  If String is null then a pointer to a zero terminator
        is inserted into output buffer.

    CharacterCount - Supplies the length of String, not including zero
        terminator.

    FixedDataEnd - Supplies a pointer to just after the end of the last
        fixed structure in the buffer.

    EndOfVariableData - Supplies an address to a pointer to just after the
        last position in the output buffer that variable data can occupy.
        Returns a pointer to the string written in the output buffer.

    VariableDataPointer - Supplies a pointer to the place in the fixed
        portion of the output buffer where a pointer to the variable data
        should be written.

Return Value:

    Returns TRUE if string fits into output buffer, FALSE otherwise.

--*/
{
    DWORD BytesNeeded = (CharacterCount + 1) * sizeof(TCHAR);

    IF_DEBUG(PACKSTR) {
        NetpKdPrint(("NetpStringToBuffer: String at " FORMAT_LPVOID
                ", CharacterCount=" FORMAT_DWORD
                ",\n  FixedDataEnd at " FORMAT_LPVOID
                ", *EndOfVariableData at " FORMAT_LPVOID
                ",\n  VariableDataPointer at " FORMAT_LPVOID
                ", BytesNeeded=" FORMAT_DWORD ".\n",
                (LPVOID) String, CharacterCount, FixedDataEnd,
                (LPVOID) *EndOfVariableData,
                (LPVOID) VariableDataPointer, BytesNeeded));
    }

    //
    // Determine if string will fit, allowing for a zero terminator.  If no,
    // just set the pointer to NULL.
    //

    if ((*EndOfVariableData - (CharacterCount+1)) >= (LPTSTR)FixedDataEnd) {

        //
        // It fits.  Move EndOfVariableData pointer up to the location where
        // we will write the string.
        //

        *EndOfVariableData -= (CharacterCount+1);

        //
        // Copy the string to the buffer if it is not null.
        //

        if (CharacterCount > 0 && String != NULL) {

            STRNCPY(*EndOfVariableData, String, CharacterCount);
        }

        //
        // Set the zero terminator.
        //

        *(*EndOfVariableData + CharacterCount) = TCHAR_EOS;

        //
        // Set up the pointer in the fixed data portion to point to where the
        // string is written.
        //

        *VariableDataPointer = *EndOfVariableData;

        return TRUE;

    }
    else {

        //
        // It doesn't fit.  Set the offset to NULL.
        //

        *VariableDataPointer = NULL;

        return FALSE;
    }
} // NetpCopyStringToBuffer


BOOL
NetpCopyDataToBuffer (
    IN LPBYTE Data,
    IN DWORD ByteCount,
    IN LPBYTE FixedDataEnd,
    IN OUT LPBYTE *EndOfVariableData,
    OUT LPBYTE *VariableDataPointer,
    IN DWORD Alignment
    )

/*++

Routine Description:

    This routine puts the specified data into an output buffer.
    The data is not written if it would overwrite the last fixed structure
    in the buffer.

    The output buffer is aligned as requested.

    Sample usage:

            LPBYTE FixedDataEnd = OutputBuffer + sizeof(WKSTA_INFO_202);
            LPBYTE EndOfVariableData = OutputBuffer + OutputBufferSize;

            //
            // Copy Logon hours
            //

            NetpCopyDataToBuffer(
                StructurePointer,
                sizeof( STRUCTURE_TYPE),
                FixedDataEnd,
                &EndOfVariableData,
                &UserInfo->usri2->LogonHours,
                sizeof(ULONG)
                );

Arguments:

    Data - Supplies a pointer to the source data to copy into the
        output buffer.  If Data is null then a null pointer is returned in
        VariableDataPointer.

    ByteCount - Supplies the length of Data.

    FixedDataEnd - Supplies a pointer to just after the end of the last
        fixed structure in the buffer.

    EndOfVariableData - Supplies an address to a pointer to just after the
        last position in the output buffer that variable data can occupy.
        Returns a pointer to the data written in the output buffer.

    VariableDataPointer - Supplies a pointer to the place in the fixed
        portion of the output buffer where a pointer to the variable data
        should be written.

    Alignment - Supplies the required alignment of the data expressed
        as the number of bytes in the primitive datatype (e.g., 1 for byte,
        2 for short, 4 for long, and 8 for quad).

Return Value:

    Returns TRUE if data fits into output buffer, FALSE otherwise.

--*/
{

    LPBYTE NewEndOfVariableData;

    //
    // If there is no data to copy, just return success.
    //

    if ( Data == NULL ) {
        *VariableDataPointer = NULL;
        return TRUE;
    }

    //
    // Compute where the data will be copied to (taking alignment into
    //  consideration).
    //
    // We may end up with a few unused byte after the copied data.
    //

    NetpAssert((Alignment == 1) || (Alignment == 2) ||
               (Alignment == 4) || (Alignment == 8));

    NewEndOfVariableData = (LPBYTE)
        (((DWORD_PTR)(*EndOfVariableData - ByteCount)) & ~((LONG)Alignment - 1));

    //
    // If the data doesn't fit into the buffer, error out
    //

    if ( NewEndOfVariableData < FixedDataEnd) {
        *VariableDataPointer = NULL;
        return FALSE;
    }

    //
    // Copy the data to the buffer
    //

    if (ByteCount > 0) {
        NetpMoveMemory(NewEndOfVariableData, Data, ByteCount);
    }

    //
    // Return the pointer to the new data and update the pointer to
    // how much of the buffer we've used so far.
    //

    *VariableDataPointer = NewEndOfVariableData;
    *EndOfVariableData = NewEndOfVariableData;

    return TRUE;

} // NetpCopyDataToBuffer


NET_API_STATUS
NetpAllocateEnumBuffer(
    IN OUT PBUFFER_DESCRIPTOR BufferDescriptor,
    IN BOOL IsGet,
    IN DWORD PrefMaxSize,
    IN DWORD NeededSize,
    IN VOID (*RelocationRoutine)( IN DWORD RelocationParameter,
                                  IN OUT PBUFFER_DESCRIPTOR BufferDescriptor,
                                  IN PTRDIFF_T Offset ),
    IN DWORD RelocationParameter
    )

/*++

Routine Description:

    Ensures a buffer is allocated which contains the needed size.

Arguments:

    BufferDescriptor - Points to a structure which describes the allocated
        buffer.  On the first call, pass in BufferDescriptor->Buffer set
        to NULL.  On subsequent calls (in the 'enum' case), pass in the
        structure just as it was passed back on a previous call.

        The caller must deallocate the BufferDescriptor->Buffer using
        MIDL_user_free if it is non-null.

    IsGet - TRUE iff this is a 'get' rather than an 'enum' operation.

    PrefMaxSize - Callers prefered maximum size

    NeededSize - the number of bytes which must be available in the allocated
        buffer.

    RelocationRoutine - Supplies a pointer to a routine that will be called
        when the buffer needs to be relocated.  The routine is called with
        both the fixed portion and the strings already copied.  Merely,
        the pointers to the strings need to be adjusted.

        The 'Offset' parameter to the relocation routine merely needs to
        be added to the each pointer within the allocated buffer which points
        to a place within the allocated buffer.  It is a byte-offset.  This
        design depends on a 'flat' address space where the addresses of two
        unrelated pointers can simply be subtracted.

    RelocationParameter - Supplies a parameter which will (in turn) be passed
        to the relocation routine.

Return Value:

    Error code for the operation.

    If this is an Enum call, the status can be ERROR_MORE_DATA implying that
    the Buffer has grown to PrefMaxSize and that this much data should
    be returned to the caller.

--*/

{
    return NetpAllocateEnumBufferEx(
                            BufferDescriptor,
                            IsGet,
                            PrefMaxSize,
                            NeededSize,
                            RelocationRoutine,
                            RelocationParameter,
                            NETP_ENUM_GUESS );
}


NET_API_STATUS
NetpAllocateEnumBufferEx(
    IN OUT PBUFFER_DESCRIPTOR BufferDescriptor,
    IN BOOL IsGet,
    IN DWORD PrefMaxSize,
    IN DWORD NeededSize,
    IN VOID (*RelocationRoutine)( IN DWORD RelocationParameter,
                                  IN OUT PBUFFER_DESCRIPTOR BufferDescriptor,
                                  IN PTRDIFF_T Offset ),
    IN DWORD RelocationParameter,
    IN DWORD IncrementalSize
    )

/*++

Routine Description:

    Ensures a buffer is allocated which contains the needed size.

Arguments:

    BufferDescriptor - Points to a structure which describes the allocated
        buffer.  On the first call, pass in BufferDescriptor->Buffer set
        to NULL.  On subsequent calls (in the 'enum' case), pass in the
        structure just as it was passed back on a previous call.

        The caller must deallocate the BufferDescriptor->Buffer using
        MIDL_user_free if it is non-null.

    IsGet - TRUE iff this is a 'get' rather than an 'enum' operation.

    PrefMaxSize - Callers prefered maximum size

    NeededSize - the number of bytes which must be available in the allocated
        buffer.

    RelocationRoutine - Supplies a pointer to a routine that will be called
        when the buffer needs to be relocated.  The routine is called with
        both the fixed portion and the strings already copied.  Merely,
        the pointers to the strings need to be adjusted.

        The 'Offset' parameter to the relocation routine merely needs to
        be added to the each pointer within the allocated buffer which points
        to a place within the allocated buffer.  It is a byte-offset.  This
        design depends on a 'flat' address space where the addresses of two
        unrelated pointers can simply be subtracted.

    RelocationParameter - Supplies a parameter which will (in turn) be passed
        to the relocation routine.

    IncrementalSize - Mimimum number of bytes to extend the buffer by when it
        needs extending.

Return Value:

    Error code for the operation.

    If this is an Enum call, the status can be ERROR_MORE_DATA implying that
    the Buffer has grown to PrefMaxSize and that this much data should
    be returned to the caller.

--*/

{
        NET_API_STATUS NetStatus;
    PBUFFER_DESCRIPTOR Desc = BufferDescriptor;

    IF_DEBUG(PACKSTR) {
        NetpKdPrint((
            "NetpAllocateEnumBuffer: Isget: " FORMAT_DWORD " PrefMaxSize: "
            FORMAT_HEX_DWORD " NeededSize: " FORMAT_HEX_DWORD "\n",
            IsGet, PrefMaxSize, NeededSize ));

        NetpKdPrint((
            "+BufferDescriptor: Buffer: " FORMAT_HEX_DWORD " AllocSize: "
            FORMAT_HEX_DWORD " AllocIncr: " FORMAT_HEX_DWORD "\n",
            Desc->Buffer, Desc->AllocSize, Desc->AllocIncrement ));
        NetpKdPrint(( "                  variable: " FORMAT_HEX_DWORD " Fixed:"
            FORMAT_HEX_DWORD "\n",
            Desc->EndOfVariableData, Desc->FixedDataEnd ));
    }

    //
    // If this is not a resume, initialize a buffer descriptor.
    //

    if ( Desc->Buffer == NULL ) {

        //
        // Allocate the return buffer.
        //
        // If this is a Getinfo call, allocate the buffer the correct size.
        //
        // If the is an Enum call, this is an initial allocation which
        // might be reallocated later if this size isn't big enough.
        // The initial allocation is the user's prefered maximum
        // length unless that length is deemed to be very large.
        // In that case we allocate a good sized buffer and will
        // reallocate later as needed.
        //

        if ( IsGet ) {

            Desc->AllocSize = NeededSize;

        } else {

            if ( PrefMaxSize < NeededSize ) {
                NetStatus = NERR_BufTooSmall;
                goto Cleanup;
            }

            Desc->AllocSize = min(PrefMaxSize, IncrementalSize);
            Desc->AllocSize = max(NeededSize, Desc->AllocSize );

        }

        // Some callers pack data on that top end of this buffer so
        // ensure the buffer size allows for proper alignment.
        Desc->AllocSize = ROUND_UP_COUNT( Desc->AllocSize, ALIGN_WORST );

        Desc->AllocIncrement = Desc->AllocSize;
        IF_DEBUG(PACKSTR) {
            NetpKdPrint((" Allocated size : " FORMAT_HEX_DWORD "\n",
                Desc->AllocSize ));
        }

        Desc->Buffer = MIDL_user_allocate(Desc->AllocSize);

        if (Desc->Buffer == NULL) {
            NetStatus = ERROR_NOT_ENOUGH_MEMORY;
            goto Cleanup;
        }

        IF_DEBUG(PACKSTR) {
            NetpKdPrint((" Allocated: " FORMAT_HEX_DWORD "\n", Desc->Buffer ));
        }

        Desc->FixedDataEnd = Desc->Buffer;
        Desc->EndOfVariableData = Desc->Buffer + Desc->AllocSize;

    //
    // If this is a resume, get the buffer descriptor that the caller passed in.
    //

    } else {

        //
        // If the entry doesn't fit, reallocate a larger return buffer
        //

        if ((DWORD)(Desc->EndOfVariableData - Desc->FixedDataEnd) < NeededSize){

            BUFFER_DESCRIPTOR OldDesc;
            DWORD FixedSize;        // Total size of the fixed data
            DWORD StringSize;       // Total size of the string data

            //
            // If the buffer is as big as is allowed,
            //      we're all done for now.
            //

            if ( Desc->AllocSize >= PrefMaxSize ) {
                NetStatus = ERROR_MORE_DATA;
                goto Cleanup;
            }


            //
            // Allocate a larger return buffer.
            //

            OldDesc = *Desc;

            Desc->AllocSize += max( NeededSize, Desc->AllocIncrement );
            Desc->AllocSize = min( Desc->AllocSize, PrefMaxSize );
            Desc->AllocSize = ROUND_UP_COUNT( Desc->AllocSize, ALIGN_WORST );
            IF_DEBUG(PACKSTR) {
                NetpKdPrint(("Re-Allocated size : " FORMAT_HEX_DWORD "\n",
                    Desc->AllocSize ));
            }
            Desc->Buffer = MIDL_user_allocate( Desc->AllocSize );

            if ( Desc->Buffer == NULL ) {
                MIDL_user_free( OldDesc.Buffer );
                NetStatus = ERROR_NOT_ENOUGH_MEMORY;
                goto Cleanup;
            }
            IF_DEBUG(PACKSTR) {
                NetpKdPrint(("ReAllocated: " FORMAT_HEX_DWORD "\n",
                             Desc->Buffer ));
            }

            //
            // Copy the fixed length portion of the data to the new buffer
            //

            FixedSize = (DWORD)(OldDesc.FixedDataEnd - OldDesc.Buffer);

            RtlCopyMemory( Desc->Buffer,
                            OldDesc.Buffer,
                            FixedSize );

            Desc->FixedDataEnd = Desc->Buffer + FixedSize ;

            //
            // Copy the string portion of the data to the new buffer
            //

            StringSize = OldDesc.AllocSize -
                                (DWORD)(OldDesc.EndOfVariableData - OldDesc.Buffer);

            Desc->EndOfVariableData = Desc->Buffer + Desc->AllocSize - StringSize;

            RtlCopyMemory( Desc->EndOfVariableData, OldDesc.EndOfVariableData, StringSize );

            //
            // Callback to allow the pointers into the string data to be
            // relocated.
            //
            // The callback routine merely needs to add the value I pass it
            // to all of the pointers from the fixed area to the string area.
            //

            (*RelocationRoutine)(
                    RelocationParameter,
                    Desc,
                    (Desc->EndOfVariableData - OldDesc.EndOfVariableData) );

            //
            // Free the old buffer.
            //

            MIDL_user_free( OldDesc.Buffer );
        }
    }

    NetStatus = NERR_Success;

    //
    // Clean up
    //

Cleanup:
    //
    //
    //

    if ( NetStatus != NERR_Success && NetStatus != ERROR_MORE_DATA &&
        Desc->Buffer != NULL ) {

        MIDL_user_free (Desc->Buffer );
        Desc->Buffer = NULL;
    }

    IF_DEBUG(PACKSTR) {
        NetpKdPrint((
            "BufferDescriptor: Buffer: " FORMAT_HEX_DWORD " AllocSize: "
            FORMAT_HEX_DWORD " AllocIncr: " FORMAT_HEX_DWORD "\n",
            Desc->Buffer, Desc->AllocSize, Desc->AllocIncrement ));
        NetpKdPrint(( "                  variable: " FORMAT_HEX_DWORD " Fixed:"
            FORMAT_HEX_DWORD "\n",
            Desc->EndOfVariableData, Desc->FixedDataEnd ));
    }

    return NetStatus;

} // NetpAllocateEnumBuffer
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\ntstatus.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    NtStatus.c

Abstract:

    This module contains code to convert status code types.

Author:

    Rita Wong (ritaw) 01-Mar-1991

Revision History:

    03-Apr-1991 JohnRo
        Borrowed Rita's WsMapStatus routine to create NetpNtStatusToApiStatus.
    16-Apr-1991 JohnRo
        Include other header files for <netlibnt.h>.
    06-May-1991 JohnRo
        Avoid NET_API_FUNCTION for non-APIs.
    26-Jul-1991 CliffV
        Add the SAM status codes.
    06-Sep-1991 CliffV
        Added NetpApiStatusToNtStatus.
    02-Oct-1991 JohnRo
        Avoid STATUS_INVALID_CONNECTION duplicate warnings.
    05-Aug-1992 Madana
        Add new netlogon error codes.

--*/

//
// These must be included first:
//

#include <nt.h>              // IN, NTSTATUS, etc.
#include <windef.h>             // DWORD.
#include <lmcons.h>             // NET_API_STATUS.
#include <netlibnt.h>           // My prototype.

//
// These may be included in any order:
//

#include <debuglib.h>           // IF_DEBUG().
#include <lmerr.h>              // NERR_ and ERROR_ equates.
#include <netdebug.h>           // FORMAT_NTSTATUS, NetpKdPrint(()).
#include <ntstatus.h>           // STATUS_ equates.
#include <ntrtl.h>

#ifdef WIN32_CHICAGO
#include "ntcalls.h"
#endif // WIN32_CHICAGO

NET_API_STATUS
NetpNtStatusToApiStatus (
    IN NTSTATUS NtStatus
    )

/*++

Routine Description:

    This function takes an NT status code and maps it to the appropriate
    LAN Man error code.

Arguments:

    NtStatus - Supplies the NT status.

Return Value:

    Returns the appropriate LAN Man error code for the NT status.

--*/
{
    NET_API_STATUS error;

    IF_DEBUG(NTSTATUS) {
#ifndef WIN32_CHICAGO
        NetpKdPrint(( "   NT status is " FORMAT_NTSTATUS "\n", NtStatus ));
#else  // WIN32_CHICAGO
        NlPrint(( NL_MISC, "   NT status is " FORMAT_NTSTATUS "\n", NtStatus ));
#endif // WIN32_CHICAGO
    }

    //
    // A small optimization for the most common case.
    //

    if ( NtStatus == STATUS_SUCCESS ) {
        return NERR_Success;
    }


    switch ( NtStatus ) {

        case STATUS_BUFFER_TOO_SMALL :
            return NERR_BufTooSmall;

        case STATUS_FILES_OPEN :
            return NERR_OpenFiles;

        case STATUS_CONNECTION_IN_USE :
            return NERR_DevInUse;

        case STATUS_INVALID_LOGON_HOURS :
            return NERR_InvalidLogonHours;

        case STATUS_INVALID_WORKSTATION :
            return NERR_InvalidWorkstation;

        case STATUS_PASSWORD_EXPIRED :
            return NERR_PasswordExpired;

        case STATUS_ACCOUNT_EXPIRED :
            return NERR_AccountExpired;

        case STATUS_REDIRECTOR_NOT_STARTED :
            return NERR_NetNotStarted;

        case STATUS_GROUP_EXISTS:
                return NERR_GroupExists;

        case STATUS_INTERNAL_DB_CORRUPTION:
                return NERR_InvalidDatabase;

        case STATUS_INVALID_ACCOUNT_NAME:
                return NERR_BadUsername;

        case STATUS_INVALID_DOMAIN_ROLE:
        case STATUS_INVALID_SERVER_STATE:
        case STATUS_BACKUP_CONTROLLER:
                return NERR_NotPrimary;

        case STATUS_INVALID_DOMAIN_STATE:
                return NERR_ACFNotLoaded;

        case STATUS_MEMBER_IN_GROUP:
                return NERR_UserInGroup;

        case STATUS_MEMBER_NOT_IN_GROUP:
                return NERR_UserNotInGroup;

        case STATUS_NONE_MAPPED:
        case STATUS_NO_SUCH_GROUP:
                return NERR_GroupNotFound;

        case STATUS_SPECIAL_GROUP:
        case STATUS_MEMBERS_PRIMARY_GROUP:
                return NERR_SpeGroupOp;

        case STATUS_USER_EXISTS:
                return NERR_UserExists;

        case STATUS_NO_SUCH_USER:
                return NERR_UserNotFound;

        case STATUS_PRIVILEGE_NOT_HELD:
                return ERROR_ACCESS_DENIED;

        case STATUS_LOGON_SERVER_CONFLICT:
                return NERR_LogonServerConflict;

        case STATUS_TIME_DIFFERENCE_AT_DC:
                return NERR_TimeDiffAtDC;

        case STATUS_SYNCHRONIZATION_REQUIRED:
                return NERR_SyncRequired;

        case STATUS_WRONG_PASSWORD_CORE:
                return NERR_BadPasswordCore;

        case STATUS_DOMAIN_CONTROLLER_NOT_FOUND:
                return NERR_DCNotFound;

        case STATUS_PASSWORD_RESTRICTION:
                return NERR_PasswordTooShort;

        case STATUS_ALREADY_DISCONNECTED:
                return NERR_Success;

        default:

            //
            // Use the system routine to do the mapping to ERROR_ codes.
            //

#ifndef WIN32_CHICAGO

            error = RtlNtStatusToDosError( NtStatus );

            if ( error != (NET_API_STATUS)NtStatus ) {
                return error;
            }

#endif  // WIN32_CHICAGO

            //
            // Could not map the NT status to anything appropriate.
            //
#if DBG
            DbgPrint( "   Unmapped NT status is " FORMAT_NTSTATUS "\n", NtStatus);
#endif
            return NERR_InternalError;
    }

} // NetpNtStatusToApiStatus



//
// Map of Network (DOS) status codes to NT status codes
//
DBGSTATIC
struct {
    NET_API_STATUS NetStatus;
    NTSTATUS NtStatus;
} ErrorMap[] =
{
    { NERR_Success, STATUS_SUCCESS },
    { ERROR_ACCESS_DENIED, STATUS_ACCESS_DENIED},
    { ERROR_ADAP_HDW_ERR, STATUS_ADAPTER_HARDWARE_ERROR},
    { ERROR_ALREADY_EXISTS, STATUS_OBJECT_NAME_COLLISION},
    { ERROR_ARITHMETIC_OVERFLOW, STATUS_INTEGER_OVERFLOW},
    { ERROR_BAD_DEV_TYPE, STATUS_BAD_DEVICE_TYPE},
    { ERROR_BAD_EXE_FORMAT, STATUS_INVALID_IMAGE_FORMAT},
    { ERROR_BAD_LENGTH, STATUS_DATA_ERROR},
    { ERROR_BAD_NETPATH, STATUS_BAD_NETWORK_PATH},
    { ERROR_BAD_NET_NAME, STATUS_BAD_NETWORK_NAME},
    { ERROR_BAD_NET_RESP, STATUS_INVALID_NETWORK_RESPONSE},
    { ERROR_BAD_PATHNAME, STATUS_OBJECT_PATH_SYNTAX_BAD},
    { ERROR_BAD_PIPE, STATUS_INVALID_PIPE_STATE},
    { ERROR_BAD_REM_ADAP, STATUS_BAD_REMOTE_ADAPTER},
    { ERROR_BUFFER_OVERFLOW, STATUS_BUFFER_OVERFLOW},
    { ERROR_BUSY, STATUS_DEVICE_BUSY},
    { ERROR_CRC, STATUS_CRC_ERROR},
    { ERROR_CURRENT_DIRECTORY, STATUS_DIRECTORY_NOT_EMPTY},
    { ERROR_DEV_NOT_EXIST, STATUS_DEVICE_DOES_NOT_EXIST},
    { ERROR_DIRECTORY, STATUS_NOT_A_DIRECTORY},
    { ERROR_DISK_FULL, STATUS_DISK_FULL},
    { ERROR_DUP_NAME, STATUS_DUPLICATE_NAME},
    { ERROR_EAS_DIDNT_FIT, STATUS_EA_TOO_LARGE},
    { ERROR_EAS_NOT_SUPPORTED, STATUS_EAS_NOT_SUPPORTED},
    { ERROR_FILE_NOT_FOUND, STATUS_NO_SUCH_FILE},
    { ERROR_GEN_FAILURE, STATUS_UNSUCCESSFUL},
    { ERROR_HANDLE_EOF, STATUS_END_OF_FILE},
    { ERROR_INVALID_ADDRESS, STATUS_MEMORY_NOT_ALLOCATED},
    { ERROR_INVALID_EA_NAME, STATUS_INVALID_EA_NAME},
    { ERROR_INVALID_FUNCTION, STATUS_NOT_IMPLEMENTED},
    { ERROR_INVALID_HANDLE, STATUS_INVALID_HANDLE},
    { ERROR_INVALID_NAME, STATUS_OBJECT_NAME_INVALID},
    { ERROR_INVALID_PARAMETER, STATUS_INVALID_PARAMETER},
    { ERROR_INVALID_PASSWORD, STATUS_WRONG_PASSWORD},
    { ERROR_IO_PENDING, STATUS_PENDING},
    { ERROR_LOCK_VIOLATION, STATUS_LOCK_NOT_GRANTED},
    { ERROR_LOGON_TYPE_NOT_GRANTED, STATUS_LOGON_TYPE_NOT_GRANTED},
    { ERROR_NETNAME_DELETED, STATUS_NETWORK_NAME_DELETED},
    { ERROR_NETWORK_ACCESS_DENIED, STATUS_NETWORK_ACCESS_DENIED},
    { ERROR_NETWORK_BUSY, STATUS_NETWORK_BUSY},
    { ERROR_NETWORK_UNREACHABLE, STATUS_NETWORK_UNREACHABLE},
    { ERROR_NET_WRITE_FAULT, STATUS_NET_WRITE_FAULT},
    { ERROR_NOACCESS, STATUS_ACCESS_VIOLATION},
    { ERROR_NOT_DOS_DISK, STATUS_DISK_CORRUPT_ERROR},
    { ERROR_NOT_ENOUGH_MEMORY, STATUS_NO_MEMORY},
    { ERROR_NOT_LOCKED, STATUS_RANGE_NOT_LOCKED},
    { ERROR_NOT_OWNER, STATUS_MUTANT_NOT_OWNED},
    { ERROR_NOT_READY, STATUS_DEVICE_OFF_LINE},
    { ERROR_NOT_SAME_DEVICE, STATUS_NOT_SAME_DEVICE},
    { ERROR_NOT_SUPPORTED, STATUS_NOT_SUPPORTED},
    { ERROR_NO_DATA, STATUS_PIPE_CLOSING},
    { ERROR_NO_MORE_FILES, STATUS_NO_MORE_FILES},
    { ERROR_NO_MORE_ITEMS, STATUS_NO_MORE_EAS},
    { ERROR_NO_SPOOL_SPACE, STATUS_NO_SPOOL_SPACE},
    { ERROR_OUT_OF_PAPER, STATUS_DEVICE_PAPER_EMPTY},
    { ERROR_PATH_NOT_FOUND, STATUS_OBJECT_PATH_NOT_FOUND},
    { ERROR_PIPE_BUSY, STATUS_PIPE_NOT_AVAILABLE},
    { ERROR_PIPE_NOT_CONNECTED, STATUS_PIPE_DISCONNECTED},
    { ERROR_PRINTQ_FULL, STATUS_PRINT_QUEUE_FULL},
    { ERROR_PRINT_CANCELLED, STATUS_PRINT_CANCELLED},
    { ERROR_PROC_NOT_FOUND, STATUS_PROCEDURE_NOT_FOUND},
    { ERROR_REDIR_PAUSED, STATUS_REDIRECTOR_PAUSED},
    { ERROR_REM_NOT_LIST, STATUS_REMOTE_NOT_LISTENING},
    { ERROR_REQ_NOT_ACCEP, STATUS_REQUEST_NOT_ACCEPTED},
    { ERROR_SECTOR_NOT_FOUND, STATUS_NONEXISTENT_SECTOR},
    { ERROR_SEM_TIMEOUT, STATUS_IO_TIMEOUT},
    { ERROR_SHARING_PAUSED, STATUS_SHARING_PAUSED},
    { ERROR_SHARING_VIOLATION, STATUS_SHARING_VIOLATION},
    { ERROR_SWAPERROR, STATUS_IN_PAGE_ERROR},
    { ERROR_TOO_MANY_CMDS, STATUS_TOO_MANY_COMMANDS},
    { ERROR_TOO_MANY_NAMES, STATUS_TOO_MANY_NAMES},
    { ERROR_TOO_MANY_OPEN_FILES, STATUS_TOO_MANY_OPENED_FILES},
    { ERROR_TOO_MANY_POSTS, STATUS_SEMAPHORE_LIMIT_EXCEEDED},
    { ERROR_TOO_MANY_SESS, STATUS_TOO_MANY_SESSIONS},
    { ERROR_UNEXP_NET_ERR, STATUS_UNEXPECTED_NETWORK_ERROR},
    { ERROR_VC_DISCONNECTED, STATUS_VIRTUAL_CIRCUIT_CLOSED},
    { ERROR_WRONG_DISK, STATUS_WRONG_VOLUME},
    { ERROR_NETLOGON_NOT_STARTED, STATUS_NETLOGON_NOT_STARTED},
    { ERROR_ACCOUNT_EXPIRED, STATUS_ACCOUNT_EXPIRED},
    { ERROR_ACCOUNT_LOCKED_OUT, STATUS_ACCOUNT_LOCKED_OUT},
    { ERROR_PASSWORD_MUST_CHANGE, STATUS_PASSWORD_MUST_CHANGE },
    { ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT, STATUS_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT},
    { ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT, STATUS_NOLOGON_WORKSTATION_TRUST_ACCOUNT},
    { ERROR_NOLOGON_SERVER_TRUST_ACCOUNT, STATUS_NOLOGON_SERVER_TRUST_ACCOUNT},
    { ERROR_DOMAIN_TRUST_INCONSISTENT, STATUS_DOMAIN_TRUST_INCONSISTENT},
    { ERROR_INVALID_DOMAIN_ROLE, STATUS_INVALID_DOMAIN_ROLE },
    { NERR_AccountExpired, STATUS_ACCOUNT_EXPIRED},
    { NERR_ACFNotLoaded, STATUS_INVALID_DOMAIN_STATE},
    { NERR_ACFNoRoom, STATUS_INTERNAL_DB_ERROR},
    { NERR_BadPassword, STATUS_WRONG_PASSWORD},
    { NERR_BadUsername, STATUS_INVALID_ACCOUNT_NAME},
    { NERR_BufTooSmall, STATUS_BUFFER_TOO_SMALL},
    { NERR_CanNotGrowUASFile, STATUS_INTERNAL_DB_ERROR},
    { NERR_DevInUse, STATUS_CONNECTION_IN_USE},
    { NERR_GroupExists, STATUS_GROUP_EXISTS},
    { NERR_GroupNotFound, STATUS_NONE_MAPPED},
    { NERR_InvalidDatabase, STATUS_INTERNAL_DB_CORRUPTION},
    { NERR_InvalidLogonHours, STATUS_INVALID_LOGON_HOURS},
    { NERR_InvalidWorkstation, STATUS_INVALID_WORKSTATION},
    { NERR_NetNotStarted, STATUS_REDIRECTOR_NOT_STARTED},
    { NERR_NotPrimary, STATUS_BACKUP_CONTROLLER},
    { NERR_OpenFiles, STATUS_FILES_OPEN},
    { NERR_PasswordExpired, STATUS_PASSWORD_EXPIRED},
    { NERR_SpeGroupOp, STATUS_SPECIAL_GROUP},
    { NERR_UserExists, STATUS_USER_EXISTS},
    { NERR_UserInGroup, STATUS_MEMBER_IN_GROUP},
    { NERR_UserNotInGroup, STATUS_MEMBER_NOT_IN_GROUP},
    { NERR_UserNotFound, STATUS_NO_SUCH_USER },
    { NERR_LogonServerConflict, STATUS_LOGON_SERVER_CONFLICT},
    { NERR_TimeDiffAtDC, STATUS_TIME_DIFFERENCE_AT_DC},
    { NERR_SyncRequired, STATUS_SYNCHRONIZATION_REQUIRED},
    { NERR_DCNotFound, STATUS_DOMAIN_CONTROLLER_NOT_FOUND},
    { NERR_WkstaNotStarted, RPC_NT_SERVER_UNAVAILABLE },
    { NERR_ServerNotStarted, RPC_NT_SERVER_UNAVAILABLE },
    { NERR_ServiceNotInstalled, RPC_NT_SERVER_UNAVAILABLE },
    { NERR_PasswordTooShort, STATUS_PASSWORD_RESTRICTION },
    { NERR_PasswordCantChange, STATUS_PASSWORD_RESTRICTION },
    { NERR_PasswordTooRecent, STATUS_PASSWORD_RESTRICTION },
};


NTSTATUS
NetpApiStatusToNtStatus(
    NET_API_STATUS NetStatus
    )
/*++

Routine Description:

    Convert a Network (DOS) status code to the NT equivalent.

Arguments:

    NetStatus - The Network status code to convert

Return Value:

    The corresponding NT status code.

--*/
{
    DWORD i;

    //
    // Loop trying to find the matching status code.
    //

    for ( i=0; i<sizeof(ErrorMap) / sizeof(ErrorMap[0]); i++) {
        if (ErrorMap[i].NetStatus == NetStatus) {
            return ErrorMap[i].NtStatus;
        }
    }

    return STATUS_INTERNAL_ERROR;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\pathtype.c ===
/*++

Copyright (c) 1989-92  Microsoft Corporation

Module Name:

    pathtype.c

Abstract:

    The NetpPathType routine attempts to determine the type of a path
    Net path type routines:

        NetpwPathType
        (TokenAdvance)
        (DeviceTokenToDeviceType)
        (SysnameTokenToSysnameType)
        (TypeParseMain)
        (TypeParseLeadSlashName)
        (TypeParseUNCName)
        (TypeParseOneLeadSlashName)
        (TypeParseNoLeadSlashName)
        (TypeParseRelPath)
        (TypeParseDeviceName)
        (TypeParseMailslotPath)
        (TypeParseAbsPath)
        (TypeParseUNCPath)
        (TypeParseSysPath)
        (TypeParseDevPath)
        (TypeParseOptSlash)
        (TypeParseOptColon)
        (TypeParseOptRelPath)

Author:

    Danny Glasser (dannygl) 16 June 1989

Revision History:

    01-Dec-1992 JohnRo
        RAID 4371: probable device canon bug.
        Use NetpKdPrint instead of NT-specific version.

--*/

#include "nticanon.h"

#define PATHLEN1_1 128      // Lanman 1.0 path len ((ie OS2 1.1/FAT))

//
// PARSER_PARMS - A structure containing the parameters passed to each
//      of the parser functions.  We put all of these parameters in a
//      structure so that they're not all separate function parameters.
//      This saves stack space and makes it easier to change the parameter
//      format, at the expense of re-entrancy.
//

typedef struct
{
    LPDWORD PathType;   /* Pointer to path type */
    LPTSTR  Token;      /* Pointer to the front of the current token */
    LPTSTR  TokenEnd;   /* Pointer to the end of the current token */
    DWORD   TokenType;  /* Type of the current token */
    DWORD   Flags;      /* Flags to determine function operation */
} PARSER_PARMS;

typedef PARSER_PARMS* PPARSER_PARMS;

//
// Values for <Flags> in PARSER_PARMS
//

#define PPF_MATCH_OPTIONAL      0x00000001L
#define PPF_8_DOT_3             0x00000002L

#define PPF_RESERVED            (~(PPF_MATCH_OPTIONAL | PPF_8_DOT_3))

//
// data
//

DWORD   cbMaxPathLen        = MAX_PATH-1;
DWORD   cbMaxPathCompLen    = MAX_PATH;     // ??

//
// local prototypes
//

STATIC  DWORD   TokenAdvance(PARSER_PARMS far *parms);
STATIC  DWORD   DeviceTokenToDeviceType(ULONG TokenType);
STATIC  DWORD   SysnameTokenToSysnameType(ULONG TokenType);

STATIC  DWORD   TypeParseMain               (PPARSER_PARMS parms);
STATIC  DWORD   TypeParseLeadSlashName      (PPARSER_PARMS parms);
STATIC  DWORD   TypeParseUNCName            (PPARSER_PARMS parms);
STATIC  DWORD   TypeParseOneLeadSlashName   (PPARSER_PARMS parms);
STATIC  DWORD   TypeParseNoLeadSlashName    (PPARSER_PARMS parms);
STATIC  DWORD   TypeParseRelPath            (PPARSER_PARMS parms);
STATIC  DWORD   TypeParseDeviceName         (PPARSER_PARMS parms);
STATIC  DWORD   TypeParseMailslotPath       (PPARSER_PARMS parms);
STATIC  DWORD   TypeParseAbsPath            (PPARSER_PARMS parms);
STATIC  DWORD   TypeParseUNCPath            (PPARSER_PARMS parms);
STATIC  DWORD   TypeParseSysPath            (PPARSER_PARMS parms);
STATIC  DWORD   TypeParseDevPath            (PPARSER_PARMS parms);
STATIC  DWORD   TypeParseOptSlash           (PPARSER_PARMS parms);
STATIC  DWORD   TypeParseOptColon           (PPARSER_PARMS parms);
STATIC  DWORD   TypeParseOptRelPath         (PPARSER_PARMS parms);

//
// some commonly occurring operations as macros to improve readability
//

#define ADVANCE_TOKEN() if (RetVal = TokenAdvance(parms)) {return RetVal;}
#define TURN_ON(flag)   (parms->Flags |= (PPF_##flag))
#define TURN_OFF(flag)  (parms->Flags &= (~PPF_##flag))
#define PARSE_NULL()    if (parms->TokenType & TOKEN_TYPE_EOS) {\
                            return 0;\
                        } else {\
                            return ERROR_INVALID_NAME;\
                        }

//
// routines
//


NET_API_STATUS
NetpwPathType(
    IN  LPTSTR  PathName,
    OUT LPDWORD PathType,
    IN  DWORD   Flags
    )

/*++

Routine Description:

    NetpPathType parses the specified pathname, determining that
    it is a valid pathname and determining its path type.  Path type
    values are defined as ITYPE_* manifest constants in ICANON.H.

    If this call is remoted and the remote server returns
    NERR_InvalidAPI (meaning that the server doesn't know about this
    function, i.e. it's a LM 1.0D server), the work is done locally
    with the OLDPATHS bits set.

Arguments:

    PathName    - The pathname to validate and type.

    PathType    - The place to store the type.

    Flags       - Flags to determine operation.  Currently defined
                  values are:

                        rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrro

                  where:

                    r = Reserved.  MBZ.

                    o = If set, the function uses old-style pathname rules
                        (128-byte paths, 8.3 components) when validating the
                        pathname.  This flag gets set automatically on DOS
                        and OS/2 1.1 systems.

Return Value:

    0 if successful.
    The error number (> 0) if unsuccessful.

    Possible error returns include:

        ERROR_INVALID_PARAMETER
        ERROR_INVALID_NAME
        NERR_BufTooSmall

    any errors returned by the API functions called by this function.

--*/

{
    NET_API_STATUS RetVal;
    DWORD   Len;
    PARSER_PARMS parms;

#ifdef CANONDBG
    NetpKdPrint(("NetpwPathType\n"));
#endif

    *PathType = 0;

    if (Flags & INPT_FLAGS_RESERVED) {
        return ERROR_INVALID_PARAMETER;
    }

    if (ARGUMENT_PRESENT(PathName)) {
        Len = (DWORD)STRLEN(PathName);
    } else {
        Len = 0;
    }
    if (!Len || (Len > MAX_PATH - 1)) {
        return ERROR_INVALID_NAME;
    }

    //
    // Initialize parser parameter structure
    //

    parms.PathType = PathType;
    parms.Flags = 0L;
    if (Flags & INPT_FLAGS_OLDPATHS) {
        parms.Flags |= PPF_8_DOT_3;
    }

    parms.Token = PathName;

    RetVal = GetToken(
        parms.Token,
        &parms.TokenEnd,
        &parms.TokenType,
        (parms.Flags & PPF_8_DOT_3) ? GTF_8_DOT_3 : 0L
        );

    if (RetVal) {
        return RetVal;
    }

    //
    // Now call the parser
    //

    RetVal = TypeParseMain(&parms);

    if (RetVal) {
        return RetVal;
    }

    //
    // If we get here, the parsing operation succeeded.  We return 0
    // unless the path type is still 0, in which case we return NERR_CantType.
    //
    //

    return *PathType ? NERR_Success : NERR_CantType;
}


STATIC DWORD TokenAdvance(PPARSER_PARMS parms)
{
    parms->Token = parms->TokenEnd;
    return GetToken(parms->Token,
                    &parms->TokenEnd,
                    &parms->TokenType,
                    (parms->Flags & PPF_8_DOT_3) ? GTF_8_DOT_3 : 0L
                    );
}

STATIC DWORD DeviceTokenToDeviceType(DWORD TokenType)
{
    DWORD   DeviceType = 0;

    if (TokenType & (TOKEN_TYPE_LPT | TOKEN_TYPE_PRN)) {
        DeviceType = ITYPE_LPT;
    } else if (TokenType & (TOKEN_TYPE_COM | TOKEN_TYPE_AUX)) {
        DeviceType = ITYPE_COM;
    } else if (TokenType & TOKEN_TYPE_CON) {
        DeviceType = ITYPE_CON;
    } else if (TokenType & TOKEN_TYPE_NUL) {
        DeviceType = ITYPE_NUL;
    }
    return DeviceType;
}

STATIC DWORD SysnameTokenToSysnameType(DWORD TokenType)
{
    DWORD   SysnameType = 0;

    if (TokenType & TOKEN_TYPE_MAILSLOT) {
        SysnameType = ITYPE_SYS_MSLOT;
    } else if (TokenType & TOKEN_TYPE_PIPE) {
        SysnameType = ITYPE_SYS_PIPE;
    } else if (TokenType & TOKEN_TYPE_PRINT) {
        SysnameType = ITYPE_SYS_PRINT;
    } else if (TokenType & TOKEN_TYPE_COMM) {
        SysnameType = ITYPE_SYS_COMM;
    } else if (TokenType & TOKEN_TYPE_SEM) {
        SysnameType = ITYPE_SYS_SEM;
    } else if (TokenType & TOKEN_TYPE_SHAREMEM) {
        SysnameType = ITYPE_SYS_SHMEM;
    } else if (TokenType & TOKEN_TYPE_QUEUES) {
        SysnameType = ITYPE_SYS_QUEUE;
    }
    return SysnameType;
}


STATIC DWORD TypeParseMain(PPARSER_PARMS parms)
{
    DWORD   RetVal = NERR_CantType;

    //
    // <MAIN> --> <slash> <leadslashname> <null>
    //

    if (parms->TokenType & TOKEN_TYPE_SLASH) {
        ADVANCE_TOKEN();
        TURN_OFF(MATCH_OPTIONAL);
        if (RetVal = TypeParseLeadSlashName(parms)) {
            return RetVal;
        }
        PARSE_NULL();
    } else {

        //
        // <MAIN> --> <noleadslashname> <null>
        //

        if (RetVal = TypeParseNoLeadSlashName(parms)) {
            if (RetVal == NERR_CantType) {

                //
                // Return ERROR_INVALID_NAME if MATCH_OPTIONAL isn't set
                //

                if (!(parms->Flags & PPF_MATCH_OPTIONAL)) {
                    RetVal = ERROR_INVALID_NAME;
                }
            }
            return RetVal;
        }
        PARSE_NULL();
    }
}


STATIC DWORD TypeParseLeadSlashName(PPARSER_PARMS parms)
{
    DWORD   RetVal = NERR_CantType;
    BOOL    fSetMatchOptional = FALSE;

    //
    // <leadslashname> --> <slash> <uncname>
    //

    if (parms->TokenType & TOKEN_TYPE_SLASH) {
        ADVANCE_TOKEN();
        TURN_OFF(MATCH_OPTIONAL);
        return TypeParseUNCName(parms);
    } else {

        //
        // <leadslashname> --> <oneleadslashname>
        //

        //
        // Turn on MATCH_OPTIONAL flag (if it isn't already on)
        //

        if (!(parms->Flags & PPF_MATCH_OPTIONAL)) {
            fSetMatchOptional = TRUE;
            TURN_ON(MATCH_OPTIONAL);
        }
        RetVal = TypeParseOneLeadSlashName(parms);
        if (fSetMatchOptional) {
            TURN_OFF(MATCH_OPTIONAL);
        }
        if (RetVal != NERR_CantType) {
            return RetVal;
        }
    }

    //
    // <leadslashname> --> {}
    //

    if (RetVal == NERR_CantType) {

        //
        // There's nothing after the slash, but it's still an absolute path
        //

        *parms->PathType |= (ITYPE_PATH | ITYPE_ABSOLUTE);
        RetVal = 0;
    }
    return RetVal;
}

STATIC DWORD TypeParseUNCName(PPARSER_PARMS parms)
{
    DWORD   RetVal = NERR_CantType;

    if( parms->TokenType & TOKEN_TYPE_DOT ) {

        //
        // Take care of paths like //./stuff\stuff\..
        //

        ADVANCE_TOKEN();

        if( parms->TokenType & TOKEN_TYPE_SLASH ) {

            //
            // If it starts with //./, then let anything else through
            //

            *parms->PathType |= ITYPE_PATH | ITYPE_ABSOLUTE | ITYPE_DPATH;

            //
            // Chew up the rest of the input.
            //
            while( TokenAdvance(parms) == 0 ) {
                if( parms->TokenType & TOKEN_TYPE_EOS ) {
                    break;
                }
            }
            
            return 0;
        }

        return ERROR_INVALID_NAME;
    }

    //
    // Set the UNC type bit
    //

    *parms->PathType |= ITYPE_UNC;

    //
    // We turn off 8.3 checking for UNC names, because we don't want to
    // impose this restriction on remote names.
    //

    TURN_OFF(8_DOT_3);

    //
    // <uncname> --> <computername> <uncpath>
    //

    if (parms->TokenType & TOKEN_TYPE_COMPUTERNAME) {
        ADVANCE_TOKEN();
        TURN_OFF(MATCH_OPTIONAL);
        if (RetVal = TypeParseUNCPath(parms)) {
            return RetVal;
        }
    } else if (parms->TokenType & TOKEN_TYPE_WILDONE) {

        //
        // <uncname> --> "*" <mailslotpath>
        //

        //
        // Set the wildcard type bit
        //

        *parms->PathType |= ITYPE_WILD;
        ADVANCE_TOKEN();
        TURN_OFF(MATCH_OPTIONAL);
        if (RetVal = TypeParseMailslotPath(parms)) {
            return RetVal;
        }
    }
    if (RetVal == 0) {

        //
        // HACK - Since ITYPE_PATH and ITYPE_ABSOLUTE are not for UNC paths,
        //        we need to turn them off here.
        //

        *parms->PathType &= ~(ITYPE_PATH | ITYPE_ABSOLUTE);
    } else if (RetVal == NERR_CantType) {
        RetVal = (parms->Flags & PPF_MATCH_OPTIONAL)
            ? NERR_CantType
            : ERROR_INVALID_NAME;
    }
    return RetVal;
}

STATIC DWORD TypeParseOneLeadSlashName(PPARSER_PARMS parms)
{
    DWORD   RetVal = NERR_CantType;
    BOOL    fDevice = FALSE;

    //
    // <oneleadslashname> --> <sysname> <syspath>
    //

    if (parms->TokenType & TOKEN_TYPE_SYSNAME) {

        //
        // Set the appropriate Sysname type bits
        //

        *parms->PathType |= SysnameTokenToSysnameType(parms->TokenType);
        ADVANCE_TOKEN();
        TURN_OFF(MATCH_OPTIONAL);
        RetVal = TypeParseSysPath(parms);
    } else if (parms->TokenType & TOKEN_TYPE_MAILSLOT) {

        //
        // <oneleadslashname> --> <mailslotname> <syspath>
        //

        //
        // Set the appropriate Mailslot type bits
        //

        *parms->PathType |= ITYPE_SYS_MSLOT;
        ADVANCE_TOKEN();
        TURN_OFF(MATCH_OPTIONAL);
        RetVal = TypeParseSysPath(parms);
    } else if (parms->TokenType & TOKEN_TYPE_DEV) {

        //
        // <oneleadslashname> --> <deviceprefix> <devpath>
        //

        //
        // Set the device flag (for use below)
        //

        fDevice = TRUE;
        ADVANCE_TOKEN();
        TURN_OFF(MATCH_OPTIONAL);
        RetVal = TypeParseDevPath(parms);
    } else {

        //
        // <oneleadslashname> --> <relpath>
        //

        RetVal = TypeParseRelPath(parms);
        if (RetVal == NERR_CantType) {

            //
            // Return ERROR_INVALID_NAME if MATCH_OPTIONAL isn't set
            //

            if (!(parms->Flags & PPF_MATCH_OPTIONAL)) {
                RetVal = ERROR_INVALID_NAME;
            }
        }
    }

    //
    // If we were able to determine the type of the object and it isn't
    // a device, we know that we have an absolute path, so we turn on the
    // absolute type bit.
    //

    if (! RetVal && ! fDevice) {
        *parms->PathType |= ITYPE_ABSOLUTE;
    }
    return RetVal;
}

STATIC DWORD TypeParseNoLeadSlashName(PPARSER_PARMS parms)
{
    DWORD   RetVal = NERR_CantType;
    LPTSTR  PreviousToken;
    DWORD   ulPreviousTokenType;
    DWORD   ulSavedType;

    //
    // <noleadslashname> --> <driveletter> ":" <optslash> <optrelpath>
    //
    // WARNING:  Since a drive letter can also be a component name, it's
    //           impossible to determine which production to use without
    //           looking at the next token (to see if it's ":").  We have
    //           to cheat here to get around this hole in the grammar.
    //

    if (parms->TokenType & TOKEN_TYPE_DRIVE) {

        //
        // Save the current token pointer and type (in case we need to backtrack)
        //

        PreviousToken = parms->Token;
        ulPreviousTokenType = parms->TokenType;
        ADVANCE_TOKEN();

        //
        // Parse ":"; restore token if it fails, otherwise proceed
        //

        if (! (parms->TokenType & TOKEN_TYPE_COLON)) {
            parms->TokenEnd = parms->Token;
            parms->Token = PreviousToken;
            parms->TokenType = ulPreviousTokenType;
        } else {
            TURN_OFF(MATCH_OPTIONAL);

            //
            // We save the object type here; if it hasn't changed after
            // the calls to OptSlash and OptRelPath, then we know we have
            // a disk device only.  If it does change, we know he have a
            // drive path.  In either case, we use this information to
            // set the appropriate type bits.
            //

            ulSavedType = *parms->PathType;
            ADVANCE_TOKEN();
            if (RetVal = TypeParseOptSlash(parms)) {
                return RetVal;
            }
            if (RetVal = TypeParseOptRelPath(parms)) {
                return RetVal;
            }

            //
            // Set type bits based on whether the calls to OptSlash and
            // OptRelpath changed the type.
            //

            *parms->PathType |= (ulSavedType == *parms->PathType)
                ? (ITYPE_DEVICE | ITYPE_DISK)
                : ITYPE_DPATH;
            return 0;
        }
    } else if (parms->TokenType & TOKEN_TYPE_LOCALDEVICE) {

        //
        // <noleadslashname> --> <localdevice> <optcolon>
        //

        //
        // Set the appropriate Device type bits
        //

        *parms->PathType |= ITYPE_DEVICE |
                                 DeviceTokenToDeviceType(parms->TokenType);

        ADVANCE_TOKEN();
        TURN_OFF(MATCH_OPTIONAL);
        return TypeParseOptColon(parms);
    }

    //
    // <noleadslashname> --> <relpath>
    //

    RetVal = TypeParseRelPath(parms);

    if (RetVal == NERR_CantType) {

        //
        // Return ERROR_INVALID_NAME if MATCH_OPTIONAL isn't set
        //

        if (!(parms->Flags & PPF_MATCH_OPTIONAL)) {
            RetVal = ERROR_INVALID_NAME;
        }
    }
    return RetVal;
}

STATIC DWORD TypeParseRelPath(PPARSER_PARMS parms)
{
    DWORD RetVal = NERR_CantType;

    //
    // <relpath> --> <component> <abspath>
    //

    if (parms->TokenType & TOKEN_TYPE_COMPONENT) {

        //
        // Set the path bit
        //

        *parms->PathType |= ITYPE_PATH;

        //
        // Set the wildcard type bit, if appropriate
        //

        if (parms->TokenType & TOKEN_TYPE_WILDCARD) {
            *parms->PathType |= ITYPE_WILD;
        }

        ADVANCE_TOKEN();
        TURN_OFF(MATCH_OPTIONAL);
        return TypeParseAbsPath(parms);
    } else {
        return (parms->Flags & PPF_MATCH_OPTIONAL)
            ? NERR_CantType
            : ERROR_INVALID_NAME;
    }
}

STATIC DWORD TypeParseDeviceName(PPARSER_PARMS parms)
{
    DWORD   RetVal = NERR_CantType;

    //
    // <devicename> --> <localdevice>
    //

    if (parms->TokenType & TOKEN_TYPE_LOCALDEVICE) {

        //
        // Set the appropriate Device type bits
        //

        *parms->PathType |= DeviceTokenToDeviceType(parms->TokenType);
        ADVANCE_TOKEN();
        TURN_OFF(MATCH_OPTIONAL);
        return 0;
    } else if (parms->TokenType & TOKEN_TYPE_COMPONENT) {

        //
        // <devicename> --> <component>
        //

        ADVANCE_TOKEN();
        TURN_OFF(MATCH_OPTIONAL);
        return 0;
    } else {
        return (parms->Flags & PPF_MATCH_OPTIONAL)
            ? NERR_CantType
            : ERROR_INVALID_NAME;
    }
}

STATIC DWORD TypeParseMailslotPath(PPARSER_PARMS parms)
{
    DWORD RetVal = NERR_CantType;

    //
    // <mailslotpath> --> <slash> <mailslotname> <syspath>
    //

    if (parms->TokenType & TOKEN_TYPE_SLASH) {
        ADVANCE_TOKEN();
        TURN_OFF(MATCH_OPTIONAL);

        //
        // Parse <mailslotname>
        //

        if (! (parms->TokenType & TOKEN_TYPE_MAILSLOT)) {
            return ERROR_INVALID_NAME;
        }

        //
        // Set the appropriate Mailslot type bits
        //

        *parms->PathType |= ITYPE_SYS_MSLOT;
        ADVANCE_TOKEN();
        return TypeParseSysPath(parms);
    }

    //
    // <mailslotpath> --> {}
    //

    if (RetVal == NERR_CantType) {

        //
        // Since there's no mailslot path, this is a UNC wildcard compname
        //

        *parms->PathType |= ITYPE_COMPNAME;
        RetVal = 0;
    }
    return RetVal;
}

STATIC DWORD TypeParseAbsPath(PPARSER_PARMS parms)
{
    DWORD   RetVal = NERR_CantType;

    //
    // <abspath> --> <slash> <component> <abspath>
    //

    if (parms->TokenType & TOKEN_TYPE_SLASH) {
        ADVANCE_TOKEN();
        TURN_OFF(MATCH_OPTIONAL);

        //
        // Parse <component>
        //

        if (!(parms->TokenType & TOKEN_TYPE_COMPONENT)) {
            return ERROR_INVALID_NAME;
        }

        //
        // Set the wildcard type bit, if appropriate
        //

        if (parms->TokenType & TOKEN_TYPE_WILDCARD) {
            *parms->PathType |= ITYPE_WILD;
        }

        ADVANCE_TOKEN();
        return TypeParseAbsPath(parms);
    }

    //
    // <abspath> --> {}
    //

    if (RetVal == NERR_CantType) {
        RetVal = 0;
    }
    return RetVal;
}

STATIC DWORD TypeParseUNCPath(PPARSER_PARMS parms)
{
    DWORD   RetVal = NERR_CantType;

    //
    // <uncpath> --> <slash> <oneleadslashname>
    //

    if (parms->TokenType & TOKEN_TYPE_SLASH) {
        ADVANCE_TOKEN();
        TURN_OFF(MATCH_OPTIONAL);
        //
        // Turn off the TOKEN_TYPE_DEV flag.  If we got to this function,
        // it means that we are working on the share name portion of
        // a UNC style name.  We want to allow a share called "Dev".
        //
        parms->TokenType &= ~TOKEN_TYPE_DEV;

        return TypeParseOneLeadSlashName(parms);
    }

    //
    // <uncpath> --> {}
    //

    if (RetVal == NERR_CantType) {

        //
        // Since there's no UNC path, this is a UNC computername
        //

        *parms->PathType |= ITYPE_COMPNAME;
        RetVal = 0;
    }
    return RetVal;
}

STATIC DWORD TypeParseSysPath(PPARSER_PARMS parms)
{
    DWORD   RetVal = NERR_CantType;

    //
    // <syspath> --> <slash> <relpath>
    //

    if (parms->TokenType & TOKEN_TYPE_SLASH) {
        ADVANCE_TOKEN();
        TURN_OFF(MATCH_OPTIONAL);
        return TypeParseRelPath(parms);
    }

    //
    // <syspath> --> {}
    //

    if (RetVal == NERR_CantType) {

        //
        // If there's no Syspath, turn on the Meta and Path bits
        //

        *parms->PathType |= (ITYPE_META | ITYPE_PATH);
        RetVal = 0;
    }
    return RetVal;
}

STATIC DWORD TypeParseDevPath(PPARSER_PARMS parms)
{
    DWORD   RetVal = NERR_CantType;

    //
    // Set the appropriate Device type bit
    //

    *parms->PathType |= ITYPE_DEVICE;

    //
    // <devpath> --> <slash> <devicename>
    //

    if (parms->TokenType & TOKEN_TYPE_SLASH) {
        ADVANCE_TOKEN();
        TURN_OFF(MATCH_OPTIONAL);
        return TypeParseDeviceName(parms);
    }

    //
    // <devpath> --> {}
    //

    if (RetVal == NERR_CantType) {

        //
        // If there's no Devpath, turn on the Meta bit
        //

        *parms->PathType |= ITYPE_META;
        RetVal = 0;
    }
    return RetVal;
}

STATIC DWORD TypeParseOptSlash(PPARSER_PARMS parms)
{
    DWORD   RetVal = NERR_CantType;

    //
    // <optslash> --> <slash>
    //

    if (parms->TokenType & TOKEN_TYPE_SLASH) {

        //
        // This is an absolute path; set the type bits
        //

        *parms->PathType |= (ITYPE_ABSOLUTE | ITYPE_PATH);
        ADVANCE_TOKEN();
        TURN_OFF(MATCH_OPTIONAL);
        return 0;
    }

    //
    // <optslash> --> {}
    //

    if (RetVal == NERR_CantType) {
        RetVal = 0;
    }
    return RetVal;
}

STATIC DWORD TypeParseOptColon(PPARSER_PARMS parms)
{
    DWORD   RetVal = NERR_CantType;

    //
    // <optcolon> --> <colon>
    //

    if (parms->TokenType & TOKEN_TYPE_COLON) {
        ADVANCE_TOKEN();
        TURN_OFF(MATCH_OPTIONAL);
        return 0;
    }

    //
    // <optcolon> --> {}
    //

    if (RetVal == NERR_CantType) {
        RetVal = 0;
    }
    return RetVal;
}

STATIC DWORD TypeParseOptRelPath(PPARSER_PARMS parms)
{
    DWORD   RetVal = NERR_CantType;
    BOOL    fSetMatchOptional = FALSE;

    //
    // <optrelpath> --> <relpath>
    //

    //
    // Turn on MATCH_OPTIONAL flag (if it isn't already on)
    //

    if (!(parms->Flags & PPF_MATCH_OPTIONAL)) {
        fSetMatchOptional = TRUE;
        TURN_ON(MATCH_OPTIONAL);
    }
    RetVal = TypeParseRelPath(parms);
    if (fSetMatchOptional) {
        TURN_OFF(MATCH_OPTIONAL);
    }

    //
    // <optrelpath> --> {}
    //

    if (RetVal == NERR_CantType) {
        RetVal = 0;
    }
    return RetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\rdrfsctl.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    RdrFsCtl.c

Abstract:

    NetpRdrFsControlTree performs an FSCTL (file system control) operation
    on a given tree connection name.

Author:

    John Rogers (JohnRo) 26-Mar-1991

Environment:

    Only runs under NT; has an NT-specific interface (with Win32 types).
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    26-Mar-91 JohnRo
        Created.
    02-Apr-1991 JohnRo
        Moved NetpRdrFsControlTree to <netlibnt.h>.  Use IF_DEBUG and
        NetpNtStatusToApiStatus().
    10-Apr-1991 JohnRo
        Various changes suggested by LINT.
    16-Apr-1991 JohnRo
        Added a little more debug output.
    07-May-1991 JohnRo
        Implement UNICODE.  Avoid NET_API_FUNCTION.
    14-Nov-1991 JohnRo
        RAID 4407: "NET VIEW" to an NT server gives 2140.
        Made changes suggested by PC-LINT.  Use more FORMAT_ equates.
        Display unexpected create file error even if trace off.
    21-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.
    22-Sep-1992 JohnRo
        RAID 6739: Browser too slow when not logged into browsed domain.
    21-Jun-1993 JohnRo
        RAID 14180: NetServerEnum never returns (alignment bug in
        RxpConvertDataStructures).
        Also quiet some debug output if other machine just isn't there.
        Added tree name to unexpected error debug messages.
        Made changes suggested by PC-LINT 5.0
        Use NetpKdPrint() where possible.
        Use PREFIX_ equates.

--*/

// These must be included first:

#include <nt.h>                 // IN, etc.  (Needed by ntddnfs.h and others.)
#include <windef.h>             // LPVOID, etc.
#include <lmcons.h>             // NET_API_STATUS, etc.

// These may be included in any order:

#include <debuglib.h>           // IF_DEBUG().
#include <lmerr.h>              // NERR_Success, etc.
#include <names.h>              // NetpIsRemoteNameValid().
#include <netdebug.h>   // FORMAT_NTSTATUS, NetpKdPrint(), etc.
#include <netlib.h>             // NetpMemoryAllocate().
#include <netlibnt.h>           // My prototype.
#include <ntddnfs.h>            // DD_NFS_DEVICE_NAME, EA_NAME_ equates, etc.
#include <ntioapi.h>            // NtFsControlFile().
#include <ntrtl.h>              // Rtl APIs.
#include <ntstatus.h>           // NT_SUCCESS(), STATUS_PENDING, etc.
#include <prefix.h>     // PREFIX_ equates.
#include <tstr.h>               // STRCAT(), STRCPY(), STRLEN().
#include <lmuse.h>              // USE_IPC...
#include <align.h>              // ALIGN_xxx

NET_API_STATUS
NetpRdrFsControlTree(
    IN LPTSTR TreeName,
    IN LPTSTR TransportName OPTIONAL,
    IN DWORD ConnectionType,
    IN DWORD FsControlCode,
    IN LPVOID SecurityDescriptor OPTIONAL,
    IN LPVOID InputBuffer OPTIONAL,
    IN DWORD InputBufferSize,
    OUT LPVOID OutputBuffer OPTIONAL,
    IN DWORD OutputBufferSize,
    IN BOOL NoPermissionRequired
    )

/*++

Routine Description:

    NetpRdrFsControlTree performs a given FSCTL (file system control)
    on a given tree connection name.

Arguments:

    TreeName - Remote name to do fsctl to (in \\server\share format).

    FsControlCode - function code to pass to the redirector.  These are
        defined in <ntddnfs.h>.

    SecurityDescriptor - optionally points to a security descriptor to be
        used when creating the tree connection.

    InputBuffer - optionally points to a structure to be passed to the
        redirector.

    InputBufferSize - size of InputBuffer in bytes; must be zero if
        InputBuffer is a NULL pointer.

    OutputBuffer - optionally points to a structure to be filled in by the
        redirector.

    OutputBufferSize - size of OutputBuffer in bytes; must be zero if
        OutputBuffer is a NULL pointer.

    NoPermissionRequired - TRUE if this is a no permission required API.  (I.e.
        TRUE if the null session may be used.)

Return Value:

    NET_API_STATUS

--*/

{
    NET_API_STATUS ApiStatus;
    IO_STATUS_BLOCK iosb;
    NTSTATUS ntstatus;                      // Status from NT operations.
    OBJECT_ATTRIBUTES objattrTreeConn;      // Attrs for tree conn.
    LPTSTR pszTreeConn = NULL;              // See strTreeConn below.
    UNICODE_STRING ucTreeConn;
    HANDLE TreeConnHandle = NULL;

    PFILE_FULL_EA_INFORMATION EaBuffer = NULL;
    PFILE_FULL_EA_INFORMATION Ea;
    USHORT TransportNameSize = 0;
    ULONG EaBufferSize = 0;
    PWSTR UnicodeTransportName = NULL;
    BOOLEAN ImpersonatingAnonymous = FALSE;
    HANDLE CurrentToken = NULL;

    UCHAR EaNameDomainNameSize = (UCHAR) (ROUND_UP_COUNT(
                                             strlen(EA_NAME_DOMAIN) + sizeof(CHAR),
                                             ALIGN_WCHAR
                                             ) - sizeof(CHAR));

    UCHAR EaNamePasswordSize = (UCHAR) (ROUND_UP_COUNT(
                                             strlen(EA_NAME_PASSWORD) + sizeof(CHAR),
                                             ALIGN_WCHAR
                                             ) - sizeof(CHAR));

    UCHAR EaNameTransportNameSize = (UCHAR) (ROUND_UP_COUNT(
                                             strlen(EA_NAME_TRANSPORT) + sizeof(CHAR),
                                             ALIGN_WCHAR
                                             ) - sizeof(CHAR));

    UCHAR EaNameTypeSize = (UCHAR) (ROUND_UP_COUNT(
                                        strlen(EA_NAME_TYPE) + sizeof(CHAR),
                                        ALIGN_DWORD
                                        ) - sizeof(CHAR));

    UCHAR EaNameUserNameSize = (UCHAR) (ROUND_UP_COUNT(
                                             strlen(EA_NAME_USERNAME) + sizeof(CHAR),
                                             ALIGN_WCHAR
                                             ) - sizeof(CHAR));

    USHORT TypeSize = sizeof(ULONG);




    IF_DEBUG(RDRFSCTL) {
        NetpKdPrint(( PREFIX_NETLIB
                "NetpRdrFsControlTree: entered, TreeName='"
                FORMAT_LPTSTR "', " FORMAT_LPTSTR " session.\n",
                TreeName,
                NoPermissionRequired ? TEXT("null") : TEXT("non-null") ));
    }

    if ((TreeName == NULL) || (TreeName[0] == 0)) {
        ApiStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    if (! NetpIsRemoteNameValid(TreeName)) {
        ApiStatus = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    //
    // Build NT-style name for what we're connecting to.  Note that there is
    // NOT a pair of backslashes anywhere in this name.
    //

    {
        DWORD NameSize =

            // /Device/LanManRedirector      /    server/share     \0
            ( ( STRLEN((LPTSTR)DD_NFS_DEVICE_NAME_U) + 1 + STRLEN(TreeName) + 1 ) )
            * sizeof(TCHAR);

        pszTreeConn = (LPTSTR)NetpMemoryAllocate( NameSize );
    }

    if (pszTreeConn == NULL) {
        ApiStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Build the tree connect name.
    //

    (void) STRCPY(pszTreeConn, (LPTSTR) DD_NFS_DEVICE_NAME_U);

    //
    // NOTE: We add 1, (not sizeof(TCHAR)) because pointer arithmetic is done
    // in terms of multiples of sizeof(*pointer), not bytes
    //

    (void) STRCAT(pszTreeConn, TreeName+1); // \server\share

    RtlInitUnicodeString(&ucTreeConn, pszTreeConn);

    IF_DEBUG(RDRFSCTL) {
        NetpKdPrint(( PREFIX_NETLIB
                "NetpRdrFsControlTree: UNICODE name is " FORMAT_LPWSTR
                ".\n", ucTreeConn.Buffer ));
    }



    //
    // Calculate the number of bytes needed for the EA buffer.
    // This may have the transport name.  For regular sessions, the user
    // name, password, and domain name are implicit.  For null sessions, we
    // must give 0-len user name, 0-len password, and 0-len domain name.
    //

    if (ARGUMENT_PRESENT(TransportName)) {
        ASSERT(ConnectionType == USE_IPC);

        UnicodeTransportName = TransportName;
        TransportNameSize = (USHORT) (wcslen(UnicodeTransportName) * sizeof(WCHAR));

        EaBufferSize += ROUND_UP_COUNT(
                            FIELD_OFFSET(FILE_FULL_EA_INFORMATION, EaName[0]) +
                            EaNameTransportNameSize + sizeof(CHAR) +
                            TransportNameSize,
                            ALIGN_DWORD
                            );
    }


    EaBufferSize += ((ULONG)FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0]))+
                    EaNameTypeSize + sizeof(CHAR) +
                    TypeSize;


    //
    // Allocate the EA buffer
    //

    if ((EaBuffer = NetpMemoryAllocate( EaBufferSize )) == NULL) {
        ApiStatus = ERROR_NOT_ENOUGH_MEMORY;
        goto Cleanup;
    }

    //
    // Fill-in the EA buffer.
    //

    RtlZeroMemory(EaBuffer, EaBufferSize);

    Ea = EaBuffer;

    if (ARGUMENT_PRESENT(TransportName)) {

        //
        // Copy the EA name into EA buffer.  EA name length does not
        // include the zero terminator.
        //
        strcpy(Ea->EaName, EA_NAME_TRANSPORT);
        Ea->EaNameLength = EaNameTransportNameSize;

        //
        // Copy the EA value into EA buffer.  EA value length does not
        // include the zero terminator.
        //
        (VOID) wcscpy(
            (LPWSTR) &(Ea->EaName[EaNameTransportNameSize + sizeof(CHAR)]),
            UnicodeTransportName
            );

        Ea->EaValueLength = TransportNameSize;

        Ea->NextEntryOffset = ROUND_UP_COUNT(
                                  FIELD_OFFSET( FILE_FULL_EA_INFORMATION, EaName[0]) +
                                  EaNameTransportNameSize + sizeof(CHAR) +
                                  TransportNameSize,
                                  ALIGN_DWORD
                                  );
        Ea->Flags = 0;

        (ULONG_PTR) Ea += Ea->NextEntryOffset;
    }




    //
    // Copy the EA for the connection type name into EA buffer.  EA name length
    // does not include the zero terminator.
    //
    strcpy(Ea->EaName, EA_NAME_TYPE);
    Ea->EaNameLength = EaNameTypeSize;

    *((PULONG) &(Ea->EaName[EaNameTypeSize + sizeof(CHAR)])) = ConnectionType;

    Ea->EaValueLength = TypeSize;

    Ea->NextEntryOffset = 0;
    Ea->Flags = 0;

    // Set object attributes for the tree conn.
    InitializeObjectAttributes(
                & objattrTreeConn,                       // obj attr to init
                (LPVOID) & ucTreeConn,                   // string to use
                OBJ_CASE_INSENSITIVE,                    // Attributes
                NULL,                                    // Root directory
                SecurityDescriptor);                     // Security Descriptor

    //
    // If the caller doesn't want to call as himself,
    //  impersonate the anonymous token.
    //

    if (NoPermissionRequired) {

        //
        // Check to see if we're already impsonating
        //

        ntstatus = NtOpenThreadToken(
                        NtCurrentThread(),
                        TOKEN_IMPERSONATE,
                        TRUE,       // as self to ensure we never fail
                        &CurrentToken
                        );

        if ( ntstatus == STATUS_NO_TOKEN ) {
            //
            // We're not already impersonating
            CurrentToken = NULL;

        } else if ( !NT_SUCCESS(ntstatus) ) {
            ApiStatus = NetpNtStatusToApiStatus(ntstatus);
            NetpKdPrint(( PREFIX_NETLIB
                        "NetpRdrFsControlTree: cannot NtOpenThreadToken: 0x%lx\n",
                        ntstatus ));

            goto Cleanup;
        }


        //
        // Impersonate the anonymous token
        //
        ntstatus = NtImpersonateAnonymousToken( NtCurrentThread() );

        if ( !NT_SUCCESS(ntstatus)) {
            ApiStatus = NetpNtStatusToApiStatus(ntstatus);
            NetpKdPrint(( PREFIX_NETLIB
                        "NetpRdrFsControlTree: cannot NtImpersonatedAnonymousToken: 0x%lx\n",
                        ntstatus ));

            goto Cleanup;
        }

        ImpersonatingAnonymous = TRUE;

    }

    //
    // Open a tree connection to the remote server.
    //

    IF_DEBUG(RDRFSCTL) {
        NetpKdPrint(( PREFIX_NETLIB
                "NetpRdrFsControlTree: opening " FORMAT_LPTSTR ".\n",
                pszTreeConn ));
    }
    ntstatus = NtCreateFile(
                &TreeConnHandle,                        // ptr to handle
                SYNCHRONIZE                              // desired...
                | GENERIC_READ | GENERIC_WRITE,          // ...access
                & objattrTreeConn,                       // name & attributes
                & iosb,                                  // I/O status block.
                NULL,                                    // alloc size.
                FILE_ATTRIBUTE_NORMAL,                   // (ignored)
                FILE_SHARE_READ | FILE_SHARE_WRITE,      // ...access
                FILE_OPEN_IF,                            // create disposition
                FILE_CREATE_TREE_CONNECTION              // create...
                | FILE_SYNCHRONOUS_IO_NONALERT,          // ...options
                EaBuffer,                                // EA buffer
                EaBufferSize );                          // Ea buffer size


    if (! NT_SUCCESS(ntstatus)) {

        ApiStatus = NetpNtStatusToApiStatus(ntstatus);
        if (ApiStatus == ERROR_BAD_NET_NAME) {
            ApiStatus = NERR_BadTransactConfig;  // Special meaning if no IPC$
        }

        if (ApiStatus != ERROR_BAD_NETPATH) {
            NetpKdPrint(( PREFIX_NETLIB
                    "NetpRdrFsControlTree: unexpected create error,\n"
                    "  tree name='" FORMAT_LPTSTR "', "
                    "ntstatus=" FORMAT_NTSTATUS ",\n"
                    "  iosb.Status=" FORMAT_NTSTATUS ", "
                    "iosb.Info=" FORMAT_HEX_ULONG ", "
                    "  returning " FORMAT_API_STATUS ".\n",
                    TreeName, ntstatus,
                    iosb.Status, iosb.Information, ApiStatus ));
        }

        goto Cleanup;
    }

    // Do the FSCTL.
    IF_DEBUG(RDRFSCTL) {
        NetpKdPrint(( PREFIX_NETLIB
                "NetpRdrFsControlTree: doing fsctl...\n" ));
    }
    ntstatus = NtFsControlFile(
                        TreeConnHandle,                  // handle
                        NULL,                            // no event
                        NULL,                            // no APC routine
                        NULL,                            // no APC context
                        & iosb,                          // I/O stat blk (set)
                        FsControlCode,                   // func code
                        InputBuffer,
                        InputBufferSize,
                        OutputBuffer,
                        OutputBufferSize);

    {
        // The additional scope is to localize all the changes for deleting the
        // connection. When a connection is opened with the FILE_CREATE_TREE_CONNECTION
        // flag set, the rdr takes an additional reference on the connection. In order
        // to delete the connection this additional reference needs to be taken off
        // by issuing a FSCTL_LMR_DELETE_CONNECTION.

        LMR_REQUEST_PACKET Rrp;            // Redirector request packet
        NTSTATUS           Status;

        RtlZeroMemory(&Rrp,sizeof(LMR_REQUEST_PACKET));
        Rrp.Level = USE_FORCE;  // this tells rdr2 to take away the extra reference
                                // to connection strucutre even when files are open.
                                // BUG #381842
        Rrp.Version = REQUEST_PACKET_VERSION;

        Status = NtFsControlFile(
                            TreeConnHandle,                  // handle
                            NULL,                            // no event
                            NULL,                            // no APC routine
                            NULL,                            // no APC context
                            &iosb,                          // I/O stat blk (set)
                            FSCTL_LMR_DELETE_CONNECTION,    // func code
                            &Rrp,
                            sizeof(LMR_REQUEST_PACKET),
                            NULL,
                            0);

        /*
        NetpKdPrint(( PREFIX_NETLIB
                 "NetpRdrFsControlTree: "
                 "Deleting tree connection: "
                 FORMAT_NTSTATUS "\n",
                 Status ));
        */

        IF_DEBUG(RDRFSCTL) {
            if (!NT_SUCCESS(Status)) {
                NetpKdPrint(( PREFIX_NETLIB
                   "NetpRdrFsControlTree: "
                   "Unexpected error Deleting tree connection: "
                   FORMAT_NTSTATUS "\n",
                   Status ));
            }
        }
    }

    if (! NT_SUCCESS(ntstatus)) {

        ApiStatus = NetpNtStatusToApiStatus(ntstatus);

        NetpKdPrint(( PREFIX_NETLIB
                "NetpRdrFsControlTree: unexpected FSCTL error,\n"
                "  tree name='" FORMAT_LPTSTR "', "
                "ntstatus=" FORMAT_NTSTATUS ".\n"
                "  ApiStatus=" FORMAT_API_STATUS ", "
                "iosb.Status=" FORMAT_NTSTATUS ", "
                "iosb.Info=" FORMAT_HEX_ULONG ".\n",
                TreeName, ntstatus, ApiStatus, iosb.Status, iosb.Information ));

        goto Cleanup;
    }

    ApiStatus = NERR_Success;
Cleanup:
    // Clean up.
    if ( TreeConnHandle != NULL ) {
        ntstatus = NtClose(TreeConnHandle);

        IF_DEBUG(RDRFSCTL) {
           if (!NT_SUCCESS(ntstatus)) {
               NetpKdPrint(( PREFIX_NETLIB
                       "NetpRdrFsControlTree: "
                       "Unexpected error closing tree connect handle: "
                       FORMAT_NTSTATUS "\n", ntstatus ));
           }
        }
    }

    if ( pszTreeConn != NULL ) {
        NetpMemoryFree(pszTreeConn);
    }

    if (EaBuffer != NULL) {
        NetpMemoryFree(EaBuffer);
    }

    if ( ImpersonatingAnonymous ) {

        ntstatus = NtSetInformationThread(
                         NtCurrentThread(),
                         ThreadImpersonationToken,
                         &CurrentToken,
                         sizeof(HANDLE)
                         );

        if (!NT_SUCCESS(ntstatus)) {
            NetpKdPrint(( PREFIX_NETLIB
                    "NetpRdrFsControlTree: "
                    "Unexpected error reverting to self: "
                    FORMAT_NTSTATUS "\n", ntstatus ));
        }

    }

    if ( CurrentToken != NULL ) {
        NtClose( CurrentToken );
    }

    return ApiStatus;

} // NetpRdrFsControlTree
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\prefmax.c ===
/*++

Copyright (c) 1991-92  Microsoft Corporation

Module Name:

    PrefMax.c

Abstract:

    This module contains NetpAdjustPreferedMaximum.

Author:

    John Rogers (JohnRo) 24-Mar-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    24-Mar-91 JohnRo
        Created.
    03-May-1991 JohnRo
        Added (quiet) debug output.  Fixed massive bug (I was using % for
        division - it must have been a long day).
    03-Apr-1992 JohnRo
        Handle preferred maximum of (DWORD)-1.
        Avoid NT-specific header files if we don't need them.
    04-Apr-1992 JohnRo
        Use MAX_PREFERRED_LENGTH equate.

--*/


// These must be included first:

#include <windef.h>     // IN, DWORD, etc.
#include <lmcons.h>     // NET_API_STATUS.

// These may be included in any order:

#include <debuglib.h>   // IF_DEBUG().
#include <netdebug.h>   // FORMAT_DWORD, NetpKdPrint(()).
#include <netlib.h>     // My prototype, NetpSetOptionalArg().


VOID
NetpAdjustPreferedMaximum (
    IN DWORD PreferedMaximum,
    IN DWORD EntrySize,
    IN DWORD Overhead,
    OUT LPDWORD BytesToAllocate OPTIONAL,
    OUT LPDWORD EntriesToAllocate OPTIONAL
    )


/*++

Routine Description:

    NetpAdjustPreferedMaximum analyzes the prefered maximum length and
    compares it with the size of an entry and the total overhead.

Arguments:

    PreferedMaximum - the number of bytes "prefered" by the application for
       a given buffer.

    EntrySize - the number of bytes for each entry.

    Overhead - the number of bytes (if any) of overhead.  For instance,
       some enum operations have a null at the end of the array returned.

    BytesToAllocate - optionally points to a DWORD which will be set on
       output to the number of bytes to allocate (consistent with the
       prefered maximum, entry size, and overhead).

    EntriesToAllocate - optionally points to a DWORD which will be set with
       the number of entries which BytesToAllocate can contain.

Return Value:

    None.

--*/

{

    if ( (PreferedMaximum <= (EntrySize+Overhead)) ||
         (PreferedMaximum == MAX_PREFERRED_LENGTH) ) {

        NetpSetOptionalArg(BytesToAllocate, EntrySize+Overhead);
        NetpSetOptionalArg(EntriesToAllocate, 1);
    } else {
        DWORD EntryCount;

        EntryCount = (PreferedMaximum-Overhead) / EntrySize;
        NetpSetOptionalArg(
                 BytesToAllocate,
                 (EntryCount*EntrySize) + Overhead);
        NetpSetOptionalArg(EntriesToAllocate, EntryCount);
    }

    IF_DEBUG(PREFMAX) {
        NetpKdPrint(("NetpAdjustPreferedMaximum: "
                "pref max=" FORMAT_DWORD ", "
                "entry size=" FORMAT_DWORD ", "
                "overhead=" FORMAT_DWORD ".\n",
                PreferedMaximum, EntrySize, Overhead));
        if (BytesToAllocate != NULL) {
            NetpKdPrint(("NetpAdjustPreferedMaximum: bytes to allocate="
                    FORMAT_DWORD ".\n", *BytesToAllocate));
        }
        if (EntriesToAllocate != NULL) {
            NetpKdPrint(("NetpAdjustPreferedMaximum: Entries to allocate="
                    FORMAT_DWORD ".\n", *EntriesToAllocate));
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\pathcmp.c ===
/*++

Copyright (c) 1989-91  Microsoft Corporation

Module Name:

    pathcmp.c

Abstract:

    Net path compare routines:

        NetpwPathCompare

Author:

    Richard L Firth (rfirth) 06-Jan-1992

Revision History:

--*/

#include "nticanon.h"

//
// The size of the buffer needed to hold a canonicalized pathname
//

#define CANON_PATH_SIZE     (MAX_PATH * sizeof(TCHAR))

//
// routines
//


LONG
NetpwPathCompare(
    IN  LPTSTR  PathName1,
    IN  LPTSTR  PathName2,
    IN  DWORD   PathType,
    IN  DWORD   Flags
    )

/*++

Routine Description:

    NetpPathCompare compares the two pathnames to see if they match.
    If the supplied names are not canonicalized this function will
    do the canonicalization of the pathnames.

    It is strongly recommended that this function be called with
    canonicalized pathnames ONLY, because the canonicalization
    operation is very expensive.  If uncanonicalized pathnames are
    passed in, the caller should be aware that a non-zero result
    could be due to an error which occurred during canonicalization.

Arguments:

    PathName1 - The first pathname to compare.

    PathName2 - The second pathname to compare.

    PathType - The type of the pathnames as determined by NetpPathType.
                 If non-zero, the function assumes that NetpPathType has
                 been called on both of the pathnames and that their
                 types are equal to this value.  If zero, the function
                 ignores this value.

    Flags - Flags to determine operation.  Currently defined
        values are:

            rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrc

        where

            r = Reserved.  MBZ.

            c = should be set if both of the paths have already been
                canonicalized (using NetpPathCanonicalize).

        Manifest values for these flags are defined in NET\H\ICANON.H.

Return Value:

    0 if the two paths match.

    Non-zero if they don't match, or if an error occurred in the
    functions operation.

--*/

{
    LONG    RetVal = 0;
    DWORD   PathType1;
    DWORD   PathType2;
    LPTSTR  CanonPath1;
    LPTSTR  CanonPath2;
    BOOL    HaveHeap = FALSE;

#ifdef CANONDBG
    DbgPrint("NetpwPathCompare\n");
#endif

    //
    // Parameter validation
    //

    if (Flags & INPC_FLAGS_RESERVED) {
        return ERROR_INVALID_PARAMETER;
    }

    //
    // If the paths aren't canonicalized, we curse at the caller under
    // our breath and canonicalize them ourselves.
    //

    if (!(Flags & INPC_FLAGS_PATHS_CANONICALIZED)) {

        //
        // We can save time and space if we determine and compare
        // their types first.
        //

        if (RetVal = NetpwPathType(PathName1, &PathType1, 0L)) {
            return RetVal;
        }
        if (RetVal = NetpwPathType(PathName2, &PathType2, 0L)) {
            return RetVal;
        }

        //
        // Now compare the types and return non-zero if they don't match
        //

        if (PathType1 != PathType2) {
            return 1;
        }

        //
        // If the types match, we have to do the canonicalization
        //

        if ((CanonPath1 = (LPTSTR)NetpMemoryAllocate(CANON_PATH_SIZE)) == NULL) {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        if ((CanonPath2 = (LPTSTR)NetpMemoryAllocate(CANON_PATH_SIZE)) == NULL) {
            NetpMemoryFree((PVOID)CanonPath1);
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        HaveHeap = TRUE;

        //
        // Call NetpPathCanonicalize on each pathname
        //

        RetVal = NetpwPathCanonicalize(
                    PathName1,
                    CanonPath1,
                    CANON_PATH_SIZE,
                    NULL,
                    &PathType1,
                    0L
                    );
        if (RetVal) {
            NetpMemoryFree((PVOID)CanonPath1);
            NetpMemoryFree((PVOID)CanonPath2);
            return RetVal;
        }

        RetVal = NetpwPathCanonicalize(
                    PathName2,
                    CanonPath2,
                    CANON_PATH_SIZE,
                    NULL,
                    &PathType2,
                    0L
                    );
        if (RetVal) {
            NetpMemoryFree((PVOID)CanonPath1);
            NetpMemoryFree((PVOID)CanonPath2);
            return RetVal;
        }
    } else {

        //
        // The paths are already canonicalized, just set the pointers
        //

        CanonPath1 = PathName1;
        CanonPath2 = PathName2;
    }

    //
    // Now do the comparison
    //
    // Paths are no longer case mapped during canonicalization, so we use
    // case-insensitive comparison
    //

    RetVal = STRICMP(CanonPath1, CanonPath2);

    //
    // if we had to allocate space to store the canonicalized paths then free
    // that memory (why don't C have local procedures?)
    //

    if (HaveHeap) {
        NetpMemoryFree((PVOID)CanonPath1);
        NetpMemoryFree((PVOID)CanonPath2);
    }

    return RetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\prtinfo.c ===
/*++

Copyright (c) 1992-1993  Microsoft Corporation

Module Name:

    PrtInfo.c

Abstract:

    This file contains:

        NetpPrintDestStructureInfo()
        NetpPrintJobStructureInfo()
        NetpPrintQStructureInfo()

Author:

    John Rogers (JohnRo) 16-Jun-1992

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    16-Jun-1992 JohnRo
        Created for RAID 10324: net print vs. UNICODE.
    02-Oct-1992 JohnRo
        RAID 3556: DosPrintQGetInfo(from downlevel) level 3, rc=124.  (4&5 too.)
    11-May-1993 JohnRo
        RAID 9942: fixed GP fault in debug code (NetpDisplayPrintStructureInfo).

--*/

// These must be included first:

#include <windef.h>     // IN, DWORD, etc.
#include <lmcons.h>     // MAXCOMMENTSZ, DEVLEN, NET_API_STATUS, etc.
#include <rap.h>        // LPDESC, needed by <strucinf.h>.

// These may be included in any order:

#include <debuglib.h>   // IF_DEBUG().
#include <lmerr.h>      // ERROR_ and NERR_ equates.
#include <netlib.h>     // NetpSetOptionalArg().
#include <netdebug.h>   // NetpAssert().
#include <prefix.h>     // PREFIX_ equates.
#include <remdef.h>     // REM16_, REM32_, REMSmb_ equates.
#include <rxprint.h>    // PDLEN, PRDINFO, etc.
#include <strucinf.h>   // My prototypes.


#define MAX_DEST_LIST_LEN           NNLEN
#define MAX_DOC_LEN                 NNLEN
#define MAX_DRIVER_NAME_LEN         NNLEN
#define MAX_DRIVER_LIST_LEN         NNLEN
#define MAX_LONG_PRINT_Q_LEN        QNLEN
#define MAX_NOTIFY_LEN              UNLEN
#define MAX_PRINT_PARMS_LEN         NNLEN
#define MAX_PRINTER_NAME_LEN        PRINTERNAME_SIZE
#define MAX_PRINTER_NAME_LIST_LEN   NNLEN
#define MAX_QPROC_LEN               NNLEN
#define MAX_QPROC_PARMS_LEN         NNLEN
#define MAX_SEP_FILE_LEN            PATHLEN
#define MAX_STATUS_LEN              NNLEN


#define MAX_PRINT_DEST_0_STRING_LENGTH \
        (0)
#define MAX_PRINT_DEST_1_STRING_LENGTH \
        (MAX_STATUS_LEN+1)
#define MAX_PRINT_DEST_2_STRING_LENGTH \
        (MAX_PRINTER_NAME_LEN+1)
#define MAX_PRINT_DEST_3_STRING_LENGTH \
        (MAX_PRINTER_NAME_LEN+1 + UNLEN+1 + DEVLEN+1 + MAX_STATUS_LEN+1 \
         + MAXCOMMENTSZ+1 + MAX_DRIVER_LIST_LEN+1)

#define MAX_PRINT_JOB_0_STRING_LENGTH \
        (0)
#define MAX_PRINT_JOB_1_STRING_LENGTH \
        (MAX_PRINT_PARMS_LEN+1 + MAX_STATUS_LEN+1 + MAXCOMMENTSZ+1)
#define MAX_PRINT_JOB_2_STRING_LENGTH \
        (UNLEN+1 + MAXCOMMENTSZ+1 + MAX_DOC_LEN+1)
#define MAX_PRINT_JOB_3_STRING_LENGTH \
        (MAX_PRINT_JOB_2_STRING_LENGTH + MAX_NOTIFY_LEN+1 + DTLEN+1 \
         + MAX_PRINT_PARMS_LEN+1 + MAX_STATUS_LEN+1 \
         + QNLEN+1 + MAX_QPROC_LEN+1 \
         + MAX_QPROC_PARMS_LEN+1 + MAX_DRIVER_NAME_LEN+1 \
         + MAX_PRINTER_NAME_LEN+1 )

#define MAX_PRINT_Q_0_STRING_LENGTH \
        (0)
#define MAX_PRINT_Q_1_STRING_LENGTH \
        (MAX_SEP_FILE_LEN+1 + MAX_QPROC_LEN+1 + MAX_DEST_LIST_LEN+1 \
         + MAX_PRINT_PARMS_LEN+1 + MAXCOMMENTSZ+1)
#define MAX_PRINT_Q_2_STRING_LENGTH \
        (MAX_PRINT_PARMS_LEN+1 + MAX_STATUS_LEN+1 + MAXCOMMENTSZ+1)
#define MAX_PRINT_Q_3_STRING_LENGTH \
        (MAX_LONG_PRINT_Q_LEN+1 + MAX_SEP_FILE_LEN+1 + MAX_QPROC_LEN+1 \
         + MAX_PRINT_PARMS_LEN+1 + MAXCOMMENTSZ + MAX_PRINTER_NAME_LIST_LEN+1 )
#define MAX_PRINT_Q_4_STRING_LENGTH \
        (MAX_PRINT_Q_3_STRING_LENGTH)
#define MAX_PRINT_Q_5_STRING_LENGTH \
        (MAX_LONG_PRINT_Q_LEN+1)


#define SET_PRINT_SIZES(ansiFixed,unicodeFixed,variableLength) \
    { \
        DWORD fixed; \
        if (CharSize == sizeof(CHAR)) { \
            fixed = ansiFixed; \
        } else { \
            fixed = unicodeFixed; \
        } \
        NetpSetOptionalArg( MaxSize, fixed + (variableLength) * CharSize ); \
        NetpSetOptionalArg( FixedSize, fixed ); \
        NetpSetOptionalArg( StringSize, (variableLength) * CharSize ); \
    }


#if DBG
DBGSTATIC VOID
NetpDisplayPrintStructureInfo(
    IN LPDEBUG_STRING ApiName,
    IN LPDESC * DataDesc16 OPTIONAL,
    IN LPDESC * DataDesc32 OPTIONAL,
    IN LPDESC * DataDescSmb OPTIONAL,
    IN LPDESC * AuxDesc16 OPTIONAL,
    IN LPDESC * AuxDesc32 OPTIONAL,
    IN LPDESC * AuxDescSmb OPTIONAL,
    IN LPDWORD MaxSize OPTIONAL,
    IN LPDWORD FixedSize OPTIONAL,
    IN LPDWORD StringSize OPTIONAL
    )
{
    IF_DEBUG( STRUCINF ) {
        if (DataDesc16) {
            NetpKdPrint(( PREFIX_NETLIB FORMAT_LPDEBUG_STRING
                    ": desc 16 is " FORMAT_LPDESC
                    ".\n", ApiName, *DataDesc16 ));
        }
        if (DataDesc32) {
            NetpKdPrint(( PREFIX_NETLIB FORMAT_LPDEBUG_STRING
                    ": desc 32 is " FORMAT_LPDESC
                    ".\n", ApiName, *DataDesc32 ));
        }
        if (DataDescSmb) {
            NetpKdPrint(( PREFIX_NETLIB FORMAT_LPDEBUG_STRING
                    ": desc Smb is " FORMAT_LPDESC
                    ".\n", ApiName, *DataDescSmb ));
        }
        if (AuxDesc16) {
            NetpKdPrint(( PREFIX_NETLIB FORMAT_LPDEBUG_STRING
                    ": aux desc 16 is " FORMAT_LPDESC
                    ".\n", ApiName, *AuxDesc16 ));
        }
        if (AuxDesc32) {
            NetpKdPrint(( PREFIX_NETLIB FORMAT_LPDEBUG_STRING
                    ": aux desc 32 is " FORMAT_LPDESC
                    ".\n", ApiName, *AuxDesc32 ));
        }
        if (AuxDescSmb) {
            NetpKdPrint(( PREFIX_NETLIB FORMAT_LPDEBUG_STRING
                    ": aux desc Smb is " FORMAT_LPDESC
                    ".\n", ApiName, *AuxDescSmb ));
        }
        if (MaxSize) {
            NetpKdPrint(( PREFIX_NETLIB FORMAT_LPDEBUG_STRING
                    ": max size is " FORMAT_DWORD
                    ".\n", ApiName, *MaxSize ));
        }
        if (FixedSize) {
            NetpKdPrint(( PREFIX_NETLIB FORMAT_LPDEBUG_STRING
                    ": fixed size is " FORMAT_DWORD
                    ".\n", ApiName, *FixedSize ));
        }
        if (StringSize) {
            NetpKdPrint(( PREFIX_NETLIB FORMAT_LPDEBUG_STRING
                    ": string size is " FORMAT_DWORD
                    ".\n", ApiName, *StringSize ));
        }
    }

} // NetpDisplayPrintStructureInfo

#endif // DBG


NET_API_STATUS
NetpPrintDestStructureInfo (
    IN DWORD Level,
    IN DWORD ParmNum,  // Use PARMNUM_ALL if not applicable.
    IN BOOL Native,    // Should sizes be native or RAP?
    IN BOOL AddOrSetInfoApi,
    IN DWORD CharSize, // size of chars wanted
    OUT LPDESC * DataDesc16 OPTIONAL,
    OUT LPDESC * DataDesc32 OPTIONAL,
    OUT LPDESC * DataDescSmb OPTIONAL,
    OUT LPDWORD MaxSize OPTIONAL,
    OUT LPDWORD FixedSize OPTIONAL,
    OUT LPDWORD StringSize OPTIONAL
    )

{
    DBG_UNREFERENCED_PARAMETER(ParmNum);

    NetpAssert( Native );
    NetpAssert( (CharSize==sizeof(CHAR)) || (CharSize==sizeof(WCHAR)) );

    //
    // Decide what to do based on the info level.
    //
    switch (Level) {


    case 0 :
        if (AddOrSetInfoApi == TRUE) {
            return (ERROR_INVALID_LEVEL);
        }
        NetpSetOptionalArg( DataDesc16, REM16_print_dest_0 );
        NetpSetOptionalArg( DataDesc32, REM32_print_dest_0 );
        NetpSetOptionalArg( DataDescSmb, REMSmb_print_dest_0 );

        SET_PRINT_SIZES(
                (PDLEN+1),                         // ansi "struct"
                (PDLEN+1) * sizeof(WCHAR),         // unicode "struct"
                MAX_PRINT_DEST_0_STRING_LENGTH );
        break;

    case 1 :
        if (AddOrSetInfoApi == TRUE) {
            return (ERROR_INVALID_LEVEL);
        }
        NetpSetOptionalArg( DataDesc16, REM16_print_dest_1 );
        NetpSetOptionalArg( DataDesc32, REM32_print_dest_1 );
        NetpSetOptionalArg( DataDescSmb, REMSmb_print_dest_1 );
        SET_PRINT_SIZES(
                 sizeof(PRDINFOA),                 // ansi struct
                 sizeof(PRDINFOW),                 // unicode struct
                 MAX_PRINT_DEST_1_STRING_LENGTH );
        break;

    case 2 :
        if (AddOrSetInfoApi == TRUE) {
            return (ERROR_INVALID_LEVEL);
        }
        NetpSetOptionalArg( DataDesc16, REM16_print_dest_2 );
        NetpSetOptionalArg( DataDesc32, REM32_print_dest_2 );
        NetpSetOptionalArg( DataDescSmb, REMSmb_print_dest_2 );
        SET_PRINT_SIZES(
                 sizeof(LPSTR),                    // ansi "struct"
                 sizeof(LPWSTR),                   // unicode "struct"
                 MAX_PRINT_DEST_2_STRING_LENGTH );
        break;

    case 3 :
        NetpSetOptionalArg( DataDesc16, REM16_print_dest_3 );
        NetpSetOptionalArg( DataDesc32, REM32_print_dest_3 );
        NetpSetOptionalArg( DataDescSmb, REMSmb_print_dest_3 );
        SET_PRINT_SIZES(
                sizeof(PRDINFO3A),
                sizeof(PRDINFO3W),
                MAX_PRINT_DEST_3_STRING_LENGTH );
        break;

    default :
        return (ERROR_INVALID_LEVEL);
    }

#if DBG
    NetpDisplayPrintStructureInfo(
            "NetpPrintDestStructureInfo",
            DataDesc16, DataDesc32, DataDescSmb,
            NULL, NULL, NULL,   // no aux data descs (16, 32, SMB)
            MaxSize, FixedSize, StringSize );
#endif

    return (NERR_Success);

} // NetpPrintDestStructureInfo


NET_API_STATUS
NetpPrintJobStructureInfo (
    IN DWORD Level,
    IN DWORD ParmNum,  // Use PARMNUM_ALL if not applicable.
    IN BOOL Native,    // Should sizes be native or RAP?
    IN BOOL SetInfoApi,
    IN DWORD CharSize, // size of chars wanted
    OUT LPDESC * DataDesc16 OPTIONAL,
    OUT LPDESC * DataDesc32 OPTIONAL,
    OUT LPDESC * DataDescSmb OPTIONAL,
    OUT LPDWORD MaxSize OPTIONAL,
    OUT LPDWORD FixedSize OPTIONAL,
    OUT LPDWORD StringSize OPTIONAL
    )
{
    DBG_UNREFERENCED_PARAMETER(ParmNum);

    NetpAssert( Native );
    NetpAssert( (CharSize==sizeof(CHAR)) || (CharSize==sizeof(WCHAR)) );

    switch (Level) {
    case 0 :
        if (SetInfoApi == TRUE) {
            return (ERROR_INVALID_LEVEL);
        }
        NetpSetOptionalArg(DataDesc16, REM16_print_job_0);
        NetpSetOptionalArg(DataDesc32, REM32_print_job_0);
        NetpSetOptionalArg(DataDescSmb, REMSmb_print_job_0);

        SET_PRINT_SIZES(
                 sizeof(WORD),
                 sizeof(WORD),
                 MAX_PRINT_JOB_0_STRING_LENGTH );
        break;

    case 1 :
        NetpSetOptionalArg(DataDesc16, REM16_print_job_1);
        NetpSetOptionalArg(DataDesc32, REM32_print_job_1);
        NetpSetOptionalArg(DataDescSmb, REMSmb_print_job_1);
        SET_PRINT_SIZES(
                 sizeof(PRJINFOA),
                 sizeof(PRJINFOW),
                 MAX_PRINT_JOB_1_STRING_LENGTH );
        break;

    case 2 :
        if (SetInfoApi == TRUE) {
            return (ERROR_INVALID_LEVEL);
        }
        NetpSetOptionalArg(DataDesc16, REM16_print_job_2);
        NetpSetOptionalArg(DataDesc32, REM32_print_job_2);
        NetpSetOptionalArg(DataDescSmb, REMSmb_print_job_2);
        SET_PRINT_SIZES(
                 sizeof(PRJINFO2A),
                 sizeof(PRJINFO2W),
                 MAX_PRINT_JOB_2_STRING_LENGTH );
        break;

    case 3 :
        NetpSetOptionalArg(DataDesc16, REM16_print_job_3);
        NetpSetOptionalArg(DataDesc32, REM32_print_job_3);
        NetpSetOptionalArg(DataDescSmb, REMSmb_print_job_3);
        SET_PRINT_SIZES(
                 sizeof(PRJINFO3A),
                 sizeof(PRJINFO3W),
                 MAX_PRINT_JOB_3_STRING_LENGTH );
        break;

    default :
        return (ERROR_INVALID_LEVEL);
    }

#if DBG
    NetpDisplayPrintStructureInfo(
            "NetpPrintJobStructureInfo",
            DataDesc16, DataDesc32, DataDescSmb,
            NULL, NULL, NULL,   // no aux data descs (16, 32, SMB)
            MaxSize, FixedSize, StringSize );
#endif

    return (NO_ERROR);

} // NetpPrintJobStructureInfo


NET_API_STATUS
NetpPrintQStructureInfo (
    IN DWORD Level,
    IN DWORD ParmNum,  // Use PARMNUM_ALL if not applicable.
    IN BOOL Native,    // Should sizes be native or RAP?
    IN BOOL AddOrSetInfoApi,
    IN DWORD CharSize, // size of chars wanted
    OUT LPDESC * DataDesc16 OPTIONAL,
    OUT LPDESC * DataDesc32 OPTIONAL,
    OUT LPDESC * DataDescSmb OPTIONAL,
    OUT LPDESC * AuxDesc16 OPTIONAL,
    OUT LPDESC * AuxDesc32 OPTIONAL,
    OUT LPDESC * AuxDescSmb OPTIONAL,
    OUT LPDWORD MaxSize OPTIONAL,
    OUT LPDWORD FixedSize OPTIONAL,
    OUT LPDWORD StringSize OPTIONAL
    )
{
    DBG_UNREFERENCED_PARAMETER(ParmNum);

    NetpAssert( Native );
    NetpAssert( (CharSize==sizeof(CHAR)) || (CharSize==sizeof(WCHAR)) );

    switch (Level) {
    case 0 :
        if (AddOrSetInfoApi) {
            return (ERROR_INVALID_LEVEL);
        }
        NetpSetOptionalArg(AuxDesc16, NULL);
        NetpSetOptionalArg(AuxDesc32, NULL);
        NetpSetOptionalArg(AuxDescSmb, NULL);
        NetpSetOptionalArg(DataDesc16, REM16_printQ_0);
        NetpSetOptionalArg(DataDesc32, REM32_printQ_0);
        NetpSetOptionalArg(DataDescSmb, REMSmb_printQ_0);
        SET_PRINT_SIZES(
                (LM20_QNLEN+1),
                (LM20_QNLEN+1) * sizeof(WCHAR),
                MAX_PRINT_Q_0_STRING_LENGTH );
        break;

    case 1 :
        NetpSetOptionalArg(AuxDesc16, NULL);
        NetpSetOptionalArg(AuxDesc32, NULL);
        NetpSetOptionalArg(AuxDescSmb, NULL);
        NetpSetOptionalArg(DataDesc16, REM16_printQ_1);
        NetpSetOptionalArg(DataDesc32, REM32_printQ_1);
        NetpSetOptionalArg(DataDescSmb, REMSmb_printQ_1);
        SET_PRINT_SIZES(
                 sizeof(PRQINFOA),
                 sizeof(PRQINFOW),
                 MAX_PRINT_Q_1_STRING_LENGTH );
        break;

    case 2 :
        if (AddOrSetInfoApi) {
            return (ERROR_INVALID_LEVEL);
        }
        NetpSetOptionalArg(AuxDesc16, REM16_print_job_1);
        NetpSetOptionalArg(AuxDesc32, REM32_print_job_1);
        NetpSetOptionalArg(AuxDescSmb, REMSmb_print_job_1);
        NetpSetOptionalArg(DataDesc16, REM16_printQ_2);
        NetpSetOptionalArg(DataDesc32, REM32_printQ_2);
        NetpSetOptionalArg(DataDescSmb, REMSmb_printQ_2);
        SET_PRINT_SIZES(
                 sizeof(PRQINFOA),
                 sizeof(PRQINFOW),
                 MAX_PRINT_Q_2_STRING_LENGTH );
        break;

    case 3 :
        NetpSetOptionalArg(AuxDesc16, NULL);
        NetpSetOptionalArg(AuxDesc32, NULL);
        NetpSetOptionalArg(AuxDescSmb, NULL);
        NetpSetOptionalArg(DataDesc16, REM16_printQ_3);
        NetpSetOptionalArg(DataDesc32, REM32_printQ_3);
        NetpSetOptionalArg(DataDescSmb, REMSmb_printQ_3);
        SET_PRINT_SIZES(
                 sizeof(PRQINFO3A),
                 sizeof(PRQINFO3W),
                 MAX_PRINT_Q_3_STRING_LENGTH );
        break;

    case 4 :
        if (AddOrSetInfoApi) {
            return (ERROR_INVALID_LEVEL);
        }
        NetpSetOptionalArg(AuxDesc16, REM16_print_job_2);
        NetpSetOptionalArg(AuxDesc32, REM32_print_job_2);
        NetpSetOptionalArg(AuxDescSmb, REMSmb_print_job_2);
        NetpSetOptionalArg(DataDesc16, REM16_printQ_4);
        NetpSetOptionalArg(DataDesc32, REM32_printQ_4);
        NetpSetOptionalArg(DataDescSmb, REMSmb_printQ_4);
        SET_PRINT_SIZES(
                 sizeof(PRQINFO3A),
                 sizeof(PRQINFO3W),
                 MAX_PRINT_Q_4_STRING_LENGTH );
        break;

    case 5 :
        if (AddOrSetInfoApi) {
            return (ERROR_INVALID_LEVEL);
        }
        NetpSetOptionalArg(AuxDesc16, NULL);
        NetpSetOptionalArg(AuxDesc32, NULL);
        NetpSetOptionalArg(AuxDescSmb, NULL);
        NetpSetOptionalArg(DataDesc16, REM16_printQ_5);
        NetpSetOptionalArg(DataDesc32, REM32_printQ_5);
        NetpSetOptionalArg(DataDescSmb, REMSmb_printQ_5);

        SET_PRINT_SIZES(
                 sizeof(LPVOID),
                 sizeof(LPVOID),
                 MAX_PRINT_Q_5_STRING_LENGTH );
        break;

    default :
        return (ERROR_INVALID_LEVEL);
    }

#if DBG
    NetpDisplayPrintStructureInfo(
            "NetpPrintQStructureInfo",
            DataDesc16, DataDesc32, DataDescSmb,
            AuxDesc16, AuxDesc32, AuxDescSmb,
            MaxSize, FixedSize, StringSize );
#endif

    return (NO_ERROR);

} // NetpPrintQStructureInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\replinfo.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    ReplInfo.c

Abstract:

    This file contains functions which return info about the various levels
    of replicator data structures.  (See LmRepl.h)

Author:

    John Rogers (JohnRo) 07-Jan-1992

Environment:

    Portable.
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    07-Jan-1992 JohnRo
        Created.
    24-Jan-1992 JohnRo
        Changed to use LPTSTR etc.
    30-Jan-1992 JohnRo
        Fixed NetpReplDirStructureInfo()'s return code.

--*/


// These must be included first:

#include <windef.h>             // IN, VOID, LPTSTR, etc.
#include <lmcons.h>             // NET_API_STATUS, etc.
#include <rap.h>                // Needed by <strucinf.h>.

// These can be in any order:

#include <lmrepl.h>             // REPL_INFO_0, etc.
#include <netdebug.h>           // NetpAssert(), etc.
#include <netlib.h>             // NetpSetOptionalArg() macro.
#include <strucinf.h>           // My prototypes.
#include <winerror.h>           // ERROR_ equates, NO_ERROR.


#define MAX_DIR_NAME_SIZE       ( (PATHLEN+1) * sizeof( TCHAR ) )
#define MAX_LIST_SIZE           ( 512         * sizeof( TCHAR ) )  // arbitrary
#define MAX_MASTER_NAME_SIZE    ( (MAX_PATH+1)* sizeof( TCHAR ) )
#define MAX_PATH_SIZE           ( (PATHLEN+1) * sizeof( TCHAR ) )
#define MAX_USER_NAME_SIZE      ( (UNLEN+1)   * sizeof( TCHAR ) )


#define SetSizes(fixed,variable) \
    { \
        NetpSetOptionalArg( MaxSize, (fixed) + (variable) ); \
        NetpSetOptionalArg( FixedSize, (fixed) ); \
        NetpSetOptionalArg( StringSize, (variable) ); \
    }


NET_API_STATUS
NetpReplDirStructureInfo (
    IN DWORD Level,
    IN DWORD ParmNum,  // Use PARMNUM_ALL if not applicable.
    IN BOOL Native,    // Should sizes be native or RAP?
    OUT LPDESC * DataDesc16 OPTIONAL,
    OUT LPDESC * DataDesc32 OPTIONAL,
    OUT LPDESC * DataDescSmb OPTIONAL,
    OUT LPDWORD MaxSize OPTIONAL,
    OUT LPDWORD FixedSize OPTIONAL,
    OUT LPDWORD StringSize OPTIONAL
    )
{
    const DWORD StringSize0 = MAX_PATH_SIZE  // export path
                            + MAX_LIST_SIZE  // export list
                            + MAX_PATH_SIZE  // import path
                            + MAX_LIST_SIZE  // import list
                            + MAX_USER_NAME_SIZE;  // logon user name
    if (Level != 0) {
        return (ERROR_INVALID_LEVEL);
    }
    NetpAssert( ParmNum == PARMNUM_ALL );
    NetpAssert( Native );
    NetpSetOptionalArg( DataDesc16, NULL );
    NetpSetOptionalArg( DataDesc32, NULL );
    NetpSetOptionalArg( DataDescSmb, NULL );

    SetSizes( sizeof( REPL_INFO_0 ), StringSize0 );

    return (NO_ERROR);

} // NetpReplDirStructureInfo


NET_API_STATUS
NetpReplExportDirStructureInfo (
    IN DWORD Level,
    IN DWORD ParmNum,  // Use PARMNUM_ALL if not applicable.
    IN BOOL Native,    // Should sizes be native or RAP?
    OUT LPDESC * DataDesc16 OPTIONAL,
    OUT LPDESC * DataDesc32 OPTIONAL,
    OUT LPDESC * DataDescSmb OPTIONAL,
    OUT LPDWORD MaxSize OPTIONAL,
    OUT LPDWORD FixedSize OPTIONAL,
    OUT LPDWORD StringSize OPTIONAL
    )
{
    NetpAssert( ParmNum == PARMNUM_ALL );
    NetpAssert( Native );
    NetpSetOptionalArg( DataDesc16, NULL );
    NetpSetOptionalArg( DataDesc32, NULL );
    NetpSetOptionalArg( DataDescSmb, NULL );
    switch (Level) {
    case 0 :
        SetSizes(
            sizeof( REPL_EDIR_INFO_0 ),
            MAX_DIR_NAME_SIZE );
        break;
    case 1 :
        SetSizes(
            sizeof( REPL_EDIR_INFO_1 ),
            MAX_DIR_NAME_SIZE );
        break;
    case 2 :
        SetSizes(
            sizeof( REPL_EDIR_INFO_2 ),
            MAX_DIR_NAME_SIZE );
        break;
    default :
        return (ERROR_INVALID_LEVEL);
    }
    return (NO_ERROR);

} // NetpReplExportDirStructureInfo


NET_API_STATUS
NetpReplImportDirStructureInfo (
    IN DWORD Level,
    IN DWORD ParmNum,  // Use PARMNUM_ALL if not applicable.
    IN BOOL Native,    // Should sizes be native or RAP?
    OUT LPDESC * DataDesc16 OPTIONAL,
    OUT LPDESC * DataDesc32 OPTIONAL,
    OUT LPDESC * DataDescSmb OPTIONAL,
    OUT LPDWORD MaxSize OPTIONAL,
    OUT LPDWORD FixedSize OPTIONAL,
    OUT LPDWORD StringSize OPTIONAL
    )
{
    NetpAssert( ParmNum == PARMNUM_ALL );
    NetpAssert( Native );

    NetpSetOptionalArg( DataDesc16, NULL );
    NetpSetOptionalArg( DataDesc32, NULL );
    NetpSetOptionalArg( DataDescSmb, NULL );

    switch (Level) {
    case 0 :
        SetSizes(
                sizeof( REPL_IDIR_INFO_0 ),
                MAX_DIR_NAME_SIZE );
        break;
    case 1 :
        SetSizes(
                sizeof( REPL_IDIR_INFO_1 ),
                MAX_DIR_NAME_SIZE + MAX_MASTER_NAME_SIZE );
        break;
    default :
        return (ERROR_INVALID_LEVEL);
    }

    return (NO_ERROR);

} // NetpReplImportDirStructureInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\rpcbind.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    RpcBind.c

Abstract:

    This file contains RPC Bind caching functions:

    (public functions)
        NetpBindRpc
        NetpUnbindRpc

    NOTE: Initialization is done via a dllinit routine for netapi.dll.

Author:

    Dan Lafferty    danl    25-Oct-1991

Environment:

    User Mode - Win32

Revision History:

    12-Oct-1993     Danl
        #IFDEF out the caching code when we are not building with the
        cache.  (Make it smaller).

    15-Jan-1992     Danl
        Make sure LocalComputerName is not NULL prior to doing the
        string compare.  Make the string compare case insensitive.

    10-Jun-1992     JohnRo
        Tons of debug output changes.

    25-Oct-1991     danl
        Created

--*/

// These must be included first:

#include <nt.h>                 // NTSTATUS, etc.
#include <ntrtl.h>              // needed for nturtl.h
#include <nturtl.h>             // needed for windows.h when I have nt.h
#include <windows.h>            // win32 typedefs
#include <lmcons.h>             // NET_API_STATUS
#include <rpc.h>                // rpc prototypes

#include <netlib.h>
#include <netlibnt.h>           // NetpNtStatusToApiStatus
#include <tstring.h>            // STRSIZE, STRLEN, STRCPY, etc.
#include <rpcutil.h>
#include <ntrpcp.h>             // RpcpBindRpc

// These may be included in any order:

#include <lmerr.h>              // NetError codes
#include <string.h>             // for strcpy strcat strlen memcmp
#include <debuglib.h>           // IF_DEBUG
#include <netdebug.h>           // FORMAT_ equates, NetpKdPrint(()), NetpAssert(), etc.
#include <prefix.h>             // PREFIX_ equates.

//
// CONSTANTS & MACROS
//

#ifndef FORMAT_HANDLE
#define FORMAT_HANDLE "0x%lX"
#endif


RPC_STATUS
NetpBindRpc(
    IN  LPTSTR                  ServerName,
    IN  LPTSTR                  ServiceName,
    IN  LPTSTR                  NetworkOptions,
    OUT RPC_BINDING_HANDLE      *BindingHandlePtr
    )
/*++

Routine Description:

    Binds to the RPC server if possible.

Arguments:

    ServerName - Name of server to bind with.  This may be NULL if it is to
        bind with the local server.

    ServiceName - Name of service to bind with.  This is typically the
        name of the interface as specified in the .idl file.  Although
        it doesn't HAVE to be, it would be consistant to use that name.

    NetworkOptions - Supplies network options which describe the
        security to be used for named pipe instances created for
        this binding handle.

    BindingHandlePtr - Location where binding handle is to be placed.

Return Value:

    NERR_Success if the binding was successful.  An error value if it
    was not.


--*/

{

    NTSTATUS        ntStatus;
    NET_API_STATUS  status = NERR_Success;

    //
    // Create a New binding
    //
    ntStatus = RpcpBindRpc(
                (LPWSTR) ServerName,
                (LPWSTR) ServiceName,
                (LPWSTR) NetworkOptions,
                BindingHandlePtr);

    if ( ntStatus != RPC_S_OK ) {
        IF_DEBUG(RPC) {
            NetpKdPrint((PREFIX_NETLIB "[NetpBindRpc]RpcpBindRpc Failed "
                    "(impersonating) "FORMAT_NTSTATUS "\n",ntStatus));
        }
    }

    return(NetpNtStatusToApiStatus(ntStatus));
}


RPC_STATUS
NetpUnbindRpc(
    IN RPC_BINDING_HANDLE  BindingHandle
    )

/*++

Routine Description:

    This function is called when the application desired to unbind an
    RPC handle.  If the handle is cached, the handle is not actually unbound.
    Instead the entry for this handle has its UseCount decremented.
    If the handle is not in the cache, the RpcUnbind routine is called and
    the win32 mapped status is returned.

Arguments:

    BindingHandle - This points to the binding handle that is to
        have its UseCount decremented.


Return Value:

    NERR_Success - If the handle was successfully unbound, or if the
        cache entry UseCount was decremented.


--*/
{
    RPC_STATUS      status = NERR_Success;

    IF_DEBUG(RPC) {
        NetpKdPrint((PREFIX_NETLIB "[NetpUnbindRpc] UnBinding Handle "
                FORMAT_HANDLE "\n", BindingHandle));
    }

    status = RpcpUnbindRpc( BindingHandle );

    IF_DEBUG(RPC) {
        if (status) {
            NetpKdPrint((PREFIX_NETLIB "Unbind Failure! RpcUnbind = "
                    FORMAT_NTSTATUS "\n",status));
        }
    }

    status = NetpNtStatusToApiStatus(status);

    return(status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\rpcfail.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    RpcFail.c

Abstract:

    This routine is a captive of the NET_REMOTE_RPC_FAILED macro in
    netrpc.h.  See that header file for more info.

Author:

    John Rogers (JohnRo) 01-Nov-1991

Environment:

    User Mode - Win32
    Only runs under NT; has an NT-specific interface (with Win32 types).
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    01-Nov-1991 JohnRo
        Created this routine as part of fixing RAID 3414: allow explicit local
        server name.
    07-Nov-1991 JohnRo
        RAID 4186: assert in RxNetShareAdd and other DLL stub problems.
    12-Nov-1991 JohnRo
        Return correct error code for server not started.
    17-Jan-1992 JohnRo
        Added NET_REMOTE_RPC_FAILED_W for UNICODE-only server names.
    08-Apr-1992 JohnRo
        Clarify that ServiceName parameter is OPTIONAL.
    12-Jan-1993 JohnRo
        RAID 1586: NetReplSetInfo fails after stop service.  (Also fix error
        code if remote RPC service is not started.)
        Use PREFIX_ equates.
        Use NetpKdPrint where possible.
    30-Jun-1993 JohnRo
        Perhaps we don't need to query if remote service is started.
        Also handle RPC_S_SERVER_TOO_BUSY.

--*/


// These must be included first:

#include <nt.h>         // IN, etc.
#include <windef.h>     // LPVOID, etc.
#include <lmcons.h>     // NET_API_STATUS, etc.
#include <rpc.h>        // Needed by NetRpc.h

// These may be included in any order:

#include <debuglib.h>   // IF_DEBUG().
#include <lmerr.h>      // NERR_Success, etc.
#include <lmremutl.h>   // NetpRemoteComputerSupports(), SUPPORTS_ stuff
#include <lmsname.h>    // SERVICE_ equates.
#include <netdebug.h>   // FORMAT_ equates, LPDEBUG_STRING, NetpKdPrint(), etc.
#include <netlib.h>     // NetpIsServiceStarted().
#include <netrpc.h>     // My prototypes, NET_REMOTE_FLAG_ equates.
#include <prefix.h>     // PREFIX_ equates.
#include <rpcutil.h>    // NetpRpcStatusToApiStatus().
#include <tstring.h>    // NetpAlloc{type}From{type}(), TCHAR_EOS, STRICMP().


#define UnexpectedMsg( debugString ) \
    { \
        NetpKdPrint(( PREFIX_NETAPI \
                FORMAT_LPDEBUG_STRING ": unexpected situation... " \
                debugString ", rpc status is " FORMAT_RPC_STATUS ".\n", \
                DebugName, RpcStatus )); \
    }

NET_API_STATUS
NetpHandleRpcFailure(
    IN LPDEBUG_STRING DebugName,  // Used by UnexpectedMsg().
    IN RPC_STATUS RpcStatus,    // Used by UnexpectedMsg().
    IN LPTSTR ServerNameValue OPTIONAL,
    IN LPTSTR ServiceName OPTIONAL,
    IN DWORD Flags,             // NET_REMOTE_FLAG_ stuff.
    OUT LPBOOL TryDownlevel
    )

{
    NET_API_STATUS ApiStatus;

    *TryDownlevel = FALSE;        // Be pesimistic until we know for sure.

    if (RpcStatus == RPC_S_OK) {

        //
        // Exception without error code?  Don't try the downlevel call.
        // In theory, this should never happen.
        //
        UnexpectedMsg( "exception with RPC_S_OK" );
        return (NERR_InternalError);

    } else if (RpcStatus == ERROR_ACCESS_DENIED) {

        //
        // Exception was access denied, so it does no good to go any further
        //
        return (RpcStatus);
    }
    else
    { // exception with error code

        DWORD OptionsSupported = 0;

        //
        // Learn about the machine.  This is fairly easy since the
        // NetRemoteComputerSupports also handles the local machine (whether
        // or not a server name is given).
        //
        ApiStatus = NetRemoteComputerSupports(
                ServerNameValue,
                SUPPORTS_RPC | SUPPORTS_LOCAL,  // options wanted
                &OptionsSupported);

        if (ApiStatus != NERR_Success) {
            // This is where machine not found gets handled.
            return (ApiStatus);
        }

        if (OptionsSupported & SUPPORTS_LOCAL) {

            //
            // Local service not started?
            //
            if (RpcStatus == RPC_S_SERVER_UNAVAILABLE ||
                RpcStatus == RPC_S_UNKNOWN_IF ) {

                if ( (Flags & NET_REMOTE_FLAG_SVC_CTRL) == 0 ) {

                    NetpAssert( ServiceName != NULL );
                    NetpAssert( (*ServiceName) != TCHAR_EOS );

                    //
                    // This isn't a service controller API, so we can ask the
                    // service controller if the service is started.
                    //
                    if ( !NetpIsServiceStarted(ServiceName)) {

                        // Local service not started.
                        if (STRICMP( ServiceName,
                                (LPTSTR) SERVICE_WORKSTATION) == 0) {
                            return (NERR_WkstaNotStarted);
                        } else if (STRICMP( ServiceName,
                                (LPTSTR) SERVICE_SERVER) == 0) {
                            return (NERR_ServerNotStarted);
                        } else {
                            return (NERR_ServiceNotInstalled);
                        }
                        /*NOTREACHED*/

                    } else { // local service started

                        //
                        // In theory, this shouldn't be possible,
                        // but just in case...
                        //
                        UnexpectedMsg("local, can't connect, started");
                        return (NetpRpcStatusToApiStatus(RpcStatus));
                    }
                    /*NOTREACHED*/

                } else { // local, can't connect, service controller API

                    //
                    // Perhaps service controller died?  Bug in RPC?
                    // Service too busy?
                    // Or, may just be out of memory trying to connect...
                    //
                    UnexpectedMsg(
                            "local, can't connect, service controller API" );
                return (NetpRpcStatusToApiStatus(RpcStatus));

                }
                /*NOTREACHED*/

            } else {

                // Local and something besides RPC_S_SERVER_UNAVAILABLE.
                // Perhaps we just ran out of memory, or service too busy.
                UnexpectedMsg( "local, not RPC_S_SERVER_UNAVAILABLE" );
                return (NetpRpcStatusToApiStatus(RpcStatus));
            }
            /*NOTREACHED*/

        } else { // remote machine

            //
            // Local workstation is not started?  (It must be in order to
            // remote downlevel APIs to the other system.)
            //
            if ( (RpcStatus == RPC_S_SERVER_UNAVAILABLE) &&
                ( !NetpIsServiceStarted( (LPTSTR) SERVICE_WORKSTATION))) {

                return (NERR_WkstaNotStarted);

            } else if (RpcStatus == RPC_S_SERVER_UNAVAILABLE) {

                //
                // Local wksta is started, assume remote service isn't...
                // Remote RPC binding failed.  Find out why.
                //
                IF_DEBUG(DLLSTUBS) {
                    NetpKdPrint(( PREFIX_NETAPI
                            FORMAT_LPDEBUG_STRING
                            ": RPC binding failed.\n", DebugName));
                }

                //
                // See if the machine supports RPC.  If it does, we do not
                // try the downlevel calls, but just return the error.
                //
                if (OptionsSupported & SUPPORTS_RPC) {

                    if ( (Flags & NET_REMOTE_FLAG_SVC_CTRL) == 0 ) {

                        NetpAssert( ServiceName != NULL );
                        NetpAssert( (*ServiceName) != TCHAR_EOS );

                        //
                        // This isn't a service controller API, so we can
                        // generate an error code based on the service name.
                        //

                        if (STRICMP( ServiceName,
                                (LPTSTR) SERVICE_WORKSTATION) == 0) {
                            return (NERR_WkstaNotStarted);
                        } else if (STRICMP( ServiceName,
                                (LPTSTR) SERVICE_SERVER) == 0) {
                            return (NERR_ServerNotStarted);
                        } else {
                            return (NERR_ServiceNotInstalled);
                        }
                        /*NOTREACHED*/

                    } else { // local, can't connect, service controller API
                        UnexpectedMsg( "remote svc ctrl: "
                                "machine supports RPC, or other error." );
                        return (NetpRpcStatusToApiStatus(RpcStatus));
                    }
                    /*NOTREACHED*/


                } else { // need to call downlevel

                    // NetpKdPrint(( PREFIX_NETAPI
                    //         FORMAT_LPDEBUG_STRING
                    //         ": call downlevel.\n", DebugName ));

                    //
                    // Caller would insert a call to some RxNet routine
                    // after the NET_REMOTE_RPC_FAILED macro.  This flag is how
                    // we tell the macro whether or not to fall into that call.
                    //

                    *TryDownlevel = TRUE;

                    return (ERROR_NOT_SUPPORTED);  // any error code will do.

                } // need to call downlevel

                /*NOTREACHED*/

            } else {

                //
                // Perhaps just out of memory somewhere, server too busy, etc.
                //
                UnexpectedMsg("remote, not RPC_S_SERVER_UNAVAILABLE");
                return (NetpRpcStatusToApiStatus(RpcStatus));

            }

            /*NOTREACHED*/

        } // remote machine

        /*NOTREACHED*/

    } // exception with error code

    /*NOTREACHED*/

} // NetpHandleRpcFailure
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\started.c ===
/*++

Copyright (c) 1991-1993  Microsoft Corporation

Module Name:

    Started.c

Abstract:

    NetpIsServiceStarted() routine.

Author:

    Rita Wong (ritaw) 10-May-1991

Environment:

    User Mode - Win32

Revision History:

    10-May-1991 RitaW
        Created routine for wksta APIs.
    24-Jul-1991 JohnRo
        Provide NetpIsServiceStarted() in NetLib for use by <netrpc.h> macros.
        Fixed bug (was using wrong field).  Also, this code should use
        NetApiBufferFree() instead of LocalFree().
    16-Sep-1991 JohnRo
        Made changes suggested by PC-LINT.
    18-Feb-1992 RitaW
        Converted to use the Win32 service control APIs.
    06-Mar-1992 JohnRo
        Fixed bug checking current state values.
    02-Nov-1992 JohnRo
        Added NetpIsRemoteServiceStarted().
    30-Jun-1993 JohnRo
        Use NetServiceGetInfo instead of NetServiceControl (much faster).
        Use NetpKdPrint() where possible.
        Use PREFIX_ and FORMAT_ equates.
        Made changes suggested by PC-LINT 5.0

--*/


// These must be included first:

#include <nt.h>                 // (Only needed by NT version of netlib.h)
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>             // IN, BOOL, LPTSTR, etc.
#include <winbase.h>
#include <winsvc.h>             // Win32 service control APIs
#include <lmcons.h>             // NET_API_STATUS (needed by netlib.h et al).

// These may be included in any order:

#include <lmapibuf.h>           // NetApiBufferFree().
#include <lmerr.h>              // NERR_Success.
#include <lmsvc.h>      // LPSERVICE_INFO_2, etc.
#include <netlib.h>     // My prototypes.
#include <netdebug.h>   // NetpKdPrint(), NetpAssert(), FORMAT_ equates.
#include <prefix.h>     // PREFIX_ equates.
#include <tstr.h>       // TCHAR_EOS.


BOOL
NetpIsServiceStarted(
    IN LPWSTR ServiceName
    )

/*++

Routine Description:

    This routine queries the Service Controller to find out if the
    specified service has been started.

Arguments:

    ServiceName - Supplies the name of the service.

Return Value:

    Returns TRUE if the specified service has been started; otherwise
    returns FALSE.  This routine returns FALSE if it got an error
    from calling the Service Controller.

--*/
{

    NET_API_STATUS ApiStatus;
    SC_HANDLE hScManager;
    SC_HANDLE hService;
    SERVICE_STATUS ServiceStatus;


    if ((hScManager = OpenSCManager(
                          NULL,
                          NULL,
                          SC_MANAGER_CONNECT
                          )) == (SC_HANDLE) NULL) {

#if DBG
        ApiStatus = (NET_API_STATUS) GetLastError();
        KdPrintEx((DPFLTR_NETAPI_ID,
                   DPFLTR_WARNING_LEVEL,
                   PREFIX_NETLIB
                   "NetpIsServiceStarted: OpenSCManager failed: "
                   FORMAT_API_STATUS
                   "\n",
                   ApiStatus));
#endif

        return FALSE;
    }

    if ((hService = OpenService(
                        hScManager,
                        ServiceName,
                        SERVICE_QUERY_STATUS
                        )) == (SC_HANDLE) NULL) {

#if DBG
        ApiStatus = (NET_API_STATUS) GetLastError();
        KdPrintEx((DPFLTR_NETAPI_ID,
                   DPFLTR_WARNING_LEVEL,
                   PREFIX_NETLIB
                   "NetpIsServiceStarted: OpenService failed: "
                   FORMAT_API_STATUS
                   "\n",
                   ApiStatus));
#endif

        (void) CloseServiceHandle(hScManager);

        return FALSE;
    }

    if (! QueryServiceStatus(
              hService,
              &ServiceStatus
              )) {

#if DBG
        ApiStatus = GetLastError();
        KdPrintEx((DPFLTR_NETAPI_ID,
                   DPFLTR_WARNING_LEVEL,
                   PREFIX_NETLIB
                   "NetpIsServiceStarted: QueryServiceStatus failed: "
                   FORMAT_API_STATUS
                   "\n",
                   ApiStatus));
#endif

        (void) CloseServiceHandle(hScManager);
        (void) CloseServiceHandle(hService);

        return FALSE;
    }

    (void) CloseServiceHandle(hScManager);
    (void) CloseServiceHandle(hService);

    if ( (ServiceStatus.dwCurrentState == SERVICE_RUNNING) ||
         (ServiceStatus.dwCurrentState == SERVICE_CONTINUE_PENDING) ||
         (ServiceStatus.dwCurrentState == SERVICE_PAUSE_PENDING) ||
         (ServiceStatus.dwCurrentState == SERVICE_PAUSED) ) {

        return TRUE;
    }

    return FALSE;

} // NetpIsServiceStarted
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\secobj.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    secobj.c

Abstract:

    This module provides support routines to simplify the creation of
    security descriptors for user-mode objects.

Author:

    Rita Wong (ritaw) 27-Feb-1991

Environment:

    Contains NT specific code.

Revision History:

    16-Apr-1991 JohnRo
        Include header files for <netlib.h>.

    14 Apr 1992 RichardW
        Changed for modified ACE_HEADER struct.

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>             // DWORD.
#include <lmcons.h>             // NET_API_STATUS.

#include <netlib.h>
#include <lmerr.h>
#include <lmapibuf.h>

#include <netdebug.h>
#include <debuglib.h>
#include <netlibnt.h>

#include <secobj.h>
#include <tstring.h>            // NetpInitOemString().

#if DEVL
#define STATIC
#else
#define STATIC static
#endif // DEVL

//-------------------------------------------------------------------//
//                                                                   //
// Local function prototypes                                         //
//                                                                   //
//-------------------------------------------------------------------//

STATIC
NTSTATUS
NetpInitializeAllowedAce(
    IN  PACCESS_ALLOWED_ACE AllowedAce,
    IN  USHORT AceSize,
    IN  UCHAR InheritFlags,
    IN  UCHAR AceFlags,
    IN  ACCESS_MASK Mask,
    IN  PSID AllowedSid
    );

STATIC
NTSTATUS
NetpInitializeDeniedAce(
    IN  PACCESS_DENIED_ACE DeniedAce,
    IN  USHORT AceSize,
    IN  UCHAR InheritFlags,
    IN  UCHAR AceFlags,
    IN  ACCESS_MASK Mask,
    IN  PSID DeniedSid
    );

STATIC
NTSTATUS
NetpInitializeAuditAce(
    IN  PACCESS_ALLOWED_ACE AuditAce,
    IN  USHORT AceSize,
    IN  UCHAR InheritFlags,
    IN  UCHAR AceFlags,
    IN  ACCESS_MASK Mask,
    IN  PSID AuditSid
    );

//-------------------------------------------------------------------//
//                                                                   //
// Global variables                                                  //
//                                                                   //
//-------------------------------------------------------------------//

//
// NT well-known SIDs
//

PSID NullSid = NULL;                  // No members SID
PSID WorldSid = NULL;                 // All users SID
PSID LocalSid = NULL;                 // NT local users SID
PSID NetworkSid = NULL;               // NT remote users SID
PSID LocalSystemSid = NULL;           // NT system processes SID
PSID BuiltinDomainSid = NULL;         // Domain Id of the Builtin Domain
PSID AuthenticatedUserSid = NULL;     // Authenticated user SID
PSID AnonymousLogonSid = NULL;        // Anonymous Logon SID
PSID LocalServiceSid = NULL;          // Local Service SID

//
// Well Known Aliases.
//
// These are aliases that are relative to the built-in domain.
//

PSID LocalAdminSid = NULL;            // NT local admins SID
PSID AliasAdminsSid = NULL;
PSID AliasUsersSid = NULL;
PSID AliasGuestsSid = NULL;
PSID AliasPowerUsersSid = NULL;
PSID AliasAccountOpsSid = NULL;
PSID AliasSystemOpsSid = NULL;
PSID AliasPrintOpsSid = NULL;
PSID AliasBackupOpsSid = NULL;

#if DBG

typedef struct _STANDARD_ACE {
    ACE_HEADER Header;
    ACCESS_MASK Mask;
    PSID Sid;
} STANDARD_ACE;
typedef STANDARD_ACE *PSTANDARD_ACE;

//
//  The following macros used by DumpAcl(), these macros and DumpAcl() are
//  stolen from private\ntos\se\ctaccess.c (written by robertre) for
//  debugging purposes.
//

//
//  Returns a pointer to the first Ace in an Acl (even if the Acl is empty).
//

#define FirstAce(Acl) ((PVOID)((PUCHAR)(Acl) + sizeof(ACL)))

//
//  Returns a pointer to the next Ace in a sequence (even if the input
//  Ace is the one in the sequence).
//

#define NextAce(Ace) ((PVOID)((PUCHAR)(Ace) + ((PACE_HEADER)(Ace))->AceSize))

STATIC
VOID
DumpAcl(
    IN PACL Acl
    );

#endif //ifdef DBG

//
// Data describing the well-known SIDs created by NetpCreateWellKnownSids.
//

ULONG MakeItCompile1,
      MakeItCompile2,
      MakeItCompile3;


struct _SID_DATA {
    PSID *Sid;
    SID_IDENTIFIER_AUTHORITY IdentifierAuthority;
    ULONG SubAuthority;
} SidData[] = {
 {&NullSid,          SECURITY_NULL_SID_AUTHORITY,  SECURITY_NULL_RID},
 {&WorldSid,         SECURITY_WORLD_SID_AUTHORITY, SECURITY_WORLD_RID},
 {&LocalSid,         SECURITY_LOCAL_SID_AUTHORITY, SECURITY_LOCAL_RID},
 {&NetworkSid,       SECURITY_NT_AUTHORITY,        SECURITY_NETWORK_RID},
 {&LocalSystemSid,   SECURITY_NT_AUTHORITY,        SECURITY_LOCAL_SYSTEM_RID},
 {&BuiltinDomainSid, SECURITY_NT_AUTHORITY,        SECURITY_BUILTIN_DOMAIN_RID},
 {&AuthenticatedUserSid, SECURITY_NT_AUTHORITY,    SECURITY_AUTHENTICATED_USER_RID},
 {&AnonymousLogonSid,SECURITY_NT_AUTHORITY,        SECURITY_ANONYMOUS_LOGON_RID},
 {&LocalServiceSid,  SECURITY_NT_AUTHORITY,        SECURITY_LOCAL_SERVICE_RID}
};

struct _BUILTIN_DOMAIN_SID_DATA {
    PSID *Sid;
    ULONG RelativeId;
} BuiltinDomainSidData[] = {
    { &LocalAdminSid, DOMAIN_ALIAS_RID_ADMINS},
    { &AliasAdminsSid, DOMAIN_ALIAS_RID_ADMINS },
    { &AliasUsersSid, DOMAIN_ALIAS_RID_USERS },
    { &AliasGuestsSid, DOMAIN_ALIAS_RID_GUESTS },
    { &AliasPowerUsersSid, DOMAIN_ALIAS_RID_POWER_USERS },
    { &AliasAccountOpsSid, DOMAIN_ALIAS_RID_ACCOUNT_OPS },
    { &AliasSystemOpsSid, DOMAIN_ALIAS_RID_SYSTEM_OPS },
    { &AliasPrintOpsSid, DOMAIN_ALIAS_RID_PRINT_OPS },
    { &AliasBackupOpsSid, DOMAIN_ALIAS_RID_BACKUP_OPS }
};


NTSTATUS
NetpCreateWellKnownSids(
    IN  PSID DomainId
    )
/*++

Routine Description:

    This function creates some well-known SIDs and store them in global
    variables.

Arguments:

    DomainId - Supplies the Domain SID of the primary domain of this system.
               This can be attained from UaspGetDomainId.

Return Value:

    STATUS_SUCCESS - if successful
    STATUS_NO_MEMORY - if cannot allocate memory for SID

--*/
{
    NTSTATUS ntstatus;
    DWORD i;

    UNREFERENCED_PARAMETER(DomainId);

    //
    // Allocate and initialize well-known SIDs which aren't relative to
    // the domain Id.
    //

    for (i = 0; i < (sizeof(SidData) / sizeof(SidData[0])) ; i++) {

        ntstatus = NetpAllocateAndInitializeSid(
                       SidData[i].Sid,
                       &(SidData[i].IdentifierAuthority),
                       1);

        if (! NT_SUCCESS(ntstatus)) {
            return STATUS_NO_MEMORY;
        }

        *(RtlSubAuthoritySid(*(SidData[i].Sid), 0)) = SidData[i].SubAuthority;
    }

    //
    // Build each SID which is relative to the Builtin Domain Id.
    //

    for ( i = 0;
          i < (sizeof(BuiltinDomainSidData) / sizeof(BuiltinDomainSidData[0]));
          i++) {

        NET_API_STATUS NetStatus;

        NetStatus = NetpDomainIdToSid(
                        BuiltinDomainSid,
                        BuiltinDomainSidData[i].RelativeId,
                        BuiltinDomainSidData[i].Sid );

        if ( NetStatus != NERR_Success ) {
            return STATUS_NO_MEMORY;
        }

    }

    return STATUS_SUCCESS;
}


VOID
NetpFreeWellKnownSids(
    VOID
    )
/*++

Routine Description:

    This function frees up the dynamic memory consumed by the well-known
    SIDs.

Arguments:

    none.

Return Value:

    none

--*/
{
    DWORD i;

    //
    // free up memory allocated for well-known SIDs
    //

    for (i = 0; i < (sizeof(SidData) / sizeof(SidData[0])) ; i++) {

        if( *SidData[i].Sid != NULL ) {
            NetpMemoryFree( *SidData[i].Sid );
            *SidData[i].Sid = NULL;
        }
    }

    //
    // free up memory allocated for Builtin Domain SIDs
    //

    for (i = 0;
            i < (sizeof(BuiltinDomainSidData) /
                sizeof(BuiltinDomainSidData[0])) ;
                    i++) {

        if( *BuiltinDomainSidData[i].Sid != NULL ) {
            NetpMemoryFree( *BuiltinDomainSidData[i].Sid );
            *BuiltinDomainSidData[i].Sid = NULL;
        }
    }

}


NTSTATUS
NetpAllocateAndInitializeSid(
    OUT PSID *Sid,
    IN  PSID_IDENTIFIER_AUTHORITY IdentifierAuthority,
    IN  ULONG SubAuthorityCount
    )
/*++

Routine Description:

    This function allocates memory for a SID and initializes it.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS - if successful
    STATUS_NO_MEMORY - if cannot allocate memory for SID

--*/
{
    *Sid = (PSID) NetpMemoryAllocate(RtlLengthRequiredSid(SubAuthorityCount));

    if (*Sid == NULL) {
        return STATUS_NO_MEMORY;
    }

    RtlInitializeSid(*Sid, IdentifierAuthority, (UCHAR)SubAuthorityCount);

    return STATUS_SUCCESS;
}


NET_API_STATUS
NetpDomainIdToSid(
    IN PSID DomainId,
    IN ULONG RelativeId,
    OUT PSID *Sid
    )
/*++

Routine Description:

    Given a domain Id and a relative ID create a SID

Arguments:

    DomainId - The template SID to use.

    RelativeId - The relative Id to append to the DomainId.

    Sid - Returns a pointer to an allocated buffer containing the resultant
            Sid.  Free this buffer using NetpMemoryFree.

Return Value:

    STATUS_SUCCESS - if successful
    STATUS_NO_MEMORY - if cannot allocate memory for SID

--*/
{
    UCHAR DomainIdSubAuthorityCount; // Number of sub authorities in domain ID

    ULONG SidLength;    // Length of newly allocated SID

    //
    // Allocate a Sid which has one more sub-authority than the domain ID.
    //

    DomainIdSubAuthorityCount = *(RtlSubAuthorityCountSid( DomainId ));
    SidLength = RtlLengthRequiredSid(DomainIdSubAuthorityCount+1);

    if ((*Sid = (PSID) NetpMemoryAllocate( SidLength )) == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Initialize the new SID to have the same inital value as the
    // domain ID.
    //

    if ( !NT_SUCCESS( RtlCopySid( SidLength, *Sid, DomainId ) ) ) {
        NetpMemoryFree( *Sid );
        return NERR_InternalError;
    }

    //
    // Adjust the sub-authority count and
    //  add the relative Id unique to the newly allocated SID
    //

    (*(RtlSubAuthorityCountSid( *Sid ))) ++;
    *RtlSubAuthoritySid( *Sid, DomainIdSubAuthorityCount ) = RelativeId;

    return NERR_Success;
}


NTSTATUS
NetpCreateSecurityDescriptor(
    IN  PACE_DATA AceData,
    IN  ULONG AceCount,
    IN  PSID OwnerSid OPTIONAL,
    IN  PSID GroupSid OPTIONAL,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor
    )
/*++

Routine Description:

    This function creates an absolutes security descriptor containing
    the supplied ACE information.

    A sample usage of this function:

        //
        // Order matters!  These ACEs are inserted into the DACL in the
        // following order.  Security access is granted or denied based on
        // the order of the ACEs in the DACL.
        //

        ACE_DATA AceData[4] = {
            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   GENERIC_ALL,                  &LocalAdminSid},

            {ACCESS_DENIED_ACE_TYPE,  0, 0,
                   GENERIC_ALL,                  &NetworkSid},

            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   WKSTA_CONFIG_GUEST_INFO_GET |
                   WKSTA_CONFIG_USER_INFO_GET,   &DomainUsersSid},

            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   WKSTA_CONFIG_GUEST_INFO_GET,  &DomainGuestsSid}
            };

        return NetpCreateSecurityDescriptor(
                   AceData,
                   4,
                   NullSid,
                   LocalSystemSid,
                   &ConfigurationInfoSd
                   );

Arguments:

    AceData - Supplies the structure of information that describes the DACL.

    AceCount - Supplies the number of entries in AceData structure.

    OwnerSid - Supplies the pointer to the SID of the security descriptor
        owner.  If not specified, a security descriptor with no owner
        will be created.

    GroupSid - Supplies the pointer to the SID of the security descriptor
        primary group.  If not specified, a security descriptor with no primary
        group will be created.

    NewDescriptor - Returns a pointer to the absolute secutiry descriptor
        allocated using NetpMemoryAllocate.

Return Value:

    STATUS_SUCCESS - if successful
    STATUS_NO_MEMORY - if cannot allocate memory for DACL, ACEs, and
        security descriptor.

    Any other status codes returned from the security Rtl routines.

--*/
{

    NTSTATUS ntstatus;
    DWORD i;

    //
    // Pointer to memory dynamically allocated by this routine to hold
    // the absolute security descriptor, the DACL, the SACL, and all the ACEs.
    //
    // +---------------------------------------------------------------+
    // |                     Security Descriptor                       |
    // +-------------------------------+-------+---------------+-------+
    // |          DACL                 | ACE 1 |   .  .  .     | ACE n |
    // +-------------------------------+-------+---------------+-------+
    // |          SACL                 | ACE 1 |   .  .  .     | ACE n |
    // +-------------------------------+-------+---------------+-------+
    //

    PSECURITY_DESCRIPTOR AbsoluteSd = NULL;
    PACL Dacl = NULL;   // Pointer to the DACL portion of above buffer
    PACL Sacl = NULL;   // Pointer to the SACL portion of above buffer

    DWORD DaclSize = sizeof(ACL);
    DWORD SaclSize = sizeof(ACL);
    DWORD MaxAceSize = 0;
    PVOID MaxAce = NULL;

    LPBYTE CurrentAvailable;
    DWORD Size;

    ASSERT( AceCount > 0 );

    //
    // Compute the total size of the DACL and SACL ACEs and the maximum
    // size of any ACE.
    //

    for (i = 0; i < AceCount; i++) {
        DWORD AceSize;

        AceSize = RtlLengthSid(*(AceData[i].Sid));

        switch (AceData[i].AceType) {
        case ACCESS_ALLOWED_ACE_TYPE:
            AceSize += sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG);
            DaclSize += AceSize;
            break;

        case ACCESS_DENIED_ACE_TYPE:
            AceSize += sizeof(ACCESS_DENIED_ACE) - sizeof(ULONG);
            DaclSize += AceSize;
            break;

        case SYSTEM_AUDIT_ACE_TYPE:
            AceSize += sizeof(SYSTEM_AUDIT_ACE) - sizeof(ULONG);
            SaclSize += AceSize;
            break;

        default:
            return STATUS_INVALID_PARAMETER;
        }

        MaxAceSize = max( MaxAceSize, AceSize );
    }

    //
    // Allocate a chunk of memory large enough the security descriptor
    // the DACL, the SACL and all ACEs.
    //
    // A security descriptor is of opaque data type but
    // SECURITY_DESCRIPTOR_MIN_LENGTH is the right size.
    //

    Size = SECURITY_DESCRIPTOR_MIN_LENGTH;
    if ( DaclSize != sizeof(ACL) ) {
        Size += DaclSize;
    }
    if ( SaclSize != sizeof(ACL) ) {
        Size += SaclSize;
    }

    if ((AbsoluteSd = NetpMemoryAllocate( Size )) == NULL) {
        IF_DEBUG(SECURITY) {
            NetpKdPrint(( "NetpCreateSecurityDescriptor Fail Create abs SD\n"));
        }
        ntstatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    //
    // Initialize the Dacl and Sacl
    //

    CurrentAvailable = (LPBYTE)AbsoluteSd + SECURITY_DESCRIPTOR_MIN_LENGTH;

    if ( DaclSize != sizeof(ACL) ) {
        Dacl = (PACL)CurrentAvailable;
        CurrentAvailable += DaclSize;

        ntstatus = RtlCreateAcl( Dacl, DaclSize, ACL_REVISION );

        if ( !NT_SUCCESS(ntstatus) ) {
            IF_DEBUG(SECURITY) {
                NetpKdPrint(( "NetpCreateSecurityDescriptor Fail DACL Create ACL\n"));
            }
            goto Cleanup;
        }
    }

    if ( SaclSize != sizeof(ACL) ) {
        Sacl = (PACL)CurrentAvailable;
        CurrentAvailable += SaclSize;

        ntstatus = RtlCreateAcl( Sacl, SaclSize, ACL_REVISION );

        if ( !NT_SUCCESS(ntstatus) ) {
            IF_DEBUG(SECURITY) {
                NetpKdPrint(( "NetpCreateSecurityDescriptor Fail SACL Create ACL\n"));
            }
            goto Cleanup;
        }
    }

    //
    // Allocate a temporary buffer big enough for the biggest ACE.
    //

    if ((MaxAce = NetpMemoryAllocate( MaxAceSize )) == NULL ) {
        IF_DEBUG(SECURITY) {
            NetpKdPrint(( "NetpCreateSecurityDescriptor Fail Create max ace\n"));
        }
        ntstatus = STATUS_NO_MEMORY;
        goto Cleanup;
    }

    //
    // Initialize each ACE, and append it into the end of the DACL or SACL.
    //

    for (i = 0; i < AceCount; i++) {
        DWORD AceSize;
        PACL CurrentAcl;

        AceSize = RtlLengthSid(*(AceData[i].Sid));

        switch (AceData[i].AceType) {
        case ACCESS_ALLOWED_ACE_TYPE:

            AceSize += sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG);
            CurrentAcl = Dacl;
            ntstatus = NetpInitializeAllowedAce(
                           MaxAce,
                           (USHORT) AceSize,
                           AceData[i].InheritFlags,
                           AceData[i].AceFlags,
                           AceData[i].Mask,
                           *(AceData[i].Sid)
                           );
            break;

        case ACCESS_DENIED_ACE_TYPE:
            AceSize += sizeof(ACCESS_DENIED_ACE) - sizeof(ULONG);
            CurrentAcl = Dacl;
            ntstatus = NetpInitializeDeniedAce(
                           MaxAce,
                           (USHORT) AceSize,
                           AceData[i].InheritFlags,
                           AceData[i].AceFlags,
                           AceData[i].Mask,
                           *(AceData[i].Sid)
                           );
            break;

        case SYSTEM_AUDIT_ACE_TYPE:
            AceSize += sizeof(SYSTEM_AUDIT_ACE) - sizeof(ULONG);
            CurrentAcl = Sacl;
            ntstatus = NetpInitializeAuditAce(
                           MaxAce,
                           (USHORT) AceSize,
                           AceData[i].InheritFlags,
                           AceData[i].AceFlags,
                           AceData[i].Mask,
                           *(AceData[i].Sid)
                           );
            break;
        }

        if ( !NT_SUCCESS( ntstatus ) ) {
            IF_DEBUG(SECURITY) {
                NetpKdPrint(( "NetpCreateSecurityDescriptor Fail InitAce i: %d ntstatus: %lx\n", i, ntstatus));
            }
            goto Cleanup;
        }

        //
        // Append the initialized ACE to the end of DACL or SACL
        //

        if (! NT_SUCCESS (ntstatus = RtlAddAce(
                                         CurrentAcl,
                                         ACL_REVISION,
                                         MAXULONG,
                                         MaxAce,
                                         AceSize
                                         ))) {
            IF_DEBUG(SECURITY) {
                NetpKdPrint(( "NetpCreateSecurityDescriptor Fail add ace i: %d ntstatus: %lx\n", i, ntstatus));
            }
            goto Cleanup;
        }
    }

#if DBG
    DumpAcl(Dacl);
    DumpAcl(Sacl);
#endif

    //
    // Create the security descriptor with absolute pointers to SIDs
    // and ACLs.
    //
    // Owner = OwnerSid
    // Group = GroupSid
    // Dacl  = Dacl
    // Sacl  = Sacl
    //

    if (! NT_SUCCESS(ntstatus = RtlCreateSecurityDescriptor(
                                    AbsoluteSd,
                                    SECURITY_DESCRIPTOR_REVISION
                                    ))) {
        goto Cleanup;
    }

    if (! NT_SUCCESS(ntstatus = RtlSetOwnerSecurityDescriptor(
                                    AbsoluteSd,
                                    OwnerSid,
                                    FALSE
                                    ))) {
        goto Cleanup;
    }

    if (! NT_SUCCESS(ntstatus = RtlSetGroupSecurityDescriptor(
                                    AbsoluteSd,
                                    GroupSid,
                                    FALSE
                                    ))) {
        goto Cleanup;
    }

    if (! NT_SUCCESS(ntstatus = RtlSetDaclSecurityDescriptor(
                                    AbsoluteSd,
                                    TRUE,
                                    Dacl,
                                    FALSE
                                    ))) {
        goto Cleanup;
    }

    if (! NT_SUCCESS(ntstatus = RtlSetSaclSecurityDescriptor(
                                    AbsoluteSd,
                                    FALSE,
                                    Sacl,
                                    FALSE
                                    ))) {
        goto Cleanup;
    }

    //
    // Done
    //

    ntstatus = STATUS_SUCCESS;

    //
    // Clean up
    //

Cleanup:
    //
    // Either return the security descriptor to the caller or delete it
    //

    if ( NT_SUCCESS( ntstatus ) ) {
        *NewDescriptor = AbsoluteSd;
    } else if ( AbsoluteSd != NULL ) {
        NetpMemoryFree(AbsoluteSd);
    }

    //
    // Delete the temporary ACE
    //

    if ( MaxAce != NULL ) {
        NetpMemoryFree( MaxAce );
    }
    return ntstatus;
}


NTSTATUS
NetpCreateSecurityObject(
    IN  PACE_DATA AceData,
    IN  ULONG AceCount,
    IN  PSID OwnerSid,
    IN  PSID GroupSid,
    IN  PGENERIC_MAPPING GenericMapping,
    OUT PSECURITY_DESCRIPTOR *NewDescriptor
    )
/*++

Routine Description:

    This function creates the DACL for the security descriptor based on
    on the ACE information specified, and creates the security descriptor
    which becomes the user-mode security object.

    A sample usage of this function:

        //
        // Structure that describes the mapping of Generic access rights to
        // object specific access rights for the ConfigurationInfo object.
        //

        GENERIC_MAPPING WsConfigInfoMapping = {
            STANDARD_RIGHTS_READ            |      // Generic read
                WKSTA_CONFIG_GUEST_INFO_GET |
                WKSTA_CONFIG_USER_INFO_GET  |
                WKSTA_CONFIG_ADMIN_INFO_GET,
            STANDARD_RIGHTS_WRITE |                // Generic write
                WKSTA_CONFIG_INFO_SET,
            STANDARD_RIGHTS_EXECUTE,               // Generic execute
            WKSTA_CONFIG_ALL_ACCESS                // Generic all
            };

        //
        // Order matters!  These ACEs are inserted into the DACL in the
        // following order.  Security access is granted or denied based on
        // the order of the ACEs in the DACL.
        //

        ACE_DATA AceData[4] = {
            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   GENERIC_ALL,                  &LocalAdminSid},

            {ACCESS_DENIED_ACE_TYPE,  0, 0,
                   GENERIC_ALL,                  &NetworkSid},

            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   WKSTA_CONFIG_GUEST_INFO_GET |
                   WKSTA_CONFIG_USER_INFO_GET,   &DomainUsersSid},

            {ACCESS_ALLOWED_ACE_TYPE, 0, 0,
                   WKSTA_CONFIG_GUEST_INFO_GET,  &DomainGuestsSid}
            };

        return NetpCreateSecurityObject(
                   AceData,
                   4,
                   NullSid,
                   LocalSystemSid,
                   &WsConfigInfoMapping,
                   &ConfigurationInfoSd
                   );

Arguments:

    AceData - Supplies the structure of information that describes the DACL.

    AceCount - Supplies the number of entries in AceData structure.

    OwnerSid - Supplies the pointer to the SID of the security descriptor
        owner.

    GroupSid - Supplies the pointer to the SID of the security descriptor
        primary group.

    GenericMapping - Supplies the pointer to a generic mapping array denoting
        the mapping between each generic right to specific rights.

    NewDescriptor - Returns a pointer to the self-relative security descriptor
        which represents the user-mode object.

Return Value:

    STATUS_SUCCESS - if successful
    STATUS_NO_MEMORY - if cannot allocate memory for DACL, ACEs, and
        security descriptor.

    Any other status codes returned from the security Rtl routines.

    NOTE : the security object created by calling this function may be
                freed up by calling NetpDeleteSecurityObject().

--*/
{

    NTSTATUS ntstatus;
    PSECURITY_DESCRIPTOR AbsoluteSd;
    HANDLE TokenHandle;


    ntstatus = NetpCreateSecurityDescriptor(
                   AceData,
                   AceCount,
                   OwnerSid,
                   GroupSid,
                   &AbsoluteSd
                   );

    if (! NT_SUCCESS(ntstatus)) {
        NetpKdPrint(("[Netlib] NetpCreateSecurityDescriptor returned %08lx\n",
                     ntstatus));
        return ntstatus;
    }

    ntstatus = NtOpenProcessToken(
                   NtCurrentProcess(),
                   TOKEN_QUERY,
                   &TokenHandle
                   );

    if (! NT_SUCCESS(ntstatus)) {
        NetpKdPrint(("[Netlib] NtOpenProcessToken returned %08lx\n", ntstatus));
        NetpMemoryFree(AbsoluteSd);
        return ntstatus;
    }

    //
    // Create the security object (a user-mode object is really a pseudo-
    // object represented by a security descriptor that have relative
    // pointers to SIDs and ACLs).  This routine allocates the memory to
    // hold the relative security descriptor so the memory allocated for the
    // DACL, ACEs, and the absolute descriptor can be freed.
    //
    ntstatus = RtlNewSecurityObject(
                   NULL,                   // Parent descriptor
                   AbsoluteSd,             // Creator descriptor
                   NewDescriptor,          // Pointer to new descriptor
                   FALSE,                  // Is directory object
                   TokenHandle,            // Token
                   GenericMapping          // Generic mapping
                   );

    NtClose(TokenHandle);

    if (! NT_SUCCESS(ntstatus)) {
        NetpKdPrint(("[Netlib] RtlNewSecurityObject returned %08lx\n",
                     ntstatus));
    }

    //
    // Free dynamic memory before returning
    //
    NetpMemoryFree(AbsoluteSd);
    return ntstatus;
}


NTSTATUS
NetpDeleteSecurityObject(
    IN PSECURITY_DESCRIPTOR *Descriptor
    )
/*++

Routine Description:

    This function deletes a security object that was created by calling
    NetpCreateSecurityObject() function.

Arguments:

    Descriptor - Returns a pointer to the self-relative security descriptor
        which represents the user-mode object.

Return Value:

    STATUS_SUCCESS - if successful

--*/
{

    return( RtlDeleteSecurityObject( Descriptor ) );
}


STATIC
NTSTATUS
NetpInitializeAllowedAce(
    IN  PACCESS_ALLOWED_ACE AllowedAce,
    IN  USHORT AceSize,
    IN  UCHAR InheritFlags,
    IN  UCHAR AceFlags,
    IN  ACCESS_MASK Mask,
    IN  PSID AllowedSid
    )
/*++

Routine Description:

    This function assigns the specified ACE values into an allowed type ACE.

Arguments:

    AllowedAce - Supplies a pointer to the ACE that is initialized.

    AceSize - Supplies the size of the ACE in bytes.

    InheritFlags - Supplies ACE inherit flags.

    AceFlags - Supplies ACE type specific control flags.

    Mask - Supplies the allowed access masks.

    AllowedSid - Supplies the pointer to the SID of user/group which is allowed
        the specified access.

Return Value:

    Returns status from RtlCopySid.

--*/
{
    AllowedAce->Header.AceType = ACCESS_ALLOWED_ACE_TYPE;
    AllowedAce->Header.AceSize = AceSize;
    AllowedAce->Header.AceFlags = AceFlags | InheritFlags;

    AllowedAce->Mask = Mask;

    return RtlCopySid(
               RtlLengthSid(AllowedSid),
               &(AllowedAce->SidStart),
               AllowedSid
               );
}


STATIC
NTSTATUS
NetpInitializeDeniedAce(
    IN  PACCESS_DENIED_ACE DeniedAce,
    IN  USHORT AceSize,
    IN  UCHAR InheritFlags,
    IN  UCHAR AceFlags,
    IN  ACCESS_MASK Mask,
    IN  PSID DeniedSid
    )
/*++

Routine Description:

    This function assigns the specified ACE values into a denied type ACE.

Arguments:

    DeniedAce - Supplies a pointer to the ACE that is initialized.

    AceSize - Supplies the size of the ACE in bytes.

    InheritFlags - Supplies ACE inherit flags.

    AceFlags - Supplies ACE type specific control flags.

    Mask - Supplies the denied access masks.

    AllowedSid - Supplies the pointer to the SID of user/group which is denied
        the specified access.

Return Value:

    Returns status from RtlCopySid.

--*/
{
    DeniedAce->Header.AceType = ACCESS_DENIED_ACE_TYPE;
    DeniedAce->Header.AceSize = AceSize;
    DeniedAce->Header.AceFlags = AceFlags | InheritFlags;

    DeniedAce->Mask = Mask;

    return RtlCopySid(
               RtlLengthSid(DeniedSid),
               &(DeniedAce->SidStart),
               DeniedSid
               );
}


STATIC
NTSTATUS
NetpInitializeAuditAce(
    IN  PACCESS_ALLOWED_ACE AuditAce,
    IN  USHORT AceSize,
    IN  UCHAR InheritFlags,
    IN  UCHAR AceFlags,
    IN  ACCESS_MASK Mask,
    IN  PSID AuditSid
    )
/*++

Routine Description:

    This function assigns the specified ACE values into an audit type ACE.

Arguments:

    AuditAce - Supplies a pointer to the ACE that is initialized.

    AceSize - Supplies the size of the ACE in bytes.

    InheritFlags - Supplies ACE inherit flags.

    AceFlags - Supplies ACE type specific control flags.

    Mask - Supplies the allowed access masks.

    AuditSid - Supplies the pointer to the SID of user/group which is to be
        audited.

Return Value:

    Returns status from RtlCopySid.

--*/
{
    AuditAce->Header.AceType = SYSTEM_AUDIT_ACE_TYPE;
    AuditAce->Header.AceSize = AceSize;
    AuditAce->Header.AceFlags = AceFlags | InheritFlags;

    AuditAce->Mask = Mask;

    return RtlCopySid(
               RtlLengthSid(AuditSid),
               &(AuditAce->SidStart),
               AuditSid
               );
}



#if DBG

STATIC
VOID
DumpAcl(
    IN PACL Acl
    )
/*++

Routine Description:

    This routine dumps via (NetpKdPrint) an Acl for debug purposes.  It is
    specialized to dump standard aces.

Arguments:

    Acl - Supplies the Acl to dump

Return Value:

    None

--*/
{
    ULONG i;
    PSTANDARD_ACE Ace;

    IF_DEBUG(SECURITY) {

        NetpKdPrint(("DumpAcl @%08lx\n", Acl));

        //
        //  Check if the Acl is null
        //

        if (Acl == NULL) {
            return;
        }

        //
        //  Dump the Acl header
        //

        NetpKdPrint(("    Revision: %02x", Acl->AclRevision));
        NetpKdPrint(("    Size: %04x", Acl->AclSize));
        NetpKdPrint(("    AceCount: %04x\n", Acl->AceCount));

        //
        //  Now for each Ace we want do dump it
        //

        for (i = 0, Ace = FirstAce(Acl);
             i < Acl->AceCount;
             i++, Ace = NextAce(Ace) ) {

            //
            //  print out the ace header
            //

            NetpKdPrint((" AceHeader: %08lx ", *(PULONG)Ace));

            //
            //  special case on the standard ace types
            //

            if ((Ace->Header.AceType == ACCESS_ALLOWED_ACE_TYPE) ||
                (Ace->Header.AceType == ACCESS_DENIED_ACE_TYPE) ||
                (Ace->Header.AceType == SYSTEM_AUDIT_ACE_TYPE) ||
                (Ace->Header.AceType == SYSTEM_ALARM_ACE_TYPE)) {

                //
                //  The following array is indexed by ace types and must
                //  follow the allowed, denied, audit, alarm seqeuence
                //

                static PCHAR AceTypes[] = { "Access Allowed",
                                            "Access Denied ",
                                            "System Audit  ",
                                            "System Alarm  "
                                          };

                NetpKdPrint((AceTypes[Ace->Header.AceType]));
                NetpKdPrint(("\nAccess Mask: %08lx ", Ace->Mask));

            } else {

                NetpKdPrint(("Unknown Ace Type\n"));

            }

            NetpKdPrint(("\n"));

            NetpKdPrint(("AceSize = %d\n",Ace->Header.AceSize));
            NetpKdPrint(("Ace Flags = "));
            if (Ace->Header.AceFlags & OBJECT_INHERIT_ACE) {
                NetpKdPrint(("OBJECT_INHERIT_ACE\n"));
                NetpKdPrint(("                   "));
            }
            if (Ace->Header.AceFlags & CONTAINER_INHERIT_ACE) {
                NetpKdPrint(("CONTAINER_INHERIT_ACE\n"));
                NetpKdPrint(("                   "));
            }

            if (Ace->Header.AceFlags & NO_PROPAGATE_INHERIT_ACE) {
                NetpKdPrint(("NO_PROPAGATE_INHERIT_ACE\n"));
                NetpKdPrint(("                   "));
            }

            if (Ace->Header.AceFlags & INHERIT_ONLY_ACE) {
                NetpKdPrint(("INHERIT_ONLY_ACE\n"));
                NetpKdPrint(("                   "));
            }

            if (Ace->Header.AceFlags & SUCCESSFUL_ACCESS_ACE_FLAG) {
                NetpKdPrint(("SUCCESSFUL_ACCESS_ACE_FLAG\n"));
                NetpKdPrint(("            "));
            }

            if (Ace->Header.AceFlags & FAILED_ACCESS_ACE_FLAG) {
                NetpKdPrint(("FAILED_ACCESS_ACE_FLAG\n"));
                NetpKdPrint(("            "));
            }

            NetpKdPrint(("\n"));

        }
    }

}

#endif // if DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\sessinfo.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    SessInfo.c

Abstract:

    This file contains NetpSessionStructureInfo().

Author:

    John Rogers (JohnRo) 18-Oct-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    18-Oct-1991 JohnRo
        Implement downlevel NetSession APIs.
    18-Oct-1991 JohnRo
        Quiet debug output.  sesiX_cname is not a UNC name.
    20-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.

--*/

// These must be included first:

#include <windef.h>             // IN, DWORD, etc.
#include <lmcons.h>             // LM20_ equates, NET_API_STATUS, etc.
#include <rap.h>                // LPDESC, needed by <strucinf.h>.

// These may be included in any order:

#include <debuglib.h>           // IF_DEBUG().
#include <lmerr.h>              // ERROR_ and NERR_ equates.
#include <lmshare.h>            // SESSION_INFO_2, etc.
#include <netlib.h>             // NetpSetOptionalArg().
#include <netdebug.h>           // NetpAssert().
#include <remdef.h>             // REM16_, REM32_, REMSmb_ equates.
#include <strucinf.h>           // My prototype.


// Level 0.
#define MAX_SESSION_0_STRING_LENGTH \
        (MAX_PATH+1)
#define MAX_SESSION_0_STRING_SIZE \
        (MAX_SESSION_0_STRING_LENGTH * sizeof(TCHAR))

// Level 1 is superset of 0.
#define MAX_SESSION_1_STRING_LENGTH \
        (MAX_SESSION_0_STRING_LENGTH + LM20_UNLEN+1)
#define MAX_SESSION_1_STRING_SIZE \
        (MAX_SESSION_1_STRING_LENGTH * sizeof(TCHAR))

// Level 2 is superset of 1.
#define MAX_SESSION_2_STRING_LENGTH \
        (MAX_SESSION_1_STRING_LENGTH + CLTYPE_LEN+1)
#define MAX_SESSION_2_STRING_SIZE \
        (MAX_SESSION_2_STRING_LENGTH * sizeof(TCHAR))

// Level 10 is unique.
#define MAX_SESSION_10_STRING_LENGTH \
        (MAX_PATH+1 + LM20_UNLEN+1)
#define MAX_SESSION_10_STRING_SIZE \
        (MAX_SESSION_10_STRING_LENGTH * sizeof(TCHAR))


NET_API_STATUS
NetpSessionStructureInfo (
    IN DWORD Level,
    IN DWORD ParmNum,  // Use PARMNUM_ALL if not applicable.
    IN BOOL Native,    // Should sizes be native or RAP?
    OUT LPDESC * DataDesc16 OPTIONAL,
    OUT LPDESC * DataDesc32 OPTIONAL,
    OUT LPDESC * DataDescSmb OPTIONAL,
    OUT LPDWORD MaxSize OPTIONAL,
    OUT LPDWORD FixedSize OPTIONAL,
    OUT LPDWORD StringSize OPTIONAL
    )

{
    DBG_UNREFERENCED_PARAMETER(ParmNum);

    NetpAssert( Native );

    //
    // Decide what to do based on the info level.
    //
    switch (Level) {

#define SetSizes(fixed,variable) \
    { \
        NetpSetOptionalArg( MaxSize, (fixed) + (variable) ); \
        NetpSetOptionalArg( FixedSize, (fixed) ); \
        NetpSetOptionalArg( StringSize, (variable) ); \
    }

    case 0 :
        NetpSetOptionalArg( DataDesc16, REM16_session_info_0 );
        NetpSetOptionalArg( DataDesc32, REM32_session_info_0 );
        NetpSetOptionalArg( DataDescSmb, REMSmb_session_info_0 );
        SetSizes( sizeof(SESSION_INFO_0), MAX_SESSION_0_STRING_SIZE );
        break;

    case 1 :
        NetpSetOptionalArg( DataDesc16, REM16_session_info_1 );
        NetpSetOptionalArg( DataDesc32, REM32_session_info_1 );
        NetpSetOptionalArg( DataDescSmb, REMSmb_session_info_1 );
        SetSizes( sizeof(SESSION_INFO_1), MAX_SESSION_1_STRING_SIZE );
        break;

    case 2 :
        NetpSetOptionalArg( DataDesc16, REM16_session_info_2 );
        NetpSetOptionalArg( DataDesc32, REM32_session_info_2 );
        NetpSetOptionalArg( DataDescSmb, REMSmb_session_info_2 );
        SetSizes( sizeof(SESSION_INFO_2), MAX_SESSION_2_STRING_SIZE );
        break;

    case 10 :
        NetpSetOptionalArg( DataDesc16, REM16_session_info_10 );
        NetpSetOptionalArg( DataDesc32, REM32_session_info_10 );
        NetpSetOptionalArg( DataDescSmb, REMSmb_session_info_10 );
        SetSizes( sizeof(SESSION_INFO_10), MAX_SESSION_10_STRING_SIZE );
        break;

    default :
        return (ERROR_INVALID_LEVEL);
    }

    IF_DEBUG(STRUCINF) {
        if (DataDesc16) {
            NetpKdPrint(( "NetpSessionStructureInfo: desc 16 is " FORMAT_LPDESC
                    ".\n", *DataDesc16 ));
        }
        if (DataDesc32) {
            NetpKdPrint(( "NetpSessionStructureInfo: desc 32 is " FORMAT_LPDESC
                    ".\n", *DataDesc32 ));
        }
        if (DataDescSmb) {
            NetpKdPrint(( "NetpSessionStructureInfo: desc Smb is " FORMAT_LPDESC
                    ".\n", *DataDescSmb ));
        }
    }
    return (NERR_Success);

} // NetpSessionStructureInfo
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\secobj2.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    secobj.c

Abstract:

    This module provides support routines to simplify the creation of
    security descriptors for user-mode objects.

Author:

    Cliff Van Dyke (CliffV) 09-Feb-1994

Environment:

    Contains NT specific code.

Revision History:

    Cliff Van Dyke (CliffV) 09-Feb-1994
        Split off from secobj.c so NtLmSsp can reference secobj.c
        without loading the rpc libaries.

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>            // DWORD.
#include <lmcons.h>             // NET_API_STATUS.

#include <netlib.h>
#include <lmerr.h>

#include <netdebug.h>
#include <debuglib.h>

#include <rpc.h>
#include <rpcutil.h>

#include <secobj.h>



NET_API_STATUS
NetpAccessCheckAndAudit(
    IN  LPTSTR SubsystemName,
    IN  LPTSTR ObjectTypeName,
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN  ACCESS_MASK DesiredAccess,
    IN  PGENERIC_MAPPING GenericMapping
    )
/*++

Routine Description:

    This function impersonates the caller so that it can perform access
    validation using NtAccessCheckAndAuditAlarm; and reverts back to
    itself before returning.

Arguments:

    SubsystemName - Supplies a name string identifying the subsystem
        calling this routine.

    ObjectTypeName - Supplies the name of the type of the object being
        accessed.

    SecurityDescriptor - A pointer to the Security Descriptor against which
        acccess is to be checked.

    DesiredAccess - Supplies desired acccess mask.  This mask must have been
        previously mapped to contain no generic accesses.

    GenericMapping - Supplies a pointer to the generic mapping associated
        with this object type.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{

    NTSTATUS NtStatus;
    RPC_STATUS RpcStatus;
    BOOLEAN fWasEnabled;

    UNICODE_STRING Subsystem;
    UNICODE_STRING ObjectType;
    UNICODE_STRING ObjectName;

#ifndef UNICODE
    OEM_STRING AnsiString;
#endif

    ACCESS_MASK GrantedAccess;
    BOOLEAN GenerateOnClose;
    NTSTATUS AccessStatus;


#ifdef UNICODE
    RtlInitUnicodeString(&Subsystem, SubsystemName);
    RtlInitUnicodeString(&ObjectType, ObjectTypeName);
#else
    NetpInitOemString( &AnsiString, SubsystemName );
    NtStatus = RtlOemStringToUnicodeString(
                   &Subsystem,
                   &AnsiString,
                   TRUE
                   );

    if ( !NT_SUCCESS( NtStatus )) {
        NetpKdPrint(("[Netlib] Error calling RtlOemStringToUnicodeString %08lx\n",
                     NtStatus));
        return NetpNtStatusToApiStatus( NtStatus );
    }

    NetpInitOemString( &AnsiString, ObjectTypeName );

    NtStatus = RtlOemStringToUnicodeString(&ObjectType,
                                           &AnsiString,
                                           TRUE);

    if ( !NT_SUCCESS( NtStatus )) {
        NetpKdPrint(("[Netlib] Error calling RtlOemStringToUnicodeString %08lx\n",
                     NtStatus));
        RtlFreeUnicodeString( &Subsystem );
        return NetpNtStatusToApiStatus( NtStatus );
    }
#endif

    //
    // Make sure SE_AUDIT_PRIVILEGE is enabled for this process (rather
    // than the thread) since the audit privilege is checked in the process
    // token (and not the thread token).  Leave it enabled since there's
    // no harm in doing so once it's been enabled (since the process needs
    // to have the privilege in the first place).
    //

    RtlAdjustPrivilege(SE_AUDIT_PRIVILEGE,
                       TRUE,
                       FALSE,
                       &fWasEnabled);

    RtlInitUnicodeString(&ObjectName, NULL);             // No object name

    if ((RpcStatus = RpcImpersonateClient(NULL)) != RPC_S_OK) {
        NetpKdPrint(("[Netlib] Failed to impersonate client %08lx\n",
                     RpcStatus));
        return NetpRpcStatusToApiStatus(RpcStatus);
    }

    NtStatus = NtAccessCheckAndAuditAlarm(
                   &Subsystem,
                   NULL,                        // No handle for object
                   &ObjectType,
                   &ObjectName,
                   SecurityDescriptor,
                   DesiredAccess,
                   GenericMapping,
                   FALSE,
                   &GrantedAccess,
                   &AccessStatus,
                   &GenerateOnClose
                   );

#ifndef UNICODE
    RtlFreeUnicodeString( &Subsystem );
    RtlFreeUnicodeString( &ObjectType );
#endif

    if ((RpcStatus = RpcRevertToSelf()) != RPC_S_OK) {
        NetpKdPrint(("[Netlib] Fail to revert to self %08lx\n", RpcStatus));
        NetpAssert(FALSE);
    }

    if (! NT_SUCCESS(NtStatus)) {
        NetpKdPrint(("[Netlib] Error calling NtAccessCheckAndAuditAlarm %08lx\n",
                     NtStatus));
        return ERROR_ACCESS_DENIED;
    }

    if (AccessStatus != STATUS_SUCCESS) {
        IF_DEBUG(SECURITY) {
            NetpKdPrint(("[Netlib] Access status is %08lx\n", AccessStatus));
        }
        return ERROR_ACCESS_DENIED;
    }

    return NERR_Success;
}



NET_API_STATUS
NetpAccessCheck(
    IN  PSECURITY_DESCRIPTOR SecurityDescriptor,
    IN  ACCESS_MASK DesiredAccess,
    IN  PGENERIC_MAPPING GenericMapping
    )
/*++

Routine Description:

    This function impersonates the caller so that it can perform access
    validation using NtAccessCheck; and reverts back to
    itself before returning.

    This routine differs from NetpAccessCheckAndAudit in that it doesn't require
    the caller to have SE_AUDIT_PRIVILEGE nor does it generate audits.
    That is typically fine since the passed in security descriptor typically doesn't
    have a SACL requesting an audit.

Arguments:

    SecurityDescriptor - A pointer to the Security Descriptor against which
        acccess is to be checked.

    DesiredAccess - Supplies desired acccess mask.  This mask must have been
        previously mapped to contain no generic accesses.

    GenericMapping - Supplies a pointer to the generic mapping associated
        with this object type.

Return Value:

    NET_API_STATUS - NERR_Success or reason for failure.

--*/
{
    NET_API_STATUS NetStatus;
    NET_API_STATUS TempStatus;

    HANDLE ClientToken = NULL;

    DWORD GrantedAccess;
    BOOL AccessStatus;
    BYTE PrivilegeSet[500]; // Large buffer
    DWORD PrivilegeSetSize;


    //
    // Impersonate the client.
    //

    NetStatus = RpcImpersonateClient(NULL);

    if ( NetStatus != RPC_S_OK ) {
        NetpKdPrint(("[Netlib] Failed to impersonate client %08lx\n",
                     NetStatus));
        return NetpRpcStatusToApiStatus(NetStatus);
    }

    //
    // Open the impersonated token.
    //

    if ( !OpenThreadToken( GetCurrentThread(),
                           TOKEN_QUERY,
                           TRUE, // Use NtLmSvc security context to open token
                           &ClientToken )) {

        NetStatus = GetLastError();
        NetpKdPrint(("[Netlib] Error calling GetCurrentThread %ld\n",
                     NetStatus));

        goto Cleanup;
    }

    //
    // Check if the client has the required access.
    //

    PrivilegeSetSize = sizeof(PrivilegeSet);

    if ( !AccessCheck( SecurityDescriptor,
                       ClientToken,
                       DesiredAccess,
                       GenericMapping,
                       (PPRIVILEGE_SET) &PrivilegeSet,
                       &PrivilegeSetSize,
                       &GrantedAccess,
                       &AccessStatus ) ) {

        NetStatus = GetLastError();
        NetpKdPrint(("[Netlib] Error calling AccessCheck %ld\n",
                     NetStatus));

        goto Cleanup;

    }

    if ( !AccessStatus ) {
        NetStatus = GetLastError();
        IF_DEBUG(SECURITY) {
            NetpKdPrint(("[Netlib] Access status is %ld\n", NetStatus ));
        }
        goto Cleanup;
    }

    //
    // Success
    //

    NetStatus = NERR_Success;

    //
    // Free locally used resources
    //
Cleanup:
    TempStatus = RpcRevertToSelf();
    if ( TempStatus != RPC_S_OK ) {
        NetpKdPrint(("[Netlib] Fail to revert to self %08lx\n", TempStatus));
        NetpAssert(FALSE);
    }

    if ( ClientToken != NULL ) {
        CloseHandle( ClientToken );
    }

    return NetStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\strtail.c ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    strtail.c

Abstract:

    Contains:

        strtail
        ReverseString

Author:

    Richard L. Firth (rfirth) 04-Apr-1991

Revision History:

--*/

#include "nticanon.h"

//
// prototypes
//

LPTSTR
ReverseString(
    IN OUT  LPTSTR  String
    );

//
// routines
//

LPTSTR
strtail(
    IN  LPTSTR str1,
    IN  LPTSTR str2
    )

/*++

Routine Description:

    strtail returns a pointer to the longest trailing substring within str1
    consisting of characters contained in the set pointed at by str2

Arguments:

    str1    pointer to string in which to find longest trailing substring
    str2    pointer to string of characters commprising substring

Return Value:

    pointer to longest trailing substring or end of string

--*/

{
    int index;

    //
    // reverse subject string
    // get index of first non-matching character in target string
    // re-reverse subject string
    //

    ReverseString(str1);
    index = STRSPN(str1, str2);
    ReverseString(str1);
    return str1+STRLEN(str1)-index;
}

LPTSTR
ReverseString(
    IN OUT  LPTSTR  String
    )

/*++

Routine Description:

    Reverses a UNICODE string (LPWSTR)

Arguments:

    String  - to be reversed. Reverses string in place

Return Value:

    pointer to String

--*/

{
    DWORD   len = STRLEN(String);
    DWORD   i = 0;
    DWORD   j = len - 1;
    TCHAR   tmp;

    len /= 2;

    while (len) {
        tmp = String[i];
        String[i] = String[j];
        String[j] = tmp;
        ++i;
        --j;
        --len;
    }
    return String;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\strarray.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    StrArray.c

Abstract:

    This is the a header file of handy functions and macros for TCHAR
    string arrays.

    These arrays are in the following format (spaces added for clarity):

       one \0 two \0 three \0 \0

    where \0 is a null character in the appropriate format.

    These functions are useful for the NetServerDiskEnum and NetConfigGetAll
    APIs, and possibly others.

Author:

    John Rogers (JohnRo) 24-Oct-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Note:

    This function assumes that the machine's default codepage is the same
    as the LAN's default codepage.

Revision History:

    24-Oct-1991 JohnRo
        Created.
    02-Jan-1992 JohnRo
        Moved my RxpCopyStrArrayToTStrArray() from RxCommon to NetLib,
        and renamed it.  Added some other random functions.
    30-Jan-1992 JohnRo
        Fixed off-by-one bug in NetpAddTStrToTStrArray().
        Enhanced handling of "empty" TCHAR string arrays.
        Use TCHAR_EOS equate.
    05-Jun-1992 JohnRo
        RAID 11253: NetConfigGetAll fails when remoted to downlevel.
    01-Sep-1992 JohnRo
        RAID 5016: NetConfigGetAll heap trash.

--*/


// These must be included first:

#include <windef.h>             // IN, VOID, LPWSTR, etc.
#include <lmcons.h>             // (Needed by NetLib.h)

// These can be in any order:

#include <netlib.h>             // NetpPointerPlusSomeBytes().
#include <netdebug.h>           // NetpAssert(), etc.
#include <strarray.h>           // LPTSTR_ARRAY, my prototypes.
#include <string.h>             // strlen() for codepage strings.
#include <tstring.h>            // NetpCopyStrToTStr(), TCHAR_EOS.


//
//////////////////////////////// LPTSTR_ARRAY stuff //////////////////////////
//

VOID
NetpAddTStrToTStrArray (
    IN OUT LPTSTR_ARRAY DestArray,
    IN LPTSTR Src
    )
{
    DWORD AddSize;  // byte count (including null char) of string being added
    LPTSTR DestStringStart;
    DWORD NewArraySize;
    DWORD OldArraySize;

    NetpAssert( DestArray != NULL );
    NetpAssert( Src != NULL );

    OldArraySize = NetpTStrArraySize( DestArray );  // May be 0.

    NetpAssert( STRLEN(Src) > 0 );  // We couldn't tell from end of array.

    AddSize = STRSIZE( Src );

    NewArraySize = OldArraySize + AddSize;

    NetpAssert( NewArraySize > 0 );  // We couldn't tell from end of array.

    //
    // Figure-out where new string would start.  Note that OldArraySize
    // includes the null char which was the end of the array, so we have
    // to subtract a character to start the new one where that null char is.
    //
    DestStringStart = (LPTSTR)
            NetpPointerPlusSomeBytes( DestArray, OldArraySize-sizeof(TCHAR) );
    NetpAssert( DestStringStart != NULL );

    (void) STRCPY(
            DestStringStart,            // dest
            Src);                       // src

    // Mark end of array.
    DestArray[NewArraySize/sizeof(TCHAR)-1] = TCHAR_EOS;

    NetpAssert( ! NetpIsTStrArrayEmpty( DestArray ) );

} // NetpAddTStrToTStrArray


VOID
NetpCopyStrArrayToTStrArray(
    OUT LPTSTR_ARRAY Dest,  // string array: TCHARs
    IN  LPSTR  Src    // string array: 8-bit input in default codepage for LAN
    )

/*++

Routine Description:

    NetpCopyStrArrayToTStrArray copies an array of strings (in some codepage)
    to an array of strings (in TCHAR format).

    These arrays are in the following format (spaces added for clarity):

       one \0 two \0 three \0 \0

    where \0 is a null character in the appropriate format.

    This function is useful for the NetServerDiskEnum and NetConfigGetAll
    APIs, and possibly others.

Arguments:

    Dest - is an LPTSTR_ARRAY indicating where the converted characters are to
        go.   This area must be large enough to hold the data.

    Src - is an LPSTR array indicating the source strings.  This must be an
        array of strings in the default codepage of the LAN.

Return Value:

    None.

--*/

{
    NetpAssert( Dest != NULL );
    NetpAssert( Src != NULL );

    //
    // Loop for each string in the array.
    //
    while ( (*Src) != '\0' ) {

        DWORD SrcByteCount = strlen(Src)+1;  // Bytes for this codepage str.

        //
        // Copy one string.
        //
        NetpCopyStrToTStr( Dest, Src );      // Copy and conv to TCHARs.

        Dest = (LPVOID) ( ((LPBYTE)Dest) + (SrcByteCount * sizeof(TCHAR)) );

        Src += SrcByteCount;

    }

    *Dest = '\0';               // Indicate end of array.

} // NetpCopyStrArrayToTStrArray


#if DBG

// Caller is assumed to have displayed a prefix and/or other identifying
// text.
VOID
NetpDisplayTStrArray (
    IN LPTSTR_ARRAY Array
    )
{
    LPTSTR CurrentEntry = (LPVOID) Array;

    NetpAssert( Array != NULL );

    if (*CurrentEntry == TCHAR_EOS) {
        NetpKdPrint(("   (empty)\n"));
    } else {
        while (*CurrentEntry != TCHAR_EOS) {
            NetpKdPrint(("   "  FORMAT_LPTSTR "\n", (LPTSTR) CurrentEntry));
            CurrentEntry += ( STRLEN( CurrentEntry ) + 1 );
        }
    }

} // NetpDisplayTStrArray

#endif // DBG


DWORD
NetpTStrArrayEntryCount (
    IN LPTSTR_ARRAY Array
    )
{
    DWORD EntryCount = 0;
    LPTSTR Entry = (LPVOID) Array;

    NetpAssert( Array != NULL );

    //
    // Loop for each string in the array.
    //
    while ( (*Entry) != TCHAR_EOS ) {

        ++EntryCount;

        Entry += STRLEN(Entry)+1;

    }

    return (EntryCount);

} // NetpTStrArrayEntryCount


DWORD
NetpTStrArraySize(
    IN LPTSTR_ARRAY Array
    )
{
    DWORD ArrayByteCount = 0;
    LPTSTR Entry = (LPVOID) Array;

    NetpAssert( Array != NULL );

    //
    // Loop for each string in the array.
    //
    while ( (*Entry) != TCHAR_EOS ) {

        DWORD EntryByteCount = STRSIZE(Entry);  // This entry and its null.

        ArrayByteCount += EntryByteCount;

        Entry = (LPTSTR)NetpPointerPlusSomeBytes(Entry, EntryByteCount);

    }

    ArrayByteCount += sizeof(TCHAR);    // Indicate end of array.

    return (ArrayByteCount);

} // NetpTStrArraySize


//
//////////////////////////////// LPSTR_ARRAY stuff //////////////////////////
//

DWORD
NetpStrArraySize(
    IN LPSTR_ARRAY Array
    )
{
    DWORD ArrayByteCount = 0;
    LPSTR Entry = (LPVOID) Array;

    NetpAssert( Array != NULL );

    //
    // Loop for each string in the array.
    //
    while ( (*Entry) != '\0' ) {

        DWORD EntryByteCount = strlen(Entry)+1;  // This entry and its null.

        ArrayByteCount += EntryByteCount;

        Entry = (LPSTR)NetpPointerPlusSomeBytes(Entry, EntryByteCount);

    }

    ArrayByteCount += sizeof(CHAR);    // Indicate end of array.

    return (ArrayByteCount);

} // NetpStrArraySize
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\thread.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    Thread.c

Abstract:

    This module defines private types and macros for use in implementing
    a portable thread ID interface.

Author:

    John Rogers (JohnRo) 14-Jan-1992

Environment:

    User Mode - Win32
    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    14-Jan-1992 JohnRo
        Created.
--*/


// These must be included first:

#include <nt.h>                 // IN, VOID, NtCurrentTeb(), etc.
#include <windef.h>             // DWORD.

// These may be included in any order:

#include <netdebug.h>           // NetpAssert(), NetpKdPrint(()), etc.
#include <thread.h>             // NET_THREAD_ID, NetpCurrentThread().



NET_THREAD_ID
NetpCurrentThread(
    VOID
    )
{
    PTEB currentTeb;
    NET_THREAD_ID currentThread;

    currentTeb = NtCurrentTeb( );
    NetpAssert( currentTeb != NULL );

    currentThread = (NET_THREAD_ID) currentTeb->ClientId.UniqueThread;
    NetpAssert( currentThread != (NET_THREAD_ID) 0 );

    return (currentThread);

} // NetpCurrentThread
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\ds\netapi\netlib\svcinfo.c ===
/*++

Copyright (c) 1991-1992  Microsoft Corporation

Module Name:

    SvcInfo.c

Abstract:

    This file contains NetpServiceStructureInfo().

Author:

    John Rogers (JohnRo) 15-Aug-1991

Environment:

    Portable to any flat, 32-bit environment.  (Uses Win32 typedefs.)
    Requires ANSI C extensions: slash-slash comments, long external names.

Revision History:

    10-Sep-1991 JohnRo
        Downlevel NetService APIs.
    20-Sep-1991 JohnRo
        Support non-native structure sizes.
    21-Oct-1991 JohnRo
        Quiet normal debug output.
    20-Nov-1991 JohnRo
        Removed NT dependencies to reduce recompiles.
    31-Aug-1992 JohnRo
        Allow NT-sized service names.
        Use PREFIX_ equates.

--*/

// These must be included first:

#include <windef.h>             // IN, DWORD, etc.
#include <lmcons.h>             // LM20_ equates, NET_API_STATUS, etc.
#include <rap.h>                // LPDESC, needed by <strucinf.h>.

// These may be included in any order:

#include <debuglib.h>           // IF_DEBUG().
#include <lmerr.h>              // ERROR_ and NERR_ equates.
#include <lmsvc.h>              // SERVICE_INFO_2, etc.
#include <netlib.h>             // NetpSetOptionalArg().
#include <netdebug.h>           // NetpKdPrint(()).
#include <prefix.h>     // PREFIX_ equates.
#include <remdef.h>             // REM16_, REM32_, REMSmb_ equates.
#include <strucinf.h>           // My prototype.


#define MAX_SERVICE_0_STRING_LENGTH \
        (SNLEN+1)
#define MAX_SERVICE_0_STRING_SIZE \
        (MAX_SERVICE_0_STRING_LENGTH * sizeof(TCHAR))

#define MAX_SERVICE_1_STRING_LENGTH \
        (MAX_SERVICE_0_STRING_LENGTH)
#define MAX_SERVICE_1_STRING_SIZE \
        (MAX_SERVICE_1_STRING_LENGTH * sizeof(TCHAR))

//
// The extra SNLEN+1 added below is for the display name.
//
#define MAX_SERVICE_2_STRING_LENGTH \
        (MAX_SERVICE_1_STRING_LENGTH + LM20_STXTLEN+1 + SNLEN+1)
#define MAX_SERVICE_2_STRING_SIZE \
        (MAX_SERVICE_2_STRING_LENGTH * sizeof(TCHAR))


NET_API_STATUS
NetpServiceStructureInfo (
    IN DWORD Level,
    IN DWORD ParmNum,  // Use PARMNUM_ALL if not applicable.
    IN BOOL Native,    // Should sizes be native or RAP?
    OUT LPDESC * DataDesc16 OPTIONAL,
    OUT LPDESC * DataDesc32 OPTIONAL,
    OUT LPDESC * DataDescSmb OPTIONAL,
    OUT LPDWORD MaxSize OPTIONAL,
    OUT LPDWORD FixedSize OPTIONAL,
    OUT LPDWORD StringSize OPTIONAL
    )

{
    LPDESC LocalDataDesc16, LocalDataDesc32, LocalDataDescSmb;

    DBG_UNREFERENCED_PARAMETER(ParmNum);

    //
    // Decide what to do based on the info level.
    //
    switch (Level) {

#define SetSizes(fixed,variable) \
    { \
        NetpSetOptionalArg( MaxSize, (fixed) + (variable) ); \
        NetpSetOptionalArg( FixedSize, (fixed) ); \
        NetpSetOptionalArg( StringSize, (variable) ); \
    }

    case 0 :
        LocalDataDesc16 = REM16_service_info_0;
        LocalDataDesc32 = REM32_service_info_0;
        LocalDataDescSm