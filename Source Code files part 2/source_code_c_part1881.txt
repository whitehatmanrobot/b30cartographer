eAnm;
				}
			break;
			
		case lskalRight:
			*pdurBefore = durRemain;
			*pdurAfter = durSpaceAnm;
			break;
			
		default:
			NotReached();
		}

	Assert(FIsDnodeReal(plsdnAnmAfter));
	Assert(plsdnAnmAfter->fTab);

	SetDnodeDurFmt(plsdnAnmAfter, *pdurAfter);
	plsdnAnmAfter->icaltbd = 0xFF;		/* spoil icaltbd */
	
	}


/* A L L I G N  A U T O N U M */
/*----------------------------------------------------------------------------
	%%Function: AllignAutonum
	%%Contact: igorzv
	Parameters
	plstabscontext	-	(IN) tabs context
	lskalignAnm			-	(IN) allignment for autonumber
	fAllignmentAfter-	(IN) is there tab after autonumber
	plsdnAnmAfter	-	(IN) tab dnode to put durAfter
	urAfterAnm		-	(IN) pen position after autonumber
	durUsed			-	(IN) width of autonumbering text
	pdurBefore		-	(OUT)calculated distance from indent to autonumber 
	pdurAfter		-	(OUT)calculated distance from autonumber to main text

	Calculates space before and after autonumber for the case Word95 model.
----------------------------------------------------------------------------*/
LSERR AllignAutonum(PLSTABSCONTEXT plstabscontext, LSKALIGN lskalignAnm, 
				   BOOL fAllignmentAfter, PLSDNODE plsdnAnmAfter,
				   long urAfterAnm, long durUsed,
				   long* pdurBefore, long* pdurAfter)
	{
	LSERR lserr;
	LSKTAB lsktab;
	BOOL fBreakThroughTab;
	LSCALTBD* plscaltbd;  
	
	/* resolving durBefore */
	
	switch (lskalignAnm)
		{
		case lskalLeft:
			*pdurBefore = 0;
			break;
			
		case lskalCentered:
			*pdurBefore = -durUsed/2;
			break;
			
		case lskalRight:
			*pdurBefore = -durUsed;
			break;
			
		default:
			NotReached();
		}
	
	
	/*	resolving  durAfter  */
	*pdurAfter = 0;
	if (fAllignmentAfter)
		{
		Assert(FIsDnodeReal(plsdnAnmAfter));
		Assert(plsdnAnmAfter->fTab);

		plsdnAnmAfter->fTabForAutonumber = fTrue;

		urAfterAnm += *pdurBefore; 
		
		lserr = GetCurTabInfoCore(plstabscontext, plsdnAnmAfter,	
					urAfterAnm,	fTrue, &lsktab, &fBreakThroughTab);
		if (lserr != lserrNone) 
			return lserr;
		
		plscaltbd = &(plstabscontext->pcaltbd[plsdnAnmAfter->icaltbd]);
		
		*pdurAfter = plsdnAnmAfter->u.real.objdim.dur;
		}
	return lserrNone;
	}

LSERR WINAPI AutonumEnumerate(PDOBJ pdobj, PLSRUN plsrun, PCLSCHP plschp, LSCP cpFirst, LSDCP dcp, 
					LSTFLOW lstflow, BOOL fReverseOrder, BOOL fGeometryProvided, 
					const POINT* pptStart, PCHEIGHTS pheightsPres, long dupRun)
				  
{

	Unreferenced(plschp);
	Unreferenced(plsrun);
	Unreferenced(cpFirst);
	Unreferenced(dcp);
	Unreferenced(lstflow);
	Unreferenced(fGeometryProvided);
	Unreferenced(pheightsPres);
	Unreferenced(dupRun);

	return LsEnumSubline(pdobj->plssubl, fReverseOrder,	fGeometryProvided,	
						 pptStart);	

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\dispmain.c ===
#include "dispmain.h"
#include "lsc.h"
#include "lsdnode.h"
#include "lstflow.h"
#include "lsline.h"
#include "lssubl.h"
#include "dispul.h"	
#include "lstfset.h"
#include "lssubset.h"
#include "dispmisc.h"
#include "dispi.h"
#include "dninfo.h"
#include "memory.h"
#include "port.h"


static LSERR DisplayDnode(PLSC plsc, PLSDNODE pdn, const POINT* pptOrg, POINTUV pt,
				UINT kdispmode,	LSTFLOW lstflow, const RECT* prectClip, 
				BOOL fDrawStrike, BOOL fDrawUnderline, long upLimUnderline);
				
static LSERR ShadeSubline(PLSSUBL plssubl, const POINT* pptOrg, UINT kdispmode,
						const RECT* prectClip, long upLimUnderline, long upLeftIndent);

static LSERR DrawBorders(PLSSUBL plssubl, const POINT* pptOrg, UINT kdispmode,
						const RECT* prectClip, long upLimUnderline, long upLeftIndent);

static long GetDupUnderline(long up, long dup, long upLimUnderline);

static BOOL FGetNeighboringOpeningBorder(PLSDNODE pdnClosingBorder, PLSDNODE pdnNext, POINTUV* pptStart, 
										LSCP cpLim,	LSTFLOW	lstflowMain,
										PLSDNODE* ppdnOpeningBorder, POINTUV* pptStartOpeningBorder);

#define FIsDnodeToShade(pdn, cpLim) 	(FDnodeBeforeCpLim(pdn, cpLim) && FIsDnodeReal(pdn) && 	\
									!(pdn)->u.real.lschp.fInvisible && (pdn)->u.real.lschp.fShade)

#define UpdateMaximum(a,b)		if ((a) < (b)) (a) = (b); else

#define FIsDnodeOpeningBorder(pdn, lstflowMain)	((pdn)->fOpenBorder ^ ((pdn)->plssubl->lstflow != (lstflowMain)))
#define FIsDnodeClosingBorder(pdn, lstflowMain)	(!FIsDnodeOpeningBorder(pdn, lstflowMain))




//    %%Function:	DisplaySublineCore
//    %%Contact:	victork
//
// 
//	Displays subline with shading, striking and underlining, merging consecutive underlined dnodes
//	
//	Logic to select underlining method:
//	
//	If (metrics_are_good)
//		Draw_by_fnDrawUnderline;
//	else
//		if (There_is_merging_going)
//			Draw_by_pfnDrawUnderlineAsText;
//		else
//			Draw_along_with_Display;

LSERR DisplaySublineCore(		
						PLSSUBL plssubl,			/* subline to display */
						const POINT* pptOrg, 		/*  (x,y) starting point */
						UINT kdispmode,				/*  transparent or opaque */
						const RECT* prectClip, 		/*  clipping rect (x,y) */
						long upLimUnderline,
						long upLeftIndent)
{
	LSERR 		lserr;
	LSCP		cpLim = plssubl->cpLimDisplay;
	PLSC		plsc = plssubl->plsc;
	LSTFLOW		lstflowMain = plssubl->lstflow;
	BOOL 		fCollectVisual = plsc->plslineDisplay->fCollectVisual;

	LSSTRIKEMETRIC lsstrikemetric;

	//	Underline merge group - normal scenario: we first count dnodes willing to participate 
	//	in merging looking ahead, then draw them, then underline them as a whole
	
	PLSDNODE pdnFirstInGroup = NULL;			/* First dnode in Underline merge group */
	int 	cdnodesLeftInGroup = 0;				/* these are not displayed yet */
	int 	cdnodesToUnderline = 0;				/* these are already displayed */
	BOOL 	fGoodUnderline = fFalse;			/* is there metric for UL */
	LSULMETRIC lsulmetric;						/* merge metric info (if fGoodUnderline) */
	long 	upUnderlineStart = 0;				/* Starting point for the group */
	BOOL 	fMergeUnderline = fFalse;			/* There is more then one dnode in the group */

	BOOL 	fUnderlineWithDisplay, fStrikeWithDisplay;

	POINTUV		pt;
	PLSDNODE	pdn;

	FLineValid(plsc->plslineDisplay, plsc);					// Assert the display context is valid
	
	Assert(plssubl->plsdnUpTemp == NULL);					// against displaying accepted sublines

	if (fCollectVisual)
		{
		CreateDisplayTree(plssubl);
		}

	if (plsc->plslineDisplay->AggregatedDisplayFlags & fPortDisplayShade)
		{
		lserr = ShadeSubline(plssubl, pptOrg, kdispmode, prectClip, upLimUnderline, upLeftIndent);
		if (lserr != lserrNone) return lserr;
		}

	pt.u = upLeftIndent;						
	pt.v = 0;
	
	pdn = AdvanceToFirstDnode(plssubl, lstflowMain, &pt);

	while (FDnodeBeforeCpLim(pdn, cpLim))
		{

		if (pdn->klsdn == klsdnReal && !pdn->u.real.lschp.fInvisible)
			{	
			/* Real dnode */
				
			fStrikeWithDisplay = fFalse;
			if (pdn->u.real.lschp.fStrike)
				{
				BOOL fGoodStrike;
				lserr = GetStrikeMetric(plsc, pdn, lstflowMain, &lsstrikemetric, &fGoodStrike);
				if (lserr != lserrNone) return lserr;
				fStrikeWithDisplay = !fGoodStrike;
				}

			fUnderlineWithDisplay = fFalse;
			if (pdn->u.real.lschp.fUnderline && pt.u < upLimUnderline)	
				{	
				/* Node has underline */
				
				if (cdnodesLeftInGroup  == 0) 
					{ 
					/* There are no on-going UL group */
					/* Find out how many dnodes will participate in the merge and what metric to use */
					
					lserr = GetUnderlineMergeMetric(plsc, pdn, pt, upLimUnderline, lstflowMain, 
										cpLim, &lsulmetric, &cdnodesLeftInGroup , &fGoodUnderline);
					if (lserr != lserrNone) return lserr;
					fMergeUnderline = (cdnodesLeftInGroup  > 1);
					cdnodesToUnderline = 0;
					}

				if (!fGoodUnderline)				
					fUnderlineWithDisplay = !fMergeUnderline;
				else
					fUnderlineWithDisplay = fFalse;

				if (!fUnderlineWithDisplay)
					{
					if (cdnodesToUnderline == 0)
						{	
						/* Mark starting point of underline merge */
						
						pdnFirstInGroup = pdn;
						upUnderlineStart = pt.u;
						}
						
					/* Add to pending UL dnode count */
					
					++cdnodesToUnderline;	
					}
					
				// current dnode will be displayed shortly - consider it done
				
				--cdnodesLeftInGroup ;		
				}							
			
			lserr = DisplayDnode(plsc, pdn, pptOrg, pt, kdispmode, lstflowMain, prectClip,
									fStrikeWithDisplay, fUnderlineWithDisplay, upLimUnderline);
			if (lserr != lserrNone) return lserr;
			
			if (pdn->u.real.lschp.fStrike && !fStrikeWithDisplay)
				{
				lserr = StrikeDnode(plsc, pdn, pptOrg, pt, &lsstrikemetric, kdispmode, prectClip, 
										upLimUnderline, lstflowMain);
				if (lserr != lserrNone) return lserr;
				}
				
			/* Draw any pending UL after last dnode in group has been drawn */
			
			if (cdnodesToUnderline != 0 && cdnodesLeftInGroup  == 0)
				{
				lserr = DrawUnderlineMerge(plsc, pdnFirstInGroup, pptOrg, 
									cdnodesToUnderline, upUnderlineStart, fGoodUnderline, &lsulmetric, 
									kdispmode, prectClip, upLimUnderline, lstflowMain);
				if (lserr != lserrNone) return lserr;
				
				cdnodesToUnderline = 0;
				}
			}
			
		pdn = AdvanceToNextDnode(pdn, lstflowMain, &pt);
		}
		
	if (fCollectVisual)
		{
		// call display method for submitting dnodes
		
		pt.u = upLeftIndent;						
		pt.v = 0;
		
		pdn = AdvanceToFirstSubmittingDnode(plssubl, lstflowMain, &pt);

		while (FDnodeBeforeCpLim(pdn, cpLim))
			{
			lserr = DisplayDnode(plsc, pdn, pptOrg, pt, kdispmode, lstflowMain, prectClip,
									fFalse, fFalse, upLimUnderline);
			if (lserr != lserrNone) return lserr;
			
			pdn = AdvanceToNextSubmittingDnode(pdn, lstflowMain, &pt);
			}
		}
		
	if (plsc->plslineDisplay->AggregatedDisplayFlags & fPortDisplayBorder)
		{
		lserr = DrawBorders(plssubl, pptOrg, kdispmode, prectClip, upLimUnderline, upLeftIndent);
		if (lserr != lserrNone) return lserr;
		}

	if (fCollectVisual)
		{
		// destroy display tree

		DestroyDisplayTree(plssubl);
		}

	return lserrNone;			
}

//    %%Function:	DisplayDnode
//    %%Contact:	victork

static LSERR DisplayDnode(PLSC plsc, PLSDNODE pdn, const POINT* pptOrg, POINTUV pt,
						UINT kdispmode,	LSTFLOW lstflowMain, const RECT* prectClip,
						BOOL fDrawStrike, BOOL fDrawUnderline, long upLimUnderline)
{
	PDOBJ 	pdobj;
	DISPIN 	dispin;

	pdobj = pdn->u.real.pdobj;

	dispin.plschp = &(pdn->u.real.lschp);
	dispin.plsrun = pdn->u.real.plsrun;
	
	dispin.kDispMode = kdispmode;
	dispin.lstflow = pdn->plssubl->lstflow;								
	dispin.prcClip = (RECT*) prectClip;

	dispin.fDrawUnderline = fDrawUnderline;
	dispin.fDrawStrikethrough = fDrawStrike;
	
	dispin.heightsPres = pdn->u.real.objdim.heightsPres;
	dispin.dup = pdn->u.real.dup;
	
	dispin.dupLimUnderline = GetDupUnderline(pt.u, dispin.dup, upLimUnderline);

	if (dispin.lstflow != lstflowMain)
		{
		// Dnode lstflow is opposite to lstflowMain - get real starting point
		
		pt.u = pt.u + dispin.dup - 1;

		// Partial underlining can only happen on the top level
		
		Assert(dispin.dupLimUnderline == 0 || dispin.dupLimUnderline == dispin.dup);
		}

	pt.v += pdn->u.real.lschp.dvpPos;
	
	LsPointXYFromPointUV(pptOrg, lstflowMain, &pt, &(dispin.ptPen));
	
	
	return (*plsc->lsiobjcontext.rgobj[pdn->u.real.lschp.idObj].lsim.pfnDisplay)(pdobj, &dispin);
}


//    %%Function:	ShadeSubline
//    %%Contact:	victork

LSERR ShadeSubline(PLSSUBL plssubl,				/* subline to shade */
					const POINT* pptOrg, 		/*  (x,y) starting point */
					UINT kdispmode,				/*  transparent or opaque */
					const RECT* prectClip, 		/*  clipping rect (x,y) */
					long upLimUnderline,
					long upLeftIndent)
{
	LSERR 		lserr;
	LSCP		cpLim = plssubl->cpLimDisplay;
	PLSC		plsc = plssubl->plsc;
	PLSLINE		plsline = plsc->plslineDisplay;
	LSTFLOW		lstflowMain = plssubl->lstflow;

	POINTUV		pt;
	PLSDNODE	pdn;

	HEIGHTS		heightsLineWithAddedSpace;
	HEIGHTS		heightsLineWithoutAddedSpace;
	OBJDIM		objdimSubline;
	
	POINT		ptStart;
	PLSRUN		plsrunFirst, plsrunPrevious;
	long		upStart;
	long		dupInclTrail, dupExclTrail;
	HEIGHTS		heightsRunsInclTrail;
	HEIGHTS		heightsRunsExclTrail;

	BOOL	 	fInterruptShading;
	BOOL 		fCollectVisual = plsc->plslineDisplay->fCollectVisual;


	heightsLineWithAddedSpace.dvAscent = plsline->dvpAbove + plsline->lslinfo.dvpAscent;
	heightsLineWithAddedSpace.dvDescent = plsline->dvpBelow + plsline->lslinfo.dvpDescent;
	heightsLineWithAddedSpace.dvMultiLineHeight = dvHeightIgnore;
	
	heightsLineWithoutAddedSpace.dvAscent = plsline->lslinfo.dvpAscent;
	heightsLineWithoutAddedSpace.dvDescent = plsline->lslinfo.dvpDescent;
	heightsLineWithoutAddedSpace.dvMultiLineHeight = dvHeightIgnore;
	
	lserr = LssbGetObjDimSubline(plssubl, &lstflowMain, &objdimSubline);
	if (lserr != lserrNone) return lserr;
	
	if (fCollectVisual)
		{
		// shade submitting dnodes - pretend they are on the top level, no merging for them
		
		pt.u = upLeftIndent;						
		pt.v = 0;
		
		pdn = AdvanceToFirstSubmittingDnode(plssubl, lstflowMain, &pt);

		while (FDnodeBeforeCpLim(pdn, cpLim))
			{
			if (FIsDnodeToShade(pdn, cpLim))
				{
				LsPointXYFromPointUV(pptOrg, lstflowMain, &pt, &ptStart);
				dupInclTrail = pdn->u.real.dup;
				dupExclTrail = GetDupUnderline(pt.u, dupInclTrail, upLimUnderline);
				lserr = (*plsc->lscbk.pfnShadeRectangle)(plsc->pols, pdn->u.real.plsrun, &ptStart, 
									&heightsLineWithAddedSpace,	&heightsLineWithoutAddedSpace, 
									&(objdimSubline.heightsPres),
									&(pdn->u.real.objdim.heightsPres), &(pdn->u.real.objdim.heightsPres),
									dupExclTrail, dupInclTrail, 
									lstflowMain, kdispmode, prectClip);
				if (lserr != lserrNone) return lserr;
				}
			
			pdn = AdvanceToNextSubmittingDnode(pdn, lstflowMain, &pt);
			}
		}


	pt.u = upLeftIndent;						
	pt.v = 0;
	
	pdn = AdvanceToFirstDnode(plssubl, lstflowMain, &pt);

	while (FDnodeBeforeCpLim(pdn, cpLim)  && !FIsDnodeToShade(pdn, cpLim))
		{
		pdn = AdvanceToNextDnode(pdn, lstflowMain, &pt);
		}

	// next loop will do one shading merge at a run

	while (FDnodeBeforeCpLim(pdn, cpLim))
		{
		// pdn is the first dnode to participate in the shade merge
		// initialize the merge with this dnode data
		
		LsPointXYFromPointUV(pptOrg, lstflowMain, &pt, &ptStart);
		plsrunFirst = pdn->u.real.plsrun;
		upStart = pt.u;
		
		heightsRunsInclTrail = pdn->u.real.objdim.heightsPres;

		// What should we have in heightsRunsExclTrail if all shading is in trailing spaces?
		// I decided to put heights of the first run there for convenience sake
		// Client can check for dupExclTrail == 0.
		
		heightsRunsExclTrail = heightsRunsInclTrail;

		// We will now append to the merge as many dnodes as possible
		// The loop will stop when dnode doesn't need to be shaded - while condition
		// or if callback says two dnodes are not to be shaded together - break inside

		plsrunPrevious = pdn->u.real.plsrun;
		pdn = AdvanceToNextDnode(pdn, lstflowMain, &pt);
	
		while (FIsDnodeToShade(pdn, cpLim))
			{
			lserr = (*plsc->lscbk.pfnFInterruptShade)(plsc->pols, plsrunPrevious,pdn->u.real.plsrun,
														&fInterruptShading);
			if (lserr != lserrNone) return lserr;

			if (fInterruptShading)
				{
				break;
				}
				
			plsrunPrevious = pdn->u.real.plsrun;

			UpdateMaximum(heightsRunsInclTrail.dvAscent, pdn->u.real.objdim.heightsPres.dvAscent);
			UpdateMaximum(heightsRunsInclTrail.dvDescent, pdn->u.real.objdim.heightsPres.dvDescent);
			UpdateMaximum(heightsRunsInclTrail.dvMultiLineHeight, pdn->u.real.objdim.heightsPres.dvMultiLineHeight);

			if (pt.u < upLimUnderline)
				{
				UpdateMaximum(heightsRunsExclTrail.dvAscent, pdn->u.real.objdim.heightsPres.dvAscent);
				UpdateMaximum(heightsRunsExclTrail.dvDescent, pdn->u.real.objdim.heightsPres.dvDescent);
				UpdateMaximum(heightsRunsExclTrail.dvMultiLineHeight, pdn->u.real.objdim.heightsPres.dvMultiLineHeight);
				}

			pdn = AdvanceToNextDnode(pdn, lstflowMain, &pt);
			}
			
		// Merge is stopped - time to draw
		
		dupInclTrail = pt.u - upStart;
		dupExclTrail = GetDupUnderline(upStart, dupInclTrail, upLimUnderline);

		lserr = (*plsc->lscbk.pfnShadeRectangle)(plsc->pols, plsrunFirst, &ptStart, 
									&heightsLineWithAddedSpace,	&heightsLineWithoutAddedSpace, 
									&(objdimSubline.heightsPres),
									&heightsRunsExclTrail, &heightsRunsInclTrail, 
									dupExclTrail, dupInclTrail, 
									lstflowMain, kdispmode, prectClip);
		if (lserr != lserrNone) return lserr;

		// get to the beginning of the next shade merge
		
		while (FDnodeBeforeCpLim(pdn, cpLim)  && !FIsDnodeToShade(pdn, cpLim))
			{
			pdn = AdvanceToNextDnode(pdn, lstflowMain, &pt);
			}
		
		}
		
	return lserrNone;
}

//    %%Function:	GetDupUnderline
//    %%Contact:	victork
//
// Calculate dup of underlined part (of dnode). Deals with situations when upLimUnderline is
//  outside of [upStart, upStart + dup]

static long GetDupUnderline(long upStart, long dup, long upLimUnderline)

{
	long dupLimUnderline;
	
	dupLimUnderline = upLimUnderline - upStart;
	
	if (dupLimUnderline >= dup)
		{
		dupLimUnderline = dup;
		}
	else if (dupLimUnderline < 0)
		{
		dupLimUnderline = 0;
		}

	return dupLimUnderline;
}

//    %%Function:	DrawBorders
//    %%Contact:	victork

LSERR DrawBorders(PLSSUBL plssubl,
					const POINT* pptOrg, 		/*  (x,y) starting point */
					UINT kdispmode,				/*  transparent or opaque */
					const RECT* prectClip, 		/*  clipping rect (x,y) */
					long upLimUnderline,
					long upLeftIndent)
{
	LSERR 		lserr;
	LSCP		cpLim = plssubl->cpLimDisplay;
	PLSC		plsc = plssubl->plsc;
	PLSLINE		plsline = plsc->plslineDisplay;
	LSTFLOW		lstflowMain = plssubl->lstflow;

	HEIGHTS		heightsLineWithAddedSpace;
	HEIGHTS		heightsLineWithoutAddedSpace;
	OBJDIM		objdimSubline;
	HEIGHTS		heightsRuns;

	long		upStart, dupBorder, dupBordered;
	POINT		ptStart;
	PLSRUN		plsrunOpeningBorder, plsrunClosingBorder;
	POINTUV		pt, ptAfterClosingBorder;
	PLSDNODE	pdn, pdnPrev, pdnClosingBorder, pdnAfterClosingBorder;

	BOOL	 	fClosingOpeningBorderSequenceFound;
	PLSDNODE	pdnNextOpeningBorder;
	POINTUV		ptStartNextOpeningBorder;
	BOOL	 	fInterruptBorder;

	heightsLineWithAddedSpace.dvAscent = plsline->dvpAbove + plsline->lslinfo.dvpAscent;
	heightsLineWithAddedSpace.dvDescent = plsline->dvpBelow + plsline->lslinfo.dvpDescent;
	heightsLineWithAddedSpace.dvMultiLineHeight = dvHeightIgnore;
	
	heightsLineWithoutAddedSpace.dvAscent = plsline->lslinfo.dvpAscent;
	heightsLineWithoutAddedSpace.dvDescent = plsline->lslinfo.dvpDescent;
	heightsLineWithoutAddedSpace.dvMultiLineHeight = dvHeightIgnore;
	
	lserr = LssbGetObjDimSubline(plssubl, &lstflowMain, &objdimSubline);
	if (lserr != lserrNone) return lserr;
	
	pt.u = upLeftIndent;						
	pt.v = 0;
	
	pdn = AdvanceToFirstDnode(plssubl, lstflowMain, &pt);

	// next loop will draw one border at a run

	while (FDnodeBeforeCpLim(pdn, cpLim))
		{
		// first find an opening border

		while (FDnodeBeforeCpLim(pdn, cpLim) && !FIsDnodeBorder(pdn))
			{
			pdn = AdvanceToNextDnode(pdn, lstflowMain, &pt);
			}

		if (FDnodeBeforeCpLim(pdn, cpLim))
			{
			// border is found - it must be an opening one

			Assert(FIsDnodeOpeningBorder(pdn, lstflowMain));

			// remember the starting point and border width
			
			upStart = pt.u;
			LsPointXYFromPointUV(pptOrg, lstflowMain, &pt, &ptStart);
			dupBorder = pdn->u.pen.dup;

			// take lsrun from the first bordered run
			
			pdn = AdvanceToNextDnode(pdn, lstflowMain, &pt);

			Assert(FDnodeBeforeCpLim(pdn, cpLim) && FIsDnodeReal(pdn));

			plsrunOpeningBorder = pdn->u.real.plsrun;

			// start collecting max run height
			
			heightsRuns = pdn->u.real.objdim.heightsPres;

			// now look for an closing border to draw, collecting max run height
			// loop will be ended by break
			
			for (;;)
				{
				// find a border

				pdnPrev = NULL;

				while (FDnodeBeforeCpLim(pdn, cpLim) && !FIsDnodeBorder(pdn))
					{
					if (FIsDnodeReal(pdn))
						{
						UpdateMaximum(heightsRuns.dvAscent, pdn->u.real.objdim.heightsPres.dvAscent);
						UpdateMaximum(heightsRuns.dvDescent, pdn->u.real.objdim.heightsPres.dvDescent);
						UpdateMaximum(heightsRuns.dvMultiLineHeight, pdn->u.real.objdim.heightsPres.dvMultiLineHeight);
						}
						
					pdnPrev = pdn;
					pdn = AdvanceToNextDnode(pdn, lstflowMain, &pt);
					}
					
				Assert(FDnodeBeforeCpLim(pdn, cpLim));
				
				// border is found - it must be a closing one
				// Sequence opening border - closing border is prohibited by formatting

				Assert(pdnPrev != NULL);						
				Assert(FIsDnodeReal(pdnPrev));
				Assert(FIsDnodeClosingBorder(pdn, lstflowMain));
				Assert(pdn->u.pen.dup == dupBorder);

				pdnClosingBorder = pdn;
				plsrunClosingBorder = pdnPrev->u.real.plsrun;
				
				pdn = AdvanceToNextDnode(pdn, lstflowMain, &pt);
				
				ptAfterClosingBorder = pt;
				pdnAfterClosingBorder = pdn;

				// check for the "surplus borders" situation: closing border and opening border of the same
				// type brought together by submitting sublines. (Hard to check at formatting time)
				
				// It can be more complicated if there are bordered trailing spaces between the two borders
				// (Trailing spaces can happen in the middle of the line in Bidi case). The problem is
				// that border is moved away from trailing spaces at SetBreak time. We try to restore 
				// bordering of trailing spaces when they are in the middle of bordered line below.
				
				fClosingOpeningBorderSequenceFound = FGetNeighboringOpeningBorder(pdnClosingBorder, pdn, &pt, 
											cpLim, lstflowMain,	&pdnNextOpeningBorder, &ptStartNextOpeningBorder);
				
				if (fClosingOpeningBorderSequenceFound)
					{
					pdn = pdnNextOpeningBorder;
					pt = ptStartNextOpeningBorder;
					
					pdn = AdvanceToNextDnode(pdn, lstflowMain, &pt);

					Assert(FDnodeBeforeCpLim(pdn, cpLim) && FIsDnodeReal(pdn));

					lserr = (*plsc->lscbk.pfnFInterruptBorder)(plsc->pols, plsrunClosingBorder, 
										pdn->u.real.plsrun,	&fInterruptBorder);
					if (lserr != lserrNone) return lserr;
					
					if (!fInterruptBorder)
						{
						// Client decided against interrupting border here. These two border dnodes
						// will be ignored. Space reserved for them by formatting will be left empty.
						// Continue seeking for closing border starting from pdn
						
						continue;
						}
					}
					
				// No special situation - we are ready to display
				
				// Well, we are almost ready. Word doesn't normally draw borders in trailing spaces, 
				// just reserve space for them and leave this space blank. In FE Word, however,  
				// borders are drawn if underlining of trailing spaces is required.
				// We hack in the following way: Borders in trailing area are deleted after formatting.
				// If there are a border which opens in text and closes in trailing spaces, it is moved
				// to the left to exclude trailing spaces. If the fUnderlineTrailSpacesRM flag is on 
				// the "moved" border is marked and now have to be displayed up to upLimUnderline.
				// Yes, it's bad, it will appear painted over already displayed spaces (queries!) and 
				// what about a scenario when not all trailing spaces are bordered? We know, we know.
				// Word can even get a "negative" border with a negative advance field.

				dupBordered = ptAfterClosingBorder.u - upStart;
				
				if (pdnClosingBorder->fBorderMovedFromTrailingArea)
					{
					Assert(ptAfterClosingBorder.u <= upLimUnderline);
					
					dupBordered = upLimUnderline - upStart;
					}
					
				lserr = (*plsc->lscbk.pfnDrawBorder)(plsc->pols, plsrunOpeningBorder, &ptStart, 
										&heightsLineWithAddedSpace,	&heightsLineWithoutAddedSpace, 
										&(objdimSubline.heightsPres), &heightsRuns,
										dupBorder, dupBordered,
										lstflowMain, kdispmode, prectClip);
				if (lserr != lserrNone) return lserr;
				
				// maybe we peeped ahead checking for the surplus borders - return
				
				pdn = pdnAfterClosingBorder;
				pt = ptAfterClosingBorder;
				break;
				}
			}

			// Previous border is drawn, start looking for the next one from pdn.
		}
		
	return lserrNone;
}


// Find an opening border neighboring pdnClosingBorder broght together by submitting sublines. 
// Ignore trailing spaces that lost their borders during SetBreak - their heights will be ignored.

// Input: 	pdnClosingBorder
//			pdnNext - next to pdnClosingBorder (in visual order)
//			ptStart - starting poing of pdnNext (in visual order)
//			cpLim and lstflowMain
// Output:	pdnOpeningBorder and ptStartOpeningBorder


static BOOL FGetNeighboringOpeningBorder(PLSDNODE pdnClosingBorder, PLSDNODE pdnNext, POINTUV* pptStart, 
										LSCP cpLim,	LSTFLOW	lstflowMain,
										PLSDNODE* ppdnOpeningBorder, POINTUV* pptStartOpeningBorder)
{
	PLSDNODE	pdn;
	POINTUV		pt;

	pdn = pdnNext;
	pt = *pptStart;
	
	// skip spaces that were bordered once
	// not sure about spaces, but what else could be skipped?
	
	while (FDnodeBeforeCpLim(pdn, cpLim) && FIsDnodeReal(pdn) && pdn->u.real.lschp.fBorder)
		{
		pdn = AdvanceToNextDnode(pdn, lstflowMain, &pt);
		}

	if (!FDnodeBeforeCpLim(pdn, cpLim))
		{
		return fFalse;
		}

	// looking for an opening border from another subline

	if (FIsDnodeOpeningBorder(pdn, lstflowMain) && pdn->plssubl != pdnClosingBorder->plssubl)
		{
		*ppdnOpeningBorder = pdn;
		*pptStartOpeningBorder = pt;
		return fTrue;
		}

	return fFalse;
}

	
// N.B. 
//	Interruption of underlining/shading logic by invisible dnode is OK, because we are sure that no
//		underlining/shading is allowed in preprinted forms.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\chnutils.c ===
#include "lsmem.h"						/* memset() */

#include "lsidefs.h"
#include "chnutils.h"
#include "iobj.h"
#include "dninfo.h"
#include "locchnk.h"
#include "posichnk.h"
#include "plschcon.h"
#include "lschcon.h"
#include "lscbk.h"
#include "limqmem.h"
#include "lstext.h"

#ifdef DEBUG
#define DebugMemset(a,b,c)		if ((a) != NULL) memset(a,b,c); else
#else
#define DebugMemset(a,b,c)		(void)(0)
#endif


static LSERR SetChunkArraysSize(PLSCHUNKCONTEXT, DWORD);
static LSERR IncreaseChunkArrays(PLSCHUNKCONTEXT);
static LSERR IncreaseGroupChunkNonTextArrays(PLSCHUNKCONTEXT plschunkcontext);
static LSERR ConvertChunkToGroupChunk(GRCHUNKEXT*, LSCP);
static void LocateChunk(PLSCHUNKCONTEXT plschnukcontext,/* IN: LS chunk context */
					     PLSDNODE plsdn,	 		    /* IN:  dnode to collect chunk arround  */
						 LSTFLOW  lstflow,				/* IN: text flow */
						 POINTUV* ppoint);  			/* IN: position of dnode */
static LSERR FExpandBeforeNonTextObject(GRCHUNKEXT* pgrchunkext, DWORD cTextBeforePrevioustNonText,
									   BOOL* pfExpand);
static LSERR FExpandAfterNonTextObject(GRCHUNKEXT* pgrchunkext, DWORD cTextBeforeLastNonText,
									   BOOL* pfExpand);

typedef struct groupchunkiterator
	{
	COLLECTSUBLINES Purpose; /* what sublines to take from a complex object */
	PLSDNODE plsdnFirst; /* dnode from which we started collecting */
	PLSDNODE plsdnStart; /* dnode where to start search for next, if NULL then 
							use plsdnFirst as first opportunity */
	LSCP cpLim;			/* boundary for group chunk if we go forward */
	BOOL fForward;		/* direction of traversing is forward otherwise it's backward*/
	}
GROUPCHUNKITERATOR;


static void CreateGroupChunkIterator(
					GROUPCHUNKITERATOR* pgroupchunkiterator, /* handler for iterator */
					COLLECTSUBLINES Purpose, /* what sublines to take from a complex object */
					PLSDNODE plsdnFirst, /* dnode from which we started collecting */
					LSCP cpLim,			/* boundary for group chunk if we go forward */
					BOOL fForward);		/* direction of traversing is forward otherwise it's backward*/


					
static void DestroyGroupChunkIterator(
					GROUPCHUNKITERATOR* pgroupchunkiterator); /* handler for iterator */



static PLSDNODE ContinueGroupChunk(
					GROUPCHUNKITERATOR* pgroupchunkiterator, /* handler for iterator */
					BOOL* pfSuccessful);				/* OUT: do we find dnode */

static PLSDNODE GetNextDnodeInGroupChunk(
					GROUPCHUNKITERATOR* pgroupchunkiterator, /* handler for iterator */
					BOOL* pfSuccessful);				/* OUT: do we find dnode */





#define  LschnkeFromDnode(plschnke, plsdn) \
		 (plschnke)->cpFirst = plsdn->cpFirst; \
		 (plschnke)->dcp = (plsdn)->dcp; \
		 (plschnke)->plschp = &((plsdn)->u.real.lschp); \
		 (plschnke)->plsrun = (plsdn)->u.real.plsrun; \
		 (plschnke)->pdobj = (plsdn)->u.real.pdobj; 


#define FIsGroupChunkBoundary(plsdn, cpLim, cpBase)  \
		(FIsOutOfBoundary((plsdn), (cpLim))  \
		||(FIsDnodePen(plsdn) && (!(plsdn)->fAdvancedPen)) \
		|| ((plsdn)->fTab) \
		||  (((cpBase) >= 0) ? ((plsdn)->cpFirst < 0) : ((plsdn)->cpFirst >= 0)))
/* last check verifies that we are not crossing boundaries of autonumber */

#define FIsGroupChunkStartBoundary(plsdn, cpBase)  \
		(((plsdn) == NULL)  \
		||(FIsDnodePen(plsdn) && (!(plsdn)->fAdvancedPen)) \
		|| ((plsdn)->fTab) \
		||  (((cpBase) >= 0) ? ((plsdn)->cpFirst < 0) : ((plsdn)->cpFirst >= 0)))
/* last check verifies that we are not crossing boundaries of autonumber */

#define FIsGrchnkExtValid(plschunkcontext, pgrchunkext)  \
		(((plschunkcontext) == (pgrchunkext)->plschunkcontext)  &&\
		 ((pgrchunkext)->lsgrchnk.plschnk == (plschunkcontext)->locchnkCurrent.plschnk) &&\
		 ((pgrchunkext)->lsgrchnk.pcont == (plschunkcontext)->pcont) &&\
		 ((pgrchunkext)->pplsdnNonText == (plschunkcontext)->pplsdnNonText) &&\
		 ((pgrchunkext)->pfNonTextExpandAfter == (plschunkcontext)->pfNonTextExpandAfter) \
        )
 
#define FDnodeInsideSubline(plssubl, plsdn) \
	    (FDnodeBeforeCpLim(plsdn, (plssubl)->cpLim) \
		&& FDnodeAfterCpFirst(plsdn, (plssubl)->cpFirst)) 

#define FUseForPurpose(plsdn, purpose)  \
		(*(&((plsdn)->u.real.pinfosubl->fUseForJustification) + (purpose -1)))

#define FIsUsageFlagsCastWorks(plsdn)  \
		((plsdn)->u.real.pinfosubl->fUseForCompression == \
					FUseForPurpose(plsdn, CollectSublinesForCompression) && \
		 (plsdn)->u.real.pinfosubl->fUseForJustification == \
					FUseForPurpose(plsdn, CollectSublinesForJustification)  && \
		 (plsdn)->u.real.pinfosubl->fUseForDisplay == \
					FUseForPurpose(plsdn, CollectSublinesForDisplay)  && \
		 (plsdn)->u.real.pinfosubl->fUseForDecimalTab == \
					FUseForPurpose(plsdn, CollectSublinesForDecimalTab) && \
		 (plsdn)->u.real.pinfosubl->fUseForTrailingArea == \
					FUseForPurpose(plsdn, CollectSublinesForTrailingArea))

#define GetSubmittedSublines(plsdn, purpose) \
	   ((((purpose) == CollectSublinesNone) || \
		 (Assert(FIsDnodeReal(plsdn)), (plsdn)->u.real.pinfosubl == NULL) || \
		 ((plsdn)->u.real.pinfosubl->rgpsubl == NULL)) ?  \
			NULL :  (Assert(FIsUsageFlagsCastWorks(plsdn)), \
					 (FUseForPurpose(plsdn, purpose)) ? \
					(plsdn)->u.real.pinfosubl->rgpsubl : NULL))

#define GetNumberSubmittedSublines(plsdn) \
			(Assert((plsdn)->u.real.pinfosubl != NULL), (plsdn)->u.real.pinfosubl->cSubline)

#define FColinearTflows(t1, t2)  \
			(((t1) & fUVertical) == ((t2) & fUVertical))

#define FSameSemiPlaneTflows(t1, t2)  \
			(((t1) & fUDirection) == ((t2) & fUDirection))

#define FParallelTflows(t1,t2) \
		Assert(FColinearTflows(t1, t2)), \
		FSameSemiPlaneTflows(t1, t2)   // we assume here that they are colinear 



/* C O L L E C T  C H U N K  A R O U N D*/
/*----------------------------------------------------------------------------
    %%Function: CollectChunkAround
    %%Contact: igorzv

Parameters:
	plsc			-		(IN) chunk context
	plsdn			-	    (IN) dnode to collect chunk arround
	lstflow			-		(IN) lstflow
	ppoint					(IN) starting position of dnode

Fill in cnunk elements array for chunk arround pposinline->plsdn
Calculate location of the chunk
----------------------------------------------------------------------------*/

LSERR CollectChunkAround(PLSCHUNKCONTEXT plschunkcontext, PLSDNODE plsdnInChunk, 
						 LSTFLOW lstflow, POINTUV* ppoint)  
						  
{
	WORD idObjChnk;
	PLSDNODE plsdnNext;
	PLSDNODE plsdnCurrent;
	PLOCCHNK plocchnk;
	LSCHNKE* plschnke;
	DWORD clschnk;
	LSERR lserr;
	LSCP cpInChunk;

	Assert(FIsLSDNODE(plsdnInChunk));

	plocchnk = &(plschunkcontext->locchnkCurrent);
	clschnk = plocchnk->clschnk;
	plschnke = plocchnk->plschnk;
	plsdnCurrent = plsdnInChunk;
	cpInChunk = plsdnInChunk->cpFirst;
	
	
	/* check: has this chunk already collected? */
	/* chunk was already collected if there is some chunk and our dnode is within this chunk
	   and nothing was added to list after chunk was collected  			*/
	/* we turn off optimisation for dnodes with dcp=0 (ex. pens) because of a problem how
	   to figure out that dnode is within chunk */
	if ((!plschunkcontext->FChunkValid) || (plschunkcontext->FGroupChunk)  
		||(plschnke[0].cpFirst > plsdnCurrent->cpFirst)
		|| (plschnke[clschnk - 1].cpFirst < plsdnCurrent->cpFirst)
		|| (plsdnCurrent->dcp == 0) 
		|| (plschnke[0].dcp == 0)
		|| ((plschunkcontext->pplsdnChunk[clschnk - 1])->plsdnNext != NULL))
		{
		/* we need to recollect chunk  */

		/* we don't allow caller to pass border as a plsdnInChunk */
		Assert(!FIsDnodeBorder(plsdnInChunk));

		if ( FIsDnodePen(plsdnInChunk) || plsdnInChunk->fTab || FIsDnodeSplat(plsdnInChunk))
			{
			/* for pens and tabs chunk consists of one element and we collect it right away */
			plocchnk->clschnk = 1;
			Assert(plocchnk->clschnk <= plschunkcontext->cchnkMax);
			LschnkeFromDnode((&(plschnke[0])), plsdnInChunk);
			plschunkcontext->pplsdnChunk[0] = plsdnInChunk;
			plschunkcontext->FChunkValid = fTrue;
			plschunkcontext->FLocationValid = fFalse;
			plschunkcontext->FGroupChunk = fFalse;
			/* we should here calculate width of border before dnode, the same way it done
			   in FillChunkArray */
			plschunkcontext->pdurOpenBorderBefore[0] = 0;
			plschunkcontext->pdurCloseBorderAfter[0] = 0;
			plschunkcontext->FBorderInside = fFalse;
			plsdnCurrent = plsdnInChunk->plsdnPrev;
			if (plsdnCurrent != NULL && FIsDnodeOpenBorder(plsdnCurrent))
				{
				plschunkcontext->FBorderInside = fTrue;
				plschunkcontext->pdurOpenBorderBefore[0] += DurFromDnode(plsdnCurrent);
				}
			plsdnCurrent = plsdnInChunk->plsdnNext;
			if (plsdnCurrent != NULL && FIsDnodeCloseBorder(plsdnCurrent))
				{
				plschunkcontext->FBorderInside = fTrue;
				plschunkcontext->pdurCloseBorderAfter[0] += DurFromDnode(plsdnCurrent);
				}
			}
		else
			{
	
			idObjChnk = IdObjFromDnode(plsdnInChunk);
			
			/* go to the end of chunk   */
			plsdnNext = plsdnCurrent->plsdnNext;
			while(!FIsChunkBoundary(plsdnNext, idObjChnk, cpInChunk))
				{
				plsdnCurrent = plsdnNext;
				plsdnNext = plsdnCurrent->plsdnNext;
				}
			
			lserr = FillChunkArray(plschunkcontext, plsdnCurrent);
			if (lserr != lserrNone)
				return lserr;
			}
		}
			
	/* check: is chunck located  */
	if (!plschunkcontext->FLocationValid)
		{
		LocateChunk(plschunkcontext, plsdnInChunk, lstflow, ppoint);
		}
	
	return lserrNone;

}

/* L O C A T E   C H U N K  */
/*----------------------------------------------------------------------------
    %%Function: CollectPreviousChunk
    %%Contact: igorzv

Parameters:
	plsc			-		(IN) chunk context
	plsdn			-	    (IN) dnode to collect chunk arround
	lstflow			-		(IN) lstflow
	ppoint					(IN) starting position of dnode

Calculates location of the chunk. We assume here that pointUv.u in locchunk
contains before this procedure width of border before dnode.
After procedure we put location there 
/*----------------------------------------------------------------------------*/


static void LocateChunk(PLSCHUNKCONTEXT plschunkcontext, PLSDNODE plsdnInChunk, 
						 LSTFLOW lstflow, POINTUV* ppoint)	
	{
	PLSDNODE plsdnFirst;
	PLOCCHNK plocchnk;
	PLSDNODE* pplsdnChunk;
	PLSDNODE plsdnCurrent;
	long urPen,vrPen;
	LONG i;
	PPOINTUV ppointUv;
	LONG* pdurOpenBorderBefore;
	LONG* pdurCloseBorderAfter;

	Assert(!FIsDnodeBorder(plsdnInChunk));  /* we don't allow border as in input */

	plocchnk = &(plschunkcontext->locchnkCurrent);
	plsdnFirst = plschunkcontext->pplsdnChunk[0];
	plocchnk->lsfgi.fFirstOnLine = FIsFirstOnLine(plsdnFirst)   
										&& FIsSubLineMain(SublineFromDnode(plsdnFirst));   
	plocchnk->lsfgi.cpFirst = plsdnFirst->cpFirst;		
	plocchnk->lsfgi.lstflow = lstflow;  		
	/* we can't set urColumnMax here, because during breaking object handler can change it */
	/* and we suppose that caller use  for this purpose SetUrColumnMaxForChunks */
	
	pplsdnChunk = plschunkcontext->pplsdnChunk;
	ppointUv = plocchnk->ppointUvLoc;
	pdurOpenBorderBefore = plschunkcontext->pdurOpenBorderBefore;
	pdurCloseBorderAfter = plschunkcontext->pdurCloseBorderAfter;

	/* calculation of pen position  before chunk */
	if (plsdnFirst->plsdnPrev == NULL)      /* optimization */
		{
		urPen = plschunkcontext->urFirstChunk;		
		vrPen = plschunkcontext->vrFirstChunk;	
		}
	else
		{
		plsdnCurrent = plsdnInChunk; 
		urPen = ppoint->u;
		vrPen = ppoint->v;
		
		for (i = 0; pplsdnChunk[i] != plsdnCurrent; i++)
			{
			Assert(i < (LONG) plocchnk->clschnk);      
			urPen -= DurFromDnode(pplsdnChunk[i]);
			vrPen -= DvrFromDnode(pplsdnChunk[i]);
			/* substract also border before dnode */
			urPen -= pdurOpenBorderBefore[i];
			urPen -= pdurCloseBorderAfter[i];
			}
		/* and now open border before plsdnCurrent */
		urPen -= pdurOpenBorderBefore[i];

		}

	plocchnk->lsfgi.urPen = urPen;
	plocchnk->lsfgi.vrPen = vrPen;

	/* location of all dnodes */
	for (i = 0; i < (LONG) plocchnk->clschnk; i++)
		{
		urPen += pdurOpenBorderBefore[i]; /* count border */
		if (i != 0) urPen += pdurCloseBorderAfter[i - 1];
		ppointUv[i].u = urPen;
		ppointUv[i].v = vrPen;
		urPen += DurFromDnode(pplsdnChunk[i]);
		vrPen += DvrFromDnode(pplsdnChunk[i]);
		}

	plschunkcontext->FLocationValid = fTrue;
	}

/* C O L L E C T  P R E V I O U S  C H U N K  */
/*----------------------------------------------------------------------------
    %%Function: CollectPreviousChunk
    %%Contact: igorzv

Parameters:
	plschuncontext				-	(IN) chunk context
	pfSuccessful		-			(OUT) does previous chunk exist 

Check that we are in the begining of line,
othewise call CollectChunkAround with the previous dnode
----------------------------------------------------------------------------*/


LSERR CollectPreviousChunk(PLSCHUNKCONTEXT plschunkcontext,	 
					   BOOL* pfSuccessful )		
{
	PLOCCHNK plocchnk;
	POINTUV point;
	PLSDNODE plsdn;


	plocchnk = &(plschunkcontext->locchnkCurrent);

	if (FIsFirstOnLine(plschunkcontext->pplsdnChunk[0]))  
		{
		*pfSuccessful = fFalse;
		return lserrNone;
		}
	else
		{
		plsdn = plschunkcontext->pplsdnChunk[0]->plsdnPrev;
		point = plocchnk->ppointUvLoc[0];
		while (FIsDnodeBorder(plsdn))
			{
			point.u -= DurFromDnode(plsdn);
			point.v -= DvrFromDnode(plsdn);
			plsdn = plsdn->plsdnPrev;
			}

		point.u -= DurFromDnode(plsdn);
		point.v -= DvrFromDnode(plsdn);

		*pfSuccessful = fTrue;
		return CollectChunkAround(plschunkcontext, plsdn, 
								  plocchnk->lsfgi.lstflow, &point);
		}
}

/* C O L L E C T  N E X T  C H U N K  */
/*----------------------------------------------------------------------------
    %%Function: CollectNextChunk
    %%Contact: igorzv

Parameters:
	plschuncontext				-	(IN) chunk context
	pfSuccessful		-	(OUT) does next chunk exist 

Check that we are in the end of list, in this case return *pfSuccessful and don't change chunk
othewise call CollectChunkAround with the next dnode
----------------------------------------------------------------------------*/


LSERR CollectNextChunk(PLSCHUNKCONTEXT plschunkcontext,	 
					   BOOL* pfSuccessful )		
	{
	PLOCCHNK plocchnk;
	DWORD clschnk;
	PLSDNODE* pplsdnChunk;
	POINTUV point; 
	PLSDNODE plsdn;
	
	
	plocchnk = &(plschunkcontext->locchnkCurrent);
	clschnk = plocchnk->clschnk;
	Assert(clschnk > 0);
	pplsdnChunk = plschunkcontext->pplsdnChunk;
	
	point = plocchnk->ppointUvLoc[clschnk - 1];
	point.u += DurFromDnode(pplsdnChunk[clschnk - 1]);
	point.v += DvrFromDnode(pplsdnChunk[clschnk - 1]);
	
	plsdn = pplsdnChunk[clschnk - 1]->plsdnNext;
	/* skip borders */
	while (plsdn != NULL && FIsDnodeBorder(plsdn))
		{
		point.u += DurFromDnode(plsdn);
		point.v += DvrFromDnode(plsdn);
		plsdn = plsdn->plsdnNext;
		}

	if (plsdn == NULL)
		{
		*pfSuccessful = fFalse;
		return lserrNone;
		}
	else
		{
		*pfSuccessful = fTrue;
		return CollectChunkAround(plschunkcontext, plsdn, 
			plocchnk->lsfgi.lstflow, &point);
		}
	}

/* F I L L  C H U N K  A R R A Y*/
/*----------------------------------------------------------------------------
    %%Function: FillChunkArray
    %%Contact: igorzv

Parameters:
	plschuncontext		-	(IN) chunk context
	plsdnLast			-	(IN) last dnode in chunk

Fill in chunk elements array for chunk before plsdnLast
----------------------------------------------------------------------------*/
LSERR 	FillChunkArray(PLSCHUNKCONTEXT  plschunkcontext,
						 PLSDNODE  plsdnLast) 
{
	PLSDNODE plsdnCurrent, plsdnPrev;
	WORD idObjChnk;
	PLOCCHNK plocchnk;
	LSCHNKE* plschnke;
	LONG clschnke;
	LSERR lserr;
	LONG i;
	LSCP cpInChunk;
	PPOINTUV ppointUv;
	LONG* pdurOpenBorderBefore;
	LONG* pdurCloseBorderAfter;

	Assert(FIsLSDNODE(plsdnLast));

	Assert(!plsdnLast->fTab);  /* for optimization we assume that caller will resolve */
	Assert(! FIsDnodePen(plsdnLast)); /* pen and tabs */
	Assert(!FIsDnodeSplat(plsdnLast));

	plocchnk = &(plschunkcontext->locchnkCurrent);

	/* skip borders in the end of chunk to figure out what idObj this chunk has */
	while (FIsDnodeBorder(plsdnLast))
		{
		plsdnLast = plsdnLast->plsdnPrev;
		Assert(FIsLSDNODE(plsdnLast));
		}

	idObjChnk = IdObjFromDnode(plsdnLast);
	cpInChunk = plsdnLast->cpFirst;

	/* go to the begining of chunk calculating amount of elements */
	plsdnCurrent = plsdnLast;
	plsdnPrev = plsdnCurrent->plsdnPrev;
	clschnke = 1;

	while (!FIsChunkBoundary(plsdnPrev, idObjChnk, cpInChunk))
			{
			plsdnCurrent = plsdnPrev;
			plsdnPrev = plsdnCurrent->plsdnPrev;
			if (!FIsDnodeBorder(plsdnCurrent)) clschnke++; /* we don't put borders into array */
			}
	/* plsdnCurrent is first dnode in chunk, clschnke is amount of chnk elements */

	if (clschnke > (LONG) plschunkcontext->cchnkMax)
		{
		lserr = SetChunkArraysSize(plschunkcontext, clschnke);
		if (lserr != lserrNone)
			return lserr;
		}
	
	

	/* fill in array of chunk elements   */
	FlushNominalToIdealState(plschunkcontext);
	plschnke = plocchnk->plschnk;
	plocchnk->clschnk = clschnke;
	ppointUv = plocchnk->ppointUvLoc;
	pdurOpenBorderBefore = plschunkcontext->pdurOpenBorderBefore;
	pdurCloseBorderAfter = plschunkcontext->pdurCloseBorderAfter;
	plschunkcontext->FBorderInside = fFalse;

	for (i=0; i < clschnke; i++)
		{
		Assert(!FIsChunkBoundary(plsdnCurrent, idObjChnk, cpInChunk));
		ppointUv[i].u = 0;
		pdurOpenBorderBefore[i] = 0;
		if (i != 0) pdurCloseBorderAfter[i - 1] = 0;
		while (FIsDnodeBorder(plsdnCurrent))
			{
			/* calculates border widths */
			plschunkcontext->FBorderInside = fTrue;
			if (FIsDnodeOpenBorder(plsdnCurrent))
				{
				pdurOpenBorderBefore[i] += DurFromDnode(plsdnCurrent);
				}
			else
				{
				if (i != 0) pdurCloseBorderAfter[i - 1] += DurFromDnode(plsdnCurrent);
				}
				
			plsdnCurrent = plsdnCurrent->plsdnNext;
			}

		LschnkeFromDnode(plschnke, plsdnCurrent);
		plschunkcontext->pplsdnChunk[i] = plsdnCurrent;
		SetNominalToIdealFlags(plschunkcontext, &(plsdnCurrent->u.real.lschp));

		plsdnCurrent = plsdnCurrent->plsdnNext;

		plschnke++;
		}

	/* closing border after chunk */
	if (plsdnCurrent != NULL && FIsDnodeCloseBorder(plsdnCurrent))
		{
		plschunkcontext->FBorderInside = fTrue;
		pdurCloseBorderAfter[clschnke - 1] = DurFromDnode(plsdnCurrent);
		}
	else
		{
		pdurCloseBorderAfter[clschnke - 1] = 0;
		}

	plschunkcontext->FChunkValid = fTrue;	
	plschunkcontext->FLocationValid = fFalse; /* chunk we collected is not located and */
	plschunkcontext->FGroupChunk = fFalse;	/* is not group */

	return lserrNone;

}


/* S E T  P O S  I N  C H U N K */
/*----------------------------------------------------------------------------
    %%Function: SetPosInChunk
    %%Contact: igorzv

Parameters:
	plschunkcontext		-	(IN) LineServices context
	PLSDNODE plsdn		-	(IN) dnode
	LSDCP dcp			-	(IN) dcp
	pposichnk			-	(OUT) position in chunk to fill in

Convert position in line to position in chunk
----------------------------------------------------------------------------*/

void SetPosInChunk(PLSCHUNKCONTEXT plschunkcontext, PLSDNODE plsdn,
				   LSDCP dcp, PPOSICHNK pposichnk)
{

	LONG i;
	LONG clschnkMac;
	PLSDNODE* pplsdnChunk;
	
	Assert(FIsLSDNODE(plsdn));

	pplsdnChunk = plschunkcontext->pplsdnChunk;
	clschnkMac = plschunkcontext->locchnkCurrent.clschnk;  
	for (i=0; (i < clschnkMac) && (plsdn != pplsdnChunk[i]) ; i++);

	Assert(i < clschnkMac);

	pposichnk->dcp = dcp;
	pposichnk->ichnk = i;

}


		 
/* I N I T  G R O U P  C H U N K  E X T */
/*----------------------------------------------------------------------------
    %%Function: InitGroupChunkExt
    %%Contact: igorzv

Parameters:
	plschunkcontext				-	(IN) chunkcontext context
	iobjText				-		(IN) idobj of text
	pgrchunkext			-	(OUT) structure to initialize

Link GroupChunkExt with state 
Fill in default values
----------------------------------------------------------------------------*/


void InitGroupChunkExt(PLSCHUNKCONTEXT plschunkcontext, DWORD iobjText,
					   GRCHUNKEXT* pgrchunkext)
{
	Assert(pgrchunkext != NULL);
	
	pgrchunkext->plschunkcontext = plschunkcontext;

	pgrchunkext->iobjText = iobjText;
	
	/* we don't need to flush everything here */
	/* we will do this in CollectGroupChunk procedures */

	pgrchunkext->lsgrchnk.plschnk = plschunkcontext->locchnkCurrent.plschnk;
	pgrchunkext->lsgrchnk.pcont = plschunkcontext->pcont;
	pgrchunkext->pfNonTextExpandAfter = plschunkcontext->pfNonTextExpandAfter;
	pgrchunkext->pplsdnNonText = plschunkcontext->pplsdnNonText;
}




/* C O L L E C T  T E X T  G R O U P  C H U N K*/
/*----------------------------------------------------------------------------
%%Function: CollectTextGroupChunk
%%Contact: igorzv

  Parameters:
  plsdnFirst			-	(IN) start dnode
  cpLim				-   (IN) boundary for group chunk
  Purpose				-	(IN) what subline to take from complex object
  pgrchunkext			-	(OUT) group chunk to fill in
  
	Fill in group chunk structure with text dnodes located from plsdFirst 
----------------------------------------------------------------------------*/



LSERR CollectTextGroupChunk(		
							PLSDNODE plsdnFirst,
							LSCP cpLim,
							COLLECTSUBLINES Purpose,
							GRCHUNKEXT* pgrchunkext)
	{
	PLSCHUNKCONTEXT plschunkcontext = pgrchunkext->plschunkcontext;
	DWORD iobjText = pgrchunkext->iobjText;
	PLOCCHNK plocchnk;
	DWORD cChunk;
	PLSDNODE plsdnCurrent;
	BOOL fPreviousIsNonText = fFalse;
	LSERR lserr;
	LSCHNKE* plschnke;
	BOOL fSuccessful;
	BOOL fExpand;
	DWORD cTextBeforeLastNonText = 0;
	GROUPCHUNKITERATOR groupchunkiterator;
	PLSDNODE plsdnLastForTrailing;
	int cDnodesTrailing;
	LSDCP dcpStartTrailing;
	PLSDNODE plsdnTrailingObject;
	LSDCP dcpTrailingObject;
	
	
	Assert(FIsLSDNODE(plsdnFirst));
	Assert(FIsGrchnkExtValid(plschunkcontext, pgrchunkext)); 
	
	
	
	/* we try to optimize here in a case when group chunk consist of one (last in a line)
	chunk 	and this chunk has been already collected */
	plocchnk = &(plschunkcontext->locchnkCurrent);
	cChunk = plocchnk->clschnk;
	
	/* if we have text chunk without borders started with plsdnFirst 
	and going up or beyond cpLim */
	if ((cChunk > 0) &&
		(plschunkcontext->FChunkValid) && 
		(!plschunkcontext->FGroupChunk) && 
		(!plschunkcontext->FBorderInside) && 
		(IdObjFromChnk(plocchnk) ==  pgrchunkext->iobjText) && 
		(plschunkcontext->pplsdnChunk[0] == plsdnFirst)
		&& (!plsdnFirst->fTab)
		&& (FIsOutOfBoundary((plschunkcontext->pplsdnChunk[cChunk - 1])->plsdnNext, cpLim)))
		{
		pgrchunkext->Purpose = Purpose;
		return ConvertChunkToGroupChunk(pgrchunkext, cpLim);
		}
	
	/* we have to go through general procedure */
	
	/* flush group chunk				*/
	pgrchunkext->plsdnFirst = plsdnFirst;
	pgrchunkext->durTotal = 0;
	pgrchunkext->durTextTotal = 0;
	pgrchunkext->dupNonTextTotal = 0;
	pgrchunkext->cNonTextObjects = 0;
	pgrchunkext->cNonTextObjectsExpand = 0;
	pgrchunkext->lsgrchnk.clsgrchnk = 0;
	pgrchunkext->plsdnNext = NULL;
	pgrchunkext->plsdnLastUsed = NULL;
	plschunkcontext->FGroupChunk = fTrue;
	plschunkcontext->FBorderInside = fFalse;
	pgrchunkext->Purpose = Purpose;
	
	CreateGroupChunkIterator(&groupchunkiterator, 
		Purpose, plsdnFirst, cpLim,	fTrue);	
	
	plsdnCurrent = GetNextDnodeInGroupChunk(&groupchunkiterator, &fSuccessful);
	
	while(fSuccessful)
		{
		pgrchunkext->plsdnLastUsed = plsdnCurrent;
		
		/* fill in array of elements   */
		if (FIsDnodeReal(plsdnCurrent) && !FIsDnodeSplat(plsdnCurrent)) /* not a pen border or splat*/
			{
			if (IdObjFromDnode(plsdnCurrent) == iobjText) /* is text */
				{
				
				pgrchunkext->lsgrchnk.clsgrchnk++;
				if (pgrchunkext->lsgrchnk.clsgrchnk > plschunkcontext->cchnkMax)
					{
					lserr = IncreaseChunkArrays(plschunkcontext);
					if (lserr != lserrNone)
						{
						DestroyGroupChunkIterator(&groupchunkiterator);
						return lserr;
						}
					pgrchunkext->lsgrchnk.plschnk = plschunkcontext->locchnkCurrent.plschnk;
					pgrchunkext->lsgrchnk.pcont = plschunkcontext->pcont;
					Assert(FIsGrchnkExtValid(plschunkcontext, pgrchunkext)); 
					}
				
				/* fill in group chunk element */
				plschnke = &(pgrchunkext->lsgrchnk.plschnk[pgrchunkext->lsgrchnk.clsgrchnk - 1]);
				LschnkeFromDnode(plschnke, plsdnCurrent);
				
				/* fill in array of dnodes in context */
				plschunkcontext->pplsdnChunk[pgrchunkext->lsgrchnk.clsgrchnk - 1] = plsdnCurrent;
				
				/* flash flags */
				pgrchunkext->lsgrchnk.pcont[pgrchunkext->lsgrchnk.clsgrchnk - 1] = 0;
				
				/* set flags  */
				if (fPreviousIsNonText)
					{
					pgrchunkext->lsgrchnk.pcont[pgrchunkext->lsgrchnk.clsgrchnk - 1] |=
						fcontNonTextBefore;  
					}
				
				
				fPreviousIsNonText = fFalse;
				
				/* calculate integrated information   */
				pgrchunkext->durTextTotal += plsdnCurrent->u.real.objdim.dur;
				pgrchunkext->durTotal += plsdnCurrent->u.real.objdim.dur;
				}
			else
				{
				/* resolve expansion after previous non text */
				if (pgrchunkext->cNonTextObjects > 0)
					{
					lserr = FExpandAfterNonTextObject(pgrchunkext, cTextBeforeLastNonText, 
						&fExpand);
					if (lserr != lserrNone)
						{
						DestroyGroupChunkIterator(&groupchunkiterator);
						return lserr;
						}
					
					pgrchunkext->pfNonTextExpandAfter[pgrchunkext->cNonTextObjects - 1] =
						fExpand;
					
					if (fExpand)
						{
						/* increase amount of expandable non text objects */
						pgrchunkext->cNonTextObjectsExpand++;
						/* it was text between two non texts */
						if (!fPreviousIsNonText)
							{
							Assert(pgrchunkext->lsgrchnk.clsgrchnk > cTextBeforeLastNonText);
							pgrchunkext->lsgrchnk.pcont[cTextBeforeLastNonText] |=
								fcontExpandBefore; 
							}
						}
					}
				
				
				pgrchunkext->cNonTextObjects++;
				if (pgrchunkext->cNonTextObjects > plschunkcontext->cNonTextMax)
					{
					lserr = IncreaseGroupChunkNonTextArrays(plschunkcontext);
					if (lserr != lserrNone)
						{
						DestroyGroupChunkIterator(&groupchunkiterator);
						return lserr;
						}
					pgrchunkext->pplsdnNonText = plschunkcontext->pplsdnNonText;
					pgrchunkext->pfNonTextExpandAfter = plschunkcontext->pfNonTextExpandAfter;
					Assert(FIsGrchnkExtValid(plschunkcontext, pgrchunkext)); 
					}
				
				/* fill in array of non text dnodes in context */
				plschunkcontext->pplsdnNonText[pgrchunkext->cNonTextObjects - 1] = plsdnCurrent;
				
				
				/* set flags in previous text */
				if (!fPreviousIsNonText && pgrchunkext->lsgrchnk.clsgrchnk >= 1)
					{
					Assert(pgrchunkext->lsgrchnk.clsgrchnk >= 1);
					pgrchunkext->lsgrchnk.pcont[pgrchunkext->lsgrchnk.clsgrchnk  - 1] |=
						(fcontNonTextAfter); 
					
					/* resolve expansion before current non text */
					Assert(cTextBeforeLastNonText < pgrchunkext->lsgrchnk.clsgrchnk);
					lserr =FExpandBeforeNonTextObject(pgrchunkext, cTextBeforeLastNonText,
						&fExpand);
					if (lserr != lserrNone)
						{
						DestroyGroupChunkIterator(&groupchunkiterator);
						return lserr;
						}
					if (fExpand)
						{
						pgrchunkext->lsgrchnk.pcont[pgrchunkext->lsgrchnk.clsgrchnk  - 1] |=
							fcontExpandAfter;
						}
					}
				
				fPreviousIsNonText = fTrue;
				cTextBeforeLastNonText = pgrchunkext->lsgrchnk.clsgrchnk;
				
				/* calculate integrated information   */
				pgrchunkext->durTotal += DurFromRealDnode(plsdnCurrent);
				pgrchunkext->dupNonTextTotal += DupFromRealDnode(plsdnCurrent);
				} /* non -text */
			} /* real dnode */
			else
				{  /* pen  or border*/
				Assert(FIsDnodePen(plsdnCurrent) ||
					FIsDnodeBorder(plsdnCurrent) || FIsDnodeSplat(plsdnCurrent));
				Assert(FIsDnodeBorder(plsdnCurrent) || FIsDnodeSplat(plsdnCurrent) ||
					plsdnCurrent->fAdvancedPen); /* only advanced pens are allowed here */
				
				if (FIsDnodeBorder(plsdnCurrent)) 
					plschunkcontext->FBorderInside = fTrue;
				
				pgrchunkext->durTotal += DurFromDnode(plsdnCurrent);
				pgrchunkext->dupNonTextTotal += DupFromDnode(plsdnCurrent);
				}
			
			/* prepare next iteration */
			plsdnCurrent = GetNextDnodeInGroupChunk(&groupchunkiterator, &fSuccessful);
		}
		
		/* resolve expansion after previous non text */
		if (pgrchunkext->cNonTextObjects > 0)
			{
			lserr = FExpandAfterNonTextObject(pgrchunkext, cTextBeforeLastNonText, 
				&fExpand);
			if (lserr != lserrNone)
				{
				DestroyGroupChunkIterator(&groupchunkiterator);
				return lserr;
				}
			
			pgrchunkext->pfNonTextExpandAfter[pgrchunkext->cNonTextObjects - 1] |=
				fExpand;
			
			if (fExpand)
				{
				/* increase amount of expandable non text objects */
				pgrchunkext->cNonTextObjectsExpand++;
				/* it was text between two non texts */
				if (!fPreviousIsNonText)
					{
					Assert(pgrchunkext->lsgrchnk.clsgrchnk > cTextBeforeLastNonText);
					pgrchunkext->lsgrchnk.pcont[cTextBeforeLastNonText] |=
						fcontExpandBefore; 
					}
				}
			}
		
		pgrchunkext->plsdnNext = plsdnCurrent;
		
		DestroyGroupChunkIterator(&groupchunkiterator);
		
		/* because collecting of group chunk can be called before SetBreak, dcp of last
		dnode, if it come from lower level, should be cut using  cpLim */
		
		if ((pgrchunkext->lsgrchnk.clsgrchnk > 0) &&
			(plschunkcontext->pplsdnChunk[pgrchunkext->lsgrchnk.clsgrchnk - 1]->cpLimOriginal 
			> cpLim)
			)
			{
			pgrchunkext->lsgrchnk.plschnk[pgrchunkext->lsgrchnk.clsgrchnk - 1].dcp =
				cpLim - 
				plschunkcontext->pplsdnChunk[pgrchunkext->lsgrchnk.clsgrchnk - 1]->cpFirst;
			}
		
		if (Purpose == CollectSublinesForJustification || 
			Purpose == CollectSublinesForCompression)
			{
			/* we should find here last dnode on the upper level before chunk boundary */
			if (pgrchunkext->plsdnLastUsed == NULL)
				{
				/* first dnode is already out of boundary, it can happened with tabs or pens  */
				Assert(pgrchunkext->plsdnFirst == pgrchunkext->plsdnNext);
				plsdnLastForTrailing = pgrchunkext->plsdnFirst;
				}
			else if (pgrchunkext->plsdnNext != NULL)
				{
				plsdnLastForTrailing = pgrchunkext->plsdnNext->plsdnPrev;
				}
			else
				{
				plsdnLastForTrailing = (SublineFromDnode(pgrchunkext->plsdnFirst))->plsdnLast;
				}
			
			lserr = GetTrailingInfoForTextGroupChunk
				(plsdnLastForTrailing, plsdnLastForTrailing->dcp,
				iobjText, &(pgrchunkext->durTrailing), &(pgrchunkext->dcpTrailing),
				&(pgrchunkext->plsdnStartTrailing), 
				&dcpStartTrailing,
				&cDnodesTrailing, &plsdnTrailingObject, &dcpTrailingObject,
				&(pgrchunkext->fClosingBorderStartsTrailing));
			
			if (lserr != lserrNone)
				{
				return lserr;
				}
			
			if (cDnodesTrailing == 0)
				{
				if (pgrchunkext->lsgrchnk.clsgrchnk != 0)
					{
					pgrchunkext->posichnkBeforeTrailing.ichnk = pgrchunkext->lsgrchnk.clsgrchnk - 1;
					pgrchunkext->posichnkBeforeTrailing.dcp = pgrchunkext->lsgrchnk.plschnk
						[pgrchunkext->posichnkBeforeTrailing.ichnk].dcp;
					}
				else
					{
					/* in this case posichnkBeforeTrailing doesn't make any sense and we can't use
					code above not to triger memory violation, so we put zeroes just to put something */
					pgrchunkext->posichnkBeforeTrailing.ichnk = 0;
					pgrchunkext->posichnkBeforeTrailing.dcp = 0;
					}
				}
			else
				{
				pgrchunkext->posichnkBeforeTrailing.ichnk = pgrchunkext->lsgrchnk.clsgrchnk 
					- cDnodesTrailing;
				if (FIsDnodeReal(pgrchunkext->plsdnStartTrailing) 
					&& IdObjFromDnode(pgrchunkext->plsdnStartTrailing) == iobjText)
					{
					pgrchunkext->posichnkBeforeTrailing.dcp = dcpStartTrailing;
					}
				else
					{
					/* trailing area was interupted by non text, we report to text starting of trailing before
					previous text */
					Assert(pgrchunkext->plsdnStartTrailing->dcp == dcpStartTrailing);
					pgrchunkext->posichnkBeforeTrailing.dcp = 0;
					}
				}
			}
		
		
		return lserrNone;
		
	}
	
	


/* C O N T I N U E  G R O U P  C H U N K*/
/*----------------------------------------------------------------------------
    %%Function: ContinueGroupChunk
    %%Contact: igorzv

Parameters:
	pgroupchunkiterator	-(IN) handler for iterator 
	pfSuccessful	-	(OUT) do we find dnode in this group chunk 

Start traversing list for collecting group chunk 
----------------------------------------------------------------------------*/

PLSDNODE ContinueGroupChunk(
							GROUPCHUNKITERATOR* pgroupchunkiterator, 
							BOOL* pfSuccessful)
	{
	PLSSUBL plssubl;
	PLSSUBL* rgpsubl;
	PLSDNODE plsdnStart = pgroupchunkiterator->plsdnStart;
	BOOL fBoundaryCondition;
	int cSublines;

	/* we assume here that dnode out of group chunk boundary can happen only on main subline of
	the group chunk */

	fBoundaryCondition = pgroupchunkiterator->fForward ? 
		FIsGroupChunkBoundary(plsdnStart, pgroupchunkiterator->cpLim, 
			pgroupchunkiterator->plsdnFirst->cpFirst) :
		FIsGroupChunkStartBoundary(plsdnStart, pgroupchunkiterator->plsdnFirst->cpFirst) ;
		

	if (fBoundaryCondition)		/* we out of limits */
		{	
		AssertImplies(plsdnStart != NULL, FIsLSDNODE(plsdnStart));
		AssertImplies(plsdnStart != NULL, 
			SublineFromDnode(plsdnStart) == SublineFromDnode(pgroupchunkiterator->plsdnFirst));
		*pfSuccessful = fFalse;
		return plsdnStart;
		}

	Assert(FIsLSDNODE(plsdnStart));
	plssubl = SublineFromDnode(plsdnStart);

	/* we assume here that here that plsnStart is valid dnode within subline*/
	Assert(!FIsOutOfBoundary(plsdnStart, plssubl->cpLim));

	*pfSuccessful = fTrue;

	if (FIsDnodeBorder(plsdnStart) || FIsDnodePen(plsdnStart))
		{
		return plsdnStart;
		}

	rgpsubl = GetSubmittedSublines(plsdnStart, pgroupchunkiterator->Purpose);

	if (rgpsubl == NULL)
		{
		return plsdnStart;
		}
	else
		{
		cSublines = GetNumberSubmittedSublines(plsdnStart);
		if (cSublines > 0)
			{
			plssubl = pgroupchunkiterator->fForward ? 
				rgpsubl[0] : rgpsubl[cSublines - 1];
			/* we assume here that empty subline can not be submitted */
			Assert(!FIsOutOfBoundary(plssubl->plsdnFirst, plssubl->cpLim));
			plssubl->plsdnUpTemp = plsdnStart;
			pgroupchunkiterator->plsdnStart = pgroupchunkiterator->fForward ?
				plssubl->plsdnFirst : plssubl->plsdnLast;
			return ContinueGroupChunk(pgroupchunkiterator, pfSuccessful);
			}
		else
			{
			return plsdnStart;
			}
		}
	}


/* G E T  N E X T  D N O D E  I N  G R O U P  C H U N K*/
/*----------------------------------------------------------------------------
    %%Function: GetNextDnodeInGroupChunk
    %%Contact: igorzv

Parameters:
	pgroupchunkiterator	-(IN) handler for iterator 
	pfSuccessful	-	(OUT) do we find dnode in this group chunk 

Continue traversing list for collecting group chunk 
----------------------------------------------------------------------------*/

PLSDNODE GetNextDnodeInGroupChunk(
					GROUPCHUNKITERATOR* pgroupchunkiterator, 
					BOOL* pfSuccessful)
	{
	LONG i;
	PLSSUBL plssubl;
	PLSDNODE plsdnNext;
	PLSDNODE plsdnUp;
	PLSSUBL* rgpsubl;
	LONG cSublines;
	PLSDNODE plsdnStart = pgroupchunkiterator->plsdnStart;

	if (plsdnStart == NULL)  /* first iteration */
		{
		pgroupchunkiterator->plsdnStart = pgroupchunkiterator->plsdnFirst;
		return ContinueGroupChunk(pgroupchunkiterator, pfSuccessful);
		}

	Assert(FIsLSDNODE(plsdnStart));
	
	plssubl = plsdnStart->plssubl;
	plsdnNext = pgroupchunkiterator->fForward ? 
					plsdnStart->plsdnNext : plsdnStart->plsdnPrev;

	/* we are in one of submitted sublines and this subline ended */
	if (plssubl != SublineFromDnode(pgroupchunkiterator->plsdnFirst) && 
		FIsOutOfBoundary(plsdnNext, plssubl->cpLim)) 
		{
		plsdnUp = plssubl->plsdnUpTemp;
		Assert(FIsLSDNODE(plsdnUp));
		/* flush temporary field */
		plssubl->plsdnUpTemp = NULL;

		rgpsubl = GetSubmittedSublines(plsdnUp, pgroupchunkiterator->Purpose);
		cSublines = GetNumberSubmittedSublines(plsdnUp);
		Assert(rgpsubl != NULL);
		Assert(cSublines > 0);

		/* find index in a array of submitted sublines */
		for (i=0; i < cSublines	&& plssubl != rgpsubl[i]; i++);
		Assert(i < cSublines);

		if ( (pgroupchunkiterator->fForward && i == cSublines - 1) ||
			 (!pgroupchunkiterator->fForward && i == 0)
		   )
		/* array ended: return to the upper level */
			{
			pgroupchunkiterator->plsdnStart = plsdnUp;
			return GetNextDnodeInGroupChunk(pgroupchunkiterator, pfSuccessful);
			}
		else
			{
			plssubl = pgroupchunkiterator->fForward ? 
						rgpsubl[i + 1] : rgpsubl[i - 1];
			/* we assume here that empty subline can not be submitted */
			Assert(!FIsOutOfBoundary(plssubl->plsdnFirst, plssubl->cpLim));
			plssubl->plsdnUpTemp = plsdnUp;
			pgroupchunkiterator->plsdnStart = plssubl->plsdnFirst;
			return ContinueGroupChunk(pgroupchunkiterator, pfSuccessful);
			}
		}
	else /* we can continue with the same subline */
		{
		pgroupchunkiterator->plsdnStart = plsdnNext;
		return ContinueGroupChunk(pgroupchunkiterator, pfSuccessful);
		}

	}

/* C R E A T E  G R O U P  C H U N K  I T E R A T O R*/
/*----------------------------------------------------------------------------
    %%Function: CreateGroupChunkIterator
    %%Contact: igorzv

Parameters:
	pgroupchunkiterator	-(IN) handler for iterator 
	Purpose				-(INI what sublines to take from a complex object 
	plsdnFirst			-(IN) dnode from which we started collecting 
	cpLim				-(IN) boundary for group chunk if we go forward 
	fForward			-(IN) direction of traversing is forward otherwise it's backward

----------------------------------------------------------------------------*/
static void CreateGroupChunkIterator(
					GROUPCHUNKITERATOR* pgroupchunkiterator, 
					COLLECTSUBLINES Purpose, 
					PLSDNODE plsdnFirst, 
					LSCP cpLim,			
					BOOL fForward)
	{
	pgroupchunkiterator->Purpose = Purpose;
	pgroupchunkiterator->plsdnFirst = plsdnFirst;
	pgroupchunkiterator->plsdnStart = NULL;
	pgroupchunkiterator->cpLim = cpLim;
	pgroupchunkiterator->fForward = fForward;
	}

/* D E S T R O Y  G R O U P  C H U N K  I T E R A T O R*/
/*----------------------------------------------------------------------------
    %%Function: DesroyGroupChunkIterator
    %%Contact: igorzv

Parameters:
	pgroupchunkiterator	-(IN) handler for iterator 

----------------------------------------------------------------------------*/
static void DestroyGroupChunkIterator(
									  GROUPCHUNKITERATOR* pgroupchunkiterator) 
	{
	PLSSUBL plssubl;
	PLSDNODE plsdn;
	if (pgroupchunkiterator->plsdnStart != NULL)
		{
		plssubl = SublineFromDnode(pgroupchunkiterator->plsdnStart);
		while (SublineFromDnode(pgroupchunkiterator->plsdnFirst) != plssubl)
			{
			plsdn = plssubl->plsdnUpTemp;
			Assert(FIsLSDNODE(plsdn));
			plssubl->plsdnUpTemp = NULL;
			plssubl = SublineFromDnode(plsdn);
			}
		}
	}

/* F  E X P A N D  B E F O R E  N O N  T E X T  O B J E C T*/
/*----------------------------------------------------------------------------
    %%Function: FExpandBeforeNonTextObject
    %%Contact: igorzv

Parameters:
	pgrchunkext					-	(IN) group chunk
	cTextBeforePreviousNonText	-	(IN) number of text before previous non text 
										 to calculate contiguous chunk
	pfExpand					-	(OUT) to expand dnode before non text

----------------------------------------------------------------------------*/
static LSERR FExpandBeforeNonTextObject(GRCHUNKEXT* pgrchunkext, DWORD cTextBeforePrevioustNonText,
									   BOOL* pfExpand)
	{
	DWORD cTextBetween;
	LSERR lserr;
	BOOL fSuccessful;
	WCHAR wchar;
	PLSRUN plsrunText;
	HEIGHTS heightsText;
	MWCLS mwcls;
	DWORD iobj;
	LSIMETHODS* plsim;
	PLSDNODE plsdnNonText;

	*pfExpand = fTrue;

	cTextBetween = pgrchunkext->lsgrchnk.clsgrchnk - cTextBeforePrevioustNonText;
	if (cTextBetween)
		{
		lserr = GetLastCharInChunk(cTextBetween,
				(pgrchunkext->lsgrchnk.plschnk + cTextBeforePrevioustNonText), &fSuccessful,
				&wchar, &plsrunText, &heightsText, &mwcls);
		if (lserr != lserrNone)
			return lserr; 
		if (fSuccessful)
			{
			plsdnNonText = pgrchunkext->pplsdnNonText[pgrchunkext->cNonTextObjects - 1];
			iobj = IdObjFromDnode(plsdnNonText);
			plsim = PLsimFromLsc(pgrchunkext->plschunkcontext->plsiobjcontext, iobj);
			if (plsim->pfnFExpandWithPrecedingChar != NULL)
				{
				lserr = plsim->pfnFExpandWithPrecedingChar(plsdnNonText->u.real.pdobj,
					plsdnNonText->u.real.plsrun, plsrunText, wchar,
					mwcls, pfExpand);
				if (lserr != lserrNone)
					return lserr;
				}  /* object has this method */
			}	/* call back from text was successful  */
		}
	return lserrNone;
	}

/* F  E X P A N D  A F T E R  N O N  T E X T  O B J E C T*/
/*----------------------------------------------------------------------------
    %%Function: FExpandAfterNonTextObject
    %%Contact: igorzv

Parameters:
	pgrchunkext					-	(IN) group chunk
	cTextBeforeLastNonText		-	(IN) number of text before last non text 
										 to calculate contiguous chunk
	pfExpand					-	(OUT) to expand dnode before non text

----------------------------------------------------------------------------*/
static LSERR FExpandAfterNonTextObject(GRCHUNKEXT* pgrchunkext, DWORD cTextBeforeLastNonText,
									   BOOL* pfExpand)
	{
	DWORD cTextBetween;
	LSERR lserr;
	BOOL fSuccessful;
	WCHAR wchar;
	PLSRUN plsrunText;
	HEIGHTS heightsText;
	MWCLS mwcls;
	DWORD iobj;
	LSIMETHODS* plsim;
	PLSDNODE plsdnNonText;

	*pfExpand = fTrue;

	cTextBetween = pgrchunkext->lsgrchnk.clsgrchnk - cTextBeforeLastNonText;
	if (cTextBetween)
		{
		lserr = GetFirstCharInChunk(cTextBetween,
				(pgrchunkext->lsgrchnk.plschnk + cTextBeforeLastNonText), &fSuccessful,
				&wchar, &plsrunText, &heightsText, &mwcls);
		if (lserr != lserrNone)
			return lserr; 
		if (fSuccessful)
			{
			plsdnNonText = pgrchunkext->pplsdnNonText[pgrchunkext->cNonTextObjects - 1];
			iobj = IdObjFromDnode(plsdnNonText);
			plsim = PLsimFromLsc(pgrchunkext->plschunkcontext->plsiobjcontext, iobj);
			if (plsim->pfnFExpandWithFollowingChar != NULL)
				{
				lserr = plsim->pfnFExpandWithFollowingChar(plsdnNonText->u.real.pdobj,
					plsdnNonText->u.real.plsrun, plsrunText, wchar,
					mwcls, pfExpand);
				if (lserr != lserrNone)
					return lserr;
				}  /* object has this method */
			}	/* call back from text was successful  */
		}
	return lserrNone;
	}


/* C O L L E C T  P R E V I O U S  T E X T  G R O U P  C H U N K*/
/*----------------------------------------------------------------------------
    %%Function: CollectPreviousTextGroupChunk
    %%Contact: igorzv

Parameters:
	plsdnEnd			-	(IN) end dnode
	sublinnesToCollect		(IN) what subline to take from complex object
	pgrchunkext			-	(OUT) group chunk to fill in

Fill in group chunk structure with text dnodes located before  plsdEnd
----------------------------------------------------------------------------*/



LSERR CollectPreviousTextGroupChunk(		
			 		 PLSDNODE plsdnEnd,
					 COLLECTSUBLINES Purpose,
					 BOOL fAllSimpleText,
					 GRCHUNKEXT* pgrchunkext)
{
	LSCHUNKCONTEXT* plschunkcontext = pgrchunkext->plschunkcontext;
	PLOCCHNK plocchnk;
	DWORD cChunk;
	LSCP cpLim;
	PLSDNODE plsdn;
	PLSDNODE plsdnPrev;

	Assert(FIsLSDNODE(plsdnEnd));
	Assert(FIsGrchnkExtValid(plschunkcontext, pgrchunkext)); 

	/* we try to optimize here in a case when there is only text in line  */
	/* chunk of text has been already collected */
	plocchnk = &(plschunkcontext->locchnkCurrent);
	cChunk = plocchnk->clschnk;
	cpLim = plsdnEnd->cpLimOriginal; 

	if (fAllSimpleText && cChunk > 0) 
		{
		/* chunk goes up to the end of a line */
		Assert((plschunkcontext->pplsdnChunk[cChunk - 1])->plsdnNext == NULL);
		pgrchunkext->Purpose = Purpose;
		return ConvertChunkToGroupChunk(pgrchunkext, cpLim);
		}

	/* go backward to the start of group chunk  */
	plsdn = plsdnEnd;
	plsdnPrev = plsdn->plsdnPrev;
	while (!FIsGroupChunkStartBoundary(plsdnPrev, plsdnEnd->cpFirst))
		{
		plsdn = plsdnPrev;
		plsdnPrev = plsdn->plsdnPrev;
		}
	
	return CollectTextGroupChunk(plsdn, cpLim, Purpose, pgrchunkext);
	
}

/* C O N V E R T  C H U N K  T O  G R O U P  C H U N K*/
/*----------------------------------------------------------------------------
    %%Function: ConvertChunkToGroupChunk
    %%Contact: igorzv

Parameters:
	cpLim			-		(IN) cpLim
	pgrchunkext			-	(OUT) group chunk to fill in

Fill in group chunk structure with text dnodes located before  plsdEnd
We assume here that chunk doesn't contain border.
----------------------------------------------------------------------------*/


static LSERR ConvertChunkToGroupChunk(GRCHUNKEXT* pgrchunkext, LSCP cpLim)
{
	DWORD clsgrchnkCollected = 0;
	long durTotal = 0;
	LSCHUNKCONTEXT* plschunkcontext = pgrchunkext->plschunkcontext;
	PLOCCHNK plocchnk;
	LONG cChunk;
	LONG i;
	BOOL fLineEnded;
	PLSDNODE plsdn;
	long durTrailingDnode;
	LSDCP dcpTrailingDnode;

	Assert(FIsGrchnkExtValid(plschunkcontext, pgrchunkext)); 

	plocchnk = &(plschunkcontext->locchnkCurrent);
	cChunk = (int) plocchnk->clschnk;
	fLineEnded = fFalse;

	for (i = 0; (i < cChunk) && !fLineEnded; i ++)
		{
		clsgrchnkCollected++;
		pgrchunkext->lsgrchnk.pcont[i] = 0; 
		plsdn = plschunkcontext->pplsdnChunk[i];
		durTotal += DurFromRealDnode(plsdn);
		
		/* if we are in last dnode before cpLim there is possibility 
		that during break it was changed 
		so we  should rewrite dcp in chunk element and quit */
		if ((LSCP)(plsdn->cpLimOriginal) == cpLim)
			{
			plocchnk->plschnk[i].dcp = plsdn->dcp;
			fLineEnded = fTrue;
			}
		}

	/* fill in header  of groupchunkext   */
	pgrchunkext->plsdnFirst = plschunkcontext->pplsdnChunk[0];;
	pgrchunkext->plsdnLastUsed = plschunkcontext->pplsdnChunk[clsgrchnkCollected - 1];
	pgrchunkext->plsdnNext = pgrchunkext->plsdnLastUsed->plsdnNext;
	pgrchunkext->durTotal = durTotal;
	pgrchunkext->durTextTotal = durTotal;
	pgrchunkext->dupNonTextTotal = 0;
	pgrchunkext->cNonTextObjects = 0;
	pgrchunkext->cNonTextObjectsExpand = 0;
	pgrchunkext->lsgrchnk.clsgrchnk = clsgrchnkCollected;

	plschunkcontext->FGroupChunk = fTrue;

	if (pgrchunkext->Purpose == CollectSublinesForJustification || 
		pgrchunkext->Purpose == CollectSublinesForCompression)
		{
		Assert(clsgrchnkCollected > 0);
		pgrchunkext->durTrailing = 0;
		pgrchunkext->dcpTrailing = 0;
		plsdn = NULL;
		dcpTrailingDnode = 0;

		pgrchunkext->fClosingBorderStartsTrailing = fFalse;
		
		for (i = clsgrchnkCollected - 1; i >= 0; i--)
			{
			plsdn = plschunkcontext->pplsdnChunk[i];
			GetTrailInfoText(PdobjFromDnode(plsdn), plsdn->dcp,
				&dcpTrailingDnode, &durTrailingDnode);
			pgrchunkext->durTrailing += durTrailingDnode;
			pgrchunkext->dcpTrailing += dcpTrailingDnode;
			
			/* add opening border before previous dnode */
			if (i < (int) (clsgrchnkCollected - 1))
				pgrchunkext->durTrailing += plschunkcontext->pdurOpenBorderBefore[i +1];

			if (dcpTrailingDnode != 0) 
				/* add closing border after */
				pgrchunkext->durTrailing += plschunkcontext->pdurCloseBorderAfter[i];
			else
				{
				pgrchunkext->fClosingBorderStartsTrailing = 
					(plschunkcontext->pdurCloseBorderAfter[i] != 0);
				}
			
			if (plsdn->dcp != dcpTrailingDnode)
				break;
			
			}
		
		pgrchunkext->plsdnStartTrailing = plsdn;

		if (i == -1) i = 0;
		
		pgrchunkext->posichnkBeforeTrailing.ichnk = i;
		pgrchunkext->posichnkBeforeTrailing.dcp = plsdn->dcp - dcpTrailingDnode;
		}
	

	return lserrNone;
}

/* G E T  T R A I L I N G  I N F O  F O R  T E X T  G R O U P  C H U N K */
/*----------------------------------------------------------------------------
    %%Function: GetTrailingInfoForTextGroupChunk
    %%Contact: igorzv

Parameters:
	plsdnLastDnode		-	(IN) dnode where to start calculation of trailing area
	dcpLastDnode		-	(IN) dcp in this dnode
	iobjText			-	(IN) iobj of text
	pdurTrailing		-	(OUT) dur of trailing area in  group chunk
	pdcpTrailing		-	(OUT) dcp of trailing area in chunk
	pplsdnStartTrailing -	(OUT) dnode where trailing area starts
	pdcpStartTrailing-	(OUT) with pcDnodesTrailing defines last character in text before
								  trailing area
	pcDnodesTrailing	-	(OUT) number of text dnodes participates in trailing area
	pplsdnStartTrailingObject -(OUT) dnode on the upper level where trailing are starts
	pdcpStartTrailingObject	-(OUT) dcp in such dnode 
	pfClosingBorderStartsTrailing - (OUT) closing border located just before trailing area
----------------------------------------------------------------------------*/
	
LSERR GetTrailingInfoForTextGroupChunk
				(PLSDNODE plsdnLast, LSDCP dcpLastDnode, DWORD iobjText,
				 long* pdurTrailing, LSDCP* pdcpTrailing,
				 PLSDNODE* pplsdnStartTrailing, LSDCP* pdcpStartTrailing,
				 int* pcDnodesTrailing, PLSDNODE* pplsdnStartTrailingObject,
				 LSDCP* pdcpStartTrailingObject, BOOL* pfClosingBorderStartsTrailing)
	{
	PLSDNODE plsdn;
	long durTrailingDnode;
	LSDCP dcpTrailingDnode;
	BOOL fSuccessful;
	LSDCP dcpDnode;
	GROUPCHUNKITERATOR groupchunkiterator;
	LSCP cpLim;
	LSCP cpLimTrail;
	LSSUBL* plssubl;
	long durPrevClosingBorder = 0;

	*pdurTrailing = 0;
	*pdcpTrailing = 0;
	*pplsdnStartTrailing = plsdnLast;
	*pdcpStartTrailing = dcpLastDnode;
	*pcDnodesTrailing = 0;
	if (plsdnLast->dcp == dcpLastDnode)
		cpLim = plsdnLast->cpLimOriginal;
	else
		cpLim = plsdnLast->cpFirst + dcpLastDnode;
	
	CreateGroupChunkIterator(&groupchunkiterator, 
					CollectSublinesForTrailingArea, plsdnLast, 
					cpLim, fFalse);	

	plsdn = GetNextDnodeInGroupChunk(&groupchunkiterator, &fSuccessful);
	
	while(fSuccessful)
		{
		*pplsdnStartTrailing = plsdn;
		/* this procedure can be called before SetBreak so we should calculate 
			dcp of last dnode in chunk using cpLim */
		if (plsdn->cpLimOriginal > cpLim)
			dcpDnode = cpLim - plsdn->cpFirst;
		else
			dcpDnode = plsdn->dcp;
		*pdcpStartTrailing = dcpDnode;

		if (FIsDnodeReal(plsdn) && !FIsDnodeSplat(plsdn)) /* not a pen border or splat*/
			{
			if (IdObjFromDnode(plsdn) == iobjText) /* is text */
				{

				GetTrailInfoText(PdobjFromDnode(plsdn), dcpDnode,
					&dcpTrailingDnode, &durTrailingDnode);

				(*pcDnodesTrailing)++;

				if (dcpTrailingDnode == 0)
					{
					break;
					}
				
				*pdurTrailing += durTrailingDnode;
				*pdcpTrailing += dcpTrailingDnode;
				*pdcpStartTrailing -= dcpTrailingDnode;
				*pdurTrailing += durPrevClosingBorder;
				durPrevClosingBorder = 0;

				if (dcpDnode != dcpTrailingDnode)
					break;
				}
			else
				{
				/* object which did not submit subline for trailing */
				break;
				}
			
			}
		else
			{
			/* border or splat */
			if (FIsDnodeCloseBorder(plsdn))
				{
				durPrevClosingBorder = DurFromDnode(plsdn);
				}
			else
				{
				*pdurTrailing += DurFromDnode(plsdn);
				}
			*pdcpTrailing += plsdn->dcp;
			}

		plsdn = GetNextDnodeInGroupChunk(&groupchunkiterator, &fSuccessful);

		}

	*pfClosingBorderStartsTrailing = (durPrevClosingBorder != 0);

	if (*pcDnodesTrailing == 0)
		{
		*pplsdnStartTrailingObject = plsdnLast;
		*pdcpStartTrailingObject = dcpLastDnode;
		}
	else if (SublineFromDnode(*pplsdnStartTrailing) == 
		     SublineFromDnode(plsdnLast))
		{
		*pplsdnStartTrailingObject = *pplsdnStartTrailing;
		*pdcpStartTrailingObject = *pdcpStartTrailing;
		}
	/* the last dnode we've checked was on the lower level */
	else if (fSuccessful) /* and we actually stopped on it */
		{
		if ((*pplsdnStartTrailing)->dcp == *pdcpStartTrailing)
			cpLimTrail = (*pplsdnStartTrailing)->cpLimOriginal;
		else
			cpLimTrail = (*pplsdnStartTrailing)->cpFirst + *pdcpStartTrailing;

		plsdn = *pplsdnStartTrailing;
		plssubl = SublineFromDnode(plsdn);
		while (SublineFromDnode(plsdnLast) != plssubl)
			{
			plsdn = plssubl->plsdnUpTemp;
			Assert(FIsLSDNODE(plsdn));
			plssubl = SublineFromDnode(plsdn);
			}
		*pplsdnStartTrailingObject = plsdn;
		if (plsdn->cpLimOriginal > cpLimTrail)
			*pdcpStartTrailingObject = cpLimTrail - plsdn->cpFirst;
		else
			*pdcpStartTrailingObject = plsdn->dcp;
		}
	else
		{
		/* we went through all group chunk and the last dnode under investigation was on lower level */
		/* plsdn is dnode before group chunk */
		if (plsdn == NULL) /* there is nothing before group chunk */
			{
			*pplsdnStartTrailingObject = (SublineFromDnode(plsdnLast))->plsdnFirst;
			}
		else
			{
			*pplsdnStartTrailingObject = plsdn->plsdnNext;
			}
		Assert(FIsLSDNODE(*pplsdnStartTrailingObject));

		*pdcpStartTrailingObject = 0;
		}

	DestroyGroupChunkIterator(&groupchunkiterator);

	return lserrNone;
	}


/* A L L O C  C H U N K  A R R A Y S */
/*----------------------------------------------------------------------------
    %%Function: AllocChunkArrays
    %%Contact: igorzv

Parameters:
	plschunkcontext				-	(IN) chunk context
	plscbk						-	(IN) callbacks
	pols						-   (IN) pols for callbacks
	plsiobjcontext				-	(IN) pointer to a table of methods
----------------------------------------------------------------------------*/
LSERR AllocChunkArrays(PLSCHUNKCONTEXT plschunkcontext, LSCBK* plscbk, POLS pols,
					   PLSIOBJCONTEXT plsiobjcontext)
	{

	plschunkcontext->pplsdnChunk = plscbk->pfnNewPtr(pols, 
											sizeof(PLSDNODE)*limAllDNodes);
	plschunkcontext->pcont = plscbk->pfnNewPtr(pols, 
											sizeof(DWORD)*limAllDNodes);
	plschunkcontext->locchnkCurrent.plschnk = plscbk->pfnNewPtr(pols, 
											sizeof(LSCHNKE)*limAllDNodes);
	plschunkcontext->locchnkCurrent.ppointUvLoc = plscbk->pfnNewPtr(pols, 
											sizeof(POINTUV)*limAllDNodes);
	plschunkcontext->pfNonTextExpandAfter = plscbk->pfnNewPtr(pols, 
											sizeof(BOOL)*limAllDNodes);
	plschunkcontext->pplsdnNonText = plscbk->pfnNewPtr(pols, 
											sizeof(PLSDNODE)*limAllDNodes);
	plschunkcontext->pdurOpenBorderBefore = plscbk->pfnNewPtr(pols, 
											sizeof(LONG)*limAllDNodes);
	plschunkcontext->pdurCloseBorderAfter = plscbk->pfnNewPtr(pols, 
											sizeof(LONG)*limAllDNodes);

	plschunkcontext->cchnkMax = limAllDNodes;
	plschunkcontext->cNonTextMax = limAllDNodes;
	plschunkcontext->plscbk = plscbk;
	plschunkcontext->pols = pols;
	plschunkcontext->plsiobjcontext = plsiobjcontext;

	if (plschunkcontext->pplsdnChunk == NULL || plschunkcontext->pcont == NULL
		|| plschunkcontext->locchnkCurrent.plschnk == NULL
		|| plschunkcontext->locchnkCurrent.ppointUvLoc == NULL
		|| plschunkcontext->pfNonTextExpandAfter == NULL 
		|| plschunkcontext->pplsdnNonText == NULL
		||plschunkcontext->pdurOpenBorderBefore == NULL
		||plschunkcontext->pdurCloseBorderAfter == NULL
	   )
		{
		return lserrOutOfMemory;
		}
	else
		{
		return lserrNone;
		}

	}
/* G E T  U R  P E N  A T  B E G I N I N G  O F  L A S T  C H U N K */
/*----------------------------------------------------------------------------
    %%Function: GetUrPenAtBeginingOfLastChunk
    %%Contact: igorzv

Parameters:
	plschunkcontext				-	(IN) chunk context
	plsdnFirst					-	(IN) First dnode in a chunk (used for checks)
	plsdnLast					-	(IN) last dnode in subline
	point						-	(IN) point after last dnode
	purPen						-	(OUT) ur before chunk
----------------------------------------------------------------------------*/

LSERR GetUrPenAtBeginingOfLastChunk(PLSCHUNKCONTEXT plschunkcontext,PLSDNODE plsdnFirst,
									PLSDNODE plsdnLast,	POINTUV* ppoint,
									long* purPen)		
	{
	/* chunk must be already collected and has plsdnFirst as the first element */
	Assert(plschunkcontext->locchnkCurrent.clschnk != 0);
	Assert(!plschunkcontext->FGroupChunk);
	Assert(plschunkcontext->pplsdnChunk[0]== plsdnFirst);
	
	if (plschunkcontext->locchnkCurrent.clschnk == 0 ||
		plschunkcontext->FGroupChunk ||
		plschunkcontext->pplsdnChunk[0]!= plsdnFirst)
		return lserrInvalidParameter;

	
	/* calculate point before the last dnode */
	ppoint->u -= DurFromDnode(plsdnLast);
	ppoint->v -= DvrFromDnode(plsdnLast);

	/* go back until first dnode in chunk */
	while(plsdnLast != plsdnFirst)
		{
		plsdnLast = plsdnLast->plsdnPrev;
		Assert(FIsLSDNODE(plsdnLast));
		ppoint->u -= DurFromDnode(plsdnLast);
		ppoint->v -= DvrFromDnode(plsdnLast);
		}

	
	/* locate chunk  */
	if (!plschunkcontext->FLocationValid)
		{
		LocateChunk(plschunkcontext, plsdnFirst, LstflowFromDnode(plsdnFirst), ppoint);
		}
	
	*purPen = plschunkcontext->locchnkCurrent.lsfgi.urPen;
	return lserrNone;
	}

/* F I N D  P O I N T  O F F S E T   */
/*----------------------------------------------------------------------------
    %%Function: FindPointOffset
    %%Contact: igorzv

Parameters:
	plsdnFirst			-	(IN) dnode from the boundaries of which to calculate offset  
	lsdev				-	(IN) presentation or reference device 
	lstflowBase				-	(IN) text flow to use for calculation 
	Purpose				-	(IN) what sublines to take from a complex object 
	plsdnContainsPoint	-	(IN) dnode contains point 
	duInDnode,			-	(IN) offset in the dnode 
	pduOffset			-	(OUT) offset from the starting point 

----------------------------------------------------------------------------*/
void FindPointOffset(PLSDNODE plsdnFirst,	enum lsdevice lsdev,
			  LSTFLOW lstflowBase, COLLECTSUBLINES Purpose,	
			  PLSDNODE plsdnContainsPoint, long duInDnode,	
			  long* pduOffset)
	{
	PLSDNODE plsdnCurrent;
	PLSSUBL plssubl;
	LSTFLOW lstflow;
	LSCP cpFirstDnode;
	PLSSUBL* rgpsubl;
	long cSublines;
	long i;
	long duOffsetSubline;

	plssubl = SublineFromDnode(plsdnFirst);
	lstflow = LstflowFromSubline(plssubl);
	cpFirstDnode = plsdnContainsPoint->cpFirst;
	*pduOffset = 0;

	if (FParallelTflows(lstflow, lstflowBase))
		{
		for(plsdnCurrent = plsdnFirst; 
			plsdnCurrent->cpLimOriginal <= cpFirstDnode && (plsdnCurrent != plsdnContainsPoint);
			/* second check is to catch situation when plsdnContainsPoint has dcp = 0 */
			plsdnCurrent = plsdnCurrent->plsdnNext)
			{
			Assert(FIsLSDNODE(plsdnCurrent));
			if (lsdev == lsdevReference)
				{
				*pduOffset += DurFromDnode(plsdnCurrent);
				}
			else
				{
				Assert(lsdev == lsdevPres);
				*pduOffset += DupFromDnode(plsdnCurrent);
				}
			}

		Assert(FIsLSDNODE(plsdnCurrent));
		
		if (FIsDnodeReal(plsdnCurrent))
			rgpsubl = GetSubmittedSublines(plsdnCurrent, Purpose);
		else
			rgpsubl = NULL;

		if (rgpsubl == NULL)
			{
			Assert(plsdnCurrent == plsdnContainsPoint);
			*pduOffset += duInDnode;
			}
		else
			{
			cSublines = GetNumberSubmittedSublines(plsdnCurrent);
			
			/* if everything is correct we should always find subline in this loop,
			check (i < cSublines) is just to avoid infinite loop and catch situation in a Assert */
			for (i = 0; (i < cSublines) && !FDnodeInsideSubline(rgpsubl[i], plsdnContainsPoint); i++)
				{
				plssubl = rgpsubl[i];
				Assert(FIsLSSUBL(plssubl));
				for (plsdnCurrent = plssubl->plsdnFirst; 
					FDnodeBeforeCpLim(plsdnCurrent, plssubl->cpLim); 
					plsdnCurrent = plsdnCurrent->plsdnNext)
					{
					Assert(FIsLSDNODE(plsdnCurrent));
					if (lsdev == lsdevReference)
						{
						*pduOffset += DurFromDnode(plsdnCurrent);
						}
					else
						{
						Assert(lsdev == lsdevPres);
						*pduOffset += DupFromDnode(plsdnCurrent);
						}
					}
				}
				     

			
			Assert(i != cSublines);
			plssubl = rgpsubl[i];
			Assert(FIsLSSUBL(plssubl));

			FindPointOffset(plssubl->plsdnFirst, lsdev, lstflowBase,
							Purpose, plsdnContainsPoint, duInDnode,	
							&duOffsetSubline);

			*pduOffset += duOffsetSubline;

			}
		}
	else
		{
		for(plsdnCurrent = plssubl->plsdnLast; 
			plsdnCurrent->cpFirst > cpFirstDnode && (plsdnCurrent != plsdnContainsPoint);
			/* second check is to catch situation when plsdnContainsPoint has dcp = 0 */
			plsdnCurrent = plsdnCurrent->plsdnPrev)
			{
			Assert(FIsLSDNODE(plsdnCurrent));
			if (lsdev == lsdevReference)
				{
				*pduOffset += DurFromDnode(plsdnCurrent);
				}
			else
				{
				Assert(lsdev == lsdevPres);
				*pduOffset += DupFromDnode(plsdnCurrent);
				}
			}

		Assert(FIsLSDNODE(plsdnCurrent));

		if (FIsDnodeReal(plsdnCurrent))
			rgpsubl = GetSubmittedSublines(plsdnCurrent, Purpose);
		else
			rgpsubl = NULL;


		if (rgpsubl == NULL)
			{
			Assert(plsdnCurrent == plsdnContainsPoint);
			if (lsdev == lsdevReference)
				{
				*pduOffset += (DurFromDnode(plsdnCurrent) - duInDnode);
				}
			else
				{
				Assert(lsdev == lsdevPres);
				*pduOffset += (DupFromDnode(plsdnCurrent) - duInDnode);
				}
			}
		else
			{
			cSublines = GetNumberSubmittedSublines(plsdnCurrent);
			
			
			/* if everything is correct we should always find subline in this loop,
			check (i >= 0) is just to avoid infinite loop and catch situation in a Assert */
			for (i = cSublines - 1; (i >= 0) && !FDnodeInsideSubline(rgpsubl[i], plsdnContainsPoint); i--)
				{
				plssubl = rgpsubl[i];
				Assert(FIsLSSUBL(plssubl));
				for (plsdnCurrent = plssubl->plsdnFirst; 
					FDnodeBeforeCpLim(plsdnCurrent, plssubl->cpLim); 
					plsdnCurrent = plsdnCurrent->plsdnNext)
					{
					Assert(FIsLSDNODE(plsdnCurrent));
					if (lsdev == lsdevReference)
						{
						*pduOffset += DurFromDnode(plsdnCurrent);
						}
					else
						{
						Assert(lsdev == lsdevPres);
						*pduOffset += DupFromDnode(plsdnCurrent);
						}
					}
				}
			
			Assert(i >= 0);
			plssubl = rgpsubl[i];
			Assert(FIsLSSUBL(plssubl));

			FindPointOffset(plssubl->plsdnFirst, lsdev, lstflowBase,
							Purpose, plsdnContainsPoint, duInDnode,	
							&duOffsetSubline);

			*pduOffset += duOffsetSubline;

			}
		}

	}



/* D I S P O S E  C H U N K  A R R A Y S */
/*----------------------------------------------------------------------------
    %%Function: AllocChunkArrays
    %%Contact: igorzv

Parameters:
	plschunkcontext				-	(IN) chunk context
----------------------------------------------------------------------------*/
void DisposeChunkArrays(PLSCHUNKCONTEXT plschunkcontext)
	{
	if (plschunkcontext->pplsdnChunk != NULL)
		plschunkcontext->plscbk->pfnDisposePtr(plschunkcontext->pols,
										  plschunkcontext->pplsdnChunk);
	if (plschunkcontext->pcont != NULL)
		plschunkcontext->plscbk->pfnDisposePtr(plschunkcontext->pols,
										  plschunkcontext->pcont);
	if (plschunkcontext->locchnkCurrent.plschnk != NULL)
		plschunkcontext->plscbk->pfnDisposePtr(plschunkcontext->pols, 
										  plschunkcontext->locchnkCurrent.plschnk);
	if (plschunkcontext->locchnkCurrent.ppointUvLoc != NULL)
		plschunkcontext->plscbk->pfnDisposePtr(plschunkcontext->pols, 
										  plschunkcontext->locchnkCurrent.ppointUvLoc);
	if (plschunkcontext->pplsdnNonText != NULL)
		plschunkcontext->plscbk->pfnDisposePtr(plschunkcontext->pols,
										  plschunkcontext->pplsdnNonText);
	if (plschunkcontext->pfNonTextExpandAfter != NULL)
		plschunkcontext->plscbk->pfnDisposePtr(plschunkcontext->pols,
										  plschunkcontext->pfNonTextExpandAfter);
	if (plschunkcontext->pdurOpenBorderBefore != NULL)
		plschunkcontext->plscbk->pfnDisposePtr(plschunkcontext->pols,
										  plschunkcontext->pdurOpenBorderBefore);
	if (plschunkcontext->pdurCloseBorderAfter != NULL)
		plschunkcontext->plscbk->pfnDisposePtr(plschunkcontext->pols,
										  plschunkcontext->pdurCloseBorderAfter);

	}

/* S E T  C H U N K  A R R A Y S  S I Z E   */
/*----------------------------------------------------------------------------
    %%Function: SetChunkArraysSize
    %%Contact: igorzv

Parameters:
	plschunkcontext				-	(IN) chunk context
	cchnkMax			-	(IN) new max size for array
----------------------------------------------------------------------------*/

static LSERR SetChunkArraysSize(PLSCHUNKCONTEXT plschunkcontext, DWORD cchnkMax)
{

/* arrays pfNonTextExpandAfter and pplsdnNonText should not be touched here:
   they are independable */

	plschunkcontext->plscbk->pfnDisposePtr(plschunkcontext->pols,
										  plschunkcontext->pplsdnChunk);
	plschunkcontext->plscbk->pfnDisposePtr(plschunkcontext->pols,
										  plschunkcontext->pcont);
	plschunkcontext->plscbk->pfnDisposePtr(plschunkcontext->pols, 
										  plschunkcontext->locchnkCurrent.plschnk);
	plschunkcontext->plscbk->pfnDisposePtr(plschunkcontext->pols, 
										  plschunkcontext->locchnkCurrent.ppointUvLoc);
	plschunkcontext->plscbk->pfnDisposePtr(plschunkcontext->pols,
										  plschunkcontext->pdurOpenBorderBefore);
	plschunkcontext->plscbk->pfnDisposePtr(plschunkcontext->pols,
										  plschunkcontext->pdurCloseBorderAfter);


	/* create arrays for chunks  */
	plschunkcontext->pplsdnChunk = plschunkcontext->plscbk->pfnNewPtr(plschunkcontext->pols, 
											sizeof(PLSDNODE)*cchnkMax);
	plschunkcontext->pcont = plschunkcontext->plscbk->pfnNewPtr(plschunkcontext->pols, 
											sizeof(DWORD)*cchnkMax);
	plschunkcontext->locchnkCurrent.plschnk = plschunkcontext->plscbk->pfnNewPtr(plschunkcontext->pols, 
											sizeof(LSCHNKE)*cchnkMax);
	plschunkcontext->locchnkCurrent.ppointUvLoc = plschunkcontext->plscbk->pfnNewPtr(plschunkcontext->pols, 
											sizeof(POINTUV)*cchnkMax);
	plschunkcontext->pdurOpenBorderBefore = plschunkcontext->plscbk->pfnNewPtr(plschunkcontext->pols, 
											sizeof(LONG)*cchnkMax);
	plschunkcontext->pdurCloseBorderAfter = plschunkcontext->plscbk->pfnNewPtr(plschunkcontext->pols, 
											sizeof(LONG)*cchnkMax);


	if (plschunkcontext->pplsdnChunk == NULL || plschunkcontext->pcont == NULL
		|| plschunkcontext->locchnkCurrent.plschnk == NULL
		|| plschunkcontext->locchnkCurrent.ppointUvLoc == NULL
		|| plschunkcontext->pdurOpenBorderBefore == NULL
		|| plschunkcontext->pdurCloseBorderAfter == NULL
	   )
		return lserrOutOfMemory;

	plschunkcontext->cchnkMax = cchnkMax;

	return lserrNone;

}


/* I N C R E A S E  C H U N K  A R R A Y S  S I Z E   */
/*----------------------------------------------------------------------------
    %%Function: IncreaseChunkArrays
    %%Contact: igorzv

Parameters:
	plschunkcontext				-	(IN) chunk context

The difference from previous function is that we don't now final size 
and going to increase size step by step
----------------------------------------------------------------------------*/

static LSERR IncreaseChunkArrays(PLSCHUNKCONTEXT plschunkcontext)
{
/* arrays pfNonTextExpandAfter and pplsdnNonText should not be touched here:
   they are independable */

	DWORD cchnkMax;

	cchnkMax = plschunkcontext->cchnkMax + limAllDNodes;


	/* create arrays for chunks  */
	plschunkcontext->pplsdnChunk = plschunkcontext->plscbk->pfnReallocPtr(plschunkcontext->pols, 
											plschunkcontext->pplsdnChunk,
											sizeof(PLSDNODE)*cchnkMax);
	plschunkcontext->pcont = plschunkcontext->plscbk->pfnReallocPtr(plschunkcontext->pols,
											plschunkcontext->pcont, 
											sizeof(DWORD)*cchnkMax);
	plschunkcontext->locchnkCurrent.plschnk = plschunkcontext->plscbk->pfnReallocPtr(plschunkcontext->pols, 
											plschunkcontext->locchnkCurrent.plschnk,
											sizeof(LSCHNKE)*cchnkMax);
	plschunkcontext->locchnkCurrent.ppointUvLoc = plschunkcontext->plscbk->pfnReallocPtr(plschunkcontext->pols, 
											plschunkcontext->locchnkCurrent.ppointUvLoc,
											sizeof(POINTUV)*cchnkMax);
	plschunkcontext->pdurOpenBorderBefore = plschunkcontext->plscbk->pfnReallocPtr(plschunkcontext->pols, 
											plschunkcontext->pdurOpenBorderBefore,
											sizeof(LONG)*cchnkMax);
	plschunkcontext->pdurCloseBorderAfter = plschunkcontext->plscbk->pfnReallocPtr(plschunkcontext->pols, 
											plschunkcontext->pdurCloseBorderAfter,
											sizeof(LONG)*cchnkMax);

	if (plschunkcontext->pplsdnChunk == NULL || plschunkcontext->pcont == NULL
		|| plschunkcontext->locchnkCurrent.plschnk == NULL
		|| plschunkcontext->locchnkCurrent.ppointUvLoc == NULL
		|| plschunkcontext->pdurOpenBorderBefore == NULL
		|| plschunkcontext->pdurCloseBorderAfter == NULL
	   )
		return lserrOutOfMemory;

	plschunkcontext->cchnkMax = cchnkMax;

	return lserrNone;

}

/* D U P L I C A T E  C H U N K  C O N T E X T  */
/*----------------------------------------------------------------------------
    %%Function: DuplicateChunkContext
    %%Contact: igorzv

Parameters:
	plschunkcontextOld				-	(IN) chunk context to duplicate
	pplschunkcontextNew				-	(OUT) new chunk context 

----------------------------------------------------------------------------*/

LSERR DuplicateChunkContext(PLSCHUNKCONTEXT plschunkcontextOld, 
							PLSCHUNKCONTEXT* pplschunkcontextNew)
	{
	*pplschunkcontextNew = plschunkcontextOld->plscbk->pfnNewPtr(plschunkcontextOld->pols,
											sizeof(LSCHUNKCONTEXT));
	if (*pplschunkcontextNew == NULL)
		return lserrOutOfMemory;

	memcpy(*pplschunkcontextNew, plschunkcontextOld, sizeof(LSCHUNKCONTEXT));

	/* but we need to use new arrays */
	/* create arrays for chunks  */
	(*pplschunkcontextNew)->pplsdnChunk = (*pplschunkcontextNew)->plscbk->pfnNewPtr((*pplschunkcontextNew)->pols, 
											sizeof(PLSDNODE) * ((*pplschunkcontextNew)->cchnkMax));
	(*pplschunkcontextNew)->pcont = (*pplschunkcontextNew)->plscbk->pfnNewPtr((*pplschunkcontextNew)->pols, 
											sizeof(DWORD) * ((*pplschunkcontextNew)->cchnkMax));
	(*pplschunkcontextNew)->locchnkCurrent.plschnk =
					(*pplschunkcontextNew)->plscbk->pfnNewPtr((*pplschunkcontextNew)->pols, 
											sizeof(LSCHNKE) * ((*pplschunkcontextNew)->cchnkMax));
	(*pplschunkcontextNew)->locchnkCurrent.ppointUvLoc = 
					(*pplschunkcontextNew)->plscbk->pfnNewPtr((*pplschunkcontextNew)->pols, 
											sizeof(POINTUV) * ((*pplschunkcontextNew)->cchnkMax));
	(*pplschunkcontextNew)->pfNonTextExpandAfter = 
					(*pplschunkcontextNew)->plscbk->pfnNewPtr((*pplschunkcontextNew)->pols, 
											sizeof(BOOL) * ((*pplschunkcontextNew)->cNonTextMax));
	(*pplschunkcontextNew)->pplsdnNonText = 
					(*pplschunkcontextNew)->plscbk->pfnNewPtr((*pplschunkcontextNew)->pols, 
											sizeof(PLSDNODE) * ((*pplschunkcontextNew)->cNonTextMax));
	(*pplschunkcontextNew)->pdurOpenBorderBefore = 
					(*pplschunkcontextNew)->plscbk->pfnNewPtr((*pplschunkcontextNew)->pols, 
											sizeof(LONG) * ((*pplschunkcontextNew)->cchnkMax));
	(*pplschunkcontextNew)->pdurCloseBorderAfter = 
					(*pplschunkcontextNew)->plscbk->pfnNewPtr((*pplschunkcontextNew)->pols, 
											sizeof(LONG) * ((*pplschunkcontextNew)->cchnkMax));


	if ((*pplschunkcontextNew)->pplsdnChunk == NULL || (*pplschunkcontextNew)->pcont == NULL
		|| (*pplschunkcontextNew)->locchnkCurrent.plschnk == NULL
		|| (*pplschunkcontextNew)->locchnkCurrent.ppointUvLoc == NULL
		|| (*pplschunkcontextNew)->pfNonTextExpandAfter == NULL
		|| (*pplschunkcontextNew)->pplsdnNonText == NULL
		|| (*pplschunkcontextNew)->pdurOpenBorderBefore == NULL
		|| (*pplschunkcontextNew)->pdurCloseBorderAfter == NULL
	   )
		return lserrOutOfMemory;

	/* copy valid parts of the arrays */
	memcpy ((*pplschunkcontextNew)->pplsdnChunk, plschunkcontextOld->pplsdnChunk,
						plschunkcontextOld->locchnkCurrent.clschnk * sizeof(PLSDNODE));
	memcpy ((*pplschunkcontextNew)->pcont, plschunkcontextOld->pcont,
						plschunkcontextOld->locchnkCurrent.clschnk * sizeof(DWORD));
	memcpy ((*pplschunkcontextNew)->locchnkCurrent.plschnk, plschunkcontextOld->locchnkCurrent.plschnk,
						plschunkcontextOld->locchnkCurrent.clschnk * sizeof(LSCHNKE));
	memcpy ((*pplschunkcontextNew)->locchnkCurrent.ppointUvLoc, plschunkcontextOld->locchnkCurrent.ppointUvLoc,
						plschunkcontextOld->locchnkCurrent.clschnk * sizeof(POINTUV));
	memcpy ((*pplschunkcontextNew)->pfNonTextExpandAfter, plschunkcontextOld->pfNonTextExpandAfter,
						plschunkcontextOld->cNonTextMax * sizeof(BOOL));
	memcpy ((*pplschunkcontextNew)->pplsdnNonText, plschunkcontextOld->pplsdnNonText,
						plschunkcontextOld->cNonTextMax * sizeof(PLSDNODE));
	memcpy ((*pplschunkcontextNew)->pdurOpenBorderBefore, plschunkcontextOld->pdurOpenBorderBefore,
						plschunkcontextOld->locchnkCurrent.clschnk * sizeof(LONG));
	memcpy ((*pplschunkcontextNew)->pdurCloseBorderAfter, plschunkcontextOld->pdurCloseBorderAfter,
						plschunkcontextOld->locchnkCurrent.clschnk * sizeof(LONG));


	return lserrNone;

	}

/* D E S T R O Y  C H U N K  C O N T E X T  */
/*----------------------------------------------------------------------------
    %%Function: DestroyChunkContext
    %%Contact: igorzv

Parameters:
	plschunkcontext					-	(IN) chunk context to destroy

----------------------------------------------------------------------------*/

void DestroyChunkContext(PLSCHUNKCONTEXT plschunkcontext)
	{
	POLS pols = plschunkcontext->pols;
	LSCBK* plscbk = plschunkcontext->plscbk;
	DisposeChunkArrays(plschunkcontext);
	DebugMemset(plschunkcontext, 0xE9, sizeof(LSCHUNKCONTEXT));
	plscbk->pfnDisposePtr(pols, plschunkcontext);

	}


/* I N C R E A S E  G R O U P  C H U N K  N O N  T E X T  A R R A Y S  S I Z E   */
/*----------------------------------------------------------------------------
    %%Function: SetGroupChunkNonTextArraysSize
    %%Contact: igorzv

Parameters:
	plschunkcontext				-	(IN) chunk context

The difference from previous function is that we don't now final size 
and going to increase size step by step
----------------------------------------------------------------------------*/

static LSERR IncreaseGroupChunkNonTextArrays(PLSCHUNKCONTEXT plschunkcontext)
{

	DWORD cNonTextMax;

	cNonTextMax = plschunkcontext->cNonTextMax + limAllDNodes;


	/* create arrays for chunks  */
	plschunkcontext->pplsdnNonText = plschunkcontext->plscbk->pfnReallocPtr(plschunkcontext->pols, 
											plschunkcontext->pplsdnNonText,
											sizeof(PLSDNODE)*cNonTextMax);
	plschunkcontext->pfNonTextExpandAfter = plschunkcontext->plscbk->pfnReallocPtr(plschunkcontext->pols,
											plschunkcontext->pfNonTextExpandAfter, 
											sizeof(BOOL)*cNonTextMax);

	if (plschunkcontext->pplsdnNonText == NULL || plschunkcontext->pfNonTextExpandAfter == NULL)
		return lserrOutOfMemory;

	plschunkcontext->cNonTextMax = cNonTextMax;

	return lserrNone;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\disptext.c ===
/*
 *	Contains Display and CalcPres methods of display object
 */ 

#include "disptext.h"
#include "dispmisc.h"
#include "lsdevice.h"
#include "lstfset.h"
#include "lstxtmap.h"
#include "dispi.h"
#include "txtobj.h"
#include "txtln.h"
#include "txtils.h"
#include "lschp.h"

#define TABBUFSIZE 32

static LSERR DisplayGlyphs(PTXTOBJ ptxtobj, PCDISPIN pdispin);
static LSERR DisplayTabLeader(PCDISPIN pdispin, PILSOBJ pilsobj, WCHAR wchtl);

//    %%Function:	DisplayText
//    %%Contact:	victork
//
LSERR WINAPI DisplayText(PDOBJ pdo, PCDISPIN pdispin)
{
   	LSERR 	lserr;
	PTXTOBJ ptxtobj;
	WCHAR 	wchSave;
	WCHAR* 	pwch;
	int 	iwch;
	int 	cwch;
	PILSOBJ pilsobj;
	POINT	ptOrg, ptExtTextOut;
	POINTUV	ptLeftCut;

	long 	dupStart;
	long 	dupPenStart;
	long* 	pdup;
	long* 	pdupPen;
	long* 	rgdupLeftCut;
	int 	i;
	void* 	(WINAPI* pfnNewPtr)(POLS, DWORD);
	void  	(WINAPI* pfnDisposePtr)(POLS, void*);


	ptxtobj = (PTXTOBJ) pdo;
	pilsobj = ptxtobj->plnobj->pilsobj;

	Assert(ptxtobj->txtkind == txtkindRegular 			||
			ptxtobj->txtkind == txtkindHardHyphen  		||
			ptxtobj->txtkind == txtkindTab 				||
			ptxtobj->txtkind == txtkindNonReqHyphen 	||
			ptxtobj->txtkind == txtkindYsrChar			|| 
			ptxtobj->txtkind == txtkindNonBreakSpace 	||	
			ptxtobj->txtkind == txtkindNonBreakHyphen	||
			ptxtobj->txtkind == txtkindOptNonBreak 		||
			ptxtobj->txtkind == txtkindSpecSpace		|| 
			ptxtobj->txtkind == txtkindOptBreak 		||
			ptxtobj->txtkind == txtkindEOL );

	if (ptxtobj->txtkind == txtkindTab) 				
		{
		Assert(ptxtobj->dupBefore == 0);

		if (pdispin->dup <= 0)								/* do nothing for zero-length tab */
			{
			return lserrNone;
			}

		// Draw tab only if it is visi case

		if (ptxtobj->txtf&txtfVisi)
			{
			lserr = (*pilsobj->plscbk->pfnDrawTextRun)(pilsobj->pols, pdispin->plsrun,
											FALSE, FALSE,					/* Tab leader will take care of UL */
											&(pdispin->ptPen), &(pilsobj->wchVisiTab), 
											(const int*) &(pdispin->dup), 1, 
											pdispin->lstflow, (const) pdispin->kDispMode, 
											&(pdispin->ptPen), &(pdispin->heightsPres), pdispin->dup, 
											pdispin->dupLimUnderline, pdispin->prcClip);
			if (lserr != lserrNone) return lserr;
			}

		if (ptxtobj->u.tab.wchTabLeader == pilsobj->wchSpace)
			{
			
			// it is OK to draw the space in one take
			
			lserr = (*pilsobj->plscbk->pfnDrawTextRun)(pilsobj->pols, pdispin->plsrun,
											pdispin->fDrawStrikethrough, pdispin->fDrawUnderline,
											&(pdispin->ptPen), &(pilsobj->wchSpace), 
											(const int*) &(pdispin->dup), 1, 
											pdispin->lstflow, (const) pdispin->kDispMode, 
											&(pdispin->ptPen), &(pdispin->heightsPres), pdispin->dup, 
											pdispin->dupLimUnderline, pdispin->prcClip);
			}
		else
			{
			
			// we should apply tab leader alingment logic
			
			lserr = DisplayTabLeader(pdispin, pilsobj, ptxtobj->u.tab.wchTabLeader);
			}

		return lserr;
		}

	if (ptxtobj->txtf & txtfGlyphBased)
		{
		return DisplayGlyphs(ptxtobj, pdispin);
		}
		
	iwch = ptxtobj->iwchFirst;
	pwch = ptxtobj->plnobj->pwch + iwch;
	cwch = ptxtobj->iwchLim - iwch;
	
	if (cwch == 0)									// nothing to display
		{
		return lserrNone;
		}

	Assert(ptxtobj->plnobj->pdupPen == ptxtobj->plnobj->pdup || ptxtobj->plnobj->pdupPen == ptxtobj->plnobj->pdupPenAlloc);

	pdupPen = ptxtobj->plnobj->pdupPen + iwch;

	ptOrg = pdispin->ptPen;

	if (ptxtobj->dupBefore == 0)
		{
		ptExtTextOut = ptOrg;
		}
	else
		{
		ptLeftCut.u = -ptxtobj->dupBefore;
		ptLeftCut.v = 0;
		LsPointXYFromPointUV(&(ptOrg), pdispin->lstflow, &ptLeftCut, &ptExtTextOut);
		}

	// Have to deal with special spaces before DrawTextRun
	
	if (ptxtobj->txtkind == txtkindSpecSpace && !(ptxtobj->txtf&txtfVisi))
		{
		wchSave = *pwch;								// remember actual code
		
		for (i = 0; i < cwch; i++)
			{
			pwch[i] = pilsobj->wchSpace;				// replace special spaces with the normal space
			}
			
		lserr = (*pilsobj->plscbk->pfnDrawTextRun)(pilsobj->pols, pdispin->plsrun, 
										pdispin->fDrawStrikethrough, pdispin->fDrawUnderline,
	                               		&ptExtTextOut, pwch, (const int*) pdupPen, cwch,
										pdispin->lstflow, pdispin->kDispMode, 
										&ptOrg, &(pdispin->heightsPres), 
										pdispin->dup, pdispin->dupLimUnderline, pdispin->prcClip);
		if (lserr != lserrNone) return lserr;
		
		for (i = 0; i < cwch; i++)
			{
			pwch[i] = wchSave;							// restore special spaces
			}
		}
	else
		{
		lserr = (*pilsobj->plscbk->pfnDrawTextRun)(pilsobj->pols, pdispin->plsrun, 
										pdispin->fDrawStrikethrough, pdispin->fDrawUnderline,
	                               		&ptExtTextOut, pwch, (const int*) pdupPen, cwch,
										pdispin->lstflow, pdispin->kDispMode, 
										&ptOrg, &(pdispin->heightsPres), 
										pdispin->dup, pdispin->dupLimUnderline, pdispin->prcClip);
		if (lserr != lserrNone) return lserr;
		}


	if (pdispin->plschp->EffectsFlags)
		{
		pfnNewPtr = pilsobj->plscbk->pfnNewPtr;
		pfnDisposePtr = pilsobj->plscbk->pfnDisposePtr;

		/* create array for LeftCut info */
		rgdupLeftCut = pfnNewPtr(pilsobj->pols, cwch * sizeof(*rgdupLeftCut));
		if (rgdupLeftCut == NULL)
			return lserrOutOfMemory;

		/* fill LeftCut info array */
		pdup = ptxtobj->plnobj->pdup + iwch;
		dupStart = pdup[0];								/* the beginning of char */
		dupPenStart = pdupPen[0];						/* starting position for drawing char */

		for (i = 1; i < cwch; i++)
			{
			rgdupLeftCut[i] = dupStart - dupPenStart;
			dupStart  += pdup[i];
			dupPenStart  += pdupPen[i];
			}

		rgdupLeftCut[0] = ptxtobj->dupBefore;

		lserr = (*pilsobj->plscbk->pfnDrawEffects)(pilsobj->pols, pdispin->plsrun, pdispin->plschp->EffectsFlags,
	                               		&(ptOrg), pwch, (const int*) pdup, (const int*) rgdupLeftCut, 
										ptxtobj->iwchLim - iwch,
										pdispin->lstflow, pdispin->kDispMode, &(pdispin->heightsPres), 
										pdispin->dup, pdispin->dupLimUnderline, pdispin->prcClip);

		/* dispose of the array for LeftCut info */
		pfnDisposePtr(pilsobj->pols, rgdupLeftCut);
		}

	return lserr;
}




//    %%Function:	DisplayTabLeader
//    %%Contact:	victork
//
static LSERR DisplayTabLeader(PCDISPIN pdispin, PILSOBJ pilsobj, WCHAR wchtl)
{
	LSTFLOW lstflow = pdispin->lstflow;
	LONG	dupSum, dupCh, dupAdj, z, zOnGrid;
	BOOL 	fGrow;
	WCHAR	rgwch[TABBUFSIZE];
	LONG	rgdup[TABBUFSIZE];
	LONG	dupbuf;
	int		i = 0, cwch, cwchout;
	LSERR	lserr;
	POINT	pt;
	POINTUV	ptAdj = {0,0};

	lserr = (*pilsobj->plscbk->pfnGetRunCharWidths)(pilsobj->pols, pdispin->plsrun,
						lsdevPres, (LPCWSTR) &wchtl, 1,
						pdispin->dup, lstflow, (int*) &dupCh, &dupSum, (LONG*) &i);
						
	if (lserr != lserrNone) return lserr;
	
	if (i == 0 || dupCh <= 0) dupCh = 1;	

	for (i = 0; i < TABBUFSIZE; ++i)
		{
		rgwch[i] = wchtl;
		rgdup[i] = dupCh;
		}

	/* advance to next multiple of dupCh 
	
		dupAdj is the distance between "pt.z" and the next integral multiple of dupch.
		I.e. dupAdj = N * dupCh - "pt.x" where N is the smallest integer such that
		N * dupCh is not less than "pt.x" in Latin case. 
		The starting pen position will be "rounded"	to this "dupCh stop" by the assignment 
		"pt.z += dupAdj" in the code below.
		
		Complications are:	
		
		depending on lstflow "z" can be either x or y;
		depending on lstflow next can be bigger (Grow) or smaller;
		Simple formula dupAdj = (ptPen.x + dupCh - 1) / dupCh * dupCh - ptPen.x	does not
			necessarily work if ptPen.x is negative;
	*/

	if (lstflow & fUVertical)
		{
		z = pdispin->ptPen.y;
		}
	else
		{
		z = pdispin->ptPen.x;
		}

	if (lstflow & fUDirection)
		{
		fGrow = fFalse;
		}
	else
		{
		fGrow = fTrue;
		}

	zOnGrid = (z / dupCh) * dupCh;

	// zOnGrid is on grid, but maybe from the wrong side

	if (zOnGrid == z)
		{
		dupAdj = 0;
		}
	else if (zOnGrid > z)
		{
		if (fGrow)
			{
			dupAdj = zOnGrid - z;				// zOnGrid is the point we want
			}
		else
			{
			dupAdj = dupCh - (zOnGrid - z);		// zOnGrid is on the wrong side
			}
		}
	else	// zOnGrid < z
		{
		if (!fGrow)
			{
			dupAdj = z - zOnGrid;				// zOnGrid is the point we want
			}
		else
			{
			dupAdj = dupCh - (z - zOnGrid);		// zOnGrid is on the wrong side
			}
		}

	cwch = (pdispin->dup - dupAdj) / dupCh;	/* always round down */
	dupbuf = dupCh * TABBUFSIZE;

#ifdef NEVER			//  We've decided to kill rcClip optimization for now.
	while (cwch > 0 && up <= pdispin->rcClip.right && lserr == lserrNone)
#endif /* NEVER */

	while (cwch > 0 && lserr == lserrNone)
		{
		cwchout = cwch < TABBUFSIZE ? cwch : TABBUFSIZE;
		
		ptAdj.u = dupAdj;
		LsPointXYFromPointUV(&(pdispin->ptPen), lstflow, &ptAdj, &(pt));

		lserr =  (*pilsobj->plscbk->pfnDrawTextRun)(pilsobj->pols, pdispin->plsrun, 
									pdispin->fDrawStrikethrough, pdispin->fDrawUnderline,
                               		&pt, rgwch, (const int*) rgdup, cwchout,
									lstflow, pdispin->kDispMode, &pt, &(pdispin->heightsPres), 
									dupCh * cwchout, pdispin->dupLimUnderline, pdispin->prcClip);
		cwch -= cwchout;
		dupAdj += dupbuf;
		}
	return lserr;
}


//    %%Function:	DisplayGlyphs
//    %%Contact:	victork
//
static LSERR DisplayGlyphs(PTXTOBJ ptxtobj, PCDISPIN pdispin)
{
   	LSERR	lserr;
	PLNOBJ	plnobj = ptxtobj->plnobj;
	PILSOBJ	pilsobj = plnobj->pilsobj;

	WCHAR* 	pwch;
	int 	iwch;
	int 	cwch;

	if (plnobj->fDrawInCharCodes)
		{
		// for meta-file output we call pfnDrawTextRun without widths
		
		iwch = ptxtobj->iwchFirst;
		pwch = ptxtobj->plnobj->pwch + iwch;
		cwch = ptxtobj->iwchLim - iwch;
		
		lserr = (*pilsobj->plscbk->pfnDrawTextRun)(pilsobj->pols, pdispin->plsrun, 
										pdispin->fDrawStrikethrough, pdispin->fDrawUnderline,
	                               		&(pdispin->ptPen), pwch, NULL, cwch,
										pdispin->lstflow, pdispin->kDispMode, 
										&(pdispin->ptPen), &(pdispin->heightsPres), 
										pdispin->dup, pdispin->dupLimUnderline, pdispin->prcClip);
		}
	else
		{
		lserr = (*pilsobj->plscbk->pfnDrawGlyphs)(pilsobj->pols, pdispin->plsrun, 
										pdispin->fDrawStrikethrough, pdispin->fDrawUnderline,
										&plnobj->pgind[ptxtobj->igindFirst],
										(const int*)&plnobj->pdupGind[ptxtobj->igindFirst],
										(const int*)&plnobj->pdupBeforeJust[ptxtobj->igindFirst],
										&plnobj->pgoffs[ptxtobj->igindFirst],
										&plnobj->pgprop[ptxtobj->igindFirst],
										&plnobj->pexpt[ptxtobj->igindFirst],
										ptxtobj->igindLim - ptxtobj->igindFirst,
										pdispin->lstflow, pdispin->kDispMode, 
										&(pdispin->ptPen), &(pdispin->heightsPres), 
										pdispin->dup, pdispin->dupLimUnderline, pdispin->prcClip);
		}
									
	return lserr;
	
}


//    %%Function:	CalcPresentationText
//    %%Contact:	victork
//
/*	
 *	CalcPres for text is called only for the dnode between autonumbering dnode and main text.
 *	The dnode should contain one character (space).
 */

LSERR WINAPI CalcPresentationText(PDOBJ pdobj, long dup, LSKJUST lskj, BOOL fLastOnLine)
{

	PTXTOBJ ptxtobj = (PTXTOBJ)pdobj;

	Unreferenced(lskj);
	Unreferenced(fLastOnLine);
	
	Assert(ptxtobj->txtkind == txtkindRegular);
	Assert(ptxtobj->iwchFirst + 1 == ptxtobj->iwchLim);

	(ptxtobj->plnobj->pdup)[ptxtobj->iwchFirst] = dup;

	return lserrNone;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\dispmisc.c ===
#include "dispmisc.h"
#include "lsdnode.h"
#include "lssubl.h"

static long	AddSublineAdvanceWidth(PLSSUBL plssubl);
static PLSDNODE AdvanceToNextVisualDnodeCore(PLSDNODE, LSTFLOW, POINTUV*);
static PLSDNODE NextVisualDnodeOnTheLevel(PLSDNODE pdn, LSTFLOW lstflowMain);

#define fUVerticalPlusVDirection	(fUVertical|fVDirection)			// see comments in lstfset.c 

// Has this dnode submitted subline(s) for display?
#define FIsSubmittingDnode(pdn) 	(FIsDnodeReal(pdn) && (pdn)->u.real.pinfosubl != NULL && 	\
									(pdn)->u.real.pinfosubl->fUseForDisplay)

// Has this dnode accepted subline(s) for display?
#define FIsAcceptingDnode(pdn) 	(FIsDnodeReal(pdn) && (pdn)->u.real.pinfosubl != NULL && 	\
									((pdn)->u.real.pinfosubl->rgpsubl)[0]->fAcceptedForDisplay)


//    %%Function:	CreateDisplayTree
//    %%Contact:	victork
//
/* 	CreateDisplayTree sets plsdnUpTemp in sublines to be displayed with given subline,
 *	rejects wrong sublines, submitted for display, sets fAcceptedForDisplay in good ones
 */

void CreateDisplayTree(PLSSUBL plssubl)
{
	LSTFLOW 	lstflowMain = plssubl->lstflow;	
	
	PLSDNODE 	pdn = plssubl->plsdnFirst;
	
	long		dupSum;
	BOOL 		fAccept;
	DWORD		i;
	LSTFLOW 	lstflowSubline;	
	
	while (pdn != NULL)							/* don't care about break */
		{
		if (FIsSubmittingDnode(pdn))
			{

			Assert(pdn->u.real.pinfosubl->cSubline > 0);
			
			fAccept = fTrue;

			lstflowSubline = ((pdn->u.real.pinfosubl->rgpsubl)[0])->lstflow;

			// reject if one tflow is vertical, another is horizontal or v-directions are not the same
			//		(see explanation of bits meaning in lstfset.c)
			
			if ((lstflowSubline ^ lstflowMain) & fUVerticalPlusVDirection)
				{
				fAccept = fFalse;
				}
				
			dupSum = 0;
			
			for (i = 0; i < pdn->u.real.pinfosubl->cSubline; i++)
				{
				dupSum += AddSublineAdvanceWidth((pdn->u.real.pinfosubl->rgpsubl)[i]);
				
				// all tflows should be the same
				
				if (((pdn->u.real.pinfosubl->rgpsubl)[i])->lstflow != lstflowSubline)
					{
					fAccept = fFalse;
					}
					
				// Submitting empty sublines is prohibited
				
				if (((pdn->u.real.pinfosubl->rgpsubl)[i])->plsdnFirst == NULL)
					{
					fAccept = fFalse;
					}		
				}
				
			// reject if sublines don't sum up to the dnode width
			
			if (dupSum != pdn->u.real.dup)
				{
				fAccept = fFalse;
				}
				
			if (fAccept)
				{
				for (i = 0; i < pdn->u.real.pinfosubl->cSubline; i++)
					{
					((pdn->u.real.pinfosubl->rgpsubl)[i])->plsdnUpTemp = pdn;
					((pdn->u.real.pinfosubl->rgpsubl)[i])->fAcceptedForDisplay = fTrue;
					CreateDisplayTree((pdn->u.real.pinfosubl->rgpsubl)[i]);
					}
				}
			}
				
		pdn = pdn->plsdnNext;
		}
}


//    %%Function:	DestroyDisplayTree
//    %%Contact:	victork
//
/*
 * 	DestroyDisplayTree nulls plsdnUpTemp in sublines displayed with given subline.
 */

void DestroyDisplayTree(PLSSUBL plssubl)
{
	PLSDNODE 	pdn = plssubl->plsdnFirst;
	DWORD		i;
	
	while (pdn != NULL)							/* don't care about break */
		{
		if (FIsAcceptingDnode(pdn))
			{
			for (i = 0; i < pdn->u.real.pinfosubl->cSubline; i++)
				{
				((pdn->u.real.pinfosubl->rgpsubl)[i])->plsdnUpTemp = NULL;
				((pdn->u.real.pinfosubl->rgpsubl)[i])->fAcceptedForDisplay = fFalse;
				DestroyDisplayTree((pdn->u.real.pinfosubl->rgpsubl)[i]);
				}
			}
				
		pdn = pdn->plsdnNext;
		}
}


//    %%Function:	AdvanceToNextDnode
//    %%Contact:	victork
//
/* 
 *	Advance to the next (visual) node and update pen position, skipping submitting dnodes.
 */
 
PLSDNODE AdvanceToNextDnode(PLSDNODE pdn, LSTFLOW lstflowMain, POINTUV* pptpen)
{
	// move to the next
	
	pdn = AdvanceToNextVisualDnodeCore(pdn, lstflowMain, pptpen);

	// skip submitting dnodes
	
	while (pdn != NULL && FIsAcceptingDnode(pdn))
		{
		pdn = AdvanceToNextVisualDnodeCore(pdn, lstflowMain, pptpen);
		}
		
	return pdn;	
}

//    %%Function:	AdvanceToFirstDnode
//    %%Contact:	victork
//
PLSDNODE AdvanceToFirstDnode(PLSSUBL plssubl, LSTFLOW lstflowMain, POINTUV* pptpen)
{
	PLSDNODE pdn = plssubl->plsdnFirst;

	if (pdn != NULL && FIsAcceptingDnode(pdn))
		{
		pdn = AdvanceToNextDnode(pdn, lstflowMain, pptpen);
		}
		
	return pdn;	
}


//    %%Function:	AdvanceToNextSubmittingDnode
//    %%Contact:	victork
//
/* 
 *	Advance to the next (visual) node and update pen position, stopping only at submitting dnodes.
 */
 
PLSDNODE AdvanceToNextSubmittingDnode(PLSDNODE pdn, LSTFLOW lstflowMain, POINTUV* pptpen)
{
	// move to the next
	
	pdn = AdvanceToNextVisualDnodeCore(pdn, lstflowMain, pptpen);

	// skip non-submitting dnodes
	
	while (pdn != NULL && !FIsAcceptingDnode(pdn))
		{
		pdn = AdvanceToNextVisualDnodeCore(pdn, lstflowMain, pptpen);
		}
		
	return pdn;	
}

//    %%Function:	AdvanceToFirstSubmittingDnode
//    %%Contact:	victork
//
PLSDNODE AdvanceToFirstSubmittingDnode(PLSSUBL plssubl, LSTFLOW lstflowMain, POINTUV* pptpen)
{
	PLSDNODE pdn = plssubl->plsdnFirst;

	if (pdn != NULL && !FIsAcceptingDnode(pdn))
		{
		pdn = AdvanceToNextSubmittingDnode(pdn, lstflowMain, pptpen);
		}
		
	return pdn;	
}


//    %%Function:	AdvanceToNextVisualDnodeCore
//    %%Contact:	victork
//
/* 
 *	Advance to the next node and update pen position
 *	Goes into sublines, submitted for display, traversing the whole display tree.
 *	Stops at dnodes that submitted subline on the way down, skips them going up, so that
 *	every dnode is visited once with pen position at the start of it in visual order.
 */

static PLSDNODE AdvanceToNextVisualDnodeCore(PLSDNODE pdn, LSTFLOW lstflowMain, POINTUV* pptpen)
{

	PLSDNODE 	pdnNextVisual, pdnTop;
	PLSSUBL		plssublCurrent;
	long		cSublines, i;
	PLSSUBL* 	rgpsubl;

	if (FIsAcceptingDnode(pdn))
		{
		
		// Last time we stopped at submitting dnode -
		//	now don't move pen point, go down to the VisualStart of the VisualFirst subline.
		
		rgpsubl = pdn->u.real.pinfosubl->rgpsubl;
		cSublines = pdn->u.real.pinfosubl->cSubline;
		
		if (rgpsubl[0]->lstflow == lstflowMain)
			{
			pdnNextVisual = rgpsubl[0]->plsdnFirst;
			}
		else
			{
			pdnNextVisual = rgpsubl[cSublines - 1]->plsdnLastDisplay;
			}
		}
	else
		{
		// update pen position - we always move to the (visual) right, all vs are the same tflow
		
		if (pdn->klsdn == klsdnReal)
			{
			pptpen->u += pdn->u.real.dup;										
			}
		else
			{
			pptpen->u += pdn->u.pen.dup;
			pptpen->v += pdn->u.pen.dvp;
			}
			
		plssublCurrent = pdn->plssubl;

		// go to the next dnode of the current subline in visual order
		
		pdnNextVisual = NextVisualDnodeOnTheLevel(pdn, lstflowMain);

		// If current subline is ended, (try) change subline.
			
		if (pdnNextVisual == NULL)
			{
			// 		Change subline
			//
			//	In the loop: pdnNextVisual != NULL signals that next dnode is successfully found.
			//	If 	pdnNextVisual == NULL, plssublCurrent is the subline just exhausted.
			//	One run of the loop replaces current subline with another subline on the same level
			//	(such change always ends the loop) or with parent subline.
			
			while (pdnNextVisual == NULL && plssublCurrent->plsdnUpTemp != NULL)
				{
				
				// find (the index of) the current subline in the list of submitted sublines
				
				pdnTop = plssublCurrent->plsdnUpTemp;
				rgpsubl = pdnTop->u.real.pinfosubl->rgpsubl;
				cSublines = pdnTop->u.real.pinfosubl->cSubline;
				
				for (i=0; i < cSublines && plssublCurrent != rgpsubl[i]; i++);
				
				Assert(i < cSublines);

				// do we have "next" subline? If we do, pdnNextVisual we seek "starts" it.
				
				if (pdnTop->plssubl->lstflow == lstflowMain)
					{
					i++;
					if (i < cSublines)
						{
						plssublCurrent = rgpsubl[i];
						pdnNextVisual = plssublCurrent->plsdnFirst;
						}
					}
				else
					{
					i--;
					if (i >= 0)
						{
						plssublCurrent = rgpsubl[i];
						pdnNextVisual = plssublCurrent->plsdnLastDisplay;
						}
					}

				//	We don't, let's try next dnode on the upper level.
				
				if (pdnNextVisual == NULL)
					{
					plssublCurrent = pdnTop->plssubl;
					pdnNextVisual = NextVisualDnodeOnTheLevel(pdnTop, lstflowMain);
					}
				}
			}
		}
	
	return pdnNextVisual;
}


//    %%Function:	NextVisualDnodeOnTheLevel
//    %%Contact:	victork
//
// find next dnode on the level moving right or left, signalling end with a NULL

static PLSDNODE NextVisualDnodeOnTheLevel(PLSDNODE pdn, LSTFLOW lstflowMain)
{
	if (pdn->plssubl->lstflow == lstflowMain)
		{
		if (pdn == pdn->plssubl->plsdnLastDisplay)
			{
			return NULL;
			}
		else
			{
			return pdn->plsdnNext;
			}
		}
	return pdn->plsdnPrev;
}


//    %%Function:	AddSublineAdvanceWidth
//    %%Contact:	victork
//
// Note: It is not subline width as calculated in GetObjDimSubline

static long	AddSublineAdvanceWidth(PLSSUBL plssubl)
{
	long		dupSum;
	PLSDNODE 	pdn;

	pdn = plssubl->plsdnFirst;
	dupSum = 0;
	
	while (pdn != NULL)
		{
		if (pdn->klsdn == klsdnReal)
			{
			dupSum += pdn->u.real.dup;
			}
		else 								/*  pen, border */
			{  
			dupSum += pdn->u.pen.dup;
			}

		if (pdn == plssubl->plsdnLastDisplay)
			{
			pdn = NULL;
			}
		else
			{
			pdn = pdn->plsdnNext;
			Assert(pdn != NULL);				// plsdnLastDisplay should prevent this	
			}
		}
		
	return dupSum;
}


// NB Victork - following functions were used only for upClipLeft, upClipRight optimization.
// If we'll decide that we do need that optimization after Word integration - I'll uncomment.

#ifdef NEVER
//    %%Function:	RectUVFromRectXY
//    %%Contact:	victork
//
//	There is an assymetry in the definition of the rectangle.
//	(Left, Top) belongs to rectangle and (Right, Bottom) doesn't,
//  It makes following procedures hard to understand and write.
//	So I first cut off the points that don't belong, then turn the rectangle, then add extra 
//	points again and hope compiler will make it fast.

// RectUVFromRectXY calculates (clip) rectangle in local (u,v) coordinates given
//								(clip) rectangle in (x,y) and point of origin 

void RectUVFromRectXY(const POINT* pptXY, 		/* IN: point of origin for local coordinates (x,y) */
						const RECT* prectXY,	/* IN: input rectangle (x,y) */
						LSTFLOW lstflow, 		/* IN: local text flow */
						RECTUV* prectUV)		/* OUT: output rectangle (u,v) */
{
	switch (lstflow)
		{
		case lstflowES:												/* latin */
			prectUV->upLeft = (prectXY->left - pptXY->x);
			prectUV->upRight = (prectXY->right - 1 - pptXY->x) + 1;
			prectUV->vpTop = -(prectXY->top - pptXY->y);
			prectUV->vpBottom = -(prectXY->bottom - 1 - pptXY->y) - 1;
			return;

		case lstflowSW:												/* vertical FE */
			prectUV->upLeft = (prectXY->top - pptXY->y);
			prectUV->upRight = (prectXY->bottom - 1 - pptXY->y) + 1;
			prectUV->vpTop = (prectXY->right - 1 - pptXY->x);
			prectUV->vpBottom = (prectXY->left - pptXY->x) - 1;
			return;

		case lstflowWS:												/* BiDi */
			prectUV->upLeft = -(prectXY->right - 1 - pptXY->x);
			prectUV->upRight = -(prectXY->left - pptXY->x) + 1;
			prectUV->vpTop = -(prectXY->top - pptXY->y);
			prectUV->vpBottom = -(prectXY->bottom - 1 - pptXY->y) - 1;
			return;

		case lstflowEN:
			prectUV->upLeft = (prectXY->left - pptXY->x);
			prectUV->upRight = (prectXY->right - 1 - pptXY->x) + 1;
			prectUV->vpTop = (prectXY->bottom - 1 - pptXY->y);
			prectUV->vpBottom = (prectXY->top - pptXY->y) - 1;
			return;

		case lstflowSE:
			prectUV->upLeft = (prectXY->top - pptXY->y);
			prectUV->upRight = (prectXY->bottom - 1 - pptXY->y) + 1;
			prectUV->vpTop = -(prectXY->left - pptXY->x);
			prectUV->vpBottom = -(prectXY->right - 1 - pptXY->x) - 1;
			return;

		case lstflowWN:
			prectUV->upLeft = -(prectXY->right - 1 - pptXY->x);
			prectUV->upRight = -(prectXY->left - pptXY->x) + 1;
			prectUV->vpTop = (prectXY->bottom - 1 - pptXY->y);
			prectUV->vpBottom = (prectXY->top - pptXY->y) - 1;
			return;

		case lstflowNE:
			prectUV->upLeft = -(prectXY->bottom - 1 - pptXY->y);
			prectUV->upRight = -(prectXY->top - pptXY->y) + 1;
			prectUV->vpTop = -(prectXY->left - pptXY->x);
			prectUV->vpBottom = -(prectXY->right - 1 - pptXY->x) - 1;
			return;

		case lstflowNW:
			prectUV->upLeft = -(prectXY->bottom - 1 - pptXY->y);
			prectUV->upRight = -(prectXY->top - pptXY->y) + 1;
			prectUV->vpTop = (prectXY->right - 1 - pptXY->x);
			prectUV->vpBottom = (prectXY->left - pptXY->x) - 1;
			return;
		default:
			NotReached();
		}
}


//    %%Function:	RectXYFromRectUV
//    %%Contact:	victork
//
// RectXYFromRectUV calculates rectangle in (x,y) coordinates given rectangle in local (u,v) 
//							and point of origin (x,y) for local coordinate system


void RectXYFromRectUV(const POINT* pptXY, 		/* IN: point of origin for local coordinates (x,y) */
						PCRECTUV prectUV,		/* IN: input rectangle (u,v) */
						LSTFLOW lstflow, 		/* IN: local text flow */
						RECT* prectXY)			/* OUT: output rectangle (x,y) */
{
	switch (lstflow)
		{
		case lstflowES:												/* latin */
			prectXY->left = pptXY->x + prectUV->upLeft;
			prectXY->right = pptXY->x + (prectUV->upRight - 1) + 1;
			prectXY->top = pptXY->y - (prectUV->vpTop);
			prectXY->bottom = pptXY->y - (prectUV->vpBottom + 1) + 1;
			return;

		case lstflowSW:												/* vertical FE */
			prectXY->left = pptXY->x + (prectUV->vpBottom + 1);
			prectXY->right = pptXY->x + (prectUV->vpTop) + 1;
			prectXY->top = pptXY->y + prectUV->upLeft;
			prectXY->bottom = pptXY->y + (prectUV->upRight - 1) + 1;
			return;

		case lstflowWS:												/* BiDi */
			prectXY->left = pptXY->x - (prectUV->upRight - 1);
			prectXY->right = pptXY->x - prectUV->upLeft + 1;
			prectXY->top = pptXY->y - (prectUV->vpTop);
			prectXY->bottom = pptXY->y - (prectUV->vpBottom + 1) + 1;
			return;

		case lstflowEN:
			prectXY->left = pptXY->x + prectUV->upLeft;
			prectXY->right = pptXY->x + (prectUV->upRight - 1) + 1;
			prectXY->top = pptXY->y + (prectUV->vpBottom + 1);
			prectXY->bottom = pptXY->y + (prectUV->vpTop) + 1;
			return;

		case lstflowSE:
			prectXY->left = pptXY->x - (prectUV->vpTop);
			prectXY->right = pptXY->x - (prectUV->vpBottom + 1) + 1;
			prectXY->top = pptXY->y + prectUV->upLeft;
			prectXY->bottom = pptXY->y + (prectUV->upRight - 1) + 1;
			return;

		case lstflowWN:
			prectXY->left = pptXY->x - (prectUV->upRight - 1);
			prectXY->right = pptXY->x - prectUV->upLeft + 1;
			prectXY->top = pptXY->y + (prectUV->vpBottom + 1);
			prectXY->bottom = pptXY->y + (prectUV->vpTop) + 1;
			return;

		case lstflowNE:
			prectXY->left = pptXY->x - (prectUV->vpTop);
			prectXY->right = pptXY->x - (prectUV->vpBottom + 1) + 1;
			prectXY->top = pptXY->y - (prectUV->upRight - 1);
			prectXY->bottom = pptXY->y - prectUV->upLeft + 1;
			return;

		case lstflowNW:
			prectXY->left = pptXY->x + (prectUV->vpBottom + 1);
			prectXY->right = pptXY->x + (prectUV->vpTop) + 1;
			prectXY->top = pptXY->y - (prectUV->upRight - 1);
			prectXY->bottom = pptXY->y - prectUV->upLeft + 1;
			return;
			
		default:
			NotReached();
		}
}
#endif /* NEVER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\enumcore.c ===
#include "enumcore.h"
#include "lsc.h"
#include "lssubl.h"
#include "heights.h"
#include "lsdnode.h"
#include "dninfo.h"
#include "lstfset.h"

static LSERR EnumerateDnode(PLSC plsc, PLSDNODE pdn, POINTUV pt, BOOL fReverse,
					BOOL fGeometry, const POINT* pptOrg);

//    %%Function:	EnumSublineCore
//    %%Contact:	victork
//
/*
 *	Enumerates subline calling enumeration callback for pens, methods for objects.
 *	Provides geometry information if needed (Prepdisp should be done already in this case.)
 *	Notice that auto-decimal tab is enumerated as a tab before Prepdisp and as a pen after.
 */

LSERR EnumSublineCore(PLSSUBL plssubl, BOOL fReverse, BOOL fGeometry, 
					const POINT* pptOrg, long upLeftIndent)
{
	LSERR 		lserr;
	LSCP		cpLim = plssubl->cpLimDisplay;
	PLSC		plsc = plssubl->plsc;

	PLSDNODE	pdn;
	POINTUV		pt	= {0,0};				// init'ed to get rid of assert.

	if (plssubl->plsdnFirst == NULL)
		{
		return lserrNone;					// early exit for empty sublines
		}

	Assert(!fGeometry || plssubl->fDupInvalid == fFalse);
	
	if (fReverse)
		{
		pdn = plssubl->plsdnFirst;

		if (fGeometry)
			{
			pt.u = upLeftIndent;						
			pt.v = 0;

			while (FDnodeBeforeCpLim(pdn, cpLim))
				{
				if (pdn->klsdn == klsdnReal)
					{				
					pt.u += pdn->u.real.dup;
					}
				else
					{
					pt.u += pdn->u.pen.dup;					
					pt.v += pdn->u.pen.dvp;
					}
				
				pdn = pdn->plsdnNext;
				}
			}

		pdn = plssubl->plsdnLastDisplay;
			
		while (pdn != NULL)
			{
			if (fGeometry)
				{
				// pt is now after pdn, downdate it to point before
				if (pdn->klsdn == klsdnReal)
					{				
					pt.u -= pdn->u.real.dup;
					}
				else
					{
					pt.u -= pdn->u.pen.dup;					
					pt.v -= pdn->u.pen.dvp;
					}
				}

			lserr = EnumerateDnode(plsc, pdn, pt, fReverse, fGeometry, pptOrg);
			if (lserr != lserrNone) return lserr;

			pdn = pdn->plsdnPrev;
			}
		}
	else
		{
		pdn = plssubl->plsdnFirst;

		pt.u = upLeftIndent;						
		pt.v = 0;

		while (FDnodeBeforeCpLim(pdn, cpLim))
			{
			lserr = EnumerateDnode(plsc, pdn, pt, fReverse, fGeometry, pptOrg);
			if (lserr != lserrNone) return lserr;

			if (fGeometry)
				{
				if (pdn->klsdn == klsdnReal)
					{				
					pt.u += pdn->u.real.dup;
					}
				else
					{
					pt.u += pdn->u.pen.dup;					
					pt.v += pdn->u.pen.dvp;
					}
				}
				
			pdn = pdn->plsdnNext;
			}
		}		
		

	return lserrNone;			
}

//    %%Function:	EnumerateDnode
//    %%Contact:	victork
//
static LSERR EnumerateDnode(PLSC plsc, PLSDNODE pdn, POINTUV pt, BOOL fReverse,
							BOOL fGeometry, const POINT* pptOrg)
{
	POINTUV	ptRaised;
	POINT	ptXY;
	LSTFLOW	lstflow = pdn->plssubl->lstflow;

	if (pdn->klsdn == klsdnReal)
		{
		if (pdn->u.real.pdobj == NULL)
			{
			// How could it happen:
			// we substitute autodecimal tab by a pen at  PrepareLineForDisplay time. 
			// Pens don't require plsrun, so we are fine at display.
			// If Client doesn't ask for geometry, the substitution might not happen

			Assert (!fGeometry);
			Assert (pdn->fTab);
			Assert(pdn->cpFirst < 0);
			Assert(plsc->lsadjustcontext.fAutodecimalTabPresent);
			
			return plsc->lscbk.pfnEnumPen(plsc->pols, fFalse, lstflow, 
						fReverse, fFalse, &ptXY, 0, 0);
			}
		else
			{
			if (fGeometry)
				{
				ptRaised = pt;
				ptRaised.v += pdn->u.real.lschp.dvpPos;

				LsPointXYFromPointUV(pptOrg, lstflow, &ptRaised, &(ptXY));
				}

			return (*plsc->lsiobjcontext.rgobj[pdn->u.real.lschp.idObj].lsim.pfnEnum)
				(pdn->u.real.pdobj, pdn->u.real.plsrun, &(pdn->u.real.lschp), pdn->cpFirst, pdn->dcp,
				lstflow, fReverse, fGeometry, &ptXY, &pdn->u.real.objdim.heightsPres, pdn->u.real.dup);
			}
		}
	else
		{
		return plsc->lscbk.pfnEnumPen(plsc->pols, pdn->fBorderNode, lstflow, 
					fReverse, fGeometry, &ptXY, pdn->u.pen.dup, pdn->u.pen.dvp);
		}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\hih.c ===
#include	"lsmem.h"
#include	"limits.h"
#include	"hih.h"
#include	"objhelp.h"
#include	"lscbk.h"
#include	"lsdevres.h"
#include	"pdobj.h"
#include	"objdim.h"
#include	"plssubl.h"
#include	"plsdnode.h"
#include	"pilsobj.h"
#include	"lscrsubl.h"
#include	"lssubset.h"
#include	"lsdnset.h"
#include	"zqfromza.h"
#include	"lsdocinf.h"
#include	"fmti.h"
#include	"posichnk.h"
#include	"locchnk.h"
#include	"lsdnfin.h"
#include	"brko.h"
#include	"lspap.h"
#include	"plspap.h"
#include	"lsqsubl.h"
#include	"dispi.h"
#include	"lsdssubl.h"
#include	"lsems.h"
#include	"dispmisc.h"
#include	"sobjhelp.h"

#define HIH_ESC_CNT	1


struct ilsobj
{
    POLS				pols;
	LSCBK				lscbk;
	PLSC				plsc;
	PFNHIHENUM			pfnEnum;
	LSESC				lsescHih;
};


struct dobj
{
	SOBJHELP			sobjhelp;			/* common area for simple objects */	
	PILSOBJ				pilsobj;			/* ILS object */
	LSCP				cpStart;			/* Starting LS cp for object */
	PLSSUBL				plssubl;			/* Handle to second line */
};


/* H I H F R E E D O B J */
/*----------------------------------------------------------------------------
	%%Function: HihFreeDobj
	%%Contact: antons

		Free all resources associated with Hih dobj.
	
----------------------------------------------------------------------------*/
static LSERR HihFreeDobj (PDOBJ pdobj)
{
	LSERR lserr = lserrNone;
	
	PILSOBJ pilsobj = pdobj->pilsobj;

	if (pdobj->plssubl != NULL)
		{
		lserr = LsDestroySubline(pdobj->plssubl);
		}

    pilsobj->lscbk.pfnDisposePtr(pilsobj->pols, pdobj);

	return lserr;
}


/* H I H C R E A T E I L S O B J */
/*----------------------------------------------------------------------------
	%%Function: HihCreateILSObj
	%%Contact: ricksa

		CreateILSObj

		Create the ILS object for all Hih objects.
	
----------------------------------------------------------------------------*/
LSERR WINAPI HihCreateILSObj(
	POLS pols,				/* (IN): client application context */
	PLSC plsc,				/* (IN): LS context */
	PCLSCBK pclscbk,		/* (IN): callbacks to client application */
	DWORD idObj,			/* (IN): id of the object */
	PILSOBJ *ppilsobj)		/* (OUT): object ilsobj */
{
    PILSOBJ pilsobj;
	LSERR lserr;
	HIHINIT hihinit;
	hihinit.dwVersion = HIH_VERSION;

	/* Get initialization data */
	lserr = pclscbk->pfnGetObjectHandlerInfo(pols, idObj, &hihinit);

	if (lserr != lserrNone)
		{
		return lserr;
		}

    pilsobj = pclscbk->pfnNewPtr(pols, sizeof(*pilsobj));

	if (NULL == pilsobj)
	{
		return lserrOutOfMemory;
	}

    pilsobj->pols = pols;
    pilsobj->lscbk = *pclscbk;
	pilsobj->plsc = plsc;
	pilsobj->lsescHih.wchFirst = hihinit.wchEndHih;
	pilsobj->lsescHih.wchLast = hihinit.wchEndHih;
	pilsobj->pfnEnum = hihinit.pfnEnum;
	*ppilsobj = pilsobj;
	return lserrNone;
}

/* H I H D E S T R O Y I L S O B J */
/*----------------------------------------------------------------------------
	%%Function: HihDestroyILSObj
	%%Contact: ricksa

		DestroyILSObj

		Free all resources assocaiated with Hih ILS object.
	
----------------------------------------------------------------------------*/
LSERR WINAPI HihDestroyILSObj(
	PILSOBJ pilsobj)			/* (IN): object ilsobj */
{
	pilsobj->lscbk.pfnDisposePtr(pilsobj->pols, pilsobj);
	return lserrNone;
}

/* H I H S E T D O C */
/*----------------------------------------------------------------------------
	%%Function: HihSetDoc
	%%Contact: ricksa

		SetDoc

		Keep track of device information for scaling purposes.
	
----------------------------------------------------------------------------*/
LSERR WINAPI HihSetDoc(
	PILSOBJ pilsobj,			/* (IN): object ilsobj */
	PCLSDOCINF pclsdocinf)		/* (IN): initialization data of the document level */
{
	Unreferenced(pilsobj);
	Unreferenced(pclsdocinf);
	return lserrNone;
}


/* H I H C R E A T E L N O B J */
/*----------------------------------------------------------------------------
	%%Function: HihCreateLNObj
	%%Contact: ricksa

		CreateLNObj

		Create the Line Object for the Hih. No real need for a line
		object so don't allocated it.
	
----------------------------------------------------------------------------*/
LSERR WINAPI HihCreateLNObj(
	PCILSOBJ pcilsobj,			/* (IN): object ilsobj */
	PLNOBJ *pplnobj)			/* (OUT): object lnobj */
{
	*pplnobj = (PLNOBJ) pcilsobj;
	return lserrNone;
}

/* H I H D E S T R O Y L N O B J */
/*----------------------------------------------------------------------------
	%%Function: HihDestroyLNObj
	%%Contact: ricksa

		DestroyLNObj

		Frees resources associated with the Hih line object. Since
		there isn't any this is a no-op.
	
----------------------------------------------------------------------------*/
LSERR WINAPI HihDestroyLNObj(
	PLNOBJ plnobj)				/* (OUT): object lnobj */

{
	Unreferenced(plnobj);
	return lserrNone;
}

/* H I H F M T */
/*----------------------------------------------------------------------------
	%%Function: HihFmt
	%%Contact: ricksa

		Fmt

		Format the Hih object. 
	
----------------------------------------------------------------------------*/
LSERR WINAPI HihFmt(
    PLNOBJ plnobj,				/* (IN): object lnobj */
    PCFMTIN pcfmtin,			/* (IN): formatting input */
    FMTRES *pfmtres)			/* (OUT): formatting result */
{
	PDOBJ pdobj;
	LSERR lserr;
	PILSOBJ pilsobj = (PILSOBJ) plnobj;
	POLS pols = pilsobj->pols;
	LSCP cpStartMain = pcfmtin->lsfgi.cpFirst + 1;
	LSCP cpOut;
	FMTRES fmtres;
	FMTRES fmtr = fmtrCompletedRun;

    /*
     * Allocate the DOBJ
     */
     
    pdobj = pilsobj->lscbk.pfnNewPtr(pols, sizeof(*pdobj));

    if (NULL == pdobj)
		{
		return lserrOutOfMemory;
		}

	ZeroMemory(pdobj, sizeof(*pdobj));
	pdobj->pilsobj = pilsobj;
	pdobj->cpStart = pcfmtin->lsfgi.cpFirst;

	/*
	 * Build main line of text
	 */
	 
	lserr = FormatLine(pilsobj->plsc, cpStartMain, LONG_MAX, pcfmtin->lsfgi.lstflow,
		&pdobj->plssubl, HIH_ESC_CNT, &pilsobj->lsescHih,
			&pdobj->sobjhelp.objdimAll, &cpOut, NULL, NULL, &fmtres);

	if (lserr != lserrNone)
		{
		HihFreeDobj(pdobj); /* do not need to check return error code */

		return lserr;
		}

	/*
	 * Note: the + 2 in the following is because cpStartMain is + 1 from the
	 * actual start of the object (it is the cpStartMain of the Hih
	 * data) and additional + 1 for the escape character at the end of the
	 * tatenakayoko.
	 */

	Assert (fmtres != fmtrExceededMargin);

	pdobj->sobjhelp.dcp = cpOut - cpStartMain + 2;

	lserr = LsdnFinishRegular(pilsobj->plsc, pdobj->sobjhelp.dcp, 
		pcfmtin->lsfrun.plsrun, pcfmtin->lsfrun.plschp, pdobj, 
			&pdobj->sobjhelp.objdimAll);
		
	if (lserr != lserrNone)
		{
		HihFreeDobj(pdobj); /* do not need to check return error code */

		return lserr;
		}

	if (pcfmtin->lsfgi.urPen + pdobj->sobjhelp.objdimAll.dur > pcfmtin->lsfgi.urColumnMax)
		{
		fmtr = fmtrExceededMargin;
		}

	*pfmtres = fmtr;

	return lserrNone;
}



/* H I H G E T S P E C I A L E F F E C T S I N S I D E */
/*----------------------------------------------------------------------------
	%%Function: HihGetSpecialEffectsInside
	%%Contact: ricksa

		GetSpecialEffectsInside

		.

----------------------------------------------------------------------------*/
LSERR WINAPI HihGetSpecialEffectsInside(
	PDOBJ pdobj,				/* (IN): dobj */
	UINT *pEffectsFlags)		/* (OUT): Special effects for this object */
{
	return LsGetSpecialEffectsSubline(pdobj->plssubl, pEffectsFlags);
}

/* H I H C A L C P R E S E N T A T I O N */
/*----------------------------------------------------------------------------
	%%Function: HihCalcPresentation
	%%Contact: ricksa

		CalcPresentation
	
		This has three jobs. First it distributes space to the shorter string
		if so requested. Next it prepares each line for presentation. Finally,
		it calculates the positions of the lines in output device coordinates.
	
----------------------------------------------------------------------------*/
LSERR WINAPI HihCalcPresentation(
	PDOBJ pdobj,				/* (IN): dobj */
	long dup,					/* (IN): dup of dobj */
	LSKJUST lskjust,			/* (IN): Justification type */
	BOOL fLastVisibleOnLine )	/* (IN): Is this object last visible on line? */
{
	Unreferenced (fLastVisibleOnLine);	
	Unreferenced(dup);
	Unreferenced (lskjust);
	return LsMatchPresSubline(pdobj->plssubl);

}

/* H I H Q U E R Y P O I N T P C P */
/*----------------------------------------------------------------------------
	%%Function: HihQueryPointPcp
	%%Contact: ricksa

		Map dup to dcp

		Just call through to Query result helper.

----------------------------------------------------------------------------*/
LSERR WINAPI HihQueryPointPcp(
	PDOBJ pdobj,				/*(IN): dobj to query */
	PCPOINTUV ppointuvQuery,	/*(IN): query point (uQuery,vQuery) */
	PCLSQIN plsqin,				/*(IN): query input */
	PLSQOUT plsqout)			/*(OUT): query output */
{
	Unreferenced(ppointuvQuery);
	return CreateQueryResult(pdobj->plssubl, 0, 0, plsqin, plsqout);
}
	
/* H I H Q U E R Y C P P P O I N T */
/*----------------------------------------------------------------------------
	%%Function: HihQueryCpPpoint
	%%Contact: ricksa

		Map dcp to dup

		Just call through to Query result helper.

----------------------------------------------------------------------------*/
LSERR WINAPI HihQueryCpPpoint(
	PDOBJ pdobj,				/*(IN): dobj to query, */
	LSDCP dcp,					/*(IN): dcp for the query */
	PCLSQIN plsqin,				/*(IN): query input */
	PLSQOUT plsqout)			/*(OUT): query output */
{
	Unreferenced(dcp);
	return CreateQueryResult(pdobj->plssubl, 0, 0, plsqin, plsqout);
}

	
/* H I H D I S P L A Y */
/*----------------------------------------------------------------------------
	%%Function: HihDisplay
	%%Contact: ricksa

		Display

		This calculates the positions of the various lines for the
		display and then displays them.
	
----------------------------------------------------------------------------*/
LSERR WINAPI HihDisplay(
	PDOBJ pdobj,				/*(IN): dobj to display */
	PCDISPIN pcdispin)			/*(IN): info for display */
{

	/* display the Hih line */
	return LsDisplaySubline(pdobj->plssubl, &pcdispin->ptPen, pcdispin->kDispMode, 
		pcdispin->prcClip);
}

/* H I H D E S T R O Y D O B J */
/*----------------------------------------------------------------------------
	%%Function: HihDestroyDobj
	%%Contact: ricksa

		DestroyDobj

		Free all resources connected with the input dobj.
	
----------------------------------------------------------------------------*/
LSERR WINAPI HihDestroyDobj(
	PDOBJ pdobj)				/*(IN): dobj to destroy */
{
	return HihFreeDobj(pdobj);
}

/* H I H E N U M */
/*----------------------------------------------------------------------------
	%%Function: HihEnum
	%%Contact: ricksa

		Enumeration callback - passed to client.
	
----------------------------------------------------------------------------*/
LSERR WINAPI HihEnum(
	PDOBJ pdobj,				/*(IN): dobj to enumerate */
	PLSRUN plsrun,				/*(IN): from DNODE */
	PCLSCHP plschp,				/*(IN): from DNODE */
	LSCP cp,					/*(IN): from DNODE */
	LSDCP dcp,					/*(IN): from DNODE */
	LSTFLOW lstflow,			/*(IN): text flow*/
	BOOL fReverse,				/*(IN): enumerate in reverse order */
	BOOL fGeometryNeeded,		/*(IN): */
	const POINT* pt,			/*(IN): starting position (top left), iff fGeometryNeeded */
	PCHEIGHTS pcheights,		/*(IN): from DNODE, relevant iff fGeometryNeeded */
	long dupRun)				/*(IN): from DNODE, relevant iff fGeometryNeeded */
{
	return pdobj->pilsobj->pfnEnum(pdobj->pilsobj->pols, plsrun, plschp, cp, 
		dcp, lstflow, fReverse, fGeometryNeeded, pt, pcheights, dupRun, 
			pdobj->plssubl);
}
	

/* H I H H A N D L E R I N I T */
/*----------------------------------------------------------------------------
	%%Function: HihHandlerInit
	%%Contact: ricksa

		Initialize global Hih data and return LSIMETHODS.
	
----------------------------------------------------------------------------*/
LSERR WINAPI LsGetHihLsimethods(
	LSIMETHODS *plsim)
{
	plsim->pfnCreateILSObj = HihCreateILSObj;
	plsim->pfnDestroyILSObj = HihDestroyILSObj;
	plsim->pfnSetDoc = HihSetDoc;
	plsim->pfnCreateLNObj = HihCreateLNObj;
	plsim->pfnDestroyLNObj = HihDestroyLNObj;
	plsim->pfnFmt = HihFmt;
	plsim->pfnFmtResume = ObjHelpFmtResume;
	plsim->pfnGetModWidthPrecedingChar = ObjHelpGetModWidthChar;
	plsim->pfnGetModWidthFollowingChar = ObjHelpGetModWidthChar;
	plsim->pfnTruncateChunk = SobjTruncateChunk;
	plsim->pfnFindPrevBreakChunk = SobjFindPrevBreakChunk;
	plsim->pfnFindNextBreakChunk = SobjFindNextBreakChunk;
	plsim->pfnForceBreakChunk = SobjForceBreakChunk;
	plsim->pfnSetBreak = ObjHelpSetBreak;
	plsim->pfnGetSpecialEffectsInside = HihGetSpecialEffectsInside;
	plsim->pfnFExpandWithPrecedingChar = ObjHelpFExpandWithPrecedingChar;
	plsim->pfnFExpandWithFollowingChar = ObjHelpFExpandWithFollowingChar;
	plsim->pfnCalcPresentation = HihCalcPresentation;
	plsim->pfnQueryPointPcp = HihQueryPointPcp;
	plsim->pfnQueryCpPpoint = HihQueryCpPpoint;
	plsim->pfnDisplay = HihDisplay;
	plsim->pfnDestroyDObj = HihDestroyDobj;
	plsim->pfnEnum = HihEnum;
	return lserrNone;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\dnutils.c ===
#include "dnutils.h"
#include "dninfo.h"
#include "iobj.h"
#include "lsdnode.h"
#include "lscbk.h"
#include "qheap.h"
#include "lstext.h"
#include "lsmem.h"						/* memset() prototype */


#define FIsOutOfLine(plsc, plsdn)  \
		(((plsdn) == NULL) ||   \
		  (((plsc)->plslineCur->lslinfo.cpLim != 0) && ((plsc)->plslineCur->lslinfo.cpLim <= (plsdn)->cpFirst)))





/* F I N D  L I S T  D U P */
/*----------------------------------------------------------------------------
    %%Function: FindListDup
    %%Contact: igorzv

    Visit each node in the list of DNODES, until reaching cpLim
	Compute dup between start and end points.
----------------------------------------------------------------------------*/
void FindListDup(PLSDNODE plsdnFirst, LSCP cpLim, long *pdup)
{
	PLSDNODE plsdn;

	/* tolerate pldnFirst == NULL */

	*pdup = 0;
	plsdn = plsdnFirst;

	while (plsdn != NULL && plsdn->cpLimOriginal <= cpLim)
		{
		Assert(FIsLSDNODE(plsdn));
		*pdup += DupFromDnode(plsdn);
		plsdn = plsdn->plsdnNext;
		}

}

/* F I N D  L I S T  F I N A L  P E N  M O V E M E N T*/
/*----------------------------------------------------------------------------
    %%Function: FindListFinalPenMovement
    %%Contact: igorzv

    Visit each node in the list of DNODES, until reaching cpLim
	Compute dur dvr dvp  between start and end points.
----------------------------------------------------------------------------*/
void FindListFinalPenMovement(PLSDNODE plsdnFirst, PLSDNODE plsdnLast, long *pdur, long *pdvr, long *pdvp)
{
	PLSDNODE plsdn;

	/* tolerate pldnFirst == NULL */

	*pdur = 0;
	*pdvr = 0;
	*pdvp = 0;
	plsdn = plsdnFirst;

	while (plsdn != NULL && plsdn->plsdnPrev != plsdnLast)
		{
		Assert(FIsLSDNODE(plsdn));
		*pdur += DurFromDnode(plsdn);
		*pdvr += DvrFromDnode(plsdn);
		*pdvp += DvpFromDnode(plsdn);
		plsdn = plsdn->plsdnNext;
		}

}

/* F I N D  L I S T  D I M S */
/*----------------------------------------------------------------------------
    %%Function: FindListDims
    %%Contact: igorzv

    Visit each node in the list of DNODES, until reaching plsdnLast.
	Compute OBJDIM which describes the list.
----------------------------------------------------------------------------*/
LSERR FindListDims(PLSDNODE plsdnFirst, PLSDNODE plsdnLast, OBJDIM* pobjdimList)
{
	PLSDNODE plsdn;
	long urPen = 0;
	long urLim = 0;
	long vpPen = 0;
	long vrPen = 0;
	OBJDIM objdimFound;
	long dvpNode, dvrNode, durNode;
	long dvpAscentNext;
	long dvrAscentNext;
	long dvpDescentNext;
	long dvrDescentNext;
	long dvpLineHeight;
	long dvrLineHeight;
	POBJDIM pobjdimNode;
	BOOL fFindLast;
	OBJDIM* pobjdimLastSkiped = NULL;


	/* N.B. Tolerate an empty input list! */
	Assert(((plsdnFirst == NULL) && (plsdnLast == NULL)) || (FIsLSDNODE(plsdnFirst) && FIsLSDNODE(plsdnLast)));

	/* the most efficient way to put zeroes in heights */
	memset(&objdimFound, 0, sizeof objdimFound);

	/* quick return if list is empty */
	if (plsdnFirst == NULL)
		{
		*pobjdimList = objdimFound;   /* in objdim will be zeroes */
		return lserrNone;
		}


	fFindLast = fFalse;
	for (plsdn = plsdnFirst; !fFindLast ; plsdn = plsdn->plsdnNext)
		{
		if (plsdn == NULL)
		/* we dont found plsdnLast, so return error */
			return lserrInvalidParameter;

		if (plsdn == plsdnLast)
			fFindLast = fTrue;


		if (plsdn->klsdn == klsdnReal)
			{
			pobjdimNode = &plsdn->u.real.objdim;
			durNode = pobjdimNode->dur;
			Assert(durNode >= 0);
			dvrNode = 0;
			dvpNode = 0;

			dvpAscentNext = pobjdimNode->heightsPres.dvAscent + vpPen;
			dvrAscentNext = pobjdimNode->heightsRef.dvAscent + vrPen;
			dvpDescentNext = pobjdimNode->heightsPres.dvDescent - vpPen;
			dvrDescentNext = pobjdimNode->heightsRef.dvDescent - vrPen;
			dvpLineHeight = pobjdimNode->heightsPres.dvMultiLineHeight;
			dvrLineHeight = pobjdimNode->heightsRef.dvMultiLineHeight;

			if (dvrLineHeight != dvHeightIgnore) /* dvrLineHeight == dvHeightIgnore */
												 /* for us is sign that we  */
				{						/* should not take into account for height calculation 
										this dnode */
				if (objdimFound.heightsPres.dvAscent < dvpAscentNext)
					objdimFound.heightsPres.dvAscent = dvpAscentNext;
				if (objdimFound.heightsRef.dvAscent < dvrAscentNext)
					objdimFound.heightsRef.dvAscent = dvrAscentNext;
				if (objdimFound.heightsPres.dvDescent < dvpDescentNext)
					objdimFound.heightsPres.dvDescent = dvpDescentNext;
				if (objdimFound.heightsRef.dvDescent < dvrDescentNext)
					objdimFound.heightsRef.dvDescent = dvrDescentNext;
				if (objdimFound.heightsPres.dvMultiLineHeight < dvpLineHeight)
					objdimFound.heightsPres.dvMultiLineHeight = dvpLineHeight;
				if (objdimFound.heightsRef.dvMultiLineHeight < dvrLineHeight)
					objdimFound.heightsRef.dvMultiLineHeight = dvrLineHeight;
				}

			else	/*  if final heights is 0, we will take  ascent and desent from
					   this dnode */
				{
				pobjdimLastSkiped = pobjdimNode;
				}
					

			}
		else 			/*  klsdnPenOrBorder*/
			{  
			dvpNode = plsdn->u.pen.dvp;
			durNode = plsdn->u.pen.dur;
			dvrNode = plsdn->u.pen.dvr;
			}


		vpPen += dvpNode;
		urPen += durNode;
		vrPen += dvrNode;
		if (urLim < urPen)
			urLim = urPen;
		}

	if (objdimFound.heightsRef.dvAscent == 0 && objdimFound.heightsRef.dvDescent == 0
		&& pobjdimLastSkiped != NULL)
		{
		objdimFound.heightsPres.dvAscent = pobjdimLastSkiped->heightsPres.dvAscent + vpPen;
		objdimFound.heightsRef.dvAscent = pobjdimLastSkiped->heightsRef.dvAscent + vrPen;
		objdimFound.heightsPres.dvDescent = pobjdimLastSkiped->heightsPres.dvDescent - vpPen;
		objdimFound.heightsRef.dvDescent = pobjdimLastSkiped->heightsRef.dvDescent - vrPen;
		objdimFound.heightsPres.dvMultiLineHeight = dvHeightIgnore;
		objdimFound.heightsRef.dvMultiLineHeight = dvHeightIgnore;
		}


	*pobjdimList = objdimFound;
	pobjdimList->dur = urLim;
	return lserrNone;
}




/* D E S T R O Y  D N O D E  L I S T   */
/*----------------------------------------------------------------------------
    %%Function: DestroyDnodeList
    %%Contact: igorzv

Parameters:
	plscbk				-	(IN) callbacks
	pols				-	(IN) pols to pass for callbacks
	plsiobjcontext		-	(IN) object handlers 
	plsdn				-	(IN) first dnode in list
	fDontReleaseRuns	-	(IN) not to call release run
----------------------------------------------------------------------------*/
LSERR DestroyDnodeList(LSCBK* plscbk, POLS pols, PLSIOBJCONTEXT plsiobjcontext,
					   PLSDNODE plsdn, BOOL fDontReleaseRuns)
{
	LSERR lserr, lserrFinal = lserrNone;
	PLSDNODE plsdnNext;
	PDOBJ pdobj;
	PLSRUN plsrun;
	DWORD iobj;


	if (plsdn == NULL)
		return lserrNone;

	Assert(FIsLSDNODE(plsdn));

	/* link with this dnode should  be broken before */
	Assert(plsdn->plsdnPrev == NULL || plsdn->plsdnPrev->plsdnNext != plsdn );

	for (;  plsdn != NULL;  plsdn = plsdnNext)
		{

		Assert(FIsLSDNODE(plsdn));

		if (plsdn->klsdn == klsdnReal)
			{
			if (plsdn->u.real.pinfosubl != NULL)
				{
				if (plsdn->u.real.pinfosubl->rgpsubl != NULL)
					{
					plscbk->pfnDisposePtr(pols, plsdn->u.real.pinfosubl->rgpsubl);
					}

				plscbk->pfnDisposePtr(pols, plsdn->u.real.pinfosubl);
				}

			iobj = plsdn->u.real.lschp.idObj;
			plsrun = plsdn->u.real.plsrun;
			pdobj = plsdn->u.real.pdobj;
			}
		else
			{
			Assert (FIsDnodePen(plsdn) || FIsDnodeBorder(plsdn));
			iobj = 0;
			plsrun = NULL;
			pdobj = NULL;
			}

		if (plsrun != NULL && !fDontReleaseRuns)
			{
			lserr = plscbk->pfnReleaseRun(pols, plsrun);
			if (lserr != lserrNone && lserrFinal == lserrNone)
				lserrFinal = lserr;
			}

		if (pdobj != NULL)
			{
			lserr = (PLsimFromLsc(plsiobjcontext, iobj))->pfnDestroyDObj (pdobj);
			if (lserr != lserrNone && lserrFinal == lserrNone)
				lserrFinal = lserr;
			}

		plsdn->tag = tagInvalid;
		plsdnNext = plsdn->plsdnNext;
		}

	return lserrFinal;
}


/* ---------------------------------------------------------------------- */

/*  D U R  B O R D E R  F R O M  D N O D E  I N S I D E*/
/*----------------------------------------------------------------------------
    %%Function: DurBorderFromDnodeInside
    %%Contact: igorzv
Parameters:
	plsdn	-	(IN) dnode inside borders 
----------------------------------------------------------------------------*/
long DurBorderFromDnodeInside(PLSDNODE plsdn) /* IN: dnode inside borders */
	{
	PLSDNODE plsdnBorder = plsdn;
	while (!FIsDnodeBorder(plsdnBorder))
		{
		plsdnBorder = plsdnBorder->plsdnPrev;
		Assert(FIsLSDNODE(plsdnBorder));
		}
	
	Assert(FIsDnodeBorder(plsdnBorder));
	Assert(plsdnBorder->fOpenBorder);
				
	return plsdnBorder->u.pen.dur;
				
	}

/* ---------------------------------------------------------------------- */

/*  F  S P A C E S  O N L Y*/
/*----------------------------------------------------------------------------
    %%Function: FSpacesOnly
    %%Contact: igorzv
Parameters:
	plsdn	-	(IN) dnode 
	iObjText-	(IN) id for text dnode 
----------------------------------------------------------------------------*/
BOOL FSpacesOnly(PLSDNODE plsdn, DWORD iObjText)
	{
	DWORD dcpTrailing;
	long durTrailing;

	if (FIsDnodeSplat(plsdn))
		return fTrue;
	else if (FIsDnodeReal(plsdn) 
			 && (IdObjFromDnode(plsdn) == iObjText)
			 && !(plsdn->fTab))
		{
		GetTrailInfoText(PdobjFromDnode(plsdn), plsdn->dcp,
					&dcpTrailing, &durTrailing);	
		if (dcpTrailing == plsdn->dcp)
			return fTrue;
		}
	return fFalse;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\lnutils.c ===
/*   obsolete */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\dispul.c ===
#include "dispul.h"
#include "lsc.h"    
#include "lsdnode.h"
#include "lstfset.h"
#include "lsulinfo.h"
#include "lsstinfo.h"
#include "dninfo.h"
#include "dispmisc.h"

#include "zqfromza.h"


/* GetULMetric output */
typedef struct {
    UINT kul;                   
    DWORD cNumberOfLines;       
    __int64 dvpUnderlineOriginOffset;       
    __int64 dvpFirstUnderlineOffset;    
    __int64 dvpFirstUnderlineSize;      
    __int64 dvpGapBetweenLines;     
    __int64 dvpSecondUnderlineSize; 
} ULMETRIC;

/* weighted sums for averaging */
typedef struct {
    __int64 dupSum;                     // the sum of weights
    
    __int64 dvpFirstUnderlineOffset;        // unnormalized values -
    __int64 dvpFirstUnderlineSize;      
    __int64 dvpGapBetweenLines;         // divide them by dupSum    
    __int64 dvpSecondUnderlineSize;     // to get weighted averages
} ULMETRICSUM;

//    %%Function:   InitULMetricSums
//    %%Contact:    victork
//
// Neighbouring dnodes with good metrics and same baseline get averaged.
// We use weighted average with dnode width for weights.
// If the first dnode to participate in averaging happens to have zero width (almost never),
// we arbitrarily change width to 1. This hack changes result very slightly and in a very rare case,
// but simplify the logic considerably.

static void InitULMetricSums(long dup, const ULMETRIC* pulm, ULMETRICSUM* pulmSum)
{
    Assert(dup >= 0);
    
    if (dup == 0)
        {
        dup = 1;
        }
    pulmSum->dvpFirstUnderlineOffset = Mul64 (pulm->dvpFirstUnderlineOffset, dup);
    pulmSum->dvpFirstUnderlineSize = Mul64 (pulm->dvpFirstUnderlineSize, dup);
    pulmSum->dvpGapBetweenLines = Mul64 (pulm->dvpGapBetweenLines, dup);
    pulmSum->dvpSecondUnderlineSize = Mul64 (pulm->dvpSecondUnderlineSize, dup);

    pulmSum->dupSum = dup;
}

//    %%Function:   AddToULMetricSums
//    %%Contact:    victork
//
static void AddToULMetricSums(long dup, const ULMETRIC* pulm, ULMETRICSUM* pulmSum)
{
    Assert(dup >= 0);
    
    /* Add to running sums */

    pulmSum->dvpFirstUnderlineOffset += Mul64 (pulm->dvpFirstUnderlineOffset, dup);
    pulmSum->dvpFirstUnderlineSize += Mul64 (pulm->dvpFirstUnderlineSize, dup);
    pulmSum->dvpGapBetweenLines += Mul64 (pulm->dvpGapBetweenLines, dup);
    pulmSum->dvpSecondUnderlineSize += Mul64 (pulm->dvpSecondUnderlineSize, dup);

    pulmSum->dupSum += dup;
}

//    %%Function:   GetAveragedMetrics
//    %%Contact:    victork
//
static void GetAveragedMetrics(const ULMETRICSUM* pulmSum, LSULMETRIC* pulm)
{
    __int64 dupSum = pulmSum->dupSum;
    
    Assert(dupSum > 0);
    
    /* divide by sum of weights */
    
    pulm->dvpFirstUnderlineOffset = (long) Div64 (pulmSum->dvpFirstUnderlineOffset + Div64 (dupSum, 2), dupSum);
    pulm->dvpFirstUnderlineSize = (long) Div64 (pulmSum->dvpFirstUnderlineSize + Div64 (dupSum, 2), dupSum);
    pulm->dvpGapBetweenLines = (long) Div64 (pulmSum->dvpGapBetweenLines + Div64 (dupSum, 2), dupSum);
    pulm->dvpSecondUnderlineSize = (long) Div64 (pulmSum->dvpSecondUnderlineSize + Div64 (dupSum, 2), dupSum);

    Assert (pulm->dvpFirstUnderlineOffset == Div64 (pulmSum->dvpFirstUnderlineOffset + Div64 (dupSum, 2), dupSum));
    Assert (pulm->dvpFirstUnderlineSize == Div64 (pulmSum->dvpFirstUnderlineSize + Div64 (dupSum, 2), dupSum));
    Assert (pulm->dvpGapBetweenLines == Div64 (pulmSum->dvpGapBetweenLines + Div64 (dupSum, 2), dupSum));
    Assert (pulm->dvpSecondUnderlineSize == Div64 (pulmSum->dvpSecondUnderlineSize + Div64 (dupSum, 2), dupSum));
}

//    %%Function:   GetULMetric
//    %%Contact:    victork
//
/*
 *      Normally, when underlining goes on the under (negative, descent) side,
 *          dvpFirstUnderlineOffset >= 0.
 *      However, underlining on the other side is possible too, (vertical Japanese)
 *
 *      Notice that offsets are from dnode baseline, not from the current baseline, so
 *      underline can be both above current baseline and on the under side for raised dnodes.
 *
 *      We have to be compatible with Word meaning what's good for him should be good for us (pity).
 *      For example, Word sometimes allow the lower UL to be below descent.
 */

static LSERR GetULMetric(PLSC plsc, PLSDNODE pdn, LSTFLOW lstflow,
                        BOOL* pfUnderlineFromBelow, ULMETRIC* pulm, BOOL *pfGood)
{
    LSULINFO lsulinfo;
    LSERR   lserr;
    long    dvpUnderlineLim;

    lserr = (*plsc->lscbk.pfnGetRunUnderlineInfo)(plsc->pols, pdn->u.real.plsrun,
                                                    &(pdn->u.real.objdim.heightsPres), lstflow,
                                                    &lsulinfo);
    if (lserr != lserrNone) return lserr;

    pulm->kul = lsulinfo.kulbase;
    pulm->cNumberOfLines = lsulinfo.cNumberOfLines;
    
    pulm->dvpFirstUnderlineSize = lsulinfo.dvpFirstUnderlineSize;

    *pfUnderlineFromBelow = (lsulinfo.dvpFirstUnderlineOffset >= lsulinfo.dvpUnderlineOriginOffset);

    if (*pfUnderlineFromBelow)
        {
        pulm->dvpFirstUnderlineOffset = lsulinfo.dvpFirstUnderlineOffset;
        pulm->dvpUnderlineOriginOffset = lsulinfo.dvpUnderlineOriginOffset;
        dvpUnderlineLim = pdn->u.real.objdim.heightsPres.dvDescent + pdn->u.real.lschp.dvpPos;
        }
    else
        {
        pulm->dvpFirstUnderlineOffset = -lsulinfo.dvpFirstUnderlineOffset;
        pulm->dvpUnderlineOriginOffset = -lsulinfo.dvpUnderlineOriginOffset;
        dvpUnderlineLim = pdn->u.real.objdim.heightsPres.dvAscent + 1 - pdn->u.real.lschp.dvpPos;
        }

    *pfGood = pulm->dvpFirstUnderlineSize > 0 &&
                (dvpUnderlineLim == 0 || pulm->dvpFirstUnderlineOffset < dvpUnderlineLim);
    
    if (lsulinfo.cNumberOfLines == 2)
        {
        pulm->dvpGapBetweenLines = lsulinfo.dvpGapBetweenLines;
        pulm->dvpSecondUnderlineSize = lsulinfo.dvpSecondUnderlineSize;
        
        *pfGood = *pfGood && pulm->dvpSecondUnderlineSize > 0;
        }
    else
    	{
    	Assert (lsulinfo.cNumberOfLines == 1);
    	
        pulm->dvpGapBetweenLines = 0;
        pulm->dvpSecondUnderlineSize = 0;
        };
   	   

    if (!*pfGood)
        {
        pulm->dvpUnderlineOriginOffset = 0;     // to provide good input to DrawUnderlineAsText
        }

    // dvpFirstUnderlineOffset was relative to local baseline until this moment, it is relative
    //  to the UnderlineOrigin from now on. (because we average runs with the same UnderlineOrigin)
    pulm->dvpFirstUnderlineOffset -= pulm->dvpUnderlineOriginOffset;

	// The notion of bad metrics was introduced in Word to deal with particular, now obsolete, printers.
	// Word doesn't support them any more, other clients never cared about them.
	// We drop the support for them now too.
	// The assignment below makes a lot of code in dispul.c and dispmain.c unneeded or unreachable.
	// Callback pfnDrawUnderlineAsText will never be called now. Input parameter fUnderline to 
	// pfnDrawTextRun is now always False.
	// Now is not the time to make big changes, maybe later.
	
	*pfGood = fTrue;
    
    return lserrNone;
}

//    %%Function:   GetUnderlineOrigin
//    %%Contact:    victork
//
/* normal and raised text are in the same group, lowered texts doesn't mix */

// Note: dvpUnderlineOriginOffset is relative to the local baseline, positive means down the page
//          in case of fUnderlineFromBelow - bigger means lower.
// dvpUnderlineOrigin is relative to the current baseline, negative means down the page
//          in case of fUnderlineFromBelow - bigger means higher (sign changed).
//
static void GetUnderlineOrigin(PLSDNODE pdn, BOOL fUnderlineFromBelow, long dvpUnderlineOriginOffset,
                            long* pdvpSubscriptOffset, long* pdvpUnderlineOrigin)

{
    if (fUnderlineFromBelow)
        {
        *pdvpSubscriptOffset = pdn->u.real.lschp.dvpPos;
        *pdvpUnderlineOrigin = pdn->u.real.lschp.dvpPos - dvpUnderlineOriginOffset;
        }
    else
        {
        *pdvpSubscriptOffset = -pdn->u.real.lschp.dvpPos;
        *pdvpUnderlineOrigin = -pdn->u.real.lschp.dvpPos - dvpUnderlineOriginOffset;
        }
        
    if (*pdvpSubscriptOffset > 0)
        {
        *pdvpSubscriptOffset = 0;       // put all superscripts in the baseline group
        }
    
    return;
}

//    %%Function:   GetUnderlineMergeMetric
//    %%Contact:    victork
//
/* For aesthetics, we try to underline dnodes (typically text) on the same side of
    the baseline (normal text and superscripts are considered to be on the
    same side of the baseline, versus subscripts, which are on the other side) with one
    continuous underline in even thickness. The underline metric used is the
    average from all those dnodes which are at the lowest height in the
    merge group. Merge is sometimes not possible because some dnodes may have
    bad underline metric. The following rules describe the merge decision
    under all possible scenarios. The dnodes in question are all on the same
    side of the baseline, i.e, there is never a merge of underline if it involes
    crossing the baseline.

Rules for merging underlined dnodes on the same side of the baseline

A. current: good Metric, new dnode: good metric
                                Merge?      Metric Used
    new dnode same height   :   yes         average
    new dnode lower         :   yes         new dnode
    new dnode higher        :   yes         current

B. current: good Metric, new dnode: bad metric
                                Merge?      Metric Used
    new dnode same height   :   no
    new dnode lower         :   no
    new dnode higher        :   yes         current

C. current: bad Metric, new dnode: good metric
                                Merge?      Metric Used
    new dnode same height   :   no
    new dnode lower         :   yes         new dnode
    new dnode higher        :   no

B. current: bad Metric, new dnode: bad metric
                                Merge?      Metric Used (baseline only)
    new dnode same height   :   no
    new dnode lower         :   yes         new dnode
    new dnode higher        :   yes         current

*/
LSERR GetUnderlineMergeMetric(PLSC plsc, PLSDNODE pdn, POINTUV pt, long upLimUnderline,
                    LSTFLOW lstflow, LSCP cpLimBreak, LSULMETRIC* pulmMerge, int* pcdnodes, BOOL* pfGoodMerge)
{
    LSERR       lserr;
    
    long        dupNew;
    long        dvpUnderlineOriginMerge, dvpUnderlineOriginNew;
    long        dvpSubscriptOffsetNew, dvpSubscriptOffsetMerge;
    BOOL        fGoodNew;
    BOOL        fUnderlineFromBelowMerge, fUnderlineFromBelowNew;
    ULMETRIC    ulm;
    ULMETRICSUM ulmSum;
    UINT        kulMerge;               
    DWORD       cNumberOfLinesMerge;

    lserr = GetULMetric(plsc, pdn, lstflow, &fUnderlineFromBelowMerge, &ulm, pfGoodMerge);
    if (lserr != lserrNone) return lserr;

    *pcdnodes = 1;  /* Counter for number of dnodes participationg in UL merge */
        
    kulMerge = ulm.kul;
    cNumberOfLinesMerge = ulm.cNumberOfLines;

    /* Initialize running sums with current dnode */
    dupNew = pdn->u.real.dup;
    InitULMetricSums(dupNew, &ulm, &ulmSum);

    GetUnderlineOrigin(pdn, fUnderlineFromBelowMerge, (long)ulm.dvpUnderlineOriginOffset,
                        &dvpSubscriptOffsetMerge, &dvpUnderlineOriginMerge);
        
    /* March down display list to collect merge participants */
    pdn = AdvanceToNextDnode(pdn, lstflow, &pt);


    /* Iterate till end of list, or end of UL */
    while (FDnodeBeforeCpLim(pdn, cpLimBreak)
            && pdn->klsdn == klsdnReal
            && !pdn->u.real.lschp.fInvisible
            && pdn->u.real.lschp.fUnderline && pt.u < upLimUnderline
            )
        {   
        /* loop invariance:
         *  *pcdnodes are merged already, merge ends at pt.u,
         *  dvpUnderlineOriginMerge reflect lowest dnode in merge group,
         *  other variables ending with Merge - other Merge info
         *  ulmSum contains ulm info of Merge, entries in it are not normalized yet.
         */

        lserr = GetULMetric(plsc, pdn, lstflow, &fUnderlineFromBelowNew, &ulm, &fGoodNew);
        if (lserr != lserrNone) return lserr;

        /* break if new dnode has different underline type or position */
        
        GetUnderlineOrigin(pdn, fUnderlineFromBelowNew, (long)ulm.dvpUnderlineOriginOffset,
                                &dvpSubscriptOffsetNew, &dvpUnderlineOriginNew);

        if (ulm.kul != kulMerge ||
                ulm.cNumberOfLines != cNumberOfLinesMerge ||
                dvpSubscriptOffsetNew != dvpSubscriptOffsetMerge ||
                fUnderlineFromBelowNew != fUnderlineFromBelowMerge)
            {
            break;
            }

        /* Type and position are the same - try to extend merge */
        
        dupNew = pdn->u.real.dup;

        if (dvpUnderlineOriginNew < dvpUnderlineOriginMerge)    
            {                                   /* new dnode lower - previous metrics is irrelevant     */
            if (*pfGoodMerge && !fGoodNew)
                break;                          /* except we won't change from good to bad          */

            dvpUnderlineOriginMerge = dvpUnderlineOriginNew;
            *pfGoodMerge = fGoodNew;
            if (fGoodNew)                       /* New good metrics - */
                {                               /* restart running sums from this dnode */      
                InitULMetricSums(dupNew, &ulm, &ulmSum);
                }
            }

        else if (dvpUnderlineOriginNew > dvpUnderlineOriginMerge)
            {                                   /* new dnode higher - new metrics is irrelevant     */
            if (!*pfGoodMerge && fGoodNew)
                break;                          /* except we won't throw away good for bad      */
            }
            /* NB We are not adding contribution of higher dnode to running sums */

        else                                    /* new dnode the same height */
            if (*pfGoodMerge && fGoodNew)
                {
                /* Add contribution of current dnode to running sums */
                AddToULMetricSums(dupNew, &ulm, &ulmSum);
                }
            else                                /* dvpUnderlineOriginNew == dvpUnderlineOriginMerge && */
                break;                          /* !both good */

        /* Advance to next dnode */
        ++*pcdnodes;
        pdn = AdvanceToNextDnode(pdn, lstflow, &pt);
        }


    pulmMerge->kul = kulMerge;
    pulmMerge->cNumberOfLines = cNumberOfLinesMerge;
    
    if (*pfGoodMerge)
        {
        GetAveragedMetrics(&ulmSum, pulmMerge);
        }

    if (!fUnderlineFromBelowMerge)
        {
        pulmMerge->dvpFirstUnderlineOffset = -pulmMerge->dvpFirstUnderlineOffset;
        dvpUnderlineOriginMerge = -dvpUnderlineOriginMerge;
        }

    pulmMerge->vpUnderlineOrigin = pt.v + dvpUnderlineOriginMerge;
    
    return lserrNone;
}

//    %%Function:   DrawUnderlineMerge
//    %%Contact:    victork
//
LSERR DrawUnderlineMerge(PLSC plsc, PLSDNODE pdn, const POINT* pptOrg, int cdnodes, long upUnderlineStart,
                        BOOL fgoodmetric, const LSULMETRIC* pulm, UINT kdispmode,
                        const RECT* prectclip, long upLimUnderline, LSTFLOW lstflow)

{
/*  pdn is the first of cdnodes dnodes, merged and averaged by LSULMetric. Now we cut this merge into
 *  smaller ones if client wants interruption. Merge here means this smaller merge.
 */
    LSERR   lserr;
    POINTUV ptUnderlineStart[2];
    long    dvpUnderlineSize[2];
    long    dup = 0;
    
    BOOL    fInterruptUnderline;
    BOOL    fFirstNode = TRUE;
    PLSRUN  plsrunFirstInMerge, plsrunPrevious, plsrunCurrent = NULL;
    LSCP    cpLastInPrevious, cpFirstInCurrent = 0;
    LSDCP   dcpCurrent = 0;
    
    int     cLines, i;

    POINT   ptXY;
    POINTUV ptDummy = {0,0};
    
    cLines = (fgoodmetric && pulm->cNumberOfLines == 2) ? 2 : 1;

    ptUnderlineStart[0].u = upUnderlineStart;

    if (fgoodmetric)
        ptUnderlineStart[0].v = pulm->vpUnderlineOrigin - pulm->dvpFirstUnderlineOffset;
    else
        ptUnderlineStart[0].v = pulm->vpUnderlineOrigin;

    dvpUnderlineSize[0] = pulm->dvpFirstUnderlineSize;

    if (cLines == 2)
        {
        ptUnderlineStart[1].u = upUnderlineStart;
        ptUnderlineStart[1].v = ptUnderlineStart[0].v - pulm->dvpFirstUnderlineSize -
                                                        pulm->dvpGapBetweenLines;
        dvpUnderlineSize[1] = pulm->dvpSecondUnderlineSize;
        }

    plsrunFirstInMerge = pdn->u.real.plsrun;

    while (cdnodes >= 0)    /* cdnodes is at least 1 coming in */
        {
        Assert(FIsDnodeReal(pdn));
        /* Check to flush out pending UL */
        if (fFirstNode)
            {
            fFirstNode = FALSE;
            fInterruptUnderline = FALSE;
            plsrunCurrent = pdn->u.real.plsrun;
            cpFirstInCurrent = pdn->cpFirst;
            dcpCurrent = pdn->dcp;
            }
        else if (cdnodes != 0)
            {
            plsrunPrevious = plsrunCurrent;
            cpLastInPrevious = cpFirstInCurrent + dcpCurrent - 1;
            plsrunCurrent = pdn->u.real.plsrun;
            cpFirstInCurrent = pdn->cpFirst;
            dcpCurrent = pdn->dcp;
            lserr = (*plsc->lscbk.pfnFInterruptUnderline)(plsc->pols, plsrunPrevious, cpLastInPrevious,
                                plsrunCurrent, cpFirstInCurrent, &fInterruptUnderline);
            if (lserr != lserrNone) return lserr;
            }
        else                                        /* we've come to the last one */
            fInterruptUnderline = TRUE;

        if (fInterruptUnderline)
            {   
            if (ptUnderlineStart[0].u + dup > upLimUnderline)
                {
                dup = upLimUnderline - ptUnderlineStart[0].u;
                }

            Assert(dup >= 0);                       /* upLimUnderline should not change */

            if (fgoodmetric)
                for (i = 0; i < cLines; ++i)
                    {
                    LsPointXYFromPointUV(pptOrg, lstflow, &ptUnderlineStart[i], &ptXY);

                    lserr = (*plsc->lscbk.pfnDrawUnderline)(plsc->pols, plsrunFirstInMerge, pulm->kul,
                                    &ptXY, dup, dvpUnderlineSize[i], lstflow, kdispmode, prectclip);
                    if (lserr != lserrNone) return lserr;
                    }
            else
                {
                LsPointXYFromPointUV(pptOrg, lstflow, &ptUnderlineStart[0], &ptXY);
                
                lserr = (*plsc->lscbk.pfnDrawUnderlineAsText)(plsc->pols, plsrunFirstInMerge, &ptXY,
                                                                dup, kdispmode, lstflow, prectclip);
                if (lserr != lserrNone) return lserr;
                }

            /* reset states to start with current dnode */
            ptUnderlineStart[0].u += dup;
            if (cLines == 2) ptUnderlineStart[1].u += dup;
            dup = 0;
            plsrunFirstInMerge = pdn->u.real.plsrun;
            }
            
        dup += pdn->u.real.dup;
        --cdnodes;
        if (cdnodes > 0)
            {
            pdn = AdvanceToNextDnode(pdn, lstflow, &ptDummy);
            }
        }
    return lserrNone;
}

//    %%Function:   GetStrikeMetric
//    %%Contact:    victork
//
LSERR GetStrikeMetric(PLSC plsc, PLSDNODE pdn, LSTFLOW lstflow, LSSTRIKEMETRIC* pstm, BOOL* pfgood)
{
    LSSTINFO lsstinfo;
    LSERR lserr;
    long dvpAscent = pdn->u.real.objdim.heightsPres.dvAscent;               // dvpUppermost
    long dvpDescent = -pdn->u.real.objdim.heightsPres.dvDescent + 1;        // dvpLowest

    lserr = (*plsc->lscbk.pfnGetRunStrikethroughInfo)(plsc->pols, pdn->u.real.plsrun,
                                        &(pdn->u.real.objdim.heightsPres), lstflow, &lsstinfo);
    if (lserr != lserrNone) return lserr;

    pstm->cNumberOfLines = lsstinfo.cNumberOfLines;
    pstm->kul = lsstinfo.kstbase;

    if (lsstinfo.cNumberOfLines == 2)
        {
        *pfgood = lsstinfo.dvpLowerStrikethroughOffset  >= dvpDescent
                && lsstinfo.dvpLowerStrikethroughSize  > 0
                && lsstinfo.dvpUpperStrikethroughOffset > lsstinfo.dvpLowerStrikethroughOffset  + lsstinfo.dvpLowerStrikethroughSize
                && lsstinfo.dvpUpperStrikethroughSize > 0
                && lsstinfo.dvpUpperStrikethroughOffset + lsstinfo.dvpUpperStrikethroughSize <= dvpAscent;
        if (*pfgood)
            {
            pstm->dvp1stSSSize = lsstinfo.dvpLowerStrikethroughSize;
            pstm->dvp1stSSOffset = lsstinfo.dvpLowerStrikethroughOffset;
            pstm->dvp2ndSSSize = lsstinfo.dvpUpperStrikethroughSize;
            pstm->dvp2ndSSOffset = lsstinfo.dvpUpperStrikethroughOffset;
            }
        }
    else
        {
        *pfgood = lsstinfo.dvpLowerStrikethroughOffset  >= dvpDescent
                && lsstinfo.dvpLowerStrikethroughSize  > 0
                && lsstinfo.dvpLowerStrikethroughOffset  + lsstinfo.dvpLowerStrikethroughSize  <= dvpAscent;
        if (*pfgood)
            {
            pstm->dvp1stSSSize = lsstinfo.dvpLowerStrikethroughSize;
            pstm->dvp1stSSOffset = lsstinfo.dvpLowerStrikethroughOffset;
            }
        }
    return lserrNone;
}

//    %%Function:   StrikeDnode
//    %%Contact:    victork
//
LSERR StrikeDnode(PLSC plsc, PLSDNODE pdn, const POINT* pptOrg, POINTUV pt, const LSSTRIKEMETRIC* pstm,
                    UINT kdispmode, const RECT* prectclip, long upLimUnderline, LSTFLOW lstflow)
{

    LSERR lserr = lserrNone;
    
    long    dup;
    POINT   ptXY;


    if (pt.u < upLimUnderline)
        {
        dup = pdn->u.real.dup;
        if (pt.u + dup > upLimUnderline) dup = upLimUnderline - pt.u;

        pt.v += pdn->u.real.lschp.dvpPos + pstm->dvp1stSSOffset;
        LsPointXYFromPointUV(pptOrg, lstflow, &pt, &ptXY);
        
        lserr = (*plsc->lscbk.pfnDrawStrikethrough)(plsc->pols, pdn->u.real.plsrun, pstm->kul,
                            &ptXY, dup, pstm->dvp1stSSSize, lstflow, kdispmode, prectclip);

        if (lserr == lserrNone && pstm->cNumberOfLines == 2)
            {
            pt.v += pstm->dvp2ndSSOffset - pstm->dvp1stSSOffset;
            LsPointXYFromPointUV(pptOrg, lstflow, &pt, &ptXY);
            
            lserr = (*plsc->lscbk.pfnDrawStrikethrough)(plsc->pols, pdn->u.real.plsrun, pstm->kul,
                                &ptXY, dup, pstm->dvp2ndSSSize, lstflow, kdispmode, prectclip);
            }
        }

    return lserr;

}

// Note:    Lstfow and BiDi
// Lstfow used in this file is always lstflow of the main subline.
// It doesn't matter if no sublines are submitted and looks logical for submitted dnodes.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\lscontxt.c ===
#include "lsidefs.h"
#include "pilsobj.h"
#include "plsline.h"
#include "lstext.h"
#include "lscbk.h"
#include "lsc.h"
#include "lscontxt.h"
#include "limqmem.h"
#include "qheap.h"
#include "lsline.h"
#include "lsdnode.h"
#include "iobj.h"
#include "chnutils.h"
#include "autonum.h"

#include "lsmem.h"						/* memset() */



static LSERR CannotCreateLsContext(PLSC, LSERR);
static LSERR  InitObject(PLSC plsc, DWORD iobj, const LSIMETHODS* plsim);
static LSERR RemoveContextObjects(PLSC plsc);

#ifdef DEBUG
#ifdef LSTEST_ASSERTSTOP

/* We use it to run debug LS with ship build of WORD */

int nZero = 0;

void AssertFailedStop (char* pzstrMsg, char* pzstrFile, int nLine)
{
	Unreferenced (pzstrMsg);
	Unreferenced (pzstrFile);
	Unreferenced (nLine);

	nZero = nZero / nZero;

	return;
}

#endif
#endif


/* L S  C R E A T E  C O N T E X T */
/*----------------------------------------------------------------------------
    %%Function: LsCreateContext
    %%Contact: igorzv

Parameters:
	plsci 		-   (IN) structure which contains clients setings
	pplsc		-   (OUT) pointer to created contexts (opaque to clients)

    Creates a Line Services context.
	Typically called once, at the beginning of time.
----------------------------------------------------------------------------*/
LSERR WINAPI LsCreateContext(const LSCONTEXTINFO* plsci, PLSC* pplsc)
{
	static LSIMETHODS const lsimText = 
	{
		CreateILSObjText,
		DestroyILSObjText,
		SetDocText,
		CreateLNObjText,
		DestroyLNObjText,
		FmtText,
		NULL,
		NULL,         
		NULL,
		TruncateText,
		FindPrevBreakText,
		FindNextBreakText,
		ForceBreakText,
		SetBreakText,
		NULL,
		NULL,
		NULL,
		CalcPresentationText,
		QueryPointPcpText,
		QueryCpPpointText,
		EnumObjText,
		DisplayText,
		DestroyDObjText,
	};

	static LSIMETHODS const lsimAutonum = 
	{
		AutonumCreateILSObj,
		AutonumDestroyILSObj,
		AutonumSetDoc,
		AutonumCreateLNObj,
		AutonumDestroyLNObj,
		AutonumFmt,
		NULL,
		NULL,         
		NULL,
		AutonumTruncateChunk,
		AutonumFindPrevBreakChunk,
		AutonumFindNextBreakChunk,
		AutonumForceBreakChunk,
		AutonumSetBreak,
		AutonumGetSpecialEffectsInside,
		NULL,
		NULL,
		AutonumCalcPresentation,
		AutonumQueryPointPcp,
		AutonumQueryCpPpoint,
		AutonumEnumerate,
		AutonumDisplay,
		AutonumDestroyDobj,
	};

	DWORD const iobjText = plsci->cInstalledHandlers;
	DWORD const iobjAutonum = plsci->cInstalledHandlers + 1; 
	DWORD const iobjMac = iobjText + 2;
	POLS const pols = plsci->pols;
	const LSIMETHODS* const plsim = plsci->pInstalledHandlers;

	DWORD iobj;
	PLSC plsc;
	LSERR lserr;
	

#ifdef DEBUG
#ifdef LSTEST_ASSERTSTOP

	/* We use this option when run debug LS with ship WORD */

	pfnAssertFailed = AssertFailedStop;

#else

    pfnAssertFailed = plsci->lscbk.pfnAssertFailed;

#endif
#endif

	if (pplsc == NULL)
		return lserrNullOutputParameter;

	*pplsc = NULL;

	/* Allocate memory for the context and clean it
	 */
	plsc = plsci->lscbk.pfnNewPtr(pols, cbRep(struct lscontext, lsiobjcontext.rgobj, iobjMac));
	if (plsc == NULL)
		return lserrOutOfMemory;
	memset(plsc, 0, cbRep(struct lscontext, lsiobjcontext.rgobj, iobjMac)); 

	/* Initialize the fixed-size part of the context
	 */
	plsc->tag = tagLSC;
	plsc->pols = pols;
	plsc->lscbk = plsci->lscbk;
	plsc->fDontReleaseRuns = plsci->fDontReleaseRuns;
	

	plsc->cLinesActive = 0;
	plsc->plslineCur = NULL;

	plsc->lsstate = LsStateCreatingContext;

	plsc->pqhLines = CreateQuickHeap(plsc, limLines,
									 cbRep(struct lsline, rgplnobj, iobjMac), fFalse);
	plsc->pqhAllDNodesRecycled = CreateQuickHeap(plsc, limAllDNodes,
										 sizeof (struct lsdnode), fTrue);
	if (plsc->pqhLines == NULL || plsc->pqhAllDNodesRecycled == NULL )
		{
		return CannotCreateLsContext(plsc, lserrOutOfMemory);
		}


	/* create arrays for chunks  */
	lserr = AllocChunkArrays(&plsc->lschunkcontextStorage, &plsc->lscbk, plsc->pols,
		&plsc->lsiobjcontext);
	if (lserr != lserrNone)
		return CannotCreateLsContext(plsc, lserr);


	/* create array for tabs  */
	plsc->lstabscontext.pcaltbd = plsci->lscbk.pfnNewPtr(pols, 
											sizeof(LSCALTBD)*limCaltbd);

	plsc->lstabscontext.ccaltbdMax = limCaltbd;

	if (plsc->lstabscontext.pcaltbd == NULL )
		{
		return CannotCreateLsContext(plsc, lserrOutOfMemory);
		}

	/*  set links in lstabscontext */
	plsc->lstabscontext.plscbk = &plsc->lscbk;
	plsc->lstabscontext.pols = plsc->pols;
	plsc->lstabscontext.plsdocinf = &plsc->lsdocinf;


	/* ****************************************************************** */
	/* Initialize the "static" array part of the context
	 * "Text" is the last element of the array
	 */
	plsc->lsiobjcontext.iobjMac = iobjMac;
	for (iobj = 0;  iobj < iobjText;  iobj++)
		{
		lserr = InitObject(plsc, iobj, &plsim[iobj]);
		if (lserr != lserrNone)
			return CannotCreateLsContext(plsc, lserr);
		}

	lserr = InitObject(plsc, iobjText, &lsimText);
	if (lserr != lserrNone)
		return CannotCreateLsContext(plsc, lserr);

	/* Set text Config				*/
	lserr = SetTextConfig(PilsobjFromLsc(&plsc->lsiobjcontext, iobjText), &(plsci->lstxtcfg));
	if (lserr != lserrNone)
		return CannotCreateLsContext(plsc, lserr);

	lserr = InitObject(plsc, iobjAutonum, &lsimAutonum);
	if (lserr != lserrNone)
		return CannotCreateLsContext(plsc, lserr);

	/* Set text Config				*/
	lserr = SetAutonumConfig(PilsobjFromLsc(&plsc->lsiobjcontext, iobjAutonum), 
					&(plsci->lstxtcfg));
	if (lserr != lserrNone)
		return CannotCreateLsContext(plsc, lserr);


	plsc->lsstate = LsStateNotReady;  /* nobody can use context before LsSetDoc  */


	/* we set other variavles by memset, bellow we check that we get what we want  */
	Assert(plsc->cLinesActive == 0);
	Assert(plsc->plslineCur == NULL);
	Assert(plsc->fIgnoreSplatBreak == 0);
	Assert(plsc->fLimSplat == fFalse);
	Assert(plsc->fHyphenated == fFalse);
	Assert(plsc->fAdvanceBack == fFalse);
	Assert(plsc->grpfManager == 0);
	Assert(plsc->urRightMarginBreak == 0);
	Assert(plsc->lMarginIncreaseCoefficient == 0);


	Assert(plsc->lsdocinf.fDisplay == fFalse);
	Assert(plsc->lsdocinf.fPresEqualRef == fFalse);
	Assert(plsc->lsdocinf.lsdevres.dxpInch == 0);
	Assert(plsc->lsdocinf.lsdevres.dxrInch == 0);
	Assert(plsc->lsdocinf.lsdevres.dypInch == 0);
	Assert(plsc->lsdocinf.lsdevres.dyrInch == 0);

	Assert(plsc->lstabscontext.fTabsInitialized == fFalse);
	Assert(plsc->lstabscontext.durIncrementalTab == 0);
	Assert(plsc->lstabscontext.urBeforePendingTab == 0);
	Assert(plsc->lstabscontext.plsdnPendingTab == NULL);
	Assert(plsc->lstabscontext.icaltbdMac == 0);
	Assert(plsc->lstabscontext.urColumnMax == 0);
	Assert(plsc->lstabscontext.fResolveTabsAsWord97 == fFalse);

	Assert(plsc->lsadjustcontext.fLineCompressed == fFalse);
	Assert(plsc->lsadjustcontext.fLineContainsAutoNumber == fFalse);
	Assert(plsc->lsadjustcontext.fUnderlineTrailSpacesRM == fFalse);
	Assert(plsc->lsadjustcontext.fForgetLastTabAlignment == fFalse);
	Assert(plsc->lsadjustcontext.fNominalToIdealEncounted == fFalse);
	Assert(plsc->lsadjustcontext.fForeignObjectEncounted == fFalse);
	Assert(plsc->lsadjustcontext.fTabEncounted == fFalse);
	Assert(plsc->lsadjustcontext.fNonLeftTabEncounted == fFalse);
	Assert(plsc->lsadjustcontext.fSubmittedSublineEncounted == fFalse);
	Assert(plsc->lsadjustcontext.fAutodecimalTabPresent == fFalse);
	Assert(plsc->lsadjustcontext.lskj == lskjNone);
	Assert(plsc->lsadjustcontext.lskalign == lskalLeft);
	Assert(plsc->lsadjustcontext.lsbrj == lsbrjBreakJustify);
	Assert(plsc->lsadjustcontext.urLeftIndent == 0);
	Assert(plsc->lsadjustcontext.urStartAutonumberingText == 0);
	Assert(plsc->lsadjustcontext.urStartMainText == 0);
	Assert(plsc->lsadjustcontext.urRightMarginJustify == 0);

	Assert(plsc->lschunkcontextStorage.FChunkValid == fFalse);
	Assert(plsc->lschunkcontextStorage.FLocationValid == fFalse);
	Assert(plsc->lschunkcontextStorage.FGroupChunk == fFalse);
	Assert(plsc->lschunkcontextStorage.FBorderInside == fFalse);
	Assert(plsc->lschunkcontextStorage.grpfTnti == 0);
	Assert(plsc->lschunkcontextStorage.fNTIAppliedToLastChunk == fFalse);
	Assert(plsc->lschunkcontextStorage.locchnkCurrent.clschnk == 0);
	Assert(plsc->lschunkcontextStorage.locchnkCurrent.lsfgi.fFirstOnLine == fFalse);
	Assert(plsc->lschunkcontextStorage.locchnkCurrent.lsfgi.cpFirst == fFalse);
	Assert(plsc->lschunkcontextStorage.locchnkCurrent.lsfgi.urPen == 0);
	Assert(plsc->lschunkcontextStorage.locchnkCurrent.lsfgi.vrPen == 0);
	Assert(plsc->lschunkcontextStorage.locchnkCurrent.lsfgi.urColumnMax == 0);
	Assert(plsc->lschunkcontextStorage.locchnkCurrent.lsfgi.lstflow == 0);


	Assert(plsc->lslistcontext.plsdnToFinish == NULL);
	Assert(plsc->lslistcontext.plssublCurrent == NULL);
	Assert(plsc->lslistcontext.nDepthFormatLineCurrent == 0);

	/* Everything worked, so set the output parameter and return success
	 */
	*pplsc = plsc;
	return lserrNone;
}

/* C A N N O T  C R E A T E  L S  C O N T E X T */
/*----------------------------------------------------------------------------
    %%Function: CannotCreateLsContext
    %%Contact: igorzv

Parameters:
	plsc		-	partually created context
	lseReturn 	-	error code

    Utility function called when an error occurs when an LSC is
	partially created.
----------------------------------------------------------------------------*/
static LSERR CannotCreateLsContext(PLSC plsc, LSERR lseReturn)
{
	plsc->lsstate = LsStateFree;   /* otherwise destroy will not work */
	(void) LsDestroyContext(plsc);
	return lseReturn;
}




/* L S  D E S T R O Y  C O N T E X T */
/*----------------------------------------------------------------------------
    %%Function: LsDestroyContext
    %%Contact: igorzv

Parameters:
	plsc		-	(IN) ptr to line services context 

    Frees all resources associated with a Line Services context,
	which was created by CreateLsContext.
----------------------------------------------------------------------------*/

LSERR WINAPI LsDestroyContext(PLSC plsc) 
{
	LSERR lserr = lserrNone;

	if (plsc != NULL)
		{
		if (!FIsLSC(plsc))
			return lserrInvalidContext;

		if (plsc->cLinesActive != 0 || FIsLSCBusy(plsc))
			return lserrContextInUse;

		plsc->lsstate = LsStateDestroyingContext;

		DestroyQuickHeap(plsc->pqhLines);
		Assert(plsc->pqhAllDNodesRecycled != NULL);
		DestroyQuickHeap(plsc->pqhAllDNodesRecycled);

		DisposeChunkArrays(&plsc->lschunkcontextStorage);
		
		plsc->lscbk.pfnDisposePtr(plsc->pols, plsc->lstabscontext.pcaltbd);


		lserr = RemoveContextObjects(plsc);


		plsc->tag = tagInvalid;
		plsc->lscbk.pfnDisposePtr(plsc->pols, plsc);
		}

	return lserr;
}

 static LSERR  InitObject(PLSC plsc, DWORD iobj, const LSIMETHODS* plsim)
{
	struct OBJ *pobj;
	LSERR lserr;
	
	Assert(FIsLSC(plsc));
	Assert(plsc->lsstate == LsStateCreatingContext);
	Assert(iobj < plsc->lsiobjcontext.iobjMac);

	pobj = &(plsc->lsiobjcontext.rgobj[iobj]);
	pobj->lsim = *plsim;
	Assert(pobj->pilsobj == NULL); 

	lserr = pobj->lsim.pfnCreateILSObj(plsc->pols, plsc, &(plsc->lscbk), iobj, &(pobj->pilsobj));
	if (lserr != lserrNone)
		{
		if (pobj->pilsobj != NULL)
			{
			pobj->lsim.pfnDestroyILSObj(pobj->pilsobj);
			pobj->pilsobj = NULL;
			}
		return lserr;
		}

	return lserrNone;   
	
}
/* R E M O V E  C O N T E X T  O B J E C T S */
/*----------------------------------------------------------------------------
    %%Function: RemoveContextObjects
    %%Contact: igorzv
Parameter:
	plsc		-	(IN) ptr to line services context 

    Removes a set of installed objects from an LSC.
	Destroy all ilsobj 
----------------------------------------------------------------------------*/
LSERR RemoveContextObjects(PLSC plsc)
{
	DWORD iobjMac;
	LSERR lserr, lserrFinal = lserrNone;
	DWORD iobj;
	PILSOBJ pilsobj;

	Assert(FIsLSC(plsc));
	Assert(plsc->lsstate == LsStateDestroyingContext);

	iobjMac = plsc->lsiobjcontext.iobjMac;
	
	for (iobj = 0;  iobj < iobjMac;  iobj++)
		{
		pilsobj = plsc->lsiobjcontext.rgobj[iobj].pilsobj;
		if (pilsobj != NULL)
			{
			lserr = plsc->lsiobjcontext.rgobj[iobj].lsim.pfnDestroyILSObj(pilsobj);
			plsc->lsiobjcontext.rgobj[iobj].pilsobj = NULL;
			if (lserr != lserrNone)
				lserrFinal = lserr;
			}
		}

	return lserrFinal;	
}


#ifdef DEBUG
/* F  I S  L S C O N T E X T   V A L I D*/
/*----------------------------------------------------------------------------
    %%Function: FIsLsContextValid
    %%Contact: igorzv

Parameters:
	plsc		-	(IN) ptr to line services context 

this function verify that nobody spoiled context, all reasonable integrity checks 
should be here 																		
----------------------------------------------------------------------------*/


BOOL FIsLsContextValid(PLSC plsc)
{
	DWORD iobjText = IobjTextFromLsc(&plsc->lsiobjcontext);
	Assert(plsc->lsiobjcontext.rgobj[iobjText].lsim.pfnCreateILSObj ==CreateILSObjText);
	Assert(plsc->lsiobjcontext.rgobj[iobjText].lsim.pfnDestroyILSObj == DestroyILSObjText);
	Assert(plsc->lsiobjcontext.rgobj[iobjText].lsim.pfnSetDoc == SetDocText);
	Assert(plsc->lsiobjcontext.rgobj[iobjText].lsim.pfnCreateLNObj == CreateLNObjText);
	Assert(plsc->lsiobjcontext.rgobj[iobjText].lsim.pfnDestroyLNObj == DestroyLNObjText);
	Assert(plsc->lsiobjcontext.rgobj[iobjText].lsim.pfnTruncateChunk == TruncateText);
	Assert(plsc->lsiobjcontext.rgobj[iobjText].lsim.pfnFindPrevBreakChunk == FindPrevBreakText);
	Assert(plsc->lsiobjcontext.rgobj[iobjText].lsim.pfnFindNextBreakChunk == FindNextBreakText);
	Assert(plsc->lsiobjcontext.rgobj[iobjText].lsim.pfnForceBreakChunk == ForceBreakText);
	Assert(plsc->lsiobjcontext.rgobj[iobjText].lsim.pfnDisplay == DisplayText);
	Assert(plsc->lsiobjcontext.rgobj[iobjText].lsim.pfnQueryPointPcp == QueryPointPcpText);
	Assert(plsc->lsiobjcontext.rgobj[iobjText].lsim.pfnQueryCpPpoint == QueryCpPpointText);
	Assert(plsc->lsiobjcontext.rgobj[iobjText].lsim.pfnDestroyDObj == DestroyDObjText);
	Assert(plsc->lschunkcontextStorage.pcont != NULL);
	Assert(plsc->lschunkcontextStorage.pplsdnChunk != NULL);
	Assert(plsc->lschunkcontextStorage.locchnkCurrent.plschnk != NULL);
	Assert(plsc->lschunkcontextStorage.pplsdnNonText != NULL);
	Assert(plsc->lschunkcontextStorage.pfNonTextExpandAfter != NULL);
	Assert(plsc->lschunkcontextStorage.pdurOpenBorderBefore != NULL);
	Assert(plsc->lschunkcontextStorage.pdurCloseBorderAfter != NULL);

	return fTrue; /* if we here than everything OK  */
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\lscrsubl.c ===
/* LSCRSUBL.C						*/

#include "lscrsubl.h"
#include "lsidefs.h"
#include "lsc.h"
#include "lsfetch.h"
#include "getfmtst.h"
#include "setfmtst.h"
#include "fmtres.h"
#include "sublutil.h"
#include "break.h"
#include "prepdisp.h"

#include <limits.h>

#define DO_COMPRESSION	fTrue
#define DO_EXPANSION	fFalse


static LSERR ErrorInCurrentSubline(PLSC plsc, LSERR error)
	{
	Assert(GetCurrentSubline(plsc) != NULL);
	DestroySublineCore(GetCurrentSubline(plsc),&plsc->lscbk, plsc->pols,
		&plsc->lsiobjcontext, plsc->fDontReleaseRuns);
	SetCurrentSubline(plsc, NULL);
	return error;
	}

/* ---------------------------------------------------------------------- */

/*  L S  C R E A T E  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LsCreateSubline
    %%Contact: igorzv
Parameters:
	plsc		-			(IN) LS context
	cpFirst		-			(IN) first cp of a subline
	urColumnMax	-			(IN) width restriction for a subline
	lstflow		-			(IN) text flow of a subline
	fContiguos	-			(IN) if TRUE such line has the same coordinate system as main line
							and is allowed to have tabs

----------------------------------------------------------------------------*/
LSERR WINAPI LsCreateSubline(PLSC plsc,	LSCP cpFirst, long urColumnMax,	
							LSTFLOW lstflow, BOOL fContiguos)
	{
	

	if (!FIsLSC(plsc)) return lserrInvalidParameter;

	if (!FFormattingAllowed(plsc) && !FBreakingAllowed(plsc)) return lserrCreateSublineDisabled;

	if (GetCurrentSubline(plsc) != NULL) return lserrCreateSublineDisabled; 

	if (fContiguos)  /* this flag is allowed only in formating time and only within fmt method */
		{
		if (!FFormattingAllowed(plsc)) return lserrInvalidParameter;
		if (GetDnodeToFinish(plsc) == NULL) return lserrInvalidParameter;
		if (!(SublineFromDnode(GetDnodeToFinish(plsc))->fContiguous)) 
			fContiguos = fFalse;
		}
	if (urColumnMax > uLsInfiniteRM) 
		urColumnMax = uLsInfiniteRM;

	return CreateSublineCore(plsc, cpFirst, urColumnMax, lstflow, fContiguos);	
	}

/* ---------------------------------------------------------------------- */

/*  L S  F E T C H  A P P E N D  T O  C U R R E N T  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LsFetchAppendToCurrentSubline
    %%Contact: igorzv
Parameters:
	plsc		-		(IN) LS context
	lsdcp		-		(IN) increse cp before fetching
	plsesc		-		(IN) escape characters
	cEsc		-		(IN) # of escape characters
	pfSuccessful-		(OUT) Successful?---if not, finish 
												subline, destroy it and start anew	
	pfmtres		-		(OUT) result of last formatter
	pcpLim	-			(OUT) where we stop fetching
	pplsdnFirst		-	(OUT) first dnode that was created
	pplsdnLast		-	(OUT) last dnode that was created

----------------------------------------------------------------------------*/

LSERR WINAPI LsFetchAppendToCurrentSubline(PLSC plsc, LSDCP lsdcp,
										   const LSESC* plsesc, DWORD cEsc, 
										   BOOL *pfSuccessful, FMTRES* pfmtres,
										   LSCP* pcpLim, PLSDNODE* pplsdnFirst, 
										   PLSDNODE* pplsdnLast)
	{
	LSERR lserr;
	PLSSUBL plssubl;
	long dur;
	long urColumnMaxIncreased;
	BOOL fDone = fFalse;
	LSSTATE lsstateOld;
	BOOL fFirstIteration = fTrue;
	PLSDNODE plsdnFirstCurrent;
	PLSDNODE plsdnLastCurrent;
	
	
	if (!FIsLSC(plsc)) return lserrInvalidParameter;
	
	plssubl = GetCurrentSubline(plsc);
	if (plssubl == NULL) return lserrFormattingFunctionDisabled; 

	/* client can use this function only in formatting or breaking time */
	if (!FFormattingAllowed(plsc) && !FBreakingAllowed(plsc)) 
		return ErrorInCurrentSubline(plsc, lserrFormattingFunctionDisabled); 
	
	/* in formatting time it should be some dnode to finish */
	if (FFormattingAllowed(plsc) && GetDnodeToFinish(plsc) == NULL) 
		return ErrorInCurrentSubline(plsc, lserrFormattingFunctionDisabled); 
	
	/* we don't allow to continue formatting if right margin is exceeded */
	if (plssubl->fRightMarginExceeded) 
		return ErrorInCurrentSubline(plsc, lserrFormattingFunctionDisabled); 
	
	*pfSuccessful = fTrue;
	
	/* we must to set state to formatting and later restore the old one */
	lsstateOld = plssubl->plsc->lsstate;
	plssubl->plsc->lsstate = LsStateFormatting;
	
	
	/*Initialization;    */
	AdvanceCurrentCpLimSubl(plssubl, lsdcp);
	*pplsdnLast = NULL;
	
	urColumnMaxIncreased = RightMarginIncreasing(plsc, plssubl->urColumnMax);
	
	while(!fDone)  /* we continue fetching 	when we have 
		tab that are not allowed in our subline */
		{
		lserr = FetchAppendEscCore(plsc, urColumnMaxIncreased, plsesc, cEsc, pfmtres,
				pcpLim, &plsdnFirstCurrent, &plsdnLastCurrent, &dur);
		if (lserr != lserrNone)
			return ErrorInCurrentSubline(plsc, lserr); 
			
		Assert((plsdnFirstCurrent == NULL) == (plsdnLastCurrent == NULL));
		Assert((plsdnLastCurrent == NULL) || ((plsdnLastCurrent)->plsdnNext == NULL));

		if (fFirstIteration)
			{
			*pplsdnFirst = plsdnFirstCurrent;
			fFirstIteration = fFalse;
			}
		if (plsdnLastCurrent != NULL)
			*pplsdnLast = plsdnLastCurrent;

		if (*pfmtres == fmtrTab && !plssubl->fContiguous)
			{
			fDone = fFalse;
			}
		else
			{
			fDone = fTrue;
			}
		}
	plsc->lsstate = lsstateOld;
		
	if (*pfmtres == fmtrExceededMargin)
		{
		if (GetCurrentUrSubl(plssubl) <= plssubl->urColumnMax)
			{
			*pfSuccessful = fFalse;
			if (plsc->lMarginIncreaseCoefficient >= uLsInfiniteRM / 2 )
				plsc->lMarginIncreaseCoefficient = uLsInfiniteRM;
			else
				plsc->lMarginIncreaseCoefficient *= 2; /* increase coefficient to be successful
												   next time */
			return lserrNone;
			}

		plssubl->fRightMarginExceeded = fTrue;
		}
		
	Assert((*pplsdnFirst == NULL) == (*pplsdnLast == NULL));
	Assert((*pplsdnLast == NULL) || ((*pplsdnLast)->plsdnNext == NULL));
		
		
	return lserrNone;
	}
/* ---------------------------------------------------------------------- */

/*  L S  F E T C H  A P P E N D   T O  C U R R E N T  S U B L I N E  R E S U M E*/
/*----------------------------------------------------------------------------
    %%Function: LsFetchAppendToCurrentSublineResume
    %%Contact: igorzv
Parameters:
	plsc		-		(IN) LS context
	rgbreakrec	-		(IN) input array of break records 
	cbreakrec,			(IN) number of records in input array 
	lsdcp		-		(IN) increse cp before fetching
	plsesc		-		(IN) escape characters
	cEsc		-		(IN) # of escape characters
	pfSuccessful-		(OUT) Successful?---if not, finish 
												subline, destroy it and start anew	
	pfmtres		-		(OUT) result of last formatter
	pcpLim	-			(OUT) where we stop fetching
	pplsdnFirst		-	(OUT) first dnode that was created
	pplsdnLast		-	(OUT) last dnode that was created

----------------------------------------------------------------------------*/

LSERR WINAPI LsFetchAppendToCurrentSublineResume(PLSC plsc, const BREAKREC* rgbreakrec,
						   DWORD cbreakrec, LSDCP lsdcp, const LSESC* plsesc, 
						   DWORD cEsc, BOOL *pfSuccessful, 
						   FMTRES* pfmtres, LSCP* pcpLim, PLSDNODE* pplsdnFirst, 
						   PLSDNODE* pplsdnLast)
	{
	LSERR lserr;
	PLSSUBL plssubl;
	long dur;
	long urColumnMaxIncreased;
	BOOL fDone = fFalse;
	LSSTATE lsstateOld;
	BOOL fFirstIteration = fTrue;
	PLSDNODE plsdnFirstCurrent;
	PLSDNODE plsdnLastCurrent;
	
	
	if (!FIsLSC(plsc)) return lserrInvalidParameter;
	
	plssubl = GetCurrentSubline(plsc);
	if (plssubl == NULL) return lserrFormattingFunctionDisabled; 

	/* client can use this function only in formatting or breaking time */
	if (!FFormattingAllowed(plsc) && !FBreakingAllowed(plsc)) 
		return ErrorInCurrentSubline(plsc, lserrFormattingFunctionDisabled); 
	
	/* in formatting time it should be some dnode to finish */
	if (FFormattingAllowed(plsc) && GetDnodeToFinish(plsc) == NULL) 
		return ErrorInCurrentSubline(plsc, lserrFormattingFunctionDisabled); 
	
	/* subline should be empty to use this function */
	if (GetCurrentDnode(plsc) != NULL) 
		return ErrorInCurrentSubline(plsc, lserrFormattingFunctionDisabled); 
	
	/* we don't allow to continue formatting if right margin is exceeded */
	if (plssubl->fRightMarginExceeded) 
		return ErrorInCurrentSubline(plsc, lserrFormattingFunctionDisabled); 

	*pfSuccessful = fTrue;

	/* we must to set state to formatting and later restore the old one */
	lsstateOld = plssubl->plsc->lsstate;
	plssubl->plsc->lsstate = LsStateFormatting;
	
	
	/*Initialization;    */
	AdvanceCurrentCpLimSubl(plssubl, lsdcp);
	*pplsdnLast = NULL;
	
	urColumnMaxIncreased = RightMarginIncreasing(plsc, plssubl->urColumnMax);
	
	while(!fDone)  /* we continue fetching 	when we have 
		tab that are not allowed in our subline */
		{
		if (fFirstIteration)
			{
			lserr = FetchAppendEscResumeCore(plsc, urColumnMaxIncreased, plsesc, cEsc, rgbreakrec,
						   cbreakrec,pfmtres,	pcpLim, &plsdnFirstCurrent,
						   &plsdnLastCurrent, &dur);
			}
		else
			{
			lserr = FetchAppendEscCore(plsc, urColumnMaxIncreased, plsesc, cEsc, pfmtres,
					pcpLim, &plsdnFirstCurrent, &plsdnLastCurrent, &dur);
			}
		if (lserr != lserrNone)
			return ErrorInCurrentSubline(plsc, lserr); 
			
		Assert((plsdnFirstCurrent == NULL) == (plsdnLastCurrent == NULL));
		Assert((plsdnLastCurrent == NULL) || ((plsdnLastCurrent)->plsdnNext == NULL));

		if (fFirstIteration)
			{
			*pplsdnFirst = plsdnFirstCurrent;
			fFirstIteration = fFalse;
			}
		if (plsdnLastCurrent != NULL)
			*pplsdnLast = plsdnLastCurrent;
			
		if (*pfmtres == fmtrTab && !plssubl->fContiguous)
			{
			fDone = fFalse;
			}
		else
			{
			fDone = fTrue;
			}
		}

	plsc->lsstate = lsstateOld;

	if (*pfmtres == fmtrExceededMargin)
		{
		if (GetCurrentUrSubl(plssubl) <= plssubl->urColumnMax)
			{
			*pfSuccessful = fFalse;
			if (plsc->lMarginIncreaseCoefficient >= uLsInfiniteRM / 2 )
				plsc->lMarginIncreaseCoefficient = uLsInfiniteRM;
			else
				plsc->lMarginIncreaseCoefficient *= 2; /* increase coefficient to be successful
												   next time */
			return lserrNone;
			}

		plssubl->fRightMarginExceeded = fTrue;
		}
			
	Assert((*pplsdnFirst == NULL) == (*pplsdnLast == NULL));
	Assert((*pplsdnLast == NULL) || ((*pplsdnLast)->plsdnNext == NULL));
		
		
	return lserrNone;
	}

/* ---------------------------------------------------------------------- */

/*  L S  A P P E N D  R U N  T O  C U R R E N T  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LsAppendRunToCurrentSubline
    %%Contact: igorzv
Parameters:
	plsc		-		(IN) LS context
	plsfrun		-		(IN) given run
	pfSuccessful-		(OUT) Successful?---if not, finish 
												subline, destroy it and start anew	
	pfmtres		-		(OUT) result of last formatter
	pcpLim		-		(OUT) where we stop fetching
	pplsdn		-		(OUT) dnode created

----------------------------------------------------------------------------*/
LSERR WINAPI LsAppendRunToCurrentSubline(PLSC plsc,	const LSFRUN* plsfrun, BOOL *pfSuccessful,	
						    FMTRES* pfmtres, LSCP* pcpLim, PLSDNODE* pplsdn)	
	{
	LSERR lserr;
	PLSSUBL plssubl;
	LSSTATE lsstateOld;
	long urColumnMaxIncreased;
	
	if (!FIsLSC(plsc)) return lserrInvalidParameter;

	plssubl = GetCurrentSubline(plsc);
	if (plssubl == NULL) return lserrFormattingFunctionDisabled; 

	/* client can use this function only in formatting or breaking time */
	if (!FFormattingAllowed(plsc) && !FBreakingAllowed(plsc)) 
		return ErrorInCurrentSubline(plsc, lserrFormattingFunctionDisabled); 
	
	/* in formatting time it should be some dnode to finish */
	if (FFormattingAllowed(plsc) && GetDnodeToFinish(plsc) == NULL) 
		return ErrorInCurrentSubline(plsc, lserrFormattingFunctionDisabled); 

	/* we don't allow to continue formatting if right margin is exceeded */
	if (plssubl->fRightMarginExceeded) 
		return ErrorInCurrentSubline(plsc, lserrFormattingFunctionDisabled); 

	*pfSuccessful = fTrue;

	/* we must to set state to formatting and later restore the old one */
	lsstateOld = plssubl->plsc->lsstate;
	plssubl->plsc->lsstate = LsStateFormatting;

	urColumnMaxIncreased = RightMarginIncreasing(plsc, plssubl->urColumnMax);

	lserr = ProcessOneRun(plsc, urColumnMaxIncreased, plsfrun, NULL, 0, pfmtres);
	if (lserr != lserrNone)
		return ErrorInCurrentSubline(plsc, lserr); 
	
	plsc->lsstate = lsstateOld;

	if (*pfmtres == fmtrExceededMargin)
		{
		if (GetCurrentUrSubl(plssubl) <= plssubl->urColumnMax)
			{
			*pfSuccessful = fFalse;
			if (plsc->lMarginIncreaseCoefficient >= uLsInfiniteRM / 2 )
				plsc->lMarginIncreaseCoefficient = uLsInfiniteRM;
			else
				plsc->lMarginIncreaseCoefficient *= 2; /* increase coefficient to be successful
												   next time */
			return lserrNone;
			}

		plssubl->fRightMarginExceeded = fTrue;
		}
			

	/* prepare output */
	*pplsdn = GetCurrentDnodeSubl(plssubl);
	*pcpLim = GetCurrentCpLimSubl(plssubl);

	return lserrNone;
	}

/* ---------------------------------------------------------------------- */

/*  L S  R E S E T  R M  I N  C U R R E N T  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LsResetRMInCurrentSubline
    %%Contact: igorzv
Parameters:
	plsc		-		(IN) LS context
	urColumnMax	-		(IN) new value of right margin

----------------------------------------------------------------------------*/
LSERR WINAPI LsResetRMInCurrentSubline(PLSC plsc, long urColumnMax)	
	{
	PLSSUBL plssubl;

	if (!FIsLSC(plsc)) return lserrInvalidParameter;

	plssubl = GetCurrentSubline(plsc);

	if (plssubl == NULL) return lserrCurrentSublineDoesNotExist;

	/* we don't allow to change right margin if it is exceeded */
	if (plssubl->fRightMarginExceeded) return lserrFormattingFunctionDisabled; 

	Assert(FIsLSSUBL(plssubl));

	plssubl->urColumnMax = urColumnMax;

	return lserrNone;
	}


/* ---------------------------------------------------------------------- */

/*  L S  F I N I S H  C U R R E N T  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LsFinishCurrentSubline
    %%Contact: igorzv
Parameters:
	plsc		-		(IN) LS context
	pplssubl	-		(OUT) subline context

----------------------------------------------------------------------------*/
LSERR WINAPI LsFinishCurrentSubline(PLSC plsc, PLSSUBL* pplssubl)
	{
	if (!FIsLSC(plsc)) return lserrInvalidParameter;

	*pplssubl = GetCurrentSubline(plsc);

	if (*pplssubl == NULL) return lserrCurrentSublineDoesNotExist;

	Assert(FIsLSSUBL(*pplssubl));

	return FinishSublineCore(*pplssubl);
	}


/* ---------------------------------------------------------------------- */

/*  L S  T R U N C A T E  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LsTruncateSubline
    %%Contact: igorzv
Parameters:
	plsc		-		(IN) LS context
	urColumnMax	-		(IN) right margin
	pcpTruncate	-		(OUT) truncation point

----------------------------------------------------------------------------*/

LSERR WINAPI LsTruncateSubline(PLSSUBL plssubl, long urColumnMax, LSCP* pcpTruncate)
	{
	LSERR lserr;
	LSSTATE lsstateOld;

	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;
	/* it's error if urColumnmMax is biger then lenght of subline */
	if (urColumnMax >= GetCurrentUrSubl(plssubl)) return lserrInvalidParameter;

	/* we must to set state to breaking and later restore the old one */
	lsstateOld = plssubl->plsc->lsstate;
	plssubl->plsc->lsstate = LsStateBreaking;
	
	lserr = TruncateSublineCore(plssubl, urColumnMax,	pcpTruncate);

	plssubl->plsc->lsstate = lsstateOld;

	return lserr;
	}


/* ---------------------------------------------------------------------- */

/*  L S  F I N D  P R E V  B R E A K  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LsFindPrevBreakSubline
    %%Contact: igorzv
Parameters:
	plssubl			-	(IN) subline context
	fFirstSubline	-	(IN) to apply rules for first character to the first character of
							 this subline 
	cpTruncate		-	(IN) truncation point
	urColumnMax		-	(IN) right margin
	pfSuccessful	-	(OUT) do we find break?
	pcpBreak		-	(OUT) position of break
	pobjdimSubline	-	(OUT) objdim from begining of the subline up to break
	pbkpos			-	(OUT) Before/Inside/After			

----------------------------------------------------------------------------*/
LSERR WINAPI LsFindPrevBreakSubline(PLSSUBL plssubl, BOOL fFirstSubline, LSCP cpTruncate,	
						    long urColumnMax, BOOL* pfSuccessful, LSCP* pcpBreak,
							POBJDIM pobjdimSubline, BRKPOS* pbkpos)	
	{
	LSERR lserr;
	LSSTATE lsstateOld;

	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;

	/* we must to set state to breaking and later retore the old one */
	lsstateOld = plssubl->plsc->lsstate;
	plssubl->plsc->lsstate = LsStateBreaking;
	
	lserr = FindPrevBreakSublineCore(plssubl, fFirstSubline, cpTruncate, urColumnMax, 
									pfSuccessful, pcpBreak, pobjdimSubline, pbkpos);

	plssubl->plsc->lsstate = lsstateOld;

	return lserr;
	}

/* ---------------------------------------------------------------------- */

/*  L S  F I N D  N E X T  B R E A K  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LsFindNextBreakSubline
    %%Contact: igorzv
Parameters:
	plssubl			-	(IN) subline context
	fFirstSubline	-	(IN) to apply rules for first character to the first character of
							 this subline 
	cpTruncate		-	(IN) truncation point
	urColumnMax		-	(IN) right margin
	pfSuccessful	-	(OUT) do we find break?
	pcpBreak		-	(OUT) position of break
	pobjdimSubline	-	(OUT) objdim from begining of the subline up to break
	pbkpos			-	(OUT) Before/Inside/After			

----------------------------------------------------------------------------*/
LSERR WINAPI LsFindNextBreakSubline(PLSSUBL plssubl, BOOL fFirstSubline, LSCP cpTruncate,	
						    long urColumnMax, BOOL* pfSuccessful, LSCP* pcpBreak,
							POBJDIM pobjdimSubline, BRKPOS* pbkpos)		
	{
	LSERR lserr;
	LSSTATE lsstateOld;

	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;

	/* we must to set state to breaking and later retore the old one */
	lsstateOld = plssubl->plsc->lsstate;
	plssubl->plsc->lsstate = LsStateBreaking;
	
	lserr = FindNextBreakSublineCore(plssubl, fFirstSubline, cpTruncate, urColumnMax, 
									pfSuccessful, pcpBreak, pobjdimSubline, pbkpos);

	plssubl->plsc->lsstate = lsstateOld;

	return lserr;
	}

/* ---------------------------------------------------------------------- */

/*  L S  F O R C E  B R E A K  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LsForceBreakSubline
    %%Contact: igorzv
Parameters:
	plssubl			-	(IN) subline context
	fFirstSubline	-	(IN) to apply rules for first character to the first character of
							 this subline 
	cpTruncate		-	(IN) truncation point
	urColumnMax		-	(IN) right margin
	pcpBreak		-	(OUT) position of break
	pobjdimSubline	-	(OUT) objdim from begining of the subline up to break
	pbkpos			-	(OUT) Before/Inside/After			

----------------------------------------------------------------------------*/

LSERR WINAPI LsForceBreakSubline(PLSSUBL plssubl, BOOL fFirstSubline, LSCP cpTruncate,	
						    long urColumnMax, LSCP* pcpBreak,
							POBJDIM pobjdimSubline, BRKPOS* pbkpos)		
	{
	LSERR lserr;
	LSSTATE lsstateOld;

	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;

	/* we must to set state to breaking and later retore the old one */
	lsstateOld = plssubl->plsc->lsstate;
	plssubl->plsc->lsstate = LsStateBreaking;
	
	lserr = ForceBreakSublineCore(plssubl, fFirstSubline, cpTruncate, urColumnMax, 
									pcpBreak, pobjdimSubline, pbkpos);

	plssubl->plsc->lsstate = lsstateOld;

	return lserr;
	}


/* ---------------------------------------------------------------------- */

/*  L S  S E T  B R E A K  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LsSetBreakSubline
    %%Contact: igorzv
Parameters:
	plssubl				-	(IN) subline context
	brkkind,			-	(IN) Prev/Next/Force/Imposed						
	breakrecMaxCurrent	-	(IN) size of array
	pbreakrecCurrent	-	(OUT) array of break records
	pbreakrecMacCurrent	-	(OUT)  number of used elements of the array

----------------------------------------------------------------------------*/
LSERR WINAPI LsSetBreakSubline(PLSSUBL plssubl,	BRKKIND brkkind, DWORD breakrecMaxCurrent,
							   BREAKREC* pbreakrecCurrent, 
							   DWORD* pbreakrecMacCurrent)

	{
	LSERR lserr;
	LSSTATE lsstateOld;

	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;

	/* we must to set state to breaking and later retore the old one */
	lsstateOld = plssubl->plsc->lsstate;
	plssubl->plsc->lsstate = LsStateBreaking;
	
	lserr = SetBreakSublineCore(plssubl, brkkind, breakrecMaxCurrent,
						pbreakrecCurrent, pbreakrecMacCurrent);

	plssubl->plsc->lsstate = lsstateOld;

	return lserr;
	}

/* ---------------------------------------------------------------------- */

/*  L S  D E S T R O Y  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LsDestroySubline
    %%Contact: igorzv
Parameters:
	plssubl				-	(IN) subline context

----------------------------------------------------------------------------*/

LSERR WINAPI LsDestroySubline(PLSSUBL plssubl)
	{
	PLSC plsc;
	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;

	plsc = plssubl->plsc;
	Assert(FIsLSC(plsc));

	return DestroySublineCore(plssubl,&plsc->lscbk, plsc->pols,
		&plsc->lsiobjcontext, plsc->fDontReleaseRuns);
	}


/* ---------------------------------------------------------------------- */

/*  L S  M A T C H  P R E S  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LsMatchPresSubline
    %%Contact: igorzv
Parameters:
	plssubl				-	(IN) subline context

----------------------------------------------------------------------------*/
LSERR WINAPI LsMatchPresSubline(PLSSUBL plssubl)
	{
	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;

	return MatchPresSubline(plssubl);
	}


/* ---------------------------------------------------------------------- */

/*  L S  E X P A N D  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LsExpandSubline
    %%Contact: igorzv
Parameters:
	plssubl		-	(IN) subline context
	lskjust		-	(IN) justification type
	dup			-	(IN) amount to expand

----------------------------------------------------------------------------*/
LSERR WINAPI LsExpandSubline(PLSSUBL plssubl, LSKJUST lskjust, long dup)	
	{
	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;

	return AdjustSubline(plssubl, lskjust, dup, DO_EXPANSION);
	}


/* ---------------------------------------------------------------------- */

/*  L S  C O M P R E S S  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LsCompressSubline
    %%Contact: igorzv
Parameters:
	plssubl		-	(IN) subline context
	lskjust		-	(IN) justification type
	dup			-	(IN) amount to compress

----------------------------------------------------------------------------*/
LSERR WINAPI LsCompressSubline(PLSSUBL plssubl, LSKJUST lskjust, long dup)
	{
	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;

	return AdjustSubline(plssubl, lskjust, dup, DO_COMPRESSION);
	}


/* ---------------------------------------------------------------------- */

/*  L S  G E T  S P E C I A L  E F F E C T S  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LsGetSpecialEffectsSubline
    %%Contact: igorzv
Parameters:
	plssubl				-	(IN) subline context
	pfSpecialEffects	-	(OUT)special effects

----------------------------------------------------------------------------*/
LSERR WINAPI LsGetSpecialEffectsSubline(PLSSUBL plssubl, UINT* pfSpecialEffects)
	{
	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;

	return GetSpecialEffectsSublineCore(plssubl, &(plssubl->plsc->lsiobjcontext),
										pfSpecialEffects);
	}


/* ---------------------------------------------------------------------- */

/*  L S  S Q U E E Z E  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LsSqueezeSubline
    %%Contact: igorzv
Parameters:
	plssubl			-	(IN) subline context
	durTarget		-	(IN) target width of subline
	pfSuccessful	-	(OUT)do we achieve the goal
	pdurExtra		-	(OUT)if nof successful, extra dur we have from the goal

----------------------------------------------------------------------------*/
LSERR WINAPI LsSqueezeSubline(
							  PLSSUBL plssubl,		/* IN: subline context		*/
							  long durTarget,			/* IN: durTarget			*/
							  BOOL* pfSuccessful,		/* OUT: fSuccessful?		*/
							  long* pdurExtra)	/* OUT: if nof successful, 
													extra dur 			*/

	{
	LSERR lserr;
	LSSTATE lsstateOld;

	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;

	/* we must to set state to breaking and later retore the old one */
	lsstateOld = plssubl->plsc->lsstate;
	plssubl->plsc->lsstate = LsStateBreaking;
	
	lserr = SqueezeSublineCore(plssubl, durTarget, pfSuccessful, pdurExtra);

	plssubl->plsc->lsstate = lsstateOld;

	return lserr;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\lscrline.c ===
#include <limits.h>
#include "lsmem.h"						/* memset() */


#include "break.h"
#include "dnutils.h"
#include "iobj.h"
#include "iobjln.h"
#include "lsc.h"
#include "lschp.h"
#include "lscrline.h"
#include "lsdevres.h"
#include "lskysr.h"
#include "lsffi.h"
#include "lsidefs.h"
#include "lsline.h"
#include "lsfetch.h"
#include "lstext.h"
#include "prepdisp.h"
#include "tlpr.h"
#include "qheap.h"
#include "sublutil.h"
#include "zqfromza.h"
#include "lscfmtfl.h"
#include "limqmem.h"
#include "ntiman.h"



typedef struct   
{
	long urLeft;
	BOOL fAutoDecimalTab;
	long durAutoDecimalTab;
	LSCP cpFirstVis;
	BOOL fAutonumber;
	BOOL fStopped;
	BOOL fYsrChangeAfter;
	WCHAR wchYsr;  /* we need memory to keep wchYsr for kysrChangeAfter  */

} LINEGEOMETRY;

static LSERR CreateLineCore(PLSC,			/* IN: ptr to line services context */			
						  LSCP,				/* IN: starting cp in line */
						  long,				/* IN: column width in twips */
						  const BREAKREC*,	/* IN: previous line's break records */	
						  DWORD,			/* IN: number of previous line's break records */
						  DWORD,			/* IN: size of the array of current line's break records */
						  BREAKREC*,		/* OUT: current line's break records */
						  DWORD*,			/* OUT: actual number of current line's break records */
						  LSLINFO*,			/* OUT: visible line info to fill in		*/
						  PLSLINE*,			/* OUT: ptr to line opaque to client */
						  BOOL*);			/* OUT fSuccessful: false means insufficient fetch */

static BOOL FRoundingOK(void);
static LSERR CannotCreateLine(PLSLINE*,	/* IN: ponter to a line structure to be deleted */
							  LSERR);	/* IN: code of an error							*/

static LSERR ErrReleasePreFetchedRun (PLSC,			/* IN: ptr to line services context */	
									  PLSRUN,	/* IN: ponter to a run structure to be deleted */
									  LSERR);	/* IN: code of an error							*/

static LSERR EndFormatting(PLSC,		/* IN: ptr to line services context */
						   enum endres,	/* IN: type of line ending to put in lslinfo */
						   LSCP,		/* IN: cpLim to put in lslinfo */ 
						   LSDCP,		/* IN: dcpDepend to put in lslinfo*/								
						   LSLINFO*);	/* OUT: lslinfo to fill in, output of LsCreateLine*/
static LSERR FiniFormatGeneralCase (
				PLSC,			/* IN: ptr to line services context */ 
				const BREAKREC*,/* IN: input array of break records		*/
				DWORD,			/* IN: number of records in input array	*/
				DWORD,			/* IN: size of the output array			*/
				BREAKREC*,		/* OUT: output array of break records	*/
				DWORD*,			/* OUT:actual number of records in array*/
				LSLINFO*,		/* OUT: lslinfo to fill in, output of LsCreateLine*/
				BOOL*);			/* OUT fSuccessful: false means insufficient fetch */

static LSERR FiniEndLine(PLSC,		/* IN: ptr to line services context */
						 ENDRES,	/* IN: how the line ended */
						 LSCP		/* IN: cpLim of a line as a result of breaking,
										   can be changed in this procedure*/,
						 LSDCP,		/* IN: dcpDepend (amount of characters after breaking point 
										   that has participated in breaking decision) 
										   can be changed in this procedure  */	
						 LSLINFO*);	/* OUT: lslinfo to fill in, output of LsCreateLine*/

static LSERR FetchUntilVisible(
				PLSC,	 /* IN: ptr to line services context */
				LSPAP*,	 /* IN/OUT current lspap before and after */
				LSCP*,	 /* IN/OUT current cp before and after */
				LSFRUN*, /* IN/OUT current lsfrun before and after */
				PLSCHP,  /* IN/OUT current lschp before and after */
				BOOL*,	 /* OUT fStopped: procedure stopped fetching because has not been allowed
						        to go across paragraph boundaries (result CheckPara Boundaries) */
				BOOL*);  /* OUT fNewPara: procedure crossed paragraph boundaries */

static LSERR InitTextParams(PLSC,			/* IN: ptr to line services context */
							LSCP,			/* IN: cp to start fetch	*/
							long,			/* IN: duaColumn	*/
							LSFRUN*,		/* OUT: lsfrun of the first run		*/
							PLSCHP,			/* OUT: lsfrun of the first run		*/
							LINEGEOMETRY*);	/* OUT: set of flags and parameters about a line */

static LSERR FiniAuto(PLSC ,			/* IN: ptr to line services context */ 
					  BOOL ,			/* IN: fAutonumber	*/
					  BOOL ,			/* IN: fAutoDecimalTab	*/
					  PLSFRUN ,			/* IN: first run of the main text */
					  long,				/* IN: durAutoDecimalTab	*/	
					  const BREAKREC*,	/* IN: input array of break records		*/
					  DWORD,			/* IN: number of records in input array	*/
					  DWORD,			/* IN: size of the output array			*/
					  BREAKREC*,		/* OUT: output array of break records	*/
					  DWORD*,			/* OUT:actual number of records in array*/
					  LSLINFO*,			/* OUT: lslinfo to fill in, output of LsCreateLine*/
					  BOOL*);			/* OUT fSuccessful: false means insufficient fetch */

static LSERR InitCurLine(PLSC plsc,		/* IN: ptr to line services context */
						 LSCP cpFirst);	/* IN: first cp in al line */

static LSERR RemoveLineObjects(PLSLINE plsline);	/* IN: ponter to a line structure */

static LSERR GetYsrChangeAfterRun(
					PLSC plsc,				/* IN: ptr to line services context */ 
					LSCP cp,				/* IN: cp to start fetch	*/
					BOOL* pfYsrChangeAfter,	/* OUT: is it hyphenation of the previous line */
					PLSFRUN plsfrun,		/* OUT: lsfrun of modified first run	*/
					PLSCHP plschp,			/* OUT: lschp of modified first run	*/
					LINEGEOMETRY*);			/* OUT: to put wchYsr */

static LSERR FillTextParams(
				PLSC plsc,				/* IN: ptr to line services context */ 
				LSCP cp,				/* IN: cp to start fetch	*/
				long duaCol,			/* IN: duaColumn	*/
				PLSPAP plspap,			/* IN: paragraph properties */
				BOOL fFirstLineInPara,	/* IN: flag fFirstLineInPara */
				BOOL fStopped,			/* IN: flag fStopped	*/
				LINEGEOMETRY*);			/* OUT: set of flags and parameters about a line */	

static LSERR FiniChangeAfter(
						PLSC plsc,			/* IN: ptr to line services context */ 
						LSFRUN* plsfrun,	/* IN: lsfrun of modified first run	*/ 
						const BREAKREC*,	/* IN: input array of break records		*/
						DWORD,				/* IN: number of records in input array	*/
						DWORD,				/* IN: size of the output array			*/
						BREAKREC*,			/* OUT: output array of break records	*/
						DWORD*,				/* OUT:actual number of records in array*/
						LSLINFO*,			/* OUT: lslinfo to fill in, output of LsCreateLine*/
						BOOL*);				/* OUT fSuccessful: false means insufficient fetch */





/* L I M  R G */
/*----------------------------------------------------------------------------
    %%Function: LimRg
    %%Contact: lenoxb

    Returns # of elements in an array.
----------------------------------------------------------------------------*/
#define LimRg(rg)	(sizeof(rg)/sizeof((rg)[0]))





#define  fFmiAdvancedFormatting  (fFmiPunctStartLine | fFmiHangingPunct)
							  	  

#define FBreakJustSimple(lsbrj)  (lsbrj == lsbrjBreakJustify || lsbrj == lsbrjBreakThenSqueeze)

#define FAdvancedTypographyEnabled(plsc, cbreakrec)  \
						(FNominalToIdealBecauseOfParagraphProperties(plsc->grpfManager, \
								plsc->lsadjustcontext.lskj) || \
						 !FBreakJustSimple((plsc)->lsadjustcontext.lsbrj) ||\
						 cbreakrec != 0 \
						 )

#define fFmiSpecialSpaceBreaking (fFmiWrapTrailingSpaces | fFmiWrapAllSpaces)

#define fFmiQuickBreakProhibited (fFmiSpecialSpaceBreaking | fFmiDoHyphenation)

/* F T R Y  Q U I C K  B R E A K */
/*----------------------------------------------------------------------------
    %%Macro: FTryQuickBreak
    %%Contact: igorzv

    "Returns" fTrue when the formatter flags indicate that it it may be
	possible to use QuickBreakText() instead of the more expensive
	BreakGeneralCase().
----------------------------------------------------------------------------*/
#define FTryQuickBreak(plsc) ((((plsc)->grpfManager & fFmiQuickBreakProhibited) == 0) && \
							  ((plsc)->lMarginIncreaseCoefficient == LONG_MIN) \
                             )


#define GetMainSubline(plsc)	\
							(Assert(FWorkWithCurrentLine(plsc)),\
							&((plsc)->plslineCur->lssubl))

#define FPapInconsistent(plspap)	\
					((((plspap)->lsbrj == lsbrjBreakJustify ||  \
					   (plspap)->lsbrj == lsbrjBreakWithCompJustify) \
							&& (plspap)->uaRightBreak < uLsInfiniteRM \
							&& (plspap)->uaRightBreak != (plspap)->uaRightJustify) \
				||	 ((plspap)->lsbrj == lsbrjBreakThenExpand \
							&& (plspap)->uaRightBreak < (plspap)->uaRightJustify) \
				||	 ((plspap)->lsbrj == lsbrjBreakThenSqueeze \
							&& (plspap)->uaRightBreak > (plspap)->uaRightJustify) \
				||	 ((plspap)->lsbrj != lsbrjBreakWithCompJustify \
							&& (plspap)->grpf & fFmiHangingPunct) \
				||   ((plspap)->lsbrj == lsbrjBreakWithCompJustify \
							&& (plspap)->lskj == lskjFullGlyphs))

/* ---------------------------------------------------------------------- */

/* L S  C R E A T E  L I N E */
/*----------------------------------------------------------------------------
    %%Function: LsCreateLine
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 
	cpFirst			-	(IN) starting cp in line
	duaColumn		-	(IN) column width in twips
	pbreakrecPrev	-	(IN) previous line's break records 
	breakrecMacPrev	-	(IN) number of previous line's break records 
	breakrecMaxCurrent-	(IN) size of the array of current line's break records
	pbreakrecCurrent-	(OUT) current line's break records
	pbreakrecMacCurrent-(OUT) actual number of current line's break records 
	plsinfo		-	(OUT) visible line info to fill in
	pplsline	-	(OUT) ptr to line opaque to client 

    An exported LineServices API.
----------------------------------------------------------------------------*/

LSERR WINAPI LsCreateLine(PLSC plsc,			
						  LSCP cpFirst,			
						  long duaColumn,
						  const BREAKREC* pbreakrecPrev,
						  DWORD breakrecMacPrev,
						  DWORD breakrecMaxCurrent,
						  BREAKREC* pbreakrecCurrent,
						  DWORD* pbreakrecMacCurrent,
						  LSLINFO* plslinfo,		
						  PLSLINE* pplsline)	
	{
	
	
	LSERR lserr;
	BOOL fSuccessful;
	
	
	/* Check parameters and enviroment   	*/
	
	
	Assert(FRoundingOK());
	
	if (plslinfo == NULL || pplsline == NULL || pbreakrecMacCurrent == NULL)
		return lserrNullOutputParameter;
	
	*pplsline = NULL;
	*pbreakrecMacCurrent = 0;  /* it's very important to initialize number of break records 
							   because for example quick break doesn't work with break records */
	
	if (!FIsLSC(plsc))
		return lserrInvalidContext;
	
	if (plsc->lsstate != LsStateFree)
		return lserrContextInUse;
	
	Assert(FIsLsContextValid(plsc));

	if (pbreakrecPrev == NULL && breakrecMacPrev != 0)
		return lserrInvalidParameter;
	
	if (pbreakrecCurrent == NULL && breakrecMaxCurrent != 0)
		return lserrInvalidParameter;
	
	if (duaColumn < 0)
		return lserrInvalidParameter;

	if (duaColumn > uLsInfiniteRM) 
		duaColumn = uLsInfiniteRM;

	/* if we have current line we  must prepare it for display before creating of new line  */
	/* can change context. We've delayed this untill last moment because of optimisation reasons */
	if (plsc->plslineCur != NULL)
		{
		lserr = PrepareLineForDisplayProc(plsc->plslineCur);
		if (lserr != lserrNone)
			return lserr;
		plsc->plslineCur = NULL;
		}
	
	plsc->lMarginIncreaseCoefficient = LONG_MIN;

	do	/* loop allowing change of exceeded right margin if it's not sufficient */
		{
		lserr = CreateLineCore(plsc, cpFirst, duaColumn, pbreakrecPrev, breakrecMacPrev,
							breakrecMaxCurrent, pbreakrecCurrent, pbreakrecMacCurrent,
							plslinfo, pplsline, &fSuccessful);

		if (lserr != lserrNone)
			return lserr;

		if (!fSuccessful)
			{	/* coefficient has not been sufficient before so increase it */
			if (plsc->lMarginIncreaseCoefficient == LONG_MIN)
				plsc->lMarginIncreaseCoefficient = 1;
			else
				{
				if (plsc->lMarginIncreaseCoefficient >= uLsInfiniteRM / 2 )
					plsc->lMarginIncreaseCoefficient = uLsInfiniteRM;
				else
					plsc->lMarginIncreaseCoefficient *= 2;
				}
			}
		}
	while (!fSuccessful);


#ifdef DEBUG
#ifdef LSTEST_GETMINDUR

	/* Test LsGetMinDurBreaks () */

	if ((lserr == lserrNone) && (plslinfo->endr != endrNormal) &&
		(plslinfo->endr != endrHyphenated) && (! (plsc->grpfManager & fFmiDoHyphenation)) )
		{
		/* Line was ended with hard break / stopped */

		long durMinInclTrail;
		long durMinExclTrail;

		lserr = LsGetMinDurBreaks ( plsc, *pplsline, &durMinInclTrail, 
								    &durMinExclTrail );
		};

#endif /* LSTEST_GETMINDUR */
#endif /* DEBUG */


	return lserr;

	}


/* ---------------------------------------------------------------------- */

/* C R E A T E  L I N E   C O R E*/
/*----------------------------------------------------------------------------
    %%Function: CreateLineCore
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 
	cpFirst			-	(IN) starting cp in line
	duaColumn		-	(IN) column width in twips
	pbreakrecPrev	-	(IN) previous line's break records 
	breakrecMacPrev	-	(IN) number of previous line's break records 
	breakrecMaxCurrent-	(IN) size of the array of current line's break records
	pbreakrecCurrent-	(OUT) current line's break records
	pbreakrecMacCurrent-(OUT) actual number of current line's break records 
	plsinfo			-	(OUT) visible line info to fill in
	pplsline		-	(OUT) ptr to line opaque to client 
	pfSuccessful	-	(OUT) fSuccessful: false means insufficient fetch

	Internal procedure organized to handle error in choosing extended right margin
----------------------------------------------------------------------------*/

static LSERR CreateLineCore(PLSC plsc,			
						  LSCP cpFirst,			
						  long duaColumn,
						  const BREAKREC* pbreakrecPrev,
						  DWORD breakrecMacPrev,
						  DWORD breakrecMaxCurrent,
						  BREAKREC* pbreakrecCurrent,
						  DWORD* pbreakrecMacCurrent,
						  LSLINFO* plslinfo,		
						  PLSLINE* pplsline,
						  BOOL* pfSuccessful)	
{


	PLSLINE plsline;
	LINEGEOMETRY lgeom;
	LSCHP lschp;
	LSERR lserr;
	BOOL fGeneral = fFalse;
	BOOL fHardStop;
	BOOL fSuccessfulQuickBreak;
	LSCP cpLimLine;
	LSDCP dcpDepend = 0;
	LSFRUN lsfrun;
	long urFinalPen;
	long urColumnMaxIncreased;
	ENDRES endr = endrNormal;


	/*Initialization;   */

	*pfSuccessful = fTrue;

	lsfrun.plschp = &lschp;  /* we use the same area for lschips */
								 /* because we pasing pointer to const nobody can change it */


	plsline= PvNewQuick(plsc->pqhLines, cbRep(struct lsline, rgplnobj, plsc->lsiobjcontext.iobjMac));
	if (plsline == NULL)
		return lserrOutOfMemory;

	plsc->lsstate = LsStateFormatting; /* We start here  forwating line. After this momemt we must 
										  free context before return. We do this either in CannotCreateLine (error)
										  or EndFormatting (success)   */

	plsc->plslineCur = plsline;
	*pplsline = plsline;

	lserr = InitCurLine (plsc, cpFirst);  
	if (lserr != lserrNone)
		return CannotCreateLine(pplsline, lserr);


	/* check initial value of flags */
	Assert(FAllSimpleText(plsc));
	Assert(!FNonRealDnodeEncounted(plsc));
	Assert(!FNonZeroDvpPosEncounted(plsc));
	Assert(AggregatedDisplayFlags(plsc) == 0);
	Assert(!FNominalToIdealEncounted(plsc));
	Assert(!FForeignObjectEncounted(plsc));
	Assert(!FTabEncounted(plsc));
	Assert(!FNonLeftTabEncounted(plsc));
	Assert(!FSubmittedSublineEncounted(plsc));
	Assert(!FAutodecimalTabPresent(plsc));
	
	plsc->cLinesActive += 1;


	lserr = InitTextParams(plsc, cpFirst, duaColumn, &lsfrun, &lschp, &lgeom);
	if (lserr != lserrNone)
		return CannotCreateLine(pplsline,lserr);

	/* prepare starting set for formatting */
	InitFormattingContext(plsc,  lgeom.urLeft, lgeom.cpFirstVis); 


	/* REVIEW comments */
	if (lgeom.fStopped)
		{
		plsc->lsstate = LsStateBreaking;  /* we now in a stage of breaking */

		lserr = FiniEndLine(plsc, endrStopped, lgeom.cpFirstVis, 0, plslinfo);
		if (lserr != lserrNone)
			return CannotCreateLine(pplsline,lserr);
		else
			return lserrNone;
		}
		
	/* change first character because of hyphenation */
	if (lgeom.fYsrChangeAfter)
		{
		Assert(!(lgeom.fAutonumber) || (lgeom.fAutoDecimalTab));

		lserr = FiniChangeAfter(plsc, &lsfrun, pbreakrecPrev,
								breakrecMacPrev, breakrecMaxCurrent,
								pbreakrecCurrent, pbreakrecMacCurrent, plslinfo, pfSuccessful);

		if (lserr != lserrNone || !*pfSuccessful)
			return CannotCreateLine(pplsline, lserr);
		else
			return lserrNone;
		}
	/* important note to understand code flow : The situation below can happened
	   only for first line in a paragraph, the situation above never can happened 
	   for such line. */

	/* if autonumbering or auto-decimal tab */
	if ((lgeom.fAutonumber) || (lgeom.fAutoDecimalTab))
		{
		Assert(!lgeom.fYsrChangeAfter);

		TurnOffAllSimpleText(plsc);

		/* we will release plsrun in FiniAuto */

		lserr = FiniAuto(plsc, lgeom.fAutonumber, lgeom.fAutoDecimalTab, &lsfrun,
						lgeom.durAutoDecimalTab, pbreakrecPrev,
						breakrecMacPrev, breakrecMaxCurrent,
						pbreakrecCurrent, pbreakrecMacCurrent, plslinfo, pfSuccessful); 

		if (lserr != lserrNone || !*pfSuccessful)
			return CannotCreateLine(pplsline, lserr);
		else
			return lserrNone;
		}

	if (FAdvancedTypographyEnabled(plsc, breakrecMacPrev ))
		{
		/* we should release run here, in general procedure we will fetch it again */
		if (!plsc->fDontReleaseRuns)
			{
			lserr = plsc->lscbk.pfnReleaseRun(plsc->pols, lsfrun.plsrun);
			if (lserr != lserrNone)
				return CannotCreateLine(pplsline,lserr);
			}

		lserr = FiniFormatGeneralCase(plsc, pbreakrecPrev,
						breakrecMacPrev, breakrecMaxCurrent,
						pbreakrecCurrent, pbreakrecMacCurrent, plslinfo, pfSuccessful); 
		
		if (lserr != lserrNone || !*pfSuccessful)
			return CannotCreateLine(pplsline,lserr);
		else
			return lserrNone;
		}

	/* it is possible that width of column is negative: in such scase we'll 
	use another right margin*/
	if (plsc->urRightMarginBreak <= 0 && plsc->lMarginIncreaseCoefficient == LONG_MIN)
		plsc->lMarginIncreaseCoefficient = 1;

	if (plsc->lMarginIncreaseCoefficient != LONG_MIN)
		{
		urColumnMaxIncreased = RightMarginIncreasing(plsc, plsc->urRightMarginBreak);
		}
	else
		{
		urColumnMaxIncreased = plsc->urRightMarginBreak;
		}

 	lserr = QuickFormatting(plsc, &lsfrun, urColumnMaxIncreased,
							&fGeneral, &fHardStop, &cpLimLine, &urFinalPen);	

	if (lserr != lserrNone)
		return CannotCreateLine(pplsline,lserr);


	if (fGeneral)
		{
		lserr = FiniFormatGeneralCase(plsc, pbreakrecPrev,
									  breakrecMacPrev, breakrecMaxCurrent,
									  pbreakrecCurrent, pbreakrecMacCurrent,
									  plslinfo, pfSuccessful); 
 
		if (lserr != lserrNone || !*pfSuccessful)
			return CannotCreateLine(pplsline, lserr);
		else
			return lserrNone;
		}
 
	plsc->lsstate = LsStateBreaking;  /* we now in a stage of breaking */
	if (FTryQuickBreak(plsc))
		{
		lserr = BreakQuickCase(plsc, fHardStop, &dcpDepend, &cpLimLine, 
							   &fSuccessfulQuickBreak, &endr);		
		if (lserr != lserrNone)
			return CannotCreateLine(pplsline,lserr);
		}
	else
		{
		fSuccessfulQuickBreak = fFalse;
		}

	if (fSuccessfulQuickBreak)
		{
		if (endr == endrNormal || endr == endrAltEndPara ||   
			(endr == endrEndPara && !plsc->fLimSplat))
			{
			lserr = EndFormatting(plsc, endr, cpLimLine,
				dcpDepend, plslinfo);
			if (lserr != lserrNone)
				return CannotCreateLine(pplsline,lserr);
			else
				return lserrNone;
			}
		else	/* there is splat that is handled in FiniEndLine */
			{
			lserr = FiniEndLine(plsc, endr, cpLimLine, dcpDepend, plslinfo);
			if (lserr != lserrNone)
				return CannotCreateLine(pplsline, lserr);
			else
				return lserrNone;
			}
		}
	else
		{
		/*  here we should use BreakGeneralCase */
		lserr = BreakGeneralCase(plsc, fHardStop, breakrecMaxCurrent,
								pbreakrecCurrent, pbreakrecMacCurrent,&dcpDepend, 
								&cpLimLine, &endr, pfSuccessful); 
		if (lserr != lserrNone || !*pfSuccessful)
			return CannotCreateLine(pplsline,lserr);

		lserr = FiniEndLine(plsc, endr, cpLimLine, dcpDepend, plslinfo);
		if (lserr != lserrNone)
			return CannotCreateLine(pplsline, lserr);
     	else
		 	return lserrNone;
		}


}   /* end LsCreateLine   */


/* ---------------------------------------------------------------------- */

/* F I N I  F O R M A T  G E N E R A L   C A S E*/
/*----------------------------------------------------------------------------
    %%Function: FiniFormatGeneralCase 
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 
	pbreakrecPrev	-	(IN) previous line's break records 
	breakrecMacPrev	-	(IN) number of previous line's break records 
	breakrecMaxCurrent-	(IN) size of the array of current line's break records
	pbreakrecCurrent-	(OUT) current line's break records
	pbreakrecMacCurrent-(OUT) actual number of current line's break records 
	plsinfo		-		(OUT) visible line info to fill in
	pfSuccessful	-	(OUT) fSuccessful: false means insufficient fetch

    Formatting and breaking in a case when "quick formatting" is prohibit
----------------------------------------------------------------------------*/
static LSERR FiniFormatGeneralCase (PLSC  plsc,					
									const BREAKREC* pbreakrecPrev,
									DWORD breakrecMacPrev,
									DWORD breakrecMaxCurrent,
									BREAKREC* pbreakrecCurrent,
									DWORD* pbreakrecMacCurrent,
									LSLINFO* plslinfo, BOOL* pfSuccessful)			 
									
									
									
	{
	long urColumnMaxIncreased;
	FMTRES fmtres;
	LSERR lserr;
	LSCP cpLimLine;
	LSDCP dcpDepend;
	PLSDNODE plsdnFirst, plsdnLast;
	long urFinal;
	ENDRES endr;
	
	
	Assert(FIsLSC(plsc));
	Assert(FFormattingAllowed(plsc));
	Assert(plslinfo != NULL);
	
	*pfSuccessful = fTrue;

	if (plsc->lMarginIncreaseCoefficient == LONG_MIN) /* we are here for the first time */
		{
		/* increase right margin for nominal to ideal and compression */
		if (!FBreakJustSimple(plsc->lsadjustcontext.lsbrj))
			plsc->lMarginIncreaseCoefficient = 2;
		else 
			plsc->lMarginIncreaseCoefficient = 1;
		}

	urColumnMaxIncreased = RightMarginIncreasing(plsc, plsc->urRightMarginBreak);
	
	if (FNominalToIdealBecauseOfParagraphProperties(plsc->grpfManager,
		 plsc->lsadjustcontext.lskj))
		 TurnOnNominalToIdealEncounted(plsc);
	
	if (breakrecMacPrev != 0)
		lserr = FetchAppendEscResumeCore(plsc, urColumnMaxIncreased, NULL, 0,
										pbreakrecPrev, breakrecMacPrev, 
										&fmtres, &cpLimLine, &plsdnFirst,
										&plsdnLast, &urFinal);
	else
		lserr = FetchAppendEscCore(plsc, urColumnMaxIncreased, NULL, 0, 
									&fmtres, &cpLimLine, &plsdnFirst,
									&plsdnLast, &urFinal);
	if (lserr != lserrNone) 
		return lserr;
	
	
	/* fetch append esc can be stopped because of tab */
	/* so we have loop for tabs here				  */
	while (fmtres == fmtrTab)
		{
		lserr = HandleTab(plsc);
		if (lserr != lserrNone) 
			return lserr;

		if (FBreakthroughLine(plsc))
			{
			urColumnMaxIncreased = RightMarginIncreasing(plsc, plsc->urRightMarginBreak);
			}
		
		lserr = FetchAppendEscCore(plsc, urColumnMaxIncreased, NULL, 0, 
			&fmtres, &cpLimLine, &plsdnFirst,
			&plsdnLast, &urFinal);
		if (lserr != lserrNone) 
			return lserr;
		}
		
	Assert(fmtres == fmtrStopped || fmtres == fmtrExceededMargin);
	
	/* skip back pen dnodes */
	while (plsdnLast != NULL && FIsDnodePen(plsdnLast)) 
		{
		plsdnLast = plsdnLast->plsdnPrev;
		}

	/* close last border */
	if (FDnodeHasBorder(plsdnLast) && !FIsDnodeCloseBorder(plsdnLast))
		{
		lserr = CloseCurrentBorder(plsc);
		if (lserr != lserrNone)
			return lserr;
		}

	if (fmtres == fmtrExceededMargin 
		&& (urFinal <= plsc->urRightMarginBreak 	/* it's important for truncation to have <= here */
			|| plsdnLast == NULL || FIsNotInContent(plsdnLast)   /* this can happen if in nominal
											to ideal (dcpMaxContext) we deleted everything 
											in content, but starting point
											of content is already behind right margin */
			)
		) 
		{
		/* return unsuccessful	*/
		*pfSuccessful = fFalse;
		return lserrNone;
		}
	else
		{
		plsc->lsstate = LsStateBreaking;  /* we now in a stage of breaking */
		lserr = BreakGeneralCase(plsc, (fmtres == fmtrStopped), breakrecMaxCurrent,
			pbreakrecCurrent, pbreakrecMacCurrent,
			&dcpDepend, &cpLimLine, &endr, pfSuccessful);

		if (lserr != lserrNone || !*pfSuccessful)
			return lserr;
		
		/* because, we work with increased margin we can resolve pending tab only after break */
		/* we use here that after breaking decision  we set state after break point*/
		lserr = HandleTab(plsc);
		if (lserr != lserrNone)
			return lserr;
		
		return FiniEndLine(plsc, endr, cpLimLine, dcpDepend, plslinfo);
		}	
		
		
	}
	

/* ---------------------------------------------------------------------- */

/* F I N I  E N D  L I N E  */
/*----------------------------------------------------------------------------
    %%Function: FiniEndLine	
    %%Contact: igorzv
Parameters:
	plsc		-		(IN) ptr to line services context 
	endr		-		(IN) how the line ended
	cpLimLine	-		(IN) cpLim of a line as a result of breaking,
										   can be changed in this procedure
	dcpDepend	-		(IN) amount of characters after breaking point 
										   that has participated in breaking decision,
										   can be changed in this procedure  	
	plsinfo		-		(OUT) visible line info to fill in

    Handles splat, calculates heights, special effects
----------------------------------------------------------------------------*/

static LSERR FiniEndLine(PLSC plsc, ENDRES endr, LSCP cpLimLine, 
						 LSDCP dcpDepend, LSLINFO* plslinfo)	

{
	LSLINFO* plslinfoState;
	OBJDIM objdim;
	LSERR lserr; 
	PLSLINE plsline;
	BOOL fEmpty;
	ENDRES endrOld;
	
	Assert(FIsLSC(plsc));
	Assert(plslinfo != NULL);

	plsline = plsc->plslineCur;
	plslinfoState = &(plsline->lslinfo);


	endrOld = endr;
	if (endr == endrEndPara && plsc->fLimSplat)
		{
		endr = endrEndParaSection;
		cpLimLine++;
		}

	/* handling splat   */
    if (endr == endrEndColumn || endr == endrEndSection || 
		endr == endrEndParaSection|| endr == endrEndPage)
		{
 
		if (plsc->grpfManager & fFmiVisiSplats)
			{
			switch (endr)
				{
			case endrEndColumn:			plsline->kspl = ksplColumnBreak;	break;
			case endrEndSection:		plsline->kspl = ksplSectionBreak;	break;
			case endrEndParaSection:	plsline->kspl = ksplSectionBreak;	break;
			case endrEndPage:			plsline->kspl = ksplPageBreak;		break;
				}
			}

		lserr = FIsSublineEmpty(GetMainSubline(plsc), &fEmpty);
		if (lserr != lserrNone)
			return lserr;

		if (!fEmpty && (plsc->grpfManager & fFmiAllowSplatLine))
			{
			cpLimLine--;
			dcpDepend++;
			plsline->kspl = ksplNone;
			if (endrOld == endrEndPara)
				{
				endr = endrEndPara;
				}
			else
				{
				endr = endrNormal;
				}
			}

		}



 	/* Height calculation;       */	
		
	lserr = GetObjDimSublineCore(GetMainSubline(plsc), &objdim);
	if (lserr != lserrNone)
			return lserr;

	plslinfoState->dvrAscent = objdim.heightsRef.dvAscent;
	plslinfoState->dvpAscent = objdim.heightsPres.dvAscent;
	plslinfoState->dvrDescent = objdim.heightsRef.dvDescent;
	plslinfoState->dvpDescent = objdim.heightsPres.dvDescent;
	plslinfoState->dvpMultiLineHeight = objdim.heightsPres.dvMultiLineHeight;
	plslinfoState->dvrMultiLineHeight = objdim.heightsRef.dvMultiLineHeight;

	/* calculation plslinfoState->EffectsFlags*/
	if (plslinfoState->EffectsFlags) /* some run with special effects happend during formating */
		{
		lserr = GetSpecialEffectsSublineCore(GetMainSubline(plsc), 
							&plsc->lsiobjcontext, &plslinfoState->EffectsFlags);
		if (lserr != lserrNone)
			return lserr;
		}


	return EndFormatting(plsc, endr, cpLimLine, dcpDepend, plslinfo);


}



/* ---------------------------------------------------------------------- */
/* F I N I  A U T O */
/*----------------------------------------------------------------------------
    %%Function: FiniAuto
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 
	fAutonumber		-	(IN) does this line containes autonimber
	fAutoDecimaltab	-	(IN) does this line containes autodecimal tab
	plsfrunMainText	-	(IN) first run of main text
	durAutoDecimalTab-	(IN) tab stop for autodecimal tab 
	pbreakrecPrev	-	(IN) previous line's break records 
	breakrecMacPrev	-	(IN) number of previous line's break records 
	breakrecMaxCurrent-	(IN) size of the array of current line's break records
	pbreakrecCurrent-	(OUT) current line's break records
	pbreakrecMacCurrent-(OUT) actual number of current line's break records 
	plsinfo		-		(OUT) visible line info to fill in
	pfSuccessful	-	(OUT) fSuccessful: false means insufficient fetch

    Completes CreateLine logic for autonumbering and auto-decimal tab 
----------------------------------------------------------------------------*/
static LSERR FiniAuto(
					 PLSC plsc,
					 BOOL fAutonumber,
					 BOOL fAutoDecimalTab,
					 PLSFRUN plsfrunMainText,
					 long durAutoDecimalTab,
					 const BREAKREC* pbreakrecPrev,
					 DWORD breakrecMacPrev,
					 DWORD breakrecMaxCurrent,
				     BREAKREC* pbreakrecCurrent,
					 DWORD* pbreakrecMacCurrent,
					 LSLINFO* plslinfo, BOOL* pfSuccessful)
{
	LSERR lserr;


		if (plsc->lMarginIncreaseCoefficient == LONG_MIN)
			plsc->lMarginIncreaseCoefficient = 1;

		if (fAutonumber)		/*autonumbering  */
		{
		lserr = FormatAnm(plsc, plsfrunMainText);
		if (lserr != lserrNone)
			{
			return ErrReleasePreFetchedRun(plsc, plsfrunMainText->plsrun, lserr);
			}
		}

	if (fAutoDecimalTab)
		{
		lserr = InitializeAutoDecTab(plsc, durAutoDecimalTab); 
		if (lserr != lserrNone)
			{
			return ErrReleasePreFetchedRun(plsc, plsfrunMainText->plsrun, lserr);
			}
		}

	/* we should release run here, in general procedure we will fetch it again */
	if (!plsc->fDontReleaseRuns)
		{
		lserr = plsc->lscbk.pfnReleaseRun(plsc->pols, plsfrunMainText->plsrun);
		if (lserr != lserrNone)
			return lserr;
		}

	return FiniFormatGeneralCase(plsc, pbreakrecPrev,
						  breakrecMacPrev, breakrecMaxCurrent,
						  pbreakrecCurrent, pbreakrecMacCurrent, plslinfo, pfSuccessful);
}

/* F I N I  C H A N G E  A F T E R */
/*----------------------------------------------------------------------------
    %%Function: FiniChangeAfter
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 
	plsfrun,		-	(IN) lsfrun of modified first run	 
	pbreakrecPrev	-	(IN) previous line's break records 
	breakrecMacPrev	-	(IN) number of previous line's break records 
	breakrecMaxCurrent-	(IN) size of the array of current line's break records
	pbreakrecCurrent-	(OUT) current line's break records
	pbreakrecMacCurrent-(OUT) actual number of current line's break records 
	plsinfo		-		(OUT) visible line info to fill in
	pfSuccessful	-	(OUT) fSuccessful: false means insufficient fetch

    Completes CreateLine logic for change after because of hyphenation
----------------------------------------------------------------------------*/

static LSERR FiniChangeAfter(PLSC plsc, LSFRUN* plsfrun, const BREAKREC* pbreakrecPrev,
					 DWORD breakrecMacPrev,
					 DWORD breakrecMaxCurrent,
				     BREAKREC* pbreakrecCurrent,
					 DWORD* pbreakrecMacCurrent,
					 LSLINFO* plslinfo, BOOL* pfSuccessful)
	{

	LSERR lserr;
	FMTRES fmtres;

	lserr = ProcessOneRun(plsc, plsc->urRightMarginBreak, plsfrun, NULL, 0, &fmtres); 
	if (lserr != lserrNone)
		return lserr;

	return FiniFormatGeneralCase(plsc, pbreakrecPrev,
						  breakrecMacPrev, breakrecMaxCurrent,
						  pbreakrecCurrent, pbreakrecMacCurrent, plslinfo, pfSuccessful);
	}

/* ---------------------------------------------------------------------- */

/* E N D  F O R M A T T I N G*/
/*----------------------------------------------------------------------------
    %%Function: EndFormatting
    %%Contact: igorzv
Parameters:
	plsc		-		(IN) ptr to line services context 
	endres		-		(IN) how line ends
	cpLimLine	-		(IN) cpLim of a line as a result of breaking,
										   can be changed in this procedure
	dcpDepend	-		(IN) amount of characters after breaking point 
										   that has participated in breaking decision,
										   can be changed in this procedure  	
	plsinfo		-		(OUT) visible line info to fill in

    Filles in lslinfo
----------------------------------------------------------------------------*/


static LSERR EndFormatting (PLSC plsc, enum endres endr,
							LSCP cpLimLine, LSDCP dcpDepend, LSLINFO* plslinfo)

{

	PLSLINE plsline = plsc->plslineCur;
	LSLINFO* plslinfoContext = &(plsline->lslinfo);


	Assert(FIsLSC(plsc));
	Assert(plslinfo != NULL);


	plslinfoContext->cpLim = cpLimLine;
	plslinfoContext->dcpDepend = dcpDepend;
	plslinfoContext->endr = endr;

  	
	*plslinfo = *plslinfoContext;
	plsc->lsstate = LsStateFree;  /* we always return through this procedure (in a case of success )
									 so we free context here */
	return lserrNone;
}

/*----------------------------------------------------------------------------
/* L S  M O D I F Y  L I N E  H E I G H T */
/*----------------------------------------------------------------------------
    %%Function: LsModifyLineHeight
    %%Contact: igorzv
Parameters:
	plsc		-		(IN) ptr to line services context 
	psline		-		(IN) ptr to a line to be modified
	dvpAbove	-		(IN) dvpAbove to set in plsline
	dvpAscent	-		(IN) dvpAscent to set in plsline
	dvpDescent	-		(IN) dvpDescent to set in plsline
	dvpBelow	-		(IN) dvpBelow to set in plsline

	An exported LineServices API.
	Modifies heights in a plsline structure
----------------------------------------------------------------------------*/
LSERR WINAPI LsModifyLineHeight(PLSC plsc,
								PLSLINE plsline,
								long dvpAbove,
								long dvpAscent,
								long dvpDescent,
								long dvpBelow)
{
	if (!FIsLSC(plsc))
		return lserrInvalidContext;

	if (!FIsLSLINE(plsline))
		return lserrInvalidLine;

	if (plsline->lssubl.plsc != plsc)
		return lserrMismatchLineContext;

	if (plsc->lsstate != LsStateFree)
		return lserrContextInUse;



	plsline->dvpAbove = dvpAbove;
	plsline->lslinfo.dvpAscent = dvpAscent;
	plsline->lslinfo.dvpDescent = dvpDescent;
	plsline->dvpBelow = dvpBelow;
	return lserrNone;
}

/*----------------------------------------------------------------------------
/* L S  D E S T R O Y   L I N E  */
/*----------------------------------------------------------------------------
    %%Function: LsDestroyLine
    %%Contact: igorzv
Parameters:
	plsc		-		(IN) ptr to line services context 
	psline		-		(IN) ptr to a line to be deleted

	An exported LineServices API.
	Removed plsline structure , dnode list, line objects structures
----------------------------------------------------------------------------*/

LSERR WINAPI LsDestroyLine(PLSC plsc,		/* IN: ptr to line services context */
						   PLSLINE plsline)	/* IN: ptr to line -- opaque to client */
{
	POLS pols;
	LSERR lserrNew, lserr = lserrNone;

	if (!FIsLSC(plsc))
		return lserrInvalidContext;

	if (!FIsLSLINE(plsline))
		return lserrInvalidLine;

	if (plsline->lssubl.plsc != plsc)
		return lserrMismatchLineContext;

	if (plsc->lsstate != LsStateFree)
		return lserrContextInUse;

	Assert(FIsLsContextValid(plsc));
	Assert(plsc->cLinesActive > 0);

	plsc->lsstate = LsStateDestroyingLine;

	pols = plsc->pols;

	/* optimization */
	/* we use here that text doesn't have pinfosubl and DestroyDobj is actually empty for text */
	if (!plsc->fDontReleaseRuns || !plsline->fAllSimpleText)
		{

		lserrNew = DestroyDnodeList(&plsc->lscbk, plsc->pols, &plsc->lsiobjcontext, 
								plsline->lssubl.plsdnFirst, plsc->fDontReleaseRuns);
		if (lserrNew != lserrNone && lserr == lserrNone)
			lserr = lserrNew;  
		}

	if (plsline == plsc->plslineCur)
		plsc->plslineCur = NULL;  


	lserrNew = RemoveLineObjects(plsline);
	if (lserrNew != lserrNone && lserr == lserrNone)
		lserr = lserrNew; 
	
	/* flush heap of dnodes */
	if (plsline->pqhAllDNodes != NULL)
		FlushQuickHeap(plsline->pqhAllDNodes);

	if (plsc->pqhAllDNodesRecycled != NULL)
				DestroyQuickHeap(plsc->pqhAllDNodesRecycled);

	/* recycle quick heap of dnodes */
	plsc->pqhAllDNodesRecycled = plsline->pqhAllDNodes;


	plsline->tag = tagInvalid;
	DisposeQuickPv(plsc->pqhLines, plsline,
			 cbRep(struct lsline, rgplnobj, plsc->lsiobjcontext.iobjMac));

	plsc->cLinesActive -= 1;

	plsc->lsstate = LsStateFree;
	return lserr;
}

/* ---------------------------------------------------------------------- */

/*  L S  G E T  L I N E  D U R   */
/*----------------------------------------------------------------------------
    %%Function: LsGetLineDur
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) LS context
	plsline			-	(IN) ptr to a line 
	pdurInclTrail	-	(OUT) dur of line incl. trailing area
	pdurExclTrail	-	(OUT)  dur of line excl. trailing area

----------------------------------------------------------------------------*/
LSERR  WINAPI LsGetLineDur	(PLSC plsc,	PLSLINE plsline,
							 long* pdurInclTrail, long* pdurExclTrail)
	{
	LSERR lserr;

	if (!FIsLSC(plsc))
		return lserrInvalidContext;

	if (!FIsLSLINE(plsline))
		return lserrInvalidLine;

	if (plsline->lssubl.plsc != plsc)
		return lserrMismatchLineContext;

	if (plsc->lsstate != LsStateFree)
		return lserrContextInUse;

	Assert(FIsLsContextValid(plsc));
	Assert(plsc->cLinesActive > 0);

	/* check that the line is active */
	if (plsline != plsc->plslineCur)
		return lserrLineIsNotActive;

	/* set breaking state */
	plsc->lsstate = LsStateBreaking;  

	lserr = GetLineDurCore(plsc, pdurInclTrail, pdurExclTrail);

	plsc->lsstate = LsStateFree; 
	
	return lserr;

	}
/* ---------------------------------------------------------------------- */

/*  L S  G E T  M I N  D U R  B R E A K S  */
/*----------------------------------------------------------------------------
    %%Function: LsGetMinDurBreaks
    %%Contact: igorzv
Parameters:
	plsc				-	(IN) LS context
	plsline				-	(IN) ptr to a line 
	pdurMinInclTrail	-	(OUT) min dur between breaks including trailing area
	pdurMinExclTrail	-	(OUT) min dur between breaks excluding trailing area

----------------------------------------------------------------------------*/

LSERR  WINAPI LsGetMinDurBreaks		(PLSC plsc,	PLSLINE plsline,
									 long* pdurMinInclTrail, long* pdurMinExclTrail)
	{
	LSERR lserr;

	if (!FIsLSC(plsc))
		return lserrInvalidContext;

	if (!FIsLSLINE(plsline))
		return lserrInvalidLine;

	if (plsline->lssubl.plsc != plsc)
		return lserrMismatchLineContext;

	if (plsc->lsstate != LsStateFree)
		return lserrContextInUse;

	Assert(FIsLsContextValid(plsc));
	Assert(plsc->cLinesActive > 0);

	/* check that the line is active */
	if (plsline != plsc->plslineCur)
		return lserrLineIsNotActive;

	/* set breaking state */
	plsc->lsstate = LsStateBreaking;  

	lserr = GetMinDurBreaksCore(plsc, pdurMinInclTrail, pdurMinExclTrail);

	plsc->lsstate = LsStateFree; 
	
	return lserr;

	}

/*----------------------------------------------------------------------*/
#define grpfTextMask ( \
		fFmiVisiCondHyphens | \
		fFmiVisiParaMarks | \
		fFmiVisiSpaces | \
		fFmiVisiTabs | \
		fFmiVisiBreaks | \
		fFmiDoHyphenation | \
		fFmiWrapTrailingSpaces | \
		fFmiWrapAllSpaces | \
		fFmiPunctStartLine | \
		fFmiHangingPunct | \
		fFmiApplyBreakingRules | \
		fFmiFCheckTruncateBefore | \
		fFmiDrawInCharCodes | \
		fFmiSpacesInfluenceHeight  | \
		fFmiIndentChangesHyphenZone | \
		fFmiNoPunctAfterAutoNumber  | \
		fFmiTreatHyphenAsRegular \
		)


/*----------------------------------------------------------------------------*/
/* I N I T  T E X T  P A R A M S */
/*----------------------------------------------------------------------------
    %%Function: InitTextParams
    %%Contact: igorzv
Parameters:
	plsc		-		(IN) ptr to line services context 
	cp,			-		(IN) cp to start fetch	
	duaCol		-		(IN) duaColumn	
	plsfrun		-		(IN) lsfrun of the first run	
	plschp		-		(OUT) lsfrun of the first run	
	plgeom		-		(OUT) set of flags and parameters about a line 


    LsCreateLine calls this function at the beginning of the line in order
	to skip over vanished text, fetch an LSPAP, and invoke the text APIs
	SetTextLineParams().
----------------------------------------------------------------------------*/
static LSERR InitTextParams(PLSC plsc, LSCP cp, long duaCol,
							LSFRUN* plsfrun, PLSCHP plschp, LINEGEOMETRY* plgeom)
	{
	LSERR lserr;
	LSPAP lspap;
	POLS pols = plsc->pols;
	BOOL fFirstLineInPara;
	BOOL fHidden;
	BOOL fStopped = fFalse;
	BOOL fNoLinesParaBefore;
	BOOL fNewPara;
	
	plsfrun->lpwchRun = NULL;
	plsfrun->plsrun = NULL;
	plsfrun->cwchRun = 0;

	plgeom->fYsrChangeAfter = fFalse;
	
	Assert(cp >= 0);
	
	lserr = plsc->lscbk.pfnFetchPap(pols, cp, &lspap);
	if (lserr != lserrNone)
		return lserr;
	if (FPapInconsistent(&lspap))
		return lserrInvalidPap;
	
	/* N.B. lspap.cpFirstContent may be negative, which indicates
	* "no content in this paragraph".
	*/
	
	fNoLinesParaBefore = lspap.cpFirstContent < 0 || cp <= lspap.cpFirstContent;
	
	if (!fNoLinesParaBefore && (lspap.grpf & fFmiDoHyphenation))
		{
		lserr = GetYsrChangeAfterRun(plsc, cp, &plgeom->fYsrChangeAfter, plsfrun, plschp, plgeom);
		if (lserr != lserrNone)
			return lserr;
		
		if (plgeom->fYsrChangeAfter)
			{
			fFirstLineInPara = fFalse;
			fStopped = fFalse;
			lserr = FillTextParams(plsc, cp, duaCol, &lspap, fFirstLineInPara, 
				fStopped, plgeom);
			if (lserr != lserrNone)
				return ErrReleasePreFetchedRun(plsc, plsfrun->plsrun, lserr);
			else
				return lserrNone;
			}
		}
	
	lserr = plsc->lscbk.pfnFetchRun(pols, cp,&plsfrun->lpwchRun, &plsfrun->cwchRun,
									&fHidden, plschp,	&plsfrun->plsrun);
	if (lserr != lserrNone)
		return lserr;
	
	
	if (fHidden)		/* vanished text */
		{
		lserr = FetchUntilVisible(plsc, &lspap, &cp, plsfrun, plschp, 
			&fStopped, &fNewPara);
		if (lserr != lserrNone)
			return lserr;
		if (fNewPara)
			fNoLinesParaBefore = fTrue;
		}
	
	fFirstLineInPara = fNoLinesParaBefore && FBetween(lspap.cpFirstContent, 0, cp);
	lserr = FillTextParams(plsc, cp, duaCol, &lspap, fFirstLineInPara,
		fStopped, plgeom);
	if (lserr != lserrNone)
		return ErrReleasePreFetchedRun(plsc, plsfrun->plsrun, lserr);
	else
		return lserrNone;
	
	}

/*----------------------------------------------------------------------------*/
/* G E T  Y S R  C H A N G E  A F T E R  R U N */
/*----------------------------------------------------------------------------
    %%Function: GetYsrChangeAfterRun
    %%Contact: igorzv
Parameters:
	plsc		-		(IN) ptr to line services context 
	cp,			-		(IN) cp to start fetch	
	pfYsrChangeAfter	(OUT) is it hyphenation of the previous line 
	plsfrun,			(OUT) lsfrun of modified first run
	plschp				(OUT) lschp of modified first run
	plsgeom				(OUT) to put wchYsr 


	InitTextParams calls this procedure if there is a possibility 
	for previous line to be hyphenated.
	If previous line has been hyphenated with ysr change after procedure returns
	modified first run for a line
----------------------------------------------------------------------------*/

static LSERR GetYsrChangeAfterRun(PLSC plsc, LSCP cp, BOOL* pfYsrChangeAfter,
								  PLSFRUN plsfrun, PLSCHP plschp, LINEGEOMETRY* plgeom)
	{
	LSFRUN lsfrunPrev;
	LSCHP lschpPrev;
	BOOL fHidden;
	LSERR lserr;
	
	lsfrunPrev.plschp = &lschpPrev;
	*pfYsrChangeAfter = fFalse;
	
	/* Fetch run at cp-1 to handle ysrChangeAfter from previous line.
	*/
	lserr = plsc->lscbk.pfnFetchRun(plsc->pols, cp-1, &lsfrunPrev.lpwchRun,
		&lsfrunPrev.cwchRun, &fHidden, 
		&lschpPrev, &lsfrunPrev.plsrun);
	if (lserr != lserrNone)
		return lserr;

	/* previous run is hyphenated text */
	if (!fHidden && ((lsfrunPrev.plschp)->idObj == idObjTextChp)
		&& (lsfrunPrev.plschp)->fHyphen)
		{
		DWORD kysr;
		WCHAR wchYsr;
		Assert(lsfrunPrev.cwchRun == 1);
		
		lserr = plsc->lscbk.pfnGetHyphenInfo(plsc->pols, lsfrunPrev.plsrun, &kysr, &wchYsr);
		if (lserr != lserrNone)
			return ErrReleasePreFetchedRun(plsc, lsfrunPrev.plsrun, lserr);
		
		if ((kysr == kysrChangeAfter) &&
			(wchYsr != 0))
			{
			lserr = plsc->lscbk.pfnFetchRun(plsc->pols, cp, &plsfrun->lpwchRun,
				&plsfrun->cwchRun, &fHidden, 
				plschp, &plsfrun->plsrun);
			if (lserr != lserrNone)
				return ErrReleasePreFetchedRun(plsc, lsfrunPrev.plsrun, lserr);
			
			if (!fHidden)
				{
				Assert((plsfrun->plschp)->idObj == idObjTextChp);
				plgeom->wchYsr = wchYsr;
				/* Synthesize a 1-byte run */
				plsfrun->lpwchRun = &plgeom->wchYsr; /* here is the only reason to keep wchrChar in lgeom
				we cann't use local memory to keep it */
				plsfrun->cwchRun = 1;
				plschp->fHyphen = kysrNil; 
				
				*pfYsrChangeAfter = fTrue;
				}
			else
				{
				if (!plsc->fDontReleaseRuns)
					{
					lserr = plsc->lscbk.pfnReleaseRun(plsc->pols, plsfrun->plsrun);
					if (lserr != lserrNone)
						return ErrReleasePreFetchedRun(plsc, lsfrunPrev.plsrun, lserr);
					
					}
				}
			}
		}
	/* Release run from previous line */
	if (!plsc->fDontReleaseRuns)
		{
		
		lserr = plsc->lscbk.pfnReleaseRun(plsc->pols, lsfrunPrev.plsrun);
		if (lserr != lserrNone)
			return ErrReleasePreFetchedRun(plsc, plsfrun->plsrun, lserr);
		}
	return lserrNone;
	}

/*----------------------------------------------------------------------------*/
/* F I L L  T E X T  P A R A M S */
/*----------------------------------------------------------------------------
    %%Function: FillTextParamsTextParams
    %%Contact: igorzv
Parameters:
	plsc		-		(IN) ptr to line services context 
	cp,			-		(IN) cp to start fetch	
	duaCol		-		(IN) duaColumn	
	plspap		-		(IN) paragraph properties
	fFirstLineInPara-	(IN) flag fFirstLineInPara 
	fStopped	-		(IN) flag fStopped	
	plgeom		-		(OUT) set of flags and parameters about a line 


    LsCreateLine calls this function at the beginning of the line in order
	to skip over vanished text, fetch an LSPAP, and invoke the text APIs
	SetTextLineParams().
----------------------------------------------------------------------------*/

static LSERR FillTextParams(PLSC plsc, LSCP cp, long duaCol, PLSPAP plspap,
			   BOOL fFirstLineInPara, BOOL fStopped, LINEGEOMETRY* plgeom)
	{
	LSERR lserr;
	TLPR tlpr;
	DWORD iobjText;
	PILSOBJ pilsobjText;
	PLNOBJ plnobjText;
	long uaLeft;
	PLSLINE plsline = plsc->plslineCur;
	long duaColumnMaxBreak;
	long duaColumnMaxJustify;
	long urLeft;

	/* Copy information from lspap to context  current line  and local for LsCreateLine structure lgeom */
	
	uaLeft = plspap->uaLeft;
	if (fFirstLineInPara)
		uaLeft += plspap->duaIndent;
	urLeft = UrFromUa(LstflowFromSubline(GetMainSubline(plsc)),
		&plsc->lsdocinf.lsdevres, uaLeft);

	
	/* line  */
	plsline->lslinfo.fFirstLineInPara = fFirstLineInPara;
	plsline->lslinfo.cpFirstVis = cp;
	plsline->lssubl.lstflow = plspap->lstflow;
	
	if (duaCol != uLsInfiniteRM && plspap->uaRightBreak < uLsInfiniteRM 
		&& plspap->uaRightJustify < uLsInfiniteRM)
		{
		duaColumnMaxBreak = duaCol - plspap->uaRightBreak;
		duaColumnMaxJustify = duaCol - plspap->uaRightJustify;
		}
	else{
		if (duaCol == uLsInfiniteRM)
			{
			duaColumnMaxBreak = uLsInfiniteRM;
			duaColumnMaxJustify = uLsInfiniteRM;
			}
		else
			{
			if (plspap->uaRightBreak >= uLsInfiniteRM)
				duaColumnMaxBreak = uLsInfiniteRM;
			else
				duaColumnMaxBreak = duaCol - plspap->uaRightBreak;
			if (plspap->uaRightJustify >= uLsInfiniteRM)
				duaColumnMaxJustify = uLsInfiniteRM;
			else
				duaColumnMaxJustify = duaCol - plspap->uaRightJustify;
			}
		}
				
	
	/* fill in context for adjustment */
	SetLineLineContainsAutoNumber(plsc, (plspap->grpf & fFmiAnm) && fFirstLineInPara);
	SetUnderlineTrailSpacesRM(plsc, plspap->grpf & fFmiUnderlineTrailSpacesRM);
	SetForgetLastTabAlignment(plsc, plspap->grpf & fFmiForgetLastTabAlignment);
	plsc->lsadjustcontext.lskj = plspap->lskj;
	plsc->lsadjustcontext.lskalign = plspap->lskal;
	plsc->lsadjustcontext.lsbrj = plspap->lsbrj;
	plsc->lsadjustcontext.urLeftIndent = urLeft;
	plsc->lsadjustcontext.urStartAutonumberingText =0;
	plsc->lsadjustcontext.urStartMainText = urLeft; /* autonumber can change it later */
	if (duaColumnMaxJustify != uLsInfiniteRM)
		{
		plsc->lsadjustcontext.urRightMarginJustify = UrFromUa(
												 LstflowFromSubline(GetMainSubline(plsc)),
												 &(plsc->lsdocinf.lsdevres), duaColumnMaxJustify);
		}
	else
		{
		plsc->lsadjustcontext.urRightMarginJustify = uLsInfiniteRM;
		}
	if (duaColumnMaxBreak != uLsInfiniteRM)
		{
		plsc->urRightMarginBreak = UrFromUa(LstflowFromSubline(GetMainSubline(plsc)),
								&(plsc->lsdocinf.lsdevres), duaColumnMaxBreak); 
		}
	else
		{
		plsc->urRightMarginBreak = uLsInfiniteRM;
		}
	plsc->fIgnoreSplatBreak = plspap->grpf & fFmiIgnoreSplatBreak;
	plsc->grpfManager = plspap->grpf;
	plsc->fLimSplat = plspap->grpf & fFmiLimSplat;
	plsc->urHangingTab = UrFromUa(LstflowFromSubline(GetMainSubline(plsc)),
								 &(plsc->lsdocinf.lsdevres), plspap->uaLeft); 

	/* snap grid */
	if (plspap->lskj == lskjSnapGrid)
		{
		if (duaCol != uLsInfiniteRM)
			{
			plsc->lsgridcontext.urColumn = UrFromUa(
				LstflowFromSubline(GetMainSubline(plsc)),
				&(plsc->lsdocinf.lsdevres), duaCol);
			}
		else
			{
			plsc->lsgridcontext.urColumn = uLsInfiniteRM;
			}
		}
	
	/* lgeom */
	plgeom->cpFirstVis = cp;			
	plgeom->urLeft = urLeft;
	plgeom->fAutonumber =  (plspap->grpf & fFmiAnm) && fFirstLineInPara;
	if (plspap->grpf & fFmiAutoDecimalTab)
		{
		plgeom->fAutoDecimalTab = fTrue;
		plgeom->durAutoDecimalTab = UrFromUa(LstflowFromSubline(GetMainSubline(plsc)),
			&(plsc->lsdocinf.lsdevres), plspap->duaAutoDecimalTab);
		}
	else
		{
		plgeom->fAutoDecimalTab = fFalse;
		plgeom->durAutoDecimalTab = LONG_MIN;
		}
	plgeom->fStopped = fStopped;
	
	
	/* prepare tlpr for text */
	
	tlpr.grpfText = (plspap->grpf & grpfTextMask);
	tlpr.fSnapGrid = (plspap->lskj == lskjSnapGrid);
	tlpr.duaHyphenationZone = plspap->duaHyphenationZone;
	tlpr.lskeop = plspap->lskeop;
	
	
	/* we know that here is the first place we need plnobjText and we are creating it */
	iobjText = IobjTextFromLsc(&(plsc->lsiobjcontext));
	Assert( PlnobjFromLsline(plsline,iobjText) == NULL);
	pilsobjText = PilsobjFromLsc(&(plsc->lsiobjcontext), iobjText);
	lserr = CreateLNObjText(pilsobjText, &(plsline->rgplnobj[iobjText]));
	if (lserr != lserrNone)
		return lserr;
	plnobjText = PlnobjFromLsline(plsline, iobjText);
	
	lserr = SetTextLineParams(plnobjText, &tlpr);
	if (lserr != lserrNone)
		return lserr;
	
	return lserrNone;
	}

/*----------------------------------------------------------------------------
/* F E T C H  U N T I L  V I S I B L E */
/*----------------------------------------------------------------------------
    %%Function: FetchUntilVisible
    %%Contact: igorzv
Parameters:
	plsc		-		(IN) ptr to line services context 
	plspap		-		(IN/OUT) current lspap before and after 
	pcp			-		(IN/OUT) current cp before and after 
	plsfrun		-		(IN/OUT) current lsfrun before and after 
	plschp		-		(IN/OUT) current lschp before and after 
	pfStopped	-		(OUT) fStopped: procedure stopped fetching because has not been allowed
						        to go across paragraph boundaries (result CheckPara Boundaries)
	pfNewPara	-		(OUT) fNewPara: procedure crossed paragraph boundaries 

	Releases the supplied PLSRUN, if any, and fetches runs, starting at
	the supplied cp, until a non-vanished run is fetched. As paragraph
	boundaries are crossed, the LSPAP is updated.

----------------------------------------------------------------------------*/
static LSERR FetchUntilVisible(PLSC plsc, LSPAP* plspap, LSCP* pcp,	
							   LSFRUN* plsfrun, PLSCHP plschp,
							   BOOL* pfStopped,	BOOL* pfNewPara)	
	{
	LSERR lserr;
	LSCP dcpPrevRun = plsfrun->cwchRun;
	BOOL fHidden;
	*pfStopped = fFalse;
	*pfNewPara = fFalse;
	
	/* we assume here that this finction is called only after hidden run has been fetched
	   and such run is passed as an input parameter */
	
	do
		{
		const PLSRUN plsrunT = plsfrun->plsrun;
		
		
		*pcp += dcpPrevRun;
		lserr = plsc->lscbk.pfnCheckParaBoundaries(plsc->pols, *pcp - dcpPrevRun, *pcp, pfStopped);
		if (lserr != lserrNone)
			return ErrReleasePreFetchedRun(plsc, plsrunT, lserr);
		if (*pfStopped)
			return lserrNone;
		
		lserr = plsc->lscbk.pfnFetchPap(plsc->pols, *pcp, plspap);
		if (lserr != lserrNone)
			return ErrReleasePreFetchedRun(plsc, plsrunT, lserr);
		if (FPapInconsistent(plspap))
			return ErrReleasePreFetchedRun(plsc, plsrunT, lserrInvalidPap);
		
		if ((*pcp - dcpPrevRun) < plspap->cpFirst)
			*pfNewPara = fTrue;
		
		
		plsfrun->plsrun = NULL;
		if (plsrunT != NULL && !plsc->fDontReleaseRuns)
			{
			lserr = plsc->lscbk.pfnReleaseRun(plsc->pols, plsrunT);
			if (lserr != lserrNone)
				return lserr;
			}
		
		
		lserr = plsc->lscbk.pfnFetchRun(plsc->pols, *pcp,
			&plsfrun->lpwchRun,
			&plsfrun->cwchRun,
			&fHidden,
			plschp,
			&plsfrun->plsrun);
		if (lserr != lserrNone)
			return lserr;
		
		dcpPrevRun = plsfrun->cwchRun;
		}
		while (fHidden);
		
		return lserrNone;
	}




/* I N I T  C U R  L I N E  */
/*----------------------------------------------------------------------------
    %%Function: InitCurLine
    %%Contact: igorzv

Parameters:
	plsc		-	(IN) ptr to line services context 
	cpFirst		-	(IN) starting cp for a line

	Set default value in lsline
----------------------------------------------------------------------------*/

static LSERR InitCurLine(PLSC plsc, LSCP cpFirst)
{
	PLSLINE plsline = plsc->plslineCur;

	memset(plsline, 0, cbRep(struct lsline, rgplnobj, plsc->lsiobjcontext.iobjMac));
	plsline->tag = tagLSLINE;
	plsline->lssubl.tag = tagLSSUBL;
	plsline->lssubl.plsc = plsc;
	plsline->lssubl.cpFirst = cpFirst;

	/* reuse quick heap for dnodes if it possible */
	if (plsc->pqhAllDNodesRecycled != NULL)
		{
		plsline->pqhAllDNodes = plsc->pqhAllDNodesRecycled;
		plsc->pqhAllDNodesRecycled = NULL;
		}
	else
		{
		plsline->pqhAllDNodes = CreateQuickHeap(plsc, limAllDNodes,
										 sizeof (struct lsdnode), fTrue);
		if (plsline->pqhAllDNodes == NULL  )
			return lserrOutOfMemory;

		}

	plsline->lssubl.fDupInvalid = fTrue;
	plsline->lssubl.fContiguous = fTrue;
	plsline->lssubl.plschunkcontext = &(plsc->lschunkcontextStorage);
	plsline->lssubl.fMain = fTrue;
	TurnOnAllSimpleText(plsc); 
	plsline->lslinfo.nDepthFormatLineMax = 1;
	TurnOffLineCompressed(plsc);
	TurnOffNominalToIdealEncounted(plsc);
	TurnOffForeignObjectEncounted(plsc);
	TurnOffTabEncounted(plsc);
	TurnOffNonLeftTabEncounted(plsc);
	TurnOffSubmittedSublineEncounted(plsc);
	TurnOffAutodecimalTabPresent(plsc);
	plsc->fHyphenated = fFalse;
	plsc->fAdvanceBack = fFalse;


	/* we use memset to set default value, below we check that after memset we really have
	correct defaults   */
	Assert(plsline->lssubl.plsdnFirst == NULL);  
	Assert(plsline->lssubl.urColumnMax == 0);  
	Assert(plsline->lssubl.cpLim == 0);  
 	Assert(plsline->lssubl.plsdnLast == NULL);  
	Assert(plsline->lssubl.urCur == 0);  
	Assert(plsline->lssubl.vrCur == 0);  
	Assert(plsline->lssubl.fAcceptedForDisplay == fFalse);  
	Assert(plsline->lssubl.fRightMarginExceeded == fFalse);
 	Assert(plsline->lssubl.plsdnUpTemp == NULL);  
	Assert(plsline->lssubl.pbrkcontext == NULL);

	Assert(plsline->lslinfo.dvpAscent == 0);  /* lslinfo   */
	Assert(plsline->lslinfo.dvrAscent == 0);
	Assert(plsline->lslinfo.dvpDescent == 0);
	Assert(plsline->lslinfo.dvrDescent == 0);
	Assert(plsline->lslinfo.dvpMultiLineHeight == 0);
	Assert(plsline->lslinfo.dvrMultiLineHeight == 0);
	Assert(plsline->lslinfo.dvpAscentAutoNumber == 0);
	Assert(plsline->lslinfo.dvrAscentAutoNumber == 0);
	Assert(plsline->lslinfo.dvpDescentAutoNumber == 0);
	Assert(plsline->lslinfo.dvrDescentAutoNumber == 0);
	Assert(plsline->lslinfo.cpLim == 0);
	Assert(plsline->lslinfo.dcpDepend == 0);
	Assert(plsline->lslinfo.cpFirstVis == 0);
	Assert(plsline->lslinfo.endr == endrNormal);
	Assert(plsline->lslinfo.fAdvanced == fFalse);
	Assert(plsline->lslinfo.vaAdvance == 0);
	Assert(plsline->lslinfo.fFirstLineInPara == fFalse);
	Assert(plsline->lslinfo.EffectsFlags == 0);
	Assert(plsline->lslinfo.fTabInMarginExLine == fFalse);
	Assert(plsline->lslinfo.fForcedBreak == fFalse);

	Assert(plsline->upStartAutonumberingText == 0);  
	Assert(plsline->upLimAutonumberingText == 0);  
	Assert(plsline->upStartMainText == 0);  
	Assert(plsline->upLimLine == 0);  
	Assert(plsline->dvpAbove == 0);  
	Assert(plsline->dvpBelow == 0);  
	Assert(plsline->upRightMarginJustify == 0);  
	Assert(plsline->upLimUnderline == 0);  
	Assert(plsline->kspl == ksplNone);
	Assert(!plsline->fCollectVisual);
	Assert(!plsline->fNonRealDnodeEncounted);
	Assert(!plsline->fNonZeroDvpPosEncounted);
	Assert(plsline->AggregatedDisplayFlags == 0);
	Assert(plsline->pad == 0);

#ifdef DEBUG
	{
		DWORD i;
		for (i=0; i < plsc->lsiobjcontext.iobjMac; i++)
			{
			Assert(plsline->rgplnobj[i] == NULL);
			}
	}
#endif

	return lserrNone;
}


/*----------------------------------------------------------------------------
/* C A N N O T  C R E A T E  L I N E */
/*----------------------------------------------------------------------------
    %%Function: CannotCreateLine
    %%Contact: igorzv
Parameters:
	pplsline	-	(IN) ponter to a line structure to be deleted	
	lserr		-	(IN) code of an error	

	Called when LsCreateLine needs to return for an error condition.
----------------------------------------------------------------------------*/
static LSERR CannotCreateLine(PLSLINE* pplsline, LSERR lserr) 
{
	LSERR lserrIgnore;
	PLSLINE plsline = *pplsline;
	PLSC plsc = plsline->lssubl.plsc;

	plsc->plslineCur = NULL; 
	plsc->lsstate = LsStateFree;  /*  we need free context to destroy line */

	lserrIgnore = LsDestroyLine(plsc, plsline);

	*pplsline = NULL;   
	return lserr;
}

/*----------------------------------------------------------------------------
/* E R R  R E L E A S E  P R E F E T C H E D  R U N */
/*----------------------------------------------------------------------------
    %%Function: ErrReleasePreFetchedRun
    %%Contact: igorzv
Parameters:
	plsc		-	(IN) ptr to line services context 
	plsrun		-	(IN) ponter to a run structure to be deleted	
	lserr		-	(IN) code of an error	

	Called in a error situation when fist run of main text has been prefetched .
----------------------------------------------------------------------------*/
static LSERR ErrReleasePreFetchedRun(PLSC plsc, PLSRUN plsrun, LSERR lserr) 
{
	LSERR lserrIgnore;

	if (!plsc->fDontReleaseRuns)
			lserrIgnore = plsc->lscbk.pfnReleaseRun(plsc->pols, plsrun);

	return lserr;
}


/* R E M O V E  L I N E  O B J E C T S */
/*----------------------------------------------------------------------------
    %%Function: RemoveLineObjects
    %%Contact: igorzv
Parameter:
	plsc		-	(IN) ponter to a line structure

    Removes a line context of installed objects from an line.
----------------------------------------------------------------------------*/
LSERR RemoveLineObjects(PLSLINE plsline)
{
	DWORD iobjMac;
	PLSC plsc;
	LSERR lserr, lserrFinal = lserrNone;
	DWORD iobj;
	PLNOBJ plnobj;

	Assert(FIsLSLINE(plsline));

	plsc = plsline->lssubl.plsc;
	Assert(FIsLSC(plsc));
	Assert(plsc->lsstate == LsStateDestroyingLine);
	
	iobjMac = plsc->lsiobjcontext.iobjMac;	

	for (iobj = 0;  iobj < iobjMac;  iobj++)
		{
		plnobj = plsline->rgplnobj[iobj];
		if (plnobj != NULL)
			{
			lserr = plsc->lsiobjcontext.rgobj[iobj].lsim.pfnDestroyLNObj(plnobj);
			plsline->rgplnobj[iobj] = NULL;
			if (lserr != lserrNone)
				lserrFinal = lserr;
			}
		}

	return lserrFinal;	
}




#ifdef DEBUG
/* F R O U N D I N G  O K */
/*----------------------------------------------------------------------------
    %%Function: FRoundingOK
    %%Contact: lenoxb

    Checks for correctness of rounding algorithm in converting absolute to
	device units, to agree with Word 6.0.

	Checks that:
		0.5 rounds up to 1.0,
		1.4 rounds down to 1.4, 
		-0.5 rounds down to -1.0, and
		-1.4 rounds up to -1.0.
		
----------------------------------------------------------------------------*/
static BOOL FRoundingOK(void)
{
	LSDEVRES devresT;

	Assert((czaUnitInch % 10) == 0);

	devresT.dxpInch = czaUnitInch / 10;

	if (UpFromUa(lstflowDefault, &devresT, 5) != 1)
		return fFalse;
	if (UpFromUa(lstflowDefault, &devresT, 14) != 1)
		return fFalse;
	if (UpFromUa(lstflowDefault, &devresT, -5) != -1)
		return fFalse;
	if (UpFromUa(lstflowDefault, &devresT, -14) != -1)
		return fFalse;

	return fTrue;
}
#endif /* DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\lsdnset.c ===
#include "lsdnset.h"
#include "lsc.h"
#include "lsdnode.h"
#include "dnutils.h"
#include "iobj.h"
#include "ntiman.h"
#include "tabutils.h"
#include "getfmtst.h"
#include "setfmtst.h"
#include "lstext.h"
#include "dninfo.h"
#include "chnutils.h"
#include "lssubl.h"
#include "sublutil.h"
#include "lscfmtfl.h"
#include "iobjln.h"

#include "lsmem.h"						/* memset() */

#define FColinearTflows(t1, t2)  \
			(((t1) & fUVertical) == ((t2) & fUVertical))


/* L S D N  Q U E R Y  O B J  D I M  R A N G E */
/*----------------------------------------------------------------------------
    %%Function: LsdnQueryObjDimRange
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 
	plsdnFirst		-	(IN) first dnode in the range
	plsdnLast		-	(IN) last dnode in the range
	pobjdim			-	(OUT) geometry of the range

----------------------------------------------------------------------------*/

LSERR WINAPI LsdnQueryObjDimRange(PLSC plsc,
					  PLSDNODE plsdnFirst, PLSDNODE plsdnLast,
					  POBJDIM pobjdim)
{
	PLSDNODE plsdn;
	LSERR lserr;

	if (pobjdim == NULL)
		return lserrNullOutputParameter;

	if (!FIsLSC(plsc))
		return lserrInvalidContext;

	/* if client call us with empty range return right away */
	if (plsdnFirst == NULL)
		{
		if (plsdnLast != NULL) 
			return lserrInvalidDnode;
		memset(pobjdim, 0, sizeof(OBJDIM));
		return lserrNone;
		}

	if (!FIsLSDNODE(plsdnFirst))
		return lserrInvalidDnode;
	if (!FIsLSDNODE(plsdnLast))
		return lserrInvalidDnode;
	if (plsdnFirst->plssubl != plsdnLast->plssubl)							
		return lserrInvalidDnode;

	/* we should call NominalToIdeal if we are in formating stage and range intersects last chunk 
	and this chunk is chunk of text*/
	plsdn = plsdnLast;
	/* to find chunk where we are we should skip back borders */
	while (plsdn != NULL && FIsDnodeBorder(plsdn))
		{
		plsdn = plsdn->plsdnPrev;
		}

	if ((plsc->lsstate == LsStateFormatting) && 
		 FNominalToIdealEncounted(plsc) &&
		(plsdn != NULL) && 
		FIsDnodeReal(plsdn) &&
		(IdObjFromDnode(plsdn) == IobjTextFromLsc(&plsc->lsiobjcontext)) 
	   )
		{
		for(; !FIsChunkBoundary(plsdn->plsdnNext, IobjTextFromLsc(&plsc->lsiobjcontext),
								plsdnLast->cpFirst);
			   plsdn=plsdn->plsdnNext);
		if (plsdn->plsdnNext == NULL)
			{
			lserr = ApplyNominalToIdeal(PlschunkcontextFromSubline(plsdnFirst->plssubl),
				&plsc->lsiobjcontext, plsc->grpfManager, plsc->lsadjustcontext.lskj,
				FIsSubLineMain(SublineFromDnode(plsdn)), FLineContainsAutoNumber(plsc),
				plsdn);
			if (lserr != lserrNone)
				return lserr;
			}
		}  


	return FindListDims(plsdnFirst, plsdnLast, pobjdim);


}

/* L S D N  G E T  C U R  T A B  I N F O */
/*----------------------------------------------------------------------------
    %%Function: LsdnGetCurTabInfo
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 
	plsktab			-	(OUT) type of current tab

  Finds tab stop nearest to the current pen position and returns type of such tab stop.
----------------------------------------------------------------------------*/

LSERR WINAPI LsdnGetCurTabInfo(PLSC plsc, LSKTAB* plsktab)
{
	PLSDNODE plsdnTab;
	LSTABSCONTEXT* plstabscontext;
	BOOL fBreakThroughTab;
	LSERR lserr;
	long urNewMargin;
	
	if (!FIsLSC(plsc)) return lserrInvalidParameter;

	if (!FFormattingAllowed(plsc)) return lserrFormattingFunctionDisabled;

	if (plsktab == NULL) return lserrInvalidParameter;

	plsdnTab = GetCurrentDnode(plsc);
	plstabscontext = &(plsc->lstabscontext);

	Assert(FIsLSDNODE(plsdnTab));
	if (!plsdnTab->fTab) return lserrCurrentDnodeIsNotTab;
	Assert(FIsDnodeReal(plsdnTab));

	if (plstabscontext->plsdnPendingTab != NULL) return lserrPendingTabIsNotResolved;


	lserr = GetCurTabInfoCore(&plsc->lstabscontext, plsdnTab, GetCurrentUr(plsc), fFalse,
			plsktab, &fBreakThroughTab);
	if (lserr != lserrNone)
		return lserr;

	TurnOnTabEncounted(plsc);
	if (*plsktab != lsktLeft)
		TurnOnNonLeftTabEncounted(plsc);


	/* move current pen position */
	AdvanceCurrentUr(plsc, DurFromDnode(plsdnTab));

	if (fBreakThroughTab)
		{
		lserr = GetMarginAfterBreakThroughTab(&plsc->lstabscontext, plsdnTab, &urNewMargin);
		if (lserr != lserrNone)
			return lserr;

		SetBreakthroughLine(plsc, urNewMargin);
		}

	return lserrNone;

}

/* L S D N  R E S O L V E  P R E V  T A B */
/*----------------------------------------------------------------------------
    %%Function: LsdnResolvePrevTab
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 

----------------------------------------------------------------------------*/

LSERR WINAPI LsdnResolvePrevTab(PLSC plsc)
{
	long dur;
	LSERR lserr;

	if (!FIsLSC(plsc)) return lserrInvalidParameter;

	if (!FFormattingAllowed(plsc)) return lserrFormattingFunctionDisabled;

	lserr = ResolvePrevTabCore(&plsc->lstabscontext, GetCurrentDnode(plsc), GetCurrentUr(plsc),
							  &dur);
	if (lserr != lserrNone)
		return lserr;

	AdvanceCurrentUr(plsc, dur);

	return lserrNone;

}

/* L S D N  S K I P  C U R  T A B */
/*----------------------------------------------------------------------------
    %%Function: LsdnSkipCurTab
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 

----------------------------------------------------------------------------*/

LSERR WINAPI LsdnSkipCurTab(PLSC plsc)				/* IN: Pointer to LS Context */
{

	PLSDNODE plsdnTab;
	LSTABSCONTEXT* plstabscontext;

	if (!FIsLSC(plsc)) return lserrInvalidParameter;

	if (!FFormattingAllowed(plsc)) return lserrFormattingFunctionDisabled;

	plsdnTab = GetCurrentDnode(plsc);
	plstabscontext = &(plsc->lstabscontext);

	Assert(FIsLSDNODE(plsdnTab));
	if (!plsdnTab->fTab) return lserrCurrentDnodeIsNotTab;
	Assert(FIsDnodeReal(plsdnTab));


	if (plstabscontext->plsdnPendingTab != NULL)
		{
		CancelPendingTab(&plsc->lstabscontext);
		}
	else
		{
		AdvanceCurrentUr(plsc, - plsdnTab->u.real.objdim.dur);
		SetDnodeDurFmt(plsdnTab, 0);
		}

	return lserrNone;
}

/* L S D N  S E T  R I G I D  D U P */
/*----------------------------------------------------------------------------
    %%Function: LsdnSetRigidDup
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 
	plsdn			-	(IN) dnode to be modified
	dup				-	(IN) dup to put in the dnode

----------------------------------------------------------------------------*/

LSERR WINAPI LsdnSetRigidDup(PLSC plsc,	PLSDNODE plsdn,	long dup)
{

	if (!FIsLSC(plsc)) return lserrInvalidParameter;

	if (!FIsLSDNODE(plsdn)) return lserrInvalidParameter;

	if (!FFormattingAllowed(plsc)) return lserrFormattingFunctionDisabled;


	plsdn->fRigidDup = fTrue;

	if (plsdn->klsdn == klsdnReal)
		{
		plsdn->u.real.dup = dup;
		}
	else 
		{
		plsdn->u.pen.dup = dup;
		}

	return lserrNone;
}

/* L S D N  G E T  D U P */
/*----------------------------------------------------------------------------
    %%Function: LsdnGetDup
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 
	plsdn			-	(IN) dnode queried
	dup				-	(OUT) dup of this dnode

----------------------------------------------------------------------------*/
	
LSERR WINAPI LsdnGetDup(PLSC plsc, PLSDNODE plsdn, long* pdup)	
{

	if (!FIsLSC(plsc)) return lserrInvalidParameter;

	if (!FIsLSDNODE(plsdn)) return lserrInvalidParameter;

	/* check that dup in dnode is valid */

	if (plsdn->plssubl->fDupInvalid && !plsdn->fRigidDup)
		return lserrDupInvalid;

	*pdup = DupFromDnode(plsdn);

	return lserrNone;
}

/* L S D N  R E S E T  O B J  D I M */
/*----------------------------------------------------------------------------
    %%Function: LsdnResetObjDim
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 
	plsdn			-	(IN) dnode to be modified
	pobjdimNew		-	(IN) new dimensions of the dnode

----------------------------------------------------------------------------*/

LSERR WINAPI LsdnResetObjDim(PLSC plsc,	PLSDNODE plsdn,	PCOBJDIM pobjdimNew)	

{
	long durOld;

	if (!FIsLSC(plsc)) return lserrInvalidParameter;
	if (!FIsLSDNODE(plsdn)) return lserrInvalidParameter;
	if (!FIsDnodeReal(plsdn)) return lserrInvalidParameter;

	/* we should be in the stage of formatting or breaking */    
	if (!FFormattingAllowed(plsc) && !FBreakingAllowed(plsc))
		return lserrFormattingFunctionDisabled;

	durOld = plsdn->u.real.objdim.dur;
	
	SetDnodeObjdimFmt(plsdn, *pobjdimNew);

	/* update current pen position */
	AdvanceCurrentUrSubl(plsdn->plssubl, (plsdn->u.real.objdim.dur - durOld));

	return lserrNone;
}

/* L S D N  R E S E T  P E N  N O D E */
/*----------------------------------------------------------------------------
    %%Function: LsdnResetPenNode
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 
	plsdnPen		-	(IN) dnode to be modified
	dvpPen			-	(IN) new dvp of the dnode
	durPen			-	(IN) new dur of the dnode
	dvrPen			-	(IN) new dvr of the dnode

----------------------------------------------------------------------------*/


LSERR WINAPI LsdnResetPenNode(PLSC plsc, PLSDNODE plsdnPen,	
						  	  long dvpPen, long durPen, long dvrPen)	

{
	long durOld;
	long dvrOld;

	if (!FIsLSC(plsc)) return lserrInvalidParameter;
	if (!FIsLSDNODE(plsdnPen)) return lserrInvalidParameter;
	if (!FIsDnodePen(plsdnPen)) return lserrInvalidParameter;

	/* we should be in the stage of formatting  */
	if (!FFormattingAllowed(plsc)) return lserrFormattingFunctionDisabled;
	if (GetDnodeToFinish(plsc) == NULL) return lserrFormattingFunctionDisabled; 
	if (!FIsDnodeReal(GetDnodeToFinish(plsc)) )
			return lserrFormattingFunctionDisabled; 
	if (plsdnPen->plssubl != GetCurrentSubline(plsc)) return lserrInvalidParameter;

	durOld = plsdnPen->u.pen.dur;
	dvrOld = plsdnPen->u.pen.dvr;

	plsdnPen->u.pen.dvp = dvpPen;
	SetPenBorderDurFmt(plsdnPen, durPen);
	plsdnPen->u.pen.dvr = dvrPen;

	/* update current pen position */
	AdvanceCurrentUr(plsc, plsdnPen->u.pen.dur - durOld);
	AdvanceCurrentVr(plsc, plsdnPen->u.pen.dvr - dvrOld);

	return lserrNone;
}

/* L S D N  Q U E R Y  N O D E */
/*----------------------------------------------------------------------------
    %%Function: LsdnQueryPenNode
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 
	plsdnPen		-	(IN) dnode quried
	pdvpPen			-	(OUT) dvp of the dnode
	pdurPen			-	(OUT) dur of the dnode
	pdvrPen			-	(OUT) dvr of the dnode

----------------------------------------------------------------------------*/

LSERR WINAPI LsdnQueryPenNode(PLSC plsc, PLSDNODE plsdnPen,	
						  	  long* pdvpPen, long* pdurPen,	long* pdvrPen)		

{

	if (!FIsLSC(plsc)) return lserrInvalidParameter;
	if (!FIsLSDNODE(plsdnPen)) return lserrInvalidParameter;
	if (!FIsDnodePen(plsdnPen)) return lserrInvalidParameter;


	*pdvpPen = plsdnPen->u.pen.dvp;
	*pdurPen = plsdnPen->u.pen.dur;
	*pdvrPen = plsdnPen->u.pen.dvr;

	return lserrNone;
}

/* L S D N  S E T  A B S  B A S E  L I N E */
/*----------------------------------------------------------------------------
    %%Function:  LsdnSetAbsBaseLine
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 
	vaAdvanceNew	-	(IN) new vaBase

----------------------------------------------------------------------------*/

LSERR WINAPI LsdnSetAbsBaseLine(PLSC plsc, long vaAdvanceNew)	
{

	if (!FIsLSC(plsc)) return lserrInvalidParameter;

	/* we should be in the stage of formatting*/
	if (!FFormattingAllowed(plsc)) return lserrFormattingFunctionDisabled;
	
	plsc->plslineCur->lslinfo.fAdvanced = fTrue;
	plsc->plslineCur->lslinfo.vaAdvance = vaAdvanceNew;

	return lserrNone;
}


#define PlnobjFromLsc(plsc,iobj)	((Assert(FIsLSC(plsc)), PlnobjFromLsline((plsc)->plslineCur,iobj)))

/* L S D N  M O D I F Y  P A R A  E N D I N G*/
/*----------------------------------------------------------------------------
    %%Function:  LsdnModifyParaEnding
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 
	lskeop			-	(IN) Kind of line ending

----------------------------------------------------------------------------*/
LSERR WINAPI LsdnModifyParaEnding(PLSC plsc, LSKEOP lskeop)
{
	LSERR lserr;
	DWORD iobjText; 
	PLNOBJ plnobjText;  

	if (!FIsLSC(plsc)) return lserrInvalidParameter;

	/* we should be in the stage of formatting*/
	if (!FFormattingAllowed(plsc)) return lserrFormattingFunctionDisabled;
	
	iobjText = IobjTextFromLsc(&plsc->lsiobjcontext);
	plnobjText = PlnobjFromLsc(plsc, iobjText);

	lserr = ModifyTextLineEnding(plnobjText, lskeop);

	return lserr;
}

/* L S D N  D I S T R I B U T E */
/*----------------------------------------------------------------------------
    %%Function:  LsdnDistribute
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 
	plsdnFirst		-	(IN) first dnode in the range
	plsdnFirst		-	(IN) last dnode in the range
	durToDistribute	-	(IN) amount to distribute between dnodes

----------------------------------------------------------------------------*/

LSERR WINAPI LsdnDistribute(PLSC plsc, PLSDNODE plsdnFirst, 
							PLSDNODE plsdnLast,	long durToDistribute)

{
	GRCHUNKEXT grchunkext;
	LSERR lserr;
	long durToNonText;
	
	if (!FIsLSC(plsc)) return lserrInvalidParameter;
	if (!FIsLSDNODE(plsdnFirst)) return lserrInvalidParameter;
	if (!FIsLSDNODE(plsdnLast)) return lserrInvalidParameter;

	/* we should be in the stage of formatting or breaking*/
	if (!FFormattingAllowed(plsc) && !FBreakingAllowed(plsc))
		return lserrFormattingFunctionDisabled;

	InitGroupChunkExt(PlschunkcontextFromSubline(plsdnFirst->plssubl),
					  IobjTextFromLsc(&plsc->lsiobjcontext), &grchunkext);	

	/* skip first pen dnodes  */

	while (FIsDnodePen(plsdnFirst) && (plsdnFirst != plsdnLast))
		{
		plsdnFirst = plsdnFirst->plsdnNext;
		if (plsdnFirst == NULL)  /* plsdnFirst and plksdnLast are not in the same level */
			return lserrInvalidParameter;
		}

	if (FIsDnodePen(plsdnFirst)) /* only pens are in the list so there is no business for us */
		return lserrNone;

	while (FIsDnodePen(plsdnLast) && (plsdnLast != plsdnFirst))
		{
		plsdnLast = plsdnLast->plsdnPrev;
		if (plsdnLast == NULL)  /* plsdnFirst and plksdnLast are not in the same level */
			return lserrInvalidParameter;
		}

	Assert(!FIsDnodePen(plsdnLast));

	lserr = CollectTextGroupChunk(plsdnFirst, plsdnLast->cpFirst + plsdnLast->dcp,
								  CollectSublinesNone, &grchunkext);
	if (lserr != lserrNone)
		return lserr;

	/* Because of rigid dup it doesn't make sense to change dur of non text objects 
	   We inforce text to distrubute everything among text by setting amount of
	   non text to 0 */

	return DistributeInText(&(grchunkext.lsgrchnk), 
							LstflowFromSubline(SublineFromDnode(plsdnFirst)),
							0, durToDistribute, &durToNonText);

}


/* L S D N  S U B M I T  S U B L I N E S */
/*----------------------------------------------------------------------------
    %%Function:  LsdnSubmitSublines
    %%Contact: igorzv
Parameters:
	plsc					-	(IN) ptr to line services context 
	plsdnode				-	(IN) dnode 
	cSubline				-	(IN) amount of submitted sublines 
	rgpsubl					-	(IN) array of submitted sublines 
	fUseForJustification	-	(IN) to use for justification
	fUseForCompression		-	(IN) to use for compression
	fUseForDisplay			-	(IN) to use for display
	fUseForDecimalTab		-	(IN) to use for decimal tab
	fUseForTrailingArea		-	(IN) to use for calculating trailing area

----------------------------------------------------------------------------*/

LSERR WINAPI LsdnSubmitSublines(PLSC plsc, PLSDNODE plsdnode,	
							DWORD cSubline, PLSSUBL* rgpsubl,	
							BOOL fUseForJustification, BOOL fUseForCompression,
							BOOL fUseForDisplay, BOOL fUseForDecimalTab, 
							BOOL fUseForTrailingArea)	
	{
	DWORD i;
	BOOL fEmpty = fFalse;
	BOOL fEmptyWork;
	BOOL fTabOrPen = fFalse;
	BOOL fNotColinearTflow = fFalse;
	BOOL fNotSameTflow = fFalse;
	LSERR lserr;
	
	if (!FIsLSC(plsc)) return lserrInvalidParameter;
	if (!FIsLSDNODE(plsdnode)) return lserrInvalidParameter;
	if (!FIsDnodeReal(plsdnode)) return lserrInvalidParameter;

	/* we should be in the stage of formatting or breaking*/
	if (!FFormattingAllowed(plsc) && !FBreakingAllowed(plsc)) return lserrFormattingFunctionDisabled;

	/* this procedure can be called many times for the same dnode, so
	   we should dispose memory allocated in previous call */
	if (plsdnode->u.real.pinfosubl != NULL)
		{
		if (plsdnode->u.real.pinfosubl->rgpsubl != NULL)
			{
			plsc->lscbk.pfnDisposePtr(plsc->pols, plsdnode->u.real.pinfosubl->rgpsubl);
			}

		plsc->lscbk.pfnDisposePtr(plsc->pols, plsdnode->u.real.pinfosubl);
		plsdnode->u.real.pinfosubl = NULL;
		}

	/* if nothing submitted return right away */
	if (cSubline == 0)
		return lserrNone;

	TurnOnSubmittedSublineEncounted(plsc);

	/* calculate some properties of sublines  to decide accept or not */
	for (i = 0; i < cSubline; i++)
		{
		if (rgpsubl[i] == NULL) return lserrInvalidParameter;
		if (!FIsLSSUBL(rgpsubl[i])) return lserrInvalidParameter;

		lserr = FIsSublineEmpty(rgpsubl[i], &fEmptyWork);
		if (lserr != lserrNone)
			return lserr;
		if (fEmptyWork) fEmpty = fTrue;

		if (FAreTabsPensInSubline(rgpsubl[i])) 
			fTabOrPen = fTrue;

		if (LstflowFromSubline(SublineFromDnode(plsdnode)) != 
			LstflowFromSubline(rgpsubl[i]))
			fNotSameTflow = fTrue;
		
		if (!FColinearTflows(LstflowFromSubline(SublineFromDnode(plsdnode)),
			LstflowFromSubline(rgpsubl[i])))
			fNotColinearTflow = fTrue;
			
		}


	plsdnode->u.real.pinfosubl = plsc->lscbk.pfnNewPtr(plsc->pols,
											sizeof(*(plsdnode->u.real.pinfosubl)));

	if (plsdnode->u.real.pinfosubl == NULL)
		return lserrOutOfMemory;

	plsdnode->u.real.pinfosubl->cSubline = cSubline;
	plsdnode->u.real.pinfosubl->rgpsubl = plsc->lscbk.pfnNewPtr(plsc->pols,
											sizeof(PLSSUBL) * cSubline);
	if (plsdnode->u.real.pinfosubl->rgpsubl == NULL)
			return lserrOutOfMemory;

	/* copy array of sublines */
	for (i = 0; i < cSubline; i++)
		{
		plsdnode->u.real.pinfosubl->rgpsubl[i] = rgpsubl[i];
		}

	/* set flags */
	plsdnode->u.real.pinfosubl->fUseForJustification = 
		fUseForJustification && !fEmpty && !fTabOrPen && !fNotColinearTflow ;
	plsdnode->u.real.pinfosubl->fUseForCompression = 
		fUseForCompression && plsdnode->u.real.pinfosubl->fUseForJustification;
	/* if subline is submitted for compression it should also submitted for justification */
	plsdnode->u.real.pinfosubl->fUseForTrailingArea = 
		fUseForTrailingArea && plsdnode->u.real.pinfosubl->fUseForCompression;
	/* if subline is submitted for trailing area  it should also be submitted for compression
	which implies submitting for justification */
	plsdnode->u.real.pinfosubl->fUseForDisplay = 
		fUseForDisplay && !fEmpty && !(plsc->grpfManager & fFmiDrawInCharCodes);
	plsdnode->u.real.pinfosubl->fUseForDecimalTab = 
		fUseForDecimalTab && !fEmpty && !fTabOrPen;


	return lserrNone;
	}

/* L S D N  G E T  F O R M A T  D E P T H */
/*----------------------------------------------------------------------------
    %%Function:  LsdnGetFormatDepth
    %%Contact: igorzv
Parameters:
	plsc					-	(IN) ptr to line services context 
	pnDepthFormatLineMax	-	(OUT) maximum depth of sublines 

----------------------------------------------------------------------------*/

LSERR WINAPI LsdnGetFormatDepth(
							PLSC plsc,				/* IN: Pointer to LS Context	*/
							DWORD* pnDepthFormatLineMax)			/* OUT: nDepthFormatLineMax		*/
	{
	if (!FIsLSC(plsc)) return lserrInvalidParameter;

	/* we should be in the stage of formatting or breaking*/
	if (!FFormattingAllowed(plsc) && !FBreakingAllowed(plsc)) 
		return lserrFormattingFunctionDisabled;

	Assert(FWorkWithCurrentLine(plsc));

	*pnDepthFormatLineMax = plsc->plslineCur->lslinfo.nDepthFormatLineMax;

	return lserrNone;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\lsdssubl.c ===
#include "lsdssubl.h"
#include <limits.h>
#include "lsc.h"
#include "dispmain.h"
#include "lssubl.h"

//    %%Function:	LsDisplaySubline
//    %%Contact:	victork
//

LSERR WINAPI LsDisplaySubline(PLSSUBL plssubl, const POINT* pptorg, UINT kdispmode, const RECT *prectClip)
{

	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;
	
	if (plssubl->plsc->lsstate != LsStateDisplaying) return lserrContextInUse;		/* change lserr later */ 

	return DisplaySublineCore(plssubl, pptorg, kdispmode, prectClip,
								LONG_MAX,					/* upLimUnderline ignored */
								0);							/* dupLeftIndent */

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\lsensubl.c ===
#include "lsensubl.h"
#include "lsc.h"
#include "lssubl.h"
#include "enumcore.h"


//    %%Function:	LsEnumSubline
//    %%Contact:	victork
//
/*
 * Enumerates subline (from the given point is fGeometry needed).
 */
	
LSERR WINAPI LsEnumSubline(PLSSUBL plssubl, BOOL fReverseOrder, BOOL fGeometryNeeded, const POINT* pptorg)
{

	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;
	
	if (plssubl->plsc->lsstate != LsStateEnumerating) return lserrContextInUse;

	return EnumSublineCore(plssubl, fReverseOrder, fGeometryNeeded, pptorg, 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\lsdsply.c ===
#include "lsdsply.h"
#include "lsc.h"
#include "lsline.h"
#include "lssubl.h"
#include "heights.h"
#include "lstflow.h"
#include "lssubset.h"
#include "lstfset.h"
#include "port.h"
#include "prepdisp.h"
#include "dispmain.h"

static LSERR LSDrawBreaks(PLSC, PLSLINE, const POINT*, UINT, const RECT*);


#define grpfQuickDisplayMask   (fPortDisplayInvisible 	| \
								fPortDisplayUnderline 	| \
								fPortDisplayStrike 		| \
								fPortDisplayShade 		| \
								fPortDisplayBorder 		  \
								)


//    %%Function:	LsDisplayLine
//    %%Contact:	victork
//
/*
 * Displays formatted line (main subline) from the given point.
 * Assumes background has been properly erased.
 */
	
LSERR WINAPI LsDisplayLine(PLSLINE plsline, const POINT* pptOrg, UINT kdispmode, const RECT *prectClip)
{

	PLSC		plsc;
	LSERR 		lserr;

	PLSSUBL		plssubl;
	LSCP		cpLim;
	LSTFLOW		lstflow;
	
	POINTUV		pt;
	PLSDNODE	pdn;

	PDOBJ 		pdobj;
	DISPIN 		dispin;

	if (!FIsLSLINE(plsline)) return lserrInvalidParameter;

	plsc = plsline->lssubl.plsc;
	Assert(FIsLSC(plsc));

	if (plsc->lsstate != LsStateFree) return lserrContextInUse;

	lserr = PrepareLineForDisplayProc(plsline);

	plsc->lsstate = LsStateFree;
	
	if (lserr != lserrNone) return lserr;

	plsc->lsstate = LsStateDisplaying;

	Assert(plsline->lslinfo.dvpDescent >= 0);
	Assert(plsline->lslinfo.dvpAscent >= 0);
	Assert(plsline->upStartAutonumberingText <= plsline->upLimAutonumberingText);
	Assert(plsline->upLimAutonumberingText <= plsline->upStartMainText);
	// Assert(plsline->upStartMainText <= plsline->upLimUnderline) wrong - negative advance pen
	Assert(plsline->upLimUnderline <= plsline->upLimLine);

	plssubl = &(plsline->lssubl);

	plsc->plslineDisplay = plsline;				// set up display context

	if (plsline->lssubl.plsdnLastDisplay == NULL)
		{
		// do nothing - happens with only splat on the line
		}
	

	else // Do it quick way or call general procedure
	
	if (!plsline->fNonZeroDvpPosEncounted 					&&
			!plsline->fNonRealDnodeEncounted				&&
			((plsline->AggregatedDisplayFlags == 0) || 
			((plsline->AggregatedDisplayFlags & grpfQuickDisplayMask) == 0)
			)
		   )
		
		{

		cpLim = plssubl->cpLimDisplay;
		lstflow = plssubl->lstflow;
		
		dispin.dupLimUnderline = 0;
		dispin.fDrawUnderline = fFalse;
		dispin.fDrawStrikethrough = fFalse;
	
		dispin.kDispMode = kdispmode;
		dispin.lstflow = lstflow;								
		dispin.prcClip = (RECT*) prectClip;
		
		pt.u = plsline->upStartAutonumberingText;						
		pt.v = 0;
		pdn = plssubl->plsdnFirst;

		// can use the loop condition instead of FDnodeBeforeCpLim macro - no borders
		
		for (;;)
			{

			Assert(pdn->klsdn == klsdnReal);

			pdobj = pdn->u.real.pdobj;
			dispin.plschp = &(pdn->u.real.lschp);
			dispin.plsrun = pdn->u.real.plsrun;
			dispin.heightsPres = pdn->u.real.objdim.heightsPres;
			dispin.dup = pdn->u.real.dup;
			
			LsPointXYFromPointUV(pptOrg, lstflow, &pt, &(dispin.ptPen));
			
			lserr = (*plsc->lsiobjcontext.rgobj[pdn->u.real.lschp.idObj].lsim.pfnDisplay)
													(pdobj, &dispin);

			if (pdn == plsline->lssubl.plsdnLastDisplay || lserr != lserrNone)
				{
				break;
				}
			
			pt.u += pdn->u.real.dup;										
			pdn = pdn->plsdnNext;

			}

		}
	else
		{
		lserr = DisplaySublineCore(plssubl, pptOrg, kdispmode, prectClip,
									plsline->upLimUnderline,
									plsline->upStartAutonumberingText);
		}

	if (lserr == lserrNone && plsline->kspl != ksplNone)
		{
		lserr = LSDrawBreaks(plsc, plsline, pptOrg,	kdispmode, prectClip);
		}

	plsc->plslineDisplay = NULL;				// invalidate display context
	plsc->lsstate = LsStateFree;
	return lserr;
}

//    %%Function:	LSDrawBreaks
//    %%Contact:	victork
//
static LSERR LSDrawBreaks(PLSC plsc, PLSLINE plsline, const POINT* pptOrg, UINT kdispmode, const RECT* prectClip)
{

	LSERR 	lserr;
	POINTUV 		ptUV;
	POINT 			pt;
	long 			dup;
	enum lsksplat 	lsks;

	LSTFLOW	lstflow = plsline->lssubl.lstflow;
	
	HEIGHTS	heightsLineFull;
	HEIGHTS	heightsLineWithoutAddedSpace;
	OBJDIM	objdimSubline;

	heightsLineFull.dvAscent = plsline->dvpAbove + plsline->lslinfo.dvpAscent;
	heightsLineFull.dvDescent = plsline->dvpBelow + plsline->lslinfo.dvpDescent;
	heightsLineFull.dvMultiLineHeight = dvHeightIgnore;
	
	heightsLineWithoutAddedSpace.dvAscent = plsline->lslinfo.dvpAscent;
	heightsLineWithoutAddedSpace.dvDescent = plsline->lslinfo.dvpDescent;
	heightsLineWithoutAddedSpace.dvMultiLineHeight = dvHeightIgnore;
	
	lserr = LssbGetObjDimSubline(&(plsline->lssubl), &lstflow, &objdimSubline);
	
	if (lserr == lserrNone)
		{
		ptUV.u = plsline->upLimLine;
		ptUV.v = 0;

		dup = plsline->upRightMarginJustify - plsline->upLimLine;

		if (plsline->kspl == ksplPageBreak)
			lsks = lsksplPageBreak;
		else if (plsline->kspl == ksplColumnBreak)
			lsks = lsksplColumnBreak;
		else
			lsks = lsksplSectionBreak;

		LsPointXYFromPointUV(pptOrg, lstflow, &ptUV, &pt);
		
		return (*plsc->lscbk.pfnDrawSplatLine) (plsc->pols, lsks, plsline->lslinfo.cpLim - 1, &pt,
												&(heightsLineFull), &(heightsLineWithoutAddedSpace),
												&(objdimSubline.heightsPres),
												dup, lstflow, kdispmode, prectClip);
		}

	return lserr;
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\lsdnfin.c ===
/* LSDNFIN.C					*/
#include "lsdnfin.h"
#include "lsidefs.h"
#include "lsc.h"
#include "getfmtst.h"
#include "setfmtst.h"
#include "dninfo.h"
#include "lschp.h"
#include "lsffi.h"
#include "iobj.h"
#include "dnutils.h"
#include "lsfrun.h"
#include "lsfetch.h"
#include "qheap.h"
#include "sublutil.h"
#include "lsmem.h"
#include "lscfmtfl.h"
#include "ntiman.h"

#ifdef DEBUG
#define DebugMemset(a,b,c)		if ((a) != NULL) memset(a,b,c); else
#else
#define DebugMemset(a,b,c)		(void)(0)
#endif



#define IsLschpFlagsValid(plsc, plschp)  fTrue

/* Word violates condition bellow and it is not very important to us, so I deleted body of this macro,
but not deleted macro itself to have a place where to put such checks later */

//		((((plsc)->lsadjustcontext.lsbrj == lsbrjBreakWithCompJustify) || ((plsc)->lsadjustcontext.lskj == lskjSnapGrid)) ? \
//		fTrue :\
//		(!((plschp)->fCompressOnRun || (plschp)->fCompressSpace || (plschp)->fCompressTable))) 



/* L S D N  F I N I S H   R E G U L A R */
/*----------------------------------------------------------------------------
    %%Function: LsdnFinishRegular
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	lsdcp				-	(IN) dcp adopted
	plsrun				-	(IN) plsrun of dnode		
	plschp				-	(IN) plschp of dnode
	pdobj				-	(IN) pdobj of dnode
	pobjdim				-	(IN) pobjdim of dnode

Finish creating dnode
----------------------------------------------------------------------------*/

LSERR WINAPI LsdnFinishRegular(
							  PLSC  plsc,			
							  LSDCP lsdcp,     		
							  PLSRUN plsrun,   		
							  PCLSCHP plschp,  		
							  PDOBJ pdobj,    		
							  PCOBJDIM pobjdim) 	
{
	
	PLSDNODE plsdn;
	LSERR lserr;
	PLSSUBL plssubl;
	
	if (!FIsLSC(plsc)) return lserrInvalidParameter;

	if (!FFormattingAllowed(plsc)) return lserrFormattingFunctionDisabled;

	/* all sublines should be closed */
	if (GetCurrentSubline(plsc) != NULL) return lserrFormattingFunctionDisabled;

	plsdn = GetDnodeToFinish(plsc);
	
	if (plsdn == NULL) return lserrFiniFunctionDisabled;

	plssubl = SublineFromDnode(plsdn);

	plsdn->u.real.pdobj = pdobj;
	/* if handler changed plsrun that we passed to him than we should release previous one */
	/* Attention: we have assumption here that new one has another plsrun     				*/
	if (plsdn->u.real.plsrun != plsrun && !plsc->fDontReleaseRuns)
		{
		lserr = plsc->lscbk.pfnReleaseRun(plsc->pols, plsdn->u.real.plsrun);
		plsdn->u.real.plsrun = plsrun; /* to release it later */
		if (lserr != lserrNone)
			return lserr;
		}

	plsdn->dcp = lsdcp;
	plsdn->cpLimOriginal = plsdn->cpFirst + lsdcp;
	Assert(FIsDnodeReal(plsdn)); /* this is default value */
	Assert(pobjdim->dur >= 0);
	SetDnodeObjdimFmt(plsdn, *pobjdim);

	Assert(IsLschpFlagsValid(plsc, plschp));
	plsdn->u.real.lschp = *plschp;
	/*  Special effects */
	plsc->plslineCur->lslinfo.EffectsFlags |= plschp->EffectsFlags;  
	/* set flags for display */
	if (plschp->dvpPos != 0)
		TurnOnNonZeroDvpPosEncounted(plsc);
	AddToAggregatedDisplayFlags(plsc, plschp);
	if (FApplyNominalToIdeal(plschp))
		TurnOnNominalToIdealEncounted(plsc);



	if (plsdn->u.real.lschp.idObj == idObjTextChp)
		plsdn->u.real.lschp.idObj = (WORD) IobjTextFromLsc(&plsc->lsiobjcontext);


	AssertImplies(plsc->lsdocinf.fPresEqualRef, 
		plsdn->u.real.objdim.heightsPres.dvAscent == plsdn->u.real.objdim.heightsRef.dvAscent);
	AssertImplies(plsc->lsdocinf.fPresEqualRef, 
		plsdn->u.real.objdim.heightsPres.dvDescent == plsdn->u.real.objdim.heightsRef.dvDescent);
	AssertImplies(plsc->lsdocinf.fPresEqualRef, 
		plsdn->u.real.objdim.heightsPres.dvMultiLineHeight 
				== plsdn->u.real.objdim.heightsRef.dvMultiLineHeight);


	/* nobody can change current dnode after plsdn was constructed  */
	Assert(GetCurrentDnodeSubl(plssubl) == plsdn->plsdnPrev);

	*(GetWhereToPutLinkSubl(plssubl, plsdn->plsdnPrev)) = plsdn;
	
	
	SetCurrentDnodeSubl(plssubl, plsdn);
	SetDnodeToFinish(plsc, NULL);	
	
	AdvanceCurrentCpLimSubl(plssubl, lsdcp);
	AdvanceCurrentUrSubl(plssubl, pobjdim->dur);
	return lserrNone;
}

/* L S D N  F I N I S H   R E G U L A R  A D D  A D V A N C E D  P E N */
/*----------------------------------------------------------------------------
    %%Function: LsdnFinishRegularAddAdvancePen
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	lsdcp				-	(IN) dcp adopted
	plsrun				-	(IN) plsrun of dnode		
	plschp				-	(IN) plschp of dnode
	pdobj				-	(IN) pdobj of dnode
	pobjdim				-	(IN) pobjdim of dnode
	durPen				-	(IN) dur of advanced pen 
	dvrPen				-	(IN) dvr of advanced pen 
	dvpPen				-	(IN) dvp of advanced pen 

  Finish creating dnode and add advanced pen after such dnode 
----------------------------------------------------------------------------*/

LSERR WINAPI LsdnFinishRegularAddAdvancePen(
							  PLSC plsc,			/* IN: Pointer to LS Context */
							  LSDCP lsdcp,     		/* IN: dcp adopted           */
							  PLSRUN plsrun,   		/* IN: PLSRUN  		         */
							  PCLSCHP plschp,  		/* IN: CHP          	     */
							  PDOBJ pdobj,    		/* IN: PDOBJ             	 */ 
							  PCOBJDIM pobjdim,		/* IN: OBJDIM      		     */
							  long durPen,			/* IN: durPen				 */
							  long dvrPen,			/* IN: dvrPen				 */
							  long dvpPen)			/* IN: dvpPen 				 */
	{
	LSERR lserr;
	PLSDNODE plsdnPrev;
	PLSDNODE plsdnPen;
	PLSSUBL plssubl;

	/* we don't have checks of parameters here because they are in LsdnFinishRegular */

	plsdnPrev = GetDnodeToFinish(plsc);	/* we should store it before calling LsdnFinishRegular */
	plssubl = SublineFromDnode(plsdnPrev);
		
	lserr = LsdnFinishRegular(plsc, lsdcp, plsrun, plschp, pdobj, pobjdim);
	if (lserr != lserrNone)
		return lserr;

	/* create and fill in pen dnode */
	plsdnPen = PvNewQuick(GetPqhAllDNodes(plsc), sizeof *plsdnPen);
	if (plsdnPen == NULL)
		return lserrOutOfMemory;
	plsdnPen->tag = tagLSDNODE;
	plsdnPen->cpFirst = GetCurrentCpLimSubl(plssubl);
	plsdnPen->cpLimOriginal = plsdnPen->cpFirst;
	plsdnPen->plsdnPrev = plsdnPrev;
	plsdnPen->plsdnNext = NULL;
	plsdnPen->plssubl = plssubl;
	plsdnPen->dcp = 0;
	/* flush all flags, bellow check that result is what  we expect */ \
	*((DWORD *) ((&(plsdnPen)->dcp)+1)) = 0;\
	Assert((plsdnPen)->fRigidDup == fFalse);\
	Assert((plsdnPen)->fTab == fFalse);\
	Assert((plsdnPen)->icaltbd == 0);\
	Assert((plsdnPen)->fBorderNode == fFalse);\
	Assert((plsdnPen)->fOpenBorder == fFalse);\
	Assert((plsdnPen)->fEndOfSection == fFalse); \
	Assert((plsdnPen)->fEndOfColumn == fFalse); \
	Assert((plsdnPen)->fEndOfPage == fFalse); \
	Assert((plsdnPen)->fEndOfPara == fFalse); \
	Assert((plsdnPen)->fAltEndOfPara == fFalse); \
	Assert((plsdnPen)->fSoftCR == fFalse); \
	Assert((plsdnPen)->fInsideBorder == fFalse); \
	Assert((plsdnPen)->fAutoDecTab == fFalse); \
	Assert((plsdnPen)->fTabForAutonumber == fFalse);
	plsdnPen->klsdn = klsdnPenBorder;
	plsdnPen->fAdvancedPen = fTrue;
	SetPenBorderDurFmt(plsdnPen, durPen);
	plsdnPen->u.pen.dvr = dvrPen;
	plsdnPen->u.pen.dvp = dvpPen;
	
	/* maintain list */
	plsdnPrev->plsdnNext = plsdnPen;
	SetCurrentDnodeSubl(plssubl, plsdnPen);
	AdvanceCurrentUrSubl(plssubl, durPen);
	AdvanceCurrentVrSubl(plssubl, dvrPen);

	if (durPen < 0)
		plsc->fAdvanceBack = fTrue;

	TurnOnNonRealDnodeEncounted(plsc);
		
	return lserrNone;
	}

/* L S D N  F I N I S H   D E L E T E */
/*----------------------------------------------------------------------------
    %%Function: LsdnFinishDelete
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	lsdcp				-	(IN) dcp adopted

Delete dnode due to the will of formater
----------------------------------------------------------------------------*/


LSERR WINAPI LsdnFinishDelete(
							  PLSC plsc,				/* IN: Pointer to LS Context */
					  		  LSDCP lsdcp)		/* IN: dcp to add			 */
	{
	PLSDNODE plsdn;
	PLSSUBL plssubl;
	LSERR lserr;
	
	if (!FIsLSC(plsc)) return lserrInvalidParameter;

	if (!FFormattingAllowed(plsc)) return lserrFormattingFunctionDisabled;

	/* all sublines should be closed */
	if (GetCurrentSubline(plsc) != NULL) return lserrFormattingFunctionDisabled;

	plsdn = GetDnodeToFinish(plsc);
	
	if (plsdn == NULL) return lserrFiniFunctionDisabled;

	plssubl = SublineFromDnode(plsdn);

	/* nobody can change current dnode after plsdn was constructed  */
	Assert(GetCurrentDnodeSubl(plssubl) == plsdn->plsdnPrev);

	Assert(plsdn->plsdnNext == NULL);
	lserr = DestroyDnodeList (&plsc->lscbk, plsc->pols, &plsc->lsiobjcontext,
					  plsdn, plsc->fDontReleaseRuns);
	if (lserr != lserrNone)
		return lserr;

	SetDnodeToFinish(plsc, NULL);	
	
	AdvanceCurrentCpLimSubl(plssubl, lsdcp);

	return lserrNone;
	}


/* L S D N  F I N I S H  P E N  */
/*----------------------------------------------------------------------------
    %%Function: LsdnFinishSimpleRegular
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	lsdcp				-	(IN) dcp adopted
	plsrun				-	(IN) plsrun of dnode		
	plschp				-	(IN) plschp of dnode
	dur, dvr, dvp		-   (IN) variables to put in pen dnode 

Finish dnode as a pen
----------------------------------------------------------------------------*/

LSERR WINAPI LsdnFinishByPen(PLSC plsc,				/* IN: Pointer to LS Context */
						   LSDCP lsdcp, 	   		/* IN: dcp	adopted          */
						   PLSRUN plsrun,	   		/* IN: PLSRUN  		         */
						   PDOBJ pdobj,	    		/* IN: PDOBJ             	 */ 
						   long durPen,    			/* IN: dur         		     */
						   long dvrPen,     		/* IN: dvr             		 */
						   long dvpPen)   			/* IN: dvp          	     */
	{
	PLSDNODE plsdn;
	LSERR lserr;
	PLSSUBL plssubl;
	
	if (!FIsLSC(plsc)) return lserrInvalidParameter;

	if (!FFormattingAllowed(plsc)) return lserrFormattingFunctionDisabled;

	/* all sublines should be closed */
	if (GetCurrentSubline(plsc) != NULL) return lserrFormattingFunctionDisabled;

	plsdn = GetDnodeToFinish(plsc);
	
	if (plsdn == NULL) return lserrFiniFunctionDisabled;

	plssubl = SublineFromDnode(plsdn);

	if (plsrun != NULL && !plsc->fDontReleaseRuns)
		{
		lserr = plsc->lscbk.pfnReleaseRun(plsc->pols, plsrun);
		if (lserr != lserrNone)	return lserr;
		}

	/* caller pass pdobj to us only to destroy it*/
	if (pdobj != NULL)
		{
		Assert(plsdn->u.real.lschp.idObj != idObjTextChp);
		lserr = (PLsimFromLsc(&plsc->lsiobjcontext, 
			plsdn->u.real.lschp.idObj))->pfnDestroyDObj (pdobj);
		if (lserr != lserrNone)	return lserr;
		}


	
	plsdn->dcp = lsdcp;
	plsdn->cpLimOriginal = plsdn->cpFirst + lsdcp;
	plsdn->klsdn = klsdnPenBorder;
	plsdn->fBorderNode = fFalse;
	SetPenBorderDurFmt(plsdn, durPen);
	plsdn->u.pen.dvr = dvrPen;
	plsdn->u.pen.dvp = dvpPen;

	/* nobody can change current dnode after plsdn was constructed  */
	Assert(GetCurrentDnodeSubl(plssubl) == plsdn->plsdnPrev);

	*(GetWhereToPutLinkSubl(plssubl, plsdn->plsdnPrev)) = plsdn;
	
	
	SetCurrentDnodeSubl(plssubl, plsdn);
	SetDnodeToFinish(plsc, NULL);	
	
	AdvanceCurrentCpLimSubl(plssubl, lsdcp);
	AdvanceCurrentUrSubl(plssubl, durPen);
	AdvanceCurrentVrSubl(plssubl, dvrPen);

	TurnOnNonRealDnodeEncounted(plsc);

	return lserrNone;
	}


/* L S D N  F I N I S H  B Y  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LsdnFinishBySubline
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	lsdcp				-	(IN) increase cp by this number before hanldler ends
	plssubl				-	(IN) subline to substitute dnode to finish

Delete dnode and include child list in the upper level
----------------------------------------------------------------------------*/

LSERR WINAPI LsdnFinishBySubline(PLSC plsc,			/* IN: Pointer to LS Context */
							  	LSDCP lsdcp,     		/* IN: dcp adopted           */
								PLSSUBL plssubl)		/* IN: Subline context		 */
	{
	PLSDNODE plsdnParent;
	PLSDNODE plsdnChildFirst;
	PLSDNODE plsdnChildCurrent, plsdnChildPrevious;
	PLSSUBL plssublParent;
	LSERR lserr;

	if (!FIsLSC(plsc)) return lserrInvalidParameter;

	if (!FFormattingAllowed(plsc)) return lserrFormattingFunctionDisabled;

	/* all sublines should be closed */
	if (GetCurrentSubline(plsc) != NULL) return lserrFormattingFunctionDisabled;

	plsdnParent = GetDnodeToFinish(plsc);
	
	if (plsdnParent == NULL) return lserrFiniFunctionDisabled;

	plssublParent = SublineFromDnode(plsdnParent);

	
	AdvanceCurrentCpLimSubl(plssublParent, lsdcp);

	plsdnChildFirst = plssubl->plsdnFirst;

	/* go through child list change subline and calculate resulting pen movement  */
	plsdnChildCurrent = plsdnChildFirst;
	plsdnChildPrevious = NULL;
	while (plsdnChildPrevious != plssubl->plsdnLast)
		{
		plsdnChildCurrent->plssubl = plssublParent;
		AdvanceCurrentUrSubl(plssublParent, DurFromDnode(plsdnChildCurrent));
		AdvanceCurrentVrSubl(plssublParent, DvrFromDnode(plsdnChildCurrent));
		plsdnChildPrevious = plsdnChildCurrent;
		plsdnChildCurrent = plsdnChildCurrent->plsdnNext;
		} 
	

	/* include subline's list to upper level */
	*(GetWhereToPutLinkSubl(plssublParent, plsdnParent->plsdnPrev)) = plsdnChildFirst;
	if (plsdnChildFirst != NULL && plsdnParent->plsdnPrev != NULL) 
		plsdnChildFirst->plsdnPrev = plsdnParent->plsdnPrev;

	/* if subline's list is empty than dnode before parent should be made current */
	if (plsdnChildFirst == NULL)
		{
		/* if subline's list is empty than dnode before parent should be made current */
		SetCurrentDnodeSubl(plssublParent, plsdnParent->plsdnPrev);
		}
	else
		{
		/* else last dnode in subline is now current dnode */
		SetCurrentDnodeSubl(plssublParent, plssubl->plsdnLast);
		}

	/* delete parent dnode */
	lserr = DestroyDnodeList (&plsc->lscbk, plsc->pols, &plsc->lsiobjcontext,
					  plsdnParent, plsc->fDontReleaseRuns);
	if (lserr != lserrNone)
		return lserr;

	/* set first dnode of subline to NULL and destroy subline will not erase dnodes that has 
	been promoted to the upper level */
	plssubl->plsdnFirst = NULL;

	lserr = DestroySublineCore(plssubl,&plsc->lscbk, plsc->pols,
			&plsc->lsiobjcontext, plsc->fDontReleaseRuns);
	if (lserr != lserrNone)
		return lserr;

	SetDnodeToFinish(plsc, NULL);	
	
	return lserrNone;
	}

/* L S D N  F I N I S H  D E L E T E  A L L*/
/*----------------------------------------------------------------------------
    %%Function: LsdnFinishDeleteAll
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	dcpToAdvance		-	(IN) increase cp by this number before hanldler ends

Delete parent dnode and include child list in the upper level
----------------------------------------------------------------------------*/


LSERR WINAPI LsdnFinishDeleteAll(PLSC plsc,			/* IN: Pointer to LS Context */
					  			LSDCP lsdcp)			/* IN: dcp adopted			 */
	{
	PLSDNODE plsdnParent;
	PLSDNODE plsdnFirstOnLine;
	PLSDNODE plsdnFirstInContents;
	PLSDNODE plsdnLastBeforeContents;
	LSERR lserr;
	long dvpPen;
	long durPen;
	long dvrPen;
	PLSSUBL plssublMain;

	if (!FIsLSC(plsc)) return lserrInvalidParameter;

	if (!FFormattingAllowed(plsc)) return lserrFormattingFunctionDisabled;

	/* all sublines should be closed */
	if (GetCurrentSubline(plsc) != NULL) return lserrFormattingFunctionDisabled;

	plsdnParent = GetDnodeToFinish(plsc);
	
	if (plsdnParent == NULL) return lserrFiniFunctionDisabled;

	plssublMain = &plsc->plslineCur->lssubl;

	
	AdvanceCurrentCpLimSubl(plssublMain, lsdcp);
	
	plsdnFirstOnLine = plssublMain->plsdnFirst;

	plsdnFirstInContents = plsdnFirstOnLine;
	plsdnLastBeforeContents = NULL;
	while (plsdnFirstInContents != NULL && FIsNotInContent(plsdnFirstInContents))
		{
		plsdnLastBeforeContents = plsdnFirstInContents;
		plsdnFirstInContents = plsdnFirstInContents->plsdnNext;
		}

	/* restore state as it was before starting formatting content*/
	plsc->lstabscontext.plsdnPendingTab = NULL;
	plsc->plslineCur->lslinfo.fAdvanced = 0;
	plsc->plslineCur->lslinfo.EffectsFlags = 0;

	/* break link with contest*/
	if (plsdnFirstInContents != NULL)
		*(GetWhereToPutLinkSubl(plssublMain, plsdnFirstInContents->plsdnPrev)) = NULL;
	/* set dnode to append */
	SetCurrentDnodeSubl(plssublMain, plsdnLastBeforeContents);
	/* set current subline */
	SetCurrentSubline(plsc, plssublMain);

	/* recalculate current position */
	if (plsdnFirstInContents != NULL)
		{
		FindListFinalPenMovement(plsdnFirstInContents, plssublMain->plsdnLast,
							 &durPen, &dvrPen, &dvpPen);
		AdvanceCurrentUrSubl(plssublMain, -durPen);
		AdvanceCurrentVrSubl(plssublMain, -dvrPen);

		}

	/* delete content before this parent dnode */
	if (plsdnFirstInContents != NULL)
		{
		lserr = DestroyDnodeList (&plsc->lscbk, plsc->pols, &plsc->lsiobjcontext,
					  plsdnFirstInContents, plsc->fDontReleaseRuns);
		if (lserr != lserrNone)
			return lserr;
		}

	/* delete parent dnode and child list*/
	lserr = DestroyDnodeList (&plsc->lscbk, plsc->pols, &plsc->lsiobjcontext,
					  plsdnParent, plsc->fDontReleaseRuns);
	if (lserr != lserrNone)
		return lserr;

	SetDnodeToFinish(plsc, NULL);	

	return lserrNone;
	}

LSERR WINAPI LsdnFinishByOneChar(				/* allows replacement by simple DNODE only */
							  PLSC plsc,				/* IN: Pointer to LS Context */
							  long urColumnMax,				/* IN: urColumnMax			 */
							  WCHAR ch,			/* IN: character to replace	 */
							  PCLSCHP plschp,			/* IN: lschp for character   */
							  PLSRUN plsrun,			/* IN: plsrun for character  */
							  FMTRES* pfmtres)		/* OUT:Result of the Repl formatter*/
	{	
	LSERR lserr;
	LSFRUN lsfrun;	
	PLSDNODE plsdn;
	PLSSUBL plssubl;
	
	if (!FIsLSC(plsc)) return lserrInvalidParameter;

	if (!FFormattingAllowed(plsc)) return lserrFormattingFunctionDisabled;

	/* all sublines should be closed */
	if (GetCurrentSubline(plsc) != NULL) return lserrFormattingFunctionDisabled;

	plsdn = GetDnodeToFinish(plsc);
	
	if (plsdn == NULL) return lserrFiniFunctionDisabled;

	plssubl = SublineFromDnode(plsdn);

	/* nobody can change current dnode after plsdn was constructed  */
	Assert(GetCurrentDnodeSubl(plssubl) == plsdn->plsdnPrev);

	if (plsdn->dcp != 1) return lserrWrongFiniFunction;


	lserr = LsdnFinishDelete(plsc, 0);
	if (lserr != lserrNone)
		return lserr;

	Assert(IsLschpFlagsValid(plsc, plschp));
	lsfrun.plschp = plschp;
	/*  Special effects */
	plsc->plslineCur->lslinfo.EffectsFlags |= plschp->EffectsFlags;   
	lsfrun.plsrun = plsrun;
	lsfrun.lpwchRun = &ch;
	lsfrun.cwchRun = 1;

	/* to ProcessOneRun work properly we need to temporarely restore current subline */
	SetCurrentSubline(plsc, plssubl);
	lserr = ProcessOneRun(plsc, urColumnMax, &lsfrun, NULL, 0, pfmtres);
	if (lserr != lserrNone)
		return lserr;

	SetCurrentSubline(plsc, NULL);

	return lserrNone;

	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\lsdntext.c ===
/* LSDNTEXT.C								*/
#include "lsdntext.h"
#include "lsidefs.h"
#include "lsc.h"
#include "lsdnode.h"
#include "iobj.h"
#include "dninfo.h"
#include "getfmtst.h"
#include "setfmtst.h"
#include "chnutils.h"
#include "dnutils.h"
#include "break.h"

static LSERR ResetDcpCore(PLSC plsc, PLSDNODE plsdn, LSCP cpFirstNew,
						  LSDCP dcpNew, BOOL fMerge);	


/* L S D N  S E T  T E X T  D U P*/
/*----------------------------------------------------------------------------
    %%Function: LsdnSetTextDup
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	plsdn				-	(IN) Pointer to the dnode
	dup					-	(IN) dup to be set

Set dup in dnode  
----------------------------------------------------------------------------*/
LSERR LsdnSetTextDup(PLSC plsc,	PLSDNODE plsdn, long dup)
{
	Unreferenced(plsc);  /* to avoid warning in shiping version */
	
	Assert(FIsLSC(plsc));
	Assert(FIsLSDNODE(plsdn));
	Assert(FIsDnodeReal(plsdn));
	Assert(IobjTextFromLsc(&plsc->lsiobjcontext) == IdObjFromDnode(plsdn));
	Assert(dup >= 0);

	plsdn->u.real.dup = dup;
   	return lserrNone;		

}


/* L S D N  M O D I F Y  T E X T  D U P*/
/*----------------------------------------------------------------------------
    %%Function: LsdnModifyTextDup
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	plsdn				-	(IN) Pointer to the dnode
	ddup				-	(IN) ddup 

modify dup in dnode  
----------------------------------------------------------------------------*/
LSERR LsdnModifyTextDup(PLSC plsc,	PLSDNODE plsdn, long ddup)
{
	Unreferenced(plsc);  /* to avoid warning in shiping version */

	Assert(FIsLSC(plsc));
	Assert(FIsLSDNODE(plsdn));
	Assert(FIsDnodeReal(plsdn));
	Assert(IobjTextFromLsc(&plsc->lsiobjcontext) == IdObjFromDnode(plsdn));

	plsdn->u.real.dup += ddup;
	Assert(plsdn->u.real.dup >= 0);

   	return lserrNone;		

}

/* L S D N  G E T  O B J  D I M */
/*----------------------------------------------------------------------------
    %%Function: LsdnGetObjDim
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	plsdn				-	(IN) Pointer to the dnode
	pobjdim				-	(OUT) dimensions of DNODE

return objdim of dnode 
----------------------------------------------------------------------------*/
LSERR LsdnGetObjDim(PLSC plsc, PLSDNODE plsdn, POBJDIM pobjdim )		
{
	Unreferenced(plsc);  /* to avoid warning in shiping version */

	Assert(FIsLSC(plsc));
	Assert(FIsLSDNODE(plsdn));
	Assert(FIsDnodeReal(plsdn));
	Assert(IobjTextFromLsc(&plsc->lsiobjcontext) == IdObjFromDnode(plsdn));

	*pobjdim = plsdn->u.real.objdim;
   	return lserrNone;		

}

/* L S D N  G E T  C P  F I R S T*/
/*----------------------------------------------------------------------------
    %%Function: LsdnGetObjDim
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	plsdn				-	(IN) Pointer to the dnode
	pcpFirst			-	(OUT) cpFirst of this DNODE

return cpFirst of dnode
----------------------------------------------------------------------------*/
LSERR LsdnGetCpFirst(PLSC plsc, PLSDNODE plsdn, LSCP* pcpFirst )		
{
	Unreferenced(plsc);  /* to avoid warning in shiping version */

	Assert(FIsLSC(plsc));
	Assert(FIsLSDNODE(plsdn));
	Assert(FIsDnodeReal(plsdn));
	Assert(IobjTextFromLsc(&plsc->lsiobjcontext) == IdObjFromDnode(plsdn));

	*pcpFirst = plsdn->cpFirst;
   	return lserrNone;		

}

/* L S D N  G E T  P L S R U N*/
/*----------------------------------------------------------------------------
    %%Function: LsdnGetPlsrun
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	plsdn				-	(IN) Pointer to the dnode
	pplsrun				-	(OUT) plsrun of this DNODE

return cpFirst of dnode
----------------------------------------------------------------------------*/
LSERR LsdnGetPlsrun(PLSC plsc, PLSDNODE plsdn, PLSRUN* pplsrun )		
{
	Unreferenced(plsc);  /* to avoid warning in shiping version */

	Assert(FIsLSC(plsc));
	Assert(FIsLSDNODE(plsdn));
	Assert(FIsDnodeReal(plsdn));
	Assert(IobjTextFromLsc(&plsc->lsiobjcontext) == IdObjFromDnode(plsdn));

	*pplsrun = plsdn->u.real.plsrun;
   	return lserrNone;		

}




/* L S D N  M O D I F Y  S I M P L E  W I D T H*/
/*----------------------------------------------------------------------------
    %%Function: LsdnModifySimpleWidth
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	plsdn				-	(IN) Pointer to the dnode
	ddur			-		(IN) ddur

modify dur in dnode  
----------------------------------------------------------------------------*/
LSERR LsdnModifySimpleWidth(PLSC plsc,	PLSDNODE plsdn, long ddur)
{

	Assert(FIsLSC(plsc));
	Assert(FIsLSDNODE(plsdn));

	Unreferenced(plsc);
	
	if (ddur != 0)
		{
		if (plsdn->klsdn == klsdnReal)
			{
			ModifyDnodeDurFmt(plsdn, ddur);
			Assert(plsdn->u.real.objdim.dur >= 0);
			}
		else /* pen */
			{
			ModifyPenBorderDurFmt(plsdn, ddur);
			}
		AdvanceCurrentUrSubl(plsdn->plssubl, ddur);
		/* after such changes in dnode location of chunk should be recalculatted */
		InvalidateChunkLocation(PlschunkcontextFromSubline(plsdn->plssubl));

		}
   	return lserrNone;		

}

/* L S D N  S E T  S I M P L E  W I D T H*/
/*----------------------------------------------------------------------------
    %%Function: LsdnSetySimpleWidth
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	plsdn				-	(IN) Pointer to the dnode
	dur			-			(IN) new dur

modify dur in dnode  
----------------------------------------------------------------------------*/
LSERR LsdnSetSimpleWidth(PLSC plsc,	PLSDNODE plsdn, long dur)
	{
	long ddur;
	
	Assert(FIsLSC(plsc));
	Assert(FIsLSDNODE(plsdn));
	Assert(dur >= 0);
	
	Unreferenced(plsc);
	
	
	if (plsdn->klsdn == klsdnReal)
		{
		ddur = dur - plsdn->u.real.objdim.dur;
		SetDnodeDurFmt(plsdn, dur);
		}
	else /* pen */
		{
		ddur = dur - plsdn->u.pen.dur;
		SetPenBorderDurFmt(plsdn, dur);
		}
	
	AdvanceCurrentUrSubl(plsdn->plssubl, ddur);
	/* after such changes in dnode location of chunk should be recalculatted */
	InvalidateChunkLocation(PlschunkcontextFromSubline(plsdn->plssubl));
   	return lserrNone;		
	
	}

/* L S D N  F  I N  C H I L D  L I S T*/
/*----------------------------------------------------------------------------
    %%Function: LsdnFInChildList
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	plsdn				-	(IN) Pointer to the dnode
	pfInChildList		-	(OUT) is this in a low level subline

Used for switching off hyphenation in child list
----------------------------------------------------------------------------*/

LSERR LsdnFInChildList(PLSC plsc, PLSDNODE plsdn, BOOL* pfInChildList)  
	{
	Assert(FIsLSC(plsc));
	Assert(FIsLSDNODE(plsdn));
	Unreferenced(plsc);    /* to avoid warning in shiping version */

	*pfInChildList = ! (FIsSubLineMain(SublineFromDnode(plsdn)));

	return lserrNone;
	}

/* L S D N  S E T  H Y P H E N A T E D*/
/*----------------------------------------------------------------------------
    %%Function: LsdnSetHyphenated
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 

Set thet current line has been hyphenated
----------------------------------------------------------------------------*/
LSERR LsdnSetHyphenated(PLSC plsc)		
	{

	Assert(FIsLSC(plsc));

	plsc->fHyphenated = fTrue;

	return lserrNone;
	}

/* L S D N  R E S E T  W I T H  I N  P R E V I O U S  D N O D E S*/
/*----------------------------------------------------------------------------
    %%Function: LsdnResetWidthInPreviousDnodes
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	plsdn				-	(IN) dnode
	durChangePrev		-	(IN) durChangePrev (don't change if 0)
	durChangePrevPrev	-	(IN) durChangePrevPrev (don't change if 0) 

  Used at SetBreak time for hyphen/nonreqhyphen cases
----------------------------------------------------------------------------*/
LSERR LsdnResetWidthInPreviousDnodes(PLSC plsc,	PLSDNODE plsdn,	
					 long durChangePrev, long durChangePrevPrev)  
	{

	Assert(FIsLSC(plsc));
	Assert(FIsLSDNODE(plsdn));
	Assert(FBreakingAllowed(plsc)); /* this procedure are called only in breaking time */
	Assert(FIsDnodeReal(plsdn));
	Assert(IdObjFromDnode(plsdn) == IobjTextFromLsc(&plsc->lsiobjcontext)); /* only text can do this */

	Unreferenced(plsc);    /* to avoid warning in shiping version */

	/* change dnode  */
	ModifyDnodeDurFmt(plsdn, -(durChangePrev + durChangePrevPrev));
	
	/* change previous dnode */
	if (durChangePrev != 0)
		{
		Assert(plsdn->plsdnPrev != NULL);
		Assert(FIsDnodeReal(plsdn->plsdnPrev));
		 /* only with text we can do this */
		Assert(IdObjFromDnode(plsdn->plsdnPrev) == IobjTextFromLsc(&plsc->lsiobjcontext));

		ModifyDnodeDurFmt(plsdn->plsdnPrev, durChangePrev);
		}

	/* change dnode before previous  */
	if (durChangePrevPrev != 0)
		{
		Assert(plsdn->plsdnPrev != NULL);
		Assert(plsdn->plsdnPrev->plsdnPrev != NULL);
		Assert(FIsDnodeReal(plsdn->plsdnPrev->plsdnPrev));
		 /* only with text we can do this */
		Assert(IdObjFromDnode(plsdn->plsdnPrev->plsdnPrev) == IobjTextFromLsc(&plsc->lsiobjcontext));

		ModifyDnodeDurFmt(plsdn->plsdnPrev->plsdnPrev, durChangePrevPrev);
		}

	/* this procedure doesn't change resulting pen position */

	/* after such changes in dnode location of chunk should be recalculatted */
	InvalidateChunkLocation(PlschunkcontextFromSubline(plsdn->plssubl));

	return lserrNone;
	}

/* L S D N  G E T  U R  P E N  A T  B E G I N N I N G  O F  C H U N K*/
/*----------------------------------------------------------------------------
    %%Function: LsdnGetUrPenAtBeginningOfChunk
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	plsdn				-	(IN) first dnode in chunk
	purPen				-	(OUT) position of the begining of the chunk
	purColumnMax		-	(OUT) width of column

  Used by SnapGrid
----------------------------------------------------------------------------*/
LSERR LsdnGetUrPenAtBeginningOfChunk(PLSC plsc,	PLSDNODE plsdn,	
					 long* purPen, long* purColumnMax)   	
	{
	PLSSUBL plssubl = SublineFromDnode(plsdn);
	POINTUV point;

	Assert(FIsLSC(plsc));
	Assert(FIsLSDNODE(plsdn));

	*purColumnMax = plsc->lsgridcontext.urColumn;
	GetCurrentPointSubl(plssubl, point);

	return GetUrPenAtBeginingOfLastChunk(plssubl->plschunkcontext, plsdn, 
			GetCurrentDnodeSubl(plssubl), &point, purPen);

			
	}


/* L S D N  R E S E T  D C P  M E R G E*/
/*----------------------------------------------------------------------------
    %%Function: LsdnResetDcpMerge
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	plsdn				-	(IN) dnode 
	cpFirstNew			-	(IN) new cpFirst to put in the dnode
	dcpNew				-	(IN) new dcp to put in the dnode

  Reset amount of characters in the dnode due to shaping glyph together
----------------------------------------------------------------------------*/
LSERR LsdnResetDcpMerge(PLSC plsc, PLSDNODE plsdn, LSCP cpFirstNew, LSDCP dcpNew)
	{
	return ResetDcpCore(plsc, plsdn, cpFirstNew, dcpNew, fTrue);
	}

/* L S D N  R E S E T  D C P  */
/*----------------------------------------------------------------------------
    %%Function: LsdnResetDcp
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	plsdn				-	(IN) dnode 
	dcpNew				-	(IN) new dcp to put in the dnode

  Cut amount of characters in the dnode.
----------------------------------------------------------------------------*/
LSERR LsdnResetDcp(PLSC plsc, PLSDNODE plsdn, LSDCP dcpNew)
	{
	return ResetDcpCore(plsc, plsdn, plsdn->cpFirst, dcpNew, fFalse);
	}

/*  R E S E T  D C P  C O R E*/
/*----------------------------------------------------------------------------
    %%Function: ResetDcpCore
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	plsdn				-	(IN) dnode 
	cpFirstNew			-	(IN) new cpFirst to put in the dnode
	dcpNew				-	(IN) new dcp to put in the dnode
	fMerge				-	(IN) characters from the next dnode moves to previous

  Internal procedure which implements both LsdnResetDcpMerge and LsdnResetDcp
----------------------------------------------------------------------------*/
static LSERR ResetDcpCore(PLSC plsc, PLSDNODE plsdn, LSCP cpFirstNew,
						  LSDCP dcpNew, BOOL fMerge)	
	{
	LSERR lserr;
	PLSDNODE plsdnPrev;
	PLSDNODE plsdnNext;
	PLSDNODE plsdnPrevNonBorder;
	PLSDNODE plsdnFirstDelete;
	PLSDNODE plsdnLastDelete;
	PLSDNODE plsdnBorder;

	Assert(FIsLSDNODE(plsdn));
	Assert(FIsDnodeReal(plsdn));

	/* if everything stays the same return right away */
	if ((cpFirstNew == plsdn->cpFirst) && (dcpNew == plsdn->dcp))
		   	return lserrNone;	

	/* after such changes in dnodes chunk should be recollected */
	InvalidateChunk(PlschunkcontextFromSubline(plsdn->plssubl));
	
	lserr = plsc->lscbk.pfnResetRunContents(plsc->pols, plsdn->u.real.plsrun, plsdn->cpFirst,
		plsdn->dcp, cpFirstNew, dcpNew);
	if (lserr != lserrNone)
		return lserr;

	plsdn->cpFirst = cpFirstNew;
	plsdn->dcp = dcpNew;

	if (plsdn->cpFirst + (LSCP) plsdn->dcp > plsdn->cpLimOriginal)
		plsdn->cpLimOriginal = plsdn->cpFirst + plsdn->dcp;

	if (dcpNew == 0)  /* delete this dnode */
		{
		/* check that objdim has been zeroed */
		Assert(DurFromDnode(plsdn) == 0);
		Assert(DvrFromDnode(plsdn) == 0);

		plsdnPrev = plsdn->plsdnPrev;
		plsdnNext = plsdn->plsdnNext;

		if (fMerge)
			{
			plsdnPrevNonBorder = plsdnPrev;
			Assert(FIsLSDNODE(plsdnPrevNonBorder));
			while(FIsDnodeBorder(plsdnPrevNonBorder))
				{
				plsdnPrevNonBorder = plsdnPrevNonBorder->plsdnPrev;
				Assert(FIsLSDNODE(plsdnPrevNonBorder));
				}
			
			/* set cpLimOriginal  */
			plsdnPrevNonBorder->cpLimOriginal = plsdn->cpLimOriginal;
			plsdnBorder = plsdnPrevNonBorder->plsdnNext;
			while(FIsDnodeBorder(plsdnBorder))
				{
				plsdnBorder->cpFirst = plsdn->cpLimOriginal;
				plsdnBorder->cpLimOriginal = plsdn->cpLimOriginal;
				plsdnBorder = plsdnBorder->plsdnNext;
				Assert(FIsLSDNODE(plsdnBorder));
				}
			Assert(plsdnBorder == plsdn);
			}

		if ((plsdnPrev != NULL && FIsDnodeOpenBorder(plsdnPrev))
			&& (plsdnNext == NULL 
			    || (FIsDnodeBorder(plsdnNext) &&  !FIsDnodeOpenBorder(plsdnNext))
			   )
			)
			/* we should delete  empty borders */
			{
			plsdnFirstDelete = plsdnPrev;
			if (plsdnNext != NULL)
				{
				plsdnLastDelete = plsdnNext;
				AdvanceCurrentUrSubl(SublineFromDnode(plsdnFirstDelete),
					  -DurFromDnode(plsdnFirstDelete));
				AdvanceCurrentUrSubl(SublineFromDnode(plsdnLastDelete),
					  -DurFromDnode(plsdnLastDelete));
				}
			else 
				{
				plsdnLastDelete = plsdn;
				AdvanceCurrentUrSubl(SublineFromDnode(plsdnFirstDelete),
					  -DurFromDnode(plsdnFirstDelete));
				}

			plsdnPrev = plsdnFirstDelete->plsdnPrev;
			plsdnNext = plsdnLastDelete->plsdnNext;
			}
		else
			{
			plsdnFirstDelete = plsdn;
			plsdnLastDelete = plsdn;
			}

		/*set links */
		if (plsdnPrev != NULL)
			{
			Assert(FIsLSDNODE(plsdnPrev));
			plsdnPrev->plsdnNext = plsdnNext;
			}

		if (plsdnNext != NULL)
			{
			Assert(FIsLSDNODE(plsdnNext));
			plsdnNext->plsdnPrev = plsdnPrev;
			}
		else
			{
			/* this dnode was the last one so we need to change state */
			SetCurrentDnodeSubl(plsdn->plssubl, plsdnPrev);
			}


		/* break link with next and destroy */
		plsdnLastDelete->plsdnNext = NULL;
		lserr = DestroyDnodeList (&plsc->lscbk, plsc->pols, &plsc->lsiobjcontext, 
				plsdnFirstDelete, plsc->fDontReleaseRuns);
		if (lserr != lserrNone)
			return lserr;
		}


   	return lserrNone;	

}

/* L S D N  G E T  B O R D E R  A F T E R */
/*----------------------------------------------------------------------------
    %%Function: LsdnCheckAvailableSpace
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	plsdn				-	(IN) dnode to find closing border for
	pdurBorder			-	(OUT) dur of the border after this DNODE

----------------------------------------------------------------------------*/
LSERR LsdnGetBorderAfter(PLSC plsc,	PLSDNODE plsdn,	
					 long* pdurBorder)	
	{
	Unreferenced(plsc);  /* to avoid warning in shiping version */

	Assert(FIsLSC(plsc));
	Assert(FIsLSDNODE(plsdn));

	*pdurBorder = 0;
	if (FDnodeHasBorder(plsdn))
		{
		*pdurBorder = DurBorderFromDnodeInside(plsdn);
		}
	return lserrNone;

	}

/* L S D N  G E T  G E T  L E F T  I N D E N T  D U R */
/*----------------------------------------------------------------------------
    %%Function: LsdnGetLeftIndentDur
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	pdurLeft			-	(OUT) dur of the left margin

----------------------------------------------------------------------------*/
LSERR LsdnGetLeftIndentDur(PLSC plsc, long* pdurLeft)		
	{

	Assert(FIsLSC(plsc));

	*pdurLeft = plsc->lsadjustcontext.urLeftIndent;

	return lserrNone;
	}

/* L S D N  S E T  S T O P R */
/*----------------------------------------------------------------------------
    %%Function: LsdnSetStopr
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	plsdn				-	(IN) dnode 
	stopres				-	(IN) kind of hard break

  Set flag correspondent to a type of hard break into dnode
----------------------------------------------------------------------------*/
LSERR LsdnSetStopr(PLSC plsc, PLSDNODE plsdn, STOPRES stopres)	
	{
	Unreferenced(plsc);  /* to avoid warning in shiping version */

	Assert(FIsLSC(plsc));
	Assert(FIsLSDNODE(plsdn));
	Assert(!plsdn->fEndOfColumn && !plsdn->fEndOfPage && !plsdn->fEndOfSection &&
		   !plsdn->fEndOfPara && !plsdn->fAltEndOfPara && !plsdn->fSoftCR);
	
	switch (stopres)
		{
		case stoprEndColumn:
			plsdn->fEndOfColumn = fTrue;
			break;
		case stoprEndPage:
			plsdn->fEndOfPage = fTrue;
			break;
		case stoprEndSection:
			plsdn->fEndOfSection = fTrue;
			break;
		case stoprEndPara:
			plsdn->fEndOfPara = fTrue;
			break;
		case stoprAltEndPara:
			plsdn->fAltEndOfPara = fTrue;
			break;
		case stoprSoftCR:
			plsdn->fSoftCR = fTrue;
			break;
		default:
			NotReached();
		}

   	return lserrNone;		

}

/* L S D N  F  C A N  B E F O R E  N E X T  C H U N K */
/*----------------------------------------------------------------------------
    %%Function: LsdnFCanBreakBeforeNextChunk
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	plsdn				-	(IN) Last DNODE of the current chunk 
	pfCanBreakBeforeNextChunk-(OUT) Can break before next chunk ? 

Called by text during find previous break when it's going to set break after last text dnode.
Procedure forwards this question to the next after text object
----------------------------------------------------------------------------*/

LSERR LsdnFCanBreakBeforeNextChunk(PLSC  plsc, PLSDNODE plsdn,	BOOL* pfCanBreakBeforeNextChunk)
	{
	Assert(FIsLSC(plsc));
	Assert(FIsLSDNODE(plsdn));

	return FCanBreakBeforeNextChunkCore (plsc, plsdn, pfCanBreakBeforeNextChunk);
	}

/* L S D N  F  S T O P P E D  A F T E R  C H U N K */
/*----------------------------------------------------------------------------
    %%Function: LsdnFStoppedAfterChunk
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	plsdn				-	(IN) Last DNODE of the current chunk 
	pfStoppedAfterChunk-(OUT) Splat or Hidden Text, producing fmtrStopped after chunk? 

Called by text during find previous break when breaking rules prohibit text to break after last dnode,
but is must do this because of splat.
----------------------------------------------------------------------------*/

LSERR LsdnFStoppedAfterChunk(PLSC  plsc, PLSDNODE plsdn,	BOOL* pfStoppedAfterChunk)
	{
	PLSDNODE plsdnNext;

	Unreferenced(plsc);  /* to avoid warning in shiping version */

	Assert(FIsLSC(plsc));
	Assert(FIsLSDNODE(plsdn));

	if (!FIsSubLineMain(SublineFromDnode(plsdn)))
		*pfStoppedAfterChunk = fFalse;
	else 
		{
		plsdnNext = plsdn->plsdnNext;
		if (plsdnNext == NULL || FIsDnodeSplat(plsdnNext))
			*pfStoppedAfterChunk = fTrue;
		else
			*pfStoppedAfterChunk = fFalse;
		}
	return lserrNone;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\lsenum.c ===
#include "lsenum.h"
#include "lsc.h"
#include "lsline.h"
#include "prepdisp.h"
#include "enumcore.h"


//    %%Function:	LsEnumLine
//    %%Contact:	victork
//
/*
 * Enumerates the formatted line (main subline) (from the given point is fGeometry needed).
 */
	
LSERR WINAPI LsEnumLine(PLSLINE plsline, BOOL fReverseOrder, BOOL fGeometryNeeded, const POINT* pptorg)
{

	PLSC 	plsc;
	LSERR 	lserr;

	if (!FIsLSLINE(plsline)) return lserrInvalidParameter;

	plsc = plsline->lssubl.plsc;
	Assert(FIsLSC(plsc));

	if (plsc->lsstate != LsStateFree) return lserrContextInUse;

	if (fGeometryNeeded)
		{
		lserr = PrepareLineForDisplayProc(plsline);

		plsc->lsstate = LsStateFree;
		
		if (lserr != lserrNone) return lserr;
		}

	plsc->lsstate = LsStateEnumerating;

	lserr = EnumSublineCore(&(plsline->lssubl), fReverseOrder, fGeometryNeeded, 
								pptorg, plsline->upStartAutonumberingText);

	plsc->lsstate = LsStateFree;
	
	return lserr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\lsfetch.c ===
#include "lsidefs.h"
#include "dninfo.h"
#include "dnutils.h"
#include "fmti.h"
#include "getfmtst.h"
#include "iobj.h"
#include "iobjln.h"
#include "lsc.h"
#include "lsdnode.h"
#include "lsfetch.h"
#include "lsfrun.h"
#include "lsline.h"
#include "lsesc.h"
#include "lstext.h"
#include "ntiman.h"
#include "qheap.h"
#include "setfmtst.h"
#include "tabutils.h"
#include "zqfromza.h"
#include "lssubl.h"
#include "autonum.h"
#include "lscfmtfl.h"

#include <limits.h>
#include "lsmem.h"						/* memset() */

/* L I M  R G */
/*----------------------------------------------------------------------------
    %%Function: LimRg
    %%Contact: igorzv

    Returns # of elements in an array.
----------------------------------------------------------------------------*/
#define LimRg(rg)	(sizeof(rg)/sizeof((rg)[0]))



/* A S S E R T  V A L I D  F M T R E S */
/*----------------------------------------------------------------------------
    %%Macro: AssertValidFmtres
    %%Contact: lenoxb

    Verifies that fmtrCk has a legal value.
----------------------------------------------------------------------------*/
#define AssertValidFmtres(fmtrCk) \
		Assert( \
				(fmtrCk) == fmtrCompletedRun || \
				(fmtrCk) == fmtrExceededMargin || \
				(fmtrCk) == fmtrTab  || \
				(fmtrCk) == fmtrStopped \
			  );




/* S E T  T O  M A X */
/*----------------------------------------------------------------------------
    %%Macro: SetToMax
    %%Contact: lenoxb

    Sets "a" to the maximum of "a" and "b".
----------------------------------------------------------------------------*/
#define SetToMax(a,b)		if ((a) < (b)) (a) = (b); else




/* S E T  H E I G H T  T O  M A X */
/*----------------------------------------------------------------------------
    %%Macro: SetHeightToMax
    %%Contact: igorzv

    Sets the line height elements of an LSLINFO structure to the maximum
	of their current value, and the height of an arbitrary object.
	(plslinfo)->dvrMultiLineHeight == dvHeightIgnore is sign not 
	to take into account this dnode 
----------------------------------------------------------------------------*/
#define SetHeightToMax(plslinfo,pobjdim) \
{\
	if ((pobjdim)->heightsRef.dvMultiLineHeight != dvHeightIgnore)\
		{\
		SetToMax((plslinfo)->dvrAscent, (pobjdim)->heightsRef.dvAscent);\
		SetToMax((plslinfo)->dvpAscent, (pobjdim)->heightsPres.dvAscent);\
		SetToMax((plslinfo)->dvrDescent, (pobjdim)->heightsRef.dvDescent);\
		SetToMax((plslinfo)->dvpDescent, (pobjdim)->heightsPres.dvDescent);\
		SetToMax((plslinfo)->dvpMultiLineHeight, (pobjdim)->heightsPres.dvMultiLineHeight);\
		SetToMax((plslinfo)->dvrMultiLineHeight, (pobjdim)->heightsRef.dvMultiLineHeight);\
		}\
}






#define PlnobjFromLsc(plsc,iobj)	((Assert(FIsLSC(plsc)), PlnobjFromLsline((plsc)->plslineCur,iobj)))

#define CreateLNObjInLsc(plsc, iobj) ((PLsimFromLsc(&((plsc)->lsiobjcontext),iobj))->pfnCreateLNObj\
									 (PilsobjFromLsc(&((plsc)->lsiobjcontext),iobj), \
														   &((plsc)->plslineCur->rgplnobj[iobj])))

/* This macros created to avoid code duplication  */

#define FRunIsNotSimple(plschp, fHidden)   \
									(((plschp)->idObj != idObjTextChp) ||  \
									 ((fHidden)) ||  \
									  ((plschp)->fBorder) || \
									  FApplyNominalToIdeal(plschp))

#define CreateDnode(plsc, plsdnNew) \
		(plsdnNew) = PvNewQuick(GetPqhAllDNodes(plsc), sizeof *(plsdnNew));\
		if ((plsdnNew) == NULL)\
			return lserrOutOfMemory;\
		(plsdnNew)->tag = tagLSDNODE;\
		(plsdnNew)->plsdnPrev = GetCurrentDnode(plsc);\
		(plsdnNew)->plsdnNext = NULL;\
		(plsdnNew)->plssubl = GetCurrentSubline(plsc);\
		/* we don't connect dnode list with this dnode untill handler calls*/ \
		/*Finish API, but we put correct pointer to previous in this dnode,*/ \
		/*so we can easily link list in Finish routines   */\
		(plsdnNew)->cpFirst = GetCurrentCpLim(plsc); \
		/* flush all flags, bellow check that result is what  we expect */ \
		*((DWORD *) ((&(plsdnNew)->dcp)+1)) = 0;\
		Assert((plsdnNew)->klsdn == klsdnReal);\
		Assert((plsdnNew)->fRigidDup == fFalse);\
		Assert((plsdnNew)->fAdvancedPen == fFalse);\
		Assert((plsdnNew)->fTab == fFalse);\
		Assert((plsdnNew)->icaltbd == 0);\
		Assert((plsdnNew)->fBorderNode == fFalse);\
		Assert((plsdnNew)->fOpenBorder == fFalse);\
		Assert((plsdnNew)->fEndOfSection == fFalse); \
		Assert((plsdnNew)->fEndOfColumn == fFalse); \
		Assert((plsdnNew)->fEndOfPage == fFalse); \
		Assert((plsdnNew)->fEndOfPara == fFalse); \
		Assert((plsdnNew)->fAltEndOfPara == fFalse); \
		Assert((plsdnNew)->fSoftCR == fFalse); \
		Assert((plsdnNew)->fInsideBorder == fFalse); \
		Assert((plsdnNew)->fAutoDecTab == fFalse); \
		Assert((plsdnNew)->fTabForAutonumber == fFalse);


#define FillRealPart(plsdnNew, plsfrunOfDnode)\
		/* we don't initialize  here variables that will be set in FiniSimpleRegular  */ \
		(plsdnNew)->u.real.pinfosubl = NULL;\
		/* next two assignement we do to use DestroyDnodeList in the case of error */ \
		(plsdnNew)->u.real.plsrun = (plsfrunOfDnode)->plsrun;\
		(plsdnNew)->u.real.pdobj = NULL;\
		/* we put amount of characters to dcp to check it in LsdnFinishSimpleByOneChar */ \
		(plsdnNew)->dcp = (plsfrunOfDnode)->cwchRun; \
		(plsdnNew)->cpLimOriginal = (plsdnNew)->cpFirst + (plsdnNew)->dcp;

#define CreateRealDnode(plsc,plsdnNew, plsrun)\
		CreateDnode((plsc), (plsdnNew));\
		FillRealPart((plsdnNew), (plsrun));

#define CreatePenDnode(plsc,plsdnNew)\
		CreateDnode((plsc), (plsdnNew));\
		(plsdnNew)->dcp = 0;\
		(plsdnNew)->cpLimOriginal = (plsdnNew)->cpFirst;\
		(plsdnNew)->u.pen.dur = 0;\
		(plsdnNew)->u.pen.dup = 0;\
		(plsdnNew)->u.pen.dvr = 0;\
		(plsdnNew)->u.pen.dvp = 0;\
		(plsdnNew)->klsdn = klsdnPenBorder;

#define CreateBorderDnode(plsc,plsdnNew, durBorder, dupBorder)\
		CreateDnode((plsc), (plsdnNew));\
		(plsdnNew)->dcp = 0;\
		(plsdnNew)->cpLimOriginal = (plsdnNew)->cpFirst;\
		(plsdnNew)->u.pen.dur = (durBorder);\
		(plsdnNew)->u.pen.dup = (dupBorder);\
		(plsdnNew)->u.pen.dvr = 0;\
		(plsdnNew)->u.pen.dvp = 0;\
		(plsdnNew)->klsdn = klsdnPenBorder; \
		(plsdnNew)->fBorderNode = fTrue; \
		TurnOnNonRealDnodeEncounted(plsc);

#define FNeedToCutPossibleContextViolation(plsc, plsdn) \
	(FIsDnodeReal(plsdn) && \
	 ((plsdn)->u.real.lschp.dcpMaxContext > 1) && \
	 (IdObjFromDnode(plsdn) == IobjTextFromLsc(&((plsc)->lsiobjcontext)))  \
    )

/* ------------------------------------------------------------------ */
static LSERR CheckNewPara(PLSC, LSCP, LSCP, BOOL*);
static BOOL FLimitRunEsc(LSFRUN*, const LSESC*, DWORD);
static LSERR CreateInitialPen(PLSC plsc, long dur);
static LSERR 	UndoLastDnode(PLSC);				/* IN: ls context */
static LSERR  OpenBorder(PLSC plsc, PLSRUN plsrun);
static LSERR HandleSplat(PLSC plsc, FMTRES* pfmtres);
static LSERR ErrReleaseRunToFormat	  (PLSC,	/* IN: ptr to line services context */	
									  PLSRUN,	/* IN: ponter to a run structure to be deleted */
									  LSERR);	/* IN: code of an error							*/


/* ---------------------------------------------------------------------- */

/* F E T C H  A P P E N D  E S C  R E S U M E  C O R E */
/*----------------------------------------------------------------------------
    %%Function: FetchAppendEscResumeCore
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 
	urColumnMax		-	(IN) right margin where to stop
	plsesc		-		(IN) escape characters
	clsesc	-			(IN) # of escape characters
	rgbreakrec	-		(IN) input array of break records 
	cbreakrec,			(IN) number of records in input array 
	pfmtres		-		(OUT) result of last formatter
	pcpLim	-			(OUT) where we stop fetching
	pplsdnFirst		-	(OUT) first dnode that was created
	pplsdnLast		-	(OUT) last dnode that was created
	pur			-		(OUT) pen position after procedure

	If cbreakrec > 0 fetches run with cpFirst from first break record.
	After that if rigth msrgin is not exceeded cals FetchAppendEscCore
----------------------------------------------------------------------------*/
LSERR 	FetchAppendEscResumeCore(PLSC plsc, long urColumnMax, const LSESC* plsesc,
						   DWORD clsesc, const BREAKREC* rgbreakrec,
						   DWORD cbreakrec, FMTRES* pfmtres, LSCP*	  pcpLim,
						   PLSDNODE* pplsdnFirst, PLSDNODE* pplsdnLast, 
						   long* pur)
						   
	{
	LSFRUN lsfrun;
	LSCHP lschp;  /* local memory to store lschp */
	BOOL fHidden;
	FMTRES fmtresResume;
	LSERR lserr;
	PLSDNODE* pplsdnFirstStore;   /* where to find plsdnFirst  */
	
	Assert(FIsLSC(plsc)); 
	Assert(FFormattingAllowed(plsc));
	Assert(!(rgbreakrec == NULL && cbreakrec != 0));
	Assert(GetCurrentDnode(plsc) == NULL); /* it should be begining of a subline */

	if (cbreakrec > 0)
		{
		/*Initialization;    */
		
		lsfrun.plschp = &lschp;
		pplsdnFirstStore = GetWhereToPutLink(plsc, GetCurrentDnode(plsc));

		/* fetch run that starts object to resume */
		lserr = plsc->lscbk.pfnFetchRun(plsc->pols, rgbreakrec[0].cpFirst,
			&lsfrun.lpwchRun, &lsfrun.cwchRun,
			&fHidden, &lschp, &lsfrun.plsrun);
		if (lserr != lserrNone)
			return lserr;
		
		if (lsfrun.cwchRun <= 0 || fHidden || lsfrun.plschp->idObj != rgbreakrec[0].idobj)
			{
			lserr = lserrInvalidBreakRecord;
			if (!plsc->fDontReleaseRuns)
				{
				plsc->lscbk.pfnReleaseRun(plsc->pols, lsfrun.plsrun);
				}
			return lserr;
			}

		/* zero amount of characters before dispatching to an object */
		lsfrun.cwchRun = 0;

		lserr = ProcessOneRun(plsc, urColumnMax, &lsfrun, rgbreakrec,
							  cbreakrec,&fmtresResume);
		if (lserr != lserrNone)
			return lserr;

		/* we know that resumed object is not text, so only two fmtres are possible
		   and we don't consider others */
		Assert(fmtresResume == fmtrCompletedRun || fmtresResume == fmtrExceededMargin);

		if (fmtresResume == fmtrCompletedRun)
			{

			lserr = FetchAppendEscCore(plsc, urColumnMax, plsesc, clsesc, pfmtres, pcpLim,
						   pplsdnFirst, pplsdnLast, pur);
			if (lserr != lserrNone)
				return lserr;

			/* special handling of empty dnode list as an result of FetchAppendEscCore */
			if (*pplsdnFirst == NULL)
				{
				*pplsdnLast = GetCurrentDnode(plsc); /* this assigning is correct even when 
													    resumed object produces empty list 
														of dnodes because it starts subline */

				*pfmtres = fmtresResume;
				}

			/* rewrite first dnode */
			*pplsdnFirst = *pplsdnFirstStore; 
			}
		else	/* stop fetching here */
			{
			/*  Prepare output   */
			*pfmtres = fmtresResume;
			*pcpLim = GetCurrentCpLim(plsc);
			*pplsdnFirst = *pplsdnFirstStore; 
			*pplsdnLast = GetCurrentDnode(plsc);
			*pur = GetCurrentUr(plsc);
			}
		
		Assert((*pplsdnFirst == NULL) == (*pplsdnLast == NULL));
		Assert((*pplsdnLast == NULL) || ((*pplsdnLast)->plsdnNext == NULL));

		return lserrNone;
		}
	else    /* no breakrecords */
		{
		return FetchAppendEscCore(plsc, urColumnMax, plsesc, clsesc, pfmtres, pcpLim,
						   pplsdnFirst, pplsdnLast, pur);
		}
	}

/* ---------------------------------------------------------------------- */

/* F E T C H  A P P E N D  E S C  C O R E */
/*----------------------------------------------------------------------------
    %%Function: FetchAppendEscCore
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 
	urColumnMax		-	(IN) right margin where to stop
	plsesc		-		(IN) escape characters
	clsesc	-			(IN) # of escape characters
	pfmtres		-		(OUT) result of last formatter
	pcpLim	-			(OUT) where we stop fetching
	pplsdnFirst		-	(OUT) first dnode that was created
	pplsdnLast		-	(OUT) last dnode that was created
	pur			-		(OUT) pen position after procedure

	Loop: fetch run, dispatch it to object handler until escape character
			or terminal fmtres.
----------------------------------------------------------------------------*/


LSERR 	FetchAppendEscCore(PLSC plsc, long urColumnMax, const LSESC* plsesc,
						   DWORD clsesc, FMTRES* pfmtres, LSCP*	  pcpLim,
						   PLSDNODE* pplsdnFirst, PLSDNODE* pplsdnLast, 
						   long* pur)
						   
	{
	
	BOOL fDone = fFalse;
	LSFRUN lsfrun;
	LSCHP lschp;  /* local memory to store lschp */
	FMTRES fmtres;
	BOOL fHidden;
	LSCP cpLimOfCutRun = (LSCP)(-1);   /* cpLim of run that was cuted according with Esc character
									   is not valid in other cases
	we use it to check that whole such run was handled by formater */
	LSCP cpPrev = (LSCP)(-1);	/* cp of previous run valid only after first iteration */
	LSERR lserr;
	PLSDNODE* pplsdnFirstStore;   /* where to find plsdnFirst  */
	
	
	Assert(FIsLSC(plsc)); 
	Assert(FFormattingAllowed(plsc)); 
	
	/*Initialization;    */
	lsfrun.plschp = &lschp;
	fmtres = fmtrCompletedRun;  /* it will be output if return right away with esc character */
	pplsdnFirstStore = GetWhereToPutLink(plsc, GetCurrentDnode(plsc));
	
	while (!fDone)
		{
		cpPrev = GetCurrentCpLim(plsc);
		/*     FetchRun        */
		lserr = plsc->lscbk.pfnFetchRun(plsc->pols, GetCurrentCpLim(plsc),
			&lsfrun.lpwchRun, &lsfrun.cwchRun,
			&fHidden, &lschp, &lsfrun.plsrun);
		if (lserr != lserrNone)
			return lserr;
		
		if (lsfrun.cwchRun <= 0)
			{
			lserr = lserrInvalidDcpFetched;
			if (!plsc->fDontReleaseRuns)
				{
				plsc->lscbk.pfnReleaseRun(plsc->pols, lsfrun.plsrun);
				}
			return lserr;
			}
		
		if (fHidden)
			{
			AdvanceCurrentCpLim(plsc, lsfrun.cwchRun);
			if (lsfrun.plsrun != NULL && !plsc->fDontReleaseRuns)  /* we have not used this plsrun */
				{
				lserr = plsc->lscbk.pfnReleaseRun(plsc->pols, lsfrun.plsrun);
				if (lserr != lserrNone)
					return lserr;
				}
			/*  Handle vanish end of paragraph;  */
			/*  There is situation in Word (see bug 118) when after fetching hidden text
			paragraph boundaries can be changed. So we have to call CheckNewPara
			every time after hidden text  */
			
			lserr = CheckNewPara(plsc, cpPrev, GetCurrentCpLim(plsc), &fDone);
			if (lserr != lserrNone)
				return lserr;
			
			if (fDone) 
				{
				/* it will eventually force stop formatting so we should apply 
				nominal to ideal here */
				if (FNominalToIdealEncounted(plsc))
					{
					lserr = ApplyNominalToIdeal(PlschunkcontextFromSubline(GetCurrentSubline(plsc)),
						&plsc->lsiobjcontext,
						plsc->grpfManager, plsc->lsadjustcontext.lskj,
						FIsSubLineMain(GetCurrentSubline(plsc)),
						FLineContainsAutoNumber(plsc), 
						GetCurrentDnode(plsc));
					if (lserr != lserrNone)
						return lserr;  
					}
				fmtres = fmtrStopped;
				}
			}
		else
			{
			/*   Check Esc character;     */
			if (clsesc > 0 && FLimitRunEsc(&lsfrun, plsesc, clsesc))
				{
				cpLimOfCutRun = (LSCP) (GetCurrentCpLim(plsc) + lsfrun.cwchRun);
				fDone = (lsfrun.cwchRun == 0);
				}
			
			if (!fDone)
				{
				lserr = ProcessOneRun(plsc, urColumnMax, &lsfrun, NULL, 0, &fmtres);
				if (lserr != lserrNone)
					return lserr;
				
				/*Check fmtres: Are formating done?;   */
				switch (fmtres)
					{
					case fmtrCompletedRun:  
						fDone = (GetCurrentCpLim(plsc) == cpLimOfCutRun); /* is true only if we cuted because */
						Assert(!fDone || clsesc > 0);			 /* of esc character and formater handled such*/
						break;									 /* run completely  */
						
					case fmtrExceededMargin:
						fDone = fTrue;
						break;
						
					case fmtrTab:
						fDone = fTrue;
						break;

					case fmtrStopped:
						fDone = fTrue;
						break;
						
					default:
						NotReached();
						
					}
				
				}
			else   /* after limiting run by esc characters it was empty */
				{
				if (lsfrun.plsrun != NULL && !plsc->fDontReleaseRuns)  /* we have not used this plsrun */
					{
					lserr = plsc->lscbk.pfnReleaseRun(plsc->pols, lsfrun.plsrun);
					if (lserr != lserrNone)
						return lserr;
					fmtres = fmtrCompletedRun;
					}
				}
			}  /* if/else hidden  */
		}
		
		
		/*  Prepare output   */
		*pfmtres = fmtres;
		*pcpLim = GetCurrentCpLim(plsc);
		*pplsdnFirst = *pplsdnFirstStore; 
		if (*pplsdnFirst != NULL)					
			*pplsdnLast = GetCurrentDnode(plsc);
		else
			*pplsdnLast = NULL;
		*pur = GetCurrentUr(plsc);
		
		Assert((*pplsdnFirst == NULL) == (*pplsdnLast == NULL));
		Assert((*pplsdnLast == NULL) || ((*pplsdnLast)->plsdnNext == NULL));
		
		return lserrNone;
	}		
	

/* ---------------------------------------------------------------------- */

/* P R O C E S S  O N E  R U N */
/*----------------------------------------------------------------------------
    %%Function: ProcessOneRun
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 
	urColumnMax		-	(IN) right margin where to stop
	plsfrun		-		(IN) given run
	rgbreakrec	-		(IN) input array of break records 
	cbreakrec,			(IN) number of records in input array 
	pfmtres		-		(OUT) result of formatting

1) If run it's not a text run applies nominal to ideal to previous text chunk.
	To have correct pen position before dispatching to an foreign object.
2) Get text metrics and dispatches run to an handler.
3) If fmtres is terminal applies nominal to ideal to the last chunk. 
----------------------------------------------------------------------------*/


LSERR ProcessOneRun	(PLSC plsc,	long urColumnMax, const LSFRUN* plsfrun, 
					 const BREAKREC* rgbreakrec,
					 DWORD cbreakrec, FMTRES* pfmtres)	


{
	DWORD iobj;
	LSIMETHODS* plsim;
	PLNOBJ plnobj;
	struct fmtin fmti;
	LSERR lserr;
	PLSDNODE plsdnNew;
	PLSDNODE  plsdnToFinishOld;   /* we should restore it after every formater */
	PLSSUBL  plssublOld;
	PLSDNODE plsdnNomimalToIdeal;
	PLSDNODE* pplsdnToStoreNext; 
	PLSDNODE plsdnNext;
	PLSDNODE plsdnCurrent;
	PLSDNODE plsdnLast;
	BOOL fInterruptBorder;
	BOOL fInsideBorderUp = fFalse;
	BOOL fBordered = fFalse;

	

	Assert(FIsLSC(plsc));
	Assert(!(rgbreakrec == NULL && cbreakrec != 0));


	plsdnToFinishOld = GetDnodeToFinish(plsc);
	plssublOld = GetCurrentSubline(plsc);
	plsdnCurrent = GetCurrentDnode(plsc);
	pplsdnToStoreNext = GetWhereToPutLink(plsc, plsdnCurrent);
	if (plsdnToFinishOld != NULL)
		fInsideBorderUp = plsdnToFinishOld->fInsideBorder;


	if (plsfrun->plschp->idObj == idObjTextChp)
		iobj = IobjTextFromLsc(&plsc->lsiobjcontext);
	else
		iobj = plsfrun->plschp->idObj;

	Assert (FIobjValid(&plsc->lsiobjcontext, iobj));		/* Reject other out of range ids */
	if (!FIobjValid(&plsc->lsiobjcontext, iobj))			/*  for both debug and ship builds. */
		return ErrReleaseRunToFormat(plsc, plsfrun->plsrun, lserrInvalidObjectIdFetched);

	/* here we are catching for situatuion when client adding text dnode to a chunk to 
	which nominal to ideal has been applied, such situation will lead later to applying nominal
	to ideal twice to the same dnode, and this text doesn't like */
	AssertImplies(iobj == IobjTextFromLsc(&plsc->lsiobjcontext),
				  !FNTIAppliedToLastChunk(PlschunkcontextFromSubline(plssublOld)));
	if (iobj == IobjTextFromLsc(&plsc->lsiobjcontext) &&
		FNTIAppliedToLastChunk(PlschunkcontextFromSubline(plssublOld)))
		return ErrReleaseRunToFormat(plsc, plsfrun->plsrun, lserrFormattingFunctionDisabled);


	plsim = PLsimFromLsc(&plsc->lsiobjcontext, iobj);

	if (iobj != IobjTextFromLsc(&plsc->lsiobjcontext))
		{
		TurnOffAllSimpleText(plsc);  /* not text */
		TurnOnForeignObjectEncounted(plsc);
		
		if (FNominalToIdealEncounted(plsc))
			{
			lserr = ApplyNominalToIdeal(PlschunkcontextFromSubline(plssublOld), &plsc->lsiobjcontext,
				plsc->grpfManager, plsc->lsadjustcontext.lskj,
				FIsSubLineMain(plssublOld),	FLineContainsAutoNumber(plsc),
				plsdnCurrent);
			if (lserr != lserrNone)
				return ErrReleaseRunToFormat(plsc, plsfrun->plsrun, lserr);
			
			/* we should recalculate plsdnCurrent because nominal to ideal can destroy last dnode */
			plsdnCurrent = GetCurrentDnode(plsc);
			pplsdnToStoreNext = GetWhereToPutLink(plsc, plsdnCurrent);
			}
		
		} 

	FlushNTIAppliedToLastChunk(PlschunkcontextFromSubline(plssublOld));

	/* creating border dnodes */
	/* skip back pen dnodes */
	while (plsdnCurrent != NULL && FIsDnodePen(plsdnCurrent)) 
		{
		plsdnCurrent = plsdnCurrent->plsdnPrev;
		}

	if (FDnodeHasBorder(plsdnCurrent) && 
		!(FIsDnodeBorder(plsdnCurrent) && !FIsDnodeOpenBorder(plsdnCurrent))) /* previous dnode has unclosed border */
		/* condition in if looks superfluous but it works correctly even if dnodes deleting
		happend during formatting */
		{
		if (plsfrun->plschp->fBorder)
			{
			/* check that client wants to border runs together */
			lserr = plsc->lscbk.pfnFInterruptBorder(plsc->pols, plsdnCurrent->u.real.plsrun,
				plsfrun->plsrun, &fInterruptBorder);
			if (lserr != lserrNone)
				return ErrReleaseRunToFormat(plsc, plsfrun->plsrun, lserr);

			if (fInterruptBorder)
				{
				/* close previous border and open new one */
				lserr = CloseCurrentBorder(plsc);
				if (lserr != lserrNone)
					return ErrReleaseRunToFormat(plsc, plsfrun->plsrun, lserr);
				lserr = OpenBorder(plsc, plsfrun->plsrun);
				if (lserr != lserrNone)
					return ErrReleaseRunToFormat(plsc, plsfrun->plsrun, lserr);
				}
			fBordered = fTrue;
			}
		else
			{
			lserr = CloseCurrentBorder(plsc);
			if (lserr != lserrNone)
				return ErrReleaseRunToFormat(plsc, plsfrun->plsrun, lserr);
			}
		}
	else
		{
		if (plsfrun->plschp->fBorder)
			{
			if 	(fInsideBorderUp)
				{
				/* border is open on upper level: turn off border flag */
				((PLSCHP) (plsfrun->plschp))->fBorder = fFalse;
				}
			else
				{
				lserr = OpenBorder(plsc, plsfrun->plsrun);
				if (lserr != lserrNone)
					return ErrReleaseRunToFormat(plsc, plsfrun->plsrun, lserr);
				fBordered = fTrue;
				}
			}
		}

	/* we always create real dnode and change it for pen if needed in Finish method */
	CreateRealDnode(plsc, plsdnNew, plsfrun);
	plsdnNew->fInsideBorder = fInsideBorderUp || fBordered;

	/* initialization of fmti    */


	fmti.lsfgi.fFirstOnLine = FIsFirstOnLine(plsdnNew) && FIsSubLineMain(plssublOld);
	fmti.lsfgi.cpFirst = GetCurrentCpLim(plsc);
	fmti.lsfgi.urPen = GetCurrentUr(plsc);
	fmti.lsfgi.vrPen = GetCurrentVr(plsc);

	fmti.lsfgi.urColumnMax = urColumnMax;
	
	fmti.lsfgi.lstflow = plssublOld->lstflow;
	fmti.lsfrun = *plsfrun;
	fmti.plsdnTop = plsdnNew;


	lserr = plsc->lscbk.pfnGetRunTextMetrics(plsc->pols, fmti.lsfrun.plsrun,
								   lsdevReference, fmti.lsfgi.lstflow, &fmti.lstxmRef);
	if (lserr != lserrNone)
		{
		DestroyDnodeList (&plsc->lscbk, plsc->pols, &plsc->lsiobjcontext, 
			plsdnNew, plsc->fDontReleaseRuns);
		return lserr;
		}

	if (plsc->lsdocinf.fPresEqualRef)
		fmti.lstxmPres = fmti.lstxmRef;
	else
		{
		lserr = plsc->lscbk.pfnGetRunTextMetrics(plsc->pols, fmti.lsfrun.plsrun,
									   lsdevPres, fmti.lsfgi.lstflow,
										   &fmti.lstxmPres);
		if (lserr != lserrNone)
			{
			DestroyDnodeList (&plsc->lscbk, plsc->pols, &plsc->lsiobjcontext, 
				plsdnNew, plsc->fDontReleaseRuns);
			return lserr;
			}
		}


	plnobj = PlnobjFromLsc(plsc, iobj);


	if (plnobj == NULL)
		{
		lserr = CreateLNObjInLsc(plsc, iobj);
		if (lserr != lserrNone) 
			{
			DestroyDnodeList (&plsc->lscbk, plsc->pols, &plsc->lsiobjcontext, 
				plsdnNew, plsc->fDontReleaseRuns);
			return lserr;
			}
		plnobj = PlnobjFromLsc(plsc, iobj);
		}

	/* set dnode to finish */
	SetDnodeToFinish(plsc, plsdnNew);
	/* set current subline to NULL */
	SetCurrentSubline(plsc, NULL);
	
	if (cbreakrec == 0)
		{
		lserr = plsim->pfnFmt(plnobj, &fmti, pfmtres);
		}
	else{
		if (plsim->pfnFmtResume == NULL)
			return lserrInvalidBreakRecord;
		lserr = plsim->pfnFmtResume(plnobj, rgbreakrec, cbreakrec, &fmti, pfmtres);
		}

	if (lserr != lserrNone) 
		{
		if (plsc->lslistcontext.plsdnToFinish != NULL) /* dnode hasn't added to list */
			DestroyDnodeList (&plsc->lscbk, plsc->pols, &plsc->lsiobjcontext, 
				plsdnNew, plsc->fDontReleaseRuns);
		/* we should restore dnode to finish  and current subline  to properly handle
		error on upper level */
		SetCurrentSubline(plsc, plssublOld);
		SetDnodeToFinish(plsc, plsdnToFinishOld);
		return lserr;
		}

	AssertValidFmtres(*pfmtres); 

	if (GetCurrentSubline(plsc) != NULL || GetDnodeToFinish(plsc) != NULL)
		{
		/* we should restore dnode to finish  and current subline  to properly handle
		error on upper level */
		SetCurrentSubline(plsc, plssublOld);
		SetDnodeToFinish(plsc, plsdnToFinishOld);
		return lserrUnfinishedDnode;
		}

	/* restore dnode to finish  and current subline */
	SetCurrentSubline(plsc, plssublOld);
	SetDnodeToFinish(plsc, plsdnToFinishOld);

	/* to avoid all problems with deleteing dnodes we don't use plsdnNew */
	plsdnLast = GetCurrentDnodeSubl(plssublOld);

	/* case of tab */
	if (*pfmtres == fmtrTab)
		{	
		plsdnLast->fTab = fTrue;
		/* caller later can skip this tab so we prepare zero values */
		Assert(FIsDnodeReal(plsdnLast));
		Assert(IdObjFromDnode(plsdnLast) == IobjTextFromLsc(&plsc->lsiobjcontext));

		TurnOffAllSimpleText(plsc);  /* not text */
		}

	/* case of splat */
	if (*pfmtres == fmtrStopped && plsdnLast != NULL && FIsDnodeSplat(plsdnLast))
		{
		lserr = HandleSplat(plsc, pfmtres);
		if (lserr != lserrNone)
			return lserr;  
		/* Handle splat can delete plsdnLast */
		plsdnLast = GetCurrentDnodeSubl(plssublOld);
		}

	/* in a case of exceeded margin or hard break or tab (so all values of fmtres but fmtrCompletedRun)  */
	/* we need apply nominal to ideal to have correct lenght */
	if (*pfmtres != fmtrCompletedRun && plsdnLast != NULL && FNominalToIdealEncounted(plsc))
		{	
		if (*pfmtres == fmtrTab || FIsDnodeSplat(plsdnLast)) 
			plsdnNomimalToIdeal = plsdnLast->plsdnPrev;
		else
			plsdnNomimalToIdeal = plsdnLast;

		lserr = ApplyNominalToIdeal(PlschunkcontextFromSubline(plssublOld), &plsc->lsiobjcontext,
									plsc->grpfManager, plsc->lsadjustcontext.lskj,
									FIsSubLineMain(plssublOld),	FLineContainsAutoNumber(plsc),
									plsdnNomimalToIdeal);
		if (lserr != lserrNone)
			return lserr;  

		/* ApplyNominalToIdeal can delete plsdnLast */
		plsdnLast = GetCurrentDnodeSubl(plssublOld);
		/* if we run nominal to ideal because of tab chunk of text to which
		nominal to ideal is applied is not last chunk */
		if (*pfmtres == fmtrTab || FIsDnodeSplat(plsdnLast)) 
			FlushNTIAppliedToLastChunk(PlschunkcontextFromSubline(plssublOld));

		/* in a case of exceeded right margin we should extract dcpMaxContext characters 
		   because after fetching further result of nominal to ideal can be different for these
		   characters: examples ligatures or kerning */
		if (*pfmtres == fmtrExceededMargin && 
			FNeedToCutPossibleContextViolation(plsc, plsdnLast))
			{
			lserr = CutPossibleContextViolation(PlschunkcontextFromSubline(plssublOld),
												plsdnLast);
			if (lserr != lserrNone)
				return lserr; 
			/* such procedure also can delete plsdnLast */
			plsdnLast = GetCurrentDnodeSubl(plssublOld);
			}

		} 

	if (iobj != IobjTextFromLsc(&plsc->lsiobjcontext))
	/* only in this case there is a possibility to apply width modification 
	to preceding character */
		{
		/* we are actually applying width modification to preceding character if first
		dnode produced by formating is non text */
	   /* we can't relly on plsdnLast here because of such Finish methods as 
	   FinishByOneCharacter and FinishBySubline */
		/* we still rely here on pplsdnToStoreNext in other words we assume that
		plsdnCurrent (the current dnode in the begining of our procedure ) has not been
		deleted during nominal to ideal. To prove this we use that nominal to ideal has been
		already applied to plsdnCurrent*/
		plsdnNext = *pplsdnToStoreNext;
		Assert(plsdnNext == NULL || FIsLSDNODE(plsdnNext));
		if (FNominalToIdealEncounted(plsc) && 
			plsdnNext != NULL && 
			FIsDnodeReal(plsdnNext) &&
			IdObjFromDnode(plsdnNext) != IobjTextFromLsc(&plsc->lsiobjcontext)
			)
			{
				lserr = ApplyModWidthToPrecedingChar(PlschunkcontextFromSubline(plssublOld),
										&plsc->lsiobjcontext, plsc->grpfManager, 
										plsc->lsadjustcontext.lskj, plsdnNext);
			if (lserr != lserrNone)
				return lserr; 
			} 
		}


	
	return lserrNone;
}


/* ---------------------------------------------------------------------- */

/* Q U I C K  F O R M A T T I N G */
/*----------------------------------------------------------------------------
    %%Function: QuickFormatting
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 
	plsfrun		-		(IN) given run
	urColumnMax		-	(IN) right margin where to stop
	pfGeneral		-	(OUT) quick formatting was stopped: we should use general formatting 
	pfHardStop		-	(OUT) formatting ended with hard break
	pcpLim		-		(OUT) cpLim after procedure
	pur			-		(OUT) pen position after procedure

Works only with text runs without nominal to ideal and without tabs.
Stops if condition below is broken. 
----------------------------------------------------------------------------*/


LSERR 	QuickFormatting(PLSC plsc, LSFRUN* plsfrun,	long urColumnMax,
					    BOOL* pfGeneral, BOOL* pfHardStop,	
					    LSCP* pcpLim, long* pur)	

	{
	
	struct fmtin fmti;
	LSLINFO* plslinfoText;
	DWORD iobjText;
	PLNOBJ plnobjText;
	PLSLINE plsline;
	BOOL fHidden;
	const POLS pols = plsc->pols;
	BOOL fGeneral;
	FMTRES fmtres = fmtrCompletedRun;
	LSERR lserr;
	PLSDNODE plsdnNew;
	PLSSUBL plssubl;
	
	iobjText = IobjTextFromLsc(&(plsc->lsiobjcontext));
	plnobjText = PlnobjFromLsc(plsc, iobjText);
	plssubl = GetCurrentSubline(plsc);
	
	fmti.lsfrun = *plsfrun;
	fmti.lsfgi.fFirstOnLine = TRUE;
	fmti.lsfgi.cpFirst = GetCurrentCpLim(plsc);
	fmti.lsfgi.vrPen = GetCurrentVr(plsc);
	fmti.lsfgi.urPen = GetCurrentUr(plsc);
	fmti.lsfgi.lstflow = plssubl->lstflow;
	fmti.lsfgi.urColumnMax = urColumnMax;
	
	
	plsline = plsc->plslineCur;
	plslinfoText = &(plsline->lslinfo);
	
	fGeneral = fFalse;
	fHidden = fFalse;  /* in InitTextParams we already skipped all vanished text  */
	
	
	
	for (;;)						/* "break" exits quick-format loop */
		{							
		/* Run has been alreary fetched */
		
		/*we don't want to handle here vanished text, foreign object, nominal to ideal */
		if ( FRunIsNotSimple(fmti.lsfrun.plschp, fHidden))
			{
			/* we should release run here, in general procedure we will fetch it again */
			if (!plsc->fDontReleaseRuns)
				{
				
				lserr = plsc->lscbk.pfnReleaseRun(plsc->pols, fmti.lsfrun.plsrun);
				if (lserr != lserrNone)
					return lserr;
				}			
			fGeneral = fTrue;			
			break;						
			}
		
		/*Create dnode for text;     */
		CreateRealDnode(plsc, plsdnNew, &fmti.lsfrun);
		
		SetDnodeToFinish(plsc, plsdnNew);
		
		/*		prepare fmtin     */
		fmti.plsdnTop = plsdnNew;

		
		lserr = plsc->lscbk.pfnGetRunTextMetrics(pols, fmti.lsfrun.plsrun,
			lsdevReference, fmti.lsfgi.lstflow, &fmti.lstxmRef);
		if (lserr != lserrNone)
			{
			DestroyDnodeList (&plsc->lscbk, plsc->pols, &plsc->lsiobjcontext, 
				plsdnNew, plsc->fDontReleaseRuns);
			return lserr;
			}
		
		if (plsc->lsdocinf.fPresEqualRef)
			{
			fmti.lstxmPres = fmti.lstxmRef;
			}
		else
			{
			lserr = plsc->lscbk.pfnGetRunTextMetrics(pols, fmti.lsfrun.plsrun,
				lsdevPres, fmti.lsfgi.lstflow,
				&fmti.lstxmPres);
			if (lserr != lserrNone)
				{
				DestroyDnodeList (&plsc->lscbk, plsc->pols, &plsc->lsiobjcontext, 
					plsdnNew, plsc->fDontReleaseRuns);
				return lserr;
				}
			}
		
		SetCurrentSubline(plsc, NULL);
		lserr = FmtText(plnobjText, &fmti, &fmtres);
		if (lserr != lserrNone)
			{
			if (plsc->lslistcontext.plsdnToFinish != NULL) /* dnode hasn't added to list */
				DestroyDnodeList (&plsc->lscbk, plsc->pols, &plsc->lsiobjcontext, 
				plsdnNew, plsc->fDontReleaseRuns);
			return lserr;
			}
		/* restore current subline */
		SetCurrentSubline(plsc, plssubl);

		if (fmtres == fmtrTab )  /* tab: we quite from quick loop deleting this dnode
				because we will append it again in FormatGeneralCase  */
			{
			lserr = UndoLastDnode(plsc);  /* dnode is already in list  */
			if (lserr != lserrNone)
				return lserr;
			fGeneral = fTrue;
			break;
			}
			
			
		AssertValidFmtres(fmtres); 
			
		SetHeightToMax(plslinfoText, &(plsdnNew->u.real.objdim));
			
		if (FIsDnodeSplat(plsdnNew))
			{
			lserr = HandleSplat(plsc, &fmtres);
			if (lserr != lserrNone)
				return lserr;
			}

		if (fmtres != fmtrCompletedRun)
			{
			/*  after break we should check that final heights is not zero	*/
			/* otherwise  we take heights from last run */
			/* so we will have correct line height after quick break */
			if (plslinfoText->dvrAscent == 0 && plslinfoText->dvrDescent == 0)
				{
				plslinfoText->dvrAscent = fmti.lstxmRef.dvAscent;
				plslinfoText->dvpAscent = fmti.lstxmPres.dvAscent;
				plslinfoText->dvrDescent = fmti.lstxmRef.dvDescent;
				plslinfoText->dvpDescent = fmti.lstxmPres.dvDescent;
				plslinfoText->dvpMultiLineHeight = dvHeightIgnore;
				plslinfoText->dvrMultiLineHeight = dvHeightIgnore;		
				}	
			break;
			}
		
		/*	prepare next iteration;  */
			
		fmti.lsfgi.fFirstOnLine = fFalse;
		fmti.lsfgi.urPen = GetCurrentUr(plsc);
		fmti.lsfgi.cpFirst = GetCurrentCpLim(plsc);
			
		lserr = plsc->lscbk.pfnFetchRun(pols, fmti.lsfgi.cpFirst,
			&fmti.lsfrun.lpwchRun,
			&fmti.lsfrun.cwchRun,
			&fHidden, (LSCHP *)fmti.lsfrun.plschp,
			&fmti.lsfrun.plsrun);
		if (lserr != lserrNone)
			return lserr;

		Assert(fmti.lsfrun.cwchRun > 0);
			
		}		/* for (;;) */
	
	
	
	/* prepare output */
	*pfGeneral = fGeneral;
	*pfHardStop = (fmtres == fmtrStopped);
	*pcpLim = GetCurrentCpLim(plsc);
	*pur = GetCurrentUr(plsc);
	
	return lserrNone;
	
	}


/* C H E C K  N E W  P A R A */
/*----------------------------------------------------------------------------
    %%Function: CheckNewPara
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 
	cpPrev			-   (IN) cp in old paragraph
	cpThis			-	(IN) cp in new paragraph
	pfQuit			-	(OUT) stop formatting because new paragraph is not compatible with old

    Handles leaping from paragraph to paragraph (due to vanished text) on
	behalf of FetchAppendEscCore().  If the new paragraph is compatible
	with the old one, FetchPap is called and text is informed of the
	new para end parameters.
----------------------------------------------------------------------------*/
static LSERR CheckNewPara(PLSC plsc, LSCP cpPrev, LSCP cpThis, BOOL* pfQuit)
{
	LSERR lserr;
	BOOL  fHazard;
	LSPAP lspap;
	DWORD iobjText; 
	PLNOBJ plnobjText;  

	*pfQuit = fTrue;

	Assert(cpThis >= 0 && cpThis > cpPrev);


		

	lserr = plsc->lscbk.pfnCheckParaBoundaries(plsc->pols, cpPrev, cpThis, &fHazard);
	if (lserr != lserrNone)
		return lserr;

	if (!fHazard)
		{

		lserr = plsc->lscbk.pfnFetchPap(plsc->pols, cpThis, &lspap);
			if (lserr != lserrNone)
			return lserr;

		/* we don't know are we really in a new paragraph or not */
		/* so we have to modify information about end of paragraph */
		/* always as would we are in a new paragraph */
		iobjText = IobjTextFromLsc(&plsc->lsiobjcontext);
		plnobjText = PlnobjFromLsc(plsc, iobjText);

		lserr = ModifyTextLineEnding(plnobjText, lspap.lskeop);
		if (lserr != lserrNone)
			return lserr;    
		
		SetCpInPara(plsc->lstabscontext, cpThis);
		plsc->fLimSplat = lspap.grpf & fFmiLimSplat;
		plsc->fIgnoreSplatBreak = lspap.grpf & fFmiIgnoreSplatBreak;

		/* we don't invalidate tabs info and other paragraph properties 
		/* that we stored in context */

		*pfQuit = fFalse;
		}

	return lserr;
}


/* F L I M I T  R U N  E S C */
/*----------------------------------------------------------------------------
    %%Function: FLimitRunEsc
    %%Contact: igorzv
Parameters:
	plsfrun		-	(IN) run to cut
	plsesc		-	(IN) set of esc characters
	iescLim		-	(IN) number of esc characters 

    On behalf of LsFetchAppendEscCore(), this routine limits a run when
	an escape character is present.
----------------------------------------------------------------------------*/
static BOOL FLimitRunEsc(LSFRUN* plsfrun, const LSESC* plsesc, DWORD iescLim)
{
	DWORD iesc;
	DWORD ich;
	const LPCWSTR pwch = plsfrun->lpwchRun;
	const DWORD ichLim = plsfrun->cwchRun;

	Assert(iescLim > 0);	/* optimization -- test before calling */

	for (ich=0;  ich<ichLim;  ich++)
		{
		for (iesc=0;  iesc<iescLim;  iesc++)
			{

			if (FBetween(pwch[ich], plsesc[iesc].wchFirst, plsesc[iesc].wchLast))
				{
				plsfrun->cwchRun = ich;
				return fTrue;
				}
			}
		}
	return fFalse;
}



/* F O R M A T  A N M */
/*----------------------------------------------------------------------------
    %%Function: FormatAnm
    %%Contact: igorzv
Parameters:
	plsc			-	(IN) ptr to line services context 
	plsfrunMainText	-	(IN) first run of the main text

    Formats and allignes bullets and numbering
----------------------------------------------------------------------------*/

LSERR FormatAnm(PLSC plsc, PLSFRUN plsfrunMainText)
{
	long duaSpaceAnm;
	long duaWidthAnm;
	LSKALIGN lskalignAnm;
	WCHAR wchAdd;
	BOOL fWord95Model;
	LSERR lserr;
	LSFRUN lsfrun;
	LSCHP lschp;  /* local memory to store lschp */
	FMTRES fmtres;
	long durUsed;
	long urOriginal;
	long durAfter = 0;
	long durBefore = 0;
	LSCP cpLimOriginal;
	OBJDIM* pobjdimAnm;
	PLSDNODE plsdnAllignmentTab;
	BOOL fInterruptBorder;
	LSCHP lschpAdd; /* lschp for character added after autonumber */
	PLSRUN plsrunAdd; /* plsrun for character added after autonumber */


	Assert(FIsLSC(plsc)); 
	Assert(FFormattingAllowed(plsc)); 


	/*Initialization;    */
	lsfrun.plschp = &lschp;
	cpLimOriginal = GetCurrentCpLim(plsc);
	urOriginal = GetCurrentUr(plsc);
	SetCurrentCpLim(plsc, cpFirstAnm); 

	/* get autonumbering information */
	lserr = plsc->lscbk.pfnGetAutoNumberInfo(plsc->pols, &lskalignAnm, &lschp, &lsfrun.plsrun,
							&wchAdd, &lschpAdd, &plsrunAdd, 
							&fWord95Model, &duaSpaceAnm, &duaWidthAnm);
	if (lserr != lserrNone)
			return lserr;

	Assert(!memcmp(&lschp, &lschpAdd, sizeof(lschpAdd)));

	lsfrun.cwchRun = 0 ; /* we dont use characters in formating autonumbering object */
	lsfrun.lpwchRun = NULL;

	/* put idobj of autonumber to lschp */
	lschp.idObj = (WORD) IobjAutonumFromLsc(&plsc->lsiobjcontext);

	/* remove underlining and some other bits from chp */
	/* we don't underline it as a whole */
	lschp.fUnderline = fFalse;
	lschp.fStrike = fFalse;
	lschp.fShade = fFalse;
	lschp.EffectsFlags = 0;

	lserr = ProcessOneRun(plsc, uLsInfiniteRM, &lsfrun, NULL,
						  0, &fmtres);
	if (lserr != lserrNone)
		return lserr;

	Assert(fmtres == fmtrCompletedRun);
	Assert(GetCurrentDnode(plsc) != NULL);


	/* store heights of autonumber */
	Assert(FIsDnodeReal(GetCurrentDnode(plsc)));
	pobjdimAnm = &(GetCurrentDnode(plsc)->u.real.objdim);
	plsc->plslineCur->lslinfo.dvpAscentAutoNumber = pobjdimAnm->heightsPres.dvAscent;
	plsc->plslineCur->lslinfo.dvrAscentAutoNumber = pobjdimAnm->heightsRef.dvAscent;
	plsc->plslineCur->lslinfo.dvpDescentAutoNumber = pobjdimAnm->heightsPres.dvDescent;
	plsc->plslineCur->lslinfo.dvrDescentAutoNumber = pobjdimAnm->heightsRef.dvDescent;


	if (wchAdd != 0)  /* fill in lsfrun with a run of one character */
		{
		lsfrun.plschp = &lschpAdd;
		lsfrun.plsrun = plsrunAdd;
		lsfrun.lpwchRun = &wchAdd;
		lsfrun.cwchRun = 1;
		
		lserr = ProcessOneRun(plsc, uLsInfiniteRM, &lsfrun, NULL,
			0, &fmtres);
		if (lserr != lserrNone)
			return lserr;
		
		Assert(fmtres == fmtrCompletedRun || fmtres == fmtrTab);
		}

	plsdnAllignmentTab = GetCurrentDnode(plsc); /* in the case when added character is not tab this
												   value will not be used */

	if (lsfrun.plschp->fBorder)
		{
		if (plsfrunMainText->plschp->fBorder)
			{
			/* check that client wants to border runs together */
			lserr = plsc->lscbk.pfnFInterruptBorder(plsc->pols, 
				lsfrun.plsrun, plsfrunMainText->plsrun, &fInterruptBorder);
			if (lserr != lserrNone)
				return lserr;
			
			if (fInterruptBorder)
				{
				/* we should close border before allignment */
				lserr = CloseCurrentBorder(plsc);
				if (lserr != lserrNone)
					return lserr;
				}
			}
		else
			{
			/* we should close border before allignment */
			lserr = CloseCurrentBorder(plsc);
			if (lserr != lserrNone)
				return lserr;
			}
		}

	durUsed = GetCurrentUr(plsc) - urOriginal; 

	if (fWord95Model)
		{
		Assert(wchAdd != 0);
		Assert(fmtres == fmtrTab);

		AllignAutonum95(UrFromUa(LstflowFromSubline(GetCurrentSubline(plsc)),
							&(plsc->lsdocinf.lsdevres), duaSpaceAnm),
						UrFromUa(LstflowFromSubline(GetCurrentSubline(plsc)),
							&(plsc->lsdocinf.lsdevres), duaWidthAnm),
						lskalignAnm, durUsed, plsdnAllignmentTab,
						&durBefore, &durAfter);
		}
	else
		{
		lserr = AllignAutonum(&(plsc->lstabscontext), lskalignAnm, 
							(wchAdd != 0 && fmtres == fmtrTab),
					        plsdnAllignmentTab, GetCurrentUr(plsc), 
					        durUsed, &durBefore, &durAfter);
		if (lserr != lserrNone)
			return lserr;
		/* if there is no allignment after then durAfter should be zero */
		Assert(!((durAfter != 0) && (!(wchAdd != 0 && fmtres == fmtrTab))));
		}

	/* change geometry because of durBefore  */
	plsc->lsadjustcontext.urStartAutonumberingText = 
		plsc->lsadjustcontext.urLeftIndent + durBefore;
	AdvanceCurrentUr(plsc, durBefore);
	
	/* change geometry because of durAfter */
	AdvanceCurrentUr(plsc, durAfter);

	plsc->lsadjustcontext.urStartMainText = GetCurrentUr(plsc);

	/* restore cpLim   */
	SetCurrentCpLim(plsc, cpLimOriginal);
	
	return lserrNone;
}

#define iobjAutoDecimalTab		(idObjTextChp-1)

/* I N I T I A L I Z E  A U T O  D E C  T A B	 */
/*----------------------------------------------------------------------------
    %%Function: InitializeAutoDecTab
    %%Contact: igorzv
Parameters:
	plsc				-	(IN) ptr to line services context
	durAutoDecimalTab	-	(IN) auto decimal tab offset 

    Creates tab stop record and dnode for "auto-decimal tab"
----------------------------------------------------------------------------*/


LSERR InitializeAutoDecTab(PLSC plsc, long durAutoDecimalTab) 

	{
	PLSDNODE plsdnTab;
	LSERR lserr;
	LSKTAB lsktab;
	BOOL fBreakThroughTab;
	LSCP cpLimOriginal;
	
	if (durAutoDecimalTab > GetCurrentUr(plsc))  
		{
		cpLimOriginal = GetCurrentCpLim(plsc);
		SetCurrentCpLim(plsc, LONG_MIN + 1); 

		lserr = InitTabsContextForAutoDecimalTab(&plsc->lstabscontext, durAutoDecimalTab);
		if (lserr != lserrNone)
			return lserrNone;

		CreateDnode(plsc, plsdnTab);  

		*(GetWhereToPutLink(plsc, plsdnTab->plsdnPrev)) = plsdnTab;
		SetCurrentDnode(plsc, plsdnTab); 

		/* fill in this dnode */
		memset(&plsdnTab->u.real.objdim, 0, sizeof(OBJDIM));
		memset(&plsdnTab->u.real.lschp, 0, sizeof(LSCHP));
		plsdnTab->u.real.lschp.idObj = (WORD) IobjTextFromLsc(&plsc->lsiobjcontext);
		plsdnTab->fTab = fTrue;
		plsdnTab->fAutoDecTab = fTrue;
		plsdnTab->cpLimOriginal = cpLimOriginal; /* it's important to display to put correct value here */
		plsdnTab->dcp = 0;

		/* If PrepareLineToDisplay is not called, this dnode will not convert to pen and will destroyed
		   as real dnode. So we need to put NULL to plsrun, pdobj, pinfosubl*/
		plsdnTab->u.real.plsrun = NULL;
		plsdnTab->u.real.pdobj = NULL;
		plsdnTab->u.real.pinfosubl = NULL;

		lserr = GetCurTabInfoCore(&plsc->lstabscontext, plsdnTab, GetCurrentUr(plsc),
								  fFalse, &lsktab, &fBreakThroughTab);			
		if (lserr != lserrNone)
			return lserr;

		TurnOnTabEncounted(plsc);
		if (lsktab != lsktLeft)
			TurnOnNonLeftTabEncounted(plsc);

		/* restore cpLim   */
		SetCurrentCpLim(plsc, cpLimOriginal);

		TurnOnAutodecimalTabPresent(plsc);	
		}
	return lserrNone;
	}

/* H A N D L E  T A B	 */
/*----------------------------------------------------------------------------
    %%Function: HandleTab
    %%Contact: igorzv
Parameters:
	plsc				-	(IN) ptr to line services context

    Wraper around calls to tabutils module.
----------------------------------------------------------------------------*/

LSERR HandleTab(PLSC plsc)	
{
	LSKTAB lsktab; 
	LSERR lserr;
	BOOL fBreakThroughTab;
	long durPendingTab;
	long urNewMargin;

	/* if we are not on a stage of a formatting this procedure resolve previous tab if any */

	/* before tab calculation we should resolve pending tab */
	lserr = ResolvePrevTabCore(&plsc->lstabscontext, GetCurrentDnode(plsc),
							  GetCurrentUr(plsc), &durPendingTab);
	if (lserr != lserrNone) 
		return lserr;
	/* move current pen position */
	Assert(durPendingTab >= 0);
	AdvanceCurrentUr(plsc, durPendingTab);

	if (FFormattingAllowed(plsc))
		{
		/* in this case we are called only after tab */
		Assert(GetCurrentDnode(plsc)->fTab);
		lserr = GetCurTabInfoCore(&plsc->lstabscontext, GetCurrentDnode(plsc), GetCurrentUr(plsc),
			fFalse, &lsktab, &fBreakThroughTab);			
		if (lserr != lserrNone)
			return lserr;

		TurnOnTabEncounted(plsc);
		if (lsktab != lsktLeft)
			TurnOnNonLeftTabEncounted(plsc);

		/* move current pen position */
		AdvanceCurrentUr(plsc, DurFromDnode(GetCurrentDnode(plsc)));

		if (fBreakThroughTab)
			{
			lserr = GetMarginAfterBreakThroughTab(&plsc->lstabscontext, GetCurrentDnode(plsc),
												  &urNewMargin);
			if (lserr != lserrNone)
				return lserr;
			
			SetBreakthroughLine(plsc, urNewMargin);
			}
		}
	return lserrNone;
}

#define idObjSplat		idObjTextChp - 2

/* H A N D L E  S P L A T */
/*----------------------------------------------------------------------------
    %%Function: HandleSplat
    %%Contact: igorzv
Parameters:
	plsc				-	(IN) ptr to line services context
	pfmtres				-	(OUT) fmtres of the splat dnode, procedure can change it
							in the case of fIgnoreSplatBreak to either fmtrCompletedRun 
							or fmtrStopped

    Markes dnode for splat, deletes it in a case of fIgnoreSplatBreak
----------------------------------------------------------------------------*/

LSERR HandleSplat(PLSC plsc, FMTRES* pfmtres)	
	{
	PLSDNODE plsdn;
	LSCP cpAfterSplat;
	BOOL fQuit;
	LSERR lserr;

	plsdn = GetCurrentDnode(plsc);
	cpAfterSplat = GetCurrentCpLim(plsc);

	if (plsc->fIgnoreSplatBreak)
		{
		lserr = CheckNewPara(plsc, cpAfterSplat - 1, cpAfterSplat, &fQuit);
		if (lserr != lserrNone)
			return lserr;
		
		if (fQuit)
			{
			/* despite plsc->fIgnoreSplatBreak we should stop formatting here */
			*pfmtres = fmtrStopped;
			}
		else
			{
			*pfmtres = fmtrCompletedRun;
			}
		
		/* delete splat dnode */
		/* break link   */
		*(GetWhereToPutLink(plsc, plsdn->plsdnPrev)) = NULL;
		
		/* restore current dnode, don't change cpLim and geometry */
		SetCurrentDnode(plsc, plsdn->plsdnPrev);
		
		Assert(plsdn->plsdnNext == NULL);
		lserr =	DestroyDnodeList (&plsc->lscbk, plsc->pols, &plsc->lsiobjcontext, 
			plsdn, plsc->fDontReleaseRuns);
		if (lserr != lserrNone)
			return lserr;
		
		
		}
	else
		{
		
		/* set special idobj that will solve all chunk group chunk problems */
		Assert(FIsDnodeReal(plsdn));
		plsdn->u.real.lschp.idObj = idObjSplat;
		TurnOffAllSimpleText(plsc);  /* not simple text */
		
		}

	return lserrNone;
	}

/* C R E A T E  S U B L I N E  C O R E	 */
/*----------------------------------------------------------------------------
    %%Function: CreateSublineCore
    %%Contact: igorzv
Parameters:
	plsc		-	(IN) ptr to line services context
	cpFirst		-	(IN) first cp of a subline
	urColumnMax	-	(IN) max possible width of a subline
	lstflow		-	(IN) text flow of a subline
	fContiguos	-	(IN) if TRUE such line has the same coordinate system as main line
						 and is allowed to have tabs

    Allocates, initializes subline structure. Sets subline as current.
----------------------------------------------------------------------------*/

LSERR 	CreateSublineCore(PLSC plsc, LSCP cpFirst, long urColumnMax,
						  LSTFLOW lstflow, BOOL fContiguous)
	{
	PLSSUBL plssubl;
	LSERR lserr;

	Assert(FIsLSC(plsc));
	Assert(FFormattingAllowed(plsc) || FBreakingAllowed(plsc));
	Assert(GetCurrentSubline(plsc) == NULL); 

	plssubl = plsc->lscbk.pfnNewPtr(plsc->pols,
											sizeof(LSSUBL));
	if (plssubl == NULL)
		return lserrOutOfMemory;

	/* fill in structure */
	plssubl->tag = tagLSSUBL;
	plssubl->plsc = plsc;
	plssubl->cpFirst = cpFirst;
	plssubl->lstflow = lstflow;
	plssubl->urColumnMax = urColumnMax;
	plssubl->cpLim = cpFirst;
	plssubl->plsdnFirst = NULL;
	plssubl->plsdnLast = NULL;
	plssubl->fMain = fFalse;
	plssubl->plsdnUpTemp = NULL;
	plssubl->fAcceptedForDisplay = fFalse;
	plssubl->fRightMarginExceeded = fFalse;

	if (fContiguous)
		{
		Assert(FFormattingAllowed(plsc));
		Assert(SublineFromDnode(GetDnodeToFinish(plsc))->fContiguous);
		plssubl->urCur = GetCurrentUrSubl(SublineFromDnode(GetDnodeToFinish(plsc)));
		plssubl->vrCur = GetCurrentVrSubl(SublineFromDnode(GetDnodeToFinish(plsc)));
		}
	else
		{
		plssubl->urCur = 0;
		plssubl->vrCur = 0;
		}
	plssubl->fContiguous = (BYTE) fContiguous;
	plssubl->fDupInvalid = fTrue;

	plssubl->plschunkcontext = plsc->lscbk.pfnNewPtr(plsc->pols,
											sizeof(LSCHUNKCONTEXT));
	if (plssubl->plschunkcontext == NULL)
		return lserrOutOfMemory;

	lserr = AllocChunkArrays(plssubl->plschunkcontext, &plsc->lscbk, plsc->pols,
							 &plsc->lsiobjcontext);
	if (lserr != lserrNone)
		return lserr;
	
	InitSublineChunkContext(plssubl->plschunkcontext, plssubl->urCur, plssubl->vrCur);

	/* allocate break context */
	plssubl->pbrkcontext = plsc->lscbk.pfnNewPtr(plsc->pols,
											sizeof(BRKCONTEXT));
	if (plssubl->pbrkcontext == NULL)
		return lserrOutOfMemory;
	/* set flags */
	plssubl->pbrkcontext->fBreakPrevValid = fFalse;
	plssubl->pbrkcontext->fBreakNextValid = fFalse;
	plssubl->pbrkcontext->fBreakForceValid = fFalse;


	/* set this subline as current */
	SetCurrentSubline(plsc, plssubl);

	IncreaseFormatDepth(plsc);

	return lserrNone;
	}


/* F I N I S H  S U B L I N E  C O R E	 */
/*----------------------------------------------------------------------------
    %%Function: FinishSublineCore
    %%Contact: igorzv
Parameters:
	plssubl		-	(IN) subline to finish

    Applies nominal to ideal to the last chunk of text, flushes current subline
----------------------------------------------------------------------------*/


LSERR   FinishSublineCore(
						 PLSSUBL plssubl)			/* IN: subline to finish	*/
	{
	PLSC plsc;
	LSERR lserr;
	PLSDNODE plsdn;

	Assert(FIsLSSUBL(plssubl));

	plsc = plssubl->plsc;
	Assert(plssubl == GetCurrentSubline(plsc));

	/* apply nominal to ideal to the last chunk of text */
	if (FNominalToIdealEncounted(plsc))
		{
		lserr = ApplyNominalToIdeal(PlschunkcontextFromSubline(plssubl), &plsc->lsiobjcontext,
								plsc->grpfManager, plsc->lsadjustcontext.lskj,
								FIsSubLineMain(plssubl), FLineContainsAutoNumber(plsc),
								GetCurrentDnodeSubl(plssubl));
		if (lserr != lserrNone)
			return lserr; 
		}

	/* skip back pen dnodes */
	plsdn = plssubl->plsdnLast;
	while (plsdn != NULL && FIsDnodePen(plsdn)) 
		{
		plsdn = plsdn->plsdnPrev;
		}

	/* close last border */
	if (FDnodeHasBorder(plsdn) && !FIsDnodeCloseBorder(plsdn))
		{
		lserr = CloseCurrentBorder(plsc);
		if (lserr != lserrNone)
			return lserr;
		}

	/* set boundaries for display */
	SetCpLimDisplaySubl(plssubl, GetCurrentCpLimSubl(plssubl));
	SetLastDnodeDisplaySubl(plssubl, GetCurrentDnodeSubl(plssubl));


	/* flush current subline */
	SetCurrentSubline(plsc, NULL);

	DecreaseFormatDepth(plsc); 

	lserr = LsSublineFinishedText(PlnobjFromLsc(plsc, IobjTextFromLsc(&((plsc)->lsiobjcontext))));
	if (lserr != lserrNone)
		return lserr;

	return lserrNone;
	}

/* U N D O  L A S T  D N O D E	 */
/*----------------------------------------------------------------------------
    %%Function: UndoLastDnode
    %%Contact: igorzv
Parameters:
	plsc		-	(IN) ptr to line services context

    Restores set before last dnode and deletes it.
----------------------------------------------------------------------------*/

static LSERR 	UndoLastDnode(PLSC plsc)
{
	PLSDNODE plsdn = GetCurrentDnode(plsc);
	long cpDecrease;
	
	Assert(FIsLSDNODE(plsdn));

	/* break link   */
	*(GetWhereToPutLink(plsc, plsdn->plsdnPrev)) = NULL;

	/* restore state */
	cpDecrease = plsdn->dcp;
	AdvanceCurrentCpLim(plsc, -cpDecrease);
	SetCurrentDnode(plsc, plsdn->plsdnPrev);
	AdvanceCurrentUr(plsc, -DurFromDnode(plsdn)); 
	AdvanceCurrentVr(plsc, -DvrFromDnode(plsdn)); 

	Assert(plsdn->plsdnNext == NULL);
	return 	DestroyDnodeList (&plsc->lscbk, plsc->pols, &plsc->lsiobjcontext, 
				plsdn, plsc->fDontReleaseRuns);


}

/* O P E N  B O R D E R	 */
/*----------------------------------------------------------------------------
    %%Function: OpenBorder
    %%Contact: igorzv
Parameters:
	plsc		-	(IN) ptr to line services context
	plsrun		-	(IN) run with border information

    Creates border dnode
----------------------------------------------------------------------------*/
static LSERR  OpenBorder(PLSC plsc, PLSRUN plsrun)
	{
	PLSDNODE plsdnCurrent;
	PLSDNODE* pplsdnToStoreNext;
	long durBorder, dupBorder;
	PLSDNODE plsdnBorder;
	LSERR lserr;

	plsdnCurrent = GetCurrentDnode(plsc);
	pplsdnToStoreNext = GetWhereToPutLink(plsc, plsdnCurrent);

	lserr = plsc->lscbk.pfnGetBorderInfo(plsc->pols, plsrun, GetCurrentLstflow(plsc),
		&durBorder, &dupBorder);
	if (lserr != lserrNone)
		return lserr;


	CreateBorderDnode(plsc, plsdnBorder, durBorder, dupBorder);
	plsdnBorder->fOpenBorder = fTrue;
	
	/* maintain list and state */
	*pplsdnToStoreNext = plsdnBorder;
	SetCurrentDnode(plsc, plsdnBorder);
	AdvanceCurrentUr(plsc, durBorder);
	TurnOffAllSimpleText(plsc);  /* not simple text */

	return lserrNone;
	}

/* C L O S E  C U R R E N T  B O R D E R	 */
/*----------------------------------------------------------------------------
    %%Function: CloseCurrentBorder
    %%Contact: igorzv
Parameters:
	plsc		-	(IN) ptr to line services context

    Creates border dnode
----------------------------------------------------------------------------*/
LSERR  CloseCurrentBorder(PLSC plsc)
	{
	PLSDNODE plsdnCurrent;
	PLSDNODE* pplsdnToStoreNext;
	long durBorder, dupBorder;
	PLSDNODE plsdnBorder;
	LSERR lserr;
	PLSDNODE plsdn;

	plsdnCurrent = GetCurrentDnode(plsc);
	pplsdnToStoreNext = GetWhereToPutLink(plsc, plsdnCurrent);

	/* find open border */
	plsdn = plsdnCurrent;
	Assert(FIsLSDNODE(plsdn));
	while (! FIsDnodeBorder(plsdn))
		{
		plsdn = plsdn->plsdnPrev;
		Assert(FIsLSDNODE(plsdn));
		}
	Assert(plsdn->fOpenBorder);

	if (plsdn != plsdnCurrent)
		{
		durBorder = plsdn->u.pen.dur;
		dupBorder = plsdn->u.pen.dup;

		CreateBorderDnode(plsc, plsdnBorder, durBorder, dupBorder);
	
		/* maintain list and state */
		*pplsdnToStoreNext = plsdnBorder;
		SetCurrentDnode(plsc, plsdnBorder);
		AdvanceCurrentUr(plsc, durBorder);
		}
	else
		{
		/* we have empty list between borders */
		lserr = UndoLastDnode(plsc);
		if (lserr != lserrNone)
			return lserrNone;
		}

	return lserrNone;
	}

long RightMarginIncreasing(PLSC plsc, long urColumnMax) 
	{
	long Coeff = plsc->lMarginIncreaseCoefficient;
	long urInch;
	long One32rd;
		if (urColumnMax <= 0) 
			{ 
			/* such strange formula for non positive margin is to have on 
			the first iteration 1 inch and 8 inches 	on the second*/
			urInch = UrFromUa(LstflowFromSubline(GetCurrentSubline(plsc)), 
								&(plsc)->lsdocinf.lsdevres,	1440);
			if (Coeff == uLsInfiniteRM || (Coeff >= uLsInfiniteRM / (7 * urInch)))
				return uLsInfiniteRM;
			else
				return (7*Coeff - 6)* urInch; 
			}
		else
			{
			if (urColumnMax <= 32)
				One32rd = 1;
			else
				One32rd = urColumnMax >> 5;
			
			if (Coeff == uLsInfiniteRM || (Coeff >= (uLsInfiniteRM - urColumnMax)/One32rd))
				return uLsInfiniteRM;
			else
				return urColumnMax + (Coeff * One32rd); 
			}
	}

/*----------------------------------------------------------------------------
/* E R R  R E L E A S E  R U N  T O  F O R M A T */
/*----------------------------------------------------------------------------
    %%Function: ErrReleaseRunToFormat
    %%Contact: igorzv
Parameters:
	plsc		-	(IN) ptr to line services context 
	plsrun		-	(IN) ponter to a run structure to be deleted	
	lserr		-	(IN) code of an error	

	Called in a error situation when run has not been formatted yet .
----------------------------------------------------------------------------*/
static LSERR ErrReleaseRunToFormat(PLSC plsc, PLSRUN plsrun, LSERR lserr) 
{
	LSERR lserrIgnore;

	if (!plsc->fDontReleaseRuns)
			lserrIgnore = plsc->lscbk.pfnReleaseRun(plsc->pols, plsrun);

	return lserr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\lsqcore.c ===
#include "lsqcore.h"
#include "lsc.h"
#include "lsqsinfo.h"
#include "lsdnode.h"
#include "lssubl.h"
#include "heights.h"
#include "lschp.h"
#include "iobj.h"
#include "lsqin.h"
#include "lsqout.h"
#include "dninfo.h"
#include "lssubset.h"
#include "lstfset.h"
#include "dispmisc.h"


#define FIsInContent(pdn)			(!FIsNotInContent(pdn))
#define FIsZeroWidth(pdn)			(FIsDnodeReal(pdn) && (pdn)->u.real.dup == 0)
#define	FIsDnodeClosingBorder(pdn)  (FIsDnodeBorder(pdn) && (!(pdn)->fOpenBorder))


static void PrepareQueryCall(PLSSUBL, PLSDNODE, LSQIN*);
static LSERR FillInQueryResults(PLSC, PLSSUBL, PLSQSUBINFO, PLSDNODE, POINTUV*, LSQOUT*);
static void FillInTextCellInfo(PLSC, PLSDNODE, POINTUV*, LSQOUT*, PLSTEXTCELL);
static void TransformPointsOnLowerLevels(PLSQSUBINFO, DWORD, PLSTEXTCELL, PPOINTUV, LSTFLOW, LSTFLOW);
static void ApplyFormula(PPOINTUV, DWORD[], PPOINTUV);

static PLSDNODE BacktrackToPreviousDnode(PLSDNODE pdn, POINTUV* pt);
static PLSDNODE AdvanceToNextDnodeQuery(PLSDNODE, PPOINTUV);


//    %%Function:	QuerySublineCpPpointCore
//    %%Contact:	victork
//
/*
 *		Returns dim-info of the cp in the subline.
 *
 *		If that cp isn't displayed in the line, take closest to the left that is displayed.
 *		If that's impossible, go to the right.
 *
 *		Hidden text inside ligature makes it impossible to tell whether a particular cp is hidden or not
 */

LSERR QuerySublineCpPpointCore(
								PLSSUBL 	plssubl, 	
								LSCP 		cp,					/* IN: cpQuery */
								DWORD		cDepthQueryMax,		/* IN: allocated size of results array */
								PLSQSUBINFO	plsqsubinfoResults,	/* OUT: array[cDepthQueryMax] of results */
								DWORD*		pcActualDepth,		/* OUT: size of results array (filled) */
								PLSTEXTCELL	plstextcell)		/* OUT: Text cell info */


{
	PLSC		plsc;
	LSERR 		lserr = lserrNone;
	PLSDNODE 	pdn, pdnPrev = NULL;
	POINTUV		pt;
	LSCP 		cpLim;
	
	LSQIN		lsqin;
	LSQOUT		lsqout;

	PLSSUBL 	plssublLowerLevels; 	
	POINTUV		ptStartLowerLevels;
	PLSQSUBINFO	plsqsubinfoLowerLevels;
	DWORD		cDepthQueryMaxLowerLevels;
	DWORD		cActualDepthLowerLevels;

	Assert(FIsLSSUBL(plssubl));
	Assert(!plssubl->fDupInvalid);
	
	if (cDepthQueryMax == 0)
		{
		return lserrInsufficientQueryDepth;
		}

	plsc = plssubl->plsc;
	cpLim = plssubl->cpLimDisplay;

	pt.u = 0;
	pt.v = 0;
	pdn = plssubl->plsdnFirst;

	/* Skip over autonumbers & starting pens/borders */
	while (FDnodeBeforeCpLim(pdn, cpLim) && (FIsNotInContent(pdn) || !(FIsDnodeReal(pdn))))
		{
		pdn = AdvanceToNextDnodeQuery(pdn, &pt);
		}

	if (!FDnodeBeforeCpLim(pdn, cpLim))
		{												/* empty subline */
		*pcActualDepth = 0;
		return lserrNone;
		}

	// if cp <= pdn->cpFirst, pdn is the dnode to query, else...
	
	if (cp > pdn->cpFirst)
		{
		/* Skip dnodes before the cp */
		while (FDnodeBeforeCpLim(pdn, cpLim) && pdn->cpFirst + pdn->dcp <= (LSDCP)cp)
			{
			pdnPrev = pdn;
			pdn = AdvanceToNextDnodeQuery(pdn, &pt);
			}

		/* go back if our cp is in vanished text or pen or border */
	 	if (!FDnodeBeforeCpLim(pdn, cpLim) || 					// reached the end
	 				pdn->cpFirst > cp ||						// went too far because of hidden text
	 				!(FIsDnodeReal(pdn)))						// our cp points to a pen
			{	
			Assert(pdnPrev != NULL);							// we made at least one forward step
			pdn = pdnPrev;	
			pdnPrev = BacktrackToPreviousDnode(pdnPrev, &pt);

			// skip all pens/borders
			while (pdn != NULL && FIsInContent(pdn) && !(FIsDnodeReal(pdn)))
				{
				pdn = pdnPrev;	
				pdnPrev = BacktrackToPreviousDnode(pdnPrev, &pt);	
				}
				
			// nothing good to the left situation is impossible
			Assert(pdn != NULL && !FIsNotInContent(pdn));
			}		
		}
		
	/* we've found the dnode, have pt just before it, ask method for details */

	if (cp >= (LSCP) (pdn->cpFirst + pdn->dcp))				/* cp in next vanished piece */
		cp = pdn->cpFirst + pdn->dcp - 1;					/* query last cp */

	if (cp < (LSCP) pdn->cpFirst)							/* cp in a previous pen */
		cp = pdn->cpFirst;									/* query first  cp */

	pt.v += pdn->u.real.lschp.dvpPos;						// go to the local baseline
	
	PrepareQueryCall(plssubl, pdn, &lsqin);
	
	lserr = (*plsc->lsiobjcontext.rgobj[pdn->u.real.lschp.idObj].lsim.pfnQueryCpPpoint)
							(pdn->u.real.pdobj, cp - pdn->cpFirst, &lsqin, &lsqout);
	if (lserr != lserrNone)
			 return lserr;

	lserr = FillInQueryResults(plsc, plssubl, plsqsubinfoResults, pdn, &pt, &lsqout);
	
	if (lserr != lserrNone)
			 return lserr;

	if (lsqout.plssubl == NULL)						// terminal object
		{
		*pcActualDepth = 1;

		FillInTextCellInfo(plsc, pdn, &pt, &lsqout, plstextcell);
		}
	else											// there are more level(s)
		{
		// recursive call to fill lower levels
		plssublLowerLevels = lsqout.plssubl;
		plsqsubinfoLowerLevels = plsqsubinfoResults + 1;
		cDepthQueryMaxLowerLevels = cDepthQueryMax - 1;
		
		lserr = QuerySublineCpPpointCore(plssublLowerLevels, cp, cDepthQueryMaxLowerLevels, 
										plsqsubinfoLowerLevels, &cActualDepthLowerLevels, plstextcell);		
		if (lserr != lserrNone)
				 return lserr;
				 
		*pcActualDepth = cActualDepthLowerLevels + 1;

		ptStartLowerLevels.u = pt.u + lsqout.pointUvStartSubline.u;
		ptStartLowerLevels.v = pt.v + lsqout.pointUvStartSubline.v;

		TransformPointsOnLowerLevels(plsqsubinfoLowerLevels, cActualDepthLowerLevels, plstextcell, 
								 &ptStartLowerLevels, plssubl->lstflow, plssublLowerLevels->lstflow);
		}
		
	return lserrNone;
}


//    %%Function:	QuerySublinePointPcpCore
//    %%Contact:	victork
//
/*
 *		Returns dim-info of the cp in the line, that a) contains given point or
 *													 b) is closest to it from the left or
 *													 c) is just closest to it
 */
 
LSERR QuerySublinePointPcpCore(
								PLSSUBL 	plssubl, 
								PCPOINTUV 	pptIn,
								DWORD		cDepthQueryMax,		/* IN: allocated size of results array */
								PLSQSUBINFO	plsqsubinfoResults,	/* OUT: array[cDepthQueryMax] of results */
								DWORD*		pcActualDepth,		/* OUT: size of results array (filled) */
								PLSTEXTCELL	plstextcell)		/* OUT: Text cell info */
{
	PLSC		plsc;
	LSERR 		lserr = lserrNone;
	PLSDNODE 	pdn, pdnPrev = NULL;
	POINTUV		pt, ptInside, ptInsideLocal;
	LSCP 		cpLim;
	
	LSQIN		lsqin;
	LSQOUT		lsqout;

	PLSSUBL 	plssublLowerLevels; 	
	POINTUV		ptStartLowerLevels;
	PLSQSUBINFO	plsqsubinfoLowerLevels;
	DWORD		cDepthQueryMaxLowerLevels;
	DWORD		cActualDepthLowerLevels;
	long		upQuery;

	Assert(FIsLSSUBL(plssubl));
	Assert(!plssubl->fDupInvalid);
	
	if (cDepthQueryMax == 0)
		{
		return lserrInsufficientQueryDepth;
		}
	
	plsc = plssubl->plsc;
	cpLim = plssubl->cpLimDisplay;
	
	pt.u = 0;
	pt.v = 0;
	pdn = plssubl->plsdnFirst;

	/* Skip over autonumbers & starting pens & empty dnodes */
	while (FDnodeBeforeCpLim(pdn, cpLim) && (FIsNotInContent(pdn) || !(FIsDnodeReal(pdn)) || FIsZeroWidth(pdn)))
		{
		pdn = AdvanceToNextDnodeQuery(pdn, &pt);
		}

	if (!FDnodeBeforeCpLim(pdn, cpLim))
		{												/* empty subline */
		*pcActualDepth = 0;
		return lserrNone;
		}

	upQuery = pptIn->u;
	
	/* 
	 *	Find dnode with our point inside.
	 *
	 *	We look only at upQuery to do it.
	 */

	// if pt.u >= upQuery, pdn is the dnode to query, else...
	
 	if (pt.u <= upQuery)
 		{
		// skip until the end or dnode to the right of our point
		//	(That means extra work, but covers zero dup situation without additional if.)
			
		while (FDnodeBeforeCpLim(pdn, cpLim) && pt.u <= upQuery)
			{
			pdnPrev = pdn;
			pdn = AdvanceToNextDnodeQuery(pdn, &pt);
			}

		if (FIsDnodeBorder(pdnPrev))
			{
			if (pdnPrev->fOpenBorder)
				{
				// upQuery was in the previous opening border - pdn is the dnode we need
				
				Assert(FDnodeBeforeCpLim(pdn, cpLim));
				}
			else
				{
				// upQuery was in the previous closing border - dnode we need is before the border
				
				pdn = pdnPrev;	
				Assert(pdn != NULL && !FIsNotInContent(pdn));
				
				pdnPrev = BacktrackToPreviousDnode(pdnPrev, &pt);

				pdn = pdnPrev;	
				Assert(pdn != NULL && !FIsNotInContent(pdn));
				
				pdnPrev = BacktrackToPreviousDnode(pdnPrev, &pt);
				}
			}
		else
			{
			/* go back to the previous dnode */
			
			pdn = pdnPrev;	
			pdnPrev = BacktrackToPreviousDnode(pdnPrev, &pt);

			// if it is a pen/border or empty dnode (non-req hyphen), skip them all
			// (Border cannot be the previous dnode, but is possble later)
			
			while (pdn != NULL && (!(FIsDnodeReal(pdn)) || FIsZeroWidth(pdn)))
				{
				pdn = pdnPrev;	
				pdnPrev = BacktrackToPreviousDnode(pdnPrev, &pt);	
				}
				
			// "nothing good to the left" situation is impossible
			Assert(pdn != NULL && !FIsNotInContent(pdn));
			}
 		}
		
	// We have found the leftmost dnode with our dup to the right of it
	// pt is just before it, ask method for details
	
	pt.v += pdn->u.real.lschp.dvpPos;						// go to the local baseline

	PrepareQueryCall(plssubl, pdn, &lsqin);
	
	// get query point relative to the starting point of the dnode
	// we give no guarantee that it is really inside dnode box
	ptInside.u = pptIn->u - pt.u;
	ptInside.v = pptIn->v - pt.v;

	lserr = (*plsc->lsiobjcontext.rgobj[pdn->u.real.lschp.idObj].lsim.pfnQueryPointPcp)
							(pdn->u.real.pdobj, &ptInside, &lsqin, &lsqout);								 
	if (lserr != lserrNone)
			 return lserr;
			 
	lserr = FillInQueryResults(plsc, plssubl, plsqsubinfoResults, pdn, &pt, &lsqout);
	
	if (lserr != lserrNone)
			 return lserr;

	if (lsqout.plssubl == NULL)						// terminal object
		{
		*pcActualDepth = 1;

		FillInTextCellInfo(plsc, pdn, &pt, &lsqout, plstextcell);
		}
	else											// there are more level(s)
		{
		// recursive call to fill lower levels
		plssublLowerLevels = lsqout.plssubl;
		plsqsubinfoLowerLevels = plsqsubinfoResults + 1;
		cDepthQueryMaxLowerLevels = cDepthQueryMax - 1;
		
		// get query point in lower level subline coordinate system

		lserr = LsPointUV2FromPointUV1(plssubl->lstflow, &(lsqout.pointUvStartSubline), &ptInside,			/* IN: end input point (TF1) */
											plssublLowerLevels->lstflow, &ptInsideLocal);
		if (lserr != lserrNone)
				 return lserr;

		lserr = QuerySublinePointPcpCore(plssublLowerLevels, &ptInsideLocal, cDepthQueryMaxLowerLevels, 
										plsqsubinfoLowerLevels, &cActualDepthLowerLevels, plstextcell);		
		if (lserr != lserrNone)
				 return lserr;
				 
		*pcActualDepth = cActualDepthLowerLevels + 1;

		ptStartLowerLevels.u = pt.u + lsqout.pointUvStartSubline.u;
		ptStartLowerLevels.v = pt.v + lsqout.pointUvStartSubline.v;

		TransformPointsOnLowerLevels(plsqsubinfoLowerLevels, cActualDepthLowerLevels, plstextcell, 
								 &ptStartLowerLevels, plssubl->lstflow, plssublLowerLevels->lstflow);
		}

	return lserrNone;
}


//    %%Function:	PrepareQueryCall
//    %%Contact:	victork
//
static void PrepareQueryCall(PLSSUBL plssubl, PLSDNODE pdn, LSQIN*	plsqin)
{
	plsqin->lstflowSubline = plssubl->lstflow;
	plsqin->plsrun = pdn->u.real.plsrun;
	plsqin->cpFirstRun = pdn->cpFirst;
	plsqin->dcpRun = pdn->dcp;
	plsqin->heightsPresRun = pdn->u.real.objdim.heightsPres;
	plsqin->dupRun = pdn->u.real.dup;
	plsqin->dvpPosRun = pdn->u.real.lschp.dvpPos;
}


//    %%Function:	FillInQueryResults
//    %%Contact:	victork
//
static LSERR FillInQueryResults(
								PLSC		plsc,
								PLSSUBL 	plssubl, 
								PLSQSUBINFO	plsqsubinfoResults,
								PLSDNODE 	pdn,
								POINTUV* 	ppt,
								LSQOUT*		plsqout
								)
{							
	OBJDIM		objdimSubline;
	LSERR		lserr;
	PLSDNODE	pdnNext, pdnPrev;
	
	// fill in subline info
	
	lserr = LssbGetObjDimSubline(plssubl, &(plsqsubinfoResults->lstflowSubline), &objdimSubline);
	if (lserr != lserrNone)
			 return lserr;

	lserr = LssbGetDupSubline(plssubl, &(plsqsubinfoResults->lstflowSubline), &plsqsubinfoResults->dupSubline);
	if (lserr != lserrNone)
			 return lserr;

	plsqsubinfoResults->cpFirstSubline = plssubl->cpFirst;
	plsqsubinfoResults->dcpSubline = plssubl->cpLimDisplay - plssubl->cpFirst;
	plsqsubinfoResults->pointUvStartSubline.u = 0;
	plsqsubinfoResults->pointUvStartSubline.v = 0;

	plsqsubinfoResults->heightsPresSubline = objdimSubline.heightsPres;

	// fill in dnode info
	
	if (IdObjFromDnode(pdn) == IobjTextFromLsc(&(plsc->lsiobjcontext)))
		plsqsubinfoResults->idobj = idObjText;
	else
		plsqsubinfoResults->idobj = pdn->u.real.lschp.idObj;

	plsqsubinfoResults->plsrun = pdn->u.real.plsrun;
	plsqsubinfoResults->cpFirstRun = pdn->cpFirst;
	plsqsubinfoResults->dcpRun = pdn->dcp;
	plsqsubinfoResults->pointUvStartRun = *ppt;							// local baseline
	plsqsubinfoResults->heightsPresRun = pdn->u.real.objdim.heightsPres;
	plsqsubinfoResults->dupRun = pdn->u.real.dup;
	plsqsubinfoResults->dvpPosRun = pdn->u.real.lschp.dvpPos;
	
	// fill in object info
	
	plsqsubinfoResults->pointUvStartObj.u = ppt->u + plsqout->pointUvStartObj.u;
	plsqsubinfoResults->pointUvStartObj.v = ppt->v + plsqout->pointUvStartObj.v;
	plsqsubinfoResults->heightsPresObj = plsqout->heightsPresObj;
	plsqsubinfoResults->dupObj = plsqout->dupObj;

	// add borders info
	
	plsqsubinfoResults->dupBorderAfter = 0;
	plsqsubinfoResults->dupBorderBefore = 0;

	if (pdn->u.real.lschp.fBorder)
		{
		pdnNext = pdn->plsdnNext;
		
		if (pdnNext != NULL && FIsDnodeClosingBorder(pdnNext))
			{
			plsqsubinfoResults->dupBorderAfter = pdnNext->u.pen.dup;
			}

		pdnPrev = pdn->plsdnPrev;
		
		if (pdnPrev != NULL && FIsDnodeOpenBorder(pdnPrev))
			{
			Assert(FIsInContent(pdnPrev));
			
			plsqsubinfoResults->dupBorderBefore = pdnPrev->u.pen.dup;
			}
		}

	return lserrNone;
}


//    %%Function:	FillInTextCellInfo
//    %%Contact:	victork
//
static void FillInTextCellInfo(
								PLSC		plsc,
								PLSDNODE 	pdn,
								POINTUV* 	ppt,
								LSQOUT*		plsqout,
								PLSTEXTCELL	plstextcell		/* OUT: Text cell info */
								)
{		
	if (IdObjFromDnode(pdn) == IobjTextFromLsc(&(plsc->lsiobjcontext)))
		{
		// text has cell info filled - copy it
		
		*plstextcell = plsqout->lstextcell;

		// but starting point is relative to the begining of dnode - adjust to that of subline

		plstextcell->pointUvStartCell.u += ppt->u;
		plstextcell->pointUvStartCell.v += ppt->v;

		// adjust cpEndCell if some hidden text got into last ligature - text is unaware of the issue
		
		if (pdn->cpFirst + pdn->dcp < (LSDCP) pdn->cpLimOriginal &&
			(LSDCP) plstextcell->cpEndCell == pdn->cpFirst + pdn->dcp - 1)
			{
			plstextcell->cpEndCell = pdn->cpLimOriginal - 1;
			}

		// pointer to the dnode to get details quickly - only query manager knows what PCELLDETAILS is
		
		plstextcell->pCellDetails = (PCELLDETAILS)pdn;
		}
	else
		{
		// non-text object should not fill lstxtcell, client should not look into it
		// I fill it with object information for debug purposes
		// Consider zapping it in lsqline later (Rick's suggestion)
		
		plstextcell->cpStartCell = pdn->cpFirst;
		plstextcell->cpEndCell = pdn->cpFirst + pdn->dcp - 1;
	 	plstextcell->pointUvStartCell = *ppt;
		plstextcell->dupCell = pdn->u.real.dup;
		plstextcell->cCharsInCell = 0;
		plstextcell->cGlyphsInCell = 0;
		plstextcell->pCellDetails = NULL;
		}
}


//    %%Function:	TransformPointsOnLowerLevels
//    %%Contact:	victork
//
// transform all vectors in results array from lstflow2 to lstflow1, adding pointuvStart (lstflow1)

static void TransformPointsOnLowerLevels(
								PLSQSUBINFO	plsqsubinfo,		/* IN/OUT: results array */		
								DWORD		cDepth,				/* IN: size of results array */
								PLSTEXTCELL	plstextcell,		// IN/OUT: text cell
								PPOINTUV	ppointuvStart,		// IN: in lstflow1
								LSTFLOW		lstflow1,			// IN: lstflow1
								LSTFLOW		lstflow2)			// IN: lstflow2

{
	// Have to apply formulas
	//		VectorOut.u = k11 * VectorIn.u + k12 * VectorIn.v + pointuvStart.u 
	//		VectorOut.v = k21 * VectorIn.u + k22 * VectorIn.v + pointuvStart.u 
	// to several vectors in results array (all elements in k matrix are zero or +/- 1)
	// Algorithm: find the matrix first, then use it

	DWORD	k[4];
	POINTUV	pointuv0, pointuv1, pointuv2;

	pointuv0.u = 0;
	pointuv0.v = 0;
	
	pointuv1.u = 1;
	pointuv1.v = 0;
	
	LsPointUV2FromPointUV1(lstflow2, &pointuv0, &pointuv1, lstflow1, &pointuv2);
	
	k[0] = pointuv2.u;			// k11
	k[1] = pointuv2.v;			// k21

	pointuv1.u = 0;
	pointuv1.v = 1;
	
	LsPointUV2FromPointUV1(lstflow2, &pointuv0, &pointuv1, lstflow1, &pointuv2);
	
	k[2] = pointuv2.u;			// k12
	k[3] = pointuv2.v;			// k22


	// all points in lower levels are in lstflowLowerLevels (lstflow2) with starting point at the 
	// beginning of the top lower levels subline
	// Translate them to lstflowTop (lstflow1) and starting point of our subline.
	
	while (cDepth > 0)
		{
		ApplyFormula(&(plsqsubinfo->pointUvStartSubline), k, ppointuvStart);
		ApplyFormula(&(plsqsubinfo->pointUvStartRun), k, ppointuvStart);
		ApplyFormula(&(plsqsubinfo->pointUvStartObj), k, ppointuvStart);
		plsqsubinfo++;
		cDepth--;
		}

	// StartCell point should be adjusted too
	ApplyFormula(&(plstextcell->pointUvStartCell), k, ppointuvStart);
		
}

//    %%Function:	ApplyFormula
//    %%Contact:	victork
//
static void ApplyFormula(PPOINTUV ppointuv, DWORD* rgk, PPOINTUV ppointuvStart)
{
	POINTUV	pointuvTemp;

	pointuvTemp.u = ppointuvStart->u + rgk[0] * ppointuv->u + rgk[2] * ppointuv->v;
	pointuvTemp.v = ppointuvStart->v + rgk[1] * ppointuv->u + rgk[3] * ppointuv->v;
	*ppointuv = pointuvTemp;
}

//    %%Function:	AdvanceToNextDnodeQuery
//    %%Contact:	victork
//
/* 
 *	Advance to the next node and update pen position (never goes into sublines)
 */

static PLSDNODE AdvanceToNextDnodeQuery(PLSDNODE pdn, POINTUV* ppt)
{

	if (pdn->klsdn == klsdnReal)
		{
		ppt->u += pdn->u.real.dup;										
		}
	else												/* 	case klsdnPen */
		{
		ppt->u += pdn->u.pen.dup;
		ppt->v += pdn->u.pen.dvp;
		}

	return pdn->plsdnNext;
}

//    %%Function:	BacktrackToPreviousDnode
//    %%Contact:	victork
//
// 	Backtrack and downdate pen position.
//	Both parameters are input/output
//	Input: dnode number N-1 and point at the beginning of the dnode number N
//	Output: point at the beginning of the dnode number N-1
//	Return: dnode number N-2

static PLSDNODE BacktrackToPreviousDnode(PLSDNODE pdn, POINTUV* ppt)
{

	if (FIsDnodeReal(pdn))
		{
		ppt->u -= pdn->u.real.dup;										
		}
	else												/* 	it's Pen */
		{
		ppt->u -=	pdn->u.pen.dup;
		ppt->v -= pdn->u.pen.dvp;
		}
	
	return pdn->plsdnPrev;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\lsqline.c ===
#include "lsqline.h"
#include "lsc.h"
#include "lsline.h"
#include "lslinfo.h"
#include "lsqsinfo.h"
#include "lsqcore.h"
#include "lstxtqry.h"
#include "lsqrycon.h"
#include "lsdnode.h"
#include "prepdisp.h"
#include "dispmisc.h"
#include "heights.h"
#include "lschp.h"
#include "dnutils.h"
#include "dninfo.h"
#include "iobj.h"
#include "zqfromza.h"
#include "lsdevice.h"

void AdjustForLeftIndent(PLSQSUBINFO, DWORD, PLSTEXTCELL, long);


#define FIsSplat(endr)	(endr == endrEndColumn 	|| 	\
						endr == endrEndSection 	|| 	\
						endr == endrEndPage)


//    %%Function:	LsQueryLineCpPpoint
//    %%Contact:	victork
//
/*
 *		Returns dim-info of the cp in the line.
 *
 *		If that cp isn't displayed in the line, take closest to the left that is displayed.
 *		If that's impossible, go to the right.
 */
LSERR WINAPI  LsQueryLineCpPpoint(
							PLSLINE 	plsline,
							LSCP		cpQuery,
							DWORD		cDepthQueryMax,			/* IN: allocated size of results array */
							PLSQSUBINFO	plsqsubinfoResults,		/* OUT: array[nDepthFormatMax] of query results */
							DWORD*		pcActualDepth,			/* OUT: size of results array (filled) */
							PLSTEXTCELL	plstextcell)			/* OUT: Text cell info */
{
	LSERR 	lserr;
	PLSSUBL	plssubl;
	PLSC	plsc;
	
	if (!FIsLSLINE(plsline)) return lserrInvalidLine;

	plssubl = &(plsline->lssubl);
	plsc = plssubl->plsc;
	Assert(FIsLSC(plsc));

	lserr = PrepareLineForDisplayProc(plsline);
	if (lserr != lserrNone)
		return lserr;

	/* cp of splat - we can return nothing sensible */
	
	if (cpQuery >= (plsline->lslinfo.cpLim)-1 && FIsSplat(plsline->lslinfo.endr))
		{
		*pcActualDepth = 0;
		return lserrNone;
		}
		
	if (plsc->lsstate == LsStateFree)
		{
		plsc->lsstate = LsStateQuerying;
		}
		
	lserr = QuerySublineCpPpointCore(plssubl, cpQuery, cDepthQueryMax, 
									plsqsubinfoResults, pcActualDepth, plstextcell);		
	
	if (lserr == lserrNone)
		{
		if (plsline->upStartAutonumberingText != 0)
			{
			AdjustForLeftIndent(plsqsubinfoResults, *pcActualDepth, plstextcell, plsline->upStartAutonumberingText);
			}

		if (plsqsubinfoResults->idobj == idObjNone)
			{												
			/* empty line - we can return nothing */
			*pcActualDepth = 0;
			}
		}
		
	if (plsc->lsstate == LsStateQuerying)
		{
		plsc->lsstate = LsStateFree;
		}

	return lserr;
}



//    %%Function:	LsQueryLinePointPcp
//    %%Contact:	victork
//
/*
 *		Returns dim-info of the cp in the line that contains given point.
 *
 *		If that dup isn't in the line, take closest that is instead.
 */
LSERR WINAPI  LsQueryLinePointPcp(
							PLSLINE 	plsline,
						 	PCPOINTUV 	ppointuvIn,				/* IN: query point */
							DWORD		cDepthQueryMax,
							PLSQSUBINFO	plsqsubinfoResults,		/* IN: pointer to array[nDepthQueryMax] */
							DWORD*		pcActualDepth,			/* OUT */
							PLSTEXTCELL	plstextcell)			/* OUT: Text cell info */
{
	LSERR 	lserr;
	PLSSUBL	plssubl;
	PLSC	plsc;
	POINTUV	pointuvStart;
	
	if (!FIsLSLINE(plsline)) return lserrInvalidLine;

	
	plssubl = &(plsline->lssubl);
	plsc = plssubl->plsc;
	Assert(FIsLSC(plsc));

	lserr = PrepareLineForDisplayProc(plsline);
	if (lserr != lserrNone)
		return lserr;
	
	/* splat - we can return nothing */
	if (ppointuvIn->u >= plsline->upLimLine && FIsSplat(plsline->lslinfo.endr))
		{
		*pcActualDepth = 0;
		return lserrNone;
		}
		
	pointuvStart = *ppointuvIn;
	
	// left indent isn't represented in the dnode list
	if (plsline->upStartAutonumberingText != 0)
		{
		pointuvStart.u -= plsline->upStartAutonumberingText;
		}
		
	lserr = QuerySublinePointPcpCore(plssubl, &pointuvStart, cDepthQueryMax, 
									plsqsubinfoResults, pcActualDepth, plstextcell);	
	
	if (lserr == lserrNone)
		{
		if (plsline->upStartAutonumberingText != 0)
			{
			AdjustForLeftIndent(plsqsubinfoResults, *pcActualDepth, plstextcell, plsline->upStartAutonumberingText);
			}

		if (plsqsubinfoResults->idobj == idObjNone)
			{												
			/* empty line - we can return nothing */
			*pcActualDepth = 0;
			}
		}

	return lserr;
}


//    %%Function:	LsQueryTextCellDetails
//    %%Contact:	victork
//
LSERR WINAPI LsQueryTextCellDetails(
							PLSLINE 		plsline,
						 	PCELLDETAILS	pcelldetails,
							LSCP			cpStartCell,		/* IN: cpStartCell	*/
							DWORD			cCharsInCell,		/* IN: nCharsInCell */
							DWORD			cGlyphsInCell,		/* IN: nGlyphsInCell */
							WCHAR*			pwch,				/* OUT: pointer array[nCharsInCell] of char codes */
							PGINDEX			pgindex,			/* OUT: pointer array[nGlyphsInCell] of glyph indices */
							long*			pdup,				/* OUT: pointer array[nGlyphsCell] of glyph widths */
							PGOFFSET 		pgoffset,			/* OUT: pointer array[nGlyphsInCell] of glyph offsets */
							PGPROP			pgprop)				/* OUT: pointer array[nGlyphsInCell] of glyph handles */
{

	PLSDNODE	pdnText;

	Unreferenced(plsline);					// is used in an assert only
	
	pdnText = (PLSDNODE)pcelldetails;		// I know it's really PLSDNODE

	Assert(FIsLSDNODE(pdnText));
	Assert(FIsDnodeReal(pdnText));
	Assert(IdObjFromDnode(pdnText) == IobjTextFromLsc(&(plsline->lssubl.plsc->lsiobjcontext)));

	// Try to defend again wrong input. Can't do a better job (use cCharsInCell) because of hyphenation.

	if (cpStartCell < pdnText->cpFirst || cpStartCell > pdnText->cpFirst + (long)pdnText->dcp)
		{
		NotReached();											// can only be client's mistake
		return lserrContradictoryQueryInput;					// in case it isn't noticed						
		}
	
	return QueryTextCellDetails(
						 	pdnText->u.real.pdobj,
							cpStartCell - pdnText->cpFirst,
							cCharsInCell,	
							cGlyphsInCell,	
							pwch,				
							pgindex,			
							pdup,				
							pgoffset,			
							pgprop);
}

//    %%Function:	LsQueryLineDup
//    %%Contact:	victork
//
LSERR WINAPI LsQueryLineDup(PLSLINE plsline,	/* IN: pointer to line -- opaque to client */
							long* pupStartAutonumberingText,
							long* pupLimAutonumberingText,
							long* pupStartMainText,
							long* pupStartTrailing,
							long* pupLimLine)

{
	LSERR lserr;

	if (!FIsLSLINE(plsline))
		return lserrInvalidLine;

	if (plsline->lssubl.plsc->lsstate != LsStateFree)
		return lserrContextInUse;

	lserr = PrepareLineForDisplayProc(plsline);
	if (lserr != lserrNone)
		return lserr;

	*pupStartAutonumberingText = plsline->upStartAutonumberingText; 
	*pupLimAutonumberingText = plsline->upLimAutonumberingText; 
	*pupStartMainText = plsline->upStartMainText; 
	*pupStartTrailing = plsline->upStartTrailing; 
	*pupLimLine = plsline->upLimLine; 
	
	return lserrNone;

}


//    %%Function:	LsQueryFLineEmpty
//    %%Contact:	victork
//
LSERR WINAPI LsQueryFLineEmpty(PLSLINE plsline,	/* IN: pointer to line -- opaque to client */
							   BOOL* pfEmpty)	/* OUT: Is line empty? */
{

	enum endres endr;
	PLSDNODE plsdnFirst;
	

	if (!FIsLSLINE(plsline))
		return lserrInvalidLine;

	if (plsline->lssubl.plsc->lsstate != LsStateFree)
		return lserrContextInUse;

	endr = plsline->lslinfo.endr;

	if (endr == endrNormal || endr == endrHyphenated)
		{
		// line that ends like that cannot be empty
		*pfEmpty = fFalse;
		return lserrNone;
		}

	// skip autonumbering - it cannot make line non-empty
	for(plsdnFirst = plsline->lssubl.plsdnFirst;
		plsdnFirst != NULL && FIsNotInContent(plsdnFirst);
		plsdnFirst = plsdnFirst->plsdnNext);

	// plsdnFirst points to the first dnode in content now or it is NULL

	switch (endr)
		{
	case endrEndPara:
	case endrAltEndPara:
	case endrSoftCR:
		// last dnode contains EOP and doesn't count as content
		Assert(plsdnFirst != NULL);
		Assert(plsdnFirst->plsdnNext == NULL || 
			   plsdnFirst->plsdnNext->cpFirst < plsline->lslinfo.cpLim);
		// EOP doesn't count as content - it cannot make line non-empty
		*pfEmpty = (plsdnFirst->plsdnNext == NULL);
		break;
		
	case endrEndColumn:
	case endrEndSection:
	case endrEndParaSection:
	case endrEndPage:
	case endrStopped:
		*pfEmpty = (plsdnFirst == NULL);
		break;
		
	default:
		NotReached();
		}

	return lserrNone;

}


//    %%Function:	AdjustForLeftIndent
//    %%Contact:	victork
//
void AdjustForLeftIndent(PLSQSUBINFO plsqsubinfoResults, DWORD cQueryLim, PLSTEXTCELL plstextcell, long upStartLine)

{
	plstextcell->pointUvStartCell.u += upStartLine;
	
	while (cQueryLim > 0)
		{
		plsqsubinfoResults->pointUvStartSubline.u += upStartLine;
		plsqsubinfoResults->pointUvStartRun.u += upStartLine;
		plsqsubinfoResults->pointUvStartObj.u += upStartLine;
		plsqsubinfoResults++;
		cQueryLim--;
		}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\lsqsubl.c ===
#include "lsc.h"
#include "lsqsubl.h"
#include "lssubl.h"
#include "lsqcore.h"


//    %%Function:	LsQueryCpPpointSubline
//    %%Contact:	victork
//
LSERR WINAPI  LsQueryCpPpointSubline(
							PLSSUBL 	plssubl,			/* IN: pointer to subline info */
							LSCP 		cpQuery,			/* IN: cpQuery */
							DWORD		cDepthQueryMax,		/* IN: allocated size of results array */
							PLSQSUBINFO	plsqsubinfoResults,	/* OUT: array[cDepthFormatMax] of query results */
							DWORD*		pcActualDepth,		/* OUT: size of results array (filled) */
							PLSTEXTCELL	plstextcellInfo)	/* OUT: Text cell info */
{
	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;
	
	Assert(!plssubl->fDupInvalid);

	return	QuerySublineCpPpointCore(plssubl, cpQuery, cDepthQueryMax, 
									plsqsubinfoResults, pcActualDepth, plstextcellInfo);
}


//    %%Function:	LsQueryPointPcpSubline
//    %%Contact:	victork
//
LSERR WINAPI LsQueryPointPcpSubline(
							PLSSUBL 	plssubl,			/* IN: pointer to subline info */
						 	PCPOINTUV 	ppointuvIn,			/* IN: query point (uQuery,vQuery) (line text flow) */
							DWORD		cDepthQueryMax,		/* IN: allocated size of results array */
							PLSQSUBINFO	plsqsubinfoResults,	/* OUT: array[cDepthFormatMax] of query results */
							DWORD*		pcActualDepth,		/* OUT: size of results array (filled) */
							PLSTEXTCELL	plstextcellInfo)	/* OUT: Text cell info */
{
	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;
	
	Assert(!plssubl->fDupInvalid);

	return	QuerySublinePointPcpCore(plssubl, ppointuvIn, cDepthQueryMax, 
									plsqsubinfoResults, pcActualDepth, plstextcellInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\lssetdoc.c ===
#include "iobj.h"
#include "lsidefs.h"	
#include "lssetdoc.h" 
#include "lsc.h"
#include "lstext.h"
#include "prepdisp.h"
#include "zqfromza.h"

static LSERR SetDocForFormaters(PLSC plsc, LSDOCINF* plsdocinf);


/* L S  S E T  D O C */
/*----------------------------------------------------------------------------
    %%Function: LsSetDoc
    %%Contact: igorzv

Parameters:
	plsc				-	(IN) ptr to line services context 
	fDisplay			-	(IN) Intend to display? 
	fPresEqualRef		-	(IN) Ref & Pres Devices are equal?
	pclsdevres			-	(IN) device resolutions 			


    Fill in a part of a Line Services context.
	Can be called more frequently then LsCreateContext.
----------------------------------------------------------------------------*/


LSERR WINAPI LsSetDoc(PLSC plsc,	
					  BOOL fDisplay,				
					  BOOL fPresEqualRef,				
					  const LSDEVRES* pclsdevres) 
{

	LSDOCINF* plsdocinf = &(plsc->lsdocinf);
	LSERR lserr;

	if (!FIsLSC(plsc))					/* check that context is valid and not busy (for example in formating) */
		return lserrInvalidContext;
	if (FIsLSCBusy(plsc))
		return lserrSetDocDisabled;


	if (!fDisplay && !fPresEqualRef) 
		{
		plsc->lsstate = LsStateNotReady;
		return lserrInvalidParameter;
		}

	/* if nothing is changed: return right away */
	if (((BYTE) fDisplay == plsdocinf->fDisplay) &&
		((BYTE) fPresEqualRef == plsdocinf->fPresEqualRef ) &&
		(pclsdevres->dxrInch == plsdocinf->lsdevres.dxrInch) &&
		(pclsdevres->dyrInch == plsdocinf->lsdevres.dyrInch) && 
		(fPresEqualRef ||
			((pclsdevres->dxpInch == plsdocinf->lsdevres.dxpInch) &&
			 (pclsdevres->dypInch == plsdocinf->lsdevres.dypInch))))
		return lserrNone;
		  

	/* if we have current line we  must prepare it for display before changing context  */
	if (plsc->plslineCur != NULL)
		{
		lserr = PrepareLineForDisplayProc(plsc->plslineCur);
		if (lserr != lserrNone)
			{
			plsc->lsstate = LsStateNotReady;
			return lserr;
			}
		plsc->plslineCur = NULL;
		}

	plsc->lsstate = LsStateSettingDoc;  /* this assignment should be after PrepareForDisplay */


	plsdocinf->fDisplay = (BYTE) fDisplay;
	plsdocinf->fPresEqualRef = (BYTE) fPresEqualRef;
	plsdocinf->lsdevres = *pclsdevres;

	if (fPresEqualRef) 
		{
		plsdocinf->lsdevres.dxpInch = plsdocinf->lsdevres.dxrInch;
		plsdocinf->lsdevres.dypInch = plsdocinf->lsdevres.dyrInch;
		}

	if (!FBetween(plsdocinf->lsdevres.dxpInch, 0, zqLim-1) ||
		!FBetween(plsdocinf->lsdevres.dypInch, 0, zqLim-1) ||
		!FBetween(plsdocinf->lsdevres.dxrInch, 0, zqLim-1) ||
		!FBetween(plsdocinf->lsdevres.dyrInch, 0, zqLim-1))
		{
		plsc->lsstate = LsStateNotReady;
		return lserrInvalidParameter;
		}
		
	lserr = SetDocForFormaters(plsc, plsdocinf);
	if (lserr != lserrNone)
		{
		plsc->lsstate = LsStateNotReady;
		return lserr;
		}

	plsc->lsstate = LsStateFree;
	return lserrNone;
}

LSERR WINAPI LsSetModWidthPairs(
					  PLSC  plsc,				/* IN: ptr to line services context */
					  DWORD clspairact,			/* IN: Number of mod pairs info units*/ 
					  const LSPAIRACT* rglspairact,	/* IN: Mod pairs info units array  */
					  DWORD cModWidthClasses,			/* IN: Number of Mod Width classes	*/
					  const BYTE* rgilspairact)	/* IN: Mod width information(square):
											  indexes in the LSPAIRACT array */
{
	LSERR lserr;
	DWORD iobjText;
	PILSOBJ pilsobjText;

	if (!FIsLSC(plsc))					/* check that context is valid and not busy (for example in formating) */
		return lserrInvalidContext;
	if (FIsLSCBusy(plsc))
		return lserrSetDocDisabled;



	/* if we have current line we  must prepare it for display before changing context  */
	if (plsc->plslineCur != NULL)
		{
		lserr = PrepareLineForDisplayProc(plsc->plslineCur);
		if (lserr != lserrNone)
			{
			plsc->lsstate = LsStateNotReady;
			return lserr;
			}
		plsc->plslineCur = NULL;
		}

	plsc->lsstate = LsStateSettingDoc;  /* this assignment should be after PrepareForDisplay */


	iobjText = IobjTextFromLsc(&plsc->lsiobjcontext);
	pilsobjText = PilsobjFromLsc(&plsc->lsiobjcontext, iobjText); 
	
	lserr = SetTextModWidthPairs(pilsobjText, clspairact,
				rglspairact, cModWidthClasses, rgilspairact);
	if (lserr != lserrNone)
		{
		plsc->lsstate = LsStateNotReady;
		return lserr;
		}

	plsc->lsstate = LsStateFree;
	return lserrNone;
}

LSERR WINAPI LsSetCompression(
					  PLSC plsc,				/* IN: ptr to line services context */
					  DWORD cPriorities,			/* IN: Number of compression priorities*/
					  DWORD clspract,			/* IN: Number of compression info units*/
					  const LSPRACT* rglspract,	/* IN: Compession info units array 	*/
					  DWORD cModWidthClasses,			/* IN: Number of Mod Width classes	*/
					  const BYTE* rgilspract)		/* IN: Compression information:
											  indexes in the LSPRACT array  */
{
	LSERR lserr;
	DWORD iobjText;
	PILSOBJ pilsobjText;

	if (!FIsLSC(plsc))					/* check that context is valid and not busy (for example in formating) */
		return lserrInvalidContext;
	if (FIsLSCBusy(plsc))
		return lserrSetDocDisabled;



	/* if we have current line we  must prepare it for display before changing context  */
	if (plsc->plslineCur != NULL)
		{
		lserr = PrepareLineForDisplayProc(plsc->plslineCur);
		if (lserr != lserrNone)
			{
			plsc->lsstate = LsStateNotReady;
			return lserr;
			}
		plsc->plslineCur = NULL;
		}

	plsc->lsstate = LsStateSettingDoc;  /* this assignment should be after PrepareForDisplay */


	iobjText = IobjTextFromLsc(&plsc->lsiobjcontext);
	pilsobjText = PilsobjFromLsc(&plsc->lsiobjcontext, iobjText); 
	
	lserr = SetTextCompression(pilsobjText, cPriorities, clspract,
				rglspract, cModWidthClasses, rgilspract);
	if (lserr != lserrNone)
		{
		plsc->lsstate = LsStateNotReady;
		return lserr;
		}

	plsc->lsstate = LsStateFree;
	return lserrNone;
}


LSERR WINAPI LsSetExpansion(
					  PLSC plsc,				/* IN: ptr to line services context */
					  DWORD cExpansionClasses,			/* IN: Number of expansion info units*/
					  const LSEXPAN* rglsexpan,	/* IN: Expansion info units array	*/
					  DWORD cModWidthClasses,			/* IN: Number of Mod Width classes	*/
					  const BYTE* rgilsexpan)		/* IN: Expansion information(square):
											  indexes in the LSEXPAN array  */

{
	LSERR lserr;
	DWORD iobjText;
	PILSOBJ pilsobjText;

	if (!FIsLSC(plsc))					/* check that context is valid and not busy (for example in formating) */
		return lserrInvalidContext;
	if (FIsLSCBusy(plsc))
		return lserrSetDocDisabled;



	/* if we have current line we  must prepare it for display before changing context  */
	if (plsc->plslineCur != NULL)
		{
		lserr = PrepareLineForDisplayProc(plsc->plslineCur);
		if (lserr != lserrNone)
			{
			plsc->lsstate = LsStateNotReady;
			return lserr;
			}
		plsc->plslineCur = NULL;
		}

	plsc->lsstate = LsStateSettingDoc;  /* this assignment should be after PrepareForDisplay */


	iobjText = IobjTextFromLsc(&plsc->lsiobjcontext);
	pilsobjText = PilsobjFromLsc(&plsc->lsiobjcontext, iobjText); 
	
	lserr = SetTextExpansion(pilsobjText, cExpansionClasses, 
				rglsexpan, cModWidthClasses, rgilsexpan);
	if (lserr != lserrNone)
		{
		plsc->lsstate = LsStateNotReady;
		return lserr;
		}

	plsc->lsstate = LsStateFree;
	return lserrNone;
}


LSERR WINAPI LsSetBreaking(
					  PLSC plsc,				/* IN: ptr to line services context */
					  DWORD clsbrk,			/* IN: Number of breaking info units*/
					  const LSBRK* rglsbrk,		/* IN: Breaking info units array	*/
					  DWORD cBreakingClasses,			/* IN: Number of breaking classes	*/
					  const BYTE* rgilsbrk)		/* IN: Breaking information(square):
											  indexes in the LSBRK array  */

{
	LSERR lserr;
	DWORD iobjText;
	PILSOBJ pilsobjText;

	if (!FIsLSC(plsc))					/* check that context is valid and not busy (for example in formating) */
		return lserrInvalidContext;
	if (FIsLSCBusy(plsc))
		return lserrSetDocDisabled;



	/* if we have current line we  must prepare it for display before changing context  */
	if (plsc->plslineCur != NULL)
		{
		lserr = PrepareLineForDisplayProc(plsc->plslineCur);
		if (lserr != lserrNone)
			{
			plsc->lsstate = LsStateNotReady;
			return lserr;
			}
		plsc->plslineCur = NULL;
		}

	plsc->lsstate = LsStateSettingDoc;  /* this assignment should be after PrepareForDisplay */


	iobjText = IobjTextFromLsc(&plsc->lsiobjcontext);
	pilsobjText = PilsobjFromLsc(&plsc->lsiobjcontext, iobjText); 
	
	lserr = SetTextBreaking(pilsobjText, clsbrk, 
				rglsbrk, cBreakingClasses, rgilsbrk);
	if (lserr != lserrNone)
		{
		plsc->lsstate = LsStateNotReady;
		return lserr;
		}

	plsc->lsstate = LsStateFree;
	return lserrNone;
}



/* S E T  D O C  F O R  F O R M A T E R S */
/*----------------------------------------------------------------------------
    %%Function: SetDocForFormaters
    %%Contact: igorzv
Parameter:
	plsc		-	(IN) ptr to line services context 
	plsdocinf	-	(IN) ptr to set doc input 

Invokes SetDoc methods for all formaters
----------------------------------------------------------------------------*/

LSERR SetDocForFormaters(PLSC plsc, LSDOCINF* plsdocinf)
{
	DWORD iobjMac;
	DWORD iobj;
	PILSOBJ pilsobj;
	LSERR lserr;


	Assert(FIsLSC(plsc));
	Assert(plsc->lsstate == LsStateSettingDoc);
	Assert(plsdocinf != NULL);

	iobjMac = plsc->lsiobjcontext.iobjMac;

	for (iobj = 0;  iobj < iobjMac;  iobj++)
		{
		pilsobj = plsc->lsiobjcontext.rgobj[iobj].pilsobj;
		lserr = plsc->lsiobjcontext.rgobj[iobj].lsim.pfnSetDoc(pilsobj,plsdocinf);
		if (lserr != lserrNone)
			return lserr;
		}
	return lserrNone;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\lsstring.c ===
#include "lsmem.h"
#include <limits.h>

#include "lsstring.h"
#include "txtils.h"
#include "txtln.h"
#include "txtobj.h"

/* Internal Functions prototypes */
static LSERR CheckReallocCharArrays(PLNOBJ plnobj, long cwch, long iwchLocalStart, long *cwchCorrect);
static LSERR CheckReallocSpacesArrays(PILSOBJ pobj, long cwSpaces);
static LSERR CopyCharsSpacesToDispList(PLNOBJ plnobj, WCHAR* rgwch, long cwch,
																	long* rgwSpaces, long cwSpaces);
static LSERR CopySpacesToDispList(PLNOBJ plnobj, long iNumOfSpaces, long durSpace);

/* Export Functions implementations */

/*----------------------------------------------------------------------------
    %%Function: GetWidth
    %%Contact: sergeyge
	
	Fetches widths until end of run or right margin

	Uses cache to improve performance
----------------------------------------------------------------------------*/
LSERR GetWidths(PLNOBJ plnobj, PLSRUN plsrun, long iwchStart, LPWSTR lpwch, LSCP cpFirst, long dcp, long durWidthExceed,
											LSTFLOW lstflow, long* pcwchFetched, long* pdurWidth)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	long durWidth;
	long cwch;
	long iwchDur;
	long cwchCorrect;
	long cwchIter;
	long durWidthIter;
	BOOL fNothingReturned = fTrue;

	pilsobj = plnobj->pilsobj;

	durWidth = 0;
	cwch = 0;
	iwchDur = iwchStart;
	*pcwchFetched = 0;
	*pdurWidth = 0;

	if (pilsobj->dcpFetchedWidth != 0 && cpFirst == pilsobj->cpFirstFetchedWidth &&
		iwchStart == pilsobj->iwchFetchedWidth && lpwch[0] == pilsobj->wchFetchedWidthFirst)
		{
		Assert(dcp >= pilsobj->dcpFetchedWidth);
		cwch = pilsobj->dcpFetchedWidth;
		durWidth = pilsobj->durFetchedWidth;
/* FormatRegular assumes that First character exceeding right margin will stop GetCharWidth loop;
	Special character could change situation---fix it.
*/
		if (durWidth > durWidthExceed)
			{
			while(cwch > 1 && durWidth - durWidthExceed > pilsobj->pdur[iwchStart + cwch - 1])
				{
				cwch--;
				durWidth -= pilsobj->pdur[iwchStart + cwch];
				}
			}
		dcp -= cwch;
		durWidthExceed -= durWidth;
		iwchDur += cwch;
		fNothingReturned = fFalse;
		}
		
	while (fNothingReturned || dcp > 0 && durWidthExceed >= 0)
		{
		lserr = CheckReallocCharArrays(plnobj, dcp, iwchDur, &cwchCorrect);
		if (lserr != lserrNone) return lserr;

		lserr = (*pilsobj->plscbk->pfnGetRunCharWidths)(pilsobj->pols, plsrun, lsdevReference, 
						&lpwch[cwch], cwchCorrect, (int)durWidthExceed, 
						lstflow, (int*)&pilsobj->pdur[iwchDur], &durWidthIter, &cwchIter);
		if (lserr != lserrNone) return lserr;

		Assert(durWidthIter >= 0);
		Assert(durWidthIter <= uLsInfiniteRM);

		Assert (durWidthIter <= uLsInfiniteRM - durWidth);

		if (durWidthIter > uLsInfiniteRM - durWidth)
			return lserrTooLongParagraph;

		durWidth += durWidthIter;

		durWidthExceed -= durWidthIter;
		iwchDur += cwchIter;
		cwch += cwchIter;
		dcp -= cwchIter;
		fNothingReturned = fFalse;
		}
	

	*pcwchFetched = cwch;
	*pdurWidth = durWidth;

	pilsobj->iwchFetchedWidth = iwchStart;
	pilsobj->cpFirstFetchedWidth = cpFirst;
	pilsobj->dcpFetchedWidth = cwch;
	pilsobj->durFetchedWidth = durWidth;

	return lserrNone;
}


/* F O R M A T  S T R I N G */
/*----------------------------------------------------------------------------
    %%Function: FormatString
    %%Contact: sergeyge
	
	Formats the local run
----------------------------------------------------------------------------*/
LSERR FormatString(PLNOBJ plnobj, PTXTOBJ pdobjText, WCHAR* rgwch, long cwch, 
												long* rgwSpaces, long cwSpaces, long durWidth)
{
	LSERR lserr;
	PILSOBJ pilsobj;

	pilsobj = plnobj->pilsobj;

	lserr = CopyCharsSpacesToDispList(plnobj, rgwch, cwch, rgwSpaces, cwSpaces);
	if (lserr != lserrNone) return lserr;

	/* fill out all related members from strils and output parameters */
	pdobjText->iwchLim = pdobjText->iwchLim + cwch;
	pdobjText->u.reg.iwSpacesLim = pdobjText->u.reg.iwSpacesLim + cwSpaces;

	/* Fix Width Fetching state */
	Assert((long)pilsobj->dcpFetchedWidth >=  cwch);
	Assert(pilsobj->durFetchedWidth >= durWidth);

	pilsobj->iwchFetchedWidth = pilsobj->iwchFetchedWidth + cwch;
	pilsobj->cpFirstFetchedWidth += cwch;
	pilsobj->dcpFetchedWidth -= cwch;
	pilsobj->durFetchedWidth -= durWidth;

	return lserrNone;
}

/* F I L L  R E G U L A R  P R E S  W I D T H S */
/*----------------------------------------------------------------------------
    %%Function: MeasureStringFirst
    %%Contact: sergeyge

	Calculates dur of one character.
----------------------------------------------------------------------------*/
LSERR FillRegularPresWidths(PLNOBJ plnobj, PLSRUN plsrun, LSTFLOW lstflow, PTXTOBJ pdobjText)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	int* rgDup;
	long dupJunk;
	long limDupJunk;

	pilsobj = plnobj->pilsobj;

	if (pilsobj->fDisplay)
		{
		rgDup = (int *)&plnobj->pdup[pdobjText->iwchFirst];

		if (!pilsobj->fPresEqualRef)
			{		
			lserr = (*pilsobj->plscbk->pfnGetRunCharWidths)(pilsobj->pols, plsrun, lsdevPres,
				&pilsobj->pwchOrig[pdobjText->iwchFirst], pdobjText->iwchLim - pdobjText->iwchFirst,
				LONG_MAX, lstflow, rgDup, &dupJunk, &limDupJunk);
			if (lserr != lserrNone) return lserr;
			}
		else            /* fPresEqualRef        */
			{
			memcpy(rgDup, &pilsobj->pdur[pdobjText->iwchFirst], sizeof(long) * (pdobjText->iwchLim - pdobjText->iwchFirst));
			}
		}
	
	return lserrNone;

}


/* G E T  O N E  C H A R  D U P */
/*----------------------------------------------------------------------------
    %%Function: MeasureStringFirst
    %%Contact: sergeyge

	Calculates dur of one character.
----------------------------------------------------------------------------*/
LSERR GetOneCharDur(PILSOBJ pilsobj, PLSRUN plsrun, WCHAR wch, LSTFLOW lstflow, long* pdur)
{
	LSERR lserr;
	long durSumJunk;
	long limDurJunk;

	lserr = (*pilsobj->plscbk->pfnGetRunCharWidths)(pilsobj->pols, plsrun, lsdevReference, &wch, 1, LONG_MAX, lstflow,
													(int*)pdur, &durSumJunk, &limDurJunk);
	if (lserr != lserrNone) return lserr;

	return lserrNone;
}

/* G E T  O N E  C H A R  D U P */
/*----------------------------------------------------------------------------
    %%Function: GetOneCharDup
    %%Contact: sergeyge
	
	Calculates dup of one character
----------------------------------------------------------------------------*/
LSERR GetOneCharDup(PILSOBJ pilsobj, PLSRUN plsrun, WCHAR wch, LSTFLOW lstflow, long dur, long* pdup)
{
	LSERR lserr;
	long dupSumJunk;
	long limDupJunk;

	*pdup = 0;
	if (pilsobj->fDisplay)
		{
		if (!pilsobj->fPresEqualRef)
			{
			lserr = (*pilsobj->plscbk->pfnGetRunCharWidths)(pilsobj->pols, plsrun, lsdevPres, &wch, 1,
								 LONG_MAX, lstflow, (int*)pdup, &dupSumJunk, &limDupJunk);
			if (lserr != lserrNone) return lserr;
			}
		else
			{
			*pdup = dur;
			}
		}
		

	return lserrNone;
}

/* G E T  V I S I  D U P */
/*----------------------------------------------------------------------------
    %%Function: GetVisiDup
    %%Contact: sergeyge
	
	Calculates dup of visi character character
----------------------------------------------------------------------------*/
LSERR GetVisiCharDup(PILSOBJ pilsobj, PLSRUN plsrun, WCHAR wch, LSTFLOW lstflow, long* pdup)
{
	LSERR lserr;
	long dupSumJunk;
	long limDupJunk;

	*pdup = 0;
	if (pilsobj->fDisplay)
		{
		lserr = (*pilsobj->plscbk->pfnGetRunCharWidths)(pilsobj->pols, plsrun, lsdevPres, &wch, 1,
								 LONG_MAX, lstflow, (int*)pdup, &dupSumJunk, &limDupJunk);
		if (lserr != lserrNone) return lserr;
		}

	return lserrNone;
}


/* A D D  C H A R A C T E R  W I T H  W I D T H */
/*----------------------------------------------------------------------------
    %%Function: AddCharacterWithWidth
    %%Contact: sergeyge
	
	Writes character code and its width in wchOrig, wch, dup, dur arrays.
	Stores character code (in the VISI situation it can be different from wch)
	in pilsobj->wchPrev.
----------------------------------------------------------------------------*/
LSERR AddCharacterWithWidth(PLNOBJ plnobj, PTXTOBJ pdobjText, WCHAR wchOrig, long durWidth, WCHAR wch, long dupWidth)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	long iwchLocalStart;
	long cjunk;

	pilsobj = plnobj->pilsobj;

	iwchLocalStart = pilsobj->wchMac;

	lserr = CheckReallocCharArrays(plnobj, 1, iwchLocalStart, &cjunk);
	if (lserr != lserrNone) return lserr;


/* Fix cached width information before width in the pdur array is overwritten by durWidth.
	Theoretically durWidth can be different from the cached value */

	if (pilsobj->dcpFetchedWidth > 0)
		{
		pilsobj->iwchFetchedWidth ++;
		pilsobj->cpFirstFetchedWidth ++;
		pilsobj->dcpFetchedWidth --;
		pilsobj->durFetchedWidth -= pilsobj->pdur[iwchLocalStart];
		}


	pilsobj->pwchOrig[iwchLocalStart] = wchOrig;
	pilsobj->pdur[iwchLocalStart] = durWidth;

	if (pilsobj->fDisplay)
		{
		plnobj->pwch[iwchLocalStart] = wch;
		plnobj->pdup[iwchLocalStart] = dupWidth;
		}

	pilsobj->wchMac++;

	pdobjText->iwchLim++;

	Assert(pilsobj->wchMac == pdobjText->iwchLim);


	return lserrNone;
}

/* F I X  S P A C E S */
/*----------------------------------------------------------------------------
    %%Function: FixSpaces
    %%Contact: sergeyge
	
	Fixes space character code for the Visi Spaces situation
----------------------------------------------------------------------------*/
void FixSpaces(PLNOBJ plnobj, PTXTOBJ pdobjText, WCHAR wch)
{
	PILSOBJ pilsobj;
	long i;

	pilsobj = plnobj->pilsobj;

	if (pilsobj->fDisplay)
		{
		for (i = pdobjText->u.reg.iwSpacesFirst; i < pdobjText->u.reg.iwSpacesLim; i++)
			{
			plnobj->pwch[pilsobj->pwSpaces[i]] = wch;
			}
		}
}

/* A D D  S P A C E S */
/*----------------------------------------------------------------------------
    %%Function: AddTrailingSpaces
    %%Contact: sergeyge
	
	Adds trailing/bordered spaces to the disp list
----------------------------------------------------------------------------*/
LSERR AddSpaces(PLNOBJ plnobj, PTXTOBJ pdobjText, long durSpace, long iNumOfSpaces)
{
	LSERR lserr;

	lserr = CopySpacesToDispList(plnobj, iNumOfSpaces, durSpace);
	if (lserr != lserrNone) return lserr;

	pdobjText->iwchLim = pdobjText->iwchLim + iNumOfSpaces;
	pdobjText->u.reg.iwSpacesLim = pdobjText->u.reg.iwSpacesLim + iNumOfSpaces;

	/* Fix Fetched Widths part. For non-bordered case, this procedure is activated for
		trailing spaces only, so this state should also be filled with 0s, but
		for bordered case it must be flushed
	*/
	FlushStringState(plnobj->pilsobj);

	return lserrNone;
}

/* I N C R E A S E   W C H M A C  B Y  @ */
/*----------------------------------------------------------------------------
    %%Function: IncreaseWchMacBy2
    %%Contact: sergeyge
	
----------------------------------------------------------------------------*/
LSERR IncreaseWchMacBy2(PLNOBJ plnobj)
{
	LSERR lserr;
	long cwch;
	
	lserr = CheckReallocCharArrays(plnobj, 2, plnobj->pilsobj->wchMac, &cwch);
	if (lserr != lserrNone) return lserr;

	Assert(cwch <= 2 && cwch > 0);

	if (cwch == 1)
		{
		lserr = CheckReallocCharArrays(plnobj, 1, plnobj->pilsobj->wchMac + 1, &cwch);
		if (lserr != lserrNone) return lserr;
		Assert(cwch == 1);
		}

	plnobj->pilsobj->wchMac += 2;

	return lserrNone;	
}

/* Internal Functions Implementation */


/* C H E C K  R E A L L O C  C H A R  A R R A Y S */
/*----------------------------------------------------------------------------
    %%Function: ReallocCharArrays
    %%Contact: sergeyge
	
	Reallocates character based arrays, increasing them by delta
----------------------------------------------------------------------------*/
static LSERR CheckReallocCharArrays(PLNOBJ plnobj, long cwch, long iwchLocalStart, long *cwchCorrect)
{
	PILSOBJ pilsobj;
	WCHAR* pwch;
	long* pdup;
	long* pdur;
	GMAP* pgmap;
	TXTINF* ptxtinf;
	long delta;

	pilsobj = plnobj->pilsobj;

	/* pdupPen was made equal to pdup at the CreateLnObj time;
		it can be changed to pdupPenAlloc at Adjust time only */
	Assert(plnobj->pdup == plnobj->pdupPen);

	/* Constant 2 is not random. We need to have 2 extra places for characters
	   for breaking with AutoHyphen and YSR which adds one charcter and hyphen.
	*/
	if (iwchLocalStart + cwch <= (long)pilsobj->wchMax - 2)
		{
		*cwchCorrect = cwch;
		}
	else if (iwchLocalStart < (long)pilsobj->wchMax - 2)
		{
		*cwchCorrect = pilsobj->wchMax - 2 - iwchLocalStart;
		}
	else 
		{
		Assert (iwchLocalStart == (long)pilsobj->wchMax - 2);

		delta = wchAddM;

		pwch = (*pilsobj->plscbk->pfnReallocPtr)(pilsobj->pols, pilsobj->pwchOrig, (pilsobj->wchMax + delta) * sizeof(WCHAR) );
		if (pwch == NULL)
			{
			return lserrOutOfMemory;
			}
		pilsobj->pwchOrig = pwch;

		pwch = (*pilsobj->plscbk->pfnReallocPtr)(pilsobj->pols, plnobj->pwch, (pilsobj->wchMax + delta) * sizeof(WCHAR) );
		if (pwch == NULL)
			{
			return lserrOutOfMemory;
			}
		plnobj->pwch = pwch;

		pdur = (*pilsobj->plscbk->pfnReallocPtr)(pilsobj->pols, pilsobj->pdur, (pilsobj->wchMax + delta) * sizeof(long) );
		if (pdur == NULL)
			{
			return lserrOutOfMemory;
			}
		pilsobj->pdur = pdur;

		pdup = (*pilsobj->plscbk->pfnReallocPtr)(pilsobj->pols, plnobj->pdup, (pilsobj->wchMax + delta) * sizeof(long) );
		if (pdup == NULL)
			{
			return lserrOutOfMemory;
			}
		plnobj->pdup = pdup;

		if (plnobj->pdupPenAlloc != NULL)
			{
			pdup = (*pilsobj->plscbk->pfnReallocPtr)(pilsobj->pols, plnobj->pdupPenAlloc, (pilsobj->wchMax + delta) * sizeof(long) );
			if (pdup == NULL)
				{
				return lserrOutOfMemory;
				}
			plnobj->pdupPenAlloc = pdup;
			}

		if (plnobj->pgmap != NULL)
			{
			pgmap = (*pilsobj->plscbk->pfnReallocPtr)(pilsobj->pols, plnobj->pgmap, (pilsobj->wchMax + delta) * sizeof(GMAP) );
			if (pgmap == NULL)
				{
				return lserrOutOfMemory;
				}
			plnobj->pgmap = pgmap;
			}

		if (pilsobj->pdurLeft != NULL)
			{
			pdur = (*pilsobj->plscbk->pfnReallocPtr)(pilsobj->pols, pilsobj->pdurLeft, (pilsobj->wchMax + delta) * sizeof(long) );
			if (pdur == NULL)
				{
				return lserrOutOfMemory;
				}
			pilsobj->pdurLeft = pdur;
			memset(&pilsobj->pdurLeft[pilsobj->wchMax], 0, sizeof(long) * delta );
			}

		if	(pilsobj->pdurRight != NULL)
			{
			pdur = (*pilsobj->plscbk->pfnReallocPtr)(pilsobj->pols, pilsobj->pdurRight, (pilsobj->wchMax + delta) * sizeof(long) );
			if (pdur == NULL)
				{
				return lserrOutOfMemory;
				}
			pilsobj->pdurRight = pdur;
			memset(&pilsobj->pdurRight[pilsobj->wchMax], 0, sizeof(long) * delta);
			}

		if (pilsobj->pduAdjust != NULL)
			{
			pdur = (*pilsobj->plscbk->pfnReallocPtr)(pilsobj->pols, pilsobj->pduAdjust, (pilsobj->wchMax + delta) * sizeof(long) );
			if (pdur == NULL)
				{
				return lserrOutOfMemory;
				}
			pilsobj->pduAdjust = pdur;
			}

		if (pilsobj->ptxtinf != NULL)
			{
			ptxtinf = (*pilsobj->plscbk->pfnReallocPtr)(pilsobj->pols, pilsobj->ptxtinf, (pilsobj->wchMax + delta) * sizeof(TXTINF) );
			if (ptxtinf == NULL)
				{
				return lserrOutOfMemory;
				}
			pilsobj->ptxtinf = ptxtinf;
			memset(&pilsobj->ptxtinf[pilsobj->wchMax], 0, sizeof(TXTINF) * delta);
			}

		pilsobj->wchMax += delta;
		plnobj->wchMax = pilsobj->wchMax;

		*cwchCorrect = delta;
		if (cwch < delta)
			*cwchCorrect = cwch;
		}

	/* see comment and Assert at the beginning of the file */
	plnobj->pdupPen = plnobj->pdup;

	return lserrNone;

}


/* C H E C K  R E A L L O C  S P A C E S  A R R A Y S */
/*----------------------------------------------------------------------------
    %%Function: CheckReallocSpacesArrays
    %%Contact: sergeyge
	
	Checks that there is enough space wSpaces
	to accomodate characters & spaces from the current local run.
	Reallocates these arrays if it is needed.
----------------------------------------------------------------------------*/
static LSERR CheckReallocSpacesArrays(PILSOBJ pilsobj, long cwSpaces)
{
	long iwSpacesLocalStart;
	long delta;
	long* pwSpaces;

	iwSpacesLocalStart = pilsobj->wSpacesMac;

	/* check that there is enough space for spaces in pwSpaces           */
	if (iwSpacesLocalStart + cwSpaces > pilsobj->wSpacesMax)
		{
		delta = wchAddM;
		if (delta < iwSpacesLocalStart + cwSpaces - pilsobj->wSpacesMax)
			{
			delta = iwSpacesLocalStart + cwSpaces - pilsobj->wSpacesMax;
			}
		pwSpaces = (*pilsobj->plscbk->pfnReallocPtr)(pilsobj->pols, pilsobj->pwSpaces, (pilsobj->wSpacesMax + delta) * sizeof(long) );
		if (pwSpaces == NULL)
			{
			return lserrOutOfMemory;
			}
		pilsobj->pwSpaces = pwSpaces;
		pilsobj->wSpacesMax += delta;
		}

	return lserrNone;
}

/* C O P Y  C H A R S  S P A C E S  T O  D I S P  L I S T */
/*----------------------------------------------------------------------------
    %%Function: CopyCharsSpacesToDispList
    %%Contact: sergeyge
	
	Fills wch, dur and wSpaces arrays
----------------------------------------------------------------------------*/
static LSERR CopyCharsSpacesToDispList(PLNOBJ plnobj, WCHAR* rgwch, long cwch,
																		long* rgwSpaces, long cwSpaces)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	long iwchLocalStart;
	long iwSpacesLocalStart;
	long i;

	pilsobj = plnobj->pilsobj;
	iwchLocalStart = pilsobj->wchMac;
	iwSpacesLocalStart = pilsobj->wSpacesMac;

	/* check that there is enough space for characters and their widths in pwch and pdup arrays  */ 
	lserr = CheckReallocSpacesArrays(pilsobj, cwSpaces);
	if (lserr != lserrNone) return lserr;

	/* fill pwch array      */
	memcpy(&pilsobj->pwchOrig[iwchLocalStart], rgwch, sizeof(rgwch[0]) * cwch);
	memcpy(&plnobj->pwch[iwchLocalStart], rgwch, sizeof(rgwch[0]) * cwch);
	pilsobj->wchMac += cwch;

	/* fill pwSpaces array, note that spaces with idexes greater than cwch should not be copied */
	for (i=0; i < cwSpaces && rgwSpaces[i] < cwch; i++)
		{
		pilsobj->pwSpaces[iwSpacesLocalStart + i] = iwchLocalStart + rgwSpaces[i];
		}

	pilsobj->wSpacesMac += i;

	return lserrNone;
}


/* C O P Y  S P A C E S  T O  D I S P  L I S T */
/*----------------------------------------------------------------------------
    %%Function: CopyTrailingSpacesToDispList
    %%Contact: sergeyge
	
	Fills wch, dur, dup, wSpaces arrays with the trailing spaces info
----------------------------------------------------------------------------*/
static LSERR CopySpacesToDispList(PLNOBJ plnobj, long iNumOfSpaces, long durSpace)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	long iwchLocalStart;
	long iwSpacesLocalStart;
	long i;
	long cwch;
	long iwchStartCheck;
	long cwchCorrect;

	pilsobj = plnobj->pilsobj;
	iwchLocalStart = pilsobj->wchMac;
	iwSpacesLocalStart = pilsobj->wSpacesMac;

	cwch = iNumOfSpaces;
	iwchStartCheck = iwchLocalStart;

	while (cwch > 0)
		{
		lserr = CheckReallocCharArrays(plnobj, cwch, iwchStartCheck, &cwchCorrect);
		if (lserr != lserrNone) return lserr;

		iwchStartCheck += cwchCorrect;
		cwch -= cwchCorrect;
		}
	
	lserr = CheckReallocSpacesArrays(pilsobj, iNumOfSpaces);
	if (lserr != lserrNone) return lserr;

	for (i=0; i < iNumOfSpaces; i++)
		{
		plnobj->pwch[iwchLocalStart + i] = pilsobj->wchSpace;
		pilsobj->pwchOrig[iwchLocalStart + i] = pilsobj->wchSpace;
		pilsobj->pdur[iwchLocalStart + i] = durSpace;
		pilsobj->pwSpaces[iwSpacesLocalStart + i] = iwchLocalStart + i;
		}

	pilsobj->wchMac += iNumOfSpaces;
	pilsobj->wSpacesMac += iNumOfSpaces;
	
	return lserrNone;
}

/* F L A S H  S T R I N G  S T A T E */
/*----------------------------------------------------------------------------
    %%Function: FlashStringState
    %%Contact: sergeyge
	
----------------------------------------------------------------------------*/
void FlushStringState(PILSOBJ pilsobj)
{
	pilsobj->iwchFetchedWidth = 0;
	pilsobj->cpFirstFetchedWidth = 0;
	pilsobj->dcpFetchedWidth = 0;
	pilsobj->durFetchedWidth = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\lstxtbr1.c ===
#include <limits.h>
#include "lsmem.h"
#include "lstxtbr1.h"
#include "lstxtbrs.h"
#include "lstxtmap.h"
#include "lsdntext.h"
#include "brko.h"
#include "locchnk.h"
#include "locchnk.h"
#include "posichnk.h"
#include "objdim.h"
#include "lstxtffi.h"
#include "txtils.h"
#include "txtln.h"
#include "txtobj.h"

static void TruncateGlyphBased(PTXTOBJ ptxtobj, long itxtobj, long urTotal, long urColumnMax,
													PPOSICHNK pposichnk);

/* Export Functions Implementation */


/* Q U I C K  B R E A K  T E X T */
/*----------------------------------------------------------------------------
    %%Function: QuickBreakText
    %%Contact: sergeyge

	Breaks the line if it is easy to do, namely:
		-- break-character is space
		-- previous character is not space
----------------------------------------------------------------------------*/
LSERR QuickBreakText(PDOBJ pdobj, BOOL* pfSuccessful, LSDCP* pdcpBreak, POBJDIM pobjdim)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	long iwchSpace;
	long dur;

	*pfSuccessful = fFalse;

	ptxtobj = (PTXTOBJ)pdobj;

	pilsobj = ptxtobj->plnobj->pilsobj;

	Assert(!(pilsobj->grpf & fTxtDoHyphenation));
	Assert(!(pilsobj->grpf & fTxtWrapTrailingSpaces));
	Assert(!(pilsobj->grpf & fTxtWrapAllSpaces));
	Assert(!(ptxtobj->txtf & txtfGlyphBased));

	if (ptxtobj->txtkind == txtkindRegular)
		{
		if	(!(pilsobj->grpf & fTxtApplyBreakingRules))
			{
			if	(ptxtobj->u.reg.iwSpacesLim > ptxtobj->u.reg.iwSpacesFirst)
				{
				iwchSpace = pilsobj->pwSpaces[ptxtobj->u.reg.iwSpacesLim - 1];
				Assert(iwchSpace < ptxtobj->iwchLim - 1);		/* formatting never stops at space	*/
				if (iwchSpace + 1 - ptxtobj->iwchFirst > ptxtobj->u.reg.iwSpacesLim - ptxtobj->u.reg.iwSpacesFirst)
					{
					*pfSuccessful = fTrue;
					*pdcpBreak = iwchSpace - ptxtobj->iwchFirst + 1;
					lserr = CalcPartWidths(ptxtobj, *pdcpBreak, pobjdim, &dur);
					Assert(lserr == lserrNone);
					pobjdim->dur = dur;
					
					Assert(*pdcpBreak > 1);

					ptxtobj->iwchLim = iwchSpace + 1;
					}
				}
			}
	
		else
			{
			LSCP cpFirst;
			PLSRUN plsrun;
			long iwchFirst;
			long iwchCur;
			long iwchInSpace;
			BRKCLS brkclsFollowingCache;
			BRKCLS brkclsLeading;
			BRKCLS brkclsFollowing;

			Assert(pilsobj->pwchOrig[ptxtobj->iwchLim - 1] != pilsobj->wchSpace);
			lserr = LsdnGetCpFirst(pilsobj->plsc, ptxtobj->plsdnUpNode, &cpFirst);
			Assert(lserr == lserrNone);
			lserr = LsdnGetPlsrun(pilsobj->plsc, ptxtobj->plsdnUpNode, &plsrun);
			Assert(lserr == lserrNone);
			iwchFirst = ptxtobj->iwchFirst;
			if (ptxtobj->u.reg.iwSpacesLim > ptxtobj->u.reg.iwSpacesFirst)
				iwchFirst = pilsobj->pwSpaces[ptxtobj->u.reg.iwSpacesLim - 1] + 1;

			iwchCur = ptxtobj->iwchLim - 1;

			lserr =(*pilsobj->plscbk->pfnGetBreakingClasses)(pilsobj->pols, plsrun,
					cpFirst + (iwchCur - ptxtobj->iwchFirst),			
					pilsobj->pwchOrig[iwchCur], &brkclsLeading, &brkclsFollowingCache);
			if (lserr != lserrNone) return lserr;

			Assert(brkclsLeading < pilsobj->cBreakingClasses && brkclsFollowingCache < pilsobj->cBreakingClasses);

			iwchCur--;

			while (!*pfSuccessful && iwchCur >= iwchFirst)
				{
				brkclsFollowing = brkclsFollowingCache;
				lserr =(*pilsobj->plscbk->pfnGetBreakingClasses)(pilsobj->pols, plsrun,
					cpFirst + (iwchCur - ptxtobj->iwchFirst),				
					pilsobj->pwchOrig[iwchCur], &brkclsLeading, &brkclsFollowingCache);
				if (lserr != lserrNone) return lserr;
		
				Assert(brkclsLeading < pilsobj->cBreakingClasses && brkclsFollowingCache < pilsobj->cBreakingClasses);

				*pfSuccessful = FCanBreak(pilsobj, brkclsLeading, brkclsFollowing);
				iwchCur --;
				}
			
			if (!*pfSuccessful && iwchFirst > ptxtobj->iwchFirst)
				{
				Assert(pilsobj->pwchOrig[iwchCur] == pilsobj->wchSpace);
				iwchCur--;
				for (iwchInSpace = iwchCur; iwchInSpace >= ptxtobj->iwchFirst &&
						pilsobj->pwchOrig[iwchInSpace] == pilsobj->wchSpace; iwchInSpace--);

				if (iwchInSpace >= ptxtobj->iwchFirst)
					{
					brkclsFollowing = brkclsFollowingCache;
					lserr =(*pilsobj->plscbk->pfnGetBreakingClasses)(pilsobj->pols, plsrun,
							cpFirst + (iwchInSpace - ptxtobj->iwchFirst),			
							pilsobj->pwchOrig[iwchInSpace], &brkclsLeading, &brkclsFollowingCache);
					if (lserr != lserrNone) return lserr;

					Assert(brkclsLeading < pilsobj->cBreakingClasses && brkclsFollowingCache < pilsobj->cBreakingClasses);
				
					*pfSuccessful = FCanBreakAcrossSpaces(pilsobj, brkclsLeading, brkclsFollowing);

					}
				}

			if (*pfSuccessful)
				{
				*pdcpBreak = iwchCur + 1 - ptxtobj->iwchFirst + 1;
				lserr = CalcPartWidths(ptxtobj, *pdcpBreak, pobjdim, &dur);
				Assert(lserr == lserrNone);
				pobjdim->dur = dur;
				
				Assert(*pdcpBreak >= 1);

				ptxtobj->iwchLim = iwchCur + 2;
				}
			}
		}

   return lserrNone;			

}

/* S E T  B R E A K  T E X T */
/*----------------------------------------------------------------------------
    %%Function:SetBreakText
    %%Contact: sergeyge

----------------------------------------------------------------------------*/
LSERR WINAPI SetBreakText(PDOBJ pdobj, BRKKIND brkkind, DWORD nBreakRec, BREAKREC* rgBreakRec, DWORD* pnActual)
{
	LSERR lserr;
	PLNOBJ plnobj;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	long iwchLim;
	long ibrkinf;
	BREAKINFO* pbrkinf;
	BOOL fInChildList;

	Unreferenced(nBreakRec);
	Unreferenced(rgBreakRec);

	*pnActual = 0;

	ptxtobj = (PTXTOBJ) pdobj;
	plnobj = ptxtobj->plnobj;
	pilsobj = plnobj->pilsobj;

	for (ibrkinf = 0; ibrkinf < (long)pilsobj->breakinfMac &&
		(pilsobj->pbreakinf[ibrkinf].pdobj != pdobj || pilsobj->pbreakinf[ibrkinf].brkkind != brkkind);
																						ibrkinf++ );
	if (ibrkinf < (long)pilsobj->breakinfMac)
		{
		pbrkinf = &pilsobj->pbreakinf[ibrkinf];
		switch (pbrkinf->brkt)
			{
		case brktNormal:
			iwchLim = ptxtobj->iwchFirst + pbrkinf->dcp;
			if (iwchLim < ptxtobj->iwchLim)
				ptxtobj->iwchLim = iwchLim;
			ptxtobj->igindLim = pbrkinf->u.normal.igindLim;
			if (pbrkinf->u.normal.durFix != 0)
				{
				Assert(!(ptxtobj->txtf & txtfGlyphBased));
				pilsobj->pdur[ptxtobj->iwchLim - 1] += pbrkinf->u.normal.durFix;
				Assert (pilsobj->pdurRight != NULL);
				pilsobj->pdurRight[ptxtobj->iwchLim - 1] = 0;
				}
			break;
		case brktHyphen:
			iwchLim = pbrkinf->u.hyphen.iwchLim;
			ptxtobj->iwchLim = iwchLim;
			plnobj->pdobjHyphen = ptxtobj;	
			plnobj->dwchYsr = pbrkinf->u.hyphen.dwchYsr;	

			pilsobj->pwchOrig[iwchLim - 1] = pilsobj->wchHyphen;
			plnobj->pwch[iwchLim - 1] = pilsobj->wchHyphen;

			if (pbrkinf->u.hyphen.gindHyphen != 0)
				{
				ptxtobj->igindLim = pbrkinf->u.hyphen.igindHyphen + 1;
				plnobj->pgind[pbrkinf->u.hyphen.igindHyphen] = pbrkinf->u.hyphen.gindHyphen;
				pilsobj->pdurGind[pbrkinf->u.hyphen.igindHyphen] = pbrkinf->u.hyphen.durHyphen;
				plnobj->pdupGind[pbrkinf->u.hyphen.igindHyphen] = pbrkinf->u.hyphen.dupHyphen;
				if (pilsobj->pduGright != NULL)
						pilsobj->pduGright[pbrkinf->u.hyphen.igindHyphen] = 0;
				/* REVIEW sergeyge: It would be nice to move this activity to lstxtmap module */
				plnobj->pgmap[iwchLim - 1] = (WORD)(pbrkinf->u.hyphen.igindHyphen -
												(ptxtobj->igindFirst - plnobj->pgmap[ptxtobj->iwchFirst]));
				pilsobj->ptxtinf[iwchLim - 1].fOneToOne = fTrue;
				pilsobj->ptxtinf[iwchLim - 1].fFirstInContext = fTrue;
				pilsobj->ptxtinf[iwchLim - 1].fLastInContext = fTrue;
				pilsobj->pginf[pbrkinf->u.hyphen.igindHyphen] = ginffOneToOne |
													 ginffFirstInContext | ginffLastInContext;
				}
			else
				{
				pilsobj->pdur[iwchLim - 1] = pbrkinf->u.hyphen.durHyphen;
				plnobj->pdup[iwchLim - 1] = pbrkinf->u.hyphen.dupHyphen;
				if (pilsobj->pdurRight != NULL)
					pilsobj->pdurRight[iwchLim - 1] = 0;
				if (pilsobj->pdurLeft != NULL)
					pilsobj->pdurLeft[iwchLim - 1] = 0;
				}

			if (pbrkinf->u.hyphen.wchPrev != 0)
				{
				pilsobj->pwchOrig[iwchLim - 2] = pbrkinf->u.hyphen.wchPrev;
				plnobj->pwch[iwchLim - 2] = pbrkinf->u.hyphen.wchPrev;
				if (pbrkinf->u.hyphen.gindPrev != 0)
					{
					plnobj->pgind[pbrkinf->u.hyphen.igindPrev] = pbrkinf->u.hyphen.gindPrev;
					pilsobj->pdurGind[pbrkinf->u.hyphen.igindPrev] = pbrkinf->u.hyphen.durPrev;
					plnobj->pdupGind[pbrkinf->u.hyphen.igindPrev] = pbrkinf->u.hyphen.dupPrev;
					if (pilsobj->pduGright != NULL)
						pilsobj->pduGright[pbrkinf->u.hyphen.igindPrev] = 0;
					/* REVIEW sergeyge: It would be nice to move this activity to lstxtmap module */
					/* If Prev glyph is added the following activity is required;
						If it is just replaced, we assign the same values,because ProcessYsr
						would not allow replace not OneToOne character
					*/
					plnobj->pgmap[iwchLim - 2] = (WORD)(pbrkinf->u.hyphen.igindPrev - 
											(ptxtobj->igindFirst - plnobj->pgmap[ptxtobj->iwchFirst]));
					pilsobj->ptxtinf[iwchLim - 2].fOneToOne = fTrue;
					pilsobj->ptxtinf[iwchLim - 2].fFirstInContext = fTrue;
					pilsobj->ptxtinf[iwchLim - 2].fLastInContext = fTrue;
					pilsobj->pginf[pbrkinf->u.hyphen.igindPrev] = ginffOneToOne |
													ginffFirstInContext | ginffLastInContext;
					}
				else
					{
					pilsobj->pdur[iwchLim - 2] = pbrkinf->u.hyphen.durPrev;
					plnobj->pdup[iwchLim - 2] = pbrkinf->u.hyphen.dupPrev;
					if (pilsobj->pdurRight != NULL)
						pilsobj->pdurRight[iwchLim - 2] = 0;
					if (pilsobj->pdurLeft != NULL)
						pilsobj->pdurLeft[iwchLim - 2] = 0;
						}
				}

			if (pbrkinf->u.hyphen.wchPrevPrev != 0)
				{
				pilsobj->pwchOrig[iwchLim - 3] = pbrkinf->u.hyphen.wchPrevPrev;
				plnobj->pwch[iwchLim - 3] = pbrkinf->u.hyphen.wchPrevPrev;
				if (pbrkinf->u.hyphen.gindPrevPrev != 0)
					{
					plnobj->pgind[pbrkinf->u.hyphen.igindPrevPrev] = pbrkinf->u.hyphen.gindPrevPrev;
					pilsobj->pdurGind[pbrkinf->u.hyphen.igindPrevPrev] = pbrkinf->u.hyphen.durPrevPrev;
					plnobj->pdupGind[pbrkinf->u.hyphen.igindPrevPrev] = pbrkinf->u.hyphen.dupPrevPrev;
					if (pilsobj->pduGright != NULL)
						pilsobj->pduGright[pbrkinf->u.hyphen.igindPrevPrev] = 0;
					}
				else
					{
					pilsobj->pdur[iwchLim - 3] = pbrkinf->u.hyphen.durPrevPrev;
					plnobj->pdup[iwchLim - 3] = pbrkinf->u.hyphen.dupPrevPrev;
					if (pilsobj->pdurRight != NULL)
						pilsobj->pdurRight[iwchLim - 3] = 0;
					if (pilsobj->pdurLeft != NULL)
						pilsobj->pdurLeft[iwchLim - 3] = 0;
					}

				}

			if (pbrkinf->u.hyphen.ddurDnodePrev != 0)
				{
				
				lserr = LsdnResetWidthInPreviousDnodes(pilsobj->plsc, ptxtobj->plsdnUpNode, 
					pbrkinf->u.hyphen.ddurDnodePrev, 0);

				if (lserr != lserrNone) return lserr;
				}

			lserr = LsdnSetHyphenated(pilsobj->plsc);
			if (lserr != lserrNone) return lserr;

			break;

		case brktNonReq:
			Assert(pbrkinf->dcp == 1);
			iwchLim = pbrkinf->u.nonreq.iwchLim;
			ptxtobj->iwchLim = iwchLim;
			Assert(iwchLim == ptxtobj->iwchFirst + pbrkinf->u.nonreq.dwchYsr);
			plnobj->pdobjHyphen = ptxtobj;	
			plnobj->dwchYsr = pbrkinf->u.nonreq.dwchYsr;	

			Assert(ptxtobj->iwchLim == iwchLim);
			pilsobj->pwchOrig[iwchLim - 1] = pilsobj->wchHyphen;
			plnobj->pwch[iwchLim - 1] = pbrkinf->u.nonreq.wchHyphenPres;
			pilsobj->pdur[iwchLim - 1] = pbrkinf->u.nonreq.durHyphen;
			plnobj->pdup[iwchLim - 1] = pbrkinf->u.nonreq.dupHyphen;
			if (pilsobj->pdurRight != NULL)
				pilsobj->pdurRight[iwchLim - 1] = 0;
			if (pilsobj->pdurLeft != NULL)
				pilsobj->pdurLeft[iwchLim - 1] = 0;

			if (pbrkinf->u.nonreq.wchPrev != 0)
				{
				pilsobj->pwchOrig[iwchLim - 2] = pbrkinf->u.nonreq.wchPrev;
				plnobj->pwch[iwchLim - 2] = pbrkinf->u.nonreq.wchPrev;

				if (pbrkinf->u.nonreq.gindPrev != 0)
					{
					plnobj->pgind[pbrkinf->u.nonreq.igindPrev] = pbrkinf->u.nonreq.gindPrev;
					pilsobj->pdurGind[pbrkinf->u.nonreq.igindPrev] = pbrkinf->u.nonreq.durPrev;
					plnobj->pdupGind[pbrkinf->u.nonreq.igindPrev] = pbrkinf->u.nonreq.dupPrev;
					if (pilsobj->pduGright != NULL)
						pilsobj->pduGright[pbrkinf->u.nonreq.igindPrev] = 0;
					}
				else
					{
					pilsobj->pdur[iwchLim - 2] = pbrkinf->u.nonreq.durPrev;
					plnobj->pdup[iwchLim - 2] = pbrkinf->u.nonreq.dupPrev;
					if (pilsobj->pdurRight != NULL)
						pilsobj->pdurRight[iwchLim - 2] = 0;
					if (pilsobj->pdurLeft != NULL)
						pilsobj->pdurLeft[iwchLim - 2] = 0;
					}
				}

			if (pbrkinf->u.nonreq.wchPrevPrev != 0)
				{
				pilsobj->pwchOrig[iwchLim - 3] = pbrkinf->u.nonreq.wchPrevPrev;
				plnobj->pwch[iwchLim - 3] = pbrkinf->u.nonreq.wchPrevPrev;
				if (pbrkinf->u.nonreq.gindPrevPrev != 0)
					{
					plnobj->pgind[pbrkinf->u.nonreq.igindPrevPrev] = pbrkinf->u.nonreq.gindPrevPrev;
					pilsobj->pdurGind[pbrkinf->u.nonreq.igindPrevPrev] = pbrkinf->u.nonreq.durPrevPrev;
					plnobj->pdupGind[pbrkinf->u.nonreq.igindPrevPrev] = pbrkinf->u.nonreq.dupPrevPrev;
					if (pilsobj->pduGright != NULL)
						pilsobj->pduGright[pbrkinf->u.nonreq.igindPrevPrev] = 0;
					}
				else
					{
					pilsobj->pdur[iwchLim - 3] = pbrkinf->u.nonreq.durPrevPrev;
					plnobj->pdup[iwchLim - 3] = pbrkinf->u.nonreq.dupPrevPrev;
					if (pilsobj->pdurRight != NULL)
						pilsobj->pdurRight[iwchLim - 3] = 0;
					if (pilsobj->pdurLeft != NULL)
						pilsobj->pdurLeft[iwchLim - 3] = 0;
					}
				}

			if (pbrkinf->u.nonreq.ddurDnodePrev != 0 || pbrkinf->u.nonreq.ddurDnodePrevPrev != 0)
				{
				lserr = LsdnResetWidthInPreviousDnodes(pilsobj->plsc, ptxtobj->plsdnUpNode, 
					pbrkinf->u.nonreq.ddurDnodePrev, pbrkinf->u.nonreq.ddurDnodePrevPrev);

				if (lserr != lserrNone) return lserr;
				}


			lserr = LsdnFInChildList(pilsobj->plsc, ptxtobj->plsdnUpNode, &fInChildList);
			Assert(lserr == lserrNone);
			
			if (!fInChildList)
				{
				lserr = LsdnSetHyphenated(pilsobj->plsc);
				Assert(lserr == lserrNone);
				}
			break;
		case brktOptBreak:
			break;
		default:
			NotReached();
			}
		}
	else
		{
		/* REVIEW sergeyge: we should return to the discussion of brkkind later.
			At the moment manager passes brkkindNext if during NextBreak object retrurned break 
			with dcp == 0 and break was snapped to the previous DNODE inside chunk
		*/
//		Assert(ptxtobj->iwchLim == ptxtobj->iwchFirst || ptxtobj->txtkind == txtkindEOL ||
//				brkkind == brkkindImposedAfter);
		}

	return lserrNone;			
}


/* F O R C E  B R E A K  T E X T */
/*----------------------------------------------------------------------------
    %%Function: ForceBreakText
    %%Contact: sergeyge

	Force break method.
	Breaks behind all characters in dobj, if they fit in line, or
		dobj consists of one character which is the first on the line,
	Breaks before the last character otherwise.
----------------------------------------------------------------------------*/
LSERR WINAPI ForceBreakText(PCLOCCHNK plocchnk, PCPOSICHNK pposichnk, PBRKOUT ptbo)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobjLast;
	long itxtobjLast;
	long dcpLast;
	OBJDIM objdim;
	BREAKINFO* pbrkinf;
	long igindLim;

	pilsobj = ((PTXTOBJ)plocchnk->plschnk[0].pdobj)->plnobj->pilsobj;

	memset(ptbo, 0, sizeof(*ptbo));

	ptbo->fSuccessful = fTrue;

	igindLim = 0;

	/* Outside means before for ForceBreak */
	if (pposichnk->ichnk == ichnkOutside)
		{
		itxtobjLast = 0;
		ptxtobjLast = (PTXTOBJ)plocchnk->plschnk[itxtobjLast].pdobj;
		dcpLast = 1;
		}
	else
		{
		itxtobjLast = pposichnk->ichnk;
		ptxtobjLast = (PTXTOBJ)plocchnk->plschnk[itxtobjLast].pdobj;
		Assert(ptxtobjLast->iwchFirst + pposichnk->dcp > 0);
		Assert(pposichnk->dcp > 0);
		dcpLast = pposichnk->dcp;

		if (pilsobj->fTruncatedBefore)
			{

			BOOL fInChildList;
	
			lserr = LsdnFInChildList(pilsobj->plsc, ptxtobjLast->plsdnUpNode, &fInChildList);
			Assert(lserr == lserrNone);
			
			if (!fInChildList)
				{
				dcpLast++;
				Assert(ptxtobjLast->iwchLim + 1 >= ptxtobjLast->iwchFirst + dcpLast);

				/* possible because if truncation returned dcp == 0, manager has reset it to previous dnode */
				if (ptxtobjLast->iwchLim + 1 == ptxtobjLast->iwchFirst + dcpLast)
					{
					itxtobjLast++;
					Assert(itxtobjLast < (long)plocchnk->clschnk);
					ptxtobjLast = (PTXTOBJ)plocchnk->plschnk[itxtobjLast].pdobj;
					dcpLast = 1;
					}
				}
			}
		}

	ptbo->posichnk.ichnk = itxtobjLast;

	lserr = LsdnGetObjDim(pilsobj->plsc, ptxtobjLast->plsdnUpNode, &ptbo->objdim);
	if (lserr != lserrNone) return lserr;

	if (plocchnk->lsfgi.fFirstOnLine && itxtobjLast == 0 && ptxtobjLast->iwchLim == ptxtobjLast->iwchFirst)
		{
		Assert(!(ptxtobjLast->txtf & txtfGlyphBased));
		ptbo->posichnk.dcp = 1;
		}
	else
		{
		if (ptxtobjLast->txtf & txtfGlyphBased)
			{
			Assert(ptxtobjLast->iwchLim > ptxtobjLast->iwchFirst);
			if (!plocchnk->lsfgi.fFirstOnLine || itxtobjLast > 0 || dcpLast > 1)
				{
				ptbo->posichnk.dcp = 0;
				if (dcpLast > 1)
					ptbo->posichnk.dcp = DcpAfterContextFromDcp(ptxtobjLast, dcpLast - 1);
				}
			else
				ptbo->posichnk.dcp =  DcpAfterContextFromDcp(ptxtobjLast, 1);

			igindLim = IgindFirstFromIwch(ptxtobjLast, ptxtobjLast->iwchFirst + ptbo->posichnk.dcp);

			lserr = CalcPartWidthsGlyphs(ptxtobjLast, ptbo->posichnk.dcp, &objdim, &ptbo->objdim.dur);
			if (lserr != lserrNone) return lserr;
			}
		else
			{
			if (!plocchnk->lsfgi.fFirstOnLine || itxtobjLast > 0 || dcpLast > 1)
				{
				ptbo->posichnk.dcp = dcpLast - 1;
				lserr = CalcPartWidths(ptxtobjLast, ptbo->posichnk.dcp, &objdim, &ptbo->objdim.dur);
				if (lserr != lserrNone) return lserr;
				}
			else
				{
				if (ptxtobjLast->iwchLim > ptxtobjLast->iwchFirst)
					{
					lserr = CalcPartWidths(ptxtobjLast, 1, &objdim, &ptbo->objdim.dur);
					}
				else
					{
					ptbo->objdim.dur = 0;
					}
				ptbo->posichnk.dcp =  1;
				}
			}
		}


/* Don't check that Heights of this dobj should be ignored, since in normal case, if there were spaces
	there was also break */

	lserr = GetPbrkinf(pilsobj, (PDOBJ)ptxtobjLast, brkkindForce, &pbrkinf);
	if (lserr != lserrNone) return lserr;

	pbrkinf->pdobj = (PDOBJ)ptxtobjLast;
	pbrkinf->brkkind = brkkindForce;
	pbrkinf->dcp = ptbo->posichnk.dcp;
	pbrkinf->u.normal.igindLim = igindLim;
	Assert(pbrkinf->brkt == brktNormal);
	Assert(pbrkinf->u.normal.durFix == 0);

	return lserrNone;
}


/* T R U N C A T E  T E X T */
/*----------------------------------------------------------------------------
    %%Function: TruncateText
    %%Contact: sergeyge

	Truncates text chunk
----------------------------------------------------------------------------*/
LSERR WINAPI TruncateText(PCLOCCHNK plocchnk, PPOSICHNK pposichnk)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj = NULL;
	long itxtobj;
	long iwchCur;
	long iwchFirst;
	long* pdur;
	long urColumnMax;
	long urTotal;
	OBJDIM objdim;
	BOOL fTruncateBefore;

	pilsobj = ((PTXTOBJ)plocchnk->plschnk[0].pdobj)->plnobj->pilsobj;

	urColumnMax = plocchnk->lsfgi.urColumnMax; 
	
	Assert(plocchnk->ppointUvLoc[0].u <= urColumnMax);

	for (itxtobj = plocchnk->clschnk - 1; plocchnk->ppointUvLoc[itxtobj].u > urColumnMax; itxtobj--);

	ptxtobj = (PTXTOBJ)plocchnk->plschnk[itxtobj].pdobj;
	lserr = LsdnGetObjDim(pilsobj->plsc, ptxtobj->plsdnUpNode, &objdim);
	if (lserr != lserrNone) return lserr;
	urTotal = plocchnk->ppointUvLoc[itxtobj].u + objdim.dur;

	Assert(urTotal > urColumnMax);

	if (ptxtobj->txtf & txtfGlyphBased)
		{
		TruncateGlyphBased(ptxtobj, itxtobj, urTotal, urColumnMax, pposichnk);
		return lserrNone;
		}

	iwchCur = ptxtobj->iwchLim;
	iwchFirst = ptxtobj->iwchFirst;

	pdur = pilsobj->pdur;
	while (urTotal > urColumnMax)
		{
		iwchCur--;
		urTotal -= pdur[iwchCur];
		}

	Assert(iwchCur >= iwchFirst);

/* REVIEW sergeyge--- extremely ugly condition, 
	and still slightly incompatible with Word.
	To make it more compatible txtkind should be checked against
	OptBreak, OptNonBreak, NonReqHyphen
	If we won't check it for OptBreak,..., we will have different break point for the Visi case

  Before fix for bug 227 we checked also that prev char is not space, but now it is not important.

*/
	if ((pilsobj->grpf & fTxtFCheckTruncateBefore) && iwchCur > 0 && 

		/* We enforce that there is no funny logic if EOL is truncation point */
		ptxtobj->txtkind != txtkindEOL &&
		
		 !(iwchCur == iwchFirst && itxtobj > 0 &&
		 ((PTXTOBJ)plocchnk->plschnk[itxtobj-1].pdobj)->txtkind != txtkindRegular &&
		 ((PTXTOBJ)plocchnk->plschnk[itxtobj-1].pdobj)->txtkind != txtkindHardHyphen &&
		 ((PTXTOBJ)plocchnk->plschnk[itxtobj-1].pdobj)->txtkind != txtkindYsrChar)
		
		)
		{
		BOOL fInChildList;

		lserr = LsdnFInChildList(pilsobj->plsc, ptxtobj->plsdnUpNode, &fInChildList);
		Assert(lserr == lserrNone);

		if (!fInChildList)
			{
			PLSRUN plsrunCur = plocchnk->plschnk[itxtobj].plsrun;
			LSCP cpCur = plocchnk->plschnk[itxtobj].cpFirst + (iwchCur - iwchFirst);
			long durCur = 0;
			PLSRUN plsrunPrev = NULL;
			WCHAR wchPrev = 0;
			LSCP cpPrev = -1;
			long durPrev = 0;

			if (iwchCur > iwchFirst)
				{
				plsrunPrev = plsrunCur;
				wchPrev = pilsobj->pwchOrig[iwchCur - 1];
				durPrev = pilsobj->pdur[iwchCur - 1];
				cpPrev = cpCur - 1;
				}
			else if (itxtobj > 0)
				{
				PTXTOBJ ptxtobjPrev = (PTXTOBJ)plocchnk->plschnk[itxtobj - 1].pdobj;
				long iwchPrev = ptxtobjPrev->iwchLim - 1;
				plsrunPrev= plocchnk->plschnk[itxtobj - 1].plsrun;
				wchPrev = pilsobj->pwchOrig[iwchPrev];
				durPrev = pilsobj->pdur[iwchPrev];
				cpPrev = plocchnk->plschnk[itxtobj-1].cpFirst + (iwchPrev - ptxtobjPrev->iwchFirst);
				}

	/* REVIEW sergeyge: dangerous change to fix bug 399. It looks correct, but might trigger some other
		incompatibility.
	*/
			durCur = pilsobj->pdur[iwchCur];
			if (pilsobj->pdurRight != NULL)
				durCur -= pilsobj->pdurRight[iwchCur];

			lserr = (*pilsobj->plscbk->pfnFTruncateBefore)(pilsobj->pols,
						plsrunCur, cpCur, pilsobj->pwchOrig[iwchCur], durCur,
						plsrunPrev, cpPrev, wchPrev, durPrev,
						urTotal + durCur - urColumnMax,	&fTruncateBefore);
			if (lserr != lserrNone) return lserr;

			if (fTruncateBefore && iwchCur > 0 && pdur[iwchCur-1] > 0)
				{
				iwchCur--;
				pilsobj->fTruncatedBefore = fTrue;
				}
			}
		}

	pposichnk->ichnk = itxtobj;
	pposichnk->dcp = iwchCur - iwchFirst + 1;

	return lserrNone;
}

/* internal functions implementation */

static void TruncateGlyphBased(PTXTOBJ ptxtobj, long itxtobj, long urTotal, long urColumnMax,
													PPOSICHNK pposichnk)
{
	PILSOBJ pilsobj;
	long iwchFirst;
	long iwchCur;
	long igindCur;
	long igindFirst;
	long* pdurGind;

	pilsobj= ptxtobj->plnobj->pilsobj;

	iwchFirst = ptxtobj->iwchFirst;
	
	igindCur = ptxtobj->igindLim;
	igindFirst = ptxtobj->igindFirst;

	pdurGind = pilsobj->pdurGind;
	while (urTotal > urColumnMax)
		{
		igindCur--;
		urTotal -= pdurGind[igindCur];
		}

	Assert(igindCur >= igindFirst);

	iwchCur = IwchFirstFromIgind(ptxtobj, igindCur);

	pposichnk->ichnk = itxtobj;
	pposichnk->dcp = iwchCur - iwchFirst + 1;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\lstfset.c ===
#include "lsidefs.h"
#include "lstfset.h"

//    %%Function:	LsPointUV2FromPointUV1
//    %%Contact:	victork
//
LSERR WINAPI LsPointUV2FromPointUV1(LSTFLOW lstflow1,	 		/* IN: text flow 1 */
									PCPOINTUV pptStart,	 		/* IN: start input point (TF1) */
									PCPOINTUV pptEnd,			/* IN: end input point (TF1) */
									LSTFLOW lstflow2,	 		/* IN: text flow 2 */
									PPOINTUV pptOut)			/* OUT: vector in TF2 */


{

Assert(lstflowES == 0);
Assert(lstflowEN == 1);
Assert(lstflowSE == 2);
Assert(lstflowSW == 3);
Assert(lstflowWS == 4);
Assert(lstflowWN == 5);
Assert(lstflowNE == 6);
Assert(lstflowNW == 7);

// The three bits that constitute lstflow happens to have well defined meanings.
//
// Middle bit: on for vertical writing, off for horizontal.
// First (low value) bit: "on" means v-axis points right or down (positive).
// Third bit: "off" means u-axis points right or down (positive).
//
// So the algorithm of covertion (u1,v1) in lstflow1 to (u2,v2) in lstflow2 is:
// 
// fHorizontalOrVertical1 = lstflow1 & fUVertical;
// fUPositive1 = !(lstflow1 & fUDirection);
// fVPositive1 = lstflow1 & fVDirection;
// fHorizontalOrVertical2 = lstflow2 & fUVertical;
// fUPositive2 = !(lstflow2 & fUDirection);
// fVPositive2 = lstflow2 & fVDirection;
//
// 
// if (fHorizontalOrVertical1 == fHorizontalOrVertical2)
//  	{
//		if (fUPositive1 == fUPositive2)
//			{
//			u2 = u1;
//			}
//		else
//			{
//			u2 = -u1;
//			}
//		if (fVPositive1 == fVPositive2)
//			{
//			v2 = v1;
//			}
//		else
//			{
//			v2 = -v1;
//			}
//	 	}
// else
//		{
//		if (fUPositive1 == fVPositive2)
//			{
//			u2 = v1;
//			}
//		else
//			{
//			u2 = -v1;
//			}
//		if (fVPositive1 == fUPositive2)
//			{
//			v2 = u1;
//			}
//		else
//			{
//			v2 = -u1;
//			}
//		}
//
// Actual code is a little bit more compact.
// 
// A hack (?): (!a == !b) is used instead of (((a==0) && (b==0)) || ((a!=0) && (b!=0)))

if ((lstflow1 ^ lstflow2) & fUVertical)				// one is vertical, another is horizontal
	{
	pptOut->u = (pptEnd->v - pptStart->v) * 
							((!(lstflow2 & fUDirection) == !(lstflow1 & fVDirection)) ? -1 : 1);
	pptOut->v = (pptEnd->u - pptStart->u) * 
							((!(lstflow2 & fVDirection) == !(lstflow1 & fUDirection)) ? -1 : 1);
	}
else
	{
	pptOut->u = (pptEnd->u - pptStart->u) * 
							(((lstflow1 ^ lstflow2) & fUDirection) ? -1 : 1);
	pptOut->v = (pptEnd->v - pptStart->v) * 
							(((lstflow1 ^ lstflow2) & fVDirection) ? -1 : 1);
	}

	return lserrNone;
}


//    %%Function:	LsPointXYFromPointUV
//    %%Contact:	victork
//
/*  returns (x,y) point given (x,y) point and (u,v) vector */

LSERR WINAPI LsPointXYFromPointUV(const POINT* pptXY, 		/* IN: input point (x,y) */
							LSTFLOW lstflow,	 	/* IN: text flow for */
							PCPOINTUV pptUV,		/* IN: vector in (u,v) */
							POINT* pptXYOut) 		/* OUT: point (x,y) */

{
	switch (lstflow)
		{
		case lstflowES:									/* latin */
			pptXYOut->x = pptXY->x + pptUV->u;
			pptXYOut->y = pptXY->y - pptUV->v;
			return lserrNone;
		case lstflowSW:									/* vertical FE */
			pptXYOut->x = pptXY->x + pptUV->v;
			pptXYOut->y = pptXY->y + pptUV->u;
			return lserrNone;
		case lstflowWS:									/* BiDi */
			pptXYOut->x = pptXY->x - pptUV->u;
			pptXYOut->y = pptXY->y - pptUV->v;
			return lserrNone;
		case lstflowEN:
			pptXYOut->x = pptXY->x + pptUV->u;
			pptXYOut->y = pptXY->y + pptUV->v;
			return lserrNone;
		case lstflowSE:
			pptXYOut->x = pptXY->x - pptUV->v;
			pptXYOut->y = pptXY->y + pptUV->u;
			return lserrNone;
		case lstflowWN:
			pptXYOut->x = pptXY->x - pptUV->u;
			pptXYOut->y = pptXY->y + pptUV->v;
			return lserrNone;
		case lstflowNE:
			pptXYOut->x = pptXY->x - pptUV->v;
			pptXYOut->y = pptXY->y - pptUV->u;
			return lserrNone;
		case lstflowNW:
			pptXYOut->x = pptXY->x + pptUV->v;
			pptXYOut->y = pptXY->y - pptUV->u;
			return lserrNone;
		default:
			NotReached();
			return lserrInvalidParameter;
		}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\lssubset.c ===
/* LSSUBSET.C                  */
#include "lssubset.h"
#include "lsidefs.h"
#include "lssubl.h"
#include "sublutil.h"

/* L S S B  G E T  O B J  D I M  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LssbGetObjDimSubline
    %%Contact: igorzv

Parameters:
	plssubl				-	(IN) ptr to subline context 
	plstflow			-	(OUT) subline's lstflow
	pobjdim				-	(OUT) dimensions of subline

----------------------------------------------------------------------------*/

LSERR WINAPI LssbGetObjDimSubline(PLSSUBL plssubl, LSTFLOW* plstflow, POBJDIM pobjdim)			
	{
	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;
	if (plstflow == NULL) return lserrInvalidParameter;
	if (pobjdim == NULL) return lserrInvalidParameter;

	*plstflow = plssubl->lstflow;

	return GetObjDimSublineCore(plssubl, pobjdim);
	}
							
/* L S S B  G E T  D U P  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LssbGetDupSubline
    %%Contact: igorzv

Parameters:
	plssubl				-	(IN) ptr to subline context 
	plstflow			-	(OUT) subline's lstflow
	pdup				-	(OUT) width of subline

----------------------------------------------------------------------------*/
LSERR WINAPI LssbGetDupSubline(PLSSUBL plssubl,	LSTFLOW* plstflow, long* pdup)	
	{

	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;
	if (plstflow == NULL) return lserrInvalidParameter;
	if (pdup == NULL) return lserrInvalidParameter;

	*plstflow = plssubl->lstflow;

	return GetDupSublineCore(plssubl, pdup);
	}

/* L S S B  F  D O N E  P R E S  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LssbFDonePresSubline
    %%Contact: igorzv

Parameters:
	plssubl				-	(IN) ptr to subline context 
	pfDonePresSubline	-	(OUT) is presentation coordinates are already calculated 

----------------------------------------------------------------------------*/
LSERR WINAPI LssbFDonePresSubline(PLSSUBL plssubl, BOOL* pfDonePresSubline)		
	{

	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;
	if (pfDonePresSubline == NULL) return lserrInvalidParameter;

	*pfDonePresSubline = !plssubl->fDupInvalid;

	return lserrNone;
	}

/* L S S B  F  D O N E  D I S P L A Y*/
/*----------------------------------------------------------------------------
    %%Function: LssbFDoneDisplay
    %%Contact: igorzv

Parameters:
	plssubl				-	(IN) ptr to subline context 
	pfDonePresSubline	-	(OUT) is subline has been accepted for display with 
								  upper subline

----------------------------------------------------------------------------*/

LSERR WINAPI LssbFDoneDisplay(PLSSUBL plssubl, BOOL* pfDoneDisplay)	
	{

	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;
	if (pfDoneDisplay == NULL) return lserrInvalidParameter;

	*pfDoneDisplay = plssubl->fAcceptedForDisplay;

	return lserrNone;
	}

/* L S S B  G E T  P L S R U N S  F R O M  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LssbGetPlsrunsFromSubline
    %%Contact: igorzv

Parameters:
	plssubl				-	(IN) ptr to subline context 
	cDnodes				-	(IN) number of dnodes in subline
	rgplsrun			-	(OUT) array of plsrun's

----------------------------------------------------------------------------*/

LSERR WINAPI LssbGetPlsrunsFromSubline(PLSSUBL plssubl,	DWORD cDnodes, PLSRUN* rgplsrun)	
	{

	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;
	if (rgplsrun == NULL) return lserrInvalidParameter;

	return GetPlsrunFromSublineCore(plssubl, cDnodes, rgplsrun);
	}

/* L S S B  G E T  N U M B E R  D N O D E S  I N  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LssbGetNumberDnodesInSubline
    %%Contact: igorzv

Parameters:
	plssubl				-	(IN) ptr to subline context 
	pcDnodes			-	(OUT) number of dnodes in subline

----------------------------------------------------------------------------*/
LSERR WINAPI LssbGetNumberDnodesInSubline(PLSSUBL plssubl, DWORD* pcDnodes)	
	{

	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;
	if (pcDnodes == NULL) return lserrInvalidParameter;

	return GetNumberDnodesCore(plssubl, pcDnodes);
	}

/* L S S B  G E T  V I S I B L E  D C P  I N  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LssbGetVisibleDcpInSubline
    %%Contact: igorzv

Parameters:
	plssubl				-	(IN) ptr to subline context 
	pdcp				-	(OUT) number of characters

----------------------------------------------------------------------------*/
LSERR WINAPI LssbGetVisibleDcpInSubline(PLSSUBL plssubl, LSDCP* pdcp)	
	{

	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;
	if (pdcp == NULL) return lserrInvalidParameter;

	return GetVisibleDcpInSublineCore(plssubl, pdcp);
	}

/* L S S B  G E T  G E T  D U R  T R A I L  I N  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LssbGetDurTrailInSubline
    %%Contact: igorzv

Parameters:
	plssubl				-	(IN) ptr to subline context 
	pdurTrail			-	(OUT) width of trailing area in subline

----------------------------------------------------------------------------*/
LSERR WINAPI LssbGetDurTrailInSubline(PLSSUBL plssubl, long* pdurTrail)
	{

	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;
	if (pdurTrail == NULL) return lserrInvalidParameter;

	return GetDurTrailInSubline(plssubl, pdurTrail);
	}

/* L S S B  G E T  G E T  D U R  T R A I L  W I T H  P E N S  I N  S U B L I N E*/
/*----------------------------------------------------------------------------
    %%Function: LssbGetDurTrailWithPensInSubline
    %%Contact: igorzv

Parameters:
	plssubl				-	(IN) ptr to subline context 
	pdurTrail			-	(OUT) width of trailing area in subline

----------------------------------------------------------------------------*/
LSERR WINAPI LssbGetDurTrailWithPensInSubline(PLSSUBL plssubl, long* pdurTrail)
	{

	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;
	if (pdurTrail == NULL) return lserrInvalidParameter;

	return GetDurTrailWithPensInSubline(plssubl, pdurTrail);
	}


/* L S S B  F  I S  S U B L I N E  E M P T Y*/
/*----------------------------------------------------------------------------
    %%Function: LssbFIsSublineEmpty
    %%Contact: igorzv

Parameters:
	plssubl				-	(IN) ptr to subline context 
	pfEmpty				-	(OUT) is this subline empty

----------------------------------------------------------------------------*/
LSERR WINAPI LssbFIsSublineEmpty(PLSSUBL plssubl, BOOL*  pfEmpty)	
								
	{
	if (!FIsLSSUBL(plssubl)) return lserrInvalidParameter;
	if (pfEmpty == NULL) return lserrInvalidParameter;

	return FIsSublineEmpty(plssubl, pfEmpty);
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\lstxtbrk.c ===
#include <limits.h>
#include "lsmem.h"
#include "lstxtbrk.h"
#include "lstxtbrs.h"
#include "lstxtmap.h"
#include "lsdntext.h"
#include "brko.h"
#include "locchnk.h"
#include "lschp.h"
#include "posichnk.h"
#include "objdim.h"
#include "lshyph.h"
#include "lskysr.h"
#include "lstxtffi.h"
#include "txtils.h"
#include "txtln.h"
#include "txtobj.h"

#define FWrapTrailingSpaces(pilsobj, ptxtobj, fInChildList) \
		(lserr = LsdnFInChildList((pilsobj)->plsc, (ptxtobj)->plsdnUpNode, &(fInChildList)), \
		Assert(lserr == lserrNone), \
		(fInChildList) || ((pilsobj)->grpf & fTxtWrapTrailingSpaces))

#define FRegularBreakableBeforeDobj(ptxtobj) \
		((ptxtobj)->txtkind == txtkindRegular || (ptxtobj)->txtkind == txtkindYsrChar || \
		 (ptxtobj)->txtkind == txtkindSpecSpace || (ptxtobj)->txtkind == txtkindHardHyphen)
#define FRegularBreakableAfterDobj(ptxtobj) \
		((ptxtobj)->txtkind == txtkindRegular || (ptxtobj)->txtkind == txtkindYsrChar || \
		 (ptxtobj)->txtkind == txtkindSpecSpace)
/* Internal Functions prototypes */
static BOOL FindPrevSpace(PCLOCCHNK plocchnk, long itxtobjCur, long iwchCur,
										long* pitxtobjSpace, long* piwchSpace);
static BOOL FindNextSpace(PCLOCCHNK plocchnk, long itxtobjCur, long iwchCur,
										long* pitxtobjSpace, long* piwchSpace);
static LSERR TryPrevBreakFindYsr(PCLOCCHNK plocchnk, long itxtobjCur, long iwchCur,
								long itxtobjSpace, long iwchSpace,
								BOOL* pfBroken, BOOL* pfFoundYsr, long* pitxtobjYsr, PBRKOUT ptbo);
static LSERR TryNextBreakFindYsr(PCLOCCHNK plocchnk, long itxtobjCur, long iwchCur,
								long itxtobjSpace, long iwchSpace,
								BOOL* pfBroken, PBRKOUT ptbo);
static LSERR TryBreakWithHyphen(PCLOCCHNK plocchnk, long itxtobjCur, long iwchCur,
						BOOL fSpaceFound, long itxtobjSpace, long iwchSpace,
						BOOL fFoundYsr, long itxtobjYsr, BOOL* pfBroken, PBRKOUT ptbo);
static LSERR TryBreakAtSpace(PCLOCCHNK plocchnk, PCPOSICHNK pposichnk,long itxtobjSpace, long iwchSpace, 
					BRKKIND brkkind, BOOL* pfBroken, long* pitxtobjCurNew, long* piwchCurNew, PBRKOUT ptbo);
static LSERR TryBreakAtSpaceWrap(PCLOCCHNK plocchnk, PCPOSICHNK pposichnk,
								 long itxtobjSpace, long iwchSpace, BRKKIND brkkind,
								 BOOL* pfBroken, long* pitxtobjCurNew, long* piwchCurNew, PBRKOUT ptbo);
static LSERR TryBreakAtSpaceNormal(PCLOCCHNK plocchnk, long itxtobjSpace, long iwchSpace, BRKKIND brkkind,
								 BOOL* pfBroken, long* pitxtobjCurNew, long* piwchCurNew, PBRKOUT ptbo);
static LSERR TryBreakAcrossSpaces(PCLOCCHNK plocchnk,
						BOOL fBeforeFound, long itxtobjBefore, long iwchBefore,
						BOOL fAfterFound, long itxtobjAfter, long iwchAfter, BRKKIND brkkind,
						BOOL* pfBroken, PBRKOUT ptbo);
static LSERR TryPrevBreakRegular(PCLOCCHNK plocchnk, long itxtobj, long iwchSpace, long iwchCur,
																BOOL* pfBroken, PBRKOUT ptbo);
static LSERR TryNextBreakRegular(PCLOCCHNK plocchnk, long itxtobj, long iwchSpace, long iwchCur,
																BOOL* pfBroken, PBRKOUT ptbo);
static LSERR CheckBreakAtLastChar(PCLOCCHNK pclocchnk, BRKCLS brkclsLeading, long iwch, long itxtobj,
																BOOL* pfBroken);
static LSERR TryBreakAtHardHyphen(PCLOCCHNK plocchnk, long itxtobj, long iwch, BRKKIND brkkind,
																BOOL* pfBroken, PBRKOUT ptbo);
static LSERR TryBreakAtOptBreak(PCLOCCHNK plocchnk, long itxtobj, BRKKIND brkkind,
																BOOL* pfBroken, PBRKOUT ptbo);
static LSERR TryBreakAtEOL(PCLOCCHNK plocchnk, long itxtobj, BRKKIND brkkind, BOOL* pfBroken, PBRKOUT ptbo);
static LSERR TryBreakAtNonReqHyphen(PCLOCCHNK plocchnk, long itxtobj, BRKKIND brkkind, 
																BOOL* pfBroken, PBRKOUT ptbo);
static LSERR TryBreakAfterChunk(PCLOCCHNK plocchnk, BRKCOND brkcond, BOOL* pfBroken, PBRKOUT ptbo);
static LSERR TryBreakBeforeChunk(PCLOCCHNK plocchnk, BRKCOND brkcond, BOOL* pfBroken, PBRKOUT ptbo);
static LSERR CanBreakBeforeText(PCLOCCHNK plocchnk, BRKCOND* pbrktxt);
static LSERR CanBreakAfterText(PCLOCCHNK plocchnk, BOOL fNonSpaceFound, long itxtobjBefore,
																	long iwchBefore, BRKCOND* pbrktxt);
static LSERR FillPtboPbrkinf(PCLOCCHNK plocchnk, long itxtobj, long iwch, 
										/*long itxtobjBeforeTrail,*/ long iwchBeforeTrail, BRKKIND brkkind,
										BREAKINFO** ppbrkinf, PBRKOUT ptbo);

/* Export Functions Implementation */


/* F I N D  P R E V  B R E A K  T E X T */
/*----------------------------------------------------------------------------
    %%Function: FindPrevBreakTxt
    %%Contact: sergeyge

	Breaks the line in general case.

	Strategy:
	in loop while break was not found:
		--Finds the last space.
		--Checks for break opportunity behind last space. If it exists, performs break.
		--If there is no such an opportunity tries to hyphenate if needed.
		--Tries to breaks at space, if other possibilies did not work
----------------------------------------------------------------------------*/
LSERR WINAPI FindPrevBreakText(PCLOCCHNK plocchnk, PCPOSICHNK pposichnk, BRKCOND brkcondAfter, PBRKOUT ptbo)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	long iwchFirst;
	long itxtobjCur = 0;				/* Initialization to keep compiler satisfied */
	PTXTOBJ ptxtobjCur;
	long iwchCur = 0;					/* Initialization to keep compiler satisfied */	/* Absolute index of current char in rgwch */
	long itxtobjSpace;
	long iwchSpace;						/* Absolute index of last space in rgwch */
	long itxtobjYsr;
	BOOL fSpaceFound;
	BOOL fBroken;
	BOOL fFoundYsr;
	long itxtobjCurNew;
	long iwchCurNew;
	BOOL fInChildList;

	Assert(plocchnk->clschnk > 0);
	pilsobj = ((PTXTOBJ)plocchnk->plschnk[0].pdobj)->plnobj->pilsobj;
	iwchFirst = ((PTXTOBJ)plocchnk->plschnk[0].pdobj)->iwchFirst;
	fBroken = fFalse;

	if (pposichnk->ichnk == ichnkOutside)
		{
/* Check break after chunk. If break is impossible, make sure that it is not considered any longer */
		lserr = TryBreakAfterChunk(plocchnk, brkcondAfter, &fBroken, ptbo);
		if (lserr != lserrNone) return lserr;

		if (!fBroken)
			{
			itxtobjCur = plocchnk->clschnk-1;
			ptxtobjCur = (PTXTOBJ)plocchnk->plschnk[itxtobjCur].pdobj;
			iwchCur = ptxtobjCur->iwchFirst + plocchnk->plschnk[itxtobjCur].dcp  - 1;
			if (iwchCur < ptxtobjCur->iwchFirst)
				itxtobjCur--;

			Assert(itxtobjCur >= 0 || iwchCur < iwchFirst);

			if (itxtobjCur >= 0)
				FindNonSpaceBefore(plocchnk->plschnk, itxtobjCur, iwchCur, &itxtobjCur, &iwchCur);
			/* if not found, we are safe because iwchCur will be < iwchFirst in this case */

			}
		}
	else
		{
		itxtobjCur = pposichnk->ichnk;
		ptxtobjCur = (PTXTOBJ)plocchnk->plschnk[itxtobjCur].pdobj;
		Assert(ptxtobjCur->iwchFirst + pposichnk->dcp > 0);
		iwchCur = ptxtobjCur->iwchFirst + pposichnk->dcp - 1;

		if (ptxtobjCur->txtkind == txtkindEOL)
			{
			lserr = TryBreakAtEOL(plocchnk, itxtobjCur, brkkindPrev, &fBroken, ptbo);
			if (lserr != lserrNone) return lserr;
			}
		else if (!FRegularBreakableAfterDobj(ptxtobjCur))
			{
			/* It won't be done after FindPrevSpace for non-regular DOBJ's, because they might overwrite
				don't break before space logic
			*/
			iwchCur--;
			if (iwchCur < ptxtobjCur->iwchFirst)
				itxtobjCur--;
			}

		}

	while (!fBroken && iwchCur >= iwchFirst)
		{

		/* it is important to start search for space before subtructing 1,
			since space might have been a truncation point

			it is not very beautiful that iwchCur is wrong for ichnkOutside, but
			fortunately it still works correctly with FindPrevSpace.
		*/

		fSpaceFound = FindPrevSpace(plocchnk, itxtobjCur, iwchCur, &itxtobjSpace, &iwchSpace);

		/* now index of the current wchar should be decreased by 1 in both starting situation(obviously)
			and following iterations (because break cannot happen before space),
			but not for non-Regular DOBJ's.
			At starting situation it has already been done. In following iterations Hard/OptBreak's should
			produce hard-coded break opportunity
		 */
		Assert(itxtobjCur >= 0);
		ptxtobjCur = (PTXTOBJ)plocchnk->plschnk[itxtobjCur].pdobj;
		if (FRegularBreakableAfterDobj(ptxtobjCur))
			{
			iwchCur--;
			if (iwchCur < ptxtobjCur->iwchFirst && itxtobjCur > 0)
				itxtobjCur--;
			}

	/* Check if there is break opportunity behind last space */
		lserr = TryPrevBreakFindYsr(plocchnk, itxtobjCur, iwchCur, itxtobjSpace, iwchSpace,
									 &fBroken, &fFoundYsr, &itxtobjYsr, ptbo);
		if (lserr != lserrNone) return lserr;

		if (!fBroken)
			{
			if ((pilsobj->grpf & fTxtDoHyphenation) && iwchCur > iwchSpace)
				{
				lserr = LsdnFInChildList(ptxtobjCur->plnobj->pilsobj->plsc, ptxtobjCur->plsdnUpNode, &fInChildList);
				if (lserr != lserrNone) return lserr;
				if (!fInChildList)
					{
					lserr = TryBreakWithHyphen(plocchnk, itxtobjCur, iwchCur, fSpaceFound, itxtobjSpace, iwchSpace,
												fFoundYsr, itxtobjYsr, &fBroken, ptbo);
					if (lserr != lserrNone) return lserr;
					}
				}
			if (!fBroken)
				{
				if (fSpaceFound)
					{
					lserr = TryBreakAtSpace(plocchnk, pposichnk, itxtobjSpace, iwchSpace, brkkindPrev,
								 &fBroken, &itxtobjCurNew, &iwchCurNew, ptbo);
					if (lserr != lserrNone) return lserr;
		
					iwchCur = iwchCurNew;
					itxtobjCur = itxtobjCurNew;
					}
				else
					{
					iwchCur = iwchFirst - 1;
					}
				}
			}
		}

	if (!fBroken)
		{
		memset(ptbo, 0, sizeof (*ptbo));
		Assert(ptbo->fSuccessful == fFalse);
	/* Addition for the new break logic---brkcond is added as input/output*/
		ptbo->brkcond = brkcondCan;
		if (pilsobj->grpf & fTxtApplyBreakingRules)
			{
			lserr = CanBreakBeforeText(plocchnk, &ptbo->brkcond);
			if (lserr != lserrNone) return lserr;
			}
	/* end of new breaking logic */
		}

	return lserrNone;
}

/* F I N D  N E X T  B R E A K  T E X T */
/*----------------------------------------------------------------------------
    %%Function: FindNextBreakTxt
    %%Contact: sergeyge

	Breaks the line in general case.

	Strategy:
	in loop while break was not found:
		--Finds the next space.
		--Checks for break opportunity before found space. If it exists, performs break.
		--Tries to breaks at space, if other possibilies did not work
----------------------------------------------------------------------------*/
LSERR WINAPI FindNextBreakText(PCLOCCHNK plocchnk, PCPOSICHNK pposichnk, BRKCOND brkcondBefore, PBRKOUT ptbo)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	long iwchLast;
	long itxtobjCur = 0;				/* Initialization to keep compiler satisfied */
	PTXTOBJ ptxtobjCur;					/* Initialization to keep compiler satisfied */
	long iwchCur = 0;						/* Absolute index of current char in rgwch */
	long itxtobjSpace;
	long iwchSpace;						/* Absolute index of last space in rgwch */
	BOOL fSpaceFound;
	BOOL fBroken;
	long itxtobjCurNew;
	long iwchCurNew;
	BOOL fInChildList;

	BOOL fNonSpaceFound;
	long itxtobjBefore;
	long iwchBefore;
	BREAKINFO* pbrkinf;
	

	Assert(plocchnk->clschnk > 0);
	pilsobj = ((PTXTOBJ)plocchnk->plschnk[0].pdobj)->plnobj->pilsobj;
	iwchLast = ((PTXTOBJ)plocchnk->plschnk[plocchnk->clschnk - 1].pdobj)->iwchLim - 1;
	fBroken = fFalse;

	if (pposichnk->ichnk == ichnkOutside)
		{
/* Check break after chunk. If break is impossible, make sure that it is not considered any longer */
		lserr = TryBreakBeforeChunk(plocchnk, brkcondBefore, &fBroken, ptbo);
		if (lserr != lserrNone) return lserr;
		if (!fBroken)
			{
			itxtobjCur = 0;
			ptxtobjCur = (PTXTOBJ)plocchnk->plschnk[0].pdobj;
			iwchCur = ptxtobjCur->iwchFirst;
			/* Hack: In the case of NRH or alike satisfy condition of the while loop below */
			if (ptxtobjCur->iwchLim == ptxtobjCur->iwchFirst)
				iwchCur--;
			}
		}
	else
		{
		itxtobjCur = pposichnk->ichnk;
		ptxtobjCur = (PTXTOBJ)plocchnk->plschnk[itxtobjCur].pdobj;
		Assert(ptxtobjCur->iwchFirst + pposichnk->dcp > 0);
		iwchCur = ptxtobjCur->iwchFirst + pposichnk->dcp - 1;

	/* 	if truncation point was space, find first next opportunity after spaces	*/
		if (!FWrapTrailingSpaces(pilsobj, ptxtobjCur, fInChildList))
			{
			FindNonSpaceAfter(plocchnk->plschnk, plocchnk->clschnk,
												 itxtobjCur, iwchCur, &itxtobjCur, &iwchCur);
			ptxtobjCur = (PTXTOBJ)plocchnk->plschnk[itxtobjCur].pdobj;
			}

		/* Hack: In the case of NRH or alike satisfy condition of the while loop below */
		if (ptxtobjCur->iwchLim == ptxtobjCur->iwchFirst)
			iwchCur = ptxtobjCur->iwchFirst - 1;
		}

	while (!fBroken && iwchCur <= iwchLast)
		{

		fSpaceFound = FindNextSpace(plocchnk, itxtobjCur, iwchCur, &itxtobjSpace, &iwchSpace);

	/* Check if there is break opportunity before next space */
		lserr = TryNextBreakFindYsr(plocchnk, itxtobjCur, iwchCur, itxtobjSpace, iwchSpace,
								 &fBroken, ptbo);
		if (lserr != lserrNone) return lserr;

		if (!fBroken)
			{
			if (fSpaceFound)
				{
				lserr = TryBreakAtSpace(plocchnk, pposichnk, itxtobjSpace, iwchSpace, brkkindNext,
							 &fBroken, &itxtobjCurNew, &iwchCurNew, ptbo);
				if (lserr != lserrNone) return lserr;

				if (!fBroken)
					{
					iwchCur = iwchCurNew;
					itxtobjCur = itxtobjCurNew;
					Assert(itxtobjCur >= 0 && itxtobjCur < (long)plocchnk->clschnk);
					ptxtobjCur = (PTXTOBJ)plocchnk->plschnk[itxtobjCur].pdobj;
					/* Hack: In the case of NRH or alike satisfy condition of the while loop */
					if (ptxtobjCur->iwchLim == ptxtobjCur->iwchFirst)
						iwchCur--;
					}
				}
			else
				{
				iwchCur = iwchLast + 1;
				}
			}
		}

	if (!fBroken)
		{
		memset(ptbo, 0, sizeof (*ptbo));
		Assert(ptbo->fSuccessful == fFalse);
		ptbo->brkcond = brkcondCan;

		Assert(plocchnk->clschnk > 0);
		itxtobjCur = plocchnk->clschnk - 1;
		ptxtobjCur = (PTXTOBJ)plocchnk->plschnk[itxtobjCur].pdobj;
		iwchCur = ptxtobjCur->iwchLim - 1;
		fNonSpaceFound = FindNonSpaceBefore(plocchnk->plschnk, itxtobjCur, iwchCur,
																	&itxtobjBefore, &iwchBefore);
		if (pilsobj->grpf & fTxtApplyBreakingRules)
			{
			lserr = CanBreakAfterText(plocchnk, fNonSpaceFound, itxtobjBefore, iwchBefore, &ptbo->brkcond);
			if (lserr != lserrNone) return lserr;
			if (iwchBefore != iwchCur && ptbo->brkcond == brkcondCan)
				ptbo->brkcond = brkcondPlease;
			}
		if (ptbo->brkcond != brkcondNever)
			{

			/* if following Assert fails, iwchCur is calculated incorrectly a few lines above,
				but it must be correct, because NonRecHyphen/... would have already caused break
			*/
			Assert(ptxtobjCur->iwchLim > ptxtobjCur->iwchFirst);
														
			lserr = FillPtboPbrkinf(plocchnk, itxtobjCur, iwchCur, /*itxtobjBefore,*/ iwchBefore,
													brkkindNext, &pbrkinf, ptbo);
			if (lserr != lserrNone) return lserr;
			ptbo->fSuccessful = fFalse;
		
		/* next if statement with comment is copied from TryBreakNextNormal() with replacement of
			iwchCur - 1 by iwchCur */
		/* fModWidthSpace can be at the last char here only iff fWrapAllSpaces;
			if we touch balanced space here, the logic of GetMinCompressAmount should be rethinked!*/
			if (pilsobj->pdurRight != NULL && pilsobj->pdurRight[iwchCur] != 0 &&
														!pilsobj->ptxtinf[iwchCur].fModWidthSpace)
				{
				pbrkinf->u.normal.durFix = - pilsobj->pdurRight[iwchCur];
				ptbo->objdim.dur -= pilsobj->pdurRight[iwchCur];
				}

			}
		}

	return lserrNone;
}


/* Internal Functions Implementation */

/* F I N D  P R E V  S P A C E */
/*----------------------------------------------------------------------------
    %%Function: FindPrevSpace
    %%Contact: sergeyge

	Returns TRUE if there is a space and FALSE otherwise.
	Reports the index of the dobj containing last space
	and space's index in rgwchOrig array.
----------------------------------------------------------------------------*/
static BOOL FindPrevSpace(PCLOCCHNK plocchnk, long itxtobjCur, long iwchCur,
										long* pitxtobjSpace, long* piwchSpace)
{

	PILSOBJ pilsobj;
	BOOL fSpaceFound;
	PTXTOBJ ptxtobjCur;
	long* rgwSpaces;
	long iwSpacesCur;

	ptxtobjCur = (PTXTOBJ)plocchnk->plschnk[itxtobjCur].pdobj;
	pilsobj = ptxtobjCur->plnobj->pilsobj;
	rgwSpaces = pilsobj->pwSpaces;

	fSpaceFound = fFalse;

/* In the case fWrapAllSpaces space is treated as a regular character */

	if (!(pilsobj->grpf & fTxtWrapAllSpaces))
		{

		if (ptxtobjCur->txtkind == txtkindRegular)
			{
			iwSpacesCur = ptxtobjCur->u.reg.iwSpacesLim - 1;
			while (iwSpacesCur >= ptxtobjCur->u.reg.iwSpacesFirst &&
	 /* current character might be space, if text chunk is not last on the line */
						 rgwSpaces[iwSpacesCur] > iwchCur)
				{
				iwSpacesCur--;
				}

			if (ptxtobjCur->txtf & txtfGlyphBased)
				{
				while (iwSpacesCur >= ptxtobjCur->u.reg.iwSpacesFirst && 
										!FIwchOneToOne(pilsobj, rgwSpaces[iwSpacesCur]))
				iwSpacesCur--;
				}

			if (iwSpacesCur >= ptxtobjCur->u.reg.iwSpacesFirst)
				{
				fSpaceFound = fTrue;
				*pitxtobjSpace = itxtobjCur;
				*piwchSpace = rgwSpaces[iwSpacesCur];
				}
			}
		else if (ptxtobjCur->txtkind == txtkindSpecSpace)
			{
			fSpaceFound = fTrue;
			*pitxtobjSpace = itxtobjCur;
			*piwchSpace = iwchCur;
			}

		itxtobjCur--;

		while (!fSpaceFound && itxtobjCur >= 0)
		 	{

			ptxtobjCur = (PTXTOBJ)plocchnk->plschnk[itxtobjCur].pdobj;

			if (ptxtobjCur->txtkind == txtkindRegular)
				{

				iwSpacesCur = ptxtobjCur->u.reg.iwSpacesLim - 1;

				if (ptxtobjCur->txtf & txtfGlyphBased)
					{
					while (iwSpacesCur >= ptxtobjCur->u.reg.iwSpacesFirst && 
										!FIwchOneToOne(pilsobj, rgwSpaces[iwSpacesCur]))
					iwSpacesCur--;
					}


				if (iwSpacesCur >= ptxtobjCur->u.reg.iwSpacesFirst)
					{
					fSpaceFound = fTrue;
					*pitxtobjSpace = itxtobjCur;
					*piwchSpace = rgwSpaces[iwSpacesCur];
					}
				}
			else if (ptxtobjCur->txtkind == txtkindSpecSpace)
				{
				fSpaceFound = fTrue;
				*pitxtobjSpace = itxtobjCur;
				*piwchSpace = ptxtobjCur->iwchLim - 1;
				}

			itxtobjCur--;		

			}
		}

	if (!fSpaceFound)
		{
		*pitxtobjSpace = -1;
		*piwchSpace = ((PTXTOBJ)plocchnk->plschnk[0].pdobj)->iwchFirst - 1;
		}

	return fSpaceFound;
}

/* F I N D  N E X T  S P A C E */
/*----------------------------------------------------------------------------
    %%Function: FindNextSpace
    %%Contact: sergeyge

	Returns TRUE if there is a space and FALSE otherwise.
	Reports the index of the dobj containing last space
	and space's index in rgwchOrig array.
----------------------------------------------------------------------------*/
static BOOL FindNextSpace(PCLOCCHNK plocchnk, long itxtobjCur, long iwchCur,
										long* pitxtobjSpace, long* piwchSpace)
{

	PILSOBJ pilsobj;
	BOOL fSpaceFound;
	PTXTOBJ ptxtobjCur;
	long* rgwSpaces;
	long iwSpacesCur;

	ptxtobjCur = (PTXTOBJ)plocchnk->plschnk[itxtobjCur].pdobj;
	pilsobj = ptxtobjCur->plnobj->pilsobj;
	rgwSpaces = pilsobj->pwSpaces;

	fSpaceFound = fFalse;

/* In the case fWrapAllSpaces space is treated as a regular character */

	if (!(pilsobj->grpf & fTxtWrapAllSpaces))
		{
		if (ptxtobjCur->txtkind == txtkindRegular)
			{
			iwSpacesCur = ptxtobjCur->u.reg.iwSpacesFirst;
			while (iwSpacesCur < ptxtobjCur->u.reg.iwSpacesLim &&
						 rgwSpaces[iwSpacesCur] < iwchCur)
				{
				iwSpacesCur++;
				}

			if (ptxtobjCur->txtf & txtfGlyphBased)
				{
				while (iwSpacesCur < ptxtobjCur->u.reg.iwSpacesLim && 
									!FIwchOneToOne(pilsobj, rgwSpaces[iwSpacesCur]))
				iwSpacesCur++;
				}


			if (iwSpacesCur < ptxtobjCur->u.reg.iwSpacesLim)
				{
				fSpaceFound = fTrue;
				*pitxtobjSpace = itxtobjCur;
				*piwchSpace = rgwSpaces[iwSpacesCur];
				}
			}
		else if (ptxtobjCur->txtkind == txtkindSpecSpace)
			{
			fSpaceFound = fTrue;
			*pitxtobjSpace = itxtobjCur;
			*piwchSpace = iwchCur;
			}

		itxtobjCur++;

		while (!fSpaceFound && itxtobjCur < (long)plocchnk->clschnk)
		 	{

			ptxtobjCur = (PTXTOBJ)plocchnk->plschnk[itxtobjCur].pdobj;

			if (ptxtobjCur->txtkind == txtkindRegular)
				{

				iwSpacesCur = ptxtobjCur->u.reg.iwSpacesFirst;

				if (ptxtobjCur->txtf & txtfGlyphBased)
					{
					while (iwSpacesCur < ptxtobjCur->u.reg.iwSpacesLim && 
									!FIwchOneToOne(pilsobj, rgwSpaces[iwSpacesCur]))
					iwSpacesCur++;
					}

				if (iwSpacesCur < ptxtobjCur->u.reg.iwSpacesLim)
					{
					fSpaceFound = fTrue;
					*pitxtobjSpace = itxtobjCur;
					*piwchSpace = rgwSpaces[iwSpacesCur];
					}
				}
			else if (ptxtobjCur->txtkind == txtkindSpecSpace)
				{
				fSpaceFound = fTrue;
				*pitxtobjSpace = itxtobjCur;
				*piwchSpace = ptxtobjCur->iwchFirst;
				}

			itxtobjCur++;		

			}
		}

	if (!fSpaceFound)
		{
		*pitxtobjSpace = plocchnk->clschnk;
		*piwchSpace = ((PTXTOBJ)plocchnk->plschnk[plocchnk->clschnk-1].pdobj)->iwchLim;
		}

	return fSpaceFound;
}

/* T R Y  P R E V  B R E A K  F I N D  Y S R */
/*----------------------------------------------------------------------------
    %%Function: TryPrevBreakFindYsr
    %%Contact: sergeyge

	Realizes break if there is one before next space.
	Since each special character has its own dobj we need to check only type of dobj
----------------------------------------------------------------------------*/
static LSERR TryPrevBreakFindYsr(PCLOCCHNK plocchnk, long itxtobjCur, long iwchCur,
								long itxtobjSpace, long iwchSpace,
								BOOL* pfBroken, BOOL* pfFoundYsr, long* pitxtobjYsr, PBRKOUT ptbo)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobjCur;

	ptxtobjCur = (PTXTOBJ)plocchnk->plschnk[itxtobjCur].pdobj;
	pilsobj = ptxtobjCur->plnobj->pilsobj;

	*pfBroken = fFalse;
	*pfFoundYsr = fFalse;

	/* following condition is almost always TRUE,
	   so in bread-and-butter situation we do almost nothing */ 
	if ((long)itxtobjCur == itxtobjSpace && !(pilsobj->grpf & fTxtApplyBreakingRules))
		{
		return lserrNone;
		}

/* In loop condition check for itxtobjCur > itxtobjSpace is necessary for the case of empty
	DOBJ's: NonReqHyphen, OptBreak
*/
	while((itxtobjCur > itxtobjSpace || iwchCur > iwchSpace) && !*pfBroken)
		{
		ptxtobjCur = (PTXTOBJ)plocchnk->plschnk[itxtobjCur].pdobj;

		Assert(ptxtobjCur->txtkind != txtkindEOL && ptxtobjCur->txtkind != txtkindTab);
		Assert(ptxtobjCur->txtkind != txtkindSpecSpace || (pilsobj->grpf & fTxtWrapAllSpaces));

		switch (ptxtobjCur->txtkind)
			{
		case txtkindRegular:
			if (pilsobj->grpf & fTxtApplyBreakingRules)
				{
				lserr = TryPrevBreakRegular(plocchnk, itxtobjCur, iwchSpace, iwchCur, pfBroken, ptbo);
				if (lserr != lserrNone) return lserr;
				}
			break;
		case txtkindHardHyphen:
	        lserr = TryBreakAtHardHyphen(plocchnk, itxtobjCur, iwchCur, brkkindPrev, pfBroken, ptbo);
			if (lserr != lserrNone) return lserr;
			break;
		case txtkindOptBreak:
	        lserr = TryBreakAtOptBreak(plocchnk, itxtobjCur, brkkindPrev, pfBroken, ptbo);
			if (lserr != lserrNone) return lserr;
			break;
		case txtkindNonReqHyphen:
	        lserr = TryBreakAtNonReqHyphen(plocchnk, itxtobjCur, brkkindPrev, pfBroken, ptbo);
			if (lserr != lserrNone) return lserr;
			break;
		case txtkindYsrChar:
			if (!*pfFoundYsr)
				{
				*pfFoundYsr = fTrue;
				*pitxtobjYsr = itxtobjCur;
				}
			break;
		case txtkindSpecSpace:
/* It is possible for fTxtWrapAllSpaces case */
			Assert(pilsobj->grpf & fTxtApplyBreakingRules);
			Assert(pilsobj->grpf & fTxtWrapAllSpaces);

			lserr = TryPrevBreakRegular(plocchnk, itxtobjCur, iwchSpace, iwchCur, pfBroken, ptbo);
			if (lserr != lserrNone) return lserr;
			break;
			}

		iwchCur = ptxtobjCur->iwchFirst - 1;

		itxtobjCur--;

		}

	return lserrNone;
}

/* T R Y  N E X T  B R E A K  F I N D  Y S R */
/*----------------------------------------------------------------------------
    %%Function: TryPrevBreakFindYsr
    %%Contact: sergeyge

	Realizes break if there is one after last space.
	Also fills info about last YSR character after last space.
	Since each special character has its own dobj we need to check only type of dobj
----------------------------------------------------------------------------*/
static LSERR TryNextBreakFindYsr(PCLOCCHNK plocchnk, long itxtobjCur, long iwchCur,
								long itxtobjSpace, long iwchSpace,
								BOOL* pfBroken, PBRKOUT ptbo)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobjCur;

	ptxtobjCur = (PTXTOBJ)plocchnk->plschnk[itxtobjCur].pdobj;
	pilsobj = ptxtobjCur->plnobj->pilsobj;

	*pfBroken = fFalse;

/* In loop condition check for itxtobjCur < itxtobjSpace is necessary for the case of empty
	DOBJ's: NonReqHyphen, OptBreak
*/
	while((itxtobjCur < itxtobjSpace || iwchCur < iwchSpace) && !*pfBroken)
		{
		ptxtobjCur = (PTXTOBJ)plocchnk->plschnk[itxtobjCur].pdobj;

		Assert(ptxtobjCur->txtkind != txtkindSpecSpace || (pilsobj->grpf & fTxtWrapAllSpaces));

		switch (ptxtobjCur->txtkind)
			{
		case txtkindRegular:
			if (pilsobj->grpf & fTxtApplyBreakingRules)
				{
				lserr = TryNextBreakRegular(plocchnk, itxtobjCur, iwchSpace, iwchCur, pfBroken, ptbo);
				if (lserr != lserrNone) return lserr;
				}
			break;
		case txtkindHardHyphen:
	        lserr = TryBreakAtHardHyphen(plocchnk, itxtobjCur, iwchCur, brkkindNext, pfBroken, ptbo);
			if (lserr != lserrNone) return lserr;
			break;
		case txtkindOptBreak:
	        lserr = TryBreakAtOptBreak(plocchnk, itxtobjCur, brkkindNext, pfBroken, ptbo);
			if (lserr != lserrNone) return lserr;
			break;
		case txtkindEOL:
	        lserr = TryBreakAtEOL(plocchnk, itxtobjCur, brkkindNext, pfBroken, ptbo);
			if (lserr != lserrNone) return lserr;
			break;
		case txtkindNonReqHyphen:
	        lserr = TryBreakAtNonReqHyphen(plocchnk, itxtobjCur, brkkindNext, pfBroken, ptbo);
			if (lserr != lserrNone) return lserr;
			break;
		case txtkindSpecSpace:
/* It is possible for fTxtWrapAllSpaces case */
			Assert(pilsobj->grpf & fTxtApplyBreakingRules);
			Assert(pilsobj->grpf & fTxtWrapAllSpaces);

			lserr = TryNextBreakRegular(plocchnk, itxtobjCur, iwchSpace, iwchCur, pfBroken, ptbo);
			if (lserr != lserrNone) return lserr;
			break;
			}

		iwchCur = ptxtobjCur->iwchLim;

		itxtobjCur++;

		}

	return lserrNone;
}


/* T R Y  B R E A K  W I T H  H Y P H E N */
/*----------------------------------------------------------------------------
    %%Function: TryBreakWithHyphen
    %%Contact: sergeyge

	Tries to realize break as hyphenation

	Strategy:

	--Checks if hyphenation should be performed (CheckHotZone)
	--If it should, calls hyphenator.
`	--If hyphenator is successful tryes to insert hyphen
	  else sets break opportunity at the last space
----------------------------------------------------------------------------*/
static LSERR TryBreakWithHyphen(PCLOCCHNK plocchnk, long itxtobjCur, long iwchCur,
						BOOL fSpaceFound, long itxtobjSpace, long iwchSpace,
						BOOL fFoundYsr, long itxtobjYsr, BOOL* pfBroken, PBRKOUT ptbo)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	long itxtobjWordStart;
	long iwchWordStart;
	PTXTOBJ ptxtobjWordStart;
	PTXTOBJ ptxtobjYsr;
	long dwchYsr;
	LSCP cpMac;
	LSCP cpWordStart;
	PLSRUN plsrunYsr;
	YSRINF ysrinf;
	HYPHOUT hyphout;
	struct lshyph lshyphLast;
	struct lshyph lshyphNew;
	BOOL fHyphenInserted;
	BOOL fInHyphenZone = fTrue;
	DWORD kysr;
	WCHAR wchYsr;
	long urPenLast;
	OBJDIM objdim;
	BREAKINFO* pbrkinf;
	long itxtobjPrevPrev;
	long durBorder;
	BOOL fSuccessful;
	long i;
	
	if (!fSpaceFound)
		{
		itxtobjWordStart = 0;
		iwchWordStart = ((PTXTOBJ)plocchnk->plschnk[0].pdobj)->iwchFirst;
		}
	else
		{
		itxtobjWordStart = itxtobjSpace;
		iwchWordStart = iwchSpace + 1;
		lserr = CheckHotZone(plocchnk, itxtobjSpace, iwchSpace, &fInHyphenZone);
		if (lserr != lserrNone) return lserr;
		}

	ptxtobjWordStart = (PTXTOBJ)plocchnk->plschnk[itxtobjWordStart].pdobj;
	pilsobj = ptxtobjWordStart->plnobj->pilsobj;

	fHyphenInserted = fFalse;


	if (fInHyphenZone)
		{

		/* Fill lshyphLast if there was YSR character */
		if (fFoundYsr)
			{
			plsrunYsr = plocchnk->plschnk[itxtobjYsr].plsrun;

			lserr = (*pilsobj->plscbk->pfnGetHyphenInfo)(pilsobj->pols, plsrunYsr, &kysr, &wchYsr);
		   	if (lserr != lserrNone) return lserr;
	
			lshyphLast.kysr = kysr;
			lshyphLast.wchYsr = wchYsr;

			lshyphLast.cpYsr = plocchnk->plschnk[itxtobjYsr].cpFirst;
			}
		else
			{
			lshyphLast.kysr = kysrNil;
			}

		Assert (iwchCur >= ((PTXTOBJ)plocchnk->plschnk[itxtobjCur].pdobj)->iwchFirst ||
		((PTXTOBJ)plocchnk->plschnk[itxtobjCur].pdobj)->iwchFirst == ((PTXTOBJ)plocchnk->plschnk[itxtobjCur].pdobj)->iwchLim);

		cpMac = plocchnk->plschnk[itxtobjCur].cpFirst + 
						(iwchCur - ((PTXTOBJ)plocchnk->plschnk[itxtobjCur].pdobj)->iwchFirst) + 1;

		cpWordStart = plocchnk->plschnk[itxtobjWordStart].cpFirst +
								 (iwchWordStart - ptxtobjWordStart->iwchFirst);

		lshyphNew.kysr = kysrNormal;

		while (!fHyphenInserted && lshyphNew.kysr != kysrNil)
			{
			lserr = (pilsobj->plscbk->pfnHyphenate)(pilsobj->pols, &lshyphLast,	cpWordStart, cpMac, &lshyphNew);

			if (lserr != lserrNone) return lserr;
		
			if (lshyphNew.kysr != kysrNil)
				{
				/* if TryBreak.. will be unsuccessful we will try hyphenation again with a new cpMac */
				Assert(lshyphNew.cpYsr >= cpWordStart && lshyphNew.cpYsr < cpMac);

				cpMac = lshyphNew.cpYsr;
				lshyphLast = lshyphNew;

				for (i=0; i <= itxtobjCur && plocchnk->plschnk[i].cpFirst <= cpMac; i++);

				itxtobjYsr = i - 1;

				Assert(lshyphNew.cpYsr < plocchnk->plschnk[itxtobjYsr].cpFirst + 
																(long)plocchnk->plschnk[itxtobjYsr].dcp);

				dwchYsr = cpMac - plocchnk->plschnk[itxtobjYsr].cpFirst;

				ysrinf.wchYsr = lshyphNew.wchYsr;
				ysrinf.kysr = (WORD)lshyphNew.kysr;

				itxtobjPrevPrev = ichnkOutside;
				for (i=itxtobjYsr; i >= 0 && plocchnk->plschnk[i].cpFirst > cpMac - 1; i--);
				if (i >= 0)
					itxtobjPrevPrev = i;
				
				lserr = ProcessYsr(plocchnk, itxtobjYsr, dwchYsr, itxtobjYsr, itxtobjPrevPrev, ysrinf,
																					&fSuccessful, &hyphout);
				if (lserr != lserrNone) return lserr;
				Assert(hyphout.ddurDnodePrevPrev == 0);

				if (fSuccessful)
					{
					/* try break may be unsuccessful because it won't fit in the column */
					ptxtobjYsr = (PTXTOBJ)plocchnk->plschnk[itxtobjYsr].pdobj;
					if (ptxtobjYsr->txtf & txtfGlyphBased)
						lserr = CalcPartWidthsGlyphs(ptxtobjYsr, dwchYsr + 1, &objdim, &urPenLast);
					else
						lserr = CalcPartWidths(ptxtobjYsr, dwchYsr + 1, &objdim, &urPenLast);
					if (lserr != lserrNone) return lserr;

					durBorder = 0;
					if (plocchnk->plschnk[itxtobjYsr].plschp->fBorder)
						{
						lserr = LsdnGetBorderAfter(pilsobj->plsc, ptxtobjYsr->plsdnUpNode, &durBorder);
						Assert(lserr == lserrNone);
						}

					if (plocchnk->ppointUvLoc[itxtobjYsr].u + urPenLast + hyphout.durChangeTotal + durBorder
																	<= plocchnk->lsfgi.urColumnMax)
						{

						fHyphenInserted = fTrue;

						ptbo->fSuccessful = fTrue;
						ptbo->posichnk.ichnk = itxtobjYsr;
						ptbo->posichnk.dcp = dwchYsr + 1;
						ptbo->objdim = objdim;
						ptbo->objdim.dur = urPenLast + hyphout.durChangeTotal;

						lserr = GetPbrkinf(pilsobj, plocchnk->plschnk[itxtobjYsr].pdobj, brkkindPrev, &pbrkinf);
						if (lserr != lserrNone) return lserr;

						pbrkinf->pdobj = plocchnk->plschnk[itxtobjYsr].pdobj;
						pbrkinf->brkkind = brkkindPrev;
						pbrkinf->dcp = dwchYsr + 1;
						pbrkinf->brkt = brktHyphen;

						pbrkinf->u.hyphen.iwchLim = hyphout.iwchLim;
						pbrkinf->u.hyphen.dwchYsr = hyphout.dwchYsr;
						pbrkinf->u.hyphen.durHyphen = hyphout.durHyphen;
						pbrkinf->u.hyphen.dupHyphen = hyphout.dupHyphen;
						pbrkinf->u.hyphen.durPrev = hyphout.durPrev;
						pbrkinf->u.hyphen.dupPrev = hyphout.dupPrev;
						pbrkinf->u.hyphen.durPrevPrev = hyphout.durPrevPrev;
						pbrkinf->u.hyphen.dupPrevPrev = hyphout.dupPrevPrev;
						pbrkinf->u.hyphen.ddurDnodePrev = hyphout.ddurDnodePrev;
						pbrkinf->u.hyphen.wchPrev = hyphout.wchPrev;
						pbrkinf->u.hyphen.wchPrevPrev = hyphout.wchPrevPrev;
						pbrkinf->u.hyphen.gindHyphen = hyphout.gindHyphen;
						pbrkinf->u.hyphen.gindPrev = hyphout.gindPrev;
						pbrkinf->u.hyphen.gindPrevPrev = hyphout.gindPrevPrev;
						pbrkinf->u.hyphen.igindHyphen = hyphout.igindHyphen;
						pbrkinf->u.hyphen.igindPrev = hyphout.igindPrev;
						pbrkinf->u.hyphen.igindPrevPrev = hyphout.igindPrevPrev;
						}
					}
				}
			}

		}
		
	*pfBroken = fHyphenInserted;

	return lserrNone;
}

/* T R Y  B R E A K  A T  S P A C E */
/*----------------------------------------------------------------------------
    %%Function: TryBreakAtSpace
    %%Contact: sergeyge
	
	Dispatchs desicion to either TryBreakAtSpaceNormal or
								 TryBreakAtSpaceWrap
----------------------------------------------------------------------------*/
static LSERR TryBreakAtSpace(PCLOCCHNK plocchnk, PCPOSICHNK pposichnk, long itxtobjSpace, long iwchSpace, 
							BRKKIND brkkind, BOOL* pfBroken, long* pitxtobjCurNew, long* piwchCurNew, PBRKOUT ptbo)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	BOOL fInChildList;

	ptxtobj = (PTXTOBJ)plocchnk->plschnk[itxtobjSpace].pdobj;
	pilsobj = ptxtobj->plnobj->pilsobj;

	Assert(!(pilsobj->grpf & fTxtWrapAllSpaces));

	if (FWrapTrailingSpaces(pilsobj, ptxtobj, fInChildList))
		{
		lserr = TryBreakAtSpaceWrap(plocchnk, pposichnk, itxtobjSpace, iwchSpace, brkkind,
											pfBroken, pitxtobjCurNew, piwchCurNew, ptbo);
		}
	else
		{
		lserr = TryBreakAtSpaceNormal(plocchnk, itxtobjSpace, iwchSpace, brkkind, 
											pfBroken, pitxtobjCurNew, piwchCurNew, ptbo);
		}

	return lserr;
}


/* T R Y  B R E A K  A T  S P A C E  W R A P */
/*----------------------------------------------------------------------------
    %%Function: TryBreakAtSpaceWrap
    %%Contact: sergeyge
	
	Realizes break at space for the fWrapTrailingSpaces case.
----------------------------------------------------------------------------*/
static LSERR TryBreakAtSpaceWrap(PCLOCCHNK plocchnk, PCPOSICHNK pposichnk,
								 long itxtobjSpace, long iwchSpace, BRKKIND brkkind,
								 BOOL* pfBroken, long* pitxtobjCurNew, long* piwchCurNew, PBRKOUT ptbo)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobjSpace;
	long itxtobjBefore;
	long itxtobjAfter;
	long iwchBefore;
	long iwchAfter;
	BOOL fBeforeFound;
	BOOL fAfterFound = fTrue;
	
	*pfBroken = fFalse;
	*pitxtobjCurNew = -1;
	*piwchCurNew = -1;

	ptxtobjSpace = (PTXTOBJ)plocchnk->plschnk[itxtobjSpace].pdobj;
	pilsobj = ptxtobjSpace->plnobj->pilsobj;

	fBeforeFound = FindNonSpaceBefore(plocchnk->plschnk, itxtobjSpace, iwchSpace,
														&itxtobjBefore, &iwchBefore);
	Assert(fBeforeFound || iwchBefore == ((PTXTOBJ)plocchnk->plschnk[0].pdobj)->iwchFirst - 1);
		 /* iwchBefore is needed for check that previous char is not space	*/

	if (brkkind == brkkindPrev &&						/* previous break only, next break must be after */
		iwchSpace - iwchBefore > 1 &&					/* previous character is space	*/
		pposichnk->ichnk != ichnkOutside &&				/* and space exceeds right margin */
		iwchSpace == (long)(((PTXTOBJ)plocchnk->plschnk[pposichnk->ichnk].pdobj)->iwchFirst +
						  						pposichnk->dcp - 1))
		{
		fAfterFound = fTrue;
		itxtobjAfter = itxtobjSpace;
		iwchAfter = iwchSpace;
		}
	else
		{
		fAfterFound = FindNextChar(plocchnk->plschnk, plocchnk->clschnk, itxtobjSpace, iwchSpace,
														 &itxtobjAfter, &iwchAfter);
		}

	lserr = TryBreakAcrossSpaces(plocchnk,
							fBeforeFound, itxtobjBefore, iwchBefore,
							fAfterFound, itxtobjAfter, iwchAfter, brkkind, pfBroken, ptbo);

	if (lserr != lserrNone) return lserr;

	if (!*pfBroken)
		{
		if (brkkind == brkkindPrev)
			{
			FindPrevChar(plocchnk->plschnk, itxtobjSpace, iwchSpace,
														 pitxtobjCurNew, piwchCurNew);
			}
		else
			{
			Assert(brkkind == brkkindNext);
			*pitxtobjCurNew = itxtobjAfter;
			*piwchCurNew = iwchAfter;
			}
		}

	return lserrNone;
}

/* T R Y  B R E A K  A T  S P A C E  N O R M A L */
/*----------------------------------------------------------------------------
    %%Function: TryBreakAtSpaceNormal
    %%Contact: sergeyge
	
	Realizes break at space for the normal (!fWrapTrailingSpaces) case.
----------------------------------------------------------------------------*/
static LSERR TryBreakAtSpaceNormal(PCLOCCHNK plocchnk, long itxtobjSpace, long iwchSpace, BRKKIND brkkind,
								 BOOL* pfBroken, long* pitxtobjCurNew, long* piwchCurNew, PBRKOUT ptbo)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobjSpace;
	long itxtobjBefore;
	long itxtobjAfter;
	long iwchBefore;
	long iwchAfter;
	BOOL fBeforeFound;
	BOOL fAfterFound;
	
	*pfBroken = fFalse;
	*pitxtobjCurNew = -1;
	*piwchCurNew = -1;

	ptxtobjSpace = (PTXTOBJ)plocchnk->plschnk[itxtobjSpace].pdobj;
	pilsobj = ptxtobjSpace->plnobj->pilsobj;

	fBeforeFound = FindNonSpaceBefore(plocchnk->plschnk, 
										itxtobjSpace, iwchSpace, &itxtobjBefore, &iwchBefore);
	Assert(fBeforeFound || iwchBefore == ((PTXTOBJ)plocchnk->plschnk[0].pdobj)->iwchFirst - 1);

	fAfterFound = FindNonSpaceAfter(plocchnk->plschnk, plocchnk->clschnk,
												 itxtobjSpace, iwchSpace, &itxtobjAfter, &iwchAfter);

	lserr = TryBreakAcrossSpaces(plocchnk, fBeforeFound, itxtobjBefore, iwchBefore,
										fAfterFound, itxtobjAfter, iwchAfter, brkkind, pfBroken, ptbo);
	if (lserr != lserrNone) return lserr;

	if (!*pfBroken)
		{
		if (brkkind == brkkindPrev)
			{
			*pitxtobjCurNew = itxtobjBefore;
			*piwchCurNew = iwchBefore;
			}
		else
			{
			Assert(brkkind == brkkindNext);
			*pitxtobjCurNew = itxtobjAfter;
			*piwchCurNew = iwchAfter;
			}
		}

	return lserrNone;
}


/* T R Y  B R E A K  A C R O S S  S P A C E S */
/*----------------------------------------------------------------------------
    %%Function: TryBreakAcrossSpaces
    %%Contact: sergeyge
	
	Checks break across spaces, sets it if it is possible
----------------------------------------------------------------------------*/
static LSERR TryBreakAcrossSpaces(PCLOCCHNK plocchnk,
						BOOL fBeforeFound, long itxtobjBefore, long iwchBefore,
						BOOL fAfterFound, long itxtobjAfter, long iwchAfter, BRKKIND brkkind,
						BOOL* pfBroken, PBRKOUT ptbo)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobjBefore = NULL;
	PTXTOBJ ptxtobjAfter = NULL;
	BRKCLS brkclsLeading = 0;			/* Initialization to keep compiler satisfied */
	BRKCLS brkclsFollowing = 0;			/* Initialization to keep compiler satisfied */
	BRKCLS brkclsJunk;
	BRKCOND brktxt;
	BREAKINFO* pbrkinf;
	BOOL fCanBreak;

	pilsobj = ((PTXTOBJ)plocchnk->plschnk[0].pdobj)->plnobj->pilsobj;

	fCanBreak = fTrue;
	*pfBroken = fFalse;

	if (fAfterFound)
		{
		ptxtobjAfter = (PTXTOBJ)plocchnk->plschnk[itxtobjAfter].pdobj;

		if (ptxtobjAfter->txtkind == txtkindEOL)
			{
			lserr = TryBreakAtEOL(plocchnk, itxtobjAfter, brkkind, pfBroken, ptbo);
			if (lserr != lserrNone) return lserr;
			Assert (*pfBroken == fTrue);
			}

		}

	if (!*pfBroken && (pilsobj->grpf & fTxtApplyBreakingRules) )
		{

		if (fAfterFound)
			{
			Assert(ptxtobjAfter->txtkind != txtkindTab && ptxtobjAfter->txtkind != txtkindEOL);
			/* Space After is possible for fWarapTrailingSpaces case*/
			if (ptxtobjAfter->txtkind == txtkindOptBreak ||
				ptxtobjAfter->txtkind == txtkindNonReqHyphen)
				{
				fAfterFound = fFalse;		/* After char of no importance for making break decision */
				}
			else if (!FRegularBreakableBeforeDobj(ptxtobjAfter))
				{
				fCanBreak = fFalse;		/* Cannot break before non-standard dobj's,
										compare with CheckBreakAtLastChar			 */
				}
			else if ((ptxtobjAfter->txtf & txtfGlyphBased) && iwchAfter > ptxtobjAfter->iwchFirst)
				/* if iwchAfter is first character of Dnode, it is definitely not shaped together
					 with the previous char */
				{
				if (!FIwchLastInContext(pilsobj, iwchAfter - 1))
					{
					fCanBreak = fFalse;
				/* Additional hack to handle case when Accented spaces are separated by spaces */
					if (iwchAfter - 1 > iwchBefore + 1 && /* There are more spaces in between */
						FIwchFirstInContext(pilsobj, iwchAfter - 1) )
						{
						fCanBreak = fTrue;
						iwchAfter--;
						}
					}
				}
			}
		else
			{
			if (brkkind == brkkindPrev)
			/* patch for the cases when we break across spaces 
				at the end of text chunk during PrevBreak logic.
				Problems are possible because trailing spaces could exceed RM, 
				and no information about following chunk was passed in.
			*/
				{
				BOOL fStoppedAfter;
				
				Assert(fCanBreak);
				Assert(plocchnk->clschnk > 0);
				/* Check if there is Splat, or Hidden text producing fStopped after this chunk
					In this case we must break after
					(we will set fAfterFound and fBeforeFound to False to ensure it)
				*/
				lserr = LsdnFStoppedAfterChunk(pilsobj->plsc,
							((PTXTOBJ)plocchnk->plschnk[plocchnk->clschnk-1].pdobj)->plsdnUpNode,
							&fStoppedAfter);
				if (lserr != lserrNone) return lserr;

				if (fStoppedAfter)
					{
					Assert(fCanBreak);
					Assert(!fAfterFound);
					fBeforeFound = fFalse;
					}
				else
				/* If there is no Splat, or Hidden text producing fStopped after this chunk
					we should not break if next chunk returnd brkcondNever on the left side.
				*/
					{

					lserr = LsdnFCanBreakBeforeNextChunk(pilsobj->plsc,
							((PTXTOBJ)plocchnk->plschnk[plocchnk->clschnk-1].pdobj)->plsdnUpNode,
							&fCanBreak);
					if (lserr != lserrNone) return lserr;
					}
				}
			else
				{
				Assert (brkkind == brkkindNext);
				fCanBreak = fFalse;		/* Do not break; let code at the ens of FindNextBreak set correct brkcond */
				}
			}

		if (fBeforeFound)
			{
			ptxtobjBefore = (PTXTOBJ)plocchnk->plschnk[itxtobjBefore].pdobj;

			Assert(ptxtobjBefore->txtkind != txtkindTab &&
				   ptxtobjBefore->txtkind != txtkindSpecSpace &&
				   ptxtobjBefore->txtkind != txtkindEOL);

			if (ptxtobjBefore->txtkind == txtkindHardHyphen ||
				ptxtobjBefore->txtkind == txtkindOptBreak ||
				ptxtobjBefore->txtkind == txtkindNonReqHyphen)
				{
				fBeforeFound = fFalse;		/* Before char of no importance for making break decision */
				}
			else if (ptxtobjBefore->txtkind == txtkindNonBreakSpace ||
				ptxtobjBefore->txtkind == txtkindNonBreakHyphen ||
				ptxtobjBefore->txtkind == txtkindOptNonBreak)
				{
				fCanBreak = fFalse;		/* Cannot break after Non-Breaks */
				}
			}

		if (fCanBreak)
			{
			if (fBeforeFound)
				{
				lserr =(*pilsobj->plscbk->pfnGetBreakingClasses)(pilsobj->pols, plocchnk->plschnk[itxtobjBefore].plsrun,
					plocchnk->plschnk[itxtobjBefore].cpFirst + (iwchBefore - ptxtobjBefore->iwchFirst),
					pilsobj->pwchOrig[iwchBefore], &brkclsLeading, &brkclsJunk);
				if (lserr != lserrNone) return lserr;

				Assert(brkclsLeading < pilsobj->cBreakingClasses && brkclsJunk < pilsobj->cBreakingClasses);
				if (brkclsLeading >= pilsobj->cBreakingClasses || brkclsJunk >= pilsobj->cBreakingClasses)
						return lserrInvalidBreakingClass;
				}

			if (fAfterFound)
				{
				lserr =(*pilsobj->plscbk->pfnGetBreakingClasses)(pilsobj->pols, plocchnk->plschnk[itxtobjAfter].plsrun,
					plocchnk->plschnk[itxtobjAfter].cpFirst + (iwchAfter - ptxtobjAfter->iwchFirst),					
					pilsobj->pwchOrig[iwchAfter], &brkclsJunk, &brkclsFollowing);
				if (lserr != lserrNone) return lserr;

				Assert(brkclsJunk < pilsobj->cBreakingClasses && brkclsFollowing < pilsobj->cBreakingClasses);
				if (brkclsJunk >= pilsobj->cBreakingClasses || brkclsFollowing >= pilsobj->cBreakingClasses)
						return lserrInvalidBreakingClass;
				}

			if (fBeforeFound && fAfterFound)
				{
				fCanBreak = FCanBreakAcrossSpaces(pilsobj, brkclsLeading, brkclsFollowing);
				}
			else if (fBeforeFound && !fAfterFound)
				{
				lserr = (*pilsobj->plscbk->pfnCanBreakAfterChar)(pilsobj->pols, brkclsLeading, &brktxt);
				if (lserr != lserrNone) return lserr;
				fCanBreak = (brktxt != brkcondNever);
				}
			else if (!fBeforeFound && fAfterFound)
				{
				lserr = (*pilsobj->plscbk->pfnCanBreakBeforeChar)(pilsobj->pols, brkclsFollowing, &brktxt);
				if (lserr != lserrNone) return lserr;
				fCanBreak = (brktxt != brkcondNever);
				}
			}
		}

	if (!*pfBroken && fCanBreak)
		{
		FillPtboPbrkinf(plocchnk, itxtobjAfter, iwchAfter - 1, /*itxtobjBefore,*/ iwchBefore,
																	brkkind, &pbrkinf, ptbo);
		*pfBroken = fTrue;
		}

	return lserrNone;

}

/* T R Y  P R E V  B R E A K  R E G U L A R */
/*----------------------------------------------------------------------------
    %%Function: TryPrevBreakRegular
    %%Contact: sergeyge
	
	Checks (and sets) for prev break inside regular dobj
----------------------------------------------------------------------------*/
static LSERR TryPrevBreakRegular(PCLOCCHNK plocchnk, long itxtobj, long iwchSpace, long iwchCur,
																	BOOL* pfBroken, PBRKOUT ptbo)
{
	LSERR lserr;
	PTXTOBJ ptxtobj;
	PILSOBJ pilsobj;
	PLSRUN plsrun;
	long iwchFirst;
	BRKCLS brkclsFollowingCache;
	BRKCLS brkclsLeading;
	BRKCLS brkclsFollowing;
	BREAKINFO* pbrkinf;
	
	*pfBroken = fFalse;
	if (iwchCur <= iwchSpace) return lserrNone;

	ptxtobj = (PTXTOBJ)plocchnk->plschnk[itxtobj].pdobj;
	pilsobj = ptxtobj->plnobj->pilsobj;

	Assert(ptxtobj->txtkind == txtkindRegular || 
		(ptxtobj->txtkind == txtkindSpecSpace && (pilsobj->grpf & fTxtWrapAllSpaces)));

	Assert( pilsobj->grpf & fTxtApplyBreakingRules );
	plsrun = plocchnk->plschnk[itxtobj].plsrun;

	iwchFirst = ptxtobj->iwchFirst;
	if (iwchSpace + 1 > iwchFirst)
		iwchFirst = iwchSpace + 1;

	lserr =(*pilsobj->plscbk->pfnGetBreakingClasses)(pilsobj->pols, plsrun,
				plocchnk->plschnk[itxtobj].cpFirst + (iwchCur - ptxtobj->iwchFirst),			
				pilsobj->pwchOrig[iwchCur], &brkclsLeading, &brkclsFollowingCache);
	if (lserr != lserrNone) return lserr;

	Assert(brkclsLeading < pilsobj->cBreakingClasses && brkclsFollowingCache < pilsobj->cBreakingClasses);
	if (brkclsLeading >= pilsobj->cBreakingClasses || brkclsFollowingCache >= pilsobj->cBreakingClasses)
					return lserrInvalidBreakingClass;


	lserr = CheckBreakAtLastChar(plocchnk, brkclsLeading, iwchCur, itxtobj, pfBroken);
	if (lserr != lserrNone) return lserr;

	iwchCur--;

	while (!*pfBroken && iwchCur >= iwchFirst)
		{
		brkclsFollowing = brkclsFollowingCache;
		lserr =(*pilsobj->plscbk->pfnGetBreakingClasses)(pilsobj->pols, plsrun,
			plocchnk->plschnk[itxtobj].cpFirst + (iwchCur - ptxtobj->iwchFirst),				
			pilsobj->pwchOrig[iwchCur], &brkclsLeading, &brkclsFollowingCache);
		if (lserr != lserrNone) return lserr;
	
		Assert(brkclsLeading < pilsobj->cBreakingClasses && brkclsFollowingCache < pilsobj->cBreakingClasses);
		if (brkclsLeading >= pilsobj->cBreakingClasses || brkclsFollowingCache >= pilsobj->cBreakingClasses)
					return lserrInvalidBreakingClass;

		*pfBroken = FCanBreak(pilsobj, brkclsLeading, brkclsFollowing) && 
					(!(ptxtobj->txtf & txtfGlyphBased) || FIwchLastInContext(pilsobj, iwchCur));
		iwchCur --;
		}

	if (*pfBroken)
		{
		lserr = FillPtboPbrkinf(plocchnk, itxtobj, iwchCur+1, /*itxtobj,*/ iwchCur+1, 
															brkkindPrev, &pbrkinf, ptbo);
		if (lserr != lserrNone) return lserr;
		/* fModWidthSpace can be at the last char here only iff fWrapAllSpaces;
			if we touch balanced space here, the logic of GetMinCompressAmount should be rethinked!*/
		if (pilsobj->pdurRight != NULL && pilsobj->pdurRight[iwchCur + 1] > 0 &&
													!pilsobj->ptxtinf[iwchCur - 1].fModWidthSpace)
			{
			pbrkinf->u.normal.durFix = - pilsobj->pdurRight[iwchCur + 1];
			ptbo->objdim.dur -= pilsobj->pdurRight[iwchCur + 1];
			}
		}

	return lserrNone;

}

/* T R Y  N E X T  B R E A K  R E G U L A R */
/*----------------------------------------------------------------------------
    %%Function: TryNextBreakRegular
    %%Contact: sergeyge
	
	Checks (and sets) for next break inside regular dobj
----------------------------------------------------------------------------*/
static LSERR TryNextBreakRegular(PCLOCCHNK plocchnk, long itxtobj, long iwchSpace, long iwchCur,
																		BOOL* pfBroken, PBRKOUT ptbo)
{
	LSERR lserr;
	PTXTOBJ ptxtobj;
	PILSOBJ pilsobj;
	PLSRUN plsrun;
	long iwchLast;
	BRKCLS brkclsLeadingCache;
	BRKCLS brkclsLeading;
	BRKCLS brkclsFollowing;
	BRKCLS brkclsJunk;
	BREAKINFO* pbrkinf;
	
	*pfBroken = fFalse;
	if (iwchCur >= iwchSpace) return lserrNone;

	ptxtobj = (PTXTOBJ)plocchnk->plschnk[itxtobj].pdobj;
	pilsobj = ptxtobj->plnobj->pilsobj;

	Assert(ptxtobj->txtkind == txtkindRegular || 
		(ptxtobj->txtkind == txtkindSpecSpace && (pilsobj->grpf & fTxtWrapAllSpaces)));

	Assert(pilsobj->grpf & fTxtApplyBreakingRules);
	plsrun = plocchnk->plschnk[itxtobj].plsrun;

	iwchLast = ptxtobj->iwchLim - 1;
	/* The last possibility for break is BEFORE LAST CHAR before space */
	if (iwchSpace - 1 < iwchLast)
		iwchLast = iwchSpace - 1;

	lserr =(*pilsobj->plscbk->pfnGetBreakingClasses)(pilsobj->pols, plsrun,
		plocchnk->plschnk[itxtobj].cpFirst + (iwchCur - ptxtobj->iwchFirst),
		pilsobj->pwchOrig[iwchCur], &brkclsLeadingCache, &brkclsJunk);
	if (lserr != lserrNone) return lserr;

	Assert(brkclsLeadingCache < pilsobj->cBreakingClasses && brkclsJunk < pilsobj->cBreakingClasses);
	if (brkclsLeadingCache >= pilsobj->cBreakingClasses || brkclsJunk >= pilsobj->cBreakingClasses)
					return lserrInvalidBreakingClass;

	while (!*pfBroken && iwchCur < iwchLast)
		{
		brkclsLeading = brkclsLeadingCache;
		lserr =(*pilsobj->plscbk->pfnGetBreakingClasses)(pilsobj->pols, plsrun,
			plocchnk->plschnk[itxtobj].cpFirst + (iwchCur + 1 - ptxtobj->iwchFirst),
			pilsobj->pwchOrig[iwchCur + 1], &brkclsLeadingCache, &brkclsFollowing);
		if (lserr != lserrNone) return lserr;

		Assert(brkclsLeadingCache < pilsobj->cBreakingClasses && brkclsFollowing < pilsobj->cBreakingClasses);
		if (brkclsLeadingCache >= pilsobj->cBreakingClasses || brkclsFollowing >= pilsobj->cBreakingClasses)
					return lserrInvalidBreakingClass;

		*pfBroken = FCanBreak(pilsobj, brkclsLeading, brkclsFollowing) &&
					(!(ptxtobj->txtf & txtfGlyphBased) || FIwchLastInContext(pilsobj, iwchCur));

		iwchCur++;
		}

	if (!*pfBroken && iwchCur == iwchLast && iwchLast < iwchSpace - 1)
		{
		lserr = CheckBreakAtLastChar(plocchnk, brkclsLeadingCache, iwchLast, itxtobj, pfBroken);
		iwchCur++;
		if (lserr != lserrNone) return lserr;
		}

	if (*pfBroken)
		{
		Assert (iwchCur >= 1);

		FillPtboPbrkinf(plocchnk, itxtobj, iwchCur-1, /*itxtobj,*/ iwchCur-1, brkkindNext, &pbrkinf, ptbo);

		/* fModWidthSpace can be at the last char here only iff fWrapAllSpaces;
			if we touch balanced space here, the logic of GetMinCompressAmount should be rethinked!*/
		if (pilsobj->pdurRight != NULL && pilsobj->pdurRight[iwchCur - 1] != 0 &&
													!pilsobj->ptxtinf[iwchCur - 1].fModWidthSpace)
			{
			pbrkinf->u.normal.durFix = - pilsobj->pdurRight[iwchCur - 1];
			ptbo->objdim.dur -= pilsobj->pdurRight[iwchCur - 1];
			}

		}

	return lserrNone;

}

/* C H E C K  B R E A K  A T  L A S T  C H A R */
/*----------------------------------------------------------------------------
    %%Function: CheckBreakAtLastChar
    %%Contact: sergeyge
	
	Checks (and sets) for prev break inside regular dobj
----------------------------------------------------------------------------*/
static LSERR CheckBreakAtLastChar(PCLOCCHNK plocchnk, BRKCLS brkclsLeading, long iwch, long itxtobj, BOOL* pfBroken)
{
	LSERR lserr;
	PTXTOBJ ptxtobj;
	PILSOBJ pilsobj;
	long itxtobjAfter;
	long iwchAfter;
	BRKCLS brkclsFollowing;
	BRKCLS brkclsJunk;
/*	BRKTXTCOND brktxt;*/

	*pfBroken = fFalse;

	ptxtobj = (PTXTOBJ)plocchnk->plschnk[itxtobj].pdobj;
	pilsobj = ptxtobj->plnobj->pilsobj;

	if ((ptxtobj->txtf & txtfGlyphBased) && !FIwchLastInContext(pilsobj, iwch))
		return lserrNone;

	pilsobj = ptxtobj->plnobj->pilsobj;

	if (iwch < ptxtobj->iwchLim - 1)
		{
		lserr =(*pilsobj->plscbk->pfnGetBreakingClasses)(pilsobj->pols, plocchnk->plschnk[itxtobj].plsrun,
			plocchnk->plschnk[itxtobj].cpFirst + (iwch + 1 - ptxtobj->iwchFirst),
			pilsobj->pwchOrig[iwch + 1], &brkclsJunk, &brkclsFollowing);
		if (lserr != lserrNone) return lserr;

		Assert(brkclsJunk < pilsobj->cBreakingClasses && brkclsFollowing < pilsobj->cBreakingClasses);
		if (brkclsJunk >= pilsobj->cBreakingClasses || brkclsFollowing >= pilsobj->cBreakingClasses)
					return lserrInvalidBreakingClass;

		*pfBroken = FCanBreak(pilsobj, brkclsLeading, brkclsFollowing);

		}
	else if (FindNextChar(plocchnk->plschnk, plocchnk->clschnk, itxtobj, iwch, 
															&itxtobjAfter, &iwchAfter))
		{

		ptxtobj = (PTXTOBJ)plocchnk->plschnk[itxtobjAfter].pdobj;

		if (FRegularBreakableBeforeDobj(ptxtobj))
			{
			Assert(ptxtobj->txtkind != txtkindSpecSpace || (pilsobj->grpf & fTxtWrapAllSpaces) );
						
			lserr =(*pilsobj->plscbk->pfnGetBreakingClasses)(pilsobj->pols, plocchnk->plschnk[itxtobjAfter].plsrun,
				plocchnk->plschnk[itxtobjAfter].cpFirst + (iwchAfter - ptxtobj->iwchFirst),
				pilsobj->pwchOrig[iwchAfter], &brkclsJunk, &brkclsFollowing);
			if (lserr != lserrNone) return lserr;

			Assert(brkclsJunk < pilsobj->cBreakingClasses && brkclsFollowing < pilsobj->cBreakingClasses);
			if (brkclsJunk >= pilsobj->cBreakingClasses || brkclsFollowing >= pilsobj->cBreakingClasses)
					return lserrInvalidBreakingClass;


			*pfBroken = FCanBreak(pilsobj, brkclsLeading, brkclsFollowing);
			}

		}
/* Manager takes care of the ELSE situation; */

	return lserrNone;

}

/* T R Y  B R E A K  A T  H A R D  H Y P H E N */
/*----------------------------------------------------------------------------
    %%Function: TryBreakAtHardHyphen
    %%Contact: sergeyge
	
	Realizes break at hard hyphen
----------------------------------------------------------------------------*/
static LSERR TryBreakAtHardHyphen(PCLOCCHNK plocchnk, long itxtobj, long iwch, BRKKIND brkkind,
													BOOL* pfBroken, PBRKOUT ptbo)
{

	LSERR lserr;
	BREAKINFO* pbrkinf;

	Assert(((PTXTOBJ)plocchnk->plschnk[itxtobj].pdobj)->txtkind == txtkindHardHyphen);
	Assert(!(((PTXTOBJ)plocchnk->plschnk[itxtobj].pdobj)->txtf & txtfGlyphBased));

	lserr = FillPtboPbrkinf(plocchnk, itxtobj, iwch, /*itxtobj,*/ iwch, brkkind, &pbrkinf, ptbo);
	if (lserr != lserrNone) return lserr;

	*pfBroken = fTrue;

	return lserrNone;
}

/* T R Y  B R E A K  A T  O P T  B R E A K */
/*----------------------------------------------------------------------------
    %%Function: TryBreakAtOptBreak
    %%Contact: sergeyge
	
	Realizes break at OptBreak
----------------------------------------------------------------------------*/
static LSERR TryBreakAtOptBreak(PCLOCCHNK plocchnk, long itxtobj, BRKKIND brkkind,
																 BOOL* pfBroken, PBRKOUT ptbo)
{

	LSERR lserr;
	PTXTOBJ ptxtobj;
	BREAKINFO* pbrkinf;

	ptxtobj = (PTXTOBJ)plocchnk->plschnk[itxtobj].pdobj;
	Assert(!(ptxtobj->txtf & txtfGlyphBased));

	Assert(ptxtobj->txtkind == txtkindOptBreak);
	Assert(ptxtobj->iwchLim == ptxtobj->iwchFirst + 1 && (ptxtobj->txtf & txtfVisi)||
			ptxtobj->iwchLim == ptxtobj->iwchFirst);

	lserr = FillPtboPbrkinf(plocchnk, itxtobj, ptxtobj->iwchLim-1, /*itxtobj,*/ ptxtobj->iwchLim-1,
											brkkind, &pbrkinf, ptbo);
	if (lserr != lserrNone) return lserr;
	
	ptbo->posichnk.dcp = 1;
	pbrkinf->dcp = 1;
	pbrkinf->brkt = brktOptBreak;

	*pfBroken = fTrue;

	return lserrNone;
}


/* T R Y  B R E A K  A T  E O L */
/*----------------------------------------------------------------------------
    %%Function: TryBreakAtEOL
    %%Contact: sergeyge
	
	Realizes break at EOP/EOL
----------------------------------------------------------------------------*/
static LSERR TryBreakAtEOL(PCLOCCHNK plocchnk, long itxtobj, BRKKIND brkkind, BOOL* pfBroken, PBRKOUT ptbo)
{

	LSERR lserr;
	PTXTOBJ ptxtobj;
	long itxtobjBefore;
	long iwchBefore;
	BREAKINFO* pbrkinf;

	ptxtobj = (PTXTOBJ)plocchnk->plschnk[itxtobj].pdobj; 

	Assert(ptxtobj->txtkind == txtkindEOL);
	Assert(ptxtobj->iwchLim == ptxtobj->iwchFirst + 1);

	FindNonSpaceBefore(plocchnk->plschnk, itxtobj, ptxtobj->iwchFirst, &itxtobjBefore, &iwchBefore);

	lserr = FillPtboPbrkinf(plocchnk, itxtobj, ptxtobj->iwchFirst, /*itxtobjBefore,*/ iwchBefore, 
													brkkind, &pbrkinf, ptbo);
	if (lserr != lserrNone) return lserr;

	*pfBroken = fTrue;

	return lserrNone;
}


/* T R Y  B R E A K  A T  N O N  R E Q  H Y P H E N */
/*----------------------------------------------------------------------------
    %%Function: TryBreakAtNonReqHyphen
    %%Contact: sergeyge
	
	Realizes break at NonReqHyphen.
----------------------------------------------------------------------------*/
static LSERR TryBreakAtNonReqHyphen(PCLOCCHNK plocchnk, long itxtobj, BRKKIND brkkind,
																 BOOL* pfBroken, PBRKOUT ptbo)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PLNOBJ plnobj;
	PTXTOBJ ptxtobj;
	YSRINF ysrinf;
	HYPHOUT hyphout;
	BREAKINFO* pbrkinf;
	LSCP cpMac;
	DWORD kysr;
	WCHAR wchYsr;
	long itxtobjPrev;
	long itxtobjPrevPrev;
	BOOL fSuccessful;
	long durBorder;
	long i;

	ptxtobj = (PTXTOBJ)plocchnk->plschnk[itxtobj].pdobj;
	plnobj = ptxtobj->plnobj;
	pilsobj = plnobj->pilsobj;
	cpMac = plocchnk->plschnk[itxtobj].cpFirst;

	Assert( ptxtobj->txtkind == txtkindNonReqHyphen);
	Assert(!(ptxtobj->txtf & txtfGlyphBased));

	lserr = (*pilsobj->plscbk->pfnGetHyphenInfo)(pilsobj->pols, plocchnk->plschnk[itxtobj].plsrun, &kysr, &wchYsr);
   	if (lserr != lserrNone) return lserr;

	if (kysr == kysrNil)
		kysr = kysrNormal;

	ysrinf.wchYsr = wchYsr;
	ysrinf.kysr = (WORD)kysr;

	itxtobjPrev = ichnkOutside;
	for (i=itxtobj; i >= 0 && plocchnk->plschnk[i].cpFirst > cpMac - 1; i--);
	if (i >= 0)
		itxtobjPrev = i;

	itxtobjPrevPrev = ichnkOutside;
	for (i=itxtobj; i >= 0 && plocchnk->plschnk[i].cpFirst > cpMac - 2; i--);
	if (i >= 0)
		itxtobjPrevPrev = i;
	
	lserr = ProcessYsr(plocchnk, itxtobj, - 1, itxtobjPrev, itxtobjPrevPrev, ysrinf, &fSuccessful, &hyphout);
	if (lserr != lserrNone) return lserr;

	if (fSuccessful)
		{

		durBorder = 0;
		if (plocchnk->plschnk[itxtobj].plschp->fBorder)
			{
			lserr = LsdnGetBorderAfter(pilsobj->plsc, ptxtobj->plsdnUpNode, &durBorder);
			Assert(lserr == lserrNone);
			}

		if (plocchnk->ppointUvLoc[itxtobj].u + hyphout.durChangeTotal + durBorder <= 
									plocchnk->lsfgi.urColumnMax || brkkind == brkkindNext)
			{
			*pfBroken = fTrue;

			ptbo->fSuccessful = fTrue;
			ptbo->posichnk.ichnk = itxtobj;
			ptbo->posichnk.dcp = 1;

			lserr = LsdnGetObjDim(pilsobj->plsc, ptxtobj->plsdnUpNode, &ptbo->objdim);
			if (lserr != lserrNone) return lserr;

			ptbo->objdim.dur += hyphout.durChangeTotal;

			lserr = GetPbrkinf(pilsobj, plocchnk->plschnk[itxtobj].pdobj, brkkind, &pbrkinf);
			if (lserr != lserrNone) return lserr;

			pbrkinf->pdobj = plocchnk->plschnk[itxtobj].pdobj;
			pbrkinf->brkkind = brkkind;
			pbrkinf->dcp = 1;

			pbrkinf->brkt = brktNonReq;

			pbrkinf->u.nonreq.durHyphen = hyphout.durHyphen;
			if (pilsobj->grpf & fTxtVisiCondHyphens)
				{
				pbrkinf->u.nonreq.wchHyphenPres = pilsobj->wchVisiNonReqHyphen;
				pbrkinf->u.nonreq.dupHyphen = plnobj->pdup[ptxtobj->iwchFirst];
				}
			else
				{	
				pbrkinf->u.nonreq.wchHyphenPres = pilsobj->wchHyphen;
				pbrkinf->u.nonreq.dupHyphen = hyphout.dupHyphen;
				}

			pbrkinf->u.nonreq.iwchLim = hyphout.iwchLim;
			pbrkinf->u.nonreq.dwchYsr = hyphout.dwchYsr - 1;
			pbrkinf->u.nonreq.durPrev = hyphout.durPrev;
			pbrkinf->u.nonreq.dupPrev = hyphout.dupPrev;
			pbrkinf->u.nonreq.durPrevPrev = hyphout.durPrevPrev;
			pbrkinf->u.nonreq.dupPrevPrev = hyphout.dupPrevPrev;
			pbrkinf->u.nonreq.ddurDnodePrev = hyphout.ddurDnodePrev;
			pbrkinf->u.nonreq.ddurDnodePrevPrev = hyphout.ddurDnodePrevPrev;
			pbrkinf->u.nonreq.ddurTotal = hyphout.durChangeTotal;
			pbrkinf->u.nonreq.wchPrev = hyphout.wchPrev;
			pbrkinf->u.nonreq.wchPrevPrev = hyphout.wchPrevPrev;
			pbrkinf->u.nonreq.gindPrev = hyphout.gindPrev;
			pbrkinf->u.nonreq.gindPrevPrev = hyphout.gindPrevPrev;
			pbrkinf->u.nonreq.igindPrev = hyphout.igindPrev;
			pbrkinf->u.nonreq.igindPrevPrev = hyphout.igindPrevPrev;
			}
		}
	return lserrNone;
}

/* T R Y  B R E A K  A F T E R  C H U N K */
/*----------------------------------------------------------------------------
    %%Function: TryBreakAfterChunk
    %%Contact: sergeyge

----------------------------------------------------------------------------*/
static LSERR TryBreakAfterChunk(PCLOCCHNK plocchnk, BRKCOND brkcond, BOOL* pfBroken, PBRKOUT ptbo)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobjLast;
	long itxtobjLast;
	long iwchLast;
	long itxtobjBefore;
	long iwchBefore;
	BOOL fNonSpaceFound;
	BRKCOND brkcondTemp;
	BREAKINFO* pbrkinf;
	

	*pfBroken = fFalse;

	itxtobjLast = plocchnk->clschnk-1;
	ptxtobjLast = (PTXTOBJ)plocchnk->plschnk[itxtobjLast].pdobj;
	pilsobj = ptxtobjLast->plnobj->pilsobj;
	iwchLast = ptxtobjLast->iwchLim - 1;

	Assert(ptxtobjLast->txtkind != txtkindTab &&
			   ptxtobjLast->txtkind != txtkindEOL);

	switch (ptxtobjLast->txtkind)
		{
	case txtkindRegular:
	case txtkindSpecSpace:
	case txtkindYsrChar:

		fNonSpaceFound = FindNonSpaceBefore(plocchnk->plschnk, itxtobjLast, iwchLast,
																	&itxtobjBefore, &iwchBefore);

		if (pilsobj->grpf & fTxtApplyBreakingRules)

			{
			lserr = CanBreakAfterText(plocchnk, fNonSpaceFound, itxtobjBefore, iwchBefore, &brkcondTemp);
			if (lserr != lserrNone) return lserr;
			if (iwchBefore != iwchLast && brkcondTemp == brkcondCan)
				brkcondTemp = brkcondPlease;

			if (brkcond == brkcondPlease && brkcondTemp != brkcondNever ||
				brkcond == brkcondCan && brkcondTemp == brkcondPlease)
				{
				*pfBroken = fTrue;
				lserr = FillPtboPbrkinf(plocchnk, itxtobjLast, iwchLast, /*itxtobjBefore,*/ iwchBefore,
																		brkkindPrev, &pbrkinf, ptbo);
				if (lserr != lserrNone) return lserr;
				}
			}
		else
			{
			Assert(iwchLast >= ptxtobjLast->iwchFirst);
			if (brkcond == brkcondPlease || 
				brkcond == brkcondCan && iwchLast != iwchBefore)
				{
				*pfBroken = fTrue;
				lserr = FillPtboPbrkinf(plocchnk, itxtobjLast, iwchLast, /*itxtobjBefore,*/ iwchBefore,
																		brkkindPrev, &pbrkinf, ptbo);
				if (lserr != lserrNone) return lserr;
				}
			}
		break;
	case txtkindNonBreakSpace:
	case txtkindNonBreakHyphen:
	case txtkindOptNonBreak:
		break;
	case txtkindHardHyphen:
        lserr = TryBreakAtHardHyphen(plocchnk, itxtobjLast, iwchLast, brkkindPrev, pfBroken, ptbo);
		if (lserr != lserrNone) return lserr;
		break;
	case txtkindOptBreak:
        lserr = TryBreakAtOptBreak(plocchnk, itxtobjLast, brkkindPrev, pfBroken, ptbo);
		if (lserr != lserrNone) return lserr;
		break;
	case txtkindNonReqHyphen:
        lserr = TryBreakAtNonReqHyphen(plocchnk, itxtobjLast, brkkindPrev, pfBroken, ptbo);
		if (lserr != lserrNone) return lserr;
		break;
		}
	
	return lserrNone;
}

/* T R Y  B R E A K  B E F O R E  C H U N K */
/*----------------------------------------------------------------------------
    %%Function: TryBreakBeforeChunk
    %%Contact: sergeyge

----------------------------------------------------------------------------*/
static LSERR TryBreakBeforeChunk(PCLOCCHNK plocchnk, BRKCOND brkcond, BOOL* pfBroken, PBRKOUT ptbo)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	BRKCOND brkcondTemp;

	pilsobj = ((PTXTOBJ)plocchnk->plschnk[0].pdobj)->plnobj->pilsobj;

	*pfBroken = fFalse;

	if (!(pilsobj->grpf & fTxtApplyBreakingRules))
		*pfBroken = (brkcond == brkcondPlease);
	else 
		{
		lserr = CanBreakBeforeText(plocchnk, &brkcondTemp);
		if (lserr != lserrNone) return lserr;
		*pfBroken = (brkcond == brkcondPlease && brkcondTemp != brkcondNever ||
						brkcond == brkcondCan && brkcondTemp == brkcondPlease);			
		}

	if (*pfBroken)
		{
		memset(ptbo, 0, sizeof (*ptbo));
		ptbo->fSuccessful = fTrue;
		return lserrNone;
		}

	return lserrNone;

}



/* C A N  B R E A K  B E F O R E  T E X T */
/*----------------------------------------------------------------------------
    %%Function: CanBreakBeforeText
    %%Contact: sergeyge

	Checks if break before text chunk is possible.
----------------------------------------------------------------------------*/
static LSERR CanBreakBeforeText(PCLOCCHNK plocchnk, BRKCOND* pbrktxt)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	WCHAR wch;
	BRKCLS brkclsBefore;
	BRKCLS brkclsJunk;

	Assert(plocchnk->clschnk > 0);
	ptxtobj = (PTXTOBJ)plocchnk->plschnk[0].pdobj;
	pilsobj = ptxtobj->plnobj->pilsobj;
	if (plocchnk->lsfgi.fFirstOnLine || !FRegularBreakableBeforeDobj(ptxtobj))
		{
		*pbrktxt = brkcondNever;
		}
	else
		{
		wch = pilsobj->pwchOrig[ptxtobj->iwchFirst];
		if ( (wch == pilsobj->wchSpace || ptxtobj->txtkind == txtkindSpecSpace) &&
					 !(pilsobj->grpf & fTxtWrapAllSpaces) )
			{
			*pbrktxt = brkcondNever;
			}
		else
			{
			lserr =(*pilsobj->plscbk->pfnGetBreakingClasses)(pilsobj->pols, plocchnk->plschnk[0].plsrun,
					plocchnk->plschnk[0].cpFirst, wch, &brkclsJunk, &brkclsBefore);
			if (lserr != lserrNone) return lserr;

			lserr = (*pilsobj->plscbk->pfnCanBreakBeforeChar)(pilsobj->pols, brkclsBefore, pbrktxt);
			if (lserr != lserrNone) return lserr;
			
			}
		}

	return lserrNone;

}				

/* C A N  B R E A K  A F T E R  T E X T */
/*----------------------------------------------------------------------------
    %%Function: CanBreakAfterText
    %%Contact: sergeyge

	Checks if break after text chunk is possible.
----------------------------------------------------------------------------*/
static LSERR CanBreakAfterText(PCLOCCHNK plocchnk, BOOL fNonSpaceFound, long itxtobjBefore,
																	long iwchBefore, BRKCOND* pbrktxt)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	BRKCLS brkclsAfter;
	BRKCLS brkclsJunk;

	if (fNonSpaceFound)
		{
		ptxtobj = (PTXTOBJ)plocchnk->plschnk[itxtobjBefore].pdobj;
		
		pilsobj = ptxtobj->plnobj->pilsobj;

		Assert(ptxtobj->txtkind != txtkindTab &&
			   ptxtobj->txtkind != txtkindSpecSpace &&
			   ptxtobj->txtkind != txtkindEOL);

		if (ptxtobj->txtkind == txtkindHardHyphen ||
			ptxtobj->txtkind == txtkindOptBreak ||
			ptxtobj->txtkind == txtkindNonReqHyphen)
			{
			*pbrktxt = brkcondPlease;
			}
		else if (ptxtobj->txtkind == txtkindNonBreakSpace ||
			ptxtobj->txtkind == txtkindNonBreakHyphen ||
			ptxtobj->txtkind == txtkindOptNonBreak)
			{
			*pbrktxt = brkcondNever;
			}
		else
			{
			Assert(ptxtobj->txtkind == txtkindRegular ||
			   ptxtobj->txtkind == txtkindYsrChar);

			lserr =(*pilsobj->plscbk->pfnGetBreakingClasses)(pilsobj->pols,
				plocchnk->plschnk[itxtobjBefore].plsrun,
				plocchnk->plschnk[itxtobjBefore].cpFirst + (iwchBefore - ptxtobj->iwchFirst),
				pilsobj->pwchOrig[iwchBefore], &brkclsAfter, &brkclsJunk);
			if (lserr != lserrNone) return lserr;

			lserr = (*pilsobj->plscbk->pfnCanBreakAfterChar)(pilsobj->pols, brkclsAfter, pbrktxt);
			if (lserr != lserrNone) return lserr;
			}
		}
	else
		{
		/* REVIEW sergeyge: check if it is correct	*/
		*pbrktxt = brkcondPlease;
//		*pbrktxt = brkcondNever;
		}

	return lserrNone;

}				

/* F I L L  P T B O  P B R K I N F */
/*----------------------------------------------------------------------------
    %%Function: FillPtboPbrkinf
    %%Contact: sergeyge
	
	Prepares output of the breaking procedure
----------------------------------------------------------------------------*/
static LSERR FillPtboPbrkinf(PCLOCCHNK plocchnk, long itxtobj, long iwch, 
										/* long itxtobjBefore,*/ long iwchBefore, BRKKIND brkkind,
										BREAKINFO** ppbrkinf, PBRKOUT ptbo)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	long dwchBreak;
	long igindLim;
	long dur;

	ptxtobj = (PTXTOBJ)plocchnk->plschnk[itxtobj].pdobj;
	pilsobj = ptxtobj->plnobj->pilsobj;
	dwchBreak = iwch - ptxtobj->iwchFirst + 1;
	igindLim = 0;

	if (ptxtobj->txtf & txtfGlyphBased)
		{
		igindLim = IgindFirstFromIwch(ptxtobj, ptxtobj->iwchFirst + dwchBreak);
		lserr = CalcPartWidthsGlyphs(ptxtobj, dwchBreak, &ptbo->objdim, &dur);
		}
	else
		lserr = CalcPartWidths(ptxtobj, dwchBreak, &ptbo->objdim, &dur);
	if (lserr != lserrNone) return lserr;

	ptbo->fSuccessful = fTrue;
	ptbo->objdim.dur = dur;
	ptbo->posichnk.ichnk = itxtobj;
	ptbo->posichnk.dcp = dwchBreak;

	if (iwchBefore < ptxtobj->iwchFirst)
		{
		if (!(pilsobj->grpf & fTxtSpacesInfluenceHeight))
			{
			ptbo->objdim.heightsRef.dvMultiLineHeight = dvHeightIgnore;
			ptbo->objdim.heightsPres.dvMultiLineHeight = dvHeightIgnore;
			}
		}

	lserr = GetPbrkinf(pilsobj, (PDOBJ)ptxtobj, brkkind, ppbrkinf);
	if (lserr != lserrNone) return lserr;

	(*ppbrkinf)->pdobj = (PDOBJ)ptxtobj;
	(*ppbrkinf)->brkkind = brkkind;
	(*ppbrkinf)->dcp = (LSDCP)dwchBreak;
	(*ppbrkinf)->u.normal.igindLim = igindLim;
	Assert((*ppbrkinf)->brkt == brktNormal);
	Assert((*ppbrkinf)->u.normal.durFix == 0);

	return lserrNone;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\lstxtbrs.c ===
#include "lsmem.h"
#include <limits.h>
#include "lstxtbrs.h"
#include "lstxtmap.h"
#include "lsdntext.h"
#include "zqfromza.h"
#include "locchnk.h"
#include "posichnk.h"
#include "objdim.h"
#include "lskysr.h"
#include "lstxtffi.h"
#include "txtils.h"
#include "txtln.h"
#include "txtobj.h"

static void GetOneCharWidth(PTXTOBJ ptxtobj, long dwch, long* pdurChar);
static LSERR GetWidthOfGlyph(PILSOBJ pilsobj, PLSRUN plsrun, LSTFLOW lstflow, WCHAR wch, BOOL* pfSuccessful, 
											GINDEX* pgind, long* pdurNew, long* pdupNew);
static LSERR GetWidthOfChar(PILSOBJ pilsobj, PLSRUN plsrun, LSTFLOW lstflow, WCHAR wch,
																			long* pdurNew, long* pdupNew);


/* F I N D  N O N  S P A C E  B E F O R E */
/*----------------------------------------------------------------------------
    %%Function: FindNonSpaceBefore
    %%Contact: sergeyge
	
----------------------------------------------------------------------------*/
BOOL FindNonSpaceBefore(PCLSCHNK rglschnk, long itxtobjCur, long iwchCur,
									long* pitxtobjBefore, long* piwchBefore)
{
	PILSOBJ pilsobj;
	long iwch;
	BOOL fInSpace;
	long itxtobj;
	PTXTOBJ ptxtobj;
	long iwchFirst;

	pilsobj = ((PTXTOBJ)rglschnk[0].pdobj)->plnobj->pilsobj;

	fInSpace = fTrue;
	itxtobj = itxtobjCur;

	iwch = iwchCur;

	while (fInSpace && itxtobj >= 0)
		{
		ptxtobj = (PTXTOBJ)rglschnk[itxtobj].pdobj;

		if ((ptxtobj->txtkind != txtkindRegular && ptxtobj->txtkind != txtkindSpecSpace || 
			(pilsobj->grpf & fTxtWrapAllSpaces)) && ptxtobj->txtkind != txtkindEOL )
			{
			*pitxtobjBefore = itxtobj;
			*piwchBefore = ptxtobj->iwchLim - 1;
			if (iwchCur < *piwchBefore)
				*piwchBefore = iwchCur;
			fInSpace = fFalse;
			}
		else if (ptxtobj->txtkind == txtkindRegular)
			{
			iwchFirst = ptxtobj->iwchFirst;

			for (; iwch >= iwchFirst && pilsobj->pwchOrig[iwch] == pilsobj->wchSpace; iwch--);

			if (iwch >= iwchFirst)
				{
				*pitxtobjBefore = itxtobj;
				*piwchBefore = iwch;
				fInSpace = fFalse;
				}
			}

		iwch = ptxtobj->iwchFirst - 1;
		itxtobj--;

		}

	if (fInSpace)
		{
		*pitxtobjBefore = 0;
		*piwchBefore = iwch;
		}

	return !fInSpace;

}

/* F I N D  N O N  S P A C E  A F T E R */
/*----------------------------------------------------------------------------
    %%Function: FindNonSpaceAfter
    %%Contact: sergeyge
	
----------------------------------------------------------------------------*/
BOOL FindNonSpaceAfter(PCLSCHNK rglschnk, DWORD clschnk, long itxtobjCur, long iwchCur,
									long* pitxtobjAfter, long* piwchAfter)
{
	PILSOBJ pilsobj;
	long iwch;
	BOOL fInSpace;
	long itxtobj;
	PTXTOBJ ptxtobj;
	long iwchLim;

	pilsobj = ((PTXTOBJ)rglschnk[0].pdobj)->plnobj->pilsobj;

	fInSpace = fTrue;
	itxtobj = itxtobjCur;

	iwch = iwchCur;

	while (fInSpace && itxtobj < (long)clschnk)
		{
		ptxtobj = (PTXTOBJ)rglschnk[itxtobj].pdobj;

		if (ptxtobj->txtkind != txtkindRegular && ptxtobj->txtkind != txtkindSpecSpace ||
				(pilsobj->grpf & fTxtWrapAllSpaces))
			{
			*pitxtobjAfter = itxtobj;
			*piwchAfter = ptxtobj->iwchFirst;
			if (iwchCur > *piwchAfter)
				*piwchAfter = iwchCur;
			fInSpace = fFalse;
			}
		else if (ptxtobj->txtkind == txtkindRegular)
			{
			iwchLim = ptxtobj->iwchLim;
			for (; iwch < iwchLim && pilsobj->pwchOrig[iwch] == pilsobj->wchSpace; iwch++);
			if (iwch < iwchLim)
				{
				*pitxtobjAfter = itxtobj;
				*piwchAfter = iwch;
				fInSpace = fFalse;
				}
			}

		iwch = ptxtobj->iwchLim;
		itxtobj++;
		}


	if (fInSpace)
		{
		*pitxtobjAfter = clschnk - 1;   /* Important for correct ptbo settting in TryBreakAcrossSpaces */
		*piwchAfter = iwch;
		}

	return !fInSpace;
	
}

/* F I N D  P R E V  C H A R */
/*----------------------------------------------------------------------------
    %%Function: FindPrevChar
    %%Contact: sergeyge
	
----------------------------------------------------------------------------*/
BOOL FindPrevChar(PCLSCHNK rglschnk, long itxtobjCur, long iwchCur,
																long* pitxtobjBefore, long* piwchBefore)
{
	PTXTOBJ ptxtobj;

	ptxtobj = (PTXTOBJ)rglschnk[itxtobjCur].pdobj;

	if (iwchCur > ptxtobj->iwchFirst)
		{
		*pitxtobjBefore = itxtobjCur;
		*piwchBefore = iwchCur - 1;
		return fTrue;
		}
	else if (itxtobjCur > 0)
		{
		*pitxtobjBefore = itxtobjCur - 1;
		*piwchBefore = ((PTXTOBJ)rglschnk[*pitxtobjBefore].pdobj)->iwchLim - 1;
		return fTrue;
		}
	else
		{
		*pitxtobjBefore = 0;
		*piwchBefore = ((PTXTOBJ)rglschnk[0].pdobj)->iwchFirst - 1;
		}

	return fFalse;
}



/* F I N D  N E X T  C H A R */
/*----------------------------------------------------------------------------
    %%Function: FindNextChar
    %%Contact: sergeyge
	
----------------------------------------------------------------------------*/
BOOL FindNextChar(PCLSCHNK rglschnk, DWORD clschnk, long itxtobjCur, long iwchCur,
																long* pitxtobjAfter, long* piwchAfter)
{
	PTXTOBJ ptxtobj;

	ptxtobj = (PTXTOBJ)rglschnk[itxtobjCur].pdobj;

	if (iwchCur < ptxtobj->iwchLim - 1)
		{
		*pitxtobjAfter = itxtobjCur;
		*piwchAfter = iwchCur + 1;
		return fTrue;
		}
	else if (itxtobjCur < (long)clschnk - 1)
		{
		*pitxtobjAfter = itxtobjCur + 1;
		*piwchAfter = ((PTXTOBJ)rglschnk[*pitxtobjAfter].pdobj)->iwchFirst;
		return fTrue;
		}
	else
		{
		/* not found but set correct values for ptbo in TryBreakAcrossSpaces */
		*pitxtobjAfter = clschnk - 1;
		*piwchAfter = ((PTXTOBJ)rglschnk[*pitxtobjAfter].pdobj)->iwchLim;
		}

	return fFalse;
}



/* C A L C  P A R T  W I D T H S */
/*----------------------------------------------------------------------------
    %%Function: CalcPartWidths
    %%Contact: sergeyge
	
	Calculates width from the beginning of the dobj until character iwchLim
----------------------------------------------------------------------------*/
LSERR CalcPartWidths(PTXTOBJ ptxtobj, long dwchLim, POBJDIM pobjdim, long* pdur)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	long* rgdur;
	long durSum;
	long i;

	pilsobj = ptxtobj->plnobj->pilsobj;

	rgdur = pilsobj->pdur;

	Assert(dwchLim <= ptxtobj->iwchLim - ptxtobj->iwchFirst);

	lserr = LsdnGetObjDim(pilsobj->plsc, ptxtobj->plsdnUpNode, pobjdim);
	if (lserr != lserrNone) return lserr;

	if (dwchLim == 0)
		{
		*pdur = 0;
		return lserrNone;
		}

	durSum = 0;
	/* Calculate the tail of the string, then subtract */ 
	for (i = ptxtobj->iwchFirst + dwchLim; i < ptxtobj->iwchLim; i++)
		{
		durSum += rgdur[i];
		}

	*pdur = pobjdim->dur - durSum;

	return lserrNone;	
}

/* C A L C  P A R T  W I D T H S  G L Y P H S */
/*----------------------------------------------------------------------------
    %%Function: CalcPartWidthsGlyphs
    %%Contact: sergeyge
	
	Calculates width from the beginning of the dobj until character iwchLim
----------------------------------------------------------------------------*/
LSERR CalcPartWidthsGlyphs(PTXTOBJ ptxtobj, long dwchLim, POBJDIM pobjdim, long* pdur)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	long* rgdurGind;
	long durSum;
	long igindStart;
	long i;

	pilsobj = ptxtobj->plnobj->pilsobj;

	rgdurGind = pilsobj->pdurGind;

	Assert(dwchLim <= ptxtobj->iwchLim - ptxtobj->iwchFirst);

	
	Assert(ptxtobj->iwchFirst + dwchLim == ptxtobj->iwchLim ||
						pilsobj->ptxtinf[ptxtobj->iwchFirst + dwchLim].fFirstInContext);
	igindStart = IgindFirstFromIwch(ptxtobj, ptxtobj->iwchFirst + dwchLim);

	lserr = LsdnGetObjDim(pilsobj->plsc, ptxtobj->plsdnUpNode, pobjdim);
	if (lserr != lserrNone) return lserr;

	durSum = 0;
	/* Calculate the tail of the string, then subtract */ 
	for (i = igindStart; i < ptxtobj->igindLim; i++)
		{
		durSum += rgdurGind[i];
		}

	*pdur = pobjdim->dur - durSum;

	return lserrNone;	
}


/* C H E C K  H O T  Z O N E */
/*----------------------------------------------------------------------------
    %%Function: CheckHotZone
    %%Contact: sergeyge
	
----------------------------------------------------------------------------*/
LSERR CheckHotZone(PCLOCCHNK plocchnk, long itxtobj, long iwch, BOOL* pfInHyphenZone)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	long dur;
	long durLeftIndent;
	OBJDIM objdim;

	ptxtobj = (PTXTOBJ)plocchnk->plschnk[itxtobj].pdobj;
	pilsobj = ptxtobj->plnobj->pilsobj;

	if (ptxtobj->txtf & txtfGlyphBased)
		lserr = CalcPartWidthsGlyphs(ptxtobj, iwch + 1 - ptxtobj->iwchFirst, &objdim, &dur);
	else
		lserr = CalcPartWidths(ptxtobj, iwch + 1 - ptxtobj->iwchFirst, &objdim, &dur);

	if (lserr != lserrNone) return lserr;

	durLeftIndent = 0;

	if (pilsobj->grpf & fTxtIndentChangesHyphenZone	)
		{
		lserr = LsdnGetLeftIndentDur(pilsobj->plsc, &durLeftIndent);
		Assert(lserr == lserrNone);
		}

	*pfInHyphenZone = 
			(plocchnk->lsfgi.urColumnMax - (plocchnk->ppointUvLoc[itxtobj].u + dur) + durLeftIndent >= 
			UrFromUa(plocchnk->lsfgi.lstflow, &pilsobj->lsdevres, pilsobj->duaHyphenationZone) );

	return lserrNone;
}

/* P R O C E S S  Y S R */
/*----------------------------------------------------------------------------
    %%Function: ProcessYsr
    %%Contact: sergeyge
	
----------------------------------------------------------------------------*/
LSERR ProcessYsr(PCLOCCHNK plocchnk, long itxtobjYsr, long dwchYsr, long itxtobjPrev, long itxtobjPrevPrev,
														YSRINF ysrinf, BOOL* pfSuccess, HYPHOUT* phyphout)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PLNOBJ plnobj;
	PTXTOBJ ptxtobjYsr;
	PTXTOBJ ptxtobjPrev;
	PTXTOBJ ptxtobjPrevPrev;
	const LSCHNKE* pchnkeYsr;
	const LSCHNKE* pchnkePrev;
	const LSCHNKE* pchnkePrevPrev;
	long iwchYsr;
	long durPrevOld = 0;
	long durPrevPrevOld = 0;
	long dupNew;
	long durNew;
	long dupHyphen;
	long durHyphen;
	BOOL fSuccessful;
	GINDEX gind;

	memset(phyphout, 0, sizeof(*phyphout));
	*pfSuccess = fTrue;

	pchnkeYsr = &plocchnk->plschnk[itxtobjYsr];
	ptxtobjYsr = (PTXTOBJ)pchnkeYsr->pdobj;
	plnobj = ptxtobjYsr->plnobj;
	pilsobj = plnobj->pilsobj;

	iwchYsr = ptxtobjYsr->iwchFirst + dwchYsr;

	if (ptxtobjYsr->txtf & txtfGlyphBased)
		{
		lserr = GetWidthOfGlyph(pilsobj, pchnkeYsr->plsrun, plocchnk->lsfgi.lstflow, pilsobj->wchHyphen,
									 &fSuccessful, &gind, &durHyphen, &dupHyphen);
		if (lserr != lserrNone) return lserr;

		if (!fSuccessful)
			{
			*pfSuccess = fFalse;
			return lserrNone;
			}

		phyphout->gindHyphen = gind;
		phyphout->igindHyphen = IgindFirstFromIwch(ptxtobjYsr, iwchYsr) + 1;
		}
	else
		{
		lserr = GetWidthOfChar(pilsobj, pchnkeYsr->plsrun, plocchnk->lsfgi.lstflow, pilsobj->wchHyphen, &durHyphen, &dupHyphen);
		if (lserr != lserrNone) return lserr;
		}
	
	phyphout->durHyphen = durHyphen;
	phyphout->dupHyphen = dupHyphen;
	Assert(phyphout->wchPrev == 0);
	Assert(phyphout->durPrev == 0);
	Assert(phyphout->dupPrev == 0);
	Assert(phyphout->wchPrevPrev == 0);
	Assert(phyphout->durPrevPrev == 0);
	Assert(phyphout->dupPrevPrev == 0);

	switch (ysrinf.kysr)
		{
	case kysrNormal:
	case kysrChangeAfter:
		if (itxtobjPrev == itxtobjYsr && (ptxtobjYsr->txtf & txtfGlyphBased) && !FIwchOneToOne(pilsobj, iwchYsr))
			{
			*pfSuccess = fFalse;
			return lserrNone;
			}

		phyphout->iwchLim = iwchYsr + 2;
		phyphout->dwchYsr = 2;

		phyphout->durChangeTotal = durHyphen;
		break;

	case kysrChangeBefore:
		if (itxtobjPrev == ichnkOutside)
			{
			*pfSuccess = fFalse;
			return lserrNone;
			}

		pchnkePrev = &plocchnk->plschnk[itxtobjPrev];
		ptxtobjPrev = (PTXTOBJ)pchnkePrev->pdobj;

		if (iwchYsr < ptxtobjPrev->iwchFirst || iwchYsr >= ptxtobjPrev->iwchLim)
			{
			*pfSuccess = fFalse;
			return lserrNone;
			}

		if (ptxtobjPrev->txtf & txtfGlyphBased)
			{
			lserr = GetWidthOfGlyph(pilsobj, pchnkePrev->plsrun, plocchnk->lsfgi.lstflow, ysrinf.wchYsr,
										 &fSuccessful, &gind, &durNew, &dupNew);
			if (lserr != lserrNone) return lserr;

			if (!fSuccessful || !FIwchOneToOne(pilsobj, iwchYsr))
				{
				*pfSuccess = fFalse;
				return lserrNone;
				}
			phyphout->gindPrev = gind;
			phyphout->igindPrev = IgindFirstFromIwch(ptxtobjPrev, iwchYsr);
			}
		else
			{
			lserr = GetWidthOfChar(pilsobj, pchnkePrev->plsrun, plocchnk->lsfgi.lstflow, ysrinf.wchYsr, &durNew, &dupNew);
			if (lserr != lserrNone) return lserr;
			}

		GetOneCharWidth(ptxtobjPrev, iwchYsr, &durPrevOld);

		phyphout->iwchLim = iwchYsr + 2;
		phyphout->dwchYsr = 2;

		phyphout->wchPrev = ysrinf.wchYsr;
		phyphout->durPrev = durNew;
		phyphout->dupPrev = dupNew;

		phyphout->durChangeTotal = durHyphen + durNew - durPrevOld;
		break;

	case kysrAddBefore:
		if (ptxtobjYsr->txtf & txtfGlyphBased)
			{
			lserr = GetWidthOfGlyph(pilsobj, pchnkeYsr->plsrun, plocchnk->lsfgi.lstflow, ysrinf.wchYsr,
										 &fSuccessful, &gind, &durNew, &dupNew);
			if (lserr != lserrNone) return lserr;

			if (!fSuccessful || !FIwchOneToOne(pilsobj, iwchYsr))
				{
				*pfSuccess = fFalse;
				return lserrNone;
				}
			phyphout->gindPrev = gind;
			phyphout->igindHyphen++;
			phyphout->igindPrev = phyphout->igindHyphen - 1;
			}
		else
			{
			lserr = GetWidthOfChar(pilsobj, pchnkeYsr->plsrun, plocchnk->lsfgi.lstflow, ysrinf.wchYsr, &durNew, &dupNew);
			if (lserr != lserrNone) return lserr;
			}

		/* procedure CheckReallocArrays made shure we have enough space in arrays */
		phyphout->iwchLim = iwchYsr + 3;
		phyphout->dwchYsr = 3;

		phyphout->wchPrev = ysrinf.wchYsr;
		phyphout->durPrev = durNew;
		phyphout->dupPrev = dupNew;

		phyphout->durChangeTotal = durHyphen + durNew;
		break;

	case kysrDelAndChange:
		if (itxtobjPrev == ichnkOutside || itxtobjPrevPrev == ichnkOutside)
			{
			*pfSuccess = fFalse;
			return lserrNone;
			}
		

		pchnkePrev = &plocchnk->plschnk[itxtobjPrev];
		ptxtobjPrev = (PTXTOBJ)pchnkePrev->pdobj;
		pchnkePrevPrev = &plocchnk->plschnk[itxtobjPrevPrev];
		ptxtobjPrevPrev = (PTXTOBJ)pchnkePrevPrev->pdobj;

		if (iwchYsr < ptxtobjPrev->iwchFirst || iwchYsr >= ptxtobjPrev->iwchLim ||
			iwchYsr - 1 < ptxtobjPrevPrev->iwchFirst || iwchYsr - 1>= ptxtobjPrevPrev->iwchLim)
			{
			*pfSuccess = fFalse;
			return lserrNone;
			}

		GetOneCharWidth(ptxtobjPrev, iwchYsr, &durPrevOld);
		GetOneCharWidth(ptxtobjPrevPrev, iwchYsr - 1, &durPrevPrevOld);

		if (ptxtobjPrev->txtf & txtfGlyphBased)
			{
			lserr = GetWidthOfGlyph(pilsobj, pchnkePrev->plsrun, plocchnk->lsfgi.lstflow, pilsobj->wchSpace,
										 &fSuccessful, &gind, &durNew, &dupNew);
			if (lserr != lserrNone) return lserr;

			if (!fSuccessful || !FIwchOneToOne(pilsobj, iwchYsr))
				{
				*pfSuccess = fFalse;
				return lserrNone;
				}
			phyphout->gindPrev = gind;
			phyphout->igindPrev = IgindFirstFromIwch(ptxtobjPrev, iwchYsr);
			}

		if (ptxtobjPrevPrev->txtf & txtfGlyphBased)
			{
			lserr = GetWidthOfGlyph(pilsobj, pchnkePrevPrev->plsrun, plocchnk->lsfgi.lstflow, ysrinf.wchYsr,
										 &fSuccessful, &gind, &durNew, &dupNew);
			if (lserr != lserrNone) return lserr;

			if (!fSuccessful || !FIwchOneToOne(pilsobj, iwchYsr - 1))
				{
				*pfSuccess = fFalse;
				return lserrNone;
				}
			phyphout->gindPrevPrev = gind;
			phyphout->igindPrevPrev = IgindFirstFromIwch(ptxtobjPrevPrev, iwchYsr - 1);
			}
		else
			{
			lserr = GetWidthOfChar(pilsobj, pchnkePrevPrev->plsrun, plocchnk->lsfgi.lstflow, ysrinf.wchYsr, &durNew, &dupNew);
			if (lserr != lserrNone) return lserr;
			}

		
		phyphout->iwchLim = iwchYsr + 2;
		phyphout->dwchYsr = 2;

		phyphout->wchPrev = pilsobj->wchSpace;
		phyphout->durPrev = 0;
		phyphout->dupPrev = 0;
		phyphout->wchPrevPrev = ysrinf.wchYsr;
		phyphout->durPrevPrev = durNew;
		phyphout->dupPrevPrev = dupNew;

		phyphout->durChangeTotal = durHyphen + durNew - durPrevOld - durPrevPrevOld;
		
		break;

	case kysrDeleteBefore:
		if (itxtobjPrev == ichnkOutside)
			{
			*pfSuccess = fFalse;
			return lserrNone;
			}

		pchnkePrev = &plocchnk->plschnk[itxtobjPrev];
		ptxtobjPrev = (PTXTOBJ)pchnkePrev->pdobj;

		if (iwchYsr < ptxtobjPrev->iwchFirst || iwchYsr >= ptxtobjPrev->iwchLim)
			{
			*pfSuccess = fFalse;
			return lserrNone;
			}

		GetOneCharWidth(ptxtobjPrev, iwchYsr, &durPrevOld);

		if (ptxtobjPrev->txtf & txtfGlyphBased)
			{
			lserr = GetWidthOfGlyph(pilsobj, pchnkePrev->plsrun, plocchnk->lsfgi.lstflow, pilsobj->wchSpace,
										 &fSuccessful, &gind, &durNew, &dupNew);
			if (lserr != lserrNone) return lserr;

			if (!fSuccessful || !FIwchOneToOne(pilsobj, iwchYsr))
				{
				*pfSuccess = fFalse;
				return lserrNone;
				}
			phyphout->gindPrev = gind;
			phyphout->igindPrev = IgindFirstFromIwch(ptxtobjPrev, iwchYsr);
			}


		phyphout->iwchLim = iwchYsr + 2;
		phyphout->dwchYsr = 2;

		phyphout->wchPrev = pilsobj->wchSpace;
		phyphout->durPrev = 0;
		phyphout->dupPrev = 0;

		phyphout->durChangeTotal = durHyphen - durPrevOld;
		break;
	default:
		NotReached();
		}

	if (itxtobjPrev != itxtobjYsr && durPrevOld != 0)
		{
		phyphout->ddurDnodePrev += (phyphout->durPrev - durPrevOld);
		}

	if (itxtobjPrevPrev != itxtobjYsr && durPrevPrevOld != 0)
		{
		if (itxtobjPrev == itxtobjPrevPrev || itxtobjPrev == itxtobjYsr)
			{
			phyphout->ddurDnodePrev += (phyphout->durPrevPrev - durPrevPrevOld);
			}
		else
			{
			phyphout->ddurDnodePrevPrev += (phyphout->durPrevPrev - durPrevPrevOld);
			}
		}

	return lserrNone;
}

#define cIncreaseBeakInfoMax	4

/* G E T  P B R K I N F */
/*----------------------------------------------------------------------------
    %%Function: GetPbrkinf
    %%Contact: sergeyge
	
	Gets the pointer to the available BREAKINFO staructure
----------------------------------------------------------------------------*/
LSERR GetPbrkinf(PILSOBJ pilsobj, PDOBJ pdobj, BRKKIND brkkind, BREAKINFO** ppbrkinf)
{
	LSERR lserr;
	BREAKINFO* pbreakinf;
	long ibrkinf = 0xFFFF;
	BOOL fInChildList;

	pbreakinf = pilsobj->pbreakinf;

	lserr = LsdnFInChildList(pilsobj->plsc, ((PTXTOBJ)pdobj)->plsdnUpNode, &fInChildList);
	Assert(lserr == lserrNone);

	if (!fInChildList)
		{
		switch(brkkind)
			{
		case brkkindPrev:
			ibrkinf = 0;
			break;
		case brkkindNext:
			ibrkinf = 1;
			break;
		case brkkindForce:
			ibrkinf = 2;
			break;
		default:
			NotReached();
			}
		}
	else
		{
		for (ibrkinf = 3; ibrkinf < (long)pilsobj->breakinfMac && 
					(pbreakinf[ibrkinf].pdobj != pdobj || pbreakinf[ibrkinf].brkkind != brkkind); ibrkinf++);
		}

	if (ibrkinf < (long)pilsobj->breakinfMac)
		{
		Assert(ibrkinf < 3 || pbreakinf[ibrkinf].pdobj == pdobj && pbreakinf[ibrkinf].brkkind == brkkind);
		*ppbrkinf = &pbreakinf[ibrkinf];
		}
	else if (pilsobj->breakinfMac < pilsobj->breakinfMax)
		{
		*ppbrkinf = &pilsobj->pbreakinf[pilsobj->breakinfMac];
		pilsobj->breakinfMac++;
		}
	else
		{
		Assert(pilsobj->breakinfMac == pilsobj->breakinfMax);
		pbreakinf = (*pilsobj->plscbk->pfnReallocPtr)(pilsobj->pols, pilsobj->pbreakinf,
									 (pilsobj->breakinfMax + cIncreaseBeakInfoMax) * sizeof(BREAKINFO) );
		if (pbreakinf == NULL)
			{
			return lserrOutOfMemory;
			}
		pilsobj->pbreakinf = pbreakinf;
		pilsobj->breakinfMax += cIncreaseBeakInfoMax;

		*ppbrkinf = &pilsobj->pbreakinf[pilsobj->breakinfMac];
		pilsobj->breakinfMac++;
		}

	memset(*ppbrkinf, 0, sizeof(BREAKINFO));

	return lserrNone;
}

/* Internal functions implementation */

/* G E T  O N E  C H A R  W I D T H */
/*----------------------------------------------------------------------------
    %%Function: GetOneCharWidth
    %%Contact: sergeyge
	
	Reports width of the character iwch
----------------------------------------------------------------------------*/
static void GetOneCharWidth(PTXTOBJ ptxtobj, long iwch, long* pdurChar)
{
	if (ptxtobj->txtf & txtfGlyphBased)
		*pdurChar = ptxtobj->plnobj->pilsobj->pdurGind[IgindFirstFromIwch(ptxtobj, iwch)];
	else 
		*pdurChar = ptxtobj->plnobj->pilsobj->pdur[iwch];
}

/* G E T  W I D T H  O F  C H A R */
/*----------------------------------------------------------------------------
    %%Function: GetWidthOfChar
    %%Contact: sergeyge
	
	Reports width of the character wch with plsrun
----------------------------------------------------------------------------*/
static LSERR GetWidthOfChar(PILSOBJ pilsobj, PLSRUN plsrun, LSTFLOW lstflow, WCHAR wch, long* pdurNew, long* pdupNew)
{
	LSERR lserr;
	long durSumJunk;
	long limDurJunk;

	lserr = (*pilsobj->plscbk->pfnGetRunCharWidths)(pilsobj->pols, plsrun, lsdevReference, &wch, 1, LONG_MAX, lstflow,
																		(int*)pdurNew, &durSumJunk, &limDurJunk);
	if (lserr != lserrNone) return lserr;

	if (pilsobj->fDisplay)
		{
		if (!pilsobj->fPresEqualRef)
			{		
			lserr = (*pilsobj->plscbk->pfnGetRunCharWidths)(pilsobj->pols, plsrun, lsdevPres, &wch, 1, LONG_MAX, lstflow,
																		(int*)pdupNew, &durSumJunk, &limDurJunk);
			if (lserr != lserrNone) return lserr;
			}
		else            /* fPresEqualRef        */
			{
			*pdupNew = *pdurNew;
			}
		}

	return lserrNone;
	
}

/* G E T  W I D T H  O F  G L Y P H */
/*----------------------------------------------------------------------------
    %%Function: GetWidthOfGlyph
    %%Contact: sergeyge
	
	Reports width of the glyph corresponding to the character with plsrun
----------------------------------------------------------------------------*/
static LSERR GetWidthOfGlyph(PILSOBJ pilsobj, PLSRUN plsrun, LSTFLOW lstflow, WCHAR wch, BOOL* pfSuccessful, 
											GINDEX* pgind, long* pdurNew, long* pdupNew)
{
	LSERR lserr;
	GPROP* pgpropTemp;
	GPROP gprop;
	GMAP gmap;
	GINDEX* pgindTemp;
	DWORD cgind;
	GOFFSET goffs;

	*pfSuccessful = fTrue;

	lserr = (*pilsobj->plscbk->pfnGetGlyphs)(pilsobj->pols, plsrun, &wch, 1, lstflow, &gmap, &pgindTemp, &pgpropTemp, &cgind);
	if (lserr != lserrNone) return lserr;

	if (cgind != 1)
		{
		*pfSuccessful = fFalse;
		return lserrNone;
		}

	*pgind = *pgindTemp;
	gprop = *pgpropTemp;

	lserr = (*pilsobj->plscbk->pfnGetGlyphPositions)(pilsobj->pols, plsrun, lsdevReference, &wch, &gmap, 1, pgind,
				&gprop, cgind, lstflow,
				(int*)pdurNew, &goffs);
	if (lserr != lserrNone) return lserr;
	
	Assert(goffs.du == 0);
	Assert(goffs.dv == 0);

	if (pilsobj->fDisplay)
		{
		if (!pilsobj->fPresEqualRef)
			{
			lserr = (*pilsobj->plscbk->pfnGetGlyphPositions)(pilsobj->pols, plsrun, lsdevPres, &wch, &gmap, 1, pgind,
				&gprop, cgind, lstflow,
				(int*)pdupNew, &goffs);
			if (lserr != lserrNone) return lserr;
			}
		else
			*pdupNew = *pdurNew;
		}

	return lserrNone;
	
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\lstxtmap.c ===
#include "lstxtmap.h"
#include "txtinf.h"
#include "txtginf.h"
#include "txtobj.h"
#include "txtils.h"


/* ==============================================================	*/
/* IgndFirstFromIwch	Find first GL index for a given IWCH		*/
/*																	*/
/* Contact: antons													*/
/* ==============================================================	*/

long IgindFirstFromIwch(PTXTOBJ ptxtobj, long iwch)
{
	PLNOBJ  plnobj  = ptxtobj->plnobj;

	Assert (FBetween (iwch, ptxtobj->iwchFirst, ptxtobj->iwchLim));

	/* Since "pilsobj->pgmap [iwch]" - */
	/* GL index is not absolute but RELATIVE to the first run shaped */
	/* with ptxtobj "together", we have to calculate required GL index */
	/* with the following folmula: */

	if (iwch == ptxtobj->iwchLim)
		return ptxtobj->igindLim;
	else
		return ptxtobj->igindFirst + plnobj->pgmap [iwch] - 
				plnobj->pgmap [ptxtobj->iwchFirst];
}

/* ==============================================================	*/
/* IgindFirstFromIwchVeryFirst 										*/
/*																	*/
/* Contact: antons													*/
/* ==============================================================	*/

long IgindFirstFromIwchVeryFirst (PTXTOBJ ptxtobj, long igindVeryFirst, long iwch)
{
	Assert (ptxtobj->iwchLim > ptxtobj->iwchFirst);

	return igindVeryFirst + ptxtobj->plnobj->pgmap [iwch];
}


/* ==============================================================	*/
/* IgindLastFromIwchVeryFirst										*/
/*																	*/
/* Contact: antons													*/
/* ==============================================================	*/

long IgindLastFromIwchVeryFirst (PTXTOBJ ptxtobj, long igindVeryFirst, long iwch)
{
	TXTGINF* pginf = ptxtobj->plnobj->pilsobj->pginf; 
	long igindLast;

	Assert (ptxtobj->iwchLim > ptxtobj->iwchFirst);

	igindLast = IgindFirstFromIwchVeryFirst (ptxtobj, igindVeryFirst, iwch);

	while (! (pginf [igindLast] & ginffLastInContext)) igindLast++;

	return igindLast;
}

void GetIgindsFromTxtobj ( PTXTOBJ	ptxtobj, 
						   long 	igindVeryFirst, 
						   long * 	pigindFirst, 
						   long * 	pigindLim )
{
	PLNOBJ  plnobj = ptxtobj->plnobj;
	PILSOBJ pilsobj = plnobj->pilsobj;
	TXTGINF* pginf = pilsobj->pginf; 
	long igindLast;

	Assert (ptxtobj->iwchLim > ptxtobj->iwchFirst);
	Assert (pilsobj->ptxtinf [ptxtobj->iwchFirst].fFirstInContext);
	Assert (pilsobj->ptxtinf [ptxtobj->iwchLim-1].fLastInContext);
	
	*pigindFirst = igindVeryFirst + plnobj->pgmap [ptxtobj->iwchFirst];

	igindLast = IgindFirstFromIwch (ptxtobj, ptxtobj->iwchLim-1);

	while (! (pginf [igindLast] & ginffLastInContext)) igindLast++;

	*pigindLim = igindLast + 1;
}





/* ==============================================================	*/
/* IgndLastFromIwch		Find last GL index for a given IWCH			*/
/*																	*/
/* Contact: antons													*/
/* ==============================================================	*/

long IgindLastFromIwch(PTXTOBJ ptxtobj, long iwch)
{
	PILSOBJ  pilsobj  = ptxtobj->plnobj->pilsobj;
	TXTGINF* pginf    = pilsobj->pginf; 
	long igindLast;

	if (iwch < ptxtobj->iwchFirst)
		return -1;

	igindLast = IgindFirstFromIwch (ptxtobj, iwch);

	Assert (FBetween (iwch, ptxtobj->iwchFirst, ptxtobj->iwchLim-1));

	while (! (pginf [igindLast] & ginffLastInContext)) igindLast++;

	Assert (ptxtobj->igindLim == 0 || FBetween (igindLast, ptxtobj->igindFirst, ptxtobj->igindLim-1));

	return igindLast;
}


/* ===================================================================	*/
/* IgindBaseFromIgind:													*/
/* Returns last glyph with non-zero width before IGIND in this context	*/
/*																		*/
/* Contact: antons														*/
/* ===================================================================	*/

long IgindBaseFromIgind(PILSOBJ pilsobj, long igind)
{
	TXTGINF* pginf    = pilsobj->pginf; 

	/*  Very simple... just scan back until <> 0 */

	while (pilsobj->pdurGind [igind] == 0 && !(pginf [igind] & ginffFirstInContext)) 
		{

		Assert (igind > 0);

		igind --;
		}

	return igind;
}


/* ===================================================================	*/
/* IwchFirstFromIgind:													*/
/* Returns first IWCH in the context for a given IGIND					*/
/*																		*/
/* Contact: antons														*/
/* ===================================================================	*/

long IwchFirstFromIgind(PTXTOBJ ptxtobj, long igind)
{
	PILSOBJ  pilsobj  = ptxtobj->plnobj->pilsobj;
	TXTINF*  ptxtinf  = pilsobj->ptxtinf;
	TXTGINF* pginf    = pilsobj->pginf; 

	long iwchFirst	= ptxtobj->iwchFirst;
	long igindLast	= ptxtobj->igindFirst;

	Assert (FBetween (igind, ptxtobj->igindFirst, ptxtobj->igindLim-1));

	/* Go ahead until we have found last GIND of the first conext in txtobj */
		
	while (! (pginf [igindLast] & ginffLastInContext)) igindLast++;

	/* The following LOOP goes ahead checking context after context 	/* beginning of txtobj

	   INVARIANT:

			iwchFirst -- First IWCH of the current context
			igindLast -- Last  GIND of the current context
			
	   The second condition is true because of the "while" above

	*/

	while (igindLast < igind)
	{

		/* Asserts to check that INVARIANT is true */
		
		Assert (ptxtinf  [iwchFirst].fFirstInContext);
		Assert (pginf [igindLast] & ginffLastInContext);

		/* Move ahead by 1 context... it is easy */

		igindLast++;
		while (! (pginf [igindLast] & ginffLastInContext)) igindLast++;
		while (! (ptxtinf [iwchFirst]. fLastInContext)) iwchFirst++;
		iwchFirst++;
	};

	/* Asserts to check that we have not gone out from txtobj boundaries before reaching igind */

	Assert (FBetween (iwchFirst, ptxtobj->iwchFirst, ptxtobj->iwchLim-1));
	Assert (FBetween (igindLast, ptxtobj->igindFirst, ptxtobj->igindLim-1));
	
	/* Well, since INVARIANT is true and "igindLast >= igind", 
	   igind should belong to the current context. What we have to return
	   is just iwchFirst 
	*/

	return iwchFirst;
}

/* ===================================================================	*/
/* IwchLastFromIwch:													*/
/* Returns last iwch of context from given iwch							*/
/*																		*/
/* Contact: antons														*/
/* ===================================================================	*/

long IwchLastFromIwch(PTXTOBJ ptxtobj, long iwch)
{
	PILSOBJ  pilsobj  = ptxtobj->plnobj->pilsobj;
	TXTINF*  ptxtinf  = pilsobj->ptxtinf;

	Assert(iwch >= ptxtobj->iwchFirst && iwch < ptxtobj->iwchLim);

	while (! (ptxtinf [iwch]. fLastInContext))
		iwch++;

	Assert(iwch >= ptxtobj->iwchFirst && iwch < ptxtobj->iwchLim);

	return iwch;
}

/* ===================================================================	*/
/* IwchPrevLastFromIwch:												*/
/* Returns last iwch of previous context from given iwch				*/
/*																		*/
/* Contact: antons														*/
/* ===================================================================	*/

long IwchPrevLastFromIwch(PTXTOBJ ptxtobj, long iwch)
{
	PILSOBJ  pilsobj  = ptxtobj->plnobj->pilsobj;
	TXTINF*  ptxtinf  = pilsobj->ptxtinf;

	long iwchFirst	= ptxtobj->iwchFirst;

	iwch--;

	Assert(iwch >= ptxtobj->iwchFirst && iwch < ptxtobj->iwchLim);

	while (iwch >= iwchFirst && ! (ptxtinf [iwch]. fLastInContext))
		iwch--;

	return iwch;
}


/* ===================================================================	*/
/* FIwchOneToOne:														*/
/* Checks that IWCH belongs to 1:1 context								*/
/*																		*/
/* Contact: antons														*/
/* ===================================================================	*/

BOOL FIwchOneToOne(PILSOBJ pilsobj, long iwch)
{
	return pilsobj->ptxtinf [iwch].fOneToOne;
}


/* ===================================================================	*/
/* FIwchLastInContext:													*/
/* Checks that IWCH is last in the context								*/
/*																		*/
/* Contact: antons														*/
/* ===================================================================	*/

BOOL FIwchLastInContext(PILSOBJ pilsobj, long iwch)
{
	return pilsobj->ptxtinf [iwch].fLastInContext;

}

/* ===================================================================	*/
/* FIwchFirstInContext:													*/
/* Checks that IWCH is first in the context								*/
/*																		*/
/* Contact: antons														*/
/* ===================================================================	*/

BOOL FIwchFirstInContext(PILSOBJ pilsobj, long iwch)
{
	return pilsobj->ptxtinf [iwch].fFirstInContext;
}


/* ===================================================================	*/
/* FIgindLastInContext:													*/
/* Checks that a given GL index is last in the context					*/
/*																		*/
/* Contact: antons														*/
/* ===================================================================	*/

BOOL FIgindLastInContext(PILSOBJ pilsobj, long igind)
{
	return pilsobj->pginf [igind] & ginffLastInContext;
}

/* ===================================================================	*/
/* FIgindFirstInContext:												*/
/* Checks that a given GL index is first in the context					*/
/*																		*/
/* Contact: antons														*/
/* ===================================================================	*/

BOOL FIgindFirstInContext(PILSOBJ pilsobj, long igind)
{
	return pilsobj->pginf [igind] & ginffFirstInContext;
}


/* ===================================================================	*/
/* DcpAfterContextFromDcp:												*/
/* For a given DCP (from the beginning of txtobj) it returns DCP after	*/
/* context bondary														*/
/*																		*/	
/* Function assumes that DCP starts with 1 and means					*/
/* "number of characters" from the beginning of txtobj. The resulting	*/
/* DCP (number of characters) will contain the rest of last context in	*/
/* given DCP. If context was closed then it returns the same DCP		*/	
/*																		*/
/* Contact: antons														*/
/* ===================================================================	*/

long DcpAfterContextFromDcp(PTXTOBJ ptxtobj, long dcp)
{
	PILSOBJ  pilsobj  = ptxtobj->plnobj->pilsobj;
	TXTINF*  ptxtinf  = pilsobj->ptxtinf;

	/* Translate dcp to iwchLast */

	long iwchLast = ptxtobj->iwchFirst + dcp - 1; 

	/* Here we check that iwchLast "= dcp-1" is correct for a given txtobj */

	Assert (FBetween (iwchLast, ptxtobj->iwchFirst, ptxtobj->iwchLim-1));

	/* Just scan ahead until context finishes */

	while (! ptxtinf [iwchLast].fLastInContext) iwchLast++;

	/* Again check that we are in txtobj boundaries */
	
	Assert (FBetween (iwchLast, ptxtobj->iwchFirst, ptxtobj->iwchLim-1));

	/* Translate iwchLast back to dcp */

	return iwchLast - ptxtobj->iwchFirst + 1;
}


/* ===================================================================	*/
/* InterpretMap															*/	
/*																		*/
/* Fills internal CH- and GL- based bits with context information		*/	
/* (the information is used by the rest functions in this file only)	*/
/*																		*/
/* IN:	pilsobj															*/
/*		iwchFirst	- The first iwch in "shaped together" chunk			*/
/*		dwch		- Number of characters in this chunk				*/
/*		igindFirst	- The first gind in "shaped together chunk			*/
/*		cgind		- Number of glyphs in this chunk					*/
/*																		*/
/* OUT:	(nothing)														*/
/*																		*/
/* Contact: antons														*/
/* ===================================================================	*/

void InterpretMap(PLNOBJ plnobj, long iwchFirst, long dwch, long igindFirst, long cgind)
{

	TXTINF*  ptxtinf  = plnobj->pilsobj->ptxtinf;
	TXTGINF* pginf    = plnobj->pilsobj->pginf; 
	GMAP*	 pgmap	  = plnobj->pgmap;

	/* Last possible iwch and gind (remember, they are "last", not "lim" */

	long iwchLast  = iwchFirst + dwch - 1;
	long igindLast = igindFirst + cgind - 1;

	/* Two global variables for main loop */

	long iwchFirstInContext = iwchFirst;
	long igindFirstInContext = igindFirst;
	
	/* The following WHILE translates context after context

		INVARIANT:

			* iwchFirstInContext   -- The first iwch in current context
			* igindFirstInContext  -- The first gind in current context
			* All context to the left from current have been translated

		The loop translates current context and moves iwchFirstIn... &
		igindFirst... to the next context

	*/

	while (iwchFirstInContext <= iwchLast)
			
		/* According to D.Gris I should have checked "!= iwchLast+1" but I do not
		   like ship version to come to infinite loop even because of wrong data ;-)
		   For debug, I will have Assert right after loop terminates */	
	
		{

		/* Variables for last gind and iwch of the current context */

		long igindLastInContext;
		long iwchLastInContext = iwchFirstInContext;

		/* Just to make sure that igindFirst... corresponds to iwchFirst... */

		Assert ( pgmap [iwchFirstInContext] + igindFirst == igindFirstInContext );
		Assert (iwchLastInContext <= iwchLast);

		/* P.S. Since pgmap values are RELATIVE to the beginning of "shape together"
		   chunk, we shall ALWAYS add igindFirst to pgmap value in order to get
		   GL index in our meaning 
		*/
		
		/* Following simple loop with find correct iwchLastInContext */
		/* Note that we add igindFirst to pgmap value (see PS. above) */

		while ((iwchLastInContext <= iwchLast) && (pgmap [iwchLastInContext] + igindFirst == igindFirstInContext)) 
			iwchLastInContext++;

		iwchLastInContext--;

		/* Now we know iwchLastInContextare and we are ready to find igindLastInContext 

		   I will peep in pgmap value of the character following iwchLastInContext or take
		   last avaiable GL index (igindLast) if iwchLastInContext is really last available

		*/

		igindLastInContext = (iwchLastInContext < iwchLast ? 
			pgmap [iwchLastInContext+1] + igindFirst - 1 :
			igindLast
		);

		/* Check that there is at least one GL inside our context */
		/* Note: we do not need to check the same for characters */

		Assert (igindFirstInContext <= igindLastInContext);

		/* It is time to set flags in our GL and CH arrays */

		if ( ( iwchFirstInContext ==  iwchLastInContext) && 
			 (igindFirstInContext == igindLastInContext))
			{

			/* We have 1:1 mapping (I separate it for better perfomance) */
			
			ptxtinf [iwchFirstInContext].fOneToOne = fTrue;
			ptxtinf [iwchFirstInContext].fFirstInContext = fTrue;
			ptxtinf [iwchFirstInContext].fLastInContext = fTrue;

			/* See comments in "General case" */

			pginf [igindFirstInContext] |= ginffOneToOne | ginffFirstInContext | ginffLastInContext;
			}
		else 
			{
			
			/* General case when there is not 1:1 mapping */
			
			long i; /* Variable for two loops */

			/* Set up character-based bits */
			
			for (i=iwchFirstInContext; i<=iwchLastInContext; i++)
				{
				ptxtinf [i].fOneToOne = fFalse; /* Of course, it is not 1:1 */

				/* I was considering whether to place boundary cases (first/last character
				   in context) outside loop but finally came to the conclusion that it would
				   cheaper both for code and perfomance to check it for each character as
				   follows */

				ptxtinf [i].fFirstInContext = (i==iwchFirstInContext);
				ptxtinf [i].fLastInContext = (i==iwchLastInContext);
				};

			
			/* With glyph-based flags we can win some perfomance by setting all bits in
			   one operation (since they are really bits, not booleans. Again I do not like
			   to do separate job for context boundaries */			

			for (i=igindFirstInContext; i<=igindLastInContext; i++)
				pginf [i] &= ~ (ginffOneToOne | ginffFirstInContext |
									ginffLastInContext);

			/* And finally I set corresponding bits for the first & last GLs in the context */

			pginf [igindFirstInContext] |= ginffFirstInContext;
			pginf [igindLastInContext] |= ginffLastInContext;
			};


		/* To start loop again we have to move to the next context. Now it is easy... */

		iwchFirstInContext = iwchLastInContext+1;
		igindFirstInContext = igindLastInContext+1;
		};


	/* See comments in the beginning of the loop */

	Assert (iwchFirstInContext == iwchLast + 1);
	Assert (igindFirstInContext == igindLast + 1);

	/* And according to INVARIANT, we are done */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\lstxtmod.c ===
#include "lstxtmod.h"

#include "lsems.h"
#include "txtils.h"

void GetChanges(LSACT lsact, LSEMS* plsems, long durCur, BOOL fByIsPlus, BYTE* pside, long* pddurChange)
{
	*pside = lsact.side;
	switch (lsact.kamnt)
		{
	case kamntNone:
		*pddurChange = 0;
		break;
	case kamntToHalfEm:
		*pddurChange = plsems->em2 - durCur;
		break;
	case kamntToQuarterEm:
		*pddurChange = plsems->em4 - durCur;
		break;
	case kamntToThirdEm:
		*pddurChange = plsems->em3 - durCur;
		break;
	case kamntTo15Sixteenth:
		*pddurChange = plsems->em16 - durCur;
		break;
	case kamntToUserDefinedExpan:
		*pddurChange = plsems->udExp - durCur;
		break;
	case kamntToUserDefinedComp:
		*pddurChange = plsems->udComp - durCur;
		break;
	case kamntByHalfEm:
		if (fByIsPlus)
			*pddurChange = plsems->em2;
		else
			*pddurChange = -plsems->em2;
		break;
	case kamntByQuarterEm:
		if (fByIsPlus)
			*pddurChange = plsems->em4;
		else
			*pddurChange = -plsems->em4;
		break;
	case kamntByEighthEm:
		if (fByIsPlus)
			*pddurChange = plsems->em8;
		else
			*pddurChange = -plsems->em8;
		break;
	case kamntByUserDefinedExpan:
		if (fByIsPlus)
			*pddurChange = plsems->udExp;
		else
			*pddurChange = -plsems->udExp;
		break;
	case kamntByUserDefinedComp:
		if (fByIsPlus)
			*pddurChange = plsems->udComp;
		else
			*pddurChange = -plsems->udComp;
		break;
	default:
		Assert(fFalse);
		}

	if (*pddurChange < -durCur)
		*pddurChange = -durCur;

}

void TranslateChanges(BYTE sideRecom, long durAdjustRecom, long durCur, long durRight, long durLeft,
														 BYTE* psideFinal, long* pdurChange)
{
	long durLeftRecom = 0;
	long durRightRecom = 0;

	Assert(sideRecom != sideNone);

	switch (sideRecom)
		{
	case sideRight:
		durLeftRecom = 0;
		durRightRecom = durAdjustRecom - durRight;
		break;
	case sideLeft:
		durRightRecom = 0;
		durLeftRecom = durAdjustRecom - durLeft;
		break;
	case sideLeftRight:
		durRightRecom = durAdjustRecom >> 1;
		durLeftRecom = durAdjustRecom - durRightRecom;
		durRightRecom -= durRight;
		durLeftRecom -= durLeft;
		break;
		}

	*psideFinal = sideNone;
	if (durRightRecom != 0 && durLeftRecom != 0)
		*psideFinal = sideLeftRight;
	else if (durRightRecom != 0)
		*psideFinal = sideRight;
	else if (durLeftRecom != 0)
		*psideFinal = sideLeft;

	*pdurChange = durLeftRecom + durRightRecom;

	if (*pdurChange < -durCur)
		*pdurChange = -durCur;
}

void ApplyChanges(PILSOBJ pilsobj, long iwch, BYTE side, long ddurChange)
{
	long ddurChangeLeft;
	long ddurChangeRight;

	pilsobj->pdur[iwch] += ddurChange;

	InterpretChanges(pilsobj, iwch, side, ddurChange, &ddurChangeLeft, &ddurChangeRight);
	Assert(ddurChange == ddurChangeLeft + ddurChangeRight);

	pilsobj->pdurLeft[iwch] += ddurChangeLeft;
	pilsobj->pdurRight[iwch] += ddurChangeRight;
}

void InterpretChanges(PILSOBJ pilsobj, long iwch, BYTE side, long ddurChange, long* pddurChangeLeft, long* pddurChangeRight)
{
	long ddurChangeLeftRight;

	switch (side)
		{
	case sideNone:
		Assert(ddurChange == 0);
		*pddurChangeLeft = 0;
		*pddurChangeRight = 0;
		break;
	case sideRight:
		Assert(pilsobj->pdurRight != NULL);
		*pddurChangeLeft = 0;
		*pddurChangeRight = ddurChange;
		break;
	case sideLeft:
		Assert(pilsobj->pdurLeft != NULL);
		*pddurChangeLeft = ddurChange;
		*pddurChangeRight = 0;
		break;
	case sideLeftRight:
		Assert(pilsobj->pdurRight != NULL);
		Assert(pilsobj->pdurLeft != NULL);
		ddurChangeLeftRight = ddurChange + pilsobj->pdurRight[iwch] + pilsobj->pdurLeft[iwch];
		*pddurChangeRight = (ddurChangeLeftRight >> 1) - pilsobj->pdurRight[iwch];
		*pddurChangeLeft = (ddurChange - *pddurChangeRight);
		break;
		}
}

void UndoAppliedChanges(PILSOBJ pilsobj, long iwch, BYTE side, long* pddurChange)
{
	Assert(side == sideRight || side == sideLeft);

	switch (side)
		{
	case sideRight:
		Assert(pilsobj->pdurRight != NULL);
		*pddurChange = -pilsobj->pdurRight[iwch];
		pilsobj->pdurRight[iwch] = 0;
		break;
	case sideLeft:
		Assert(pilsobj->pdurLeft != NULL);
		*pddurChange = -pilsobj->pdurLeft[iwch];
		pilsobj->pdurLeft[iwch] = 0;
		break;
		}

	pilsobj->pdur[iwch] += *pddurChange;
	
}

void ApplyGlyphChanges(PILSOBJ pilsobj, long igind, long ddurChange)
{
/*	while (pilsobj->pdurGind[igind] == 0 && !pislobj->ptxtginf[igind].fFirstInContext)
		igind--;
*/
	pilsobj->pdurGind[igind] += ddurChange;

	Assert(pilsobj->pduGright != NULL);
	pilsobj->pduGright[igind] += ddurChange;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\lstxtnti.c ===
#include "lsmem.h"

#include "lstxtnti.h"
#include "lstxtmod.h"
#include "lstxtmap.h"
#include "lstxtbrs.h"
#include "lsdnset.h"
#include "lsdntext.h"
#include "lschp.h"
#include "lstxtffi.h"
#include "tnti.h"
#include "txtils.h"
#include "txtln.h"
#include "txtobj.h"
#include "lschnke.h"
#include "lsems.h"
#include "objdim.h"

#define max(a,b)     ((a) < (b) ? (b) : (a))


#define maskAllCharBasedArrays  (fTntiModWidthOnRun | fTntiModWidthSpace | fTntiModWidthPairs | \
			fTntiCompressOnRun | fTntiCompressSpace | fTntiCompressTable | \
			fTntiExpandOnRun | fTntiExpandSpace | fTntiExpandTable)

#define maskModWidth  (fTntiModWidthOnRun | fTntiModWidthSpace | fTntiModWidthPairs)

#define FModWidthSomeDobj(n)	(rglschnk[(n)].plschp->fModWidthOnRun || \
								rglschnk[(n)].plschp->fModWidthSpace || \
								rglschnk[(n)].plschp->fModWidthPairs)

static LSERR PrepareAllArraysGetModWidth(DWORD grpfTnti, DWORD cchnk, const LSCHNKE* rglschnk);
static LSERR ApplyKern(LSTFLOW lstflow, DWORD cchnk, const LSCHNKE* rglschnk);
static LSERR CheckApplyKernBetweenRuns(LSTFLOW lstflow, const LSCHNKE* rglschnk, long itxtobjPrev, long itxtobjCur);
static LSERR ApplyKernToRun(LSTFLOW lstflow, const LSCHNKE* rglschnk, long itxtobjCur);
static BOOL GetPrevImportantRun(const LSCHNKE* rglschnk, long itxtobj, long* pitxtobjPrev);
static BOOL GetNextImportantRun(DWORD cchnk, const LSCHNKE* rglschnk, long itxtobj, long* pitxtobjNext);
static LSERR GetModWidthClasses(DWORD cchnk, const LSCHNKE* rglschnk);
static LSERR ApplyModWidth(LSTFLOW lstflow, BOOL fFirstOnLine, BOOL fAutoNumberPresent, DWORD cchnk, const LSCHNKE* rglschnk);
static LSERR ApplySnapGrid(DWORD cchnk, const LSCHNKE* rglschnk);
static LSERR ApplyModWidthToRun(LSTFLOW lstflow, BOOL fFirstOnLine, BOOL fAutoNumberPresent, DWORD cchnk, const LSCHNKE* rglschnk, long itxtobjCur);
static LSERR CheckApplyModWidthBetweenRuns(LSTFLOW lstflow, const LSCHNKE* rglschnk, long itxtobjPrev, long itxtobjCur);
static LSERR CheckApplyPunctStartLine(PILSOBJ pilsobj, PLSRUN plsrun, LSEMS* plsems, long iwch,
																				long* pddurChange);
static LSERR CheckApplyModWidthSpace(PILSOBJ pilsobj, PLSRUN plsrunPrev, PLSRUN plsrunCur, PLSRUN plsrunNext,
						LSEMS* plsems, long iwchPrev, long iwchCur, long iwchNext, long* pddurChange);
static LSERR CheckApplyModWidthOnRun(PILSOBJ pilsobj, PTXTOBJ ptxtobjPrev, PLSRUN plsrunPrev, PLSRUN plsrunCur,
						LSEMS* plsems, long iwchFirst, long iwchSecond, long* pddurChange);
static LSERR ApplySnapChanges(PILSOBJ pilsobj, const LSCHNKE* rglschnk, long iwchFirstSnapped,
							 long itxtobjFirstSnapped, long iwchPrev, long itxtobjPrev, long durTotal);
static LSERR UndoAppliedModWidth(PILSOBJ pilsobj, const LSCHNKE* rglschnk,
										long itxtobj, long iwch, BYTE side, long* pdurUndo);
static LSERR CleanUpGrid(PILSOBJ pilsobj, PLSRUN* rgplsrun, LSCP* rgcp, BOOL* rgfSnapped, 
																				LSERR lserr);
static long CalcSnapped(long urPen, long urColumnMax, long cGrid, long durGridWhole, long durGridRem);

static LSERR ApplyGlyphs(LSTFLOW lstflow, DWORD cchnk, const LSCHNKE* rglschnk);
static LSERR ApplyGlyphsToRange(LSTFLOW lstflow, const LSCHNKE* rglschnk, long itxtobjFirst, long itxtobjLast);
static LSERR CheckReallocGlyphs(PLNOBJ plnobj, long cglyphs);
static LSERR FixGlyphSpaces(LSTFLOW lstflow, const LSCHNKE* rglschnk,
									long itxtobjFirst, long igindVeryFirst, long itxtobjLast);
static LSERR FixTxtobjs(const LSCHNKE* rglschnk, long itxtobjFirst, long igindFirst, long itxtobjLast);
static LSERR Realloc(PILSOBJ pols, void** pInOut, long cbytes);
static void	CopyGindices(PLNOBJ plnobj, GINDEX* pgindex, PGPROP pgprop, long cgind, long* pigindFirst);

#define CheckApplyModWidthTwoChars(pilsobj, plsemsFirst, plsemsSecond,\
						 iwchFirst, iwchSecond, pddurChangeFirst, pddurChangeSecond) \
{\
	LSPAIRACT lspairact;\
	MWCLS mwclsCur;\
	MWCLS mwclsNext;\
	BYTE side;\
\
	*(pddurChangeFirst) = 0;\
	*(pddurChangeSecond) = 0;\
	mwclsCur = (BYTE)(pilsobj)->ptxtinf[((iwchFirst))].mwcls;\
	mwclsNext = (BYTE)(pilsobj)->ptxtinf[(iwchSecond)].mwcls;\
	Assert(mwclsCur < (pilsobj)->cModWidthClasses);\
	Assert(mwclsNext < (pilsobj)->cModWidthClasses);\
	lspairact = \
		(pilsobj)->plspairact[(pilsobj)->pilspairact[(pilsobj)->cModWidthClasses * mwclsCur + mwclsNext]];\
\
	if (lspairact.lsactFirst.side != sideNone)\
		{\
		GetChanges(lspairact.lsactFirst, (plsemsFirst), (pilsobj)->pdur[((iwchFirst))], fFalse, &side, (pddurChangeFirst));\
		ApplyChanges((pilsobj), ((iwchFirst)), side, *(pddurChangeFirst));\
/*		(pilsobj)->ptxtinf[((iwchFirst))].fModWidthPair = fTrue;*/\
		}\
\
	if (lspairact.lsactSecond.side != sideNone)\
		{\
		GetChanges(lspairact.lsactSecond, (plsemsSecond), (pilsobj)->pdur[(iwchSecond)], fFalse, &side, (pddurChangeSecond));\
		ApplyChanges((pilsobj), (iwchSecond), side, *(pddurChangeSecond));\
/*		(pilsobj)->ptxtinf[(iwchSecond)].fModWidthPair = fTrue;*/\
		}\
\
}


LSERR NominalToIdealText(DWORD grpfTnti, LSTFLOW lstflow, BOOL fFirstOnLine, BOOL fAutoNumberPresent, DWORD cchnk, const LSCHNKE* rglschnk)
{
	LSERR lserr;
	PILSOBJ pilsobj;

	Assert(cchnk > 0);

	pilsobj = ((PTXTOBJ)rglschnk[0].pdobj)->plnobj->pilsobj;

	lserr = PrepareAllArraysGetModWidth(grpfTnti, cchnk, rglschnk);
	if (lserr != lserrNone) return lserr;

	if (grpfTnti & fTntiGlyphBased)
		{
		lserr = ApplyGlyphs(lstflow, cchnk, rglschnk);
		if (lserr != lserrNone) return lserr;
		}

	if (grpfTnti & fTntiKern)
		{
		lserr = ApplyKern(lstflow, cchnk, rglschnk);
		if (lserr != lserrNone) return lserr;
		}

	if ((grpfTnti & maskModWidth) || (pilsobj->grpf & fTxtPunctStartLine))
		{
		lserr = ApplyModWidth(lstflow, fFirstOnLine, fAutoNumberPresent, cchnk, rglschnk);
		if (lserr != lserrNone) return lserr;
		}

	if (pilsobj->fSnapGrid)
		{
#ifdef DEBUG
		{
		BOOL fInChildList;
		lserr = LsdnFInChildList(pilsobj->plsc, ((PTXTOBJ)rglschnk[0].pdobj)->plsdnUpNode, &fInChildList);
		Assert(lserr == lserrNone);
		Assert(!(grpfTnti & fTntiGlyphBased) || fInChildList);
		}
#endif
		lserr = ApplySnapGrid(cchnk, rglschnk);
		if (lserr != lserrNone) return lserr;
		}

	return lserr;
}

/* G E T  F I R S T  C H A R  I N  C H U N K */
/*----------------------------------------------------------------------------
    %%Function: GetFirstCharInChunk
    %%Contact: sergeyge

	Prepares information about first visible char in chunk
----------------------------------------------------------------------------*/
LSERR GetFirstCharInChunk(DWORD cchnk, const LSCHNKE* rglschnk, BOOL* pfSuccessful,
					 WCHAR* pwch, PLSRUN* pplsrun, PHEIGHTS pheights, MWCLS* pmwcls)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	long itxtobj;
	long iwch;
	PTXTOBJ ptxtobj;
	OBJDIM objdim;

	Assert(cchnk > 0);
	
	pilsobj = ((PTXTOBJ)rglschnk[0].pdobj)->plnobj->pilsobj;
	*pfSuccessful = fFalse;
	if (GetNextImportantRun(cchnk, rglschnk, 0, &itxtobj))
		{
		ptxtobj = (PTXTOBJ)rglschnk[itxtobj].pdobj;
		if (ptxtobj->txtf & txtfModWidthClassed)
			{
			Assert(!(ptxtobj->txtf & txtfGlyphBased));
			*pfSuccessful = fTrue;
			iwch = ptxtobj->iwchFirst;
			*pwch = pilsobj->pwchOrig[iwch];
			*pplsrun = rglschnk[itxtobj].plsrun;
			*pmwcls = (MWCLS)pilsobj->ptxtinf[iwch].mwcls;
			lserr = LsdnGetObjDim(pilsobj->plsc, ptxtobj->plsdnUpNode, &objdim);
			if (lserr != lserrNone) return lserr;
			*pheights = objdim.heightsRef;
			}
		}

	return lserrNone;

}

/* G E T  L A S T  C H A R  I N  C H U N K */
/*----------------------------------------------------------------------------
    %%Function: GetLastCharInChunk
    %%Contact: sergeyge

	Prepares information about first visible char in chunk
----------------------------------------------------------------------------*/
LSERR GetLastCharInChunk(DWORD cchnk, const LSCHNKE* rglschnk, BOOL* pfSuccessful,
					 WCHAR* pwch, PLSRUN* pplsrun, PHEIGHTS pheights, MWCLS* pmwcls)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	long itxtobj;
	long iwch;
	PTXTOBJ ptxtobj;
	OBJDIM objdim;

	Assert(cchnk > 0);
	
	pilsobj = ((PTXTOBJ)rglschnk[0].pdobj)->plnobj->pilsobj;
	*pfSuccessful = fFalse;
	if ( GetPrevImportantRun(rglschnk, cchnk - 1, &itxtobj))
		{
		ptxtobj = (PTXTOBJ)rglschnk[itxtobj].pdobj;
		if (ptxtobj->txtf & txtfModWidthClassed)
			{
			Assert(!(ptxtobj->txtf & txtfGlyphBased));
			*pfSuccessful = fTrue;
			iwch = ptxtobj->iwchLim - 1;
			*pwch = pilsobj->pwchOrig[iwch];
			*pplsrun = rglschnk[itxtobj].plsrun;
			*pmwcls = (MWCLS)pilsobj->ptxtinf[iwch].mwcls;
			lserr = LsdnGetObjDim(pilsobj->plsc, ptxtobj->plsdnUpNode, &objdim);
			if (lserr != lserrNone) return lserr;
			*pheights = objdim.heightsRef;
			}
		}

	return lserrNone;

}

/* M O D I F Y  F I R S T  C H A R  I N  C H U N K */
/*----------------------------------------------------------------------------
    %%Function: ModifyFirstCharInChunk
    %%Contact: sergeyge

	Prepares information about first visible char in chunk
----------------------------------------------------------------------------*/
LSERR ModifyFirstCharInChunk(DWORD cchnk, const LSCHNKE* rglschnk, long durChange)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	long itxtobj;
	long iwch;
	PTXTOBJ ptxtobj;
	BOOL fFound;

	Assert(cchnk > 0);
	
	pilsobj = ((PTXTOBJ)rglschnk[0].pdobj)->plnobj->pilsobj;

	fFound = GetNextImportantRun(cchnk, rglschnk, 0, &itxtobj);

	Assert(fFound);
	Assert(pilsobj->pdurLeft != NULL);

	ptxtobj = (PTXTOBJ)rglschnk[itxtobj].pdobj;

	Assert(!(ptxtobj->txtf & txtfGlyphBased));
	Assert(ptxtobj->txtf & txtfModWidthClassed);

	iwch = ptxtobj->iwchFirst;
	ApplyChanges(pilsobj, iwch, sideLeft, durChange);
	lserr = LsdnModifySimpleWidth(pilsobj->plsc, ptxtobj->plsdnUpNode, durChange);
	
	return lserrNone;
}

/* M O D I F Y  L A S T  C H A R  I N  C H U N K */
/*----------------------------------------------------------------------------
    %%Function: ModifyLastCharInChunk
    %%Contact: sergeyge

	Prepares information about first visible char in chunk
----------------------------------------------------------------------------*/
LSERR ModifyLastCharInChunk(DWORD cchnk, const LSCHNKE* rglschnk, long durChange)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	long itxtobj;
	long iwch;
	PTXTOBJ ptxtobj;
	BOOL fFound;

	Assert(cchnk > 0);
	
	pilsobj = ((PTXTOBJ)rglschnk[0].pdobj)->plnobj->pilsobj;

	fFound = GetPrevImportantRun(rglschnk, cchnk-1, &itxtobj);

	Assert(fFound);
	Assert(pilsobj->pdurRight != NULL);

	ptxtobj = (PTXTOBJ)rglschnk[itxtobj].pdobj;

	Assert(!(ptxtobj->txtf & txtfGlyphBased));
	Assert(ptxtobj->txtf & txtfModWidthClassed);

	iwch = ptxtobj->iwchLim - 1;
	ApplyChanges(pilsobj, iwch, sideRight, durChange);
	lserr = LsdnModifySimpleWidth(pilsobj->plsc, ptxtobj->plsdnUpNode, durChange);
	
	return lserrNone;
}

/* C U T  T E X T  D O B J */
/*----------------------------------------------------------------------------
    %%Function: CutTextDobj
    %%Contact: sergeyge

	Cuts characters according to dcpMaxContext
----------------------------------------------------------------------------*/

LSERR CutTextDobj(DWORD cchnk, const LSCHNKE* rglschnk)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	long itxtobjLast;
	long dcp;
	long dur;
	long iwchLim;
	long igindLim;
	long iwSpacesFirst;
	long iwSpacesLim;
	BOOL fNonSpaceBeforeFound;
	long itxtobjBefore;
	long iwchBefore;
	OBJDIM objdim;
	long itxtobj;
	BOOL fFixSpaces = fTrue;

	Assert(cchnk > 0);

	pilsobj = ((PTXTOBJ)rglschnk[0].pdobj)->plnobj->pilsobj;

	iwchLim = ((PTXTOBJ)rglschnk[cchnk - 1].pdobj)->iwchLim - rglschnk[cchnk-1].plschp->dcpMaxContext + 1;

	itxtobjLast = cchnk - 1;
	while (itxtobjLast >= 0 && iwchLim <= ((PTXTOBJ)rglschnk[itxtobjLast].pdobj)->iwchFirst)
		itxtobjLast--;

	if (itxtobjLast >= 0)
		{
		ptxtobj = (PTXTOBJ)rglschnk[itxtobjLast].pdobj;

		fNonSpaceBeforeFound = FindNonSpaceBefore(rglschnk, itxtobjLast, iwchLim - 1, &itxtobjBefore, &iwchBefore);

		if (fNonSpaceBeforeFound)
			{
			if (iwchBefore != iwchLim - 1)
				{
				Assert(itxtobjBefore >= 0);
				itxtobjLast = itxtobjBefore;
				iwchLim = iwchBefore + 1;
				ptxtobj = (PTXTOBJ)rglschnk[itxtobjLast].pdobj;
				}

			dcp = iwchLim - ptxtobj->iwchFirst;

			lserr = LsdnGetObjDim(pilsobj->plsc, ptxtobj->plsdnUpNode, &objdim);
			Assert(lserr == lserrNone);

			dur = objdim.dur;

			Assert(ptxtobj->iwchFirst + (long)dcp <= ptxtobj->iwchLim);
		
			if (ptxtobj->txtf & txtfGlyphBased)
				{
				long igind;

				Assert(iwchLim >= ptxtobj->iwchFirst);

/* REVIEW sergeyge: We should take IwchLastFromIwch instead and get rid of fFixSpaces---
		right?
*/
				if (iwchLim > ptxtobj->iwchFirst)
					iwchLim = IwchPrevLastFromIwch(ptxtobj, iwchLim) + 1;

				/* if part of Dnode is to be left, calculate this part
					else delete the whole Dnode
				*/
				if (iwchLim > ptxtobj->iwchFirst)
					{
					igindLim = IgindLastFromIwch(ptxtobj, iwchLim - 1) + 1;
					for (igind = igindLim; igind < ptxtobj->igindLim; igind++)
						dur -= pilsobj->pdurGind[igind];
					ptxtobj->iwchLim = iwchLim;
					ptxtobj->igindLim = igindLim;
					lserr = LsdnSetSimpleWidth(pilsobj->plsc, ptxtobj->plsdnUpNode, dur);
					Assert (lserr == lserrNone);
					lserr = LsdnResetDcp(pilsobj->plsc, 
											ptxtobj->plsdnUpNode, iwchLim - ptxtobj->iwchFirst);
					Assert (lserr == lserrNone);
					}
				else
					{
					itxtobjLast--;
					fFixSpaces = fFalse;
					}
			
				}
			else
				{
				long iwch;

				for (iwch = iwchLim; iwch < ptxtobj->iwchLim; iwch++)
					dur -= pilsobj->pdur[iwch];
				ptxtobj->iwchLim = iwchLim;
				lserr = LsdnSetSimpleWidth(pilsobj->plsc, ptxtobj->plsdnUpNode, dur);
				Assert (lserr == lserrNone);
				lserr = LsdnResetDcp(pilsobj->plsc, ptxtobj->plsdnUpNode, dcp);
				Assert (lserr == lserrNone);
			
				}

			if (fFixSpaces)
				{
				Assert(ptxtobj == (PTXTOBJ)rglschnk[itxtobjLast].pdobj);
				iwSpacesFirst = ptxtobj->u.reg.iwSpacesFirst;
				iwSpacesLim = ptxtobj->u.reg.iwSpacesLim;

				while (iwSpacesLim > iwSpacesFirst && pilsobj->pwSpaces[iwSpacesLim - 1] > iwchLim - 1)
					{
					iwSpacesLim--;
					}

				ptxtobj->u.reg.iwSpacesLim = iwSpacesLim;

				Assert(iwchLim == ptxtobj->iwchLim);

				if (iwSpacesLim - iwSpacesFirst == iwchLim - ptxtobj->iwchFirst && 
					!(pilsobj->grpf & fTxtSpacesInfluenceHeight) &&
					objdim.heightsRef.dvMultiLineHeight != dvHeightIgnore)
					{
					objdim.dur = dur;
					objdim.heightsRef.dvMultiLineHeight = dvHeightIgnore;
					objdim.heightsPres.dvMultiLineHeight = dvHeightIgnore;
					lserr = LsdnResetObjDim(pilsobj->plsc, ptxtobj->plsdnUpNode, &objdim);
					Assert (lserr == lserrNone);
					}
				}
			}
		else
			{
	/* dirty triangle: in the case of fNonSpaceFound==fFalse, correct itxtobjLast */ 
			itxtobjLast = -1;
			}
		}


	for (itxtobj = itxtobjLast + 1; itxtobj < (long)cchnk; itxtobj++)
		{
		lserr = LsdnSetSimpleWidth(pilsobj->plsc, ((PTXTOBJ)rglschnk[itxtobj].pdobj)->plsdnUpNode, 0);
		Assert (lserr == lserrNone);
		lserr = LsdnResetDcp(pilsobj->plsc, ((PTXTOBJ)rglschnk[itxtobj].pdobj)->plsdnUpNode, 0);
		Assert (lserr == lserrNone);
		}


	return lserrNone;
}


/* Internal functions implementation */

static LSERR PrepareAllArraysGetModWidth(DWORD grpfTnti, DWORD cchnk, const LSCHNKE* rglschnk)
{
	LSERR lserr;
	PLNOBJ plnobj;
	PILSOBJ pilsobj;

	plnobj = ((PTXTOBJ)rglschnk[0].pdobj)->plnobj;
	pilsobj = plnobj->pilsobj;

	Assert ((grpfTnti & maskAllCharBasedArrays) || (pilsobj->grpf & fTxtPunctStartLine) || 
			(pilsobj->grpf & fTxtHangingPunct) || (grpfTnti & fTntiGlyphBased) ||
			(grpfTnti & fTntiKern) || pilsobj->fSnapGrid);
/* if we got to nti some adjustment is needed and we must allocate pdurAdjust */

	if (pilsobj->pduAdjust == NULL)
		{
		pilsobj->pduAdjust = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(long) * pilsobj->wchMax );
		if (pilsobj->pduAdjust == NULL)
			{
			return lserrOutOfMemory;
			}
		}

	if ( (grpfTnti & maskAllCharBasedArrays) || (pilsobj->grpf & fTxtPunctStartLine) || 
					(pilsobj->grpf & fTxtHangingPunct) || pilsobj->fSnapGrid || (grpfTnti & fTntiGlyphBased))
		{
		Assert(pilsobj->pduAdjust != NULL);

		if (pilsobj->pdurRight == NULL)
			{

			Assert (pilsobj->pdurLeft == NULL);
			Assert(pilsobj->ptxtinf == NULL);

			pilsobj->pdurRight = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(long) * pilsobj->wchMax );
			pilsobj->pdurLeft = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(long) * pilsobj->wchMax );
			pilsobj->ptxtinf = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(TXTINF) * pilsobj->wchMax );
			if (pilsobj->pdurRight == NULL || pilsobj->pdurLeft == NULL || pilsobj->ptxtinf == NULL)
				{
				return lserrOutOfMemory;
				}
			memset(pilsobj->pdurRight, 0, sizeof(long) * pilsobj->wchMax );
			memset(pilsobj->pdurLeft, 0, sizeof(long) * pilsobj->wchMax );
			memset(pilsobj->ptxtinf, 0, sizeof(TXTINF) * pilsobj->wchMax);
			}


		pilsobj->fNotSimpleText = fTrue;
		}

	if (grpfTnti & fTntiGlyphBased)
		{
		lserr = CheckReallocGlyphs(plnobj, pilsobj->wchMax - 2);
		if (lserr != lserrNone) return lserr;
		}

	if ( (grpfTnti & maskAllCharBasedArrays) || (pilsobj->grpf & fTxtPunctStartLine) || 
					(pilsobj->grpf & fTxtHangingPunct) || pilsobj->fSnapGrid)
		{
		lserr = GetModWidthClasses(cchnk, rglschnk);
		if (lserr != lserrNone) return lserr;
		}

	return lserrNone;

}

static LSERR ApplyKern(LSTFLOW lstflow, DWORD cchnk, const LSCHNKE* rglschnk)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PLNOBJ plnobj;
	long itxtobjPrev = 0;
	long itxtobjCur;
	BOOL fFoundNextRun;
	BOOL fFoundKernedPrevRun;

	plnobj = ((PTXTOBJ)rglschnk[0].pdobj)->plnobj;
	pilsobj = plnobj->pilsobj;

	fFoundNextRun = GetNextImportantRun(cchnk, rglschnk, 0, &itxtobjCur);

	fFoundKernedPrevRun = fFalse;

	while (fFoundNextRun)
		{
		if (fFoundKernedPrevRun && rglschnk[itxtobjCur].plschp->fApplyKern)
			{
			lserr = CheckApplyKernBetweenRuns(lstflow, rglschnk, itxtobjPrev, itxtobjCur);
			if (lserr != lserrNone) return lserr;
			}

		if (rglschnk[itxtobjCur].plschp->fApplyKern)
			{
			lserr = ApplyKernToRun(lstflow, rglschnk, itxtobjCur);
			if (lserr != lserrNone) return lserr;

			fFoundKernedPrevRun = fTrue;
			itxtobjPrev = itxtobjCur;
			}
		else
			{
			fFoundKernedPrevRun = fFalse;
			}

		fFoundNextRun = GetNextImportantRun(cchnk, rglschnk, itxtobjCur + 1, &itxtobjCur);
		}
	
	return lserrNone;
}

static LSERR CheckApplyKernBetweenRuns(LSTFLOW lstflow, const LSCHNKE* rglschnk,
															long itxtobjPrev, long itxtobjCur)
{
	LSERR lserr;
	PTXTOBJ ptxtobj;
	PLNOBJ plnobj;
	PILSOBJ pilsobj;
	long iwchLim;
	BOOL fKernPrevRun;
	long dduKern;
	WCHAR* pwch = NULL;
	WCHAR rgwchTwo[2];
	long dduAdjust;

	ptxtobj = (PTXTOBJ)rglschnk[itxtobjPrev].pdobj;
	plnobj = ptxtobj->plnobj;
	pilsobj = plnobj->pilsobj; 

	Assert(!(ptxtobj->txtf & txtfGlyphBased));

	lserr = (*pilsobj->plscbk->pfnCheckRunKernability)(pilsobj->pols, rglschnk[itxtobjPrev].plsrun,
									 rglschnk[itxtobjCur].plsrun, &fKernPrevRun);
	if (lserr != lserrNone) return lserr;

	if (fKernPrevRun)
		{
		iwchLim = ptxtobj->iwchLim;
		if (iwchLim == ((PTXTOBJ)rglschnk[itxtobjCur].pdobj)->iwchFirst)
			{
			pwch = &pilsobj->pwchOrig[iwchLim - 1];
			}
		else
			{
			rgwchTwo[0] = pilsobj->pwchOrig[iwchLim - 1];
			rgwchTwo[1] = pilsobj->pwchOrig[((PTXTOBJ)rglschnk[itxtobjCur].pdobj)->iwchFirst];
			pwch = rgwchTwo;
			}

		lserr = (*pilsobj->plscbk->pfnGetRunCharKerning)(pilsobj->pols, rglschnk[itxtobjPrev].plsrun,
						lsdevReference,	pwch, 2, lstflow, (int*)&dduKern);
		if (lserr != lserrNone) return lserr;
		
		dduAdjust = max(-pilsobj->pdur[iwchLim - 1], dduKern);
		pilsobj->pdur[iwchLim - 1] += dduAdjust;

		lserr = LsdnModifySimpleWidth(pilsobj->plsc, ptxtobj->plsdnUpNode, dduAdjust);
		if (lserr != lserrNone) return lserr;

		if (pilsobj->fDisplay)
			{
			if (!pilsobj->fPresEqualRef)
				{
				lserr = (*pilsobj->plscbk->pfnGetRunCharKerning)(pilsobj->pols, rglschnk[itxtobjPrev].plsrun,
								lsdevPres, pwch, 2, lstflow, (int*)&dduKern);
				if (lserr != lserrNone) return lserr;
				
				dduAdjust = max(-plnobj->pdup[iwchLim - 1], dduKern);
				plnobj->pdup[iwchLim - 1] += dduAdjust;

				}
			else
				{
				plnobj->pdup[iwchLim - 1] = pilsobj->pdur[iwchLim-1];
				}
			}
		}

	return lserrNone;

}

static LSERR ApplyKernToRun(LSTFLOW lstflow, const LSCHNKE* rglschnk, long itxtobjCur)
{
	LSERR lserr;
	PTXTOBJ ptxtobj;
	PLNOBJ plnobj;
	PILSOBJ pilsobj;
	long iwchFirst;
	long iwchLim;
	long iwch;
	long dduAdjust;
	long ddurChange;

	ptxtobj = (PTXTOBJ)rglschnk[itxtobjCur].pdobj;
	plnobj = ptxtobj->plnobj;
	pilsobj = plnobj->pilsobj;

	Assert(!(ptxtobj->txtf & txtfGlyphBased));
	Assert(pilsobj->pduAdjust != NULL);

	iwchFirst = ptxtobj->iwchFirst;
	iwchLim = ptxtobj->iwchLim;

	Assert (iwchLim > iwchFirst);

	if (iwchLim == iwchFirst + 1)
		return lserrNone;

	lserr = (*pilsobj->plscbk->pfnGetRunCharKerning)(pilsobj->pols, rglschnk[itxtobjCur].plsrun, lsdevReference,
				&pilsobj->pwchOrig[iwchFirst], iwchLim - iwchFirst, lstflow, (int*)&pilsobj->pduAdjust[iwchFirst]);
	if (lserr != lserrNone) return lserr;

	ddurChange = 0;

	for (iwch = iwchFirst; iwch < iwchLim - 1; iwch++)
		{
		dduAdjust = max(-pilsobj->pdur[iwch], pilsobj->pduAdjust[iwch]);
		pilsobj->pdur[iwch] += dduAdjust;
		ddurChange += dduAdjust;
		}

	if (ddurChange != 0)
		{
		lserr = LsdnModifySimpleWidth(pilsobj->plsc, ptxtobj->plsdnUpNode, ddurChange);
		if (lserr != lserrNone) return lserr;
		}

	if (pilsobj->fDisplay)
		{
		if (!pilsobj->fPresEqualRef)
			{
			lserr = (*pilsobj->plscbk->pfnGetRunCharKerning)(pilsobj->pols, rglschnk[itxtobjCur].plsrun, lsdevPres,
					&plnobj->pwch[iwchFirst], iwchLim - iwchFirst, lstflow, (int*)&pilsobj->pduAdjust[iwchFirst]);
			if (lserr != lserrNone) return lserr;
	
			for (iwch = iwchFirst; iwch < iwchLim - 1; iwch++)
				{
				dduAdjust = max(-plnobj->pdup[iwch], pilsobj->pduAdjust[iwch]);
				plnobj->pdup[iwch] += dduAdjust;
				}
			}
		else
			{
			memcpy(&plnobj->pdup[iwchFirst], &pilsobj->pdur[iwchFirst], sizeof(long) * (iwchLim - iwchFirst) );
			}
		}

	return lserrNone;
}

static BOOL GetPrevImportantRun(const LSCHNKE* rglschnk, long itxtobj, long* pitxtobjPrev)
{
	PTXTOBJ ptxtobj;

	while (itxtobj >= 0 /*&& !fFound  (fFound logic changed to break)*/)
		{
		ptxtobj = (PTXTOBJ)rglschnk[itxtobj].pdobj;
		if (!(ptxtobj->txtf & txtfSkipAtNti))
			{
			/*fFound = fTrue;*/
			break;
			}
		else
			{
			itxtobj--;
			}
		}

	*pitxtobjPrev = itxtobj;

	return (itxtobj >= 0);
}

static BOOL GetNextImportantRun(DWORD cchnk, const LSCHNKE* rglschnk, long itxtobj, long* pitxtobjNext)
{
	PTXTOBJ ptxtobj;

	while (itxtobj < (long)cchnk /*&& !fFound  (fFound logic changed to break)*/)
		{
		ptxtobj = (PTXTOBJ)rglschnk[itxtobj].pdobj;
		if (!(ptxtobj->txtf & txtfSkipAtNti))
			{
			/*fFound = fTrue;*/
			break;
			}
		else
			{
			itxtobj++;
			}
		}

	*pitxtobjNext = itxtobj;

	return (itxtobj < (long)cchnk);
}

static LSERR ApplyModWidth(LSTFLOW lstflow, BOOL fFirstOnLine, BOOL fAutoNumberPresent, DWORD cchnk, const LSCHNKE* rglschnk)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PLNOBJ plnobj;
	long itxtobjPrev=0;
	long itxtobjCur;
	BOOL fFoundNextRun;
	BOOL fFoundModWidthPrevRun;

	plnobj = ((PTXTOBJ)rglschnk[0].pdobj)->plnobj;
	pilsobj = plnobj->pilsobj;

	fFoundNextRun = GetNextImportantRun(cchnk, rglschnk, 0, &itxtobjCur);

	fFoundModWidthPrevRun = fFalse;

	while (fFoundNextRun)
		{
		if (fFoundModWidthPrevRun && FModWidthSomeDobj(itxtobjCur))
			{
			lserr = CheckApplyModWidthBetweenRuns(lstflow, rglschnk, itxtobjPrev, itxtobjCur);
			if (lserr != lserrNone) return lserr;
			}

		lserr = ApplyModWidthToRun(lstflow, fFirstOnLine, fAutoNumberPresent,cchnk, rglschnk, itxtobjCur);
		if (lserr != lserrNone) return lserr;

		fFoundModWidthPrevRun = FModWidthSomeDobj(itxtobjCur);
		itxtobjPrev = itxtobjCur;

		fFoundNextRun = GetNextImportantRun(cchnk, rglschnk, itxtobjCur + 1, &itxtobjCur);
		}
	
	return lserrNone;
}

static LSERR ApplyModWidthToRun(LSTFLOW lstflow, BOOL fFirstOnLine, BOOL fAutoNumberPresent, DWORD cchnk, const LSCHNKE* rglschnk, long itxtobjCur)
{
	LSERR lserr;
	PTXTOBJ ptxtobj;
	PLNOBJ plnobj;
	PILSOBJ pilsobj;
	long iwchVeryFirst;
	long iwchVeryLim;
	long iwchFirst;
	long iwchLim;
	long iwch;
	long iwchPrev;
	long iwchNext;
	LSEMS lsems;
	PLSRUN plsrun;
	PLSRUN plsrunPrev;
	PLSRUN plsrunNext;
	long itxtobjPrev;
	long itxtobjNext;
	BOOL fFoundPrevRun;
	BOOL fFoundNextRun;
	long ddurChangeFirst;
	long ddurChangeSecond;
	long ddurChange;
	WCHAR* pwchOrig;

	ptxtobj = (PTXTOBJ)rglschnk[itxtobjCur].pdobj;
	plnobj = ptxtobj->plnobj;
	pilsobj = plnobj->pilsobj;
	plsrun = rglschnk[itxtobjCur].plsrun;

	lserr = (*pilsobj->plscbk->pfnGetEms)(pilsobj->pols, plsrun, lstflow, &lsems);
	if (lserr != lserrNone) return lserr;

	Assert(ptxtobj->iwchLim > ptxtobj->iwchFirst);

	ddurChange = 0;
	/* all changes to the last char which depend on the next run will be applied in the next
		call to ApplyModWidthBetween runs
	*/ 
	iwchLim = ptxtobj->iwchLim;
	iwchFirst = ptxtobj->iwchFirst;

	if ( (pilsobj->grpf & fTxtPunctStartLine) && fFirstOnLine && itxtobjCur == 0 &&
					!(fAutoNumberPresent && (pilsobj->grpf & fTxtNoPunctAfterAutoNumber	)) &&
					!(ptxtobj->txtf & txtfGlyphBased)
		)
		{
		CheckApplyPunctStartLine(pilsobj, plsrun, &lsems, iwchFirst, &ddurChangeFirst);
		ddurChange += ddurChangeFirst;
		}

	if (rglschnk[itxtobjCur].plschp->fModWidthPairs)
		{
		Assert(pilsobj->ptxtinf != NULL);
		Assert(pilsobj->plspairact != NULL);
		Assert(pilsobj->pilspairact != NULL);
		Assert(!(ptxtobj->txtf & txtfGlyphBased));

		Assert(pilsobj->pilspairact != NULL);
		if(pilsobj->pilspairact == NULL)
			return lserrModWidthPairsNotSet;			

		for (iwch = iwchFirst; iwch < iwchLim - 1; iwch++)
			{
			CheckApplyModWidthTwoChars(pilsobj, &lsems, &lsems, iwch, iwch+1, &ddurChangeFirst, &ddurChangeSecond);
			ddurChange += (ddurChangeFirst + ddurChangeSecond);
			}

		}

	/* REVIEW sergeyge(elik): should we try to avoid second loop through characters? */
	if (rglschnk[itxtobjCur].plschp->fModWidthSpace)
		{
		Assert(!(ptxtobj->txtf & txtfGlyphBased));

		iwchVeryFirst = ((PTXTOBJ)rglschnk[0].pdobj)->iwchFirst;
		iwchVeryLim = ((PTXTOBJ)rglschnk[cchnk-1].pdobj)->iwchLim;
		pwchOrig = pilsobj->pwchOrig;

		for (iwch = iwchFirst; iwch < iwchLim; iwch++)
			{
			if (pwchOrig[iwch] == pilsobj->wchSpace)
				{
				plsrunPrev = NULL;
				iwchPrev = 0;
				if (iwch > iwchFirst)
					{
					plsrunPrev = plsrun;
					iwchPrev = iwch - 1;
					}
				else if (iwch > iwchVeryFirst)
					{
					Assert(itxtobjCur > 0);
					fFoundPrevRun = GetPrevImportantRun(rglschnk, itxtobjCur-1, &itxtobjPrev);
					if (fFoundPrevRun)
						{
						Assert(itxtobjPrev >= 0);
						plsrunPrev = rglschnk[itxtobjPrev].plsrun;
						iwchPrev = ((PTXTOBJ)rglschnk[itxtobjPrev].pdobj)->iwchLim - 1;
						}
					}

				plsrunNext = NULL;
				iwchNext = 0;
				if (iwch < iwchLim - 1)
					{
					plsrunNext = plsrun;
					iwchNext = iwch + 1;
					}
				else if (iwch < iwchVeryLim - 1)
					{
					Assert(itxtobjCur < (long)cchnk - 1);
					fFoundNextRun = GetNextImportantRun(cchnk, rglschnk, itxtobjCur+1, &itxtobjNext);
					if (fFoundNextRun)
						{
						Assert(itxtobjNext < (long)cchnk);
						plsrunNext = rglschnk[itxtobjNext].plsrun;
						iwchNext = ((PTXTOBJ)rglschnk[itxtobjNext].pdobj)->iwchFirst;
						}
					}

				lserr = CheckApplyModWidthSpace(pilsobj, plsrunPrev, plsrun, plsrunNext, &lsems,
													iwchPrev, iwch, iwchNext, &ddurChangeFirst);
				if (lserr != lserrNone) return lserr;

				ddurChange += ddurChangeFirst;

				}
			}
		}

	if (ddurChange != 0)
		{
		lserr = LsdnModifySimpleWidth(pilsobj->plsc, ptxtobj->plsdnUpNode, ddurChange);
		if (lserr != lserrNone) return lserr;
		}

	return lserrNone;
}

static LSERR CheckApplyModWidthBetweenRuns(LSTFLOW lstflow, const LSCHNKE* rglschnk, long itxtobjPrev, long itxtobjCur)
{
	LSERR lserr;
	PTXTOBJ ptxtobjPrev;
	PLNOBJ plnobj;
	PILSOBJ pilsobj;
	long iwchNext;
	long iwch;
	LSEMS lsemsPrev;
	LSEMS lsemsCur;
	PLSRUN plsrunPrev;
	PLSRUN plsrunCur;
	long ddurChangeFirst;
	long ddurChangeSecond;
	long ddurChangePrev;
	long ddurChangeCur;

	ddurChangePrev = 0;
	ddurChangeCur = 0;

	ptxtobjPrev = (PTXTOBJ)rglschnk[itxtobjPrev].pdobj;
	plnobj = ptxtobjPrev->plnobj;
	pilsobj = plnobj->pilsobj;
	plsrunPrev = rglschnk[itxtobjPrev].plsrun;
	plsrunCur = rglschnk[itxtobjCur].plsrun;

	iwchNext = ((PTXTOBJ)rglschnk[itxtobjCur].pdobj)->iwchFirst;

	lserr = (*pilsobj->plscbk->pfnGetEms)(pilsobj->pols, plsrunPrev, lstflow, &lsemsPrev);
	if (lserr != lserrNone) return lserr;
	lserr = (*pilsobj->plscbk->pfnGetEms)(pilsobj->pols, plsrunCur, lstflow, &lsemsCur);
	if (lserr != lserrNone) return lserr;

	iwch = ptxtobjPrev->iwchLim - 1;

	if (rglschnk[itxtobjPrev].plschp->fModWidthOnRun && rglschnk[itxtobjCur].plschp->fModWidthOnRun)
		{
		lserr = CheckApplyModWidthOnRun(pilsobj, ptxtobjPrev, 
									plsrunPrev, plsrunCur, &lsemsPrev, iwch, iwchNext, &ddurChangeFirst);
		if (lserr != lserrNone) return lserr;
		ddurChangePrev += ddurChangeFirst;
		}

	if (rglschnk[itxtobjPrev].plschp->fModWidthPairs && rglschnk[itxtobjCur].plschp->fModWidthPairs)
		{
		Assert ((!(ptxtobjPrev->txtf & txtfGlyphBased)) &&
								!(((PTXTOBJ)rglschnk[itxtobjCur].pdobj)->txtf & txtfGlyphBased));
		CheckApplyModWidthTwoChars(pilsobj, &lsemsPrev, &lsemsCur, iwch, iwchNext, &ddurChangeFirst, &ddurChangeSecond);
		ddurChangePrev += ddurChangeFirst;
		ddurChangeCur += ddurChangeSecond;
		}

	if (ddurChangePrev != 0)
		{
		lserr = LsdnModifySimpleWidth(pilsobj->plsc, ptxtobjPrev->plsdnUpNode, ddurChangePrev);
		if (lserr != lserrNone) return lserr;
		}

	if (ddurChangeCur != 0)
		{
		lserr = LsdnModifySimpleWidth(pilsobj->plsc, ((PTXTOBJ)rglschnk[itxtobjCur].pdobj)->plsdnUpNode,
																						ddurChangeCur);
		if (lserr != lserrNone) return lserr;
		}

	return lserrNone;
}

static LSERR GetModWidthClasses(DWORD cchnk, const LSCHNKE* rglschnk)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	long itxtobj;
	long iwchFirst;
	long iwchLim;
	long iwch;
	long i;
	MWCLS* pmwcls;
	WCHAR* pwchOrig;
	TXTINF* ptxtinf;

	pilsobj = ((PTXTOBJ)rglschnk[0].pdobj)->plnobj->pilsobj;
	pwchOrig = pilsobj->pwchOrig;
	ptxtinf = pilsobj->ptxtinf;
	
	for (itxtobj = 0; itxtobj < (long)cchnk; itxtobj++)
		{
		ptxtobj = (PTXTOBJ)rglschnk[itxtobj].pdobj;
		if (!(ptxtobj->txtf & txtfGlyphBased))
			{
			iwchFirst = ptxtobj->iwchFirst;
			iwchLim = ptxtobj->iwchLim;

			if (iwchLim > iwchFirst)
				{
				Assert(pilsobj->pduAdjust != NULL);
				/* I use pdurAdjust as temporary buffer to read MWCLS info */
				pmwcls = (MWCLS*)(&pilsobj->pduAdjust[iwchFirst]);
				lserr =(*pilsobj->plscbk->pfnGetModWidthClasses)(pilsobj->pols, rglschnk[itxtobj].plsrun,
									&pwchOrig[iwchFirst], (DWORD)(iwchLim - iwchFirst), pmwcls);
				if (lserr != lserrNone) return lserr;
				for (i=0, iwch = iwchFirst; iwch < iwchLim; i++, iwch++)
					{
					Assert(pmwcls[i] < pilsobj->cModWidthClasses);
					if (pmwcls[i] >= pilsobj->cModWidthClasses)
						return lserrInvalidModWidthClass;
					ptxtinf[iwch].mwcls = pmwcls[i];
					}
				
				}

			ptxtobj->txtf |= txtfModWidthClassed;

			}


		}

	return lserrNone;
}

static LSERR CheckApplyPunctStartLine(PILSOBJ pilsobj, PLSRUN plsrun, LSEMS* plsems, long iwch,
																				long* pddurChange)
{
	LSERR lserr;
	LSACT lsact;
	MWCLS mwcls;
	BYTE side;

	*pddurChange = 0;

	mwcls = (BYTE)pilsobj->ptxtinf[iwch].mwcls;
	Assert(mwcls < pilsobj->cModWidthClasses);

	lserr = (*pilsobj->plscbk->pfnPunctStartLine)(pilsobj->pols, plsrun, mwcls, pilsobj->pwchOrig[iwch], &lsact);
	if (lserr != lserrNone) return lserr;

	if (lsact.side != sideNone)
		{
		GetChanges(lsact, plsems, pilsobj->pdur[iwch], fFalse, &side, pddurChange);
		ApplyChanges(pilsobj, iwch, side, *pddurChange);
/*		pilsobj->ptxtinf[iwch].fStartLinePunct = fTrue;*/
		}

	return lserrNone;
}

static LSERR CheckApplyModWidthSpace(PILSOBJ pilsobj, PLSRUN plsrunPrev, PLSRUN plsrunCur, PLSRUN plsrunNext,
						LSEMS* plsems, long iwchPrev, long iwchCur, long iwchNext, long* pddurChange)
{
	LSERR lserr;
	WCHAR wchPrev;
	WCHAR wchNext;
	LSACT lsact;
	BYTE side;

	*pddurChange = 0;

	wchPrev = 0;
	if (plsrunPrev != NULL)
		wchPrev = pilsobj->pwchOrig[iwchPrev];

	wchNext = 0;
	if (plsrunNext != NULL)
		wchNext = pilsobj->pwchOrig[iwchNext];

	lserr = (*pilsobj->plscbk->pfnModWidthSpace)(pilsobj->pols, plsrunCur, plsrunPrev, wchPrev, plsrunNext, wchNext,
																				 &lsact);
	if (lserr != lserrNone) return lserr;

	if (lsact.side != sideNone)
		{
		GetChanges(lsact, plsems, pilsobj->pdur[iwchCur], fTrue, &side, pddurChange);
		Assert(side == sideRight);
		ApplyChanges(pilsobj, iwchCur, side, *pddurChange);
		pilsobj->ptxtinf[iwchCur].fModWidthSpace = fTrue;
		}

	return lserrNone;
}

static LSERR CheckApplyModWidthOnRun(PILSOBJ pilsobj, PTXTOBJ ptxtobjPrev, PLSRUN plsrunPrev, PLSRUN plsrunCur,
						LSEMS* plsems, long iwchFirst, long iwchSecond, long* pddurChange)
{
	LSERR lserr;
	LSACT lsact;
	BYTE side;
	long igindLast;
	long igind;

	*pddurChange = 0;
	lserr = (*pilsobj->plscbk->pfnModWidthOnRun)(pilsobj->pols, plsrunPrev, pilsobj->pwchOrig[iwchFirst],
					plsrunCur, pilsobj->pwchOrig[iwchSecond], &lsact);
	if (lserr != lserrNone) return lserr;

	if (lsact.side != sideNone)
		{
		if (ptxtobjPrev->txtf & txtfGlyphBased)
			{
			igindLast = IgindLastFromIwch(ptxtobjPrev, iwchFirst);
			igind = IgindBaseFromIgind(pilsobj, igindLast);
			GetChanges(lsact, plsems, pilsobj->pdurGind[igind], fTrue, &side, pddurChange);
			Assert(side == sideRight);
			ApplyGlyphChanges(pilsobj, igind, *pddurChange);
			}
		else
			{
			GetChanges(lsact, plsems, pilsobj->pdur[iwchFirst], fTrue, &side, pddurChange);
			Assert(side == sideRight);
			ApplyChanges(pilsobj, iwchFirst, side, *pddurChange);
			}
		pilsobj->ptxtinf[iwchFirst].fModWidthOnRun = fTrue;
		}

	return lserrNone;
}

static LSERR ApplySnapGrid(DWORD cchnk, const LSCHNKE* rglschnk)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	long iwchVeryFirst;
	long iwchVeryLim;
	long iwchFirstInDobj;
	long iwchLimInDobj;
	long iwch;
	long iwchFirstSnapped;
	long iwchPrev;
	long itxtobj;
	long itxtobjCur;
	long itxtobjFirstSnapped;
	long itxtobjPrev;
	PLSRUN* rgplsrun = NULL;
	LSCP* rgcp = NULL;
	BOOL* rgfSnapped = NULL;
	long irg;
	PLSRUN plsrunCur;
	LSCP cpCur;
	long cGrid;
	BOOL fFoundNextRun;
	long urColumnMax;
	long urPen;
	long durPen;
	long urPenSnapped;
	long urPenFirstSnapped;
	long durUndo;
	long durGridWhole;
	long durGridRem;
	BOOL fInChildList;

	pilsobj = ((PTXTOBJ)rglschnk[0].pdobj)->plnobj->pilsobj;

	lserr = LsdnFInChildList(pilsobj->plsc, ((PTXTOBJ)rglschnk[0].pdobj)->plsdnUpNode, &fInChildList);
	Assert(lserr == lserrNone);

	if (fInChildList)
		return lserrNone;

	iwchVeryFirst = ((PTXTOBJ)rglschnk[0].pdobj)->iwchFirst;
	iwchVeryLim = ((PTXTOBJ)rglschnk[cchnk - 1].pdobj)->iwchLim;

	if (iwchVeryLim <= iwchVeryFirst)
		return lserrNone;

	rgcp = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, (iwchVeryLim - iwchVeryFirst) * sizeof (LSCP));
	if (rgcp == NULL)
		return CleanUpGrid(pilsobj, rgplsrun, rgcp, rgfSnapped, lserrOutOfMemory);
	
	rgplsrun = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, (iwchVeryLim - iwchVeryFirst) * sizeof (PLSRUN));
	if (rgplsrun == NULL)
		return CleanUpGrid(pilsobj, rgplsrun, rgcp, rgfSnapped, lserrOutOfMemory);
		
	rgfSnapped = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, (iwchVeryLim - iwchVeryFirst) * sizeof (BOOL));
	if (rgfSnapped == NULL)
		return CleanUpGrid(pilsobj, rgplsrun, rgcp, rgfSnapped, lserrOutOfMemory);

	irg = 0;

	for (itxtobj = 0; itxtobj < (long)cchnk; itxtobj++)
		{
		iwchFirstInDobj = ((PTXTOBJ)rglschnk[itxtobj].pdobj)->iwchFirst;
		iwchLimInDobj = ((PTXTOBJ)rglschnk[itxtobj].pdobj)->iwchLim;
		plsrunCur = rglschnk[itxtobj].plsrun;
		cpCur = rglschnk[itxtobj].cpFirst;

		for (iwch = iwchFirstInDobj; iwch < iwchLimInDobj; iwch++)
			{
			rgcp[irg] = cpCur;
			rgplsrun[irg] = plsrunCur;
			irg++;
			cpCur++;
			}
		}

	lserr = (*pilsobj->plscbk->pfnGetSnapGrid)(pilsobj->pols, &pilsobj->pwchOrig[iwchVeryFirst], rgplsrun, rgcp, irg, rgfSnapped, (DWORD*)&cGrid);
	if (lserr != lserrNone) return CleanUpGrid(pilsobj, rgplsrun, rgcp, rgfSnapped, lserr);

	Assert(cGrid > 0);

	if (cGrid <= 0) return CleanUpGrid(pilsobj, rgplsrun, rgcp, rgfSnapped, lserrNone);

	rgfSnapped[0] = fTrue;	/* First character of each lock chunk must be snapped */

	fFoundNextRun = GetNextImportantRun(cchnk, rglschnk, 0, &itxtobjCur);

	if (fFoundNextRun && rgfSnapped[((PTXTOBJ)rglschnk[itxtobjCur].pdobj)->iwchFirst - iwchVeryFirst])
		{
		iwchFirstInDobj = ((PTXTOBJ)rglschnk[itxtobjCur].pdobj)->iwchFirst;

	/* fix for the case when ModWidth was applied before snapping to grid.
		Changes to the left of the first character should be undone.
	*/
		lserr = UndoAppliedModWidth(pilsobj, rglschnk, itxtobjCur, iwchFirstInDobj, sideLeft, &durUndo);
		if (lserr != lserrNone) return CleanUpGrid(pilsobj, rgplsrun, rgcp, rgfSnapped, lserr);

		lserr = LsdnGetUrPenAtBeginningOfChunk(pilsobj->plsc, ((PTXTOBJ)rglschnk[0].pdobj)->plsdnUpNode,
																					 &urPen, &urColumnMax);
		if (lserr != lserrNone) return CleanUpGrid(pilsobj, rgplsrun, rgcp, rgfSnapped, lserr);

		if (urColumnMax <= 0) return CleanUpGrid(pilsobj, rgplsrun, rgcp, rgfSnapped, lserrNone);

		durGridWhole = urColumnMax / cGrid;
		durGridRem = urColumnMax - durGridWhole * cGrid;

		urPenSnapped = CalcSnapped(urPen, urColumnMax, cGrid, durGridWhole, durGridRem);

		Assert(urPenSnapped >= urPen);

		if (urPenSnapped > urPen)
			{
			ApplyChanges(pilsobj, iwchFirstInDobj, sideLeft, urPenSnapped - urPen);
			lserr = LsdnModifySimpleWidth(pilsobj->plsc, ((PTXTOBJ)rglschnk[itxtobjCur].pdobj)->plsdnUpNode, 
																						urPenSnapped - urPen);
			if (lserr != lserrNone) return CleanUpGrid(pilsobj, rgplsrun, rgcp, rgfSnapped, lserr);
			}

/* Dangerous fix to the bug 594. Width of first character was just changed. First iteration of the 
	following for loop assumes that it was not. So I initialize variables in such way that 
	first iteration will work correctly---2 errors compensate each other

	before fix initialization was:
		durPen = 0;
		urPen = urPenSnapped
*/
		durPen = urPen - urPenSnapped;
/*		urPen = urPenSnapped;*/


		urPenFirstSnapped = urPenSnapped;
		iwchFirstSnapped = iwchFirstInDobj;
		itxtobjFirstSnapped = itxtobjCur;
		iwchPrev = iwchFirstInDobj;
		itxtobjPrev = itxtobjCur;

		while (fFoundNextRun)
			{
			iwchFirstInDobj = ((PTXTOBJ)rglschnk[itxtobjCur].pdobj)->iwchFirst;
			iwchLimInDobj = ((PTXTOBJ)rglschnk[itxtobjCur].pdobj)->iwchLim;
			for (iwch = iwchFirstInDobj; iwch < iwchLimInDobj; iwch++)
				{
				if (rgfSnapped[iwch - iwchVeryFirst] && iwch > iwchFirstSnapped)
					{

	/* fix for the case when ModWidth was applied before snapping to grid.
		Changes to the right of the last character should be undone.
	*/
					lserr = UndoAppliedModWidth(pilsobj, rglschnk, itxtobjPrev, iwchPrev, sideRight, &durUndo);
					if (lserr != lserrNone) return CleanUpGrid(pilsobj, rgplsrun, rgcp, rgfSnapped, lserr);
					if (durUndo != 0)
						{
						urPen += durUndo;
						durPen += durUndo;
						}
	/* end of the fix due to ModWidth */

					urPenSnapped = CalcSnapped(urPen, urColumnMax, cGrid, durGridWhole, durGridRem);
					Assert(urPenSnapped - urPenFirstSnapped - durPen >= 0);

					lserr = ApplySnapChanges(pilsobj, rglschnk, iwchFirstSnapped, itxtobjFirstSnapped,
										iwchPrev, itxtobjPrev, urPenSnapped - urPenFirstSnapped - durPen);
					if (lserr != lserrNone) return CleanUpGrid(pilsobj,  rgplsrun, rgcp, rgfSnapped, lserr);

					durPen = 0;
					urPen = urPenSnapped;
					urPenFirstSnapped = urPenSnapped;
					iwchFirstSnapped = iwch;
					itxtobjFirstSnapped = itxtobjCur;

	/* fix for the case when ModWidth was applied before snapping to grid.
		Changes to the left of the first character should be undone.
	*/
					lserr = UndoAppliedModWidth(pilsobj, rglschnk, itxtobjCur, iwch, sideLeft, &durUndo);
					if (lserr != lserrNone) return CleanUpGrid(pilsobj, rgplsrun, rgcp, rgfSnapped, lserr);
					}

				urPen += pilsobj->pdur[iwch];
				durPen += pilsobj->pdur[iwch];
				iwchPrev = iwch;
				itxtobjPrev = itxtobjCur;
				}

			fFoundNextRun = GetNextImportantRun(cchnk, rglschnk, itxtobjCur + 1, &itxtobjCur);
			}

	/* fix for the case when ModWidth was applied before snapping to grid.
		Changes to the right of the last character should be undone.
	*/
		UndoAppliedModWidth(pilsobj, rglschnk, itxtobjPrev, iwchPrev, sideRight, &durUndo);
		if (lserr != lserrNone) return CleanUpGrid(pilsobj, rgplsrun, rgcp, rgfSnapped, lserr);
		if (durUndo != 0)
			{
			urPen += durUndo;
			durPen += durUndo;
			}
	/* end of the fix due to ModWidth */

		urPenSnapped = CalcSnapped(urPen, urColumnMax, cGrid, durGridWhole, durGridRem);
		Assert(urPenSnapped - urPenFirstSnapped - durPen >= 0);
		lserr = ApplySnapChanges(pilsobj, rglschnk, iwchFirstSnapped, itxtobjFirstSnapped,
								iwchPrev, itxtobjPrev, urPenSnapped - urPenFirstSnapped - durPen);
		if (lserr != lserrNone) return CleanUpGrid(pilsobj, rgplsrun, rgcp, rgfSnapped, lserr);
		}


	return CleanUpGrid(pilsobj, rgplsrun, rgcp, rgfSnapped, lserrNone);
}

static LSERR UndoAppliedModWidth(PILSOBJ pilsobj, const LSCHNKE* rglschnk,
										long itxtobj, long iwch, BYTE side, long* pdurUndo)
{
	LSERR lserr;

	UndoAppliedChanges(pilsobj, iwch, side, pdurUndo);
	if (*pdurUndo != 0)
		{
		lserr = LsdnModifySimpleWidth(pilsobj->plsc, ((PTXTOBJ)rglschnk[itxtobj].pdobj)->plsdnUpNode, 
																					*pdurUndo);
		if (lserr != lserrNone) return lserr;

		pilsobj->ptxtinf[iwch].fModWidthOnRun = fFalse;
		pilsobj->ptxtinf[iwch].fModWidthSpace = fTrue;
		}

	return lserrNone;

}

static LSERR ApplySnapChanges(PILSOBJ pilsobj, const LSCHNKE* rglschnk, long iwchFirstSnapped,
					 long itxtobjFirstSnapped, long iwchLastSnapped, long itxtobjLastSnapped, long durTotal)
{
	LSERR lserr;
	long durSnapRight;
	long durSnapLeft;

	durSnapRight = durTotal >> 1;
	durSnapLeft = durTotal - durSnapRight;
	ApplyChanges(pilsobj, iwchFirstSnapped, sideLeft, durSnapLeft);
	lserr = LsdnModifySimpleWidth(pilsobj->plsc, ((PTXTOBJ)rglschnk[itxtobjFirstSnapped].pdobj)->plsdnUpNode, 
																				durSnapLeft);
	if (lserr != lserrNone) return lserr;

	ApplyChanges(pilsobj, iwchLastSnapped, sideRight, durSnapRight);
	lserr = LsdnModifySimpleWidth(pilsobj->plsc, ((PTXTOBJ)rglschnk[itxtobjLastSnapped].pdobj)->plsdnUpNode, 
																					durSnapRight);
	if (lserr != lserrNone) return lserr;

	return lserrNone;
}

static LSERR CleanUpGrid(PILSOBJ pilsobj, PLSRUN* rgplsrun, LSCP* rgcp, BOOL* rgfSnapped, 
																				LSERR lserr)
{
	if (rgplsrun != NULL)
		(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, rgplsrun);
	if (rgcp != NULL)
		(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, rgcp);
	if (rgfSnapped != NULL)
		(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, rgfSnapped);

	return lserr;

}

static long CalcSnapped(long urPen, long urColumnMax, long cGrid, long durGridWhole, long durGridRem)
{
	long idGrid;

	/* It is important to prove that idGrid-->urPenSnapped-->idGrid produces the same idGrid we started with.
	Here is the proof:
	idGrid-->urPenSnapped:	(idGrid * durGridWhole + durGridRem*idGrid/cGrid)---it is urPenSnapped

	urPenSnapped-->idGrid:

	(urPenSnapped * cGrid + urColumnMax - 1 ) / urColumnMax =
	((idGrid * durGridWhole + durGridRem*idGrid/cGrid) * cGrid + urColumnMax - 1) / urColumnMax =
	(idGrid * (urColumnMax - durGridRem) + durGridRem * idGrid + urColumnMax - 1) / urColumnMax =
	(idGrid * urColumnMax + urColumnMax - 1) / urColumnMax = idGrid

	It shows also that if one takes urPenSnapped + 1, result will be idGrid + 1 which is exactly correct
	*/

	if (urPen >= 0)
		idGrid = (urPen * cGrid + urColumnMax - 1 ) / urColumnMax;
	else
		idGrid = - ((-urPen * cGrid) / urColumnMax);

	return idGrid * durGridWhole + durGridRem * idGrid / cGrid;

}


#define cwchShapedTogetherMax	0x7FFF

/* Glyph-related activities */

static LSERR ApplyGlyphs(LSTFLOW lstflow, DWORD cchnk, const LSCHNKE* rglschnk)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	long itxtobj;
	long itxtobjFirst;
	long itxtobjLast;
	BOOL fInterruptShaping;
	long iwchFirstGlobal;
	long iwchLimGlobal;

	pilsobj = ((PTXTOBJ)rglschnk[0].pdobj)->plnobj->pilsobj;

	itxtobj = 0;
	while (itxtobj < (long)cchnk && !(((PTXTOBJ)rglschnk[itxtobj].pdobj)->txtf & txtfGlyphBased))
		itxtobj++;

/* Following Assert is surprisingly wrong, counterexample: glyph-based EOP and nothing else on the line */
/*	Assert(itxtobj < (long)cchnk); */

	while (itxtobj < (long)cchnk)
		{
		itxtobjFirst = itxtobj;
		iwchFirstGlobal = ((PTXTOBJ)rglschnk[itxtobjFirst].pdobj)->iwchFirst;

		iwchLimGlobal = ((PTXTOBJ)rglschnk[itxtobj].pdobj)->iwchLim;
		Assert(iwchLimGlobal - iwchFirstGlobal < cwchShapedTogetherMax);

		itxtobj++;
		fInterruptShaping = fFalse;

		if (itxtobj < (long)cchnk)
			iwchLimGlobal = ((PTXTOBJ)rglschnk[itxtobj].pdobj)->iwchLim;


		while (iwchLimGlobal - iwchFirstGlobal < cwchShapedTogetherMax && 
						!fInterruptShaping && itxtobj < (long)cchnk && 
						(((PTXTOBJ)rglschnk[itxtobj].pdobj)->txtf & txtfGlyphBased))
			{
			lserr = (*pilsobj->plscbk->pfnFInterruptShaping)(pilsobj->pols, lstflow,
					 rglschnk[itxtobj-1].plsrun, rglschnk[itxtobj].plsrun, &fInterruptShaping);
			if (lserr != lserrNone) return lserr;
	
			if (!fInterruptShaping)
				itxtobj++;

			if (itxtobj < (long)cchnk)
				iwchLimGlobal = ((PTXTOBJ)rglschnk[itxtobj].pdobj)->iwchLim;
			}
	
		itxtobjLast = itxtobj - 1;

		lserr = ApplyGlyphsToRange(lstflow, rglschnk, itxtobjFirst, itxtobjLast);
		if (lserr != lserrNone) return lserr;

		while (itxtobj < (long)cchnk && !(((PTXTOBJ)rglschnk[itxtobj].pdobj)->txtf & txtfGlyphBased))
			itxtobj++;

		}

	return lserrNone;
}

static LSERR ApplyGlyphsToRange(LSTFLOW lstflow, const LSCHNKE* rglschnk, long itxtobjFirst, long itxtobjLast)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PLNOBJ plnobj;
	PTXTOBJ ptxtobjFirst;
	PTXTOBJ ptxtobjLast;
	PLSRUN plsrun;
	long iwchFirstGlobal;
	long iwchLimGlobal;
	GINDEX* pgindex;
	PGPROP pgprop;
	DWORD cgind;
	long igindFirst;

	ptxtobjFirst = (PTXTOBJ)rglschnk[itxtobjFirst].pdobj;
	ptxtobjLast = (PTXTOBJ)rglschnk[itxtobjLast].pdobj;

	plnobj = ptxtobjFirst->plnobj;
	pilsobj = plnobj->pilsobj;

	iwchFirstGlobal = ptxtobjFirst->iwchFirst;
	iwchLimGlobal = ptxtobjLast->iwchLim;

	plsrun = rglschnk[itxtobjFirst].plsrun;
	
	lserr = (*pilsobj->plscbk->pfnGetGlyphs)(pilsobj->pols, plsrun, &pilsobj->pwchOrig[iwchFirstGlobal],
								iwchLimGlobal - iwchFirstGlobal, lstflow,
								&plnobj->pgmap[iwchFirstGlobal], &pgindex, &pgprop, &cgind);
	if (lserr != lserrNone) return lserr;

	lserr = CheckReallocGlyphs(plnobj, cgind);
	if (lserr != lserrNone) return lserr;

	CopyGindices(plnobj, pgindex, pgprop, cgind, &igindFirst);

	lserr = (*pilsobj->plscbk->pfnGetGlyphPositions)(pilsobj->pols, plsrun, lsdevReference, &pilsobj->pwchOrig[iwchFirstGlobal],
				&plnobj->pgmap[iwchFirstGlobal], iwchLimGlobal - iwchFirstGlobal,
				&plnobj->pgind[igindFirst], &plnobj->pgprop[igindFirst], cgind, lstflow,
				(int*)&pilsobj->pdurGind[igindFirst], &plnobj->pgoffs[igindFirst]);
	if (lserr != lserrNone) return lserr;


	if (pilsobj->fDisplay)
		{
		if (!pilsobj->fPresEqualRef)
			{
			lserr = (*pilsobj->plscbk->pfnGetGlyphPositions)(pilsobj->pols, plsrun, lsdevPres, &pilsobj->pwchOrig[iwchFirstGlobal],
				&plnobj->pgmap[iwchFirstGlobal], iwchLimGlobal - iwchFirstGlobal,
				&plnobj->pgind[igindFirst], &plnobj->pgprop[igindFirst], cgind, lstflow,
				(int*)&plnobj->pdupGind[igindFirst], &plnobj->pgoffs[igindFirst]);
			if (lserr != lserrNone) return lserr;
			}
/* ScaleSides will take care of the following memcpy */
//		else
//			memcpy (&plnobj->pdupGind[igindFirst], &pilsobj->pdurGind[igindFirst], sizeof(long)*cgind);
		}

	InterpretMap(plnobj, iwchFirstGlobal, iwchLimGlobal - iwchFirstGlobal, igindFirst, cgind);

	Assert(plnobj->pgmap[iwchFirstGlobal] == 0);

	if (pilsobj->fDisplay && (pilsobj->grpf & fTxtVisiSpaces) && rglschnk[itxtobjFirst].cpFirst >= 0)
		{
		FixGlyphSpaces(lstflow, rglschnk, itxtobjFirst, igindFirst, itxtobjLast);
		}

	lserr = FixTxtobjs(rglschnk, itxtobjFirst, igindFirst, itxtobjLast);
	if (lserr != lserrNone) return lserr;

	ptxtobjFirst->txtf |= txtfFirstShaping;

	while (ptxtobjLast->iwchLim == ptxtobjLast->iwchFirst)
		{
		itxtobjLast--;
		Assert (itxtobjLast >= itxtobjFirst);
		ptxtobjLast = (PTXTOBJ)rglschnk[itxtobjLast].pdobj;
		}

	ptxtobjLast->txtf |= txtfLastShaping;

	return lserrNone;
}

static LSERR FixTxtobjs(const LSCHNKE* rglschnk, long itxtobjFirst, long igindVeryFirst, long itxtobjLast)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	long itxtobj;
	long iwchFirst;
	long iwchLast;
	long dcpFirst;
	long durTotal;
	long iwSpacesVeryLim;
	long iwSpacesFirst;
	long iwSpacesLim;
	int igind;

	pilsobj = ((PTXTOBJ)rglschnk[itxtobjFirst].pdobj)->plnobj->pilsobj;
	iwchFirst = ((PTXTOBJ)rglschnk[itxtobjFirst].pdobj)->iwchFirst;

	iwSpacesVeryLim = ((PTXTOBJ)rglschnk[itxtobjLast].pdobj)->u.reg.iwSpacesLim;

	for (itxtobj = itxtobjFirst; itxtobj <= itxtobjLast; itxtobj++)
		{
		ptxtobj = (PTXTOBJ)rglschnk[itxtobj].pdobj;
		Assert(ptxtobj->txtkind == txtkindRegular);
		Assert((long)rglschnk[itxtobj].dcp == ptxtobj->iwchLim - ptxtobj->iwchFirst);
		dcpFirst = iwchFirst - ptxtobj->iwchFirst;
		Assert(dcpFirst >= 0);
		ptxtobj->iwchFirst = iwchFirst;
		iwchLast = ptxtobj->iwchLim - 1;
		if (iwchLast < iwchFirst)
			{
			ptxtobj->iwchLim = iwchFirst;
			ptxtobj->u.reg.iwSpacesLim = ptxtobj->u.reg.iwSpacesFirst;

			Assert(itxtobj > itxtobjFirst);
			ptxtobj->igindFirst = ((PTXTOBJ)rglschnk[itxtobj-1].pdobj)->iwchLim;
			ptxtobj->igindLim = ptxtobj->igindFirst;

			lserr = LsdnSetSimpleWidth(pilsobj->plsc, ptxtobj->plsdnUpNode, 0);
			if (lserr != lserrNone) return lserr;

			lserr = LsdnResetDcpMerge(pilsobj->plsc, 
										ptxtobj->plsdnUpNode, rglschnk[itxtobj].cpFirst + dcpFirst, 0);
			if (lserr != lserrNone) return lserr;

			/* It would be cleaner to mark these dobj's by another flag, but is it 
			worth to introduce one?
			*/
			ptxtobj->txtf |= txtfSkipAtNti;

			}
		else
			{
			while (!pilsobj->ptxtinf[iwchLast].fLastInContext)
				iwchLast++;
			Assert(iwchLast < (long)pilsobj->wchMac);

			ptxtobj->iwchLim = iwchLast + 1;

			lserr = LsdnResetDcpMerge(pilsobj->plsc, ptxtobj->plsdnUpNode, rglschnk[itxtobj].cpFirst + dcpFirst, iwchLast + 1 - iwchFirst);
			if (lserr != lserrNone) return lserr;

			Assert (iwchFirst == ptxtobj->iwchFirst);
			Assert (FIwchFirstInContext (pilsobj, iwchFirst));
			Assert (FIwchLastInContext (pilsobj, iwchLast));

			ptxtobj->igindFirst = IgindFirstFromIwchVeryFirst (ptxtobj, igindVeryFirst, iwchFirst);
			ptxtobj->igindLim = IgindLastFromIwchVeryFirst (ptxtobj, igindVeryFirst, iwchLast) + 1;

			durTotal = 0;
			for (igind = ptxtobj->igindFirst; igind < ptxtobj->igindLim; igind++)
				durTotal += pilsobj->pdurGind[igind];

			lserr = LsdnSetSimpleWidth(pilsobj->plsc, ptxtobj->plsdnUpNode, durTotal);
			if (lserr != lserrNone) return lserr;

			iwSpacesFirst = ptxtobj->u.reg.iwSpacesFirst;
			iwSpacesLim = ptxtobj->u.reg.iwSpacesLim;

			while (iwSpacesLim < iwSpacesVeryLim && pilsobj->pwSpaces[iwSpacesLim] < ptxtobj->iwchLim)
				{
				iwSpacesLim++;
				}

			while (iwSpacesFirst < iwSpacesLim && pilsobj->pwSpaces[iwSpacesFirst] < ptxtobj->iwchFirst)
				{
				iwSpacesFirst++;
				}

			ptxtobj->u.reg.iwSpacesFirst = iwSpacesFirst;
			ptxtobj->u.reg.iwSpacesLim = iwSpacesLim;

			iwchFirst = ptxtobj->iwchLim;
			}
		}

	return lserrNone;
}

static LSERR CheckReallocGlyphs(PLNOBJ plnobj, long cglyphs)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	long igindLocalStart;
	long cNew;
	void* pTemp;

	pilsobj = plnobj->pilsobj;

	igindLocalStart = pilsobj->gindMac;


	if (plnobj->pgmap == NULL)
		{
		pTemp = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(GMAP) * pilsobj->wchMax );
		if (pTemp == NULL) return lserrOutOfMemory;

		plnobj->pgmap = pTemp;
		}

	if ( igindLocalStart + cglyphs <= (long)pilsobj->gindMax - 2)
		{
		return lserrNone;
		}
	else
		{
		cNew = gindAddM + pilsobj->gindMax;
		if (cNew - 2 < igindLocalStart + cglyphs)
			{
			cNew = igindLocalStart + cglyphs + 2;
			}
		lserr = Realloc(pilsobj, &pilsobj->pdurGind, sizeof(long) * cNew);
		if (lserr != lserrNone) return lserr;
		lserr = Realloc(pilsobj, &pilsobj->pginf, sizeof(TXTGINF) * cNew);
		if (lserr != lserrNone) return lserr;
		lserr = Realloc(pilsobj, &pilsobj->pduGright, sizeof(long) * cNew);
		if (lserr != lserrNone) return lserr;
		lserr = Realloc(pilsobj, &pilsobj->plsexpinf, sizeof(LSEXPINFO) * cNew);
		if (lserr != lserrNone) return lserr;

		lserr = Realloc(pilsobj, &plnobj->pgind, sizeof(GINDEX) * cNew);
		if (lserr != lserrNone) return lserr;
		lserr = Realloc(pilsobj, &plnobj->pdupGind, sizeof(long) * cNew);
		if (lserr != lserrNone) return lserr;
		lserr = Realloc(pilsobj, &plnobj->pgoffs, sizeof(GOFFSET) * cNew);
		if (lserr != lserrNone) return lserr;
		lserr = Realloc(pilsobj, &plnobj->pexpt, sizeof(EXPTYPE) * cNew);
		if (lserr != lserrNone) return lserr;
		lserr = Realloc(pilsobj, &plnobj->pdupBeforeJust, sizeof(long) * cNew);
		if (lserr != lserrNone) return lserr;
		lserr = Realloc(pilsobj, &plnobj->pgprop, sizeof(GPROP) * cNew);
		if (lserr != lserrNone) return lserr;
	
		memset(&pilsobj->plsexpinf[pilsobj->gindMax], 0, sizeof(LSEXPINFO) * (cNew - pilsobj->gindMax) );
		memset(&pilsobj->pduGright[pilsobj->gindMax], 0, sizeof(long) * (cNew - pilsobj->gindMax) );
		memset(&plnobj->pexpt[pilsobj->gindMax], 0, sizeof(EXPTYPE) * (cNew - pilsobj->gindMax) );
		pilsobj->gindMax = cNew;
		plnobj->gindMax = cNew;
		}

	return lserrNone;
}

static LSERR Realloc(PILSOBJ pilsobj, void** pInOut, long cbytes)
{
	void* pTemp;

	if (*pInOut == NULL)
		pTemp = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, cbytes );
	else
		pTemp = (*pilsobj->plscbk->pfnReallocPtr)(pilsobj->pols, *pInOut, cbytes );

	if (pTemp == NULL)
		{
		return lserrOutOfMemory;
		}
	
	*pInOut = pTemp;

	return lserrNone;
	
}

static void	CopyGindices(PLNOBJ plnobj, GINDEX* pgindex, PGPROP pgprop, long cgind, long* pigindFirst)
{
	*pigindFirst = plnobj->pilsobj->gindMac;
	memcpy(&plnobj->pgind[*pigindFirst], pgindex, sizeof(GINDEX) * cgind);
	memcpy(&plnobj->pgprop[*pigindFirst], pgprop, sizeof(GPROP) * cgind);

	plnobj->pilsobj->gindMac += cgind;
}

/* F I X  G L Y P H  S P A C E S */
/*----------------------------------------------------------------------------
    %%Function: FixGlyphSpaces
    %%Contact: sergeyge
	
	Fixes space glyph index for the Visi Spaces situation
----------------------------------------------------------------------------*/
static LSERR FixGlyphSpaces(LSTFLOW lstflow, const LSCHNKE* rglschnk,
									long itxtobjFirst, long igindVeryFirst, long itxtobjLast)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PLNOBJ plnobj;
	PTXTOBJ ptxtobj;
	long itxtobj;
	long iwSpace;
	long iwch;

	GMAP gmapTemp;
	GINDEX* pgindTemp;
	GPROP* pgpropTemp;
	DWORD cgind;

	plnobj = ((PTXTOBJ)rglschnk[itxtobjFirst].pdobj)->plnobj;
	pilsobj = plnobj->pilsobj;

	lserr = (*pilsobj->plscbk->pfnGetGlyphs)(pilsobj->pols, rglschnk[itxtobjFirst].plsrun, 
							&pilsobj->wchVisiSpace, 1, lstflow, &gmapTemp, &pgindTemp, &pgpropTemp, &cgind);
	if (lserr != lserrNone) return lserr;

	if (cgind != 1)
		{
		return lserrNone;
		}

	for (itxtobj=itxtobjFirst; itxtobj <= itxtobjLast; itxtobj++)
		{
		ptxtobj = (PTXTOBJ)rglschnk[itxtobj].pdobj;
		Assert(ptxtobj->txtkind == txtkindRegular);
		for (iwSpace = ptxtobj->u.reg.iwSpacesFirst; iwSpace < ptxtobj->u.reg.iwSpacesLim; iwSpace++)
			{
			iwch = pilsobj->pwSpaces[iwSpace];
			if ( FIwchOneToOne(pilsobj, iwch) )
				plnobj->pgind[IgindFirstFromIwchVeryFirst (ptxtobj, igindVeryFirst, iwch)] = *pgindTemp;
			}
		}

	return lserrNone;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\lstxtglf.c ===
#include "lsmem.h"

#include "lstxtglf.h"

#include "lstxtmap.h"
#include "txtils.h"
#include "txtln.h"
#include "txtobj.h"

#include "zqfromza.h"

typedef struct
{
	long cWhite;
	long duMaxWhite;
	long duTotalWhite;
	long cContinuous;
	long duMaxContinuous;
	long duMinContinuous;
	long cDiscrete;
	long duMaxDiscrete;
} EXPG;

typedef struct
{
	long cExpginfo;
	EXPG* pexpg;
	long cResidual;
} EXPGINFO;

#define priorSpace 1
#define priorMax 8
#define cDiscreteMax 25

#define min(a,b)     ((a) > (b) ? (b) : (a))
#define max(a,b)     ((a) < (b) ? (b) : (a))

static LSERR CollectGlyphExpInfo(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, LSDEVICE lsdev,
								long itxtobjFirst, long iwchFirst, long itxtobjLast, long iwchLast,
								long* rgdu, long* rgduGind, EXPGINFO* pexpginfo);
static LSERR ApplyPriorGlyphExp(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, LSDEVICE lsdev, 
						long itxtobjFirst, long iwchFirst, long itxtobjLast, long iwchLast,
						long prior, long duToDistribute, EXPG* pexpg, long* rgdu, long* rgduGind,
						long* rgduRight, long* rgduGright, long* pduDistributed);
LSERR static ApplyDiscrete(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, LSDEVICE lsdev,
						long itxtobjFirst, long iwchFirst, long itxtobjLast, long iwchLast,
						long prior,	long duToDistribute, long cDiscrete, 
						long* rgduGind, long* rgduGright, long* pduDistributed);
static void ApplyOneEachContinuous(const LSGRCHNK* plsgrchnk, long itxtobjFirst, long iwchFirst,
						long itxtobjLast, long iwchLast, long prior, long duToDistribute, long cContinuous,
						long* rgduGind, long* rgduGright, long* pduDistributed);
static void ApplyFullWhiteContinuous(const LSGRCHNK* plsgrchnk, long itxtobjFirst, long iwchFirst, long itxtobjLast, long iwchLast,
						long prior,
						long* rgdu, long* rgduGind,	long* rgduRight, long* rgduGright, long* pduDistributed);
static void ApplyPropWhiteContinuous(const LSGRCHNK* plsgrchnk, BOOL fWhiteOnly,
						long itxtobjFirst, long iwchFirst, long itxtobjLast, long iwchLast, long prior,
					 	long duToDistribute, long duTotalMin,
						long* rgdu, long* rgduGind, long* rgduRight, long* rgduGright, long* pduDistributed);
static void	ApplyResidualGlyphExp(const LSGRCHNK* plsgrchnk, long itxtobjFirst,
						long iwchFirst, long itxtobjLast, long iwchLim, long duToDistribute,
						long cResidual, long* rgduGind, long* rgduGright, long* pduDistributed);
static void	FixExpt(const LSGRCHNK* plsgrchnk, long itxtobjFirst, long iwchVeryFirst,
					 long itxtobjLast, long iwchLast, long* rgduGright);
static void CalcExpandChanges(long cWhole, long duDenom, long duRest, long duLocal, long duMax,
												long* pduChange, long* pduAddCurrent);
static void ApplyGlyphExpandChanges(long ind, long* rgduGind, long* rgduGright, long* pduDistributed, long duChange);


/* A P P L Y  G L Y P H  E X P A N D */
/*----------------------------------------------------------------------------
    %%Function: ApplyGlyphExpand
    %%Contact: sergeyge

	Applies glyph expansion
	First collects information about expansion opportunities
	Then applies expansion according to priorities
	If it is not sufficient, applies risidual expansion
----------------------------------------------------------------------------*/
LSERR ApplyGlyphExpand(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, LSDEVICE lsdev,
						long itxtobjFirst, long iwchFirst, long itxtobjLast, long iwchLast,
						long duToDistribute, long* rgdu, long* rgduGind, long* rgduRight, long* rgduGright,
						BOOL* pfFullyJustified)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	EXPGINFO expginfo;
	EXPG rgexpg[priorMax];
	long duDistributed;
	long i;
	
	pilsobj = ((PTXTOBJ)plsgrchnk->plschnk[0].pdobj)->plnobj->pilsobj;

	expginfo.pexpg = rgexpg;
	expginfo.cExpginfo = priorMax;

	lserr = CollectGlyphExpInfo(plsgrchnk, lstflow, lsdev,
								itxtobjFirst, iwchFirst, itxtobjLast, iwchLast,  rgdu, rgduGind, &expginfo);
	if (lserr != lserrNone) return lserr;

	for (i = 0; i < priorMax && duToDistribute > 0; i++)
		{
		lserr = ApplyPriorGlyphExp(plsgrchnk, lstflow, lsdev, itxtobjFirst, iwchFirst, itxtobjLast, iwchLast,
							 i + 1, duToDistribute,	&expginfo.pexpg[i], rgdu, rgduGind, rgduRight, rgduGright,
							 &duDistributed);
		if (lserr != lserrNone) return lserr;

		Assert(duDistributed <= duToDistribute);
		duToDistribute -= duDistributed;		
		}

	FixExpt(plsgrchnk, itxtobjFirst, iwchFirst, itxtobjLast, iwchLast, rgduGright);

	if (duToDistribute > 0 && expginfo.cResidual > 0)
		{
		ApplyResidualGlyphExp(plsgrchnk, itxtobjFirst, iwchFirst, itxtobjLast, iwchLast, duToDistribute,
										expginfo.cResidual, rgduGind, rgduGright, &duDistributed);
		Assert(duDistributed == duToDistribute);
		duToDistribute = 0;		
		}

	*pfFullyJustified = (duToDistribute == 0);

	return lserrNone;
}

/* C O L L E C T  G L Y P H  E X P  I N F O */
/*----------------------------------------------------------------------------
    %%Function: CollectGlyphExpInfo
    %%Contact: sergeyge

	Collects expansion information and agreagated values for
	the expansion algorithm.
	Spaces from character-based runs contribute as expansion opportunities
	of exptAddWhiteSpace type with prior==priorSpace and duMax==lsexpinfInfinity
----------------------------------------------------------------------------*/
static LSERR CollectGlyphExpInfo(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, LSDEVICE lsdev,
								long itxtobjFirst, long iwchVeryFirst, long itxtobjLast, long iwchLast,
								long* rgdu, long* rgduGind, EXPGINFO* pexpginfo)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PLNOBJ plnobj;
	PTXTOBJ ptxtobj;
	PTXTOBJ ptxtobjLast;
	PLSRUN plsrun;
	LSEXPINFO* plsexpinf;
	EXPTYPE* pexpt;
	long itxtobj;
	long iwchFirst;
	long iwchLim;
	long igindFirst;
	long igindLim;
	long igind;
	long iwSpace;

	memset(pexpginfo->pexpg, 0, sizeof(EXPG) * pexpginfo->cExpginfo);
	pexpginfo->cResidual = 0;

	ptxtobjLast = (PTXTOBJ)plsgrchnk->plschnk[max(0, itxtobjLast)].pdobj;
	plnobj = ptxtobjLast->plnobj;
	pilsobj = plnobj->pilsobj;

	itxtobj = itxtobjFirst;

	plsexpinf = pilsobj->plsexpinf;
	pexpt = plnobj->pexpt;

	while (itxtobj <= itxtobjLast)
		{
		ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;
		if (ptxtobj->txtf & txtfGlyphBased)
			{
			iwchFirst = iwchVeryFirst;
			if (itxtobj > itxtobjFirst)
				iwchFirst = ptxtobj->iwchFirst;

			Assert(iwchFirst < ptxtobj->iwchLim);

			igindFirst = IgindFirstFromIwch(ptxtobj, iwchFirst);
			plsrun = plsgrchnk->plschnk[itxtobj].plsrun;
			while ((!(ptxtobj->txtf & txtfLastShaping)) && itxtobj < itxtobjLast )
				{
				itxtobj++;
				ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;
				Assert (ptxtobj->txtf & txtfGlyphBased);
				Assert(ptxtobj->igindFirst == ((PTXTOBJ)plsgrchnk->plschnk[itxtobj-1].pdobj)->igindLim);
				Assert(ptxtobj->iwchFirst == ((PTXTOBJ)plsgrchnk->plschnk[itxtobj-1].pdobj)->iwchLim);
				}

			iwchLim = ptxtobj->iwchLim;
			igindLim = ptxtobj->igindLim;
			Assert(itxtobj <= itxtobjLast);
			if (itxtobj == itxtobjLast)
				{
				iwchLim = iwchLast + 1;
				Assert(IgindLastFromIwch(ptxtobjLast, iwchLast) + 1 <= igindLim);
				igindLim = IgindLastFromIwch(ptxtobjLast, iwchLast);

				while (!FIgindFirstInContext(pilsobj, igindLim) && rgduGind[igindLim] == 0)
					igindLim--;

				Assert(igindLim >= ptxtobj->igindFirst);

				igindLim++;
				}

			lserr = (*pilsobj->plscbk->pfnGetGlyphExpansionInfo)(pilsobj->pols, plsrun, lsdev,
					&pilsobj->pwchOrig[iwchFirst], &plnobj->pgmap[iwchFirst], iwchLim - iwchFirst, 
					&plnobj->pgind[igindFirst], &plnobj->pgprop[igindFirst], igindLim - igindFirst, 
					lstflow, itxtobj == itxtobjLast, &pexpt[igindFirst], &plsexpinf[igindFirst]);

			if (lserr != lserrNone) return lserr;
		
			for (igind = igindFirst; igind < igindLim; igind++)
				{
				Assert(plsexpinf[igind].prior < priorMax);
				if (plsexpinf[igind].prior > 0)
					{
					switch (pexpt[igind])
						{
					case exptAddWhiteSpace:
						Assert(plsexpinf[igind].duMax > 0);
						if (rgduGind[igind] > 0)
							{
							pexpginfo->pexpg[plsexpinf[igind].prior - 1].duMaxWhite += plsexpinf[igind].duMax;
							pexpginfo->pexpg[plsexpinf[igind].prior - 1].duTotalWhite += rgduGind[igind];
							pexpginfo->pexpg[plsexpinf[igind].prior - 1].cWhite++;
							}
						break;
					case exptAddInkContinuous:
						Assert(plsexpinf[igind].duMax > 0);
						Assert(plsexpinf[igind].u.AddInkContinuous.duMin > 0);
						pexpginfo->pexpg[plsexpinf[igind].prior - 1].duMaxContinuous += plsexpinf[igind].duMax;
						pexpginfo->pexpg[plsexpinf[igind].prior - 1].duMinContinuous +=
															plsexpinf[igind].u.AddInkContinuous.duMin;
						pexpginfo->pexpg[plsexpinf[igind].prior - 1].cContinuous++;
						break;
					case exptAddInkDiscrete:
						Assert(plsexpinf[igind].duMax > 0);
						pexpginfo->pexpg[plsexpinf[igind].prior - 1].duMaxDiscrete += plsexpinf[igind].duMax;
						pexpginfo->pexpg[plsexpinf[igind].prior - 1].cDiscrete++;
						break;
						}
					}
				if (plsexpinf[igind].fCanBeUsedForResidual)
					pexpginfo->cResidual++;
				}
	
			}
		else
			{
			if (ptxtobj->txtkind == txtkindRegular)
				{
				iwchFirst = iwchVeryFirst;
				if (itxtobj > itxtobjFirst)
					iwchFirst = ptxtobj->iwchFirst;

				iwchLim = iwchLast + 1;
				if (itxtobj < itxtobjLast)
					iwchLim = ptxtobj->iwchLim;
				
				for (iwSpace = ptxtobj->u.reg.iwSpacesFirst; iwSpace < ptxtobj->u.reg.iwSpacesLim &&
														pilsobj->pwSpaces[iwSpace] < iwchFirst; iwSpace++);
				for (; iwSpace < ptxtobj->u.reg.iwSpacesLim &&
															pilsobj->pwSpaces[iwSpace] < iwchLim; iwSpace++)
					{
					pexpginfo->pexpg[priorSpace - 1].duMaxWhite += lsexpinfInfinity;
					pexpginfo->pexpg[priorSpace - 1].duTotalWhite += rgdu[pilsobj->pwSpaces[iwSpace]];
					pexpginfo->pexpg[priorSpace - 1].cWhite++;
					}
				}
			}

		itxtobj++;

		}

	return lserrNone;
}


/* A P P L Y  P R I O R  G L Y P H  E X P A N D */
/*----------------------------------------------------------------------------
    %%Function: ApplyPriorGlyphExpand
    %%Contact: sergeyge

	Applies glyph expansion for particular priority

	Startegy:
	1. Apply Discrete expansion
	2. If the rest to distribute is bigger than the sum of maximus for other distribution types
				 use these maximums for distribution
	   else if sum of mimimums is less than the rest to distribute
				 distribute proportionally to this minimums (width of character for AddWhiteSpace type)
	   else
				increase AddContinuous opportrunities by minimum one by one while possible,
				distribute the rest in White opportunities proportionally
---------------------------------------------------------------------------*/
static LSERR ApplyPriorGlyphExp(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, LSDEVICE lsdev, 
						long itxtobjFirst, long iwchFirst, long itxtobjLast, long iwchLast,
						long prior, long duToDistribute, EXPG* pexpg, long* rgdu, long* rgduGind,
						long* rgduRight, long* rgduGright, long* pduDistributed)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	long duCovered;
	const BOOL fWhiteOnly = fTrue;
	
	*pduDistributed = 0;

	pilsobj = ((PTXTOBJ)plsgrchnk->plschnk[0].pdobj)->plnobj->pilsobj;

	Assert(duToDistribute > 0);

	if (pexpg->cDiscrete > 0)
		{
		lserr = ApplyDiscrete(plsgrchnk, lstflow, lsdev, itxtobjFirst, iwchFirst, itxtobjLast, iwchLast,
						prior, duToDistribute, pexpg->cDiscrete, 
						rgduGind, rgduGright, &duCovered);
		if (lserr != lserrNone) return lserr;

		Assert(duCovered <= duToDistribute);

		duToDistribute -= duCovered;
		*pduDistributed += duCovered;
		}

	if (duToDistribute > 0 && pexpg->cWhite + pexpg->cContinuous > 0 )
		{
		if (pexpg->duMaxWhite + pexpg->duMaxContinuous <= duToDistribute)
			{
			ApplyFullWhiteContinuous(plsgrchnk, itxtobjFirst, iwchFirst, itxtobjLast, iwchLast,
						prior, rgdu, rgduGind, rgduRight, rgduGright, &duCovered);

			Assert(duCovered == pexpg->duMaxWhite + pexpg->duMaxContinuous);

			duToDistribute -= duCovered;
			*pduDistributed += duCovered;
			}
		else if (pexpg->duTotalWhite + pexpg->duMinContinuous <= duToDistribute)
			{
			Assert(pexpg->duMaxWhite + pexpg->duMaxContinuous > duToDistribute);
			ApplyPropWhiteContinuous(plsgrchnk, !fWhiteOnly,
						itxtobjFirst, iwchFirst, itxtobjLast, iwchLast,
						prior,	duToDistribute,	pexpg->duTotalWhite + pexpg->duMinContinuous,
						rgdu, rgduGind, rgduRight, rgduGright, &duCovered);

			duToDistribute -= duCovered;
			*pduDistributed += duCovered;
			}
		else
			{
			Assert(pexpg->duTotalWhite + pexpg->duMinContinuous > duToDistribute);
			if (pexpg->cContinuous > 0)
				{
				ApplyOneEachContinuous(plsgrchnk, itxtobjFirst, iwchFirst, itxtobjLast, iwchLast,
						prior, duToDistribute, pexpg->cContinuous,
						rgduGind, rgduGright, &duCovered);
				duToDistribute -= duCovered;
				*pduDistributed += duCovered;
				}
			if (pexpg->cWhite > 0 && duToDistribute > 0)
				{
				ApplyPropWhiteContinuous(plsgrchnk, fWhiteOnly,
						itxtobjFirst, iwchFirst, itxtobjLast, iwchLast,
						prior, duToDistribute, pexpg->duTotalWhite,
						rgdu, rgduGind, rgduRight, rgduGright, &duCovered);
				duToDistribute -= duCovered;
				*pduDistributed += duCovered;
				}

			}
		}

	return lserrNone;
}

/* A P P L Y  D I S C R E T E */
/*----------------------------------------------------------------------------
    %%Function: ApplyDiscrete
    %%Contact: sergeyge

	Applies disctrete glyph expansion for particular priority

	Goes ones from first to last glyph on this priority level, and chooses maximum
	discrete opportunity which still fits.
---------------------------------------------------------------------------*/
LSERR static ApplyDiscrete(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, LSDEVICE lsdev,
						long itxtobjFirst, long iwchVeryFirst, long itxtobjLast, long iwchLast,
						long prior,	long duToDistribute, long cDiscrete, 
						long* rgduGind, long* rgduGright, long* pduDistributed)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PLNOBJ plnobj;
	PTXTOBJ ptxtobj;
	PTXTOBJ ptxtobjLast;
	PLSRUN plsrun;
	LSEXPINFO* plsexpinf;
	EXPTYPE* pexpt;
	long itxtobj;
	long iwchFirst;
	long iwchLim;
	long igindFirst;
	long igindLim;
	long igind;
	long rgduDiscrete[cDiscreteMax];
	long* pduDiscrete;
	long cwidths;
	int i;

	*pduDistributed = 0;

	ptxtobjLast = (PTXTOBJ)plsgrchnk->plschnk[max(0, itxtobjLast)].pdobj;
	plnobj = ptxtobjLast->plnobj;
	pilsobj = plnobj->pilsobj;

	itxtobj = itxtobjFirst;

	plsexpinf = pilsobj->plsexpinf;
	pexpt = plnobj->pexpt;

	for (itxtobj = itxtobjLast; itxtobj >= itxtobjFirst && cDiscrete > 0 && duToDistribute > 0; itxtobj--)
		{
		ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;
		if (ptxtobj->txtf & txtfGlyphBased)
			{
			iwchFirst = iwchVeryFirst;
			if (itxtobj > itxtobjFirst)
				iwchFirst = ptxtobj->iwchFirst;

			Assert(iwchFirst < ptxtobj->iwchLim);

			igindFirst = IgindFirstFromIwch(ptxtobj, iwchFirst);

			iwchLim = ptxtobj->iwchLim;
			igindLim = ptxtobj->igindLim;
			Assert(itxtobj <= itxtobjLast);
			if (itxtobj == itxtobjLast)
				{
				iwchLim = iwchLast + 1;
				Assert(IgindLastFromIwch(ptxtobjLast, iwchLast) + 1 <= igindLim);
				igindLim = IgindLastFromIwch(ptxtobjLast, iwchLast) + 1;
				}

			plsrun = plsgrchnk->plschnk[itxtobj].plsrun;

			for (igind = igindLim - 1; igind >= igindFirst && cDiscrete > 0 && duToDistribute > 0; igind--)
				{
				if (pexpt[igind] == exptAddInkDiscrete && plsexpinf[igind].prior == prior)
					{
					cDiscrete--;
					if (duToDistribute > plsexpinf[igind].duMax)
						{
						ApplyGlyphExpandChanges(igind, rgduGind, rgduGright, pduDistributed, plsexpinf[igind].duMax);
						duToDistribute -= plsexpinf[igind].duMax;
						}
					else
						{
						pduDiscrete = rgduDiscrete;
						cwidths = plsexpinf[igind].u.AddInkDiscrete.cwidths - 1;
						if (cwidths > cDiscreteMax)
							{
							pduDiscrete = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(long) * cwidths);
							if (pduDiscrete == NULL) return lserrOutOfMemory;
							}
						lserr = (pilsobj->plscbk->pfnGetGlyphExpansionInkInfo)(pilsobj->pols, plsrun, lsdev,
								plnobj->pgind[igind], plnobj->pgprop[igind], lstflow, cwidths, pduDiscrete);
						if (lserr != lserrNone)
							{
							if (pduDiscrete != rgduDiscrete)
								(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pduDiscrete);
							return lserr;
							}
						#ifdef DEBUG
						for (i = 0; i < cwidths - 1; i++)
							Assert(pduDiscrete[i] <= pduDiscrete[i+1]);
						#endif
						for (i = cwidths - 1; i >= 0 && pduDiscrete[i] > duToDistribute; i--);
						if (i >= 0)
							{
							Assert(pduDiscrete[i] <= duToDistribute);
							ApplyGlyphExpandChanges(igind, rgduGind, rgduGright, pduDistributed, pduDiscrete[i]);
							duToDistribute -= pduDiscrete[i];
							}
						if (pduDiscrete != rgduDiscrete)
							(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pduDiscrete);
						}
					}
				}
			}
		}

	return lserrNone;
}

/* A P P L Y  O N E  E A C H  C O N T I N U O U S */
/*----------------------------------------------------------------------------
    %%Function: ApplyOneEachContinuous
    %%Contact: sergeyge

	Applies glyph expansion for particular priority

	Goes ones from first to last glyph on this priority level, and adds minimum
	to each glyph with AddIncContinuous exapnsion type, if this minimum still fits
---------------------------------------------------------------------------*/
static void ApplyOneEachContinuous(const LSGRCHNK* plsgrchnk, long itxtobjFirst, long iwchVeryFirst,
						long itxtobjLast, long iwchLast, long prior, long duToDistribute, long cContinuous,
						long* rgduGind, long* rgduGright, long* pduDistributed)
{
	PILSOBJ pilsobj;
	PLNOBJ plnobj;
	PTXTOBJ ptxtobj;
	PTXTOBJ ptxtobjLast;
	LSEXPINFO* plsexpinf;
	EXPTYPE* pexpt;
	long itxtobj;
	long iwchFirst;
	long iwchLim;
	long igindFirst;
	long igindLim;
	long igind;

	*pduDistributed = 0;

	ptxtobjLast = (PTXTOBJ)plsgrchnk->plschnk[max(0, itxtobjLast)].pdobj;
	plnobj = ptxtobjLast->plnobj;
	pilsobj = plnobj->pilsobj;

	itxtobj = itxtobjFirst;

	plsexpinf = pilsobj->plsexpinf;
	pexpt = plnobj->pexpt;

	for (itxtobj = itxtobjLast; itxtobj >= itxtobjFirst && cContinuous > 0 && duToDistribute > 0; itxtobj--)
		{
		ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;
		if (ptxtobj->txtf & txtfGlyphBased)
			{
			iwchFirst = iwchVeryFirst;
			if (itxtobj > itxtobjFirst)
				iwchFirst = ptxtobj->iwchFirst;

			Assert(iwchFirst < ptxtobj->iwchLim);
			igindFirst = IgindFirstFromIwch(ptxtobj, iwchFirst);

			iwchLim = ptxtobj->iwchLim;
			igindLim = ptxtobj->igindLim;
			Assert(itxtobj <= itxtobjLast);
			if (itxtobj == itxtobjLast)
				{
				iwchLim = iwchLast + 1;
				Assert(IgindLastFromIwch(ptxtobjLast, iwchLast) + 1 <= igindLim);
				igindLim = IgindLastFromIwch(ptxtobjLast, iwchLast) + 1;
				}

			for (igind = igindLim - 1; igind >= igindFirst && cContinuous> 0 && duToDistribute > 0; igind--)
				{
				if (pexpt[igind] == exptAddInkContinuous && plsexpinf[igind].prior == prior)
					{
					cContinuous--;
					if (duToDistribute > plsexpinf[igind].u.AddInkContinuous.duMin)
						{
						ApplyGlyphExpandChanges(igind, rgduGind, rgduGright, pduDistributed, plsexpinf[igind].u.AddInkContinuous.duMin);
						duToDistribute -= plsexpinf[igind].u.AddInkContinuous.duMin;
						}
					}
				}
			}
		}

}

/* A P P L Y  F U L L  W H I T E  C O N T I N U O U S */
/*----------------------------------------------------------------------------
    %%Function: ApplyFullWhiteContinuous
    %%Contact: sergeyge

	Applies glyph expansion for particular priority

	Goes ones from first to last glyph on this priority level, and adds maximum
	to each glyph with AddIncContinuous or AddWhiteSpace exapnsion type
---------------------------------------------------------------------------*/
static void ApplyFullWhiteContinuous(const LSGRCHNK* plsgrchnk,
						long itxtobjFirst, long iwchVeryFirst, long itxtobjLast, long iwchLast,
						long prior,
						long* rgdu, long* rgduGind,	long* rgduRight, long* rgduGright, long* pduDistributed)
{
	PILSOBJ pilsobj;
	PLNOBJ plnobj;
	PTXTOBJ ptxtobj;
	PTXTOBJ ptxtobjLast;
	LSEXPINFO* plsexpinf;
	EXPTYPE* pexpt;
	long itxtobj;
	long iwchFirst;
	long iwchLim;
	long igindFirst;
	long igindLim;
	long igind;
	long iwSpace;

	*pduDistributed = 0;

	ptxtobjLast = (PTXTOBJ)plsgrchnk->plschnk[max(0, itxtobjLast)].pdobj;
	plnobj = ptxtobjLast->plnobj;
	pilsobj = plnobj->pilsobj;

	itxtobj = itxtobjFirst;

	plsexpinf = pilsobj->plsexpinf;
	pexpt = plnobj->pexpt;

	for (itxtobj = itxtobjFirst; itxtobj <= itxtobjLast; itxtobj++)
		{
		ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;
		if (ptxtobj->txtf & txtfGlyphBased)
			{
			iwchFirst = iwchVeryFirst;
			if (itxtobj > itxtobjFirst)
				iwchFirst = ptxtobj->iwchFirst;

			Assert(iwchFirst < ptxtobj->iwchLim);

			igindFirst = IgindFirstFromIwch(ptxtobj, iwchFirst);

			iwchLim = ptxtobj->iwchLim;
			igindLim = ptxtobj->igindLim;
			Assert(itxtobj <= itxtobjLast);
			if (itxtobj == itxtobjLast)
				{
				iwchLim = iwchLast + 1;
				Assert(IgindLastFromIwch(ptxtobjLast, iwchLast) + 1 <= igindLim);
				igindLim = IgindLastFromIwch(ptxtobjLast, iwchLast) + 1;
				}

			for (igind = igindFirst; igind < igindLim; igind++)
				{
				if (plsexpinf[igind].prior == prior &&
						(pexpt[igind] == exptAddWhiteSpace || pexpt[igind] == exptAddInkContinuous))
					{
					ApplyGlyphExpandChanges(igind, rgduGind, rgduGright, pduDistributed, plsexpinf[igind].duMax);
					}
				}
	
			}
		else
			{
			if (ptxtobj->txtkind == txtkindRegular && prior == priorSpace)
				{
				iwchFirst = iwchVeryFirst;
				if (itxtobj > itxtobjFirst)
					iwchFirst = ptxtobj->iwchFirst;
			
				iwchLim = iwchLast + 1;
				if (itxtobj < itxtobjLast)
					iwchLim = ptxtobj->iwchLim;

				for (iwSpace = ptxtobj->u.reg.iwSpacesFirst; iwSpace < ptxtobj->u.reg.iwSpacesLim &&
														pilsobj->pwSpaces[iwSpace] < iwchFirst; iwSpace++);
				for (; iwSpace < ptxtobj->u.reg.iwSpacesLim &&
													 pilsobj->pwSpaces[iwSpace] < iwchLim; iwSpace++)
					{
					Assert(fFalse);
					ApplyGlyphExpandChanges(pilsobj->pwSpaces[iwSpace], rgdu, rgduRight, pduDistributed, lsexpinfInfinity);
					}
				}
			}
		}
}

/* A P P L Y  P R O P  W H I T E  C O N T I N U O U S */
/*----------------------------------------------------------------------------
    %%Function: ApplyPropWhiteContinuous
    %%Contact: sergeyge

	Applies glyph expansion for particular priority

	Goes ones from first to last glyph on this priority level, and increases width
	for each glyph with AddIncContinuous or AddWhiteSpace exapnsion type
	proportionally to its minimum (for InkCont) or width of character (for WhiteSpace).
---------------------------------------------------------------------------*/
static void ApplyPropWhiteContinuous(const LSGRCHNK* plsgrchnk, BOOL fWhiteOnly,
						long itxtobjFirst, long iwchVeryFirst, long itxtobjLast, long iwchLast, long prior,
					 	long duToDistribute, long duDenom,
						long* rgdu, long* rgduGind, long* rgduRight, long* rgduGright, long* pduDistributed)
{
	PILSOBJ pilsobj;
	PLNOBJ plnobj;
	PTXTOBJ ptxtobj;
	PTXTOBJ ptxtobjLast;
	LSEXPINFO* plsexpinf;
	EXPTYPE* pexpt;
	long itxtobj;
	long iwchFirst;
	long iwchLim;
	long igindFirst;
	long igindLim;
	long igind;
	long cWhole;
	long duAddCurrent;
	long duDebt;
	long duRest;
	long duChange;
	long iwch;
	long iwSpace;
	long duDebtSaved;

	*pduDistributed = 0;

	ptxtobjLast = (PTXTOBJ)plsgrchnk->plschnk[max(0, itxtobjLast)].pdobj;
	plnobj = ptxtobjLast->plnobj;
	pilsobj = plnobj->pilsobj;

	plsexpinf = pilsobj->plsexpinf;
	pexpt = plnobj->pexpt;

	cWhole = duToDistribute / duDenom;

	duRest = duToDistribute - cWhole * duDenom;

	duAddCurrent = 0;

	duDebt = 0;

	for (itxtobj = itxtobjFirst; itxtobj <= itxtobjLast; itxtobj++)
		{
		ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;
		if (ptxtobj->txtf & txtfGlyphBased)
			{
			iwchFirst = iwchVeryFirst;
			if (itxtobj > itxtobjFirst)
				iwchFirst = ptxtobj->iwchFirst;

			Assert(iwchFirst < ptxtobj->iwchLim);

			igindFirst = IgindFirstFromIwch(ptxtobj, iwchFirst);

			iwchLim = ptxtobj->iwchLim;
			igindLim = ptxtobj->igindLim;
			Assert(itxtobj <= itxtobjLast);
			if (itxtobj == itxtobjLast)
				{
				iwchLim = iwchLast + 1;
				Assert(IgindLastFromIwch(ptxtobjLast, iwchLast) + 1 <= igindLim);
				igindLim = IgindLastFromIwch(ptxtobjLast, iwchLast) + 1;
				}

			for (igind = igindFirst; igind < igindLim; igind++)
				{
				if (plsexpinf[igind].prior == prior)
					{
					if (pexpt[igind] == exptAddWhiteSpace)
						{
						Assert(rgduGright[igind] == 0 || pexpt[igind] == exptAddInkDiscrete);
						CalcExpandChanges(cWhole, duDenom, duRest,
								 rgduGind[igind], plsexpinf[igind].duMax, &duChange, &duAddCurrent);
						if (duChange > 0)
							ApplyGlyphExpandChanges(igind, rgduGind, rgduGright, pduDistributed, duChange);
						}

					else if (pexpt[igind] == exptAddInkContinuous && !fWhiteOnly)
						{
						Assert(rgduGright[igind] == 0 || pexpt[igind] == exptAddInkDiscrete);
						CalcExpandChanges(cWhole, duDenom, duRest, plsexpinf[igind].u.AddInkContinuous.duMin,
													 plsexpinf[igind].duMax, &duChange, &duAddCurrent);
						if (duChange > 0)
							ApplyGlyphExpandChanges(igind, rgduGind, rgduGright, pduDistributed, duChange);
						}
					}
				}
	
			}
		else
			{
			if (ptxtobj->txtkind == txtkindRegular && prior == priorSpace)
				{
				iwchFirst = iwchVeryFirst;
				if (itxtobj > itxtobjFirst)
					iwchFirst = ptxtobj->iwchFirst;

				iwchLim = iwchLast + 1;
				if (itxtobj < itxtobjLast)
					iwchLim = ptxtobj->iwchLim;

				for (iwSpace = ptxtobj->u.reg.iwSpacesFirst; iwSpace < ptxtobj->u.reg.iwSpacesLim &&
														pilsobj->pwSpaces[iwSpace] < iwchFirst; iwSpace++);
				for (; iwSpace < ptxtobj->u.reg.iwSpacesLim &&
													 pilsobj->pwSpaces[iwSpace] < iwchLim; iwSpace++)
					{
					iwch = pilsobj->pwSpaces[iwSpace];
					CalcExpandChanges(cWhole, duDenom, duRest, rgdu[iwch], lsexpinfInfinity,
												&duChange, &duAddCurrent);
					if (duChange > 0)
						ApplyGlyphExpandChanges(iwch, rgdu, rgduRight, pduDistributed, duChange);
					}
				}
			}

		}

	duDebt = duToDistribute - *pduDistributed;
	Assert(duDebt >= 0);
/* If not everything distributed, distribute it somehow not violating Min/Max boundaries */
	duDebtSaved = 0;
	while (duDebt > 0 && duDebt != duDebtSaved)
		{
		duDebtSaved = duDebt;
		for (itxtobj = itxtobjLast; itxtobj >= itxtobjFirst && duDebt > 0; itxtobj--)
			{
			ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;
			if (ptxtobj->txtf & txtfGlyphBased)
				{
				iwchFirst = iwchVeryFirst;
				if (itxtobj > itxtobjFirst)
					iwchFirst = ptxtobj->iwchFirst;

				Assert(iwchFirst < ptxtobj->iwchLim);

				igindFirst = IgindFirstFromIwch(ptxtobj, iwchFirst);

				iwchLim = ptxtobj->iwchLim;
				igindLim = ptxtobj->igindLim;
				Assert(itxtobj <= itxtobjLast);
				if (itxtobj == itxtobjLast)
					{
					iwchLim = iwchLast + 1;
					Assert(IgindLastFromIwch(ptxtobjLast, iwchLast) + 1 <= igindLim);
					igindLim = IgindLastFromIwch(ptxtobjLast, iwchLast) + 1;
					}

				for (igind = igindLim - 1; igind >= igindFirst && duDebt > 0; igind--)
					{
					if (plsexpinf[igind].prior == prior && rgduGright[igind] < plsexpinf[igind].duMax)
						{
						if (pexpt[igind] == exptAddWhiteSpace)
							{
							duChange = min(rgduGind[igind] - rgduGright[igind], min(duDebt, plsexpinf[igind].duMax - rgduGright[igind]));
							ApplyGlyphExpandChanges(igind, rgduGind, rgduGright, pduDistributed, duChange);
							duDebt -= duChange;
							}
						else if (pexpt[igind] == exptAddInkContinuous && !fWhiteOnly)
							{
							Assert(rgduGright[igind] > 0);
							duChange = min(plsexpinf[igind].u.AddInkContinuous.duMin, min(duDebt, plsexpinf[igind].duMax - rgduGright[igind]));
							ApplyGlyphExpandChanges(igind, rgduGind, rgduGright, pduDistributed, duChange);
							duDebt -= duChange;
							}
						}
					}
		
				}
			else
				{
				if (ptxtobj->txtkind == txtkindRegular && prior == priorSpace)
					{
					iwchFirst = iwchVeryFirst;
					if (itxtobj > itxtobjFirst)
						iwchFirst = ptxtobj->iwchFirst;

					iwchLim = iwchLast + 1;
					if (itxtobj < itxtobjLast)
						iwchLim = ptxtobj->iwchLim;

					for (iwSpace = ptxtobj->u.reg.iwSpacesLim - 1; iwSpace >= ptxtobj->u.reg.iwSpacesFirst &&
												pilsobj->pwSpaces[iwSpace] >= iwchLim; iwSpace--);
					for (; iwSpace >= ptxtobj->u.reg.iwSpacesFirst &&
								 pilsobj->pwSpaces[iwSpace] >= iwchFirst && duDebt > 0; iwSpace--)
						{
						iwch = pilsobj->pwSpaces[iwSpace];
						duChange = min(rgdu[iwch] - rgduRight[iwch], duDebt);
						ApplyGlyphExpandChanges(iwch, rgdu, rgduRight, pduDistributed, duChange);
						duDebt -= duChange;
						}
					}
				}

			}
		Assert(duDebt == duToDistribute - *pduDistributed);
		}

}

/* A P P L Y  R E S I D U A L  G L Y P H  E X P */
/*----------------------------------------------------------------------------
    %%Function: ApplyResidualGlyphExp
    %%Contact: sergeyge


	Distributes equally between all risidual opportunities
---------------------------------------------------------------------------*/
static void	ApplyResidualGlyphExp(const LSGRCHNK* plsgrchnk, long itxtobjFirst,
						long iwchVeryFirst, long itxtobjLast, long iwchLast, long duToDistribute,
						long cResidual, long* rgduGind, long* rgduGright, long* pduDistributed)
{
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	PTXTOBJ ptxtobjLast;
	LSEXPINFO* plsexpinf;
	long itxtobj;
	long iwchFirst;
	long iwchLim;
	long igindFirst;
	long igindLim;
	long igind;
	long cUsed;
	long duAdd;
	long cBound;

	*pduDistributed = 0;

	if (cResidual == 0)
		return;

	ptxtobjLast = (PTXTOBJ)plsgrchnk->plschnk[max(0, itxtobjLast)].pdobj;
	pilsobj = ptxtobjLast->plnobj->pilsobj;

	itxtobj = itxtobjFirst;

	plsexpinf = pilsobj->plsexpinf;

	duAdd = duToDistribute / cResidual;

	cBound = duToDistribute - duAdd * cResidual;

	cUsed = 0;

	for (itxtobj = itxtobjFirst; itxtobj <= itxtobjLast; itxtobj++)
		{
		ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;
		if (ptxtobj->txtf & txtfGlyphBased)
			{
			iwchFirst = iwchVeryFirst;
			if (itxtobj > itxtobjFirst)
				iwchFirst = ptxtobj->iwchFirst;

			Assert(iwchFirst < ptxtobj->iwchLim);
			igindFirst = IgindFirstFromIwch(ptxtobj, iwchFirst);

			iwchLim = ptxtobj->iwchLim;
			igindLim = ptxtobj->igindLim;
			Assert(itxtobj <= itxtobjLast);
			if (itxtobj == itxtobjLast)
				{
				iwchLim = iwchLast + 1;
				Assert(IgindLastFromIwch(ptxtobjLast, iwchLast) + 1 <= igindLim);
				igindLim = IgindLastFromIwch(ptxtobjLast, iwchLast) + 1;
				}

			for (igind = igindFirst; igind < igindLim; igind++)
				{
				if (plsexpinf[igind].fCanBeUsedForResidual)
					{
					if (cUsed < cBound)
						ApplyGlyphExpandChanges(igind, rgduGind, rgduGright, pduDistributed, duAdd + 1);
					else
						ApplyGlyphExpandChanges(igind, rgduGind, rgduGright, pduDistributed, duAdd);
					cUsed++;
					}
				}
			}
		}

	Assert(duToDistribute == *pduDistributed);

}

/* F I X  E X P T */
/*----------------------------------------------------------------------------
    %%Function: FixExpt
    %%Contact: sergeyge

	Zeroes expt for the glyphs which were not changed,
	so correct distribution type is passed to client at display time
---------------------------------------------------------------------------*/
static void	FixExpt(const LSGRCHNK* plsgrchnk, long itxtobjFirst, long iwchVeryFirst,
					 long itxtobjLast, long iwchLast, long* rgduGright)
{
	PTXTOBJ ptxtobj;
	PTXTOBJ ptxtobjLast;
	EXPTYPE* pexpt;
	long itxtobj;
	long iwchFirst;
	long iwchLim;
	long igindFirst;
	long igindLim;
	long igind;

	ptxtobjLast = (PTXTOBJ)plsgrchnk->plschnk[max(0, itxtobjLast)].pdobj;
	pexpt = ptxtobjLast->plnobj->pexpt;

	itxtobj = itxtobjFirst;

	for (itxtobj = itxtobjFirst; itxtobj <= itxtobjLast; itxtobj++)
		{
		ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;
		if (ptxtobj->txtf & txtfGlyphBased)
			{
			iwchFirst = iwchVeryFirst;
			if (itxtobj > itxtobjFirst)
				iwchFirst = ptxtobj->iwchFirst;

			Assert(iwchFirst < ptxtobj->iwchLim);
			igindFirst = IgindFirstFromIwch(ptxtobj, iwchFirst);

			iwchLim = ptxtobj->iwchLim;
			igindLim = ptxtobj->igindLim;
			Assert(itxtobj <= itxtobjLast);
			if (itxtobj == itxtobjLast)
				{
				iwchLim = iwchLast + 1;
				Assert(IgindLastFromIwch(ptxtobjLast, iwchLast) + 1 <= igindLim);
				igindLim = IgindLastFromIwch(ptxtobjLast, iwchLast) + 1;
				}

			for (igind = igindFirst; igind < igindLim; igind++)
				{
				if (rgduGright[igind] == 0)
					{
					pexpt[igind] = 0;
					}
				}
			}
		}

}

/* C A L C  E X P A N D  C H A N G E S */
/*----------------------------------------------------------------------------
    %%Function: CalcExpandChanges
    %%Contact: sergeyge

	Arithmetics for proportional distribution
---------------------------------------------------------------------------*/
static void CalcExpandChanges(long cWhole, long duDenom, long duRest, long duLocal, long duMax,
												long* pduChange, long* pduAddCurrent)
{
/* REVIEW sergeyge: is __int64 necessary to avoid overflow??? */
	__int64 temp;

	temp = Mul64 (duRest, duLocal) + *pduAddCurrent;
	
	Assert(duDenom > 0);
	Assert(Div64 (temp, duDenom) < 0x7FFFFFFF);
	
	*pduChange = (long) Div64 (temp, duDenom);
	
	Assert( temp - Mul64(*pduChange, duDenom) < 0x7FFFFFFF);
	*pduAddCurrent = (long)(temp - Mul64(*pduChange, duDenom));
	
	*pduChange += (cWhole * duLocal);
	if (*pduChange > duMax)
		{
		*pduChange = duMax;
		}

}

/* A P P L Y  G L Y P H  E X P A N D  C H A N G E S */
/*----------------------------------------------------------------------------
    %%Function: ApplyGlyphExpandChanges
    %%Contact: sergeyge

---------------------------------------------------------------------------*/
static void ApplyGlyphExpandChanges(long ind, long* rgduGind, long* rgduGright, long* pduDistributed, long duChange)
{
	rgduGind[ind] += duChange;
	rgduGright[ind] += duChange;
	*pduDistributed += duChange;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\lstxtcmp.c ===
#include "lsmem.h"

#include "lstxtcmp.h"
#include "lstxtmod.h"
#include "lstxtmap.h"

#include "lschp.h"
#include "lspract.h"
#include "lsems.h"
#include "txtils.h"
#include "txtln.h"
#include "txtobj.h"

#define min(a,b)     ((a) > (b) ? (b) : (a))
#define max(a,b)     ((a) < (b) ? (b) : (a))

typedef struct
{
	long rgdurPrior[2];
	long rgcExpPrior[2];
	long cExpOppr;
} EXPINFO;

typedef struct
{
	long durComp;
	long cCompOppr;
} COMPINFO;


static LSERR GetExpandInfo(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, BOOL fScaled,
					 long itxtobjFirst, long iwchFirst, long itxtobjLast, long iwchLim,	EXPINFO* pexpinfo);
static void GetCompressInfo(const LSGRCHNK* plsgrchnk, long itxtobjFirst, long iwchFirst, 
											long itxtobjLast, long iwchLim, COMPINFO* pcompinfo);
static LSERR CheckExpandSpace(PILSOBJ pilsobj, LSEMS* plsems, long iwchPrev, long iwch, long iwchNext,
							PTXTOBJ ptxtobjCur, PLSRUN plsrunPrev, PLSRUN plsrunCur, PLSRUN plsrunNext,
							BOOL* pfExpandOpp, long* pdurChange);
static LSERR CheckExpandOnRun(PILSOBJ pilsobj, LSEMS* plsems, long iwch, long iwchNext, PTXTOBJ ptxtobjCur,
							PLSRUN plsrunCur, PLSRUN plsrunNext, BOOL* pfExpandOpp, long* pdurChange);
static void ApplyPriorCompression(const LSGRCHNK* plsgrchnk,  long itxtobjFirst, long iwchFirst,
									long itxtobjLast, long iwchLim, BYTE prior,
									long durToCompress, long durAvailable, long cExpOppr);
static void ApplyPriorExpansion(const LSGRCHNK* plsgrchnk, long itxtobjFirst, long iwchFirst,
			 long txtobjLast, long iwchLim, BYTE prior, long durToExpand, long durAvailable, long cExpOppr);
static void ApplyFullExpansion(const LSGRCHNK* plsgrchnk, long itxtobjFirst, long iwchFirst,
		long itxtobjLast, long iwchLim, long durToExpand, long cExpOppr, long cNonText, long* pdurNonText);
static LSERR CheckCompSpace(PILSOBJ pilsobj, LSEMS* plsems, long iwchPrev, long iwch, long iwchNext,
			PTXTOBJ ptxtobjCur, PLSRUN plsrunPrev, PLSRUN plsrunCur, PLSRUN plsrunNext, long* pdurChange);
static LSERR CheckCompOnRun(PILSOBJ pilsobj, LSEMS* plsems, long iwch, long iwchNext, PTXTOBJ ptxtobjCur,
							PLSRUN plsrunCur, PLSRUN plsrunNext, long* pdurChange);
static void SetComp(PILSOBJ pilsobj, long iwch, BYTE prior, BYTE side, long durChange);
static BOOL GetNextRun(const LSGRCHNK* plsgrchnk, long itxtobj, long* pitxtobjNext);
static void GetPrevCharRun(const LSGRCHNK* plsgrchnk, long itxtobj, long iwch, long* piwchPrev, PLSRUN* pplsrunPrev);

/* F E T C H  C O M P R E S S  I N F O */
/*----------------------------------------------------------------------------
    %%Function: FetchCompressInfo
    %%Contact: sergeyge

	Fetches compression information until durCompressMaxStop exceeded
---------------------------------------------------------------------------*/
LSERR FetchCompressInfo(const LSGRCHNK* plsgrchnk, BOOL fFirstOnLine, LSTFLOW lstflow, 
						long itxtobjFirst, long iwchFirst, long itxtobjLast, long iwchLim,
						long durCompressMaxStop, long* pdurCompressTotal)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	TXTINF* rgtxtinf;
	WCHAR* rgwchOrig;
	PTXTOBJ ptxtobj;
	PLSRUN plsrunCur;
	PLSRUN plsrunPrev;
	PLSRUN plsrunNext = NULL;
	PCLSCHP plschp;
	LSPRACT lspract;
	BYTE side;
	BYTE sideFinal;
	long durChange;
	long durTemp;
	LSEMS lsems;
	BOOL fNextAdjacentFound;
	long itxtobj;
	long itxtobjNext;
	long itxtobjLastProcessed;
	long itxtobjCompressFetchedLim;
	long iwchCompressFetchedLim;
	long iwchLimDobj;
	long iwch;
	long iwchPrev;
	long iwchNext;
	BOOL fGlyphBased;

	*pdurCompressTotal = 0;

	pilsobj = ((PTXTOBJ)plsgrchnk->plschnk[0].pdobj)->plnobj->pilsobj;

	rgtxtinf = pilsobj->ptxtinf;
	/* rgtxtinf == NULL means that there were no runs which possibly could introduce compress opportunity */
	if (rgtxtinf == NULL)
		return lserrNone;

	iwch = iwchFirst;

	rgwchOrig = pilsobj->pwchOrig;

	itxtobjCompressFetchedLim = 0;
	iwchCompressFetchedLim = 0;
	
	if (pilsobj->iwchCompressFetchedFirst == iwchFirst)
		{
		itxtobjCompressFetchedLim = pilsobj->itxtobjCompressFetchedLim;
		iwchCompressFetchedLim = pilsobj->iwchCompressFetchedLim;
		}

	itxtobj = itxtobjFirst;
	itxtobjLastProcessed = itxtobj-1;

	if (itxtobj < (long)plsgrchnk->clsgrchnk)
		GetNextRun(plsgrchnk, itxtobj, &itxtobj);

	Assert( itxtobj == (long)plsgrchnk->clsgrchnk || 
			((PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj)->iwchLim >
			((PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj)->iwchFirst);

	while(itxtobj <= itxtobjLast && *pdurCompressTotal < durCompressMaxStop)
		{
		itxtobjLastProcessed = itxtobj;

		fNextAdjacentFound = GetNextRun(plsgrchnk, itxtobj + 1, &itxtobjNext);

		ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;
		plsrunCur = plsgrchnk->plschnk[itxtobj].plsrun;
		plschp = plsgrchnk->plschnk[itxtobj].plschp;

		iwchLimDobj = iwchLim;
		if (itxtobj < itxtobjLast)
			iwchLimDobj = ptxtobj->iwchLim;

		if (itxtobj > itxtobjCompressFetchedLim - 1 ||
			itxtobj == itxtobjCompressFetchedLim - 1 && iwchLimDobj > iwchCompressFetchedLim)
			{
			lserr = (*pilsobj->plscbk->pfnGetEms)(pilsobj->pols, plsrunCur, lstflow, &lsems);
			if (lserr != lserrNone) return lserr;
			}

		iwch = iwchFirst;
		if (itxtobj > itxtobjFirst)
			iwch = ptxtobj->iwchFirst;

		for (; iwch < iwchLimDobj && *pdurCompressTotal < durCompressMaxStop; iwch++)
			{
			if (itxtobj < itxtobjCompressFetchedLim - 1 || 
					itxtobj == itxtobjCompressFetchedLim - 1 && iwch < iwchCompressFetchedLim)
				{
				if (rgtxtinf[iwch].prior != prior0)
					*pdurCompressTotal -= pilsobj->pduAdjust[iwch];
				}
			else
				{

				fGlyphBased = (ptxtobj->txtf & txtfGlyphBased);
				rgtxtinf[iwch].prior = prior0;
	
				if (!fGlyphBased && plschp->fCompressTable && !rgtxtinf[iwch].fModWidthOnRun && 
																		!rgtxtinf[iwch].fModWidthSpace)
					{
					lspract = pilsobj->plspract[pilsobj->pilspract[rgtxtinf[iwch].mwcls]];
					Assert(lspract.prior <= pilsobj->cCompPrior);
					if (lspract.prior != prior0)
						{
						GetChanges(lspract.lsact, &lsems, pilsobj->pdur[iwch] - pilsobj->pdurRight[iwch] - pilsobj->pdurLeft[iwch],
																			fFalse, &side, &durTemp);
						TranslateChanges(side, durTemp, pilsobj->pdur[iwch], pilsobj->pdurRight[iwch], pilsobj->pdurLeft[iwch],
															 &sideFinal, &durChange);
						if (sideFinal != sideNone && durChange < 0)
							{
							if (itxtobj > itxtobjFirst || itxtobj == itxtobjFirst && iwch > iwchFirst ||
									 !fFirstOnLine || sideFinal != sideLeft)
								{
								SetComp(pilsobj, iwch, lspract.prior, sideFinal, durChange);
								*pdurCompressTotal -= durChange;
								}
							}
						}
					}

				if (rgwchOrig[iwch] == pilsobj->wchSpace && plschp->fCompressSpace &&
					rgtxtinf[iwch].prior == prior0 && (!fGlyphBased || FIwchOneToOne(pilsobj, iwch)))
					{
					plsrunNext = NULL;
					iwchNext = 0;
					/* we take ptxtobj->iwchLim instead of iwchLimDobj because iwchLimDobj char(last char
						before spaces on the line must be used for context considerations
					*/ 
					if (iwch < ptxtobj->iwchLim - 1)
						{
						plsrunNext = plsrunCur;
						iwchNext = iwch + 1;
						}
					else if (fNextAdjacentFound)
						{
						plsrunNext = plsgrchnk->plschnk[itxtobjNext].plsrun;
						iwchNext = ((PTXTOBJ)plsgrchnk->plschnk[itxtobjNext].pdobj)->iwchFirst;
						}
			
					GetPrevCharRun(plsgrchnk, itxtobj, iwch, &iwchPrev, &plsrunPrev);

					lserr = CheckCompSpace(pilsobj, &lsems, iwchPrev, iwch, iwchNext, ptxtobj,
													plsrunPrev, plsrunCur, plsrunNext, &durChange);
					if (lserr != lserrNone) return lserr;
	
					*pdurCompressTotal -= durChange;

					}

				if (iwch == ptxtobj->iwchLim - 1 && plschp->fCompressOnRun && fNextAdjacentFound && 
									rgtxtinf[iwch].prior == prior0)
					{
					plsrunNext = plsgrchnk->plschnk[itxtobjNext].plsrun;
					iwchNext = ((PTXTOBJ)plsgrchnk->plschnk[itxtobjNext].pdobj)->iwchFirst;
					lserr = CheckCompOnRun(pilsobj, &lsems, iwch, iwchNext, ptxtobj, plsrunCur, plsrunNext, &durChange);
					if (lserr != lserrNone) return lserr;
					*pdurCompressTotal -= durChange;
					}
				}

			}

		itxtobj = itxtobjNext;

		}

	pilsobj->iwchCompressFetchedFirst = iwchFirst;
	pilsobj->itxtobjCompressFetchedLim = itxtobjLastProcessed + 1;
	pilsobj->iwchCompressFetchedLim = min(iwch, iwchLim);

	return lserrNone;
}

/* G E T  C O M P  L A S T  C H A R  I N F O */
/*----------------------------------------------------------------------------
    %%Function: GetCompLastCharInfo
    %%Contact: sergeyge

---------------------------------------------------------------------------*/
void GetCompLastCharInfo(PILSOBJ pilsobj, long iwchLast, MWCLS* pmwcls,
														long* pdurCompRight, long* pdurCompLeft)
{
	/* Strong assumption for this function is that it is not called on GlyphBased run */
	TXTINF txtinf;
	
	*pdurCompRight = 0;
	*pdurCompLeft = 0;

	/* ptxtinf == NULL means that there were no runs which possibly can introduce compress opportunity */
	if (pilsobj->ptxtinf == NULL)
		return;

	txtinf = pilsobj->ptxtinf[iwchLast];

	*pmwcls = (MWCLS)txtinf.mwcls;

	if (txtinf.prior != prior0)
		{
		InterpretChanges(pilsobj, iwchLast, (BYTE)txtinf.side, pilsobj->pduAdjust[iwchLast], pdurCompLeft, pdurCompRight);
		Assert(pilsobj->pduAdjust[iwchLast] == *pdurCompLeft + *pdurCompRight);
		}

	*pdurCompLeft = - *pdurCompLeft;
	*pdurCompRight = - *pdurCompRight;
}

/* C O M P R E S S  L A S T  C H A R  R I G H T */
/*----------------------------------------------------------------------------
    %%Function: CompressLastCharRight
    %%Contact: sergeyge

---------------------------------------------------------------------------*/
void CompressLastCharRight(PILSOBJ pilsobj, long iwchLast, long durToAdjustRight)
{
	/* Strong assumption for this function is that it is not called on GlyphBased run */
	pilsobj->pdur[iwchLast] -= durToAdjustRight;

	Assert(pilsobj->pdurRight != NULL);
	Assert(pilsobj->pdurLeft != NULL);
	Assert(pilsobj->ptxtinf != NULL);

	pilsobj->pdurRight[iwchLast] -= durToAdjustRight;

	if (durToAdjustRight > 0 && pilsobj->ptxtinf[iwchLast].prior != prior0)
		{
		if (pilsobj->ptxtinf[iwchLast].side == sideRight)
			{
			pilsobj->ptxtinf[iwchLast].prior = prior0;
			pilsobj->pduAdjust[iwchLast] = 0;
			}
		else if (pilsobj->ptxtinf[iwchLast].side == sideLeftRight)
			{
			pilsobj->ptxtinf[iwchLast].side = sideLeft;
			pilsobj->pduAdjust[iwchLast] += durToAdjustRight;
			}
		else
			{
			Assert(fFalse);
			}
		}
}


/* A P P L Y  C O M P R E S S */
/*----------------------------------------------------------------------------
    %%Function: ApplyCompress
    %%Contact: sergeyge

	Applies prioratized compression
---------------------------------------------------------------------------*/
LSERR ApplyCompress(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, 
				long itxtobjFirst, long iwchFirst, long itxtobjLast, long iwchLim, long durToCompress)
{
	PILSOBJ pilsobj;
	COMPINFO rgcompinfo[5];
	COMPINFO* pcompinfo;
	BOOL fReleasePcompinfo;
	long i;
	
	Unreferenced(lstflow);	
	
	pilsobj = ((PTXTOBJ)plsgrchnk->plschnk[0].pdobj)->plnobj->pilsobj;

	fReleasePcompinfo = fFalse;
	pcompinfo = rgcompinfo;
	if (pilsobj->cCompPrior > 5)
		{
		pcompinfo = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(COMPINFO) * pilsobj->cCompPrior);
		if (pcompinfo == NULL)
			 return lserrOutOfMemory;
		else
			fReleasePcompinfo = fTrue;
		}

	GetCompressInfo(plsgrchnk, itxtobjFirst, iwchFirst, itxtobjLast, iwchLim, pcompinfo);

	for (i = 0; i < (long)pilsobj->cCompPrior && durToCompress > 0; i++)
		{
		if (pcompinfo[i].cCompOppr > 0)
			{
			ApplyPriorCompression(plsgrchnk, itxtobjFirst, iwchFirst, itxtobjLast, iwchLim, (BYTE)(i+1), durToCompress,
											pcompinfo[i].durComp, pcompinfo[i].cCompOppr);
			durToCompress -= pcompinfo[i].durComp;
			}
		}

	/* Following Assert is not compatible with the squeezing mode */
	/*Assert(durToCompress <= 0);*/

	if (fReleasePcompinfo)
		(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pcompinfo);

	return lserrNone;
}

/* A P P L Y  E X P A N D */
/*----------------------------------------------------------------------------
    %%Function: ApplyExpand
    %%Contact: sergeyge

	Applies prioratized expansion
---------------------------------------------------------------------------*/

LSERR ApplyExpand(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, BOOL fScaled,	long itxtobjFirst, long iwchFirst,
					 long itxtobjLast, long iwchLim, DWORD cNonTextObjects, long durToExpand,
					 long* pdurExtNonText, BOOL* pfFinalAdjustNeeded)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	EXPINFO expinfo;
	long i;

	pilsobj = ((PTXTOBJ)plsgrchnk->plschnk[0].pdobj)->plnobj->pilsobj;

	*pdurExtNonText = 0;

	lserr = GetExpandInfo(plsgrchnk, lstflow, fScaled, itxtobjFirst, iwchFirst, itxtobjLast, iwchLim, &expinfo);
	if (lserr != lserrNone) return lserr;

	for (i = 0; i < 2 && durToExpand > 0; i++)
		{
		if (expinfo.rgcExpPrior[i])
			{
			ApplyPriorExpansion(plsgrchnk, itxtobjFirst, iwchFirst, itxtobjLast, iwchLim, (BYTE)(i+1), durToExpand,
											expinfo.rgdurPrior[i], expinfo.rgcExpPrior[i]);
			durToExpand -= expinfo.rgdurPrior[i];
			}
		}

	if (durToExpand > 0)
		{
		ApplyFullExpansion(plsgrchnk, itxtobjFirst, iwchFirst, itxtobjLast, iwchLim, durToExpand,
									expinfo.cExpOppr, cNonTextObjects, pdurExtNonText);

		}

	*pfFinalAdjustNeeded = (expinfo.cExpOppr + cNonTextObjects > 0);

	return lserrNone;
}

/* A P P L Y  D I S T R I B U T I O N */
/*----------------------------------------------------------------------------
    %%Function: ApplyDistribution
    %%Contact: sergeyge

	Applies equal distribution to text chunk
---------------------------------------------------------------------------*/
void ApplyDistribution(const LSGRCHNK* plsgrchnk, DWORD cNonText,
									   long durToDistribute, long* pdurNonTextObjects)
{
	PILSOBJ pilsobj;
	long clschnk;
	PTXTOBJ ptxtobj;
	long itxtobj;
	long iwchFirst;
	long iwchLim;
	long iwch;
	long igind;
	long durToAdd;
	long cwchToDistribute;
	long cwchToDistributeAll;
	long wdurBound;
	long iwchUsed;

	clschnk = (long)plsgrchnk->clsgrchnk;
	Assert(clschnk > 0);

	pilsobj = ((PTXTOBJ)plsgrchnk->plschnk[0].pdobj)->plnobj->pilsobj;

	cwchToDistribute = 0;


	for (itxtobj = 0; itxtobj < clschnk; itxtobj++)
		{
		ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;
		iwchFirst = ptxtobj->iwchFirst;
		iwchLim = iwchFirst + plsgrchnk->plschnk[itxtobj].dcp;
		if (itxtobj == clschnk - 1)
			iwchLim--;
		if (ptxtobj->txtf & txtfGlyphBased)
			{
			for (iwch = iwchFirst; iwch < iwchLim; iwch++)
				{
				if (FIwchLastInContext(pilsobj, iwch))
					cwchToDistribute++;
				}
			}
		else
			cwchToDistribute += (iwchLim - iwchFirst);
		}		

	cwchToDistributeAll = cwchToDistribute + cNonText;

	*pdurNonTextObjects = 0;
	
	if (cwchToDistributeAll == 0)
		return;

	*pdurNonTextObjects = durToDistribute * cNonText / cwchToDistributeAll;

	durToDistribute -= *pdurNonTextObjects;

	if (cwchToDistribute == 0)
		return;

	durToAdd = durToDistribute / cwchToDistribute;
	wdurBound = durToDistribute - durToAdd * cwchToDistribute;

	iwchUsed = 0;

	for (itxtobj = 0; itxtobj < clschnk; itxtobj++)
		{
		ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;
		iwchFirst = ptxtobj->iwchFirst;
		iwchLim = iwchFirst + plsgrchnk->plschnk[itxtobj].dcp;
		if (itxtobj == clschnk - 1)
			iwchLim--;

		if (ptxtobj->txtf & txtfGlyphBased)
			{
			for (iwch = iwchFirst; iwch < iwchLim; iwch++)
				{
				if (FIwchLastInContext(pilsobj, iwch))
					{
					igind = IgindLastFromIwch(ptxtobj, iwch);
					igind = IgindBaseFromIgind(pilsobj, igind);
					if (iwchUsed < wdurBound)
						{
						ApplyGlyphChanges(pilsobj, igind, durToAdd + 1);
						}
					else
						{
						ApplyGlyphChanges(pilsobj, igind, durToAdd);
						}
					iwchUsed++;
					}
				}
			}
		else
			{
			for (iwch = iwchFirst; iwch < iwchLim; iwch++)
				{
				if (iwchUsed < wdurBound)
					{
					ApplyChanges(pilsobj, iwch, sideRight, durToAdd + 1);
					}
				else
					{
					ApplyChanges(pilsobj, iwch, sideRight, durToAdd);
					}
				iwchUsed++;
				}
			}
		}
}

/* Internal functions implementation */

/* G E T  E X P A N D  I N F O */
/*----------------------------------------------------------------------------
    %%Function: GetExpandInfo
    %%Contact: sergeyge

	Collects expansion information
---------------------------------------------------------------------------*/
static LSERR GetExpandInfo(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, BOOL fScaled,
					 long itxtobjFirst, long iwchFirst, long itxtobjLast, long iwchLim,	EXPINFO* pexpinfo)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	TXTINF* rgtxtinf;
	WCHAR* rgwchOrig;
	PTXTOBJ ptxtobj;
	PLSRUN plsrunCur;
	PLSRUN plsrunPrev;
	PLSRUN plsrunNext;
	PCLSCHP plschp;
	long durChange;
	LSEMS lsems;
	BOOL fNextAdjacentFound;
	long itxtobj;
	long itxtobjNext;
	long iwchLimDobj;
	LSEXPAN lsexpan;
	long iwch;
	long iwchPrev;
	long iwchNext;
	BOOL fExpandOpp;
	BOOL fGlyphBased;

	memset(pexpinfo, 0, sizeof(EXPINFO));

	pilsobj = ((PTXTOBJ)plsgrchnk->plschnk[0].pdobj)->plnobj->pilsobj;

	rgtxtinf = pilsobj->ptxtinf;
	/* rgtxtinf == NULL means that there were no runs which possibly can introduce expansion opportunity */
	if (rgtxtinf == NULL)
		return lserrNone;

	rgwchOrig = pilsobj->pwchOrig;

	itxtobj = itxtobjFirst;

	if (itxtobj < (long)plsgrchnk->clsgrchnk)
		GetNextRun(plsgrchnk, itxtobj, &itxtobj);

	Assert(itxtobj == (long)plsgrchnk->clsgrchnk ||
			((PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj)->iwchLim >
			((PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj)->iwchFirst);

	while(itxtobj <= itxtobjLast)
		{
		fNextAdjacentFound = GetNextRun(plsgrchnk, itxtobj + 1, &itxtobjNext);

		ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;
		fGlyphBased = (ptxtobj->txtf & txtfGlyphBased);
		plsrunCur = plsgrchnk->plschnk[itxtobj].plsrun;
		plschp = plsgrchnk->plschnk[itxtobj].plschp;

		lserr = (*pilsobj->plscbk->pfnGetEms)(pilsobj->pols, plsrunCur, lstflow, &lsems);
		if (lserr != lserrNone) return lserr;


		iwchLimDobj = iwchLim;
		if (itxtobj < itxtobjLast)
			iwchLimDobj = ptxtobj->iwchLim;

		iwch = iwchFirst;
		if (itxtobj > itxtobjFirst)
			iwch = ptxtobj->iwchFirst;

		for (; iwch < iwchLimDobj; iwch++)
			{

			rgtxtinf[iwch].prior = prior0;

			if (rgwchOrig[iwch] == pilsobj->wchSpace && plschp->fExpandSpace && 
												(!fGlyphBased || FIwchOneToOne(pilsobj, iwch)))
				{
				plsrunNext = NULL;
				iwchNext = 0;
				/* we take ptxtobj->iwchLim instead of iwchLimDobj because iwchLimInDobj char(last char
					before spaces on the line must be used for context considerations
				*/ 
				if (iwch < ptxtobj->iwchLim - 1)
					{
					plsrunNext = plsrunCur;
					iwchNext = iwch + 1;
					}
				else if (fNextAdjacentFound)
					{
					plsrunNext = plsgrchnk->plschnk[itxtobjNext].plsrun;
					iwchNext = ((PTXTOBJ)plsgrchnk->plschnk[itxtobjNext].pdobj)->iwchFirst;
					}
			
				GetPrevCharRun(plsgrchnk, itxtobj, iwch, &iwchPrev, &plsrunPrev);

				lserr = CheckExpandSpace(pilsobj, &lsems, iwchPrev, iwch, iwchNext, ptxtobj,
												plsrunPrev, plsrunCur, plsrunNext, &fExpandOpp, &durChange);
				if (lserr != lserrNone) return lserr;

				if (fExpandOpp)
					{
					pexpinfo->cExpOppr++;
					rgtxtinf[iwch].fExpand = fTrue;
					if (durChange > 0)
						{
						pexpinfo->rgdurPrior[0] += durChange;
						pexpinfo->rgcExpPrior[0]++;
						rgtxtinf[iwch].prior = 1;
						pilsobj->pduAdjust[iwch] = durChange;
						}
					}
	

				}

			if (!rgtxtinf[iwch].fExpand && iwch == ptxtobj->iwchLim - 1 && plschp->fExpandOnRun && 
							fNextAdjacentFound)
				{
				plsrunNext = plsgrchnk->plschnk[itxtobjNext].plsrun;
				iwchNext = ((PTXTOBJ)plsgrchnk->plschnk[itxtobjNext].pdobj)->iwchFirst;
				lserr = CheckExpandOnRun(pilsobj, &lsems, iwch, iwchNext, ptxtobj, plsrunCur, plsrunNext,
														&fExpandOpp, &durChange);
				if (lserr != lserrNone) return lserr;

				if (fExpandOpp)
					{
					pexpinfo->cExpOppr++;
					rgtxtinf[iwch].fExpand = fTrue;
					if (durChange > 0)
						{
						pexpinfo->rgdurPrior[1] += durChange;
						pexpinfo->rgcExpPrior[1]++;
						rgtxtinf[iwch].prior = 2;
						pilsobj->pduAdjust[iwch] = durChange;
						}
					}
				}
			else if (!rgtxtinf[iwch].fExpand && iwch == ptxtobj->iwchLim - 1 && !fNextAdjacentFound &&
							(plsgrchnk->pcont[itxtobj] & fcontExpandAfter))
				{
				/* Character before foreign object */
				pexpinfo->cExpOppr++;
				rgtxtinf[iwch].fExpand = fTrue;
				}

			if (!rgtxtinf[iwch].fExpand && plschp->fExpandTable)
				{
				Assert(!fGlyphBased);
				if (iwch < ptxtobj->iwchLim - 1)
					{
					lsexpan = pilsobj->plsexpan[pilsobj->pilsexpan[
							pilsobj->cModWidthClasses * rgtxtinf[iwch].mwcls + rgtxtinf[iwch+1].mwcls
																  ]
												];
					if (fScaled && lsexpan.fFullScaled || !fScaled && lsexpan.fFullInterletter)
						{
						pexpinfo->cExpOppr++;
						rgtxtinf[iwch].fExpand = fTrue;
						}
					}

				else if (fNextAdjacentFound && plsgrchnk->plschnk[itxtobjNext].plschp->fExpandTable)
					{
					Assert(!(((PTXTOBJ)plsgrchnk->plschnk[itxtobjNext].pdobj)->txtf & txtfGlyphBased));
					iwchNext = ((PTXTOBJ)plsgrchnk->plschnk[itxtobjNext].pdobj)->iwchFirst;

					lsexpan = pilsobj->plsexpan[pilsobj->pilsexpan[
							pilsobj->cModWidthClasses * rgtxtinf[iwch].mwcls + rgtxtinf[iwchNext].mwcls
																  ]
												];
					if (fScaled && lsexpan.fFullScaled || !fScaled && lsexpan.fFullInterletter)
						{
						pexpinfo->cExpOppr++;
						rgtxtinf[iwch].fExpand = fTrue;
						}
					}
				}



			}

		itxtobj = itxtobjNext;

		}

	return lserrNone;
}

/* C H E C K  E X P A N D  S P A C E */
/*----------------------------------------------------------------------------
    %%Function: CheckExpandSpace
    %%Contact: sergeyge

	Reports if there is expansion opportunity on space and amount of expansion
---------------------------------------------------------------------------*/
static LSERR CheckExpandSpace(PILSOBJ pilsobj, LSEMS* plsems, long iwchPrev, long iwch, long iwchNext,
	PTXTOBJ ptxtobjCur, PLSRUN plsrunPrev, PLSRUN plsrunCur, PLSRUN plsrunNext,
	BOOL* pfExpandOpp, long* pdurChange)
{
	LSERR lserr;
	BYTE side;
	LSACT lsact;
	long igind;
	
	*pfExpandOpp = fFalse;
	*pdurChange = 0;

	lserr = (*pilsobj->plscbk->pfnExpWidthSpace)(pilsobj->pols, plsrunCur,
			 plsrunPrev, pilsobj->pwchOrig[iwchPrev], plsrunNext, pilsobj->pwchOrig[iwchNext], &lsact);
	if (lserr != lserrNone) return lserr;

	if (lsact.side != sideNone)
		{
		*pfExpandOpp = fTrue;
		if (ptxtobjCur->txtf & txtfGlyphBased)
			{
			igind = IgindLastFromIwch(ptxtobjCur, iwch);
			GetChanges(lsact, plsems, pilsobj->pdurGind[igind], fTrue, &side, pdurChange);
			}
		else
			{
			GetChanges(lsact, plsems, pilsobj->pdur[iwch], fTrue, &side, pdurChange);
			}

		Assert(side == sideRight);

		if (*pdurChange < 0)
			*pdurChange = 0;
		}

	return lserrNone;
}

/* C H E C K  E X P A N D  O N  R U N */
/*----------------------------------------------------------------------------
    %%Function: CheckExpandOnRun
    %%Contact: sergeyge

	Reports if there is expansion opportunity between runs and amount of expansion
---------------------------------------------------------------------------*/
static LSERR CheckExpandOnRun(PILSOBJ pilsobj, LSEMS* plsems, long iwch, long iwchNext, PTXTOBJ ptxtobjCur,
							PLSRUN plsrunCur, PLSRUN plsrunNext, BOOL* pfExpandOpp, long* pdurChange)
{
	LSERR lserr;
	BYTE side;
	LSACT lsact;
	long igind;

	*pfExpandOpp = fFalse;
	*pdurChange = 0;

	lserr = (*pilsobj->plscbk->pfnExpOnRun)(pilsobj->pols, plsrunCur, pilsobj->pwchOrig[iwch], 
						plsrunNext, pilsobj->pwchOrig[iwchNext], &lsact);
	if (lserr != lserrNone) return lserr;

	if (lsact.side != sideNone)
		{
		*pfExpandOpp = fTrue;
		if (ptxtobjCur->txtf & txtfGlyphBased)
			{
			igind = IgindLastFromIwch(ptxtobjCur, iwch);
			igind = IgindBaseFromIgind(pilsobj, igind);
			GetChanges(lsact, plsems, pilsobj->pdurGind[igind], fTrue, &side, pdurChange);
			}
		else
			{
			GetChanges(lsact, plsems, pilsobj->pdur[iwch], fTrue, &side, pdurChange);
			}
		Assert(side == sideRight);
		if (*pdurChange < 0)
			*pdurChange = 0;
		}


	return lserrNone;
}

/* C H E C K  C O M P  S P A C E */
/*----------------------------------------------------------------------------
    %%Function: CheckCompSpace
    %%Contact: sergeyge

	Reports if there is compression opportunity on space and amount of compression
---------------------------------------------------------------------------*/
static LSERR CheckCompSpace(PILSOBJ pilsobj, LSEMS* plsems, long iwchPrev, long iwch, long iwchNext,
			PTXTOBJ ptxtobjCur, PLSRUN plsrunPrev, PLSRUN plsrunCur, PLSRUN plsrunNext, long* pdurChange)
{
	LSERR lserr;
	BYTE side;
	LSPRACT lspract;
	long igind;
	
	*pdurChange = 0;

	lserr = (*pilsobj->plscbk->pfnCompWidthSpace)(pilsobj->pols, plsrunCur,
			 plsrunPrev, pilsobj->pwchOrig[iwchPrev], plsrunNext, pilsobj->pwchOrig[iwchNext], &lspract);
	if (lserr != lserrNone) return lserr;

	if (lspract.prior != prior0)
		{
		if (ptxtobjCur->txtf & txtfGlyphBased)
			{
			igind = IgindLastFromIwch(ptxtobjCur, iwch);
			GetChanges(lspract.lsact, plsems, pilsobj->pdurGind[igind], fFalse, &side, pdurChange);
			}
		else
			{
			GetChanges(lspract.lsact, plsems, pilsobj->pdur[iwch], fFalse, &side, pdurChange);
			}

		Assert(side == sideRight);
		if (*pdurChange < 0)
			SetComp(pilsobj, iwch, lspract.prior, side, *pdurChange);
		else
			*pdurChange = 0;
		}

	return lserrNone;
}

/* C H E C K  C O M P  O N  R U N */
/*----------------------------------------------------------------------------
    %%Function: CheckCompOnRun
    %%Contact: sergeyge

	Reports if there is compression opportunity between runs and amount of compression
---------------------------------------------------------------------------*/
static LSERR CheckCompOnRun(PILSOBJ pilsobj, LSEMS* plsems, long iwch, long iwchNext,
							PTXTOBJ ptxtobjCur, PLSRUN plsrunCur, PLSRUN plsrunNext, long* pdurChange)
{
	LSERR lserr;
	BYTE side;
	LSPRACT lspract;
	long igind;

	*pdurChange = 0;

	lserr = (*pilsobj->plscbk->pfnCompOnRun)(pilsobj->pols, plsrunCur, pilsobj->pwchOrig[iwch], 
						plsrunNext, pilsobj->pwchOrig[iwchNext], &lspract);
	if (lserr != lserrNone) return lserr;

	if (lspract.prior != prior0)

		{
		if (ptxtobjCur->txtf & txtfGlyphBased)
			{
			igind = IgindLastFromIwch(ptxtobjCur, iwch);
			igind = IgindBaseFromIgind(pilsobj, igind);
			GetChanges(lspract.lsact, plsems, pilsobj->pdurGind[igind], fFalse, &side, pdurChange);
			}
		else
			{
			GetChanges(lspract.lsact, plsems, pilsobj->pdur[iwch], fFalse, &side, pdurChange);
			}
		Assert(side == sideRight);
		if (*pdurChange < 0)
			SetComp(pilsobj, iwch, lspract.prior, side, *pdurChange);
		else
			*pdurChange = 0;	
		}

	return lserrNone;
}

/* S E T  C O M P */
/*----------------------------------------------------------------------------
    %%Function: SetComp
    %%Contact: sergeyge

---------------------------------------------------------------------------*/
static void SetComp(PILSOBJ pilsobj, long iwch, BYTE prior, BYTE side, long durChange)
{
	pilsobj->ptxtinf[iwch].prior = prior;
	pilsobj->ptxtinf[iwch].side = side;
	pilsobj->pduAdjust[iwch] = durChange;
}

/* G E T  N E X T  R U N */
/*----------------------------------------------------------------------------
    %%Function: GetNextRun
    %%Contact: sergeyge

---------------------------------------------------------------------------*/
static BOOL GetNextRun(const LSGRCHNK* plsgrchnk, long itxtobj, long* pitxtobjNext)
{
	long clschnk;
	PTXTOBJ ptxtobj;
	BOOL fFound;
	BOOL fContiguous;

	clschnk = (long)plsgrchnk->clsgrchnk;

	*pitxtobjNext = clschnk;

	fFound = fFalse;
	fContiguous = fTrue;

	while (!fFound && itxtobj < clschnk)
		{
		ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;
		fFound = !(ptxtobj->txtf & txtfSkipAtNti);
		fContiguous = fContiguous && !(plsgrchnk->pcont[itxtobj] & fcontNonTextBefore);
		itxtobj++;
		}

	if (fFound)
		*pitxtobjNext = itxtobj - 1;

	return fFound && fContiguous;
}

/* G E T  P R E V  C H A R  R U N */
/*----------------------------------------------------------------------------
    %%Function: GetPrevCharRun
    %%Contact: sergeyge

---------------------------------------------------------------------------*/
static void GetPrevCharRun(const LSGRCHNK* plsgrchnk, long itxtobj, long iwch, long* piwchPrev, 
																					PLSRUN* pplsrunPrev)
{
	BOOL fFound;
	PTXTOBJ ptxtobj;

	fFound = fFalse;

	Assert(itxtobj < (long)plsgrchnk->clsgrchnk);

	ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;

	Assert(iwch >= ptxtobj->iwchFirst && iwch < ptxtobj->iwchLim);

	*piwchPrev = 0;
	*pplsrunPrev = NULL;
	if (iwch > ptxtobj->iwchFirst)
		{
		fFound = fTrue;
		*piwchPrev = iwch - 1;
		*pplsrunPrev = plsgrchnk->plschnk[itxtobj].plsrun;
		}
	else
		{
		while (!fFound && itxtobj > 0 && !(plsgrchnk->pcont[itxtobj] & fcontNonTextBefore))
			{
			itxtobj--;
			Assert(itxtobj >= 0);
			ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;
			fFound = !(ptxtobj->txtf & txtfSkipAtNti);
			if (fFound)
				{
				*piwchPrev = ((PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj)->iwchLim - 1;
				*pplsrunPrev = plsgrchnk->plschnk[itxtobj].plsrun;
				}

			}		
		}
}

/* A P P L Y  P R I O R  E X P A N S I O N */
/*----------------------------------------------------------------------------
    %%Function: ApplyPriorExpansion
    %%Contact: sergeyge

	Applies expansion on one priority level
---------------------------------------------------------------------------*/
static void ApplyPriorExpansion(const LSGRCHNK* plsgrchnk, long itxtobjFirst, long iwchFirst,
			 long itxtobjLast, long iwchLim, BYTE prior, long durToExpand, long durAvailable, long cExpOppr)
{
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	TXTINF* rgtxtinf;
	long* rgdurAdjust;
	long durSubstr;
	long durChange;
	long cBound;
	long cOpprCur;
	long itxtobj;
	long iwch;
	long iwchFirstInDobj;
	long iwchLimInDobj;
	long igind;
	BOOL fGlyphBased;

	pilsobj = ((PTXTOBJ)plsgrchnk->plschnk[0].pdobj)->plnobj->pilsobj;
	rgtxtinf = pilsobj->ptxtinf;
	rgdurAdjust = pilsobj->pduAdjust;

	Assert(durToExpand > 0);
	if (durAvailable == 0)
		return;

	if (durAvailable < durToExpand)
		durToExpand = durAvailable;

	Assert(cExpOppr > 0);

	durSubstr = (durAvailable - durToExpand) / cExpOppr;
	cBound = (durAvailable - durToExpand) - durSubstr * cExpOppr;

	cOpprCur = 0;

	for (itxtobj = itxtobjFirst; itxtobj <= itxtobjLast; itxtobj++)
		{
		ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;

		fGlyphBased = (ptxtobj->txtf & txtfGlyphBased);


		iwchFirstInDobj = iwchFirst;
		if (itxtobj > itxtobjFirst)
			iwchFirstInDobj = ptxtobj->iwchFirst;

		iwchLimInDobj = iwchLim;
		if (itxtobj < itxtobjLast)
			iwchLimInDobj = ptxtobj->iwchLim;

		for (iwch = iwchFirstInDobj; iwch < iwchLimInDobj; iwch++)
			{
			if (rgtxtinf[iwch].prior == prior)
				{
				cOpprCur++;
				durChange = rgdurAdjust[iwch] - durSubstr;
				if (cOpprCur <= cBound)
					durChange--;
				if (durChange >= 0)
					{
					if (fGlyphBased)
						{
						igind = IgindLastFromIwch(ptxtobj, iwch);
						igind = IgindBaseFromIgind(pilsobj, igind);
						ApplyGlyphChanges(pilsobj, igind, durChange);
						}
					else
						ApplyChanges(pilsobj, iwch, sideRight, durChange);
					}

				}
			}
		}

}

/* A P P L Y  F U L L  E X P A N S I O N */
/*----------------------------------------------------------------------------
    %%Function: ApplyFullExpansion
    %%Contact: sergeyge

	Applies risidual unlimited expansion
---------------------------------------------------------------------------*/
static void ApplyFullExpansion(const LSGRCHNK* plsgrchnk, long itxtobjFirst, long iwchFirst,
		long itxtobjLast, long iwchLim, long durToExpand, long cExpOppr, long cNonText, long* pdurNonText)
{
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	TXTINF* rgtxtinf;
	long* rgdurAdjust;
	long cBound;
	long cOpprCur;
	long cExpOpprTotal;
	long durChange;
	long durAdd;
	long itxtobj;
	long iwch;
	long iwchFirstInDobj;
	long iwchLimInDobj;
	long igind;
	BOOL fGlyphBased;

	pilsobj = ((PTXTOBJ)plsgrchnk->plschnk[0].pdobj)->plnobj->pilsobj;
	rgtxtinf = pilsobj->ptxtinf;
	rgdurAdjust = pilsobj->pduAdjust;

	*pdurNonText = 0;

	cExpOpprTotal = cExpOppr + cNonText;

	if (cExpOpprTotal > 0)
		{

		*pdurNonText = durToExpand * cNonText / cExpOpprTotal;

		durToExpand -= *pdurNonText;

		if (cExpOppr > 0)
			{

			durAdd = durToExpand / cExpOppr;

			cBound = durToExpand - durAdd * cExpOppr;

			cOpprCur = 0;

			for (itxtobj = itxtobjFirst; itxtobj <= itxtobjLast; itxtobj++)
				{
				ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;

				fGlyphBased = (ptxtobj->txtf & txtfGlyphBased);

				iwchFirstInDobj = iwchFirst;
				if (itxtobj > itxtobjFirst)
					iwchFirstInDobj = ptxtobj->iwchFirst;

				iwchLimInDobj = iwchLim;
				if (itxtobj < itxtobjLast)
					iwchLimInDobj = ptxtobj->iwchLim;

				for (iwch = iwchFirstInDobj; iwch < iwchLimInDobj; iwch++)
					{
					if (rgtxtinf[iwch].fExpand)
						{
						cOpprCur++;
						durChange = durAdd;
						if (cOpprCur <= cBound)
							durChange++;

						if (fGlyphBased)
							{
							igind = IgindLastFromIwch(ptxtobj, iwch);
							igind = IgindBaseFromIgind(pilsobj, igind);
							ApplyGlyphChanges(pilsobj, igind, durChange);
							}
						else
							ApplyChanges(pilsobj, iwch, sideRight, durChange);
						}
					}
				}
			}
		}
}

/* G E T  C O M P R E S S  I N F O */
/*----------------------------------------------------------------------------
    %%Function: GetCompressInfo
    %%Contact: sergeyge

	Agregates compression information accross for priorities
---------------------------------------------------------------------------*/
static void GetCompressInfo(const LSGRCHNK* plsgrchnk, long itxtobjFirst, long iwchFirst, 
											long itxtobjLast, long iwchLim, COMPINFO* pcompinfo)
{
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	TXTINF* rgtxtinf;
	long* rgdurAdjust;
	UINT prior;
	long cCompPrior;
	long itxtobj;
	long iwch;
	long iwchFirstInDobj;
	long iwchLimInDobj;

	pilsobj = ((PTXTOBJ)plsgrchnk->plschnk[0].pdobj)->plnobj->pilsobj;
	cCompPrior = pilsobj->cCompPrior;
	memset(pcompinfo, 0, sizeof(COMPINFO) * cCompPrior);

	rgtxtinf = pilsobj->ptxtinf;
	rgdurAdjust = pilsobj->pduAdjust;
	/* rgtxtinf == NULL means that there were no runs which possibly can introduce compress opportunity */
	if (rgtxtinf == NULL)
		return;

	for (itxtobj = itxtobjFirst; itxtobj <= itxtobjLast ; itxtobj++)
		{
		ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;

		iwchFirstInDobj = iwchFirst;
		if (itxtobj > itxtobjFirst)
			iwchFirstInDobj = ptxtobj->iwchFirst;

		iwchLimInDobj = iwchLim;
		if (itxtobj < itxtobjLast)
			iwchLimInDobj = ptxtobj->iwchLim;

		for (iwch = iwchFirstInDobj; iwch < iwchLimInDobj; iwch++)
			{
			prior =	rgtxtinf[iwch].prior;
			Assert(prior <= (BYTE)cCompPrior);
			if (prior > 0)
				{
				pcompinfo[prior - 1].cCompOppr++;
				pcompinfo[prior - 1].durComp -= rgdurAdjust[iwch];
				}
			}
		}
}

/* A P P L Y  P R I O R  C O M P R E S S I O N */
/*----------------------------------------------------------------------------
    %%Function: ApplyPriorCompression
    %%Contact: sergeyge

	Applies compression for one priority level
---------------------------------------------------------------------------*/
static void ApplyPriorCompression(const LSGRCHNK* plsgrchnk,  long itxtobjFirst, long iwchFirst,
									long itxtobjLast, long iwchLim, BYTE prior,
									long durToCompress, long durAvailable, long cExpOppr)
{
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	TXTINF* rgtxtinf;
	long* rgdurAdjust;
	long durSubstr;
	long cBound;
	long cOpprCur;
	long durChange;
	long iwch;
	long itxtobj;
	long igind;
	BOOL fGlyphBased;
	long iwchFirstInDobj;
	long iwchLimInDobj;

	pilsobj = ((PTXTOBJ)plsgrchnk->plschnk[0].pdobj)->plnobj->pilsobj;
	rgtxtinf = pilsobj->ptxtinf;
	rgdurAdjust = pilsobj->pduAdjust;

	Assert(durToCompress > 0);
	if (durAvailable == 0)
		return;

	if (durAvailable < durToCompress)
		durToCompress = durAvailable;

	Assert(cExpOppr > 0);

	durSubstr = (durAvailable - durToCompress) / cExpOppr;
	cBound = (durAvailable - durToCompress) - durSubstr * cExpOppr;

	cOpprCur = 0;
	for (itxtobj = itxtobjFirst; itxtobj <= itxtobjLast; itxtobj++)
		{
		ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;

		fGlyphBased = (ptxtobj->txtf & txtfGlyphBased);

		iwchFirstInDobj = iwchFirst;
		if (itxtobj > itxtobjFirst)
			iwchFirstInDobj = ptxtobj->iwchFirst;

		iwchLimInDobj = iwchLim;
		if (itxtobj < itxtobjLast)
			iwchLimInDobj = ptxtobj->iwchLim;

		for (iwch = iwchFirstInDobj; iwch < iwchLimInDobj; iwch++)
			{
			if (rgtxtinf[iwch].prior == prior)
				{
				cOpprCur++;
				durChange = rgdurAdjust[iwch] + durSubstr;
				if (cExpOppr - cBound < cOpprCur)
					durChange++;
				if (durChange < 0)
					{
					if (fGlyphBased)
						{
						igind = IgindLastFromIwch(ptxtobj, iwch);
						igind = IgindBaseFromIgind(pilsobj, igind);
						ApplyGlyphChanges(pilsobj, igind,  durChange);
						}
					else
						ApplyChanges(pilsobj, iwch, (BYTE)rgtxtinf[iwch].side, durChange);
					}
				}
			}
		}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\lstxtjst.c ===
#include "lsmem.h"
#include <limits.h>

#include "lstxtjst.h"

#include "lstxtwrd.h"
#include "lstxtcmp.h"
#include "lstxtglf.h"
#include "lstxtscl.h"
#include "lstxtmap.h"
#include "lsdnset.h"
#include "lsdntext.h"
#include "locchnk.h"
#include "posichnk.h"
#include "objdim.h"
#include "lstxtffi.h"
#include "txtils.h"
#include "txtln.h"
#include "txtobj.h"

#define min(a,b)     ((a) > (b) ? (b) : (a))
#define max(a,b)     ((a) < (b) ? (b) : (a))

static void GetFirstPosAfterStartSpaces(const LSGRCHNK* plsgrchnk, long itxtobjLast, long iwchLim,
				long* pitxtobjAfterStartSpaces, long* piwchAfterStartSpaces, BOOL* pfFirstOnLineAfter);
static LSERR HandleSimpleTextWysi(LSKJUST lskjust, const LSGRCHNK* plsgrchnk, long durToDistribute,
			 long dupAvailable, LSTFLOW lstflow, long itxtobjAfterStartSpaces, long iwchAfterStartSpaces,
			 long itxtobjLast, long iwchLast, BOOL fExactSync,
			 BOOL fForcedBreak, BOOL fSuppressTrailingSpaces,
			 long* pdupText, long* pdupTail);
static LSERR HandleSimpleTextPres(LSKJUST lskjust, const LSGRCHNK* plsgrchnk,
					 long dupAvailable, long itxtobjAfterStartSpaces, long iwchAfterStartSpaces,
					 long itxtobjLast, long iwchLast, BOOL fForcedBreak, BOOL fSuppressTrailingSpaces,
					 long* pdupText, long* pdupTail);
static LSERR HandleGeneralSpacesExactSync(LSKJUST lskjust, const LSGRCHNK* plsgrchnk, long durToDistribute,
			 long dupAvailable, LSTFLOW lstflow, long itxtobjAfterStartSpaces, long iwchAfterStartSpaces,
			 long itxtobjLast, long iwchLast, BOOL fForcedBreak, BOOL fSuppressTrailingSpaces,
			 long* pdupText, long* pdupTail);
static LSERR HandleGeneralSpacesPres(LSKJUST lskjust, const LSGRCHNK* plsgrchnk, long dupAvailable,
					 LSTFLOW lstflow, long itxtobjAfterStartSpaces, long iwchAfterStartSpaces,
					 long itxtobjLast, long iwchLast, BOOL fForcedBreak, BOOL fSuppressTrailingSpaces,
					 long* pdupText, long* pdupTail);
static LSERR HandleTablesBased(LSKJUST lskjust, const LSGRCHNK* plsgrchnk,
			 long durToDistribute, long dupAvailable, LSTFLOW lstflow,
			 long itxtobjAfterStartSpaces, long iwchAfterStartSpaces, BOOL fFirstOnLineAfter,
			 long itxtobjLast, long iwchLast, long cNonText, BOOL fLastObjectIsText,
			 BOOL fForcedBreak, BOOL fSuppressTrailingSpaces,
			 long* pdupText, long* pdupTail, long* pdupExtNonText);
static LSERR HandleFullGlyphsExactSync(const LSGRCHNK* plsgrchnk,
			 long durToDistribute, long dupAvailable, LSTFLOW lstflow,
			 long itxtobjAfterStartSpaces, long iwchAfterStartSpaces,
			 long itxtobjLast, long iwchLast, BOOL fForcedBreak, BOOL fSuppressTrailingSpaces,
			 long* pdupText, long* pdupTail);
static LSERR HandleFullGlyphsPres(const LSGRCHNK* plsgrchnk, long dupAvailable,
			 LSTFLOW lstflow, long itxtobjAfterStartSpaces, long iwchAfterStartSpaces,
			 long itxtobjLast, long iwchLast, BOOL fForcedBreak, BOOL fSuppressTrailingSpaces,
			 long* pdupText, long* pdupTail);

/* A D J U S T  T E X T */
/*----------------------------------------------------------------------------
    %%Function: AdjustText
    %%Contact: sergeyge

	The top-level text handler function of
	the PrepLineForDisplay time---calculation of the presentation widths

	It calculates justification area (from first non-space to last non-space),
	checks for the type of justification and WYSIWYG algorythm 
	and redirects the program flow accordingly.
----------------------------------------------------------------------------*/
LSERR AdjustText(LSKJUST lskjust, long durColumnMax, long durTotal, long dupAvailable,
		const LSGRCHNK* plsgrchnk, PCPOSICHNK pposichnkBeforeTrailing, LSTFLOW lstflow,
		BOOL fCompress, DWORD cNonText,	BOOL fSuppressWiggle, BOOL fExactSync,
		BOOL fForcedBreak, BOOL fSuppressTrailingSpaces,
		long* pdupText, long* pdupTail,long* pdupExtNonTextObjects,	DWORD* pcExtNonTextObjects)
{
	PILSOBJ pilsobj;
	long itxtobjAfterStartSpaces;
	long itxtobjLast;
	PTXTOBJ ptxtobjLast;
	long iwchAfterStartSpaces;
	long iwchLast;
	long clsgrchnk;
	long durToDistribute;
	BOOL fFirstOnLineAfter;
	BOOL fLastObjectIsText;
	LSDCP dcp;

	*pdupText = 0;
	*pdupTail = 0;
	*pdupExtNonTextObjects = 0;
	*pcExtNonTextObjects = 0;

	clsgrchnk = (long)plsgrchnk->clsgrchnk;

	if (clsgrchnk == 0)
		{
		Assert(cNonText > 0);
		if (lskjust == lskjFullScaled || lskjust == lskjFullInterLetterAligned)
			{
			*pcExtNonTextObjects = cNonText - 1;
			*pdupExtNonTextObjects = dupAvailable;
			}
		return lserrNone;
		}


	pilsobj = ((PTXTOBJ)plsgrchnk->plschnk[0].pdobj)->plnobj->pilsobj;
	Assert (pilsobj->fDisplay);

	if (pilsobj->fPresEqualRef)
		{
		fExactSync = fFalse;
		fSuppressWiggle = fFalse;
		}


	itxtobjLast = pposichnkBeforeTrailing->ichnk;
	dcp = pposichnkBeforeTrailing->dcp;

	Assert(itxtobjLast >= 0);
	Assert(itxtobjLast < clsgrchnk || (itxtobjLast == clsgrchnk && dcp == 0));

	if (dcp == 0 && itxtobjLast > 0)
		{
		itxtobjLast--;
		dcp = plsgrchnk->plschnk[itxtobjLast].dcp;
		}

	ptxtobjLast = (PTXTOBJ)plsgrchnk->plschnk[itxtobjLast].pdobj;

	if (ptxtobjLast->iwchLim > ptxtobjLast->iwchFirst)
		iwchLast = ptxtobjLast->iwchFirst + dcp - 1;
	else
		iwchLast = ptxtobjLast->iwchLim - 1;

	/* In the case of AutoHyphenation, dcp reported by manager is not equal to the real number of characters---
		it should be fixed.	Notice that in the case of "delete before" hyphenation type,
		situation is totally wrong because deleted character was replaced by space and collected by manager  as trailing space.
	*/
	if (ptxtobjLast == ptxtobjLast->plnobj->pdobjHyphen)
		{
		iwchLast = ptxtobjLast->iwchLim - 1;
		}


	Assert(iwchLast >= ptxtobjLast->iwchFirst - 1);
	Assert(iwchLast <= ptxtobjLast->iwchLim - 1);
	
	GetFirstPosAfterStartSpaces(plsgrchnk, itxtobjLast, iwchLast + 1,
								&itxtobjAfterStartSpaces, &iwchAfterStartSpaces, &fFirstOnLineAfter);

	durToDistribute = durColumnMax - durTotal;

	if (!pilsobj->fNotSimpleText)
		{
		if (durToDistribute < 0)
			fSuppressWiggle = fFalse;

		if (fExactSync || fSuppressWiggle)
			{
			return HandleSimpleTextWysi(lskjust, plsgrchnk, durToDistribute, dupAvailable, lstflow, 
				itxtobjAfterStartSpaces, iwchAfterStartSpaces, itxtobjLast, iwchLast, fExactSync,
				fForcedBreak, fSuppressTrailingSpaces,
				pdupText, pdupTail);
			}
//		else if (fSupressWiggle) /* add later */
		else
			{
			return HandleSimpleTextPres(lskjust, plsgrchnk, dupAvailable, 
							itxtobjAfterStartSpaces, iwchAfterStartSpaces, itxtobjLast, iwchLast,
							fForcedBreak, fSuppressTrailingSpaces,
							pdupText, pdupTail);
			}
		}
	else
		{
		long itxtobjFirstInLastTextChunk;
		for(itxtobjFirstInLastTextChunk = clsgrchnk; itxtobjFirstInLastTextChunk > 0 &&
			!(plsgrchnk->pcont[itxtobjFirstInLastTextChunk - 1] & fcontNonTextAfter); itxtobjFirstInLastTextChunk--);

		fLastObjectIsText = fTrue;
		if (itxtobjLast < itxtobjFirstInLastTextChunk || 
			itxtobjLast == itxtobjFirstInLastTextChunk && iwchLast < ((PTXTOBJ)plsgrchnk->plschnk[itxtobjFirstInLastTextChunk].pdobj)->iwchFirst )
			{
/* REVIEW sergeyge: check this logic */
			if (cNonText > 0)
				cNonText--;
			fLastObjectIsText = fFalse;
			}

		*pcExtNonTextObjects = cNonText;

		if (fCompress || lskjust == lskjFullInterLetterAligned || lskjust == lskjFullScaled || pilsobj->fSnapGrid)
			{
			return HandleTablesBased(lskjust, plsgrchnk, durToDistribute, dupAvailable, lstflow,
							itxtobjAfterStartSpaces, iwchAfterStartSpaces, fFirstOnLineAfter, 
							itxtobjLast, iwchLast, cNonText, fLastObjectIsText,
							fForcedBreak, fSuppressTrailingSpaces,
							pdupText, pdupTail, pdupExtNonTextObjects);
			}
		else if (lskjust == lskjFullGlyphs)
			{
			if (fExactSync || fSuppressWiggle)
				{
				return HandleFullGlyphsExactSync(plsgrchnk, durToDistribute, dupAvailable, lstflow,
							itxtobjAfterStartSpaces, iwchAfterStartSpaces, itxtobjLast, iwchLast,
							fForcedBreak, fSuppressTrailingSpaces,
							pdupText, pdupTail);
				}
			else
				{
				return HandleFullGlyphsPres(plsgrchnk, dupAvailable, lstflow,
							itxtobjAfterStartSpaces, iwchAfterStartSpaces, itxtobjLast, iwchLast,
							fForcedBreak, fSuppressTrailingSpaces,
							pdupText, pdupTail);
				}
			}
		else 
			{
			if (plsgrchnk->clsgrchnk == 0)
				return lserrNone;

			Assert(fCompress == fFalse);
			Assert(lskjust == lskjNone || lskjust == lskjFullInterWord);
			if (fExactSync || fSuppressWiggle)
				{
				return HandleGeneralSpacesExactSync(lskjust, plsgrchnk, durToDistribute, dupAvailable, lstflow,
							itxtobjAfterStartSpaces, iwchAfterStartSpaces, itxtobjLast, iwchLast,
							fForcedBreak, fSuppressTrailingSpaces,
							pdupText, pdupTail);
				}
			else
				{
				return HandleGeneralSpacesPres(lskjust, plsgrchnk, dupAvailable, lstflow,
							itxtobjAfterStartSpaces, iwchAfterStartSpaces, itxtobjLast, iwchLast,
							fForcedBreak, fSuppressTrailingSpaces,
							pdupText, pdupTail);
				}
			}

		}

}


/* C A N  C O M P R E S S  T E X T */
/*----------------------------------------------------------------------------
    %%Function: CanCompressText
    %%Contact: sergeyge

	Procedure checks if there is enough compression opportunities on the line
	to squeeze in needed amount (durToCompress).
	Trailing spaces are already subtracted by the manager.
	This procedure takes care of the hanging punctuation
	and possible changes if this break opportunity will be realized

	At the end it helps Word to solve backward compatibility issues
----------------------------------------------------------------------------*/
LSERR CanCompressText(const LSGRCHNK* plsgrchnk, PCPOSICHNK pposichnkBeforeTrailing, LSTFLOW lstflow,
					long durToCompress,	BOOL* pfCanCompress, BOOL* pfActualCompress, long* pdurNonSufficient)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	long clschnk;
	long itxtobjFirstInLastTextChunk; /* if GroupChunk ends with foreign object it is equal to cchnk */
	long itxtobjLast;
	PTXTOBJ ptxtobjLast;
	long iwchLast;
	long iwchLastTemp;
	long iwchAfterStartSpaces;
	long itxtobjAfterStartSpaces;
	long durCompressTotal;
	BOOL fHangingPunct;
	BOOL fChangeBackLastChar;
	long ibrkinf;
	BREAKINFO* pbrkinf = NULL;
	BOOL fFirstOnLineAfter;

	long durCompLastRight;
	long durCompLastLeft;
	long durChangeComp;
	BOOL fCancelHangingPunct;
	MWCLS mwclsLast;
	LSCP cpLim;
	LSCP cpLastAdjustable;
	LSDCP dcp;
	
	*pfCanCompress = fFalse;
	*pfActualCompress = fTrue;

	clschnk = (long)plsgrchnk->clsgrchnk;

	if (clschnk == 0)
		{
		*pfCanCompress = (durToCompress <=0 );
		*pfActualCompress = fFalse;
		return lserrNone;
		}

	Assert(clschnk > 0);

	pilsobj = ((PTXTOBJ)plsgrchnk->plschnk[clschnk-1].pdobj)->plnobj->pilsobj;

	itxtobjLast = pposichnkBeforeTrailing->ichnk;
	dcp = pposichnkBeforeTrailing->dcp;

	Assert(itxtobjLast >= 0);
	Assert(itxtobjLast < clschnk || (itxtobjLast == clschnk && dcp == 0));

	if (dcp == 0 && itxtobjLast > 0)
		{
		itxtobjLast--;
		dcp = plsgrchnk->plschnk[itxtobjLast].dcp;
		}

	ptxtobjLast = (PTXTOBJ)plsgrchnk->plschnk[itxtobjLast].pdobj;

	if (ptxtobjLast->iwchLim > ptxtobjLast->iwchFirst)
		iwchLast = ptxtobjLast->iwchFirst + dcp - 1;
	else
		iwchLast = ptxtobjLast->iwchLim - 1;

	Assert(iwchLast <= ptxtobjLast->iwchLim - 1);
	Assert(iwchLast >= ptxtobjLast->iwchFirst - 1);

	GetFirstPosAfterStartSpaces(plsgrchnk, itxtobjLast, iwchLast + 1,
								&itxtobjAfterStartSpaces, &iwchAfterStartSpaces, &fFirstOnLineAfter);

	if (iwchAfterStartSpaces > iwchLast)
		{
		*pfCanCompress = (durToCompress <=0 );
		*pfActualCompress = fFalse;
		return lserrNone;
		}

	for(itxtobjFirstInLastTextChunk = clschnk; itxtobjFirstInLastTextChunk > 0 && !(plsgrchnk->pcont[itxtobjFirstInLastTextChunk - 1] & fcontNonTextAfter); itxtobjFirstInLastTextChunk--);

	fHangingPunct = fFalse;
	if ((pilsobj->grpf & fTxtHangingPunct) &&
		(itxtobjLast > itxtobjFirstInLastTextChunk ||
		 itxtobjLast == itxtobjFirstInLastTextChunk && iwchLast >= ((PTXTOBJ)plsgrchnk->plschnk[itxtobjFirstInLastTextChunk].pdobj)->iwchFirst) &&
		!(ptxtobjLast->txtf & txtfGlyphBased))
		{
		lserr = (*pilsobj->plscbk->pfnFHangingPunct)(pilsobj->pols, plsgrchnk->plschnk[itxtobjLast].plsrun,
				(BYTE)pilsobj->ptxtinf[iwchLast].mwcls, pilsobj->pwchOrig[iwchLast], &fHangingPunct);
		if (lserr != lserrNone) return lserr;
		}
	
	/* Compression information should be collected under assumption that all chars have correct widths;
		Correct width of HangingPunct should be subtructed as well
	 */

	iwchLastTemp = iwchLast;
	
	fChangeBackLastChar = fFalse;

	for (ibrkinf = 0; ibrkinf < (long)pilsobj->breakinfMac &&
		(pilsobj->pbreakinf[ibrkinf].pdobj != (PDOBJ)ptxtobjLast ||
		((long)pilsobj->pbreakinf[ibrkinf].dcp != iwchLast + 1 - ptxtobjLast->iwchFirst &&
		 ptxtobjLast->txtkind != txtkindNonReqHyphen && ptxtobjLast->txtkind != txtkindOptBreak));
																						ibrkinf++);
	if (ibrkinf < (long)pilsobj->breakinfMac)
		{
		pbrkinf = &pilsobj->pbreakinf[ibrkinf];
		Assert(pbrkinf->brkt != brktHyphen);

		if (pbrkinf->brkt == brktNormal && pbrkinf->u.normal.durFix != 0)
			{
			/* Now manager makes correct calculation */
//			durToCompress += pbrkinf->u.normal.durFix;
			Assert(pilsobj->pdurRight[iwchLast] == - pbrkinf->u.normal.durFix);
			pilsobj->pdur[iwchLast] += pbrkinf->u.normal.durFix;
			pilsobj->pdurRight[iwchLast] = 0;
			fChangeBackLastChar = fTrue;
			}
		else if (pbrkinf->brkt == brktNonReq)
			{
			Assert(iwchLast + 1 == ptxtobjLast->iwchLim);
			/* Now manager makes correct calculation */
//			durToCompress += pbrkinf->u.nonreq.ddurTotal;
			fHangingPunct = fFalse;				/* hanging punct does not make sence in this case */
			if (pbrkinf->u.nonreq.dwchYsr >= 1)
				{
				if (pbrkinf->u.nonreq.wchPrev != 0)
					{
					iwchLastTemp--;
					if (pbrkinf->u.nonreq.wchPrevPrev != 0)
						{
						iwchLastTemp--;
						}
					}
				}
			}
		}


	*pfActualCompress = (durToCompress > 0);

	if (fHangingPunct)
		{
		pilsobj->ptxtinf[iwchLast].fHangingPunct = fTrue;

		durToCompress -= pilsobj->pdur[iwchLast];
		iwchLastTemp--;
		}

	durCompressTotal = 0;

	if (!pilsobj->fSnapGrid)
		{
		lserr = FetchCompressInfo(plsgrchnk, fFirstOnLineAfter, lstflow, 
			itxtobjAfterStartSpaces, iwchAfterStartSpaces, itxtobjLast, iwchLastTemp + 1,
			durToCompress, &durCompressTotal);

		if (lserr != lserrNone) return lserr;
		}

	/* Next piece is added to provide mechanism for the backword compatibility with Word */
	durCompLastRight = 0; 
	durCompLastLeft = 0; 

	if	(!(((PTXTOBJ)(plsgrchnk->plschnk[itxtobjLast].pdobj))->txtf & txtfGlyphBased) &&
									!pilsobj->fSnapGrid)
		{
		GetCompLastCharInfo(pilsobj, iwchLast, &mwclsLast, &durCompLastRight, &durCompLastLeft);

		/* First 3 lines of the following condition mean:
			Is Last Significant Character On The Line Text?
		*/
		if (itxtobjFirstInLastTextChunk < (long)clschnk &&
			(itxtobjLast > itxtobjFirstInLastTextChunk ||
				 itxtobjLast == itxtobjFirstInLastTextChunk && iwchLast >= ((PTXTOBJ)plsgrchnk->plschnk[itxtobjFirstInLastTextChunk].pdobj)->iwchFirst) &&
			(durCompLastRight > 0 || durCompLastLeft > 0 || fHangingPunct))
			{
			cpLim = plsgrchnk->plschnk[clschnk-1].cpFirst + plsgrchnk->plschnk[clschnk-1].dcp;

			cpLastAdjustable = plsgrchnk->plschnk[itxtobjLast].cpFirst + 
					iwchLast - ((PTXTOBJ)plsgrchnk->plschnk[itxtobjLast].pdobj)->iwchFirst;

			durChangeComp = 0;

			if (fHangingPunct)
				{
				lserr = (*pilsobj->plscbk->pfnFCancelHangingPunct)(pilsobj->pols, cpLim, cpLastAdjustable,
												pilsobj->pwchOrig[iwchLast], mwclsLast, &fCancelHangingPunct);
				if (lserr != lserrNone) return lserr;

				if (fCancelHangingPunct)
					{
					lserr = FetchCompressInfo(plsgrchnk, fFirstOnLineAfter, lstflow, 
							itxtobjAfterStartSpaces, iwchAfterStartSpaces, itxtobjLast, iwchLast + 1,
							LONG_MAX, &durCompressTotal);
					if (lserr != lserrNone) return lserr;

					durToCompress += pilsobj->pdur[iwchLast];
		
					GetCompLastCharInfo(pilsobj, iwchLast, &mwclsLast, &durCompLastRight, &durCompLastLeft);
		
					if ((durCompLastRight + durCompLastLeft) > 0)
						{
						lserr = (*pilsobj->plscbk->pfnModifyCompAtLastChar)(pilsobj->pols, cpLim, cpLastAdjustable,
														pilsobj->pwchOrig[iwchLast], mwclsLast, 
														durCompLastRight, durCompLastLeft, &durChangeComp);
						if (lserr != lserrNone) return lserr;
						}

					Assert(durChangeComp >= 0);
					Assert(durChangeComp == 0 || (durCompLastRight + durCompLastLeft) > 0);
					}
				}
			else
				{
				lserr = (*pilsobj->plscbk->pfnModifyCompAtLastChar)(pilsobj->pols, cpLim, cpLastAdjustable,
					pilsobj->pwchOrig[iwchLast], mwclsLast, durCompLastRight, durCompLastLeft, &durChangeComp);
				if (lserr != lserrNone) return lserr;
		
				Assert(durChangeComp >= 0);
				Assert(durChangeComp == 0 || (durCompLastRight + durCompLastLeft) > 0);
				}

			durCompressTotal -= durChangeComp;
			}
		/* End of the piece is added to provide mechanizm for the backword compatibility with Word */
		}
	/* Restore width changed before the call to FetchCompressInfo */
	if (fChangeBackLastChar)
		{
		pilsobj->pdur[iwchLast] -= pbrkinf->u.normal.durFix;
		pilsobj->pdurRight[iwchLast] = - pbrkinf->u.normal.durFix;
		}

	if (!pilsobj->fSnapGrid)
		*pfCanCompress = (durToCompress <= durCompressTotal);
	else
		*pfCanCompress = (fHangingPunct && durToCompress <= 0);

	*pdurNonSufficient = durToCompress - durCompressTotal;

	return lserrNone;
}


/* D I S T R I B U T E  I N  T E X T */
/*----------------------------------------------------------------------------
    %%Function: DistributeInText
    %%Contact: sergeyge

	Distributes given amount in text chunk equally
	between all participating characters
----------------------------------------------------------------------------*/
LSERR DistributeInText(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, DWORD cNonText,
									   long durToDistribute, long* pdurNonTextObjects)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	DWORD clschnk;
	long* rgdur;
	long iFirst;
	long iLim;
	PTXTOBJ ptxtobj;
	long itxtobj;
	long i;
	long durTxtobj;
	OBJDIM objdim;

	Unreferenced(lstflow);
	clschnk = plsgrchnk->clsgrchnk;
	Assert(clschnk + cNonText > 0);
	
	if (clschnk == 0)
		{
		*pdurNonTextObjects = durToDistribute;
		return lserrNone;
		}

	pilsobj = ((PTXTOBJ)plsgrchnk->plschnk[0].pdobj)->plnobj->pilsobj;

/* REVIEW sergeyge:Very ugly but still better than anything else?
	Problem case is latin Rubi---NTI was not called and so additional arrays were not allocated

	Original solution---scaling everything down---is not an option becuse than we lose all
	left sided changes in the Rubi subline for Japanese case
*/
	pilsobj->fNotSimpleText = fTrue;

	if (pilsobj->pdurRight == NULL)
		{
		pilsobj->pdurRight = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(long) * pilsobj->wchMax );
		Assert (pilsobj->pdurLeft == NULL);
		Assert (pilsobj->ptxtinf == NULL);
		pilsobj->pdurLeft = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(long) * pilsobj->wchMax );
		pilsobj->ptxtinf = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(TXTINF) * pilsobj->wchMax );
		if (pilsobj->pdurRight == NULL || pilsobj->pdurLeft == NULL || pilsobj->ptxtinf == NULL)
			{
			return lserrOutOfMemory;
			}
		memset(pilsobj->pdurRight, 0, sizeof(long) * pilsobj->wchMax );
		memset(pilsobj->pdurLeft, 0, sizeof(long) * pilsobj->wchMax );
		memset(pilsobj->ptxtinf, 0, sizeof(TXTINF) * pilsobj->wchMax);
		}


	ApplyDistribution(plsgrchnk, cNonText, durToDistribute, pdurNonTextObjects);

	for (itxtobj = 0; itxtobj < (long)clschnk; itxtobj++)
		{
		ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;
		if (ptxtobj->txtf & txtfGlyphBased)
			{
			iFirst = ptxtobj->igindFirst;
			iLim = ptxtobj->igindLim;
			rgdur = pilsobj->pdurGind;
			}
		else
			{
			iFirst = ptxtobj->iwchFirst;
			iLim = ptxtobj->iwchLim;
			rgdur = pilsobj->pdur;
			}
		durTxtobj = 0;
		for (i = iFirst; i < iLim; i++)
			{
			durTxtobj += rgdur[i];
			}

		lserr = LsdnGetObjDim(pilsobj->plsc, ptxtobj->plsdnUpNode, &objdim);
		if (lserr != lserrNone) return lserr;

		objdim.dur = durTxtobj;

		lserr = LsdnResetObjDim(pilsobj->plsc, ptxtobj->plsdnUpNode, &objdim);
		if (lserr != lserrNone) return lserr;
		}

	return lserrNone;
}

/* G E T  T R A I L  I N F O  T E X T */
/*----------------------------------------------------------------------------
    %%Function: GetTrailInfoText
    %%Contact: sergeyge

	Calculates number of spaces at the end of dobj (assuming that it ends at dcp)
	and	the width of the trailing area
----------------------------------------------------------------------------*/
void GetTrailInfoText(PDOBJ pdobj, LSDCP dcp, DWORD* pcNumOfTrailSpaces, long* pdurTrailing)
{
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	long iwch;
	
	Assert(dcp > 0);
	ptxtobj = (PTXTOBJ)pdobj;
	pilsobj = ptxtobj->plnobj->pilsobj;


	*pcNumOfTrailSpaces = 0;
	*pdurTrailing = 0;


	if (ptxtobj->txtkind == txtkindEOL)
		{
		Assert(dcp == 1);
		*pcNumOfTrailSpaces = 1;
		*pdurTrailing = ptxtobj->plnobj->pilsobj->pdur[ptxtobj->iwchFirst];
		}
	else if (!(pilsobj->grpf & fTxtWrapAllSpaces))
		{
		if (ptxtobj->txtkind == txtkindRegular)
			{

			Assert(ptxtobj->iwchLim >= ptxtobj->iwchFirst + (long)dcp);

			if (!(ptxtobj->txtf & txtfGlyphBased))
				{
				for (iwch = ptxtobj->iwchFirst + dcp - 1;
					iwch >= ptxtobj->iwchFirst && pilsobj->pwchOrig[iwch] == pilsobj->wchSpace; iwch--)
					{
					(*pcNumOfTrailSpaces)++;
					*pdurTrailing += pilsobj->pdur[iwch];
					}
				}
			else
				{
				long igindFirst = 0;
				long iwchFirst = 0;
				long igindLast;
				long igind;

				Assert(FIwchLastInContext(pilsobj, ptxtobj->iwchFirst + dcp - 1));

				igindLast = IgindLastFromIwch(ptxtobj, ptxtobj->iwchFirst + dcp - 1);

				for (iwch = ptxtobj->iwchFirst + dcp - 1;
					iwch >= ptxtobj->iwchFirst && pilsobj->pwchOrig[iwch] == pilsobj->wchSpace; iwch--);
				if (iwch < ptxtobj->iwchFirst)
					{
					iwchFirst = ptxtobj->iwchFirst;
					igindFirst = ptxtobj->igindFirst;
					}
				else
					{
					iwchFirst = IwchLastFromIwch(ptxtobj, iwch) + 1;
					igindFirst = IgindLastFromIwch(ptxtobj, iwch) + 1;
					}

				*pcNumOfTrailSpaces = ptxtobj->iwchFirst + dcp - iwchFirst;

				Assert(igindLast < ptxtobj->igindLim);
				for (igind = igindFirst; igind <= igindLast; igind++)
					*pdurTrailing += pilsobj->pdurGind[igind];
				}
			}
		else if (ptxtobj->txtkind == txtkindSpecSpace)
			{
			*pcNumOfTrailSpaces = dcp;
			*pdurTrailing = 0;
			for (iwch = ptxtobj->iwchFirst + dcp - 1; iwch >= ptxtobj->iwchFirst; iwch--)
					*pdurTrailing += pilsobj->pdur[iwch];
			}
		}
		
}


/* F  S U S P E C T  D E V I C E  D I F F E R E N T */
/*----------------------------------------------------------------------------
    %%Function: FSuspectDeviceDifferent
    %%Contact: sergeyge

	Returns TRUE if Visi character or NonReqHyphen-like character might be present
	on the line, and therefore fast prep-for-displaying is impossible in the case
	when fPresEqualRef is TRUE
----------------------------------------------------------------------------*/
BOOL FSuspectDeviceDifferent(PLNOBJ plnobj)
{
	return (plnobj->pilsobj->fDifficultForAdjust);
}


/* F  Q U I C K  S C A L I N G */
/*----------------------------------------------------------------------------
    %%Function: FQuickScaling
    %%Contact: sergeyge

	Checks if fast scaling is possible in the case when fPresEqualRef is FALSE
----------------------------------------------------------------------------*/
BOOL FQuickScaling(PLNOBJ plnobj, BOOL fVertical, long durTotal)
{
	PILSOBJ pilsobj;
	long durMax;

	pilsobj = plnobj->pilsobj;

	durMax = pilsobj->durRightMaxX;
	if (fVertical)
		durMax = pilsobj->durRightMaxY;

	return (durTotal < durMax && !pilsobj->fDifficultForAdjust && plnobj->ptxtobjFirst == plnobj->ptxtobj);
}


#define UpFromUrFast(ur)	( ((ur) * MagicConstant + (1 << 20)) >> 21)


/* Q U I C K  A D J U S T  E X A C T */
/*----------------------------------------------------------------------------
    %%Function: AdjustText
    %%Contact: sergeyge

	Fast scaling: does not check for width restrictions and for Visi situations,
	assumes that there is only text on the line.
----------------------------------------------------------------------------*/
void QuickAdjustExact(PDOBJ* rgpdobj, DWORD cdobj,	DWORD cNumOfTrailSpaces, BOOL fVertical,
																	long* pdupText, long* pdupTrail)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PLNOBJ plnobj;
	PTXTOBJ ptxtobj;
	long* rgdur;
	long* rgdup;
	long durSum;
	long dupSum;
	long dupErrLast;
	long dupPrevChar;
	long MagicConstant;
	long dupIdeal;
	long dupReal;
	long dupErrNew;
	long dupAdjust;
	long wCarry;
	long iwchPrev;
	long iwch;
	long itxtobj;
	long dupTotal;

	Assert(cdobj > 0);

	plnobj = ((PTXTOBJ)rgpdobj[0])->plnobj;
	pilsobj = plnobj->pilsobj;

	Assert(!pilsobj->fDifficultForAdjust);

	rgdur = pilsobj->pdur;
	rgdup = plnobj->pdup;

	if (fVertical)
		MagicConstant = pilsobj->MagicConstantY;
	else
		MagicConstant = pilsobj->MagicConstantX;

	itxtobj = 0;

	durSum = 0;
	dupPrevChar = 0;
	/* Pretty dirty; we make sure that for the first iteration dupAdjust will be 0 */
	iwchPrev = ((PTXTOBJ)rgpdobj[0])->iwchFirst;
	dupErrLast = rgdup[iwchPrev] - UpFromUrFast(rgdur[iwchPrev]);
	dupSum = 0;

	for(itxtobj = 0; itxtobj < (long)cdobj; itxtobj++)
		{
		ptxtobj = (PTXTOBJ) rgpdobj[itxtobj];
		Assert(ptxtobj->txtkind != txtkindTab);
		Assert(!(ptxtobj->txtf & txtfGlyphBased));

		for(iwch = ptxtobj->iwchFirst; iwch < ptxtobj->iwchLim; iwch++)
			{
			durSum += rgdur[iwch];
			/* here David Bangs algorithm starts */
			dupIdeal = UpFromUrFast(durSum) - dupSum;
			Assert(dupIdeal >= 0);

			dupReal = rgdup[iwch];
			dupErrNew = dupReal - dupIdeal;
			dupAdjust = dupErrNew - dupErrLast;
			Assert(iwch > ((PTXTOBJ)rgpdobj[0])->iwchFirst || dupAdjust == 0);
			if (dupAdjust != 0)
				{
				wCarry = dupAdjust & 1;

			   	if (dupAdjust > 0)	
						{
			   		dupAdjust >>= 1;
					if (dupErrLast < -dupErrNew)
						dupAdjust += wCarry;
						dupAdjust = min(dupPrevChar /*-1*/, dupAdjust); 
					}
				else
					{
					dupAdjust >>= 1;
					if (dupErrNew < -dupErrLast)
						dupAdjust += wCarry;
					dupAdjust = max(/*1*/ - dupIdeal, dupAdjust); 
					}

				rgdup[iwchPrev] -= dupAdjust;
				dupIdeal += dupAdjust;
				}

			rgdup[iwch] = dupIdeal;
			dupSum += (dupIdeal - dupAdjust);
			dupErrLast = dupReal - dupIdeal;
			iwchPrev = iwch;
			dupPrevChar = dupIdeal;
			/* here David Bangs algorithm stops */
			}

		}


	*pdupText = 0;
	*pdupTrail = 0;
	for (itxtobj=0; itxtobj < (long)cdobj - 1; itxtobj++)
		{
		ptxtobj = (PTXTOBJ) rgpdobj[itxtobj];
		dupTotal = 0;

		for(iwch = ptxtobj->iwchFirst; iwch < ptxtobj->iwchLim; iwch++)
			dupTotal += rgdup[iwch];

		*pdupText += dupTotal;
		lserr = LsdnSetTextDup(plnobj->pilsobj->plsc, ptxtobj->plsdnUpNode, dupTotal);
		Assert(lserr == lserrNone);
		}
	
	Assert(itxtobj == (long)cdobj - 1);
	ptxtobj = (PTXTOBJ) rgpdobj[itxtobj];

	Assert(ptxtobj->txtkind == txtkindEOL && cNumOfTrailSpaces == 1||
				 ptxtobj->iwchLim - ptxtobj->iwchFirst > (long)cNumOfTrailSpaces);
	dupTotal = 0;

	for (iwch = ptxtobj->iwchLim - 1; iwch > ptxtobj->iwchLim - (long)cNumOfTrailSpaces - 1; iwch--)
		{
		dupTotal += rgdup[iwch];
		*pdupTrail += rgdup[iwch];
		}

	Assert(iwch == ptxtobj->iwchLim - (long)cNumOfTrailSpaces - 1);

	for (; iwch >= ptxtobj->iwchFirst; iwch--)
		{
		dupTotal += rgdup[iwch];
		}

	*pdupText += dupTotal;
	lserr = LsdnSetTextDup(plnobj->pilsobj->plsc, ptxtobj->plsdnUpNode, dupTotal);
	Assert(lserr == lserrNone);

	return;
}

/* Internal functions implementation */


/* G E T  F I R S T  P O S  A F T E R  S T A R T  S P A C E S */
/*----------------------------------------------------------------------------
    %%Function: GetFirstPosAfterStartSpaces
    %%Contact: sergeyge

	Reports index of the first char after leading spaces
----------------------------------------------------------------------------*/
static void GetFirstPosAfterStartSpaces(const LSGRCHNK* plsgrchnk, long itxtobjLast, long iwchLim,
				long* pitxtobjAfterStartSpaces, long* piwchAfterStartSpaces, BOOL* pfFirstOnLineAfter)
{
	PILSOBJ pilsobj;
	PLNOBJ plnobj;
	long iwch;
	BOOL fInStartSpace;
	long itxtobj;
	PTXTOBJ ptxtobj;
	long iwchLimInDobj;
	PLSCHNK rglschnk;

	Assert(plsgrchnk->clsgrchnk > 0);

	rglschnk = plsgrchnk->plschnk;
	plnobj = ((PTXTOBJ)rglschnk[0].pdobj)->plnobj;
	pilsobj = plnobj->pilsobj;
	itxtobj = 0;
	ptxtobj = (PTXTOBJ)rglschnk[0].pdobj;
	iwch =  0;

	*pitxtobjAfterStartSpaces = 0;
	*piwchAfterStartSpaces = ptxtobj->iwchFirst;
	*pfFirstOnLineAfter = !(plsgrchnk->pcont[0] & fcontNonTextBefore);

	fInStartSpace = *pfFirstOnLineAfter;

	while (fInStartSpace && itxtobj <= itxtobjLast)
		{
		ptxtobj = (PTXTOBJ)rglschnk[itxtobj].pdobj;

		iwchLimInDobj = iwchLim;
		if (itxtobj < itxtobjLast)
			iwchLimInDobj = ptxtobj->iwchLim;

		if (plsgrchnk->pcont[itxtobj] & fcontNonTextBefore)
			{
			*pfFirstOnLineAfter = fFalse;
			*pitxtobjAfterStartSpaces = itxtobj;
			*piwchAfterStartSpaces = ptxtobj->iwchFirst;
			fInStartSpace = fFalse;
			}

		else if (ptxtobj->txtkind == txtkindRegular)
			{
			for (iwch = ptxtobj->iwchFirst; iwch < iwchLimInDobj && 
								pilsobj->pwchOrig[iwch] == pilsobj->wchSpace; iwch++);

			if ((ptxtobj->txtf & txtfGlyphBased) && iwch < iwchLimInDobj)
				{
				for(; !FIwchFirstInContext(pilsobj, iwch); iwch--);
				Assert(iwch >= ptxtobj->iwchFirst);
				}

			if (iwch < iwchLimInDobj)
				{
				*pitxtobjAfterStartSpaces = itxtobj;
				*piwchAfterStartSpaces = iwch;
				fInStartSpace = fFalse;
				}
			}
	/* REVIEW: sergeyge---should something be changed in the following check? */
		else if (ptxtobj->txtkind != txtkindEOL 
//				&&	 ptxtobj->txtkind != txtkindSpecSpace
				 )
			{
			*pitxtobjAfterStartSpaces = itxtobj;
			*piwchAfterStartSpaces = ptxtobj->iwchFirst;
			fInStartSpace = fFalse;
			}

		itxtobj++;
		iwch = iwchLimInDobj;
		}
		
	if (fInStartSpace)
		{
		*pitxtobjAfterStartSpaces = itxtobj;
		*piwchAfterStartSpaces = iwchLim;
		}

	return;

}


/* H A N D L E  S I M P L E  T E X T  W Y S I */
/*----------------------------------------------------------------------------
    %%Function: HandleSimpleTextWysi
    %%Contact: sergeyge

	Implements Latin-like justification in spaces (if needed)
	on the reference device	and WYSIWYG algorithm for the exact positioning
	under assumption that there were no NominalToIdeal modifications
	(except for Latin kerning) on the line.

	Startegy:
	 Distribute in spaces if needed
	 Scale down width of spaces from the reference device to the presentation one
	 Apply WYSIWYG algorithm
----------------------------------------------------------------------------*/
static LSERR HandleSimpleTextWysi(LSKJUST lskjust, const LSGRCHNK* plsgrchnk, long durToDistribute,
			 long dupAvailable, LSTFLOW lstflow, long itxtobjAfterStartSpaces, long iwchAfterStartSpaces,
			 long itxtobjLast, long iwchLast, BOOL fExactSync, BOOL fForcedBreak, BOOL fSuppressTrailingSpaces,
			 long* pdupText, long* pdupTail)
{
	PTXTOBJ ptxtobj;
	BOOL fFullyJustified;

	fFullyJustified = fFalse;

	if (itxtobjLast > itxtobjAfterStartSpaces || (itxtobjLast == itxtobjAfterStartSpaces && iwchLast >= iwchAfterStartSpaces))
		{
		ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[0].pdobj;

		if (lskjust != lskjNone && durToDistribute > 0)
			{
			FullPositiveSpaceJustification(plsgrchnk, itxtobjAfterStartSpaces, iwchAfterStartSpaces, 
							itxtobjLast, iwchLast,	ptxtobj->plnobj->pilsobj->pdur, NULL,
							durToDistribute, &fFullyJustified);
			ScaleSpaces(plsgrchnk, lstflow, itxtobjLast, iwchLast);
			}
		else if (!fForcedBreak && durToDistribute < 0)
			{
			fFullyJustified = fTrue;
			NegativeSpaceJustification(plsgrchnk, itxtobjAfterStartSpaces, iwchAfterStartSpaces, 
							itxtobjLast, iwchLast, ptxtobj->plnobj->pilsobj->pdur, NULL,
							-durToDistribute);
			ScaleSpaces(plsgrchnk, lstflow, itxtobjLast, iwchLast);
			}
		}

	Unreferenced(fExactSync);
/*	if (fExactSync)*/
		ApplyWysi(plsgrchnk, lstflow);
/*	else
		ApplyNonExactWysi(plsgrchnk, lstflow);
*/

	return FinalAdjustmentOnPres(plsgrchnk, itxtobjLast, iwchLast, dupAvailable,
									 fFullyJustified, fForcedBreak, fSuppressTrailingSpaces,
									 pdupText, pdupTail);

}

/* H A N D L E  S I M P L E  T E X T  P R E S */
/*----------------------------------------------------------------------------
    %%Function: HandleSimpleTextPres
    %%Contact: sergeyge

	Implements Latin-like justification in spaces (if needed) 
	on the presentation device
	under assumption that there were no NominalToIdeal modifications
	(except for Latin kerning) on the line.

----------------------------------------------------------------------------*/
static LSERR HandleSimpleTextPres(LSKJUST lskjust, const LSGRCHNK* plsgrchnk,
					 long dupAvailable, long itxtobjAfterStartSpaces, long iwchAfterStartSpaces,
					 long itxtobjLast, long iwchLast, BOOL fForcedBreak, BOOL fSuppressTrailingSpaces,
					 long* pdupText, long* pdupTail)
{
	PTXTOBJ ptxtobj;
	BOOL fFullyJustified;
	long* rgdup;
	long itxtobj;
	long iwchLim;
	long iwch;
	long dupTotal;
	long dupToDistribute;

	if (itxtobjLast > itxtobjAfterStartSpaces || (itxtobjLast == itxtobjAfterStartSpaces && iwchLast >= iwchAfterStartSpaces))
		{
		ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[0].pdobj;

		rgdup = ptxtobj->plnobj->pdup;

		dupTotal = 0;

		/* REVIEW sergeyge: should we think about eliminating this loop for online view? */
		for (itxtobj=0; itxtobj <= itxtobjLast; itxtobj++)
			{
			ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;
	
			iwchLim = iwchLast + 1;
			if (itxtobj < itxtobjLast)
				iwchLim = ptxtobj->iwchLim;

			for (iwch = ptxtobj->iwchFirst; iwch < iwchLim; iwch++)
				{
				dupTotal += rgdup[iwch];
				}
			}

		dupToDistribute = dupAvailable - dupTotal;

		if (lskjust != lskjNone && dupToDistribute > 0)
			{
			FullPositiveSpaceJustification(plsgrchnk, itxtobjAfterStartSpaces, iwchAfterStartSpaces, 
							itxtobjLast, iwchLast, rgdup, NULL,
							dupToDistribute, &fFullyJustified);
			}
		else if (!fForcedBreak && dupToDistribute < 0)
			{
			NegativeSpaceJustification(plsgrchnk, itxtobjAfterStartSpaces, iwchAfterStartSpaces, 
							itxtobjLast, iwchLast, rgdup, NULL,
							-dupToDistribute);
			}

		}

	return FinalAdjustmentOnPres(plsgrchnk, itxtobjLast, iwchLast, dupAvailable,
									 fFalse, fForcedBreak, fSuppressTrailingSpaces,
									 pdupText, pdupTail);

}

/* H A N D L E  G E N E R A L  S P A C E S  E X A C T  S Y N C */
/*----------------------------------------------------------------------------
    %%Function: HandleGeneralSpacesExactSync
    %%Contact: sergeyge

	Implements Latin-like justification in spaces (if needed)
	on the reference device	and WYSIWYG algorithm for the exact positioning
	in the general case

	Startegy:
	 Distribute in spaces if needed
	 Scale down changes applied to characters during NTI and distribution
	 If glyphs were detected on the line,
      scale down changes apllied to glyphs during NTI
	  and adjust offsets
	 Apply WYSIWYG algorithm
	 If some characters were changed on the left side
	  prepare additional width array for the display time
----------------------------------------------------------------------------*/
static LSERR HandleGeneralSpacesExactSync(LSKJUST lskjust, const LSGRCHNK* plsgrchnk, long durToDistribute,
			 long dupAvailable, LSTFLOW lstflow, long itxtobjAfterStartSpaces, long iwchAfterStartSpaces,
			 long itxtobjLast, long iwchLast, BOOL fForcedBreak, BOOL fSuppressTrailingSpaces,
			 long* pdupText, long* pdupTail)
{
	LSERR lserr;
	PLNOBJ plnobj;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	BOOL fFullyJustified = fFalse;
	BOOL fLeftSideAffected = fFalse;
	BOOL fGlyphDetected = fFalse;

	plnobj = ((PTXTOBJ) plsgrchnk->plschnk[0].pdobj)->plnobj;
	pilsobj = plnobj->pilsobj;

	if (itxtobjLast > itxtobjAfterStartSpaces || (itxtobjLast == itxtobjAfterStartSpaces && iwchLast >= iwchAfterStartSpaces))
		{
		ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[0].pdobj;

		if (lskjust != lskjNone && durToDistribute > 0)
			{
			FullPositiveSpaceJustification(plsgrchnk, itxtobjAfterStartSpaces, iwchAfterStartSpaces, 
							itxtobjLast, iwchLast,	pilsobj->pdur, pilsobj->pdurGind,
							durToDistribute, &fFullyJustified);
			}
		else if (!fForcedBreak && durToDistribute < 0)
			{
			fFullyJustified = fTrue;
			NegativeSpaceJustification(plsgrchnk, itxtobjAfterStartSpaces, iwchAfterStartSpaces, 
							itxtobjLast, iwchLast, pilsobj->pdur, pilsobj->pdurGind,
							-durToDistribute);
			}
		}

	ScaleCharSides(plsgrchnk, lstflow, &fLeftSideAffected, &fGlyphDetected);

	if (fGlyphDetected)
		{
		ScaleGlyphSides(plsgrchnk, lstflow);
		UpdateGlyphOffsets(plsgrchnk);
		SetBeforeJustCopy(plsgrchnk);
		}

	ApplyWysi(plsgrchnk, lstflow);

	lserr = FinalAdjustmentOnPres(plsgrchnk, itxtobjLast, iwchLast, dupAvailable,
									 fFullyJustified, fForcedBreak, fSuppressTrailingSpaces,
									 pdupText, pdupTail);
	if (lserr != lserrNone) return lserr;

	/* If pdupPen is already used, don't forget to copy pdup there---ScaleSides could change it */
	if (fLeftSideAffected || plnobj->pdup != plnobj->pdupPen)
		{
		lserr = FillDupPen(plsgrchnk, lstflow, itxtobjLast, iwchLast);
		if (lserr != lserrNone) return lserr;
		}

	return lserrNone;

}

/* H A N D L E  G E N E R A L  S P A C E S  P R E S */
/*----------------------------------------------------------------------------
    %%Function: HandleGeneralSpacesPres
    %%Contact: sergeyge

	Implements Latin-like justification in spaces (if needed)
	directly on the presentation device in the general case

	Startegy:
	 Scale down changes applied to characters during NTI
	 If glyphs were detected on the line,
      scale down changes apllied to glyphs during NTI
	  and adjust glyph offsets
	 Distribute in spaces if needed
	 If glyphs were detected on the line,
	  adjust glyph offsets
	 If some characters were changed on the left side
	  prepare additional width array for the display time
----------------------------------------------------------------------------*/
static LSERR HandleGeneralSpacesPres(LSKJUST lskjust, const LSGRCHNK* plsgrchnk, long dupAvailable,
					 LSTFLOW lstflow, long itxtobjAfterStartSpaces, long iwchAfterStartSpaces,
					 long itxtobjLast, long iwchLast, BOOL fForcedBreak, BOOL fSuppressTrailingSpaces,
					 long* pdupText, long* pdupTail)
{
	LSERR lserr;
	PLNOBJ plnobj;
	PTXTOBJ ptxtobj;
	PTXTOBJ ptxtobjLast;
	long* rgdup;
	BOOL fFullyJustified;
	long itxtobj;
	long iwchLastInDobj;
	long iFirst;
	long iLim;
	long i;
	long dupTotal;
	long dupToDistribute;
	BOOL fLeftSideAffected = fFalse;
	BOOL fGlyphDetected = fFalse;

	ptxtobjLast = (PTXTOBJ)plsgrchnk->plschnk[max(0, itxtobjLast)].pdobj;
	plnobj = ptxtobjLast->plnobj;

	ScaleCharSides(plsgrchnk, lstflow, &fLeftSideAffected, &fGlyphDetected);

	if (fGlyphDetected)
		{
		ScaleGlyphSides(plsgrchnk, lstflow);
		UpdateGlyphOffsets(plsgrchnk);
		SetBeforeJustCopy(plsgrchnk);
		}

	if (itxtobjLast > itxtobjAfterStartSpaces || (itxtobjLast == itxtobjAfterStartSpaces && iwchLast >= iwchAfterStartSpaces))
		{
		ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[0].pdobj;

		dupTotal = 0;
		for (itxtobj=0; itxtobj <= itxtobjLast; itxtobj++)
			{
			ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;

			if (ptxtobj->txtf & txtfGlyphBased)
				{
				iFirst = ptxtobj->igindFirst;
				iwchLastInDobj = iwchLast;
				if (itxtobj < itxtobjLast)
					iwchLastInDobj = ptxtobj->iwchLim - 1;
				iLim = IgindLastFromIwch(ptxtobj, iwchLastInDobj) + 1;
				rgdup = plnobj->pdupGind;
				}
			else
				{
				iFirst = ptxtobj->iwchFirst;
				iLim = iwchLast + 1;
				if (itxtobj < itxtobjLast)
					iLim = ptxtobj->iwchLim;
				rgdup = plnobj->pdup;
				}
	
			for (i =iFirst; i < iLim; i++)
				{
				dupTotal += rgdup[i];
				}
			}

		dupToDistribute = dupAvailable - dupTotal;

		if (lskjust != lskjNone && dupToDistribute > 0)
			{
			FullPositiveSpaceJustification(plsgrchnk, itxtobjAfterStartSpaces, iwchAfterStartSpaces, 
							itxtobjLast, iwchLast, plnobj->pdup, plnobj->pdupGind,
							dupToDistribute, &fFullyJustified);
			}
		else if (!fForcedBreak && dupToDistribute < 0)
			{
			NegativeSpaceJustification(plsgrchnk, itxtobjAfterStartSpaces, iwchAfterStartSpaces, 
							itxtobjLast, iwchLast, plnobj->pdup, plnobj->pdupGind,
							-dupToDistribute);
			}

		if (fGlyphDetected)
			{
			UpdateGlyphOffsets(plsgrchnk);
			}
		}

	lserr = FinalAdjustmentOnPres(plsgrchnk, itxtobjLast, iwchLast, dupAvailable,
									 fFalse, fForcedBreak, fSuppressTrailingSpaces,
									 pdupText, pdupTail);

	if (lserr != lserrNone) return lserr;

	/* If pdupPen is already used, don't forget to copy pdup there---ScaleSides could change it */
	if (fLeftSideAffected || plnobj->pdup != plnobj->pdupPen)
		{
		lserr = FillDupPen(plsgrchnk, lstflow, itxtobjLast, iwchLast);
		if (lserr != lserrNone) return lserr;
		}

	return lserrNone;
}

/* H A N D L E  T A B L E  B A S E D */
/*----------------------------------------------------------------------------
    %%Function: HandleTableBased
    %%Contact: sergeyge

	Implements FE-like justification or compression
	on the reference device	and WYSIWYG algorithm for the exact positioning

	Startegy:
	 Apply needed type of justification or compression
	 Scale down changes applied to characters during NTI and justification
	 If glyphs were detected on the line,
      scale down changes apllied to glyphs during NTI
	  and adjust offsets
	 Apply WYSIWYG algorithm
	 If some characters were changed on the left side
	  prepare additional width array for the display time
----------------------------------------------------------------------------*/
static LSERR HandleTablesBased(LSKJUST lskjust, const LSGRCHNK* plsgrchnk,
			 long durToDistribute, long dupAvailable, LSTFLOW lstflow,
			 long itxtobjAfterStartSpaces, long iwchAfterStartSpaces, BOOL fFirstOnLineAfter,
			 long itxtobjLast, long iwchLast, long cNonText, BOOL fLastObjectIsText,
			 BOOL fForcedBreak, BOOL fSuppressTrailingSpaces,
			 long* pdupText, long* pdupTail, long* pdupExtNonText)
{
	LSERR lserr;
	PILSOBJ pilsobj = NULL;
	PLNOBJ plnobj;
	long durExtNonText = 0;
	DWORD clschnk;
	MWCLS mwclsLast;
	long durCompLastLeft = 0;
	long durCompLastRight = 0;
	long durHangingChar;
	long dupHangingChar = 0;
	BOOL fHangingUsed = fFalse;
	long durCompressTotal;
	long iwchLastTemp;
	BOOL fScaledExp;
	BOOL fFullyJustified = fFalse;
	BOOL fLeftSideAffected = fFalse;
	BOOL fGlyphDetected = fFalse;

	Assert(lskjust == lskjFullInterLetterAligned ||
		   lskjust == lskjFullScaled ||
		   lskjust == lskjNone);

	*pdupExtNonText = 0;
	clschnk = plsgrchnk->clsgrchnk;
	Assert(clschnk > 0);

	plnobj = ((PTXTOBJ) plsgrchnk->plschnk[0].pdobj)->plnobj;
	pilsobj = plnobj->pilsobj;

	if (itxtobjLast > itxtobjAfterStartSpaces || (itxtobjLast == itxtobjAfterStartSpaces && iwchLast >= iwchAfterStartSpaces))
		{

		Assert(clschnk > 0);

		if (pilsobj->fSnapGrid)
			{
			if (durToDistribute < 0)
				{
				Assert(-durToDistribute <= pilsobj->pdur[iwchLast]);
				fHangingUsed = fTrue;
				}
			}
		else if (durToDistribute < 0)
			{
			fFullyJustified = fTrue;
			lserr = FetchCompressInfo(plsgrchnk, fFirstOnLineAfter, lstflow,
				itxtobjAfterStartSpaces, iwchAfterStartSpaces, itxtobjLast, iwchLast + 1,
				LONG_MAX, &durCompressTotal);
			if (lserr != lserrNone) return lserr;
			
			if (fLastObjectIsText && !(((PTXTOBJ) plsgrchnk->plschnk[0].pdobj)->txtf & txtfGlyphBased))
				GetCompLastCharInfo(pilsobj, iwchLast, &mwclsLast, &durCompLastRight, &durCompLastLeft);

			if (pilsobj->ptxtinf[iwchLast].fHangingPunct)
				{		
				Assert(lskjust == lskjNone || lskjust == lskjFullInterLetterAligned || lskjust == lskjFullScaled);
				Assert(fLastObjectIsText);
				if (durCompLastRight >= -durToDistribute)
					{

					Assert(durCompLastRight > 0);
					CompressLastCharRight(pilsobj, iwchLast, durCompLastRight);

					if (lskjust != lskjNone)
						{
						fScaledExp = (lskjust != lskjFullInterLetterAligned);
						lserr = ApplyExpand(plsgrchnk, lstflow, fScaledExp, 
							itxtobjAfterStartSpaces, iwchAfterStartSpaces, itxtobjLast, iwchLast, cNonText,
							durCompLastRight + durToDistribute, &durExtNonText, &fFullyJustified);
						if (lserr != lserrNone) return lserr;
						}
					}

				else if (durCompressTotal - durCompLastRight >= -durToDistribute)
					{
					lserr = ApplyCompress(plsgrchnk, lstflow, itxtobjAfterStartSpaces, iwchAfterStartSpaces,
						itxtobjLast, iwchLast, -durToDistribute);
					if (lserr != lserrNone) return lserr;
					}

				else if (durCompressTotal >= -durToDistribute)
					{
					if (durCompLastRight > 0)
						CompressLastCharRight(pilsobj, iwchLast, durCompLastRight);

					lserr = ApplyCompress(plsgrchnk, lstflow, itxtobjAfterStartSpaces, iwchAfterStartSpaces,
						itxtobjLast, iwchLast + 1, -durToDistribute - durCompLastRight);
					if (lserr != lserrNone) return lserr;
					}
				else
					{
					durHangingChar = pilsobj->pdur[iwchLast];
					/* Order of operations is important here because dur of the hanging
						punctuation gets chnaged in the next lines of code and
						durHangingChar is used in ApplyCompress/ApplyExpand calls below!!!
					*/
					if (durCompLastRight > 0)
						CompressLastCharRight(pilsobj, iwchLast, durCompLastRight);

					fHangingUsed = fTrue;

					if (durHangingChar + durToDistribute >= 0)
						{
						fScaledExp = (lskjust != lskjFullInterLetterAligned);
						lserr = ApplyExpand(plsgrchnk, lstflow, fScaledExp,
							itxtobjAfterStartSpaces, iwchAfterStartSpaces, itxtobjLast,	iwchLast,
							cNonText, durHangingChar + durToDistribute, &durExtNonText, &fFullyJustified);
						if (lserr != lserrNone) return lserr;
						}
					else
						{
						lserr = ApplyCompress(plsgrchnk, lstflow,
							itxtobjAfterStartSpaces, iwchAfterStartSpaces, itxtobjLast, iwchLast,
							 -durToDistribute - durHangingChar);
						if (lserr != lserrNone) return lserr;
						}
					}
				}
			else
				{
				if (durCompLastRight >= -durToDistribute)
					{
					Assert(!(((PTXTOBJ) plsgrchnk->plschnk[0].pdobj)->txtf & txtfGlyphBased));
					CompressLastCharRight(pilsobj, iwchLast, -durToDistribute);
					}
				else
					{
					if (durCompLastRight > 0)
						{
						Assert(!(((PTXTOBJ) plsgrchnk->plschnk[0].pdobj)->txtf & txtfGlyphBased));
						CompressLastCharRight(pilsobj, iwchLast, durCompLastRight);
						}
					lserr = ApplyCompress(plsgrchnk, lstflow, itxtobjAfterStartSpaces, iwchAfterStartSpaces,
						itxtobjLast, iwchLast + 1, -durToDistribute - durCompLastRight);
					if (lserr != lserrNone) return lserr;
					}
				}

			}
		else 
			{
/*			Assert (durToDistribute >= 0 || iwchLast == iwchAfterStartSpaces);---Unfortunately it might be not true
			for the second line of Warichu, because durTotal for it is scaled up value of dup of the first line
*/
			if (lskjust != lskjNone && durToDistribute > 0)
				{
				Assert(lskjust == lskjFullScaled || lskjust == lskjFullInterLetterAligned);
				iwchLastTemp = iwchLast;
				if (!fLastObjectIsText)
					iwchLastTemp++;
				lserr = ApplyExpand(plsgrchnk, lstflow, lskjust == lskjFullScaled,
						itxtobjAfterStartSpaces, iwchAfterStartSpaces, itxtobjLast, iwchLastTemp,
						cNonText, durToDistribute, &durExtNonText, &fFullyJustified);
				if (lserr != lserrNone) return lserr;
				}
			}

		}
	else if (cNonText != 0 && lskjust != lskjNone && durToDistribute > 0)
		{
		durExtNonText = durToDistribute;
		}

	ScaleExtNonText(pilsobj, lstflow, durExtNonText, pdupExtNonText);
	
	ScaleCharSides(plsgrchnk, lstflow, &fLeftSideAffected, &fGlyphDetected);

	if (fGlyphDetected)
		{
		ScaleGlyphSides(plsgrchnk, lstflow);
		UpdateGlyphOffsets(plsgrchnk);
		SetBeforeJustCopy(plsgrchnk);
		}

	ApplyWysi(plsgrchnk, lstflow);

	if (fHangingUsed)
		GetDupLastChar(plsgrchnk, iwchLast, &dupHangingChar);
		

	lserr = FinalAdjustmentOnPres(plsgrchnk, itxtobjLast, iwchLast,
									 dupAvailable + dupHangingChar - *pdupExtNonText,
									 fFullyJustified, fForcedBreak, fSuppressTrailingSpaces,
									 pdupText, pdupTail);
	if (lserr != lserrNone) return lserr;

	/* If pdupPen is already used, don't forget to copy pdup there---ScaleSides could change it */
	if (fLeftSideAffected || plnobj->pdup != plnobj->pdupPen)
		{
		lserr = FillDupPen(plsgrchnk, lstflow, itxtobjLast, iwchLast);
		if (lserr != lserrNone) return lserr;
		}

	return lserrNone;
}

/* H A N D L E  F U L L  G L Y P H S  E X A C T  S Y N C */
/*----------------------------------------------------------------------------
    %%Function: HandleFullGlyphsExactSync
    %%Contact: sergeyge

	Implements glyph-based justification
	on the reference device	and WYSIWYG algorithm
	for the exact positioning

	Startegy:
	 Apply glyph-based justification if needed
	 Scale down changes applied to characters during NTI and justification
	 If glyphs were detected on the line,
      scale down changes apllied to glyphs during NTI
	  and adjust offsets
	 Apply WYSIWYG algorithm
	 If some characters were changed on the left side
	  prepare additional width array for the display time
----------------------------------------------------------------------------*/
static LSERR HandleFullGlyphsExactSync(const LSGRCHNK* plsgrchnk,
			 long durToDistribute, long dupAvailable, LSTFLOW lstflow,
			 long itxtobjAfterStartSpaces, long iwchAfterStartSpaces,
			 long itxtobjLast, long iwchLast, BOOL fForcedBreak, BOOL fSuppressTrailingSpaces,
			 long* pdupText, long* pdupTail)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PLNOBJ plnobj;
	BOOL fFullyJustified = fFalse;
	BOOL fLeftSideAffected = fFalse;
	BOOL fGlyphDetected = fFalse;

	plnobj = ((PTXTOBJ) plsgrchnk->plschnk[0].pdobj)->plnobj;
	pilsobj = plnobj->pilsobj;

	ScaleGlyphSides(plsgrchnk, lstflow);
	UpdateGlyphOffsets(plsgrchnk);
	SetBeforeJustCopy(plsgrchnk);

	if (itxtobjLast > itxtobjAfterStartSpaces || (itxtobjLast == itxtobjAfterStartSpaces && iwchLast >= iwchAfterStartSpaces))
		{
		lserr = ApplyGlyphExpand(plsgrchnk, lstflow, lsdevReference,
						itxtobjAfterStartSpaces, iwchAfterStartSpaces, itxtobjLast, iwchLast,
						durToDistribute, pilsobj->pdur, pilsobj->pdurGind, pilsobj->pdurRight, pilsobj->pduGright,
						&fFullyJustified);
		if (lserr != lserrNone) return lserr;
		}

	ScaleCharSides(plsgrchnk, lstflow, &fLeftSideAffected, &fGlyphDetected);

	if (fGlyphDetected)
		{
		ScaleGlyphSides(plsgrchnk, lstflow);
		UpdateGlyphOffsets(plsgrchnk);
		}

	ApplyWysi(plsgrchnk, lstflow);

	lserr = FinalAdjustmentOnPres(plsgrchnk, itxtobjLast, iwchLast, dupAvailable,
									 fFullyJustified, fForcedBreak, fSuppressTrailingSpaces,
									 pdupText, pdupTail);
	if (lserr != lserrNone) return lserr;

	/* If pdupPen is already used, don't forget to copy pdup there---ScaleSides could change it */
	if (fLeftSideAffected || plnobj->pdup != plnobj->pdupPen)
		{
		lserr = FillDupPen(plsgrchnk, lstflow, itxtobjLast, iwchLast);
		if (lserr != lserrNone) return lserr;
		}

	return lserrNone;
}

/* H A N D L E  F U L L  G L Y P H S  P R E S */
/*----------------------------------------------------------------------------
    %%Function: HandleFullGlyphsPres
    %%Contact: sergeyge

	Implements glyph-based justification
	directly on the presentation device

	Startegy:
	 Scale down changes applied to characters during NTI
	 If glyphs were detected on the line,
      scale down changes apllied to glyphs during NTI
	  and adjust offsets
	 Apply glyph-based justification if needed
	 If glyphs were detected on the line,
	  adjust offsets
	 If some characters were changed on the left side
	  prepare additional width array for the display time
----------------------------------------------------------------------------*/
static LSERR HandleFullGlyphsPres(const LSGRCHNK* plsgrchnk,
			 long dupAvailable, LSTFLOW lstflow,
			 long itxtobjAfterStartSpaces, long iwchAfterStartSpaces,
			 long itxtobjLast, long iwchLast, BOOL fForcedBreak, BOOL fSuppressTrailingSpaces,
			 long* pdupText, long* pdupTail)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PLNOBJ plnobj;
	PTXTOBJ ptxtobj;
	PTXTOBJ ptxtobjLast;
	long* rgdup;
	long itxtobj;
	long iwchLastInDobj;
	long iFirst;
	long iLim;
	long i;
	long dupTotal;
	long dupToDistribute;
	BOOL fFullyJustified = fFalse;
	BOOL fLeftSideAffected = fFalse;
	BOOL fGlyphDetected = fFalse;

	ptxtobjLast = (PTXTOBJ)plsgrchnk->plschnk[max(0, itxtobjLast)].pdobj;
	plnobj = ptxtobjLast->plnobj;
	pilsobj = plnobj->pilsobj;

	ScaleCharSides(plsgrchnk, lstflow, &fLeftSideAffected, &fGlyphDetected);
	if (fGlyphDetected)
		{
		ScaleGlyphSides(plsgrchnk, lstflow);
		UpdateGlyphOffsets(plsgrchnk);
		SetBeforeJustCopy(plsgrchnk);
		}

	if (itxtobjLast > itxtobjAfterStartSpaces || (itxtobjLast == itxtobjAfterStartSpaces && iwchLast >= iwchAfterStartSpaces))
		{
		rgdup = plnobj->pdup;

		dupTotal = 0;
		for (itxtobj=0; itxtobj <= itxtobjLast; itxtobj++)
			{
			ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;

			if (ptxtobj->txtf & txtfGlyphBased)
				{
				iFirst = ptxtobj->igindFirst;
				iwchLastInDobj = iwchLast;
				if (itxtobj < itxtobjLast)
					iwchLastInDobj = ptxtobj->iwchLim - 1;
				iLim = IgindLastFromIwch(ptxtobj, iwchLastInDobj) + 1;
				rgdup = plnobj->pdupGind;
				}
			else
				{
				iFirst = ptxtobj->iwchFirst;
				iLim = iwchLast + 1;
				if (itxtobj < itxtobjLast)
					iLim = ptxtobj->iwchLim;
				rgdup = plnobj->pdup;
				}
			

			for (i =iFirst; i < iLim; i++)
				{
				dupTotal += rgdup[i];
				}
			}

		dupToDistribute = dupAvailable - dupTotal;

		lserr = ApplyGlyphExpand(plsgrchnk, lstflow, lsdevPres,
				itxtobjAfterStartSpaces, iwchAfterStartSpaces, itxtobjLast, iwchLast,
				dupToDistribute, plnobj->pdup, plnobj->pdupGind, pilsobj->pdurRight, pilsobj->pduGright,
				&fFullyJustified);
		if (lserr != lserrNone) return lserr;

		if (fGlyphDetected)
			{
			UpdateGlyphOffsets(plsgrchnk);
			}

		}

	lserr = FinalAdjustmentOnPres(plsgrchnk, itxtobjLast, iwchLast, dupAvailable,
									 fFalse, fForcedBreak, fSuppressTrailingSpaces,
									 pdupText, pdupTail);

	if (lserr != lserrNone) return lserr;

	/* If pdupPen is already used, don't forget to copy pdup there---ScaleSides could change it */
	if (fLeftSideAffected || plnobj->pdup != plnobj->pdupPen)
		{
		lserr = FillDupPen(plsgrchnk, lstflow, itxtobjLast, iwchLast);
		if (lserr != lserrNone) return lserr;
		}

	return lserrNone;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\lstxtini.c ===
#include "lsmem.h"
#include "lstxtini.h"
#include "zqfromza.h"
#include "lscbk.h"
#include "lsdocinf.h"
#include "tlpr.h"
#include "txtils.h"
#include "txtln.h"
#include "txtobj.h"
#include "txtconst.h"

#define min(a,b)     ((a) > (b) ? (b) : (a))
#define TxtVisiMask  (fTxtVisiCondHyphens | fTxtVisiParaMarks | fTxtVisiSpaces | fTxtVisiTabs | fTxtVisiBreaks)

/* Internal Functions Prototypes */
static void DestroyLNObjTextCore(PLNOBJ plnobj);
static LSERR ErrorLNObjText(PLNOBJ* plnobj, LSERR lserr);
static LSERR TxtAddSpec(PILSOBJ pilsobj, WCHAR wchSymbol, CLABEL clab, WCHAR wchUndef);
static LSERR TxtSortSpec(WCHAR* rgwchSpec, CLABEL* rgbKind, DWORD cwchSpec);
static void CkeckModWidthClasses(PILSOBJ pilsobj, DWORD cModWidthClasses);

/* Export Functions Implementation*/

/*   D E S T R O Y  I L S O B J  T E X T   */
/*----------------------------------------------------------------------------
    %%Function: DestroyILSObjText
    %%Contact: sergeyge

	Deallocates list of arrays of txtobj's
	Deallocates arrays anchored to ILSOBJ

	Deallocates text ilsobj
----------------------------------------------------------------------------*/
LSERR WINAPI DestroyILSObjText(PILSOBJ pilsobj)
{
	if (pilsobj != NULL)
		{

		if ( pilsobj->pwchOrig != NULL )
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->pwchOrig);
			pilsobj->pwchOrig = NULL;
			}		
		if ( pilsobj->pdur != NULL )
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->pdur);
			pilsobj->pdur = NULL;
			}
		if ( pilsobj->pdurLeft != NULL )
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->pdurLeft);
			pilsobj->pdurLeft = NULL;
			}
		if ( pilsobj->pdurRight != NULL )
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->pdurRight);
			pilsobj->pdurRight = NULL;
			}
		if ( pilsobj->pduAdjust != NULL )
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->pduAdjust);
			pilsobj->pduAdjust = NULL;
			}
		if ( pilsobj->ptxtinf != NULL )
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->ptxtinf);
			pilsobj->ptxtinf = NULL;
			}
		if ( pilsobj->pdurGind != NULL )
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->pdurGind);
			pilsobj->pdurGind = NULL;
			}
		if ( pilsobj->pginf != NULL )
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->pginf);
			pilsobj->pginf = NULL;
			}
		if ( pilsobj->pduGright != NULL )
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->pduGright);
			pilsobj->pduGright = NULL;
			}
		if ( pilsobj->plsexpinf != NULL )
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->plsexpinf);
			pilsobj->plsexpinf = NULL;
			}
		if ( pilsobj->pwSpaces != NULL )
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->pwSpaces);
			pilsobj->pwSpaces = NULL;
			}

		if ( pilsobj->plspairact != NULL )
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->plspairact);
			pilsobj->plspairact = NULL;
			}
		if ( pilsobj->pilspairact != NULL )
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->pilspairact);
			pilsobj->pilspairact = NULL;
			}

		if ( pilsobj->plspract != NULL )
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->plspract);
			pilsobj->plspract = NULL;
			}
		if ( pilsobj->pilspract != NULL )
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->pilspract);
			pilsobj->pilspract = NULL;
			}

		if ( pilsobj->plsexpan != NULL )
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->plsexpan);
			pilsobj->plsexpan = NULL;
			}
		if ( pilsobj->pilsexpan != NULL )
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->pilsexpan);
			pilsobj->pilsexpan = NULL;
			}

		if ( pilsobj->plsbrk != NULL )
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->plsbrk);
			pilsobj->plsbrk = NULL;
			}
		if ( pilsobj->pilsbrk != NULL )
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->pilsbrk);
			pilsobj->pilsbrk = NULL;
			}

		if ( pilsobj->plnobj != NULL )
			{
			DestroyLNObjTextCore(pilsobj->plnobj);
			pilsobj->plnobj = NULL;
			}

		if (pilsobj->pbreakinf != NULL);
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->pbreakinf);
			pilsobj->pbreakinf = NULL;
			}

		(*pilsobj->plscbk->pfnDisposePtr) (pilsobj->pols, pilsobj);

		}

	return lserrNone;
}

/* C R E A T E  I L S O B J  T E X T */
/*----------------------------------------------------------------------------
    %%Function: CreateILSObjText
    %%Contact: sergeyge

	Allocates text ilsobj and sets pols, plsc and call-backs in it
	Allocates first array of the list of arrays of txtobj's
	Allocates wchOrig/dur arrays. Other arrays will be allocated when needed.
----------------------------------------------------------------------------*/
LSERR WINAPI CreateILSObjText(POLS pols, PCLSC plsc, PCLSCBK plscbk, DWORD idobj, PILSOBJ* ppilsobj)
{
	PILSOBJ ptxtils;

	Unreferenced(idobj);

	*ppilsobj = NULL;
	
	ptxtils = (*plscbk->pfnNewPtr)(pols, sizeof(struct ilsobj));

	if (ptxtils == NULL)
		return lserrOutOfMemory;

	*ppilsobj = ptxtils;

	memset(ptxtils, 0, sizeof(struct ilsobj) );

	ptxtils->pols = pols;
	ptxtils->plsc = (PLSC)plsc;

	ptxtils->plscbk = plscbk;

	return lserrNone;
		 
}

/*   D E S T R O Y  L N O B J  T E X T   */
/*----------------------------------------------------------------------------
    %%Function: DestroyLNObjText
    %%Contact: sergeyge

	Deallocates arrays anchored to LNOBJ

	Deallocates text lnobj
----------------------------------------------------------------------------*/
LSERR WINAPI DestroyLNObjText(PLNOBJ plnobj)
{
	if (plnobj->pilsobj->plnobj == NULL)
		{
		plnobj->pilsobj->plnobj = plnobj;
		}

	else if (plnobj != NULL)
		{
		DestroyLNObjTextCore(plnobj);
		}

	return lserrNone;
}

/* C R E A T E  L N O B J  T E X T */
/*----------------------------------------------------------------------------
    %%Function: CreateLNObjText
    %%Contact: sergeyge

	Allocates text lnobj
	Allocates wch/dup arrays. dupPenAllocArray will be allocated when needed.
----------------------------------------------------------------------------*/
LSERR WINAPI CreateLNObjText(PCILSOBJ pilsobj, PLNOBJ* pplnobj)
{
	PLNOBJ ptxtln;

	if (pilsobj->plnobj != NULL)
		{
		*pplnobj = pilsobj->plnobj;
		if (pilsobj->plnobj->wchMax != pilsobj->wchMax)
			{
			Assert(pilsobj->plnobj->pwch != NULL);
			Assert(pilsobj->plnobj->pdup != NULL);
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->plnobj->pwch);
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->plnobj->pdup);
			if (pilsobj->plnobj->pgmap != NULL)
				{
				/* it will be allocated in CheckReallocGlyphs in lstxtnti.c */
				(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->plnobj->pgmap);
				pilsobj->plnobj->pgmap = NULL;
				}

			if (pilsobj->plnobj->pdupPenAlloc != NULL)
				{
				(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->plnobj->pdupPenAlloc);
				}

			pilsobj->plnobj->pdupPenAlloc = NULL;

			pilsobj->plnobj->wchMax = pilsobj->wchMax;
			pilsobj->plnobj->pwch = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(WCHAR) * pilsobj->wchMax);
			pilsobj->plnobj->pdup = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(long) * pilsobj->wchMax);
			if (pilsobj->plnobj->pwch == NULL || pilsobj->plnobj->pdup == NULL)
				{
				pilsobj->plnobj = NULL;
				return ErrorLNObjText(pplnobj, lserrOutOfMemory);
				}
			}

		if (pilsobj->plnobj->gindMax != pilsobj->gindMax)
			{
			if (pilsobj->plnobj->pgind != NULL )
				(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->plnobj->pgind);
			if (pilsobj->plnobj->pdupGind != NULL )
				(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->plnobj->pdupGind);
			if (pilsobj->plnobj->pgoffs != NULL )
				(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->plnobj->pgoffs);
			if (pilsobj->plnobj->pexpt != NULL )
				(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->plnobj->pexpt);
			if (pilsobj->plnobj->pdupBeforeJust != NULL )
				(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->plnobj->pdupBeforeJust);
			if (pilsobj->plnobj->pgprop != NULL )
				(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->plnobj->pgprop);

			pilsobj->plnobj->gindMax = pilsobj->gindMax;
			pilsobj->plnobj->pgind = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(GINDEX) * pilsobj->gindMax);
			pilsobj->plnobj->pdupGind = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(long) * pilsobj->gindMax);
			pilsobj->plnobj->pgoffs = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(GOFFSET) * pilsobj->gindMax);
			pilsobj->plnobj->pexpt = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(EXPTYPE) * pilsobj->gindMax);
			pilsobj->plnobj->pdupBeforeJust = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(long) * pilsobj->gindMax);
			pilsobj->plnobj->pgprop = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(GPROP) * pilsobj->gindMax);

			if (pilsobj->plnobj->pgind == NULL || pilsobj->plnobj->pdupGind == NULL || 
				pilsobj->plnobj->pgoffs == NULL || pilsobj->plnobj->pexpt == NULL ||
				pilsobj->plnobj->pdupBeforeJust == NULL ||
				pilsobj->plnobj->pgprop == NULL)
				{
				pilsobj->plnobj = NULL;
				return ErrorLNObjText(pplnobj, lserrOutOfMemory);
				}

			memset(pilsobj->plnobj->pexpt, 0, sizeof(EXPTYPE) * pilsobj->gindMax);

			}

		pilsobj->plnobj = NULL;

		}
	else
		{
		*pplnobj = NULL;
	
		ptxtln = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(struct lnobj));

		if (ptxtln == NULL)
			{
			return lserrOutOfMemory;
			}

		*pplnobj = ptxtln;

		memset(ptxtln, 0, sizeof(struct lnobj) );

		ptxtln->pilsobj = pilsobj;

		ptxtln->ptxtobj = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(TXTOBJ) * txtobjMaxM + sizeof(TXTOBJ**));
		if ( ptxtln->ptxtobj == NULL)
			{
			return ErrorLNObjText(pplnobj, lserrOutOfMemory);
			}

		ptxtln->ptxtobjFirst = ptxtln->ptxtobj;
		*(TXTOBJ**)( ptxtln->ptxtobj + txtobjMaxM) = NULL;

		ptxtln->wchMax = pilsobj->wchMax;
		ptxtln->pwch = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(WCHAR) * pilsobj->wchMax);
		ptxtln->pdup = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(long) * pilsobj->wchMax);

		if (ptxtln->pwch == NULL || ptxtln->pdup == NULL)
			{
			return ErrorLNObjText(pplnobj, lserrOutOfMemory);
			}

		if (pilsobj->gindMax > 0)
			{
			ptxtln->pgind = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(GINDEX) * pilsobj->gindMax);
			ptxtln->pdupGind = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(long) * pilsobj->gindMax);
			ptxtln->pgoffs = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(GOFFSET) * pilsobj->gindMax);
			ptxtln->pexpt = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(EXPTYPE) * pilsobj->gindMax);
			ptxtln->pdupBeforeJust = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(long) * pilsobj->gindMax);
			ptxtln->pgprop = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(GPROP) * pilsobj->gindMax);

			if (ptxtln->pgind == NULL || ptxtln->pdupGind == NULL ||
				ptxtln->pgoffs == NULL || ptxtln->pexpt == NULL ||
				ptxtln->pdupBeforeJust == NULL || ptxtln->pgprop == NULL)
				{
				return ErrorLNObjText(pplnobj, lserrOutOfMemory);
				}

			ptxtln->gindMax = pilsobj->gindMax;
			}
		}

	if (pilsobj->fNotSimpleText)
		{
		if (pilsobj->pdurRight != NULL)
			{
			memset(pilsobj->pdurRight, 0, sizeof(long) * pilsobj->wchMac );
			Assert (pilsobj->pdurLeft != NULL);
			memset(pilsobj->pdurLeft, 0, sizeof(long) * pilsobj->wchMac );
			Assert (pilsobj->ptxtinf != NULL);
			memset(pilsobj->ptxtinf, 0, sizeof(TXTINF) * pilsobj->wchMac );
			}
		if ((*pplnobj)->pdupPen == (*pplnobj)->pdupPenAlloc && (*pplnobj)->pdupPen != NULL)
			memset((*pplnobj)->pdupPenAlloc, 0,  sizeof(long) * pilsobj->wchMax);

		if (pilsobj->gindMac != 0)
			{
			Assert (pilsobj->pduGright != NULL);
			memset(pilsobj->pduGright, 0, sizeof(long) * pilsobj->gindMac );
			Assert (pilsobj->plsexpinf != NULL);
			memset(pilsobj->plsexpinf, 0, sizeof(LSEXPINFO) * pilsobj->gindMac );
			Assert ((*pplnobj)->pexpt != NULL);
			memset((*pplnobj)->pexpt, 0, sizeof(EXPTYPE) * pilsobj->gindMac );
			}
		}

	pilsobj->txtobjMac = 0;
	pilsobj->wchMac = 0;
	pilsobj->gindMac = 0;
	pilsobj->wSpacesMac = 0;

	pilsobj->fNotSimpleText = fFalse;
	pilsobj->fDifficultForAdjust = fFalse;

	pilsobj->fTruncatedBefore = fFalse;

	pilsobj->iwchCompressFetchedFirst = 0;
	pilsobj->itxtobjCompressFetchedLim = 0;
	pilsobj->iwchCompressFetchedLim = 0;

	pilsobj->dcpFetchedWidth = 0;

	pilsobj->breakinfMac = 3;
	pilsobj->pbreakinf[0].pdobj = NULL;
	pilsobj->pbreakinf[1].pdobj = NULL;
	pilsobj->pbreakinf[2].pdobj = NULL;

	(*pplnobj)->ptxtobj = (*pplnobj)->ptxtobjFirst;

	(*pplnobj)->pdupPen = (*pplnobj)->pdup;

	(*pplnobj)->pdobjHyphen = NULL;
								
	(*pplnobj)->dwchYsr = 0;

	return lserrNone;

}

/* S E T  D O C  T E X T */
/*----------------------------------------------------------------------------
    %%Function: SetDocText
    %%Contact: sergeyge

	Initialization at the doc level
	Called when resolutions are changed
----------------------------------------------------------------------------*/
LSERR WINAPI SetDocText(PILSOBJ pilsobj, PCLSDOCINF plsdocinf)
{
	pilsobj->fDisplay = plsdocinf->fDisplay;
	pilsobj->fPresEqualRef = plsdocinf->fPresEqualRef;
	pilsobj->lsdevres = plsdocinf->lsdevres;

	/* Be careful---In Visi case fPresEqualRef can be True, but sizes of characters---different
	*/
	if (pilsobj->fDisplay && !pilsobj->fPresEqualRef)
		{
		pilsobj->MagicConstantX = LsLwMultDivR(pilsobj->lsdevres.dxpInch, 1 << 21, pilsobj->lsdevres.dxrInch);
		pilsobj->durRightMaxX = min(1 << 21, (0x7FFFFFFF - (1 << 20)) / pilsobj->MagicConstantX);

		pilsobj->MagicConstantY = pilsobj->MagicConstantX;
		pilsobj->durRightMaxY = pilsobj->durRightMaxY;

		if (pilsobj->lsdevres.dxrInch != pilsobj->lsdevres.dyrInch ||
							 pilsobj->lsdevres.dxpInch != pilsobj->lsdevres.dypInch)
			pilsobj->MagicConstantY = LsLwMultDivR(pilsobj->lsdevres.dypInch, 1 << 21, pilsobj->lsdevres.dyrInch);
			pilsobj->durRightMaxY = min(1 << 21, (0x7FFFFFFF - (1 << 20)) / pilsobj->MagicConstantY);
		}


	return lserrNone;
}

/* S E T  T E X T   B R E A K I N G */
/*----------------------------------------------------------------------------
    %%Function: SetTextBreaking
    %%Contact: sergeyge

	Initialization on the doc level
	Called when the breaking table should be installed or changed
----------------------------------------------------------------------------*/
LSERR SetTextBreaking(PILSOBJ pilsobj, DWORD clsbrk, const LSBRK* rglsbrk,
														 DWORD cBreakingClasses, const BYTE* rgibrk)
{
	DWORD i;

	if (pilsobj->cBreakingClasses < cBreakingClasses)
		{
		if (pilsobj->cBreakingClasses > 0)
			{
			Assert(pilsobj->pilsbrk != NULL);
			
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->pilsbrk);
			pilsobj->pilsbrk = NULL;
			pilsobj->cBreakingClasses = 0;
			}

		pilsobj->pilsbrk = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols,
										sizeof(BYTE) * cBreakingClasses * cBreakingClasses);
		if ( pilsobj->pilsbrk == NULL)
			{
			return lserrOutOfMemory;
			}

		pilsobj->cBreakingClasses = cBreakingClasses;
			
		}

	if (pilsobj->clsbrk < clsbrk)
		{
		if (pilsobj->clsbrk > 0)
			{
			Assert(pilsobj->plsbrk != NULL);
			
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->plsbrk);
			pilsobj->plsbrk = NULL;
			pilsobj->clsbrk = 0;
			}

		pilsobj->plsbrk = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(LSBRK) * clsbrk);
		if ( pilsobj->plsbrk == NULL)
			{
			return lserrOutOfMemory;
			}

		pilsobj->clsbrk = clsbrk;

		}

	memcpy(pilsobj->plsbrk, rglsbrk, sizeof(LSBRK) * clsbrk);
	memcpy(pilsobj->pilsbrk, rgibrk, sizeof(BYTE) * cBreakingClasses * cBreakingClasses);

	for (i = 0; i < cBreakingClasses * cBreakingClasses; i++)
		{
		if (rgibrk[i] >= clsbrk)
			{
			Assert(fFalse);
			return lserrInvalidParameter;  /* REVIEW sergeyge: another error code? */
			}
		}

	return lserrNone;
}

/* S E T  T E X T  M O D  W I D T H  P A I R S */
/*----------------------------------------------------------------------------
    %%Function: SetTextModWidthPairs
    %%Contact: sergeyge

	Initialization on the doc level
	Called when the ModWidthPairs table should be installed or changed
----------------------------------------------------------------------------*/
LSERR SetTextModWidthPairs(PILSOBJ pilsobj,	DWORD clspairact, const LSPAIRACT* rglspairact,
									DWORD cModWidthClasses, const BYTE* rgipairact)
{
	DWORD i;
	
	CkeckModWidthClasses(pilsobj, cModWidthClasses);

	if (pilsobj->pilspairact == NULL)
		{
		pilsobj->pilspairact = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols,
									sizeof(BYTE) * cModWidthClasses * cModWidthClasses);
		if ( pilsobj->pilspairact == NULL)
			{
			return lserrOutOfMemory;
			}
		}

	if (pilsobj->clspairact < clspairact)
		{
		if (pilsobj->clspairact > 0)
			{
			Assert(pilsobj->plspairact != NULL);
			
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->plspairact);
			pilsobj->plspairact = NULL;
			pilsobj->clspairact = 0;
			}

		pilsobj->plspairact = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(LSPAIRACT) * clspairact);
		if ( pilsobj->plspairact == NULL)
			{
			return lserrOutOfMemory;
			}

		pilsobj->clspairact = clspairact;
		}

	memcpy(pilsobj->plspairact, rglspairact, sizeof(LSPAIRACT) * clspairact);
	memcpy(pilsobj->pilspairact, rgipairact, sizeof(BYTE) * cModWidthClasses * cModWidthClasses);

	for (i = 0; i < cModWidthClasses * cModWidthClasses; i++)
		{
		if (rgipairact[i] >= clspairact)
			{
			Assert(fFalse);
			return lserrInvalidParameter;  /* REVIEW sergeyge: another error code? */
			}
		}

	return lserrNone;

}

/* S E T  T E X T  C O M P R E S S I O N */
/*----------------------------------------------------------------------------
    %%Function: SetTextCompression
    %%Contact: sergeyge

	Initialization on the doc level
	Called when the Compression table should be installed or changed
----------------------------------------------------------------------------*/
LSERR SetTextCompression(PILSOBJ pilsobj, DWORD cCompPrior, DWORD clspract, const LSPRACT* rglspract,
									DWORD cModWidthClasses, const BYTE* rgipract)
{
	DWORD i;
	
	CkeckModWidthClasses(pilsobj, cModWidthClasses);

	if (pilsobj->pilspract == NULL)
		{
		pilsobj->pilspract = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols,
									sizeof(BYTE) * cModWidthClasses);
		if ( pilsobj->pilspract == NULL)
			{
			return lserrOutOfMemory;
			}
		}

	if (pilsobj->clspract < clspract)
		{
		if (pilsobj->clspract > 0)
			{
			Assert(pilsobj->plspract != NULL);
			
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->plspract);
			pilsobj->plspract = NULL;
			pilsobj->clspract = 0;
			}

		pilsobj->plspract = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(LSPRACT) * clspract);
		if ( pilsobj->plspract == NULL)
			{
			return lserrOutOfMemory;
			}

		pilsobj->clspract = clspract;
		}

	pilsobj->cCompPrior = cCompPrior;

	memcpy(pilsobj->plspract, rglspract, sizeof(LSPRACT) * clspract);
	memcpy(pilsobj->pilspract, rgipract, sizeof(BYTE) * cModWidthClasses);

	for (i = 0; i < cModWidthClasses; i++)
		{
		if (rgipract[i] >= clspract)
			{
			Assert(fFalse);
			return lserrInvalidParameter;  /* REVIEW sergeyge: another error code? */
			}
		}

	return lserrNone;

}

/* S E T  T E X T  E X P A N S I O N */
/*----------------------------------------------------------------------------
    %%Function: SetTextExpansion
    %%Contact: sergeyge

	Initialization on the doc level
	Called when the Expansion table should be installed or changed
----------------------------------------------------------------------------*/
LSERR SetTextExpansion(PILSOBJ pilsobj,	DWORD clsexpan, const LSEXPAN* rglsexpan,
									DWORD cModWidthClasses, const BYTE* rgiexpan)
{
	DWORD i;
	
	CkeckModWidthClasses(pilsobj, cModWidthClasses);

	if (pilsobj->pilsexpan == NULL)
		{
		pilsobj->pilsexpan = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols,
									sizeof(BYTE) * cModWidthClasses * cModWidthClasses);
		if ( pilsobj->pilsexpan == NULL)
			{
			return lserrOutOfMemory;
			}
		}

	if (pilsobj->clsexpan < clsexpan)
		{
		if (pilsobj->clsexpan > 0)
			{
			Assert(pilsobj->plsexpan != NULL);
			
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->plsexpan);
			pilsobj->plsexpan = NULL;
			pilsobj->clsexpan = 0;
			}

		pilsobj->plsexpan = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(LSEXPAN) * clsexpan);
		if ( pilsobj->plsexpan == NULL)
			{
			return lserrOutOfMemory;
			}

		pilsobj->clsexpan = clsexpan;
		}

	memcpy(pilsobj->plsexpan, rglsexpan, sizeof(LSEXPAN) * clsexpan);
	memcpy(pilsobj->pilsexpan, rgiexpan, sizeof(BYTE) * cModWidthClasses * cModWidthClasses);

	for (i = 0; i < cModWidthClasses * cModWidthClasses; i++)
		{
		if (rgiexpan[i] >= clsexpan)
			{
			Assert(fFalse);
			return lserrInvalidParameter;  /* REVIEW sergeyge: another error code? */
			}
		}

	return lserrNone;

}

/* S E T  T E X T  L I N E  P A R A M S */
/*----------------------------------------------------------------------------
    %%Function: SetTextLineParams
    %%Contact: sergeyge

	Initialization at the beginning of the line
	with the text specific parameters.
----------------------------------------------------------------------------*/
LSERR SetTextLineParams(PLNOBJ plnobj, const TLPR* ptlpr)
{
	PILSOBJ pilsobj;

	pilsobj = plnobj->pilsobj;

	pilsobj->grpf = ptlpr->grpfText;
	pilsobj->fSnapGrid = ptlpr->fSnapGrid;
	pilsobj->duaHyphenationZone = ptlpr->duaHyphenationZone;

	pilsobj->lskeop = ptlpr->lskeop;

	plnobj->fDrawInCharCodes = pilsobj->grpf & fTxtDrawInCharCodes;

	if ( (pilsobj->grpf & fTxtApplyBreakingRules) && pilsobj->pilsbrk == NULL)
		return lserrBreakingTableNotSet;


	return lserrNone;
}

/* M O D I F Y  T E X T  L I N E  E N D I N G */
/*----------------------------------------------------------------------------
    %%Function: ModifyTextLineEnding
    %%Contact: sergeyge

	Modifies line ending information when text vanishes across paragraph boundary
----------------------------------------------------------------------------*/
LSERR ModifyTextLineEnding(PLNOBJ plnobj, LSKEOP lskeop)
{

	plnobj->pilsobj->lskeop = lskeop;

	return lserrNone;
}



/*  S E T  T E X T  C O N F I G */
/*----------------------------------------------------------------------------
    %%Function: SetTextConfig
    %%Contact: sergeyge

	Sets special characters in the ilsobj
----------------------------------------------------------------------------*/
LSERR SetTextConfig(PILSOBJ pilsobj, const LSTXTCFG* plstxtcfg)
{
	LSERR lserr;
	WCHAR wchUndef;

	wchUndef = plstxtcfg->wchUndef; 

	pilsobj->wchVisiNull = plstxtcfg->wchVisiNull;
	pilsobj->wchVisiEndPara = plstxtcfg->wchVisiEndPara;
	pilsobj->wchVisiAltEndPara = plstxtcfg->wchVisiAltEndPara;
	pilsobj->wchVisiEndLineInPara = plstxtcfg->wchVisiEndLineInPara;
	pilsobj->wchVisiSpace = plstxtcfg->wchVisiSpace;
	pilsobj->wchVisiNonBreakSpace = plstxtcfg->wchVisiNonBreakSpace;
	pilsobj->wchVisiNonBreakHyphen = plstxtcfg->wchVisiNonBreakHyphen;
	pilsobj->wchVisiNonReqHyphen = plstxtcfg->wchVisiNonReqHyphen;
	pilsobj->wchVisiTab = plstxtcfg->wchVisiTab;
	pilsobj->wchVisiEmSpace = plstxtcfg->wchVisiEmSpace;
	pilsobj->wchVisiEnSpace = plstxtcfg->wchVisiEnSpace;
	pilsobj->wchVisiNarrowSpace = plstxtcfg->wchVisiNarrowSpace;
	pilsobj->wchVisiOptBreak = plstxtcfg->wchVisiOptBreak;
	pilsobj->wchVisiNoBreak = plstxtcfg->wchVisiNoBreak;
	pilsobj->wchVisiFESpace = plstxtcfg->wchVisiFESpace;

	Assert(0 == clabRegular);
	Assert(pilsobj->wchVisiEndPara != wchUndef);
	Assert(pilsobj->wchVisiAltEndPara != wchUndef);
	Assert(pilsobj->wchVisiEndLineInPara != wchUndef);

	pilsobj->wchSpace = plstxtcfg->wchSpace;
	pilsobj->wchHyphen = plstxtcfg->wchHyphen;
	pilsobj->wchReplace = plstxtcfg->wchReplace;
	pilsobj->wchNonBreakSpace = plstxtcfg->wchNonBreakSpace;

	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchNull, clabNull, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchSpace, clabSpace, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchHyphen, clabHardHyphen, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchTab, clabTab, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchEndPara1, clabEOP1, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchEndPara2, clabEOP2, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchAltEndPara, clabAltEOP, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchEndLineInPara, clabEndLineInPara, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchColumnBreak, clabColumnBreak, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchSectionBreak, clabSectionBreak, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchPageBreak, clabPageBreak, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchNonBreakSpace, clabNonBreakSpace, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchNonBreakHyphen, clabNonBreakHyphen, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchNonReqHyphen, clabNonReqHyphen, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchEmDash, clabHardHyphen, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchEnDash, clabHardHyphen, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchEnSpace, clabEnSpace, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchEmSpace, clabEmSpace, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchNarrowSpace, clabNarrowSpace, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchOptBreak, clabOptBreak, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchNoBreak, clabNonBreak, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchFESpace, clabFESpace, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchJoiner, clabJoiner, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchNonJoiner, clabNonJoiner, wchUndef);
	if (lserr != lserrNone) return lserr;
	lserr = TxtAddSpec(pilsobj, plstxtcfg->wchToReplace, clabToReplace, wchUndef);
	if (lserr != lserrNone) return lserr;

	lserr = TxtSortSpec( pilsobj->rgwchSpec, pilsobj->rgbKind, pilsobj->cwchSpec);
	if (lserr != lserrNone) return lserr;

	Assert(pilsobj->pwchOrig == NULL && pilsobj->pdur == NULL && pilsobj->pwSpaces == NULL);

	pilsobj->wchMax = plstxtcfg->cEstimatedCharsPerLine;
	pilsobj->pwchOrig = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(WCHAR) * pilsobj->wchMax );
	pilsobj->pdur = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(long) * pilsobj->wchMax );
	pilsobj->pwSpaces = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(long) * wSpacesMaxM);
	pilsobj->pbreakinf = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(BREAKINFO) * 3);
			/* One for Prev/Next/Force Break for main subline */

	if (pilsobj->pwchOrig == NULL || pilsobj->pdur == NULL || pilsobj->pwSpaces == NULL ||
																	pilsobj->pbreakinf == NULL)
		{
		return lserrOutOfMemory;
		}

	pilsobj->wSpacesMax = wSpacesMaxM;
	pilsobj->breakinfMax = 3;
	pilsobj->breakinfMac = 3;

	/* be careful---CreateLNObjText makes pilsobj->plnobj = NULL,
		if pilsobj->plnobj is not NULL
	 */
	Assert(pilsobj->plnobj == NULL);

	lserr = CreateLNObjText(pilsobj, &pilsobj->plnobj);

	return lserr;
}

/* Internal Functions Implementation */


/*----------------------------------------------------------------------------
    %%Function: ErrorLNObjText
    %%Contact: sergeyge

----------------------------------------------------------------------------*/
static LSERR ErrorLNObjText(PLNOBJ* pplnobj, LSERR lserr)
{
	DestroyLNObjTextCore(*pplnobj);
	*pplnobj = NULL;
	
	return lserr;
}

/*----------------------------------------------------------------------------
    %%Function: DestroyLNObjTextCore
    %%Contact: sergeyge

----------------------------------------------------------------------------*/
static void DestroyLNObjTextCore(PLNOBJ plnobj)
{
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	PTXTOBJ ptxtobjNext;

	pilsobj = plnobj->pilsobj;

	ptxtobj = plnobj->ptxtobjFirst;
	while ( ptxtobj != NULL )
		{
		ptxtobjNext = *(TXTOBJ**)(ptxtobj + txtobjMaxM);
		(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, ptxtobj);
		ptxtobj = ptxtobjNext;
		}		

	plnobj->ptxtobjFirst = NULL;

	if ( plnobj->pwch != NULL )
		{
		(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, plnobj->pwch);
		plnobj->pwch = NULL;
		}		
	if ( plnobj->pdup != NULL )
		{
		(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, plnobj->pdup);
		plnobj->pdup = NULL;
		}
	if ( plnobj->pdupPenAlloc != NULL )
		{
		(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, plnobj->pdupPenAlloc);
		plnobj->pdupPenAlloc = NULL;
		}

	if ( plnobj->pgind != NULL )
		{
		(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, plnobj->pgind);
		plnobj->pgind = NULL;
		}
	if ( plnobj->pdupGind != NULL )
		{
		(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, plnobj->pdupGind);
		plnobj->pdupGind = NULL;
		}
	if ( plnobj->pgoffs != NULL )
		{
		(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, plnobj->pgoffs);
		plnobj->pgoffs = NULL;
		}
	if ( plnobj->pexpt != NULL )
		{
		(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, plnobj->pexpt);
		plnobj->pexpt = NULL;
		}
	if ( plnobj->pdupBeforeJust != NULL )
		{
		(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, plnobj->pdupBeforeJust);
		plnobj->pdupBeforeJust = NULL;
		}
	if ( plnobj->pgprop != NULL )
		{
		(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, plnobj->pgprop);
		plnobj->pgprop = NULL;
		}
	if ( plnobj->pgmap != NULL )
		{
		(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, plnobj->pgmap);
		plnobj->pgmap = NULL;
		}

	(*pilsobj->plscbk->pfnDisposePtr) (pilsobj->pols, plnobj);

	return;
}

/* C H E C K  C  M O D  W I D T H  C L A S S E S */
/*----------------------------------------------------------------------------
    %%Function: CheckCModWidthClasses
    %%Contact: sergeyge

	Checks that new cModWidthClasses does not contradict old one.
	If it does, disposes all relevant arrays
----------------------------------------------------------------------------*/
static void CkeckModWidthClasses(PILSOBJ pilsobj, DWORD cModWidthClasses)
{
	if (pilsobj->cModWidthClasses != cModWidthClasses)
		{
		if (pilsobj->pilspairact != NULL)
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->pilspairact);
			pilsobj->pilspairact = NULL;
			}

		if (pilsobj->pilspract != NULL)
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->pilspract);
			pilsobj->pilspract = NULL;
			}

		if (pilsobj->pilsexpan != NULL)
			{
			(*pilsobj->plscbk->pfnDisposePtr)(pilsobj->pols, pilsobj->pilsexpan);
			pilsobj->pilsexpan = NULL;
			}

		pilsobj->cModWidthClasses = cModWidthClasses;
			
		}

}


/* T X T  A D D  S P E C */
/*----------------------------------------------------------------------------
    %%Function: TxtAddSpec
    %%Contact: sergeyge

	Sets special character in the ilsobj structure

	Strategy:

	if special character (wchSymbol) less than 256,
	set its type in the rgbSwitch[wchSymbol] (there cannot be more then 15 different types)

	if special character is greater than 256,
	set first bit of rgbSwitch[wchSymbol & 0x00FF]
	(it is independent of types of characters < 256 , since these types <= 15);
	also remember character and it's type in 
	rgwchSpec, rgbKind respectively.
----------------------------------------------------------------------------*/
static LSERR TxtAddSpec(PILSOBJ pilsobj, WCHAR wchSymbol, CLABEL clab, WCHAR wchUndef)
{
	CLABEL* rgbSwitch;

	rgbSwitch = pilsobj->rgbSwitch;

	if (wchSymbol == wchUndef)
		{
		return lserrNone;
		}
	if (wchSymbol < 256)
		{
		if ( (rgbSwitch[wchSymbol] & fSpecMask) == 0)
			{
			rgbSwitch[wchSymbol] |= clab;
			}
		else
			{
			Assert(fFalse);
			return lserrDuplicateSpecialCharacter;
			}
		}
	else
		{		
			rgbSwitch[wchSymbol & 0x00FF] |= clabSuspicious;
			pilsobj->rgwchSpec[pilsobj->cwchSpec] = wchSymbol;
			pilsobj->rgbKind[pilsobj->cwchSpec] = clab;
			pilsobj->cwchSpec++;
		}

	return lserrNone;
}

/* T X T  S O R T  S P E C */
/*----------------------------------------------------------------------------
    %%Function: TxtSortSpec
    %%Contact: sergeyge

	Sorts rgwchSpec array (and moves elements of rgbKind appropriately)
	to make search for special chars >= 256 faster.
----------------------------------------------------------------------------*/
static LSERR TxtSortSpec(WCHAR* rgwchSpec, CLABEL* rgbKind, DWORD cwchSpec)
{
	int i, j, iMin;
	WCHAR wchChange;
	CLABEL clabChange;
	BOOL fChanged;

	for (i=0; i < (int)cwchSpec-1; i++)
		{
		iMin = i;
		fChanged = fFalse;
		for (j = i+1; j < (int)cwchSpec; j++)
			{
			if (rgwchSpec[j] < rgwchSpec[iMin])
				{
				fChanged = fTrue;
				iMin = j;
				}
			}
		if (fChanged)
			{
			clabChange = rgbKind[i];
			wchChange = rgwchSpec[i];
			rgbKind[i] = rgbKind[iMin];
			rgwchSpec[i] = rgwchSpec[iMin];
			rgbKind[iMin] = clabChange;
			rgwchSpec[iMin] = wchChange;

			}
		}

	for (i=0; i < (int)cwchSpec-1; i++)
		{
		if (rgwchSpec[i] == rgwchSpec[i+1])
			{
			Assert(fFalse);
			return lserrDuplicateSpecialCharacter;
			}
		}

	return lserrNone;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\lstxtfmt.c ===
#include "lsmem.h"
#include <limits.h>

#include "lstxtfmt.h"
#include "lsstring.h"
#include "lstxtffi.h"
#include "lsdnfin.h"
#include "lsdnfinp.h"
#include "lsdntext.h"
#include "zqfromza.h"
#include "txtobj.h"
#include "lskysr.h"
#include "lschp.h"
#include "fmti.h"
#include "objdim.h"
#include "txtils.h"
#include "txtln.h"
#include "txtobj.h"
#include "txtconst.h"

#define cwchLocalMax 120

/* Internal Functions Prototypes */
static LSERR FormatRegularCharacters(PLNOBJ plnobj, PCFMTIN pfmtin,	FMTRES* pfmtr);
static LSERR CreateFillTextDobj(PLNOBJ plnobj, long txtkind, PCFMTIN pfmtin, BOOL fIgnoreGlyphs, 
																					TXTOBJ** ppdobjText);
static LSERR GetTextDobj(PLNOBJ plnobj, TXTOBJ** ppdobjText);
static LSERR FillRealFmtOut(PILSOBJ pilsobj, LSDCP dcp, long dur, TXTOBJ* pdobjText, PCFMTIN pfmtin,
																				 BOOL fIgnoreHeights);
static LSERR AppendTrailingSpaces(PLNOBJ plnobj, TXTOBJ* pdobjText, WCHAR* rgwchGlobal,
									 long iwchGlobal, long cwchGlobal,
									 long* iwchGlobalNew, long* pddur);
static LSERR FormatStartEmptyDobj(PLNOBJ plnobj, PCFMTIN pfmtin, long txtkind, DWORD fTxtVisi, 
																		WCHAR wchVisi, FMTRES* pfmtr);
static LSERR FormatStartTab(PLNOBJ plnobj, PCFMTIN pfmtin, FMTRES* pfmtr);
static LSERR FormatStartOneRegularChar(PLNOBJ plnobj, PCFMTIN pfmtin, long txtkind, FMTRES* pfmtr);
static LSERR FormatStartToReplace(PLNOBJ plnobj, PCFMTIN pfmtin, FMTRES* pfmtr);
static LSERR FormatStartEol(PLNOBJ plnobj, PCFMTIN pfmtin, WCHAR wch, STOPRES stopr, FMTRES* pfmtr);
static LSERR FormatStartDelete(PLNOBJ plnobj, LSDCP dcp, FMTRES* pfmtr);
static LSERR FormatStartSplat(PLNOBJ plnobj, PCFMTIN pfmtin, STOPRES stopr, FMTRES* pfmtr);
static LSERR FormatStartBorderedSpaces(PLNOBJ plnobj, PCFMTIN pfmtin, FMTRES* pfmtr);
static LSERR FormatSpecial(PLNOBJ plnobj, WCHAR wchRef, WCHAR wchPres, BOOL fVisible,
															long txtkind, PCFMTIN pfmtin, FMTRES* pfmtr);
static STOPRES StoprHardBreak(CLABEL clab);
static CLABEL ClabFromChar(PILSOBJ pilsobj, WCHAR wch);

/* Export Functions Implementation  */

/* L S  T X T  F M T */
/*----------------------------------------------------------------------------
    %%Function: LsTxtFmt
    %%Contact: sergeyge

    The top-level function of the text formatter.
	It checks for the first character and state
	and redirects the program flow accordingly.
----------------------------------------------------------------------------*/

LSERR WINAPI FmtText(PLNOBJ plnobj, PCFMTIN pfmtin, FMTRES* pfmtr)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	WCHAR wchFirst;
	CLABEL clab;
	BOOL fInChildList;

	pilsobj = plnobj->pilsobj;

	wchFirst = pfmtin->lsfrun.lpwchRun[0];

	clab = pilsobj->rgbSwitch[wchFirst & 0x00FF]; /* REVIEW sergeyge       */
	if (clab != clabRegular)
		{
		clab = ClabFromChar(pilsobj, wchFirst);
		}

	/* check for the YSR-character                                           */
	if (pfmtin->lsfrun.plschp->fHyphen && clab == clabRegular)
		{
		return FormatStartOneRegularChar(plnobj, pfmtin, txtkindYsrChar, pfmtr);
		} 
	else
		{
		switch (clab)
			{
		case clabRegular:
			return FormatRegularCharacters(plnobj, pfmtin, pfmtr);
		case clabSpace:
			if (pfmtin->lsfrun.plschp->fBorder)
				return FormatStartBorderedSpaces(plnobj, pfmtin, pfmtr);
			else
				return FormatRegularCharacters(plnobj, pfmtin, pfmtr);
		case clabEOP1:
			switch (pilsobj->lskeop)
				{
			case lskeopEndPara1:
				return FormatStartEol(plnobj, pfmtin, pilsobj->wchVisiEndPara, stoprEndPara, pfmtr);
			case lskeopEndPara12:
				return FormatStartDelete(plnobj, 1, pfmtr);
			default:
				return FormatStartOneRegularChar(plnobj, pfmtin, txtkindRegular, pfmtr);
				}
		case clabEOP2:
			switch (pilsobj->lskeop)
				{
			case lskeopEndPara2:
			case lskeopEndPara12:
				return FormatStartEol(plnobj, pfmtin, pilsobj->wchVisiEndPara, stoprEndPara, pfmtr);
			default:
				return FormatStartOneRegularChar(plnobj, pfmtin, txtkindRegular, pfmtr);
				}
			break;
		case clabAltEOP:
			switch (pilsobj->lskeop)
				{
			case lskeopEndParaAlt:
				return FormatStartEol(plnobj, pfmtin, pilsobj->wchVisiAltEndPara, stoprAltEndPara, pfmtr);
			default:
				return FormatStartOneRegularChar(plnobj, pfmtin, txtkindRegular, pfmtr);
				}
		case clabEndLineInPara:
			return FormatStartEol(plnobj, pfmtin, pilsobj->wchVisiEndLineInPara, stoprSoftCR, pfmtr);
		case clabTab:
			return FormatStartTab(plnobj, pfmtin, pfmtr);
		case clabNull:
			if (pilsobj->grpf & fTxtVisiSpaces)
				return FormatSpecial(plnobj, wchFirst, pilsobj->wchVisiNull, fTrue, txtkindRegular, pfmtin, pfmtr);		
			else
				return FormatSpecial(plnobj, wchFirst, wchFirst, fFalse, txtkindRegular, pfmtin, pfmtr);		
		case clabNonReqHyphen:
			return FormatStartEmptyDobj(plnobj, pfmtin, txtkindNonReqHyphen, fTxtVisiCondHyphens, 
																	pilsobj->wchVisiNonReqHyphen, pfmtr);
		case clabNonBreakHyphen:
			if (pilsobj->grpf & fTxtVisiCondHyphens)
				return FormatSpecial(plnobj, pilsobj->wchHyphen, pilsobj->wchVisiNonBreakHyphen, fTrue, txtkindNonBreakHyphen, pfmtin, pfmtr);		
			else
				return FormatSpecial(plnobj, pilsobj->wchHyphen, pilsobj->wchHyphen, fFalse, txtkindNonBreakHyphen, pfmtin, pfmtr);		
		case clabNonBreakSpace:
			if (pilsobj->grpf & fTxtVisiSpaces)
				return FormatSpecial(plnobj, pilsobj->wchSpace, pilsobj->wchVisiNonBreakSpace, fTrue, txtkindNonBreakSpace, pfmtin, pfmtr);		
			else
				return FormatSpecial(plnobj, pilsobj->wchSpace, pilsobj->wchSpace, fFalse, txtkindNonBreakSpace, pfmtin, pfmtr);		
		case clabHardHyphen:
			if (pilsobj->grpf & fTxtTreatHyphenAsRegular)
				return FormatSpecial(plnobj, wchFirst, wchFirst, fFalse, txtkindRegular, pfmtin, pfmtr);
			else
				return FormatSpecial(plnobj, wchFirst, wchFirst, fFalse, txtkindHardHyphen, pfmtin, pfmtr);
		case clabSectionBreak:
		case clabColumnBreak:
		case clabPageBreak:
			lserr = LsdnFInChildList(pilsobj->plsc, pfmtin->plsdnTop, &fInChildList);
			if (lserr != lserrNone) return lserr;
			if (fInChildList)
				return FormatStartDelete(plnobj, 1, pfmtr);
			else
				return FormatStartSplat(plnobj, pfmtin, StoprHardBreak(clab), pfmtr);
		case clabEmSpace:
			if (pilsobj->grpf & fTxtVisiSpaces)
				return FormatSpecial(plnobj, wchFirst, pilsobj->wchVisiEmSpace, fTrue, txtkindSpecSpace, pfmtin, pfmtr);		
			else
				return FormatSpecial(plnobj, wchFirst, wchFirst, fFalse, txtkindSpecSpace, pfmtin, pfmtr);		
		case clabEnSpace:
			if (pilsobj->grpf & fTxtVisiSpaces)
				return FormatSpecial(plnobj, wchFirst, pilsobj->wchVisiEnSpace, fTrue, txtkindSpecSpace, pfmtin, pfmtr);		
			else
				return FormatSpecial(plnobj, wchFirst, wchFirst, fFalse, txtkindSpecSpace, pfmtin, pfmtr);		
		case clabNarrowSpace:
			if (pilsobj->grpf & fTxtVisiSpaces)
				return FormatSpecial(plnobj, wchFirst, pilsobj->wchVisiNarrowSpace, fTrue, txtkindSpecSpace, pfmtin, pfmtr);		
			else
				return FormatSpecial(plnobj, wchFirst, wchFirst, fFalse, txtkindSpecSpace, pfmtin, pfmtr);		
		case clabOptBreak:
			return FormatStartEmptyDobj(plnobj, pfmtin, txtkindOptBreak, fTxtVisiBreaks, 
																	pilsobj->wchVisiOptBreak, pfmtr);
		case clabNonBreak:
			return FormatStartEmptyDobj(plnobj, pfmtin, txtkindOptNonBreak, fTxtVisiBreaks, 
																	pilsobj->wchVisiNoBreak, pfmtr);
		case clabFESpace:
			if (pilsobj->grpf & fTxtVisiSpaces)
				return FormatSpecial(plnobj, wchFirst, pilsobj->wchVisiFESpace, fTrue, txtkindSpecSpace, pfmtin, pfmtr);		
			else
				return FormatSpecial(plnobj, wchFirst, wchFirst, fFalse, txtkindSpecSpace, pfmtin, pfmtr);
		case clabJoiner:
		case clabNonJoiner:
			return FormatStartOneRegularChar(plnobj, pfmtin, txtkindRegular, pfmtr);
		case clabToReplace:					/* backslash in FE Word				*/
			return FormatStartToReplace(plnobj, pfmtin, pfmtr);
			}
		}

	return lserrNone;
}

/* L S  D E S T R O Y  T X T  D O B J*/
/*----------------------------------------------------------------------------
    %%Function: LsDestroyTxtDObj
    %%Contact: sergeyge

    DestroyDObj method of the text handler.
----------------------------------------------------------------------------*/
LSERR WINAPI DestroyDObjText(PDOBJ pdobj)
{
	Unreferenced(pdobj);
	return lserrNone;
}

/* L S  S U B L I N E  F I N I S H E D  T E X T */
/*----------------------------------------------------------------------------
    %%Function: LsSublineFinishedText
    %%Contact: sergeyge

    Notification from Manager about finishing the subline
----------------------------------------------------------------------------*/
LSERR LsSublineFinishedText(PLNOBJ plnobj)
{
	Assert(plnobj->pilsobj->wchMac + 2 <= plnobj->pilsobj->wchMax);

	return IncreaseWchMacBy2(plnobj);

}

/* Internal Functions Implementation */

/* F O R M A T  R E G U L A R  C H A R A C T E R S */
/*----------------------------------------------------------------------------
    %%Function: FormatRegularCharacters
    %%Contact: sergeyge

    Formats run starting with the regular character.
	Ends as soon as any special character is encountered or
    right margin is achieved or
	all characters are processed.
----------------------------------------------------------------------------*/
static LSERR FormatRegularCharacters(PLNOBJ plnobj, PCFMTIN pfmtin, FMTRES* pfmtr)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	long cwchGlobal;
	long iwchGlobal;
	long iwchLocal;
	long cwchLocal;
	long iwSpaces;

	long cwchMax;
	LSCP cpFirst;
	long durWidthExceed;
	WCHAR* rgwchGlobal;
	WCHAR* rgwchLocal;
	long rgwSpaces[cwchLocalMax];

	TXTOBJ* pdobjText;
	long durWidth;
	long ddur;
	BOOL fTerminateLoops;
	long dur;
	CLABEL clab;
	CLABEL* rgbSwitch;
	WCHAR wchSpace;
	long iwchGlobalNew;
	BOOL fInSpaces = fFalse;
	int i;
	int idur;

	pilsobj = plnobj->pilsobj;

	lserr = CreateFillTextDobj(plnobj, txtkindRegular, pfmtin, fFalse, &pdobjText);
	if (lserr != lserrNone) return lserr;

	rgbSwitch = pilsobj->rgbSwitch;
	wchSpace = pilsobj->wchSpace;
	rgwchGlobal = (WCHAR*)pfmtin->lsfrun.lpwchRun;
	cwchGlobal = (long)pfmtin->lsfrun.cwchRun;
	iwchGlobal = 0;
	fTerminateLoops = fFalse;
	durWidthExceed = pfmtin->lsfgi.urColumnMax - pfmtin->lsfgi.urPen;

	cpFirst = pfmtin->lsfgi.cpFirst;
	dur = 0;

	while (iwchGlobal < cwchGlobal && !fTerminateLoops)
		{
		rgwchLocal = &rgwchGlobal[iwchGlobal];

		cwchMax = cwchGlobal - iwchGlobal;
		if (cwchMax > cwchLocalMax)
			cwchMax = cwchLocalMax;

		lserr = GetWidths(plnobj, pfmtin->lsfrun.plsrun, pdobjText->iwchLim, rgwchLocal, 
					cpFirst, cwchMax, durWidthExceed, pfmtin->lsfgi.lstflow, &cwchLocal, &durWidth);
		if (lserr != lserrNone) return lserr;

		iwchLocal = 0;
		iwSpaces = 0;		

		while (iwchLocal < cwchLocal /*&& !fTerminateLoops*/)
			{
			if (rgbSwitch[rgwchLocal[iwchLocal] & 0x00FF] == clabRegular)
				iwchLocal++;
			else if (rgwchLocal[iwchLocal] == wchSpace)
				{
				if (!pfmtin->lsfrun.plschp->fBorder)
					{
					rgwSpaces[iwSpaces] = iwchLocal;
					iwchLocal++;
					iwSpaces++;
					}
				else
					{
					fTerminateLoops = fTrue;

					durWidth = 0;
					for (i = 0, idur = pdobjText->iwchLim; i < iwchLocal; i++, idur++)
						durWidth += pilsobj->pdur[idur];
					break; /* This break is equivalent to the check commented out in the loop condition */
					}
				}
			else
				{
				clab = ClabFromChar(pilsobj, rgwchLocal[iwchLocal]);
				
				if (clab == clabRegular)
					{
					iwchLocal++;
					}
				else
					{
					/* Terminate loops (and processing of run) for any special character */
					fTerminateLoops = fTrue;

					durWidth = 0;
					for (i = 0, idur = pdobjText->iwchLim; i < iwchLocal; i++, idur++)
						durWidth += pilsobj->pdur[idur];

					break; /* This break is equivalent to the check commented out in the loop condition */
					}
				}
			}

		if (iwchLocal != 0)
			{

			fInSpaces = fFalse;
	
			lserr = FormatString(plnobj, pdobjText, rgwchLocal, iwchLocal, rgwSpaces, iwSpaces, durWidth);
			if (lserr != lserrNone) return lserr;

			iwchGlobal += iwchLocal;
			durWidthExceed -= durWidth;

			Assert(dur < uLsInfiniteRM); /* We can be sure of it because dur is 0 during first iteration,
											and we check for uLsInfiniteRM in the TrailingSpaces logic */
			Assert(durWidth < uLsInfiniteRM);

			dur += durWidth;

			cpFirst += iwchLocal;
			
			if (cwchLocal == iwchLocal && durWidthExceed < 0)
				{
				if (rgwchLocal[cwchLocal-1] == wchSpace)
					{
					fInSpaces = fTrue;
					if (iwchGlobal < cwchGlobal && pilsobj->wchSpace == rgwchGlobal[iwchGlobal])
						{
						lserr = AppendTrailingSpaces(plnobj, pdobjText, rgwchGlobal,
													(DWORD)iwchGlobal, cwchGlobal, &iwchGlobalNew, &ddur);
						if (lserr != lserrNone) return lserr;

						if (iwchGlobalNew != iwchGlobal)
							{
							cpFirst += (iwchGlobalNew - iwchGlobal);
							iwchGlobal = iwchGlobalNew;

							Assert (ddur <= uLsInfiniteRM - dur);

							if (ddur > uLsInfiniteRM - dur)
								return lserrTooLongParagraph;

							dur += ddur;
							}
						}
					}
				else
					fTerminateLoops = fTrue;
				}

			}  /* if iwchLocal != 0                                      */ 					
	
		}      /* while iwchGlobal < cwchGlobal && !fTerminateLoops       */


	Assert(iwchGlobal == pdobjText->iwchLim - pdobjText->iwchFirst);
	Assert(iwchGlobal > 0);

	lserr = FillRegularPresWidths(plnobj, pfmtin->lsfrun.plsrun, pfmtin->lsfgi.lstflow, pdobjText);
	if (lserr != lserrNone) return lserr;

	if ((pilsobj->grpf & fTxtVisiSpaces) && pfmtin->lsfgi.cpFirst >= 0)
		{
		FixSpaces(plnobj, pdobjText, pilsobj->wchVisiSpace);
		}

	*pfmtr = fmtrCompletedRun;	

	if (durWidthExceed < 0 && !fInSpaces)
		{
	   	*pfmtr = fmtrExceededMargin;
		}

	lserr = FillRealFmtOut(pilsobj, iwchGlobal, dur, pdobjText, pfmtin,
		iwchGlobal == pdobjText->u.reg.iwSpacesLim - pdobjText->u.reg.iwSpacesFirst);

	return lserr;
	
}



/* C R E A T E  F I L L  T E X T  D O B J */
/*----------------------------------------------------------------------------
    %%Function: CreateFillTextDobj
    %%Contact: sergeyge

	Requests pointer to the new text DObj and then fills common memebers
----------------------------------------------------------------------------*/
static LSERR CreateFillTextDobj(PLNOBJ plnobj, long txtkind, PCFMTIN pfmtin, BOOL fIgnoreGlyphs,
																				TXTOBJ** ppdobjText)
{
	LSERR lserr;
	PILSOBJ pilsobj;

	pilsobj = plnobj->pilsobj;

	lserr = GetTextDobj(plnobj, ppdobjText);
	if (lserr != lserrNone) return lserr;

	(*ppdobjText)->txtkind = (BYTE)txtkind;
	(*ppdobjText)->plnobj = plnobj;
	(*ppdobjText)->plsdnUpNode = pfmtin->plsdnTop;

	if (pfmtin->lstxmPres.fMonospaced)
		(*ppdobjText)->txtf |= txtfMonospaced;

	(*ppdobjText)->iwchFirst = pilsobj->wchMac;
	(*ppdobjText)->iwchLim = pilsobj->wchMac;
	

	if (txtkind == txtkindRegular)
		{
		(*ppdobjText)->u.reg.iwSpacesFirst = pilsobj->wSpacesMac;
		(*ppdobjText)->u.reg.iwSpacesLim = pilsobj->wSpacesMac;
		}
	
	if (!fIgnoreGlyphs && pfmtin->lsfrun.plschp->fGlyphBased)
		(*ppdobjText)->txtf |= txtfGlyphBased;
	

	return lserrNone;
}

/* G E T  T E X T  D O B J */
/*----------------------------------------------------------------------------
    %%Function: GetTextDobj
    %%Contact: sergeyge

	Produces pointer of the first unoccupied DObj from the preallocated chunk.
	If nothing is left, allocates next piece and includes it in the linked list.
----------------------------------------------------------------------------*/
static LSERR GetTextDobj(PLNOBJ plnobj, TXTOBJ** ppdobjText)
{
	PILSOBJ pilsobj;
	TXTOBJ* ptxtobj;

	pilsobj = plnobj->pilsobj;

	if (pilsobj->txtobjMac < txtobjMaxM)
		{
		*ppdobjText = &plnobj->ptxtobj[pilsobj->txtobjMac];
		pilsobj->txtobjMac++;
		}
	else
		{
		/* if nothing is left in the active piece, there are still two possibilities:
			either there is next preallocated (during the formatting of the previous lines piece
			or next piece should be allocated
		*/
		if ( *(TXTOBJ**)(plnobj->ptxtobj + txtobjMaxM) == NULL)
			{
			ptxtobj = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(TXTOBJ) * txtobjMaxM + sizeof(TXTOBJ**));
			if (ptxtobj == NULL)
				{
				return lserrOutOfMemory;
				}
			*(TXTOBJ**)(ptxtobj + txtobjMaxM) = NULL;
			*(TXTOBJ**)(plnobj->ptxtobj + txtobjMaxM) = ptxtobj;
			plnobj->ptxtobj = ptxtobj;
			}
		else
			{
			plnobj->ptxtobj = *(TXTOBJ**)(plnobj->ptxtobj + txtobjMaxM);
			}
  		*ppdobjText = plnobj->ptxtobj;
  		pilsobj->txtobjMac = 1;
		}

	memset(*ppdobjText, 0, sizeof(**ppdobjText));

	return lserrNone;
}


/* F I L L  R E A L  F M T  O U T */
/*----------------------------------------------------------------------------
    %%Function: FillRealFmtOut
    %%Contact: sergeyge

	Sets dup in dobj and
	calls to LsdnFinishSimpleRegular for the regular case (real upper node)
----------------------------------------------------------------------------*/

static LSERR FillRealFmtOut(PILSOBJ pilsobj, LSDCP lsdcp, long dur, TXTOBJ* pdobjText, PCFMTIN pfmtin,
																						 BOOL fSpacesOnly)
{
	LSERR lserr;
	OBJDIM objdim;

	objdim.dur = dur;

	objdim.heightsPres.dvAscent = pfmtin->lstxmPres.dvAscent;
	objdim.heightsRef.dvAscent = pfmtin->lstxmRef.dvAscent;
	objdim.heightsPres.dvDescent = pfmtin->lstxmPres.dvDescent;
	objdim.heightsRef.dvDescent = pfmtin->lstxmRef.dvDescent;
	objdim.heightsPres.dvMultiLineHeight = pfmtin->lstxmPres.dvMultiLineHeight;
	objdim.heightsRef.dvMultiLineHeight = pfmtin->lstxmRef.dvMultiLineHeight;

	if (fSpacesOnly)
		{
		if (!(pilsobj->grpf & fTxtSpacesInfluenceHeight))
			{
			objdim.heightsRef.dvMultiLineHeight = dvHeightIgnore;
			objdim.heightsPres.dvMultiLineHeight = dvHeightIgnore;
			}
		}


	/* It is ugly to set part of FetchedWidth state here, but it is absolutely needed
		to fix bug 546. iwchFetchedWidthFirst was introduced to fix this bug
	*/
	if (lsdcp < pfmtin->lsfrun.cwchRun)
		pilsobj->wchFetchedWidthFirst = pfmtin->lsfrun.lpwchRun[lsdcp];
	else
		FlushStringState(pilsobj);  /* Next char is not available---it is risky to use optimization */

	lserr = LsdnFinishRegular(pilsobj->plsc, lsdcp,
							pfmtin->lsfrun.plsrun, pfmtin->lsfrun.plschp, (PDOBJ)pdobjText, &objdim);
	return lserr;	
}


/* A P P E N D  T R A I L I N G  S P A C E S */
/*----------------------------------------------------------------------------
    %%Function: AppendTrailingSpaces
    %%Contact: sergeyge

	Trailing spaces logic.
----------------------------------------------------------------------------*/
static LSERR AppendTrailingSpaces(PLNOBJ plnobj, TXTOBJ* pdobjText, WCHAR* rgwchGlobal,
									 long iwchGlobal, long cwchGlobal,
									 long* iwchGlobalNew, long* pddur)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	long iNumOfSpaces;
	long durSpace;

	pilsobj = plnobj->pilsobj;

	Assert(iwchGlobal < cwchGlobal && pilsobj->wchSpace == rgwchGlobal[iwchGlobal]);

	iNumOfSpaces = 1;
	iwchGlobal++;

	while (iwchGlobal < cwchGlobal && pilsobj->wchSpace == rgwchGlobal[iwchGlobal])
		{
		iNumOfSpaces++;
		iwchGlobal++;
		}

	*iwchGlobalNew = iwchGlobal;

	Assert(pilsobj->pwchOrig[pdobjText->iwchLim - 1] == pilsobj->wchSpace);

	durSpace = pilsobj->pdur[pdobjText->iwchLim - 1];

	Assert (iNumOfSpaces > 0);
	Assert(durSpace <= uLsInfiniteRM / iNumOfSpaces);

	if (durSpace > uLsInfiniteRM / iNumOfSpaces)
		return lserrTooLongParagraph;

	*pddur = durSpace * iNumOfSpaces;

	/* Calls function of the string module level */
	lserr = AddSpaces(plnobj, pdobjText, durSpace, iNumOfSpaces);

	return lserr;
}

/* F O R M A T  S T A R T  E M P T Y  D O B J */
/*----------------------------------------------------------------------------
    %%Function: FormatStartEmptyDobj
    %%Contact: sergeyge

	NonReqHyphen/OptionalBreak/OptionalNonBreak logic
----------------------------------------------------------------------------*/
static LSERR FormatStartEmptyDobj(PLNOBJ plnobj, PCFMTIN pfmtin, long txtkind, DWORD fTxtVisi,
																		WCHAR wchVisi, FMTRES* pfmtr)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	TXTOBJ* pdobjText;
	PLSRUN plsrun;
	long dup;
/*	long durOut = 0; */

	pilsobj = plnobj->pilsobj;
	plsrun = pfmtin->lsfrun.plsrun;

	lserr = CreateFillTextDobj(plnobj, txtkind, pfmtin, fTrue, &pdobjText);
	if (lserr != lserrNone) return lserr;

	pdobjText->txtf |= txtfSkipAtNti;
	pilsobj->fDifficultForAdjust = fTrue;

	if (pilsobj->grpf & fTxtVisi)
		{
		Assert(pilsobj->fDisplay);

		/* Imitate formatting for 1-char string without writing in the string level structures */	
/*		lserr = GetOneCharDur(pilsobj, plsrun, pilsobj->wchHyphen, pfmtin->lsfgi.lstflow, &durOut);
		if (lserr != lserrNone) return lserr;
*/
		pdobjText->txtf |= txtfSkipAtWysi;
		pdobjText->txtf |= txtfVisi;

		lserr = GetVisiCharDup(pilsobj, plsrun, wchVisi, pfmtin->lsfgi.lstflow, &dup);
		if (lserr != lserrNone) return lserr;

/*	Restore this code instead of current one if Word wants to keep differences in breaking

		lserr = AddCharacterWithWidth(plnobj, pdobjText, pilsobj->wchHyphen, durOut, wchVisi, dup);
	   	if (lserr != lserrNone) return lserr;

		lserr = FillRealFmtOut(pilsobj, 1, durOut, pdobjText, pfmtin, fFalse);
	   	if (lserr != lserrNone) return lserr;
*/
		lserr = AddCharacterWithWidth(plnobj, pdobjText, pilsobj->wchHyphen, 0, wchVisi, dup);
	   	if (lserr != lserrNone) return lserr;

		lserr = FillRealFmtOut(pilsobj, 1, 0, pdobjText, pfmtin, fTrue);
	   	if (lserr != lserrNone) return lserr;
		}
	else
		{
		lserr = FillRealFmtOut(pilsobj, 1, 0, pdobjText, pfmtin, fTrue);
	   	if (lserr != lserrNone) return lserr;
		FlushStringState(pilsobj);  /* Position of fetched widths is not correct any longer */
		}

	*pfmtr = fmtrCompletedRun;	

	return lserrNone;
}

/* F O R M A T  S T A R T  T A B  */
/*----------------------------------------------------------------------------
    %%Function: FormatStartTab
    %%Contact: sergeyge

	Tab logic
----------------------------------------------------------------------------*/
static LSERR FormatStartTab(PLNOBJ plnobj, PCFMTIN pfmtin, FMTRES* pfmtr)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PTXTOBJ pdobjText;
	int durJunk;
	long cJunk;

	pilsobj = plnobj->pilsobj;

	lserr = CreateFillTextDobj(plnobj, txtkindTab, pfmtin, fTrue, &pdobjText);
	if (lserr != lserrNone) return lserr;

	pdobjText->u.tab.wchTabLeader = pilsobj->wchSpace;

	if (pilsobj->grpf & fTxtVisiTabs)
		{
		Assert(pilsobj->fDisplay);
		pdobjText->txtf |= txtfVisi;
		/* REVIEW sergeyge: Next call is made to show Visi Tab correctly in WORD
			it should be moved to the WAL */
		(*pilsobj->plscbk->pfnGetRunCharWidths)(pilsobj->pols, pfmtin->lsfrun.plsrun,
					lsdevPres, &pilsobj->wchVisiTab, 1, LONG_MAX, pfmtin->lsfgi.lstflow,
					&durJunk, (long*)&durJunk, &cJunk);
		pdobjText->u.tab.wch = 	pilsobj->wchVisiTab;
		}
	else
		{
		pdobjText->u.tab.wch = 	pfmtin->lsfrun.lpwchRun[0];
		}

	lserr = AddCharacterWithWidth(plnobj, pdobjText, pfmtin->lsfrun.lpwchRun[0], 0, 
															pfmtin->lsfrun.lpwchRun[0], 0);
   	if (lserr != lserrNone) return lserr;

	lserr = FillRealFmtOut(pilsobj, 1, 0, pdobjText, pfmtin, fTrue);
   	if (lserr != lserrNone) return lserr;

	*pfmtr = fmtrTab;

	return lserrNone;
}

/* F O R M A T  S T A R T  B O R D E R E D  S P A C E S */
/*----------------------------------------------------------------------------
    %%Function: FormatStartBorderedSpaces
    %%Contact: sergeyge

	Formatting od the spaces within bordered run
----------------------------------------------------------------------------*/
static LSERR FormatStartBorderedSpaces(PLNOBJ plnobj, PCFMTIN pfmtin, FMTRES* pfmtr)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	TXTOBJ* pdobjText;
	long durSpace;
	DWORD iNumOfSpaces;

	pilsobj = plnobj->pilsobj;

	lserr = CreateFillTextDobj(plnobj, txtkindRegular, pfmtin, fFalse, &pdobjText);
	if (lserr != lserrNone) return lserr;

	Assert(pfmtin->lsfrun.lpwchRun[0] == pilsobj->wchSpace);

	/* fill additional information for txtkindYsrChar text DObj */
	lserr = GetOneCharDur(pilsobj, pfmtin->lsfrun.plsrun, pilsobj->wchSpace, pfmtin->lsfgi.lstflow, &durSpace);
	if (lserr != lserrNone) return lserr;

	iNumOfSpaces = 0;

	while (pilsobj->wchSpace == pfmtin->lsfrun.lpwchRun[iNumOfSpaces] && iNumOfSpaces < pfmtin->lsfrun.cwchRun)
		{
		iNumOfSpaces++;
		}

	/* Calls functions of the string module level */
	lserr = AddSpaces(plnobj, pdobjText, durSpace, iNumOfSpaces);
	if (lserr != lserrNone) return lserr;

	lserr = FillRegularPresWidths(plnobj, pfmtin->lsfrun.plsrun, pfmtin->lsfgi.lstflow, pdobjText);
	if (lserr != lserrNone) return lserr;

	if ((pilsobj->grpf & fTxtVisiSpaces) && pfmtin->lsfgi.cpFirst >= 0)
		{
		FixSpaces(plnobj, pdobjText, pilsobj->wchVisiSpace);
		}


	*pfmtr = fmtrCompletedRun;	

	lserr = FillRealFmtOut(pilsobj, iNumOfSpaces, durSpace * iNumOfSpaces, pdobjText,  pfmtin, fTrue);
	if (lserr != lserrNone) return lserr;

	return lserrNone;
}


/* F O R M A T  S T A R T  O N E  R E G U L A R  C H A R  */
/*----------------------------------------------------------------------------
    %%Function: FormatStartOneRegularChar
    %%Contact: sergeyge

	YSR/(NonSignificant for this paragraph EOP) character logic.
----------------------------------------------------------------------------*/
static LSERR FormatStartOneRegularChar(PLNOBJ plnobj, PCFMTIN pfmtin, long txtkind, FMTRES* pfmtr)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	TXTOBJ* pdobjText;
	long durOut;
	long dupOut;
	WCHAR wch;

	pilsobj = plnobj->pilsobj;

	lserr = CreateFillTextDobj(plnobj, txtkind, pfmtin, fFalse, &pdobjText);
	if (lserr != lserrNone) return lserr;

	wch = pfmtin->lsfrun.lpwchRun[0];

	/* fill additional information for txtkindYsrChar text DObj */
	lserr = GetOneCharDur(pilsobj, pfmtin->lsfrun.plsrun, wch, pfmtin->lsfgi.lstflow, &durOut);
	if (lserr != lserrNone) return lserr;

	lserr = GetOneCharDup(pilsobj, pfmtin->lsfrun.plsrun, wch, pfmtin->lsfgi.lstflow, durOut, &dupOut);
	if (lserr != lserrNone) return lserr;

	Assert(durOut < uLsInfiniteRM);

	lserr = AddCharacterWithWidth(plnobj, pdobjText, wch, durOut, wch, dupOut);

	*pfmtr = fmtrCompletedRun;	

	if (durOut > pfmtin->lsfgi.urColumnMax - pfmtin->lsfgi.urPen)
		{
	   	*pfmtr = fmtrExceededMargin;
		}

	lserr = FillRealFmtOut(pilsobj, 1, durOut, pdobjText,  pfmtin, fFalse);
	if (lserr != lserrNone) return lserr;

	return lserrNone;
}

/* F O R M A T  S T A R T  T O  R E P L A C E  */
/*----------------------------------------------------------------------------
    %%Function: FormatStartToReplace
    %%Contact: sergeyge

	Implements replacement of one char code ("\") by another (Yen)
----------------------------------------------------------------------------*/
static LSERR FormatStartToReplace(PLNOBJ plnobj, PCFMTIN pfmtin, FMTRES* pfmtr)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	TXTOBJ* pdobjText;
	WCHAR wch;
	long durOut;
	long dupOut;

	pilsobj = plnobj->pilsobj;

	lserr = CreateFillTextDobj(plnobj, txtkindRegular, pfmtin, fFalse, &pdobjText);
	if (lserr != lserrNone) return lserr;

	/* fill additional information for txtkindYsrChar text DObj */

	if (pfmtin->lsfrun.plschp->fCheckForReplaceChar)
		wch = pilsobj->wchReplace;
	else
		wch = pfmtin->lsfrun.lpwchRun[0];

	lserr = GetOneCharDur(pilsobj, pfmtin->lsfrun.plsrun, wch, pfmtin->lsfgi.lstflow, &durOut);
	if (lserr != lserrNone) return lserr;

	lserr = GetOneCharDup(pilsobj, pfmtin->lsfrun.plsrun, wch, pfmtin->lsfgi.lstflow, durOut, &dupOut);
	if (lserr != lserrNone) return lserr;

	Assert(durOut < uLsInfiniteRM);

	lserr = AddCharacterWithWidth(plnobj, pdobjText, wch, durOut, wch, dupOut);

	*pfmtr = fmtrCompletedRun;	

	if (durOut > pfmtin->lsfgi.urColumnMax - pfmtin->lsfgi.urPen)
		{
	   	*pfmtr = fmtrExceededMargin;
		}

	lserr = FillRealFmtOut(pilsobj, 1, durOut, pdobjText,  pfmtin, fFalse);
	if (lserr != lserrNone) return lserr;

	return lserrNone;
}


/* F O R M A T  S T A R T  E O L  */
/*----------------------------------------------------------------------------
    %%Function: FormatStartEop
    %%Contact: sergeyge

	EOP/SoftCR logic.
----------------------------------------------------------------------------*/
static LSERR FormatStartEol(PLNOBJ plnobj, PCFMTIN pfmtin, WCHAR wchVisiEnd, STOPRES stopr, FMTRES* pfmtr)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PLSRUN plsrun;
	TXTOBJ* pdobjText;
	WCHAR wchAdd;
	long dupWch;
	long durWch;
	BOOL fInChildList;
	OBJDIM objdim;

	pilsobj = plnobj->pilsobj;
	plsrun = pfmtin->lsfrun.plsrun;

	lserr = LsdnFInChildList(pilsobj->plsc, pfmtin->plsdnTop, &fInChildList);
   	Assert(lserr == lserrNone);

	if (fInChildList)
		return FormatStartOneRegularChar(plnobj, pfmtin, txtkindRegular, pfmtr);

	*pfmtr = fmtrStopped;

	/* CreateFillTextDobj section starts */

	lserr = GetTextDobj(plnobj, &pdobjText);
	if (lserr != lserrNone) return lserr;

	pdobjText->txtkind = txtkindEOL;
	pdobjText->plnobj = plnobj;
	pdobjText->plsdnUpNode = pfmtin->plsdnTop;

	pdobjText->iwchFirst = pilsobj->wchMac;
	
	/* CreateFillTextDobj section ends */

	pdobjText->txtf |= txtfSkipAtNti;


	if (pilsobj->grpf & fTxtVisiParaMarks) 
		wchAdd = wchVisiEnd;
	else
		wchAdd = pilsobj->wchSpace;

	
	if (pilsobj->fDisplay)
		{
		lserr = GetVisiCharDup(pilsobj, plsrun, wchVisiEnd, pfmtin->lsfgi.lstflow, &dupWch);
		if (lserr != lserrNone) return lserr;
		durWch = UrFromUp(pfmtin->lsfgi.lstflow, &pilsobj->lsdevres, dupWch);
		plnobj->pwch[pilsobj->wchMac] = wchAdd;
		plnobj->pdup[pilsobj->wchMac] = dupWch;
		}
	else
		{
		durWch = 1;
		}


	Assert(durWch < uLsInfiniteRM);

	pilsobj->pwchOrig[pilsobj->wchMac] = wchAdd;
	pilsobj->pdur[pilsobj->wchMac] = durWch;

	/* AddCharacterWithWidth section starts---parts of it were moved up	*/
	/* We do not check for sufficient space in allocated arrays becayse anyway we allocate for 2 additional
			characters due to possible changes at hyphenation time
	*/
	pilsobj->dcpFetchedWidth = 0;

	pilsobj->wchMac++;

	pdobjText->iwchLim = pilsobj->wchMac;

	Assert(pdobjText->iwchLim == pdobjText->iwchFirst + 1);

	/* AddCharacterWithWidth section ends	*/

	/* FillRealFmtOut section starts	*/

	objdim.dur = durWch;

	objdim.heightsPres.dvAscent = pfmtin->lstxmPres.dvAscent;
	objdim.heightsRef.dvAscent = pfmtin->lstxmRef.dvAscent;
	objdim.heightsPres.dvDescent = pfmtin->lstxmPres.dvDescent;
	objdim.heightsRef.dvDescent = pfmtin->lstxmRef.dvDescent;
	objdim.heightsPres.dvMultiLineHeight = pfmtin->lstxmPres.dvMultiLineHeight;
	objdim.heightsRef.dvMultiLineHeight = pfmtin->lstxmRef.dvMultiLineHeight;

	if (!(pilsobj->grpf & fTxtSpacesInfluenceHeight))
		{
		objdim.heightsRef.dvMultiLineHeight = dvHeightIgnore;
		objdim.heightsPres.dvMultiLineHeight = dvHeightIgnore;
		}

	lserr = LsdnSetStopr(pilsobj->plsc, pfmtin->plsdnTop, stopr);
	Assert(lserr == lserrNone);
	lserr = LsdnFinishRegular(pilsobj->plsc, 1,
							pfmtin->lsfrun.plsrun, pfmtin->lsfrun.plschp, (PDOBJ)pdobjText, &objdim);
	return lserr;	
}

/* F O R M A T  S T A R T  D E L E T E  */
/*----------------------------------------------------------------------------
    %%Function: FormatStartDelete
    %%Contact: sergeyge

	Formatting by Delete upper dnode
----------------------------------------------------------------------------*/
static LSERR FormatStartDelete(PLNOBJ plnobj, LSDCP dcp, FMTRES* pfmtr)
{
	PILSOBJ pilsobj;

	pilsobj = plnobj->pilsobj;

	FlushStringState(pilsobj);  /* Position of fetched widths is not correct any longer */

	*pfmtr = fmtrCompletedRun;

	return LsdnFinishDelete(pilsobj->plsc, dcp);
}	

/* F O R M A T  S T A R T  S P L A T  */
/*----------------------------------------------------------------------------
    %%Function: FormatStartSplat
    %%Contact: sergeyge

	Splat formatting logic
----------------------------------------------------------------------------*/
static LSERR FormatStartSplat(PLNOBJ plnobj, PCFMTIN pfmtin, STOPRES stopr, FMTRES* pfmtr)
{
	*pfmtr = fmtrStopped;
	LsdnSetStopr(plnobj->pilsobj->plsc, pfmtin->plsdnTop, stopr);
	return FillRealFmtOut(plnobj->pilsobj, 1, 0, NULL,  pfmtin, fTrue);
}

/* F O R M A T  S P E C I A L  */
/*----------------------------------------------------------------------------
    %%Function: FormatSpecial
    %%Contact: sergeyge

	Formatting of the special characters (not NonReqHyphen, not Tab)
	Uses wchRef for formatting on reference device, wchPres--on preview device
----------------------------------------------------------------------------*/
static LSERR FormatSpecial(PLNOBJ plnobj, WCHAR wchRef, WCHAR wchPres, BOOL fVisible, long txtkind, 
											PCFMTIN pfmtin, FMTRES* pfmtr)
{
	LSERR lserr;
	PILSOBJ pilsobj;
	PTXTOBJ pdobjText;
	PLSRUN plsrun;
	long dur;
	long dup;
	long durGlobal;
	long cwchRun;
	const WCHAR* pwchRun;
	long iNumOfChars;
	long durWidth;
	long i;

	pilsobj = plnobj->pilsobj;
	plsrun = pfmtin->lsfrun.plsrun;

	lserr = CreateFillTextDobj(plnobj, txtkind, pfmtin, fTrue, &pdobjText);
	if (lserr != lserrNone) return lserr;

	durWidth = pfmtin->lsfgi.urColumnMax - pfmtin->lsfgi.urPen;

	/* Imitate formatting for 1-char string without writing in the string level structures */	
	lserr = GetOneCharDur(pilsobj, plsrun, wchRef, pfmtin->lsfgi.lstflow, &dur);
	if (lserr != lserrNone) return lserr;

	/* Calculate presentation width */
	Assert(wchPres == wchRef || fVisible);
	if (fVisible)
		{
		long dupOrig;

		pilsobj->fDifficultForAdjust = fTrue;
		lserr = GetVisiCharDup(pilsobj, plsrun, wchPres, pfmtin->lsfgi.lstflow, &dup);
		if (lserr != lserrNone) return lserr;
		lserr = GetOneCharDup(pilsobj, plsrun, wchPres, pfmtin->lsfgi.lstflow, dur, &dupOrig);
		if (lserr != lserrNone) return lserr;
		if (dup != dupOrig)
			pdobjText->txtf |= txtfSkipAtWysi;
		}
	else
		{
		lserr = GetOneCharDup(pilsobj, plsrun, wchPres, pfmtin->lsfgi.lstflow, dur, &dup);
		if (lserr != lserrNone) return lserr;
		}

	cwchRun = (long)pfmtin->lsfrun.cwchRun;

	pwchRun = pfmtin->lsfrun.lpwchRun;

	/* check if there are a few identical characters and calculate their number -- we can format them all at once */
	for (iNumOfChars = 1; iNumOfChars < cwchRun && pwchRun[0] == pwchRun[iNumOfChars]; iNumOfChars++);

	durGlobal = 0;

	Assert(iNumOfChars > 0);
	Assert (dur <= uLsInfiniteRM / iNumOfChars);

	if (dur > uLsInfiniteRM / iNumOfChars)
		return lserrTooLongParagraph;

	/*  Don't forget to write at least one char even if pen was positioned behind right margin	*/

	lserr = AddCharacterWithWidth(plnobj, pdobjText, wchRef, dur, wchPres, dup);
	if (lserr != lserrNone) return lserr;
	durWidth -= dur;
	durGlobal += dur;
	
	for (i = 1; i < iNumOfChars && (durWidth >= 0 || txtkind == txtkindSpecSpace); i++)
		{
		lserr = AddCharacterWithWidth(plnobj, pdobjText, wchRef, dur, wchPres, dup);
   		if (lserr != lserrNone) return lserr;
		durWidth -= dur;
		durGlobal += dur;
		}

	iNumOfChars = i;

	*pfmtr = fmtrCompletedRun;

	if (durWidth < 0 && txtkind != txtkindSpecSpace)   /* Don't stop formatting while in spaces	*/
   		*pfmtr = fmtrExceededMargin;

	if (fVisible)
		pdobjText->txtf |= txtfVisi;

	lserr = FillRealFmtOut(pilsobj, iNumOfChars, durGlobal, pdobjText, pfmtin,
																txtkind == txtkindSpecSpace);
	if (lserr != lserrNone) return lserr;


	return lserrNone;
}

/* F M T R  H A R D  B R E A K */
/*----------------------------------------------------------------------------
    %%Function: FmtrHardBreak
    %%Contact: sergeyge

	Calculates fmtr based on clab for the hard breaks.
----------------------------------------------------------------------------*/
static STOPRES StoprHardBreak(CLABEL clab)
{
	switch (clab)
		{
	case clabSectionBreak:
		return stoprEndSection;
	case clabPageBreak:
		return stoprEndPage;
	case clabColumnBreak:
		return stoprEndColumn;
	default:
		NotReached();
		return 0;
		}
}

/* C L A B  F R O M  C H A R */
/*----------------------------------------------------------------------------
    %%Function: ClabFromChar
    %%Contact: sergeyge

	Calculates clab for wch
----------------------------------------------------------------------------*/
static CLABEL ClabFromChar(PILSOBJ pilsobj, WCHAR wch)            /* REVIEW sergeyge   - the whole procedure can be fixed */
{
	DWORD i;

	if (wch < 0x00FF)
		{
		return (CLABEL)(pilsobj->rgbSwitch[wch] & fSpecMask);
		}
	else
		{
		if (pilsobj->rgbSwitch[wch & 0x00FF] & clabSuspicious)
			{
/*
REVIEW sergeyge (elik) It does not make sense to make bin search while
there are two wide special characters only. It would make sense to switch
to binary search as soon as this number is more than 4.
*/
			for (i=0; i < pilsobj->cwchSpec && wch != pilsobj->rgwchSpec[i]; i++);
			if (i == pilsobj->cwchSpec)
				{
				return clabRegular;
				}
			else
				{
				return pilsobj->rgbKind[i];
				}
			}
		else
			{
			return clabRegular;
			}
		}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\lstxttab.c ===
#include "lstxttab.h"

#include "lstxtmap.h"
#include "lsdnset.h"
#include "objdim.h"
#include "txtils.h"
#include "txtln.h"
#include "txtobj.h"


LSERR SetTabLeader(PDOBJ pdobj, WCHAR wch)
{
	Assert(((PTXTOBJ)pdobj)->txtkind == txtkindTab);
	
	((PTXTOBJ)pdobj)->u.tab.wchTabLeader = wch;

	return lserrNone;
}

/*  L S  G E T  D E C I M A L  P O I N T */
/*----------------------------------------------------------------------------
    %%Function: LsGetDecimalPoint
    %%Contact: sergeyge

	Finds dobj, containing decimal point and reports its index as well as
	relative and dur from the beginning of dobj until decimal point.
----------------------------------------------------------------------------*/
LSERR LsGetDecimalPoint(const LSGRCHNK* plsgrchnk, enum lsdevice lsdev, DWORD* pigrchnk, long* pduToDecimal)
{
	LSERR lserr;
	DWORD clsgrchnk;
	PLSCHNK rglschnk;
	POLS pols;
	PLSRUN plsrun;
	PLNOBJ ptxtln;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	WCHAR* rgwch;
	long* rgdu;
	long* rgwSpaces;
	long itxtobj;
	long iwch;
	long iwchSpace;
	long iwSpace;
	BOOL fInDigits;
	BOOL fDigit;
	WCHAR wchDec;
	WCHAR wchThou;
	BOOL fThouIsSpace;
	BOOL fFound;
	BOOL fRealPointFound;
	long iwchDecimal = 0;
	long du;
	BOOL fGlyphBased;
	long iFirst;
	long iLim;
	long iDecimal;
	long i;

	clsgrchnk = plsgrchnk->clsgrchnk;

	if (clsgrchnk == 0)
		{
		*pigrchnk = idobjOutside;
		*pduToDecimal = 0;
		return lserrNone;
		}

	rglschnk = plsgrchnk->plschnk;
	ptxtln = ((PTXTOBJ)rglschnk[0].pdobj)->plnobj;
	pilsobj = ptxtln->pilsobj;
	pols = pilsobj->pols;
	rgwch = pilsobj->pwchOrig;
	rgwSpaces = pilsobj->pwSpaces;

	fInDigits = fFalse;
	fFound = fFalse;
	fRealPointFound = fFalse;
	
	for (itxtobj = 0; !fFound && itxtobj < (long)clsgrchnk; itxtobj++)
		{
		ptxtobj = (PTXTOBJ)rglschnk[itxtobj].pdobj;
		fGlyphBased = ptxtobj->txtf & txtfGlyphBased;
		plsrun = rglschnk[itxtobj].plsrun;
		lserr = (*pilsobj->plscbk->pfnGetNumericSeparators)(pols, plsrun, &wchDec, &wchThou);
		if (lserr != lserrNone) return lserr;
		fThouIsSpace = (wchThou == pilsobj->wchSpace || wchThou == pilsobj->wchNonBreakSpace);
		if (ptxtobj->txtkind == txtkindRegular)
			{
			iwSpace = ptxtobj->u.reg.iwSpacesFirst;
			if (iwSpace == ptxtobj->u.reg.iwSpacesLim)
				{
				iwchSpace = ptxtobj->iwchLim;
				}
			else
				{
				iwchSpace = rgwSpaces[iwSpace];
				}
			for (iwch = ptxtobj->iwchFirst; !fFound && iwch < ptxtobj->iwchLim; iwch++)
				{
				if (!fGlyphBased || FIwchOneToOne(pilsobj, iwch))
					{
					if (iwch == iwchSpace)
						{
						if (fInDigits && !fThouIsSpace)
							{
							iwchDecimal = iwch;
							fFound = fTrue;
							}
						else
							{
							iwSpace++;
							if (iwSpace == ptxtobj->u.reg.iwSpacesLim)
								{
								iwchSpace = ptxtobj->iwchLim;
								}
							else
								{
								iwchSpace = rgwSpaces[iwSpace];
								}
							}
						}
					else if (rgwch[iwch] == wchDec)
						{
						iwchDecimal = iwch;
						fFound = fTrue;
						fRealPointFound = fTrue;
						}
					else
						{
						lserr = (*pilsobj->plscbk->pfnCheckForDigit)(pols, plsrun, rgwch[iwch], &fDigit);
						if (lserr != lserrNone) return lserr;
						if (fDigit)
							{
							fInDigits = fTrue;
							}
						else
							{
							iwchDecimal = iwch;
							fFound = (fInDigits && rgwch[iwch] != wchThou);
							}
						}
					}
				} /* for (iwch= ... */
			}     /* if (txtkind == txtkindRegular */
		else if (ptxtobj->txtkind == txtkindNonBreakSpace)
			{
			if (fInDigits && !fThouIsSpace)
				{
				iwchDecimal = ptxtobj->iwchFirst;
				fFound = fTrue;
				}
			}
		else if (ptxtobj->txtkind == txtkindEOL)
			{
			iwchDecimal = ptxtobj->iwchFirst;
			fFound = fTrue;
			}
		else 	/* All other dobj's interrupt digits */
			{
			if (fInDigits && ptxtobj->iwchLim > ptxtobj->iwchFirst)
				{
				iwchDecimal = ptxtobj->iwchFirst;
				fFound = fTrue;
				}
			}

		if (!fFound && (plsgrchnk->pcont[itxtobj] & fcontNonTextAfter))
			{
			iwchDecimal = ptxtobj->iwchLim;
			fFound = fInDigits;
			}
		}		  /* for (itxtobj= ... */

	itxtobj--;

	Assert(itxtobj >= 0);
	ptxtobj = (PTXTOBJ)rglschnk[itxtobj].pdobj;


	if (fFound)
		{

		/* If we stopped because of digit followed by non-digit
		 (real decimal point was not found) break after digit rather than before following character

		 If we stopped because of EOP after non-digit, IF statement will work correctly as well
		*/
		if (itxtobj > 0 && !fRealPointFound && iwchDecimal == ptxtobj->iwchFirst && !(plsgrchnk->pcont[itxtobj] & fcontNonTextBefore))
			{
			itxtobj--;
			ptxtobj = (PTXTOBJ)rglschnk[itxtobj].pdobj;
			iwchDecimal = ptxtobj->iwchLim;
			}

		if (ptxtobj->txtf & txtfGlyphBased)
			{
			if (lsdev == lsdevReference)
				rgdu = pilsobj->pdurGind;
			else
				rgdu = ptxtln->pdupGind;
			iFirst = ptxtobj->igindFirst;
			iLim = ptxtobj->igindLim;
			iDecimal = IgindFirstFromIwch(ptxtobj, iwchDecimal);
			Assert (iDecimal >= ptxtobj->igindFirst);
			}
		else
			{
			if (lsdev == lsdevReference)
				rgdu = pilsobj->pdur;
			else
				rgdu = ptxtln->pdup;
			iFirst = ptxtobj->iwchFirst;
			iLim = ptxtobj->iwchLim;
			iDecimal = iwchDecimal;
			Assert (iDecimal >= ptxtobj->iwchFirst);
			}


		du = 0;
		for (i = iFirst; i < iDecimal; i++)
			{
			du += rgdu[i];
			}

		*pigrchnk = itxtobj;
		*pduToDecimal = du;
		}
	else
		{
		*pigrchnk = idobjOutside;
		*pduToDecimal = 0;
		}

	return lserrNone;
}

/*  L S  G E T  C H A R  T A B */
/*----------------------------------------------------------------------------
    %%Function: LsGetCharTab
    %%Contact: sergeyge

	Finds dobj, containing char for char tab point and reports its index as well as
	relative and dur from the beginning of dobj until decimal point.
----------------------------------------------------------------------------*/
LSERR LsGetCharTab(const LSGRCHNK* plsgrchnk, WCHAR wchCharTab, enum lsdevice lsdev,
							DWORD* pigrchnk, long* pduToCharacter)
{
	DWORD clsgrchnk;
	PLSCHNK rglschnk;
	POLS pols;
	PLSRUN plsrun;
	PLNOBJ ptxtln;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	WCHAR* rgwch;
	long* rgdu;
	long itxtobj;
	long iwch;
	BOOL fFound;
	long itxtobjCharTab = 0;
	long iwchCharTab = 0;
	long du;
	BOOL fGlyphBased;
	long iFirst;
	long iLim;
	long iCharTab;
	long i;

	clsgrchnk = plsgrchnk->clsgrchnk;

	if (clsgrchnk == 0)
		{
		*pigrchnk = idobjOutside;
		*pduToCharacter = 0;
		return lserrNone;
		}

	rglschnk = plsgrchnk->plschnk;
	ptxtln = ((PTXTOBJ)rglschnk[0].pdobj)->plnobj;
	pilsobj = ptxtln->pilsobj;
	pols = pilsobj->pols;
	rgwch = pilsobj->pwchOrig;

	fFound = fFalse;

	for (itxtobj = 0; !fFound && itxtobj < (long)clsgrchnk; itxtobj++)
		{
		ptxtobj = (PTXTOBJ)rglschnk[itxtobj].pdobj;
		fGlyphBased = ptxtobj->txtf & txtfGlyphBased;
		plsrun = rglschnk[itxtobj].plsrun;
		if (ptxtobj->txtkind == txtkindRegular)
			{
			for (iwch = ptxtobj->iwchFirst; !fFound && iwch < ptxtobj->iwchLim; iwch++)
				{
				if (!fGlyphBased || FIwchOneToOne(pilsobj, iwch))
					{
					if (rgwch[iwch] == wchCharTab)
						{
						itxtobjCharTab = itxtobj;
						iwchCharTab = iwch;
						fFound = fTrue;
						}
					}
				} /* for (iwch= ... */
			}     /* if (txtkind == txtkindRegular */
		else if (ptxtobj->txtkind == txtkindEOL)
			{
			/* If we stopped because of EOP
			 (real character is not found) break after previous character rather than before EOP.
			 It is important for BiDi.
			*/
			if (itxtobj > 0 && !(plsgrchnk->pcont[itxtobj] & fcontNonTextBefore))
				{
				itxtobjCharTab = itxtobj - 1;
				iwchCharTab = ((PTXTOBJ)rglschnk[itxtobjCharTab].pdobj)->iwchLim;
				}
			else
				{
				itxtobjCharTab = itxtobj;
				iwchCharTab = ptxtobj->iwchFirst;
				}

			fFound = fTrue;
			}

		}		  /* for (itxtobj= ... */



	if (fFound)
		{

		ptxtobj = (PTXTOBJ)rglschnk[itxtobjCharTab].pdobj;

		if (ptxtobj->txtf & txtfGlyphBased)
			{
			if (lsdev == lsdevReference)
				rgdu = pilsobj->pdurGind;
			else
				rgdu = ptxtln->pdupGind;
			iFirst = ptxtobj->igindFirst;
			iLim = ptxtobj->igindLim;
			iCharTab = IgindFirstFromIwch(ptxtobj, iwchCharTab);
			Assert (iCharTab >= ptxtobj->igindFirst);
			}
		else
			{
			if (lsdev == lsdevReference)
				rgdu = pilsobj->pdur;
			else
				rgdu = ptxtln->pdup;
			iFirst = ptxtobj->iwchFirst;
			iLim = ptxtobj->iwchLim;
			iCharTab = iwchCharTab;
			Assert (iCharTab >= ptxtobj->iwchFirst);
			}


		du = 0;
		for (i = iFirst; i < iCharTab; i++)
			{
			du += rgdu[i];
			}

		*pigrchnk = itxtobjCharTab;
		*pduToCharacter = du;
		}
	else
		{
		*pigrchnk = idobjOutside;
		*pduToCharacter = 0;
		}

	return lserrNone;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\lstxtqry.c ===
#include "lsmem.h"

#include "lstxtqry.h"
#include "txtils.h"
#include "txtln.h"
#include "txtobj.h"
#include "lsqin.h"
#include "lsqout.h"

typedef struct celldimensions
{
	long	iwchFirst, iwchLim;
	long	igindFirst, igindLim;
	long	dup;
	long 	dcp;					// number of cps in cell - different from iwchLim - iwchFirst
									// if hyphenation added a character
									// filled just before calling AddHyphenationToCell
} CELL;

typedef CELL* PCELL;


static const POINTUV ptZero = {0,0};


//    %%Function:	GetCellDimensions
//    %%Contact:	victork
//
// Input: 	iwchFirst and igindFirst in CELL structure
// Output:	the rest of the structure

static void GetCellDimensions(PTXTOBJ ptxtobj, PCELL pcell)

{
	PLNOBJ	plnobj = ptxtobj->plnobj;
	long* 	rgdup = plnobj->pdupGind;			// widths of glyphs
	GMAP*	pgmap = plnobj->pgmap;				// first glyph in a cell with given character
												// 0 <= i <= wchMax (wchMax in lnobj)
												// 0 <= pgmap[i] <= "glyphs in a shape" (not igindMax)
	long	i, dupCell;
	GMAP	iShapeGindFirstInCell;				// iShape means index from gmap, not index to rgdup

	// Assert that pcell->iwchFirst is really the cell boundary
	// Notice that ptxtinf (and everything in ilsobj) is not valid in query time)
	
	Assert(pcell->iwchFirst == ptxtobj->iwchFirst || pgmap[pcell->iwchFirst] != pgmap[pcell->iwchFirst-1]);
	
	// Assert that pcell->igindFirst corresponds to pcell->iwchFirst
	
	Assert(ptxtobj->igindFirst + pgmap[pcell->iwchFirst] - pgmap [ptxtobj->iwchFirst] == pcell->igindFirst);

	// find out dimentions of the cell - all characters have the same gmap value
	
	iShapeGindFirstInCell = pgmap[pcell->iwchFirst];

	// "infinite" loop will stop when pcell->iwchLim is found

	Assert(pcell->iwchFirst < ptxtobj->iwchLim);				// ensure loop ends
	
	for (i = pcell->iwchFirst + 1; ; i++)
		{
		if (i == ptxtobj->iwchLim)
			{
			pcell->iwchLim = ptxtobj->iwchLim;
			pcell->igindLim = ptxtobj->igindLim;
			break;
			}
		else if (pgmap[i] != iShapeGindFirstInCell)
			{
			pcell->iwchLim = i;
			pcell->igindLim = pcell->igindFirst + pgmap[i] - iShapeGindFirstInCell;
			break;
			}
		}
	
	for (i = pcell->igindFirst, dupCell = 0; i < pcell->igindLim; i++)
		{
		dupCell += rgdup[i];
		}

	pcell->dup	= dupCell;
	
}

//    %%Function:	AddHyphenationToCell
//    %%Contact:	victork
//
static void	AddHyphenationToCell(PTXTOBJ ptxtobj, PCELL pcell)
{	
	long* 	rgdup;
	long	i;
	long	dwch = ptxtobj->plnobj->dwchYsr - 1;			/* number of chars to add */ 

	if (ptxtobj->txtf&txtfGlyphBased)
		{
		rgdup = ptxtobj->plnobj->pdupGind;
		i = pcell->igindLim;

		while (dwch > 0)
			{
			pcell->dup += rgdup[i];
			pcell->iwchLim ++;
			pcell->igindLim ++;					// there are no ligatures amongst added characters
			dwch--;
			i++;
			}
		}
	else
		{
		rgdup = ptxtobj->plnobj->pdup;
		i = pcell->iwchLim;
		
		while (dwch > 0)
			{
			pcell->dup += rgdup[i];
			pcell->iwchLim ++;
			dwch--;
			i++;
			}
		}

	Assert(pcell->iwchLim == (long) ptxtobj->iwchLim);
}

//    %%Function:	QueryDcpPcell
//    %%Contact:	victork
//
static void QueryDcpPcell(PTXTOBJ ptxtobj, LSDCP dcp, PCELL pcell, long* pupStartCell)
{
	PLNOBJ	plnobj = ptxtobj->plnobj;
	long 	iwchLim = (long) ptxtobj->iwchLim;
	
	long* 	rgdup;
	long 	i;

	CELL	cell = {0,0,0,0,0,0};
	
	long	iwchQuery;
	long	upStartCell;

	BOOL 	fHyphenationPresent = fFalse;

	if (ptxtobj == plnobj->pdobjHyphen)
		{
		fHyphenationPresent = fTrue;
		iwchLim -= (plnobj->dwchYsr - 1);		/* exclude additional Ysr characters */
		}
		
	iwchQuery = ptxtobj->iwchFirst + dcp;

	Assert(iwchQuery < iwchLim);

	if (ptxtobj->txtf&txtfGlyphBased)
		{
		// initialize loop variables to describe non-existent previous cell
		
		upStartCell = 0;
		cell.iwchLim = ptxtobj->iwchFirst;
		cell.igindLim = ptxtobj->igindFirst;
		cell.dup = 0;
		
		// loop does cell after cell until the cell containing iwchQuery is found
		
		while (cell.iwchLim <= iwchQuery)
			{
			// start filling info about current cell
			
			upStartCell += cell.dup;
			cell.iwchFirst = cell.iwchLim;
			cell.igindFirst = cell.igindLim;

			// get the rest
			
			GetCellDimensions(ptxtobj, &cell);
			}
		}
	else
		{
		rgdup = plnobj->pdup;

		i = ptxtobj->iwchFirst;
		upStartCell = 0;

		while (dcp > 0)
			{
			upStartCell += rgdup[i];
			dcp--;
			i++;
			}
			
		Assert(i < iwchLim);								/* I'm given dcp inside */
		
		// put the info into cell structure
		cell.dup = rgdup[i];
		cell.iwchFirst = i;
		cell.iwchLim = i+1;
		
		// these two are irrelevant, but for the sake of convenience...
		cell.igindFirst = i;
		cell.igindLim = i;
		}

	cell.dcp = cell.iwchLim - cell.iwchFirst; 			// hyphenation can change that
	
	// YSR can extend the last cell

	if (fHyphenationPresent && cell.iwchLim == iwchLim)
		{
		// the cell is up to the YSR sequence - let's include it 

		AddHyphenationToCell(ptxtobj, &cell);
		}
			
	*pcell = cell;
	*pupStartCell = upStartCell;
}


//    %%Function:	QueryCpPpointText
//    %%Contact:	victork
//
/*	Input is dcp and dnode dimensions
 *	Output is point where character begins (on baseline of dnode, so v is always zero),
 *	dimensions of the character - only width is calculated 
 */

LSERR WINAPI QueryCpPpointText(PDOBJ pdobj, LSDCP dcp, PCLSQIN plsqin, PLSQOUT plsqout)
{

	PTXTOBJ ptxtobj = (PTXTOBJ)pdobj;
	
	CELL	cell;
	long	upStartCell;

	plsqout->pointUvStartObj = ptZero;
	plsqout->heightsPresObj = plsqin->heightsPresRun;
	plsqout->dupObj = plsqin->dupRun;
	
	plsqout->plssubl = NULL;
	plsqout->pointUvStartSubline = ptZero;
	
	plsqout->lstextcell.pointUvStartCell = ptZero;					// u can be changed later

	if (ptxtobj->txtkind == txtkindTab)
		{
		// A tab is always in a separate dnode and is treated differently
		
		Assert(dcp == 0);
		
		plsqout->lstextcell.cpStartCell = plsqin->cpFirstRun;
		plsqout->lstextcell.cpEndCell = plsqin->cpFirstRun;
		plsqout->lstextcell.dupCell = plsqin->dupRun;
		plsqout->lstextcell.cCharsInCell = 1;
		plsqout->lstextcell.cGlyphsInCell = 0;
		return lserrNone;
		}
		
	if (ptxtobj->iwchFirst == ptxtobj->iwchLim)
		{
		// empty dobj (for NonReqHyphen, OptBreak, or NonBreak characters)
		
		Assert(dcp == 0);
		Assert(plsqin->dupRun == 0);
		
		Assert(ptxtobj->txtkind ==  txtkindNonReqHyphen || ptxtobj->txtkind == txtkindOptBreak || 
				ptxtobj->txtkind == txtkindOptNonBreak);

		plsqout->lstextcell.cpStartCell = plsqin->cpFirstRun;
		plsqout->lstextcell.cpEndCell = plsqin->cpFirstRun;
		plsqout->lstextcell.dupCell = 0;
		plsqout->lstextcell.cCharsInCell = 0;
		plsqout->lstextcell.cGlyphsInCell = 0;
		
		return lserrNone;
		}
		

	// Find the cell - common with QueryTextCellDetails
	
	QueryDcpPcell(ptxtobj, dcp, &cell, &upStartCell);
	
	plsqout->lstextcell.cpStartCell = plsqin->cpFirstRun + cell.iwchFirst - ptxtobj->iwchFirst;
	plsqout->lstextcell.cpEndCell = plsqout->lstextcell.cpStartCell + cell.dcp - 1;
	plsqout->lstextcell.pointUvStartCell.u = upStartCell;
	plsqout->lstextcell.dupCell = cell.dup;
	plsqout->lstextcell.cCharsInCell = cell.iwchLim - cell.iwchFirst;
	plsqout->lstextcell.cGlyphsInCell = cell.igindLim - cell.igindFirst;

	return lserrNone;
}

//    %%Function:	QueryPointPcpText
//    %%Contact:	victork
//
LSERR WINAPI QueryPointPcpText(PDOBJ pdobj, PCPOINTUV pptIn, PCLSQIN plsqin, PLSQOUT plsqout)

{
	PTXTOBJ ptxtobj = (PTXTOBJ)pdobj;
	PLNOBJ	plnobj = ptxtobj->plnobj;
	long 	iwchLim = (long) ptxtobj->iwchLim;
	BOOL 	fHyphenationPresent = fFalse;
	
	long* 	rgdup;
	long 	i;
	long	upQuery, upStartCell, upLimCell;
	
	CELL	cell = {0,0,0,0,0,0};									// init'ed to get rid of assert
	
	plsqout->pointUvStartObj = ptZero;
	plsqout->heightsPresObj = plsqin->heightsPresRun;
	plsqout->dupObj = plsqin->dupRun;
	
	plsqout->plssubl = NULL;
	plsqout->pointUvStartSubline = ptZero;
	
	plsqout->lstextcell.pointUvStartCell = ptZero;					// u can change later
	
	if (ptxtobj->txtkind == txtkindTab)
		{
		// A tab is always in a separate dnode and is treated differently
				
		plsqout->lstextcell.cpStartCell = plsqin->cpFirstRun;
		plsqout->lstextcell.cpEndCell = plsqin->cpFirstRun;
		plsqout->lstextcell.dupCell = plsqin->dupRun;
		plsqout->lstextcell.cCharsInCell = 1;
		plsqout->lstextcell.cGlyphsInCell = 0;
		return lserrNone;
		}

	if (ptxtobj == plnobj->pdobjHyphen)
		{
		fHyphenationPresent = fTrue;
		iwchLim -= (plnobj->dwchYsr - 1);		/* exclude additional Ysr characters */
		}
		
	upQuery = pptIn->u;
	if (upQuery < 0)
		{
		upQuery = 0;									// return leftmost when clicked outside left
		}
		
	upStartCell = 0;

	if (ptxtobj->txtf&txtfGlyphBased)
		{
		// initialize loop variables to describe non-existent previous cell
		
		upLimCell = 0;
		cell.iwchLim = ptxtobj->iwchFirst;
		cell.igindLim = ptxtobj->igindFirst;
		cell.dup = 0;
		
		// loop does cell after cell until the last cell or the cell containing upQuery
		
		while (cell.iwchLim < iwchLim && upLimCell <= upQuery)
			{
			// start filling info about current cell
			
			upStartCell = upLimCell;
			cell.iwchFirst = cell.iwchLim;
			cell.igindFirst = cell.igindLim;

			// get the rest
			
			GetCellDimensions(ptxtobj, &cell);
			
			upLimCell = upStartCell + cell.dup;
			}
		}
	else
		{
		rgdup = plnobj->pdup;

		i = ptxtobj->iwchFirst;
		upLimCell = 0;
		
		while (upLimCell <= upQuery && i < iwchLim)
			{
			upStartCell = upLimCell;
			upLimCell += rgdup[i];
			i++;
			}
			
		// put the info into cell structure
		cell.dup = rgdup[i - 1];
		cell.iwchFirst = i - 1;
		cell.iwchLim = i;
		
		// these two are irrelevant, but for the sake of convenience...
		cell.igindFirst = i - 1;
		cell.igindLim = i - 1;
		}

	cell.dcp = cell.iwchLim - cell.iwchFirst; 			// hyphenation can change that

	// YSR can extend the last cell

	if (fHyphenationPresent && cell.iwchLim == iwchLim)
		{
		// the cell is up to the YSR sequence - let's include it 

		AddHyphenationToCell(ptxtobj, &cell);
		}
			
	plsqout->lstextcell.cpStartCell = plsqin->cpFirstRun + cell.iwchFirst - ptxtobj->iwchFirst;
	plsqout->lstextcell.cpEndCell = plsqout->lstextcell.cpStartCell + cell.dcp - 1;
	plsqout->lstextcell.pointUvStartCell.u = upStartCell;
	plsqout->lstextcell.dupCell = cell.dup;
	plsqout->lstextcell.cCharsInCell = cell.iwchLim - cell.iwchFirst;
	plsqout->lstextcell.cGlyphsInCell = cell.igindLim - cell.igindFirst;

	return lserrNone;
}


//    %%Function:	QueryTextCellDetails
//    %%Contact:	victork
//
LSERR WINAPI QueryTextCellDetails(
						 	PDOBJ 	pdobj,
							LSDCP	dcp,				/* IN: dcpStartCell	*/
							DWORD	cChars,				/* IN: cCharsInCell */
							DWORD	cGlyphs,			/* IN: cGlyphsInCell */
							LPWSTR	pwchOut,			/* OUT: pointer array[cChars] of char codes */
							PGINDEX	pgindex,			/* OUT: pointer array[cGlyphs] of glyph indices */
							long*	pdup,				/* OUT: pointer array[cGlyphs] of glyph widths */
							PGOFFSET pgoffset,			/* OUT: pointer array[cGlyphs] of glyph offsets */
							PGPROP	pgprop)				/* OUT: pointer array[cGlyphs] of glyph handles */
{
	PTXTOBJ ptxtobj = (PTXTOBJ)pdobj;
	PLNOBJ	plnobj = ptxtobj->plnobj;

	CELL	cell;
	long	upDummy;
	
	Unreferenced(cGlyphs);
	Unreferenced(cChars);							// used only in an assert

	if (ptxtobj->txtkind == txtkindTab)
		{
		// Tab is in a separate dnode always and is treated differently
		Assert(dcp == 0);
		Assert(cChars == 1);
		*pwchOut = ptxtobj->u.tab.wch;
		*pdup = (ptxtobj->plnobj->pdup)[ptxtobj->iwchFirst];
		return lserrNone;
		}
		
	if (ptxtobj->iwchFirst == ptxtobj->iwchLim)
		{
		// empty dobj (for NonReqHyphen, OptBreak, or NonBreak characters)
		
		Assert(dcp == 0);
		Assert(cChars == 0);
		Assert(cGlyphs == 0);
		
		return lserrNone;
		}

	// Find the cell - common with QueryCpPpointText
	
	QueryDcpPcell(ptxtobj, dcp, &cell, &upDummy);
	
	Assert(cell.iwchLim - cell.iwchFirst == (long) cChars);

	memcpy(pwchOut, &plnobj->pwch[cell.iwchFirst], sizeof(long) * cChars);

	if (ptxtobj->txtf&txtfGlyphBased)
		{
		Assert(cell.igindLim - cell.igindFirst == (long) cGlyphs);
		
		memcpy(pdup, &plnobj->pdupGind[cell.igindFirst], sizeof(long) * cGlyphs);
		memcpy(pgindex, &plnobj->pgind[cell.igindFirst], sizeof(long) * cGlyphs);
		memcpy(pgoffset, &plnobj->pgoffs[cell.igindFirst], sizeof(long) * cGlyphs);
		memcpy(pgprop, &plnobj->pgprop[cell.igindFirst], sizeof(long) * cGlyphs);
		}
	else
		{
		memcpy(pdup, &plnobj->pdup[cell.iwchFirst], sizeof(long) * cChars);
		}
	
	return lserrNone;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\ntiman.c ===
#include "ntiman.h"
#include "plschcon.h"
#include "lschcon.h"
#include "dninfo.h"
#include "iobj.h"
#include "chnutils.h"
#include "lstext.h"
#include "lscfmtfl.h"

#define     	FNominalToIdealNeeded(plschnkcontext, grpf, lskjust)    \
				((plschnkcontext)->grpfTnti != 0) || \
				 FNominalToIdealBecauseOfParagraphProperties(grpf, lskjust)  
				

LSERR ApplyNominalToIdeal(
						  PLSCHUNKCONTEXT plschunkcontext, /* LS chunk context */
						  PLSIOBJCONTEXT plsiobjcontext, /* installed objects */
						  DWORD grpf,		/* grpf */
  						  LSKJUST lskjust,		/* kind of justification */
						  BOOL fIsSublineMain,			/* fIsSubLineMain */
						  BOOL fLineContainsAutoNumber,  
						  PLSDNODE plsdnLast)	/* dnode until which we should do nominal to ideal */
{
	LSERR lserr;
	PLSDNODE plsdnPrev;
	BOOL fSuccessful;
	WCHAR wchar;
	PLSRUN plsrunText;
	HEIGHTS heightsText;
	MWCLS mwcls;
	DWORD iobj;
	LSIMETHODS* plsim;
	long durChange;
	PLSDNODE plsdnLastContent;



	plsdnLastContent = plsdnLast;
	// skip borders
	while(plsdnLastContent != NULL && FIsDnodeBorder(plsdnLastContent))
		{
		plsdnLastContent = plsdnLastContent->plsdnPrev;
		}


	/* if there are now dnodes in line or nominal to ideal has been already applied 
	return right away */
	if (plsdnLastContent == NULL || plschunkcontext->fNTIAppliedToLastChunk) 
		return lserrNone;

	Assert(FIsLSDNODE(plsdnLastContent));


	/*if last dnode text */
	if (FIsDnodeReal(plsdnLastContent) && !(plsdnLastContent->fTab) && 
		(IdObjFromDnode(plsdnLastContent) == IobjTextFromLsc(plsiobjcontext)))
		{

		lserr = FillChunkArray(plschunkcontext, plsdnLastContent);
		if (lserr != lserrNone)
			return lserr; 

		if (FNominalToIdealNeeded(plschunkcontext, grpf, lskjust))
			{
			lserr = NominalToIdealText(
					plschunkcontext->grpfTnti,	
					LstflowFromDnode(plsdnLastContent),
					(FIsFirstOnLine(plschunkcontext->pplsdnChunk[0]) && fIsSublineMain),
					fLineContainsAutoNumber ,
					plschunkcontext->locchnkCurrent.clschnk,	
					plschunkcontext->locchnkCurrent.plschnk);
			if (lserr != lserrNone)
				return lserr; 
			SetNTIAppliedToLastChunk(plschunkcontext);

			/* apply width modification between preceding object and first text */
			plsdnPrev = plschunkcontext->pplsdnChunk[0]->plsdnPrev;
			if (plsdnPrev != NULL && FIsDnodeReal(plsdnPrev) && !plsdnPrev->fTab)
				{
				lserr = GetFirstCharInChunk(plschunkcontext->locchnkCurrent.clschnk,
					plschunkcontext->locchnkCurrent.plschnk, &fSuccessful,
					&wchar, &plsrunText, &heightsText, &mwcls);
				if (lserr != lserrNone)
					return lserr; 

				if (fSuccessful)
					{
					iobj = IdObjFromDnode(plsdnPrev);
					plsim = PLsimFromLsc(plsiobjcontext, iobj);
					if (plsim->pfnGetModWidthFollowingChar != NULL)
						{
						lserr = plsim->pfnGetModWidthFollowingChar(plsdnPrev->u.real.pdobj,
							plsdnPrev->u.real.plsrun, plsrunText, &heightsText, wchar,
							mwcls, &durChange);
						if (lserr != lserrNone)
							return lserr;
						
						if (durChange != 0)
							{
							lserr = ModifyFirstCharInChunk(
												plschunkcontext->locchnkCurrent.clschnk,
												plschunkcontext->locchnkCurrent.plschnk,
												durChange);				
							if (lserr != lserrNone)
								return lserr;
							} 
						}  /* object has this method */
					}	/* call back from text was successful  */
				}	/*	there is non-text object before chunk of text */
			}	/* nominal to ideal is needed */
		} /* last dnode text after autonumbering */		

	return lserrNone;
}

LSERR ApplyModWidthToPrecedingChar(
						  PLSCHUNKCONTEXT plschunkcontext, /* LS chunk context */
						  PLSIOBJCONTEXT plsiobjcontext, /* installed objects */
						  DWORD grpf,		/* grpf */
  						  LSKJUST lskjust,		/* kind of justification */
    					  PLSDNODE plsdnNonText) /* non-text dnode after text */
	{
	LSERR lserr;
	BOOL fSuccessful;
	WCHAR wchar;
	PLSRUN plsrunText;
	HEIGHTS heightsText;
	MWCLS mwcls;
	DWORD iobj;
	LSIMETHODS* plsim;
	long durChange;
	PLSDNODE plsdnPrev;
	
	Assert(FIsLSDNODE(plsdnNonText));

	plsdnPrev = plsdnNonText->plsdnPrev; 

	/*if Prev dnode text */
	if (plsdnPrev != NULL && FIsDnodeReal(plsdnPrev) && !(plsdnPrev->fTab)  &&
		(IdObjFromDnode(plsdnPrev) == IobjTextFromLsc(plsiobjcontext)))
		{
	
		if (plschunkcontext->FChunkValid)
			{
			/* chunk we have is exactly what we need */
			Assert(plschunkcontext->locchnkCurrent.clschnk != 0);
			Assert(!plschunkcontext->FGroupChunk);
			Assert((plschunkcontext->pplsdnChunk[plschunkcontext->locchnkCurrent.clschnk - 1])
			->plsdnNext == plsdnNonText);
			}
		else
			{
			lserr = FillChunkArray(plschunkcontext, plsdnPrev);
			if (lserr != lserrNone)
				return lserr; 
			}
		
		if (FNominalToIdealNeeded(plschunkcontext, grpf, lskjust))
			{
			/* apply width modification between text and following object */
			lserr = GetLastCharInChunk(plschunkcontext->locchnkCurrent.clschnk,
				plschunkcontext->locchnkCurrent.plschnk, &fSuccessful,
				&wchar, &plsrunText, &heightsText, &mwcls);
			if (lserr != lserrNone)
				return lserr; 
			
			if (fSuccessful)
				{
				iobj = IdObjFromDnode(plsdnNonText);
				plsim = PLsimFromLsc(plsiobjcontext, iobj);
				if (plsim->pfnGetModWidthPrecedingChar != NULL)
					{
					lserr = plsim->pfnGetModWidthPrecedingChar(plsdnNonText->u.real.pdobj,
						plsdnNonText->u.real.plsrun, plsrunText, &heightsText, wchar,
						mwcls, &durChange);
					if (lserr != lserrNone)
						return lserr;
					
					if (durChange != 0)
						{
						lserr = ModifyLastCharInChunk(
							plschunkcontext->locchnkCurrent.clschnk,
							plschunkcontext->locchnkCurrent.plschnk,
							durChange);				
						if (lserr != lserrNone)
							return lserr;
						} 
					}  /* object has this method */
				}	/* call back from text was successful  */
			}	/* nominal to ideal is needed */
		}  /* there is text before */
	return lserrNone;
	
	}

LSERR CutPossibleContextViolation(
						  PLSCHUNKCONTEXT plschunkcontext, /* LS chunk context */
    					  PLSDNODE plsdnLast) /* last text dnode */
	{
	LSERR lserr;
	
	Assert(FIsLSDNODE(plsdnLast));
	
	
	if (plschunkcontext->FChunkValid)
		{
		/* chunk we have is exactly what we need */
		Assert(plschunkcontext->locchnkCurrent.clschnk != 0);
		Assert(!plschunkcontext->FGroupChunk);
		Assert((plschunkcontext->pplsdnChunk[plschunkcontext->locchnkCurrent.clschnk - 1])
			== plsdnLast);
		}
	else
		{
		lserr = FillChunkArray(plschunkcontext, plsdnLast);
		if (lserr != lserrNone)
			return lserr; 
		}

	lserr = CutTextDobj(plschunkcontext->locchnkCurrent.clschnk,
					plschunkcontext->locchnkCurrent.plschnk);	
	if (lserr != lserrNone)
		return lserr; 

	
	return lserrNone;
	
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\lstxtwrd.c ===
#include "lstxtwrd.h"

#include "lstxtmap.h"
#include "txtils.h"
#include "txtln.h"
#include "txtobj.h"

#define min(a,b)     ((a) > (b) ? (b) : (a))
#define max(a,b)     ((a) < (b) ? (b) : (a))

#define SqueezingFactorShift 2

static long GetNumberOfSpaces(const LSGRCHNK* plsgrchnk, 
						long itxtobjAfterStartSpaces, long iwchAfterStartSpaces,
						long itxtobjLast, long iwchLast);

static void DistributeInDobjsSpaces(const LSGRCHNK* plsgrchnk,
						long itxtobjAfterStartSpaces, long iwchAfterStartSpaces,
						long itxtobjLast, long iwchLast, long* rgdu, long* rgduGind, long duAdd, long wDuBound);

static void GetSqueezingInfo(const LSGRCHNK* plsgrchnk,
						long itxtobjAfterStartSpaces, long iwchAfterStartSpaces,
						long itxtobjLast, long iwchLast, long* rgdu, long* rgduGind,
						long* pNumOfSpaces, long* pduForSqueezing);

static void	SqueezeInDobjs(const LSGRCHNK* plsgrchnk, 
						long itxtobjAfterStartSpaces, long iwchAfterStartSpaces,
						long itxtobjLast, long iwchLast, long* rgdu, long* rgduGind,
						long duSubstr, long wDuBound);

/* F U L L  P O S I T I V E  J U S T I F I C A T I O N */
/*----------------------------------------------------------------------------
    %%Function: FullPositiveJustification
    %%Contact: sergeyge

	Performs positive distribution in spaces.

	Since amount to distribute is not nesessary divisible by number of spaces,
	additional pixels (wDupBound, wDurBound) are distributed among first
	wDupBound/wDurBound spaces.

	Leading spaces do not participate.
----------------------------------------------------------------------------*/
void FullPositiveSpaceJustification(const LSGRCHNK* plsgrchnk,
					long itxtobjAfterStartSpaces, long iwchAfterStartSpaces,
					long itxtobjLast, long iwchLast,
					long* rgdu, long* rgduGind, long duToDistribute, BOOL* pfSpacesFound)
{
    long NumOfSpaces;
    long duAdd;
    long wDuBound;

	Assert(duToDistribute > 0);
	
	NumOfSpaces = GetNumberOfSpaces(plsgrchnk, itxtobjAfterStartSpaces, iwchAfterStartSpaces,
																			itxtobjLast, iwchLast);
	if (NumOfSpaces > 0)
		{

		duAdd = duToDistribute / NumOfSpaces;

		wDuBound = duToDistribute - (duAdd * NumOfSpaces);

		DistributeInDobjsSpaces(plsgrchnk, itxtobjAfterStartSpaces, iwchAfterStartSpaces,
											itxtobjLast, iwchLast, rgdu, rgduGind, duAdd, wDuBound);
		}

	*pfSpacesFound = (NumOfSpaces > 0);
}

/* N E G A T I V E  S P A C E  J U S T I F I C A T I O N */
/*----------------------------------------------------------------------------
    %%Function: NegativeSpaceJustification
    %%Contact: sergeyge

	Performs squeezing into spaces if it is possible.
	If it is impossible squeezes in as much as it can
----------------------------------------------------------------------------*/
void NegativeSpaceJustification(const LSGRCHNK* plsgrchnk,
						long itxtobjAfterStartSpaces, long iwchAfterStartSpaces,
						long itxtobjLast, long iwchLast, long* rgdu, long* rgduGind, long duToSqueeze)
{
    long NumOfSpaces;
	long duForSqueezing;
    long duSubstr;
    long wDuBound;

	Assert(duToSqueeze > 0);

	GetSqueezingInfo(plsgrchnk, itxtobjAfterStartSpaces, iwchAfterStartSpaces,
									itxtobjLast, iwchLast, rgdu, rgduGind, &NumOfSpaces, &duForSqueezing);

	/* We cannot squeeze more tha we can */
	if (duForSqueezing < duToSqueeze)
		duToSqueeze = duForSqueezing;

	/* dupSubstr shows how much should be subtracted from maximum squeezing
			each space provides.
	   wDupBound--from how many spaces additional pixel should be subtracted */
	if (NumOfSpaces > 0)
		{
		duSubstr = (duForSqueezing - duToSqueeze) / NumOfSpaces;
		wDuBound = (duForSqueezing - duToSqueeze) - duSubstr * NumOfSpaces;
		

		Assert(duSubstr >= 0);
		Assert(wDuBound >= 0);
		SqueezeInDobjs(plsgrchnk, itxtobjAfterStartSpaces, iwchAfterStartSpaces,
								itxtobjLast, iwchLast, rgdu, rgduGind, duSubstr, wDuBound);
		}

	return;
}


/* Internal Functions Implementation */

/* G E T  N U M B E R  O F  S P A C E S */
/*----------------------------------------------------------------------------
    %%Function: GetNumberOfSpaces
    %%Contact: sergeyge

	Reports amount of spaces for distribution.
----------------------------------------------------------------------------*/
static long GetNumberOfSpaces(const LSGRCHNK* plsgrchnk, 
						long itxtobjAfterStartSpaces, long iwchAfterStartSpaces,
						long itxtobjLast, long iwchLast)
{
	long NumOfSpaces;
	PTXTOBJ ptxtobj;
	PILSOBJ pilsobj;
	long* rgwSpaces;
	long iwSpacesFirst;
	long iwSpacesLim;
	long iwSpaces;
	long iwchFirst;
	long iwchLim;
	long itxtobj;

	ptxtobj = (PTXTOBJ) plsgrchnk->plschnk[0].pdobj;
	pilsobj = ptxtobj->plnobj->pilsobj;
	rgwSpaces = pilsobj->pwSpaces;

	NumOfSpaces = 0;

	for (itxtobj = itxtobjAfterStartSpaces; itxtobj <= itxtobjLast; itxtobj++)
		{
		ptxtobj = (PTXTOBJ) plsgrchnk->plschnk[itxtobj].pdobj;

		if (ptxtobj->txtkind == txtkindRegular)
			{
			iwSpacesFirst = ptxtobj->u.reg.iwSpacesFirst;
			iwSpacesLim = ptxtobj->u.reg.iwSpacesLim;


			iwchFirst = iwchAfterStartSpaces;
			if (itxtobj > itxtobjAfterStartSpaces)
				iwchFirst = ptxtobj->iwchFirst;

			iwchLim = iwchLast + 1;
			if (itxtobj < itxtobjLast)
				iwchLim = ptxtobj->iwchLim;

			while (iwSpacesFirst < iwSpacesLim && rgwSpaces[iwSpacesFirst] < iwchFirst)
				{
				iwSpacesFirst++;
				}

			while (iwSpacesLim > iwSpacesFirst && rgwSpaces[iwSpacesLim-1] >= iwchLim)
				{
				iwSpacesLim--;
				}
	
			if (ptxtobj->txtf & txtfGlyphBased)
				{
				for (iwSpaces = iwSpacesFirst; iwSpaces < iwSpacesLim; iwSpaces++)
					if (FIwchOneToOne(pilsobj, rgwSpaces[iwSpaces]))
						NumOfSpaces++;
				}
			else
				NumOfSpaces += (iwSpacesLim - iwSpacesFirst);
	
			}
		}

	return NumOfSpaces;
}

/* D I S T R I B U T E  I N  D O B J S */
/*----------------------------------------------------------------------------
    %%Function: DistributeInDobjs
    %%Contact: sergeyge

	Performs distribution in dobjs, based on precalculated information.
----------------------------------------------------------------------------*/
static void DistributeInDobjsSpaces(const LSGRCHNK* plsgrchnk,
						long itxtobjAfterStartSpaces, long iwchAfterStartSpaces,
						long itxtobjLast, long iwchLast, long* rgdu, long* rgduGind, long duAdd, long wDuBound)
{
	PTXTOBJ ptxtobj;
	PILSOBJ pilsobj;
	PLNOBJ plnobj;
	long* rgwSpaces;
	long iwSpacesFirst;
	long iwSpacesLim;
	long iwchFirst;
	long iwchLim;
	long CurSpace;
	long itxtobj;
	long iwSpaces;
	long igind;
	long CurSpaceForSecondLoop;

	plnobj = ((PTXTOBJ)(plsgrchnk->plschnk[0].pdobj))->plnobj;
	pilsobj = plnobj->pilsobj;
	rgwSpaces = pilsobj->pwSpaces;
	
	CurSpace = 0;
	for (itxtobj = itxtobjAfterStartSpaces; itxtobj <= itxtobjLast ; itxtobj++)
		{
		ptxtobj = (PTXTOBJ) plsgrchnk->plschnk[itxtobj].pdobj;

		if (ptxtobj->txtkind == txtkindRegular)
			{
			iwSpacesFirst = ptxtobj->u.reg.iwSpacesFirst;
			iwSpacesLim = ptxtobj->u.reg.iwSpacesLim;

			iwchFirst = iwchAfterStartSpaces;
			if (itxtobj > itxtobjAfterStartSpaces)
				iwchFirst = ptxtobj->iwchFirst;

			iwchLim = iwchLast + 1;
			if (itxtobj < itxtobjLast)
				iwchLim = ptxtobj->iwchLim;

			while (iwSpacesFirst < iwSpacesLim && rgwSpaces[iwSpacesFirst] < iwchFirst)
				{
				iwSpacesFirst++;
				}

			while (iwSpacesLim > iwSpacesFirst && rgwSpaces[iwSpacesLim-1] >= iwchLim)
				{
				iwSpacesLim--;
				}

			if (ptxtobj->txtf & txtfGlyphBased)
				{
				Assert(rgduGind != NULL);
				for(iwSpaces = iwSpacesFirst; iwSpaces < iwSpacesLim; iwSpaces++)
					{
					if (FIwchOneToOne(pilsobj, rgwSpaces[iwSpaces]))
						{
						igind = IgindFirstFromIwch(ptxtobj, rgwSpaces[iwSpaces]);
						if (CurSpace < wDuBound)
							{
							rgduGind[igind] += (duAdd + 1);
							pilsobj->pduGright[igind] += (duAdd + 1);
							}
						else
							{			
							rgduGind[igind] += duAdd;
							pilsobj->pduGright[igind] += duAdd;
							}

						CurSpace++;
						}

					}
				}
			else
				{
	
				CurSpaceForSecondLoop = CurSpace;

				for(iwSpaces = iwSpacesFirst; iwSpaces < iwSpacesLim; iwSpaces++)
					{
					if (CurSpace < wDuBound)
						{
						rgdu[rgwSpaces[iwSpaces]] += (duAdd + 1);
						}
					else
						{			
						rgdu[rgwSpaces[iwSpaces]] += duAdd;
						}

					CurSpace++;
					}
				if (pilsobj->fNotSimpleText)
					{
					for(iwSpaces = iwSpacesFirst; iwSpaces < iwSpacesLim; iwSpaces++)
						{
						if (CurSpaceForSecondLoop < wDuBound)
							{
							pilsobj->pdurRight[rgwSpaces[iwSpaces]] += (duAdd + 1);
							}
						else
							{			
							pilsobj->pdurRight[rgwSpaces[iwSpaces]] += duAdd;
							}

						CurSpaceForSecondLoop++;
						}
					}
				}
			}
		}

}

/* G E T  S Q U E E Z I N G  I N F O */
/*----------------------------------------------------------------------------
    %%Function: GetSqueezingInfo
    %%Contact: sergeyge

	Calculates maximum amount of pixels to squeeze into spaces.
	Leading spaces are used for squeezing.
----------------------------------------------------------------------------*/
static void GetSqueezingInfo(const LSGRCHNK* plsgrchnk,
						long itxtobjAfterStartSpaces, long iwchAfterStartSpaces,
						long itxtobjLast, long iwchLast, long* rgdu, long* rgduGind,
						long* pNumOfSpaces, long* pduForSqueezing)
{
	PTXTOBJ ptxtobj;
	PLNOBJ plnobj;
	PILSOBJ pilsobj;
	long* rgwSpaces;
	long iwSpacesFirst;
	long iwSpacesLim;
	long iwchFirst;
	long iwchLim;
	long itxtobj;
	long iwSpaces;

	ptxtobj = (PTXTOBJ) plsgrchnk->plschnk[0].pdobj;
	plnobj = ptxtobj->plnobj;
	pilsobj = plnobj->pilsobj;
	rgwSpaces = pilsobj->pwSpaces;

	*pNumOfSpaces = 0;
	*pduForSqueezing = 0;

	for (itxtobj = itxtobjAfterStartSpaces; itxtobj <= itxtobjLast ; itxtobj++)
		{

		ptxtobj = (PTXTOBJ) plsgrchnk->plschnk[itxtobj].pdobj;

		if (! (ptxtobj->txtf & txtfMonospaced) )
			{

			if (ptxtobj->txtkind == txtkindRegular)
				{
				iwSpacesFirst = ptxtobj->u.reg.iwSpacesFirst;
				iwSpacesLim = ptxtobj->u.reg.iwSpacesLim;

				iwchFirst = iwchAfterStartSpaces;
				if (itxtobj > itxtobjAfterStartSpaces)
					iwchFirst = ptxtobj->iwchFirst;

				iwchLim = iwchLast + 1;
				if (itxtobj < itxtobjLast)
					iwchLim = ptxtobj->iwchLim;

				while (iwSpacesFirst < iwSpacesLim && rgwSpaces[iwSpacesFirst] < iwchFirst)
					{
					iwSpacesFirst++;
					}

				while (iwSpacesLim > iwSpacesFirst && rgwSpaces[iwSpacesLim-1] >= iwchLim)
					{
					iwSpacesLim--;
					}

				if (ptxtobj->txtf & txtfGlyphBased)
					{
					for (iwSpaces = iwSpacesFirst; iwSpaces < iwSpacesLim; iwSpaces++)
						{
						if (FIwchOneToOne(pilsobj, rgwSpaces[iwSpaces]))
							{
							(*pduForSqueezing) += rgduGind[IgindFirstFromIwch(ptxtobj,rgwSpaces[iwSpaces])] >>
																					 SqueezingFactorShift;
							(*pNumOfSpaces)++;
							}
						}
					}
				else
					{
					for (iwSpaces = iwSpacesFirst; iwSpaces < iwSpacesLim; iwSpaces++)
						{
						(*pduForSqueezing) += rgdu[rgwSpaces[iwSpaces]] >> SqueezingFactorShift;
						}
	
					(*pNumOfSpaces) += (iwSpacesLim - iwSpacesFirst);
					}
				}
			}		

		}
}

/* S Q U E E Z E  I N  D O B J S  */
/*----------------------------------------------------------------------------
    %%Function: SqueezeInDobjs
    %%Contact: sergeyge

	Performs squeezing in dobjs, based on precalculated information
----------------------------------------------------------------------------*/
static void	SqueezeInDobjs(const LSGRCHNK* plsgrchnk, 
						long itxtobjAfterStartSpaces, long iwchAfterStartSpaces,
						long itxtobjLast, long iwchLast, long* rgdu, long* rgduGind,
						long duSubstr, long wDuBound)
{
	PTXTOBJ ptxtobj;
	PLNOBJ plnobj;
	PILSOBJ pilsobj;
	long* rgwSpaces;
	long iwSpacesFirst;
	long iwSpacesLim;
	long iwchFirst;
	long iwchLim;
	long duChange;
	long CurSpace;
	long itxtobj;
	long iwSpaces;
	long igind;
	long CurSpaceForSecondLoop;

	ptxtobj = (PTXTOBJ) plsgrchnk->plschnk[0].pdobj;
	plnobj = ptxtobj->plnobj;
	pilsobj = plnobj->pilsobj;
	rgwSpaces = pilsobj->pwSpaces;
	
	CurSpace = 0;

	for (itxtobj = itxtobjAfterStartSpaces; itxtobj <= itxtobjLast; itxtobj++)
		{

		ptxtobj = (PTXTOBJ) plsgrchnk->plschnk[itxtobj].pdobj;

		if (! (ptxtobj->txtf & txtfMonospaced) )
			{

			if (ptxtobj->txtkind == txtkindRegular)
				{
				iwSpacesFirst = ptxtobj->u.reg.iwSpacesFirst;
				iwSpacesLim = ptxtobj->u.reg.iwSpacesLim;

				iwchFirst = iwchAfterStartSpaces;
				if (itxtobj > itxtobjAfterStartSpaces)
					iwchFirst = ptxtobj->iwchFirst;

				iwchLim = iwchLast + 1;
				if (itxtobj < itxtobjLast)
					iwchLim = ptxtobj->iwchLim;

				while (iwSpacesFirst < iwSpacesLim && rgwSpaces[iwSpacesFirst] < iwchFirst)
					{
					iwSpacesFirst++;
					}

				while (iwSpacesLim > iwSpacesFirst && rgwSpaces[iwSpacesLim-1] >= iwchLim)
					{
					iwSpacesLim--;
					}

				if (ptxtobj->txtf & txtfGlyphBased)
					{
					for(iwSpaces = iwSpacesFirst; iwSpaces < iwSpacesLim; iwSpaces++)
						{
						if (FIwchOneToOne(pilsobj, rgwSpaces[iwSpaces]))
							{
							igind = IgindFirstFromIwch(ptxtobj, rgwSpaces[iwSpaces]);
							duChange =  -(rgduGind[igind] >> SqueezingFactorShift) + duSubstr;
							if (CurSpace < wDuBound)
								{
								duChange += 1;
								}

							rgduGind[igind] += duChange;
							pilsobj->pduGright[igind] += duChange;

							CurSpace++;

							}
						}
					}
				else
					{
					CurSpaceForSecondLoop = CurSpace;
					for(iwSpaces = iwSpacesFirst; iwSpaces < iwSpacesLim; iwSpaces++)
						{
						duChange =  -(rgdu[rgwSpaces[iwSpaces]] >> SqueezingFactorShift) + duSubstr;
						if (CurSpace < wDuBound)
							{
							duChange += 1;
							}

						rgdu[rgwSpaces[iwSpaces]] += duChange;

						CurSpace++;

						}
					if (pilsobj->fNotSimpleText)
						{

						for(iwSpaces = iwSpacesFirst; iwSpaces < iwSpacesLim; iwSpaces++)
							{
							duChange =  -(rgdu[rgwSpaces[iwSpaces]] >> SqueezingFactorShift) + duSubstr;
							if (CurSpaceForSecondLoop < wDuBound)
								{
								duChange += 1;
								}

							pilsobj->pdurRight[rgwSpaces[iwSpaces]] += duChange;

							CurSpaceForSecondLoop++;

							}
						}
					}
				}
			}

		}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\lstxtscl.c ===
#include "lsmem.h"
#include <limits.h>

#include "lstxtscl.h"

#include "lstxtmap.h"
#include "lsdntext.h"
#include "zqfromza.h"
#include "txtils.h"
#include "txtln.h"
#include "txtobj.h"

static void ApplyWysiGlyphs(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, long itxtobjStart,
							long durSumStart, long dupSumStart, BOOL fContinueWysiStart,
							long* pitxtobjLim, long* pdurSum, long* pdupSum);
static void CopyRefToPresForScaleCharSides(const LSGRCHNK* plsgrchnk, BOOL* pfLeftSideAffected, BOOL* pfGlyphDetected);
static void CopyRefToPresForScaleGlyphSides(const LSGRCHNK* plsgrchnk);

#define min(a,b)     ((a) > (b) ? (b) : (a))
#define max(a,b)     ((a) < (b) ? (b) : (a))
#define abs(a)     	((a) < 0 ? (-a) : (a))

#define SetMagicConstant() (lstflow & fUVertical) ? \
	(MagicConstant = pilsobj->MagicConstantY, durRightMax = pilsobj->durRightMaxY) : \
	(MagicConstant = pilsobj->MagicConstantX, durRightMax = pilsobj->durRightMaxX)

#define UpFromUrFast(ur)	( ((ur) * MagicConstant + (1 << 20)) >> 21)

#define FAdjustable(ptxtobj) (!((ptxtobj)->txtf & txtfSkipAtWysi)  && \
						((ptxtobj)->iwchLim - (ptxtobj)->iwchFirst > 0))

/* A P P L Y  W Y S I */
/*----------------------------------------------------------------------------
    %%Function: ApplyWysi
    %%Contact: sergeyge

	WYSIWYG algorithm for exact positioning of characters without wiggling
----------------------------------------------------------------------------*/
void ApplyWysi(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow) 
{
	PLNOBJ plnobj;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	long* rgdur;
	long* rgdup;
	long iwch;
	long itxtobj;
	long iwchPrev = 0;
	long iwchLim;
	BOOL fContinueWysi;
	BOOL fContinueAveraging;
	long durSum = 0;
	long dupSum = 0;
	long dupErrLast = 0;
	long dupPrevChar = 0;
	long MagicConstant;
	long durRightMax;
	long dupIdeal;
	long dupReal;
	long dupErrNew;
	long dupAdjust;
	long wCarry;

	long itxtobjNew;
	long durSumNew;
	long dupSumNew;

	Assert (plsgrchnk->clsgrchnk > 0);

	ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[0].pdobj;
	plnobj = ptxtobj->plnobj;
	pilsobj = plnobj->pilsobj;

	if (pilsobj->fPresEqualRef)
		return;

	SetMagicConstant();

	rgdur = pilsobj->pdur;
	rgdup = plnobj->pdup;

	fContinueWysi = fFalse;
	fContinueAveraging = fFalse;

	itxtobj = 0;

	while(itxtobj < (long)plsgrchnk->clsgrchnk)
		{
		ptxtobj = (PTXTOBJ) plsgrchnk->plschnk[itxtobj].pdobj;
		Assert(ptxtobj->txtkind != txtkindTab);
		if (ptxtobj->txtf & txtfGlyphBased)
			{
			ApplyWysiGlyphs(plsgrchnk, lstflow, itxtobj, durSum, dupSum, fContinueWysi, 
															&itxtobjNew, &durSumNew, &dupSumNew);
			itxtobj = itxtobjNew;
			durSum = durSumNew;
			dupSum = dupSumNew;
			fContinueAveraging = fFalse;
			fContinueWysi = fTrue;
			}
		else
			{
			if (FAdjustable(ptxtobj))
				{

				fContinueAveraging = fContinueAveraging && !(plsgrchnk->pcont[itxtobj] & fcontNonTextBefore);

				iwch = ptxtobj->iwchFirst;
				iwchLim = ptxtobj->iwchLim;

				while (iwch < iwchLim)
					{
					if (!fContinueAveraging)
						{
						fContinueAveraging = fTrue;
						if (!fContinueWysi)
							{
							fContinueWysi = fTrue;
							durSum = rgdur[iwch];
							if (durSum <= durRightMax)
								{
								dupIdeal = UpFromUrFast(durSum);
								dupErrLast = rgdup[iwch] - dupIdeal;
								rgdup[iwch] = dupIdeal;
								dupPrevChar = dupIdeal;
								iwchPrev = iwch;
								dupSum = dupIdeal;
								Assert(dupSum >= 0);
								}
							else
								{
								rgdup[iwch] = UpFromUr(lstflow, &pilsobj->lsdevres, durSum);
								dupSum = rgdup[iwch];
		/* Nothing else is set here because inside following while loop, first IF 
			will be FALSE and loop will be terminated
		*/
								}
							iwch++;
							}
						else
							{
							durSum += rgdur[iwch];
							if (durSum <= durRightMax)
								{
								dupIdeal = UpFromUrFast(durSum) - dupSum;
								dupErrLast = rgdup[iwch] - dupIdeal;
								rgdup[iwch] = dupIdeal;
								dupPrevChar = dupIdeal;
								iwchPrev = iwch;
								dupSum += dupIdeal;
								Assert(dupSum >= 0);
								iwch++;
								}
							else
								{
								durSum -= rgdur[iwch];
		/* Small triangle. Strictly speaking we could change nothing here
			but it is cleaner to keep invariants in order.
			Nothing else is set here because inside following while loop, first IF will 
			be FALSE and loop will be terminated.
		*/
								}
							}

						}

					while(iwch < iwchLim /* && fContinueWysi --replaced by break*/)
						{
						durSum += rgdur[iwch];
						if (durSum <= durRightMax)
							{
						/* here David Bangs algorithm starts */
							dupIdeal = UpFromUrFast(durSum) - dupSum;
							Assert(dupIdeal >= 0);

							dupReal = rgdup[iwch];
							dupErrNew = dupReal - dupIdeal;
							dupAdjust = dupErrNew - dupErrLast;
							if (dupAdjust != 0)
								{
								wCarry = dupAdjust & 1;

							   	if (dupAdjust > 0)	
			   						{
							   		dupAdjust >>= 1;
	   								if (dupErrLast < -dupErrNew)
										dupAdjust += wCarry;
									dupAdjust = min(dupPrevChar /*-1*/, dupAdjust); 
									}
								else
									{
									dupAdjust >>= 1;
									if (dupErrNew < -dupErrLast)
										dupAdjust += wCarry;
									dupAdjust = max(/*1*/ - dupIdeal, dupAdjust); 
									}
								}
				
							rgdup[iwchPrev] -= dupAdjust;
							dupIdeal += dupAdjust;
							rgdup[iwch] = dupIdeal;
							dupSum += (dupIdeal - dupAdjust);
							dupErrLast = dupReal - dupIdeal;
							iwchPrev = iwch;
							dupPrevChar = dupIdeal;
						/* here David Bangs algorithm stops */
							iwch++;
							}
						else
							{
							fContinueWysi = fFalse;
							fContinueAveraging = fFalse;
							break;
							}
						}


					}

				}

			else
				{
				fContinueAveraging = fFalse;
				}
			itxtobj++;
			}

		}

	return;

}


/* S C A L E  S P A C E S */
/*----------------------------------------------------------------------------
    %%Function: ScaleSpaces
    %%Contact: sergeyge

	Scales down widths of spaces 
----------------------------------------------------------------------------*/
void ScaleSpaces(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, long itxtobjLast, long iwchLast)
{
	PTXTOBJ ptxtobj;
	PILSOBJ pilsobj;
	PLNOBJ plnobj;
	long* rgdur;
	long* rgdup;
	long* rgwSpaces;
	long iwSpacesLim;
	long iwchLim;
	long itxtobj;
	long MagicConstant;
	long durRightMax;
	long dupSpace;
	long i;

	Assert (plsgrchnk->clsgrchnk > 0);

	plnobj = ((PTXTOBJ)(plsgrchnk->plschnk[0].pdobj))->plnobj;
	pilsobj = plnobj->pilsobj;
	rgdur = pilsobj->pdur;
	rgdup = plnobj->pdup;
	rgwSpaces = pilsobj->pwSpaces;

	Assert(!pilsobj->fPresEqualRef);
	Assert(!pilsobj->fNotSimpleText);

	SetMagicConstant();

	for (itxtobj = 0; itxtobj <= itxtobjLast; itxtobj++)
		{
		ptxtobj = (PTXTOBJ) plsgrchnk->plschnk[itxtobj].pdobj;

		Assert(!(ptxtobj->txtf & txtfGlyphBased));

		if (ptxtobj->txtkind == txtkindRegular)
			{
			iwSpacesLim = ptxtobj->u.reg.iwSpacesLim;

			iwchLim = iwchLast + 1;
			if (itxtobj < itxtobjLast)
				iwchLim = ptxtobj->iwchLim;

			while (iwSpacesLim > ptxtobj->u.reg.iwSpacesFirst && rgwSpaces[iwSpacesLim-1] >= iwchLim)
				{
				iwSpacesLim--;
				}

			for(i = ptxtobj->u.reg.iwSpacesFirst; i < iwSpacesLim; i++)
				{
				if (rgdur[rgwSpaces[i]] < durRightMax)
					{
					dupSpace = UpFromUrFast(rgdur[rgwSpaces[i]]);
					}
				else
					{
					dupSpace = UpFromUr(lstflow, &pilsobj->lsdevres, rgdur[rgwSpaces[i]]);
					}
				Assert(dupSpace >= 0);
				rgdup[rgwSpaces[i]] = dupSpace;
				}
			}
		}

	return;

}

/* S C A L E  C H A R  S I D E S */
/*----------------------------------------------------------------------------
    %%Function: ScaleCharSides
    %%Contact: sergeyge

	Scales down changes applied to characters
----------------------------------------------------------------------------*/
void ScaleCharSides(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, BOOL* pfLeftSideAffected, BOOL* pfGlyphDetected)
{
	PLNOBJ plnobj;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	long* rgdur;
	long* rgdup;
	long* rgdurRight;
	long* rgdurLeft;
	long i;
	long itxtobj;
	long iLim;
	long durTemp = 0;
	long dupTemp = 0;
	long MagicConstant;
	long durRightMax;

	Assert (plsgrchnk->clsgrchnk > 0);

	*pfLeftSideAffected = fFalse;
	*pfGlyphDetected = fFalse;
	ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[0].pdobj;
	plnobj = ptxtobj->plnobj;
	pilsobj = plnobj->pilsobj;

	if (pilsobj->fPresEqualRef)
		{
		CopyRefToPresForScaleCharSides(plsgrchnk, pfLeftSideAffected, pfGlyphDetected);
		return;
		}

	SetMagicConstant();

	for (itxtobj = 0; itxtobj < (long)plsgrchnk->clsgrchnk; itxtobj++)
		{
		ptxtobj = (PTXTOBJ) plsgrchnk->plschnk[itxtobj].pdobj;

		Assert(ptxtobj->txtkind != txtkindTab);
		if (ptxtobj->txtf & txtfGlyphBased)
			{
			*pfGlyphDetected = fTrue;
			}
		else
			{
			if (FAdjustable(ptxtobj))
				{
				rgdur = pilsobj->pdur;
				rgdup = plnobj->pdup;
				rgdurRight = pilsobj->pdurRight;
				rgdurLeft = pilsobj->pdurLeft;

				i = ptxtobj->iwchFirst;
				iLim = ptxtobj->iwchLim;

				while(i < iLim)
					{
					durTemp = rgdurRight[i] + rgdurLeft[i];
					*pfLeftSideAffected = *pfLeftSideAffected || (rgdurLeft[i] != 0);
					if (durTemp != 0)
						{
						if (abs(durTemp) <= durRightMax)
							{
							dupTemp = UpFromUrFast(durTemp);
							}
						else
							{
							dupTemp = UpFromUr(lstflow, &pilsobj->lsdevres, durTemp);
							}
						rgdup[i] += dupTemp;
						}
					i++;
					}

				}
			}
		}

	return;
}

/* S C A L E  G L Y P H  S I D E S */
/*----------------------------------------------------------------------------
    %%Function: ScaleGlyphSides
    %%Contact: sergeyge

	Scales down changes applied to glyphs
----------------------------------------------------------------------------*/
void ScaleGlyphSides(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow)
{
	PLNOBJ plnobj;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	long* rgdur;
	long* rgdup;
	long* rgdurRight;
	long i;
	long itxtobj;
	long iLim;
	long durTemp = 0;
	long dupTemp = 0;
	long MagicConstant;
	long durRightMax;

	Assert (plsgrchnk->clsgrchnk > 0);

	ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[0].pdobj;
	plnobj = ptxtobj->plnobj;
	pilsobj = plnobj->pilsobj;

	if (pilsobj->fPresEqualRef)
		{
		CopyRefToPresForScaleGlyphSides(plsgrchnk);
		return;
		}

	SetMagicConstant();

	for (itxtobj = 0; itxtobj < (long)plsgrchnk->clsgrchnk; itxtobj++)
		{
		ptxtobj = (PTXTOBJ) plsgrchnk->plschnk[itxtobj].pdobj;

		Assert(ptxtobj->txtkind != txtkindTab);
		if (ptxtobj->txtf & txtfGlyphBased)
			{
			Assert (FAdjustable(ptxtobj));
			rgdur = pilsobj->pdurGind;
			rgdup = plnobj->pdupGind;
			rgdurRight = pilsobj->pduGright;

			i = ptxtobj->igindFirst;
			iLim = ptxtobj->igindLim;

			while(i < iLim)
				{
				durTemp = rgdurRight[i];
				if (durTemp != 0)
					{
					if (abs(durTemp) <= durRightMax)
						{
						dupTemp = UpFromUrFast(durTemp);
						}
					else
						{
						dupTemp = UpFromUr(lstflow, &pilsobj->lsdevres, durTemp);
						}
					rgdup[i] += dupTemp;
					rgdurRight[i] = dupTemp;

					}
				i++;
				}
			}
		}

	return;
}

/* U P D A T E  G L Y P H  O F F S E T S */
/*----------------------------------------------------------------------------
    %%Function: UpdateGlyphOffsets
    %%Contact: sergeyge

	Adjusts offsets of glyphs which are attached to the glyph with changed width
----------------------------------------------------------------------------*/
void UpdateGlyphOffsets(const LSGRCHNK* plsgrchnk)
{
	PLNOBJ plnobj;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	long* rgduRight;
	long* rgdup;
	long igind;
	long itxtobj;
	long dupTemp = 0;

	Assert (plsgrchnk->clsgrchnk > 0);

	ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[0].pdobj;
	plnobj = ptxtobj->plnobj;
	pilsobj = plnobj->pilsobj;


	rgduRight = pilsobj->pduGright;
	rgdup = plnobj->pdupGind;

	for (itxtobj = 0; itxtobj < (long)plsgrchnk->clsgrchnk; itxtobj++)
		{
		ptxtobj = (PTXTOBJ) plsgrchnk->plschnk[itxtobj].pdobj;

		Assert(ptxtobj->txtkind != txtkindTab);
		if (ptxtobj->txtf & txtfGlyphBased)
			{
			igind = ptxtobj->igindFirst;
			while(igind < ptxtobj->igindLim)
				{
				dupTemp = rgduRight[igind];
				if (dupTemp != 0)
					{
					while(!FIgindLastInContext(pilsobj, igind) && rgdup[igind + 1] == 0)
						{
						igind++;
						plnobj->pgoffs[igind].du -= dupTemp;
						}
					}
				
				igind++;
				}
			memset(&rgduRight[ptxtobj->igindFirst], 0, sizeof(long)*(ptxtobj->igindLim - ptxtobj->igindFirst));
			}
		}

}

/* S E T  B E F O R E  J U S T  C O P Y */
/*----------------------------------------------------------------------------
    %%Function: SetBeforeJustCopy
    %%Contact: sergeyge

	Fills pdupBeforeJust output array
----------------------------------------------------------------------------*/
void SetBeforeJustCopy(const LSGRCHNK* plsgrchnk)
{
	PLNOBJ plnobj;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	long itxtobj;
	long igindFirst;
	long igindLim;

	ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[0].pdobj;
	plnobj = ptxtobj->plnobj;
	pilsobj = plnobj->pilsobj;

	for (itxtobj = 0; itxtobj < (long)plsgrchnk->clsgrchnk; itxtobj++)
		{
		ptxtobj = (PTXTOBJ) plsgrchnk->plschnk[itxtobj].pdobj;

		Assert(ptxtobj->txtkind != txtkindTab);
		if (ptxtobj->txtf & txtfGlyphBased)
			{
			igindFirst = ptxtobj->igindFirst;
			igindLim = ptxtobj->igindLim;
			memcpy(&plnobj->pdupBeforeJust[igindFirst], &plnobj->pdupGind[igindFirst], sizeof(long)*(igindLim - igindFirst));
			}
		}
}


/* S C A L E  E X T  N O N  T E X T */
/*----------------------------------------------------------------------------
    %%Function: ScaleExtNonText
    %%Contact: sergeyge

	Scales down change which is 
	to be applyed by manager to non-text objects
----------------------------------------------------------------------------*/
void ScaleExtNonText(PILSOBJ pilsobj, LSTFLOW lstflow, long durExtNonText, long* pdupExtNonText)
{
	long MagicConstant;
	long durRightMax;

	if (pilsobj->fPresEqualRef)
		*pdupExtNonText = durExtNonText;
	else
		{

		SetMagicConstant();

		*pdupExtNonText = 0;
		Assert(durExtNonText >= 0);
		if (durExtNonText > 0)
			{
			if (durExtNonText <= durRightMax)
				{
				*pdupExtNonText = UpFromUrFast(durExtNonText);
				}
			else
				{
				*pdupExtNonText = UpFromUr(lstflow, &pilsobj->lsdevres, durExtNonText);
				}
			}
		}

	return;
}

/* G E T  D U P  L A S T  C H A R */
/*----------------------------------------------------------------------------
    %%Function: GetDupLastChar
    %%Contact: sergeyge

----------------------------------------------------------------------------*/
void GetDupLastChar(const LSGRCHNK* plsgrchnk, long iwchLast, long* pdupHangingChar)
{
	*pdupHangingChar = ((PTXTOBJ)plsgrchnk->plschnk[0].pdobj)->plnobj->pdup[iwchLast];
}


/* F I L L  D U P  P E N */
/*----------------------------------------------------------------------------
    %%Function: FillDupPen
    %%Contact: sergeyge


	In the case when some characters were changed on the left side,
	prepares array of widths which is used at display time 
----------------------------------------------------------------------------*/
LSERR FillDupPen(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, long itxtobjLast, long iwchLast)
{
	PLNOBJ plnobj;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	long* rgdup;
	long* rgdupPen;
	long* rgdurLeft;
	long iwch;
	long iwchLocLim;
	long iwchLim;
	long itxtobj;
	long MagicConstant;
	long durRightMax;
	long durLeft;
	long dupLeft;

	Assert (plsgrchnk->clsgrchnk > 0);

	ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[0].pdobj;
	plnobj = ptxtobj->plnobj;
	pilsobj = plnobj->pilsobj;

	if (plnobj->pdupPenAlloc == NULL)
		{
		plnobj->pdupPenAlloc = (*pilsobj->plscbk->pfnNewPtr)(pilsobj->pols, sizeof(long) * pilsobj->wchMax);
		if (plnobj->pdupPenAlloc == NULL)
			return lserrOutOfMemory;

		memset(plnobj->pdupPenAlloc, 0,  sizeof(long) * pilsobj->wchMax);
		}

	if (plnobj->pdupPen == plnobj->pdup)
		{
		plnobj->pdupPen = plnobj->pdupPenAlloc;
		memcpy(plnobj->pdupPen, plnobj->pdup, sizeof(long) * pilsobj->wchMac);
		}

	rgdurLeft = pilsobj->pdurLeft;
	rgdup = plnobj->pdup;
	rgdupPen = plnobj->pdupPen;

	SetMagicConstant();

	for (itxtobj = 0; itxtobj <= itxtobjLast; itxtobj++)
		{
		ptxtobj = (PTXTOBJ) plsgrchnk->plschnk[itxtobj].pdobj;
		/* Left chopping is impossible for glyph-based runs;
			no additional data structures are introduced for glyphs for
			this case.
		 */
		if (!(ptxtobj->txtf & txtfGlyphBased) )
			{

			Assert(ptxtobj->txtkind != txtkindTab);

			iwch = ptxtobj->iwchFirst;
			iwchLocLim = iwchLast + 1;
			if (itxtobj < itxtobjLast)
				iwchLocLim = ptxtobj->iwchLim;

			Assert(iwchLocLim <= ptxtobj->iwchLim);

			if (iwch < iwchLocLim)
				{
				rgdupPen[iwch] = rgdup[iwch];
				durLeft = rgdurLeft[iwch];
				if (durLeft != 0)
					{
					if (pilsobj->fPresEqualRef)
						dupLeft = durLeft;
					else
						{
						if (abs(durLeft) <= durRightMax)
							{
							dupLeft = UpFromUrFast(durLeft);
							}
						else
							{
							dupLeft = UpFromUr(lstflow, &pilsobj->lsdevres, durLeft);
							}
						}

					ptxtobj->dupBefore = -dupLeft;
					rgdupPen[iwch] -= dupLeft;
					}

				iwch++;
				}


			while (iwch < iwchLocLim)
				{
				rgdupPen[iwch] = rgdup[iwch];
				durLeft = rgdurLeft[iwch];
				if (durLeft != 0)
					{
					if (pilsobj->fPresEqualRef)
						dupLeft = durLeft;
					else
						{
						if (abs(durLeft) <= durRightMax)
							{
							dupLeft = UpFromUrFast(durLeft);
							}
						else
							{
							dupLeft = UpFromUr(lstflow, &pilsobj->lsdevres, durLeft);
							}
						}

					rgdupPen[iwch-1] += dupLeft;
					rgdupPen[iwch] -= dupLeft;
					}

				iwch++;
				}

			iwchLim = ptxtobj->iwchLim;

			Assert(iwch == iwchLocLim);


			for (; iwch < iwchLim; iwch++)
				{
				rgdupPen[iwch] = rgdup[iwch];
				}
			}
		}

	Assert(itxtobj == itxtobjLast + 1);

	for (; itxtobj < (long)plsgrchnk->clsgrchnk; itxtobj++)
		{
		ptxtobj = (PTXTOBJ) plsgrchnk->plschnk[itxtobj].pdobj;
		if (!(ptxtobj->txtf & txtfGlyphBased))
			{

			for (iwch = ptxtobj->iwchFirst; iwch < ptxtobj->iwchLim; iwch++)
				{
				rgdupPen[iwch] = rgdup[iwch];
				}
			}
		}

	return lserrNone;
}

/* F I N A L  A D J U S T M E N T  O N  P R E S */
/*----------------------------------------------------------------------------
    %%Function: FinalAdjustmentOnPres
    %%Contact: sergeyge

	Sets dup's to DNODE's
	Implements emergency procedures to fit on presentation device
----------------------------------------------------------------------------*/
LSERR FinalAdjustmentOnPres(const LSGRCHNK* plsgrchnk, long itxtobjLast, long iwchLast,
					long dupAvailable, BOOL fFullyScaled, BOOL fForcedBreak, BOOL fSuppressTrailingSpaces,
					long* pdupText, long* pdupTail)
{
	LSERR lserr;
	PLNOBJ plnobj;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	PTXTOBJ ptxtobjLast;
	long* rgdup;
	long iFirst;
	long iLim;
	long iMinLim;
	long dupTotal;
	long dupToDistribute;
	long dupAdd;
	long dupChange;
	long itxtobj;
	long i;
	long iTemp;
	long dupToDistributePrev;

	Assert (plsgrchnk->clsgrchnk > 0);
	Assert (itxtobjLast < (long)plsgrchnk->clsgrchnk);
	
	ptxtobjLast = (PTXTOBJ)plsgrchnk->plschnk[max(0, itxtobjLast)].pdobj;
	plnobj = ptxtobjLast->plnobj;
	pilsobj = plnobj->pilsobj;

	*pdupText = 0;
	*pdupTail = 0;

	for (itxtobj=0; itxtobj < (long)plsgrchnk->clsgrchnk; itxtobj++)
		{
		ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;
		dupTotal = 0;
		if (ptxtobj->txtf & txtfGlyphBased)
			{
			iFirst = ptxtobj->igindFirst;
			iLim = ptxtobj->igindLim;
			iMinLim = iLim;
			if (itxtobj == itxtobjLast)
				iMinLim = IgindLastFromIwch(ptxtobjLast, iwchLast) + 1;
			else if (itxtobj > itxtobjLast)
				iMinLim = iFirst;
			rgdup = plnobj->pdupGind;
			}
		else
			{
			iFirst = ptxtobj->iwchFirst;
			iLim = ptxtobj->iwchLim;
			iMinLim = iLim;
			if (itxtobj == itxtobjLast)
				iMinLim = iwchLast + 1;
			else if (itxtobj > itxtobjLast)
				iMinLim = iFirst;

			rgdup = plnobj->pdup;
			}

		for (i = iFirst; i < iMinLim; i++)
			{
			dupTotal += rgdup[i];
			}

		Assert(i >= iMinLim);

/* Take care of trailing area, taking into account fSuppressTrailingSpaces bit */
		if (fSuppressTrailingSpaces)
			{
			for (; i < iLim; i++)
				{
				rgdup[i] = 0;
				}
			}
		else
			{
			for (; i < iLim; i++)
				{
				dupTotal += rgdup[i];
				*pdupTail += rgdup[i];
				}
			}

		*pdupText += dupTotal;
		lserr = LsdnSetTextDup(plnobj->pilsobj->plsc, ptxtobj->plsdnUpNode, dupTotal);
		if (lserr != lserrNone) return lserr;
		}

	if (itxtobjLast < 0)
		return lserrNone;

	dupToDistribute = dupAvailable - (*pdupText - *pdupTail);

/* fFinalAdjustNeeded==fTrue, if there were spaces on the line. If there were no spaces,
		justification is not needed
*/
	if ( (!fForcedBreak && dupToDistribute < 0 && -dupToDistribute < *pdupText) ||
		 	(dupToDistribute > 0 && fFullyScaled))
		{

		dupAdd = 0;
		if (dupToDistribute > 0)
			{
			dupAdd  = 1;
			}
		else if (dupToDistribute < 0)
			{
			dupAdd = -1;
			}

		dupToDistributePrev = 0;
		while (dupToDistribute != 0 && dupToDistributePrev != dupToDistribute)
			{

			dupToDistributePrev = dupToDistribute;

			for (itxtobj = itxtobjLast; itxtobj >= 0 && dupToDistribute != 0; itxtobj--)
				{
				ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[itxtobj].pdobj;
				dupChange = 0;
				/* REVIEW sergeyge: iwchLast-1 is used because we want correct alignment for the
							last character. Is it correct?
				*/
				if (ptxtobj->txtf & txtfGlyphBased)
					{
					rgdup = plnobj->pdupGind;

					if (itxtobj == itxtobjLast)
						i = IgindLastFromIwch(ptxtobjLast, iwchLast);
					else
						{ 
						Assert(itxtobj < itxtobjLast);
						i = ptxtobj->igindLim - 1;
						}

					for (; i >= ptxtobj->igindFirst && dupToDistribute != 0; i--)
						{
						if (rgdup[i] > 1)
							{
							rgdup[i] += dupAdd;
							iTemp = i;
							while(!FIgindLastInContext(pilsobj, iTemp) && rgdup[iTemp + 1] == 0)
								{
								iTemp++;
								plnobj->pgoffs[iTemp].du -= dupAdd;
								}

							dupToDistribute -= dupAdd;
							dupChange += dupAdd;
							}
						}
					}
				else
					{
					rgdup = plnobj->pdup;
					i = iwchLast;
					if (itxtobj < itxtobjLast)
						i = ptxtobj->iwchLim - 1;
					for (; i >= ptxtobj->iwchFirst && dupToDistribute != 0; i--)
						{
						if (rgdup[i] > 1)
							{
							rgdup[i] += dupAdd;
							dupToDistribute -= dupAdd;
							dupChange += dupAdd;
							}
						}
					}
			
				lserr = LsdnModifyTextDup(ptxtobj->plnobj->pilsobj->plsc, ptxtobj->plsdnUpNode, dupChange);
				if (lserr != lserrNone) return lserr;

				*pdupText += dupChange;
			
				}
			}


		}

	return lserrNone;
}

/* Internal Procedures Implementation */

/* A P P L Y  W Y S I  G L Y P H S */
/*----------------------------------------------------------------------------
    %%Function: ApplyWysiGlyphs
    %%Contact: sergeyge

	WYSIWYG algorithm for exact positioning of glyphs without wiggling
----------------------------------------------------------------------------*/
static void ApplyWysiGlyphs(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow, long itxtobjStart,
							long durSumStart, long dupSumStart, BOOL fContinueWysiStart,
							long* pitxtobjLim, long* pdurSum, long* pdupSum)
{
	PLNOBJ plnobj;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	long* rgdur;
	long* rgdup;
	long igind;
	long itxtobj;
	long igindPrev = 0;
	long igindLim;
	BOOL fContinueWysi;
	BOOL fContinueAveraging;
	long durSum;
	long dupSum;
	long dupErrLast = 0;
	long dupPrevChar = 0;
	long MagicConstant;
	long durRightMax;
	long dupIdeal;
	long dupReal;
	long dupErrNew;
	long dupAdjust;
	long wCarry;

	ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[0].pdobj;
	plnobj = ptxtobj->plnobj;
	pilsobj = plnobj->pilsobj;

	SetMagicConstant();

	rgdur = pilsobj->pdurGind;
	rgdup = plnobj->pdupGind;

	fContinueAveraging = fFalse;

	durSum = durSumStart;
	dupSum = dupSumStart;
	fContinueWysi = fContinueWysiStart;

	itxtobj = itxtobjStart;

	while(itxtobj < (long)plsgrchnk->clsgrchnk)
		{
		ptxtobj = (PTXTOBJ) plsgrchnk->plschnk[itxtobj].pdobj;
		Assert(ptxtobj->txtkind != txtkindTab);
		if (ptxtobj->txtf & txtfGlyphBased)
			{
			Assert(FAdjustable(ptxtobj));

			fContinueAveraging = fContinueAveraging && !(plsgrchnk->pcont[itxtobj] & fcontNonTextBefore);

			igind = ptxtobj->igindFirst;
			igindLim = ptxtobj->igindLim;

			while (igind < igindLim)
				{
				if (!fContinueAveraging)
					{
					fContinueAveraging = fTrue;
					if (!fContinueWysi)
						{
						fContinueWysi = fTrue;
						durSum = rgdur[igind];
						if (durSum <= durRightMax)
							{
							dupIdeal = UpFromUrFast(durSum);
							dupErrLast = rgdup[igind] - dupIdeal;
							rgdup[igind] = dupIdeal;
							dupPrevChar = dupIdeal;
							igindPrev = igind;
							dupSum = dupIdeal;
							Assert(dupSum >= 0);
							while(!FIgindLastInContext(pilsobj, igind) && rgdup[igind + 1] == 0)
								{
								igind++;
								plnobj->pgoffs[igind].du += dupErrLast;
								}
							}
						else
							{
							dupIdeal = UpFromUr(lstflow, &pilsobj->lsdevres, durSum);
							dupErrLast = rgdup[igind] - dupIdeal;
							rgdup[igind] = dupIdeal;
							dupSum = dupIdeal;
		/* Nothing else is set here because inside following while loop, first IF 
			will be FALSE and loop will be terminated
		*/
							while(!FIgindLastInContext(pilsobj, igind) && rgdup[igind + 1] == 0)
								{
								igind++;
								plnobj->pgoffs[igind].du += dupErrLast;
								}
							}
						igind++;
						}
					else
						{
						durSum += rgdur[igind];
						if (durSum <= durRightMax)
							{
							dupIdeal = UpFromUrFast(durSum) - dupSum;
							dupErrLast = rgdup[igind] - dupIdeal;
							rgdup[igind] = dupIdeal;
							dupPrevChar = dupIdeal;
							igindPrev = igind;
							dupSum += dupIdeal;
							Assert(dupSum >= 0);
							while(!FIgindLastInContext(pilsobj, igind) && rgdup[igind + 1] == 0)
								{
								igind++;
								plnobj->pgoffs[igind].du += dupErrLast;
								}
							igind++;
							}
						else
							{
							durSum -= rgdur[igind];
		/* Small triangle. Strictly speaking we could change nothing here
			but it is cleaner to keep invariants in order.
			Nothing else is set here because inside following while loop, first IF will 
			be FALSE and loop will be terminated.
		*/
							}
						}
					}

				while(igind < igindLim /* && fContinueWysi --replaced by break*/)
					{
					durSum += rgdur[igind];
					if (durSum <= durRightMax)
						{
					/* here David Bangs algorithm starts */
						dupIdeal = UpFromUrFast(durSum) - dupSum;
						Assert(dupIdeal >= 0);

						dupReal = rgdup[igind];
						dupErrNew = dupReal - dupIdeal;
						dupAdjust = dupErrNew - dupErrLast;
						if (dupAdjust != 0)
							{
							wCarry = dupAdjust & 1;

						   	if (dupAdjust > 0)	
		   						{
						   		dupAdjust >>= 1;
   								if (dupErrLast < -dupErrNew)
									dupAdjust += wCarry;
								dupAdjust = min(dupPrevChar /*-1*/, dupAdjust); 
								}
							else
								{
								dupAdjust >>= 1;
								if (dupErrNew < -dupErrLast)
									dupAdjust += wCarry;
								dupAdjust = max(/*1*/ - dupIdeal, dupAdjust); 
								}
							}
			
						rgdup[igindPrev] -= dupAdjust;
						while(!FIgindLastInContext(pilsobj, igindPrev) && rgdup[igindPrev + 1] == 0)
							{
							igindPrev++;
							plnobj->pgoffs[igindPrev].du += dupAdjust;
							}
						dupIdeal += dupAdjust;
						rgdup[igind] = dupIdeal;
						dupSum += (dupIdeal - dupAdjust);
						dupErrLast = dupReal - dupIdeal;
						igindPrev = igind;
						while(!FIgindLastInContext(pilsobj, igind) && rgdup[igind + 1] == 0)
							{
							igind++;
							plnobj->pgoffs[igind].du += dupErrLast;
							}
						dupPrevChar = dupIdeal;
						/* here David Bangs algorithm stops */
						igind++;
						}
					else
						{
						fContinueWysi = fFalse;
						fContinueAveraging = fFalse;
						break;
						}
					}

				}

			itxtobj++;

			}
		else
			{
			break;
			}
		}

	*pitxtobjLim = itxtobj;
	*pdurSum = durSum;
	*pdupSum = dupSum;	

	return;

}

/* C O P Y  R E F  T O  P R E S  F O R  S C A L E  C H A R  S I D E S */
/*----------------------------------------------------------------------------
    %%Function: CopyRefToPresForScaleCharSides
    %%Contact: sergeyge

----------------------------------------------------------------------------*/
static void CopyRefToPresForScaleCharSides(const LSGRCHNK* plsgrchnk, BOOL* pfLeftSideAffected, BOOL* pfGlyphDetected)
{
	PLNOBJ plnobj;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	long itxtobj;
	long iFirst;
	long iLim;
	long i;

	ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[0].pdobj;
	plnobj = ptxtobj->plnobj;
	pilsobj = plnobj->pilsobj;

	*pfLeftSideAffected = fFalse;
	*pfGlyphDetected = fFalse;

	for (itxtobj = 0; itxtobj < (long)plsgrchnk->clsgrchnk; itxtobj++)
		{
		ptxtobj = (PTXTOBJ) plsgrchnk->plschnk[itxtobj].pdobj;

		Assert(ptxtobj->txtkind != txtkindTab);
		if (ptxtobj->txtf & txtfGlyphBased)
			{
			Assert (FAdjustable(ptxtobj));
			*pfGlyphDetected = fTrue;
			}
		else
			{
			if(FAdjustable(ptxtobj))
				{
				iFirst = ptxtobj->iwchFirst;
				iLim = ptxtobj->iwchLim;
				memcpy(&plnobj->pdup[iFirst], &pilsobj->pdur[iFirst], sizeof(long)*(iLim - iFirst));
				for (i = iFirst; i < iLim && !*pfLeftSideAffected; i++)
					{
					*pfLeftSideAffected = (pilsobj->pdurLeft[i] != 0);
					}
				}
			}
		}
}

/* C O P Y  R E F  T O  P R E S  F O R  S C A L E  G L Y P H  S I D E S */
/*----------------------------------------------------------------------------
    %%Function: CopyRefToPresForScaleGlyphSides
    %%Contact: sergeyge

----------------------------------------------------------------------------*/
static void CopyRefToPresForScaleGlyphSides(const LSGRCHNK* plsgrchnk)
{
	PLNOBJ plnobj;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	long itxtobj;
	long iFirst;
	long iLim;

	ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[0].pdobj;
	plnobj = ptxtobj->plnobj;
	pilsobj = plnobj->pilsobj;


	for (itxtobj = 0; itxtobj < (long)plsgrchnk->clsgrchnk; itxtobj++)
		{
		ptxtobj = (PTXTOBJ) plsgrchnk->plschnk[itxtobj].pdobj;

		Assert(ptxtobj->txtkind != txtkindTab);
		if (ptxtobj->txtf & txtfGlyphBased)
			{
			Assert (FAdjustable(ptxtobj));
			iFirst = ptxtobj->igindFirst;
			iLim = ptxtobj->igindLim;
			memcpy(&plnobj->pdupGind[iFirst], &pilsobj->pdurGind[iFirst], sizeof(long)*(iLim - iFirst));
			}
		}
}


#ifdef FUTURE

/* NOT USED IN LS 3.0 */

/* A P P L Y  N O N  E X A C T  W Y S I */
/*----------------------------------------------------------------------------
    %%Function: ApplyNonExactWysi
    %%Contact: sergeyge

	Alternative WYSIWYG algorithm of characters without wiggling
	sacrifices exact positioning somewhat in attempt to improve
	character spacing
----------------------------------------------------------------------------*/

#define dupBigError 2

void ApplyNonExactWysi(const LSGRCHNK* plsgrchnk, LSTFLOW lstflow) 
{
	PLNOBJ plnobj;
	PILSOBJ pilsobj;
	PTXTOBJ ptxtobj;
	long* rgdur;
	long* rgdup;
	WCHAR* rgwch;
	long iwch;
	long itxtobj;
	long iwchPrev = 0;
	long iwchLim;
	BOOL fContinueWysi;
	BOOL fContinueAveraging;
	long durSum = 0;
	long dupSum = 0;
	long dupErrLast = 0;
	long MagicConstant;
	long durRightMax;
	long dupIdeal;
	long dupAdjust;
	BOOL fInSpaces;

	Assert (plsgrchnk->clsgrchnk > 0);

	ptxtobj = (PTXTOBJ)plsgrchnk->plschnk[0].pdobj;
	plnobj = ptxtobj->plnobj;
	pilsobj = plnobj->pilsobj;

	if (pilsobj->fPresEqualRef)
		return;

	SetMagicConstant();

	rgdur = pilsobj->pdur;
	rgdup = plnobj->pdup;
	rgwch = pilsobj->pwchOrig;

	fContinueWysi = fFalse;
	fContinueAveraging = fFalse;

	itxtobj = 0;

	while(itxtobj < (long)plsgrchnk->clsgrchnk)
		{
		ptxtobj = (PTXTOBJ) plsgrchnk->plschnk[itxtobj].pdobj;
		Assert(ptxtobj->txtkind != txtkindTab);
		Assert(!(ptxtobj->txtf & txtfGlyphBased));
		if (FAdjustable(ptxtobj))
			{
			fInSpaces = ptxtobj->txtkind == txtkindSpecSpace || ptxtobj->txtkind == txtkindNonBreakSpace;

			fContinueAveraging = fContinueAveraging && !(plsgrchnk->pcont[itxtobj] & fcontNonTextBefore);

			iwch = ptxtobj->iwchFirst;
			iwchLim = ptxtobj->iwchLim;

			while (iwch < iwchLim)
				{
				if (!fContinueAveraging)
					{
					fContinueAveraging = fTrue;
					if (!fContinueWysi)
						{
						fContinueWysi = fTrue;
						durSum = rgdur[iwch];
						if (durSum <= durRightMax)
							{
							dupIdeal = UpFromUrFast(durSum);
							if (dupIdeal < 0)
								dupIdeal = 0;							

							dupErrLast = rgdup[iwch] - dupIdeal;
	
							iwchPrev = iwch;
							if (dupErrLast > dupBigError && rgdup[iwch] > 0)
								{
								rgdup[iwch]--;
								}
							else if (dupErrLast < -dupBigError)
								{
								rgdup[iwch]++;
								}

							dupSum = rgdup[iwch];
							Assert(dupSum >= 0);
							}
						else
							{
							rgdup[iwch] = UpFromUr(lstflow, &pilsobj->lsdevres, durSum);
							dupSum = rgdup[iwch];
	/* Nothing else is set here because inside following while loop, first IF 
		will be FALSE and loop will be terminated
	*/
							}
						iwch++;
						}
					else
						{
						durSum += rgdur[iwch];
						if (durSum <= durRightMax)
							{
							dupIdeal = UpFromUrFast(durSum) - dupSum;
							dupErrLast = rgdup[iwch] - dupIdeal;

							iwchPrev = iwch;

							if (dupErrLast > dupBigError && rgdup[iwch] > 0)
								{
								rgdup[iwch]--;
								}
							else if (dupErrLast < -dupBigError)
								{
								rgdup[iwch]++;
								}

							dupSum += rgdup[iwch];

							iwch++;
							}
						else
							{
							durSum -= rgdur[iwch];
	/* Small triangle. Strictly speaking we could change nothing here
		but it is cleaner to keep invariants in order.
		Nothing else is set here because inside following while loop, first IF will 
		be FALSE and loop will be terminated.
	*/
							}
						}

					}

				while(iwch < iwchLim /* && fContinueWysi --replaced by break*/)
					{
					durSum += rgdur[iwch];
					if (durSum <= durRightMax)
						{
					/* here modified David Bangs algorithm starts */
						dupIdeal = UpFromUrFast(durSum) - dupSum;
						Assert(dupIdeal >= 0);

						dupErrLast = rgdup[iwch] - dupIdeal;

						if (dupErrLast != 0  &&  (rgwch[iwch] == pilsobj->wchSpace || fInSpaces))
							{
							if (dupErrLast > 0)
								{
								dupAdjust = min(rgdup[iwch] >> 1, dupErrLast);
								rgdup[iwch] -= dupAdjust;
								}
							else
								{
								Assert(dupErrLast < 0);
								rgdup[iwch] -= dupErrLast;
								}
							}
						else if (dupErrLast > dupBigError)
							{
							dupAdjust = (dupErrLast - 1) >> 1;

							rgdup[iwchPrev] -= dupAdjust;
							dupSum -= dupAdjust;
							rgdup[iwch] -= dupAdjust;
							}
						else if (dupErrLast < -dupBigError)
							{
							dupAdjust = -((-dupErrLast - 1) >> 1);

							rgdup[iwchPrev] -= dupAdjust;
							dupSum -= dupAdjust;
							rgdup[iwch] -= dupAdjust;
							}

						dupSum += rgdup[iwch];
						iwchPrev = iwch;
					/* here modified David Bangs algorithm stops */
						iwch++;
						}
					else
						{
						fContinueWysi = fFalse;
						fContinueAveraging = fFalse;
						break;
						}
					}


				}

			}

		else
			{
			fContinueAveraging = fFalse;
			}
		itxtobj++;

		}

	return;
}

#endif   /* FUTURE */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\qheap.c ===
#include "lsmem.h"
#include "lsidefs.h"
#include "lsc.h"
#include "qheap.h"

/* ---------------------------------------------------------------------- */

struct qheap
{
#ifdef DEBUG
    DWORD tag;
#endif

	BYTE* pbFreeObj;					/* List of free objects in storage */
	BYTE** ppbAdditionalStorageList;		/* List of additional storage (chunk)*/

	POLS pols;
	void* (WINAPI* pfnNewPtr)(POLS, DWORD);
	void  (WINAPI* pfnDisposePtr)(POLS, void*);

    DWORD cbObj;
	DWORD cbObjNoLink;
	DWORD iobjChunk; /* number of elements in chunk */

	BOOL fFlush; /* use flush and don't use destroy */
};

#define tagQHEAP		Tag('Q','H','E','A')
#define FIsQHEAP(p)		FHasTag(p,tagQHEAP)


#define SetNextPb(pb,pbNext)	( (*(BYTE**)(pb)) = (pbNext) )
#define PbGetNext(pbObj)		( *(BYTE**)(pbObj) )

#define PLinkFromClientMemory(pClient)   (BYTE *)	((BYTE**)pClient - 1)
#define ClientMemoryFromPLink(pLink)     (void *)	((BYTE**)pLink   + 1)


#ifdef DEBUG
#define DebugMemset(a,b,c)		if ((a) != NULL) memset(a,b,c); else
#else
#define DebugMemset(a,b,c)		(void)(0)
#endif

/* ---------------------------------------------------------------------- */



/* C R E A T E  Q U I C K  H E A P */
/*----------------------------------------------------------------------------
    %%Function: CreateQuickHeap
    %%Contact: igorzv

    Creates a block of fixed-size objects which can be allocated and
	deallocated with very little overhead.  Once the heap is created,
	allocation of up to the	specified number of objects will not require
	using the application's	callback function.
----------------------------------------------------------------------------*/
PQHEAP CreateQuickHeap(PLSC plsc, DWORD iobjChunk, DWORD cbObj, BOOL fFlush)
{
	DWORD cbStorage;
	PQHEAP pqh;
	BYTE* pbObj;
	BYTE* pbNextObj;
	DWORD iobj;
	DWORD cbObjNoLink = cbObj;
	BYTE** ppbChunk;

	Assert(iobjChunk != 0 && cbObj != 0);

	cbObj += sizeof(BYTE*);
	cbStorage = cbObj * iobjChunk;
	pqh = plsc->lscbk.pfnNewPtr(plsc->pols, sizeof(*pqh));
	if (pqh == NULL)
		return NULL;

	ppbChunk = plsc->lscbk.pfnNewPtr(plsc->pols, sizeof(BYTE*) + cbStorage);
	if (ppbChunk == NULL)
		{
		plsc->lscbk.pfnDisposePtr(plsc->pols, pqh);
		return NULL;
		}
	pbObj = (BYTE*) (ppbChunk + 1);

#ifdef DEBUG
	pqh->tag = tagQHEAP;
#endif

	pqh->pbFreeObj = pbObj;
	pqh->ppbAdditionalStorageList = ppbChunk;
	pqh->pols = plsc->pols;
	pqh->pfnNewPtr = plsc->lscbk.pfnNewPtr;
	pqh->pfnDisposePtr = plsc->lscbk.pfnDisposePtr;
	pqh->cbObj = cbObj;
	pqh->cbObjNoLink = cbObjNoLink;
	pqh->iobjChunk = iobjChunk;
	pqh->fFlush = fFlush;

	/* Loop iobjChunk-1 times to chain the nodes together, then terminate
	 * the chain outside the loop.
	 */
	for (iobj = 1;  iobj < iobjChunk;  iobj++)
		{
		pbNextObj = pbObj + cbObj;
		SetNextPb(pbObj,pbNextObj);
		pbObj = pbNextObj;
		}
	SetNextPb(pbObj,NULL);

	/* terminate chain of chunks */
	*ppbChunk = NULL;
	return pqh;
}


/* D E S T R O Y  Q U I C K  H E A P */
/*----------------------------------------------------------------------------
    %%Function: DestroyQuickHeap
    %%Contact: igorzv

    Destroys one of the blocks of fixed-size objects which was created by
	CreateQuickHeap().
----------------------------------------------------------------------------*/
void DestroyQuickHeap(PQHEAP pqh)
{
	BYTE** ppbChunk;
	BYTE** ppbChunkPrev = NULL;

	if (pqh)
		{

#ifdef DEBUG
		BYTE* pbObj;
		BYTE* pbNext;
		DWORD cbStorage;
		DWORD i;


		Assert(FIsQHEAP(pqh));

		/* check that everything is free */
		/* mark free objects*/
		for (pbObj = pqh->pbFreeObj;  pbObj != NULL;  pbObj = pbNext)
			{
			pbNext = PbGetNext(pbObj);

			DebugMemset(pbObj, 0xe4, pqh->cbObj);
			}

		/* check that all objects are marked */
		ppbChunk = pqh->ppbAdditionalStorageList;
		Assert(ppbChunk != NULL);
		cbStorage = pqh->cbObj * pqh->iobjChunk;
		while (ppbChunk != NULL)
			{
			for (pbObj = (BYTE *)(ppbChunk + 1), i=0; i < cbStorage;  pbObj++, i++)
				{
				AssertSz(*pbObj == 0xe4, "Heap object not freed");
				}
			ppbChunk = (BYTE**) *ppbChunk;
			}
#endif
	   /* free all chunks */
		ppbChunk = pqh->ppbAdditionalStorageList;
		Assert(ppbChunk != NULL);
		while (ppbChunk != NULL)
			{
			ppbChunkPrev = ppbChunk;
			ppbChunk = (BYTE**) *ppbChunk;
			pqh->pfnDisposePtr(pqh->pols, ppbChunkPrev);
			}
		/* free header */
		pqh->pfnDisposePtr(pqh->pols, pqh);
		}
}


/* P V  N E W  Q U I C K  P R O C */
/*----------------------------------------------------------------------------
    %%Function: PvNewQuickProc
    %%Contact: igorzv

    Allocates an object from one of the blocks of fixed-size objects which
	was created by CreateQuickHeap().  If no preallocated objects are
	available, the callback function memory management function will be
	used to attempt to allocate additional memory.

	This function should not be called directly.  Instead, the PvNewQuick()
	macro should be used in order to allow debug code to validate that the
	heap contains objects of the expected size.
----------------------------------------------------------------------------*/
void* PvNewQuickProc(PQHEAP pqh)
{
	BYTE* pbObj;
	BYTE* pbNextObj;
	BYTE** ppbChunk;
	BYTE** ppbChunkPrev = NULL;
	DWORD cbStorage;
	DWORD iobj;
	BYTE* pbObjLast = NULL;


	Assert(FIsQHEAP(pqh));

	if (pqh->pbFreeObj == NULL)
		{
		cbStorage = pqh->cbObj * pqh->iobjChunk;
		ppbChunk = pqh->ppbAdditionalStorageList;
		Assert(ppbChunk != NULL);
		/* find last chunk in the list */
		while (ppbChunk != NULL)
			{
			ppbChunkPrev = ppbChunk;
			ppbChunk = (BYTE**) *ppbChunk;
			}

		/* allocate memory */
		ppbChunk = pqh->pfnNewPtr(pqh->pols, sizeof(BYTE*) + cbStorage);
		if (ppbChunk == NULL)
			return NULL;
		pbObj = (BYTE*) (ppbChunk + 1);
		/* add chunk to the list */
		*ppbChunkPrev = (BYTE *) ppbChunk;

		/* terminate chain of chunks */
		*ppbChunk = NULL;

		/* add new objects to free list */
		pqh->pbFreeObj = pbObj;

		if (pqh->fFlush)  /* to link all objects into  a chain */
			{
			/* find last object in chain */
			pbObjLast = (BYTE*) (ppbChunkPrev + 1);
			pbObjLast += (pqh->iobjChunk - 1) * pqh->cbObj;
			SetNextPb(pbObjLast,pbObj);
			}

		/* Loop iobjChunk-1 times to chain the nodes together, then terminate
		 * the chain outside the loop.
		 */
		for (iobj = 1;  iobj < pqh->iobjChunk;  iobj++)
			{
			pbNextObj = pbObj + pqh->cbObj;
			SetNextPb(pbObj,pbNextObj);
			pbObj = pbNextObj;
			}
		SetNextPb(pbObj,NULL);
		}

	pbObj = pqh->pbFreeObj;
	Assert(pbObj != NULL);
	pqh->pbFreeObj = PbGetNext(pbObj);
	DebugMemset(ClientMemoryFromPLink(pbObj), 0xE8, pqh->cbObjNoLink);

	return ClientMemoryFromPLink(pbObj);		
}


/* D I S P O S E  Q U I C K  P V  P R O C */
/*----------------------------------------------------------------------------
    %%Function: DisposeQuickPvProc
    %%Contact: igorzv

    De-allocates an object which was allocated by PvNewQuickProc().

	This function should not be called directly.  Instead, the PvDisposeQuick
	macro should be used in order to allow debug code to validate that the
	heap contains objects of the expected size.
----------------------------------------------------------------------------*/
void DisposeQuickPvProc(PQHEAP pqh, void* pv)
{
	BYTE* pbObj = PLinkFromClientMemory(pv);

	Assert(FIsQHEAP(pqh));
	Assert(!pqh->fFlush);

	if (pbObj != NULL)
		{
		DebugMemset(pbObj, 0xE9, pqh->cbObjNoLink);

		SetNextPb(pbObj, pqh->pbFreeObj);
		pqh->pbFreeObj = pbObj;
		}
}

/* F L U S H  Q U I C K  H E A P */
/*----------------------------------------------------------------------------
    %%Function: FlushQuickHeap
    %%Contact: igorzv

  For a quck heap with a flush flag, returns all objects to the list of
  free objects.
----------------------------------------------------------------------------*/
void FlushQuickHeap(PQHEAP pqh)
{

	Assert(FIsQHEAP(pqh));
	Assert(pqh->fFlush);

	pqh->pbFreeObj = (BYTE*) (pqh->ppbAdditionalStorageList + 1);


}


#ifdef DEBUG
/* C B  O B J  Q U I C K */
/*----------------------------------------------------------------------------
    %%Function: CbObjQuick
    %%Contact: igorzv

    Returns the size of the objects in this quick heap.  Used by the
	PvNewQuick() and PvDisposeQuick() macros to validate that the
	heap contains objects of the expected size.
----------------------------------------------------------------------------*/
DWORD CbObjQuick(PQHEAP pqh)
{
	Assert(FIsQHEAP(pqh));
	return pqh->cbObjNoLink;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\prepdisp.c ===
#include <limits.h>
#include "prepdisp.h"
#include "lsc.h"
#include "lsline.h"
#include "lssubl.h"
#include "iobj.h"
#include "lstxtjst.h"
#include "lstxttab.h"
#include "lsgrchnk.h"
#include "posichnk.h"
#include "chnutils.h"
#include "tabutils.h"
#include "lsdnode.h"
#include "zqfromza.h"
#include "lsdevice.h"
#include "lssubset.h"
#include "lsffi.h"
#include "iobjln.h"
#include "txtconst.h"
#include "lskalign.h"
#include "dninfo.h"

typedef enum 				/* types of TextGroupChunk walls */
{
	LineBegin,				
	LineEnd,
	Tab,
	Pen,
} KWALL;

typedef struct
{
	KWALL 		kwall;		/* wall type */
	PLSDNODE 	pdn;		/* tab or pen dnode, PLINEBEGIN for LineBegin */
	LSKTAB		lsktab;		/* if type is Tab - kind of tab */
	WCHAR 		wchCharTab;	/* point character if lsktab == lsktChar */
	long		upTab;		/* scaled tab position */
} GrpChnkWall;

static BOOL DnodeHasSublineForMe(PLSDNODE pdn, BOOL fLineCompressed);
static void ScaleDownLevel(PLSSUBL plssubl, BOOL* pfAnySublines, BOOL* pfCollectVisual);
static LSERR SetJustificationForLastGroupChunk(PLSLINE plsline, GrpChnkWall LastWall, 
					LSKJUST* plskj, LSKALIGN* plskalign);
static LSERR CalcPresAutonumbers(PLSLINE plsline, PLSDNODE* pdnStartMainText);
static void FindWallToCollectSublinesAfter(PLSDNODE pdnFirst, LSCP cpLim, BOOL fLineCompressed, PLSDNODE* ppdnLastWall);
static LSERR GetDistanceToTabPoint(GRCHUNKEXT* pgrchunkext, LSCP cpLim, LSKTAB lsktab, WCHAR wchCharTab,
										PLSDNODE pdnFirst, long* pdupToDecimal);
static void WidenNonTextObjects(GRCHUNKEXT* pgrchunkext, long dupToAdd, DWORD cObjects);
static void ConvertAutoTabToPen(PLSLINE plsline, PLSDNODE pdnAutoDecimalTab);
static LSERR CalcPresForDnodeWithSublines(PLSC plsc, PLSDNODE pdn, BOOL fLineCompressed, 
											LSKJUST lskj, BOOL fLastOnLine);
static LSERR CalcPresChunk(PLSC plsc, PLSDNODE pdnFirst, PLSDNODE pdnLim, 
				COLLECTSUBLINES CollectGroupChunkPurpose, BOOL fLineCompressed, 
				LSKJUST lskj, BOOL fLastOnLine);
static void UpdateUpLimUnderline(PLSLINE plsline, long dupTail);
static LSERR PrepareLineForDisplay(PLSLINE plsline);


#define PLINEBEGIN    ((void *)(-1))

#define FIsWall(p, cpLim)	 (!FDnodeBeforeCpLim(p, cpLim) || p->fTab || FIsDnodePen(p))

#define FIsDnodeNormalPen(plsdn) 		(FIsDnodePen(plsdn) && (!(plsdn)->fAdvancedPen))

#define FCollinearTflows(t1, t2)  		(((t1) & fUVertical) == ((t2) & fUVertical))


//    %%Function:	DnodeHasSublineForMe
//    %%Contact:	victork
//
// Is there relevant subline in this dnode?

static BOOL DnodeHasSublineForMe(PLSDNODE pdn, BOOL fLineCompressed)
{
	BOOL	fSublineFound = fFalse;
	
	if (FIsDnodeReal(pdn) && pdn->u.real.pinfosubl != NULL)
		{
		
		if (pdn->u.real.pinfosubl->fUseForCompression && fLineCompressed)
			{
			fSublineFound = fTrue;
			}
		
		if (pdn->u.real.pinfosubl->fUseForJustification && !fLineCompressed)
			{
			fSublineFound = fTrue;
			}
		}
	return fSublineFound;
}


//    %%Function:	ScaleDownLevel
//    %%Contact:	victork
//
/*
 *	Scales all non-text objects on the level(s).
 *	
 *	If the level (meaning subline) contains dnode(s) which submitted sublines for compression
 *	or expansion, ScaleDownLevel reports the fact and calls itself for submitted sublines.
 *	This strategy relyes on the fact that ScaleDownLevel is idempotent procedure. Some sublines
 *	will be scaled down twice - let that be.
 *
 *	Two additional questions are answered - whether there are some submitted sublines and
 *		whether there is a reason go VisualLine (underlining, shading, borders on lower levels).
 */

static void ScaleDownLevel(PLSSUBL plssubl, BOOL* pfAnySublines, BOOL* pfCollectVisual)
{
	const PLSC 	plsc = plssubl->plsc;
	LSTFLOW 	lstflow = plssubl->lstflow;	
	const DWORD iobjText = IobjTextFromLsc(&(plsc->lsiobjcontext));
	LSDEVRES* 	pdevres = &(plsc->lsdocinf.lsdevres);
	PLSDNODE 	pdn = plssubl->plsdnFirst;
	DWORD		i;
	BOOL 		fDummy;
	
	BOOL 		fSeeReasonForVisualLine = fFalse;
	
	while (pdn != NULL)							/* don't care about break */
		{
		if (FIsDnodeReal(pdn))
			{
			if (pdn->u.real.lschp.fUnderline || pdn->u.real.lschp.fShade || pdn->u.real.lschp.fBorder)
				{
				fSeeReasonForVisualLine = fTrue;
				}
				
			if (IdObjFromDnode(pdn) == iobjText)
				{
				if (pdn->fTab)
					pdn->u.real.dup = UpFromUr(lstflow, pdevres, pdn->u.real.objdim.dur);
				}
			else
				{							
				if (!pdn->fRigidDup)
					{
					pdn->u.real.dup = UpFromUr(lstflow, pdevres, pdn->u.real.objdim.dur);
					}
					
				if (pdn->u.real.pinfosubl != NULL)
					{
					*pfAnySublines = fTrue;

					for (i = 0; i < pdn->u.real.pinfosubl->cSubline; i++)
						{
						ScaleDownLevel((pdn->u.real.pinfosubl->rgpsubl)[i], &fDummy, pfCollectVisual);
						}
					}
				}
			}
		else if (FIsDnodePen(pdn))
			{
			pdn->u.pen.dup = UpFromUr(lstflow, pdevres, pdn->u.pen.dur);
			}
		else
			{
			// Borders are rigidDup always - no scaling down
			
			// we'll try to "undo" the moving at display time at the main level if
			// fUnderlineTrailSpacesRM is on. So, after prepdisp we want none or only one 
			// fBorderMovedFromTrailingArea flag remain and the meaning of the flag is:
			// I am the border that should be moved back into trailing spaces.
			
			if (pdn->fBorderMovedFromTrailingArea)
				{
				if (!FIsSubLineMain(pdn->plssubl) || 
					!plsc->lsadjustcontext.fUnderlineTrailSpacesRM)
					{
					pdn->fBorderMovedFromTrailingArea = fFalse;
					}
				}
			}

		pdn = pdn->plsdnNext;
		}
		
	if (fSeeReasonForVisualLine && !plssubl->fMain)
		{
		*pfCollectVisual = fTrue;
		}
		
}


//    %%Function:	FindWallToCollectSublinesAfter
//    %%Contact:	victork
//
// Finds the last wall - wall after which we will start to use submitted subllines.
// If there are no sublines to participate in justification, pdnLastWall is set to null,
// else it points to the last wall (tab, pen or PLINEBEGIN).

static void FindWallToCollectSublinesAfter(PLSDNODE pdnFirst, LSCP cpLim, BOOL fLineCompressed, 
										PLSDNODE* ppdnLastWall)
{
	PLSDNODE pdn;
	BOOL	 fSublineFound;

	// Find last tab.

	*ppdnLastWall = PLINEBEGIN;
	
	pdn = pdnFirst;

	while (FDnodeBeforeCpLim(pdn, cpLim))
		{
		if (FIsDnodeReal(pdn))
			{
			if (pdn->fTab)
				{
				*ppdnLastWall = pdn;
				}
			}
		else													/* pen */
			if (!FIsDnodeBorder(pdn) && !pdn->fAdvancedPen)		// and not advance pen or border
				{
				*ppdnLastWall = pdn;
				}
				
		pdn = pdn->plsdnNext;
		}

	// OK, last groupchunk starts with a tab or there is only one groupchunk on the line.
	// Are there submitted sublines of our compression/expansion type after it?

	fSublineFound = fFalse;
	
	if (*ppdnLastWall == PLINEBEGIN)
		{
		pdn = pdnFirst;
		}
	else
		{
		pdn = (*ppdnLastWall)->plsdnNext;
		}

	while (FDnodeBeforeCpLim(pdn, cpLim))
		{
		fSublineFound |= DnodeHasSublineForMe(pdn, fLineCompressed);
		pdn = pdn->plsdnNext;
		}

	if (!fSublineFound)
		{
		*ppdnLastWall = NULL;									// don't need last tab
		}
	return;
}


//    %%Function:	CalcPresAutonumbers
//    %%Contact:	victork
//
/*
 *	Scales dup for autonumbering dnodes, calls CalcPres for autonumbering object.
 *
 *	We want to have main line start exactly on upStartMainText. To achive that we play with
 *	the width of "white space" dnode, which	today contains a tab (usually) or a space. 
 *	(This dnode is pdnWhiteSpace in the code.) If it is not present, we change width of autonumbering
 *	object itself. We don't want one of them go negative,so sometimes rounding errors force us
 *	to move start of the main text to the right.
 */


static LSERR CalcPresAutonumbers(PLSLINE plsline, PLSDNODE* pdnStartMainText)
{
	LSERR 	lserr;
	const PLSC 	plsc = plsline->lssubl.plsc;
	LSTFLOW 	lstflow = plsline->lssubl.lstflow;	
	LSDEVRES* 	pdevres = &(plsc->lsdocinf.lsdevres);
		
	PLSDNODE 	pdn, pdnObject, pdnWhiteSpace, pdnToAdjust, pdnAfterAutonumbers;

	long 		dupAdjust, dupClosingBorder = 0;
	long 		dupAutonumbering = 0;

	plsline->upStartAutonumberingText = UpFromUr(lstflow, pdevres, plsc->lsadjustcontext.urStartAutonumberingText);


	// Find the first dnode after autonumbering sequence
	
	// First find the first dnode with positive cpFirst
	
	pdn = plsline->lssubl.plsdnFirst;

	Assert(pdn != NULL && FIsNotInContent(pdn));
	
	pdnAfterAutonumbers = pdn->plsdnNext;

	while (pdnAfterAutonumbers != NULL && FIsNotInContent(pdnAfterAutonumbers))
		{
		pdn = pdnAfterAutonumbers;
		pdnAfterAutonumbers = pdn->plsdnNext;
		}
		
	// pdnAfterAutonumbers is first dnode in content (with positive cpFirst). It can be NULL.
	// But it is not the first dnode after autonumbering sequence if autodecimal tab is present

	if (plsc->lsadjustcontext.fAutodecimalTabPresent)
		{
		Assert(FIsDnodeReal(pdn) && pdn->fTab);
		
		pdnAfterAutonumbers = pdn;
		}

	// Now go againg through autonumbering sequence
	
	// process opening border
	
	pdn = plsline->lssubl.plsdnFirst;
	
	if (FIsDnodeBorder(pdn))
		{
		Assert(pdn->cpFirst < 0);
		Assert(pdn->fOpenBorder);
		
		pdnObject = pdn->plsdnNext;
		dupAutonumbering += pdn->u.pen.dup;
		}
	else
		{
		pdnObject = pdn;
		}
		
	// process B&N object
	
	Assert(pdnObject != NULL && pdnObject->cpFirst < 0);				// B&N object should be there
	Assert(FIsDnodeReal(pdnObject));
	
	// scale down dup from dur for the first dnode
	
	pdnObject->u.real.dup = UpFromUr(lstflow, pdevres, pdnObject->u.real.objdim.dur);
	
	dupAutonumbering += pdnObject->u.real.dup;

	pdn = pdnObject->plsdnNext;
	Assert(pdn != NULL);								// line must contain something after B&N dnodes
	
	// process "white space" dnode
	
	if (pdn != pdnAfterAutonumbers && FIsDnodeReal(pdn))
		{
		pdnWhiteSpace = pdn;
		dupAutonumbering += pdnWhiteSpace->u.real.dup;
		pdnToAdjust = pdnWhiteSpace;
		pdn = pdnWhiteSpace->plsdnNext;
		}
	else
		{
		pdnWhiteSpace = NULL;
		pdnToAdjust = pdnObject;
		}

	Assert(pdn != NULL);								// line must contain something after B&N dnodes
	
	// process closing border
	
	if (pdn != pdnAfterAutonumbers)
		{
		Assert(FIsDnodeBorder(pdn));
		Assert(!pdn->fOpenBorder);

		dupClosingBorder = pdn->u.pen.dup;
		dupAutonumbering += dupClosingBorder;
		
		pdn = pdn->plsdnNext;
		}

	Assert(pdn == pdnAfterAutonumbers);	

	*pdnStartMainText = pdn;
														
	// change dup of the tab or object dnode to ensure exact main text alignment

	dupAdjust =  plsline->upStartMainText - plsline->upStartAutonumberingText - dupAutonumbering;
	
	pdnToAdjust->u.real.dup += dupAdjust;
	
	if (pdnToAdjust->u.real.dup < 0)
		{
		// Rounding errors result in negative dup - better to move starting point of the main line.
		// It can lead to the nasty situation of right margin to the left of the line beginning in
		// theory, but not in practice. This problem is ignored then.
		
		plsline->upStartMainText -= pdnToAdjust->u.real.dup;
		pdnToAdjust->u.real.dup = 0;
		}

	// do CalcPres for the autonumbering object - it's always lskjNone and not last object on the line
	
	lserr = (*plsc->lsiobjcontext.rgobj[pdnObject->u.real.lschp.idObj].lsim.pfnCalcPresentation)
						(pdnObject->u.real.pdobj, pdnObject->u.real.dup, lskjNone, fFalse);
	if (lserr != lserrNone)
		return lserr;

	if (pdnWhiteSpace != NULL)
		{
		plsline->upLimAutonumberingText = plsline->upStartMainText - 
														pdnWhiteSpace->u.real.dup - dupClosingBorder;

		// If "white space" dnode is not a tab, dup should be set in it.
		
		if (!pdnWhiteSpace->fTab)
			{
			// It's always lskjNone and not last object on the line for white space dnode

			lserr = (*plsc->lsiobjcontext.rgobj[pdnWhiteSpace->u.real.lschp.idObj].lsim.pfnCalcPresentation)
								(pdnWhiteSpace->u.real.pdobj, pdnWhiteSpace->u.real.dup, lskjNone, fFalse);
			if (lserr != lserrNone)
				return lserr;
			}
		}
	else
		{
		plsline->upLimAutonumberingText = plsline->upStartMainText - dupClosingBorder;
		}
		
	return lserrNone;		
}

//    %%Function:	SetJustificationForLastGroupChunk
//    %%Contact:	victork
//
//	Changes lskj and lskalign for the last GC if it should be done
// 	If not, it's OK to leave these parameters unchanged - so they are kind of I/O
//
//	We adjust all group chunks except maybe the last one with lskjNone, so guestion is about
//	last GroupChunk only.
//
//	We do some tricks with justification mode at the end of line, and the answer depends on 
//	kind of last tab, end of paragraph, etc.
//
static LSERR SetJustificationForLastGroupChunk(PLSLINE plsline, GrpChnkWall LastWall, 
												LSKJUST* plskj, LSKALIGN* plskalign)

{
	LSERR 		lserr;
	const PLSC 	plsc = plsline->lssubl.plsc;
	LSKJUST 	lskjPara = plsc->lsadjustcontext.lskj;
	LSKALIGN 	lskalignPara = plsc->lsadjustcontext.lskalign;
	ENDRES		endr = plsline->lslinfo.endr;
	BOOL 		fJustify;

	//	no justification intended - lskj remains None, lskalign unchanged
	
	if ((lskjPara == lskjNone || lskjPara == lskjSnapGrid) && lskalignPara == lskalLeft)
		{
		return lserrNone;
		}
	
	//	Line ends in a normal way - we apply justification, lskalign unchanged
	
	if (endr == endrNormal || endr == endrHyphenated)
		{
		*plskj = lskjPara;
		return lserrNone;
		}
	
	// break-through tab kills justification, alignment games
	
	if (FBreakthroughLine(plsc))
		{
		return lserrNone;
		}

	// if last Left Wall is non-left tab, justification is off too
	
	if (LastWall.kwall == Tab && LastWall.lsktab != lsktLeft)
		{
		// we used to return here
		// Now we want to give Word a chance to change lskalign from Right to Left for
		// the last line in paragraph after text box.
		// REVIEW (Victork) Should we call pfnFGetLastLineJustification always?
		lskjPara = lskjNone;
		}

	// What's the matter behind the callback.
	//
	// They say: no full justification for the last line in paragraph. What does this exactly mean?
	// For example, Latin and FE word make different decisions for endrEndSection line.
	// Let's ask. 
	//
	// Additional parameter is added to cover the behavior full-justified text wrapping a textbox (bug 682)
	// A lone word should be aligned to the right to create a full-justified page, but not at the end of
	// the paragraph.
	
	lserr = (*plsc->lscbk.pfnFGetLastLineJustification)(plsc->pols, lskjPara, lskalignPara, endr, 
						&fJustify, plskalign);
	
	if (lserr != lserrNone) return lserr;

	if (fJustify)
		{
		*plskj = lskjPara;
		}
	
	return lserrNone;
}


//    %%Function:	GetDistanceToTabPoint
//    %%Contact:	victork
//
/*
 *		Calculate DistanceToTabPoint given GrpChnk and first Dnode
 *
 *		TabPoint is decimal point for the decimal tab, wchCharTab for character tab
 */
static LSERR GetDistanceToTabPoint(GRCHUNKEXT* pgrchunkext, LSCP cpLim, LSKTAB lsktab, WCHAR wchCharTab,
										PLSDNODE pdnFirst, long* pdupToTabPoint)
{
	LSERR 		lserr;
	DWORD		igrchnk;					/* # of dnodes before dnode with the point */
	long 		dupToPointInsideDnode;
	PLSDNODE	pdnTabPoint;

	if (pgrchunkext->durTotal == 0)
		{
		*pdupToTabPoint = 0;
		return lserrNone;
		}

	lserr = CollectTextGroupChunk(pdnFirst, cpLim, CollectSublinesForDecimalTab, pgrchunkext); 
	if (lserr != lserrNone) 
		return lserr;

	if (lsktab == lsktDecimal)
		{
		lserr = LsGetDecimalPoint(&(pgrchunkext->lsgrchnk), lsdevPres, &igrchnk, &dupToPointInsideDnode);
		}
	else
		{
		Assert(lsktab == lsktChar);
		lserr = LsGetCharTab(&(pgrchunkext->lsgrchnk), wchCharTab, lsdevPres, &igrchnk, &dupToPointInsideDnode);
		}
	
	if (lserr != lserrNone) 
		return lserr;
		
	if (igrchnk == ichnkOutside)						// no TabPoint in the whole grpchnk
		{
		// we say: pretend it is right after last dnode (in logical sequence)
		
		pdnTabPoint = pgrchunkext->plsdnLastUsed;
		dupToPointInsideDnode = DupFromDnode(pdnTabPoint);
		}
	else
		{
		pdnTabPoint = pgrchunkext->plschunkcontext->pplsdnChunk[igrchnk];
		}
		
	// We now have the distance between TabPoint and the beginning of the dnode containing it.
	// FindPointOffset will add the dup's of all dnodes before that dnode.

	FindPointOffset(pdnFirst, lsdevPres, LstflowFromDnode(pdnFirst), CollectSublinesForDecimalTab, 
						pdnTabPoint, dupToPointInsideDnode, pdupToTabPoint);	
						
	return lserrNone;
}

//    %%Function:	WidenNonTextObjects
//    %%Contact:	victork
//
/*
 *		Add dupToAddToNonTextObjects to the width of first cNonTextObjectsToExtend in the GroupChunk
 */
static void WidenNonTextObjects(GRCHUNKEXT* pgrchunkext, long dupToAdd, DWORD cObjects)
{
	PLSDNODE pdn;

	long	dupAddToEveryone;
	long	dupDistributeToFew;
	long	dupAddToThis;
	long	dupCurrentSum;

	DWORD 	cObjectsLeft, i;

	Assert(cObjects != 0);
	Assert(dupToAdd > 0);

	dupAddToEveryone = dupToAdd / cObjects;
	dupDistributeToFew = dupToAdd - (dupAddToEveryone * cObjects);

	cObjectsLeft = cObjects;
	dupCurrentSum = 0;

	/* 
     *		Following loop tries to distribute remaining dupDistributeToFew pixels evenly.
	 *
     *		Algorithm would be easy if fractions are allowed and you can see it in comments;
     *		The actual algorithm avoids fractions by multiplying everything by cObjects
     */

	i = 0;
	
	while (cObjectsLeft > 0)
		{
		Assert(i < pgrchunkext->cNonTextObjects);
		
		pdn = (pgrchunkext->pplsdnNonText)[i];
		Assert(pdn != NULL && FIsDnodeReal(pdn) /* && IdObjFromDnode(pdn) != iobjText */ );

		if ((pgrchunkext->pfNonTextExpandAfter)[i])
			{
			dupAddToThis = dupAddToEveryone;

			dupCurrentSum += dupDistributeToFew;			/* currentSum += Distribute / cObjects; */
			
			if (dupCurrentSum >= (long)cObjects)			/* if (currentSum >= 1) */
				{
				dupAddToThis ++;
				dupCurrentSum -= (long)cObjects;			/* currentSum--; */
				}
				
			pdn->u.real.dup += dupAddToThis;		

			cObjectsLeft --;
			}
		i++;
		}

	return;
}


//    %%Function:	ConvertAutoTabToPen
//    %%Contact:	victork
//
static void ConvertAutoTabToPen(PLSLINE plsline, PLSDNODE pdnAutoDecimalTab)
{
	long dup, dur;

	Assert(pdnAutoDecimalTab->fTab);			/* it's still a tab */

	dup = pdnAutoDecimalTab->u.real.dup;
	dur = pdnAutoDecimalTab->u.real.objdim.dur;

	pdnAutoDecimalTab->klsdn = klsdnPenBorder;
	pdnAutoDecimalTab->fAdvancedPen = fFalse;
	pdnAutoDecimalTab->fTab = fFalse;
	pdnAutoDecimalTab->icaltbd = 0;
	pdnAutoDecimalTab->u.pen.dup = dup;
	pdnAutoDecimalTab->u.pen.dur = dur;
	pdnAutoDecimalTab->u.pen.dvp = 0;
	pdnAutoDecimalTab->u.pen.dvr = 0;
	plsline->fNonRealDnodeEncounted = fTrue;
}

//    %%Function:	CalcPresForDnodeWithSublines
//    %%Contact:	victork
//
static LSERR CalcPresForDnodeWithSublines(PLSC plsc, PLSDNODE pdn, BOOL fLineCompressed, 
											LSKJUST lskj, BOOL fLastOnLine)
{
	
	PLSSUBL* rgpsubl;
	DWORD	 i;
	
	LSTFLOW lstflow;					// dummy parameter
	LSERR	lserr;
	long	dupSubline;
	long	dupDnode = 0;
	COLLECTSUBLINES CollectGroupChunkPurpose; 


	Assert(DnodeHasSublineForMe(pdn, fLineCompressed));
	
	// calculate dup for dnode with sublines that took part in justification

	if (fLineCompressed)
		{
		CollectGroupChunkPurpose = CollectSublinesForCompression;
		}
	else
		{
		CollectGroupChunkPurpose = CollectSublinesForJustification;
		}

	rgpsubl = pdn->u.real.pinfosubl->rgpsubl;
	
	for (i = 0; i < pdn->u.real.pinfosubl->cSubline; i++)
		{
		// fLastOnLine is always false on lower levels
		
		lserr = CalcPresChunk(plsc, rgpsubl[i]->plsdnFirst, rgpsubl[i]->plsdnLastDisplay,
									CollectGroupChunkPurpose, fLineCompressed, lskj, fFalse);
		if (lserr != lserrNone)
			return lserr;
		LssbGetDupSubline(rgpsubl[i], &lstflow, &dupSubline);
		dupDnode += dupSubline;
		(rgpsubl[i])->fDupInvalid = fFalse;
		}

	// fill dup and call CalcPresentation

	pdn->u.real.dup = dupDnode;

	lserr = (*plsc->lsiobjcontext.rgobj[pdn->u.real.lschp.idObj].lsim.pfnCalcPresentation)
									(pdn->u.real.pdobj, dupDnode, lskj, fLastOnLine);
	if (lserr != lserrNone)
		return lserr;
		
	return lserrNone;
}

//    %%Function:	CalcPresChunk
//    %%Contact:	victork
//
/*
 *	Calls CalcPresentation for all non-text objects on the chunk.
 *	That means 	1) all dnodes in all GroupChunks (including dnodes in submitted sublines) 
 *				2) all dnodes that have submitted sublines
 *
 *	Foreign object on the upper level, which is followed only by trailing spaces, 
 *	should be called with fLastOnLine == fTrue.
 *  Input boolean says whether the input groupchunk is the last on line.
 *
 *	Sets dup for justified sublines
 */
static LSERR CalcPresChunk(PLSC plsc, PLSDNODE pdnFirst, PLSDNODE pdnLast, 
					COLLECTSUBLINES CollectGroupChunkPurpose, BOOL fLineCompressed, 
					LSKJUST lskj, BOOL fLastOnLine)
{
	LSERR		lserr;
	const DWORD iobjText = IobjTextFromLsc(&(plsc->lsiobjcontext));
	BOOL 		fCollecting;
	
	PLSDNODE	pdn;
	
	long		dupTailDnode;				// dummy parameter - will not use
	DWORD		cNumOfTrailers;

	fCollecting = (CollectGroupChunkPurpose != CollectSublinesNone);


	Assert(pdnFirst != NULL);
	Assert(pdnLast != NULL);
	
	pdn = pdnLast;

	// go backwards to switch fLastOnLine off once we are not in trailing spaces

	for (;;)
		{
		if (FIsDnodeReal(pdn))
			if (IdObjFromDnode(pdn) == iobjText)
				{
				if (fLastOnLine == fTrue)
					{
					GetTrailInfoText(pdn->u.real.pdobj, pdn->dcp, &cNumOfTrailers, &dupTailDnode);

					if (cNumOfTrailers < pdn->dcp)
						{
						fLastOnLine = fFalse;							// trailing spaces stop here
						}
					}
				}
			else
				{
				if (fCollecting && DnodeHasSublineForMe(pdn, fLineCompressed))
					{
					lserr = CalcPresForDnodeWithSublines(plsc, pdn, fLineCompressed, lskj, fLastOnLine); 
					if (lserr != lserrNone)
						return lserr;
					}
				else
					{
					lserr = (*plsc->lsiobjcontext.rgobj[pdn->u.real.lschp.idObj].lsim.pfnCalcPresentation)
										(pdn->u.real.pdobj, pdn->u.real.dup, lskj, fLastOnLine);
					if (lserr != lserrNone)
						return lserr;
					}
					
				fLastOnLine = fFalse;
				}

		if (pdn == pdnFirst)
			{
			break;
			}
			
		pdn = pdn->plsdnPrev;

		Assert(pdn != NULL);	// we'll encounter pdnFirst first
		}
		
	return lserrNone;
}

//    %%Function:	UpdateUpLimUnderline
//    %%Contact:	victork
//
/*
 *	Change upLimUnderline to underline trailing spaces, but not EOP.
 *	Notice that from now on upLimUnderline doesn't equals upStartTrailing anymore
 */
 
static void UpdateUpLimUnderline(PLSLINE plsline, long dupTail)
{
	PLSDNODE 	pdnLast;
	
	plsline->upLimUnderline += dupTail;

	// Now EOPs - they are alone in the last dnode or have some borders around them
	
	if (plsline->lslinfo.endr == endrEndPara 		||
		plsline->lslinfo.endr == endrAltEndPara 	||
		plsline->lslinfo.endr == endrEndParaSection ||
		plsline->lslinfo.endr == endrSoftCR)
		{
			
		pdnLast = plsline->lssubl.plsdnLastDisplay;

		Assert(FIsDnodeReal(pdnLast));					// no borders in trailing spaces area
		Assert(pdnLast->dcp == 1);
		Assert(pdnLast->u.real.dup <= dupTail);
		
		plsline->upLimUnderline -= pdnLast->u.real.dup;

		pdnLast = pdnLast->plsdnPrev;
		}

	// This option extends underlining only up to the right margin
	
	if (plsline->upLimUnderline > plsline->upRightMarginJustify)
		{
		plsline->upLimUnderline = plsline->upRightMarginJustify;
		}
}


//    %%Function:	PrepareLineForDisplayProc
//    %%Contact:	victork
//
/*
 *		PrepareLineForDisplayProc fills in the dup's in dnode list and lsline
 * 			
 *	Input dnode list consists of "normal dnode list" of dnodes with positive non-negative cp,
 *	which can be preceded (in this order) by B&N sequence either and/or one Autotab dnode.
 *
 *	B&N sequence is OpeningBorder+AutonumberingObject+TabOrSpace+ClosingBorder. 
 *	ClosingBorder or both OpeningBorder and ClosingBorder can be missing. TabOrSpace can be 
 *	missing too. B&N sequence starts at urStartAutonumberingText and ends at urStartMainText.
 *	Tab in B&N sequence should not be resolved in a usual way.
 *	
 *	Autotab dnode has negative cpFirst, but starts at urStartMainText. It is to be resolved in
 *	a usual way and then be replaced by a pen dnode.
 */

LSERR PrepareLineForDisplayProc(PLSLINE plsline)
{

	LSERR 		lserr;
	const PLSC 	plsc = plsline->lssubl.plsc;
	const DWORD iobjText = IobjTextFromLsc(&(plsc->lsiobjcontext));
	LSDEVRES* 	pdevres = &(plsc->lsdocinf.lsdevres);
	LSTFLOW 	lstflow = plsline->lssubl.lstflow;					/* text flow of the line */
	BOOL 		fVertical = lstflow & fUVertical;

	long		dupText, dupTail, dupTailDnode;
	DWORD		cNumOfTrailers;
	PLSDNODE 	pdn;
	BOOL 		fLastOnLine;

	DWORD		i;
	PDOBJ		pdobj[txtobjMaxM];				// quick group chunk

	Assert(FIsLSLINE(plsline));

	// Next assert means that client should destroy line immediately after creating it 
	//	if fDisplay is set to fFalse in LsSetDoc.
	
	Assert(FDisplay(plsc));

	if (!plsline->lssubl.fDupInvalid)					/* line has been prepared earlier  */
		return lserrNone;  

	Assert(plsc->lsstate == LsStateFree);
	Assert(plsc->plslineCur == plsline);

	plsc->lsstate = LsStatePreparingForDisplay;

	// first try to recognize quick cases, call slow PredDisp otherwise
	
	if (plsc->lsadjustcontext.lskj != lskjNone						|| 
				plsc->lsadjustcontext.lskalign != lskalLeft			|| 
				plsc->lsadjustcontext.lsbrj != lsbrjBreakJustify	||
				plsc->lsadjustcontext.fNominalToIdealEncounted		|| 
				plsc->lsadjustcontext.fSubmittedSublineEncounted	||
				plsline->fNonRealDnodeEncounted						||
				plsline->lssubl.plsdnFirst == NULL					|| 
				FIsNotInContent(plsline->lssubl.plsdnFirst))
		{
		return PrepareLineForDisplay(plsline);
		}

	if (plsc->lsdocinf.fPresEqualRef && !FSuspectDeviceDifferent(PlnobjFromLsline(plsline, iobjText)))
		{
		// Trident quick case - no need to scale down. Dups are already set in text dnodes.

		// go through dnode list to calculate dupTrail and CalcPres foreign objects

		pdn = plsline->lssubl.plsdnLastDisplay;
		dupTail = 0;
		
		fLastOnLine = fTrue;
		
		while (pdn != NULL && IdObjFromDnode(pdn) == iobjText)
			{
			Assert(pdn->u.real.dup == pdn->u.real.objdim.dur);

			GetTrailInfoText(pdn->u.real.pdobj, pdn->dcp, &cNumOfTrailers, &dupTailDnode);

			dupTail += dupTailDnode;

			if (cNumOfTrailers < pdn->dcp)
				{
				fLastOnLine = fFalse;				// trailing spaces stop here
				break;								// text is the last on the line
				}

			pdn = pdn->plsdnPrev;
			}

		// dupTail is calculated, we still should call pfnCalcPresentation for foreing objects

		if (plsc->lsadjustcontext.fForeignObjectEncounted)
			{

			while (pdn != NULL)
				{
				Assert(pdn->u.real.dup == pdn->u.real.objdim.dur);
				
				if (IdObjFromDnode(pdn) != iobjText)
					{
					lserr = (*plsc->lsiobjcontext.rgobj[pdn->u.real.lschp.idObj].lsim.pfnCalcPresentation)
												(pdn->u.real.pdobj, pdn->u.real.dup, lskjNone, fLastOnLine);
					if (lserr != lserrNone)
						{
						plsc->lsstate = LsStateFree;
						return lserr;
						}

					fLastOnLine = fFalse;				// only the first coulsd be the last on the line
					}
				
				pdn = pdn->plsdnPrev;
				}
			}
			
		plsline->lssubl.fDupInvalid = fFalse;
		
		plsline->upRightMarginJustify = plsc->lsadjustcontext.urRightMarginJustify;
		plsline->upStartMainText = plsc->lsadjustcontext.urStartMainText;
		plsline->upStartAutonumberingText = plsline->upStartMainText;
		plsline->upLimAutonumberingText = plsline->upStartMainText;
		plsline->upLimLine = plsline->lssubl.urCur;
		plsline->upStartTrailing = plsline->upLimLine - dupTail;
		plsline->upLimUnderline = plsline->upStartTrailing;

		plsline->fCollectVisual = fFalse;

		if (plsc->lsadjustcontext.fUnderlineTrailSpacesRM && 
					plsline->upLimUnderline < plsline->upRightMarginJustify)
			{
			UpdateUpLimUnderline(plsline, dupTail);
			}
			
		plsc->lsstate = LsStateFree;
		return lserrNone;
	}

	if ((plsc->grpfManager & fFmiPresExactSync) != 0 &&	
			!plsc->lsadjustcontext.fForeignObjectEncounted &&
			!plsc->lsadjustcontext.fNonLeftTabEncounted &&
			plsline->lssubl.plsdnLastDisplay != NULL &&			// empty line is not a quick case ;(
			FQuickScaling(PlnobjFromLsline(plsline, iobjText), fVertical, 
										plsline->lssubl.urCur - plsc->lsadjustcontext.urStartMainText))
		{
		// Looks like Word quick case 
		// We can still go slow way if all trailing spaces are not in one dnode
		
		if (plsline->lslinfo.endr == endrEndPara)
			{
			
			Assert(FIsDnodeReal(plsline->lssubl.plsdnLastDisplay));
			Assert(plsline->lssubl.plsdnLastDisplay->dcp == 1);
			
			pdn = plsline->lssubl.plsdnLastDisplay->plsdnPrev;

			if (pdn != NULL)
				{
				GetTrailInfoText(pdn->u.real.pdobj, pdn->dcp, &cNumOfTrailers, &dupTailDnode);
				
				if (cNumOfTrailers > 0)
					{
					// There are spaces before EOP - go slow way
					return PrepareLineForDisplay(plsline);
					}
				}

			cNumOfTrailers = 1;
			}
		else
			{
			pdn = plsline->lssubl.plsdnLastDisplay;
			
			GetTrailInfoText(pdn->u.real.pdobj, pdn->dcp, &cNumOfTrailers, &dupTailDnode);
			
			if (cNumOfTrailers == pdn->dcp)
				{
				// We can't be sure all spaces are in this dnode - forget it then
				return PrepareLineForDisplay(plsline);
				}
			
			}

		// we are sure now that all cNumOfTrailers trailing spaces are in the last dnode

		// fill standard output part, upStartMainText will be used below

		plsline->lssubl.fDupInvalid = fFalse;
		plsline->fCollectVisual = fFalse;

		plsline->upRightMarginJustify = UpFromUr(lstflow, pdevres, plsc->lsadjustcontext.urRightMarginJustify);
		plsline->upStartMainText = UpFromUr(lstflow, pdevres, plsc->lsadjustcontext.urStartMainText);
		plsline->upStartAutonumberingText = plsline->upStartMainText;
		plsline->upLimAutonumberingText = plsline->upStartMainText;
		
		if (!plsc->lsadjustcontext.fTabEncounted)
			{
			// Very nice, we have only one groupchunk to collect
			
			for (pdn = plsline->lssubl.plsdnFirst, i = 0;;)
				{
				Assert(FIsDnodeReal(pdn));
				Assert(IdObjFromDnode(pdn) == iobjText);

				// i never gets outside of pdobj array.
				// Text makes sure in FQuickscaling

				Assert(i < txtobjMaxM);
				
				pdobj[i] = pdn->u.real.pdobj;

				i++;

				if (pdn == plsline->lssubl.plsdnLastDisplay)
					{
					break;
					}

				pdn = pdn->plsdnNext;
				}

			QuickAdjustExact(&(pdobj[0]), i, cNumOfTrailers, fVertical, &dupText, &dupTail);

			plsline->upRightMarginJustify = UpFromUr(lstflow, pdevres, plsc->lsadjustcontext.urRightMarginJustify);
			plsline->upStartMainText = UpFromUr(lstflow, pdevres, plsc->lsadjustcontext.urStartMainText);
			plsline->upStartAutonumberingText = plsline->upStartMainText;
			plsline->upLimAutonumberingText = plsline->upStartMainText;
			plsline->upLimLine = plsline->upStartMainText + dupText;
			plsline->upStartTrailing = plsline->upLimLine - dupTail;
			plsline->upLimUnderline = plsline->upStartTrailing;

			plsline->fCollectVisual = fFalse;

			if (plsc->lsadjustcontext.fUnderlineTrailSpacesRM && 
						plsline->upLimUnderline < plsline->upRightMarginJustify)
				{
				UpdateUpLimUnderline(plsline, dupTail);
				}
				
			plsc->lsstate = LsStateFree;
			return lserrNone;
			}
		else
			{
			// Tabs are present, but they all are left tabs

			pdn = plsline->lssubl.plsdnFirst;
			plsline->upLimLine = plsline->upStartMainText;

			// Do one QuickGroupChunk after another, moving plsline->upLimLine

			for (;;)
				{
				// loop body: Collect next QuickGroupChunk, deal with it, exit after last one

				for (i = 0;;)
					{
					Assert(FIsDnodeReal(pdn));
					Assert(IdObjFromDnode(pdn) == iobjText);

					if (pdn->fTab)
						{
						break;
						}

					Assert(i < txtobjMaxM);
					
					pdobj[i] = pdn->u.real.pdobj;

					i++;

					if (pdn == plsline->lssubl.plsdnLastDisplay)
						{
						break;
						}

					pdn = pdn->plsdnNext;
					}

				Assert(pdn == plsline->lssubl.plsdnLastDisplay || pdn->fTab);

				if (pdn->fTab)
					{
					long upTabStop;
					
					if (i == 0)
						{
						dupText = 0;
						dupTail = 0;
						}
					else
						{
						QuickAdjustExact(pdobj, i, 0, fVertical, &dupText, &dupTail);
						}

					Assert(plsc->lstabscontext.pcaltbd[pdn->icaltbd].lskt == lsktLeft);

					upTabStop = UpFromUr(lstflow, pdevres, plsc->lstabscontext.pcaltbd[pdn->icaltbd].ur);
					pdn->u.real.dup = upTabStop - plsline->upLimLine - dupText;
					plsline->upLimLine = upTabStop;

					if (pdn == plsline->lssubl.plsdnLastDisplay)
						{
						break;
						}
					
					pdn = pdn->plsdnNext;
					}
				else
					{

					Assert(i != 0);
					
					QuickAdjustExact(pdobj, i, cNumOfTrailers, fVertical, &dupText, &dupTail);
						
					plsline->upLimLine += dupText;

					break;
					}
				}
			
			plsline->upStartTrailing = plsline->upLimLine - dupTail;
			plsline->upLimUnderline = plsline->upStartTrailing;

			if (plsc->lsadjustcontext.fUnderlineTrailSpacesRM && 
						plsline->upLimUnderline < plsline->upRightMarginJustify)
				{
				UpdateUpLimUnderline(plsline, dupTail);
				}
				
			plsc->lsstate = LsStateFree;
			return lserrNone;
			}
		}

	// Getting here means quick prepdisp haven't happen
	
	return PrepareLineForDisplay(plsline);

}


/*
 *	This is slow and painstaking procedure that does everyting.
 *	Called when QuickPrep above cannot cope.
 */

static LSERR PrepareLineForDisplay(PLSLINE plsline)
{
	LSERR 		lserr = lserrNone;
	const PLSC 	plsc = plsline->lssubl.plsc;
	LSTFLOW 	lstflow = plsline->lssubl.lstflow;		/* text flow of the subline */
	const DWORD iobjText = IobjTextFromLsc(&(plsc->lsiobjcontext));
	LSDEVRES* 	pdevres = &(plsc->lsdocinf.lsdevres);
	long 		urColumnMax = plsc->lsadjustcontext.urRightMarginJustify;
	long 		upColumnMax = UpFromUr(lstflow, pdevres, urColumnMax);
	LSCP		cpLim = plsline->lssubl.cpLimDisplay;
	PLSDNODE 	pdnFirst = plsline->lssubl.plsdnFirst;	/* the first dnode of the line */

	PLSDNODE 	pdnAutoDecimalTab = NULL;		/* NULL means - no such a thing on the line */

	GRCHUNKEXT 	grchunkext;
	BOOL		fEmptyGroupChunk;
	
	PLSDNODE 	pdnLastWall = NULL;				/* last wall with submitted sublines after it */
	BOOL		fAnySublines = fFalse;
	
	COLLECTSUBLINES CollectGroupChunkPurpose =  (plsc->lsadjustcontext.fLineCompressed) ?
								CollectSublinesForCompression : CollectSublinesForJustification;

	// parameters to call AdjustText
	
	LSKJUST 	lskj = lskjNone;					/* These four will be changed only when calling	*/
	BOOL		fForcedBreak = fFalse;				/*  AdjustText last time on the line 			*/
	BOOL		fSuppressTrailingSpaces = fFalse;	/* if ever */
	LSKALIGN	lskalign = plsc->lsadjustcontext.lskalign;		// Alignment can be changed too
	
	long		dupAvailable;
	BOOL		fExact;
	BOOL		fSuppressWiggle;	
	
	long 		dupText, dupTail = 0, dupToAddToNonTextObjects;
	long 		durColumnMax;
	DWORD 		cNonTextObjectsToExtend;

	PLSDNODE 	pdnNextFirst;					/* first Dnode of the next GrpChnk */
	GrpChnkWall	LeftWall, RightWall;			/* current TextGroupChunk walls */
	long		upLeftWall,urLeftWall;			/* Left wall position */

	long		dupWall, durWall;
	long		dupGrpChnk;
	long	 	dupToTabPoint;
	long 		dupJustifyLine;

	LSKTAB		lsktabLast = lsktLeft;
	long		dupLastTab = 0;
	long		upLeftWallForCentering;
	
	PLSDNODE 	pdnLast;


	InitGroupChunkExt(plsline->lssubl.plschunkcontext, iobjText, &grchunkext);		/* prepare one GRCHUNKEXT for all */

	plsline->upStartMainText = UpFromUr(lstflow, pdevres, plsc->lsadjustcontext.urStartMainText);

	// set defaults incase there are no autonumbering
	
	plsline->upStartAutonumberingText = plsline->upStartMainText;
	plsline->upLimAutonumberingText = plsline->upStartMainText;

	// fCollectVisual can be reset to fTrue by ScaleDownLevel called here or in AdjustSubline
	
	plsline->fCollectVisual = fFalse;
	
 	if (!plsline->fAllSimpleText)
		{
		/* straighforward scaling down of non-text objects */
		
		ScaleDownLevel(&(plsline->lssubl), &fAnySublines, &(plsline->fCollectVisual));

		if (plsc->lsadjustcontext.fLineContainsAutoNumber)
			{

			// do dup setting for autonumbers, update pdnFirst to point after it
			
			lserr = CalcPresAutonumbers(plsline, &pdnFirst);		
			if (lserr != lserrNone)
				{
				plsc->lsstate = LsStateFree;
				return lserr;
				}
			}

		// If autodecimal tab is there, pdnFirst points at it - make a note.
		// This tab can only be just before main text and it has negative cpFirst
		// Check for NULL is needed because empty dnode list is possible in LS. 
		// We don't have a dnode for splat, so we'll get here with pdnFirst == NULL
		// when line is (object that said delete me) + splat
		
		if (plsc->lsadjustcontext.fAutodecimalTabPresent)
			{
			Assert(pdnFirst != NULL && FIsNotInContent(pdnFirst) && pdnFirst->fTab);
			// It doesn't need any special handling even having negative cpFirst
			// We note it to convert to pen later
			pdnAutoDecimalTab = pdnFirst;
			}
			
		if (fAnySublines)
			{
			// Find last tab and prepare sublines after it.
			
			FindWallToCollectSublinesAfter(pdnFirst,  cpLim, plsc->lsadjustcontext.fLineCompressed, 
										&pdnLastWall);
			}
	}

	/*
	 *	Loop structure : While !end_of_line do
	 *						{
	 *						get next Wall (collect GrpChnk);
	 *						adjust 	GrpChnk;
	 *						set dup of the tab to the left of the GrpChnk;
	 *						move one Wall to the right
	 *						}
	 *
	 *	Invariance: all dup before LeftWall are done.
	 *				upLeftWall is at the beginning of the left wall
	 *				pdnNextFirst is the dnode to start collecting next GrpChnk with
	 */

	pdnNextFirst = pdnFirst; 
	LeftWall.kwall = LineBegin;
	LeftWall.pdn = PLINEBEGIN;
	LeftWall.lsktab = lsktLeft;							// 4 lines just against asserts
	LeftWall.wchCharTab = 0;						
	LeftWall.upTab = 0;
	RightWall = LeftWall;
	upLeftWall = 0;
	urLeftWall = 0;

	while (LeftWall.kwall != LineEnd)
		{
		/* 	1. Find next wall (collect GrpChnk or skip collecting if two walls in a row)
		 * 	
		 * 	Input:  pdnNextFirst - first dnode after Left wall
		 *
		 * 	Output: RightWall.pdn & grchunkext. 
		 * 	   if there is no GrpChnk some zeros in grchunkext is enough
         */
		if (FIsWall(pdnNextFirst, cpLim))
			{
			fEmptyGroupChunk = fTrue;
			RightWall.pdn = pdnNextFirst;
			grchunkext.durTotal = 0;
			grchunkext.durTextTotal = 0;
			grchunkext.dupNonTextTotal = 0;
			}
		else
			{
			lserr = CollectTextGroupChunk(pdnNextFirst, cpLim, CollectGroupChunkPurpose, &grchunkext);
			if (lserr != lserrNone)
				{
				plsc->lsstate = LsStateFree;
				return lserr;
				}
				
			if (grchunkext.lsgrchnk.clsgrchnk == 0 && grchunkext.cNonTextObjects == 0)
				{
				// only borders in this groupchunk - no need to call AdjustText
				
				fEmptyGroupChunk = fTrue;
				grchunkext.durTextTotal = 0;
				}
			else
				{
				fEmptyGroupChunk = fFalse;
				}
				
			RightWall.pdn = grchunkext.plsdnNext;
			}

		/* 
		 * 	2. fill in Right Wall information
		 *
		 * 	Input: RightWall.pdn
		 *
		 * 	Output: pdnNextFirst, RightWall information. 
	 	 */
		if (!FDnodeBeforeCpLim(RightWall.pdn, cpLim))
			{
			RightWall.kwall = LineEnd;
			}
		else
			{
			Assert(FIsWall(RightWall.pdn, cpLim));
			pdnNextFirst = RightWall.pdn->plsdnNext;

			if (FIsDnodePen(RightWall.pdn))
				{
				RightWall.kwall = Pen;
				}
			else
				{
				Assert(RightWall.pdn->fTab);			/* it must be a tab */

				RightWall.kwall = Tab;
				RightWall.lsktab = plsc->lstabscontext.pcaltbd[RightWall.pdn->icaltbd].lskt;
				RightWall.wchCharTab = plsc->lstabscontext.pcaltbd[RightWall.pdn->icaltbd].wchCharTab;
				RightWall.upTab = UpFromUr(lstflow, pdevres, plsc->lstabscontext.pcaltbd[RightWall.pdn->icaltbd].ur);
				}
			}

		/* 
		 *	prepare parameters for AdjustText
		 *
		 * 	Input: LeftWall, urLeftWall, upLeftWall, is_it_the_last_one
		 *
		 * 	Output: durColumnMax; lskj, dupAvailable and other input parameters for AdjustText
		 * 	        
		 */

		if (RightWall.kwall != LineEnd)
			{
			if (RightWall.kwall == Tab && RightWall.lsktab == lsktLeft)
				{
				
				// Now we know for sure what space we have for text in this groupchunk
				// and can do decent job if client doesn't care about fExact
				
				long upLeft, urLeft, upRight, urRight;

				urRight = plsc->lstabscontext.pcaltbd[RightWall.pdn->icaltbd].ur;
				upRight = UpFromUr(lstflow, pdevres, urRight);

				if (LeftWall.kwall == Tab && LeftWall.lsktab == lsktLeft)
					{			
					urLeft = plsc->lstabscontext.pcaltbd[LeftWall.pdn->icaltbd].ur;
					upLeft = UpFromUr(lstflow, pdevres, urLeft);
					}
				else if (LeftWall.kwall == LineBegin)
					{
					urLeft = plsc->lsadjustcontext.urStartMainText;
					upLeft = plsline->upStartMainText;
					}
				else if (LeftWall.kwall == Pen)
					{
					/* pen - it've been scaled already, we know left wall dimensions in advance */
					urLeft = urLeftWall + LeftWall.pdn->u.pen.dur;
					upLeft = upLeftWall + LeftWall.pdn->u.pen.dup;
					}
				else 						/* now non-left tabs */
					{
					urLeft = urLeftWall;
					upLeft = upLeftWall;
					}

				durColumnMax = urRight - urLeft;
				dupAvailable = upRight - upLeft;

				Assert(durColumnMax >= 0);
				
				// dupAvailable can be < 0 here - visi optional hyphens in previous GC, for example.
				// AdjustText doesn't mind, meaning it won't crush.
				
				fSuppressWiggle = ((plsc->grpfManager & fFmiPresSuppressWiggle) != 0);
				fExact = ((plsc->grpfManager & fFmiPresExactSync) != 0);
				}
			else
				{
				// situation is complicated - we go the safest way.
				
				durColumnMax = grchunkext.durTotal;
				dupAvailable = LONG_MAX;
				fExact = fTrue;
				fSuppressWiggle = fTrue;
				}
			}
		else		
			{
			/* for the last GrpChnk we must to calculate durColumnMax and dupAvailable */

			if (LeftWall.kwall == Tab && LeftWall.lsktab == lsktLeft)
				{			
				durColumnMax = urColumnMax - plsc->lstabscontext.pcaltbd[LeftWall.pdn->icaltbd].ur;
				dupAvailable = UpFromUr(lstflow, pdevres, urColumnMax) - grchunkext.dupNonTextTotal - 
					UpFromUr(lstflow, pdevres, plsc->lstabscontext.pcaltbd[LeftWall.pdn->icaltbd].ur);
				}
			else if (LeftWall.kwall == LineBegin)
				{
				durColumnMax = urColumnMax - plsc->lsadjustcontext.urStartMainText;
				dupAvailable = upColumnMax - plsline->upStartMainText - grchunkext.dupNonTextTotal;

				// Ask AdjustText to set widths of trailing spaces to 0 only if
				// It is the last groupchunk, (we actually only care for "the only one" situation)
				// and its first dnode (again, we actually only care for "the only one" situation)
				// submits subline for both justification and trailing spaces
				// and this subline runs in the direction opposite to the line direction.
				
				if (!fEmptyGroupChunk &&
						FIsDnodeReal(grchunkext.plsdnFirst) && grchunkext.plsdnFirst->u.real.pinfosubl != NULL &&
						grchunkext.plsdnFirst->u.real.pinfosubl->fUseForJustification &&
						grchunkext.plsdnFirst->u.real.pinfosubl->fUseForTrailingArea &&
						FCollinearTflows(((grchunkext.plsdnFirst->u.real.pinfosubl->rgpsubl)[0])->lstflow, lstflow) &&
						((grchunkext.plsdnFirst->u.real.pinfosubl->rgpsubl)[0])->lstflow != lstflow)				
					{
					fSuppressTrailingSpaces = fTrue;
					}
				}
			else if (LeftWall.kwall == Pen)
				{
				/* pen - it've been scaled already, we know wall dimensions in advance */
				durColumnMax = urColumnMax - urLeftWall - LeftWall.pdn->u.pen.dur;
				dupAvailable = UpFromUr(lstflow, pdevres, urColumnMax) - upLeftWall - 
									LeftWall.pdn->u.pen.dup - grchunkext.dupNonTextTotal;
				}
			else 						/* now non-left tabs */
				{
				durColumnMax = urColumnMax - urLeftWall;
				dupAvailable = UpFromUr(lstflow, pdevres, urColumnMax) - upLeftWall - grchunkext.dupNonTextTotal;
				}
			
			// we do some tricks with justification mode at the end of line
			// alignment can change too.

			lserr = SetJustificationForLastGroupChunk(plsline, LeftWall, &lskj, &lskalign);   
			if (lserr != lserrNone)
				{
				plsc->lsstate = LsStateFree;
				return lserr;
				}

			// Don't try to squeeze into RMJustify is RMBreak is infinite.
			
			if (plsc->urRightMarginBreak >= uLsInfiniteRM)
				{
				dupAvailable = LONG_MAX;
				}
				
			fSuppressWiggle = ((plsc->grpfManager & fFmiPresSuppressWiggle) != 0);
			fExact = ((plsc->grpfManager & fFmiPresExactSync) != 0);
			fForcedBreak = plsline->lslinfo.fForcedBreak;
			}

		/* 
		 * Adjust text (if any) 
		 *
		 * 	Input: durColumnMax, dupAvailable, lskj and other input parameters
		 *
		 * 	Output:  dupText and dupTail 
		 */
		if (fEmptyGroupChunk)
			{
			dupText = 0;
			dupTail = 0;
			dupToAddToNonTextObjects = 0;
			}
		else
			{
			lserr = AdjustText(lskj, durColumnMax, grchunkext.durTotal - grchunkext.durTrailing,
								dupAvailable, &(grchunkext.lsgrchnk), 
								&(grchunkext.posichnkBeforeTrailing), lstflow,
								plsc->lsadjustcontext.fLineCompressed && RightWall.kwall == LineEnd,
								grchunkext.cNonTextObjectsExpand,   
								fSuppressWiggle, fExact, fForcedBreak, fSuppressTrailingSpaces, 
								&dupText, &dupTail, &dupToAddToNonTextObjects, &cNonTextObjectsToExtend);   
			if (lserr != lserrNone)
				{
				plsc->lsstate = LsStateFree;
				return lserr;
				}

			//	Finish justification by expanding non-text object.
			
			if (cNonTextObjectsToExtend != 0 && dupToAddToNonTextObjects > 0)
				{
				WidenNonTextObjects(&grchunkext, dupToAddToNonTextObjects, cNonTextObjectsToExtend);
				}
			else
				//	We don't compressi and we don't expand the last non-text object on the line
				{
				dupToAddToNonTextObjects = 0;				// don't say we did it
				}
				
			/*
			 *	Set dup in non-text objects (do CalcPres) in the current GroupChunk
			 *
			 *	The job cannot be postponed until after the end of the main loop and done for the whole line
			 *		because GetDistanceToDecimalPoint relies on dups in upper level dnodes
			 */
			 
			if (!plsline->fAllSimpleText)
				{
				// find the last upper level dnode of the groupchunk
				
				if (grchunkext.plsdnNext != NULL)
					{
					pdnLast = (grchunkext.plsdnNext)->plsdnPrev;
					}
				else
					{
					Assert(RightWall.kwall == LineEnd);
					pdnLast = plsline->lssubl.plsdnLastDisplay;
					}
					
				lserr = CalcPresChunk(plsc, grchunkext.plsdnFirst, pdnLast, CollectGroupChunkPurpose, 
							plsc->lsadjustcontext.fLineCompressed, lskj, (RightWall.kwall == LineEnd));
							
				if (lserr != lserrNone)
					{
					plsc->lsstate = LsStateFree;
					return lserr;
					}
				}
		}

		/* 
		 *	Set the left wall (if it's a tab - resolve it)
		 *
		 * 	Input: LeftWall, dupText, dupTail, grchunkext.dupNonTextTotal, grchunkext.durTotal, 
		 *			dupToAddToNonTextObjects (grchunkext for decimal tab)
		 *
		 * 	Output:  dupWall, durWall 
		 */
		dupGrpChnk = dupText + grchunkext.dupNonTextTotal + dupToAddToNonTextObjects;

		lsktabLast = lsktLeft;							// no tab equal left tab for my purpose
		
		if (LeftWall.kwall == Tab)
			{
			/* calculate dup of the Left wall now */

			if (dupGrpChnk == 0)					/* consecutive tabs */

				dupWall = LeftWall.upTab - upLeftWall;

			else 	
				if (LeftWall.lsktab == lsktLeft)
					dupWall = LeftWall.upTab - upLeftWall;
				else if (LeftWall.lsktab == lsktRight)
					dupWall = LeftWall.upTab - upLeftWall - (dupGrpChnk - dupTail);
				else if (LeftWall.lsktab == lsktCenter)
					dupWall = LeftWall.upTab - upLeftWall - ((dupGrpChnk - dupTail) / 2);
				else 	/* LeftWall.lsktab == lsktDecimal or lsktChar */
					{
					lserr = GetDistanceToTabPoint(&grchunkext, cpLim, LeftWall.lsktab, LeftWall.wchCharTab,  
													LeftWall.pdn->plsdnNext, &dupToTabPoint);
					if (lserr != lserrNone)
						{
						plsc->lsstate = LsStateFree;
						return lserr;
						}

					dupWall = LeftWall.upTab - upLeftWall - dupToTabPoint;
					}

			// take care of previous text and right margin
					
			if (RightWall.kwall == LineEnd && 
					(upLeftWall + dupWall + dupGrpChnk - dupTail) > upColumnMax)
				{
				// We don't want to cross RM because of last center tab
				
				dupWall = upColumnMax - upLeftWall - dupGrpChnk + dupTail;
				}

			if (dupWall < 0)
				dupWall = 0;

			/* LeftWall tab resolving */
			LeftWall.pdn->u.real.dup = dupWall;
			durWall = LeftWall.pdn->u.real.objdim.dur;

			// for reproducing Word's bug of forgetting last not-left tab for centering.
			
			lsktabLast = LeftWall.lsktab;
			dupLastTab = dupWall;
			}
		else if (LeftWall.kwall == Pen)
			{
			dupWall = LeftWall.pdn->u.pen.dup;		/* it've been scaled already */
			durWall = LeftWall.pdn->u.pen.dur;
			}
		else 										/* LeftWall.kwall == LineBegin */
			{
			dupWall = plsline->upStartMainText;
			durWall = plsc->lsadjustcontext.urStartMainText;
			}

		/* update loop variables, move one wall to the right */

		upLeftWall += dupWall + dupGrpChnk;
		urLeftWall += durWall + grchunkext.durTotal;
		LeftWall = RightWall;
	}												/* end of the main loop */

	/* 
	 *	prepare output parameters
	 */

	plsline->upRightMarginJustify = upColumnMax;
	plsline->upLimLine = upLeftWall;
	plsline->upStartTrailing = upLeftWall - dupTail;
	plsline->upLimUnderline = plsline->upStartTrailing;
	plsline->lssubl.fDupInvalid = fFalse;

	/* 	
     *				Do left margin adjustment (not for breakthrough tab)
     *				 We're interested in lskalRight and Centered now
	 */
	
	if (lskalign != lskalLeft && !FBreakthroughLine(plsc))
		{
		if (plsc->lsadjustcontext.fForgetLastTabAlignment && lsktabLast != lsktLeft)
			{
			// reproduction of an old Word bug: when last tab was not left and was resolved at line end
			// they forgot to update their counterpart of upLeftWallForCentering. Word still have to be
			// able to show old documents formatted in this crazy way as they were.
			
			upLeftWallForCentering = upLeftWall - dupLastTab - dupTail;
			}
		else
			{
			upLeftWallForCentering = upLeftWall - dupTail;
			}
			
		if (lskalign == lskalRight)
			{
			dupJustifyLine = upColumnMax - upLeftWallForCentering;
			}
		else	
			{
			/* These logic of centering is too simple to be valid, but Word uses it */
			
			dupJustifyLine = (upColumnMax - upLeftWallForCentering) / 2;
			}
			
		// Apply adjustment if hanging punctuation haven't make it negative
		
		if (dupJustifyLine > 0)	
			{
			plsline->upStartAutonumberingText += dupJustifyLine;
			plsline->upLimAutonumberingText += dupJustifyLine;
			plsline->upStartMainText += dupJustifyLine;
			plsline->upLimLine += dupJustifyLine;
			plsline->upStartTrailing += dupJustifyLine;
			plsline->upLimUnderline += dupJustifyLine;
			}
		}

	if (plsc->lsadjustcontext.fUnderlineTrailSpacesRM && 
				plsline->upLimUnderline < plsline->upRightMarginJustify)
		{
		UpdateUpLimUnderline(plsline, dupTail);
		}
		
	if (pdnAutoDecimalTab != NULL)
		ConvertAutoTabToPen(plsline, pdnAutoDecimalTab);

	plsc->lsstate = LsStateFree;

	return lserr;
}

//    %%Function:	MatchPresSubline
//    %%Contact:	victork
//
/*
 *			Order of operations
 *
 *		1. Straighforward scaling down of non-text objects
 *		2. Adjusting of text by LeftExact
 *		3. Intelligent rescaling of pens to counteract rounding errors and text non-expansion.
 *		4. Calling CalcPresentation for all non-text objects
 */
LSERR MatchPresSubline(PLSSUBL plssubl)
{
	LSERR 		lserr;
	const PLSC 	plsc = plssubl->plsc;
	LSTFLOW 	lstflow = plssubl->lstflow;					/* text flow of the subline */
	const DWORD iobjText = IobjTextFromLsc(&(plsc->lsiobjcontext));
	LSDEVRES* 	pdevres = &(plsc->lsdocinf.lsdevres);
	LSCP		cpLim = plssubl->cpLimDisplay;
	PLSDNODE 	pdnFirst = plssubl->plsdnFirst;
	GRCHUNKEXT 	grchunkext;

	long 		dupAvailable;							/* input for AdjustText */
	
	long 		dupText, dupTail, dupToAddToNonTextObjects;		/* dummy output for AdjustText */
	DWORD 		cNonTextObjectsToExtend;
	
	BOOL 	 	fDummy1, fDummy2;									// dummy parameters
	
	long 		urAlreadyScaled, upAlreadyScaled, upAlreadyScaledNew;

	PLSDNODE pdn;
	
	Assert(plssubl->fDupInvalid == fTrue);
	
	/*	1. Straighforward scaling down of non-text objects */
	
	ScaleDownLevel(plssubl, &fDummy1, &fDummy2);

	/* 	2. Adjusting of text on the level by LeftExact */
	
	InitGroupChunkExt(plssubl->plschunkcontext, iobjText, &grchunkext);	/* prepare GRCHUNKEXT */

	pdn = pdnFirst;

	while (pdn != NULL && (pdn->fTab || FIsDnodeNormalPen(pdn)))		/* skip GrpChnk Wall(s) */
		pdn = pdn->plsdnNext;

	while (FDnodeBeforeCpLim(pdn, cpLim))
		{
		lserr = CollectTextGroupChunk(pdn, cpLim, CollectSublinesNone, &grchunkext);
		if (lserr != lserrNone)
			return lserr;

		/* Adjust text by Left, Exact, no durFreeSpace, ignore any shortcomings */

		dupAvailable = UpFromUr(lstflow, pdevres, grchunkext.durTotal) - grchunkext.dupNonTextTotal;

		// posichnkBeforeTrailing is undefined when CollectSublinesNone, tell AdjustText about it

		grchunkext.posichnkBeforeTrailing.ichnk = grchunkext.lsgrchnk.clsgrchnk;
		grchunkext.posichnkBeforeTrailing.dcp = 0;
		
		lserr = AdjustText(lskjNone, grchunkext.durTotal, grchunkext.durTotal, 
							dupAvailable, 
							&(grchunkext.lsgrchnk),
							&(grchunkext.posichnkBeforeTrailing), 
							lstflow, 
							fFalse, 						// compress?
							grchunkext.cNonTextObjects,   
							fTrue, 							// fSuppressWiggle
							fTrue,							// fExact
							fFalse,							// fForcedBreak
							fFalse,							// fSuppressTrailingSpaces
							&dupText, &dupTail, &dupToAddToNonTextObjects, &cNonTextObjectsToExtend);   
		if (lserr != lserrNone)
			return lserr;

		pdn = grchunkext.plsdnNext;
		while (pdn != NULL && (pdn->fTab || FIsDnodeNormalPen(pdn)))		/* skip GrpChnk Wall(s) */
			pdn = pdn->plsdnNext;
		}

	/*	3-4. Intelligent rescaling of pens to counteract rounding errors and text non-expansion. 
	 *    	 and adjusting of lower levels. Calling CalcPresentation for non-text objects.
	 */

	pdn = pdnFirst;
	urAlreadyScaled = 0;
	upAlreadyScaled = 0;

	while (FDnodeBeforeCpLim(pdn, cpLim))
		{
		if (FIsDnodeReal(pdn))
			{
			urAlreadyScaled += pdn->u.real.objdim.dur;
			upAlreadyScaled += pdn->u.real.dup;
			if (IdObjFromDnode(pdn) != iobjText)
				{
				// It's always lskjNone and not last object on the line for MatchPresSubline
				lserr = (*plsc->lsiobjcontext.rgobj[pdn->u.real.lschp.idObj].lsim.pfnCalcPresentation)
									(pdn->u.real.pdobj, pdn->u.real.dup, lskjNone, fFalse);
				if (lserr != lserrNone)
					return lserr;
				}
			}
		else if (FIsDnodeBorder(pdn))
			{
			// we don't rescale borders to preserve (dupOpeningBorder == dupClosingBorder)
			upAlreadyScaled += pdn->u.real.dup;
			urAlreadyScaled += pdn->u.pen.dur;
			}
		else		/* pen */
			{							
			urAlreadyScaled += pdn->u.pen.dur;
			upAlreadyScaledNew = UpFromUr(lstflow, pdevres, urAlreadyScaled);
			pdn->u.pen.dup = upAlreadyScaledNew - upAlreadyScaled;
			upAlreadyScaled = upAlreadyScaledNew;
			}

		pdn = pdn->plsdnNext;
		}
		
	plssubl->fDupInvalid = fFalse;

	return lserrNone;
}

//    %%Function:	AdjustSubline
//    %%Contact:	victork
//
/*
 *
 *		Scale down non-text objects.
 *		Collect GroupChunk
 *		It should cover the whole subline or else do MatchPresSubline instead.
 *		Adjust text by expanding or compressing to given dup.
 *		Call CalcPresentation for all non-text objects.
 */
 
LSERR AdjustSubline(PLSSUBL plssubl, LSKJUST lskjust, long dup, BOOL fCompress)
{
	LSERR 		lserr;
	const PLSC 	plsc = plssubl->plsc;
	LSTFLOW 	lstflow = plssubl->lstflow;					/* text flow of the subline */
	const DWORD iobjText = IobjTextFromLsc(&(plsc->lsiobjcontext));
	LSDEVRES* 	pdevres = &(plsc->lsdocinf.lsdevres);
	LSCP		cpLim = plssubl->cpLimDisplay;
	PLSDNODE 	pdnFirst = plssubl->plsdnFirst;
	GRCHUNKEXT 	grchunkext;
	COLLECTSUBLINES CollectGroupChunkPurpose; 

	long 		dupAvailable, durColumnMax;			/* input for AdjustText */
	
	long 		dupText, dupTail, dupToAddToNonTextObjects;		/* dummy output for AdjustText */
	DWORD 		cNonTextObjectsToExtend;
	BOOL 	 	fDummy;

	if (plssubl->plsdnFirst == NULL)
		{
		return lserrNone;
		}

	Assert(plssubl->fDupInvalid == fTrue);
		
 	ScaleDownLevel(plssubl, &fDummy, &(plsc->plslineCur->fCollectVisual));

	CollectGroupChunkPurpose = (fCompress) ? CollectSublinesForCompression : CollectSublinesForJustification;

	InitGroupChunkExt(plssubl->plschunkcontext, iobjText, &grchunkext);	/* prepare GRCHUNKEXT */

	lserr = CollectTextGroupChunk(pdnFirst, cpLim, CollectGroupChunkPurpose, &grchunkext);
	if (lserr != lserrNone)
		return lserr;

	if (FDnodeBeforeCpLim(grchunkext.plsdnNext, cpLim))			// more than one GroupChunk -
		{
		return MatchPresSubline(plssubl);						// cancel Expansion
		}

	dupAvailable = dup - grchunkext.dupNonTextTotal;

	if (dupAvailable < 0)										// input dup is wrong -
		{
		return MatchPresSubline(plssubl);						// cancel Expansion
		}

	durColumnMax = UrFromUp(lstflow, pdevres, dup);				// get dur by scaling back

	lserr = AdjustText(lskjust, durColumnMax, grchunkext.durTotal - grchunkext.durTrailing, 
						dupAvailable, 
						&(grchunkext.lsgrchnk),
						&(grchunkext.posichnkBeforeTrailing), lstflow, 
						fCompress, 						// compress?
						grchunkext.cNonTextObjects,   
						fTrue, 							// fSuppressWiggle
						fTrue,							// fExact
						fFalse,							// fForcedBreak
						fFalse,							// fSuppressTrailingSpaces
						&dupText, &dupTail, &dupToAddToNonTextObjects, &cNonTextObjectsToExtend);   
	if (lserr != lserrNone)
		return lserr;
		
	if (cNonTextObjectsToExtend != 0 && dupToAddToNonTextObjects > 0)
		{
		WidenNonTextObjects(&grchunkext, dupToAddToNonTextObjects, cNonTextObjectsToExtend);
		}

	// fLastOnLine is always false on lower levels

	lserr = CalcPresChunk(plsc, plssubl->plsdnFirst, plssubl->plsdnLastDisplay,
									CollectGroupChunkPurpose, fCompress, lskjust, fFalse);

	plssubl->fDupInvalid = fFalse;
						
	return lserrNone;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\objhelp.c ===
#include	"lsidefs.h"
#include	"lsmem.h"
#include	"limits.h"
#include	"objhelp.h"
#include	"lscrsubl.h"
#include	"lssubset.h"
#include	"lsdnset.h"
#include	"lstfset.h"
#include	"lsdocinf.h"
#include	"fmti.h"
#include	"lsqout.h"
#include	"lsqin.h"
#include	"mwcls.h"
#include	"brkkind.h"
#include	"brko.h"


/* G E T  B R E A K  R E C O R D  I N D E X */
/*----------------------------------------------------------------------------
	%%Function: GetBreakRecordIndex
	%%Contact: antons

		Index of the break record from brkkind. Assert if 
		brrkkind = brkkindImposedAfter.
	
----------------------------------------------------------------------------*/

DWORD GetBreakRecordIndex (BRKKIND brkkind)
{
	DWORD result = 0;
	
	Assert (brkkind != brkkindImposedAfter);
	Assert (NBreaksToSave == 3);

	switch (brkkind)
		{
		case brkkindPrev:  result = 0; break;
		case brkkindNext:  result = 1; break;
		case brkkindForce: result = 2; break;

		case brkkindImposedAfter: break;

		default: AssertSz (FALSE, "Unknown brkkind");
		};

	Assert (result < NBreaksToSave);
	
	return result;		
}

/* F O R M A T L I N E */
/*----------------------------------------------------------------------------
	%%Function: FormatLine
	%%Contact: antons

		Formats a line of text with the given escape characters ignoring
		all tabs, eops, etc.
	
----------------------------------------------------------------------------*/
LSERR FormatLine(
	PLSC plsc,
	LSCP cpStart,
	long durColMax,
	LSTFLOW lstflow,
	PLSSUBL *pplssubl,
	DWORD cdwlsesc,
	const LSESC *plsesc,
	OBJDIM *pobjdim,
	LSCP *pcpOut,
	PLSDNODE *pplsdnStart,
	PLSDNODE *pplsdnEnd,
	FMTRES *pfmtres)
{
	return FormatResumedLine ( plsc,					
							   cpStart,
							   durColMax,
							   lstflow,
							   pplssubl,
							   cdwlsesc,
							   plsesc,
							   pobjdim,
							   pcpOut,
							   pplsdnStart,
							   pplsdnEnd,
							   pfmtres,
							   NULL,		/* Array of break records */
							   0 );			/* Number of break record */



}

/* F O R M A T R E S U M E D L I N E */
/*----------------------------------------------------------------------------
	%%Function: FormatResumedLine
	%%Contact: ricksa

		Formats a line that contains broken objects at its beginning.
	
----------------------------------------------------------------------------*/
LSERR FormatResumedLine(
	PLSC plsc,					
	LSCP cpStart,
	long durColMax,
	LSTFLOW lstflow,
	PLSSUBL *pplssubl,
	DWORD cdwlsesc,
	const LSESC *plsesc,
	POBJDIM pobjdim,
	LSCP *pcpOut,
	PLSDNODE *pplsdnStart,
	PLSDNODE *pplsdnEnd,
	FMTRES *pfmtres,
	const BREAKREC *pbreakrec,
	DWORD cbreakrec)
{
	LSERR lserr;
	PLSDNODE plsdnStart;
	PLSDNODE plsdnEnd;
	LSCP cpOut;
	FMTRES fmtres;
	PLSSUBL plssubl = NULL;
	BOOL fSuccessful = FALSE;
	LSTFLOW lstflowUnused;

	*pplssubl = NULL; /* In case of lserr */

	while (! fSuccessful)
		{
		lserr = LsCreateSubline(plsc, cpStart, durColMax, lstflow, FALSE);

		if (lserr != lserrNone) return lserr;

		lserr = LsFetchAppendToCurrentSublineResume(plsc, pbreakrec, cbreakrec, 
					0, plsesc, cdwlsesc, &fSuccessful, &fmtres, &cpOut, &plsdnStart, &plsdnEnd);

		if (lserr != lserrNone) return lserr;

		/* REVIEW (antons): fmtrStopped is not handled */
		Assert (fmtres == fmtrCompletedRun || fmtres == fmtrExceededMargin || fmtres == fmtrTab);

		if (pplsdnStart != NULL) *pplsdnStart = plsdnStart;

		while (fSuccessful && (fmtres == fmtrTab))
			{
			/* Format as much as we can - note we move max to maximum postive value. */
			lserr = LsFetchAppendToCurrentSubline(plsc, 0,  plsesc, cdwlsesc, 
							&fSuccessful, &fmtres, &cpOut, &plsdnStart, &plsdnEnd);

			if (lserr != lserrNone) return lserr;

			/* REVIEW (antons): fmtrStopped is not handled */
			Assert (fmtres == fmtrCompletedRun || fmtres == fmtrExceededMargin || fmtres == fmtrTab);
			}

		if (! fSuccessful)
			{
			/* FetchAppend UnSuccessful => Finish and Destroy subline, then repeat */

			lserr = LsFinishCurrentSubline(plsc, &plssubl);
			if (lserr != lserrNone) return lserr;

			lserr = LsDestroySubline(plssubl);
			if (lserr != lserrNone) return lserr;
			}
		else
			{
			if (pplsdnEnd != NULL) *pplsdnEnd = plsdnEnd;

			*pcpOut = cpOut;
			*pfmtres = fmtres;
			};

		}; /* while (! fSuccessful) */


	lserr = LsFinishCurrentSubline(plsc, &plssubl);

	if (lserrNone != lserr) return lserr;

	lserr = LssbGetObjDimSubline(plssubl, &lstflowUnused, pobjdim);

	if (lserr != lserrNone) 
		{
		LsDestroySubline(plssubl);
		return lserr;
		}

	*pplssubl = plssubl;

	return lserrNone;
}

/* C R E A T E Q U E R Y R E S U L T */
/*----------------------------------------------------------------------------
	%%Function: CreateQueryResult
	%%Contact: ricksa

		Common routine to fill in query output record for Query methods.

		.
----------------------------------------------------------------------------*/
LSERR CreateQueryResult(
	PLSSUBL plssubl,			/*(IN): subline of ruby */
	long dupAdj,				/*(IN): u offset of start of subline */
	long dvpAdj,				/*(IN): v offset of start of subline */
	PCLSQIN plsqin,				/*(IN): query input */
	PLSQOUT plsqout)			/*(OUT): query output */
{
	ZeroMemory(plsqout, sizeof(LSQOUT));
	plsqout->heightsPresObj = plsqin->heightsPresRun;
	plsqout->dupObj = plsqin->dupRun;
	ZeroMemory(&plsqout->lstextcell, sizeof(plsqout->lstextcell));
	plsqout->plssubl = plssubl;
	plsqout->pointUvStartSubline.u += dupAdj;
	plsqout->pointUvStartSubline.v += dvpAdj;
	return lserrNone;
}

/* O B J H E L P F M T R E S U M E */
/*----------------------------------------------------------------------------
	%%Function: ObjHelpFmtResume
	%%Contact: ricksa

		This is a helper that is used by objects that don't support
		the resuming of formatting.
	
----------------------------------------------------------------------------*/
LSERR WINAPI ObjHelpFmtResume(
	PLNOBJ plnobj,				/* (IN): object lnobj */
	const BREAKREC *rgBreakRecord,	/* (IN): array of break records */
	DWORD nBreakRecord,			/* (IN): size of the break records array */
	PCFMTIN pcfmtin,			/* (IN): formatting input */
	FMTRES *pfmtres)			/* (OUT): formatting result */
{
	Unreferenced(plnobj);
	Unreferenced(rgBreakRecord);
	Unreferenced(nBreakRecord);
	Unreferenced(pcfmtin);
	Unreferenced(pfmtres);

	return lserrInvalidBreakRecord;
}

/* O B J H E L P G E T M O D W I D T H C H A R */
/*----------------------------------------------------------------------------
	%%Function: ObjHelpGetModWidthChar
	%%Contact: ricksa

		Implementation of LSIMETHOD for objects that do nothing for mod width.
		Tatenakayoko and Hih are examples of this kind of object.
	
----------------------------------------------------------------------------*/
LSERR WINAPI ObjHelpGetModWidthChar(
	PDOBJ pdobj,				/* (IN): dobj */
	PLSRUN plsrun,				/* (IN): plsrun of the object */
	PLSRUN plsrunText,			/* (IN): plsrun of the preceding char */
	PCHEIGHTS pcheightsRef,		/* (IN): height info about character */
	WCHAR wchar,				/* (IN): preceding character */
	MWCLS mwcls,				/* (IN): ModWidth class of preceding character */
	long *pdurChange)			/* (OUT): amount by which width of the preceding char is to be changed */
{
	Unreferenced(pdobj);
	Unreferenced(plsrun);
	Unreferenced(plsrunText);
	Unreferenced(pcheightsRef);
	Unreferenced(wchar);
	Unreferenced(mwcls);
	*pdurChange = 0;
	return lserrNone;
}


/* O B J H E L P S E T B R E A K */
/*----------------------------------------------------------------------------
	%%Function: ObjHelpSetBreak
	%%Contact: ricksa

		SetBreak

		Implementation of LSIMETHOD for objects that do nothing for SetBreak.
		Tatenakayoko and Hih are examples of this kind of object.

----------------------------------------------------------------------------*/
LSERR WINAPI ObjHelpSetBreak(
	PDOBJ pdobj,				/* (IN): dobj which is broken */
	BRKKIND brkkind,			/* (IN): Previous / Next / Force / Imposed was chosen */
	DWORD cBreakRecord,			/* (IN): size of array */
	BREAKREC *rgBreakRecord,	/* (IN): array of break records */
	DWORD *pcActualBreakRecord)	/* (IN): actual number of used elements in array */
{
	Unreferenced(pdobj);
	Unreferenced(brkkind);
	Unreferenced(rgBreakRecord);
	Unreferenced(cBreakRecord);

	*pcActualBreakRecord = 0;

	return lserrNone;
}

/* ObjHelpFExpandWithPrecedingChar */
/*----------------------------------------------------------------------------
	%%Function: ObjHelpFExpandWithPrecedingChar
	%%Contact: ricksa

		Default implementation of LSIMETHOD for objects that do not
		allow expanding the previous character.

----------------------------------------------------------------------------*/
LSERR WINAPI ObjHelpFExpandWithPrecedingChar(
	PDOBJ pdobj,				/* (IN): dobj */
	PLSRUN plsrun,				/* (IN): plsrun of the object */
	PLSRUN plsrunText,			/* (IN): plsrun of the preceding char */
	WCHAR wchar,				/* (IN): preceding character */
	MWCLS mwcls,				/* (IN): ModWidth class of preceding character*/ 
	BOOL *pfExpand)				/* (OUT): (OUT): expand preceding character? */
{
	Unreferenced(pdobj);
	Unreferenced(plsrun);
	Unreferenced(plsrunText);
	Unreferenced(wchar);
	Unreferenced(mwcls);

	*pfExpand = fTrue;
	return lserrNone;
}

/* ObjHelpFExpandWithFollowingChar */
/*----------------------------------------------------------------------------
	%%Function: ObjHelpFExpandWithFollowingChar
	%%Contact: ricksa

		Default implementation of LSIMETHOD for objects that do not
		allow expanding themselves.

----------------------------------------------------------------------------*/
LSERR WINAPI ObjHelpFExpandWithFollowingChar(
	PDOBJ pdobj,				/* (IN): dobj */
	PLSRUN plsrun,				/* (IN): plsrun of the object */
	PLSRUN plsrunText,			/* (IN): plsrun of the following char */
	WCHAR wchar,				/* (IN): following character */
	MWCLS mwcls,				/* (IN): ModWidth class of following character*/ 
	BOOL *pfExpand)				/* (OUT): expand object? */
{
	Unreferenced(pdobj);
	Unreferenced(plsrun);
	Unreferenced(plsrunText);
	Unreferenced(wchar);
	Unreferenced(mwcls);

	*pfExpand = fTrue;
	return lserrNone;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\robj.c ===
#include	"lsmem.h"
#include	"limits.h"
#include	"lscbk.h"
#include	"lsdevres.h"
#include	"pdobj.h"
#include	"objdim.h"
#include	"plssubl.h"
#include	"plsdnode.h"
#include	"pilsobj.h"
#include	"lscrsubl.h"
#include	"lssubset.h"
#include	"lsdnset.h"
#include	"lsdocinf.h"
#include	"lsidefs.h"
#include	"fmti.h"
#include	"posichnk.h"
#include	"locchnk.h"
#include	"lsdnfin.h"
#include	"brko.h"
#include	"lspap.h"
#include	"plspap.h"
#include	"lsqsubl.h"
#include	"dispi.h"
#include	"lsdssubl.h"
#include	"lsems.h"
#include	"lstfset.h"
#include	"plnobj.h"
#include	"plocchnk.h"
#include	"lsimeth.h"
#include	"robj.h"
#include	"lsidefs.h"
#include	"brkpos.h"
#include	"objhelp.h"

#include	"lssubset.h"

typedef enum breaksublinetype
{
	breakSublineAfter,
	breakSublineInside

} BREAKSUBLINETYPE;

struct ilsobj
{
    POLS				pols;
	LSCBK				lscbk;
	PLSC				plsc;
	DWORD				idobj;
	LSESC				lsesc;
	PFNREVERSEGETINFO	pfnReverseGetInfo;
	PFNREVERSEENUM		pfnReverseEnum;
};


typedef struct rbreakrec
{
	BOOL				fValid;					/* Is this break record contains valid info? */
	BREAKSUBLINETYPE	breakSublineType;		/* After / Inside */
	LSCP				cpBreak;				/* CpLim of the break */

} RBREAKREC;


struct dobj
{
	PILSOBJ				pilsobj;			/* ILS object */
	LSTFLOW				lstflowL;			/* flow of line input */
	LSTFLOW				lstflowO;			/* flow of this object */
	BOOL				fDoNotBreakAround;	/* Break around robj as "can"  */
	BOOL				fSuppressTrailingSpaces;
											/* Kill trailing space when robj is
											   alone on the line & broken */ 
	BOOL				fFirstOnLine;		/* If first on line -- required for
											   fSuppressTrailingSpaces */
	PLSDNODE			plsdnTop;			/* Parent dnode */
	LSCP				cpStart;			/* Starting LS cp for object */
	LSCP				cpStartObj;			/* cp for start of object can be different
											   than cpStart if object is broken. */
	LSCP				cpFirstSubline;		/* cpFirst of the subline; will be
											   equal to cpStart when object is broken and
											   equal to cpStart+1 when it isnot broken */
	LSDCP				dcpSubline;			/* Number of characters in the subline */
											   
	LSDCP				dcp;				/* Number of characters in object */
	PLSSUBL				plssubl;			/* Subline formatted RTL */
	OBJDIM				objdimAll;			/* Objdim for entire object */
	long				dup;				/* dup of object */

	RBREAKREC			breakRecord [NBreaksToSave];
	
											/* Last 3 break records for each break */
};

static LSTFLOW rlstflowReverse[8] =
{
	lstflowWS,	/* Reverse lstflowES */
	lstflowWN,	/* Reverse lstflowEN */
	lstflowNE,	/* Reverse lstflowSE */
	lstflowNW,	/* Reverse lstflowSW */
	lstflowES,	/* Reverse lstflowWS */
	lstflowEN,	/* Reverse lstflowWN */
	lstflowSE,	/* Reverse lstflowNE */
	lstflowSW	/* Reverse lstflowNW */
};


/* R E V E R S E  S A V E  B R E A K  R E C O R D  */
/*----------------------------------------------------------------------------
	%%Function: RobjSaveBreakRecord
	%%Contact: antons

		Save break record in DOBJ.
	
----------------------------------------------------------------------------*/

static void ReverseSaveBreakRecord (
	PDOBJ pdobj, 
	BRKKIND brkkindWhatBreak,
	BREAKSUBLINETYPE breakSublineType,
	LSCP cpBreak)
{
	DWORD ind = GetBreakRecordIndex (brkkindWhatBreak);

	pdobj->breakRecord [ind].fValid = TRUE;
	pdobj->breakRecord [ind].breakSublineType = breakSublineType;
	pdobj->breakRecord [ind].cpBreak = cpBreak; 
}

/* R E V E R S E  G E T  B R E A K  R E C O R D  */
/*----------------------------------------------------------------------------
	%%Function: ReverseGetBreakRecord
	%%Contact: antons

		Read break record from DOBJ.
	
----------------------------------------------------------------------------*/

static void ReverseGetBreakRecord (
	PDOBJ pdobj, 
	BRKKIND brkkindWhatBreak, 
	BREAKSUBLINETYPE *breakSublineType,
	LSCP * pcpBreak )
{
	DWORD ind = GetBreakRecordIndex (brkkindWhatBreak);

	Assert (pdobj->breakRecord [ind].fValid);

	*breakSublineType = pdobj->breakRecord [ind].breakSublineType;
	*pcpBreak = pdobj->breakRecord [ind].cpBreak;
}


/* F R E E D O B J */
/*----------------------------------------------------------------------------
	%%Function: ReverseFreeDobj
	%%Contact: antons

		Free all resources associated with this Reverse dobj.
	
----------------------------------------------------------------------------*/
static LSERR ReverseFreeDobj(PDOBJ pdobj)
{
	LSERR lserr = lserrNone;

	PILSOBJ pilsobj = pdobj->pilsobj;

	if (pdobj->plssubl != NULL)
		{
		lserr = LsDestroySubline(pdobj->plssubl);
		}

    pilsobj->lscbk.pfnDisposePtr(pilsobj->pols, pdobj);

	return lserr;
}

/* R E V E R S E  F M T  F A I L E D */
/*----------------------------------------------------------------------------
	%%Function: ReverseFmtFailed
	%%Contact: antons

		Could not create Reverse DOBJ due to error. 
		
----------------------------------------------------------------------------*/
static LSERR ReverseFmtFailed (PDOBJ pdobj, LSERR lserr)
{
	if (pdobj != NULL) ReverseFreeDobj (pdobj); /* Works with parially-filled DOBJ */

	return lserr;
}

/* T R A N S L A T E  C P  L I M  S U B L I N E  T O  D C P  E X T E R N A L
/*----------------------------------------------------------------------------
	%%Function: TranslateCpLimSublineToDcpExternal
	%%Contact: antons

		Translates position (CpLim) in the subline to dcp of
		the reverse object.

----------------------------------------------------------------------------*/

/* REVIEW (antons): Is old name OK for new behavior? */

LSDCP TranslateCpLimSublineToDcpExternal (PDOBJ pdobj, LSCP cpLim)
{
	Unreferenced (pdobj);

	Assert (cpLim <= pdobj->cpStart + (long) pdobj->dcp);
	Assert (cpLim >= pdobj->cpStart);

	Assert (pdobj->cpStart <= pdobj->cpFirstSubline);
	Assert (pdobj->cpStart + pdobj->dcp >= pdobj->cpFirstSubline + pdobj->dcpSubline);

	return cpLim - pdobj->cpStart;
}

/* T R A N S L A T E  D C P  E X T E R N A L  T O  C P  L I M  S U B L I N E
/*----------------------------------------------------------------------------
	%%Function: TranslateCpLimInternalToExternal
	%%Contact: antons

		Translates position (dcp) in reverse object to cpLim of
		the subline. 

----------------------------------------------------------------------------*/

LSCP TranslateDcpExternalToCpLimSubline (PDOBJ pdobj, LSDCP dcp)
{
	Unreferenced (pdobj);

	Assert (dcp <= pdobj->dcp);

	Assert (pdobj->cpStart <= pdobj->cpFirstSubline);
	Assert (pdobj->cpStart + pdobj->dcp >= pdobj->cpFirstSubline + pdobj->dcpSubline);

	return pdobj->cpStart + dcp;
}


/* F I N I S H   B R E A K   R E G U L A R  */
/*----------------------------------------------------------------------------
	%%Function: FinishBreakRegular
	%%Contact: antons

		Set up breaking information for proposed break point. 

		Caller must save break record by hiself!
	
----------------------------------------------------------------------------*/
static LSERR FinishBreakRegular (

	DWORD ichnk,				/* (IN): chunk id */
	PDOBJ pdobj,				/* (IN): object for break */
	LSCP cpBreak,				/* (IN): cp - break to report outside */
	POBJDIM pobjdimSubline,		/* (IN): objdim for subline at proposed break */
	PBRKOUT pbrkout)			/* (OUT): break info for Line Services */
{
	Assert (ichnk != ichnkOutside);

	pbrkout->fSuccessful = fTrue;
	pbrkout->posichnk.dcp = TranslateCpLimSublineToDcpExternal (pdobj, cpBreak);
	pbrkout->posichnk.ichnk = ichnk;

	pbrkout->objdim = *pobjdimSubline;

	return lserrNone;
}

/* P U T B R E A K A T E N D O F O B J E C T */
/*----------------------------------------------------------------------------
	%%Function: PutBreakAtEndOfObject
	%%Contact: antons

		Fill in break output record for the end of the object.
	
----------------------------------------------------------------------------*/
static void PutBreakAtEndOfObject (

	DWORD ichnk,				/* (IN): index in chunk */
	PCLOCCHNK pclocchnk,		/* (IN): locchnk to find break */
	PBRKOUT pbrkout)			/* (OUT): results of breaking */
{	
	PDOBJ pdobj = pclocchnk->plschnk[ichnk].pdobj;

	Assert (ichnk != ichnkOutside);

	pbrkout->fSuccessful = fTrue;
	pbrkout->posichnk.dcp = pdobj->dcp;
	pbrkout->posichnk.ichnk = ichnk;
	pbrkout->objdim = pdobj->objdimAll;
}


/* P U T B R E A K B E F O R E O B J E C T */
/*----------------------------------------------------------------------------
	%%Function: PutBreakBeforeObject
	%%Contact: antons

		Fill in break output record for break before object.
	
----------------------------------------------------------------------------*/

static void PutBreakBeforeObject (

	DWORD ichnk,				/* (IN): index in chunk */
	PCLOCCHNK pclocchnk,		/* (IN): locchnk to find break */
	PBRKOUT pbrkout)			/* (OUT): results of breaking */
{
	Unreferenced (pclocchnk);
	
	Assert (ichnk != ichnkOutside);

	pbrkout->fSuccessful = fTrue;
	pbrkout->posichnk.dcp = 0;
	pbrkout->posichnk.ichnk = ichnk;

	ZeroMemory (&pbrkout->objdim, sizeof(pbrkout->objdim));
}


/* P U T B R E A K U N S U C C E S S F U L */
/*----------------------------------------------------------------------------
	%%Function: PutBreakUnsuccessful
	%%Contact: antons

		Fill in break output record for unsuccessful break of ROBJ
	
----------------------------------------------------------------------------*/

static void PutBreakUnsuccessful (PDOBJ pdobj, PBRKOUT pbrkout)
{
	pbrkout->fSuccessful = FALSE;

	if (pdobj->fDoNotBreakAround) pbrkout->brkcond = brkcondCan;
	else
		pbrkout->brkcond = brkcondPlease;

}


/* I N I T D O B J */
/*----------------------------------------------------------------------------
	%%Function: InitDobj
	%%Contact: ricksa

		Allocate and initialize DOBJ with basic information.
	
----------------------------------------------------------------------------*/
static LSERR InitDobj(
	PILSOBJ pilsobj,			/* (IN): ilsobj */
    PCFMTIN pcfmtin,			/* (IN): formatting input */
	PDOBJ *ppdobj)				/* (OUT): initialized dobj */	
{
	/* Assume failure */
	LSERR lserr;

    PDOBJ pdobj = (PDOBJ) 
		pilsobj->lscbk.pfnNewPtr(pilsobj->pols, sizeof(*pdobj));

    if (pdobj != NULL)
		{
		int iBreakRec;
		
		ZeroMemory(pdobj, sizeof(*pdobj));

		pdobj->pilsobj = pilsobj;
		pdobj->cpStart = pcfmtin->lsfgi.cpFirst;
		pdobj->lstflowL = pcfmtin->lsfgi.lstflow;
		pdobj->lstflowO = rlstflowReverse[(int) pcfmtin->lsfgi.lstflow];
		pdobj->cpStartObj = pcfmtin->lsfgi.cpFirst;

		for (iBreakRec = 0; iBreakRec < NBreaksToSave; iBreakRec++)
			{
			pdobj->breakRecord [iBreakRec].fValid = FALSE;
			};
		
		*ppdobj = pdobj;

		lserr = lserrNone;
		}
	else
		{
		lserr = lserrOutOfMemory;
		}

	return lserr;
}

/* F I N I S H F M T */
/*----------------------------------------------------------------------------
	%%Function: FinishFmt
	%%Contact: ricksa

		Helper for ReverseFmt & ReverseFmtResume that completes work
		for formatting.
	
----------------------------------------------------------------------------*/
static LSERR FinishFmt(
	PDOBJ pdobj,				/* (IN): dobj for reverse */
	PILSOBJ pilsobj,			/* (IN): ILS object for Reverse */
    PCFMTIN pcfmtin,			/* (IN): formatting input */
	LSCP cpFirstMain,			/* (IN): cp first of reverse subline */
	LSCP cpLast,				/* (IN): cp output from formatting subline */
	FMTRES fmtres)				/* (IN): final format state */
{
	LSERR lserr;

	/* Set cpFirst and cpLim for reverse subline */

	pdobj->cpFirstSubline = cpFirstMain;
	pdobj->dcpSubline = cpLast - pdobj->cpFirstSubline;

	/* Set dcp for whole object */

	pdobj->dcp = cpLast - pdobj->cpStart;

	if (fmtres != fmtrExceededMargin)
		{
		/* Note: +1 for the escape character at the end of the object. */
		pdobj->dcp++;
		}

	lserr = LsdnSubmitSublines(pilsobj->plsc, pcfmtin->plsdnTop, 1, 
				&pdobj->plssubl, TRUE, FALSE, TRUE, TRUE, FALSE);

	if (lserr != lserrNone) return ReverseFmtFailed (pdobj, lserr);

	return LsdnFinishRegular(pilsobj->plsc, pdobj->dcp, 
		pcfmtin->lsfrun.plsrun, pcfmtin->lsfrun.plschp, pdobj, 
			&pdobj->objdimAll);
}

/* R E V E R S E C R E A T E I L S O B J */
/*----------------------------------------------------------------------------
	%%Function: ReverseCreateILSObj
	%%Contact: ricksa

		CreateILSObj

		Create the ILS object for all Reverse objects.
	
----------------------------------------------------------------------------*/
LSERR WINAPI ReverseCreateILSObj(
	POLS pols,				/* (IN): client application context */
	PLSC plsc,				/* (IN): LS context */
	PCLSCBK pclscbk,		/* (IN): callbacks to client application */
	DWORD idObj,			/* (IN): id of the object */
	PILSOBJ *ppilsobj)		/* (OUT): object ilsobj */
{
    PILSOBJ pilsobj;
	REVERSEINIT reverseinit;
	LSERR lserr;

	*ppilsobj = NULL; /* in case of error */

	/* Get initialization data */
	reverseinit.dwVersion = REVERSE_VERSION;
	lserr = pclscbk->pfnGetObjectHandlerInfo(pols, idObj, &reverseinit);

	if (lserr != lserrNone)	return lserr;

    pilsobj = (PILSOBJ) pclscbk->pfnNewPtr(pols, sizeof(*pilsobj));

	if (NULL == pilsobj) return lserrOutOfMemory;

    pilsobj->pols = pols;
    pilsobj->lscbk = *pclscbk;
	pilsobj->plsc = plsc;
	pilsobj->idobj = idObj;
	pilsobj->lsesc.wchFirst = reverseinit.wchEndReverse;
	pilsobj->lsesc.wchLast = reverseinit.wchEndReverse;
	pilsobj->pfnReverseEnum = reverseinit.pfnEnum;
	pilsobj->pfnReverseGetInfo = reverseinit.pfnGetRobjInfo;

	*ppilsobj = pilsobj;

	return lserrNone;
}

/* R E V E R S E D E S T R O Y I L S O B J */
/*----------------------------------------------------------------------------
	%%Function: ReverseDestroyILSObj
	%%Contact: ricksa

		DestroyILSObj

		Free all resources assocaiated with Reverse ILS object.
	
----------------------------------------------------------------------------*/
LSERR WINAPI ReverseDestroyILSObj(
	PILSOBJ pilsobj)			/* (IN): object ilsobj */
{
	pilsobj->lscbk.pfnDisposePtr(pilsobj->pols, pilsobj);
	return lserrNone;
}

/* R E V E R S E S E T D O C */
/*----------------------------------------------------------------------------
	%%Function: ReverseSetDoc
	%%Contact: ricksa

		SetDoc

		Keep track of device information for scaling purposes.
	
----------------------------------------------------------------------------*/
LSERR WINAPI ReverseSetDoc(
	PILSOBJ pilsobj,			/* (IN): object ilsobj */
	PCLSDOCINF pclsdocinf)		/* (IN): initialization data of the document level */
{
	Unreferenced(pilsobj);
	Unreferenced(pclsdocinf);

	return lserrNone;
}


/* R E V E R S E C R E A T E L N O B J */
/*----------------------------------------------------------------------------
	%%Function: ReverseCreateLNObj
	%%Contact: ricksa

		CreateLNObj

		Create the Line Object for the Reverse. No real need for a line
		object so don't allocated it.
	
----------------------------------------------------------------------------*/
LSERR WINAPI ReverseCreateLNObj(
	PCILSOBJ pcilsobj,			/* (IN): object ilsobj */
	PLNOBJ *pplnobj)			/* (OUT): object lnobj */
{
	*pplnobj = (PLNOBJ) pcilsobj;

	return lserrNone;
}

/* R E V E R S E D E S T R O Y L N O B J */
/*----------------------------------------------------------------------------
	%%Function: ReverseDestroyLNObj
	%%Contact: ricksa

		DestroyLNObj

		Frees resources associated with the Reverse line object. Since
		there isn't any this is a no-op.
	
----------------------------------------------------------------------------*/
LSERR WINAPI ReverseDestroyLNObj(
	PLNOBJ plnobj)				/* (OUT): object lnobj */

{
	Unreferenced(plnobj);

	return lserrNone;
}

/* R E V E R S E F M T */
/*----------------------------------------------------------------------------
	%%Function: ReverseFmt
	%%Contact: ricksa

		Fmt

		Format the Reverse object. 
	
----------------------------------------------------------------------------*/
LSERR WINAPI ReverseFmt(
    PLNOBJ plnobj,				/* (IN): object lnobj */
    PCFMTIN pcfmtin,			/* (IN): formatting input */
    FMTRES *pfmtres)			/* (OUT): formatting result */
{
	PDOBJ pdobj;
	LSERR lserr;
	PILSOBJ pilsobj = (PILSOBJ) plnobj;
	LSCP cpStartMain = pcfmtin->lsfgi.cpFirst + 1;
	LSCP cpOut;

	lserr = InitDobj(pilsobj, pcfmtin, &pdobj);

//	Assert (pilsobj->pfnReverseGetInfo != NULL);

	if (pilsobj->pfnReverseGetInfo != NULL)
		{
		lserr = pilsobj->pfnReverseGetInfo (pilsobj->pols, 
											pcfmtin->lsfgi.cpFirst,
											pcfmtin->lsfrun.plsrun, 
											&pdobj->fDoNotBreakAround,
											&pdobj->fSuppressTrailingSpaces);

		if (lserr != lserrNone) return ReverseFmtFailed (pdobj, lserr);

	};

	if (lserr != lserrNone)	return lserrNone;

	pdobj->fFirstOnLine = pcfmtin->lsfgi.fFirstOnLine;
	pdobj->plsdnTop = pcfmtin->plsdnTop;

	// Format the text to the maximum remaining in the column
	lserr = FormatLine(pilsobj->plsc, cpStartMain, 
		pcfmtin->lsfgi.urColumnMax - pcfmtin->lsfgi.urPen, 
			pdobj->lstflowO, &pdobj->plssubl, 1, &pilsobj->lsesc,  
				&pdobj->objdimAll, &cpOut, NULL, NULL, pfmtres);

	if (lserr != lserrNone) return ReverseFmtFailed (pdobj, lserr);

	return FinishFmt(pdobj, pilsobj, pcfmtin, cpStartMain, cpOut, *pfmtres);
}

/* R E V E R S E F M T R E S U M E */
/*----------------------------------------------------------------------------
	%%Function: ReverseFmtResume
	%%Contact: ricksa

		Fmt

		Format a broken Reverse object. 

----------------------------------------------------------------------------*/

LSERR WINAPI ReverseFmtResume(
	PLNOBJ plnobj,				/* (IN): object lnobj */
	const BREAKREC *rgBreakRecord,	/* (IN): array of break records */
	DWORD nBreakRecord,			/* (IN): size of the break records array */
	PCFMTIN pcfmtin,			/* (IN): formatting input */
	FMTRES *pfmtres)			/* (OUT): formatting result */
{
	PDOBJ pdobj;
	LSERR lserr;
	PILSOBJ pilsobj = (PILSOBJ) plnobj;
	LSCP cpStartMain = pcfmtin->lsfgi.cpFirst;
	LSCP cpOut;

	lserr = InitDobj(pilsobj, pcfmtin, &pdobj);

	if (lserr != lserrNone)	return lserr;

	/* InitDobj sets cpStartObj to start of text. Because we are resuming,
	   we need to set this to the real start of the object. */

	pdobj->cpStartObj = rgBreakRecord->cpFirst;

//	Assert (pilsobj->pfnReverseGetInfo != NULL);

	if (pilsobj->pfnReverseGetInfo != NULL)
		{
		lserr = pilsobj->pfnReverseGetInfo (pilsobj->pols, pcfmtin->lsfgi.cpFirst,
											pcfmtin->lsfrun.plsrun, 
											&pdobj->fDoNotBreakAround,
											&pdobj->fSuppressTrailingSpaces);

		if (lserr != lserrNone) return ReverseFmtFailed (pdobj, lserr);
		};

	pdobj->fFirstOnLine = pcfmtin->lsfgi.fFirstOnLine;
	pdobj->plsdnTop = pcfmtin->plsdnTop;

	/* Format the text to the maximum remaining in the column */

	lserr = FormatResumedLine(pilsobj->plsc, cpStartMain, 
		pcfmtin->lsfgi.urColumnMax - pcfmtin->lsfgi.urPen, 
			pdobj->lstflowO, &pdobj->plssubl, 1, &pilsobj->lsesc,  
				&pdobj->objdimAll, &cpOut, NULL, NULL, pfmtres,
					&rgBreakRecord[1], nBreakRecord - 1);

	if (lserr != lserrNone) return ReverseFmtFailed (pdobj, lserr);

	return FinishFmt(pdobj, pilsobj, pcfmtin, cpStartMain, cpOut, *pfmtres);
}



/* R E V E R S E T R U N C A T E C H U N K */
/*----------------------------------------------------------------------------
	%%Function: ReverseTruncateChunk
	%%Contact: ricksa

	
----------------------------------------------------------------------------*/
LSERR WINAPI ReverseTruncateChunk(
	PCLOCCHNK plocchnk,			/* (IN): locchnk to truncate */
	PPOSICHNK posichnk)			/* (OUT): truncation point */
{
	long urColumnMax = plocchnk->lsfgi.urColumnMax;
	long ur = plocchnk->ppointUvLoc[0].u;
	PDOBJ pdobj = NULL;
	DWORD i;
	LSCP cp;
	LSERR lserr;

	AssertSz(plocchnk->ppointUvLoc[0].u <= urColumnMax, 
		"ReverseTruncateChunk - pen greater than column max");

	/* Look for chunk to truncate */
	for (i = 0; ur <= urColumnMax; i++)
	{
		AssertSz((i < plocchnk->clschnk), "ReverseTruncateChunk exceeded group of chunks");
	
		ur = plocchnk->ppointUvLoc[i].u;

		AssertSz(ur <= urColumnMax, 
			"ReverseTruncateChunk - pen pos past column max");

		pdobj = plocchnk->plschnk[i].pdobj;

		ur += pdobj->objdimAll.dur;
	}

	/* Found the object where truncation is to occur */
	AssertSz(pdobj != NULL, "ReverseTruncateChunk - pdobj is NULL");

	/* Get the truncation point from the subline */
	lserr = LsTruncateSubline(pdobj->plssubl, 
		urColumnMax - (ur - pdobj->objdimAll.dur), &cp);

	if (lserr != lserrNone)	return lserr;

	/* Format return result */

	posichnk->ichnk = i - 1;

	posichnk->dcp = TranslateCpLimSublineToDcpExternal (pdobj, cp + 1);

	return lserrNone;
}


/* R E V E R S E F I N D P R E V B R E A K C O R E*/
/*----------------------------------------------------------------------------
	%%Function: ReverseFindPrevBreakCore
	%%Contact: antons


----------------------------------------------------------------------------*/

LSERR ReverseFindPrevBreakCore (
									 
	PCLOCCHNK	pclocchnk,		/* (IN): locchnk to break */
	DWORD		ichnk,			/* (IN): object to start looking for break */
	BOOL		fDcpOutside,	/* (IN): when true, start looking from outside */
	LSDCP		dcp,			/* (IN): starting dcp; valid only when fDcpOutside=False */
	BRKCOND		brkcond,		/* (IN): recommmendation about the break before ichnk */
	PBRKOUT		pbrkout)		/* (OUT): result of breaking */
{
	LSERR lserr;
	PDOBJ pdobj = pclocchnk->plschnk[ichnk].pdobj;

	if (fDcpOutside)
		{
		if ( brkcond != brkcondNever &&  
			! (pdobj->fDoNotBreakAround && brkcond == brkcondCan) )
			{
			/* Can break after ichnk */

			PutBreakAtEndOfObject(ichnk, pclocchnk, pbrkout);
			ReverseSaveBreakRecord (pdobj, brkkindPrev, breakSublineAfter, pdobj->cpStart + pdobj->dcp);
			return lserrNone;
			}
		else
			{
			/* Try to break ichnk */

			return ReverseFindPrevBreakCore ( pclocchnk, 
											  ichnk, 
											  fFalse, 
											  pclocchnk->plschnk[ichnk].dcp - 1,
											  brkcond,
											  pbrkout );
			}
		}
	else
		{

		LSCP cpTruncateSubline = TranslateDcpExternalToCpLimSubline (pdobj, dcp - 1);
		BOOL fSuccessful;
		LSCP cpBreak;
		OBJDIM objdimSubline;
		BRKPOS brkpos;

		Assert (dcp >= 1 && dcp <= pdobj->dcp);

		/* REVIEW (antons): I do not think that passing pclocchnk->lsfgi.urColumnMax is correct... */
		/*					need to be confirmed with IgorZv */

		lserr = LsFindPrevBreakSubline (
						pdobj->plssubl, 
						pclocchnk->lsfgi.fFirstOnLine,
						cpTruncateSubline, 
						pclocchnk->lsfgi.urColumnMax,
						&fSuccessful, 
						&cpBreak, 
						&objdimSubline, 
						&brkpos);

		if (lserr != lserrNone)	return lserr;

		/* 1. Unsuccessful or break before first DNode */

		if (!fSuccessful || (fSuccessful && brkpos == brkposBeforeFirstDnode))
			{
			if (ichnk == 0) 
				{
				/* First in the chunk => return UnSuccessful */

				PutBreakUnsuccessful (pdobj, pbrkout);
				return lserrNone;
				}

			else
				{
				/* Break between objects */
		
				if (pdobj->fDoNotBreakAround)
					{
					return ReverseFindPrevBreakCore ( pclocchnk,
													  ichnk - 1,
													  fTrue,
													  0,
													  brkcondCan,
													  pbrkout );
					}
				else
					{
					pdobj = pclocchnk->plschnk[ichnk-1].pdobj;

					PutBreakAtEndOfObject(ichnk - 1, pclocchnk, pbrkout);
					ReverseSaveBreakRecord (
											pclocchnk->plschnk[ichnk-1].pdobj, 
											brkkindPrev, 
											breakSublineAfter, pdobj->cpStart + pdobj->dcp);
					return lserrNone;
					};
		
				};
			}

		/* 2. Successful break after last DNode */

		else if (brkpos == brkposAfterLastDnode)
			{
			if (brkcond == brkcondNever) /* Can not reset dcp */
				{

				/* We are not allowed to break "after", */
				/* so we are trying another previous break if possible */

				return ReverseFindPrevBreakCore ( pclocchnk,
												  ichnk,
												  fFalse,
												  dcp-1,
												  brkcondCan,
												  pbrkout );
				}
	
			else /* Can reset dcp */
				{
				
				/*	We reset dcp of the break so it happends after object but in break
				record we remember that we should call SetBreakSubline with brkkindPrev */

				ReverseSaveBreakRecord ( pdobj, brkkindPrev, breakSublineInside,
										 pdobj->cpStart + pdobj->dcp );

				return FinishBreakRegular ( ichnk,
											pdobj,
											pdobj->cpStart + pdobj->dcp,
											& objdimSubline,
											pbrkout );
				}	;
			}
		else
			{
			/* 3. Successful break inside subline */

			ReverseSaveBreakRecord (pdobj, brkkindPrev, breakSublineInside,
									cpBreak );

			return FinishBreakRegular (	ichnk, 
										pdobj, 
										cpBreak,
										&objdimSubline, 
										pbrkout );
			};
		};

}


/* R E V E R S E F I N D P R E V B R E A K C H U N K */
/*----------------------------------------------------------------------------
	%%Function: ReverseFindPrevBreakChunk
	%%Contact: antons

  
----------------------------------------------------------------------------*/

LSERR WINAPI ReverseFindPrevBreakChunk (

	PCLOCCHNK pclocchnk,		/* (IN): locchnk to break */
	PCPOSICHNK pcpoischnk,		/* (IN): place to start looking for break */
	BRKCOND brkcond,			/* (IN): recommmendation about the break after chunk */
	PBRKOUT pbrkout)			/* (OUT): results of breaking */
{

	if (pcpoischnk->ichnk == ichnkOutside)
		{
		return ReverseFindPrevBreakCore ( pclocchnk, 
										  pclocchnk->clschnk - 1, 
										  fTrue, 
										  0,
										  brkcond, 
										  pbrkout );
		}
	else
		{
		return ReverseFindPrevBreakCore ( pclocchnk, 
										  pcpoischnk->ichnk, 
										  fFalse, 
										  pcpoischnk->dcp,
										  brkcondPlease,
										  pbrkout );
		};
}


/* R E V E R S E F I N D N E X T B R E A K C O R E*/
/*----------------------------------------------------------------------------
	%%Function: ReverseFindNextBreakCore
	%%Contact: antons

  
----------------------------------------------------------------------------*/

LSERR ReverseFindNextBreakCore (
									 
	PCLOCCHNK	pclocchnk,		/* (IN): locchnk to break */
	DWORD		ichnk,			/* (IN): object to start looking for break */
	BOOL		fDcpOutside,	/* (IN): when true, start looking from outside */
	LSDCP		dcp,			/* (IN): starting dcp; valid only when fDcpOutside=False */
	BRKCOND		brkcond,		/* (IN): recommmendation about the break before ichnk */
	PBRKOUT		pbrkout )		/* (OUT): result of breaking */
{
	LSERR lserr;
	PDOBJ pdobj = pclocchnk->plschnk[ichnk].pdobj;

	if (fDcpOutside)
		{
		if ( brkcond != brkcondNever &&  
			! (pdobj->fDoNotBreakAround && brkcond == brkcondCan) )
			{
			/* Can break before ichnk */

			PutBreakBeforeObject (ichnk, pclocchnk, pbrkout);
			return lserrNone;
			}
		else
			{
			/* Try to break ichnk */

			return ReverseFindNextBreakCore (pclocchnk, ichnk, fFalse, 1, brkcond, pbrkout );
			}
		}
	else
		{
		/* Dcp is inside ichnk */

		LSCP cpTruncateSubline = TranslateDcpExternalToCpLimSubline (pdobj, dcp - 1);
		BOOL fSuccessful;
		LSCP cpBreak;
		OBJDIM objdimSubline;
		BRKPOS brkpos;

		Assert (dcp >= 1 && dcp <= pdobj->dcp);


		/* REVIEW (antons): I do not think that passing pclocchnk->lsfgi.urColumnMax is correct... */
		/*					need to be confirmed with IgorZv */

		lserr = LsFindNextBreakSubline (
						pdobj->plssubl, 
						pclocchnk->lsfgi.fFirstOnLine,
						cpTruncateSubline, 
						pclocchnk->lsfgi.urColumnMax,
						&fSuccessful, 
						&cpBreak, 
						&objdimSubline, 
						&brkpos);

		if (lserr != lserrNone)	return lserr;

		if (!fSuccessful)
			{
			/* Unsuccessful break */

			if (ichnk == pclocchnk->clschnk-1) /* Last object in chunk */
				{
				/* Review (AntonS): Better would be take objdimSubline */

				pbrkout->objdim = pclocchnk->plschnk[ichnk].pdobj->objdimAll;

				PutBreakUnsuccessful (pdobj, pbrkout);
	
				/* Break condition is not next => have to store break record */
				ReverseSaveBreakRecord ( pdobj, 
										brkkindNext,
										breakSublineAfter, pdobj->cpStart + pdobj->dcp );
				return lserrNone;
				}
			else if (pdobj->fDoNotBreakAround)
				{
				/* Try to break next object */

				return ReverseFindNextBreakCore (
												pclocchnk,
												ichnk+1,
												fTrue,
												0,
												brkcondCan,
												pbrkout );
				}
			else
				{
				/* Break after ichnk */

				PutBreakAtEndOfObject(ichnk, pclocchnk, pbrkout);

				ReverseSaveBreakRecord ( pclocchnk->plschnk[ichnk].pdobj, 
										 brkkindNext, 
										 breakSublineAfter,
										 pclocchnk->plschnk[ichnk].pdobj->cpStart +
										 pclocchnk->plschnk[ichnk].pdobj->dcp );
				return lserrNone;
				};
			}

		else if (brkpos == brkposAfterLastDnode)
			{
			/* Break after last dnode => reset dcp and break afetr ichnk */

			ReverseSaveBreakRecord (pdobj, brkkindNext, breakSublineInside, pdobj->cpStart + pdobj->dcp);

			return FinishBreakRegular ( ichnk, 
										pdobj, 
										pdobj->cpStart + pdobj->dcp, 
										& objdimSubline, 
										pbrkout );
			}

		else 
			{
			/* 3. Successful break inside subline */

			ReverseSaveBreakRecord (pdobj, brkkindNext, breakSublineInside, cpBreak);

			return FinishBreakRegular ( ichnk, 
										pdobj, 
										cpBreak, 
										& objdimSubline, 
										pbrkout);
			};
		}

} /* End of ReverseFindNextBreakCore */


/* R E V E R S E F I N D N E X T B R E A K C H U N K */
/*----------------------------------------------------------------------------
	%%Function: ReverseFindNextBreakChunk
	%%Contact: antons

  
----------------------------------------------------------------------------*/

LSERR WINAPI ReverseFindNextBreakChunk (

	PCLOCCHNK pclocchnk,		/* (IN): locchnk to break */
	PCPOSICHNK pcpoischnk,		/* (IN): place to start looking for break */
	BRKCOND brkcond,			/* (IN): recommmendation about the break after chunk */
	PBRKOUT pbrkout)			/* (OUT): results of breaking */
{
	LSERR lserr;

	if (pcpoischnk->ichnk == ichnkOutside)
		{
		lserr = ReverseFindNextBreakCore ( pclocchnk, 
										  0, 
										  fTrue, 
										  0,
										  brkcond,
										  pbrkout );

		}
	else
		{
		lserr = ReverseFindNextBreakCore ( pclocchnk, 
										  pcpoischnk->ichnk,
										  fFalse,
										  pcpoischnk->dcp,
										  brkcondPlease,
										  pbrkout );
		};

	return lserr;
}

			
/* R E V E R S E F O R C E B R E A K C H U N K */
/*----------------------------------------------------------------------------
	%%Function: ReverseForceBreak
	%%Contact: antons


----------------------------------------------------------------------------*/

LSERR WINAPI ReverseForceBreakChunk (

	PCLOCCHNK pclocchnk,		/* (IN): locchnk to break */
	PCPOSICHNK pcposichnkIn,	/* (IN): place to start looking for break */
	PBRKOUT pbrkout)			/* (OUT): results of breaking */
{

	POSICHNK posichnk = * pcposichnkIn;
	
	LSERR lserr;
	LSCP cpTruncateSubline;
	LSCP cpBreak;
	OBJDIM objdimSubline;
	PDOBJ pdobj;

	BRKPOS brkpos;

	if (posichnk.ichnk == ichnkOutside)
		{
		/* When left indent is bigger then Right Margin */
		posichnk.ichnk = 0;
		posichnk.dcp = 1;
		};
	
	Assert (posichnk.ichnk != ichnkOutside);

	pdobj = pclocchnk->plschnk[posichnk.ichnk].pdobj;

	if (pclocchnk->lsfgi.fFirstOnLine && (posichnk.ichnk == 0))
		{

		/* Object is the first on line (can not break before) */

		LSDCP dcp = posichnk.dcp;
		BOOL fEmpty;

		Assert (dcp >= 1 && dcp <= pdobj->dcp);

		lserr = LssbFIsSublineEmpty (pdobj->plssubl, &fEmpty);

		if (lserr != lserrNone) return lserr;
		
		if (fEmpty)
			{
			/* Can not ForceBreak empty subline */

			Assert (posichnk.ichnk == 0);
	
			PutBreakAtEndOfObject(0, pclocchnk, pbrkout);

			ReverseSaveBreakRecord ( pclocchnk->plschnk[0].pdobj, 
									 brkkindForce, 
									 breakSublineAfter,  
									 pclocchnk->plschnk[0].pdobj->cpStart +
									 pclocchnk->plschnk[0].pdobj->dcp );

			return lserrNone;
			};
			
		/* Subline is not empty => do force break */
		
		/* REVIEW (antons): The same as in Prev & Next Break */
		cpTruncateSubline = TranslateDcpExternalToCpLimSubline (pdobj, dcp - 1);
		
		lserr = LsForceBreakSubline ( 
						pdobj->plssubl, 
						pclocchnk->lsfgi.fFirstOnLine, 
						cpTruncateSubline, 
						pclocchnk->lsfgi.urColumnMax, 
						&cpBreak, 
						&objdimSubline,
						&brkpos );

		if (lserr != lserrNone) return lserr;

		/* REVIEW (antons): Check with IgorZv that Assert is correct ;-) */

		Assert (brkpos != brkposBeforeFirstDnode);

		if (brkpos == brkposAfterLastDnode)
			{
			/* We reset dcp so that closing brace stays on the same line */
			
			ReverseSaveBreakRecord (pdobj, brkkindForce, breakSublineInside, pdobj->cpStart + pdobj->dcp);

			return FinishBreakRegular ( posichnk.ichnk, 
										pdobj, 
										pdobj->cpStart + pdobj->dcp,  
										&objdimSubline, 
										pbrkout );
			}
		else
			{
			/* "Regular" ;-) ForceBreak inside subline */
			
			ReverseSaveBreakRecord (pdobj, brkkindForce, breakSublineInside, cpBreak);

			return FinishBreakRegular (  posichnk.ichnk, 
										 pdobj, 
										 cpBreak, 
										 &objdimSubline, 
										 pbrkout );
			}
		}

	else 
		{

		/* Can break before ichnk */

		PutBreakBeforeObject (posichnk.ichnk, pclocchnk, pbrkout);

		/*	Do not need to save break record when break "before", because it will be
			translated by manager to SetBreak (previous_dnode, ImposeAfter)	*/

		/* REVIEW (antons): It is strange that I have difference between break "before"
							not-first ichnk element and break "after" not-last. And only 
							in the second case I remember break record */

		return lserrNone;

		};

} /* ReverseForceBreakChunk */


/* R E V E R S E S E T B R E A K */
/*----------------------------------------------------------------------------
	%%Function: ReverseSetBreak
	%%Contact: antons


----------------------------------------------------------------------------*/

LSERR WINAPI ReverseSetBreak(
	PDOBJ pdobj,				/* (IN): dobj which is broken */
	BRKKIND brkkind,			/* (IN): Prev / Next / Force / Impose After */
	DWORD cBreakRecord,			/* (IN): size of array */
	BREAKREC *rgBreakRecord,	/* (IN): array of break records */
	DWORD *pcActualBreakRecord)	/* (IN): actual number of used elements in array */
{
	LSERR lserr = lserrNone;

	if (cBreakRecord < 1) return lserrInsufficientBreakRecBuffer;

	if (pdobj->fSuppressTrailingSpaces && pdobj->fFirstOnLine)
		{
		/* Robj is alone on the line => submit for trailing spaces */

		if (brkkind != brkkindImposedAfter)
			{
			BREAKSUBLINETYPE breakSublineType;
			LSCP cpBreak;
			ReverseGetBreakRecord (pdobj, brkkind, &breakSublineType, &cpBreak);

			if (cpBreak < (LSCP) (pdobj->cpStart + pdobj->dcp))
				{
				lserr = LsdnSubmitSublines(pdobj->pilsobj->plsc, pdobj->plsdnTop, 1, 
								&pdobj->plssubl, TRUE, TRUE, TRUE, TRUE, TRUE);

				if (lserr != lserrNone) return lserr;
				};
			};
		};

	if (brkkind == brkkindImposedAfter)
		{
		/* Break is imposed ater DNODE */

		lserr = LsSetBreakSubline ( pdobj->plssubl, 
									brkkindImposedAfter, 
									cBreakRecord-1, 
								    & rgBreakRecord [1], 
									pcActualBreakRecord );
		if (lserr != lserrNone) return lserr;

		Assert (*pcActualBreakRecord == 0);
		return lserrNone;
		}

	else
		{
		BREAKSUBLINETYPE breakSublineType;
		LSCP cpBreak;

		/* Result of previous Prev / Next or Force - used stored break record */

		ReverseGetBreakRecord (pdobj, brkkind, &breakSublineType, &cpBreak);

		Assert (breakSublineType == breakSublineAfter || breakSublineType == breakSublineInside);

		if (breakSublineType == breakSublineAfter)
			{
			/* type = breakSublineAfter */

			lserr = LsSetBreakSubline ( pdobj->plssubl, 
										brkkindImposedAfter, 
										cBreakRecord-1, 
					  				    & rgBreakRecord [1], 
										pcActualBreakRecord );
			if (lserr != lserrNone) return lserr;
										
			Assert (*pcActualBreakRecord == 0);
			return lserrNone;
			}

		else 
			{ 
			/* type = breakSublineInside */

			lserr = LsSetBreakSubline ( pdobj->plssubl, 
										brkkind, 
										cBreakRecord-1,
									    & rgBreakRecord [1], 
										pcActualBreakRecord );
			if (lserr != lserrNone) return lserr;

			/* Still possible to have break after object */

				
			if (cpBreak == (LSCP) (pdobj->cpStart + pdobj->dcp))
				{
				Assert (*pcActualBreakRecord == 0);
				return lserrNone;
				}
			else
				{
				(*pcActualBreakRecord) += 1;
	
				rgBreakRecord[0].idobj = pdobj->pilsobj->idobj;
				rgBreakRecord[0].cpFirst = pdobj->cpStartObj;

				return lserrNone;
				}
			};	

		}; 
}

/* R E V E R S E G E T S P E C I A L E F F E C T S I N S I D E */
/*----------------------------------------------------------------------------
	%%Function: ReverseGetSpecialEffectsInside
	%%Contact: ricksa

		GetSpecialEffectsInside

		.

----------------------------------------------------------------------------*/
LSERR WINAPI ReverseGetSpecialEffectsInside(
	PDOBJ pdobj,				/* (IN): dobj */
	UINT *pEffectsFlags)		/* (OUT): Special effects for this object */
{
	return LsGetSpecialEffectsSubline(pdobj->plssubl, pEffectsFlags);
}

/* R E V E R S E C A L C P R E S E N T A T I O N */
/*----------------------------------------------------------------------------
	%%Function: ReverseCalcPresentation
	%%Contact: ricksa

		CalcPresentation
	
----------------------------------------------------------------------------*/
LSERR WINAPI ReverseCalcPresentation(
	PDOBJ pdobj,				/* (IN): dobj */
	long dup,					/* (IN): dup of dobj */
	LSKJUST lskjust,			/* (IN): Justification type */
	BOOL fLastVisibleOnLine )	/* (IN): Is this object last visible on line? */
{
	LSERR lserr;
	BOOL fDone;

	Unreferenced (lskjust);
	Unreferenced (fLastVisibleOnLine);	

	pdobj->dup = dup;

	/* Make sure that justification line has been made ready for presentation */
	lserr = LssbFDonePresSubline(pdobj->plssubl, &fDone);

	if ((lserrNone == lserr) && !fDone)
		{
		lserr = LsMatchPresSubline(pdobj->plssubl);
		}

	return lserr;
}

/* R E V E R S E Q U E R Y P O I N T P C P */
/*----------------------------------------------------------------------------
	%%Function: ReverseQueryPointPcp
	%%Contact: ricksa

		Map dup to dcp

----------------------------------------------------------------------------*/
LSERR WINAPI ReverseQueryPointPcp(
	PDOBJ pdobj,				/*(IN): dobj to query */
	PCPOINTUV ppointuvQuery,	/*(IN): query point (uQuery,vQuery) */
	PCLSQIN plsqin,				/*(IN): query input */
	PLSQOUT plsqout)			/*(OUT): query output */
{
	Unreferenced(ppointuvQuery);

	return CreateQueryResult(pdobj->plssubl, pdobj->dup - 1, 0, plsqin, plsqout);
}

/* R E V E R S E Q U E R Y C P P P O I N T */
/*----------------------------------------------------------------------------
	%%Function: ReverseQueryCpPpoint
	%%Contact: ricksa

		Map dcp to dup

----------------------------------------------------------------------------*/
LSERR WINAPI ReverseQueryCpPpoint(
	PDOBJ pdobj,				/*(IN): dobj to query, */
	LSDCP dcp,					/*(IN): dcp for the query */
	PCLSQIN plsqin,				/*(IN): query input */
	PLSQOUT plsqout)			/*(OUT): query output */
{
	Unreferenced(dcp);

	return CreateQueryResult(pdobj->plssubl, pdobj->dup - 1, 0, plsqin, plsqout);
}

	
/* R E V E R S E D I S P L A Y */
/*----------------------------------------------------------------------------
	%%Function: ReverseDisplay
	%%Contact: ricksa

		Display

		This calculates the positions of the various lines for the
		display and then displays them.
	
----------------------------------------------------------------------------*/
LSERR WINAPI ReverseDisplay(
	PDOBJ pdobj,
	PCDISPIN pcdispin)
{
	POINTUV pointuv;
	POINT pt;
	BOOL fDisplayed;
	LSERR lserr = LssbFDoneDisplay(pdobj->plssubl, &fDisplayed);

	if (lserr != lserrNone)
		{
		return lserr;
		}

	if (fDisplayed)
		{
		return lserrNone;
		}

	/* Calculate point to start displaying the subline. */
	pointuv.u = pdobj->dup - 1;
	pointuv.v = 0;

	LsPointXYFromPointUV(&pcdispin->ptPen, pdobj->lstflowL, &pointuv, &pt);

	/* display the Reverse line */

	return LsDisplaySubline(pdobj->plssubl, &pt, pcdispin->kDispMode, pcdispin->prcClip);

}

/* R E V E R S E D E S T R O Y D O B J */
/*----------------------------------------------------------------------------
	%%Function: ReverseDestroyDobj
	%%Contact: ricksa

		DestroyDobj

		Free all resources connected with the input dobj.
	
----------------------------------------------------------------------------*/
LSERR WINAPI ReverseDestroyDobj(
	PDOBJ pdobj)
{
	return ReverseFreeDobj(pdobj);
}

/* R E V E R S E E N U M */
/*----------------------------------------------------------------------------
	%%Function: ReverseEnum
	%%Contact: ricksa

		Enum

		Enumeration callback - passed to client.
	
----------------------------------------------------------------------------*/
LSERR WINAPI ReverseEnum(
	PDOBJ pdobj,				/*(IN): dobj to enumerate */
	PLSRUN plsrun,				/*(IN): from DNODE */
	PCLSCHP plschp,				/*(IN): from DNODE */
	LSCP cp,					/*(IN): from DNODE */
	LSDCP dcp,					/*(IN): from DNODE */
	LSTFLOW lstflow,			/*(IN): text flow*/
	BOOL fReverse,				/*(IN): enumerate in reverse order */
	BOOL fGeometryNeeded,		/*(IN): */
	const POINT *pt,			/*(IN): starting position (top left), iff fGeometryNeeded */
	PCHEIGHTS pcheights,		/*(IN): from DNODE, relevant iff fGeometryNeeded */
	long dupRun)				/*(IN): from DNODE, relevant iff fGeometryNeeded */
{
	return pdobj->pilsobj->pfnReverseEnum(pdobj->pilsobj->pols, plsrun, plschp, 
		cp, dcp, lstflow, fReverse, fGeometryNeeded, pt, pcheights, dupRun, 
			pdobj->lstflowO, pdobj->plssubl);
}
	
/* L S G E T R E V E R S E L S I M E T H O D S */
/*----------------------------------------------------------------------------
	%%Function: LsGetReverseLsimethods
	%%Contact: ricksa

		Initialize object handler for client.
	
----------------------------------------------------------------------------*/
LSERR WINAPI LsGetReverseLsimethods(
        LSIMETHODS *plsim)
{
	plsim->pfnCreateILSObj = ReverseCreateILSObj;
	plsim->pfnDestroyILSObj = ReverseDestroyILSObj;
	plsim->pfnSetDoc = ReverseSetDoc;
	plsim->pfnCreateLNObj = ReverseCreateLNObj;
	plsim->pfnDestroyLNObj = ReverseDestroyLNObj;
	plsim->pfnFmt = ReverseFmt;
	plsim->pfnFmtResume = ReverseFmtResume;
	plsim->pfnGetModWidthPrecedingChar = ObjHelpGetModWidthChar;
	plsim->pfnGetModWidthFollowingChar = ObjHelpGetModWidthChar;
	plsim->pfnTruncateChunk = ReverseTruncateChunk;
	plsim->pfnFindPrevBreakChunk = ReverseFindPrevBreakChunk;
	plsim->pfnFindNextBreakChunk = ReverseFindNextBreakChunk;
	plsim->pfnForceBreakChunk = ReverseForceBreakChunk;
	plsim->pfnSetBreak = ReverseSetBreak;
	plsim->pfnGetSpecialEffectsInside = ReverseGetSpecialEffectsInside;
	plsim->pfnFExpandWithPrecedingChar = ObjHelpFExpandWithPrecedingChar;
	plsim->pfnFExpandWithFollowingChar = ObjHelpFExpandWithFollowingChar;
	plsim->pfnCalcPresentation = ReverseCalcPresentation;
	plsim->pfnQueryPointPcp = ReverseQueryPointPcp;
	plsim->pfnQueryCpPpoint = ReverseQueryCpPpoint;
	plsim->pfnDisplay = ReverseDisplay;
	plsim->pfnDestroyDObj = ReverseDestroyDobj;
	plsim->pfnEnum = ReverseEnum;
	return lserrNone;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\sublutil.c ===
#include "lsidefs.h"
#include "sublutil.h"
#include "dnutils.h"
#include "lssubl.h"
#include "lsdnode.h"
#include "dninfo.h"
#include "lsimeth.h"
#include "iobj.h"
#include "lsmem.h"
#include "chnutils.h"
#include "posichnk.h"
#include "getfmtst.h"
#include "lstext.h"

#ifdef DEBUG
#define DebugMemset(a,b,c)		if ((a) != NULL) memset(a,b,c); else
#else
#define DebugMemset(a,b,c)		(void)(0)
#endif



LSERR GetSpecialEffectsSublineCore(PLSSUBL plssubl,PLSIOBJCONTEXT plsiobjcontext,
								   UINT* pfEffectsFlags)
{
	PLSDNODE plsdn;
	PLSDNODE plsdnPrev;
	UINT fEffectsFlagsObject;
	DWORD iobj;
	LSERR lserr;
	LSIMETHODS* plsim;


	Assert(FIsLSSUBL(plssubl));


	*pfEffectsFlags = 0;

	plsdn = plssubl->plsdnFirst;
	plsdnPrev = NULL;

	while(plsdnPrev != plssubl->plsdnLast)
		{
		if (FIsDnodeReal(plsdn))
			{
			*pfEffectsFlags |= plsdn->u.real.lschp.EffectsFlags;
			iobj = IdObjFromDnode(plsdn);
			if (iobj != IobjTextFromLsc(plsiobjcontext) && !FIsDnodeSplat(plsdn))
				{
				plsim = PLsimFromLsc(plsiobjcontext, iobj);
				if (plsim->pfnGetSpecialEffectsInside != NULL)
					{
					lserr = plsim->pfnGetSpecialEffectsInside(plsdn->u.real.pdobj,
						&fEffectsFlagsObject);
					
					if (lserr != lserrNone)
						return lserr;
					*pfEffectsFlags |= fEffectsFlagsObject;
					}
				}
			}
		plsdnPrev = plsdn;
		plsdn = plsdn->plsdnNext;
		}
	
	return lserrNone;
}


LSERR	GetObjDimSublineCore(
							 PLSSUBL plssubl,			/* IN: subline			*/
							 POBJDIM pobjdim)			/* OUT: dimension of subline */
	{
		PLSDNODE plsdnFirst = plssubl->plsdnFirst;
		PLSDNODE plsdnLast = plssubl->plsdnLast;
		
		/* skip autonumber for the main subline  */
		if (FIsSubLineMain(plssubl))
			{
			while (plsdnFirst != NULL && plsdnFirst->cpFirst < 0)
				{
				plsdnFirst = plsdnFirst->plsdnNext;
				}
			/* because of splat right after autonumber plsdnFirst can be NULL */
			if (plsdnFirst == NULL) 
				plsdnLast = NULL;
			}

		return FindListDims(plsdnFirst, plsdnLast, pobjdim);
	}

LSERR  GetDupSublineCore(
							PLSSUBL plssubl,			/* IN: Subline Context			*/
					 	    long* pdup)					/* OUT: dup of subline			*/
	{
	   FindListDup(plssubl->plsdnFirst, plssubl->cpLim, pdup);
	   return lserrNone;
	}



LSERR 	FIsSublineEmpty(
						PLSSUBL plssubl,		/* IN: subline						*/
						 BOOL*  pfEmpty)		/* OUT:is this subline empty */
	{
	PLSDNODE plsdnLast;
	Assert(FIsLSSUBL(plssubl));
	Assert((plssubl->plsdnFirst == NULL) == (plssubl->plsdnLast == NULL));

	plsdnLast = plssubl->plsdnLast;

	if (FIsSubLineMain(plssubl))
		{
		if (plsdnLast != NULL && FIsDnodeSplat(plsdnLast))
			{
			plsdnLast = plsdnLast->plsdnPrev;
			}
		*pfEmpty = (plsdnLast == NULL || FIsNotInContent(plsdnLast));
		}
	else
		{
		*pfEmpty = (plsdnLast == NULL );
		}

	return lserrNone;
	}


LSERR	DestroySublineCore(PLSSUBL plssubl,LSCBK* plscbk, POLS pols,
						   PLSIOBJCONTEXT plsiobjcontext, BOOL fDontReleaseRuns)/* IN: subline to destroy   */
	{
	LSERR lserr;
	
	Assert(FIsLSSUBL(plssubl));

	lserr = DestroyDnodeList(plscbk, pols, plsiobjcontext,
					   plssubl->plsdnFirst, fDontReleaseRuns);
	if (lserr != lserrNone)
		return lserr;

	/* destroy chunk context */	
	DestroyChunkContext(plssubl->plschunkcontext);

	/* destroy break context */
	Assert(plssubl->pbrkcontext != NULL);  /* we don't expect main subline to be called */
	DebugMemset(plssubl->pbrkcontext, 0xE9, sizeof(BRKCONTEXT));
	plscbk->pfnDisposePtr(pols, plssubl->pbrkcontext);

	plssubl->tag = tagInvalid;
	DebugMemset(plssubl, 0xE9, sizeof(LSSUBL));
	plscbk->pfnDisposePtr(pols, plssubl);

	return lserrNone;

	}

BOOL   FAreTabsPensInSubline(
						   PLSSUBL plssubl)				/* IN: subline */
	{
	PLSDNODE plsdn;
	PLSDNODE plsdnPrev;
	BOOL fAreTabsPensInSubline;

	Assert(FIsLSSUBL(plssubl));

	fAreTabsPensInSubline = fFalse;

	plsdn = plssubl->plsdnFirst;
	plsdnPrev = NULL;

	while(plsdnPrev != plssubl->plsdnLast)
		{
		if (FIsDnodePen(plsdn) || plsdn->fTab)
			{
			fAreTabsPensInSubline = fTrue;
			break;
			}
		plsdnPrev = plsdn;
		plsdn = plsdn->plsdnNext;
		}
	
	return fAreTabsPensInSubline;
}



LSERR	GetPlsrunFromSublineCore(
							    PLSSUBL	plssubl,		/* IN: subline */
								DWORD   crgPlsrun,		/* IN: size of array */
								PLSRUN* rgPlsrun)		/* OUT: array of plsruns */
	{
	DWORD i = 0;
	PLSDNODE plsdn;
	PLSDNODE plsdnPrev;

	Assert(FIsLSSUBL(plssubl));


	plsdn = plssubl->plsdnFirst;
	plsdnPrev = NULL;

	while(plsdnPrev != plssubl->plsdnLast && i < crgPlsrun)
		{
		if (FIsDnodeReal(plsdn))
			{
			rgPlsrun[i] = plsdn->u.real.plsrun;
			}
		else  /* pen */
			{
			rgPlsrun[i] = NULL;
			}
		plsdnPrev = plsdn;
		plsdn = plsdn->plsdnNext;
		i++;
		}

	return lserrNone;

	}

LSERR	GetNumberDnodesCore(
							PLSSUBL	plssubl,	/* IN: subline */
							DWORD* cDnodes)	/* OUT: numberof dnodes in subline */
	{
	PLSDNODE plsdn;
	PLSDNODE plsdnPrev;

	Assert(FIsLSSUBL(plssubl));

	*cDnodes = 0;
	plsdn = plssubl->plsdnFirst;
	plsdnPrev = NULL;

	while(plsdnPrev != plssubl->plsdnLast)
		{
		(*cDnodes)++;
		plsdnPrev = plsdn;
		plsdn = plsdn->plsdnNext;
		}

	return lserrNone;

	}

LSERR 	GetVisibleDcpInSublineCore(
								   PLSSUBL plssubl,	 /* IN: subline						*/
								   LSDCP*  pndcp)	 /* OUT:amount of visible characters in subline */
	{
	PLSDNODE plsdn;
	PLSDNODE plsdnPrev;

	Assert(FIsLSSUBL(plssubl));

	*pndcp = 0;
	plsdn = plssubl->plsdnFirst;
	plsdnPrev = NULL;

	while(plsdnPrev != plssubl->plsdnLast)
		{
		if (FIsDnodeReal(plsdn))
			{
			*pndcp += plsdn->dcp;
			}

		plsdnPrev = plsdn;
		plsdn = plsdn->plsdnNext;
		}

	return lserrNone;

	}

LSERR GetDurTrailInSubline(
						   PLSSUBL plssubl,			/* IN: Subline Context			*/
													long* pdurTrail)				/* OUT: width of trailing area
													in subline		*/
	{
	LSERR lserr;
	PLSCHUNKCONTEXT plschunkcontext;
	PLSDNODE plsdn;
	LSDCP dcpTrail;
	PLSDNODE plsdnStartTrail;
	LSDCP dcpStartTrailingText;
	int cDnodesTrailing;
	PLSDNODE plsdnTrailingObject;
	LSDCP dcpTrailingObject;
	BOOL fClosingBorderStartsTrailing;

	*pdurTrail = 0;
	
	plsdn = GetCurrentDnodeSubl(plssubl);
	plschunkcontext = PlschunkcontextFromSubline(plssubl);
	
	
	if (plsdn != NULL)
		{
		lserr = GetTrailingInfoForTextGroupChunk(plsdn, 
				plsdn->dcp, IobjTextFromLsc(plschunkcontext->plsiobjcontext),
				pdurTrail, &dcpTrail, &plsdnStartTrail,
				&dcpStartTrailingText, &cDnodesTrailing, 
				&plsdnTrailingObject, &dcpTrailingObject, &fClosingBorderStartsTrailing);
	
		if (lserr != lserrNone) 
			return lserr;
		}
	
	return lserrNone;
	}

LSERR GetDurTrailWithPensInSubline(
						   PLSSUBL plssubl,			/* IN: Subline Context			*/
													long* pdurTrail)				/* OUT: width of trailing area
													in subline		*/
	{
	LSERR lserr;
	PLSCHUNKCONTEXT plschunkcontext;
	PLSDNODE plsdn;
	LSDCP dcpTrail;
	PLSDNODE plsdnStartTrail;
	LSDCP dcpStartTrailingText;
	int cDnodesTrailing;
	PLSDNODE plsdnTrailingObject;
	LSDCP dcpTrailingObject;
	BOOL fClosingBorderStartsTrailing;
	long durTrailLoc;
	BOOL fContinue = fTrue;

	*pdurTrail = 0;
	
	plsdn = GetCurrentDnodeSubl(plssubl);
	plschunkcontext = PlschunkcontextFromSubline(plssubl);
	
	
	while(fContinue)
		{
		
		if (plsdn != NULL)
			{
			lserr = GetTrailingInfoForTextGroupChunk(plsdn, 
				plsdn->dcp, IobjTextFromLsc(plschunkcontext->plsiobjcontext),
				&durTrailLoc, &dcpTrail, &plsdnStartTrail,
				&dcpStartTrailingText, &cDnodesTrailing, 
				&plsdnTrailingObject, &dcpTrailingObject, &fClosingBorderStartsTrailing);
			
			if (lserr != lserrNone) 
				return lserr;
			
			*pdurTrail += durTrailLoc;
			if (dcpTrailingObject == 0)
				{
				/* we stopped just before group chunk, may be because of pen */
				Assert(FIsLSDNODE(plsdnTrailingObject));
				plsdn = plsdnTrailingObject->plsdnPrev;
				while(plsdn != NULL && FIsDnodePen(plsdn))
					{
					*pdurTrail += DurFromDnode(plsdn);
					plsdn = plsdn->plsdnPrev;
					}
				}
			else
				{
				fContinue = fFalse;
				}
			}
		else
			{
			fContinue = fFalse;
			}
		
		}
	
	return lserrNone;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\tabutils.c ===
#include "lsidefs.h"
#include "dninfo.h"
#include "tabutils.h"
#include "lstbcon.h"
#include "plstbcon.h"
#include "lstabs.h"
#include "lsktab.h"
#include "lscaltbd.h"
#include "lstext.h"
#include "zqfromza.h"
#include "iobj.h"
#include "chnutils.h"
#include "lscbk.h"
#include "limqmem.h"
#include "posichnk.h"


#include <limits.h>


static LSERR FillTabsContext(PLSTABSCONTEXT, LSTFLOW);
static LSERR ItbdMergeTabs(PLSTABSCONTEXT plstabscontext, LSTFLOW lstflow, const LSTABS* plstabs,
						   BOOL fHangingTab,
						   long duaHangingTab,
						   WCHAR wchHangingTabLeader, DWORD* picaltbdMac);
static LSERR FindTab (PLSTABSCONTEXT plstabscontext, long urPen, BOOL fUseHangingTabAsDefault,
					  BOOL fZeroWidthUserTab,
					  DWORD* picaltbd, BOOL* pfBreakThroughTab);
static LSERR IncreaseTabsArray(PLSTABSCONTEXT plstabscontext, DWORD ccaltbdMaxNew);



/* G E T  C U R  T A B  I N F O  C O R E*/
/*----------------------------------------------------------------------------
    %%Function: GetCurTabInfoCore
    %%Contact: igorzv
	Parameters:
	plstabscontext	-	(IN) pointer to tabs context 
	plsdnTab		-	(IN) dnode with tab 
	urTab			-	(IN) position before this tab 
	fResolveAllTabsAsLeft(IN) switch all other tab to left
	plsktab			-	(OUT) type of current tab  
	pfBreakThroughTab-	(OUT)is break through tab occurs 

	Provides information about nearest tab stop
----------------------------------------------------------------------------*/

LSERR GetCurTabInfoCore(PLSTABSCONTEXT plstabscontext, PLSDNODE plsdnTab,	
					long urTab,	BOOL fResolveAllTabsAsLeft,
					LSKTAB* plsktab, BOOL* pfBreakThroughTab)
{
	LSERR lserr;
	LSCALTBD* plscaltbd;  
	DWORD icaltbd;
	long durTab;
	BOOL fUseHangingTabAsDefault = fFalse;
	BOOL fZeroWidthUserTab = fFalse;
	long urToFindTabStop;
	
	

	Assert(plsktab != NULL); 

	Assert(FIsLSDNODE(plsdnTab));
	Assert(plsdnTab->fTab);
	Assert(FIsDnodeReal(plsdnTab));

//	Assert(plstabscontext->plsdnPendingTab == NULL);
	

	/* first tab on line   */
	if (!plstabscontext->fTabsInitialized)
		{
		lserr = FillTabsContext(plstabscontext, LstflowFromDnode(plsdnTab));
		if (lserr != lserrNone) 
			return lserr;
		}

	urToFindTabStop = urTab;
	if (plstabscontext->fResolveTabsAsWord97	) /* such strange behaviour was in Word97 */
		{
		if (plsdnTab->fTabForAutonumber)
			{
			fZeroWidthUserTab = fTrue;
			fUseHangingTabAsDefault = fTrue;
			}
		else
			{
			urToFindTabStop++;
			}
		}

	/* find tab in tabs table */
	lserr = FindTab(plstabscontext, urToFindTabStop, fUseHangingTabAsDefault, 
		fZeroWidthUserTab, &icaltbd, pfBreakThroughTab);
	if (lserr != lserrNone) 
		return lserr;

	plsdnTab->icaltbd = icaltbd;
	plscaltbd = &(plstabscontext->pcaltbd[icaltbd]);
	
	/* ask text to set tab leader in his structures */
	if (plscaltbd->wchTabLeader != 0)
		{
		lserr = SetTabLeader(plsdnTab->u.real.pdobj, plscaltbd->wchTabLeader);
		if (lserr != lserrNone) 
			return lserr;   
		}

	*plsktab = plscaltbd->lskt;
	if (fResolveAllTabsAsLeft)
		*plsktab = lsktLeft;

	/* offset calculation for left tab , register pending tab for all others */
	switch (*plsktab)
		{
	default:
		NotReached();
		break;

	case lsktLeft:
		durTab = plscaltbd->ur - urTab;
		Assert(durTab >= 0);

		SetDnodeDurFmt(plsdnTab, durTab);
		break;

	case lsktRight:
	case lsktCenter:
	case lsktDecimal:
	case lsktChar:
		plstabscontext->plsdnPendingTab = plsdnTab;
		plstabscontext->urBeforePendingTab = urTab;
		break;
		}
	
 
	return lserrNone;
}

/* R E S O L V E  P R E V  T A B  C O R E*/
/*----------------------------------------------------------------------------
    %%Function: ResolvePrevTabCore
    %%Contact: igorzv
	Parameters:
	plstabscontext	-	(IN) pointer to tabs context 
	plsdnCurrent	-	(IN) current dnode 
	urCurrentPen	-	(IN) current pen position 
	pdurPendingTab	-	(OUT)offset because of pending tab

	Resolves if exists previous pending tab (right, decimal or center)
----------------------------------------------------------------------------*/

LSERR ResolvePrevTabCore(PLSTABSCONTEXT plstabscontext,	PLSDNODE plsdnCurrent,	
						long urCurrentPen, long* pdurPendingTab)
					
{

	PLSDNODE plsdnPendingTab;
	LSCALTBD* plscaltbd; 
	long urTabStop, durTab, durSeg; 
	PLSDNODE plsdn;
	long durTrail;
	GRCHUNKEXT grchnkext;
	DWORD index;
	long durToDecimalPoint;
	LSERR lserr;
	PLSCHUNKCONTEXT plschunkcontext;
	DWORD cchTrail;
	PLSDNODE plsdnStartTrail;
	LSDCP dcpStartTrailingText;
	PLSDNODE plsdnTrailingObject;
	LSDCP dcpTrailingObject;
	int cDnodesTrailing;
	BOOL fClosingBorderStartsTrailing;
	PLSDNODE plsdnDecimalPoint;

	
	*pdurPendingTab = 0;
	
	plsdnPendingTab = plstabscontext->plsdnPendingTab;
	
	if (plsdnPendingTab == NULL || 
		plsdnPendingTab->cpFirst >= plsdnCurrent->cpFirst)
		/* this second condition can happen after break when because of increased margin
		we fetch pending tab but later break was found before */
		{
		/* no business for us */ 
		return lserrNone;
		}
	
	/* pending in an other subline */
	if (SublineFromDnode(plsdnCurrent) != SublineFromDnode(plsdnPendingTab))
		{
		/* cancell pending tab */
		CancelPendingTab(plstabscontext);
		return lserrNone;
		}
	
	Assert(FIsLSDNODE(plsdnCurrent));
	plschunkcontext = PlschunkcontextFromSubline(SublineFromDnode(plsdnCurrent));
	Assert(plstabscontext->fTabsInitialized);
	
	
	Assert(FIsLSDNODE(plsdnPendingTab));
	Assert(plsdnPendingTab->fTab);
	Assert(FIsDnodeReal(plsdnPendingTab));
	
	plscaltbd = &(plstabscontext->pcaltbd[plsdnPendingTab->icaltbd]);
	urTabStop = plscaltbd->ur;
	durSeg = urCurrentPen - plstabscontext->urBeforePendingTab; 
	
	/* find durTrail */
	/* collect last chunk */
	plsdn = plsdnCurrent;
	/* If we resolve pending tab because of other tab we should 
	use previous dnode to calculate correct group chunk . We also must 
	be careful keeping in mind that line can be stopped right after pending tab */
	if ((plsdn->fTab && plsdn != plsdnPendingTab)) 
		plsdn = plsdn->plsdnPrev;
	
	Assert(FIsLSDNODE(plsdn));
	Assert(!FIsNotInContent(plsdn));
	
	lserr = GetTrailingInfoForTextGroupChunk(plsdn, 
		plsdn->dcp, IdObjFromDnode(plsdnPendingTab),
		&durTrail, &cchTrail, &plsdnStartTrail,
		&dcpStartTrailingText, &cDnodesTrailing, 
		&plsdnTrailingObject, &dcpTrailingObject, &fClosingBorderStartsTrailing);
	if (lserr != lserrNone) 
		return lserr;
	
	
	switch (plscaltbd->lskt)
		{
		default:
		case lsktLeft:
			NotReached();
			break;
			
		case lsktRight:
		case lsktCenter:
			durSeg -= durTrail;
			
			
			if (plscaltbd->lskt == lsktCenter)
				durSeg /= 2;
			break;
			
			
		case lsktDecimal:
		case lsktChar:
			InitGroupChunkExt(plschunkcontext, IdObjFromDnode(plsdnPendingTab), &grchnkext);
			
			plsdn = plsdnPendingTab->plsdnNext;
			Assert(FIsLSDNODE(plsdn));
			
			lserr = CollectTextGroupChunk(plsdn, plsdnCurrent->cpLimOriginal,
				CollectSublinesForDecimalTab, &grchnkext); 
			if (lserr != lserrNone) 
				return lserr;
			
			if (grchnkext.plsdnLastUsed == NULL)
				{
				/* there are now dnodes between tabs */
				durSeg = 0;
				}
			else
				{
				if (grchnkext.lsgrchnk.clsgrchnk > 0)
					{
					if (plscaltbd->lskt == lsktDecimal)
						{
						lserr = LsGetDecimalPoint(&(grchnkext.lsgrchnk), lsdevReference,
							&index, &durToDecimalPoint);
						if (lserr != lserrNone) 
							return lserr;
						}
					else
						{
						Assert(plscaltbd->lskt == lsktChar);
						lserr = LsGetCharTab(&(grchnkext.lsgrchnk), plscaltbd->wchCharTab, lsdevReference,
							&index, &durToDecimalPoint);
						if (lserr != lserrNone) 
							return lserr;
						}
					}
				else
					{
					index = idobjOutside;
					durToDecimalPoint = 0;
					}
				
				if (index != idobjOutside) /* decimal point has been found */
					{
					plsdnDecimalPoint = grchnkext.plschunkcontext->pplsdnChunk[index];
					}
				else
					{
					/* we allign end of the last logical cp to the tab stop */
					plsdnDecimalPoint = grchnkext.plsdnLastUsed;
					durToDecimalPoint = DurFromDnode(plsdnDecimalPoint);
					}
				
				FindPointOffset(plsdn, lsdevReference, LstflowFromDnode(plsdn),	
					CollectSublinesForDecimalTab, 
					plsdnDecimalPoint,	
					durToDecimalPoint, &durSeg);
				}
			
			break;   
		}
	
	durTab = urTabStop - plstabscontext->urBeforePendingTab - durSeg;
	if (urTabStop < plstabscontext->urColumnMax && 
		(durTab + urCurrentPen - durTrail > plstabscontext->urColumnMax))
		{
		/* this code is for compatibility with Word: when we are not in a situation
		of break through tab we dont allow line to leap right margin after we resolve
		pending tab */
		durTab = plstabscontext->urColumnMax - urCurrentPen + durTrail;
		}
	
	if (durTab > 0)
		{
		SetDnodeDurFmt(plsdnPendingTab, durTab);
		*pdurPendingTab = durTab;
		}
	
	
	plstabscontext->plsdnPendingTab = NULL;
	return lserrNone;
}


/* F I L L  T A B S  C O N T E X T*/
/*----------------------------------------------------------------------------
    %%Function: FillTabsContext
    %%Contact: igorzv
	Parameters:
	plstabscontext	-	(IN) pointer to tabs context 
	lstflow			-	(IN) text flow of the line

	Initializes tabs context using clients callback FetchTabs
----------------------------------------------------------------------------*/

LSERR FillTabsContext(PLSTABSCONTEXT plstabscontext, LSTFLOW lstflow)
{

	LSTABS lstabs;
	BOOL fHangingTab;
	long uaHangingTab;
	WCHAR wchHangingTabLeader;
	LSERR lserr;

	lserr = plstabscontext->plscbk->pfnFetchTabs(plstabscontext->pols, plstabscontext->cpInPara,
									&lstabs, &fHangingTab, &uaHangingTab, &wchHangingTabLeader);
	if (lserr != lserrNone) 
		return lserr;

	plstabscontext->durIncrementalTab = UrFromUa(lstflow, &(plstabscontext->plsdocinf->lsdevres), lstabs.duaIncrementalTab);
	/* Copy tabs from LSTABS to rgcaltbd[], inserting a hanging tab if
	 * required.
	 */
	if (fHangingTab || lstabs.iTabUserDefMac > 0)
		{
		lserr = ItbdMergeTabs(plstabscontext, lstflow, 
							  &lstabs, fHangingTab,
							  uaHangingTab, wchHangingTabLeader, &plstabscontext->icaltbdMac);
		if (lserr != lserrNone) 
			return lserr;
		}
	else
		{
		plstabscontext->icaltbdMac = 0;
		}


	
	plstabscontext->fTabsInitialized = fTrue;
	return lserrNone;
}


/* I N I T  T A B S  C O N T E X T  F O R  A U T O  D E C I M A L  T A B*/
/*----------------------------------------------------------------------------
    %%Function: InitTabsContextForAutoDecimalTab
    %%Contact: igorzv
	Parameters:
	plstabscontext	-	(IN) pointer to tabs context 
	durAutoDecimalTab-	(IN) tab stop for autodecimal tab

	Creates tabs context that consists of one tab stop - auto decimal
----------------------------------------------------------------------------*/

LSERR InitTabsContextForAutoDecimalTab(PLSTABSCONTEXT plstabscontext, long durAutoDecimalTab)
	{
	
	LSCALTBD* pcaltbd;
	
	
	pcaltbd = plstabscontext->pcaltbd;
	
	Assert(plstabscontext->ccaltbdMax >= 1);
	
	if (!plstabscontext->fTabsInitialized)
		{
		plstabscontext->icaltbdMac = 1;
		
		pcaltbd->lskt = lsktDecimal;
		pcaltbd->ur = durAutoDecimalTab;
		pcaltbd->wchTabLeader = 0;
		
		plstabscontext->fTabsInitialized = fTrue;
		}
	else
		{
		/* tab is already there because of autonumber */
		Assert(plstabscontext->icaltbdMac == 1);
		Assert(pcaltbd->lskt == lsktDecimal);
		Assert(pcaltbd->ur == durAutoDecimalTab);
		}

	return lserrNone;
	}



/* I T B D  M E R G E  T A B S */
/*----------------------------------------------------------------------------
    %%Function: ItbdMergeTabs
    %%Contact: igorzv
	Parameters:
	plstabscontext	-	(IN) pointer to tabs context 
	lstflow			-	(IN) text flow of the line
	plstabs			-	(IN) tabs array provided by client
	fHangingTab		-	(IN) does paragraph have hanging tab
	uaHangingTab	-	(IN) position of hanging tab
	wchHangingTabLeader-(IN) leader for hanging tab
	picaltbdMac			(OUT) amount of tabs in array



    Copies tabs from LSPAP into ptbd[], inserting a hanging tab where
    required.
----------------------------------------------------------------------------*/
static LSERR ItbdMergeTabs(PLSTABSCONTEXT plstabscontext, LSTFLOW lstflow, 
						   const LSTABS* plstabs, BOOL fHangingTab,
						   long uaHangingTab, WCHAR wchHangingTabLeader, DWORD* picaltbdMac)
{
	long uaPrevTab, uaCurrentTab;
	DWORD itbdOut, itbdIn, itbdLimIn;
	LSCALTBD* plscaltbd;
	DWORD ccaltbdMax;
	LSERR lserr;

	/* check that have enough room*/
	ccaltbdMax = plstabs->iTabUserDefMac;
	if (fHangingTab)
		ccaltbdMax++;
	if (ccaltbdMax >= plstabscontext->ccaltbdMax)
		{
		lserr = IncreaseTabsArray(plstabscontext, ccaltbdMax + limCaltbd);
		if (lserr != lserrNone)
			return lserr;
		}

	plscaltbd = plstabscontext->pcaltbd;

	itbdLimIn = plstabs->iTabUserDefMac;

	uaPrevTab = LONG_MAX;
	itbdOut = 0;

	if (fHangingTab)
		{

		/* If no user tabs, or hanging tab is before 0th user tab,
		 * make hanging tab the 0th member of ptbd[].
		 */
		if (itbdLimIn == 0 || uaHangingTab < plstabs->pTab[0].ua)
			{
			plscaltbd[0].lskt = lsktLeft;
			plscaltbd[0].ur = UrFromUa(lstflow,
						&(plstabscontext->plsdocinf->lsdevres), uaHangingTab);
			plscaltbd[0].wchTabLeader = wchHangingTabLeader;
			plscaltbd[0].fDefault = fFalse;
			plscaltbd[0].fHangingTab = fTrue;
			uaPrevTab = uaHangingTab;
			itbdOut = 1;
			}
		}
	else
		{
		uaHangingTab = LONG_MAX;
		}

	/* Copy user defined tabs, checking each time for hanging tab.
	 */
	for (itbdIn = 0;  itbdIn < itbdLimIn;  itbdOut++, itbdIn++)
		{
		uaCurrentTab = plstabs->pTab[itbdIn].ua; 

		/* If hanging tab is between previous tab and this tab,
		 * insert hanging tab into ptbd[] here and revisit "this" 
		 * tab again during next loop iteration.
		 */
		if (uaPrevTab < uaHangingTab && uaHangingTab < uaCurrentTab)
			{
			plscaltbd[itbdOut].lskt = lsktLeft;
			plscaltbd[itbdOut].ur = UrFromUa(lstflow, &(plstabscontext->plsdocinf->lsdevres),
											uaHangingTab);
			plscaltbd[itbdOut].wchTabLeader = wchHangingTabLeader;
			plscaltbd[itbdOut].fDefault = fFalse;
			plscaltbd[itbdOut].fHangingTab = fTrue;
			itbdIn -= 1;
			uaPrevTab = uaHangingTab;
			}
		else
			{
			plscaltbd[itbdOut].lskt =  plstabs->pTab[itbdIn].lskt;
			plscaltbd[itbdOut].ur = UrFromUa(lstflow, &(plstabscontext->plsdocinf->lsdevres),
												plstabs->pTab[itbdIn].ua);
			plscaltbd[itbdOut].wchTabLeader =  plstabs->pTab[itbdIn].wchTabLeader;
			plscaltbd[itbdOut].wchCharTab =  plstabs->pTab[itbdIn].wchCharTab;
			plscaltbd[itbdOut].fDefault = fFalse;
			plscaltbd[itbdOut].fHangingTab = fFalse;
			uaPrevTab = uaCurrentTab;
			}
		}

	/* If hanging tab is after final user tab, make hanging tab the
	 * final member of ptbd[]
	 */
	if (uaPrevTab < uaHangingTab && uaHangingTab < LONG_MAX)
		{
		plscaltbd[itbdOut].lskt = lsktLeft;
		plscaltbd[itbdOut].ur = UrFromUa(lstflow,
							&(plstabscontext->plsdocinf->lsdevres), uaHangingTab);
		plscaltbd[itbdOut].wchTabLeader = wchHangingTabLeader;
		plscaltbd[itbdOut].fDefault = fFalse;
		plscaltbd[itbdOut].fHangingTab = fTrue;
		itbdOut += 1;
		}

	*picaltbdMac = itbdOut;
	return lserrNone;
}

/* F I N D  T A B*/
/*----------------------------------------------------------------------------
    %%Function: FindTab
    %%Contact: igorzv
	Parameters:
	plstabscontext	-	(IN) pointer to tabs context 
	urPen			-	(IN) position before this tab 
	fUseHangingTabAsDefault - (IN) usually hanging tab is used as user defined tab,
							but in one case for compstibility with Word97 it's treated as
							user default tab 
	fZeroWidthUserTab-	(IN) for compatibility with Word97
	picaltbd		-	(OUT)pointer to a record describing tab stop 
	pfBreakThroughTab-	(OUT)is break through tab occurs 

	Procedure findes fist tab stop after current pen position. In the case when
	it is a default tab stop program adds record to an array of tab stops.
	This procedure also resolves breakthrouhtab logic.
----------------------------------------------------------------------------*/

static LSERR FindTab (PLSTABSCONTEXT plstabscontext, long urPen, BOOL fUseHangingTabAsDefault,
					  BOOL fZeroWidthUserTab,
					  DWORD* picaltbd, BOOL* pfBreakThroughTab)
{

	DWORD icaltbdMac = plstabscontext->icaltbdMac;
	LSCALTBD* pcaltbd = plstabscontext->pcaltbd;
	long durIncTab, durDelta;
	DWORD i;
	LSERR lserr;
	int iHangingTab = -1;
	long urDefaultTab;
	long urPenForUserTab = urPen;

	*pfBreakThroughTab = fFalse;
	
	if (fZeroWidthUserTab)
		urPenForUserTab--;

	for (i = 0; i < icaltbdMac &&
					(urPenForUserTab >= (pcaltbd[i].ur)		/* if fUseHangingTabAsDefault we skip it */
						|| (fUseHangingTabAsDefault && pcaltbd[i].fHangingTab));
	     i++)
			 {
			 if (fUseHangingTabAsDefault && pcaltbd[i].fHangingTab)
				iHangingTab = i;
			 }

	if (i == icaltbdMac)
		{

		/* We deleted strange calculation of tab stop which was there due to compatibility with
		Word97. Compatibility we are solving when calling this procedure */
		durIncTab = plstabscontext->durIncrementalTab;
		if (durIncTab == 0)
			durIncTab = 1;
		durDelta = durIncTab;
		if (urPen < 0)
			durDelta = 0;
		urDefaultTab = ((urPen + durDelta) / durIncTab) * durIncTab;  

		if (fUseHangingTabAsDefault && iHangingTab != -1 &&
			pcaltbd[iHangingTab].ur > urPen &&
			pcaltbd[iHangingTab].ur <= urDefaultTab)
			{
			/* in this case hanging tab is the nearesr default tab */
			i = iHangingTab;
			}
		else
			{
			
			icaltbdMac++;
			if (icaltbdMac >= plstabscontext->ccaltbdMax)
				{
				lserr = IncreaseTabsArray(plstabscontext, 0);
				if (lserr != lserrNone)
					return lserr;
				pcaltbd = plstabscontext->pcaltbd;
				}
			
			plstabscontext->icaltbdMac = icaltbdMac; 
			pcaltbd[i].lskt = lsktLeft;
			pcaltbd[i].wchTabLeader = 0;  /* REVIEW (igorzv) do we need wchSpace as tab leader in this case */
			pcaltbd[i].fDefault = fTrue;
			pcaltbd[i].fHangingTab = fFalse;
			
			pcaltbd[i].ur = urDefaultTab;  
			}
		}
	else
		{
		if (urPen < plstabscontext->urColumnMax && 
			pcaltbd[i].ur >= plstabscontext->urColumnMax)
		/* tab we found is user defined behind right margin */
		/* it is important to check also that we are not already behind right margin,
		   opposite can happens because of exceeded right margin */
			{
			*pfBreakThroughTab = fTrue;
			}
		}

	*picaltbd = i;
	return lserrNone;

}

/* I N C R E A S E  T A B S  A R R A Y*/
/*----------------------------------------------------------------------------
    %%Function: IncreaseTabsArray
    %%Contact: igorzv

Parameters:
	plsc			-		(IN) ptr to line services context 
	ccaltbdMaxNew	-		(IN) new value for array size if 0 then add limCaltbd

Relocate tabs array and set new values in context
----------------------------------------------------------------------------*/
static LSERR IncreaseTabsArray(PLSTABSCONTEXT plstabscontext, DWORD ccaltbdMaxNew)
{

	DWORD ccaltbdMax;

	if (ccaltbdMaxNew > 0)
		ccaltbdMax = ccaltbdMaxNew;
	else
		ccaltbdMax = plstabscontext->ccaltbdMax + limCaltbd;


	/* create new array for tabs  */
	plstabscontext->pcaltbd = plstabscontext->plscbk->pfnReallocPtr(plstabscontext->pols, 
											plstabscontext->pcaltbd,
											sizeof(LSCALTBD)*ccaltbdMax);


	if (plstabscontext->pcaltbd == NULL )
		return lserrOutOfMemory;

	plstabscontext->ccaltbdMax = ccaltbdMax;

	return lserrNone;

}

/* G E T  M A R G I N  A F T E R  B R E A K  T H R O U G H  T A B*/
/*----------------------------------------------------------------------------
    %%Function: GetMarginAfterBreakThroughTab
    %%Contact: igorzv

Parameters:
	plsc			-		(IN) ptr to line services context 
	plsdnTab		-		(IN) tab which triggered breakthrough tab
	purNewMargin	-		(OUT) new margin because of breakthrough tab
----------------------------------------------------------------------------*/

LSERR GetMarginAfterBreakThroughTab(PLSTABSCONTEXT plstabscontext,
								  PLSDNODE plsdnTab, long* purNewMargin)			

	{
	LSERR lserr;
	long uaNewMargin;

	lserr = plstabscontext->plscbk->pfnGetBreakThroughTab(plstabscontext->pols,
					UaFromUr(LstflowFromDnode(plsdnTab), &(plstabscontext->plsdocinf->lsdevres),
							 plstabscontext->urColumnMax),
					UaFromUr(LstflowFromDnode(plsdnTab), &(plstabscontext->plsdocinf->lsdevres),
							 plstabscontext->pcaltbd[plsdnTab->icaltbd].ur),

					&uaNewMargin);

	if (lserr != lserrNone)
		return lserr;

	*purNewMargin = UrFromUa(LstflowFromDnode(plsdnTab), &(plstabscontext->plsdocinf->lsdevres),
							 uaNewMargin);
	return lserrNone;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\textenum.c ===
#include "lsidefs.h"
#include "plsrun.h"
#include "pilsobj.h"
#include "txtils.h"
#include "txtobj.h"
#include "txtln.h"

//    %%Function:	EnumObjText
//    %%Contact:	victork
//
LSERR WINAPI EnumObjText(PDOBJ pdobj, PLSRUN plsrun, PCLSCHP plschp, LSCP cpFirst, LSDCP dcp, 
					LSTFLOW lstflow, BOOL fReverseOrder, BOOL fGeometryProvided, 
					const POINT* pptStart, PCHEIGHTS pheightsPres, long dupRun)
				  
{
	TXTOBJ* ptxtobj;
	PLNOBJ 	plnobj;
	PILSOBJ pilsobj;
	long* 	pdup;
	BOOL 	fCharWidthsProvided;

  	ptxtobj = (TXTOBJ*)pdobj;
	plnobj = ptxtobj->plnobj;
	pilsobj = plnobj->pilsobj;

	Unreferenced(plschp);

	if (ptxtobj->txtkind == txtkindTab)
		{
		return (*pilsobj->plscbk->pfnEnumTab)(pilsobj->pols, plsrun, cpFirst,
									&plnobj->pwch[ptxtobj->iwchFirst],
									ptxtobj->u.tab.wchTabLeader, lstflow, 
									fReverseOrder, fGeometryProvided,
									pptStart, pheightsPres, dupRun);
		}

	if (ptxtobj->txtf & txtfGlyphBased)
		{
		fCharWidthsProvided = fFalse;
		pdup = NULL;
		}
	else
		{
		fCharWidthsProvided = fTrue;
		pdup = &plnobj->pdup[ptxtobj->iwchFirst];
		}
		
	return (*pilsobj->plscbk->pfnEnumText)(pilsobj->pols, plsrun, cpFirst, dcp, 
									&plnobj->pwch[ptxtobj->iwchFirst],
									ptxtobj->iwchLim - ptxtobj->iwchFirst, lstflow, 
									fReverseOrder, fGeometryProvided,
									pptStart, pheightsPres, dupRun,
									fCharWidthsProvided, pdup);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\ruby.c ===
#include	"lsmem.h"
#include	"limits.h"
#include	"ruby.h"
#include	"objhelp.h"
#include	"lscbk.h"
#include	"lsdevres.h"
#include	"pdobj.h"
#include	"objdim.h"
#include	"plssubl.h"
#include	"plsdnode.h"
#include	"pilsobj.h"
#include	"lscrsubl.h"
#include	"lssubset.h"
#include	"lsdnset.h"
#include	"zqfromza.h"
#include	"lsdocinf.h"
#include	"fmti.h"
#include	"posichnk.h"
#include	"locchnk.h"
#include	"lsdnfin.h"
#include	"brko.h"
#include	"lspap.h"
#include	"plspap.h"
#include	"lsqsubl.h"
#include	"dispi.h"
#include	"lsdssubl.h"
#include	"lsems.h"
#include	"dispmisc.h"
#include	"lstfset.h"
#include	"lsqout.h"
#include	"lsqin.h"
#include	"sobjhelp.h"
#include	"brkkind.h"


#define RUBY_MAIN_ESC_CNT	1
#define RUBY_RUBY_ESC_CNT	1


struct ilsobj
{
    POLS				pols;
	LSCBK				lscbk;
	PLSC				plsc;
	LSDEVRES			lsdevres;
	RUBYSYNTAX			rubysyntax;
	LSESC				lsescMain;
	LSESC				lsescRuby;
	RUBYCBK				rcbk;			/* Callbacks  to client application */

};

typedef struct SUBLINEDNODES
{
	PLSDNODE			plsdnStart;
	PLSDNODE			plsdnEnd;

} SUBLINEDNODES, *PSUBLINEDNODES;

struct dobj
{	
	SOBJHELP			sobjhelp;			/* common area for simple objects */	
	PILSOBJ				pilsobj;			/* ILS object */
	PLSDNODE			plsdn;				/* DNODE for this object */
	LSCP				cpStart;			/* Starting LS cp for object */
	LSTFLOW				lstflow;			/* text flow for the Ruby object */
	PLSRUN				plsrunFirstRubyChar;/* plsrun for first Ruby line char */
	PLSRUN				plsrunLastRubyChar;	/* plsrun for last Ruby line char */
	LSCP				cpStartRuby;		/* first cp of the ruby line */
	LSCP				cpStartMain;		/* first cp of the main line */
	PLSSUBL				plssublMain;		/* Handle to first subline */
	OBJDIM				objdimMain;			/* Objdim of first subline */
	PLSSUBL				plssublRuby;		/* Handle to second line */
	OBJDIM				objdimRuby;			/* Objdim of second line */
	long				dvpMainOffset;		/* Offset of main line's baseline */
											/* from baseline ofRuby object. */
	long				dvpRubyOffset;		/* Offset of Ruby line's baseline */
											/* from baseline of Ruby object. */
	long				dvrRubyOffset;		/* Offset of Ruby line's baseline */
											/* from baseline of Ruby object in reference units. */
	enum rubycharjust	rubycharjust;		/* Type of centering */
	long				durSplWidthMod;		/* special Ruby width mod if special behavior
											 * when Ruby is on the end of the line */
	BOOL				fFirstOnLine:1;		/* TRUE = object is first on line */
	BOOL				fSpecialLineStartEnd:1;/* Special Begin of Line or End of */
											/* Line behavior. */
	BOOL				fModAfterCalled:1;	/* Whether mod width after has been called */
	long				durDiff;			/* Amount of overhang of ruby line if */
											/* ruby line is longer, otherwise amount */
											/* of underhang if main text is longer. */
	long				durModBefore;		/* Mod width distance before */
	long				dupOffsetMain;		/* Offset from start of object of main line. */
	long				dupOffsetRuby;		/* Offset from start of object of ruby line. */
	SUBLINEDNODES		sublnlsdnMain;		/* Start end dnodes of main line */
	SUBLINEDNODES		sublnlsdnRuby;		/* Start end dnodes of ruby line */
};



/* F R E E D O B J */
/*----------------------------------------------------------------------------
	%%Function: RubyFreeDobj
	%%Contact: antons

		Free all resources associated with this Ruby dobj.
	
----------------------------------------------------------------------------*/
static LSERR RubyFreeDobj (PDOBJ pdobj)
{
	LSERR lserr1 = lserrNone;
	LSERR lserr2 = lserrNone;

	PILSOBJ pilsobj = pdobj->pilsobj;

	if (pdobj->plssublMain != NULL)
		{
		lserr1 = LsDestroySubline(pdobj->plssublMain);
		}

	if (pdobj->plssublRuby != NULL)
		{
		lserr2 = LsDestroySubline(pdobj->plssublRuby);
		}

    pilsobj->lscbk.pfnDisposePtr(pilsobj->pols, pdobj);

	if (lserr1 != lserrNone) 
		{
		return lserr1;
		}
	else
		{
		return lserr2;
		}

}


/* R U B Y  F M T  F A I L E D */
/*----------------------------------------------------------------------------
	%%Function: RubyFmtFailed
	%%Contact: antons

		Could not create Ruby DOBJ due to error. 
		IN:	pdobj of partially created Ruby; NULL if pdobj was not yet allocated;
		IN:	lserr from the last error
		
----------------------------------------------------------------------------*/
static LSERR RubyFmtFailed (PDOBJ pdobj, LSERR lserr)
{
	if (pdobj != NULL) RubyFreeDobj (pdobj); /* Works with parially-filled DOBJ */

	return lserr;
}


/* G E T R U N S F O R S U B L I N E */
/*----------------------------------------------------------------------------
	%%Function: GetRunsForSubline
	%%Contact: ricksa

		This gets all the runs for a particular subline.
----------------------------------------------------------------------------*/
static LSERR GetRunsForSubline(
	PILSOBJ pilsobj,			/* (IN): object ILS */
	PLSSUBL plssubl,			/* (IN): subline to get the runs from */
	DWORD *pcdwRuns,			/* (OUT): count of runs for subline */
	PLSRUN **ppplsrun)			/* (OUT): array of plsruns for subline */
{
	DWORD cdwRuns;

	LSERR lserr = LssbGetNumberDnodesInSubline(plssubl, &cdwRuns);

	*ppplsrun = NULL; /* No runs or in case of error */

	if (lserr != lserrNone) return lserr;

	if (cdwRuns != 0)
		{
		
	    *ppplsrun = (PLSRUN *) pilsobj->lscbk.pfnNewPtr(pilsobj->pols,
			sizeof(PLSRUN) * cdwRuns);

		if (*ppplsrun == NULL) return lserrOutOfMemory;

		lserr = LssbGetPlsrunsFromSubline(plssubl, cdwRuns, *ppplsrun);

		if (lserr != lserrNone)
			{
			pilsobj->lscbk.pfnDisposePtr(pilsobj->pols, *ppplsrun);
			
			*ppplsrun = NULL;
			return lserr;
			}
		}

	*pcdwRuns = cdwRuns;

	return lserrNone;
}

/* D I S T R I B U T E T O L I N E */
/*----------------------------------------------------------------------------
	%%Function: DistributeToLine
	%%Contact: ricksa

		Distribute space to line & get new size of line.
----------------------------------------------------------------------------*/
static LSERR DistributeToLine(
	PLSC plsc,					/* (IN): LS context */
	SUBLINEDNODES *psublnlsdn,	/* (IN): start/end dnode for subline */
	long durToDistribute,		/* (IN): amount to distribute*/
	PLSSUBL plssubl,			/* (IN): subline for distribution */
	POBJDIM pobjdim)			/* (OUT): new size of line dimesions */
{
	LSERR lserr = LsdnDistribute(plsc, psublnlsdn->plsdnStart, 
		psublnlsdn->plsdnEnd, durToDistribute);
	LSTFLOW lstflowUnused;

	if (lserrNone == lserr)
		{
		/* recalculate objdim for line */
		lserr = LssbGetObjDimSubline(plssubl, &lstflowUnused, pobjdim);
		}

	return lserr;
}


/* D O R U B Y S P A C E D I S T R I B U T I O N */
/*----------------------------------------------------------------------------
	%%Function: DoRubySpaceDistribution
	%%Contact: ricksa

		Do the ruby space distribution to handle overhangs.
----------------------------------------------------------------------------*/
static LSERR DoRubySpaceDistribution(
	PDOBJ pdobj)
{
	long durDiff = 0; 
	long dur = pdobj->objdimMain.dur - pdobj->objdimRuby.dur;
	long durAbs = dur;
	PLSSUBL plssubl;
	LSDCP dcp;
	PILSOBJ pilsobj = pdobj->pilsobj;
	LSERR lserr = lserrNone;
	SUBLINEDNODES *psublnlsdn;
	POBJDIM pobjdim;
	BOOL fSpecialJust;
	long durToDistribute;

	if ((0 == pdobj->objdimMain.dur)
		|| (0 == pdobj->objdimRuby.dur)
		|| (0 == dur))
		{
		/* Can't distribute space on a shorter line so we are done. */
		return lserrNone;
		}

	if (dur > 0)
		{
		/* Main line is longer - distibute in Ruby pronunciation line */

		/*
		 *	According to the JIS spec, special alignment only occurs when the 
		 *	Ruby text is longer than the main text. Therefore, if the main
		 *	line is longer we turn of the special aligment flag here.
		 */
		pdobj->fSpecialLineStartEnd = FALSE;
		plssubl = pdobj->plssublRuby;
		psublnlsdn = &pdobj->sublnlsdnRuby;
		pobjdim = &pdobj->objdimRuby;
		}
	else
		{
		/* Ruby pronunciation line is longer - distibute in main line */
		plssubl = pdobj->plssublMain;
		psublnlsdn = &pdobj->sublnlsdnMain;
		pobjdim = &pdobj->objdimMain;
		durAbs = -dur;
		}

	fSpecialJust = FALSE;
//	fSpecialJust = 
//		pdobj->fSpecialLineStartEnd && pdobj->fFirstOnLine;

	if (!fSpecialJust)
		{
		switch (pdobj->rubycharjust)
			{
			case rcj121:
				lserr = LssbGetVisibleDcpInSubline(plssubl, &dcp);

				Assert (dcp > 0);

				if (lserr != lserrNone)
					{
					break;
					}

				dcp *= 2;

				if (durAbs >= (long) dcp)
					{
					durDiff = durAbs / dcp;

					/* Note: distribution amount is amount excluding 
					 * beginning and end.
					 */
					lserr = DistributeToLine(pilsobj->plsc, psublnlsdn,
						durAbs - 2 * durDiff, plssubl, pobjdim);

					if (dur < 0)
						{
						durDiff = - durDiff;
						}

					break;
					}

				/*
				 * Intention fall through in the case where the overhang will
				 * be less than one pixel.
				 */

			case rcj010:
				AssertSz(0 == durDiff, 
					"DoRubySpaceDistribution rcj010 unexpected value for durDiff");

				lserr = LssbGetVisibleDcpInSubline(plssubl, &dcp);

				Assert (dcp > 0);

				if (lserr != lserrNone)
					{
					break;
					}
				
				if (dcp != 1)
					{
					lserr = DistributeToLine(pilsobj->plsc, psublnlsdn,
						durAbs, plssubl, pobjdim);
					break;
					}

				/*
				 * Intentional fall through to center case.
				 * Only one character in line so we just center it.
				 */
	
			case rcjCenter:
				durDiff = dur / 2;
				break;

			case rcjLeft:
				durDiff = 0;
				break;

			case rcjRight:
				durDiff = dur;
				break;

			default:
				AssertSz(FALSE, 
					"DoRubySpaceDistribution - invalid adjustment value");
			}
		}
	else
		{
		/* First on line & special justification used. */
		LSERR lserr = LssbGetVisibleDcpInSubline(plssubl, &dcp);

		Assert (dcp > 0);

		if (lserrNone == lserr)
		{
			if (durAbs >= (long) dcp)
				{
				durDiff = durAbs / dcp;
				}

				durToDistribute = durAbs - durDiff;

				if (dur < 0)
					{
					durDiff = -durDiff;
					}

			lserr = DistributeToLine(pilsobj->plsc, psublnlsdn, 
				durToDistribute, plssubl, pobjdim);
			}
		}

	pdobj->durDiff = durDiff;
	return lserr;
}

/* G E T M A I N P O I N T */
/*----------------------------------------------------------------------------
	%%Function: GetMainPoint
	%%Contact: ricksa

		This gets the point for the baseline of the main line of text in
		the Ruby object.
		
----------------------------------------------------------------------------*/
static LSERR GetMainPoint(
	PDOBJ pdobj,				/*(IN): dobj for Ruby */
	const POINT *pptBase,		/*(IN): point for baseline. */
	LSTFLOW lstflow,			/*(IN): lstflow at baseline of object */
	POINT *pptLine)				/*(OUT): point for baseline of main text */
{	
	POINTUV pointuv;
	pointuv.u = pdobj->dupOffsetMain;
	pointuv.v = pdobj->dvpMainOffset;
	return LsPointXYFromPointUV(pptBase, lstflow, &pointuv, pptLine);
}

/* G E T M A I N P O I N T */
/*----------------------------------------------------------------------------
	%%Function: GetMainPoint
	%%Contact: ricksa

		This gets the point for the baseline of the main line of text in
		the Ruby object.
		
----------------------------------------------------------------------------*/
static LSERR GetRubyPoint(
	PDOBJ pdobj,				/*(IN): dobj for Ruby */
	const POINT *pptBase,		/*(IN): point for baseline. */
	LSTFLOW lstflow,			/*(IN): lstflow at baseline of object */
	POINT *pptLine)				/*(OUT): point for baseline of ruby text */
{	
	POINTUV pointuv;
	pointuv.u = pdobj->dupOffsetRuby;
	pointuv.v = pdobj->dvpRubyOffset;
	return LsPointXYFromPointUV(pptBase, lstflow, &pointuv, pptLine);
}

/* M O D W I D T H H A N D L E R */
/*----------------------------------------------------------------------------
	%%Function: ModWidthHandler
	%%Contact: ricksa

		This gets the adjustment for the Ruby object and the text character
		and then adjusts the Ruby object's size based on the response from
		the client.
----------------------------------------------------------------------------*/
static LSERR ModWidthHandler(
	PDOBJ pdobj,				/* (IN): dobj for Ruby */
	enum rubycharloc rubyloc,	/* (IN): whether char is before or after */
	PLSRUN plsrun,				/* (IN): run for character */
	WCHAR wch,					/* (IN): character before or after Ruby object */
	MWCLS mwcls,				/* (IN): mod width class for for character */
	PCHEIGHTS pcheightsRef,		/* (IN): height of character */
	PLSRUN plsrunRubyObject,	/* (IN): plsrun for the ruby object */
	PLSRUN plsrunRubyText,		/* (IN): plsrun for ruby text */
	long durOverhang,			/* (IN): maximum amount of overhang */
	long *pdurAdjText,			/* (OUT): amount to change text object size */
	long *pdurRubyMod)			/* (OUT): amount to change ruby object */
{
	LSERR lserr;
	PILSOBJ pilsobj = pdobj->pilsobj;
	LSEMS lsems;
	long durModRuby = 0;
	long durMaxOverhang = 0;

	/*
	 * Ruby can overhang only if it is longer and if preceeding/succeeding
	 * character is of lesser or equal height than the bottom of the Ruby
	 * pronunciation line.
	 */
	if ((durOverhang < 0) 
		&& (pcheightsRef->dvAscent <= 
			(pdobj->dvrRubyOffset - pdobj->objdimRuby.heightsRef.dvDescent)))
		{
		/* Ruby line overhangs - get max to overhang */
		lserr = pilsobj->lscbk.pfnGetEms(pilsobj->pols, plsrunRubyText, 
			pdobj->lstflow, &lsems);

		if (lserr != lserrNone)
			{
			return lserr;
			}

		durMaxOverhang = lsems.em;
		durOverhang = -durOverhang;

		if (durMaxOverhang > durOverhang)
			{
			/* limit maximum overhang to max overhang for ruby line */
			durMaxOverhang = durOverhang;
			}
		}

	lserr = pilsobj->rcbk.pfnFetchRubyWidthAdjust(pilsobj->pols, 
		pdobj->cpStart, plsrun, wch, mwcls, plsrunRubyObject, 
			rubyloc, durMaxOverhang, pdurAdjText, &durModRuby);

	if (lserrNone == lserr)
		{
		if (durModRuby != 0)
			{
			/* size of ruby object needs to change */
			pdobj->sobjhelp.objdimAll.dur += durModRuby;
			lserr = LsdnResetObjDim(pilsobj->plsc, pdobj->plsdn, 
				&pdobj->sobjhelp.objdimAll);
			}

		*pdurRubyMod = durModRuby;
		}

	return lserr;
}

/* M A S S A G E F O R R I G H T A D J U S T */
/*----------------------------------------------------------------------------
	%%Function: MassageForRightAdjust
	%%Contact: ricksa


		Massage object so that right aligned lines will end on exactly
		the same pixel.
	
----------------------------------------------------------------------------*/
static LSERR MassageForRightAdjust(
	PDOBJ pdobj)				/* dobj for Ruby */
{
	LSERR lserr;
	long dupRuby;
	long dupMain;
	long dupDiff;
	LSTFLOW lstflowIgnored;

	/* Get the length of the two lines */
	lserr = LssbGetDupSubline(pdobj->plssublMain, &lstflowIgnored, &dupMain);
	if (lserr != lserrNone) return lserr;

	lserr = LssbGetDupSubline(pdobj->plssublRuby, &lstflowIgnored, &dupRuby);
	if (lserr != lserrNone)	return lserr;

	/* Get difference between two lines */
	dupDiff = dupMain - dupRuby;

	if (dupDiff >= 0)
		{
		/* Main line longest */
		pdobj->dupOffsetRuby = pdobj->dupOffsetMain + dupDiff;
		}
	else
		{
		/* Ruby line longest - reverse sign of dupDiff to add */
		pdobj->dupOffsetMain = pdobj->dupOffsetRuby - dupDiff;
		}

	return lserrNone;
}

/* R U B I C R E A T E I L S O B J */
/*----------------------------------------------------------------------------
	%%Function: RubyCreateILSObj
	%%Contact: ricksa

		CreateILSObj

		Create the ILS object for all Ruby objects.
	
----------------------------------------------------------------------------*/
LSERR WINAPI RubyCreateILSObj(
	POLS pols,				/* (IN): client application context */
	PLSC plsc,				/* (IN): LS context */
	PCLSCBK pclscbk,		/* (IN): callbacks to client application */
	DWORD idObj,			/* (IN): id of the object */
	PILSOBJ *ppilsobj)		/* (OUT): object ilsobj */
{
    PILSOBJ pilsobj;
	LSERR lserr;
	RUBYINIT rubyinit;
	rubyinit.dwVersion = RUBY_VERSION;

	/* Get initialization data */
	lserr = pclscbk->pfnGetObjectHandlerInfo(pols, idObj, &rubyinit);

	if (lserr != lserrNone)
		{
		return lserr;
		}

    pilsobj = pclscbk->pfnNewPtr(pols, sizeof(*pilsobj));

	if (NULL == pilsobj)
	{
		return lserrOutOfMemory;
	}

    pilsobj->pols = pols;
    pilsobj->lscbk = *pclscbk;
	pilsobj->plsc = plsc;
	pilsobj->lsescMain.wchFirst = rubyinit.wchEscMain;
	pilsobj->lsescMain.wchLast = rubyinit.wchEscMain;
	pilsobj->lsescRuby.wchFirst = rubyinit.wchEscRuby;
	pilsobj->lsescRuby.wchLast = rubyinit.wchEscRuby;
	pilsobj->rcbk = rubyinit.rcbk;
	pilsobj->rubysyntax = rubyinit.rubysyntax;

	*ppilsobj = pilsobj;
	return lserrNone;
}

/* R U B I D E S T R O Y I L S O B J */
/*----------------------------------------------------------------------------
	%%Function: RubyDestroyILSObj
	%%Contact: ricksa

		DestroyILSObj

		Free all resources assocaiated with Ruby ILS object.
	
----------------------------------------------------------------------------*/
LSERR WINAPI RubyDestroyILSObj(
	PILSOBJ pilsobj)			/* (IN): object ilsobj */
{
	pilsobj->lscbk.pfnDisposePtr(pilsobj->pols, pilsobj);
	return lserrNone;
}

/* R U B I S E T D O C */
/*----------------------------------------------------------------------------
	%%Function: RubySetDoc
	%%Contact: ricksa

		SetDoc

		Keep track of device resolution.
	
----------------------------------------------------------------------------*/
LSERR WINAPI RubySetDoc(
	PILSOBJ pilsobj,			/* (IN): object ilsobj */
	PCLSDOCINF pclsdocinf)		/* (IN): initialization data of the document level */
{
	pilsobj->lsdevres = pclsdocinf->lsdevres;
	return lserrNone;
}


/* R U B I C R E A T E L N O B J */
/*----------------------------------------------------------------------------
	%%Function: RubyCreateLNObj
	%%Contact: ricksa

		CreateLNObj

		Create the Line Object for the Ruby. Since we only really need
		the global ILS object, just pass that object back as the line object.
	
----------------------------------------------------------------------------*/
LSERR WINAPI RubyCreateLNObj(
	PCILSOBJ pcilsobj,			/* (IN): object ilsobj */
	PLNOBJ *pplnobj)			/* (OUT): object lnobj */
{
	*pplnobj = (PLNOBJ) pcilsobj;
	return lserrNone;
}

/* R U B I D E S T R O Y L N O B J */
/*----------------------------------------------------------------------------
	%%Function: RubyDestroyLNObj
	%%Contact: ricksa

		DestroyLNObj

		Frees resources associated with the Ruby line object. No-op because
		we don't really allocate one.
	
----------------------------------------------------------------------------*/
LSERR WINAPI RubyDestroyLNObj(
	PLNOBJ plnobj)				/* (OUT): object lnobj */

{
	Unreferenced(plnobj);
	return lserrNone;
}

/* R U B I F M T */
/*----------------------------------------------------------------------------
	%%Function: RubyFmt
	%%Contact: ricksa

		Fmt

		Format the Ruby object. This formats the main line and the 
		pronunciation line. It then queries the client for spacing
		information and then completes the formatting.
	
----------------------------------------------------------------------------*/
LSERR WINAPI RubyFmt(
    PLNOBJ plnobj,				/* (IN): object lnobj */
    PCFMTIN pcfmtin,			/* (IN): formatting input */
    FMTRES *pfmtres)			/* (OUT): formatting result */
{
	PDOBJ pdobj;
	LSERR lserr;
	PILSOBJ pilsobj = (PILSOBJ) plnobj;
	POLS pols = pilsobj->pols;
	LSCP cpStartMain;
	LSCP cpStartRuby = pcfmtin->lsfgi.cpFirst + 1;
	LSCP cpOut;
	LSTFLOW lstflow = pcfmtin->lsfgi.lstflow;
	DWORD cdwRunsMain;
	DWORD cdwRunsRuby;
	PLSRUN *pplsrunMain = NULL;
	PLSRUN *pplsrunRuby = NULL;
	FMTRES fmtres;
	OBJDIM objdimAll;
	FMTRES fmtr = fmtrCompletedRun;
	BOOL fSpecialLineStartEnd;

    /*
     * Allocate the DOBJ
     */
    pdobj = pilsobj->lscbk.pfnNewPtr(pols, sizeof(*pdobj));

    if (pdobj == NULL) return RubyFmtFailed (NULL, lserrOutOfMemory);

	ZeroMemory(pdobj, sizeof(*pdobj));
	pdobj->pilsobj = pilsobj;
	pdobj->plsdn = pcfmtin->plsdnTop;
	pdobj->cpStart = pcfmtin->lsfgi.cpFirst;
	pdobj->fFirstOnLine = pcfmtin->lsfgi.fFirstOnLine;
	pdobj->lstflow = lstflow;

	if (RubyPronunciationLineFirst == pilsobj->rubysyntax)
		{
		/*
		 * Build pronunciation line of text
		 */
		 
		lserr = FormatLine(pilsobj->plsc, cpStartRuby, LONG_MAX, lstflow,
			&pdobj->plssublRuby, RUBY_RUBY_ESC_CNT, &pilsobj->lsescRuby,  
				&pdobj->objdimRuby, &cpOut, &pdobj->sublnlsdnRuby.plsdnStart,
					&pdobj->sublnlsdnRuby.plsdnEnd, &fmtres);

		/* +1 moves passed the ruby line escape character */
		cpStartMain = cpOut + 1;

		pdobj->cpStartRuby = cpStartRuby;
		pdobj->cpStartMain = cpStartMain;

		/*
		 * Build main line of text
 		 */
		if (lserrNone == lserr)
			{
			lserr = FormatLine(pilsobj->plsc, cpStartMain, LONG_MAX, lstflow,
				&pdobj->plssublMain, RUBY_MAIN_ESC_CNT, &pilsobj->lsescMain,  
					&pdobj->objdimMain, &cpOut, &pdobj->sublnlsdnMain.plsdnStart, 
						&pdobj->sublnlsdnMain.plsdnEnd, &fmtres);
			}
		}
	else
		{
		/*
		 * Build main line of text
 		 */

		cpStartMain = cpStartRuby;

		lserr = FormatLine(pilsobj->plsc, cpStartMain, LONG_MAX, lstflow,
			&pdobj->plssublMain, RUBY_MAIN_ESC_CNT, &pilsobj->lsescMain,  
				&pdobj->objdimMain, &cpOut, &pdobj->sublnlsdnMain.plsdnStart, 
					&pdobj->sublnlsdnMain.plsdnEnd, &fmtres);

		/* +1 moves passed the main line escape character */
		cpStartRuby = cpOut + 1;

		pdobj->cpStartRuby = cpStartRuby;
		pdobj->cpStartMain = cpStartMain;

		/*
		 * Build pronunciation line of text
		 */
		if (lserrNone == lserr)
			{
			lserr = FormatLine(pilsobj->plsc, cpStartRuby, LONG_MAX, lstflow,
				&pdobj->plssublRuby, RUBY_RUBY_ESC_CNT, &pilsobj->lsescRuby,  
					&pdobj->objdimRuby, &cpOut, &pdobj->sublnlsdnRuby.plsdnStart, 
						&pdobj->sublnlsdnRuby.plsdnEnd, &fmtres);

			}
		}

	if (lserr != lserrNone)	return RubyFmtFailed (pdobj, lserr);

	lserr = GetRunsForSubline(pilsobj, pdobj->plssublMain, &cdwRunsMain, &pplsrunMain);

	if (lserr != lserrNone) return RubyFmtFailed (pdobj, lserr);

	lserr = GetRunsForSubline(pilsobj, pdobj->plssublRuby, &cdwRunsRuby, &pplsrunRuby);

	if (lserr != lserrNone) return RubyFmtFailed (pdobj, lserr);

	/* Save the first and last plsrun for use in GetModWidth */
	if (cdwRunsRuby != 0)
		{
		pdobj->plsrunFirstRubyChar = pplsrunRuby[0];
		pdobj->plsrunLastRubyChar = pplsrunRuby[cdwRunsRuby - 1];
		}

	/* 
	 *	Calculate the object dimensions.
	 */
	lserr = pilsobj->rcbk.pfnFetchRubyPosition(pols, pdobj->cpStart, pdobj->lstflow,
		cdwRunsMain, pplsrunMain, &pdobj->objdimMain.heightsRef, 
			&pdobj->objdimMain.heightsPres, cdwRunsRuby, pplsrunRuby, 
				&pdobj->objdimRuby.heightsRef, &pdobj->objdimRuby.heightsPres,
					&objdimAll.heightsRef, &objdimAll.heightsPres, 
						&pdobj->dvpMainOffset, &pdobj->dvrRubyOffset, 
							&pdobj->dvpRubyOffset, &pdobj->rubycharjust, 
								&fSpecialLineStartEnd);

	/* Free buffers allocated for plsruns for this call */
	
	if (pplsrunMain != NULL) pilsobj->lscbk.pfnDisposePtr(pilsobj->pols, pplsrunMain);

	if (pplsrunRuby != NULL) pilsobj->lscbk.pfnDisposePtr(pilsobj->pols, pplsrunRuby);

	if (lserr != lserrNone) return RubyFmtFailed (pdobj, lserr);

	/*
	 * Special line start/end adjustment matters only when a justification of
	 * centered, 0:1:0 or 1:2:1 is selected.
	 */

	if (fSpecialLineStartEnd 
		&& (pdobj->rubycharjust != rcjLeft)
		&& (pdobj->rubycharjust != rcjRight))
		{
		pdobj->fSpecialLineStartEnd = TRUE;
		}

	/* Distribute space for Ruby */
	lserr = DoRubySpaceDistribution(pdobj);

	if (lserr != lserrNone) return RubyFmtFailed (pdobj, lserr);

	/* ur is ur of longest subline. */

	objdimAll.dur = pdobj->objdimMain.dur;

	if (pdobj->objdimMain.dur < pdobj->objdimRuby.dur)
		{
		objdimAll.dur = pdobj->objdimRuby.dur;
		}

	pdobj->sobjhelp.objdimAll = objdimAll;

	/* Need to add 1 to take into account escape character at end. */

	pdobj->sobjhelp.dcp = cpOut - pdobj->cpStart + 1;

	lserr = LsdnFinishRegular(pilsobj->plsc, pdobj->sobjhelp.dcp, 
		pcfmtin->lsfrun.plsrun, pcfmtin->lsfrun.plschp, pdobj, 
			&pdobj->sobjhelp.objdimAll);
		
	if (lserr != lserrNone) return RubyFmtFailed (pdobj, lserr);

	if (pcfmtin->lsfgi.urPen + objdimAll.dur > pcfmtin->lsfgi.urColumnMax)
		{
		fmtr = fmtrExceededMargin;
		}

	*pfmtres = fmtr;

	AssertSz(((pdobj->fFirstOnLine && pcfmtin->lsfgi.fFirstOnLine) 
		|| (!pdobj->fFirstOnLine && !pcfmtin->lsfgi.fFirstOnLine)), 
		"RubyFmt - bad first on line flag");

	return lserrNone;
}

/* R U B Y G E T M O D W I D T H P R E C E D I N G C H A R */
/*----------------------------------------------------------------------------
	%%Function: RubyGetModWidthPrecedingChar
	%%Contact: ricksa

		.
	
----------------------------------------------------------------------------*/
LSERR WINAPI RubyGetModWidthPrecedingChar(
	PDOBJ pdobj,				/* (IN): dobj */
	PLSRUN plsrun,				/* (IN): plsrun of the object */
	PLSRUN plsrunText,			/* (IN): plsrun of the preceding char */
	PCHEIGHTS pcheightsRef,		/* (IN): height info about character */
	WCHAR wchar,				/* (IN): preceding character */
	MWCLS mwcls,				/* (IN): ModWidth class of preceding character */
	long *pdurChange)			/* (OUT): amount by which width of the preceding char is to be changed */
{
	AssertSz(!pdobj->fFirstOnLine, "RubyGetModWidthPrecedingChar got called for first char");

	return ModWidthHandler(pdobj, rubyBefore, plsrunText, wchar, mwcls, 
		pcheightsRef, plsrun, pdobj->plsrunFirstRubyChar, pdobj->durDiff, 
			pdurChange, &pdobj->durModBefore);
}

/* R U B Y G E T M O D W I D T H F O L L O W I N G C H A R */
/*----------------------------------------------------------------------------
	%%Function: RubyGetModWidthFollowingChar
	%%Contact: ricksa

		.
	
----------------------------------------------------------------------------*/
LSERR WINAPI RubyGetModWidthFollowingChar(
	PDOBJ pdobj,				/* (IN): dobj */
	PLSRUN plsrun,				/* (IN): plsrun of the object */
	PLSRUN plsrunText,			/* (IN): plsrun of the following char */
	PCHEIGHTS pcheightsRef,		/* (IN): height info about character */
	WCHAR wchar,				/* (IN): following character */
	MWCLS mwcls,				/* (IN): ModWidth class of the following character */
	long *pdurChange)			/* (OUT): amount by which width of the following char is to be changed */
{
	long durDiff = pdobj->durDiff;
	pdobj->fModAfterCalled = TRUE;

	switch (pdobj->rubycharjust)
		{
		case rcjRight:
			/* Right justified so no overhang on right */
			durDiff = 0;
			break;

		case rcjLeft:
			/* For left, max overhang is difference between widths of lines */
			durDiff = pdobj->objdimMain.dur - pdobj->objdimRuby.dur;
			break;

		default:
			break;				
		}

	return ModWidthHandler(pdobj, rubyAfter, plsrunText, wchar, mwcls, 
		pcheightsRef, plsrun, pdobj->plsrunLastRubyChar, durDiff, pdurChange,
			&pdobj->sobjhelp.durModAfter);
}


/* R U B Y S E T B R E A K */
/*----------------------------------------------------------------------------
	%%Function: RubySetBreak
	%%Contact: ricksa

		SetBreak

		.
----------------------------------------------------------------------------*/
LSERR WINAPI RubySetBreak(
	PDOBJ pdobj,				/* (IN): dobj which is broken */
	BRKKIND brkkind,			/* (IN): prev | next | force | after */
	DWORD cBreakRecord,			/* (IN): size of array */
	BREAKREC *rgBreakRecord,	/* (IN): array of break records */
	DWORD *pcActualBreakRecord)	/* (IN): actual number of used elements in array */
{
	LSERR lserr = lserrNone;
	LSCP cpOut;

	LSDCP dcpVisible;

	/* REVIEW (antons): Check this strange logic after new breaking will work */

	Unreferenced (rgBreakRecord);
	Unreferenced (cBreakRecord);
	Unreferenced (brkkind);
	Unreferenced (pdobj);

	Unreferenced (cpOut);
	Unreferenced (dcpVisible);


	*pcActualBreakRecord = 0;

#ifdef UNDEFINED

	if (pdobj->fSpecialLineStartEnd && !pdobj->fFirstOnLine && 
		brkkind != brkkindImposedAfter)
	{

		/*
		 * Because object is last on line and Ruby overhangs, we need to adjust 
		 * its width for the new overhang.
		 */

		PILSOBJ pilsobj = pdobj->pilsobj;
		FMTRES fmtres;
		long dur;
		long dcpOffset = pdobj->dcpRuby;

		if (RubyMainLineFirst == pdobj->pilsobj->rubysyntax)
			{
			dcpOffset = 0;
			}

		/* clear out original subline */
		LsDestroySubline(pdobj->plssublMain);

		/* Format the main line over again */
		lserr = FormatLine(pilsobj->plsc, pdobj->cpStart + dcpOffset + 1, 
			LONG_MAX, pdobj->lstflow, &pdobj->plssublMain, RUBY_MAIN_ESC_CNT,
				&pilsobj->lsescMain, &pdobj->objdimMain, &cpOut, 
					&pdobj->sublnlsdnMain.plsdnStart, 
						&pdobj->sublnlsdnMain.plsdnEnd, &fmtres);

		if (lserr != lserrNone) return lserr;

		dur = pdobj->objdimRuby.dur - pdobj->objdimMain.dur;

		AssertSz(dur > 0, "RubySetBreak - no overhang width");

		lserr = LssbGetVisibleDcpInSubline(pdobj->plssublMain, &dcpVisible);

		if (lserrNone == lserr)
			{
			pdobj->durDiff = 0;

			if (dur > (long) dcpVisible)
				{
				pdobj->durDiff = -(dur / (long) dcpVisible);
				dur += pdobj->durDiff;
				}

			/* Force to right just so we can guranatee end on same pixel */
			pdobj->rubycharjust = rcjRight;	

			lserr = LsdnDistribute(pilsobj->plsc, 
				pdobj->sublnlsdnMain.plsdnStart,
					pdobj->sublnlsdnMain.plsdnEnd, dur);
			}
		}

#endif

	return lserr;	
}

/* R U B Y G E T S P E C I A L E F F E C T S I N S I D E */
/*----------------------------------------------------------------------------
	%%Function: RubyGetSpecialEffectsInside
	%%Contact: ricksa

		GetSpecialEffectsInside

		.

----------------------------------------------------------------------------*/
LSERR WINAPI RubyGetSpecialEffectsInside(
	PDOBJ pdobj,				/* (IN): dobj */
	UINT *pEffectsFlags)		/* (OUT): Special effects for this object */
{
	LSERR lserr = LsGetSpecialEffectsSubline(pdobj->plssublMain, pEffectsFlags);

	if (lserrNone == lserr)
		{
		UINT uiSpecialEffectsRuby;
	
		lserr = LsGetSpecialEffectsSubline(pdobj->plssublRuby, &uiSpecialEffectsRuby);

		*pEffectsFlags |= uiSpecialEffectsRuby;
		}

	return lserr;
}

/* R U B Y C A L C P R E S E N T A T I O N */
/*----------------------------------------------------------------------------
	%%Function: RubyCalcPresentation
	%%Contact: ricksa

		CalcPresentation
	
		This has two jobs. First, it prepares each line for presentation. Then,
		it calculates the positions of the lines in output device coordinates.
	
----------------------------------------------------------------------------*/
LSERR WINAPI RubyCalcPresentation(
	PDOBJ pdobj,				/* (IN): dobj */
	long dup,					/* (IN): dup of dobj */
	LSKJUST lskjust,			/* (IN): Justification type */
	BOOL fLastVisibleOnLine )	/* (IN): Is this object last visible on line? */
{
	PILSOBJ pilsobj = pdobj->pilsobj;
	LSERR lserr = lserrNone;
	long durOffsetMain;
	long durOffsetRuby;
	long durDiff = pdobj->durDiff;

	Unreferenced (lskjust);
	Unreferenced(dup);
		
	/*
	 *	Prepare lines for presentation
	 */

	if (pdobj->fSpecialLineStartEnd && !pdobj->fFirstOnLine && fLastVisibleOnLine)
		{
		pdobj->rubycharjust = rcjRight;	
		};

	lserr = LsMatchPresSubline(pdobj->plssublMain);

	if (lserr != lserrNone)
		{
		return lserr;
		}

	lserr = LsMatchPresSubline(pdobj->plssublRuby);

	if (lserr != lserrNone)
		{
		return lserr;
		}

	/*
	 *	Calculate positions of lines
	 */

	if (pdobj->fFirstOnLine && pdobj->fSpecialLineStartEnd)
		{
		durDiff = 0;
		}

	durOffsetMain = pdobj->durModBefore;

	/* Calculate amount to adjust in reference */
	if ((durDiff < 0) && (pdobj->rubycharjust != rcjLeft))
		{
		/* Ruby line overhangs main line */
		durOffsetMain -= durDiff;
		}

	pdobj->dupOffsetMain = UpFromUr(pdobj->lstflow, (&pilsobj->lsdevres), 
		durOffsetMain);

	durOffsetRuby = pdobj->durModBefore;

	if (durDiff > 0)
		{
		/* Main line underhangs ruby line */
		durOffsetRuby += durDiff;
		}

	pdobj->dupOffsetRuby = UpFromUr(pdobj->lstflow, (&pilsobj->lsdevres), 
		durOffsetRuby);

	if (rcjRight == pdobj->rubycharjust)
		{
		/*
		 * There can be a pixel rounding error in the above calculations
		 * so that we massage the above calculations so that when the
		 * adjustment is right, both lines are guaranteed to end of the
		 * same pixel.
		 */
		MassageForRightAdjust(pdobj);
		}

	return lserr;
}

/* R U B Y Q U E R Y P O I N T P C P */
/*----------------------------------------------------------------------------
	%%Function: RubyQueryPointPcp
	%%Contact: ricksa

		Map dup to dcp

		There is a certain trickiness about how we determine which subline
		to query. Because the client specifies the offsets, the sublines
		can actually wind up anywhere. We use the simple algorithm that
		if the query does not fall into the Ruby pronunciation line, they
		actually mean the main line of text.
----------------------------------------------------------------------------*/
LSERR WINAPI RubyQueryPointPcp(
	PDOBJ pdobj,				/*(IN): dobj to query */
	PCPOINTUV ppointuvQuery,	/*(IN): query point (uQuery,vQuery) */
	PCLSQIN plsqin,				/*(IN): query input */
	PLSQOUT plsqout)			/*(OUT): query output */
{
	PLSSUBL plssubl;
 	long dupAdj;
	long dvpAdj;
	long dvpRubyOffset = pdobj->dvpRubyOffset;

	/*
	 * Decide which line to to return based on the height of the point input
	 */

	/* Assume main line */
	plssubl = pdobj->plssublMain;
	dupAdj = pdobj->dupOffsetMain;
	dvpAdj = 0;

	if ((ppointuvQuery->v > (dvpRubyOffset - pdobj->objdimRuby.heightsPres.dvDescent))
		&& (ppointuvQuery->v <= (dvpRubyOffset + pdobj->objdimRuby.heightsPres.dvAscent)))
		{
		/* hit second line */
		plssubl = pdobj->plssublRuby;
		dupAdj = pdobj->dupOffsetRuby;
		dvpAdj = pdobj->dvpRubyOffset;
		}

	return CreateQueryResult(plssubl, dupAdj, dvpAdj, plsqin, plsqout);
}
	
/* R U B Y Q U E R Y C P P P O I N T */
/*----------------------------------------------------------------------------
	%%Function: RubyQueryCpPpoint
	%%Contact: ricksa

		Map dcp to dup

		If client wants all text treated as a single object, then the handler
		just returns the object dimensions. Otherwise, we calculate the line to
		query and ask that line for the dimensions of the dcp.
----------------------------------------------------------------------------*/
LSERR WINAPI RubyQueryCpPpoint(
	PDOBJ pdobj,				/*(IN): dobj to query, */
	LSDCP dcp,					/*(IN): dcp for the query */
	PCLSQIN plsqin,				/*(IN): query input */
	PLSQOUT plsqout)			/*(OUT): query output */
{
	PLSSUBL plssubl;
 	long dupAdj;
	long dvpAdj;
	BOOL fMain = fFalse;

	LSCP cpQuery = pdobj->cpStart + dcp;

	/*
	 *	Calculate subline to query
	 */

	/* Assume ruby line */
	plssubl = pdobj->plssublRuby;
	dupAdj = pdobj->dupOffsetRuby;
	dvpAdj = pdobj->dvpRubyOffset;

	/* + 1 means we include the cp of the object in the Ruby pronunciation line. */
	if (RubyPronunciationLineFirst == pdobj->pilsobj->rubysyntax)
		{
		/* Ruby pronunciation line is first */
		if (cpQuery >= pdobj->cpStartMain)
			{
			fMain = fTrue;
			}
		}
	else
		{
		/* Main text line is first */
		if (cpQuery < pdobj->cpStartRuby)
			{
			fMain = fTrue;
			}
		}

	if (fMain)
		{
		plssubl = pdobj->plssublMain;
		dupAdj = pdobj->dupOffsetMain;
		dvpAdj = pdobj->dvpMainOffset;
		}

	return CreateQueryResult(plssubl, dupAdj, dvpAdj, plsqin, plsqout);
}

	
/* R U B I D I S P L A Y */
/*----------------------------------------------------------------------------
	%%Function: RubyDisplay
	%%Contact: ricksa

		Display

		This calculates the positions of the various lines for the
		display and then displays them.
	
----------------------------------------------------------------------------*/
LSERR WINAPI RubyDisplay(
	PDOBJ pdobj,				/*(IN): dobj to display */
	PCDISPIN pcdispin)			/*(IN): display info */
{
	LSERR lserr;
	LSTFLOW lstflow = pcdispin->lstflow;
	UINT kDispMode = pcdispin->kDispMode;
	POINT ptLine;

	/* Calculate point to start displaying main line. */
	GetMainPoint(pdobj, &pcdispin->ptPen, lstflow, &ptLine);

	/* display first line */
	lserr = LsDisplaySubline(pdobj->plssublMain, &ptLine, kDispMode,
		pcdispin->prcClip);

	if (lserr != lserrNone)
		{
		return lserr;
		}

	/* Calculate point to start displaying ruby line. */
	GetRubyPoint(pdobj, &pcdispin->ptPen, lstflow, &ptLine);

	/* display ruby line */
	return LsDisplaySubline(pdobj->plssublRuby, &ptLine, kDispMode, 
		pcdispin->prcClip);
}

/* R U B I D E S T R O Y D O B J */
/*----------------------------------------------------------------------------
	%%Function: RubyDestroyDobj
	%%Contact: ricksa

		DestroyDobj

		Free all resources connected with the input dobj.
	
----------------------------------------------------------------------------*/
LSERR WINAPI RubyDestroyDobj(
	PDOBJ pdobj)				/*(IN): dobj to destroy */
{
	return RubyFreeDobj (pdobj);
}

/* R U B Y E N U M */
/*----------------------------------------------------------------------------
	%%Function: RubyEnum
	%%Contact: ricksa

		Enum

		Enumeration callback - passed to client.
	
----------------------------------------------------------------------------*/
LSERR WINAPI RubyEnum(
	PDOBJ pdobj,				/*(IN): dobj to enumerate */
	PLSRUN plsrun,				/*(IN): from DNODE */
	PCLSCHP plschp,				/*(IN): from DNODE */
	LSCP cp,					/*(IN): from DNODE */
	LSDCP dcp,					/*(IN): from DNODE */
	LSTFLOW lstflow,			/*(IN): text flow*/
	BOOL fReverse,				/*(IN): enumerate in reverse order */
	BOOL fGeometryNeeded,		/*(IN): */
	const POINT *pt,			/*(IN): starting position (top left), iff fGeometryNeeded */
	PCHEIGHTS pcheights,		/*(IN): from DNODE, relevant iff fGeometryNeeded */
	long dupRun)				/*(IN): from DNODE, relevant iff fGeometryNeeded */
{
	POINT ptMain;
	POINT ptRuby;
	long dupMain = 0;
	long dupRuby = 0;
	LSERR lserr;
	LSTFLOW lstflowIgnored;

	if (fGeometryNeeded)
		{
		GetMainPoint(pdobj, pt, lstflow, &ptMain);
		GetRubyPoint(pdobj, pt, lstflow, &ptMain);
		lserr = LssbGetDupSubline(pdobj->plssublMain, &lstflowIgnored, &dupMain);
		AssertSz(lserrNone == lserr, "RubyEnum - can't get dup for main");
		lserr = LssbGetDupSubline(pdobj->plssublRuby, &lstflowIgnored, &dupRuby);
		AssertSz(lserrNone == lserr, "RubyEnum - can't get dup for ruby");
		}

	return pdobj->pilsobj->rcbk.pfnRubyEnum(pdobj->pilsobj->pols, plsrun, 
		plschp, cp, dcp, lstflow, fReverse, fGeometryNeeded, pt, pcheights, 
			dupRun, &ptMain, &pdobj->objdimMain.heightsPres, dupMain, &ptRuby, 
				&pdobj->objdimRuby.heightsPres, dupRuby, pdobj->plssublMain,
					pdobj->plssublRuby);
}
	
	

/* R U B I H A N D L E R I N I T */
/*----------------------------------------------------------------------------
	%%Function: RubyHandlerInit
	%%Contact: ricksa

		Initialize global Ruby data and return LSIMETHODS.
	
----------------------------------------------------------------------------*/
LSERR WINAPI LsGetRubyLsimethods(
	LSIMETHODS *plsim)
{
	plsim->pfnCreateILSObj = RubyCreateILSObj;
	plsim->pfnDestroyILSObj = RubyDestroyILSObj;
	plsim->pfnSetDoc = RubySetDoc;
	plsim->pfnCreateLNObj = RubyCreateLNObj;
	plsim->pfnDestroyLNObj = RubyDestroyLNObj;
	plsim->pfnFmt = RubyFmt;
	plsim->pfnFmtResume = ObjHelpFmtResume;
	plsim->pfnGetModWidthPrecedingChar = RubyGetModWidthPrecedingChar;
	plsim->pfnGetModWidthFollowingChar = RubyGetModWidthFollowingChar;
	plsim->pfnTruncateChunk = SobjTruncateChunk;
	plsim->pfnFindPrevBreakChunk = SobjFindPrevBreakChunk;
	plsim->pfnFindNextBreakChunk = SobjFindNextBreakChunk;
	plsim->pfnForceBreakChunk = SobjForceBreakChunk;
	plsim->pfnSetBreak = RubySetBreak;
	plsim->pfnGetSpecialEffectsInside = RubyGetSpecialEffectsInside;
	plsim->pfnFExpandWithPrecedingChar = ObjHelpFExpandWithPrecedingChar;
	plsim->pfnFExpandWithFollowingChar = ObjHelpFExpandWithFollowingChar;
	plsim->pfnCalcPresentation = RubyCalcPresentation;
	plsim->pfnQueryPointPcp = RubyQueryPointPcp;
	plsim->pfnQueryCpPpoint = RubyQueryCpPpoint;
	plsim->pfnDisplay = RubyDisplay;
	plsim->pfnDestroyDObj = RubyDestroyDobj;
	plsim->pfnEnum = RubyEnum;
	return lserrNone;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\sobjhelp.c ===
/*
 *	sobjhelp.c 
 *
 *	This file contains implementations of methods that help
 *	common simple objects handle breaking and queries. All objects
 *	that use these routines must as the first entry in their dobj
 *	structure define an SObjCommon entry which these routines 
 *	will cast dobj's to.
 *
 */

#include "lsdefs.h"
#include "lsidefs.h"
#include "plocchnk.h"
#include "pposichn.h"
#include "posichnk.h"
#include "locchnk.h"
#include "brkcond.h"
#include "pbrko.h"
#include "brko.h"
#include "lsqout.h"
#include "lsqin.h"
#include "objhelp.h"
#include "sobjhelp.h"
#include "memory.h"
#include "lsmem.h"
#include "brkkind.h"

#define GET_DUR(pdobj) (((PSOBJHELP)pdobj)->objdimAll.dur)
#define GET_OBJDIM(pdobj) (((PSOBJHELP)pdobj)->objdimAll)
#define GET_DCP(pdobj) (((PSOBJHELP)pdobj)->dcp)
#define GET_MODAFTER(pdobj) (((PSOBJHELP)pdobj)->durModAfter)


/* F I L L B R E A K O U T */
/*----------------------------------------------------------------------------
	%%Function: FillBreakOut
	%%Contact: ricksa

		Fill break output record.
	
----------------------------------------------------------------------------*/
static void FillBreakOut(
	PDOBJ pdobj,				/* (IN): DOBJ for object */
	DWORD ichnk,				/* (IN): index in chunk */
	PBRKOUT pbrkout)			/* (OUT): break output record */
{
	pbrkout->posichnk.ichnk = ichnk;
	pbrkout->fSuccessful = fTrue;
	pbrkout->posichnk.dcp = GET_DCP(pdobj);
	pbrkout->objdim = GET_OBJDIM(pdobj);
	pbrkout->objdim.dur -= GET_MODAFTER(pdobj);
}

/* S O B J T R U N C A T E C H U N K */
/*----------------------------------------------------------------------------
	%%Function: SobjTruncateChunk
	%%Contact: ricksa

		.
	
----------------------------------------------------------------------------*/
LSERR WINAPI SobjTruncateChunk(
	PCLOCCHNK plocchnk,			/* (IN): locchnk to truncate */
	PPOSICHNK posichnk)			/* (OUT): truncation point */
{
	long urColumnMax = plocchnk->lsfgi.urColumnMax;
	long ur = plocchnk->ppointUvLoc[0].u;
	PDOBJ pdobj = NULL;
	DWORD i = 0;

	AssertSz(plocchnk->ppointUvLoc[0].u <= urColumnMax, 
		"SobjTruncateChunk - pen greater than column max");

	while (ur <= urColumnMax)
	{
		AssertSz((i < plocchnk->clschnk), "SobjTruncateChunk exceeded group of chunks");

		AssertSz(plocchnk->ppointUvLoc[i].u <= urColumnMax,
			"SobjTruncateChunk starting pen exceeds col max");

		pdobj = plocchnk->plschnk[i].pdobj;
		ur = plocchnk->ppointUvLoc[i].u + GET_DUR(pdobj);
		i++;
	}

	/* LS does not allow the truncation point to be at the beginning of the object */
	AssertSz(pdobj != NULL, "SobjTruncateChunk - pdobj NULL!");
	posichnk->ichnk = i - 1;
	posichnk->dcp = GET_DCP(pdobj);

	return lserrNone;
}

/* S O B J F I N D P R E V B R E A K C H U N K */
/*----------------------------------------------------------------------------
	%%Function: SobjFindPrevBreakChunk
	%%Contact: ricksa

		.
	
----------------------------------------------------------------------------*/
LSERR WINAPI SobjFindPrevBreakChunk(
	PCLOCCHNK pclocchnk,		/* (IN): locchnk to break */
	PCPOSICHNK pcpoischnk,		/* (IN): place to start looking for break */
	BRKCOND brkcond,			/* (IN): recommmendation about the break after chunk */
	PBRKOUT pbrkout)			/* (OUT): results of breaking */
{
	PDOBJ pdobj;
	DWORD ichnk = pcpoischnk->ichnk;

	AssertSz((int) brkcondPlease == 0, 
		"SobjFindPrevBreakChunk - brcondPlease != 0");

	ZeroMemory(pbrkout, sizeof(*pbrkout));

	if (ichnk == ichnkOutside)
	{
		ichnk = pclocchnk->clschnk - 1;
		pbrkout->posichnk.ichnk = ichnk;
		pdobj = pclocchnk->plschnk[ichnk].pdobj;

		if (GET_DUR(pdobj) - GET_MODAFTER(pdobj) 
				+ pclocchnk->ppointUvLoc[ichnk].u
					> pclocchnk->lsfgi.urColumnMax)
			{
			/* Are we at beginning of chunk? */
			if (ichnk > 0)
				{
				/* No - use the prior object in chunk */
				ichnk--;
				pdobj = pclocchnk->plschnk[ichnk].pdobj;
				}
			else
				{
				/* Yes. We need the break to happen before us. */
				pbrkout->posichnk.ichnk = ichnk;
				
				return lserrNone;
				}
			}

		if (brkcond != brkcondNever)
			{
			/* Break at end of chunk. */

			FillBreakOut(pdobj, ichnk, pbrkout);
			
			return lserrNone;
			}
			/* Else break at the beginning of last part of chunk */
	}

	if (ichnk >= 1)
	{
		/* Break before the current object */
		FillBreakOut(pclocchnk->plschnk[ichnk - 1].pdobj, ichnk - 1, pbrkout);
	}

	return lserrNone;
}

/* S O B J F I N D N E X T B R E A K C H U N K */
/*----------------------------------------------------------------------------
	%%Function: SobjFindNextBreakChunk
	%%Contact: ricksa

		.
	
----------------------------------------------------------------------------*/
LSERR WINAPI SobjFindNextBreakChunk(
	PCLOCCHNK pclocchnk,		/* (IN): locchnk to break */
	PCPOSICHNK pcpoischnk,		/* (IN): place to start looking for break */
	BRKCOND brkcond,			/* (IN): recommmendation about the break before chunk */
	PBRKOUT pbrkout)			/* (OUT): results of breaking */
{
	DWORD ichnk = pcpoischnk->ichnk;

	AssertSz((int) brkcondPlease == 0, 
		"SobjFindNextBreakChunk - brcondPlease != 0");

	ZeroMemory(pbrkout, sizeof(*pbrkout));

	if (ichnkOutside == ichnk)
		{
		if (brkcondNever != brkcond)	
			{
			pbrkout->fSuccessful = fTrue;

			return lserrNone;
			}

		/* can't break before so break after first item in chunk */
		ichnk = 0;
		}

	/* If not outside, we break at end of current dobj */
	FillBreakOut(pclocchnk->plschnk[ichnk].pdobj, ichnk, pbrkout);

	if (pclocchnk->clschnk - 1 == ichnk)
		{
		/* At the end of chunk. We can't say success for sure */
		pbrkout->fSuccessful = fFalse;
		}

	return lserrNone;
}

/* S O B J F O R C E B R E A K C H U N K */
/*----------------------------------------------------------------------------
	%%Function: SobjForceBreak
	%%Contact: ricksa

		Force Break

		.
----------------------------------------------------------------------------*/
LSERR WINAPI SobjForceBreakChunk(
	PCLOCCHNK pclocchnk,		/* (IN): locchnk to break */
	PCPOSICHNK pcposichnk,		/* (IN): place to start looking for break */
	PBRKOUT pbrkout)			/* (OUT): results of breaking */
{
	DWORD ichnk = pcposichnk->ichnk;

	ZeroMemory(pbrkout, sizeof(*pbrkout));
	pbrkout->posichnk.ichnk = ichnk;

	if (pclocchnk->lsfgi.fFirstOnLine && (0 == ichnk))
		{
		FillBreakOut(pclocchnk->plschnk[ichnk].pdobj, ichnk, pbrkout);
		}

	else if (ichnk == ichnkOutside)
		{
		/* Breaking after first object */
		FillBreakOut(pclocchnk->plschnk[0].pdobj, 0, pbrkout);
		}
	else if (ichnk != 0)
		{
		FillBreakOut(pclocchnk->plschnk[ichnk-1].pdobj, ichnk-1, pbrkout);
		}

	else /* Nothing, breaking before object */;		

	pbrkout->fSuccessful = fTrue; /* Force break is always successful! */

	return lserrNone;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\tatenak.c ===
#include	"lsmem.h"
#include	"limits.h"
#include	"tatenak.h"
#include	"objhelp.h"
#include	"lscbk.h"
#include	"lsdevres.h"
#include	"pdobj.h"
#include	"objdim.h"
#include	"plssubl.h"
#include	"plsdnode.h"
#include	"pilsobj.h"
#include	"lscrsubl.h"
#include	"lssubset.h"
#include	"lsdnset.h"
#include	"zqfromza.h"
#include	"sobjhelp.h"
#include	"lsdocinf.h"
#include	"fmti.h"
#include	"posichnk.h"
#include	"locchnk.h"
#include	"lsdnfin.h"
#include	"brko.h"
#include	"lspap.h"
#include	"plspap.h"
#include	"lsqsubl.h"
#include	"dispi.h"
#include	"lsdssubl.h"
#include	"lsems.h"
#include	"dispmisc.h"
#include	"lstfset.h"
#include	"sobjhelp.h"

#define TATENAKAYOKO_ESC_CNT	1


struct ilsobj
{
    POLS				pols;
	LSCBK				lscbk;
	PLSC				plsc;
	LSDEVRES			lsdevres;
	LSESC				lsescTatenakayoko;
	TATENAKAYOKOCBK		tcbk;			/* Callbacks  to client application */
};


typedef struct SUBLINEDNODES
{
	PLSDNODE			plsdnStart;
	PLSDNODE			plsdnEnd;

} SUBLINEDNODES, *PSUBLINEDNODES;

struct dobj
{
	SOBJHELP			sobjhelp;			/* common simple object area */
	PILSOBJ				pilsobj;			/* ILS object */
	LSCP				cpStart;			/* Starting LS cp for object */
	LSTFLOW				lstflowParent;		/* text flow of the parent subline */
	LSTFLOW				lstflowSubline;		/* text flow in Tatenakayoko Subline 
												(must be Rotate90 [lstflowParent] */
	PLSSUBL				plssubl;			/* Handle to subline for Tatenakayoko */
	long				dvpDescentReserved;	/* Part of descent reserved for client */
	OBJDIM				objdimT;			/* Objdim of the Tatenakayoko */

	/* (dupSubline, duvSubline) is vector from starting point of Tatenakayoko to */
	/* the starting point of its subline in coordinate system of parent subline */

	long				dupSubline;			
	long				dvpSubline;

};

static const POINTUV pointuvOrigin00 = { 0, 0 };
static const POINT   pointOrigin00 = { 0, 0 };

/* F R E E D O B J */
/*----------------------------------------------------------------------------
	%%Function: TatenakayokoFreeDobj
	%%Contact: antons

		Free all resources associated with this Tatenakayoko dobj.
	
----------------------------------------------------------------------------*/
static LSERR TatenakayokoFreeDobj(PDOBJ pdobj)
{
	LSERR lserr = lserrNone;

	PILSOBJ pilsobj = pdobj->pilsobj;

	if (pdobj->plssubl != NULL)
		{
		lserr = LsDestroySubline(pdobj->plssubl);
		}

    pilsobj->lscbk.pfnDisposePtr(pilsobj->pols, pdobj);
	return lserr;
}


/* T A T E N A K A Y O K O C R E A T E I L S O B J */
/*----------------------------------------------------------------------------
	%%Function: TatenakayokoCreateILSObj
	%%Contact: ricksa

		CreateILSObj

		Create the ILS object for all Tatenakayoko objects.
	
----------------------------------------------------------------------------*/
LSERR WINAPI TatenakayokoCreateILSObj(
	POLS pols,				/* (IN): client application context */
	PLSC plsc,				/* (IN): LS context */
	PCLSCBK pclscbk,		/* (IN): callbacks to client application */
	DWORD idObj,			/* (IN): id of the object */
	PILSOBJ *ppilsobj)		/* (OUT): object ilsobj */
{
    PILSOBJ pilsobj;
	LSERR lserr;
	TATENAKAYOKOINIT tatenakayokoinit;
	tatenakayokoinit.dwVersion = TATENAKAYOKO_VERSION;

	/* Get initialization data */
	lserr = pclscbk->pfnGetObjectHandlerInfo(pols, idObj, &tatenakayokoinit);

	if (lserr != lserrNone)
		{
		*ppilsobj = NULL;
		return lserr;
		}

    pilsobj = pclscbk->pfnNewPtr(pols, sizeof(*pilsobj));

	if (pilsobj == NULL)
	{
		*ppilsobj = NULL;
		return lserrOutOfMemory;
	}

    pilsobj->pols = pols;
    pilsobj->lscbk = *pclscbk;
	pilsobj->plsc = plsc;
	pilsobj->lsescTatenakayoko.wchFirst = tatenakayokoinit.wchEndTatenakayoko;
	pilsobj->lsescTatenakayoko.wchLast = tatenakayokoinit.wchEndTatenakayoko;
	pilsobj->tcbk = tatenakayokoinit.tatenakayokocbk;

	*ppilsobj = pilsobj;
	return lserrNone;
}

/* T A T E N A K A Y O K O D E S T R O Y I L S O B J */
/*----------------------------------------------------------------------------
	%%Function: TatenakayokoDestroyILSObj
	%%Contact: ricksa

		DestroyILSObj

		Free all resources assocaiated with Tatenakayoko ILS object.
	
----------------------------------------------------------------------------*/
LSERR WINAPI TatenakayokoDestroyILSObj(
	PILSOBJ pilsobj)			/* (IN): object ilsobj */
{
	pilsobj->lscbk.pfnDisposePtr(pilsobj->pols, pilsobj);
	return lserrNone;
}

/* T A T E N A K A Y O K O S E T D O C */
/*----------------------------------------------------------------------------
	%%Function: TatenakayokoSetDoc
	%%Contact: ricksa

		SetDoc

		Keep track of device information for scaling purposes.
	
----------------------------------------------------------------------------*/
LSERR WINAPI TatenakayokoSetDoc(
	PILSOBJ pilsobj,			/* (IN): object ilsobj */
	PCLSDOCINF pclsdocinf)		/* (IN): initialization data of the document level */
{
	pilsobj->lsdevres = pclsdocinf->lsdevres;
	return lserrNone;
}


/* T A T E N A K A Y O K O C R E A T E L N O B J */
/*----------------------------------------------------------------------------
	%%Function: TatenakayokoCreateLNObj
	%%Contact: ricksa

		CreateLNObj

		Create the Line Object for the Tatenakayoko. No real need for a line
		object so don't allocated it.
	
----------------------------------------------------------------------------*/
LSERR WINAPI TatenakayokoCreateLNObj(
	PCILSOBJ pcilsobj,			/* (IN): object ilsobj */
	PLNOBJ *pplnobj)			/* (OUT): object lnobj */
{
	*pplnobj = (PLNOBJ) pcilsobj;
	return lserrNone;
}

/* T A T E N A K A Y O K O D E S T R O Y L N O B J */
/*----------------------------------------------------------------------------
	%%Function: TatenakayokoDestroyLNObj
	%%Contact: ricksa

		DestroyLNObj

		Frees resources associated with the Tatenakayoko line object. Since
		there isn't any this is a no-op.
	
----------------------------------------------------------------------------*/
LSERR WINAPI TatenakayokoDestroyLNObj(
	PLNOBJ plnobj)				/* (OUT): object lnobj */

{
	Unreferenced(plnobj);
	return lserrNone;
}



/* T A T E N A K A Y O K O F M T */
/*----------------------------------------------------------------------------
	%%Function: TatenakayokoFmt
	%%Contact: ricksa

		Fmt

		Format the Tatenakayoko object. 
	
----------------------------------------------------------------------------*/
LSERR WINAPI TatenakayokoFmt(
    PLNOBJ plnobj,				/* (IN): object lnobj */
    PCFMTIN pcfmtin,			/* (IN): formatting input */
    FMTRES *pfmtres)			/* (OUT): formatting result */
{
	static LSTFLOW lstflowRotate90[] = 	
		{
		lstflowNE, /* [ lstflowES ] */
		lstflowNW, /* [ lstflowEN ] */
		lstflowEN, /* [ lstflowSE ] */
		lstflowES, /* [ lstflowSW ] */
		lstflowSE, /* [ lstflowWS ] */
		lstflowSW, /* [ lstflowWN ] */
		lstflowWN, /* [ lstflowNE ] */
		lstflowWS  /* [ lstflowNW ] */
		};

	PDOBJ pdobj;
	LSERR lserr;
	PILSOBJ pilsobj = (PILSOBJ) plnobj;
	POLS pols = pilsobj->pols;
	LSCP cpStartMain = pcfmtin->lsfgi.cpFirst + 1;
	LSCP cpOut;
	LSTFLOW lstflow = pcfmtin->lsfgi.lstflow;
	FMTRES fmtres;
	FMTRES fmtr = fmtrCompletedRun;

    /*
     * Allocate the DOBJ
     */

    pdobj = pilsobj->lscbk.pfnNewPtr(pols, sizeof(*pdobj));

    if (NULL == pdobj)
		{
		return lserrOutOfMemory;
		}

	ZeroMemory(pdobj, sizeof(*pdobj));
	pdobj->pilsobj = pilsobj;
	pdobj->cpStart = pcfmtin->lsfgi.cpFirst;
	pdobj->lstflowParent = lstflow;
	pdobj->lstflowSubline = lstflowRotate90 [lstflow];

	/*
	 * Build main line of text
	 */
	lserr = FormatLine(pilsobj->plsc, cpStartMain, LONG_MAX, pdobj->lstflowSubline,
		&pdobj->plssubl, TATENAKAYOKO_ESC_CNT, &pilsobj->lsescTatenakayoko,  
			&pdobj->objdimT, &cpOut, NULL, NULL, &fmtres);

	if (lserr != lserrNone)
		{
		TatenakayokoFreeDobj (pdobj);
		return lserr;
		}

	Assert (fmtres != fmtrExceededMargin);

	/* 
	 *	Calculate the object dimensions.
	 */
	lserr = pilsobj->tcbk.pfnGetTatenakayokoLinePosition(pols, pdobj->cpStart, pdobj->lstflowParent,
		pcfmtin->lsfrun.plsrun, pdobj->objdimT.dur, 
			&pdobj->sobjhelp.objdimAll.heightsRef, 
				&pdobj->sobjhelp.objdimAll.heightsPres, 
					&pdobj->dvpDescentReserved);

	if (lserr != lserrNone)
		{
		TatenakayokoFreeDobj (pdobj);
		return lserr;
		}

	/* set width of Tatenakayoko relative to text flow of line that contains it. */
	pdobj->sobjhelp.objdimAll.dur = pdobj->objdimT.heightsRef.dvAscent 
		+ pdobj->objdimT.heightsRef.dvDescent;

	/*
	 * Note: the + 2 in the following is because cpStartMain is + 1 from the
	 * actual start of the object (it is the cpStartMain of the Tatenakayoko
	 * data) and additional + 1 for the escape character at the end of the
	 * tatenakayoko.
	 */
	pdobj->sobjhelp.dcp = cpOut - cpStartMain + 2;
	
	lserr = LsdnFinishRegular(pilsobj->plsc, pdobj->sobjhelp.dcp, 
		pcfmtin->lsfrun.plsrun, pcfmtin->lsfrun.plschp, pdobj, 
			&pdobj->sobjhelp.objdimAll);
		
	if (lserr != lserrNone)
		{
		TatenakayokoFreeDobj (pdobj);
		return lserr;
		}

	lserr = LsdnSetRigidDup ( pilsobj->plsc, pcfmtin->plsdnTop,
							  pdobj->objdimT.heightsPres.dvAscent + 
							  pdobj->objdimT.heightsPres.dvDescent );

	if (lserr != lserrNone)
		{
		TatenakayokoFreeDobj (pdobj);
		return lserr;
		}
	
	if (pcfmtin->lsfgi.urPen + pdobj->sobjhelp.objdimAll.dur > pcfmtin->lsfgi.urColumnMax)
		{
		fmtr = fmtrExceededMargin;
		}

	*pfmtres = fmtr;

	return lserrNone;
}



/* T A T E N A K A Y O K O G E T S P E C I A L E F F E C T S I N S I D E */
/*----------------------------------------------------------------------------
	%%Function: TatenakayokoGetSpecialEffectsInside
	%%Contact: ricksa

		GetSpecialEffectsInside

		.

----------------------------------------------------------------------------*/
LSERR WINAPI TatenakayokoGetSpecialEffectsInside(
	PDOBJ pdobj,				/* (IN): dobj */
	UINT *pEffectsFlags)		/* (OUT): Special effects for this object */
{
	return LsGetSpecialEffectsSubline(pdobj->plssubl, pEffectsFlags);
}


/* G E T U F R O M L S T F L O W */
/*----------------------------------------------------------------------------
	%%Function: GetUFromLstflow
	%%Contact: antons

		GetUFromLstflow

	Gets XY vector corresponding to U-direction of lstflow.

----------------------------------------------------------------------------*/

void GetUFromLstflow (LSTFLOW lstflow, POINT * ppoint)
{
	POINTUV ptOneU = {1, 0};

	LsPointXYFromPointUV (& pointOrigin00, lstflow, &ptOneU, ppoint);
}


/* G E T V F R O M L S T F L O W */
/*----------------------------------------------------------------------------
	%%Function: GetVFromLstflow
	%%Contact: antons

		GetVFromLstflow

	Gets XY vector corresponding to V-direction of lstflow.

----------------------------------------------------------------------------*/

void GetVFromLstflow (LSTFLOW lstflow, POINT * ppoint)
{
	POINTUV ptOneV = {0, 1};

	LsPointXYFromPointUV (& pointOrigin00, lstflow, &ptOneV, ppoint);
}


/* T A T E N A K A Y O K O C A L C P R E S E N T A T I O N */
/*----------------------------------------------------------------------------
	%%Function: TatenakayokoCalcPresentation
	%%Contact: antons

		CalcPresentation
	
		This just makes the line match the calculated presentation of the line.
	
----------------------------------------------------------------------------*/
LSERR WINAPI TatenakayokoCalcPresentation(
	PDOBJ pdobj,				/* (IN): dobj */
	long dup,					/* (IN): dup of dobj */
	LSKJUST lskjust, 			/* (IN): Justification type */
	BOOL fLastVisibleOnLine )	/* (IN): Is this object last visible on line? */
{
	
	POINTUV ptTemp;
	POINTUV pointuv;

	POINT ptSublineV;
	POINT ptParentU;

	Unreferenced (fLastVisibleOnLine);
	Unreferenced (lskjust);

	pdobj->dupSubline = 0;
	pdobj->dvpSubline = 0;

	GetUFromLstflow (pdobj->lstflowParent, &ptParentU);
	GetVFromLstflow (pdobj->lstflowSubline, &ptSublineV);

	/* Assert that Main U is parallel to Subline V */

	Assert (ptParentU.x * ptSublineV.y - ptParentU.y * ptSublineV.x == 0);

	pointuv.u = - (pdobj->sobjhelp.objdimAll.heightsPres.dvDescent 
		- pdobj->dvpDescentReserved);

	pointuv.v = 0;

	LsPointUV2FromPointUV1 (pdobj->lstflowSubline, & pointuvOrigin00, & pointuv, 
							pdobj->lstflowParent, & ptTemp);

	pdobj->dupSubline += ptTemp.u;
	pdobj->dvpSubline += ptTemp.v;

	if ((ptParentU.x == ptSublineV.x) && (ptParentU.y == ptSublineV.y))
		{
		pdobj->dupSubline += pdobj->objdimT.heightsPres.dvDescent;
		}
	else
		{
		pdobj->dupSubline += pdobj->objdimT.heightsPres.dvAscent;
		}


	Unreferenced(dup);

	return LsMatchPresSubline(pdobj->plssubl);

}

/* T A T E N A K A Y O K O Q U E R Y P O I N T P C P */
/*----------------------------------------------------------------------------
	%%Function: TatenakayokoQueryPointPcp
	%%Contact: ricksa

		Map dup to dcp

		This just passes the offset of the subline to the helper function
		which will format the output.

----------------------------------------------------------------------------*/
LSERR WINAPI TatenakayokoQueryPointPcp(
	PDOBJ pdobj,				/*(IN): dobj to query */
	PCPOINTUV ppointuvQuery,	/*(IN): query point (uQuery,vQuery) */
	PCLSQIN plsqin,				/*(IN): query input */
	PLSQOUT plsqout)			/*(OUT): query output */
{
	Unreferenced(ppointuvQuery);

	return CreateQueryResult
		(pdobj->plssubl, pdobj->dupSubline, pdobj->dvpSubline, plsqin, plsqout);
}
	
/* T A T E N A K A Y O K O Q U E R Y C P P P O I N T */
/*----------------------------------------------------------------------------
	%%Function: TatenakayokoQueryCpPpoint
	%%Contact: ricksa

		Map dcp to dup

		This just passes the offset of the subline to the helper function
		which will format the output.

----------------------------------------------------------------------------*/
LSERR WINAPI TatenakayokoQueryCpPpoint(
	PDOBJ pdobj,				/*(IN): dobj to query */
	LSDCP dcp,					/*(IN): dcp for the query */
	PCLSQIN plsqin,				/*(IN): query input */
	PLSQOUT plsqout)			/*(OUT): query output */
{
	Unreferenced(dcp);

	return CreateQueryResult(pdobj->plssubl, 
		pdobj->dupSubline, pdobj->dvpSubline, plsqin, plsqout);

}


/* T A T E N A K A Y O K O D I S P L A Y */
/*----------------------------------------------------------------------------
	%%Function: TatenakayokoDisplay
	%%Contact: ricksa

		Display

		This calculates the position of the subline for the
		display and then displays it.
	
----------------------------------------------------------------------------*/
LSERR WINAPI TatenakayokoDisplay(
	PDOBJ pdobj,				/*(IN): dobj to display */
	PCDISPIN pcdispin)			/*(IN): info for display */
{
	POINT ptLine;
	POINTUV ptAdd;

	ptAdd.u = pdobj->dupSubline;
	ptAdd.v = pdobj->dvpSubline;

	LsPointXYFromPointUV(&pcdispin->ptPen, pdobj->lstflowParent, &ptAdd, &ptLine);

	/* display the Tatenakayoko line */

	return LsDisplaySubline(pdobj->plssubl, &ptLine, pcdispin->kDispMode, 
		pcdispin->prcClip);

}

/* T A T E N A K A Y O K O D E S T R O Y D O B J */
/*----------------------------------------------------------------------------
	%%Function: TatenakayokoDestroyDobj
	%%Contact: ricksa

		DestroyDobj

		Free all resources connected with the input dobj.
	
----------------------------------------------------------------------------*/
LSERR WINAPI TatenakayokoDestroyDobj(
	PDOBJ pdobj)				/*(IN): dobj to destroy */
{
	return TatenakayokoFreeDobj(pdobj);
}

/* T A T E N A K A Y O K O E N U M */
/*----------------------------------------------------------------------------
	%%Function: TatenakayokoEnum
	%%Contact: ricksa

		Enum

		Enumeration callback - passed to client.
	
----------------------------------------------------------------------------*/
LSERR WINAPI TatenakayokoEnum(
	PDOBJ pdobj,				/*(IN): dobj to enumerate */
	PLSRUN plsrun,				/*(IN): from DNODE */
	PCLSCHP plschp,				/*(IN): from DNODE */
	LSCP cp,					/*(IN): from DNODE */
	LSDCP dcp,					/*(IN): from DNODE */
	LSTFLOW lstflow,			/*(IN): text flow*/
	BOOL fReverse,				/*(IN): enumerate in reverse order */
	BOOL fGeometryNeeded,		/*(IN): */
	const POINT *pt,			/*(IN): starting position (top left), iff fGeometryNeeded */
	PCHEIGHTS pcheights,		/*(IN): from DNODE, relevant iff fGeometryNeeded */
	long dupRun)				/*(IN): from DNODE, relevant iff fGeometryNeeded */
{
	return pdobj->pilsobj->tcbk.pfnTatenakayokoEnum(pdobj->pilsobj->pols, plsrun,
		plschp, cp, dcp, lstflow, fReverse, fGeometryNeeded, pt, pcheights, 
			dupRun, pdobj->lstflowParent, pdobj->plssubl);
}

/* T A T E N A K A Y O K O H A N D L E R I N I T */
/*----------------------------------------------------------------------------
	%%Function: TatenakayokoHandlerInit
	%%Contact: ricksa

		Initialize global Tatenakayoko data and return LSIMETHODS.
	
----------------------------------------------------------------------------*/
LSERR WINAPI LsGetTatenakayokoLsimethods(
	LSIMETHODS *plsim)
{
	plsim->pfnCreateILSObj = TatenakayokoCreateILSObj;
	plsim->pfnDestroyILSObj = TatenakayokoDestroyILSObj;
	plsim->pfnSetDoc = TatenakayokoSetDoc;
	plsim->pfnCreateLNObj = TatenakayokoCreateLNObj;
	plsim->pfnDestroyLNObj = TatenakayokoDestroyLNObj;
	plsim->pfnFmt = TatenakayokoFmt;
	plsim->pfnFmtResume = ObjHelpFmtResume;
	plsim->pfnGetModWidthPrecedingChar = ObjHelpGetModWidthChar;
	plsim->pfnGetModWidthFollowingChar = ObjHelpGetModWidthChar;
	plsim->pfnTruncateChunk = SobjTruncateChunk;
	plsim->pfnFindPrevBreakChunk = SobjFindPrevBreakChunk;
	plsim->pfnFindNextBreakChunk = SobjFindNextBreakChunk;
	plsim->pfnForceBreakChunk = SobjForceBreakChunk;
	plsim->pfnSetBreak = ObjHelpSetBreak;
	plsim->pfnGetSpecialEffectsInside = TatenakayokoGetSpecialEffectsInside;
	plsim->pfnFExpandWithPrecedingChar = ObjHelpFExpandWithPrecedingChar;
	plsim->pfnFExpandWithFollowingChar = ObjHelpFExpandWithFollowingChar;
	plsim->pfnCalcPresentation = TatenakayokoCalcPresentation;
	plsim->pfnQueryPointPcp = TatenakayokoQueryPointPcp;
	plsim->pfnQueryCpPpoint = TatenakayokoQueryCpPpoint;
	plsim->pfnDisplay = TatenakayokoDisplay;
	plsim->pfnDestroyDObj = TatenakayokoDestroyDobj;
	plsim->pfnEnum = TatenakayokoEnum;
	return lserrNone;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\unixfunctions.c ===
#ifdef UNIX
void msls3_DllMain(void* handle, unsigned int reason, void* reserved)
{
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\afxres.h ===
#include <windows.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\zqfromza.c ===
#include <limits.h>

#include "lsidefs.h"
#include "zqfromza.h"


#ifdef _X86_

/* ===========================================================  */
/*																*/
/* Functions implemented on Intel X86 Assember					*/
/*																*/
/* ===========================================================  */

#define HIWORD(x) DWORD PTR [x+4]
#define LOWORD(x) DWORD PTR [x]


long ZqFromZa_Asm (long dzqInch, long za)
{
	long result;
	__asm
	{
		mov eax, za;
		cmp eax, 0
		jge POSITIVE

			neg eax
			mul dzqInch;
			add eax, czaUnitInch / 2
			mov ecx, czaUnitInch
			adc	edx, 0		
			div	ecx;
			neg eax
			jmp RETURN

		POSITIVE:

			mul dzqInch;
			add eax, czaUnitInch / 2
			mov ecx, czaUnitInch
			adc	edx, 0		
			div	ecx;
		
		RETURN:

			mov result, eax
		
	};

	/*
	Assert (result == ZqFromZa_C (dzqInch, za));
	*/

	return result;
}

/* D I V 6 4 _ A S M */
/*----------------------------------------------------------------------------
	%%Function: Div64_Asm
	%%Contact: antons

		Intel assembler implementation of 64-bit division. The 
		orignal code was taken from lldiv.asm (VC++ 6.0).
		
----------------------------------------------------------------------------*/

__int64 Div64_Asm (__int64 DVND, __int64 DVSR)
{
	__int64 result;

	__asm {

		xor     edi,edi				// result sign assumed positive

        mov     eax,HIWORD(DVND)	// hi word of a
        or      eax,eax				// test to see if signed
        jge     L1					// skip rest if a is already positive
        inc     edi					// complement result sign flag
        mov     edx,LOWORD(DVND)	// lo word of a
        neg     eax					// make a positive
        neg     edx
        sbb     eax,0
        mov     HIWORD(DVND),eax	// save positive value
        mov     LOWORD(DVND),edx
L1:
        mov     eax,HIWORD(DVSR)	// hi word of b
        or      eax,eax				// test to see if signed
        jge     L2					// skip rest if b is already positive
        inc     edi					// complement the result sign flag
        mov     edx,LOWORD(DVSR)	// lo word of a
        neg     eax					// make b positive
        neg     edx
        sbb     eax,0
        mov     HIWORD(DVSR),eax	// save positive value
        mov     LOWORD(DVSR),edx
L2:

// Now do the divide.  First look to see if the divisor is less than 4194304K.
// If so, then we can use a simple algorithm with word divides, otherwise
// things get a little more complex.
//
// NOTE - eax currently contains the high order word of DVSR

        or      eax,eax         // check to see if divisor < 4194304K
        jnz     L3				// nope, gotta do this the hard way
        mov     ecx,LOWORD(DVSR) // load divisor
        mov     eax,HIWORD(DVND) // load high word of dividend
        xor     edx,edx
        div     ecx             // eax <- high order bits of quotient
        mov     ebx,eax         // save high bits of quotient
        mov     eax,LOWORD(DVND) // edx:eax <- remainder:lo word of dividend
        div     ecx             // eax <- low order bits of quotient
        mov     edx,ebx         // edx:eax <- quotient
        jmp     L4				// set sign, restore stack and return

//
// Here we do it the hard way.  Remember, eax contains the high word of DVSR
//

L3:
        mov     ebx,eax         // ebx:ecx <- divisor
        mov     ecx,LOWORD(DVSR)
        mov     edx,HIWORD(DVND) // edx:eax <- dividend
        mov     eax,LOWORD(DVND)
L5:
        shr     ebx,1           // shift divisor right one bit
        rcr     ecx,1
        shr     edx,1           // shift dividend right one bit
        rcr     eax,1
        or      ebx,ebx
        jnz     L5				// loop until divisor < 4194304K
        div     ecx             // now divide, ignore remainder
        mov     esi,eax         // save quotient

/*
// We may be off by one, so to check, we will multiply the quotient
// by the divisor and check the result against the orignal dividend
// Note that we must also check for overflow, which can occur if the
// dividend is close to 2**64 and the quotient is off by 1.

*/

        mul     HIWORD(DVSR) // QUOT * HIWORD(DVSR)
        mov     ecx,eax
        mov     eax,LOWORD(DVSR)
        mul     esi             // QUOT * LOWORD(DVSR)
        add     edx,ecx         // EDX:EAX = QUOT * DVSR
        jc      L6				// carry means Quotient is off by 1

//
// do long compare here between original dividend and the result of the
// multiply in edx:eax.  If original is larger or equal, we are ok, otherwise
// subtract one (1) from the quotient.
//

        cmp     edx,HIWORD(DVND) // compare hi words of result and original
        ja      L6				// if result > original, do subtract
        jb      L7				// if result < original, we are ok
        cmp     eax,LOWORD(DVND) // hi words are equal, compare lo words
        jbe     L7				// if less or equal we are ok, else subtract
L6:
        dec     esi             // subtract 1 from quotient
L7:
        xor     edx,edx         // edx:eax <- quotient
        mov     eax,esi

//
// Just the cleanup left to do.  edx:eax contains the quotient.  Set the sign
// according to the save value, cleanup the stack, and return.
//

L4:
        dec     edi             // check to see if result is negative
        jnz     L8				// if EDI == 0, result should be negative
        neg     edx             // otherwise, negate the result
        neg     eax
        sbb     edx,0

//
// Restore the saved registers and return.
//

L8:
		mov		HIWORD(result),edx
		mov		LOWORD(result),eax

	}; /* ASM */

	return result;
}


/* M U L 6 4 _ A S M */
/*----------------------------------------------------------------------------
	%%Function: Mul64_Asm
	%%Contact: antons

		Intel assembler implementation of 64-bit multiplication. The 
		orignal code was taken from llmul.asm (VC++ 6.0).
		
----------------------------------------------------------------------------*/

__int64 Mul64_Asm (__int64 A, __int64 B)
{
	__int64 result;
	
	__asm {

        mov     eax,HIWORD(A)
        mov     ecx,LOWORD(B)

        mul     ecx					// eax has AHI, ecx has BLO, so AHI * BLO
        mov     esi,eax				// save result

        mov     eax,LOWORD(A)
        mul     HIWORD(B)			// ALO * BHI
        add     esi,eax				// ebx = ((ALO * BHI) + (AHI * BLO))

        mov     eax,LOWORD(A)		// ecx = BLO
        mul     ecx					// so edx:eax = ALO*BLO
        add     edx,esi				// now edx has all the LO*HI stuff

		mov		HIWORD(result),edx
		mov		LOWORD(result),eax

	}; /* ASM */

	return result;
}

/* ===========================================================  */
/*																*/
/* End of Assembler functions									*/
/*																*/
/* ===========================================================  */

#endif /* _X86_ */


long ZqFromZa_C (long dzqInch, long za)
{
	long cInches;
	long zaExtra;

	if (za < 0)
		{
		Assert (((long) -za) > 0); /* Check for overflow */
		return -ZqFromZa_C (dzqInch, -za);
		};

	Assert(0 <= za);
	Assert(0 < dzqInch && dzqInch < zqLim);
	Assert(0 < czaUnitInch);

	cInches = za / czaUnitInch;
	zaExtra = za % czaUnitInch;

	return (cInches * dzqInch) +
			((zaExtra * dzqInch) + (czaUnitInch/2)) / czaUnitInch;
}

long ZaFromZq(long dzqInch, long zq)
{
	long cInches;
	long zqExtra;

	if (zq < 0)
		return -ZaFromZq(dzqInch, -zq);

	Assert(0 <= zq);
	Assert(0 < dzqInch && dzqInch < zqLim);
	Assert(0 < czaUnitInch);

	cInches = zq / dzqInch;
	zqExtra = zq % dzqInch;

	return (cInches * czaUnitInch) + 
			((zqExtra * czaUnitInch) + ((unsigned long) dzqInch/2)) / dzqInch;
}


long LsLwMultDivR(long l, long lNumer, long lDenom)
{
	__int64 llT;

	Assert(lDenom != 0);
	if (lDenom == 0)	/* this is really sloppy! Don't depend on this! */
		return LONG_MAX;

    if (l == 0)
        return 0;

    if (lNumer == lDenom)
        return l;

    llT = Mul64 (l, lNumer);

	if ( (l ^ lNumer ^ lDenom) < 0)		/* xor sign bits to give result sign */
		llT -= lDenom / 2;
	else
		llT += lDenom / 2;
		
	if ((__int64)(long)llT == llT)		/* Did the multiply fit in 32-bits */
		return ( ((long)llT) / lDenom);	/* If so, do a 32-bit divide. */

	llT = Div64 (llT, lDenom);

	if (llT > LONG_MAX)
		return LONG_MAX;
	else if (llT < LONG_MIN)
		return LONG_MIN;
	else
		return (long) llT;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\aimm_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 3.01.75 */
/* at Tue Jan 13 08:56:29 1998
 */
/* Compiler settings for aimm.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID LIBID_ActiveIMM = {0x4955DD30,0xB159,0x11d0,{0x8F,0xCF,0x00,0xAA,0x00,0x6B,0xCC,0x59}};


const IID IID_IEnumRegisterWordA = {0x08C03412,0xF96B,0x11d0,{0xA4,0x75,0x00,0xAA,0x00,0x6B,0xCC,0x59}};


const IID IID_IEnumRegisterWordW = {0x4955DD31,0xB159,0x11d0,{0x8F,0xCF,0x00,0xAA,0x00,0x6B,0xCC,0x59}};


const IID IID_IAIMMRegistrar = {0xc7afa428,0x5007,0x11d1,{0xaa,0x94,0x00,0x60,0xb0,0x67,0xb8,0x6e}};


const IID IID_IActiveIMMMessagePumpOwner = {0xb5cf2cfa,0x8aeb,0x11d1,{0x93,0x64,0x00,0x60,0xb0,0x67,0xb8,0x6e}};


const IID IID_IActiveIMMApp = {0x08c0e040,0x62d1,0x11d1,{0x93,0x26,0x00,0x60,0xb0,0x67,0xb8,0x6e}};


const IID IID_IActiveIMMIME = {0x08C03411,0xF96B,0x11d0,{0xA4,0x75,0x00,0xAA,0x00,0x6B,0xCC,0x59}};


const IID IID_IActiveIME = {0x6FE20962,0xD077,0x11d0,{0x8F,0xE7,0x00,0xAA,0x00,0x6B,0xCC,0x59}};


const CLSID CLSID_CActiveIMM = {0x4955DD33,0xB159,0x11d0,{0x8F,0xCF,0x00,0xAA,0x00,0x6B,0xCC,0x59}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\warichu.c ===
/* ---------------------------------------------------------------
 : LineServices 3.0
 :
 : WARICHU ("Two lines in one" in Winword)
 :
 : Object Handler Routines 
 :
 : Contact: AntonS
 :
 ------------------------------------------------------------------ */

#include	"lsmem.h"
#include	"limits.h"
#include	"warichu.h"
#include	"objhelp.h"
#include	"lsesc.h"
#include	"lscbk.h"
#include	"lsdevres.h"
#include	"pdobj.h"
#include	"objdim.h"
#include	"plssubl.h"
#include	"plsdnode.h"
#include	"pilsobj.h"
#include	"lscrsubl.h"
#include	"lssubset.h"
#include	"lsdnset.h"
#include	"zqfromza.h"
#include	"lstfset.h"
#include	"lsdocinf.h"
#include	"fmti.h"
#include	"posichnk.h"
#include	"locchnk.h"
#include	"lsdnfin.h"
#include	"brko.h"
#include	"lspap.h"
#include	"plspap.h"
#include	"lsqsubl.h"
#include	"dispi.h"
#include	"lsdssubl.h"
#include	"dispmisc.h"
#include	"lstfset.h"
#include	"brkkind.h"

#include	"lschp.h"

 /* REVIEW (antons):

	- Assert that FormatUntilCpBreak fSuccessful

	- Assimetry between Prev and Next BreakWarichuDobj: it looks like
	  right margin as input to Next break may also optimize truncation.

	- In ForceBreak it may happen that dur < 0: What is the correct thing to do?

	- Invalid pdobj.wlayout when wwhole is not finished: dur must be
	  set correctly.

	- Can I assert that if subline was stopped at fmtrExceededMargin,
	  dur > RM.

	- Should ForceBreak return correct previous break if possible?

	- I rely on the following axiom:

	  If Warichu returned fmtrExceedMargin, it must be broken
	  inside (brkkind != brkkindImposedAfter)

	- Mod width: check method(s); should I count m-w in Warichu Truncation / Breaking 

	- Optimization of allocating WBRKREC

	- To have function GetDcpWarichu (additionally to GetCpLimOfWLayout)

    - Do something with FOpenBraceWLayout

	- Queries: callback to client saying where to snap?

    - Sergey: Assert in AdjustText & submitted sublines.

*/


/**********************************/
/*                                */
/* WARICHU Array of break records */
/*                                */
/**********************************/

typedef struct wbrkarray
{
	DWORD		nBreakRec;		/* Actual number of break records in the array */
	DWORD		nBreakRecMax;	/* Size of allocated array */
	BREAKREC	* rgBreakRec;	/* Ls array of break records */

	/* Note: Field nBreakRec is maintained by clients of this structure 
			 and it must be <= nBreakRecMax. nBreakRecMax and rgBreakRec
			 are set during allocation */

} WBRKARRAY;

typedef WBRKARRAY *PWBRKARRAY;


/****************************/
/*                          */
/* WARICHU Installed LS Obj */
/*                          */
/****************************/

typedef struct ilsobj
{
    POLS				pols;
    struct lscbk		lscbk;
	PLSC				plsc;
	DWORD				idobj;
	LSDEVRES			lsdevres;
	LSESC				lsescBraceOpen;
	LSESC				lsescText;
	LSESC				lsescBraceClose;
	WARICHUCBK			warichucbk;			/* Callbacks  to client application */
	BOOL				fContiguousFetch;	/* This flag was added to fix Word 9 bug */

} ILSOBJ;


/****************************/
/*                          */
/* WARICHU Internal Subline */
/*                          */
/****************************/

typedef struct wsubline
{
	PLSSUBL	plssubl;		/* Pointer to LS Subline */
	OBJDIM	objdim;			/* Dimensions of this subline */
	LSCP	cpFirst;		/* cp where formatting of this subline started */
	LSCP	cpLim;			/* cp-lim after formatting */

	/* Note: One exception when objdim & cpLim does not correspond to the
			 dimensions of the subline is the second subline in the Broken Warichu
			 before SetBreak. We lie putting objdim & cpLim of 
			 already broken subline. Durig Warichu SetBreak we call 
			 LsSetBreakSubline (plssubl...) and the lie turnes into the truth
	*/

} WSUBLINE;

typedef WSUBLINE *PWSUBLINE;


/****************************/
/*                          */
/* WARICHU Formatted Brace  */
/*                          */
/****************************/

typedef struct wbrace
{
	PLSSUBL plssubl;			/* Pointer to Ls subline with brace */
	OBJDIM  objdim;				/* Dimensions of the subline */
	LSCP	cpFirst;			/* cp-start formatting */
	LSCP	cpLim;				/* cp-lim after formatting */
	LSCP	cpLimAfterEsc;		/* cp-lim after brace ESC character (in our case cpLim + 1) */
	
} WBRACE;

typedef WBRACE *PBRACE;


/**********************/
/*                    */
/* WARICHU Dimensions */
/*                    */
/**********************/

typedef struct wdim
{
	OBJDIM	objdimAll;			/* Dimensions of the whole Warichu */
	long	dvpDescentReserved; /* Received from client together with objdimAll */
								/* REVIEW (antons): Clean this logic of calculating
													relative positions of warichu sublines */
} WDIM;


/************************/
/*                      */
/* WARICHU Layout		*/
/*                      */
/************************/

typedef struct wlayout
{
	WSUBLINE	wsubline1;		/* First subline in the layout (NULL if layout not valid) */
	WSUBLINE	wsubline2;		/* Second subline in the layout (NULL if no second line) */

	BOOL		fBroken;		/* Broken or whole Warichu? */
	BRKKIND		brkkind;		/* Kind of break to set at the end of second line if "Broken" */

	/*	Note: Although the following fields can be calculated using above data 
			  and DOBJ, it is filled by FinishObjDimLayout and nobody has the right 
			  to recalc it on his own way after it has been set. 
	*/

	WDIM		wdim;				/* Dimensions of the whole Warichu */

} WLAYOUT;

typedef WLAYOUT *PWLAYOUT;


/****************************/
/*                          */
/* WARICHU Kind of break    */
/*                          */
/****************************/

typedef enum wbreaktype 
{
	wbreaktypeInside,
	wbreaktypeAfter,
	wbreaktypeInvalid
	
} WBREAKTYPE;


/******************************************/
/*                                        */
/* Presentation Data for Warichu sublines */
/*                                        */
/******************************************/

typedef struct wdispsubl
{

	long	dup;		/* Dup of subline */
	POINTUV	duvStart;	/* Relative (from object start) position of subline */
						/* (in lstflow of the parent) */

} WDISPSUBL;

typedef WDISPSUBL *PWDISPSUBL;


/******************************************/
/*                                        */
/* Presentation Data for Warichu braces   */
/*                                        */
/******************************************/

typedef WDISPSUBL WDISPBRACE; /* Same as display information for sublines */

typedef WDISPBRACE *PWDISPBRACE;


/*****************************/
/*                           */
/* WARICHU Presentation Data */
/*                           */
/*****************************/

typedef struct wdisplay
{
	WDISPSUBL wdispsubl1;	/* Display information about Warichu first subline */
	WDISPSUBL wdispsubl2;	/* Display information about Warichu second subline */

	WDISPBRACE wdispbraceOpen;	/* Display information about Open brace */
	WDISPBRACE wdispbraceClose;	/* Display information about Closing brace */

	long dvpBetween;		/* REVIEW (antons): Do I need to store this? ;-) */
	long dupAll;			/* REVIEW (antons): Do I need to store this? ;-) */

} WDISPLAY;


/****************************/
/*                          */
/* WARICHU Whole subline    */
/*                          */
/****************************/

typedef struct wwhole
{
	PLSSUBL plssubl;	/* Whole formatted subline */

	LSCP cpFirst;		/* Cp first of the subline */
	LSCP cpLim;			/* Cp lim of the subline */

	OBJDIM objdim;		/* Dimensions of the formatted subline */

	long urColumnMax;	/* Column Max until we formatted the WHOLE line */
						/* REVIEW (antons): Do we need this? */

	BOOL fFinished;		/* If we have reached ESC character during formatting */

						/* REVIEW (antons): It seems now I can leave without cpTruncate at all */
	LSCP cpTruncate;	/* Truncation point at urColumnMax if fFinished = FALSE */
	LSCP cpLimAfterEsc;	/* First character after ESC if fFinished = TRUE */

	BOOL fJisRangeKnown;	/* Did we calculate cpJisRangeFirst & cpJisRangeLim? */

	/* The following two variables are valid only when "fJisRangeKnown == TRUE" */

	LSCP cpJisRangeFirst;	/* 4-th cpBreak break from the start of the WWhole subline */
	LSCP cpJisRangeLim;		/* 4-th cpBreak break from the end of WWhole subline */

	/* Note 1: Jis Range empty when cpJisRangeFirst >= cpJisRangeLim */
	/* Note 2: Jis Range defines possible set of Warichu breaks according
			   to JIS rule about 4 break opportunities before / after break. 
			   If cp belong to JisRange (cpJisRangeFirst <= cp < cpJisRangeLim)
			   it means that there are 4 break opportunities before / after cp. */
	/* Note 3: Jis Range is calculated only when neccesary (during breaking). After
			   formatting fJisRangeKnown==FALSE. When someone need Jis Range during
			   breaking, he should call CalcJisRange().
	*/

} WWHOLE;

typedef WWHOLE *PWWHOLE;

/***************************/
/*                         */
/* WARICHU DOBJ structure  */
/*                         */
/***************************/

struct dobj
{
	/* 1. Dobj life-time constant data */
		
	PILSOBJ		pilsobj;		 /* Pointer to ILS object */
	PLSDNODE	plsdnTop;		 /* Warichu parent DNode */

	LSCP		cpStart;		 /* Starting LS cp for object */
	LSCP		cpStartObj;		 /* Starting cp for object. If not Resumed => cpStartObj == cpStart */

	BOOL		fResumed;		 /* If Warichu was resumed  */
	/* REVIEW (antons): Can I assert that fResumed == (cpStart == cpStartObj) */

	LSTFLOW		lstflowParent;	 /* Lstflow of the parent subline */

	/* 2. Formattig + Breaking + Displaying */

	WLAYOUT		wlayout;			 /* Current layout after Formatting / SetBreak */

	WBRACE		wbraceOpen;		 /* Opening brace */
	WBRACE		wbraceClose;	 /* Closing brace */ 

	/* 3. Breaking */

	WBRKARRAY	wbrkarrayAtStart;

								/* Break records at line start */
								/* (if !fResumed => zero # of break records) */

	WWHOLE		wwhole;			 /* Structure containing warichu whole subline */

	WLAYOUT		wlayoutBreak [NBreaksToSave]; 
								 /* 3 break records for Prev / Next / Force */

	WLAYOUT		wlayoutTruncate; /* Optimization: we save the layout after Truncation */

	WBREAKTYPE	wbreaktype [NBreaksToSave];

	/* 4. Displaying */

	WDISPLAY	wdisplay;		/* Presentation info for current layout (valid after CalcPres) */

} DOBJ;


/***************************/
/*                         */
/* Some macors			   */
/*                         */
/***************************/

#define INT_UNDEFINED 0xFFFFFFFF
#define CP_MAX LONG_MAX

#define abs(x) ((x)<0 ? -(x) : (x))

#define max(a,b) ((a) > (b) ? (a) : (b))

#define ZeroObjDim(pobjdim) memset ((pobjdim), 0, sizeof(OBJDIM));

#define NOT !


/* O V E R F L O W  S A F E  A R I T H M E T I C S */
/*----------------------------------------------------------------------------
	%%Functions: ADDLongSafe, MULLongSafe
	%%Contact: antons

		Calculations with urColumnMax require special treatment because
		of possible overflow. Two functions below implement overflow-safe 
		arithmetics for ADD and MUL on positive (>=0) numbers.
		
----------------------------------------------------------------------------*/

/* ADDLongSafe: X + Y */

long ADDLongSafe (long x, long y) 
{
	Assert (x >= 0 && y >= 0);

	if (x > LONG_MAX - y) return LONG_MAX;
	else
		return x + y;
}

/* MULLongSafe: X * Y */

long MULLongSafe (long x, long y) 
{
	Assert (x >= 0 && y >= 0);

	if (y == 0) return 0;
	else if (x > LONG_MAX / y) return LONG_MAX;
	else
		return x * y;
}


/* W A  F I N D  N E X T  B R E A K  S U B L I N E */
/*----------------------------------------------------------------------------
	%%Function: WaFindNextBreakSubline
	%%Contact: antons

		Wrapper to LsFindNextBreakSubline () API. It makes sure that result is
		monotonous.

----------------------------------------------------------------------------*/
LSERR WaFindNextBreakSubline (

		PLSSUBL		plssubl, 
		LSCP		cpTruncate,	
		long		urColumnMax, 
		BOOL		* pfSuccessful, 
		LSCP		* pcpBreak,
		POBJDIM		pobjdimSubline )
{
	BRKPOS brkpos;

	LSERR lserr = LsFindNextBreakSubline ( plssubl, 
										   TRUE, 
										   cpTruncate, 
										   urColumnMax, 
										   pfSuccessful, 
										   pcpBreak, 
										   pobjdimSubline,
										   & brkpos );
	if (lserr != lserrNone) return lserr;

	if (* pfSuccessful) 
		{
		/* REVIEW (antons): Maybe still better have a loop for crazy case? */
		Assert (*pcpBreak > cpTruncate);

		/* REVIEW (antons): Check this Assert with Igor */
		Assert (brkpos != brkposBeforeFirstDnode);

		if (brkpos == brkposAfterLastDnode) *pfSuccessful = FALSE;
	};

	return lserrNone;
}

/* W A  F I N D  N E X T  B R E A K  S U B L I N E */
/*----------------------------------------------------------------------------
	%%Function: WaFindPrevBreakSubline
	%%Contact: antons

		Wrapper to LsForceBreakSubline () API. It makes sure that result is
		monotonous.

----------------------------------------------------------------------------*/
LSERR WaFindPrevBreakSubline (

		PLSSUBL		plssubl, 
		LSCP		cpTruncate,
		long		urColumnMax,
		BOOL		* pfSuccessful, 
		LSCP		* pcpBreak,
		POBJDIM		pobjdimSubline )
{
	BRKPOS brkpos;
	LSCP cpTruncateLoop;

	LSERR lserr = LsFindPrevBreakSubline ( plssubl, 
										   TRUE,
										   cpTruncate, 
										   urColumnMax, 
										   pfSuccessful, 
										   pcpBreak, 
										   pobjdimSubline,
										   & brkpos );
	if (lserr != lserrNone) return lserr;

	if (! *pfSuccessful) return lserrNone; 

	/* Successful => check monotonous and break "after"*/

	cpTruncateLoop = cpTruncate;

	while (brkpos == brkposAfterLastDnode || *pcpBreak > cpTruncate)
		{

		/*	Break is to the right from truncation point or 
			after the subline. Have to try another Prev Break 
		*/

		/* REVIEW (antons): Can I ever repeat this loop more then once? */

		cpTruncateLoop --;

		lserr = LsFindPrevBreakSubline ( plssubl,
										 TRUE, 
										 cpTruncateLoop,
										 urColumnMax,
										 pfSuccessful,
										 pcpBreak,
										 pobjdimSubline,
										 & brkpos );
		if (! *pfSuccessful) return lserrNone;

		};

	if (brkpos == brkposBeforeFirstDnode) 
		{
		*pfSuccessful = FALSE;
		return lserrNone;
		};

	Assert (*pfSuccessful);
	Assert (brkpos == brkposInside);
	Assert (*pcpBreak <= cpTruncate);

	return lserrNone;
}

/* W A  F O R C E  B R E A K  S U B L I N E */
/*----------------------------------------------------------------------------
	%%Function: WaForceForceBreakSubline
	%%Contact: antons

		Wrapper to LsForceBreakSubline () API.

----------------------------------------------------------------------------*/
LSERR WaForceBreakSubline ( PLSSUBL plssubl, 
						    LSCP	cpTruncate, 
						    long	dur, 
						    LSCP	* cpEnd, 
						    BRKPOS	* pbrkpos,
						    POBJDIM	pobjdim )
{
	LSERR	lserr;

	lserr = LsForceBreakSubline ( plssubl, TRUE, cpTruncate, dur, cpEnd, pobjdim,
								  pbrkpos );
	return lserr;
}

/* W A  D E S T R O Y  S U B L I N E  */
/*----------------------------------------------------------------------------
	%%Function: WaDestroySubline
	%%Contact: antons

		Wrapper to LsDestroySubline () API.

----------------------------------------------------------------------------*/
LSERR WaDestroySubline (PLSSUBL plssubl)
{
	if (plssubl != NULL) return LsDestroySubline (plssubl);
	else
		return lserrNone;
}


/* W A  M A T C H  P R E S  S U B L I N E   */
/*----------------------------------------------------------------------------
	%%Function: WaMatchPresSubline
	%%Contact: antons

		Wrapper to LsMatchPresSubline () API.

----------------------------------------------------------------------------*/
LSERR WaMatchPresSubline (PLSSUBL plssubl, long *pdup)
{
	LSERR lserr;
	BOOL fDone;
	LSTFLOW lstflowUnused;

	lserr = LssbFDonePresSubline (plssubl, &fDone);
	if (lserr != lserrNone) return lserr;

	if (!fDone)	lserr = LsMatchPresSubline (plssubl);
	if (lserr != lserrNone) return lserr; /* ;-) */

	lserr = LssbGetDupSubline (plssubl, &lstflowUnused, pdup);

	return lserr;
}


/* W A  E X P A N D  S U B L I N E  */
/*----------------------------------------------------------------------------
	%%Function: WaExpandSubline
	%%Contact: antons

		Wrapper to LsExpandSubline () API.

----------------------------------------------------------------------------*/
LSERR WaExpandSubline ( PLSSUBL	plssubl, 
					    LSKJUST	lskjust, 
					    long	dupExpand, 
					    long	* pdupSubline )
{
	LSERR lserr;
	LSTFLOW lstflowUnused;

	Unreferenced (dupExpand);
	Unreferenced (lskjust);

	lserr = LsExpandSubline (plssubl, lskjust, dupExpand);
	if (lserr != lserrNone) return lserr;

	lserr = LssbGetDupSubline (plssubl, &lstflowUnused, pdupSubline);
	return lserr;
}


/* S E T  B R E A K  W S U B L I N E  */
/*----------------------------------------------------------------------------
	%%Function: SetBreakWSubline
	%%Contact: antons

		Wrapper to LsSetBreakSubline () API for wsubline. Procedure changes
		objdim and cpLim of wsubline.

----------------------------------------------------------------------------*/

static LSERR SetBreakWSubline (
							   
		PWSUBLINE	pwsubline,		/* (IN): Subline to set break */
		BRKKIND		brkkind,		/* (IN): Kind of break to set */
		LSCP		cpLimBreak,		/* (IN): Cp-lim of the broken subline */
		POBJDIM		pobjdimBreak,	/* (IN): Dimensions of the broken subline */
		PWBRKARRAY	pwbrkarray)		/* (OUT): Array of break records */
{
	LSERR lserr;

	lserr = LsSetBreakSubline ( pwsubline->plssubl,
								brkkind,
								pwbrkarray->nBreakRecMax,
								pwbrkarray->rgBreakRec,
								& pwbrkarray->nBreakRec );

	pwsubline->objdim = * pobjdimBreak;
	pwsubline->cpLim = cpLimBreak;	

	#ifdef DEBUG 
	
		/* Check that pobjdimBreak contains correct dimensions of the broken subline */
		{ 
		OBJDIM objdimSubline;
		LSTFLOW lstflowSubline;

		lserr = LssbGetObjDimSubline (pwsubline->plssubl, &lstflowSubline, &objdimSubline);
		if (lserr != lserrNone) return lserr;

		Assert (memcmp (&objdimSubline, pobjdimBreak, sizeof(OBJDIM)) == 0);
		}

	#endif // DEBUG

	return lserr;
}


/* C L E A R  ... */
/*----------------------------------------------------------------------------
	%%Function: Clear...
	%%Contact: antons

		Set of procedures to clear all references from different warichu 
		data structures.
		
----------------------------------------------------------------------------*/

#define ClearWSubline(pwsubline) (pwsubline)->plssubl = NULL;

#define ClearWBrkArray(pwbrkarray) (pwbrkarray)->rgBreakRec = NULL;

#define ClearWBrace(pwbrace) (pwbrace)->plssubl = NULL;

#define ClearWWhole(pwwhole) (pwwhole)->plssubl = NULL;

static void ClearWLayout (PWLAYOUT pwlayout)
{
	ClearWSubline (&pwlayout->wsubline1);
	ClearWSubline (&pwlayout->wsubline2);
}

#define FWLayoutValid(pwlayout) ((pwlayout)->wsubline1.plssubl != NULL)
#define InvalidateWLayout(pwlayout) (pwlayout)->wsubline1.plssubl = NULL;

/* REVIEW (antons): Maybe we should have more clean def of "invalid" wlayout? */

/* Note: I do not have ClearDobj () because Warichu Dobj gets cleaned in NewDobj */



/* N E W  W B R K  A R R A Y  C O P Y */
/*----------------------------------------------------------------------------
	%%Function: NewWBrkArrayCopy
	%%Contact: antons

		Copy constructor for WBrkArray. Receives array of break records to 
		store in WBrkArray structure. Important: There is another constructor
		of WBrkArray so any change here may require adjusting of another 
		procedure.		
	
----------------------------------------------------------------------------*/

static LSERR NewWBrkArrayCopy (

		PDOBJ 		pdobj, 				/* (IN):  Warichu Dobj */
		DWORD		nBreakRec,			/* (IN):  Number of break records in array */
		const BREAKREC	
					* rgBreakRec,		/* (IN):  Array of break records */
		PWBRKARRAY  pwbrkarray )		/* (OUT): Initialized (allocated) structure */
{
	PILSOBJ pilsobj = pdobj->pilsobj;

	if (nBreakRec != 0)
		{
		pwbrkarray->rgBreakRec = AllocateMemory (pilsobj, nBreakRec * sizeof(BREAKREC));
		if (pwbrkarray->rgBreakRec == NULL) 
			{
			return lserrOutOfMemory;
			};

		pwbrkarray->nBreakRecMax = nBreakRec;
		pwbrkarray->nBreakRec = nBreakRec;
		/* Copy contents of the input array to the WBrkArray data structure */
		memcpy (pwbrkarray->rgBreakRec, rgBreakRec, nBreakRec * sizeof(BREAKREC));
		}
	else
		{
		/* nBreakRec == 0 */
		pwbrkarray->rgBreakRec = NULL;
		pwbrkarray->nBreakRecMax = 0;
		pwbrkarray->nBreakRec = 0;
		};

	return lserrNone;
}
		

/* N E W  W B R K  A R R A Y */
/*----------------------------------------------------------------------------
	%%Function: NewWBreakArray
	%%Contact: antons

		Constructor for WBrkArray. Allocate number of break records according
		to LsdnGetFormatDepth (...). Important: There is another constructor
		of WBrkArray so any change here may require adjusting of another procedure.
	
----------------------------------------------------------------------------*/

static LSERR NewWBrkArray (

		PDOBJ 		pdobj, 				/* (IN):  Warichu Dobj */
		PWBRKARRAY	pwbrarray )			/* (OUT): Initialized (allocated) structure */
{
	LSERR lserr;
	PILSOBJ pilsobj = pdobj->pilsobj;
	
	DWORD nBreakRecMax;

	lserr = LsdnGetFormatDepth (pilsobj->plsc, & nBreakRecMax);
	if (lserr != lserrNone) 
		{
		pwbrarray->rgBreakRec = NULL;
		return lserr;
		};

	pwbrarray->rgBreakRec = AllocateMemory (pilsobj, nBreakRecMax * sizeof(BREAKREC));

	if (pwbrarray->rgBreakRec == NULL) return lserrOutOfMemory;

	pwbrarray->nBreakRecMax = nBreakRecMax;
	pwbrarray->nBreakRec = 0; /* Initialization - no b.r. */

	return lserrNone;
}
		


/* D E S T R O Y  W B R K  A R R A Y  */
/*----------------------------------------------------------------------------
	%%Function: DestroyWBrkArray
	%%Contact: antons

		Destroy WBRKARRAY structure.
	
----------------------------------------------------------------------------*/

static void DestroyWBrkArray (PDOBJ pdobj, PWBRKARRAY pwbrkarray)
{
	PILSOBJ pilsobj = pdobj->pilsobj;

	if (pwbrkarray->rgBreakRec != NULL)
		{
		FreeMemory (pilsobj, pwbrkarray->rgBreakRec);
		pwbrkarray->rgBreakRec = NULL;
		};
}		
		

/* D E S T R O Y  W L A Y O U T  */
/*----------------------------------------------------------------------------
	%%Function: Destroywlayout
	%%Contact: antons

		Destroy sublines stored in the layout record

----------------------------------------------------------------------------*/

static LSERR DestroyWLayout (PWLAYOUT pwlayout)
{
	LSERR lserr1, lserr2;

	lserr1 = WaDestroySubline (pwlayout->wsubline1.plssubl);
	lserr2 = WaDestroySubline (pwlayout->wsubline2.plssubl);

	ClearWLayout (pwlayout);

	if (lserr1 != lserrNone) return lserr1;
	else return lserr2;
}


/* N E W  D O B J */
/*----------------------------------------------------------------------------
	%%Function: NewDobj
	%%Contact: antons

		Allocate new Dobj and initialize it.

----------------------------------------------------------------------------*/

static LSERR NewDobj (

	PILSOBJ		pilsobj,			/* (IN): Ilsobj for object */
	PLSDNODE	plsdnTop,			/* (IN): Parent Dnode */
	LSCP		cpStart,			/* (IN): Cp-start of the Warichu */
	LSCP		cpStartObj,			/* (IN): Cp-start from break record if fResumed */
	BOOL		fResumed,			/* (IN): FormatResume? */
	DWORD		nBreakRec,			/* (IN): fResumed => size of the break records array */
	const BREAKREC 
				* rgBreakRec,		/* (IN): fResumed => array of break records */
	LSTFLOW		lstflowParent,		/* (IN): Lstflow of the parent subline */
	PDOBJ		*ppdobj)			/* (OUT): allocated dobj */
{
	LSERR lserr;
	PDOBJ pdobj = AllocateMemory (pilsobj, sizeof(DOBJ));

	if (pdobj == NULL) 
		{
		*ppdobj = NULL;
		return lserrOutOfMemory;
		};

	#ifdef DEBUG 
	Undefined (pdobj); /* Put some garbage into all dobj bytes */
	#endif 

	pdobj->cpStart = cpStart;
	pdobj->cpStartObj = cpStartObj;

	pdobj->pilsobj = pilsobj;
	pdobj->plsdnTop = plsdnTop;
	pdobj->fResumed = fResumed;

	pdobj->lstflowParent = lstflowParent;

	ClearWLayout (&pdobj->wlayout);

	ClearWLayout (&pdobj->wlayoutBreak [0]); /* prev */
	ClearWLayout (&pdobj->wlayoutBreak [1]); /* next */
	ClearWLayout (&pdobj->wlayoutBreak [2]); /* force */

	ClearWLayout (&pdobj->wlayoutTruncate); /* OPT: Layout after truncation */

	Assert (NBreaksToSave == 3);

	pdobj->wbreaktype [0] = wbreaktypeInvalid; /* prev */
	pdobj->wbreaktype [1] = wbreaktypeInvalid; /* next */
	pdobj->wbreaktype [2] = wbreaktypeInvalid; /* force */

	ClearWBrace (&pdobj->wbraceOpen);
	ClearWBrace (&pdobj->wbraceClose);
	ClearWWhole (&pdobj->wwhole);

	*ppdobj = pdobj;

	if (fResumed)
		{
		/* RESUMED => Allocate array of break records in wwhole & store there rgBreakRec */

		lserr = NewWBrkArrayCopy (pdobj, nBreakRec, rgBreakRec, &pdobj->wbrkarrayAtStart);
		if (lserr != lserrNone) return lserr;
		}
	else
		{
		/* ! RESUMED => Allocate 0 break records */

		lserr = NewWBrkArrayCopy (pdobj, 0, NULL, &pdobj->wbrkarrayAtStart);
		if (lserr != lserrNone) return lserr;

		/*	Note: even if ! Resumed, I will use Resumed formatting just because
			I do not want to see at fResumed each time I format subline */
		};

	return lserrNone;
}


/* D E S T R O Y  D O B J */
/*----------------------------------------------------------------------------
	%%Function: DestroyDobj
	%%Contact: antons

		Release all resources associated with dobj for Warichu.
	
----------------------------------------------------------------------------*/

static LSERR DestroyDobj (PDOBJ pdobj)
{
	LSERR rglserr [8];
	int i;

	rglserr [0] = WaDestroySubline (pdobj->wbraceOpen.plssubl);
	rglserr [1] = WaDestroySubline (pdobj->wbraceClose.plssubl);
	rglserr [2] = DestroyWLayout (&pdobj->wlayout);
	rglserr [3] = DestroyWLayout (&pdobj->wlayoutBreak [0]);
	rglserr [4] = DestroyWLayout (&pdobj->wlayoutBreak [1]);
	rglserr [5] = DestroyWLayout (&pdobj->wlayoutBreak [2]);
	rglserr [6] = WaDestroySubline (pdobj->wwhole.plssubl);
	rglserr [7] = DestroyWLayout (&pdobj->wlayoutTruncate);

	DestroyWBrkArray (pdobj, &pdobj->wbrkarrayAtStart);

	FreeMemory (pdobj->pilsobj, pdobj);

	/* REVIEW (antons): return last error instead of first? */
	for (i = 0; i < 8; i++)
		{
		if (rglserr [i] != lserrNone) return rglserr [i];
		};

	return lserrNone;
}


/* F O R M A T  B R A C E  O F  W A R I C H U */
/*----------------------------------------------------------------------------
	%%Function: FormatBraceOfWarichu
	%%Contact: antons

		Create a line for beginning or ending bracket for Warichu.

----------------------------------------------------------------------------*/

typedef enum wbracekind {wbracekindOpen, wbracekindClose} WBRACEKIND;

static LSERR FormatBraceOfWarichu (

	PDOBJ		pdobj,				/* (IN): Warichu Dobj */
	LSCP		cpFirst,			/* (IN): Cp to start formatting */
	WBRACEKIND	wbracekind,			/* (IN): Open or Close */

	WBRACE		*wbrace)			/* (OUT): Brace data structure */

{
	LSERR	lserr;
	LSCP	cpLimSubline;
	FMTRES	fmtres;

	LSESC	* plsEscape; 

	Assert (wbracekind == wbracekindOpen || wbracekind == wbracekindClose);

	plsEscape = ( wbracekind == wbracekindOpen ? &pdobj->pilsobj->lsescBraceOpen
											   : &pdobj->pilsobj->lsescBraceClose );

	lserr = FormatLine( pdobj->pilsobj->plsc, 
						cpFirst, 
						LONG_MAX, 
						pdobj->lstflowParent, 
						& wbrace->plssubl, 
						1, 
						plsEscape,
						& wbrace->objdim, 
						& cpLimSubline, 
						NULL, 
						NULL, 
						& fmtres );

	if (lserr != lserrNone) return lserr;

	Assert (fmtres == fmtrCompletedRun); /* Hit esc character */

	wbrace->cpFirst = cpFirst;
	wbrace->cpLim = cpLimSubline;
	wbrace->cpLimAfterEsc = cpLimSubline + 1; /* Skip 1 esc character */

	return lserrNone;
}


/* F O R M A T  W W H O L E  S U B L I N E */
/*----------------------------------------------------------------------------
	%%Function: FormatWWholeSubline
	%%Contact: antons

		Formats the whole subline of Warichu (field "wwhole" in DOBJ).		

----------------------------------------------------------------------------*/
static LSERR FormatWWholeSubline (
								 
		PDOBJ			pdobj,		 	/* (IN):  Warichu Dobj */
		LSCP			cpFirst,	 	/* (IN):  Where to start formatting */
		long			urColumnMax, 	/* (IN):  RM to limit formatting */
		PWBRKARRAY		pwbrkarrayAtStart,
										/* (IN):  array of break records at wwhole start */
		PWWHOLE			pwwhole )	 	/* (OUT): Strucure with the whole subline */
{
	LSERR	lserr;
	LSCP	cpLimSubline;
	FMTRES	fmtres;

	ClearWWhole (pwwhole); /* For the case of error */

	Assert (pdobj->fResumed || (pdobj->wbrkarrayAtStart.nBreakRec == 0));

	lserr = FormatResumedLine ( 

						 pdobj->pilsobj->plsc, 
						 cpFirst, 
						 urColumnMax, 
						 pdobj->lstflowParent, 
						 & pwwhole->plssubl,
						 1, 
						 & pdobj->pilsobj->lsescText, 
						 & pwwhole->objdim,
						 & cpLimSubline,
						 NULL,
						 NULL,
						 & fmtres,
						 pwbrkarrayAtStart->rgBreakRec,
						 pwbrkarrayAtStart->nBreakRec );

	if (lserr != lserrNone) return lserr;

	Assert (pwwhole->plssubl != NULL);

	pwwhole->cpFirst = cpFirst;
	pwwhole->cpLim = cpLimSubline;

	pwwhole->urColumnMax = urColumnMax;

	Assert (fmtres == fmtrCompletedRun || fmtres == fmtrExceededMargin);

	if (fmtres == fmtrCompletedRun)
		{
		/* Formatting stopped at ESC character */

		pwwhole->fFinished = TRUE;
		pwwhole->cpLimAfterEsc = cpLimSubline + 1;

		Undefined (&pwwhole->cpTruncate);
		}
	else
		{
		/* Formatting stopped because of Exceeding RM */

		pwwhole->fFinished = FALSE;

		lserr = LsTruncateSubline (pwwhole->plssubl, urColumnMax, & pwwhole->cpTruncate);

		if (lserr != lserrNone)
			{
			WaDestroySubline (pwwhole->plssubl); /* Do not need to check error code */
			pwwhole->plssubl = NULL;
			return lserr;
			};

		Undefined (&pwwhole->cpLimAfterEsc);
		};

	pwwhole->fJisRangeKnown = FALSE;

	return lserrNone;
}


/* F O R M A T  W S U B L I N E  U N T I L  C P  B R E A K */
/*----------------------------------------------------------------------------
	%%Function: FormatWSublineUntilCpBreak
	%%Contact: antons

		Format subline until known break opportunity.

----------------------------------------------------------------------------*/
static LSERR FormatWSublineUntilCpBreak (

		PDOBJ		pdobj,				/* (IN): Warichu Dobj */
		LSCP		cpFirst,			/* (IN): Cp to start formatting */
		PWBRKARRAY  pwbrkArray,			/* (IN): Break records at start */
		LSCP		cpBreak,			/* (IN): Cp-break to find */
		long		urFormatEstimate,	/* (IN): Estimated RM for formatting */
		long		urTruncateEstimate,	/* (IN): Estimated RM for truncation */
		BOOL		* pfSuccessful,		/* (OUT): Did we find it? */
		WSUBLINE	* pwsubl,			/* (OUT): Warichu subline if found */
		OBJDIM		* pobjdimBreak,		/* (OUT): Dimensions of the break */
		BRKKIND		* pbrkkind )		/* (OUT): Kind of break to set in the subline */
{
	LSERR lserr;
	LSCP cpLimSubline;
	OBJDIM objdimSubline;
	OBJDIM objdimBreak;
	PLSSUBL plssubl;
	FMTRES fmtres;
	BOOL fContinue;
	LSCP cpTruncate;

	long urFormatCurrent;

	Assert (urFormatEstimate >= urTruncateEstimate);

	pwsubl->plssubl = NULL; /* in case of error */

	/* Loop initialization */

	urFormatCurrent = urFormatEstimate;
	fContinue = TRUE;

	/* Loop until we have fetched enough */

	/* REVIEW (antons): do-while instead of regular while to avoid
						VC++ 6.0 warning message */

	do /* while (fContinue) at the end */
		{
		lserr = FormatResumedLine ( pdobj->pilsobj->plsc,
									cpFirst,
									urFormatCurrent,
									pdobj->lstflowParent,
									& plssubl,
									1,
									& pdobj->pilsobj->lsescText,
									& objdimSubline,
									& cpLimSubline,
									NULL, 
									NULL,
									& fmtres,
									pwbrkArray->rgBreakRec,
									pwbrkArray->nBreakRec );

		if (lserr != lserrNone) return lserr;

		Assert (fmtres == fmtrCompletedRun || fmtres == fmtrExceededMargin);

		/*	REVIEW (antons): here I wrote "<=" because currently in our
			definition, break "after" subline is not a break opportunity.
			This place need to verifyed more carefully */

		if (cpLimSubline <= cpBreak)
			{
			/* Did not fetch enough CPs, try again with bigger RM */

			Assert (fmtres == fmtrExceededMargin);

			lserr = LsDestroySubline (plssubl);

			if (lserr != lserrNone) return lserr;

			/* REVIEW (antons): Is coefficient 1.5 OK? */

			/* REVIEW (antons): The following Assert is against infinite loop */
			Assert (urFormatCurrent < ADDLongSafe (urFormatCurrent, urFormatCurrent / 2));

			urFormatCurrent = ADDLongSafe (urFormatCurrent, urFormatCurrent / 2);
			}
		else
			{
			fContinue = FALSE;
			};

		} while (fContinue);

	Assert (cpBreak < cpLimSubline); 

	lserr = LsTruncateSubline (plssubl, urTruncateEstimate, & cpTruncate);

	if (lserr != lserrNone)
		{
		WaDestroySubline (plssubl); return lserr;
		};

	/* Going prev and next break to find required break point */

	if (cpTruncate < cpBreak)
		{
		/* Go forward with Next Break */

		LSCP cpLastBreak = cpTruncate;
		BOOL fBreakSuccessful = TRUE;

		do /* while (cpLastBreak < cpBreak && fBreakSuccessful) */
			{
			lserr = WaFindNextBreakSubline ( plssubl, cpLastBreak,
											LONG_MAX,
											& fBreakSuccessful,
											& cpLastBreak,
											& objdimBreak );

			if (lserr != lserrNone)
				{
				WaDestroySubline (plssubl); return lserr;
				};

			} while (cpLastBreak < cpBreak && fBreakSuccessful);

		if (! fBreakSuccessful || cpLastBreak > cpBreak)
			{
			lserr = LsDestroySubline (plssubl);

			if (lserr != lserrNone) return lserr;

			*pfSuccessful = FALSE;
			}
		else 
			{
			Assert (cpLastBreak == cpBreak && fBreakSuccessful);

			pwsubl->plssubl = plssubl;
			pwsubl->cpFirst = cpFirst;
			pwsubl->cpLim = cpBreak;
			pwsubl->objdim = objdimSubline;

			*pobjdimBreak = objdimBreak;
			*pfSuccessful = TRUE;

			*pbrkkind = brkkindNext;
			};

		} 

	else /* cpTruncate >= cpBreak */
		{

		/* Go backward with Prev Break */

		LSCP cpLastBreak = cpTruncate + 1;
		BOOL fBreakSuccessful = TRUE;

		do /* while (cpBreak < cpLastBreak && fBreakSuccessful) at the end */
			{
			lserr = WaFindPrevBreakSubline ( plssubl, cpLastBreak - 1,
											LONG_MAX,
											& fBreakSuccessful,
											& cpLastBreak,
											& objdimBreak );

			if (lserr != lserrNone)
				{
				WaDestroySubline (plssubl); return lserr;
				};

			} while (cpBreak < cpLastBreak && fBreakSuccessful);
			
		if (! fBreakSuccessful || cpBreak > cpLastBreak)
			{
			lserr = LsDestroySubline (plssubl);

			if (lserr != lserrNone) return lserr;

			*pfSuccessful = FALSE;
			}
		else 
			{
			Assert (cpLastBreak == cpBreak && fBreakSuccessful);

			pwsubl->plssubl = plssubl;
			pwsubl->cpFirst = cpFirst;
			pwsubl->cpLim = cpBreak;
			pwsubl->objdim = objdimSubline;

			*pobjdimBreak = objdimBreak;
			*pbrkkind = brkkindPrev;

			*pfSuccessful = TRUE;

			};

		}; /* End If (cpTruncate < cpBreak) Then ... Else ... */

	return lserrNone;

} /* FormatWSublineUntilCpBreak */



/* F O R M A T  W S U B L I N E  U N T I L  R M  */
/*----------------------------------------------------------------------------
	%%Function: FormatWSublineUntilRM
	%%Contact: antons

		Format until given right margin - wrapper to FormatLine ()

----------------------------------------------------------------------------*/
static LSERR FormatWSublineUntilRM (
								 
			PDOBJ		pdobj,			 /* (IN): Warichu Dobj */
			LSCP		cpFirst,		 /* (IN): Where to start formatting */
			long		urColumnMax,	 /* (IN): Right margin to format to */
			PWBRKARRAY	pwbrkarray,		 /* (IN): Array of break rec at subline start */
			BOOL		* fFinished,	 /* (OUT): Subline finished at Escape? */
			WSUBLINE	* pwsubl )		 /* (OUT): Formatted WSubline */
{
	LSERR lserr;
	FMTRES fmtr;

	lserr = FormatResumedLine ( pdobj->pilsobj->plsc, 
								cpFirst,
						 		urColumnMax, 
						 		pdobj->lstflowParent, 
						 		& pwsubl->plssubl,	/* out */
						 		1,
						 		& pdobj->pilsobj->lsescText, 
						 		& pwsubl->objdim, 	/* out */
						 		& pwsubl->cpLim,	/* out */
						 		NULL,
						 		NULL,
						 		& fmtr,
						 		pwbrkarray->rgBreakRec,
						 		pwbrkarray->nBreakRec );
	if (lserr != lserrNone) return lserr;

	*fFinished = (fmtr == fmtrCompletedRun);	/* out */
	pwsubl->cpFirst = cpFirst; 					/* out */
 	
	Assert (fmtr == fmtrCompletedRun || fmtr == fmtrExceededMargin);
	return lserrNone;
}
	

/* F O R M A T  W S U B L I N E  U N T I L  E S C A P E */
/*----------------------------------------------------------------------------
	%%Function: FormatWSublineUntilEscape
	%%Contact: antons

		Format subline until escape character - wrapper to FormatLine ()

----------------------------------------------------------------------------*/
static LSERR FormatWSublineUntilEscape (
								 
			PDOBJ		pdobj,			 /* (IN): Warichu Dobj */
			LSCP		cpFirst,		 /* (IN): Where to start formatting */
			PWBRKARRAY	pwbrkarray,		 /* (IN): Array of break rec at subline start */
			WSUBLINE	* pwsubl,		 /* (OUT): Formatted WSubline */
			long		* cpLimAfterEsc) /* (OUT): CpLim after Esc characters */
{
	FMTRES fmtres;
	LSERR lserr = FormatResumedLine ( pdobj->pilsobj->plsc, 
									  cpFirst,
						 			  LONG_MAX, /* urColumnMax */
							 		  pdobj->lstflowParent, 
						 		      & pwsubl->plssubl,	/* out */
						 			  1,
						 			  & pdobj->pilsobj->lsescText, 
						 		      & pwsubl->objdim,		/* out */
						 			  & pwsubl->cpLim,		/* out */
						 			  NULL,
						 			  NULL,
						 		      & fmtres,
						 			  pwbrkarray->rgBreakRec,
						 			  pwbrkarray->nBreakRec );
	if (lserr != lserrNone) return lserr;

	* cpLimAfterEsc = pwsubl->cpLim + 1;	/* out */
	pwsubl->cpFirst = cpFirst;				/* out */

	Assert (fmtres == fmtrCompletedRun);
	return lserrNone;
}


/* C H O O S E  N E A R E S T  B R E A K */
/*----------------------------------------------------------------------------
	%%Function: ChooseNearestBreak
	%%Contact: antons

		Choose nearest between prev and next breaks from the given 
		truncation Ur. If prev and next are on the same distance =>
		we choose next. 

----------------------------------------------------------------------------*/

static LSERR ChooseNearestBreak (

		PLSSUBL		plssubl,		/* (IN): Subline to find break */
		long		urTruncate2,	/* (IN): Truncation point multiplied by 2
									/*       (we *2 to avoid rounding erros) */
		LSCP		cpLookBefore,	/* (IN): Result must be before this cp */
		BOOL		*pfSuccessful,	/* (OUT): Did we find any break ? */
		LSCP		*pcpBreak,		/* (OUT): Cp of break */
		OBJDIM		*pobjdimBreak,	/* (OUT): Dimensions of the broken subline */
		BRKKIND		*pbrkkind)		/* (OUT): Break to set in the subline */
{
	LSERR lserr;
	LSCP cpTruncate;

	OBJDIM objdimNext, objdimPrev;
	LSCP cpBreakNext, cpBreakPrev;
	BOOL fSuccessfulNext, fSuccessfulPrev;

	lserr = LsTruncateSubline (plssubl, urTruncate2 / 2, & cpTruncate);

	if (lserr != lserrNone) return lserr;

	lserr = WaFindNextBreakSubline ( plssubl, cpTruncate, LONG_MAX,
									& fSuccessfulNext, & cpBreakNext,
									& objdimNext );
	if (lserr != lserrNone) return lserr;

	lserr = WaFindPrevBreakSubline ( plssubl, cpTruncate, LONG_MAX,
									& fSuccessfulPrev, & cpBreakPrev,
									& objdimPrev );
	if (lserr != lserrNone) return lserr;

	fSuccessfulNext = fSuccessfulNext && cpBreakNext <= cpLookBefore;
	fSuccessfulPrev = fSuccessfulPrev && cpBreakPrev <= cpLookBefore;
	
	if (fSuccessfulNext && 
		(!fSuccessfulPrev || abs (objdimNext.dur * 2 - urTruncate2) <= 
							 abs (objdimPrev.dur * 2 - urTruncate2) ) )
		{
		/* CHOOSING NEXT */

		* pfSuccessful = TRUE;

		* pcpBreak = cpBreakNext;
		* pobjdimBreak = objdimNext;	
		* pbrkkind = brkkindNext;
		}
	else if (fSuccessfulPrev)
		{
		/* CHOOSING PREV */

		* pfSuccessful = TRUE;

		* pcpBreak = cpBreakPrev;
		* pobjdimBreak = objdimPrev;
		* pbrkkind = brkkindPrev;
		}
	else
		{	
		/* Did not find any ;-( */

		* pfSuccessful = FALSE;
		};

	return lserrNone;

} /* ChooseNearestBreak */


/* G E T  D U R  B R A C E S */
/*----------------------------------------------------------------------------
	%%Function: GetDurBraces
	%%Contact: antons

	
----------------------------------------------------------------------------*/

#define FOpenBraceInWLayout(pdobj,pwlayout) (! (pdobj)->fResumed)

#define FCloseBraceInWLayout(pdobj,pwlayout) (! (pwlayout)->fBroken)

static void GetDurBraces (

			PDOBJ	pdobj,			/* (IN):  Warichu DOBJ */
			BOOL	fBroken,		/* (IN):  Is it broken? */
			BOOL	*pfOpenPresent,	/* (OUT): Open brace present */
		    long	*pdurOpen,		/* (OUT): dur of the open brace, 0 if no brace */
			BOOL	*pfClosePresent,/* (OUT): Close brace present */
			long	*pdurClose)		/* (OUT): dur of the close brace 0 if no brace */
{
	if (! pdobj->fResumed)
		{
		Assert (pdobj->wbraceOpen.plssubl != NULL);

		* pdurOpen = pdobj->wbraceOpen.objdim.dur;
		* pfOpenPresent = TRUE;
		}
	else
		{
		* pdurOpen = 0;
		* pfOpenPresent = FALSE;
		};

	if (! fBroken)
		{
		Assert (pdobj->wbraceClose.plssubl != NULL);

		* pdurClose = pdobj->wbraceClose.objdim.dur;
		* pfClosePresent = TRUE;
		}
	else
		{
		* pdurClose = 0;
		* pfClosePresent = FALSE;
		};

} /* CalcDurBraces */


/* F I N I S H  O B J D I M  W L A Y O U T */
/*----------------------------------------------------------------------------
	%%Function: FinishObjDimWLayout
	%%Contact: antons

		Complete calculations of the Warichu layout. This procedure
		fills WLAYOUT.wdim data structure. The calculations are based on
		the dimensions of Warichu sublines stored in WLAYOUT and the result
		of GetWarichuInfo callback.

----------------------------------------------------------------------------*/
static LSERR FinishObjDimWLayout (

			 PDOBJ		pdobj,		/* (IN): Warichu DOBJ */
			 WLAYOUT	* pwlayout)	/* (IN): Break record (layout) of the Warichu */
{
	LSERR	lserr;
	OBJDIM	objdimAll;
	long	dvpDescentReserved;
	long	durOpen, durClose;
	BOOL	fOpenBrace, fCloseBrace;

	PILSOBJ pilsobj = pdobj->pilsobj;

	Assert (pwlayout->wsubline1.plssubl != NULL);

	lserr = pilsobj->warichucbk.pfnGetWarichuInfo ( pilsobj->pols,
													pdobj->cpStartObj, 
													pdobj->lstflowParent,
													& pwlayout->wsubline1.objdim, 
													& pwlayout->wsubline2.objdim, 
													& objdimAll.heightsRef, 
													& objdimAll.heightsPres,
													& dvpDescentReserved );
	if (lserr != lserrNone) return lserr;

	GetDurBraces (pdobj, pwlayout->fBroken, 
				  &fOpenBrace, &durOpen, &fCloseBrace, &durClose);

	objdimAll.dur = durOpen + durClose +
					max (pwlayout->wsubline1.objdim.dur, pwlayout->wsubline2.objdim.dur);

	pwlayout->wdim.objdimAll = objdimAll;
	pwlayout->wdim.dvpDescentReserved = dvpDescentReserved;

	return lserrNone;
}
 	

/* F I N I S H  W L A Y O U T  S I N G L E  L I N E  */
/*----------------------------------------------------------------------------
	%%Function: FinishWLayoutSingleLine
	%%Contact: antons

		Finishes layout of warichu as it were only one line (of course, not broken)

----------------------------------------------------------------------------*/
static LSERR FinishWLayoutSingleLine (PDOBJ pdobj, PWLAYOUT pwlayout)
{
	pwlayout->fBroken = FALSE;
	pwlayout->wsubline2.plssubl = NULL; 

	/* REVIEW (antons): Does anybody use cpFirst & cpLim I set here? */
	pwlayout->wsubline2.cpFirst = pwlayout->wsubline1.cpLim;
	pwlayout->wsubline2.cpLim = pwlayout->wsubline1.cpLim;

	ZeroObjDim (& pwlayout->wsubline2.objdim);
	return FinishObjDimWLayout (pdobj, pwlayout);
}


/* P R O C E S S M O D W I D T H */
/*----------------------------------------------------------------------------
	%%Function: ProcessModWidth
	%%Contact: antons

		Ask client how much widths should be modified for lead or end
		bracket for the Warichu. Then modify the Warichu to reflect the
		change in size.
	
----------------------------------------------------------------------------*/
static LSERR ProcessModWidth (

		PDOBJ pdobj,				/* (IN): dobj */
		enum warichucharloc wloc,	/* (IN): location of mod width request */
		PLSRUN plsrun,				/* (IN): plsrun of the object */
		PLSRUN plsrunText,			/* (IN): plsrun of the preceding char */
		WCHAR wchar,				/* (IN): preceding character */
		MWCLS mwcls,				/* (IN): ModWidth class of preceding character */
		long *pdurChange)			/* (OUT): amount by which width of the preceding char is to be changed */
{
	PILSOBJ pilsobj = pdobj->pilsobj;
	LSERR lserr;
	long durWChange;

	lserr = pilsobj->warichucbk.pfnFetchWarichuWidthAdjust(pilsobj->pols,
		pdobj->cpStartObj, wloc, plsrunText, wchar, mwcls, plsrun, pdurChange,
			&durWChange);

	AssertSz(durWChange >= 0, 
		"ProcessModWidth - invalid return from FetchWidthAdjust");

	if (durWChange < 0)
		{
		durWChange = 0;
		}

	*pdurChange += durWChange;

	return lserr;
}


/* S U B M I T  W L A Y O U T  S U B L I N E S */
/*----------------------------------------------------------------------------
	%%Function: SubmitWLayoutSublines
	%%Contact: antons

		Submit sublines from the given layout for justification. We call
		it after formatting and during SetBreak.

----------------------------------------------------------------------------*/
static LSERR SubmitWLayoutSublines (PDOBJ pdobj, PWLAYOUT pwlayout)
{
	PLSSUBL rgsublSubmit [3];	/* Array of psublines to submit */
	DWORD	nSubmit;			/* Number of sublines to submit */
	LSERR	lserr;

	BOOL fOpenBrace, fCloseBrace;
	long durOpen, durClose;

	GetDurBraces (pdobj, pwlayout->fBroken, &fOpenBrace, &durOpen, &fCloseBrace, &durClose);

	nSubmit = 0;

	/* Submit open brace */

	if (fOpenBrace)
		{
		BOOL fSublineEmpty;		

		lserr = LssbFIsSublineEmpty (pdobj->wbraceOpen.plssubl, &fSublineEmpty);
		if (lserr != lserrNone) return lserr;
		
		if (! fSublineEmpty) /* Can not submit empty subline */
			{
			rgsublSubmit [nSubmit++] = pdobj->wbraceOpen.plssubl;
			}
		};

	/* Submit longest subline */

	/* REVIEW (antons): If first is empty & second is not empty but ZW,
						I do not submit neither */
	/* REVIEW (antons): Can it ever happen what I wrote before? */
 
	if (pwlayout->wsubline1.objdim.dur >= pwlayout->wsubline2.objdim.dur)
		{
		BOOL fSublineEmpty;		
		
		lserr = LssbFIsSublineEmpty (pwlayout->wsubline1.plssubl, &fSublineEmpty);
		if (lserr != lserrNone) return lserr;

		if (! fSublineEmpty) /* Can not submit empty subline */
			{
			rgsublSubmit [nSubmit++] = pwlayout->wsubline1.plssubl;
			};
		}
	else
		{
		BOOL fSublineEmpty;
		Assert (pwlayout->wsubline2.plssubl != NULL);
		
		lserr = LssbFIsSublineEmpty (pwlayout->wsubline2.plssubl, &fSublineEmpty);
		if (lserr != lserrNone) return lserr;

		if (! fSublineEmpty) /* Can not submit empty subline */
			{
			rgsublSubmit [nSubmit++] = pwlayout->wsubline2.plssubl;
			}
		};

	/* Submit closing brace */
 
	if (fCloseBrace)
		{
		BOOL fSublineEmpty;		

		lserr = LssbFIsSublineEmpty (pdobj->wbraceClose.plssubl, &fSublineEmpty);
		if (lserr != lserrNone) return lserr;
		
		if (! fSublineEmpty) /* Can not submit empty subline */
			{
			rgsublSubmit [nSubmit++] = pdobj->wbraceClose.plssubl;
			}
		};

	/* REVIEW (antons): This deletes previously submitted subline. Question: 
						should we better have additional procedure to "clear" submition?
	*/

	lserr = LsdnSubmitSublines ( pdobj->pilsobj->plsc, 
								 pdobj->plsdnTop, 
								 nSubmit, rgsublSubmit,
								 TRUE,					/* Justification */
								 FALSE,					/* Compression */
								 FALSE,					/* Display */
								 FALSE,					/* Decimal tab */
								 FALSE );				/* Trailing spaces */
	return lserr;
}


/* W A R I C H U C R E A T E I L S O B J */
/*----------------------------------------------------------------------------
	%%Function: WarichuCreateILSObj
	%%Contact: ricksa

		Create main object for Warichu handlers.
	
----------------------------------------------------------------------------*/
LSERR WINAPI WarichuCreateILSObj (

			POLS		pols,			/* (IN): client application context */
			PLSC		pclsc,			/* (IN): LS context */
			PCLSCBK		pclscbk,		/* (IN): callbacks to client application */
			DWORD		idobj,			/* (IN): id of the object */
			PILSOBJ		* ppilsobj )	/* (OUT): object ilsobj */
{
    PILSOBJ pilsobj;
	LSERR lserr;
	WARICHUINIT warichuinit;

	warichuinit.dwVersion = WARICHU_VERSION;

	/* Get initialization data */
	lserr = pclscbk->pfnGetObjectHandlerInfo(pols, idobj, &warichuinit);

	if (lserr != lserrNone)
		{
		return lserr;
		}

	/* Build ILS object */
    pilsobj = pclscbk->pfnNewPtr(pols, sizeof(*pilsobj));

	if (NULL == pilsobj) return lserrOutOfMemory;

	ZeroMemory(pilsobj, sizeof(*pilsobj));
    pilsobj->pols = pols;
	pilsobj->idobj = idobj;
    pilsobj->lscbk = *pclscbk;
	pilsobj->plsc = pclsc;
	pilsobj->lsescBraceOpen.wchFirst = warichuinit.wchEndFirstBracket;
	pilsobj->lsescBraceOpen.wchLast = warichuinit.wchEndFirstBracket;
	pilsobj->lsescText.wchFirst = warichuinit.wchEndText;
	pilsobj->lsescText.wchLast = warichuinit.wchEndText;
	pilsobj->lsescBraceClose.wchFirst = warichuinit.wchEndWarichu;
	pilsobj->lsescBraceClose.wchLast = warichuinit.wchEndWarichu;
	pilsobj->warichucbk = warichuinit.warichcbk;
	pilsobj->fContiguousFetch = warichuinit.fContiguousFetch;

	*ppilsobj = pilsobj;
	return lserrNone;
}


/* W A R I C H U D E S T R O Y I L S O B J */
/*----------------------------------------------------------------------------
	%%Function: WarichuDestroyILSObj
	%%Contact: antons

		Free all resources connected with Warichu main object.
	
----------------------------------------------------------------------------*/

LSERR WINAPI WarichuDestroyILSObj(PILSOBJ pilsobj)
{
	FreeMemory (pilsobj, pilsobj);
	return lserrNone;
}


/* W A R I C H U S E T D O C */
/*----------------------------------------------------------------------------
	%%Function: WarichuSetDoc
	%%Contact: antons

		Save the device resolution for later scaling.
	
----------------------------------------------------------------------------*/

LSERR WINAPI WarichuSetDoc(
	PILSOBJ pilsobj,			/* (IN): object ilsobj */
	PCLSDOCINF pclsdocinf)		/* (IN): initialization data of the document level */
{
	pilsobj->lsdevres = pclsdocinf->lsdevres;
	return lserrNone;
}

/* W A R I C H U  C R E A T E  L N  O B J */
/*----------------------------------------------------------------------------
	%%Function: WarichuCreateLNObj
	%%Contact: antons


----------------------------------------------------------------------------*/
LSERR WINAPI WarichuCreateLNObj (PCILSOBJ pcilsobj,	PLNOBJ *pplnobj)
{
	*pplnobj = (PLNOBJ) pcilsobj;

	return lserrNone;
}

/* W A R I C H U  D E S T R O Y  L N  O B J */
/*----------------------------------------------------------------------------
	%%Function: WarichuDestroyLNObj
	%%Contact: antons


----------------------------------------------------------------------------*/
LSERR WINAPI WarichuDestroyLNObj (PLNOBJ plnobj)				
{
	Unreferenced(plnobj);

	return lserrNone;
}


/* G E T  C P  L I M  O F  W L A Y O U T  */
/*----------------------------------------------------------------------------
	%%Function: GetCpLimOfWLayout
	%%Contact: antons

		Return cp-lim for the given Warichu layout.
	
----------------------------------------------------------------------------*/

static LSCP GetCpLimOfWLayout (PDOBJ pdobj, WLAYOUT *pwlayout)
{
	Unreferenced (pdobj);

	Assert (FWLayoutValid (pwlayout));

	if (pwlayout->fBroken)
		{
		Assert (pwlayout->wsubline2.plssubl != NULL);
		return pwlayout->wsubline2.cpLim;
		}
	else
		{
		Assert (pdobj->wbraceClose.plssubl != NULL);
		return pdobj->wbraceClose.cpLimAfterEsc;
		};
}


/* R E F O R M A T  C L O S I N G  B R A C E  F O R  W O R D 9
/*----------------------------------------------------------------------------
	%%Function: ReformatClosingBraceForWord9
	%%Contact: antons

		REVIEW (antons):

		THIS IS HACK WHICH WAS REQUESTED BY WORD 9, BECAUSE THEY
		DID NOT WANT TO FIX THEIR BUG IN CODE WHICH INSERTS BRACES 
		ON-THE-FLY. IT MUST BE REMOVED AS SOON AS POSSIBLE, BECAUSE
		IT MAY SLOWS DOWN WARICHU FORMATTING SIGNIFICANTLY.

----------------------------------------------------------------------------*/

#define min(a,b) ((a)<(b) ? (a) : (b))

LSERR ReformatClosingBraceForWord9 (PDOBJ pdobj)
{
	DWORD cwchRun;
	WCHAR * lpwchRun;
	BOOL fHidden;
	LSCHP lschp;
	PLSRUN plsrun;

	LSCP cpFetch;
	LSCP cpLimFetch;

	LSERR lserr;

	if (pdobj->pilsobj->fContiguousFetch)
		{
		if (! FWLayoutValid (&pdobj->wlayout)) return lserrNone;

		cpFetch = pdobj->wwhole.cpFirst;
		cpLimFetch = min (pdobj->wwhole.cpLim, GetCpLimOfWLayout (pdobj, &pdobj->wlayout));

		while (cpFetch < cpLimFetch)
			{
			lserr = pdobj->pilsobj->lscbk.pfnFetchRun ( pdobj->pilsobj->pols, 
									  cpFetch, & lpwchRun,  & cwchRun,
									  & fHidden, & lschp, & plsrun );
			if (lserr != lserrNone) return lserr;

			lserr = pdobj->pilsobj->lscbk.pfnReleaseRun (pdobj->pilsobj->pols, plsrun);
			if (lserr != lserrNone) return lserr;

			Assert (cwchRun > 0);
			if (cwchRun == 0) return lserrInvalidDcpFetched;
			
			cpFetch = cpFetch + cwchRun;
			};

		cpFetch = cpLimFetch;
		cpLimFetch = GetCpLimOfWLayout (pdobj, &pdobj->wlayout);

		while (cpFetch < cpLimFetch)
			{
			lserr = pdobj->pilsobj->lscbk.pfnFetchRun ( pdobj->pilsobj->pols, 
									  cpFetch, & lpwchRun,  & cwchRun,
									  & fHidden, & lschp, & plsrun );
			if (lserr != lserrNone) return lserr;

			lserr = pdobj->pilsobj->lscbk.pfnReleaseRun (pdobj->pilsobj->pols, plsrun);
			if (lserr != lserrNone) return lserr;

			Assert (cwchRun > 0);
			if (cwchRun == 0) return lserrInvalidDcpFetched;
			
			cpFetch = cpFetch + cwchRun;
			};
		
		};

	return lserrNone;
}

/* F I N D  W L A Y O U T  O F  U N B R O K E N  W A R I C H U  */
/*----------------------------------------------------------------------------
	%%Function: FindWLayoutOfUnbrokenWarichu
	%%Contact: antons

		Find layout of the Warichu which is not broken. This procedure
		returns structure WLAYOUT.
	
----------------------------------------------------------------------------*/

static LSERR FindWLayoutOfUnbrokenWarichu (PDOBJ pdobj, WLAYOUT *pwlayout)
{
	LSERR	lserr;
	BOOL	fSuccessful;
	LSCP	cpBreakFirstLine;
	OBJDIM	objdimUnused;
	OBJDIM	objdimFirstLine;
	BRKKIND brkkindUnused;
	LSCP	cpLimUnused;
	
	Assert (pdobj->wwhole.plssubl != NULL);

	/* This should not be called when wwhole was not finished */
	Assert (pdobj->wwhole.fFinished);

	ClearWLayout (pwlayout); /* For the case of error */

	if (pdobj->wwhole.objdim.dur == 0) 
		{
		/* Either empty or zero-width subline */
		/* The only thing we can do is to create single-line Warichu */

		LSCP cpLimAfterEscUnused;
		lserr = FormatWSublineUntilEscape ( pdobj, pdobj->wwhole.cpFirst, 
											& pdobj->wbrkarrayAtStart,
											& pwlayout->wsubline1, 
											& cpLimAfterEscUnused );
		if (lserr != lserrNone) return lserr;

		Assert (pwlayout->wsubline1.objdim.dur == 0);

		return FinishWLayoutSingleLine (pdobj, pwlayout);
		};

	lserr = ChooseNearestBreak ( pdobj->wwhole.plssubl, 
								 pdobj->wwhole.objdim.dur,
								 CP_MAX,
								 & fSuccessful,
								 & cpBreakFirstLine,
								 & objdimUnused,
								 & brkkindUnused );
	if (lserr != lserrNone) return lserr;

	if (! fSuccessful)
		{
		/* Not a single break in the whole Warichu line */

		LSCP cpLimAfterEscUnused;

		lserr = FormatWSublineUntilEscape ( pdobj, pdobj->wwhole.cpFirst, 
											& pdobj->wbrkarrayAtStart,
											& pwlayout->wsubline1, 
											& cpLimAfterEscUnused );
		if (lserr != lserrNone) return lserr;

		return FinishWLayoutSingleLine (pdobj, pwlayout);
		}
	else
		{
		/* Yes, we have break between lines */

		BOOL fSuccessful;
		BRKKIND brkkind;

		WBRKARRAY wbrkarray;

		lserr = FormatWSublineUntilCpBreak ( pdobj, pdobj->wwhole.cpFirst, 
									 & pdobj->wbrkarrayAtStart,
									 cpBreakFirstLine, 
									 LONG_MAX, pdobj->wwhole.objdim.dur / 2, /* REVIEW THIS ! */
									 & fSuccessful,
									 & pwlayout->wsubline1, & objdimFirstLine, & brkkind );

		if (lserr != lserrNone) return lserr;

		Assert (fSuccessful); /* Something crazy inside Warichu */

		lserr = NewWBrkArray (pdobj, &wbrkarray);

		if (lserr != lserrNone) return lserr;
		
		lserr = SetBreakWSubline (&pwlayout->wsubline1, brkkind, cpBreakFirstLine,
								  &objdimFirstLine, &wbrkarray);

		lserr = FormatWSublineUntilEscape ( pdobj, pwlayout->wsubline1.cpLim,
									   & wbrkarray, & pwlayout->wsubline2, 
								       & cpLimUnused );

		if (lserr != lserrNone) return lserr;

		DestroyWBrkArray (pdobj, &wbrkarray);
		};

	pwlayout->fBroken = FALSE; /* This warichu is not broken ;-) */

	lserr = FinishObjDimWLayout (pdobj, pwlayout);
	return lserr;
}


/* F O R M A T  W A R I C H U  C O R E  */
/*----------------------------------------------------------------------------
	%%Function: FormatWarichuCore
	%%Contact: antons

		Format Warichu Object (called from methods WarichuFmt and WarichuFmtResumt)
		
----------------------------------------------------------------------------*/
static LSERR FormatWarichuCore (

		PLNOBJ 		plnobj,			/* (IN): Warichu LNOBJ */
    	PCFMTIN 	pcfmtin,		/* (IN): Formatting input */
		BOOL		fResumed,		/* (IN): Resumed? */
		DWORD	nBreakRec,			/* (IN): fResumed => size of the break records array */
		const BREAKREC 
					* rgBreakRec,	/* (IN): fResumed => array of break records */
	    FMTRES 		* pfmtres )		/* (OUT): formatting result */
{
	LSERR	lserr;
	PILSOBJ pilsobj = (PILSOBJ) plnobj; /* They are the same */
	PDOBJ	pdobj;

	long urColumnMax  = pcfmtin->lsfgi.urColumnMax;

	/* REVIEW (antons): Can we optimize for case 0? */
	long durAvailable = max (0, pcfmtin->lsfgi.urColumnMax - pcfmtin->lsfgi.urPen);

	/* :: CREATE DOBJ WITH INITIAL OBJECT DATA */

	if (! fResumed)
		{
		/* Not Resumed */

		lserr = NewDobj ( pilsobj, 
						  pcfmtin->plsdnTop,
						  pcfmtin->lsfgi.cpFirst, 
						  pcfmtin->lsfgi.cpFirst,
						  FALSE,					/* fResumed */
						  0,
						  NULL,
						  pcfmtin->lsfgi.lstflow, 
						  & pdobj );
		}
	else
		{
		/* Resumed */

		Assert (nBreakRec > 0);
		Assert (rgBreakRec [0].idobj == pilsobj->idobj);

		lserr = NewDobj ( pilsobj, 
						  pcfmtin->plsdnTop,
						  pcfmtin->lsfgi.cpFirst, 
						  rgBreakRec [0].cpFirst,
						  TRUE,						/* fResumed */
						  nBreakRec-1,
						  & rgBreakRec [1],
						  pcfmtin->lsfgi.lstflow, 
						  & pdobj );
		};

	if (lserr != lserrNone) return lserr;

	/* :: FORMAT WARICHU OPEN BRACE IF not RESUMED*/

	if (!fResumed)
		{
		lserr = FormatBraceOfWarichu ( pdobj, pdobj->cpStart + 1 /* Skip 1 Esc */,
									   wbracekindOpen, & pdobj->wbraceOpen );
		if (lserr != lserrNone) 
			{ 
			DestroyDobj (pdobj); return lserr; 
			};
		}
	else
		pdobj->wbraceOpen.plssubl = NULL; /* No open brace */

	/* :: FORMAT THE WHOLE WARICHU LINE */

	{
		/* REVIEW (antons): Check with Igor that he is not playing with RM, because
							if he is, the following estimations of durFormatWhole are
							not correct */

		/*	To be able to check JIS rule, warichu needs to format the whole subline
			far ehough to be able to count 4 break opportunities from break-point. 
			We estimate it like

					2 * durAvailable + 2 * urColumnMax
		*/

		/* REVIEW (antons): I want to be sure that final line break does not depend on
							whatever estimations we use here */

		/* REVIEW (antons): Is that correct to return lserrUnsufficientFetch if there is
							no 4 breaks after (JIS rule) when wwhole is not finished? */

		/* REVIEW (antons): Can something like 5 * durAvailable may be better */

		long urFormatWhole = MULLongSafe (ADDLongSafe (durAvailable, urColumnMax), 2);

		LSCP cpStartFormatWhole = (fResumed ? pdobj->cpStart :
											  pdobj->wbraceOpen.cpLimAfterEsc);
		lserr = FormatWWholeSubline ( pdobj, 
									  cpStartFormatWhole,
									  urFormatWhole,
									  & pdobj->wbrkarrayAtStart,
									  & pdobj->wwhole );
		if (lserr != lserrNone) 
			{ 
			DestroyDobj (pdobj); return lserr; 
			};
	};

	/* :: CHECK IF THE WHOLE SUBLINE WAS NOT FINISHED */

	if (! pdobj->wwhole.fFinished)
		{
		/* Not finished => return fmtrExceedMargin */

		Assert (pdobj->wwhole.objdim.dur / 2 > durAvailable);

		InvalidateWLayout (&pdobj->wlayout); /* Invalidate layout */

		/* REVIEW (antons) */
		pdobj->wlayout.wdim.objdimAll = pdobj->wwhole.objdim; 
											  /* Must have correct objdim */

		/* REVIEW (antons): Check - we return dcp of the fetched range */
		/* REVIEW (antons): Check - we return objdim of the whole line */
		lserr = LsdnFinishRegular ( pilsobj->plsc,
									pdobj->wwhole.cpLim - pdobj->cpStart,
									pcfmtin->lsfrun.plsrun, 
									pcfmtin->lsfrun.plschp,
									pdobj,
									& pdobj->wwhole.objdim );

		if (lserr != lserrNone) { DestroyDobj (pdobj); return lserr; };

		* pfmtres = fmtrExceededMargin;
		return lserrNone;
		};

	/* :: FORMAT THE CLOSING BRACE */

	lserr = FormatBraceOfWarichu (pdobj, pdobj->wwhole.cpLimAfterEsc,
								  wbracekindClose, &pdobj->wbraceClose);

	if (lserr != lserrNone) { DestroyDobj (pdobj); return lserr; };

	/* :: FIND LAYOUT OF WARICHU AS IF IT IS NOT BROKEN AND FINISH FORMATTING */

	lserr = FindWLayoutOfUnbrokenWarichu (pdobj, &pdobj->wlayout);
	if (lserr != lserrNone) { DestroyDobj (pdobj); return lserr; };

	/* :: SUBMIT WARICHU SUBLINES */

	/* REVIEW (antons): MOVE SUBMITTION BELOW LSDNFINISHREGULAR WHEN
	   					WE ALIMINATE HACK WITH REFORMATTING ")" FOR SG */

	lserr = SubmitWLayoutSublines (pdobj, &pdobj->wlayout);
	if (lserr != lserrNone) { DestroyDobj (pdobj); return lserr; };

	ReformatClosingBraceForWord9 (pdobj);
	
	lserr = LsdnFinishRegular ( pilsobj->plsc,
								GetCpLimOfWLayout (pdobj, &pdobj->wlayout)-pdobj->cpStart,
								pcfmtin->lsfrun.plsrun, 
								pcfmtin->lsfrun.plschp,
								pdobj,
								& pdobj->wlayout.wdim.objdimAll );

	if (lserr != lserrNone) { DestroyDobj (pdobj); return lserr; };

	/* :: CHECK IF WE CROSSED RIGHT MARGIN AND RETURN */

	if (pdobj->wlayout.wdim.objdimAll.dur > durAvailable) 
		{
		* pfmtres = fmtrExceededMargin;
		}
	else
		{
		* pfmtres = fmtrCompletedRun;
		};

	return lserrNone;

} /* FormatWarichuCore */



/* W A R I C H U   F M T */
/*----------------------------------------------------------------------------
	%%Function: Warichu::Fmt
	%%Contact: antons

		Warichu FMT method entry point
	
----------------------------------------------------------------------------*/

LSERR WINAPI WarichuFmt ( PLNOBJ 	plnobj,			/* (IN): object lnobj */
    					  PCFMTIN 	pcfmtin,		/* (IN): formatting input */
						  FMTRES	* pfmtres )		/* (OUT): formatting result */
{
	return FormatWarichuCore ( plnobj,
							   pcfmtin,
							   FALSE,			/* fResumed  = false */
							   0,
							   NULL,
							   pfmtres );
}


/* W A R I C H U  F M T  R E S U M E */
/*----------------------------------------------------------------------------
	%%Function: Warichu::FmtResume
	%%Contact: anton

		Warichu FMT-RESUME method entry point
  
----------------------------------------------------------------------------*/
LSERR WINAPI WarichuFmtResume ( 
							   
		PLNOBJ			plnobj,				/* (IN): object lnobj */
		const BREAKREC 	* rgBreakRecord,	/* (IN): array of break records */
		DWORD			nBreakRecord,		/* (IN): size of the break records array */
		PCFMTIN			pcfmtin,			/* (IN): formatting input */
		FMTRES			* pfmtres )			/* (OUT): formatting result */
{
	return FormatWarichuCore ( plnobj,
							   pcfmtin,
							   TRUE,			/* fResumed  = true */
							   nBreakRecord,
							   rgBreakRecord,
							   pfmtres );
}


/* W A R I C H U G E T M O D W I D T H P R E C E D I N G C H A R */
/*----------------------------------------------------------------------------
	%%Function: WarichuGetModWidthPrecedingChar
	%%Contact: ricksa

		.
	
----------------------------------------------------------------------------*/
LSERR WINAPI WarichuGetModWidthPrecedingChar(
	PDOBJ pdobj,				/* (IN): dobj */
	PLSRUN plsrun,				/* (IN): plsrun of the object */
	PLSRUN plsrunText,			/* (IN): plsrun of the preceding char */
	PCHEIGHTS pcheightsRef,		/* (IN): height info about character */
	WCHAR wchar,				/* (IN): preceding character */
	MWCLS mwcls,				/* (IN): ModWidth class of preceding character */
	long *pdurChange)			/* (OUT): amount by which width of the preceding char is to be changed */
{
	Unreferenced(pcheightsRef);

	return ProcessModWidth(pdobj, warichuBegin, plsrun, plsrunText, 
		wchar, mwcls, pdurChange);
}

/* W A R I C H U G E T M O D W I D T H F O L L O W I N G C H A R */
/*----------------------------------------------------------------------------
	%%Function: WarichuGetModWidthFollowingChar
	%%Contact: ricksa

		.
	
----------------------------------------------------------------------------*/
LSERR WINAPI WarichuGetModWidthFollowingChar(
	PDOBJ pdobj,				/* (IN): dobj */
	PLSRUN plsrun,				/* (IN): plsrun of the object */
	PLSRUN plsrunText,			/* (IN): plsrun of the following char */
	PCHEIGHTS pcheightsRef,		/* (IN): height info about character */
	WCHAR wchar,				/* (IN): following character */
	MWCLS mwcls,				/* (IN): ModWidth class of the following character */
	long *pdurChange)			/* (OUT): amount by which width of the following char is to be changed */
{
	Unreferenced(pcheightsRef);

	return ProcessModWidth(pdobj, warichuEnd, plsrun, plsrunText, 
			wchar, mwcls, pdurChange);
}


/* T R Y  B R E A K  W A R I C H U  A T  C P  */
/*----------------------------------------------------------------------------
	%%Function: TryBreakWarichuAtCp
	%%Contact: antons

		Given break-point in the whole line, find break of Warichu which
		ends at this break-point. For optimization during Truncation I added
		urColumnMax and special result type trybreakkindExceedMargin.

		This is the major breakig procedure which is called from Truncation,
		Prev / Next Breaks and probably Force break.

----------------------------------------------------------------------------*/

typedef enum trybreakwarichu
{
	trybreakwarichuSuccessful,
	trybreakwarichuExceedMargin,
	trybreakwarichuCanNotFinishAtCp

} TRYBREAKWARICHU;


LSERR TryBreakWarichuAtCp (

	PDOBJ			pdobj,				/* (IN): Warichu DOBJ */
	LSCP			cpBreakCandidate,	/* (IN): Candidate cpLim of broken Warichu */
	long			durBreakCandidate,	/* (IN): dur of break-point in the whole line */
	long			urColumnMax,		/* (IN): max width of broken warichu (for OPT only!) */
	TRYBREAKWARICHU	* ptrybreakwarichu,	/* (OUT): Successful | ExceededRM | Bad Candidate */
	PWLAYOUT		pwlayout) 			/* (OUT): Layout of broken Warichu if Successful */
{
	LSERR lserr;
	BOOL fSuccessful;
	LSCP cpBreakFirst;
	BRKKIND brkkindUnused;

	OBJDIM objdimBreakFirst;
	OBJDIM objdimBreakSecond;
	BRKKIND brkkindFirst;
	BRKKIND brkkindSecond;

	WBRKARRAY wbrkarrayAtFirstEnd;	/* WBreakArray at the end of first subline */

	long durOpen, durClose;
	BOOL boolUnused1, boolUnused2;

	pwlayout->wsubline1.plssubl = NULL;
	pwlayout->wsubline2.plssubl = NULL; /* In case of error */

	GetDurBraces (pdobj, TRUE, &boolUnused1, &durOpen, &boolUnused2, &durClose);

	/* REVIEW (antons): Hidden text at "cpBreakCandidate - 1" */

	lserr = ChooseNearestBreak ( pdobj->wwhole.plssubl,
								 durBreakCandidate,
								 cpBreakCandidate - 1,
								 & fSuccessful,
								 & cpBreakFirst,
								 & objdimBreakFirst,
								 & brkkindUnused );
	if (lserr != lserrNone) return lserr;

	Assert (fSuccessful); /* REVIEW (antons): Should not we provide special ret code? */

	/* Optimization check */

	/* REVIEW (antons): I do not like this check, calculation must be done in special function */
	if (durOpen + durClose + objdimBreakFirst.dur > urColumnMax)
		{
		* ptrybreakwarichu = trybreakwarichuExceedMargin;

		lserr = DestroyWLayout (pwlayout);
		return lserrNone;
		};

	/* Format first line */

	lserr = FormatWSublineUntilCpBreak ( pdobj, 
										 pdobj->wwhole.cpFirst,
										 & pdobj->wbrkarrayAtStart,
										 cpBreakFirst,
										 objdimBreakFirst.dur, /* REVIEW (antons): urColumnMax */
										 objdimBreakFirst.dur, /* REVIEW (antons): urTuncate */
										 & fSuccessful,
										 & pwlayout->wsubline1,
										 & objdimBreakFirst,
										 & brkkindFirst );
	if (lserr != lserrNone) return lserr;

	/* REVIEW (antons): Maybe we should leave this assert? */
	/* Assert (fSuccessful); */

	if (!fSuccessful) /* Incorrect object inside Warichu, but we can handle it */
		{
		* ptrybreakwarichu = trybreakwarichuCanNotFinishAtCp;

		lserr = DestroyWLayout (pwlayout);
		return lserr;
		};

	/* Create new WBreakArray */

	lserr = NewWBrkArray (pdobj, & wbrkarrayAtFirstEnd);

	if (lserr != lserrNone) {DestroyWLayout (pwlayout); return lserr;};

	/* Set break at the end of first line and fill WBreakArray */

	lserr = SetBreakWSubline (& pwlayout->wsubline1, brkkindFirst, 
							  cpBreakFirst, & objdimBreakFirst, & wbrkarrayAtFirstEnd);

	if (lserr != lserrNone) 
		{
		DestroyWLayout (pwlayout); 
		DestroyWBrkArray (pdobj, &wbrkarrayAtFirstEnd);
		
		return lserr;
		};


	/* REVIEW (antons): Check the following assumption! */

	Assert (durBreakCandidate >= objdimBreakFirst.dur);

	/* Format second line */

	lserr = FormatWSublineUntilCpBreak ( pdobj, 
								 cpBreakFirst,
								 & wbrkarrayAtFirstEnd,
								 cpBreakCandidate,
								 durBreakCandidate - objdimBreakFirst.dur, /* REVIEW (antons): urColumnMax */
								 durBreakCandidate - objdimBreakFirst.dur, /* REVIEW (antons): urTuncate */
								 & fSuccessful,
								 & pwlayout->wsubline2,
								 & objdimBreakSecond,
								 & brkkindSecond );

	if (lserr != lserrNone) 
		{
		DestroyWLayout ( pwlayout); 
		DestroyWBrkArray (pdobj, &wbrkarrayAtFirstEnd);
		
		return lserr;
		};

	/* We do not need wBreakArrayAtFirstEnd any more, so we release it */

	DestroyWBrkArray (pdobj, & wbrkarrayAtFirstEnd);

	/* If not Successful => result "Can not Finish At Cp" */

	if (!fSuccessful)
		{
		DestroyWLayout (pwlayout);

		* ptrybreakwarichu = trybreakwarichuCanNotFinishAtCp; 
		return lserrNone;
		};

	/*	Here comes a small cheating ;-) 

		We do not want to Set Break at the end of second line, but have to
		store objdim & cpLim as if after SetBreak. Maybe in the future I will
		get rid of this checting (hope it is the only one left in Warichu ;-)
		but today I change cpLim and objdim manually & also store 
		kind of	break to set at second line end (playout->brkkind).

	*/

	pwlayout->wsubline2.cpLim = cpBreakCandidate;
	pwlayout->wsubline2.objdim = objdimBreakSecond;

	pwlayout->brkkind = brkkindSecond;
	pwlayout->fBroken = TRUE;

	lserr = FinishObjDimWLayout (pdobj, pwlayout);
	if (lserr != lserrNone) {DestroyWLayout (pwlayout); return lserr;};
	
	/* Again, check for right Margin */

	if (pwlayout->wdim.objdimAll.dur > urColumnMax)
		{
		* ptrybreakwarichu = trybreakwarichuExceedMargin;

		lserr = DestroyWLayout (pwlayout);
		return lserr;
		}
	else
		{
		* ptrybreakwarichu = trybreakwarichuSuccessful;
		return lserrNone;
		};
}


/* C A L C  J I S  R A N G E */
/*----------------------------------------------------------------------------
	%%Function: CalcJisRange
	%%Contact: antons
	
		Calculate cpJisRangeFisrt and cpJisRangeLim as 4th break opportunities
		from the beginning and from the end of Whole subline. If range is empty,
		* pfJisRangeEmpty = FALSE and cps are undefined.

----------------------------------------------------------------------------*/

static LSERR CalcJisRange (
						   
	PDOBJ	pdobj,
	BOOL	*pfJisRangeEmpty,
	LSCP	*pcpJisRangeFirst,
	LSCP	*pcpJisRangeLim )
{
	LSERR	lserr;
	OBJDIM	objdimUnused;
	WWHOLE	* pwwhole = &pdobj->wwhole;

	Assert (pwwhole->plssubl != NULL);
	
	if (!pwwhole->fJisRangeKnown) /* Have to calculate */
		{
		/* Searching 4 breaks from WWHOLE start */

		LSCP cpTruncateBefore = pdobj->wwhole.cpFirst;
		BOOL fSuccessful = TRUE;
		long nFound = 0;

		while (fSuccessful && nFound < 4)
			{
			lserr = WaFindNextBreakSubline ( pwwhole->plssubl,
											cpTruncateBefore,
											LONG_MAX,
											& fSuccessful,
											& cpTruncateBefore,
											& objdimUnused );
			if (lserr != lserrNone) return lserr;

			if (fSuccessful) nFound ++;
			};

		if (fSuccessful)
			{
			/* Searching 4 breaks from WWHOLE end */

			LSCP cpTruncateAfter;
			BOOL fSuccessful = TRUE;
			long nFound = 0;

			if (pwwhole->fFinished)
				{
				/* Subline was finished at Esc char, so we can start from cpLim */
				cpTruncateAfter = pwwhole->cpLim;
				}
			else
				{
				/* Subline was stopped at RM => start at RM truncation point */
				cpTruncateAfter = pwwhole->cpTruncate+1;
				};
			
			/*	REVIEW (antons): To reduce check above maybe we can lie about
				cp-lim of the whole subline when it was not finished? */

			while (fSuccessful && nFound < 4)
				{
				lserr = WaFindPrevBreakSubline ( pwwhole->plssubl,
												cpTruncateAfter-1,
											    LONG_MAX,
											    & fSuccessful,
											    & cpTruncateAfter,
											    & objdimUnused );

				if (lserr != lserrNone) return lserr;

				if (fSuccessful) nFound ++;
				};

			if (fSuccessful)
				{
				/* Jis Range is not empty */

				pwwhole->cpJisRangeFirst = cpTruncateBefore;
				pwwhole->cpJisRangeLim = cpTruncateAfter + 1;
				}
			else
				{	
				/* Empty range */

				pwwhole->cpJisRangeFirst = 0;
				pwwhole->cpJisRangeLim = 0;
				};
			}
		else
			{
			/* Empty range */

			pwwhole->cpJisRangeFirst = 0;
			pwwhole->cpJisRangeLim = 0;
			};

		pwwhole->fJisRangeKnown = TRUE; /* Yes, now we know it */
		}
	else
		/* Nothing - already know ;-) */ ;


	Assert (pwwhole->fJisRangeKnown);

	*pfJisRangeEmpty = pwwhole->cpJisRangeFirst >= pwwhole->cpJisRangeLim;
	*pcpJisRangeFirst = pwwhole->cpJisRangeFirst;
	*pcpJisRangeLim = pwwhole->cpJisRangeLim;

	return lserrNone;
}


/* S A V E  B R E A K  I N S I D E  W A R I C H U  */
/*----------------------------------------------------------------------------
	%%Function: SaveBreakInsideWarichu
	%%Contact: antons

		Store layout for Prev / Next / Force break in dobj. This procedure
		also Invalidates pointers in input layout after copying.

----------------------------------------------------------------------------*/

static void SaveBreakInsideWarichu ( 
		
		PDOBJ		pdobj,			/* (IN): Warichu Dobj */
		BRKKIND		brkkind,		/* (IN): Kind of break happened */
		WLAYOUT		* pwlayout )	/* (IN/OUT): Layout to store */
{
	int ind = GetBreakRecordIndex (brkkind);

	/* Destroy previously saved layout */
	DestroyWLayout (& pdobj->wlayoutBreak [ind]);

	/* Copy input layout to pdobj */
	pdobj->wlayoutBreak [ind] = *pwlayout;

	pdobj->wbreaktype [ind] = wbreaktypeInside;
	
	/* Invalidate input layout */
	InvalidateWLayout (pwlayout);
}


/* S A V E  B R E A K  A F T E R */
/*----------------------------------------------------------------------------
	%%Function: SaveBreakAfter
	%%Contact: antons

		Changes break information so it says "After current layout"

----------------------------------------------------------------------------*/

static void SaveBreakAfterWarichu ( 
		
		PDOBJ		pdobj,			/* (IN): Warichu Dobj */
		BRKKIND		brkkind )		/* (IN): Kind of break happened */
{
	int ind = GetBreakRecordIndex (brkkind);

	/* Destroy previously saved layout */
	DestroyWLayout (& pdobj->wlayoutBreak [ind]);

	pdobj->wbreaktype [ind] = wbreaktypeAfter;
}


/* F I N D  P R E V  B R E A K  W A R I C H U  D O B J  */
/*----------------------------------------------------------------------------
	%%Function: FindPrevBreakWarichuDobj
	%%Contact: antons


		Important: This procedure has a twin "FindNextBreakWarichuDobj". Any
		change here may require adjusting of the code in another procedure
		as well.

----------------------------------------------------------------------------*/

static LSERR FindPrevBreakWarichuDobj ( 
									  
		PDOBJ	pdobj, 
		LSCP	cpTruncate,
		long	urColumnMax,	/* Only for optimization from Truncate */
		BOOL	* pfSuccessful,
		BOOL	* pfNextAfterColumnMax,	/* (OUT): TRUE if we know that next break is 
												  after urColumnMax for sure */
		LSCP	* pcpBreak,
		OBJDIM	* pobjdimBreak,
		WLAYOUT	* pwlayout )		/* (OUT): Layout of broken Warichu */
{
	LSERR lserr;
	LSCP cpJisRangeFirst, cpJisRangeLim;
	BOOL fJisRangeEmpty;

	InvalidateWLayout (pwlayout); /* Unsuccessful & error */

	lserr = CalcJisRange (pdobj, &fJisRangeEmpty, &cpJisRangeFirst, &cpJisRangeLim);

	if (lserr != lserrNone) return lserr;
	
	if (fJisRangeEmpty || (cpTruncate < cpJisRangeFirst))
		{
		* pfSuccessful = FALSE;
		return lserrNone;
		}
	else
		{
		LSCP cpBreak = cpTruncate+1;

		* pfNextAfterColumnMax = FALSE;

		/* REVIEW (antons): Is not it dangerous start from cpJisLim-1 ? */
		/* Snap to the end of Jis region */
		if (cpBreak > cpJisRangeLim) cpBreak = cpJisRangeLim; 

		for (;;)
			{
			TRYBREAKWARICHU trybreakwarichuKind;
			BOOL fSuccessful;
			OBJDIM objdim;

			lserr = WaFindPrevBreakSubline ( pdobj->wwhole.plssubl, cpBreak-1, LONG_MAX,
											& fSuccessful, & cpBreak, & objdim );

			if (lserr != lserrNone) return lserr;

			if (! fSuccessful || cpBreak < cpJisRangeFirst)
				{
				Assert (fSuccessful); /* Catch against crazy objects inside Warichu, can continue */

				* pfSuccessful = FALSE;
				return lserrNone;
				};

			Assert (cpBreak < cpJisRangeLim);

			lserr =  TryBreakWarichuAtCp (pdobj, cpBreak, objdim.dur,
										  urColumnMax, & trybreakwarichuKind, pwlayout );

			if (lserr != lserrNone) return lserr;

			if (trybreakwarichuKind== trybreakwarichuSuccessful)
				{
				/* Found Warichu Break */

				* pcpBreak = GetCpLimOfWLayout (pdobj, pwlayout);
 				* pfSuccessful = TRUE;
				* pobjdimBreak = pwlayout->wdim.objdimAll;

				return lserr;
				};

			Assert (trybreakwarichuKind == trybreakwarichuExceedMargin || 
					trybreakwarichuKind == trybreakwarichuCanNotFinishAtCp);


			if (trybreakwarichuKind == trybreakwarichuExceedMargin)
				{
				/* Could not break because or Exceeding RM */
				* pfNextAfterColumnMax = TRUE;
				};

			/* Continue loop */

			};

		};

	/* Unreachable code */
}


/* F I N D  N E X T  B R E A K  W A R I C H U  D O B J  */
/*----------------------------------------------------------------------------
	%%Function: FindNextBreakWarichuDobj
	%%Contact: antons

		Important: This procedure has a twin "FindNextBreakWarichuDobj". Any
		change here may require adjusting of the code in another procedure
		as well.

----------------------------------------------------------------------------*/

static LSERR FindNextBreakWarichuDobj ( 
									  
		PDOBJ	pdobj, 
		LSCP	cpTruncate,
		BOOL	* pfSuccessful,
		LSCP	* pcpBreak,
		OBJDIM	* pobjdimBreak,
		WLAYOUT	* pwlayout )		/* (OUT): Layout of broken Warichu */
{
	LSERR lserr;
	LSCP cpJisRangeFirst, cpJisRangeLim;
	BOOL fJisRangeEmpty;

	InvalidateWLayout (pwlayout); /* Unsuccessful & error */

	lserr = CalcJisRange (pdobj, &fJisRangeEmpty, &cpJisRangeFirst, &cpJisRangeLim);

	if (lserr != lserrNone) return lserr;
	
	if (fJisRangeEmpty || (cpTruncate >= cpJisRangeLim-1))
		{
		* pfSuccessful = FALSE;
		return lserrNone;
		}
	else
		{
		LSCP cpBreak = cpTruncate;

		/* REVIEW (antons): Is not it dangerous start from cpJisLim-1 ? */
		if (cpBreak < cpJisRangeFirst) cpBreak = cpJisRangeFirst-1; /* snap to the end of Jis region */
		
		for (;;)
			{
			TRYBREAKWARICHU trybreakwarichuKind;
			BOOL fSuccessful;
			OBJDIM objdim;

			lserr = WaFindNextBreakSubline ( pdobj->wwhole.plssubl, cpBreak, LONG_MAX,
											& fSuccessful, & cpBreak, & objdim );

			if (lserr != lserrNone) return lserr;

			if (! fSuccessful || cpBreak >= cpJisRangeLim)
				{
				Assert (fSuccessful); /* Catch against crazy objects inside Warichu, can continue */

				* pfSuccessful = FALSE;
				return lserrNone;
				};

			Assert (cpBreak >= cpJisRangeFirst);

			lserr =  TryBreakWarichuAtCp (pdobj, cpBreak, objdim.dur,
										  LONG_MAX, & trybreakwarichuKind, pwlayout );

			if (lserr != lserrNone) return lserr;

			if (trybreakwarichuKind == trybreakwarichuSuccessful)
				{
				/* Found Warichu Break */

				* pcpBreak = GetCpLimOfWLayout (pdobj, pwlayout);
				* pfSuccessful = TRUE;
				* pobjdimBreak = pwlayout->wdim.objdimAll;

				return lserrNone;
				};

			Assert (trybreakwarichuKind == trybreakwarichuExceedMargin || 
					trybreakwarichuKind == trybreakwarichuCanNotFinishAtCp);

			/* Continue loop */

			};

		};

	/* Unreachable code */
}


/* W A  T R U N C A T E  P R E V  F O R C E */
/*----------------------------------------------------------------------------
    %%Function: WaTruncatePrevForce
	%%Contact: antons


----------------------------------------------------------------------------*/
static LSERR WaTruncatePrevForce ( 

			PLSSUBL		plssubl, 
			long		urColumnMax, 
			BRKKIND		* pbrkkind,			/* (OUT): Kind of break: Prev or Force */
			LSCP		* pcpBreak,
			BRKPOS		* pbrkpos,
			POBJDIM		pobjdimSubline )
{
	LSERR lserr;

	BOOL fSuccessful;
	LSCP cpTruncate;

	lserr = LsTruncateSubline (plssubl, urColumnMax,  &cpTruncate);
	if (lserr != lserrNone) return lserr;

	lserr = WaFindPrevBreakSubline ( plssubl, cpTruncate, urColumnMax,
									 & fSuccessful, pcpBreak, pobjdimSubline );
	if (lserr != lserrNone) return lserr;

	if (fSuccessful)
		{
		* pbrkkind = brkkindPrev;
		* pbrkpos = brkposInside; /* REVIEW (antons) */
		}
	else
		{
		lserr = WaForceBreakSubline ( plssubl, cpTruncate, urColumnMax,
									  pcpBreak, pbrkpos, pobjdimSubline );
		if (lserr != lserrNone) return lserr;

		Assert (* pbrkpos != brkposBeforeFirstDnode); /* REVIEW (antons): Check with Igor */

		* pbrkkind = brkkindForce;
		* pbrkpos = * pbrkpos;
		};

	return lserrNone;
}


/* F O R C E  B R E A K  W A R I C H U  C O R E */
/*----------------------------------------------------------------------------
	%%Function: ForceBreakWarichuDobjCore
	%%Contact: antons


----------------------------------------------------------------------------*/
static LSERR ForceBreakWarichuDobjCore ( 
									  
		PDOBJ	pdobj, 
		long	urColumnMax,	
		BOOL	fBrokenWarichu,		/* (IN):  Which Warichu to produce: broken or not */
		BOOL	fLeaveSpaceForCloseBrace,
		BOOL	* pfSuccessful,
		LSCP	* pcpBreak,
		OBJDIM	* pobjdimBreak,
		WLAYOUT	* pwlayout )		/* (OUT): Layout of broken Warichu */
{
	LSERR lserr;

	long durOpen, durClose;
	BOOL fBraceOpen, fBraceClose;
	long durAvailable;
	BOOL fFinished;

	BRKPOS brkpos;
	LSCP cpBreak;
	BRKKIND brkkind;
	OBJDIM objdimBreak;

	WBRKARRAY wbrkarrayAtFirstEnd;

	InvalidateWLayout (pwlayout); /* error and unsuccessful */

	/* REVIEW (antons): HACK HACK HACK */

	if (! fLeaveSpaceForCloseBrace)
		{
		GetDurBraces (pdobj, fBrokenWarichu, &fBraceOpen, &durOpen, &fBraceClose, &durClose);
		durAvailable = urColumnMax - durOpen - durClose;
		}
	else
		{
		GetDurBraces (pdobj, FALSE, &fBraceOpen, &durOpen, &fBraceClose, &durClose);
		durAvailable = urColumnMax - durOpen - durClose;
		};

	if (durAvailable <= 0)
		{
		if (! fBrokenWarichu)
			{
			* pfSuccessful = FALSE;
			return lserrNone;
			}
		else
			{
			durAvailable = 0;
			}
		};

	lserr = FormatWSublineUntilRM (pdobj, pdobj->wwhole.cpFirst, durAvailable, 
								   &pdobj->wbrkarrayAtStart, &fFinished,
								   &pwlayout->wsubline1);
	if (lserr != lserrNone) return lserr;

	if (fFinished && pwlayout->wsubline1.objdim.dur <= durAvailable)
		{
		/* REVIEW (antons): Im I right that this assert shows possible error in
		                    breaking inside Warichu? */
		AssertSz (FALSE, "This should not happen in real life, but we handle it");
	
		Assert (! fBrokenWarichu); /* REVIEW (antons) */

		lserr = FinishWLayoutSingleLine (pdobj, pwlayout);
		if (lserr != lserrNone) { DestroyWLayout (pwlayout); return lserr;};

		* pfSuccessful = TRUE;
		* pcpBreak = GetCpLimOfWLayout (pdobj, pwlayout);
		* pobjdimBreak = pwlayout->wdim.objdimAll;

		return lserrNone;
		};

	/* Break first subline at durAvailable */

	lserr = WaTruncatePrevForce ( pwlayout->wsubline1.plssubl, 
								  durAvailable,
								  & brkkind,
								  & cpBreak,
								  & brkpos,
								  & objdimBreak );
	if (lserr != lserrNone) { DestroyWLayout (pwlayout); return lserr;};

	lserr = NewWBrkArray (pdobj, &wbrkarrayAtFirstEnd);
	if (lserr != lserrNone) { DestroyWLayout (pwlayout); return lserr;};

	lserr = SetBreakWSubline ( & pwlayout->wsubline1, brkkind, cpBreak, 
							   & objdimBreak, & wbrkarrayAtFirstEnd );
	if (lserr != lserrNone) 
		{ 
		DestroyWBrkArray (pdobj, &wbrkarrayAtFirstEnd);
		DestroyWLayout (pwlayout); return lserr;
		};

	/* Continue to format second line */

	lserr = FormatWSublineUntilRM ( pdobj, cpBreak, durAvailable, 
								    & wbrkarrayAtFirstEnd, & fFinished,
								    & pwlayout->wsubline2 );
	if (lserr != lserrNone) 
		{ 
		DestroyWBrkArray (pdobj, &wbrkarrayAtFirstEnd);
		DestroyWLayout (pwlayout); return lserr;
		};

	DestroyWBrkArray (pdobj, &wbrkarrayAtFirstEnd);

	if (fFinished && pwlayout->wsubline2.objdim.dur <= durAvailable)
		{
		/* Second subline stopped before RM */

		Assert (pdobj->wwhole.fFinished);

		pwlayout->fBroken = FALSE; /* Closing brace can not stand alone */
		pwlayout->brkkind = brkkindImposedAfter; /* in the case of fBroken */

		lserr = FinishObjDimWLayout (pdobj, pwlayout);
		if (lserr != lserrNone) { DestroyWLayout (pwlayout); return lserr;};

		* pfSuccessful = TRUE;
		* pcpBreak = GetCpLimOfWLayout (pdobj, pwlayout);
		* pobjdimBreak = pwlayout->wdim.objdimAll;

		return lserrNone;
		};

	/* Break at the end of second line... */

	lserr = WaTruncatePrevForce ( pwlayout->wsubline2.plssubl, 
								  durAvailable,
								  & brkkind, 
								  & cpBreak, 
								  & brkpos, 
								  & objdimBreak );
	if (lserr != lserrNone) { DestroyWLayout (pwlayout); return lserr;};

	if (brkpos == brkposAfterLastDnode)
		{
		/* Second subline broken "After" */

		Assert (pdobj->wwhole.fFinished);
		
		pwlayout->fBroken = FALSE; /* Closing brace can not stand alone */
		pwlayout->brkkind = brkkind; /* in the case of fBroken */

		lserr = FinishObjDimWLayout (pdobj, pwlayout);
		if (lserr != lserrNone) { DestroyWLayout (pwlayout); return lserr;};

		* pfSuccessful = TRUE;
		* pcpBreak = GetCpLimOfWLayout (pdobj, pwlayout);
		* pobjdimBreak = pwlayout->wdim.objdimAll;

		return lserrNone;
	};

	if (fBrokenWarichu)
		{
		/* REVIEW (antons) */
		/* Our cheating to postpone SetBreakSubline until WarichuSetBreak */

		pwlayout->wsubline2.cpLim = cpBreak;
		pwlayout->wsubline2.objdim = objdimBreak;

		pwlayout->brkkind = brkkind;
		pwlayout->fBroken = TRUE;

		lserr = FinishObjDimWLayout (pdobj, pwlayout);

		if (lserr != lserrNone) { DestroyWLayout (pwlayout); return lserr;};

		* pfSuccessful = TRUE;
		* pcpBreak = GetCpLimOfWLayout (pdobj, pwlayout);
		* pobjdimBreak = pwlayout->wdim.objdimAll;
		return lserrNone;
		}
	else
		{
		/* Have to return Unsuccessful */

		* pfSuccessful = FALSE;

		lserr = DestroyWLayout (pwlayout); /* Not to loose memory */
		return lserrNone;
		}
}


/* F O R C E  B R E A K  W A R I C H U  D O B J  */
/*----------------------------------------------------------------------------
	%%Function: ForceBreakWarichuDobj
	%%Contact: antons


----------------------------------------------------------------------------*/
static LSERR ForceBreakWarichuDobj ( 
									
				PDOBJ	pdobj,
				long	urColumnMax,	
				BOOL	* pfSuccessful,
				LSCP	* pcpBreak,
				OBJDIM	* pobjdimBreak,
				WLAYOUT	* pwlayout )/* (OUT): Layout of broken Warichu */
{
	LSERR lserr;
	BOOL fSuccessful = FALSE;

	/* 1. TRY FORCE BREAK WITHOUT BREAKING OF WARICHU */

	if (pdobj->wwhole.fFinished)
		{
		/* Without breaking can be only when closing brace fetched */
		
		lserr = ForceBreakWarichuDobjCore ( pdobj, urColumnMax, FALSE, FALSE, & fSuccessful,
											pcpBreak, pobjdimBreak, pwlayout );
		if (lserr != lserrNone) return lserr;
		};

	if (! fSuccessful)
		{
		/* 2. TRY FORCE BREAK WITH POSSIBLE BREAKING OF WARICHU */

		lserr = ForceBreakWarichuDobjCore ( pdobj, urColumnMax, TRUE, FALSE, & fSuccessful,
											pcpBreak, pobjdimBreak, pwlayout );
		if (lserr != lserrNone) return lserr;

		/* Euristic solution for the case when we exceed RM because we added closing brace */

		if (fSuccessful && pdobj->wwhole.fFinished && urColumnMax < pobjdimBreak->dur)
			{
			lserr = DestroyWLayout (pwlayout);
			if (lserr != lserrNone) return lserr;

			lserr = ForceBreakWarichuDobjCore ( pdobj, urColumnMax, TRUE, TRUE, & fSuccessful,
												pcpBreak, pobjdimBreak, pwlayout );
			if (lserr != lserrNone) return lserr;
			};
	
		};

	* pfSuccessful = fSuccessful;

	return lserrNone;
}


/* T R U N C A T E  W A R I C H U  D O B J  */
/*----------------------------------------------------------------------------
	%%Function: TruncateWarichuDobj
	%%Contact: antons


----------------------------------------------------------------------------*/
static LSERR TruncateWarichuDobj ( 
									  
		PDOBJ	pdobj, 				/* (IN):  Warichu DOBJ */
		long	urColumnMax,		/* (IN):  ColumnMax to fix warichu before */
		BOOL	* pfSuccessful,		/* (OUT): Successful? */
		LSCP	* pcpBreak,			/* (OUT): Cp of broken Warichu if fSuccessful */
		OBJDIM	* pobjdimBreak,		/* (OUT): Dim of broken Warichu if fSuccessful */
		WLAYOUT	* pwlayout )		/* (OUT): Layout of broken Warichu if fSuccessful */
{
	LSERR lserr;

	long	durOpen;
	long	durClose;
	BOOL	boolUnused1, boolUnused2;
	BOOL	fSuccessful;
	BOOL	fNextAfterColumnMax;

	LSCP	cpBreakCandidate;
	LSCP	cpTruncateWhole;
	OBJDIM	objdimCandidate;

	ClearWLayout (pwlayout); /* in case of error or ! fSuccessful */

	GetDurBraces (pdobj, TRUE, &boolUnused1, &durOpen, &boolUnused2, &durClose);

	/* REVIEW (antons): Move this check to a separate function */
	if (urColumnMax <= durOpen + durClose) 
	{
		/* Optimization: in this case we know for sure there is no break */
		*pfSuccessful = FALSE;
		return lserrNone;
	};

	/* Estimate truncation point in WWHOLE (find cpTruncateWhole) */

	{
		/*	We want to estimate truncation point on WWHOLE as 2*(urColumnMax-durOpen-durClose),
			but unfortunately it is not always possible. Here we check if can truncate
			WWHOLE at this urTruncateWhole or, if we can not, take last possible cp in the
			whole subline. Situation depends on whether we finished WWHOLE or not */

		long urTruncateWhole = MULLongSafe (urColumnMax - durOpen - durClose, 2);

		/* REVIEW (antons): Can we optimize if we know durs of JIS range? */
		/* REVIEW (antons): Check all situation when I may come to "else" */
		/* REVIEW (antons): Should the second part (starting with "NOT") ever cause "else"? */
		if ( (    pdobj->wwhole.fFinished && urTruncateWhole < pdobj->wwhole.objdim.dur) ||
			 (NOT pdobj->wwhole.fFinished && urTruncateWhole < pdobj->wwhole.urColumnMax ) )
			{
				lserr = LsTruncateSubline (pdobj->wwhole.plssubl, urTruncateWhole,
										   & cpTruncateWhole);
				if (lserr != lserrNone) return lserr;
			}
		else if (pdobj->wwhole.fFinished)
			{
			cpTruncateWhole = pdobj->wwhole.cpLim;
			}
		else
			{
			cpTruncateWhole = pdobj->wwhole.cpTruncate;
			};
	}

	/* REVIEW (antos): Here and later in this proc I use pwayout as a candidate for 
					   truncation. Should I better use local structure? */

	lserr = FindPrevBreakWarichuDobj ( pdobj, cpTruncateWhole, urColumnMax, & fSuccessful, 
									   & fNextAfterColumnMax, & cpBreakCandidate, & objdimCandidate, 
									   pwlayout );
	if (lserr != lserrNone) return lserr;

	if (fSuccessful && fNextAfterColumnMax)
		{
		/* Candidate is OK */

		* pfSuccessful = TRUE;
		* pcpBreak = cpBreakCandidate;
		* pobjdimBreak = objdimCandidate;
		return lserrNone;
		};

	if (!fSuccessful)
		{
		/* Prev break Dobj is not found (or beyond RM) => try next break as a candidate */

		lserr = FindNextBreakWarichuDobj ( pdobj, cpTruncateWhole, & fSuccessful, 
										   & cpBreakCandidate, & objdimCandidate, pwlayout );
		if (lserr != lserrNone) return lserr;

		if (!fSuccessful)
			{
			/* NEXT break is not found */

			* pfSuccessful = FALSE;
			return lserrNone;
			}
		else if (objdimCandidate.dur > urColumnMax)
			{
			/* NEXT break is found but it is beyond RM */

			* pfSuccessful = FALSE;
			lserr = DestroyWLayout (pwlayout);
			return lserr;
			};
		};

	/* At this point we have break candidate: (pwlayout, cpBreakCandidate, objdimCandidate) */
	/* Now we shall go forward to make sure we have last possible break before RM */

	{
		BOOL fContinue;
		Assert (objdimCandidate.dur <= urColumnMax);

		fContinue = TRUE;

		while (fContinue)
			{
			WLAYOUT	wlayoutNext;
			OBJDIM	objdimNext;
			LSCP	cpBreakNext;
			BOOL	fSuccessful;
			
			lserr = FindNextBreakWarichuDobj ( pdobj, cpBreakCandidate, & fSuccessful, 
											  & cpBreakNext, & objdimNext, &wlayoutNext );
			if (lserr != lserrNone) {DestroyWLayout (pwlayout); return lserr;};

			if (!fSuccessful)
				{
				/* Next not found => Candidate is OK */
				fContinue = FALSE;
				}

			else if (objdimNext.dur > urColumnMax)
			{
				/* Next found, but exceeds RM => Candidate OK */

				/* Destroy wlayoutNext, because we do not need it */
				lserr = DestroyWLayout (&wlayoutNext); 
				if (lserr != lserrNone) {DestroyWLayout (pwlayout); return lserr;};

				fContinue = FALSE;
				}
			else
				{
				/* Next found and before RM => Is is a new Candidate */

				/* Destroy layout of the candidate, because we do not need it */
				lserr = DestroyWLayout (pwlayout); /* Destroy old candidate */
				if (lserr != lserrNone) {DestroyWLayout (&wlayoutNext); return lserr;};

				* pwlayout = wlayoutNext;
				cpBreakCandidate = cpBreakNext; /* Next break also before RM */
				objdimCandidate = objdimNext;
				}
			
			}; /* While (fContinue */

		* pfSuccessful = TRUE;
		* pcpBreak = cpBreakCandidate;
		* pobjdimBreak = objdimCandidate;

		/* pwlayout contains correct candiate layout */
		Assert (pwlayout->wdim.objdimAll.dur == objdimCandidate.dur); /* Sanity check */
		return lserrNone;
	};

} /* TruncateWarichuDobj */


/* P U T  B R E A K  A T  W A R I C H U  E N D  */
/*----------------------------------------------------------------------------
	%%Function: PutBreakAtWarichuEnd
	%%Contact: antons

		Fill in break output record for the end of the Warichu
	
----------------------------------------------------------------------------*/
static void PutBreakAtWarichuEnd (

		DWORD ichnk,				/* (IN): index in chunk */
		PCLOCCHNK pclocchnk,		/* (IN): locchnk to find break */
		PBRKOUT pbrkout)			/* (OUT): results of breaking */
{	
	PDOBJ pdobj = pclocchnk->plschnk[ichnk].pdobj;

	pbrkout->fSuccessful = TRUE;
	pbrkout->posichnk.dcp = GetCpLimOfWLayout (pdobj, &pdobj->wlayout) - pdobj->cpStart; 
																/* REVIEW (antons) */
	pbrkout->posichnk.ichnk = ichnk;
	pbrkout->objdim = pdobj->wlayout.wdim.objdimAll;
}


/* P U T  B R E A K  A T  W A R I C H U  B E G I N  */
/*----------------------------------------------------------------------------
	%%Function: PutBreakAtWarichuBegin
	%%Contact: antons

		Fill in break output record for break before Warichu.
	
----------------------------------------------------------------------------*/
static void PutBreakAtWarichuBegin (

		DWORD ichnk,				/* (IN): index in chunk */
		PCLOCCHNK pclocchnk,		/* (IN): locchnk to find break */
		PBRKOUT pbrkout )			/* (OUT): results of breaking */
{	
	Unreferenced (pclocchnk);

	pbrkout->fSuccessful = TRUE;
	pbrkout->posichnk.dcp = 0;
	pbrkout->posichnk.ichnk = ichnk;

	ZeroObjDim (&pbrkout->objdim);
}



/* P U T  B R E A K  W A R I C H U  U N S U C C E S S F U L  */
/*----------------------------------------------------------------------------
	%%Function: PutBreakWarichuUnsuccessful
	%%Contact: antons


----------------------------------------------------------------------------*/
static void PutBreakWarichuUnsuccessful (PBRKOUT pbrkout)
{	
	pbrkout->fSuccessful = FALSE;
	pbrkout->brkcond = brkcondPlease;

	/* Hack to fix crash before we eliminate posichnkBeforeTrailing */

}


/* P U T  B R E A K  W A R I C H U  D O B J */
/*----------------------------------------------------------------------------
	%%Function: PutBreakWarichuDobj
	%%Contact: antons


----------------------------------------------------------------------------*/
static void PutBreakAtWarichuDobj (

		DWORD ichnk, 
		PCLOCCHNK pclocchnk, 
		LSCP cpBreak,
		OBJDIM *pobjdimBreak,
				
		PBRKOUT pbrkout)
{	
	PDOBJ pdobj = pclocchnk->plschnk[ichnk].pdobj;

	pbrkout->fSuccessful = TRUE;
	pbrkout->posichnk.dcp = cpBreak - pdobj->cpStart;
	pbrkout->posichnk.ichnk = ichnk;
	pbrkout->objdim = *pobjdimBreak;

	Assert (pbrkout->posichnk.dcp > 0);
}


/* W A R I C H U  T R U N C A T E  C H U N K */
/*----------------------------------------------------------------------------
	%%Function: WarichuTruncateChunk
	%%Contact: antons


----------------------------------------------------------------------------*/

LSERR WINAPI WarichuTruncateChunk (PCLOCCHNK plocchnk, PPOSICHNK pposichnk)			
{
	LSERR	lserr;
	long	urColumnMax = plocchnk->lsfgi.urColumnMax;

	DWORD	ichnk = 0;
	BOOL	fFound = FALSE;

	/* Find object containing RM */

	while (!fFound)
		{
		Assert (ichnk < plocchnk->clschnk);
		Assert (plocchnk->ppointUvLoc[ichnk].u <= urColumnMax);

		fFound = plocchnk->ppointUvLoc[ichnk].u + 
				 plocchnk->plschnk[ichnk].pdobj->wlayout.wdim.objdimAll.dur > urColumnMax;

		if (!fFound) ichnk++;
		};

	Assert (ichnk < plocchnk->clschnk);

	/* Element ichnk contains RM, try to prev break it to find correct tr point */

	{
		LSCP	cpBreak;
		BOOL	fSuccessful;
		OBJDIM	objdimBreak;
		WLAYOUT wlayoutBreak;
		
		PDOBJ	pdobj = plocchnk->plschnk[ichnk].pdobj;
		
		lserr = TruncateWarichuDobj ( pdobj, 
									  urColumnMax - plocchnk->ppointUvLoc[ichnk].u,
									  & fSuccessful,
									  & cpBreak,
									  & objdimBreak,
									  & wlayoutBreak );
		if (lserr != lserrNone) return lserr;

		ReformatClosingBraceForWord9 (pdobj);
		
		if (fSuccessful) /* Found break before RM */
			{
			/* REVIEW (antons): Move this before call to TruncateWarichuDobj */
			lserr = DestroyWLayout (&pdobj->wlayoutTruncate);
			if (lserr != lserrNone) return lserr;

			pdobj->wlayoutTruncate = wlayoutBreak;
			
			pposichnk->ichnk = ichnk;
			pposichnk->dcp = cpBreak - pdobj->cpStart + 1; /* +1 because dcp is always lim */
			return lserrNone;
			}
		else
			{
			/* Break before RM not found => dcpTruncate := 1 */

			pposichnk->ichnk = ichnk;
			pposichnk->dcp = 1; 
			return lserrNone;
			};
			
	};
}


/* W A R I C H U  F I N D  P R E V  B R E A K  C H U N K */
/*----------------------------------------------------------------------------
	%%Function: WarichuFindPrevBreakChunk
	%%Contact: antons

		Important: This procedure is similar to "WarichuFindPrevBreakChunk". 
		Any change here may require to change another procedure as well.
  
----------------------------------------------------------------------------*/
LSERR WINAPI WarichuFindPrevBreakChunk (

		PCLOCCHNK	pclocchnk,		/* (IN):  locchnk to break */
		PCPOSICHNK	pcpoischnk,		/* (IN):  place to start looking for break */
		BRKCOND		brkcond,		/* (IN):  recommmendation about the break after chunk */
		PBRKOUT		pbrkout)		/* (OUT): results of breaking */
{
	LSERR	lserr;
	PDOBJ	pdobj;

	WLAYOUT	wlayoutBreak;
	BOOL	fSuccessful;
	LSCP	cpBreak;
	LSCP	cpTruncate;
	OBJDIM	objdimBreak;
	BOOL	fNextBeforeColumnMaxUnused;

	POSICHNK posichnk = *pcpoischnk;	/* position to start looking for break */

	if (posichnk.ichnk == ichnkOutside)
		{
		if (brkcond != brkcondNever)
			{
			/* Can break after chunk */

			pdobj = pclocchnk->plschnk [pclocchnk->clschnk - 1].pdobj;

			SaveBreakAfterWarichu (pdobj, brkkindPrev);
			PutBreakAtWarichuEnd (pclocchnk->clschnk - 1, pclocchnk, pbrkout);
			return lserrNone;
			}
		else
			{
			/* Can not break after chunk, will try to break last Warichu */

			PDOBJ pdobj = pclocchnk->plschnk[pclocchnk->clschnk - 1].pdobj;

			posichnk.ichnk = pclocchnk->clschnk - 1;
			posichnk.dcp = GetCpLimOfWLayout (pdobj, &pdobj->wlayout) - pdobj->cpStart;
			};
		};

	/* Call routing which breaks Warichu */

	pdobj = pclocchnk->plschnk[posichnk.ichnk].pdobj;
	cpTruncate = pdobj->cpStart + posichnk.dcp - 1;

	if (FWLayoutValid (&pdobj->wlayoutTruncate) &&
	    cpTruncate == GetCpLimOfWLayout (pdobj, &pdobj->wlayoutTruncate))
	    {
	    /* Optimization: we can take WLayout saved during Truncation */

		PutBreakAtWarichuDobj (posichnk.ichnk, pclocchnk, cpTruncate, 
							   & pdobj->wlayoutTruncate.wdim.objdimAll, pbrkout);
		SaveBreakInsideWarichu (pdobj, brkkindPrev, &pdobj->wlayoutTruncate);

	    ClearWLayout (&pdobj->wlayoutTruncate);
	    return lserrNone;
	    }

	lserr = FindPrevBreakWarichuDobj ( pdobj, cpTruncate,
									   LONG_MAX, & fSuccessful, & fNextBeforeColumnMaxUnused,
									   & cpBreak, & objdimBreak, & wlayoutBreak );
	if (lserr != lserrNone) return lserr;

	ReformatClosingBraceForWord9 (pdobj);

	/* Check result */

	if (fSuccessful)
		{
		/* Successful => Break inside Watichu */
		Assert (cpBreak <= pdobj->cpStart + (long)posichnk.dcp - 1); /* Monotinous axiom */

		SaveBreakInsideWarichu (pdobj, brkkindPrev, &wlayoutBreak);
		PutBreakAtWarichuDobj (posichnk.ichnk, pclocchnk, cpBreak, &objdimBreak, pbrkout);
		}
	else if (posichnk.ichnk > 0)
		{
		/* Can break between Warichus */

		pdobj = pclocchnk->plschnk [posichnk.ichnk-1].pdobj;

		SaveBreakAfterWarichu (pdobj, brkkindPrev);
		PutBreakAtWarichuEnd (posichnk.ichnk-1, pclocchnk, pbrkout);
		}
	else
		{
		/* Unsuccessful */

		PutBreakWarichuUnsuccessful (pbrkout);
		};

	return lserrNone;
}



/* W A R I C H U  F I N D  N E X T  B R E A K  C H U N K */
/*----------------------------------------------------------------------------
	%%Function: WarichuFindNextBreakChunk
	%%Contact: antons

		Important: This procedure is similar to "WarichuFindNextBreakChunk". 
		Any change here may require to change another procedure as well.
	
----------------------------------------------------------------------------*/
LSERR WINAPI WarichuFindNextBreakChunk (

		PCLOCCHNK pclocchnk,		/* (IN): locchnk to break */
		PCPOSICHNK pcpoischnk,		/* (IN): place to start looking for break */
		BRKCOND brkcond,			/* (IN): recommendation about the break before chunk */
		PBRKOUT pbrkout)			/* (OUT): results of breaking */
{
	LSERR	lserr;
	PDOBJ	pdobj;

	WLAYOUT	wlayoutBreak;
	BOOL	fSuccessful;
	LSCP	cpBreak;
	OBJDIM	objdimBreak;

	POSICHNK posichnk = *pcpoischnk;	/* position to start looking for break */

	if (posichnk.ichnk == ichnkOutside)
		{
		if (brkcond != brkcondNever)
			{
			/* Can break before chunk */

			PutBreakAtWarichuBegin (0, pclocchnk, pbrkout);
			return lserrNone;
			}
		else
			{
			/* Can not break before chunk, will try to break first Warichu */

			posichnk.ichnk = 0;
			posichnk.dcp = 1; /* REVIEW (antons): Check this dcp assigment */
			};
		};


	/* Call routing which breaks Warichu */

	pdobj = pclocchnk->plschnk[posichnk.ichnk].pdobj;

	lserr = FindNextBreakWarichuDobj ( pdobj, pdobj->cpStart + posichnk.dcp - 1,
									   & fSuccessful, & cpBreak, 
									   & objdimBreak, & wlayoutBreak );
	if (lserr != lserrNone) return lserr;

	ReformatClosingBraceForWord9 (pdobj);

	/* Check result */

	if (fSuccessful)
		{
		/* Break inside Watichu */
		Assert (cpBreak > pdobj->cpStart + (long)posichnk.dcp - 1); /* Monotinous axiom */

		SaveBreakInsideWarichu (pdobj, brkkindNext, &wlayoutBreak);
		PutBreakAtWarichuDobj (posichnk.ichnk, pclocchnk, cpBreak, &objdimBreak, pbrkout);
		}
	else if (posichnk.ichnk < (long)pclocchnk->clschnk - 1)
		{
		/* Can break between Warichus */

		pdobj = pclocchnk->plschnk [posichnk.ichnk].pdobj;

		SaveBreakAfterWarichu (pdobj, brkkindNext);
		PutBreakAtWarichuEnd (posichnk.ichnk, pclocchnk, pbrkout);
		}
	else
		{
		/* Unsuccessful */

		pbrkout->objdim = pclocchnk->plschnk[pclocchnk->clschnk - 1].pdobj->wlayout.wdim.objdimAll;

		SaveBreakAfterWarichu (pdobj, brkkindNext);
		PutBreakWarichuUnsuccessful (pbrkout);
		};

	return lserrNone;
}


/* W A R I C H U  F O R C E  B R E A K  C H U N K */
/*----------------------------------------------------------------------------
	%%Function: WarichuForceBreakChunk
	%%Contact: antons


----------------------------------------------------------------------------*/

LSERR WINAPI WarichuForceBreakChunk (

		PCLOCCHNK pclocchnk,		/* (IN):  Locchnk to break */
		PCPOSICHNK pcposichnk,		/* (IN):  Place to start looking for break */
		PBRKOUT pbrkout)			/* (OUT): Results of breaking */
{
	/*	This procedure must be called with same arguments passed to Truncation.
		If this is violated, Warichu may appear beyond RM */

	/* REVIEW (antons): Should I assert agains violations? */

	LSERR	lserr;

	BOOL	fSuccessful;
	LSCP	cpBreak;
	OBJDIM	objdimBreak;

	WLAYOUT wlayoutBreak;

	DWORD	ichnk = pcposichnk->ichnk;
	PDOBJ	pdobj;

	if (ichnk == ichnkOutside) ichnk = 0; /* When left indent is bigger then RM */
	Assert (ichnk != ichnkOutside);
	
	if (ichnk > 0)
		{
		/* Can break after previous Warichu */
		pdobj = pclocchnk->plschnk [ichnk-1].pdobj;

		SaveBreakAfterWarichu (pdobj, brkkindForce);
		PutBreakAtWarichuEnd (ichnk-1, pclocchnk, pbrkout);
		}
	else if (!pclocchnk->lsfgi.fFirstOnLine)
		{
		/* Can break before first chunk element, because !fFirstOnLine */

		Assert (ichnk == 0);

		PutBreakAtWarichuBegin (0, pclocchnk, pbrkout);
		}
	else
		{
		/* We are the only on the line */

		/* REVIEW (antons): Check it and if this is correct make same changes in ROBJ etc. */
		long urAvailable = pclocchnk->lsfgi.urColumnMax - 
						   pclocchnk->ppointUvLoc [ichnk].u;

		pdobj = pclocchnk->plschnk [ichnk].pdobj;

		/* Try to force break Warichi */
		lserr = ForceBreakWarichuDobj ( pdobj, urAvailable, & fSuccessful, 
									    & cpBreak, & objdimBreak, &wlayoutBreak );
		if (lserr != lserrNone) return lserr;

		ReformatClosingBraceForWord9 (pdobj);

		if (fSuccessful)
			{
			/* Yes, we can force break Warichu */
	
			Assert (cpBreak > pdobj->cpStart);

			SaveBreakInsideWarichu (pdobj, brkkindForce, &wlayoutBreak);
			PutBreakAtWarichuDobj ( ichnk, pclocchnk, cpBreak, 
									&objdimBreak, pbrkout);
			}
		else
			{
			/* Nothing to do... have to break "after" and go beyond RM */

			pdobj = pclocchnk->plschnk [ichnk].pdobj;

			SaveBreakAfterWarichu (pdobj, brkkindForce);
			PutBreakAtWarichuEnd (ichnk, pclocchnk, pbrkout);
			}
		};

	Assert (pbrkout->fSuccessful); /* Force break always successful */
	return lserrNone;
}	


/* W A R I C H U S E T B R E A K */
/*----------------------------------------------------------------------------
	%%Function: WarichuSetBreak
	%%Contact: antons


--------------------------------------------------------------------------*/
LSERR WINAPI WarichuSetBreak (

		PDOBJ pdobj,				/* (IN): Dobj which is broken */
		BRKKIND brkkind,			/* (IN): Kind of break */
		DWORD cBreakRecord,			/* (IN): Size of array */
		BREAKREC *rgBreakRecord,	/* (IN): Array of break records */
		DWORD *pcActualBreakRecord)	/* (IN): Actual number of used elements in array */
{
	LSERR lserr;

	/* REVIEW (antons): Should we destroy formatting layout forever? */
	/* REVIEW (antons): Should we release info about other previous breaks? */

	if (brkkind == brkkindImposedAfter)
		{
		/* Looks like we are doing nothing */

		*pcActualBreakRecord = 0; /* Break after Warichu, so it is terminate */
		
		return lserrNone;
		}
	else
		{
		/* Prev | Next | Force */

		int	ind = GetBreakRecordIndex (brkkind);
		WLAYOUT * pwlayout = & pdobj->wlayout;

		if (pdobj->wbreaktype [ind] == wbreaktypeAfter)
			{
			/* Break was after Warichu */

			*pcActualBreakRecord = 0;
			return lserrNone;
			};

		/* This Assert actually means != wbreaktypeInvalid */
		Assert (pdobj->wbreaktype [ind] == wbreaktypeInside);

		if (cBreakRecord < 1) return lserrInsufficientBreakRecBuffer;

		Assert (cBreakRecord >= 1); /* Broken warichu is not terminate ;-) */

		/* REVIEW (antons): Find better way to check correctess of break data */
		Assert (pdobj->wlayoutBreak [ind].wsubline1.plssubl != NULL);

		lserr = DestroyWLayout (&pdobj->wlayout);
		if (lserr != lserrNone) return lserr;

		* pwlayout = pdobj->wlayoutBreak [ind]; /* Copy break wlayout to current */

		ClearWLayout (&pdobj->wlayoutBreak [ind]);

		/* REVIEW (antons): is there any other exceptions? */
		Assert (brkkind == brkkindForce || pwlayout->fBroken);
		Assert (pwlayout->wsubline2.plssubl != NULL);

		/* Have to set break at the end of second line */

		/* REVIEW (antons): ? Assert against incorrect dimensions? */
		lserr = LsSetBreakSubline ( pwlayout->wsubline2.plssubl, 
									pwlayout->brkkind,
									cBreakRecord - 1,
									& rgBreakRecord [1],
									pcActualBreakRecord );
		if (lserr != lserrNone) return lserr;

		lserr = SubmitWLayoutSublines (pdobj, pwlayout);
		if (lserr != lserrNone) return lserr;

		rgBreakRecord [0].idobj = pdobj->pilsobj->idobj;
		rgBreakRecord [0].cpFirst = pdobj->cpStartObj; /* REVIEW (antons) */

		(*pcActualBreakRecord) ++; /* Add 1 for Warichu break record */

		return lserrNone;
		};

}

/* W A R I C H U  G E T  S P E C I A L  E F F E C T S  I N S I D E */
/*----------------------------------------------------------------------------
	%%Function: WarichuGetSpecialEffectsInside
	%%Contact: antons


----------------------------------------------------------------------------*/
LSERR WINAPI WarichuGetSpecialEffectsInside (PDOBJ pdobj, UINT *pEffectsFlags)
{
	LSERR lserr;
	WLAYOUT	* pwlayout = & pdobj->wlayout;

	UINT uiOpen   = 0;
	UINT uiClose  = 0;
	UINT uiFirst  = 0;
	UINT uiSecond = 0;

	if (FOpenBraceInWLayout (pdobj, pwlayout))
		{
		lserr = LsGetSpecialEffectsSubline (pdobj->wbraceOpen.plssubl, &uiOpen);
		if (lserr != lserrNone) return lserr;
		};

	lserr = LsGetSpecialEffectsSubline (pwlayout->wsubline1.plssubl, &uiFirst);
	if (lserr != lserrNone) return lserr;

	if (pwlayout->wsubline2.plssubl != NULL)
		{
		lserr = LsGetSpecialEffectsSubline (pwlayout->wsubline2.plssubl, &uiSecond);
		if (lserr != lserrNone) return lserr;
		};

	if (FCloseBraceInWLayout (pdobj, pwlayout))
		{
		lserr = LsGetSpecialEffectsSubline (pdobj->wbraceClose.plssubl, &uiClose);
		if (lserr != lserrNone) return lserr;
		};
	
	*pEffectsFlags = uiOpen | uiClose | uiFirst | uiSecond;
	
	return lserrNone;
}


/* W A R I C H U  C A L C   P R E S E N T A T I O N */
/*----------------------------------------------------------------------------
	%%Function: WarichuCalcPresentation
	%%Contact: antons


----------------------------------------------------------------------------*/
LSERR WINAPI WarichuCalcPresentation (PDOBJ pdobj, long dup, LSKJUST lskjust, BOOL fLastVisibleOnLine)
{
	LSERR lserr;

	WLAYOUT	 * pwlayout = & pdobj->wlayout;
	WDISPLAY * pwdisplay = & pdobj->wdisplay;

	long dupInside; /* Dup of the longest Warichu subline */

	Unreferenced (fLastVisibleOnLine);	
	Unreferenced (lskjust);
	Unreferenced (dup);

	/* REVIEW (antons): The following Assert is agains the rule that object which
	   exceeded RM must be broken inside (see formatting code for details) */

	Assert (FWLayoutValid (&pdobj->wlayout));

	/* 1. Prepare both warichu lines for display & store dups in our structures */

	if (pwlayout->wsubline1.objdim.dur >= pwlayout->wsubline2.objdim.dur)
		{
		/* First subline is bigger */
		/* NOTE: THIS PIECE OF CODE (-then-) HAS A TWIN IN (-else-) */

		lserr = WaMatchPresSubline (pwlayout->wsubline1.plssubl, & pwdisplay->wdispsubl1.dup);
		if (lserr != lserrNone) return lserr;

		dupInside = pwdisplay->wdispsubl1.dup; /* Dup of the first subline */

		if (pwlayout->wsubline2.plssubl != NULL)
			{
			/* Second subline is not empty */

			lserr = WaExpandSubline (pwlayout->wsubline2.plssubl, 
									lskjFullScaled,
									pwdisplay->wdispsubl1.dup, 
									& pwdisplay->wdispsubl2.dup);

			if (lserr != lserrNone) return lserr;
			}
		else
			pwdisplay->wdispsubl2.dup = 0; /* Used in calculation further in this proc */
		}
	else
		{
		/* Second subline is bigger */
		/* NOTE: THIS PIECE OF CODE (-else-) HAS A TWIN IN (-then-) */

		lserr = WaMatchPresSubline (pwlayout->wsubline2.plssubl, & pwdisplay->wdispsubl2.dup);
		if (lserr != lserrNone) return lserr;

		dupInside = pwdisplay->wdispsubl2.dup; /* Dup of the second subline */

		lserr = WaExpandSubline (pwlayout->wsubline1.plssubl, 
								lskjFullScaled,
								pwdisplay->wdispsubl2.dup, 
								& pwdisplay->wdispsubl1.dup);

		if (lserr != lserrNone) return lserr;
		};

	/* 2. Prepare brackets for display & store dups in our structures */

	/* REVIEW (antons): Rick expanded closing brace if it was not DonePres before... */

	if (FOpenBraceInWLayout(pdobj, pwlayout)) /* Open brace present */
		{
		lserr = WaMatchPresSubline (pdobj->wbraceOpen.plssubl, &pwdisplay->wdispbraceOpen.dup);
		if (lserr != lserrNone) return lserr;
		}
	else 
		pwdisplay->wdispbraceOpen.dup = 0; /* Used in calculation further in this proc */


	if (FCloseBraceInWLayout(pdobj, pwlayout)) /* Close brace present */
		{
		lserr = WaMatchPresSubline (pdobj->wbraceClose.plssubl, &pwdisplay->wdispbraceClose.dup);
		if (lserr != lserrNone) return lserr;
		}
	else
		pwdisplay->wdispbraceClose.dup = 0; /* Used in calculation further in this proc */

	/* 3. Magic dvpBetween */

	/* REVIEW (antons): Clear this issue */

	pwdisplay->dvpBetween =	  

			  pwlayout->wdim.objdimAll.heightsPres.dvMultiLineHeight
			- pwlayout->wsubline1.objdim.heightsPres.dvAscent
			- pwlayout->wsubline1.objdim.heightsPres.dvDescent
			- pwlayout->wsubline2.objdim.heightsPres.dvAscent
			- pwlayout->wsubline2.objdim.heightsPres.dvDescent
			- pwlayout->wdim.dvpDescentReserved ;
	
	/* 3. Calculate relative positions of Warichu sublines & braces */

	pwdisplay->wdispbraceOpen.duvStart.u = 0;
	pwdisplay->wdispbraceOpen.duvStart.v = 0;

	pwdisplay->wdispsubl1.duvStart.u = pwdisplay->wdispbraceOpen.dup;
	pwdisplay->wdispsubl1.duvStart.v = 

			  pwlayout->wsubline2.objdim.heightsPres.dvAscent 
			+ pwlayout->wsubline2.objdim.heightsPres.dvDescent 
			+ pwdisplay->dvpBetween
			+ pwlayout->wsubline1.objdim.heightsPres.dvDescent
			- pwlayout->wdim.objdimAll.heightsPres.dvDescent 
			- pwlayout->wdim.dvpDescentReserved ;

	if (pwlayout->wsubline2.plssubl != NULL)
		{

		pwdisplay->wdispsubl2.duvStart.u = pwdisplay->wdispbraceOpen.dup;
		pwdisplay->wdispsubl2.duvStart.v = 

				  pwlayout->wsubline2.objdim.heightsPres.dvDescent 
				- pwlayout->wdim.objdimAll.heightsPres.dvDescent 
				- pwlayout->wdim.dvpDescentReserved ;

		Assert (pwdisplay->wdispsubl1.duvStart.v >= pwdisplay->wdispsubl2.duvStart.v);
		};


	pwdisplay->wdispbraceClose.duvStart.u = pwdisplay->wdispbraceOpen.dup 
		+ dupInside;

	pwdisplay->wdispbraceClose.duvStart.v = 0;

	/*	REVIEW (antons): Clear the problem of possible difference 
		between dup-input and calculated dup in this procedure */

	pwdisplay->dupAll =  pwdisplay->wdispbraceOpen.dup + pwdisplay->wdispbraceClose.dup + 
						+ dupInside;

	/* REVIEW (antons): It is better if we try to make 
	   dup == pwdisplay->dupAll, do something like David Bangs in text */

/* REVIEW (antons): The following assert has been commented out for build 314 */

/*  Assert (dup == pwdisplay->dupAll); */

	return lserrNone;

} /* WarichuCalcPresentation */



/* W A R I C H U   Q U E R Y   P O I N T   P C P */
/*----------------------------------------------------------------------------
	%%Function: WarichuQueryPointPcp
	%%Contact: antons


----------------------------------------------------------------------------*/
LSERR WINAPI WarichuQueryPointPcp (

	PDOBJ		pdobj,			/* (IN): dobj to query */
	PCPOINTUV	ppointuvQuery,	/* (IN): query point (uQuery,vQuery) */
	PCLSQIN		plsqin,			/* (IN): query input */
	PLSQOUT		plsqout)		/* (OUT): query output */
{
	/* REVIEW (antons): I changed logic of snapping; must be checked */

	/* The new version does not allow to come to open & close bracket */

	WDISPLAY * pwdisplay = & pdobj->wdisplay;
	WLAYOUT * pwlayout = & pdobj->wlayout;

	if (pwlayout->wsubline2.plssubl == NULL)
		{
		/* Only first subline ;-) */

		return CreateQueryResult (pwlayout->wsubline1.plssubl, 
								  pwdisplay->wdispsubl1.duvStart.u, 
								  pwdisplay->wdispsubl1.duvStart.v,
								  plsqin, plsqout );
		}
	else
		{
		/* Two sublines; snap according to v-point */

		long dvMiddle = 
			( pwdisplay->wdispsubl1.duvStart.v - pwlayout->wsubline1.objdim.heightsPres.dvDescent +
			  pwdisplay->wdispsubl2.duvStart.v + pwlayout->wsubline2.objdim.heightsPres.dvAscent ) / 2;

		/* dvMiddle is v-level which devides between first and second lines of Warichu */

		if (ppointuvQuery->v >= dvMiddle) 
			{
			/* Snapping to the first subline */

			return CreateQueryResult (pwlayout->wsubline1.plssubl, 
									  pwdisplay->wdispsubl1.duvStart.u, 
									  pwdisplay->wdispsubl1.duvStart.v,
									  plsqin, plsqout );
			}
		else
			{
			/* Snapping to the second subline */

			return CreateQueryResult (pwlayout->wsubline2.plssubl, 
									  pwdisplay->wdispsubl2.duvStart.u, 
									  pwdisplay->wdispsubl2.duvStart.v,
									  plsqin, plsqout );
			};

	}; /* if (pwlayout->wsubline2.plssubl == NULL) */

} /* WarichuQueryPointPcp */



/* W A R I C H U  Q U E R Y  C P  P P O I N T */
/*----------------------------------------------------------------------------
	%%Function: WarichuQueryCpPpoint
	%%Contact: antons


----------------------------------------------------------------------------*/
LSERR WINAPI WarichuQueryCpPpoint(

		PDOBJ		pdobj,				/* (IN): dobj to query, */
		LSDCP		dcp,				/* (IN): dcp for the query */
		PCLSQIN		plsqin,				/* (IN): query input */
		PLSQOUT		plsqout)			/* (OUT): query output */
{

	/* REVIEW (antons): I changed logic of snapping; must be checked */

	WDISPLAY * pwdisplay = & pdobj->wdisplay;
	WLAYOUT	* pwlayout = & pdobj->wlayout;
	LSCP cpQuery = pdobj->cpStart + dcp;

	if (FOpenBraceInWLayout (pdobj, pwlayout) && 
		cpQuery < pwlayout->wsubline1.cpFirst)
		{
		/* Snap to the openning brace */

		return CreateQueryResult (pdobj->wbraceOpen.plssubl, 
								  pwdisplay->wdispbraceOpen.duvStart.u,
								  pwdisplay->wdispbraceOpen.duvStart.v,
								  plsqin, plsqout );
		}

	else if (FCloseBraceInWLayout (pdobj, pwlayout) && 
			 cpQuery >= pdobj->wbraceClose.cpFirst )
		 {
		/* Snap to the closing brace */

		return CreateQueryResult (pdobj->wbraceClose.plssubl, 
								  pwdisplay->wdispbraceClose.duvStart.u,
								  pwdisplay->wdispbraceClose.duvStart.v,
								  plsqin, plsqout );
		  }

	else if (pwlayout->wsubline2.plssubl == NULL)
		{
		/* Only first subline, snap to the first */

		return CreateQueryResult (pwlayout->wsubline1.plssubl, 
								  pwdisplay->wdispsubl1.duvStart.u, 
								  pwdisplay->wdispsubl1.duvStart.v,
								  plsqin, plsqout );
		}

	else if (cpQuery < pwlayout->wsubline2.cpFirst)
		{
		/* Snap to the first subline */

		return CreateQueryResult (pwlayout->wsubline1.plssubl, 
								  pwdisplay->wdispsubl1.duvStart.u, 
								  pwdisplay->wdispsubl1.duvStart.v,
								  plsqin, plsqout );
		}
	else
		{
		/* Snap to the second subline */

		return CreateQueryResult (pwlayout->wsubline2.plssubl, 
								  pwdisplay->wdispsubl2.duvStart.u, 
								  pwdisplay->wdispsubl2.duvStart.v,
								  plsqin, plsqout );
		};

} /* WarichuQueryPointPcp */


/* G E T  W A R I C H U  X Y  P O I N T S */
/*----------------------------------------------------------------------------
	%%Function: GetWarichuXYPoints
	%%Contact: antons


----------------------------------------------------------------------------*/

static void GetWarichuXYPoints (

		PDOBJ		pdobj, 
		const POINT	* ppt, 
		LSTFLOW		lstflow, 
		POINT		* pptOpen, 
		POINT		* pptFirst,
		POINT		* pptSecond,
		POINT		* pptClose )
{
	LSERR		lserr;

	WDISPLAY	* pwdisplay = & pdobj->wdisplay;
	WLAYOUT		* pwlayout = & pdobj->wlayout;

	/* REVIEW (antons): How they can not be equal */
	Assert (lstflow == pdobj->lstflowParent);

	/* OPEN BRACE */

	if (FOpenBraceInWLayout(pdobj, pwlayout))
		{
		lserr = LsPointXYFromPointUV (ppt, lstflow, 
									  & pwdisplay->wdispbraceOpen.duvStart, pptOpen);
		/* REVIEW (antons): Is it OK to have such asserts? */
		Assert (lserr == lserrNone);
		};

	/* FIRST SUBLINE */

	lserr = LsPointXYFromPointUV (ppt, lstflow, 
								  & pwdisplay->wdispsubl1.duvStart, pptFirst);
	Assert (lserr == lserrNone);

	/* SECIND SUBLINE */

	if (pwlayout->wsubline2.plssubl != NULL)
		{
		lserr = LsPointXYFromPointUV (ppt, lstflow, 
									  & pwdisplay->wdispsubl2.duvStart, pptSecond);
		Assert (lserr == lserrNone);
		};

	/* CLOSE BRACE */

	if (FCloseBraceInWLayout(pdobj, pwlayout))
		{
		lserr = LsPointXYFromPointUV (ppt, lstflow, 
									  & pwdisplay->wdispbraceClose.duvStart, pptClose);
		Assert (lserr == lserrNone);
		};

} /* GetWarichuXYPoints */


/* W A R I C H U  D I S P L A Y */
/*----------------------------------------------------------------------------
	%%Function: WarichuDisplay
	%%Contact: antons


----------------------------------------------------------------------------*/
LSERR WINAPI WarichuDisplay (PDOBJ pdobj, PCDISPIN pcdispin)
{
	/* Now it is very elegant ;-) */

	WLAYOUT	 *pwlayout = & pdobj->wlayout;

	LSERR lserr;
	POINT ptOpen;
	POINT ptFirst;
	POINT ptSecond;
	POINT ptClose;

	GetWarichuXYPoints (pdobj, &pcdispin->ptPen, pcdispin->lstflow,
						& ptOpen, & ptFirst, & ptSecond, & ptClose );

	/* Printing open brace */

	if (FOpenBraceInWLayout(pdobj, pwlayout))
		{
		lserr = LsDisplaySubline (pdobj->wbraceOpen.plssubl, &ptOpen, 
								  pcdispin->kDispMode, pcdispin->prcClip);
		if (lserr != lserrNone) return lserr;
		};

	/* Printing 1st subline of Warichu */
	
	lserr = LsDisplaySubline (pwlayout->wsubline1.plssubl, &ptFirst, 
							  pcdispin->kDispMode, pcdispin->prcClip);
	if (lserr != lserrNone) return lserr;

	/* Printing 2nd subline of Warichu */

	if (pwlayout->wsubline2.plssubl != NULL)
		{
		lserr = LsDisplaySubline (pwlayout->wsubline2.plssubl, &ptSecond, 
							  pcdispin->kDispMode, pcdispin->prcClip);
		if (lserr != lserrNone) return lserr;
		}

	/* Printing close brace */

	if (FCloseBraceInWLayout(pdobj, pwlayout))
		{
		lserr = LsDisplaySubline (pdobj->wbraceClose.plssubl, &ptClose,
								  pcdispin->kDispMode, pcdispin->prcClip);
		if (lserr != lserrNone) return lserr;
		};

	return lserrNone;
}

/* W A R I C H U  D E S T R O Y  D O B J */
/*----------------------------------------------------------------------------
	%%Function: WarichuDestroyDobj
	%%Contact: antons

	
----------------------------------------------------------------------------*/
LSERR WINAPI WarichuDestroyDobj (PDOBJ pdobj)
{
	/* REVIEW (antons): Should we eliminate this extra call? */

	return DestroyDobj (pdobj);
}


/* W A R I C H U E N U M */
/*----------------------------------------------------------------------------
	%%Function: WarichuEnum
	%%Contact: antons

	
----------------------------------------------------------------------------*/
LSERR WINAPI WarichuEnum(
	PDOBJ pdobj,				/*(IN): dobj to enumerate */
	PLSRUN plsrun,				/*(IN): from DNODE */
	PCLSCHP plschp,				/*(IN): from DNODE */
	LSCP cp,					/*(IN): from DNODE */
	LSDCP dcp,					/*(IN): from DNODE */
	LSTFLOW lstflow,			/*(IN): text flow*/
	BOOL fReverse,				/*(IN): enumerate in reverse order */
	BOOL fGeometryNeeded,		/*(IN): do we provide geometry ? */
	const POINT *pt,			/*(IN): starting position (top left), iff fGeometryNeeded */
	PCHEIGHTS pcheights,		/*(IN): from DNODE, relevant iff fGeometryNeeded */
	long dupRun)				/*(IN): from DNODE, relevant iff fGeometryNeeded */
{
	POINT ptOpen;
	POINT ptClose;
	POINT ptFirst;
	POINT ptSecond;

	WLAYOUT * pwlayout = & pdobj->wlayout;
	WDISPLAY * pwdisplay = & pdobj->wdisplay;

	if (fGeometryNeeded)
		{
		GetWarichuXYPoints (pdobj, pt, lstflow, &ptOpen, &ptFirst, &ptSecond, &ptClose);
		}

	/* REVIEW (antons): Should we provide something like fOpenBrace & fCloseBrace */

	return pdobj->pilsobj->warichucbk.pfnWarichuEnum (
		
		pdobj->pilsobj->pols, 
		plsrun,	plschp, cp, dcp, 

		lstflow, fReverse, fGeometryNeeded, 

		pt,	pcheights, dupRun, 

		& ptOpen,  & pdobj->wbraceOpen. objdim.heightsPres, pwdisplay->wdispbraceOpen .dup,
		& ptClose, & pdobj->wbraceClose.objdim.heightsPres, pwdisplay->wdispbraceClose.dup,

		&ptFirst, & pwlayout->wsubline1.objdim.heightsPres, pwdisplay->wdispsubl1.dup,
		&ptSecond,& pwlayout->wsubline2.objdim.heightsPres, pwdisplay->wdispsubl2.dup,

		pdobj->wbraceOpen.plssubl,
		pdobj->wbraceClose.plssubl,
		pwlayout->wsubline1.plssubl,	
		pwlayout->wsubline2.plssubl );
}

/* G E T W A R I C H U L S I M E T H O D S */
/*----------------------------------------------------------------------------
	%%Function: GetWarichuLsimethods
	%%Contact: ricksa

		Get LSIMETHODS so client application can use Warichu object handler.
	
----------------------------------------------------------------------------*/
LSERR WINAPI LsGetWarichuLsimethods (LSIMETHODS *plsim)
{
	plsim->pfnCreateILSObj = WarichuCreateILSObj;
	plsim->pfnDestroyILSObj = WarichuDestroyILSObj;
	plsim->pfnSetDoc = WarichuSetDoc;
	plsim->pfnCreateLNObj = WarichuCreateLNObj;
	plsim->pfnDestroyLNObj = WarichuDestroyLNObj;
	plsim->pfnFmt = WarichuFmt;
	plsim->pfnFmtResume = WarichuFmtResume; 
	plsim->pfnGetModWidthPrecedingChar = WarichuGetModWidthPrecedingChar;
	plsim->pfnGetModWidthFollowingChar = WarichuGetModWidthFollowingChar;
	plsim->pfnTruncateChunk = WarichuTruncateChunk;
	plsim->pfnFindPrevBreakChunk = WarichuFindPrevBreakChunk;
	plsim->pfnFindNextBreakChunk = WarichuFindNextBreakChunk;
	plsim->pfnForceBreakChunk = WarichuForceBreakChunk;
	plsim->pfnSetBreak = WarichuSetBreak;
	plsim->pfnGetSpecialEffectsInside = WarichuGetSpecialEffectsInside;
	plsim->pfnFExpandWithPrecedingChar = ObjHelpFExpandWithPrecedingChar;
	plsim->pfnFExpandWithFollowingChar = ObjHelpFExpandWithFollowingChar;
	plsim->pfnCalcPresentation = WarichuCalcPresentation;
	plsim->pfnQueryPointPcp = WarichuQueryPointPcp;
	plsim->pfnQueryCpPpoint = WarichuQueryCpPpoint;
	plsim->pfnDisplay = WarichuDisplay;
	plsim->pfnDestroyDObj = WarichuDestroyDobj;
	plsim->pfnEnum = WarichuEnum;

	return lserrNone;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\lssrc\vruby.c ===
/* ---------------------------- */
/*								*/
/* Vertical Ruby object handler */
/*								*/
/* Contact: antons				*/
/*								*/
/* ---------------------------- */


#include	"lsmem.h"
#include	"limits.h"
#include	"vruby.h"
#include	"objhelp.h"
#include	"lscbk.h"
#include	"lsdevres.h"
#include	"pdobj.h"
#include	"objdim.h"
#include	"plssubl.h"
#include	"plsdnode.h"
#include	"pilsobj.h"
#include	"lscrsubl.h"
#include	"lssubset.h"
#include	"lsdnset.h"
#include	"zqfromza.h"
#include	"lsdocinf.h"
#include	"fmti.h"
#include	"posichnk.h"
#include	"locchnk.h"
#include	"lsdnfin.h"
#include	"brko.h"
#include	"lspap.h"
#include	"plspap.h"
#include	"lsqsubl.h"
#include	"dispi.h"
#include	"lsdssubl.h"
#include	"lsems.h"
#include	"dispmisc.h"
#include	"lstfset.h"
#include	"lsqout.h"
#include	"lsqin.h"
#include	"sobjhelp.h"
#include	"brkkind.h"


#define VRUBY_MAIN_ESC_CNT	1
#define VRUBY_RUBY_ESC_CNT	1


#define max(a,b) ((a)>(b) ? (a) : (b))

struct ilsobj
{
    POLS				pols;
	LSCBK				lscbk;
	PLSC				plsc;
	LSDEVRES			lsdevres;
	VRUBYSYNTAX			vrubysyntax;
	LSESC				lsescMain;
	LSESC				lsescRuby;
	VRUBYCBK			vrcbk;		/* Callbacks  to client application */

};

struct dobj
{	
	SOBJHELP			sobjhelp;			/* common area for simple objects */	
	PILSOBJ				pilsobj;			/* ILS object */
	PLSDNODE			plsdn;				/* DNODE for this object */
	PLSRUN				plsrun;				/* PLSRUN of the object */
	LSCP				cpStart;			/* Starting LS cp for object */
	LSTFLOW				lstflowParent;		/* text flow of the parent subline */
	LSTFLOW				lstflowRuby;		/* text flow of the ruby subline (must be Rotate90CloclWise [lstflowParent]) */

	LSCP				cpStartRuby;		/* first cp of the ruby line */
	LSCP				cpStartMain;		/* first cp of the main line */

	PLSSUBL				plssublMain;		/* Handle to first subline */
	PLSSUBL				plssublRuby;		/* Handle to second line */

	HEIGHTS				heightsRefRubyT;	/* Ref and pres height of rotated Ruby line as given by client */
	HEIGHTS				heightsPresRubyT;

	OBJDIM				objdimMain;			/* Dimensions of the main subline */
	OBJDIM				objdimRuby;			/* Dimensions of the ruby subline */

	/* Display information */

	long				dupMain;
	long				dupOffsetRuby;		/* Offset of Ruby line's baseline from start of object */
	long				dvpOffsetRuby;		/* Offset of Ruby line's baseline from start of object */

};


/* V R U B Y  F R E E  D O B J */
/*----------------------------------------------------------------------------
	%%Function: VRubyFreeDobj
	%%Contact: antons

		Free all resources associated with this VRuby dobj.
	
----------------------------------------------------------------------------*/
static LSERR VRubyFreeDobj (PDOBJ pdobj)
{
	LSERR lserr1 = lserrNone;
	LSERR lserr2 = lserrNone;

	PILSOBJ pilsobj = pdobj->pilsobj;

	if (pdobj->plssublMain != NULL)
		{
		lserr1 = LsDestroySubline(pdobj->plssublMain);
		}

	if (pdobj->plssublRuby != NULL)
		{
		lserr2 = LsDestroySubline(pdobj->plssublRuby);
		}

    pilsobj->lscbk.pfnDisposePtr(pilsobj->pols, pdobj);

	if (lserr1 != lserrNone) return lserr1;
	else return lserr2;

}


/* V R U B Y  F M T  F A I L E D */
/*----------------------------------------------------------------------------
	%%Function: RubyFmtFailed
	%%Contact: antons

		Could not create VRuby DOBJ due to error. 

----------------------------------------------------------------------------*/
static LSERR VRubyFmtFailed (PDOBJ pdobj, LSERR lserr)
{
	if (pdobj != NULL) VRubyFreeDobj (pdobj); /* Works with parially-filled DOBJ */

	return lserr;
}



/* V R U B I C R E A T E I L S O B J */
/*----------------------------------------------------------------------------
	%%Function: VRubyCreateILSObj
	%%Contact: antons

		Create the ILS object for all VRuby objects.
	
----------------------------------------------------------------------------*/
LSERR WINAPI VRubyCreateILSObj (
	POLS pols,				/* (IN): client application context */
	PLSC plsc,				/* (IN): LS context */
	PCLSCBK pclscbk,		/* (IN): callbacks to client application */
	DWORD idObj,			/* (IN): id of the object */
	PILSOBJ *ppilsobj)		/* (OUT): object ilsobj */
{
    PILSOBJ pilsobj;
	LSERR lserr;
	VRUBYINIT vrubyinit;
	vrubyinit.dwVersion = VRUBY_VERSION;

	/* Get initialization data */
	lserr = pclscbk->pfnGetObjectHandlerInfo(pols, idObj, &vrubyinit);

	if (lserr != lserrNone)	return lserr;

    pilsobj = pclscbk->pfnNewPtr(pols, sizeof(*pilsobj));

	if (NULL == pilsobj) return lserrOutOfMemory;

    pilsobj->pols = pols;
    pilsobj->lscbk = *pclscbk;
	pilsobj->plsc = plsc;
	pilsobj->lsescMain.wchFirst = vrubyinit.wchEscMain;
	pilsobj->lsescMain.wchLast = vrubyinit.wchEscMain;
	pilsobj->lsescRuby.wchFirst = vrubyinit.wchEscRuby;
	pilsobj->lsescRuby.wchLast = vrubyinit.wchEscRuby;
	pilsobj->vrcbk = vrubyinit.vrcbk;
	pilsobj->vrubysyntax = vrubyinit.vrubysyntax;

	*ppilsobj = pilsobj;
	return lserrNone;
}

/* V R U B I D E S T R O Y I L S O B J */
/*----------------------------------------------------------------------------
	%%Function: RubyDestroyILSObj
	%%Contact: antons

		Free all resources assocaiated with VRuby ILS object.
	
----------------------------------------------------------------------------*/
LSERR WINAPI VRubyDestroyILSObj(
	PILSOBJ pilsobj)			/* (IN): object ilsobj */
{
	pilsobj->lscbk.pfnDisposePtr(pilsobj->pols, pilsobj);
	return lserrNone;
}

/* V R U B I S E T D O C */
/*----------------------------------------------------------------------------
	%%Function: VRubySetDoc
	%%Contact: antons

		Keep track of device resolution.
	
----------------------------------------------------------------------------*/

LSERR WINAPI VRubySetDoc(
	PILSOBJ pilsobj,			/* (IN): object ilsobj */
	PCLSDOCINF pclsdocinf)		/* (IN): initialization data of the document level */
{
	pilsobj->lsdevres = pclsdocinf->lsdevres;
	return lserrNone;
}


/* V R U B I C R E A T E L N O B J */
/*----------------------------------------------------------------------------
	%%Function: RubyCreateLNObj
	%%Contact: antons

		Create the Line Object for the Ruby. Since we only really need
		the global ILS object, just pass that object back as the line object.
	
----------------------------------------------------------------------------*/

LSERR WINAPI VRubyCreateLNObj (PCILSOBJ pcilsobj, PLNOBJ *pplnobj)
{
	*pplnobj = (PLNOBJ) pcilsobj;
	return lserrNone;
}

/* V R U B I D E S T R O Y L N O B J */
/*----------------------------------------------------------------------------
	%%Function: RubyDestroyLNObj
	%%Contact: antons

		Frees resources associated with the Ruby line object. No-op because
		we don't really allocate one.
	
----------------------------------------------------------------------------*/

LSERR WINAPI VRubyDestroyLNObj (PLNOBJ plnobj)
{
	Unreferenced(plnobj);
	return lserrNone;
}


/* L S F T L O W   V R U B Y   F R O M   L S T F L O W   M A I N */
/* ----------------------------------------------------------------------------
	%%Function: LstflowVRubyFromLstflowMain
	%%Contact: antons

	
----------------------------------------------------------------------------*/

LSTFLOW LstflowVRubyFromLstflowMain (LSTFLOW lstflow)
{
	static LSTFLOW lstflowRotateForRuby [] =
		{
		lstflowSW, /* [ lstflowES ] - english */
		lstflowNW, /* [ lstflowEN ] */ 
		lstflowEN, /* [ lstflowSE ] */
		lstflowWN, /* [ lstflowSW ] */

		lstflowSE, /* [ lstflowWS ] - bidi */

		lstflowNE, /* [ lstflowWN ] */
		lstflowES, /* [ lstflowNE ] */
		lstflowWS  /* [ lstflowNW ] */
		};

	return lstflowRotateForRuby [lstflow];
}

/* C A L C  A G R E G A T E D   H E I G H T */
/*----------------------------------------------------------------------------
	%%Function: CalcAgregatedHeight
	%%Contact: antons


----------------------------------------------------------------------------*/


void CalcAgregatedHeights (PCHEIGHTS pcHeights1, PCHEIGHTS pcHeights2, PHEIGHTS pHeightOut)
{
	pHeightOut->dvAscent = max (pcHeights1->dvAscent, pcHeights2->dvAscent);
	pHeightOut->dvDescent = max (pcHeights1->dvDescent, pcHeights2->dvDescent);
	pHeightOut->dvMultiLineHeight = max (pcHeights1->dvMultiLineHeight, pcHeights2->dvMultiLineHeight);
}


/* V R U B I F M T */
/*----------------------------------------------------------------------------
	%%Function: VRubyFmt
	%%Contact: antons

		Format Vertical Ruby object
	
----------------------------------------------------------------------------*/

LSERR WINAPI VRubyFmt(
    PLNOBJ plnobj,				/* (IN): object lnobj */
    PCFMTIN pcfmtin,			/* (IN): formatting input */
    FMTRES *pfmtres)			/* (OUT): formatting result */
{
	PDOBJ pdobj;
	LSERR lserr;
	PILSOBJ pilsobj = (PILSOBJ) plnobj;
	POLS pols = pilsobj->pols;
	LSCP cpStartMain;
	LSCP cpStartRuby = pcfmtin->lsfgi.cpFirst + 1;
	LSCP cpOut;
	LSTFLOW lstflow = pcfmtin->lsfgi.lstflow;
	FMTRES fmtres;
	FMTRES fmtr = fmtrCompletedRun;
	LONG durAdjust;

    /* Allocate the DOBJ */

    pdobj = pilsobj->lscbk.pfnNewPtr(pols, sizeof(*pdobj));

    if (pdobj == NULL) return VRubyFmtFailed (NULL, lserrOutOfMemory);

	ZeroMemory(pdobj, sizeof(*pdobj));
	pdobj->pilsobj = pilsobj;
	pdobj->plsrun = pcfmtin->lsfrun.plsrun;
	pdobj->plsdn = pcfmtin->plsdnTop;
	pdobj->cpStart = pcfmtin->lsfgi.cpFirst;
	pdobj->lstflowParent = lstflow;
	pdobj->lstflowRuby = LstflowVRubyFromLstflowMain (lstflow);

	if (VRubyPronunciationLineFirst == pilsobj->vrubysyntax)
		{
		/* Build pronunciation line of text */
		
		lserr = FormatLine ( pilsobj->plsc, cpStartRuby, LONG_MAX, pdobj->lstflowRuby,
							 & pdobj->plssublRuby, 1, &pilsobj->lsescRuby,
							 & pdobj->objdimRuby, &cpOut, NULL, NULL, &fmtres );

		/* +1 moves passed the ruby line escape character */
		cpStartMain = cpOut + 1;

		pdobj->cpStartRuby = cpStartRuby;
		pdobj->cpStartMain = cpStartMain;

		/* Build main line of text */

		if (lserrNone == lserr)
			{
			lserr = FormatLine ( pilsobj->plsc, cpStartMain, LONG_MAX, lstflow,
								 & pdobj->plssublMain, 1, &pilsobj->lsescMain,
								 & pdobj->objdimMain, &cpOut, NULL, NULL, &fmtres );
			}
		}
	else
		{
		/* Build main line of text */

		cpStartMain = cpStartRuby;

		lserr = FormatLine ( pilsobj->plsc, cpStartMain, LONG_MAX, lstflow,
							 & pdobj->plssublMain, 1, &pilsobj->lsescMain,  
							 & pdobj->objdimMain, &cpOut, NULL, NULL, &fmtres );

		/* +1 moves passed the main line escape character */
		cpStartRuby = cpOut + 1;

		pdobj->cpStartRuby = cpStartRuby;
		pdobj->cpStartMain = cpStartMain;

		/* Build pronunciation line of text */

		if (lserrNone == lserr)
			{
			lserr = FormatLine ( pilsobj->plsc, cpStartRuby, LONG_MAX, pdobj->lstflowRuby,
								 & pdobj->plssublRuby, 1, &pilsobj->lsescRuby,  
								 & pdobj->objdimRuby, &cpOut, NULL, NULL, &fmtres);

			}
		}

	if (lserr != lserrNone)	return VRubyFmtFailed (pdobj, lserr);

	/* Calculate the object dimensions */

	lserr = pilsobj->vrcbk.pfnFetchVRubyPosition
				( pols, pdobj->cpStart, pdobj->lstflowParent,
				  pdobj->plsrun,
				  &pdobj->objdimMain.heightsRef, &pdobj->objdimMain.heightsPres,
				  pdobj->objdimRuby.dur,
				  &pdobj->heightsPresRubyT,
				  &pdobj->heightsRefRubyT,
				  &durAdjust );

	if (lserr != lserrNone) return VRubyFmtFailed (pdobj, lserr);

	pdobj->sobjhelp.objdimAll.dur = pdobj->objdimMain.dur + pdobj->objdimRuby.heightsRef.dvDescent + 
															pdobj->objdimRuby.heightsRef.dvAscent +
															durAdjust ;

	CalcAgregatedHeights (&pdobj->objdimMain.heightsPres, &pdobj->heightsPresRubyT, &pdobj->sobjhelp.objdimAll.heightsPres );
	CalcAgregatedHeights (&pdobj->objdimMain.heightsRef, &pdobj->heightsRefRubyT, &pdobj->sobjhelp.objdimAll.heightsRef );

	/* Need to add 1 to take into account escape character at end. */

	pdobj->sobjhelp.dcp = cpOut - pdobj->cpStart + 1;

	lserr = LsdnFinishRegular(pilsobj->plsc, pdobj->sobjhelp.dcp, 
		pcfmtin->lsfrun.plsrun, pcfmtin->lsfrun.plschp, pdobj, 
			&pdobj->sobjhelp.objdimAll);
		
	if (lserr != lserrNone) return VRubyFmtFailed (pdobj, lserr);

	if (pcfmtin->lsfgi.urPen + pdobj->sobjhelp.objdimAll.dur > pcfmtin->lsfgi.urColumnMax)
		{
		fmtr = fmtrExceededMargin;
		}

	*pfmtres = fmtr;

	return lserrNone;
}


/* V R U B Y S E T B R E A K */
/*----------------------------------------------------------------------------
	%%Function: VRubySetBreak
	%%Contact: antons

		SetBreak

----------------------------------------------------------------------------*/

LSERR WINAPI VRubySetBreak (
	PDOBJ pdobj,				/* (IN): dobj which is broken */
	BRKKIND brkkind,			/* (IN): prev | next | force | after */
	DWORD cBreakRecord,			/* (IN): size of array */
	BREAKREC *rgBreakRecord,	/* (IN): array of break records */
	DWORD *pcActualBreakRecord)	/* (IN): actual number of used elements in array */
{
	Unreferenced (rgBreakRecord);
	Unreferenced (cBreakRecord);
	Unreferenced (brkkind);
	Unreferenced (pdobj);

	*pcActualBreakRecord = 0;

	return lserrNone;	
}

/* V R U B Y G E T S P E C I A L E F F E C T S I N S I D E */
/*----------------------------------------------------------------------------
	%%Function: VRubyGetSpecialEffectsInside
	%%Contact: antons

		VRubyGetSpecialEffectsInside


----------------------------------------------------------------------------*/
LSERR WINAPI VRubyGetSpecialEffectsInside(
	PDOBJ pdobj,				/* (IN): dobj */
	UINT *pEffectsFlags)		/* (OUT): Special effects for this object */
{
	LSERR lserr = LsGetSpecialEffectsSubline(pdobj->plssublMain, pEffectsFlags);

	if (lserrNone == lserr)
		{
		UINT uiSpecialEffectsRuby;
	
		lserr = LsGetSpecialEffectsSubline(pdobj->plssublRuby, &uiSpecialEffectsRuby);

		*pEffectsFlags |= uiSpecialEffectsRuby;
		}

	return lserr;
}

/* V R U B Y C A L C P R E S E N T A T I O N */
/*----------------------------------------------------------------------------
	%%Function: VRubyCalcPresentation
	%%Contact: antons

		CalcPresentation
	
----------------------------------------------------------------------------*/
LSERR WINAPI VRubyCalcPresentation (
	PDOBJ pdobj,				/* (IN): dobj */
	long dup,					/* (IN): dup of dobj */
	LSKJUST lskjust,			/* (IN): Justification type */
	BOOL fLastVisibleOnLine )	/* (IN): Is this object last visible on line? */
{
	LSERR lserr = lserrNone;
	LSTFLOW lstflowUnused;

	Unreferenced (lskjust);
	Unreferenced(dup);
	Unreferenced (fLastVisibleOnLine);
		
	lserr = LsMatchPresSubline(pdobj->plssublMain);
	if (lserr != lserrNone) return lserr;

	lserr = LsMatchPresSubline(pdobj->plssublRuby);
	if (lserr != lserrNone)	return lserr;

	LssbGetDupSubline (pdobj->plssublMain, &lstflowUnused, &pdobj->dupMain);

	pdobj->dupOffsetRuby = pdobj->dupMain + pdobj->objdimRuby.heightsPres.dvDescent;

	/* Review (antons): This will not work if horizintal res != vertical */

	pdobj->dvpOffsetRuby = pdobj->heightsPresRubyT.dvAscent;

	return lserr;
}

/* V R U B Y Q U E R Y P O I N T P C P */
/*----------------------------------------------------------------------------
	%%Function: RubyQueryPointPcp
	%%Contact: antons

----------------------------------------------------------------------------*/
LSERR WINAPI VRubyQueryPointPcp(
	PDOBJ pdobj,				/*(IN): dobj to query */
	PCPOINTUV ppointuvQuery,	/*(IN): query point (uQuery,vQuery) */
	PCLSQIN plsqin,				/*(IN): query input */
	PLSQOUT plsqout)			/*(OUT): query output */
{
	PLSSUBL plssubl;
 	long dupAdj;
	long dvpAdj;

	/*
	 * Decide which line to to return based on the height of the point input
	 */

	/* Assume main line */
	plssubl = pdobj->plssublMain;
	dupAdj = 0;
	dvpAdj = 0;

	if (ppointuvQuery->u > pdobj->dupMain)
		{
		/* hit second line */

		plssubl = pdobj->plssublRuby;
		dupAdj = pdobj->dupOffsetRuby;
		dvpAdj = pdobj->dvpOffsetRuby;
		}

	return CreateQueryResult(plssubl, dupAdj, dvpAdj, plsqin, plsqout);
}
	
/* V R U B Y Q U E R Y C P P P O I N T */
/*----------------------------------------------------------------------------
	%%Function: RubyQueryCpPpoint
	%%Contact: antons

----------------------------------------------------------------------------*/
LSERR WINAPI VRubyQueryCpPpoint(
	PDOBJ pdobj,				/*(IN): dobj to query, */
	LSDCP dcp,					/*(IN): dcp for the query */
	PCLSQIN plsqin,				/*(IN): query input */
	PLSQOUT plsqout)			/*(OUT): query output */
{
	PLSSUBL plssubl;
 	long dupAdj;
	long dvpAdj;
	BOOL fMain = fFalse;

	LSCP cpQuery = pdobj->cpStart + dcp;

	/* Assume ruby line */
	plssubl = pdobj->plssublRuby;
	dupAdj = pdobj->dupOffsetRuby;
	dvpAdj = pdobj->dvpOffsetRuby;

	/* + 1 means we include the cp of the object in the Ruby pronunciation line. */
	if (VRubyPronunciationLineFirst == pdobj->pilsobj->vrubysyntax)
		{
		/* Ruby pronunciation line is first */
		if (cpQuery >= pdobj->cpStartMain)
			{
			fMain = fTrue;
			}
		}
	else
		{
		/* Main text line is first */
		if (cpQuery < pdobj->cpStartRuby)
			{
			fMain = fTrue;
			}
		}

	if (fMain)
		{
		plssubl = pdobj->plssublMain;
		dupAdj = 0;
		dvpAdj = 0;
		}

	return CreateQueryResult(plssubl, dupAdj, dvpAdj, plsqin, plsqout);
}

	
/* V R U B I D I S P L A Y */
/*----------------------------------------------------------------------------
	%%Function: VRubyDisplay
	%%Contact: antons

	
----------------------------------------------------------------------------*/
LSERR WINAPI VRubyDisplay(
	PDOBJ pdobj,				/*(IN): dobj to display */
	PCDISPIN pcdispin)			/*(IN): display info */
{
	LSERR lserr;
	UINT kDispMode = pcdispin->kDispMode;
	POINTUV ptAdd;
	POINT ptLine;

	/* display first line */
	lserr = LsDisplaySubline(pdobj->plssublMain, &pcdispin->ptPen, kDispMode,
		pcdispin->prcClip);

	if (lserr != lserrNone)	return lserr;

	ptAdd.u = pdobj->dupOffsetRuby;
	ptAdd.v = pdobj->dvpOffsetRuby;

	LsPointXYFromPointUV(&pcdispin->ptPen, pdobj->lstflowParent, &ptAdd, &ptLine);

	return LsDisplaySubline(pdobj->plssublRuby, &ptLine, kDispMode, pcdispin->prcClip);
}

/* V R U B I D E S T R O Y D O B J */
/*----------------------------------------------------------------------------
	%%Function: VRubyDestroyDobj
	%%Contact: antons


----------------------------------------------------------------------------*/
LSERR WINAPI VRubyDestroyDobj(
	PDOBJ pdobj)				/*(IN): dobj to destroy */
{
	return VRubyFreeDobj (pdobj);
}

/* V R U B Y E N U M */
/*----------------------------------------------------------------------------
	%%Function: VRubyEnum
	%%Contact: antons

	
----------------------------------------------------------------------------*/
LSERR WINAPI VRubyEnum (
	PDOBJ pdobj,				/*(IN): dobj to enumerate */
	PLSRUN plsrun,				/*(IN): from DNODE */
	PCLSCHP plschp,				/*(IN): from DNODE */
	LSCP cp,					/*(IN): from DNODE */
	LSDCP dcp,					/*(IN): from DNODE */
	LSTFLOW lstflow,			/*(IN): text flow*/
	BOOL fReverse,				/*(IN): enumerate in reverse order */
	BOOL fGeometryNeeded,		/*(IN): */
	const POINT *ppt,			/*(IN): starting position (top left), iff fGeometryNeeded */
	PCHEIGHTS pcheights,		/*(IN): from DNODE, relevant iff fGeometryNeeded */
	long dupRun )				/*(IN): from DNODE, relevant iff fGeometryNeeded */
{
	POINT ptMain;
	POINT ptRuby;
	POINTUV ptAdd;
	long dupMain = 0;
	long dupRuby = 0;
	LSERR lserr;
	LSTFLOW lstflowIgnored;

	if (fGeometryNeeded)
		{
		ptMain = *ppt; 
		ptAdd.u = pdobj->dupOffsetRuby;
		ptAdd.v = pdobj->dvpOffsetRuby;

		LsPointXYFromPointUV(ppt, pdobj->lstflowParent, &ptAdd, &ptRuby);

		lserr = LssbGetDupSubline(pdobj->plssublMain, &lstflowIgnored, &dupMain);
		if (lserr != lserrNone) return lserr;

		lserr = LssbGetDupSubline(pdobj->plssublRuby, &lstflowIgnored, &dupRuby);
		if (lserr != lserrNone) return lserr;
		}

	return pdobj->pilsobj->vrcbk.pfnVRubyEnum (pdobj->pilsobj->pols, plsrun, 
		plschp, cp, dcp, lstflow, fReverse, fGeometryNeeded, ppt, pcheights, 
			dupRun, &ptMain, &pdobj->objdimMain.heightsPres, dupMain, &ptRuby, 
				&pdobj->objdimRuby.heightsPres, dupRuby, pdobj->plssublMain,
					pdobj->plssublRuby);

}
	

/* V R U B I H A N D L E R I N I T */
/*----------------------------------------------------------------------------
	%%Function: VRubyHandlerInit
	%%Contact: antons

	
----------------------------------------------------------------------------*/
LSERR WINAPI LsGetVRubyLsimethods ( LSIMETHODS *plsim )
{
	plsim->pfnCreateILSObj = VRubyCreateILSObj;
	plsim->pfnDestroyILSObj = VRubyDestroyILSObj;
	plsim->pfnSetDoc = VRubySetDoc;
	plsim->pfnCreateLNObj = VRubyCreateLNObj;
	plsim->pfnDestroyLNObj = VRubyDestroyLNObj;
	plsim->pfnFmt = VRubyFmt;
	plsim->pfnFmtResume = ObjHelpFmtResume;
	plsim->pfnGetModWidthPrecedingChar = ObjHelpGetModWidthChar;
	plsim->pfnGetModWidthFollowingChar = ObjHelpGetModWidthChar;
	plsim->pfnTruncateChunk = SobjTruncateChunk;
	plsim->pfnFindPrevBreakChunk = SobjFindPrevBreakChunk;
	plsim->pfnFindNextBreakChunk = SobjFindNextBreakChunk;
	plsim->pfnForceBreakChunk = SobjForceBreakChunk;
	plsim->pfnSetBreak = VRubySetBreak;
	plsim->pfnGetSpecialEffectsInside = VRubyGetSpecialEffectsInside;
	plsim->pfnFExpandWithPrecedingChar = ObjHelpFExpandWithPrecedingChar;
	plsim->pfnFExpandWithFollowingChar = ObjHelpFExpandWithFollowingChar;
	plsim->pfnCalcPresentation = VRubyCalcPresentation;
	plsim->pfnQueryPointPcp = VRubyQueryPointPcp;
	plsim->pfnQueryCpPpoint = VRubyQueryCpPpoint;
	plsim->pfnDisplay = VRubyDisplay;
	plsim->pfnDestroyDObj = VRubyDestroyDobj;
	plsim->pfnEnum = VRubyEnum;

	return lserrNone;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\antievt.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module	ANTIEVT.C |
 *
 *	Purpose:
 *		implemenation of common anti-events and a caching mechanism
 *
 *	Author:
 *		alexgo 3/25/95
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_m_undo.h"
#include "_antievt.h"
#include "_edit.h"
#include "_range.h"
#include "_select.h"
#include "_format.h"
#include "_coleobj.h"
#include "_objmgr.h"
#ifdef DEBUG
#include "_uspi.h"
#endif

ASSERTDATA


//
// CAntiEventDispenser global instance
//
CAntiEventDispenser gAEDispenser;


//
//	CBaseAE PUBLIC methods
//

/*
 *	CBaseAE::Destroy ()
 *
 *	@mfunc
 *		sends the Destroy notification to the next anti-event in the list
 */

void CBaseAE::Destroy()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CBaseAE::Destroy");
	;
}

/*
 *	CBaseAE::Undo (ped, publdr)
 *
 *	@mfunc
 *		sends the Undo notification to the next anti-event in the list
 *
 *	@rdesc	HRESULT
 */
HRESULT CBaseAE::Undo(
	CTxtEdit *ped,			//@parm	the context for this undo operation
	IUndoBuilder *publdr)	//@parm the undo context.
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CBaseAE::Undo");
	return NOERROR;
}

/*
 *	CBaseAE::OnCommit (ped)
 *
 *	@mfunc	called after the anti-event is added to the undo stack
 *
 *	@rdesc	void
 */
void CBaseAE::OnCommit(
	CTxtEdit *ped)			//@parm the edit context
{
	;
}

/*
 *	CBaseAE::MergeData (dwDataType, pdata)
 *
 *	@mfunc	simply forwards the merge data request to the next anti-evt
 *			(if one exists)
 *
 *	@rdesc	HRESULT.  If S_FALSE, indicates that nothing could be done
 *			with the merge data.
 */
HRESULT	CBaseAE::MergeData(
	DWORD dwDataType, 		//@parm the type of data in <p pdata>
	void *pdata)			//@parm the merge data
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CBaseAE::MergeData");

	return S_FALSE;
}

/*
 *	CBaseAE::SetNext
 *
 *	@mfunc
 *		informs this anti-event of the anti-event which should follow it
 */
void CBaseAE::SetNext(
	IAntiEvent *pNext)		//@parm	the AntiEvent to link to
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CBaseAE::SetNext");

	_pnext  = pNext;
}

/*
 *	CBaseAE::GetNext
 *
 *	@mfunc
 *		retrieves the next element (if any)
 *
 *	@rdesc	a pointer to the next AntiEvent
 */
IAntiEvent *CBaseAE::GetNext()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CBaseAE::GetNext");

	return _pnext;
}

//
// CBaseAE PROTECTED methods
//

/*
 *	CBaseAE::CBaseAE()
 *
 *	@mfunc	Constructor
 */
CBaseAE::CBaseAE()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CBaseAE::CBaseAE");

	_pnext = NULL;
}

/*
 *	CReplaceRangeAE::Destroy ()
 *
 *	@mfunc
 *		deletes this instance
 */
void CReplaceRangeAE::Destroy()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceRangeAE::Destroy");

	if(_paeCF)
	{
		_paeCF->Destroy();
		_paeCF = NULL;
	}
	if(_paePF)
	{
		_paePF->Destroy();
		_paePF = NULL;
	}

	CBaseAE::Destroy();
	delete this;
}
	
/*
 *	CReplaceRangeAE::Undo (ped, publdr)
 *
 *	@mfunc
 *		undoes a CTxtPtr::ReplaceRange operation
 *
 *	@comm	
 *	Algorithm:
 *
 *		A replace range works as follows:  delete n characters and in their
 *		place, put m characters.
 *
 *		To undo this, we delete m characters and restore the n that were
 *		originally deleted.  Note that we restore the n characters with
 *		default formatting.  If there was any other formatting to those
 *		characters, a separate anti-event (CReplaceFormattingAE) will
 *		apply the correct formatting.
 */
HRESULT CReplaceRangeAE::Undo(
	CTxtEdit *ped,			//@parm	Context for this undo operation
	IUndoBuilder *publdr)	//@parm Undo context	
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceRangeAE::Undo");

	CRchTxtPtr	rtp(ped, _cpMin);
	LONG		cchMove = 0;

	rtp.ReplaceRange(_cpMax - _cpMin,
		             _cchDel,
					 _pchDel,
					 publdr,
					 -1,
					 &cchMove,
					 RR_NO_EOR_CHECK | RR_ITMZ_NONE);		// RAID 6554


	// Passing NULL for the publdr is *extremely* important
	// below.  The rich text pointer ReplaceRange call will
	// already generate the appropriate anti-events for any
	// deleted formatting, so we do not need to repeat that here.

	if(_paeCF)
		_paeCF->Undo(ped, NULL);

	if(_paePF)
		_paePF->Undo(ped, NULL);


	if (ped->IsComplexScript())
	{
		// For complex script doc, we need itemization at the end of the range undo.
		// Since the formattings were rolled back. The rtp's runptrs are no longer
		// reliable.

		if (_paeCF && rtp._rpCF.IsValid())
			rtp._rpCF.BindToCp(_cpMin + _cchDel);

		if (_paePF && rtp._rpPF.IsValid())
			rtp._rpPF.BindToCp(_cpMin + _cchDel);

		rtp.ItemizeReplaceRange(_cchDel, cchMove, NULL, FALSE);
	}

	return CBaseAE::Undo(ped, publdr);
}

/*
 *	CReplaceRangeAE::MergeData (dwDataType, pdata)	
 *
 *	@mfunc	gives the caller a chance to extend the current anti-event
 *			if we're in merge typing mode
 *
 *	@comm	if the requested data can be trivially merged into this
 *			anti-event, then do so; otherwise, return S_FALSE.
 *
 *			There are two cases of interest:  <nl>
 *				1. typing another character
 *				2. backspacing over a character in this merge
 *				   typing session.
 */
HRESULT CReplaceRangeAE::MergeData(
	DWORD dwDataType, 		//@parm	the type of <p pdata>
	void *pdata)			//@parm the merge data
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceRangeAE::MergeData");

	if(dwDataType == MD_SIMPLE_REPLACERANGE)
	{
		SimpleReplaceRange *psr = (SimpleReplaceRange *)pdata;

		// Test for first case: just typing another character
		if(psr->cpMin == _cpMax && psr->cchDel == 0)
		{
			_cpMax = psr->cpMax;
			return NOERROR;
		}
		// Second case: deleting text stored in this antievent
		if (psr->cpMax == psr->cpMin &&
			psr->cpMin + psr->cchDel == _cpMax &&
			psr->cpMin >= _cpMin)
		{
			_cpMax = psr->cpMax;
			return NOERROR;
		}
	}
	return S_FALSE;
}	

/*
 *	CReplaceRangeAE::CReplaceRangeAE (cpMin, cpMax, cchDel, pchDel, paeCF, paePF)
 *
 *	@mfunc	Constructor for a text replace range anti-event
 */
CReplaceRangeAE::CReplaceRangeAE(
	LONG cpMin, 			//@parm cp starting the *final* range
	LONG cpMax, 			//@parm cp ending the *final* range
	LONG cchDel, 			//@parm # of chars deleted during ReplaceRange
	TCHAR *pchDel, 			//@parm deleted characters.  Ownership of
							//		memory is transferred to this object.
	IAntiEvent *paeCF,		//@parm Anti-event for any character formatting
							//		replacement
	IAntiEvent *paePF)		//@parm Anti-event for any paragraph formatting
							//		replacement
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceRangeAE::CReplaceRangeAE");

	_cpMin 	= cpMin;
	_cpMax 	= cpMax;
	_cchDel = cchDel;
	_pchDel	= pchDel;
	_paeCF  = paeCF;
	_paePF  = paePF;
}

/*
 *	CReplaceRangeAE::~CReplaceRangeAE ()
 *
 *	@mfunc	Destructor
 */
CReplaceRangeAE::~CReplaceRangeAE()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceRangeAE::~CReplaceRangeAE");
		
	if(_pchDel)
		delete _pchDel;
}

/*
 *	CReplaceFormattingAE
 *
 *	@mfunc	Destroys this instance
 */
void CReplaceFormattingAE::Destroy()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceFormattingAE::Destroy");

	CBaseAE::Destroy();
	delete this;
}

/*
 *	CReplaceFormattingAE::Undo (ped, publdr)
 *
 *	@mfunc		Undoes a formatting operation
 *
 *	@devnote	This anti-event assumes that the text to which formatting
 *				should be applied exists!!
 */			
HRESULT CReplaceFormattingAE::Undo(
	CTxtEdit *ped,			//@parm CTxtEdit closure
	IUndoBuilder *publdr)	//@parm Undo builder context
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceFormattingAE::Undo");

	LONG			cchEaten;
	LONG			cchTotal = 0;
	LONG			delta;
	LONG			i;
	LONG			iRunMerge;
	IAntiEvent *	pae;
	IFormatCache *	pf = _fPara
					   ? (IFormatCache *)GetParaFormatCache()
					   : (IFormatCache *)GetCharFormatCache();
	CNotifyMgr *	pnm = ped->GetNotifyMgr();
	CFormatRuns **	ppfmtruns;
	CTxtStory *		pStory = ped->GetTxtStory();
	const CParaFormat * pDefPF = _fPara ? pStory->GetParaFormat(-1) : NULL;
	BYTE			bDefPFLevel = pDefPF && pDefPF->IsRtlPara() ? 1 : 0;

	// First set things up correctly for whether we are paragraph
	// or character formatting
	CFormatRunPtr rp(_fPara ? pStory->GetPFRuns() :pStory->GetCFRuns());

	// Count up count of characters affected
	for(i = 0 ; i < _cRuns; i++)
		cchTotal += _prgRuns[i]._cch;

	// We are going to be adding in some runs, so be sure the format
	// run array is allocated!
	if(!rp.IsValid())
	{
		ppfmtruns = _fPara ? &(pStory->_pPFRuns) : &(pStory->_pCFRuns);

		if(!rp.InitRuns(0, ped->GetTextLength(), ppfmtruns))
			return E_OUTOFMEMORY;

		// tell folks we allocated a new run
		if(pnm)
			pnm->NotifyPostReplaceRange(NULL, CP_INFINITE, 0, 0, CP_INFINITE, CP_INFINITE);
	}
	// Now do a pre-notification of the change we are about to make
	// This let's objects like a delayed render data object grab
	// any data *before* we change it.

	rp.BindToCp(_cp);

	// do a little more checking
	AssertNr(rp.CalcTextLength() == ped->GetTextLength());

	if(pnm)
		pnm->NotifyPreReplaceRange(NULL, CP_INFINITE, 0, 0, _cp, _cp + cchTotal);

	// We want to merge runs with where we start plus one behind.
	iRunMerge = rp._iRun;
	if(iRunMerge > 0)
		iRunMerge--;

	// if we need to be able to undo this opertion, go through and
	// save existing run information
	if(publdr)
	{
		LONG	cchBackup = 0, cchAdvance = 0;
		if (ped->IsBiDi())
		{
			// For redo'ing purpose, we expand the range to keep in the antievent
			// to make sure that BiDi levels are recorded adequately.
			CRchTxtPtr	rtp(ped, _cp);
			cchBackup = rtp.ExpandRangeFormatting(cchTotal, 0, cchAdvance);
			Assert(cchBackup >= 0);
		}
		rp.AdvanceCp(-cchBackup);
		pae = gAEDispenser.CreateReplaceFormattingAE(ped, rp, cchTotal + cchBackup + cchAdvance,
				pf, _fPara);
		rp.AdvanceCp(cchBackup);

		if(pae)
			publdr->AddAntiEvent(pae);
	}	

#ifdef DEBUG
	CTxtPtr	rtp(ped, _cp);
	WCHAR   ch;
#endif
	
	// Now go through and apply the saved formatting.
	for(i = 0; i < _cRuns; i++)
	{
		cchEaten = 0;

        // Use a do-while, because we may have a zero-length
        // format run.  We know we need to do "something" at
        // least once, because otherwise, we would not have
        // bothered creating a run!
		do
		{
			if (_fPara && _prgRuns[i]._iFormat == -1)
				// (#6768) The -1 format may have changed before undoing.
				_prgRuns[i]._level._value = bDefPFLevel;

			delta = rp.SetFormat(_prgRuns[i]._iFormat,
							_prgRuns[i]._cch - cchEaten, pf, &_prgRuns[i]._level);
			if(delta == -1)
			{
				ped->GetCallMgr()->SetOutOfMemory();
				break;
			}
			cchEaten += delta;
		} while(cchEaten < _prgRuns[i]._cch);

#ifdef DEBUG
		if (_fPara)
		{
			rtp.AdvanceCp(_prgRuns[i]._cch);
			ch = rtp.GetPrevChar();
			if(!IsASCIIEOP(ch))
			{
				rtp.MoveGapToEndOfBlock();			// Make it easier to see
				AssertSz(FALSE,							//  what's going on
					"CReplaceFormattingAE::Undo: PF run doesn't end with EOP");
			}
		}
#endif

	}

	// Merge formatting runs in case there are duplicate formatting
	// runs side by side
    rp.NextRun();
	rp.MergeRuns(iRunMerge, pf);

	// Make sure the runs are still OK.
	AssertNr(rp.CalcTextLength() == ped->GetTextLength());

	if(pnm)
		pnm->NotifyPostReplaceRange(NULL, CP_INFINITE, 0, 0, _cp, _cp + cchTotal);

	ped->GetCallMgr()->SetChangeEvent(CN_GENERIC);

	return CBaseAE::Undo(ped, publdr);
}

/*
 *	CReplaceFormattingAE::CReplaceFormattingAE(&rpIn, cch, pf, fPara)
 *
 *	@mfunc	Constructor.  During construction, we will loop through and
 *			find all of the formats for the given text range
 */
CReplaceFormattingAE::CReplaceFormattingAE(
	CTxtEdit		*ped,			//@parm CTxtEdit
	CFormatRunPtr	&rpIn, 			//@parm	Run pointer to start with
	LONG cch,						//@parm Count of characters to
									//		find formatting info on
	IFormatCache 	*pf,   			//@parm Format cache (to AddRef/
									//		Release formats)
	BOOL fPara)						//@parm If TRUE, formatting is for paras
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceFormattingAE::CReplaceFormattingAE");

    LONG		  cchLeft;
	LONG		  cchtemp = (LONG)cch;
	LONG		  i;
	CFormatRunPtr rp(rpIn);			// We use 2 format run pointers to avoid
	CFormatRunPtr rpTemp(rpIn);		// backing up after counting the number of
									// format runs
	Assert(pf);

	// TODO: pass in cp as a parameter to avoid following calculation
	_cp = rpIn.CalculateCp();
	_fPara = fPara;

	// Count the number of formats needed.  Recall that even
    // if 0 characters are to be deleted, we may still be
    // "deleting" a zero length format run.
	_cRuns = 0;
    do
	{
		_cRuns++;
        cchLeft = rp.GetCchLeft();
		cchtemp -= min(cchLeft, cchtemp);
        rp.NextRun();
	} while(cchtemp > 0);

	_prgRuns = new CFormatRun[_cRuns];

	if(!_prgRuns)
	{
		_cRuns = 0;
		return;
	}

	// Would be nice to add this but ped is not passed in
	// CTxtPtr	rtp(ped, _cp);
	// WCHAR   ch;

	for(i = 0; i < _cRuns; i++)
	{
		_prgRuns[i]._cch = min(cch, rpTemp.GetCchLeft());
		CFormatRun *pRun = rpTemp.GetRun(0);

		_prgRuns[i]._iFormat = pRun->_iFormat;

		_prgRuns[i]._level = pRun->_level;
		pf->AddRef(_prgRuns[i]._iFormat);
		rpTemp.NextRun();
		cch -= _prgRuns[i]._cch;

		#if 0
		// Would be nice dor DEBUG but ped is not passed in

		if (_fPara)
		{
			rtp.AdvanceCp(_prgRuns[i]._cch);
			ch = rtp.GetPrevChar();
			if(!IsASCIIEOP(ch))
			{
				rtp.MoveGapToEndOfBlock();			// Make it easier to see
				AssertSz(FALSE,							//  what's going on
					"CReplaceFormattingAE::CReplaceFormattingAE: PF run doesn't end with EOP");
			}
		}
		#endif
	}

	Assert(cch == 0);
}

/*
 * 	CReplaceFormattingAE::~CReplaceFormattingAE	()
 *
 *	@mfunc	Destructor
 */
CReplaceFormattingAE::~CReplaceFormattingAE()
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceFormattingAE::~CReplaceFormattingAE");

	IFormatCache *	pf = _fPara
					   ? (IFormatCache *)GetParaFormatCache()
					   : (IFormatCache *)GetCharFormatCache();
	if(_prgRuns)
	{
		if(pf)
		{
			for(LONG i = 0; i < _cRuns; i++)
				pf->Release(_prgRuns[i]._iFormat);
		}
		delete _prgRuns;
	}
}

//
//	CReplaceObjectAE PUBLIC methods
//

/*
 *	CReplaceObjectAE::Destroy()
 *
 *	@mfunc	Destroy's this object
 */
void CReplaceObjectAE::Destroy()
{
	COleObject *pobj;

	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceObjectAE::Destroy");

	pobj = _pobj;
	_pobj = NULL;

	// we only need to zombie the object if it wasn't put back into
	// the document.
	if(!_fUndoInvoked)
		pobj->MakeZombie();

	pobj->Release();
	CBaseAE::Destroy();
	delete this;
}

/*
 *	CReplaceObjectAE::Undo (ped, publdr)
 *
 *	@mfunc	Undo'es the delete operation and restores the object
 *			to it's original state
 *
 *	@rdesc	HRESULT
 */
HRESULT CReplaceObjectAE::Undo(
	CTxtEdit *ped,			//@parm	edit context
	IUndoBuilder *publdr)	//@parm undo/redo context
{
	CObjectMgr *pobjmgr;

	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceObjectAE::Undo");

	pobjmgr = ped->GetObjectMgr();
	if(_pobj && pobjmgr)
	{
		_fUndoInvoked = TRUE;
		_pobj->Restore();
		pobjmgr->RestoreObject(_pobj);
	}

	return CBaseAE::Undo(ped, publdr);
}

/*
 *	CReplaceObjectAE::OnCommit(ped)
 *
 *	@mfunc	called when the anti-event chain is committed to the
 *			undo stack.  This gives us a chance to make 'dangerous'
 *			calls that could cause us to be re-entered.
 */
void CReplaceObjectAE::OnCommit(
	CTxtEdit *ped)			//@parm the edit context
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceObjectAE::OnCommit");
	_pobj->Close(OLECLOSE_SAVEIFDIRTY);
}

//
//	CReplaceObjectAE PRIVATE methods
//

/*
 *	CReplaceObjectAE::CReplaceObjectAE (pobj)
 *
 *	@mfunc	constructor
 */
CReplaceObjectAE::CReplaceObjectAE(
	COleObject *pobj)		//@parm object that was deleted
{
	_fUndoInvoked = FALSE;
	_pobj = pobj;
	_pobj->AddRef();
}

/*
 *	CReplaceObjectAE::~CReplaceObjectAE
 *
 *	@mfunc	destructor
 */
CReplaceObjectAE::~CReplaceObjectAE()
{
	Assert(_pobj == NULL);
}

//
//	CResizeObjectAE PUBLIC methods
//

/*
*	CResizeObjectAE::Destroy
 *
 *	@mfunc	Destroy's this object
 */
void CResizeObjectAE::Destroy(void)
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CResizeObjectAE::Destroy");

	_pobj = NULL;
	CBaseAE::Destroy();

	delete this;
}

/*
 *	CResizeObjectAE::Undo(ped, publdr)
 *
 *	@mfunc	Undo'es the resize operation and restores the object
 *			to it's original size/position
 *
 *	@rdesc	HRESULT
 */
HRESULT CResizeObjectAE::Undo(
	CTxtEdit *ped,			//@parm	edit context
	IUndoBuilder *publdr)	//@parm undo/redo context
{
	CObjectMgr *pobjmgr;

	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceObjectAE::Undo");

	pobjmgr = ped->GetObjectMgr();

	if(_pobj && pobjmgr)
	{
		_fUndoInvoked = TRUE;
		_pobj->Resize(_rcPos);
	}

	return CBaseAE::Undo(ped, publdr);
}

/*
 *	CResizeObjectAE::OnCommit
 *
 *	@mfunc	called when the anti-event chain is committed to the
 *			undo stack.  This gives us a chance to make 'dangerous'
 *			calls that could cause us to be re-entered.
 */
void CResizeObjectAE::OnCommit(
	CTxtEdit *ped)			//@parm the edit context
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CReplaceObjectAE::OnCommit");
}

//
//	CResizeObjectAE PRIVATE methods
//

/*
 *	CResizeObjectAE::CResizeObjectAE (pobj, rcPos)
 *
 *	@mfunc	constructor
 *
 *	@rdesc	void
 */
CResizeObjectAE::CResizeObjectAE(
	COleObject *pobj,		//@parm the object that was resized
	RECT		rcPos)		//@parm the old position/size rect
{
	_fUndoInvoked = FALSE;
	_pobj = pobj;
	_rcPos = rcPos;
}

/*
 *	CResizeObjectAE::~CResizeObjectAE
 *
 *	@mfunc	destructor
 */
CResizeObjectAE::~CResizeObjectAE(void)
{
	Assert(_pobj == NULL);
}

//
//  CSelectionAE PUBLIC methods
//

/*
 *  CSelectionAE::Destroy ()
 *
 *  @mfunc  gets rid of this instance
 *
 *  @rdesc  void
 */
void CSelectionAE::Destroy()
{
    TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CSelectionAE::Destroy");

    CBaseAE::Destroy();
    delete this;
}

/*
 *  CSelectionAE::Undo (ped, publdr)
 *
 *  @mfunc  restore the selection to it's former position
 *
 *  @rdesc  NOERROR
 */
HRESULT CSelectionAE::Undo(
    CTxtEdit *ped,          //@parm the context for this undo operation
    IUndoBuilder *publdr)   //@parm the undo context
{
    TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CSelectionAE::Destroy");

    CTxtSelection *psel = ped->GetSel();

    if(psel)
        psel->SetDelayedSelectionRange(_cp, _cch);

	if(publdr)
	{
		IAntiEvent *pae;
		pae = gAEDispenser.CreateSelectionAE(ped, _cpNext, _cchNext,
					_cp, _cch);
		if(pae)
			publdr->AddAntiEvent(pae);
	}
	return CBaseAE::Undo(ped, publdr);
}

/*
 *  CSelectionAE::MergeData(dwDataType, pdata)
 *
 *  @mfunc  merges new selection data
 *
 *  @rdesc  S_FALSE, NOERROR
 *
 *	@comm	The mergine algorithm is fairly tricky.  There are basically two
 *			cases of interest:  group typing and drag-move.
 *
 *			In the group typing case, the "start" of the typing becomes a
 *			fixed reference from which characters are added or removed (i.e.
 *			you type or hit the backspace key).  "Undo" should return you to
 *			that reference point; redo, on the other hand, should return the
 *			selection to the last insertion point.  Thus, we only update
 *			_xxNext for the SELAE_MERGE action.
 *
 *			Drag-Move is somewhat different; in this case, there are really
 *			two actions--the "paste" on the drop, and the subsequent "cut"
 *			operation.  Thus, we need to be able to update the selection
 *			anti-event during the cut (since this only happens on move; not
 *			copies).  This is accomplished with teh FORCEREPLACE flag
 *			and by setting fields to -1 to be ignored.
 *
 */
HRESULT CSelectionAE::MergeData(
    DWORD dwDataType,       //@parm the type of data in <p pdata>
    void *pdata)            //@parm the merge data
{
    TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CSelectionAE::MergeData");

    SelRange *psrg = (SelRange *)pdata;

    if(dwDataType == MD_SELECTIONRANGE)
    {
		if(psrg->flags == SELAE_MERGE)
		{
			Assert(psrg->cpNext != -1);
			_cpNext = psrg->cpNext;
			_cchNext = psrg->cchNext;
		}
		else
		{
			// -1 is used a no-op, so we should ignore it
			if(psrg->cp != -1)
			{
				_cp = psrg->cp;
				_cch = psrg->cch;
			}
			if(psrg->cpNext != -1)
			{
				_cpNext = psrg->cpNext;
				_cchNext = psrg->cchNext;
			}
		}
        return NOERROR;
    }
    return S_FALSE;
}

//
//  CSelectionAE PRIVATE methods
//

/*
 *  CSelectionAE::CSelectionAE (cp, cch, cpNext, cchNext)
 *
 *  @mfunc  Constructor
 */
CSelectionAE::CSelectionAE(
    LONG    cp,             //@parm the actve end cp
    LONG    cch,            //@parm the signed extension
	LONG	cpNext,			//@parm the cp to use for the AE of this AE
	LONG	cchNext)		//@parm the cch for the AE of this AE
{
    _cp			= cp;
    _cch		= cch;
    _cpNext		= cpNext;
	_cchNext	= cchNext;
}

/*
 *  CSelectionAE::~CSelectionAE()
 *
 *  @mfunc  desctructor
 */
CSelectionAE::~CSelectionAE()
{
    ;
}

/*
 *	CAntiEventDispenser::CreateReplaceRangeAE(ped, cpMin, cpMax, cchDel,
 *											  pchDel, paeCF, paePF)
 *	@mfunc
 *		creates an anti-event for a replace range operation
 */
IAntiEvent * CAntiEventDispenser::CreateReplaceRangeAE(
	CTxtEdit *ped,			//@parm edit context
	LONG cpMin, 			//@parm cp starting the *final* range
	LONG cpMax, 			//@parm cp ending the *final* range
	LONG cchDel, 			//@parm # of chars deleted during ReplaceRange
	TCHAR *pchDel,			//@parm Deleted characters.  Ownership of
							//  memory is transferred to this object.
	IAntiEvent *paeCF,		//@parm Anti-event for any character formatting
							// replacement
	IAntiEvent *paePF)		//@parm Anti-event for any paragraph formatting
							// replacement	
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CAntiEventDispenser::CreateReplaceRangeAE");

	// FUTURE (alexgo): improve the efficiency of this routine!!
	IAntiEvent *pae;

	pae = (IAntiEvent *)(new CReplaceRangeAE(cpMin, cpMax, cchDel, pchDel,
								paeCF, paePF));

	if(!pae)
	{
		// we don't need to do anything else; the callmgr will discard
		// undo for us.
		ped->GetCallMgr()->SetOutOfMemory();
	}

	return pae;
}

/*
 *	CAntiEventDispenser::CreateReplaceFormattingAE(ped, &rp, cch, pf, fPara)
 *
 *	@mfunc	Creates an anti-event for replacing formatting
 */
IAntiEvent * CAntiEventDispenser::CreateReplaceFormattingAE(
	CTxtEdit *ped,					//@parm Edit context
	CFormatRunPtr &rp, 				//@parm	Run pointer to start with
	LONG cch,						//@parm Countof characters to
									//		find formatting info on
	IFormatCache *pf,				//@parm Format cache (to AddRef/
									//Release formats)
	BOOL fPara)						//@parm If TRUE, formatting is paragraphs
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN, "CAntiEventDispenser::CreateReplaceFormattingAE");

	// FUTURE (alexgo): improve the efficiency of this routine!!!
	IAntiEvent *pae;
	pae = (IAntiEvent *)(new CReplaceFormattingAE(ped, rp, cch, pf, fPara));
	if(!pae)
	{
		// We don't need to do anything else; the callmgr will discard
		// undo for us.
		ped->GetCallMgr()->SetOutOfMemory();
	}

	return pae;
}

/*
 *	CAntiEventDispenser::CreateReplaceObjectAE (ped, pobj)
 *
 *	@mfunc	Creates an anti-event for replacing an object
 *
 *	@rdesc	the created anti-event
 */
IAntiEvent * CAntiEventDispenser::CreateReplaceObjectAE(
	CTxtEdit *ped,					//@parm the edit context.
	COleObject *pobj)				//@parm the object that was deleted
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN,
		"CAntiEventDispenser::CreateReplaceObjectAE");

	IAntiEvent *pae;

	// Always allocating is probably a reasonable strategy for objects;
	// they are not expected to be the bread & butter case.
	pae = (IAntiEvent *)(new CReplaceObjectAE(pobj));
	if(!pae)
	{
		// We don't need to do anything else; the callmgr will discard
		// undo for us.
		ped->GetCallMgr()->SetOutOfMemory();
	}

	return pae;
}

/*
 *	CAntiEventDispenser::CreateResizeObjectAE (ped, pobj, rcPos)
 *
 *	@mfunc	Creates an anti-event for resizing an object
 *
 *	@rdesc	the created anti-event
 */
IAntiEvent * CAntiEventDispenser::CreateResizeObjectAE(
	CTxtEdit *ped,					//@parm the edit context.
	COleObject *pobj,				//@parm the object that was resized
	RECT rcPos)						//@parm the old object position rectangle
{
	TRACEBEGIN(TRCSUBSYSUNDO, TRCSCOPEINTERN,
		"CAntiEventDispenser::CreateResizeeObjectAE");

	IAntiEvent *pae;

	// Always allocating is probably a reasonable strategy for objects;
	// they are not expected to be the bread & butter case.

	pae = (IAntiEvent *)(new CResizeObjectAE(pobj, rcPos));
	if(!pae)
	{
		// We don't need to do anything else; the callmgr will discard
		// undo for us.
		ped->GetCallMgr()->SetOutOfMemory();
	}
	return pae;
}

/*
 *  CAntiEventDispenser::CreateSelectionAE (ped, cp, cch, cpNext, cchNext)
 *
 *  @mfunc  Creates an anti-event for restoring a non-degenerate selection
 *
 *  @rdesc  the created anti-event
 */
IAntiEvent * CAntiEventDispenser::CreateSelectionAE(
	CTxtEdit *ped,					//@parm edit context
    LONG    cp,                     //@parm the active end of the selection
    LONG    cch,                    //@parm the signed extension
	LONG	cpNext,					//@parm the cp to use for the AE of this AE
	LONG	cchNext)				//@parm the cch to use for the AE
{
	// FUTURE (alexgo): improve the efficiency of this routine
	IAntiEvent *pae;

    pae = (IAntiEvent *)(new CSelectionAE(cp, cch, cpNext, cchNext));
	if(!pae)
	{
		// We don't need to do anything else; the callmgr will discard
		// undo for us.
		ped->GetCallMgr()->SetOutOfMemory();
	}
	return pae;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\array.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	ARRAY.C	-- Generic Array Implementation |
 *	
 *	Original Author: <nl>
 *		Christian Fortini
 *
 *	History: <nl>
 *		6/25/95  alexgo  Cleanup and Commented
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */


#include "_common.h"
#include "_array.h"

ASSERTDATA

const int celGrow = 8;

//
//	Invariant support
//
#define	DEBUG_CLASSNAME	CArrayBase
#include "_invar.h"

// ===================================  CArrayBase  ================================================

#ifdef DEBUG
/*
 *	CArrayBase::Invariant()
 *
 *	@mfunc	Tests the array state to make sure it is valid.  DEBUG only
 *
 *	@rdesc	TRUE if the tests succeed, FALSE otherwise
 */
BOOL CArrayBase::Invariant() const
{
	Assert(_cbElem > 0);

	if(!_prgel)
	{
		Assert(_cel == 0);
		Assert(_celMax == 0);

		// We go ahead and return a value here so that
		// this function can be executed in the "watch"
		// window of various debuggers
		if(_cel || _celMax)
			return FALSE;
	}
	else
	{
		Assert(_celMax > 0 );
		Assert(_cel <= _celMax);

		if(_celMax == 0 || _cel > _celMax)
			return FALSE;
	}

	return TRUE;
}

/* 
 *	CArrayBase::Elem(iel)
 *
 *	@mfunc	Returns a pointer to the element indexed by <p iel>
 *
 *	@rdesc	A pointer to the element indexed by <p iel>.  This pointer may
 *	be cast to a pointer of the appropriate element type.
 */
void* CArrayBase::Elem(
	LONG iel) const	//@parm Index to use
{
	_TEST_INVARIANT_

	// This can arise with empty froms^3 controls.
	// Review (keithcu) Why did this start happening in Richedit 3?
	if (!_cel)
		return NULL;

	AssertSz(iel == 0 || (iel > 0 && iel < _cel),
		"CArrayBase::Elem() - Index out of range");

	return _prgel + iel * _cbElem;
}								 
#endif

/*
 *	CArrayBase::CArrayBase
 *
 *	@mfunc Constructor
 */
CArrayBase::CArrayBase(
	LONG cbElem)		//@parm	Size of an individual array element
{	
	_prgel = NULL; 
	_cel = 0; 
	_celMax = 0; 
	_cbElem = cbElem;
}

/*
 *	CArrayBase::ArAdd
 *
 *	@mfunc	Adds <p celAdd> elements to the end of the array.
 *
 *	@rdesc	A pointer to the start of the new elements added.  If non-NULL, 
 *	<p pielIns> will be set to the index at which elements were added.
 *
 *  We grow in steps of celGrow when small and exponentially when large.
 */
void* CArrayBase::ArAdd(
	LONG celAdd,	//@parm Count of elements to add
	LONG *pielIns)	//@parm Out parm for index of first element added
{
	_TEST_INVARIANT_
	char *pel;

	if(_cel + celAdd > _celMax)					// need to grow 
	{
		LONG celNew = max(celAdd, celGrow) + _cel / 16;
		pel = (char*)PvReAlloc(_prgel, (_celMax + celNew) * _cbElem);
		if(!pel)
			return NULL;
		_prgel = pel;
		_celMax += celNew;
	}
	pel = _prgel + _cel * _cbElem;
	ZeroMemory(pel, celAdd * _cbElem);

	if(pielIns)
		*pielIns = _cel;

	_cel += celAdd;
	return pel;
}

/*
 *	CArrayBase::ArInsert (iel, celIns)
 *
 *	@mfunc Inserts <p celIns> new elements at index <p iel>
 *
 *	@rdesc A pointer to the newly inserted elements.  Will be NULL on
 *	failure.
 */
void* CArrayBase::ArInsert(
	LONG iel,		//@parm	Index at which to insert
	LONG celIns)	//@parm Count of elements to insert
{
	char *pel;

	_TEST_INVARIANT_

	AssertSz(iel <= _cel, "CArrayBase::Insert() - Insert out of range");

	if(iel >= _cel)
		return ArAdd(celIns, NULL);

	if(_cel + celIns > _celMax)				// need to grow 
	{
		AssertSz(_prgel, "CArrayBase::Insert() - Growing a non existent array !");

		LONG celNew = max(celIns, celGrow) + _cel / 16;
		pel = (char*)PvReAlloc(_prgel, (_celMax + celNew) * _cbElem);
		if(!pel)
		{
			TRACEERRORSZ("CArrayBase::Insert() - Couldn't realloc line array");
			return NULL;
		}
		_prgel = pel;
		_celMax += celNew;
	}
	pel = _prgel + iel * _cbElem;
	if(iel < _cel)				// Nove Elems up to make room for new ones
		MoveMemory(pel + celIns*_cbElem, pel, (_cel - iel)*_cbElem);

	_cel += celIns;
	return pel;
}

/*
 *	CArrayBase::Remove
 *
 *	@mfunc	Removes the <p celFree> elements from the array starting at index
 *	<p ielFirst>.  If <p celFree> is negative, then all elements after
 *	<p ielFirst> are removed.
 *
 *	@rdesc nothing
 */
void CArrayBase::Remove(
	LONG ielFirst, 		//@parm Index at which elements should be removed
	LONG celFree) 		//@parm	Count of elements to remove. 
{
	char *pel;

	_TEST_INVARIANT_

	if(celFree < 0)
		celFree = _cel - ielFirst;

	AssertSz(ielFirst + celFree <= _cel, "CArrayBase::Free() - Freeing out of range");

	if(_cel > ielFirst + celFree)
	{
		pel = _prgel + ielFirst * _cbElem;
		MoveMemory(pel, pel + celFree * _cbElem,
			(_cel - ielFirst - celFree) * _cbElem);
	}

	_cel -= celFree;

	if(_cel < _celMax - celGrow - _cel / 16)
	{
		// Shrink array
		_celMax = max(_cel, celGrow);
		_prgel = (char*)PvReAlloc(_prgel, _celMax * _cbElem);
		Assert(_prgel);
	}
}

/*
 *	CArrayBase::Clear
 *
 *	@mfunc	Clears the entire array, potentially deleting all of the memory
 *	as well.
 *
 *	@rdesc	nothing
 */
void CArrayBase::Clear(
	ArrayFlag flag)	//@parm Indicates what should be done with the memory
					//in the array.  One of AF_DELETEMEM or AF_KEEPMEM
{
	_TEST_INVARIANT_

	if( flag == AF_DELETEMEM )
	{
		FreePv(_prgel);
		_prgel = NULL;
		_celMax = 0;
	}
	else if (_prgel)
	{
		_celMax = min(celGrow, _celMax);
		_prgel = (char*) PvReAlloc(_prgel, celGrow * _cbElem);
	}
	_cel = 0;
}

/*
 *	CArrayBase::Replace
 *
 *	@mfunc	Replaces the <p celRepl> elements at index <p ielRepl> with the
 *	contents of the array specified by <p par>.  If <p celRepl> is negative,
 *	then the entire contents of <p this> array starting at <p ielRepl> should
 *	be replaced.
 *
 *	@rdesc	Returns TRUE on success, FALSE otherwise.
 */
BOOL CArrayBase::Replace(
	LONG ielRepl, 		//@parm index at which replacement should occur
	LONG celRepl, 		//@parm number of elements to replace (may be
						//		negative, indicating that all
	CArrayBase *par)	//@parm array to use as the replacement source
{
	_TEST_INVARIANT_

	LONG celMove = 0;
	LONG celIns = par->Count();
	
	if (celRepl < 0)
		celRepl = _cel - ielRepl;

	AssertSz(ielRepl + celRepl <= _cel, "CArrayBase::ArReplace() - Replacing out of range");
	
	celMove = min(celRepl, celIns);

	if (celMove > 0) 
	{
		MoveMemory(Elem(ielRepl), par->Elem(0), celMove * _cbElem);
		celIns -= celMove;
		celRepl -= celMove;
		ielRepl += celMove;
	}

	Assert(celIns >= 0);
	Assert(celRepl >= 0);
	Assert(celIns + celMove == par->Count());

	if(celIns > 0)
	{
		Assert(celRepl == 0);
		void *pelIns = ArInsert (ielRepl, celIns);
		if (!pelIns)
			return FALSE;
		MoveMemory(pelIns, par->Elem(celMove), celIns * _cbElem);
	}
	else if(celRepl > 0)
		Remove (ielRepl, celRepl);

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\aimm.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.01.75 */
/* at Tue Jan 13 08:56:29 1998
 */
/* Compiler settings for aimm.idl:
    Os (OptLev=s), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )
#include "rpc.h"
#include "rpcndr.h"

#ifndef __aimm_h__
#define __aimm_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IEnumRegisterWordA_FWD_DEFINED__
#define __IEnumRegisterWordA_FWD_DEFINED__
typedef interface IEnumRegisterWordA IEnumRegisterWordA;
#endif 	/* __IEnumRegisterWordA_FWD_DEFINED__ */


#ifndef __IEnumRegisterWordW_FWD_DEFINED__
#define __IEnumRegisterWordW_FWD_DEFINED__
typedef interface IEnumRegisterWordW IEnumRegisterWordW;
#endif 	/* __IEnumRegisterWordW_FWD_DEFINED__ */


#ifndef __IAIMMRegistrar_FWD_DEFINED__
#define __IAIMMRegistrar_FWD_DEFINED__
typedef interface IAIMMRegistrar IAIMMRegistrar;
#endif 	/* __IAIMMRegistrar_FWD_DEFINED__ */


#ifndef __IActiveIMMMessagePumpOwner_FWD_DEFINED__
#define __IActiveIMMMessagePumpOwner_FWD_DEFINED__
typedef interface IActiveIMMMessagePumpOwner IActiveIMMMessagePumpOwner;
#endif 	/* __IActiveIMMMessagePumpOwner_FWD_DEFINED__ */


#ifndef __IActiveIMMApp_FWD_DEFINED__
#define __IActiveIMMApp_FWD_DEFINED__
typedef interface IActiveIMMApp IActiveIMMApp;
#endif 	/* __IActiveIMMApp_FWD_DEFINED__ */


#ifndef __IActiveIMMIME_FWD_DEFINED__
#define __IActiveIMMIME_FWD_DEFINED__
typedef interface IActiveIMMIME IActiveIMMIME;
#endif 	/* __IActiveIMMIME_FWD_DEFINED__ */


#ifndef __IActiveIME_FWD_DEFINED__
#define __IActiveIME_FWD_DEFINED__
typedef interface IActiveIME IActiveIME;
#endif 	/* __IActiveIME_FWD_DEFINED__ */


#ifndef __CActiveIMM_FWD_DEFINED__
#define __CActiveIMM_FWD_DEFINED__

#ifdef __cplusplus
typedef class CActiveIMM CActiveIMM;
#else
typedef struct CActiveIMM CActiveIMM;
#endif /* __cplusplus */

#endif 	/* __CActiveIMM_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/****************************************
 * Generated header for interface: __MIDL_itf_aimm_0000
 * at Tue Jan 13 08:56:29 1998
 * using MIDL 3.01.75
 ****************************************/
/* [local] */ 


//=--------------------------------------------------------------------------=
// aimm.h
//=--------------------------------------------------------------------------=
// (C) Copyright 1995-1997 Microsoft Corporation.  All Rights Reserved.
//
// THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF
// ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO
// THE IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A
// PARTICULAR PURPOSE.
//=--------------------------------------------------------------------------=

#pragma comment(lib,"uuid.lib")

//--------------------------------------------------------------------------
// IActiveIMM Interfaces.



extern RPC_IF_HANDLE __MIDL_itf_aimm_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_aimm_0000_v0_0_s_ifspec;


#ifndef __ActiveIMM_LIBRARY_DEFINED__
#define __ActiveIMM_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: ActiveIMM
 * at Tue Jan 13 08:56:29 1998
 * using MIDL 3.01.75
 ****************************************/
/* [version][lcid][helpstring][uuid] */ 


#ifndef _IMM_
#error Must include imm.h!
#endif
#if 0
typedef WORD LANGID;

typedef /* [public][public][public][public] */ struct  __MIDL___MIDL_itf_aimm_0000_0001
    {
    LPSTR lpReading;
    LPSTR lpWord;
    }	REGISTERWORDA;

typedef /* [public][public][public][public][public] */ struct  __MIDL___MIDL_itf_aimm_0000_0002
    {
    LPWSTR lpReading;
    LPWSTR lpWord;
    }	REGISTERWORDW;

typedef /* [public][public][public][public][public][public][public] */ struct  __MIDL___MIDL_itf_aimm_0000_0003
    {
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    CHAR lfFaceName[ 32 ];
    }	LOGFONTA;

typedef /* [public][public][public][public][public][public][public] */ struct  __MIDL___MIDL_itf_aimm_0000_0004
    {
    LONG lfHeight;
    LONG lfWidth;
    LONG lfEscapement;
    LONG lfOrientation;
    LONG lfWeight;
    BYTE lfItalic;
    BYTE lfUnderline;
    BYTE lfStrikeOut;
    BYTE lfCharSet;
    BYTE lfOutPrecision;
    BYTE lfClipPrecision;
    BYTE lfQuality;
    BYTE lfPitchAndFamily;
    WCHAR lfFaceName[ 32 ];
    }	LOGFONTW;

typedef DWORD HIMC;

typedef DWORD HIMCC;

typedef /* [public][public][public][public][public][public][public] */ struct  __MIDL___MIDL_itf_aimm_0000_0005
    {
    DWORD dwIndex;
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT rcArea;
    }	CANDIDATEFORM;

typedef /* [public][public][public][public][public][public][public] */ struct  __MIDL___MIDL_itf_aimm_0000_0006
    {
    DWORD dwStyle;
    POINT ptCurrentPos;
    RECT rcArea;
    }	COMPOSITIONFORM;

typedef /* [public][public][public][public][public][public][public][public][public][public] */ struct  __MIDL___MIDL_itf_aimm_0000_0007
    {
    DWORD dwSize;
    DWORD dwStyle;
    DWORD dwCount;
    DWORD dwSelection;
    DWORD dwPageStart;
    DWORD dwPageSize;
    DWORD dwOffset[ 1 ];
    }	CANDIDATELIST;

typedef /* [public][public][public] */ struct  __MIDL___MIDL_itf_aimm_0000_0008
    {
    DWORD dwStyle;
    CHAR szDescription[ 32 ];
    }	STYLEBUFA;

typedef /* [public][public][public][public] */ struct  __MIDL___MIDL_itf_aimm_0000_0009
    {
    DWORD dwStyle;
    WCHAR szDescription[ 32 ];
    }	STYLEBUFW;

typedef WORD ATOM;

#endif
#ifndef _DDKIMM_H_
typedef /* [public][public] */ struct  __MIDL___MIDL_itf_aimm_0000_0010
    {
    HWND hWnd;
    BOOL fOpen;
    POINT ptStatusWndPos;
    POINT ptSoftKbdPos;
    DWORD fdwConversion;
    DWORD fdwSentence;
    union 
        {
        LOGFONTA A;
        LOGFONTW W;
        }	lfFont;
    COMPOSITIONFORM cfCompForm;
    CANDIDATEFORM cfCandForm[ 4 ];
    HIMCC hCompStr;
    HIMCC hCandInfo;
    HIMCC hGuideLine;
    HIMCC hPrivate;
    DWORD dwNumMsgBuf;
    HIMCC hMsgBuf;
    DWORD fdwInit;
    DWORD dwReserve[ 3 ];
    }	INPUTCONTEXT;

typedef /* [public][public] */ struct  __MIDL___MIDL_itf_aimm_0000_0012
    {
    DWORD dwPrivateDataSize;
    DWORD fdwProperty;
    DWORD fdwConversionCaps;
    DWORD fdwSentenceCaps;
    DWORD fdwUICaps;
    DWORD fdwSCSCaps;
    DWORD fdwSelectCaps;
    }	IMEINFO;

#endif

EXTERN_C const IID LIBID_ActiveIMM;

#ifndef __IEnumRegisterWordA_INTERFACE_DEFINED__
#define __IEnumRegisterWordA_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumRegisterWordA
 * at Tue Jan 13 08:56:29 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IEnumRegisterWordA;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("08C03412-F96B-11d0-A475-00AA006BCC59")
    IEnumRegisterWordA : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumRegisterWordA __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [out] */ REGISTERWORDA __RPC_FAR *rgRegisterWord,
            /* [out] */ ULONG __RPC_FAR *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRegisterWordAVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumRegisterWordA __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumRegisterWordA __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumRegisterWordA __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumRegisterWordA __RPC_FAR * This,
            /* [out] */ IEnumRegisterWordA __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumRegisterWordA __RPC_FAR * This,
            /* [in] */ ULONG ulCount,
            /* [out] */ REGISTERWORDA __RPC_FAR *rgRegisterWord,
            /* [out] */ ULONG __RPC_FAR *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumRegisterWordA __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumRegisterWordA __RPC_FAR * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumRegisterWordAVtbl;

    interface IEnumRegisterWordA
    {
        CONST_VTBL struct IEnumRegisterWordAVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRegisterWordA_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRegisterWordA_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRegisterWordA_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRegisterWordA_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumRegisterWordA_Next(This,ulCount,rgRegisterWord,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgRegisterWord,pcFetched)

#define IEnumRegisterWordA_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRegisterWordA_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRegisterWordA_Clone_Proxy( 
    IEnumRegisterWordA __RPC_FAR * This,
    /* [out] */ IEnumRegisterWordA __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumRegisterWordA_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordA_Next_Proxy( 
    IEnumRegisterWordA __RPC_FAR * This,
    /* [in] */ ULONG ulCount,
    /* [out] */ REGISTERWORDA __RPC_FAR *rgRegisterWord,
    /* [out] */ ULONG __RPC_FAR *pcFetched);


void __RPC_STUB IEnumRegisterWordA_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordA_Reset_Proxy( 
    IEnumRegisterWordA __RPC_FAR * This);


void __RPC_STUB IEnumRegisterWordA_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordA_Skip_Proxy( 
    IEnumRegisterWordA __RPC_FAR * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumRegisterWordA_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRegisterWordA_INTERFACE_DEFINED__ */


#ifndef __IEnumRegisterWordW_INTERFACE_DEFINED__
#define __IEnumRegisterWordW_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IEnumRegisterWordW
 * at Tue Jan 13 08:56:29 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IEnumRegisterWordW;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("4955DD31-B159-11d0-8FCF-00AA006BCC59")
    IEnumRegisterWordW : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumRegisterWordW __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG ulCount,
            /* [out] */ REGISTERWORDW __RPC_FAR *rgRegisterWord,
            /* [out] */ ULONG __RPC_FAR *pcFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG ulCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumRegisterWordWVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumRegisterWordW __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumRegisterWordW __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumRegisterWordW __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumRegisterWordW __RPC_FAR * This,
            /* [out] */ IEnumRegisterWordW __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumRegisterWordW __RPC_FAR * This,
            /* [in] */ ULONG ulCount,
            /* [out] */ REGISTERWORDW __RPC_FAR *rgRegisterWord,
            /* [out] */ ULONG __RPC_FAR *pcFetched);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumRegisterWordW __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumRegisterWordW __RPC_FAR * This,
            /* [in] */ ULONG ulCount);
        
        END_INTERFACE
    } IEnumRegisterWordWVtbl;

    interface IEnumRegisterWordW
    {
        CONST_VTBL struct IEnumRegisterWordWVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumRegisterWordW_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumRegisterWordW_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumRegisterWordW_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumRegisterWordW_Clone(This,ppEnum)	\
    (This)->lpVtbl -> Clone(This,ppEnum)

#define IEnumRegisterWordW_Next(This,ulCount,rgRegisterWord,pcFetched)	\
    (This)->lpVtbl -> Next(This,ulCount,rgRegisterWord,pcFetched)

#define IEnumRegisterWordW_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumRegisterWordW_Skip(This,ulCount)	\
    (This)->lpVtbl -> Skip(This,ulCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IEnumRegisterWordW_Clone_Proxy( 
    IEnumRegisterWordW __RPC_FAR * This,
    /* [out] */ IEnumRegisterWordW __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IEnumRegisterWordW_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordW_Next_Proxy( 
    IEnumRegisterWordW __RPC_FAR * This,
    /* [in] */ ULONG ulCount,
    /* [out] */ REGISTERWORDW __RPC_FAR *rgRegisterWord,
    /* [out] */ ULONG __RPC_FAR *pcFetched);


void __RPC_STUB IEnumRegisterWordW_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordW_Reset_Proxy( 
    IEnumRegisterWordW __RPC_FAR * This);


void __RPC_STUB IEnumRegisterWordW_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IEnumRegisterWordW_Skip_Proxy( 
    IEnumRegisterWordW __RPC_FAR * This,
    /* [in] */ ULONG ulCount);


void __RPC_STUB IEnumRegisterWordW_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumRegisterWordW_INTERFACE_DEFINED__ */


#ifndef __IAIMMRegistrar_INTERFACE_DEFINED__
#define __IAIMMRegistrar_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IAIMMRegistrar
 * at Tue Jan 13 08:56:29 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IAIMMRegistrar;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("c7afa428-5007-11d1-aa94-0060b067b86e")
    IAIMMRegistrar : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE RegisterIME( 
            /* [in] */ REFCLSID rclsid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterIME( 
            /* [in] */ REFCLSID rclsid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IAIMMRegistrarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IAIMMRegistrar __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IAIMMRegistrar __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IAIMMRegistrar __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterIME )( 
            IAIMMRegistrar __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnregisterIME )( 
            IAIMMRegistrar __RPC_FAR * This,
            /* [in] */ REFCLSID rclsid);
        
        END_INTERFACE
    } IAIMMRegistrarVtbl;

    interface IAIMMRegistrar
    {
        CONST_VTBL struct IAIMMRegistrarVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IAIMMRegistrar_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IAIMMRegistrar_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IAIMMRegistrar_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IAIMMRegistrar_RegisterIME(This,rclsid)	\
    (This)->lpVtbl -> RegisterIME(This,rclsid)

#define IAIMMRegistrar_UnregisterIME(This,rclsid)	\
    (This)->lpVtbl -> UnregisterIME(This,rclsid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IAIMMRegistrar_RegisterIME_Proxy( 
    IAIMMRegistrar __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid);


void __RPC_STUB IAIMMRegistrar_RegisterIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IAIMMRegistrar_UnregisterIME_Proxy( 
    IAIMMRegistrar __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid);


void __RPC_STUB IAIMMRegistrar_UnregisterIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IAIMMRegistrar_INTERFACE_DEFINED__ */


#ifndef __IActiveIMMMessagePumpOwner_INTERFACE_DEFINED__
#define __IActiveIMMMessagePumpOwner_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IActiveIMMMessagePumpOwner
 * at Tue Jan 13 08:56:29 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IActiveIMMMessagePumpOwner;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("b5cf2cfa-8aeb-11d1-9364-0060b067b86e")
    IActiveIMMMessagePumpOwner : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Start( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE End( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnTranslateMessage( 
            /* [in] */ MSG __RPC_FAR *pMsg) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMMMessagePumpOwnerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IActiveIMMMessagePumpOwner __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IActiveIMMMessagePumpOwner __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IActiveIMMMessagePumpOwner __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Start )( 
            IActiveIMMMessagePumpOwner __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *End )( 
            IActiveIMMMessagePumpOwner __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnTranslateMessage )( 
            IActiveIMMMessagePumpOwner __RPC_FAR * This,
            /* [in] */ MSG __RPC_FAR *pMsg);
        
        END_INTERFACE
    } IActiveIMMMessagePumpOwnerVtbl;

    interface IActiveIMMMessagePumpOwner
    {
        CONST_VTBL struct IActiveIMMMessagePumpOwnerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIMMMessagePumpOwner_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveIMMMessagePumpOwner_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveIMMMessagePumpOwner_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveIMMMessagePumpOwner_Start(This)	\
    (This)->lpVtbl -> Start(This)

#define IActiveIMMMessagePumpOwner_End(This)	\
    (This)->lpVtbl -> End(This)

#define IActiveIMMMessagePumpOwner_OnTranslateMessage(This,pMsg)	\
    (This)->lpVtbl -> OnTranslateMessage(This,pMsg)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveIMMMessagePumpOwner_Start_Proxy( 
    IActiveIMMMessagePumpOwner __RPC_FAR * This);


void __RPC_STUB IActiveIMMMessagePumpOwner_Start_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMMessagePumpOwner_End_Proxy( 
    IActiveIMMMessagePumpOwner __RPC_FAR * This);


void __RPC_STUB IActiveIMMMessagePumpOwner_End_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMMessagePumpOwner_OnTranslateMessage_Proxy( 
    IActiveIMMMessagePumpOwner __RPC_FAR * This,
    /* [in] */ MSG __RPC_FAR *pMsg);


void __RPC_STUB IActiveIMMMessagePumpOwner_OnTranslateMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveIMMMessagePumpOwner_INTERFACE_DEFINED__ */


#ifndef __IActiveIMMApp_INTERFACE_DEFINED__
#define __IActiveIMMApp_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IActiveIMMApp
 * at Tue Jan 13 08:56:29 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IActiveIMMApp;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("08c0e040-62d1-11d1-9326-0060b067b86e")
    IActiveIMMApp : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AssociateContext( 
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIME,
            /* [out] */ HIMC __RPC_FAR *phPrev) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfigureIMEA( 
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDA __RPC_FAR *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfigureIMEW( 
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW __RPC_FAR *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateContext( 
            /* [out] */ HIMC __RPC_FAR *phIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyContext( 
            /* [in] */ HIMC hIME) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRegisterWordA( 
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordA __RPC_FAR *__RPC_FAR *pEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRegisterWordW( 
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW __RPC_FAR *__RPC_FAR *pEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EscapeA( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT __RPC_FAR *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EscapeW( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT __RPC_FAR *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST __RPC_FAR *pCandList,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST __RPC_FAR *pCandList,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListCountA( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pdwListSize,
            /* [out] */ DWORD __RPC_FAR *pdwBufLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListCountW( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pdwListSize,
            /* [out] */ DWORD __RPC_FAR *pdwBufLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [out] */ CANDIDATEFORM __RPC_FAR *pCandidate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionFontA( 
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTA __RPC_FAR *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionFontW( 
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTW __RPC_FAR *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionStringA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG __RPC_FAR *plCopied,
            /* [out] */ LPVOID pBuf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionStringW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG __RPC_FAR *plCopied,
            /* [out] */ LPVOID pBuf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionWindow( 
            /* [in] */ HIMC hIMC,
            /* [out] */ COMPOSITIONFORM __RPC_FAR *pCompForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [in] */ HWND hWnd,
            /* [out] */ HIMC __RPC_FAR *phIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionListA( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST __RPC_FAR *pDst,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionListW( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST __RPC_FAR *pDst,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionStatus( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pfdwConversion,
            /* [out] */ DWORD __RPC_FAR *pfdwSentence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultIMEWnd( 
            /* [in] */ HWND hWnd,
            /* [out] */ HWND __RPC_FAR *phDefWnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescriptionA( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szDescription,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescriptionW( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szDescription,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuideLineA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPSTR pBuf,
            /* [out] */ DWORD __RPC_FAR *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuideLineW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPWSTR pBuf,
            /* [out] */ DWORD __RPC_FAR *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMEFileNameA( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szFileName,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMEFileNameW( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szFileName,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOpenStatus( 
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ HKL hKL,
            /* [in] */ DWORD fdwIndex,
            /* [out] */ DWORD __RPC_FAR *pdwProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterWordStyleA( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFA __RPC_FAR *pStyleBuf,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterWordStyleW( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW __RPC_FAR *pStyleBuf,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatusWindowPos( 
            /* [in] */ HIMC hIMC,
            /* [out] */ POINT __RPC_FAR *pptPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVirtualKey( 
            /* [in] */ HWND hWnd,
            /* [out] */ UINT __RPC_FAR *puVirtualKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallIMEA( 
            /* [in] */ LPSTR szIMEFileName,
            /* [in] */ LPSTR szLayoutText,
            /* [out] */ HKL __RPC_FAR *phKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallIMEW( 
            /* [in] */ LPWSTR szIMEFileName,
            /* [in] */ LPWSTR szLayoutText,
            /* [out] */ HKL __RPC_FAR *phKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsIME( 
            /* [in] */ HKL hKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUIMessageA( 
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUIMessageW( 
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyIME( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterWordA( 
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterWordW( 
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseContext( 
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCandidateWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ CANDIDATEFORM __RPC_FAR *pCandidate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionFontA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTA __RPC_FAR *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionFontW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTW __RPC_FAR *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionStringA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionStringW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ COMPOSITIONFORM __RPC_FAR *pCompForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConversionStatus( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD fdwConversion,
            /* [in] */ DWORD fdwSentence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOpenStatus( 
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fOpen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStatusWindowPos( 
            /* [in] */ HIMC hIMC,
            /* [in] */ POINT __RPC_FAR *pptPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SimulateHotKey( 
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwHotKeyID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterWordA( 
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szUnregister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterWordW( 
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szUnregister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Activate( 
            /* [in] */ BOOL fRestoreLayout) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Deactivate( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OnDefWindowProc( 
            /* [in] */ HWND hWnd,
            /* [in] */ UINT Msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT __RPC_FAR *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FilterClientWindows( 
            /* [in] */ ATOM __RPC_FAR *aaClassList,
            /* [in] */ UINT uSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodePageA( 
            /* [in] */ HKL hKL,
            /* [out] */ UINT __RPC_FAR *uCodePage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLangId( 
            /* [in] */ HKL hKL,
            /* [out] */ LANGID __RPC_FAR *plid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMMAppVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IActiveIMMApp __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IActiveIMMApp __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AssociateContext )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIME,
            /* [out] */ HIMC __RPC_FAR *phPrev);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConfigureIMEA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDA __RPC_FAR *pData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConfigureIMEW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW __RPC_FAR *pData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateContext )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [out] */ HIMC __RPC_FAR *phIMC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DestroyContext )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumRegisterWordA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordA __RPC_FAR *__RPC_FAR *pEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumRegisterWordW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW __RPC_FAR *__RPC_FAR *pEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EscapeA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT __RPC_FAR *plResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EscapeW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT __RPC_FAR *plResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCandidateListA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST __RPC_FAR *pCandList,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCandidateListW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST __RPC_FAR *pCandList,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCandidateListCountA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pdwListSize,
            /* [out] */ DWORD __RPC_FAR *pdwBufLen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCandidateListCountW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pdwListSize,
            /* [out] */ DWORD __RPC_FAR *pdwBufLen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCandidateWindow )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [out] */ CANDIDATEFORM __RPC_FAR *pCandidate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCompositionFontA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTA __RPC_FAR *plf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCompositionFontW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTW __RPC_FAR *plf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCompositionStringA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG __RPC_FAR *plCopied,
            /* [out] */ LPVOID pBuf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCompositionStringW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG __RPC_FAR *plCopied,
            /* [out] */ LPVOID pBuf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCompositionWindow )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ COMPOSITIONFORM __RPC_FAR *pCompForm);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetContext )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [out] */ HIMC __RPC_FAR *phIMC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConversionListA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST __RPC_FAR *pDst,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConversionListW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST __RPC_FAR *pDst,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConversionStatus )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pfdwConversion,
            /* [out] */ DWORD __RPC_FAR *pfdwSentence);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultIMEWnd )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [out] */ HWND __RPC_FAR *phDefWnd);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDescriptionA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szDescription,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDescriptionW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szDescription,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGuideLineA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPSTR pBuf,
            /* [out] */ DWORD __RPC_FAR *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGuideLineW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPWSTR pBuf,
            /* [out] */ DWORD __RPC_FAR *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIMEFileNameA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szFileName,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIMEFileNameW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szFileName,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOpenStatus )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProperty )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ DWORD fdwIndex,
            /* [out] */ DWORD __RPC_FAR *pdwProperty);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRegisterWordStyleA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFA __RPC_FAR *pStyleBuf,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRegisterWordStyleW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW __RPC_FAR *pStyleBuf,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatusWindowPos )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ POINT __RPC_FAR *pptPos);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVirtualKey )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [out] */ UINT __RPC_FAR *puVirtualKey);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InstallIMEA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ LPSTR szIMEFileName,
            /* [in] */ LPSTR szLayoutText,
            /* [out] */ HKL __RPC_FAR *phKL);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InstallIMEW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ LPWSTR szIMEFileName,
            /* [in] */ LPWSTR szLayoutText,
            /* [out] */ HKL __RPC_FAR *phKL);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsIME )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsUIMessageA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsUIMessageW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NotifyIME )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterWordA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterWordW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleaseContext )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCandidateWindow )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ CANDIDATEFORM __RPC_FAR *pCandidate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCompositionFontA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTA __RPC_FAR *plf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCompositionFontW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTW __RPC_FAR *plf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCompositionStringA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCompositionStringW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCompositionWindow )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ COMPOSITIONFORM __RPC_FAR *pCompForm);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetConversionStatus )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD fdwConversion,
            /* [in] */ DWORD fdwSentence);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOpenStatus )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fOpen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStatusWindowPos )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ POINT __RPC_FAR *pptPos);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SimulateHotKey )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwHotKeyID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnregisterWordA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szUnregister);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnregisterWordW )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szUnregister);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Activate )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ BOOL fRestoreLayout);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Deactivate )( 
            IActiveIMMApp __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *OnDefWindowProc )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [in] */ UINT Msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam,
            /* [out] */ LRESULT __RPC_FAR *plResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *FilterClientWindows )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ ATOM __RPC_FAR *aaClassList,
            /* [in] */ UINT uSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodePageA )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [out] */ UINT __RPC_FAR *uCodePage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLangId )( 
            IActiveIMMApp __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [out] */ LANGID __RPC_FAR *plid);
        
        END_INTERFACE
    } IActiveIMMAppVtbl;

    interface IActiveIMMApp
    {
        CONST_VTBL struct IActiveIMMAppVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIMMApp_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveIMMApp_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveIMMApp_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveIMMApp_AssociateContext(This,hWnd,hIME,phPrev)	\
    (This)->lpVtbl -> AssociateContext(This,hWnd,hIME,phPrev)

#define IActiveIMMApp_ConfigureIMEA(This,hKL,hWnd,dwMode,pData)	\
    (This)->lpVtbl -> ConfigureIMEA(This,hKL,hWnd,dwMode,pData)

#define IActiveIMMApp_ConfigureIMEW(This,hKL,hWnd,dwMode,pData)	\
    (This)->lpVtbl -> ConfigureIMEW(This,hKL,hWnd,dwMode,pData)

#define IActiveIMMApp_CreateContext(This,phIMC)	\
    (This)->lpVtbl -> CreateContext(This,phIMC)

#define IActiveIMMApp_DestroyContext(This,hIME)	\
    (This)->lpVtbl -> DestroyContext(This,hIME)

#define IActiveIMMApp_EnumRegisterWordA(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)	\
    (This)->lpVtbl -> EnumRegisterWordA(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)

#define IActiveIMMApp_EnumRegisterWordW(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)	\
    (This)->lpVtbl -> EnumRegisterWordW(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)

#define IActiveIMMApp_EscapeA(This,hKL,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> EscapeA(This,hKL,hIMC,uEscape,pData,plResult)

#define IActiveIMMApp_EscapeW(This,hKL,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> EscapeW(This,hKL,hIMC,uEscape,pData,plResult)

#define IActiveIMMApp_GetCandidateListA(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)	\
    (This)->lpVtbl -> GetCandidateListA(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)

#define IActiveIMMApp_GetCandidateListW(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)	\
    (This)->lpVtbl -> GetCandidateListW(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)

#define IActiveIMMApp_GetCandidateListCountA(This,hIMC,pdwListSize,pdwBufLen)	\
    (This)->lpVtbl -> GetCandidateListCountA(This,hIMC,pdwListSize,pdwBufLen)

#define IActiveIMMApp_GetCandidateListCountW(This,hIMC,pdwListSize,pdwBufLen)	\
    (This)->lpVtbl -> GetCandidateListCountW(This,hIMC,pdwListSize,pdwBufLen)

#define IActiveIMMApp_GetCandidateWindow(This,hIMC,dwIndex,pCandidate)	\
    (This)->lpVtbl -> GetCandidateWindow(This,hIMC,dwIndex,pCandidate)

#define IActiveIMMApp_GetCompositionFontA(This,hIMC,plf)	\
    (This)->lpVtbl -> GetCompositionFontA(This,hIMC,plf)

#define IActiveIMMApp_GetCompositionFontW(This,hIMC,plf)	\
    (This)->lpVtbl -> GetCompositionFontW(This,hIMC,plf)

#define IActiveIMMApp_GetCompositionStringA(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)	\
    (This)->lpVtbl -> GetCompositionStringA(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)

#define IActiveIMMApp_GetCompositionStringW(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)	\
    (This)->lpVtbl -> GetCompositionStringW(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)

#define IActiveIMMApp_GetCompositionWindow(This,hIMC,pCompForm)	\
    (This)->lpVtbl -> GetCompositionWindow(This,hIMC,pCompForm)

#define IActiveIMMApp_GetContext(This,hWnd,phIMC)	\
    (This)->lpVtbl -> GetContext(This,hWnd,phIMC)

#define IActiveIMMApp_GetConversionListA(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)	\
    (This)->lpVtbl -> GetConversionListA(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)

#define IActiveIMMApp_GetConversionListW(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)	\
    (This)->lpVtbl -> GetConversionListW(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)

#define IActiveIMMApp_GetConversionStatus(This,hIMC,pfdwConversion,pfdwSentence)	\
    (This)->lpVtbl -> GetConversionStatus(This,hIMC,pfdwConversion,pfdwSentence)

#define IActiveIMMApp_GetDefaultIMEWnd(This,hWnd,phDefWnd)	\
    (This)->lpVtbl -> GetDefaultIMEWnd(This,hWnd,phDefWnd)

#define IActiveIMMApp_GetDescriptionA(This,hKL,uBufLen,szDescription,puCopied)	\
    (This)->lpVtbl -> GetDescriptionA(This,hKL,uBufLen,szDescription,puCopied)

#define IActiveIMMApp_GetDescriptionW(This,hKL,uBufLen,szDescription,puCopied)	\
    (This)->lpVtbl -> GetDescriptionW(This,hKL,uBufLen,szDescription,puCopied)

#define IActiveIMMApp_GetGuideLineA(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)	\
    (This)->lpVtbl -> GetGuideLineA(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)

#define IActiveIMMApp_GetGuideLineW(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)	\
    (This)->lpVtbl -> GetGuideLineW(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)

#define IActiveIMMApp_GetIMEFileNameA(This,hKL,uBufLen,szFileName,puCopied)	\
    (This)->lpVtbl -> GetIMEFileNameA(This,hKL,uBufLen,szFileName,puCopied)

#define IActiveIMMApp_GetIMEFileNameW(This,hKL,uBufLen,szFileName,puCopied)	\
    (This)->lpVtbl -> GetIMEFileNameW(This,hKL,uBufLen,szFileName,puCopied)

#define IActiveIMMApp_GetOpenStatus(This,hIMC)	\
    (This)->lpVtbl -> GetOpenStatus(This,hIMC)

#define IActiveIMMApp_GetProperty(This,hKL,fdwIndex,pdwProperty)	\
    (This)->lpVtbl -> GetProperty(This,hKL,fdwIndex,pdwProperty)

#define IActiveIMMApp_GetRegisterWordStyleA(This,hKL,nItem,pStyleBuf,puCopied)	\
    (This)->lpVtbl -> GetRegisterWordStyleA(This,hKL,nItem,pStyleBuf,puCopied)

#define IActiveIMMApp_GetRegisterWordStyleW(This,hKL,nItem,pStyleBuf,puCopied)	\
    (This)->lpVtbl -> GetRegisterWordStyleW(This,hKL,nItem,pStyleBuf,puCopied)

#define IActiveIMMApp_GetStatusWindowPos(This,hIMC,pptPos)	\
    (This)->lpVtbl -> GetStatusWindowPos(This,hIMC,pptPos)

#define IActiveIMMApp_GetVirtualKey(This,hWnd,puVirtualKey)	\
    (This)->lpVtbl -> GetVirtualKey(This,hWnd,puVirtualKey)

#define IActiveIMMApp_InstallIMEA(This,szIMEFileName,szLayoutText,phKL)	\
    (This)->lpVtbl -> InstallIMEA(This,szIMEFileName,szLayoutText,phKL)

#define IActiveIMMApp_InstallIMEW(This,szIMEFileName,szLayoutText,phKL)	\
    (This)->lpVtbl -> InstallIMEW(This,szIMEFileName,szLayoutText,phKL)

#define IActiveIMMApp_IsIME(This,hKL)	\
    (This)->lpVtbl -> IsIME(This,hKL)

#define IActiveIMMApp_IsUIMessageA(This,hWndIME,msg,wParam,lParam)	\
    (This)->lpVtbl -> IsUIMessageA(This,hWndIME,msg,wParam,lParam)

#define IActiveIMMApp_IsUIMessageW(This,hWndIME,msg,wParam,lParam)	\
    (This)->lpVtbl -> IsUIMessageW(This,hWndIME,msg,wParam,lParam)

#define IActiveIMMApp_NotifyIME(This,hIMC,dwAction,dwIndex,dwValue)	\
    (This)->lpVtbl -> NotifyIME(This,hIMC,dwAction,dwIndex,dwValue)

#define IActiveIMMApp_RegisterWordA(This,hKL,szReading,dwStyle,szRegister)	\
    (This)->lpVtbl -> RegisterWordA(This,hKL,szReading,dwStyle,szRegister)

#define IActiveIMMApp_RegisterWordW(This,hKL,szReading,dwStyle,szRegister)	\
    (This)->lpVtbl -> RegisterWordW(This,hKL,szReading,dwStyle,szRegister)

#define IActiveIMMApp_ReleaseContext(This,hWnd,hIMC)	\
    (This)->lpVtbl -> ReleaseContext(This,hWnd,hIMC)

#define IActiveIMMApp_SetCandidateWindow(This,hIMC,pCandidate)	\
    (This)->lpVtbl -> SetCandidateWindow(This,hIMC,pCandidate)

#define IActiveIMMApp_SetCompositionFontA(This,hIMC,plf)	\
    (This)->lpVtbl -> SetCompositionFontA(This,hIMC,plf)

#define IActiveIMMApp_SetCompositionFontW(This,hIMC,plf)	\
    (This)->lpVtbl -> SetCompositionFontW(This,hIMC,plf)

#define IActiveIMMApp_SetCompositionStringA(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionStringA(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIMMApp_SetCompositionStringW(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionStringW(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIMMApp_SetCompositionWindow(This,hIMC,pCompForm)	\
    (This)->lpVtbl -> SetCompositionWindow(This,hIMC,pCompForm)

#define IActiveIMMApp_SetConversionStatus(This,hIMC,fdwConversion,fdwSentence)	\
    (This)->lpVtbl -> SetConversionStatus(This,hIMC,fdwConversion,fdwSentence)

#define IActiveIMMApp_SetOpenStatus(This,hIMC,fOpen)	\
    (This)->lpVtbl -> SetOpenStatus(This,hIMC,fOpen)

#define IActiveIMMApp_SetStatusWindowPos(This,hIMC,pptPos)	\
    (This)->lpVtbl -> SetStatusWindowPos(This,hIMC,pptPos)

#define IActiveIMMApp_SimulateHotKey(This,hWnd,dwHotKeyID)	\
    (This)->lpVtbl -> SimulateHotKey(This,hWnd,dwHotKeyID)

#define IActiveIMMApp_UnregisterWordA(This,hKL,szReading,dwStyle,szUnregister)	\
    (This)->lpVtbl -> UnregisterWordA(This,hKL,szReading,dwStyle,szUnregister)

#define IActiveIMMApp_UnregisterWordW(This,hKL,szReading,dwStyle,szUnregister)	\
    (This)->lpVtbl -> UnregisterWordW(This,hKL,szReading,dwStyle,szUnregister)

#define IActiveIMMApp_Activate(This,fRestoreLayout)	\
    (This)->lpVtbl -> Activate(This,fRestoreLayout)

#define IActiveIMMApp_Deactivate(This)	\
    (This)->lpVtbl -> Deactivate(This)

#define IActiveIMMApp_OnDefWindowProc(This,hWnd,Msg,wParam,lParam,plResult)	\
    (This)->lpVtbl -> OnDefWindowProc(This,hWnd,Msg,wParam,lParam,plResult)

#define IActiveIMMApp_FilterClientWindows(This,aaClassList,uSize)	\
    (This)->lpVtbl -> FilterClientWindows(This,aaClassList,uSize)

#define IActiveIMMApp_GetCodePageA(This,hKL,uCodePage)	\
    (This)->lpVtbl -> GetCodePageA(This,hKL,uCodePage)

#define IActiveIMMApp_GetLangId(This,hKL,plid)	\
    (This)->lpVtbl -> GetLangId(This,hKL,plid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveIMMApp_AssociateContext_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [in] */ HIMC hIME,
    /* [out] */ HIMC __RPC_FAR *phPrev);


void __RPC_STUB IActiveIMMApp_AssociateContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_ConfigureIMEA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwMode,
    /* [in] */ REGISTERWORDA __RPC_FAR *pData);


void __RPC_STUB IActiveIMMApp_ConfigureIMEA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_ConfigureIMEW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwMode,
    /* [in] */ REGISTERWORDW __RPC_FAR *pData);


void __RPC_STUB IActiveIMMApp_ConfigureIMEW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_CreateContext_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [out] */ HIMC __RPC_FAR *phIMC);


void __RPC_STUB IActiveIMMApp_CreateContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_DestroyContext_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIME);


void __RPC_STUB IActiveIMMApp_DestroyContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_EnumRegisterWordA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPSTR szRegister,
    /* [in] */ LPVOID pData,
    /* [out] */ IEnumRegisterWordA __RPC_FAR *__RPC_FAR *pEnum);


void __RPC_STUB IActiveIMMApp_EnumRegisterWordA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_EnumRegisterWordW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szRegister,
    /* [in] */ LPVOID pData,
    /* [out] */ IEnumRegisterWordW __RPC_FAR *__RPC_FAR *pEnum);


void __RPC_STUB IActiveIMMApp_EnumRegisterWordW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_EscapeA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ UINT uEscape,
    /* [out][in] */ LPVOID pData,
    /* [out] */ LRESULT __RPC_FAR *plResult);


void __RPC_STUB IActiveIMMApp_EscapeA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_EscapeW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ UINT uEscape,
    /* [out][in] */ LPVOID pData,
    /* [out] */ LRESULT __RPC_FAR *plResult);


void __RPC_STUB IActiveIMMApp_EscapeW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCandidateListA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ UINT uBufLen,
    /* [out] */ CANDIDATELIST __RPC_FAR *pCandList,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMApp_GetCandidateListA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCandidateListW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ UINT uBufLen,
    /* [out] */ CANDIDATELIST __RPC_FAR *pCandList,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMApp_GetCandidateListW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCandidateListCountA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD __RPC_FAR *pdwListSize,
    /* [out] */ DWORD __RPC_FAR *pdwBufLen);


void __RPC_STUB IActiveIMMApp_GetCandidateListCountA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCandidateListCountW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD __RPC_FAR *pdwListSize,
    /* [out] */ DWORD __RPC_FAR *pdwBufLen);


void __RPC_STUB IActiveIMMApp_GetCandidateListCountW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCandidateWindow_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [out] */ CANDIDATEFORM __RPC_FAR *pCandidate);


void __RPC_STUB IActiveIMMApp_GetCandidateWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCompositionFontA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ LOGFONTA __RPC_FAR *plf);


void __RPC_STUB IActiveIMMApp_GetCompositionFontA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCompositionFontW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ LOGFONTW __RPC_FAR *plf);


void __RPC_STUB IActiveIMMApp_GetCompositionFontW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCompositionStringA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LONG __RPC_FAR *plCopied,
    /* [out] */ LPVOID pBuf);


void __RPC_STUB IActiveIMMApp_GetCompositionStringA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCompositionStringW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LONG __RPC_FAR *plCopied,
    /* [out] */ LPVOID pBuf);


void __RPC_STUB IActiveIMMApp_GetCompositionStringW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCompositionWindow_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ COMPOSITIONFORM __RPC_FAR *pCompForm);


void __RPC_STUB IActiveIMMApp_GetCompositionWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetContext_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [out] */ HIMC __RPC_FAR *phIMC);


void __RPC_STUB IActiveIMMApp_GetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetConversionListA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ LPSTR pSrc,
    /* [in] */ UINT uBufLen,
    /* [in] */ UINT uFlag,
    /* [out] */ CANDIDATELIST __RPC_FAR *pDst,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMApp_GetConversionListA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetConversionListW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ LPWSTR pSrc,
    /* [in] */ UINT uBufLen,
    /* [in] */ UINT uFlag,
    /* [out] */ CANDIDATELIST __RPC_FAR *pDst,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMApp_GetConversionListW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetConversionStatus_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD __RPC_FAR *pfdwConversion,
    /* [out] */ DWORD __RPC_FAR *pfdwSentence);


void __RPC_STUB IActiveIMMApp_GetConversionStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetDefaultIMEWnd_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [out] */ HWND __RPC_FAR *phDefWnd);


void __RPC_STUB IActiveIMMApp_GetDefaultIMEWnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetDescriptionA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPSTR szDescription,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMApp_GetDescriptionA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetDescriptionW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPWSTR szDescription,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMApp_GetDescriptionW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetGuideLineA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LPSTR pBuf,
    /* [out] */ DWORD __RPC_FAR *pdwResult);


void __RPC_STUB IActiveIMMApp_GetGuideLineA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetGuideLineW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LPWSTR pBuf,
    /* [out] */ DWORD __RPC_FAR *pdwResult);


void __RPC_STUB IActiveIMMApp_GetGuideLineW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetIMEFileNameA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPSTR szFileName,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMApp_GetIMEFileNameA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetIMEFileNameW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPWSTR szFileName,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMApp_GetIMEFileNameW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetOpenStatus_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC);


void __RPC_STUB IActiveIMMApp_GetOpenStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetProperty_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ DWORD fdwIndex,
    /* [out] */ DWORD __RPC_FAR *pdwProperty);


void __RPC_STUB IActiveIMMApp_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetRegisterWordStyleA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT nItem,
    /* [out] */ STYLEBUFA __RPC_FAR *pStyleBuf,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMApp_GetRegisterWordStyleA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetRegisterWordStyleW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT nItem,
    /* [out] */ STYLEBUFW __RPC_FAR *pStyleBuf,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMApp_GetRegisterWordStyleW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetStatusWindowPos_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ POINT __RPC_FAR *pptPos);


void __RPC_STUB IActiveIMMApp_GetStatusWindowPos_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetVirtualKey_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [out] */ UINT __RPC_FAR *puVirtualKey);


void __RPC_STUB IActiveIMMApp_GetVirtualKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_InstallIMEA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ LPSTR szIMEFileName,
    /* [in] */ LPSTR szLayoutText,
    /* [out] */ HKL __RPC_FAR *phKL);


void __RPC_STUB IActiveIMMApp_InstallIMEA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_InstallIMEW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ LPWSTR szIMEFileName,
    /* [in] */ LPWSTR szLayoutText,
    /* [out] */ HKL __RPC_FAR *phKL);


void __RPC_STUB IActiveIMMApp_InstallIMEW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_IsIME_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL);


void __RPC_STUB IActiveIMMApp_IsIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_IsUIMessageA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HWND hWndIME,
    /* [in] */ UINT msg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB IActiveIMMApp_IsUIMessageA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_IsUIMessageW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HWND hWndIME,
    /* [in] */ UINT msg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB IActiveIMMApp_IsUIMessageW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_NotifyIME_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwAction,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwValue);


void __RPC_STUB IActiveIMMApp_NotifyIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_RegisterWordA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPSTR szRegister);


void __RPC_STUB IActiveIMMApp_RegisterWordA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_RegisterWordW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szRegister);


void __RPC_STUB IActiveIMMApp_RegisterWordW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_ReleaseContext_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [in] */ HIMC hIMC);


void __RPC_STUB IActiveIMMApp_ReleaseContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCandidateWindow_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ CANDIDATEFORM __RPC_FAR *pCandidate);


void __RPC_STUB IActiveIMMApp_SetCandidateWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCompositionFontA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ LOGFONTA __RPC_FAR *plf);


void __RPC_STUB IActiveIMMApp_SetCompositionFontA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCompositionFontW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ LOGFONTW __RPC_FAR *plf);


void __RPC_STUB IActiveIMMApp_SetCompositionFontW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCompositionStringA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ LPVOID pComp,
    /* [in] */ DWORD dwCompLen,
    /* [in] */ LPVOID pRead,
    /* [in] */ DWORD dwReadLen);


void __RPC_STUB IActiveIMMApp_SetCompositionStringA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCompositionStringW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ LPVOID pComp,
    /* [in] */ DWORD dwCompLen,
    /* [in] */ LPVOID pRead,
    /* [in] */ DWORD dwReadLen);


void __RPC_STUB IActiveIMMApp_SetCompositionStringW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetCompositionWindow_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ COMPOSITIONFORM __RPC_FAR *pCompForm);


void __RPC_STUB IActiveIMMApp_SetCompositionWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetConversionStatus_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD fdwConversion,
    /* [in] */ DWORD fdwSentence);


void __RPC_STUB IActiveIMMApp_SetConversionStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetOpenStatus_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ BOOL fOpen);


void __RPC_STUB IActiveIMMApp_SetOpenStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SetStatusWindowPos_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ POINT __RPC_FAR *pptPos);


void __RPC_STUB IActiveIMMApp_SetStatusWindowPos_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_SimulateHotKey_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwHotKeyID);


void __RPC_STUB IActiveIMMApp_SimulateHotKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_UnregisterWordA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPSTR szUnregister);


void __RPC_STUB IActiveIMMApp_UnregisterWordA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_UnregisterWordW_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szUnregister);


void __RPC_STUB IActiveIMMApp_UnregisterWordW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_Activate_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ BOOL fRestoreLayout);


void __RPC_STUB IActiveIMMApp_Activate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_Deactivate_Proxy( 
    IActiveIMMApp __RPC_FAR * This);


void __RPC_STUB IActiveIMMApp_Deactivate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_OnDefWindowProc_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [in] */ UINT Msg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam,
    /* [out] */ LRESULT __RPC_FAR *plResult);


void __RPC_STUB IActiveIMMApp_OnDefWindowProc_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_FilterClientWindows_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ ATOM __RPC_FAR *aaClassList,
    /* [in] */ UINT uSize);


void __RPC_STUB IActiveIMMApp_FilterClientWindows_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetCodePageA_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [out] */ UINT __RPC_FAR *uCodePage);


void __RPC_STUB IActiveIMMApp_GetCodePageA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMApp_GetLangId_Proxy( 
    IActiveIMMApp __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [out] */ LANGID __RPC_FAR *plid);


void __RPC_STUB IActiveIMMApp_GetLangId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveIMMApp_INTERFACE_DEFINED__ */


#ifndef __IActiveIMMIME_INTERFACE_DEFINED__
#define __IActiveIMMIME_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IActiveIMMIME
 * at Tue Jan 13 08:56:29 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IActiveIMMIME;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("08C03411-F96B-11d0-A475-00AA006BCC59")
    IActiveIMMIME : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AssociateContext( 
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIME,
            /* [out] */ HIMC __RPC_FAR *phPrev) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfigureIMEA( 
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDA __RPC_FAR *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConfigureIMEW( 
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW __RPC_FAR *pData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateContext( 
            /* [out] */ HIMC __RPC_FAR *phIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyContext( 
            /* [in] */ HIMC hIME) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRegisterWordA( 
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordA __RPC_FAR *__RPC_FAR *pEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRegisterWordW( 
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW __RPC_FAR *__RPC_FAR *pEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EscapeA( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT __RPC_FAR *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EscapeW( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT __RPC_FAR *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST __RPC_FAR *pCandList,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST __RPC_FAR *pCandList,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListCountA( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pdwListSize,
            /* [out] */ DWORD __RPC_FAR *pdwBufLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateListCountW( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pdwListSize,
            /* [out] */ DWORD __RPC_FAR *pdwBufLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCandidateWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [out] */ CANDIDATEFORM __RPC_FAR *pCandidate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionFontA( 
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTA __RPC_FAR *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionFontW( 
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTW __RPC_FAR *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionStringA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG __RPC_FAR *plCopied,
            /* [out] */ LPVOID pBuf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionStringW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG __RPC_FAR *plCopied,
            /* [out] */ LPVOID pBuf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCompositionWindow( 
            /* [in] */ HIMC hIMC,
            /* [out] */ COMPOSITIONFORM __RPC_FAR *pCompForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetContext( 
            /* [in] */ HWND hWnd,
            /* [out] */ HIMC __RPC_FAR *phIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionListA( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST __RPC_FAR *pDst,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionListW( 
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST __RPC_FAR *pDst,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetConversionStatus( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pfdwConversion,
            /* [out] */ DWORD __RPC_FAR *pfdwSentence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDefaultIMEWnd( 
            /* [in] */ HWND hWnd,
            /* [out] */ HWND __RPC_FAR *phDefWnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescriptionA( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szDescription,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDescriptionW( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szDescription,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuideLineA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPSTR pBuf,
            /* [out] */ DWORD __RPC_FAR *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetGuideLineW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPWSTR pBuf,
            /* [out] */ DWORD __RPC_FAR *pdwResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMEFileNameA( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szFileName,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMEFileNameW( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szFileName,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetOpenStatus( 
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetProperty( 
            /* [in] */ HKL hKL,
            /* [in] */ DWORD fdwIndex,
            /* [out] */ DWORD __RPC_FAR *pdwProperty) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterWordStyleA( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFA __RPC_FAR *pStyleBuf,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterWordStyleW( 
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW __RPC_FAR *pStyleBuf,
            /* [out] */ UINT __RPC_FAR *puCopied) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetStatusWindowPos( 
            /* [in] */ HIMC hIMC,
            /* [out] */ POINT __RPC_FAR *pptPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVirtualKey( 
            /* [in] */ HWND hWnd,
            /* [out] */ UINT __RPC_FAR *puVirtualKey) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallIMEA( 
            /* [in] */ LPSTR szIMEFileName,
            /* [in] */ LPSTR szLayoutText,
            /* [out] */ HKL __RPC_FAR *phKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE InstallIMEW( 
            /* [in] */ LPWSTR szIMEFileName,
            /* [in] */ LPWSTR szLayoutText,
            /* [out] */ HKL __RPC_FAR *phKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsIME( 
            /* [in] */ HKL hKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUIMessageA( 
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUIMessageW( 
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE NotifyIME( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterWordA( 
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterWordW( 
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReleaseContext( 
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCandidateWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ CANDIDATEFORM __RPC_FAR *pCandidate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionFontA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTA __RPC_FAR *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionFontW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTW __RPC_FAR *plf) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionStringA( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionStringW( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionWindow( 
            /* [in] */ HIMC hIMC,
            /* [in] */ COMPOSITIONFORM __RPC_FAR *pCompForm) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetConversionStatus( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD fdwConversion,
            /* [in] */ DWORD fdwSentence) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetOpenStatus( 
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fOpen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetStatusWindowPos( 
            /* [in] */ HIMC hIMC,
            /* [in] */ POINT __RPC_FAR *pptPos) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SimulateHotKey( 
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwHotKeyID) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterWordA( 
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szUnregister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterWordW( 
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szUnregister) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GenerateMessage( 
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockIMC( 
            /* [in] */ HIMC hIMC,
            /* [out] */ INPUTCONTEXT __RPC_FAR *__RPC_FAR *ppIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockIMC( 
            /* [in] */ HIMC hIMC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMCLockCount( 
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pdwLockCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateIMCC( 
            /* [in] */ DWORD dwSize,
            /* [out] */ HIMCC __RPC_FAR *phIMCC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroyIMCC( 
            /* [in] */ HIMCC hIMCC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockIMCC( 
            /* [in] */ HIMCC hIMCC,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockIMCC( 
            /* [in] */ HIMCC hIMCC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ReSizeIMCC( 
            /* [in] */ HIMCC hIMCC,
            /* [in] */ DWORD dwSize,
            /* [out] */ HIMCC __RPC_FAR *phIMCC) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMCCSize( 
            /* [in] */ HIMCC hIMCC,
            /* [out] */ DWORD __RPC_FAR *pdwSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetIMCCLockCount( 
            /* [in] */ HIMCC hIMCC,
            /* [out] */ DWORD __RPC_FAR *pdwLockCount) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHotKey( 
            /* [in] */ DWORD dwHotKeyID,
            /* [out] */ UINT __RPC_FAR *puModifiers,
            /* [out] */ UINT __RPC_FAR *puVKey,
            /* [out] */ HKL __RPC_FAR *phKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetHotKey( 
            /* [in] */ DWORD dwHotKeyID,
            /* [in] */ UINT uModifiers,
            /* [in] */ UINT uVKey,
            /* [in] */ HKL hKL) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE CreateSoftKeyboard( 
            /* [in] */ UINT uType,
            /* [in] */ HWND hOwner,
            /* [in] */ int x,
            /* [in] */ int y,
            /* [out] */ HWND __RPC_FAR *phSoftKbdWnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DestroySoftKeyboard( 
            /* [in] */ HWND hSoftKbdWnd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ShowSoftKeyboard( 
            /* [in] */ HWND hSoftKbdWnd,
            /* [in] */ int nCmdShow) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodePageA( 
            /* [in] */ HKL hKL,
            /* [out] */ UINT __RPC_FAR *uCodePage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLangId( 
            /* [in] */ HKL hKL,
            /* [out] */ LANGID __RPC_FAR *plid) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE KeybdEvent( 
            /* [in] */ LANGID lgidIME,
            /* [in] */ BYTE bVk,
            /* [in] */ BYTE bScan,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwExtraInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LockModal( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnlockModal( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMMIMEVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IActiveIMMIME __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IActiveIMMIME __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AssociateContext )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIME,
            /* [out] */ HIMC __RPC_FAR *phPrev);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConfigureIMEA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDA __RPC_FAR *pData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConfigureIMEW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW __RPC_FAR *pData);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateContext )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [out] */ HIMC __RPC_FAR *phIMC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DestroyContext )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIME);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumRegisterWordA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordA __RPC_FAR *__RPC_FAR *pEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumRegisterWordW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW __RPC_FAR *__RPC_FAR *pEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EscapeA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT __RPC_FAR *plResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EscapeW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ LPVOID pData,
            /* [out] */ LRESULT __RPC_FAR *plResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCandidateListA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST __RPC_FAR *pCandList,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCandidateListW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ UINT uBufLen,
            /* [out] */ CANDIDATELIST __RPC_FAR *pCandList,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCandidateListCountA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pdwListSize,
            /* [out] */ DWORD __RPC_FAR *pdwBufLen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCandidateListCountW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pdwListSize,
            /* [out] */ DWORD __RPC_FAR *pdwBufLen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCandidateWindow )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [out] */ CANDIDATEFORM __RPC_FAR *pCandidate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCompositionFontA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTA __RPC_FAR *plf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCompositionFontW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ LOGFONTW __RPC_FAR *plf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCompositionStringA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG __RPC_FAR *plCopied,
            /* [out] */ LPVOID pBuf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCompositionStringW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LONG __RPC_FAR *plCopied,
            /* [out] */ LPVOID pBuf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCompositionWindow )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ COMPOSITIONFORM __RPC_FAR *pCompForm);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetContext )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [out] */ HIMC __RPC_FAR *phIMC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConversionListA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST __RPC_FAR *pDst,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConversionListW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR pSrc,
            /* [in] */ UINT uBufLen,
            /* [in] */ UINT uFlag,
            /* [out] */ CANDIDATELIST __RPC_FAR *pDst,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetConversionStatus )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pfdwConversion,
            /* [out] */ DWORD __RPC_FAR *pfdwSentence);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDefaultIMEWnd )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [out] */ HWND __RPC_FAR *phDefWnd);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDescriptionA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szDescription,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetDescriptionW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szDescription,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGuideLineA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPSTR pBuf,
            /* [out] */ DWORD __RPC_FAR *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetGuideLineW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ LPWSTR pBuf,
            /* [out] */ DWORD __RPC_FAR *pdwResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIMEFileNameA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPSTR szFileName,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIMEFileNameW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT uBufLen,
            /* [out] */ LPWSTR szFileName,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetOpenStatus )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetProperty )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ DWORD fdwIndex,
            /* [out] */ DWORD __RPC_FAR *pdwProperty);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRegisterWordStyleA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFA __RPC_FAR *pStyleBuf,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRegisterWordStyleW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW __RPC_FAR *pStyleBuf,
            /* [out] */ UINT __RPC_FAR *puCopied);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetStatusWindowPos )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ POINT __RPC_FAR *pptPos);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetVirtualKey )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [out] */ UINT __RPC_FAR *puVirtualKey);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InstallIMEA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ LPSTR szIMEFileName,
            /* [in] */ LPSTR szLayoutText,
            /* [out] */ HKL __RPC_FAR *phKL);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *InstallIMEW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ LPWSTR szIMEFileName,
            /* [in] */ LPWSTR szLayoutText,
            /* [out] */ HKL __RPC_FAR *phKL);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsIME )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsUIMessageA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsUIMessageW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HWND hWndIME,
            /* [in] */ UINT msg,
            /* [in] */ WPARAM wParam,
            /* [in] */ LPARAM lParam);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *NotifyIME )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterWordA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szRegister);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterWordW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReleaseContext )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCandidateWindow )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ CANDIDATEFORM __RPC_FAR *pCandidate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCompositionFontA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTA __RPC_FAR *plf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCompositionFontW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LOGFONTW __RPC_FAR *plf);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCompositionStringA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCompositionStringW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ LPVOID pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ LPVOID pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCompositionWindow )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ COMPOSITIONFORM __RPC_FAR *pCompForm);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetConversionStatus )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD fdwConversion,
            /* [in] */ DWORD fdwSentence);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetOpenStatus )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fOpen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetStatusWindowPos )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ POINT __RPC_FAR *pptPos);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SimulateHotKey )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwHotKeyID);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnregisterWordA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPSTR szUnregister);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnregisterWordW )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szUnregister);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GenerateMessage )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LockIMC )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ INPUTCONTEXT __RPC_FAR *__RPC_FAR *ppIMC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnlockIMC )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIMCLockCount )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pdwLockCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateIMCC )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ DWORD dwSize,
            /* [out] */ HIMCC __RPC_FAR *phIMCC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DestroyIMCC )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMCC hIMCC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LockIMCC )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMCC hIMCC,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppv);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnlockIMCC )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMCC hIMCC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ReSizeIMCC )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMCC hIMCC,
            /* [in] */ DWORD dwSize,
            /* [out] */ HIMCC __RPC_FAR *phIMCC);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIMCCSize )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMCC hIMCC,
            /* [out] */ DWORD __RPC_FAR *pdwSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIMCCLockCount )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HIMCC hIMCC,
            /* [out] */ DWORD __RPC_FAR *pdwLockCount);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetHotKey )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ DWORD dwHotKeyID,
            /* [out] */ UINT __RPC_FAR *puModifiers,
            /* [out] */ UINT __RPC_FAR *puVKey,
            /* [out] */ HKL __RPC_FAR *phKL);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetHotKey )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ DWORD dwHotKeyID,
            /* [in] */ UINT uModifiers,
            /* [in] */ UINT uVKey,
            /* [in] */ HKL hKL);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateSoftKeyboard )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ UINT uType,
            /* [in] */ HWND hOwner,
            /* [in] */ int x,
            /* [in] */ int y,
            /* [out] */ HWND __RPC_FAR *phSoftKbdWnd);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *DestroySoftKeyboard )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HWND hSoftKbdWnd);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ShowSoftKeyboard )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HWND hSoftKbdWnd,
            /* [in] */ int nCmdShow);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodePageA )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [out] */ UINT __RPC_FAR *uCodePage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLangId )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [out] */ LANGID __RPC_FAR *plid);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *KeybdEvent )( 
            IActiveIMMIME __RPC_FAR * This,
            /* [in] */ LANGID lgidIME,
            /* [in] */ BYTE bVk,
            /* [in] */ BYTE bScan,
            /* [in] */ DWORD dwFlags,
            /* [in] */ DWORD dwExtraInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *LockModal )( 
            IActiveIMMIME __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnlockModal )( 
            IActiveIMMIME __RPC_FAR * This);
        
        END_INTERFACE
    } IActiveIMMIMEVtbl;

    interface IActiveIMMIME
    {
        CONST_VTBL struct IActiveIMMIMEVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIMMIME_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveIMMIME_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveIMMIME_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveIMMIME_AssociateContext(This,hWnd,hIME,phPrev)	\
    (This)->lpVtbl -> AssociateContext(This,hWnd,hIME,phPrev)

#define IActiveIMMIME_ConfigureIMEA(This,hKL,hWnd,dwMode,pData)	\
    (This)->lpVtbl -> ConfigureIMEA(This,hKL,hWnd,dwMode,pData)

#define IActiveIMMIME_ConfigureIMEW(This,hKL,hWnd,dwMode,pData)	\
    (This)->lpVtbl -> ConfigureIMEW(This,hKL,hWnd,dwMode,pData)

#define IActiveIMMIME_CreateContext(This,phIMC)	\
    (This)->lpVtbl -> CreateContext(This,phIMC)

#define IActiveIMMIME_DestroyContext(This,hIME)	\
    (This)->lpVtbl -> DestroyContext(This,hIME)

#define IActiveIMMIME_EnumRegisterWordA(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)	\
    (This)->lpVtbl -> EnumRegisterWordA(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)

#define IActiveIMMIME_EnumRegisterWordW(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)	\
    (This)->lpVtbl -> EnumRegisterWordW(This,hKL,szReading,dwStyle,szRegister,pData,pEnum)

#define IActiveIMMIME_EscapeA(This,hKL,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> EscapeA(This,hKL,hIMC,uEscape,pData,plResult)

#define IActiveIMMIME_EscapeW(This,hKL,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> EscapeW(This,hKL,hIMC,uEscape,pData,plResult)

#define IActiveIMMIME_GetCandidateListA(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)	\
    (This)->lpVtbl -> GetCandidateListA(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)

#define IActiveIMMIME_GetCandidateListW(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)	\
    (This)->lpVtbl -> GetCandidateListW(This,hIMC,dwIndex,uBufLen,pCandList,puCopied)

#define IActiveIMMIME_GetCandidateListCountA(This,hIMC,pdwListSize,pdwBufLen)	\
    (This)->lpVtbl -> GetCandidateListCountA(This,hIMC,pdwListSize,pdwBufLen)

#define IActiveIMMIME_GetCandidateListCountW(This,hIMC,pdwListSize,pdwBufLen)	\
    (This)->lpVtbl -> GetCandidateListCountW(This,hIMC,pdwListSize,pdwBufLen)

#define IActiveIMMIME_GetCandidateWindow(This,hIMC,dwIndex,pCandidate)	\
    (This)->lpVtbl -> GetCandidateWindow(This,hIMC,dwIndex,pCandidate)

#define IActiveIMMIME_GetCompositionFontA(This,hIMC,plf)	\
    (This)->lpVtbl -> GetCompositionFontA(This,hIMC,plf)

#define IActiveIMMIME_GetCompositionFontW(This,hIMC,plf)	\
    (This)->lpVtbl -> GetCompositionFontW(This,hIMC,plf)

#define IActiveIMMIME_GetCompositionStringA(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)	\
    (This)->lpVtbl -> GetCompositionStringA(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)

#define IActiveIMMIME_GetCompositionStringW(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)	\
    (This)->lpVtbl -> GetCompositionStringW(This,hIMC,dwIndex,dwBufLen,plCopied,pBuf)

#define IActiveIMMIME_GetCompositionWindow(This,hIMC,pCompForm)	\
    (This)->lpVtbl -> GetCompositionWindow(This,hIMC,pCompForm)

#define IActiveIMMIME_GetContext(This,hWnd,phIMC)	\
    (This)->lpVtbl -> GetContext(This,hWnd,phIMC)

#define IActiveIMMIME_GetConversionListA(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)	\
    (This)->lpVtbl -> GetConversionListA(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)

#define IActiveIMMIME_GetConversionListW(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)	\
    (This)->lpVtbl -> GetConversionListW(This,hKL,hIMC,pSrc,uBufLen,uFlag,pDst,puCopied)

#define IActiveIMMIME_GetConversionStatus(This,hIMC,pfdwConversion,pfdwSentence)	\
    (This)->lpVtbl -> GetConversionStatus(This,hIMC,pfdwConversion,pfdwSentence)

#define IActiveIMMIME_GetDefaultIMEWnd(This,hWnd,phDefWnd)	\
    (This)->lpVtbl -> GetDefaultIMEWnd(This,hWnd,phDefWnd)

#define IActiveIMMIME_GetDescriptionA(This,hKL,uBufLen,szDescription,puCopied)	\
    (This)->lpVtbl -> GetDescriptionA(This,hKL,uBufLen,szDescription,puCopied)

#define IActiveIMMIME_GetDescriptionW(This,hKL,uBufLen,szDescription,puCopied)	\
    (This)->lpVtbl -> GetDescriptionW(This,hKL,uBufLen,szDescription,puCopied)

#define IActiveIMMIME_GetGuideLineA(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)	\
    (This)->lpVtbl -> GetGuideLineA(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)

#define IActiveIMMIME_GetGuideLineW(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)	\
    (This)->lpVtbl -> GetGuideLineW(This,hIMC,dwIndex,dwBufLen,pBuf,pdwResult)

#define IActiveIMMIME_GetIMEFileNameA(This,hKL,uBufLen,szFileName,puCopied)	\
    (This)->lpVtbl -> GetIMEFileNameA(This,hKL,uBufLen,szFileName,puCopied)

#define IActiveIMMIME_GetIMEFileNameW(This,hKL,uBufLen,szFileName,puCopied)	\
    (This)->lpVtbl -> GetIMEFileNameW(This,hKL,uBufLen,szFileName,puCopied)

#define IActiveIMMIME_GetOpenStatus(This,hIMC)	\
    (This)->lpVtbl -> GetOpenStatus(This,hIMC)

#define IActiveIMMIME_GetProperty(This,hKL,fdwIndex,pdwProperty)	\
    (This)->lpVtbl -> GetProperty(This,hKL,fdwIndex,pdwProperty)

#define IActiveIMMIME_GetRegisterWordStyleA(This,hKL,nItem,pStyleBuf,puCopied)	\
    (This)->lpVtbl -> GetRegisterWordStyleA(This,hKL,nItem,pStyleBuf,puCopied)

#define IActiveIMMIME_GetRegisterWordStyleW(This,hKL,nItem,pStyleBuf,puCopied)	\
    (This)->lpVtbl -> GetRegisterWordStyleW(This,hKL,nItem,pStyleBuf,puCopied)

#define IActiveIMMIME_GetStatusWindowPos(This,hIMC,pptPos)	\
    (This)->lpVtbl -> GetStatusWindowPos(This,hIMC,pptPos)

#define IActiveIMMIME_GetVirtualKey(This,hWnd,puVirtualKey)	\
    (This)->lpVtbl -> GetVirtualKey(This,hWnd,puVirtualKey)

#define IActiveIMMIME_InstallIMEA(This,szIMEFileName,szLayoutText,phKL)	\
    (This)->lpVtbl -> InstallIMEA(This,szIMEFileName,szLayoutText,phKL)

#define IActiveIMMIME_InstallIMEW(This,szIMEFileName,szLayoutText,phKL)	\
    (This)->lpVtbl -> InstallIMEW(This,szIMEFileName,szLayoutText,phKL)

#define IActiveIMMIME_IsIME(This,hKL)	\
    (This)->lpVtbl -> IsIME(This,hKL)

#define IActiveIMMIME_IsUIMessageA(This,hWndIME,msg,wParam,lParam)	\
    (This)->lpVtbl -> IsUIMessageA(This,hWndIME,msg,wParam,lParam)

#define IActiveIMMIME_IsUIMessageW(This,hWndIME,msg,wParam,lParam)	\
    (This)->lpVtbl -> IsUIMessageW(This,hWndIME,msg,wParam,lParam)

#define IActiveIMMIME_NotifyIME(This,hIMC,dwAction,dwIndex,dwValue)	\
    (This)->lpVtbl -> NotifyIME(This,hIMC,dwAction,dwIndex,dwValue)

#define IActiveIMMIME_RegisterWordA(This,hKL,szReading,dwStyle,szRegister)	\
    (This)->lpVtbl -> RegisterWordA(This,hKL,szReading,dwStyle,szRegister)

#define IActiveIMMIME_RegisterWordW(This,hKL,szReading,dwStyle,szRegister)	\
    (This)->lpVtbl -> RegisterWordW(This,hKL,szReading,dwStyle,szRegister)

#define IActiveIMMIME_ReleaseContext(This,hWnd,hIMC)	\
    (This)->lpVtbl -> ReleaseContext(This,hWnd,hIMC)

#define IActiveIMMIME_SetCandidateWindow(This,hIMC,pCandidate)	\
    (This)->lpVtbl -> SetCandidateWindow(This,hIMC,pCandidate)

#define IActiveIMMIME_SetCompositionFontA(This,hIMC,plf)	\
    (This)->lpVtbl -> SetCompositionFontA(This,hIMC,plf)

#define IActiveIMMIME_SetCompositionFontW(This,hIMC,plf)	\
    (This)->lpVtbl -> SetCompositionFontW(This,hIMC,plf)

#define IActiveIMMIME_SetCompositionStringA(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionStringA(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIMMIME_SetCompositionStringW(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionStringW(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIMMIME_SetCompositionWindow(This,hIMC,pCompForm)	\
    (This)->lpVtbl -> SetCompositionWindow(This,hIMC,pCompForm)

#define IActiveIMMIME_SetConversionStatus(This,hIMC,fdwConversion,fdwSentence)	\
    (This)->lpVtbl -> SetConversionStatus(This,hIMC,fdwConversion,fdwSentence)

#define IActiveIMMIME_SetOpenStatus(This,hIMC,fOpen)	\
    (This)->lpVtbl -> SetOpenStatus(This,hIMC,fOpen)

#define IActiveIMMIME_SetStatusWindowPos(This,hIMC,pptPos)	\
    (This)->lpVtbl -> SetStatusWindowPos(This,hIMC,pptPos)

#define IActiveIMMIME_SimulateHotKey(This,hWnd,dwHotKeyID)	\
    (This)->lpVtbl -> SimulateHotKey(This,hWnd,dwHotKeyID)

#define IActiveIMMIME_UnregisterWordA(This,hKL,szReading,dwStyle,szUnregister)	\
    (This)->lpVtbl -> UnregisterWordA(This,hKL,szReading,dwStyle,szUnregister)

#define IActiveIMMIME_UnregisterWordW(This,hKL,szReading,dwStyle,szUnregister)	\
    (This)->lpVtbl -> UnregisterWordW(This,hKL,szReading,dwStyle,szUnregister)

#define IActiveIMMIME_GenerateMessage(This,hIMC)	\
    (This)->lpVtbl -> GenerateMessage(This,hIMC)

#define IActiveIMMIME_LockIMC(This,hIMC,ppIMC)	\
    (This)->lpVtbl -> LockIMC(This,hIMC,ppIMC)

#define IActiveIMMIME_UnlockIMC(This,hIMC)	\
    (This)->lpVtbl -> UnlockIMC(This,hIMC)

#define IActiveIMMIME_GetIMCLockCount(This,hIMC,pdwLockCount)	\
    (This)->lpVtbl -> GetIMCLockCount(This,hIMC,pdwLockCount)

#define IActiveIMMIME_CreateIMCC(This,dwSize,phIMCC)	\
    (This)->lpVtbl -> CreateIMCC(This,dwSize,phIMCC)

#define IActiveIMMIME_DestroyIMCC(This,hIMCC)	\
    (This)->lpVtbl -> DestroyIMCC(This,hIMCC)

#define IActiveIMMIME_LockIMCC(This,hIMCC,ppv)	\
    (This)->lpVtbl -> LockIMCC(This,hIMCC,ppv)

#define IActiveIMMIME_UnlockIMCC(This,hIMCC)	\
    (This)->lpVtbl -> UnlockIMCC(This,hIMCC)

#define IActiveIMMIME_ReSizeIMCC(This,hIMCC,dwSize,phIMCC)	\
    (This)->lpVtbl -> ReSizeIMCC(This,hIMCC,dwSize,phIMCC)

#define IActiveIMMIME_GetIMCCSize(This,hIMCC,pdwSize)	\
    (This)->lpVtbl -> GetIMCCSize(This,hIMCC,pdwSize)

#define IActiveIMMIME_GetIMCCLockCount(This,hIMCC,pdwLockCount)	\
    (This)->lpVtbl -> GetIMCCLockCount(This,hIMCC,pdwLockCount)

#define IActiveIMMIME_GetHotKey(This,dwHotKeyID,puModifiers,puVKey,phKL)	\
    (This)->lpVtbl -> GetHotKey(This,dwHotKeyID,puModifiers,puVKey,phKL)

#define IActiveIMMIME_SetHotKey(This,dwHotKeyID,uModifiers,uVKey,hKL)	\
    (This)->lpVtbl -> SetHotKey(This,dwHotKeyID,uModifiers,uVKey,hKL)

#define IActiveIMMIME_CreateSoftKeyboard(This,uType,hOwner,x,y,phSoftKbdWnd)	\
    (This)->lpVtbl -> CreateSoftKeyboard(This,uType,hOwner,x,y,phSoftKbdWnd)

#define IActiveIMMIME_DestroySoftKeyboard(This,hSoftKbdWnd)	\
    (This)->lpVtbl -> DestroySoftKeyboard(This,hSoftKbdWnd)

#define IActiveIMMIME_ShowSoftKeyboard(This,hSoftKbdWnd,nCmdShow)	\
    (This)->lpVtbl -> ShowSoftKeyboard(This,hSoftKbdWnd,nCmdShow)

#define IActiveIMMIME_GetCodePageA(This,hKL,uCodePage)	\
    (This)->lpVtbl -> GetCodePageA(This,hKL,uCodePage)

#define IActiveIMMIME_GetLangId(This,hKL,plid)	\
    (This)->lpVtbl -> GetLangId(This,hKL,plid)

#define IActiveIMMIME_KeybdEvent(This,lgidIME,bVk,bScan,dwFlags,dwExtraInfo)	\
    (This)->lpVtbl -> KeybdEvent(This,lgidIME,bVk,bScan,dwFlags,dwExtraInfo)

#define IActiveIMMIME_LockModal(This)	\
    (This)->lpVtbl -> LockModal(This)

#define IActiveIMMIME_UnlockModal(This)	\
    (This)->lpVtbl -> UnlockModal(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveIMMIME_AssociateContext_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [in] */ HIMC hIME,
    /* [out] */ HIMC __RPC_FAR *phPrev);


void __RPC_STUB IActiveIMMIME_AssociateContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_ConfigureIMEA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwMode,
    /* [in] */ REGISTERWORDA __RPC_FAR *pData);


void __RPC_STUB IActiveIMMIME_ConfigureIMEA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_ConfigureIMEW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwMode,
    /* [in] */ REGISTERWORDW __RPC_FAR *pData);


void __RPC_STUB IActiveIMMIME_ConfigureIMEW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_CreateContext_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [out] */ HIMC __RPC_FAR *phIMC);


void __RPC_STUB IActiveIMMIME_CreateContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_DestroyContext_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIME);


void __RPC_STUB IActiveIMMIME_DestroyContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_EnumRegisterWordA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPSTR szRegister,
    /* [in] */ LPVOID pData,
    /* [out] */ IEnumRegisterWordA __RPC_FAR *__RPC_FAR *pEnum);


void __RPC_STUB IActiveIMMIME_EnumRegisterWordA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_EnumRegisterWordW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szRegister,
    /* [in] */ LPVOID pData,
    /* [out] */ IEnumRegisterWordW __RPC_FAR *__RPC_FAR *pEnum);


void __RPC_STUB IActiveIMMIME_EnumRegisterWordW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_EscapeA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ UINT uEscape,
    /* [out][in] */ LPVOID pData,
    /* [out] */ LRESULT __RPC_FAR *plResult);


void __RPC_STUB IActiveIMMIME_EscapeA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_EscapeW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ UINT uEscape,
    /* [out][in] */ LPVOID pData,
    /* [out] */ LRESULT __RPC_FAR *plResult);


void __RPC_STUB IActiveIMMIME_EscapeW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCandidateListA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ UINT uBufLen,
    /* [out] */ CANDIDATELIST __RPC_FAR *pCandList,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMIME_GetCandidateListA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCandidateListW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ UINT uBufLen,
    /* [out] */ CANDIDATELIST __RPC_FAR *pCandList,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMIME_GetCandidateListW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCandidateListCountA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD __RPC_FAR *pdwListSize,
    /* [out] */ DWORD __RPC_FAR *pdwBufLen);


void __RPC_STUB IActiveIMMIME_GetCandidateListCountA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCandidateListCountW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD __RPC_FAR *pdwListSize,
    /* [out] */ DWORD __RPC_FAR *pdwBufLen);


void __RPC_STUB IActiveIMMIME_GetCandidateListCountW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCandidateWindow_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [out] */ CANDIDATEFORM __RPC_FAR *pCandidate);


void __RPC_STUB IActiveIMMIME_GetCandidateWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCompositionFontA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ LOGFONTA __RPC_FAR *plf);


void __RPC_STUB IActiveIMMIME_GetCompositionFontA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCompositionFontW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ LOGFONTW __RPC_FAR *plf);


void __RPC_STUB IActiveIMMIME_GetCompositionFontW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCompositionStringA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LONG __RPC_FAR *plCopied,
    /* [out] */ LPVOID pBuf);


void __RPC_STUB IActiveIMMIME_GetCompositionStringA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCompositionStringW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LONG __RPC_FAR *plCopied,
    /* [out] */ LPVOID pBuf);


void __RPC_STUB IActiveIMMIME_GetCompositionStringW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCompositionWindow_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ COMPOSITIONFORM __RPC_FAR *pCompForm);


void __RPC_STUB IActiveIMMIME_GetCompositionWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetContext_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [out] */ HIMC __RPC_FAR *phIMC);


void __RPC_STUB IActiveIMMIME_GetContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetConversionListA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ LPSTR pSrc,
    /* [in] */ UINT uBufLen,
    /* [in] */ UINT uFlag,
    /* [out] */ CANDIDATELIST __RPC_FAR *pDst,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMIME_GetConversionListA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetConversionListW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ HIMC hIMC,
    /* [in] */ LPWSTR pSrc,
    /* [in] */ UINT uBufLen,
    /* [in] */ UINT uFlag,
    /* [out] */ CANDIDATELIST __RPC_FAR *pDst,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMIME_GetConversionListW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetConversionStatus_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD __RPC_FAR *pfdwConversion,
    /* [out] */ DWORD __RPC_FAR *pfdwSentence);


void __RPC_STUB IActiveIMMIME_GetConversionStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetDefaultIMEWnd_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [out] */ HWND __RPC_FAR *phDefWnd);


void __RPC_STUB IActiveIMMIME_GetDefaultIMEWnd_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetDescriptionA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPSTR szDescription,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMIME_GetDescriptionA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetDescriptionW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPWSTR szDescription,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMIME_GetDescriptionW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetGuideLineA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LPSTR pBuf,
    /* [out] */ DWORD __RPC_FAR *pdwResult);


void __RPC_STUB IActiveIMMIME_GetGuideLineA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetGuideLineW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ LPWSTR pBuf,
    /* [out] */ DWORD __RPC_FAR *pdwResult);


void __RPC_STUB IActiveIMMIME_GetGuideLineW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetIMEFileNameA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPSTR szFileName,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMIME_GetIMEFileNameA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetIMEFileNameW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT uBufLen,
    /* [out] */ LPWSTR szFileName,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMIME_GetIMEFileNameW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetOpenStatus_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC);


void __RPC_STUB IActiveIMMIME_GetOpenStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetProperty_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ DWORD fdwIndex,
    /* [out] */ DWORD __RPC_FAR *pdwProperty);


void __RPC_STUB IActiveIMMIME_GetProperty_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetRegisterWordStyleA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT nItem,
    /* [out] */ STYLEBUFA __RPC_FAR *pStyleBuf,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMIME_GetRegisterWordStyleA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetRegisterWordStyleW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ UINT nItem,
    /* [out] */ STYLEBUFW __RPC_FAR *pStyleBuf,
    /* [out] */ UINT __RPC_FAR *puCopied);


void __RPC_STUB IActiveIMMIME_GetRegisterWordStyleW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetStatusWindowPos_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ POINT __RPC_FAR *pptPos);


void __RPC_STUB IActiveIMMIME_GetStatusWindowPos_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetVirtualKey_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [out] */ UINT __RPC_FAR *puVirtualKey);


void __RPC_STUB IActiveIMMIME_GetVirtualKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_InstallIMEA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ LPSTR szIMEFileName,
    /* [in] */ LPSTR szLayoutText,
    /* [out] */ HKL __RPC_FAR *phKL);


void __RPC_STUB IActiveIMMIME_InstallIMEA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_InstallIMEW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ LPWSTR szIMEFileName,
    /* [in] */ LPWSTR szLayoutText,
    /* [out] */ HKL __RPC_FAR *phKL);


void __RPC_STUB IActiveIMMIME_InstallIMEW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_IsIME_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL);


void __RPC_STUB IActiveIMMIME_IsIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_IsUIMessageA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HWND hWndIME,
    /* [in] */ UINT msg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB IActiveIMMIME_IsUIMessageA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_IsUIMessageW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HWND hWndIME,
    /* [in] */ UINT msg,
    /* [in] */ WPARAM wParam,
    /* [in] */ LPARAM lParam);


void __RPC_STUB IActiveIMMIME_IsUIMessageW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_NotifyIME_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwAction,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwValue);


void __RPC_STUB IActiveIMMIME_NotifyIME_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_RegisterWordA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPSTR szRegister);


void __RPC_STUB IActiveIMMIME_RegisterWordA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_RegisterWordW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szRegister);


void __RPC_STUB IActiveIMMIME_RegisterWordW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_ReleaseContext_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [in] */ HIMC hIMC);


void __RPC_STUB IActiveIMMIME_ReleaseContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetCandidateWindow_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ CANDIDATEFORM __RPC_FAR *pCandidate);


void __RPC_STUB IActiveIMMIME_SetCandidateWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetCompositionFontA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ LOGFONTA __RPC_FAR *plf);


void __RPC_STUB IActiveIMMIME_SetCompositionFontA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetCompositionFontW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ LOGFONTW __RPC_FAR *plf);


void __RPC_STUB IActiveIMMIME_SetCompositionFontW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetCompositionStringA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ LPVOID pComp,
    /* [in] */ DWORD dwCompLen,
    /* [in] */ LPVOID pRead,
    /* [in] */ DWORD dwReadLen);


void __RPC_STUB IActiveIMMIME_SetCompositionStringA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetCompositionStringW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ LPVOID pComp,
    /* [in] */ DWORD dwCompLen,
    /* [in] */ LPVOID pRead,
    /* [in] */ DWORD dwReadLen);


void __RPC_STUB IActiveIMMIME_SetCompositionStringW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetCompositionWindow_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ COMPOSITIONFORM __RPC_FAR *pCompForm);


void __RPC_STUB IActiveIMMIME_SetCompositionWindow_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetConversionStatus_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD fdwConversion,
    /* [in] */ DWORD fdwSentence);


void __RPC_STUB IActiveIMMIME_SetConversionStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetOpenStatus_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ BOOL fOpen);


void __RPC_STUB IActiveIMMIME_SetOpenStatus_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetStatusWindowPos_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ POINT __RPC_FAR *pptPos);


void __RPC_STUB IActiveIMMIME_SetStatusWindowPos_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SimulateHotKey_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwHotKeyID);


void __RPC_STUB IActiveIMMIME_SimulateHotKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_UnregisterWordA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPSTR szUnregister);


void __RPC_STUB IActiveIMMIME_UnregisterWordA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_UnregisterWordW_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szUnregister);


void __RPC_STUB IActiveIMMIME_UnregisterWordW_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GenerateMessage_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC);


void __RPC_STUB IActiveIMMIME_GenerateMessage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_LockIMC_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ INPUTCONTEXT __RPC_FAR *__RPC_FAR *ppIMC);


void __RPC_STUB IActiveIMMIME_LockIMC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_UnlockIMC_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC);


void __RPC_STUB IActiveIMMIME_UnlockIMC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetIMCLockCount_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD __RPC_FAR *pdwLockCount);


void __RPC_STUB IActiveIMMIME_GetIMCLockCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_CreateIMCC_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ DWORD dwSize,
    /* [out] */ HIMCC __RPC_FAR *phIMCC);


void __RPC_STUB IActiveIMMIME_CreateIMCC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_DestroyIMCC_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMCC hIMCC);


void __RPC_STUB IActiveIMMIME_DestroyIMCC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_LockIMCC_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMCC hIMCC,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppv);


void __RPC_STUB IActiveIMMIME_LockIMCC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_UnlockIMCC_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMCC hIMCC);


void __RPC_STUB IActiveIMMIME_UnlockIMCC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_ReSizeIMCC_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMCC hIMCC,
    /* [in] */ DWORD dwSize,
    /* [out] */ HIMCC __RPC_FAR *phIMCC);


void __RPC_STUB IActiveIMMIME_ReSizeIMCC_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetIMCCSize_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMCC hIMCC,
    /* [out] */ DWORD __RPC_FAR *pdwSize);


void __RPC_STUB IActiveIMMIME_GetIMCCSize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetIMCCLockCount_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HIMCC hIMCC,
    /* [out] */ DWORD __RPC_FAR *pdwLockCount);


void __RPC_STUB IActiveIMMIME_GetIMCCLockCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetHotKey_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ DWORD dwHotKeyID,
    /* [out] */ UINT __RPC_FAR *puModifiers,
    /* [out] */ UINT __RPC_FAR *puVKey,
    /* [out] */ HKL __RPC_FAR *phKL);


void __RPC_STUB IActiveIMMIME_GetHotKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_SetHotKey_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ DWORD dwHotKeyID,
    /* [in] */ UINT uModifiers,
    /* [in] */ UINT uVKey,
    /* [in] */ HKL hKL);


void __RPC_STUB IActiveIMMIME_SetHotKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_CreateSoftKeyboard_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ UINT uType,
    /* [in] */ HWND hOwner,
    /* [in] */ int x,
    /* [in] */ int y,
    /* [out] */ HWND __RPC_FAR *phSoftKbdWnd);


void __RPC_STUB IActiveIMMIME_CreateSoftKeyboard_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_DestroySoftKeyboard_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HWND hSoftKbdWnd);


void __RPC_STUB IActiveIMMIME_DestroySoftKeyboard_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_ShowSoftKeyboard_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HWND hSoftKbdWnd,
    /* [in] */ int nCmdShow);


void __RPC_STUB IActiveIMMIME_ShowSoftKeyboard_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetCodePageA_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [out] */ UINT __RPC_FAR *uCodePage);


void __RPC_STUB IActiveIMMIME_GetCodePageA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_GetLangId_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [out] */ LANGID __RPC_FAR *plid);


void __RPC_STUB IActiveIMMIME_GetLangId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_KeybdEvent_Proxy( 
    IActiveIMMIME __RPC_FAR * This,
    /* [in] */ LANGID lgidIME,
    /* [in] */ BYTE bVk,
    /* [in] */ BYTE bScan,
    /* [in] */ DWORD dwFlags,
    /* [in] */ DWORD dwExtraInfo);


void __RPC_STUB IActiveIMMIME_KeybdEvent_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_LockModal_Proxy( 
    IActiveIMMIME __RPC_FAR * This);


void __RPC_STUB IActiveIMMIME_LockModal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIMMIME_UnlockModal_Proxy( 
    IActiveIMMIME __RPC_FAR * This);


void __RPC_STUB IActiveIMMIME_UnlockModal_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveIMMIME_INTERFACE_DEFINED__ */


#ifndef __IActiveIME_INTERFACE_DEFINED__
#define __IActiveIME_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IActiveIME
 * at Tue Jan 13 08:56:29 1998
 * using MIDL 3.01.75
 ****************************************/
/* [unique][uuid][object] */ 



EXTERN_C const IID IID_IActiveIME;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    interface DECLSPEC_UUID("6FE20962-D077-11d0-8FE7-00AA006BCC59")
    IActiveIME : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Inquire( 
            /* [in] */ DWORD dwSystemInfoFlags,
            /* [out] */ IMEINFO __RPC_FAR *pIMEInfo,
            /* [out] */ LPWSTR szWndClass,
            /* [out] */ DWORD __RPC_FAR *pdwPrivate) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ConversionList( 
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR szSource,
            /* [in] */ UINT uFlag,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ CANDIDATELIST __RPC_FAR *pDest) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Configure( 
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW __RPC_FAR *pRegisterWord) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Destroy( 
            /* [in] */ UINT uReserved) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Escape( 
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ void __RPC_FAR *pData,
            /* [out] */ LRESULT __RPC_FAR *plResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetActiveContext( 
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fFlag) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ProcessKey( 
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uVirKey,
            /* [in] */ DWORD lParam,
            /* [in] */ BYTE __RPC_FAR *pbKeyState) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Select( 
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fSelect) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetCompositionString( 
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ void __RPC_FAR *pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ void __RPC_FAR *pRead,
            /* [in] */ DWORD dwReadLen) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ToAsciiEx( 
            /* [in] */ UINT uVirKey,
            /* [in] */ UINT uScanCode,
            /* [in] */ BYTE __RPC_FAR *pbKeyState,
            /* [in] */ UINT fuState,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pdwTransBuf,
            /* [out] */ UINT __RPC_FAR *puSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE RegisterWord( 
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE UnregisterWord( 
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szString) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetRegisterWordStyle( 
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW __RPC_FAR *pStyleBuf,
            /* [out] */ UINT __RPC_FAR *puBufSize) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EnumRegisterWord( 
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW __RPC_FAR *__RPC_FAR *ppEnum) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetCodePageA( 
            /* [out] */ UINT __RPC_FAR *uCodePage) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetLangId( 
            /* [out] */ LANGID __RPC_FAR *plid) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IActiveIMEVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IActiveIME __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IActiveIME __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Inquire )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ DWORD dwSystemInfoFlags,
            /* [out] */ IMEINFO __RPC_FAR *pIMEInfo,
            /* [out] */ LPWSTR szWndClass,
            /* [out] */ DWORD __RPC_FAR *pdwPrivate);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ConversionList )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ LPWSTR szSource,
            /* [in] */ UINT uFlag,
            /* [in] */ DWORD dwBufLen,
            /* [out] */ CANDIDATELIST __RPC_FAR *pDest);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Configure )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ HKL hKL,
            /* [in] */ HWND hWnd,
            /* [in] */ DWORD dwMode,
            /* [in] */ REGISTERWORDW __RPC_FAR *pRegisterWord);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Destroy )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ UINT uReserved);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Escape )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uEscape,
            /* [out][in] */ void __RPC_FAR *pData,
            /* [out] */ LRESULT __RPC_FAR *plResult);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetActiveContext )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fFlag);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ProcessKey )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ UINT uVirKey,
            /* [in] */ DWORD lParam,
            /* [in] */ BYTE __RPC_FAR *pbKeyState);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Notify )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwAction,
            /* [in] */ DWORD dwIndex,
            /* [in] */ DWORD dwValue);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Select )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ BOOL fSelect);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SetCompositionString )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ HIMC hIMC,
            /* [in] */ DWORD dwIndex,
            /* [in] */ void __RPC_FAR *pComp,
            /* [in] */ DWORD dwCompLen,
            /* [in] */ void __RPC_FAR *pRead,
            /* [in] */ DWORD dwReadLen);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *ToAsciiEx )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ UINT uVirKey,
            /* [in] */ UINT uScanCode,
            /* [in] */ BYTE __RPC_FAR *pbKeyState,
            /* [in] */ UINT fuState,
            /* [in] */ HIMC hIMC,
            /* [out] */ DWORD __RPC_FAR *pdwTransBuf,
            /* [out] */ UINT __RPC_FAR *puSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RegisterWord )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szString);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnregisterWord )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szString);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetRegisterWordStyle )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ UINT nItem,
            /* [out] */ STYLEBUFW __RPC_FAR *pStyleBuf,
            /* [out] */ UINT __RPC_FAR *puBufSize);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EnumRegisterWord )( 
            IActiveIME __RPC_FAR * This,
            /* [in] */ LPWSTR szReading,
            /* [in] */ DWORD dwStyle,
            /* [in] */ LPWSTR szRegister,
            /* [in] */ LPVOID pData,
            /* [out] */ IEnumRegisterWordW __RPC_FAR *__RPC_FAR *ppEnum);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCodePageA )( 
            IActiveIME __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *uCodePage);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetLangId )( 
            IActiveIME __RPC_FAR * This,
            /* [out] */ LANGID __RPC_FAR *plid);
        
        END_INTERFACE
    } IActiveIMEVtbl;

    interface IActiveIME
    {
        CONST_VTBL struct IActiveIMEVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IActiveIME_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IActiveIME_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IActiveIME_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IActiveIME_Inquire(This,dwSystemInfoFlags,pIMEInfo,szWndClass,pdwPrivate)	\
    (This)->lpVtbl -> Inquire(This,dwSystemInfoFlags,pIMEInfo,szWndClass,pdwPrivate)

#define IActiveIME_ConversionList(This,hIMC,szSource,uFlag,dwBufLen,pDest)	\
    (This)->lpVtbl -> ConversionList(This,hIMC,szSource,uFlag,dwBufLen,pDest)

#define IActiveIME_Configure(This,hKL,hWnd,dwMode,pRegisterWord)	\
    (This)->lpVtbl -> Configure(This,hKL,hWnd,dwMode,pRegisterWord)

#define IActiveIME_Destroy(This,uReserved)	\
    (This)->lpVtbl -> Destroy(This,uReserved)

#define IActiveIME_Escape(This,hIMC,uEscape,pData,plResult)	\
    (This)->lpVtbl -> Escape(This,hIMC,uEscape,pData,plResult)

#define IActiveIME_SetActiveContext(This,hIMC,fFlag)	\
    (This)->lpVtbl -> SetActiveContext(This,hIMC,fFlag)

#define IActiveIME_ProcessKey(This,hIMC,uVirKey,lParam,pbKeyState)	\
    (This)->lpVtbl -> ProcessKey(This,hIMC,uVirKey,lParam,pbKeyState)

#define IActiveIME_Notify(This,hIMC,dwAction,dwIndex,dwValue)	\
    (This)->lpVtbl -> Notify(This,hIMC,dwAction,dwIndex,dwValue)

#define IActiveIME_Select(This,hIMC,fSelect)	\
    (This)->lpVtbl -> Select(This,hIMC,fSelect)

#define IActiveIME_SetCompositionString(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)	\
    (This)->lpVtbl -> SetCompositionString(This,hIMC,dwIndex,pComp,dwCompLen,pRead,dwReadLen)

#define IActiveIME_ToAsciiEx(This,uVirKey,uScanCode,pbKeyState,fuState,hIMC,pdwTransBuf,puSize)	\
    (This)->lpVtbl -> ToAsciiEx(This,uVirKey,uScanCode,pbKeyState,fuState,hIMC,pdwTransBuf,puSize)

#define IActiveIME_RegisterWord(This,szReading,dwStyle,szString)	\
    (This)->lpVtbl -> RegisterWord(This,szReading,dwStyle,szString)

#define IActiveIME_UnregisterWord(This,szReading,dwStyle,szString)	\
    (This)->lpVtbl -> UnregisterWord(This,szReading,dwStyle,szString)

#define IActiveIME_GetRegisterWordStyle(This,nItem,pStyleBuf,puBufSize)	\
    (This)->lpVtbl -> GetRegisterWordStyle(This,nItem,pStyleBuf,puBufSize)

#define IActiveIME_EnumRegisterWord(This,szReading,dwStyle,szRegister,pData,ppEnum)	\
    (This)->lpVtbl -> EnumRegisterWord(This,szReading,dwStyle,szRegister,pData,ppEnum)

#define IActiveIME_GetCodePageA(This,uCodePage)	\
    (This)->lpVtbl -> GetCodePageA(This,uCodePage)

#define IActiveIME_GetLangId(This,plid)	\
    (This)->lpVtbl -> GetLangId(This,plid)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IActiveIME_Inquire_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [in] */ DWORD dwSystemInfoFlags,
    /* [out] */ IMEINFO __RPC_FAR *pIMEInfo,
    /* [out] */ LPWSTR szWndClass,
    /* [out] */ DWORD __RPC_FAR *pdwPrivate);


void __RPC_STUB IActiveIME_Inquire_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_ConversionList_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ LPWSTR szSource,
    /* [in] */ UINT uFlag,
    /* [in] */ DWORD dwBufLen,
    /* [out] */ CANDIDATELIST __RPC_FAR *pDest);


void __RPC_STUB IActiveIME_ConversionList_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_Configure_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [in] */ HKL hKL,
    /* [in] */ HWND hWnd,
    /* [in] */ DWORD dwMode,
    /* [in] */ REGISTERWORDW __RPC_FAR *pRegisterWord);


void __RPC_STUB IActiveIME_Configure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_Destroy_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [in] */ UINT uReserved);


void __RPC_STUB IActiveIME_Destroy_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_Escape_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ UINT uEscape,
    /* [out][in] */ void __RPC_FAR *pData,
    /* [out] */ LRESULT __RPC_FAR *plResult);


void __RPC_STUB IActiveIME_Escape_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_SetActiveContext_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ BOOL fFlag);


void __RPC_STUB IActiveIME_SetActiveContext_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_ProcessKey_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ UINT uVirKey,
    /* [in] */ DWORD lParam,
    /* [in] */ BYTE __RPC_FAR *pbKeyState);


void __RPC_STUB IActiveIME_ProcessKey_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_Notify_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwAction,
    /* [in] */ DWORD dwIndex,
    /* [in] */ DWORD dwValue);


void __RPC_STUB IActiveIME_Notify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_Select_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ BOOL fSelect);


void __RPC_STUB IActiveIME_Select_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_SetCompositionString_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [in] */ HIMC hIMC,
    /* [in] */ DWORD dwIndex,
    /* [in] */ void __RPC_FAR *pComp,
    /* [in] */ DWORD dwCompLen,
    /* [in] */ void __RPC_FAR *pRead,
    /* [in] */ DWORD dwReadLen);


void __RPC_STUB IActiveIME_SetCompositionString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_ToAsciiEx_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [in] */ UINT uVirKey,
    /* [in] */ UINT uScanCode,
    /* [in] */ BYTE __RPC_FAR *pbKeyState,
    /* [in] */ UINT fuState,
    /* [in] */ HIMC hIMC,
    /* [out] */ DWORD __RPC_FAR *pdwTransBuf,
    /* [out] */ UINT __RPC_FAR *puSize);


void __RPC_STUB IActiveIME_ToAsciiEx_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_RegisterWord_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szString);


void __RPC_STUB IActiveIME_RegisterWord_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_UnregisterWord_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szString);


void __RPC_STUB IActiveIME_UnregisterWord_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_GetRegisterWordStyle_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [in] */ UINT nItem,
    /* [out] */ STYLEBUFW __RPC_FAR *pStyleBuf,
    /* [out] */ UINT __RPC_FAR *puBufSize);


void __RPC_STUB IActiveIME_GetRegisterWordStyle_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_EnumRegisterWord_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [in] */ LPWSTR szReading,
    /* [in] */ DWORD dwStyle,
    /* [in] */ LPWSTR szRegister,
    /* [in] */ LPVOID pData,
    /* [out] */ IEnumRegisterWordW __RPC_FAR *__RPC_FAR *ppEnum);


void __RPC_STUB IActiveIME_EnumRegisterWord_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_GetCodePageA_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [out] */ UINT __RPC_FAR *uCodePage);


void __RPC_STUB IActiveIME_GetCodePageA_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IActiveIME_GetLangId_Proxy( 
    IActiveIME __RPC_FAR * This,
    /* [out] */ LANGID __RPC_FAR *plid);


void __RPC_STUB IActiveIME_GetLangId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IActiveIME_INTERFACE_DEFINED__ */


#ifdef __cplusplus
EXTERN_C const CLSID CLSID_CActiveIMM;

class DECLSPEC_UUID("4955DD33-B159-11d0-8FCF-00AA006BCC59")
CActiveIMM;
#endif
#endif /* __ActiveIMM_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\clasifyc.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module clasifyc.cpp -- Kinsoku classify characters |
 *	
 *		Used in word breaking procs, particularly important
 *		for properly wrapping a line.
 *	
 *	Authors: <nl>
 *		Jon Matousek
 *
 *	Copyright (c) 1995-1998 Microsoft Corporation. All rights reserved.
 */								

#include "_common.h"
#include "_clasfyc.h"
#include "_array.h"

ASSERTDATA

// Data for Kinsoku character classifications.
// NOTE: All values are for UNICODE characters.

// "dumb" quotes and other characters with no left/right orientation.
// This is a hack-around the Kinsoku rules, these are treated
// like an opening paren, when leading and kind of like a closing
// paren when follow--but will only break on white space in former case.
#define	brkclsQuote	0
#define C3_FullWidth	(C3_KATAKANA | C3_HIRAGANA | C3_IDEOGRAPH | C3_FULLWIDTH)

const WCHAR set0[] = {
	0x0022,	// QUOTATION MARK
	0x0027, // APOSTROPHE
	0x2019, // RIGHT SINGLE QUOTATION MARK
	0x301F,	// LOW DOUBLE PRIME QUOTATION MARK
	0xFF02,	// FULLWIDTH QUOTATION MARK
	0xFF07,	// FULLWIDTH APOSTROPHE
	0
};

// Opening-parenthesis character
#define	brkclsOpen	1

const WCHAR set1[] = {
	0x0028, // LEFT PARENTHESIS
	0x003C,	// LEFT ANGLE BRACKET
	0x005B, // LEFT SQUARE BRACKET
	0x007B, // LEFT CURLY BRACKET
	0x00AB, // LEFT-POINTING DOUBLE ANGLE QUOTATION MARK
	0x2018, // LEFT SINGLE QUOTATION MARK
	0x201C, // LEFT DOUBLE QUOTATION MARK
	0x2039, // SINGLE LEFT-POINTING ANGLE QUOTATION MARK
	0x2045, // LEFT SQUARE BRACKET WITH QUILL
	0x207D, // SUPERSCRIPT LEFT PARENTHESIS
	0x208D, // SUBSCRIPT LEFT PARENTHESIS
	0x3008, // LEFT ANGLE BRACKET
	0x300A, // LEFT DOUBLE ANGLE BRACKET
	0x300C, // LEFT CORNER BRACKET
	0x300E, // LEFT WHITE CORNER BRACKET
	0x3010, // LEFT BLACK LENTICULAR BRACKET
	0x3014, // LEFT TORTOISE SHELL BRACKET
	0x3016, // LEFT WHITE LENTICULAR BRACKET
	0x3018, // LEFT WHITE TORTOISE SHELL BRACKET
	0x301A, // LEFT WHITE SQUARE BRACKET
	0x301D, // REVERSED DOUBLE PRIME QUOTATION MARK
	0xFD3E, // ORNATE LEFT PARENTHESIS
	0xFE59, // SMALL LEFT PARENTHESIS
	0xFE5B, // SMALL LEFT CURLY BRACKET
	0xFE5D, // SMALL LEFT TORTOISE SHELL BRACKET
	0xFF08, // FULLWIDTH LEFT PARENTHESIS
	0xFF3B, // FULLWIDTH LEFT SQUARE BRACKET
	0xFF5B, // FULLWIDTH LEFT CURLY BRACKET
	0xFF62, // HALFWIDTH LEFT CORNER BRACKET
	0xFFE9, // HALFWIDTH LEFTWARDS ARROW
	0
};

// Closing-parenthesis character
#define	brkclsClose	2

const WCHAR set2[] = {
	// 0x002C, // COMMA	moved to set 6 to conjoin numerals.
	0x002D,	// HYPHEN
	0x00AD,	// OPTIONAL HYPHEN
	0x055D, // ARMENIAN COMMA
	0x060C, // ARABIC COMMA
	0x3001, // IDEOGRAPHIC COMMA
	0xFE50, // SMALL COMMA
	0xFE51, // SMALL IDEOGRAPHIC COMMA
	0xFF0C, // FULLWIDTH COMMA
	0xFF64, // HALFWIDTH IDEOGRAPHIC COMMA

	0x0029, // RIGHT PARENTHESIS
	0x003E,	// RIGHT ANGLE BRACKET
	0x005D, // RIGHT SQUARE BRACKET
	0x007D, // RIGHT CURLY BRACKET
	0x00BB, // RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK
	//0x2019, // RIGHT SINGLE QUOTATION MARK moved to set 0
	0x201D, // RIGHT DOUBLE QUOTATION MARK
	0x203A, // SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
	0x2046, // RIGHT SQUARE BRACKET WITH QUILL
	0x207E, // SUPERSCRIPT RIGHT PARENTHESIS
	0x208E, // SUBSCRIPT RIGHT PARENTHESIS
	0x3009, // RIGHT ANGLE BRACKET
	0x300B, // RIGHT DOUBLE ANGLE BRACKET
	0x300D, // RIGHT CORNER BRACKET
	0x300F, // RIGHT WHITE CORNER BRACKET
	0x3011, // RIGHT BLACK LENTICULAR BRACKET
	0x3015, // RIGHT TORTOISE SHELL BRACKET
	0x3017, // RIGHT WHITE LENTICULAR BRACKET
	0x3019, // RIGHT WHITE TORTOISE SHELL BRACKET
	0x301B, // RIGHT WHITE SQUARE BRACKET
	0x301E, // DOUBLE PRIME QUOTATION MARK
	0xFD3F, // ORNATE RIGHT PARENTHESIS
	0xFE5A, // SMALL RIGHT PARENTHESIS
	0xFE5C, // SMALL RIGHT CURLY BRACKET
	0xFE5E, // SMALL RIGHT TORTOISE SHELL BRACKET
	0xFF09, // FULLWIDTH RIGHT PARENTHESIS
	0xFF3D, // FULLWIDTH RIGHT SQUARE BRACKET
	0xFF5D, // FULLWIDTH RIGHT CURLY BRACKET
	0xFF63, // HALFWIDTH RIGHT CORNER BRACKET
	0xFFEB, // HALFWIDTH RIGHTWARDS ARROW
	0
};

// 'Non-breaking' em-character at line-starting point
#define	brkclsGlueA	3

const WCHAR set3[] = {
	0x3005, // IDEOGRAPHIC ITERATION MARK
	0x309D, // HIRAGANA ITERATION MARK
	0x309E, // HIRAGANA VOICED ITERATION MARK
	0x30FC, // KATAKANA-HIRAGANA PROLONGED SOUND MARK
	0x30FD, // KATAKANA ITERATION MARK
	0x30FE, // KATAKANA VOICED ITERATION MARK
	0x3041, // HIRAGANA LETTER SMALL A
	0x3043, // HIRAGANA LETTER SMALL I
	0x3045, // HIRAGANA LETTER SMALL U
	0x3047, // HIRAGANA LETTER SMALL E
	0x3049, // HIRAGANA LETTER SMALL O
	0x3063, // HIRAGANA LETTER SMALL TU
	0x3083, // HIRAGANA LETTER SMALL YA
	0x3085, // HIRAGANA LETTER SMALL YU
	0x3087, // HIRAGANA LETTER SMALL YO
	0x308E, // HIRAGANA LETTER SMALL WA
	0x309B,	// KATAKANA-HIRAGANA VOICED SOUND MARK
	0x309C,	// KATAKANA-HIRAGANA SEMI-VOICED SOUND MARK
	0x30A1, // KATAKANA LETTER SMALL A
	0x30A3, // KATAKANA LETTER SMALL I
	0x30A5, // KATAKANA LETTER SMALL U
	0x30A7, // KATAKANA LETTER SMALL E
	0x30A9, // KATAKANA LETTER SMALL O
	0x30C3, // KATAKANA LETTER SMALL TU
	0x30E3, // KATAKANA LETTER SMALL YA
	0x30E5, // KATAKANA LETTER SMALL YU
	0x30E7, // KATAKANA LETTER SMALL YO
	0x30EE, // KATAKANA LETTER SMALL WA
	0x30F5, // KATAKANA LETTER SMALL KA
	0x30F6, // KATAKANA LETTER SMALL KE
	0xFF67, // HALFWIDTH KATAKANA LETTER SMALL A
	0xFF68, // HALFWIDTH KATAKANA LETTER SMALL I
	0xFF69, // HALFWIDTH KATAKANA LETTER SMALL U
	0xFF6A, // HALFWIDTH KATAKANA LETTER SMALL E
	0xFF6B, // HALFWIDTH KATAKANA LETTER SMALL O
	0xFF6C, // HALFWIDTH KATAKANA LETTER SMALL YA
	0xFF6D, // HALFWIDTH KATAKANA LETTER SMALL YU
	0xFF6E, // HALFWIDTH KATAKANA LETTER SMALL YO
	0xFF6F, // HALFWIDTH KATAKANA LETTER SMALL TU
	0xFF70, // HALFWIDTH KATAKANA-HIRAGANA PROLONGED SOUND MARK
	0xFF9E,	// HALFWIDTH KATAKANA VOICED SOUND MARK
	0xFF9F,	// HALFWIDTH KATAKANA SEMI-VOICED SOUND MARK
	0
};

// Expression mark
#define	brkclsExclaInterr	4

const WCHAR set4[] = {
	0x0021, // EXCLAMATION MARK
	0x003F, // QUESTION MARK
	0x00A1, // INVERTED EXCLAMATION MARK
	0x00BF, // INVERTED QUESTION MARK
	0x01C3, // LATIN LETTER RETROFLEX CLICK
	0x037E, // GREEK QUESTION MARK
	0x055C, // ARMENIAN EXCLAMATION MARK
	0x055E, // ARMENIAN QUESTION MARK
	0x055F, // ARMENIAN ABBREVIATION MARK
	0x061F, // ARABIC QUESTION MARK
	0x203C, // DOUBLE EXCLAMATION MARK
	0x203D, // INTERROBANG
	0x2762, // HEAVY EXCLAMATION MARK ORNAMENT
	0x2763, // HEAVY HEART EXCLAMATION MARK ORNAMENT
	0xFE56, // SMALL QUESTION MARK
	0xFE57, // SMALL EXCLAMATION MARK
	0xFF01, // FULLWIDTH EXCLAMATION MARK
	0xFF1F, // FULLWIDTH QUESTION MARK
	0
};

// Centered punctuation mark

const WCHAR set5[] = {		
//	0x003A,	// COLON		moved to set 6 to conjoin numerals.
//	0x003B, // SEMICOLON	moved to set 6 to conjoin numerals
	0x00B7, // MIDDLE DOT
	0x30FB, // KATAKANA MIDDLE DOT
	0xFF65, // HALFWIDTH KATAKANA MIDDLE DOT
	0x061B, // ARABIC SEMICOLON
	0xFE54, // SMALL SEMICOLON
	0xFE55, // SMALL COLON
	0xFF1A, // FULLWIDTH COLON
	0xFF1B, // FULLWIDTH SEMICOLON
	0
};

// Punctuation mark		// diverged from the Kinsoku tables to enhance
#define	brkclsSlash	6

const WCHAR set6[] = {	// How colon, comma, and full stop are treated around
	0x002C, // COMMA	//  numerals and set 15 (roman text).
	0x002f,	// SLASH	// But don't break up URLs (see IsURLDelimiter())!
	0x003A, // COLON
	0x003B, // SEMICOLON

	0x002E, // FULL STOP (PERIOD)
	0x0589, // ARMENIAN FULL STOP
	0x06D4, // ARABIC FULL STOP
	0x3002, // IDEOGRAPHIC FULL STOP
	0xFE52, // SMALL FULL STOP
	0xFF0E, // FULLWIDTH FULL STOP
	0xFF61, // HALFWIDTH IDEOGRAPHIC FULL STOP
	0
};

// Inseparable character
#define	brkclsInseparable	7

const WCHAR set7[] = {
	0		// FUTURE (alexgo): maybe handle these.
};

// Pre-numeral abbreviation
#define	brkclsPrefix	8

const WCHAR set8[] = {
	0x0024, // DOLLAR SIGN
	0x00A3, // POUND SIGN
	0x00A4, // CURRENCY SIGN
	0x00A5, // YEN SIGN
	0x005C, // REVERSE SOLIDUS (looks like Yen in FE fonts.)
	0x0E3F, // THAI CURRENCY SYMBOL BAHT
	0x20AC, // EURO-CURRENCY SIGN
	0x20A1, // COLON SIGN
	0x20A2, // CRUZEIRO SIGN
	0x20A3, // FRENCH FRANC SIGN
	0x20A4, // LIRA SIGN
	0x20A5, // MILL SIGN
	0x20A6, // NAIRA SIGN
	0x20A7, // PESETA SIGN
	0x20A8, // RUPEE SIGN
	0x20A9, // WON SIGN
	0x20AA, // NEW SHEQEL SIGN

	0xFF04, // FULLWIDTH DOLLAR SIGN
	0xFFE5,	// FULLWIDTH YEN SIGN
	0xFFE6,	// FULLWIDTH WON SIGN

	0xFFE1,	// FULLWIDTH POUND SIGN
	0
};

// Post-numeral abbreviation
#define	brkclsPostfix	9

const WCHAR set9[] = {
	0x00A2, // CENT SIGN
	0x00B0, // DEGREE SIGN
	0x2103, // DEGREE CELSIUS
	0x2109, // DEGREE FAHRENHEIT
	0x212A, // KELVIN SIGN
	0x0025, // PERCENT SIGN
	0x066A, // ARABIC PERCENT SIGN
	0xFE6A, // SMALL PERCENT SIGN
	0xFF05, // FULLWIDTH PERCENT SIGN
	0x2030, // PER MILLE SIGN
	0x2031, // PER TEN THOUSAND SIGN
	0x2032, // PRIME
	0x2033, // DOUBLE PRIME
	0x2034, // TRIPLE PRIME
	0x2035, // REVERSED PRIME
	0x2036, // REVERSED DOUBLE PRIME
	0x2037,	// REVERSED TRIPLE PRIME

	0xFF05,	// FULLWIDTH PERCENT SIGN
	0xFFE0,	// FULLWIDTH CENT SIGN
	0
};

// Japanese space (blank) character
#define	brkclsNoStartIdeo	10

const WCHAR set10[] = {
	0x3000,  // IDEOGRAPHIC SPACE
	0
};

// Japanese characters other than above
#define	brkclsIdeographic	11

const WCHAR set11[] = {
	0		//we use GetStringTypeEx
};

// Characters included in numeral-sequence
#define	brkclsNumeral	12

const WCHAR set12[] = {
	0x0030, // DIGIT ZERO
	0x0031, // DIGIT ONE
	0x0032, // DIGIT TWO
	0x0033, // DIGIT THREE
	0x0034, // DIGIT FOUR
	0x0035, // DIGIT FIVE
	0x0036, // DIGIT SIX
	0x0037, // DIGIT SEVEN
	0x0038, // DIGIT EIGHT
	0x0039, // DIGIT NINE
	0x0660, // ARABIC-INDIC DIGIT ZERO
	0x0661, // ARABIC-INDIC DIGIT ONE
	0x0662, // ARABIC-INDIC DIGIT TWO
	0x0663, // ARABIC-INDIC DIGIT THREE
	0x0664, // ARABIC-INDIC DIGIT FOUR
	0x0665, // ARABIC-INDIC DIGIT FIVE
	0x0666, // ARABIC-INDIC DIGIT SIX
	0x0667, // ARABIC-INDIC DIGIT SEVEN
	0x0668, // ARABIC-INDIC DIGIT EIGHT
	0x0669, // ARABIC-INDIC DIGIT NINE
	0x06F0, // EXTENDED ARABIC-INDIC DIGIT ZERO
	0x06F1, // EXTENDED ARABIC-INDIC DIGIT ONE
	0x06F2, // EXTENDED ARABIC-INDIC DIGIT TWO
	0x06F3, // EXTENDED ARABIC-INDIC DIGIT THREE
	0x06F4, // EXTENDED ARABIC-INDIC DIGIT FOUR
	0x06F5, // EXTENDED ARABIC-INDIC DIGIT FIVE
	0x06F6, // EXTENDED ARABIC-INDIC DIGIT SIX
	0x06F7, // EXTENDED ARABIC-INDIC DIGIT SEVEN
	0x06F8, // EXTENDED ARABIC-INDIC DIGIT EIGHT
	0x06F9, // EXTENDED ARABIC-INDIC DIGIT NINE
	0x0966, // DEVANAGARI DIGIT ZERO
	0x0967, // DEVANAGARI DIGIT ONE
	0x0968, // DEVANAGARI DIGIT TWO
	0x0969, // DEVANAGARI DIGIT THREE
	0x096A, // DEVANAGARI DIGIT FOUR
	0x096B, // DEVANAGARI DIGIT FIVE
	0x096C, // DEVANAGARI DIGIT SIX
	0x096D, // DEVANAGARI DIGIT SEVEN
	0x096E, // DEVANAGARI DIGIT EIGHT
	0x096F, // DEVANAGARI DIGIT NINE
	0x09E6, // BENGALI DIGIT ZERO
	0x09E7, // BENGALI DIGIT ONE
	0x09E8, // BENGALI DIGIT TWO
	0x09E9, // BENGALI DIGIT THREE
	0x09EA, // BENGALI DIGIT FOUR
	0x09EB, // BENGALI DIGIT FIVE
	0x09EC, // BENGALI DIGIT SIX
	0x09ED, // BENGALI DIGIT SEVEN
	0x09EE, // BENGALI DIGIT EIGHT
	0x09EF, // BENGALI DIGIT NINE
	0x0A66, // GURMUKHI DIGIT ZERO
	0x0A67, // GURMUKHI DIGIT ONE
	0x0A68, // GURMUKHI DIGIT TWO
	0x0A69, // GURMUKHI DIGIT THREE
	0x0A6A, // GURMUKHI DIGIT FOUR
	0x0A6B, // GURMUKHI DIGIT FIVE
	0x0A6C, // GURMUKHI DIGIT SIX
	0x0A6D, // GURMUKHI DIGIT SEVEN
	0x0A6E, // GURMUKHI DIGIT EIGHT
	0x0A6F, // GURMUKHI DIGIT NINE
	0x0AE6, // GUJARATI DIGIT ZERO
	0x0AE7, // GUJARATI DIGIT ONE
	0x0AE8, // GUJARATI DIGIT TWO
	0x0AE9, // GUJARATI DIGIT THREE
	0x0AEA, // GUJARATI DIGIT FOUR
	0x0AEB, // GUJARATI DIGIT FIVE
	0x0AEC, // GUJARATI DIGIT SIX
	0x0AED, // GUJARATI DIGIT SEVEN
	0x0AEE, // GUJARATI DIGIT EIGHT
	0x0AEF, // GUJARATI DIGIT NINE
	0x0B66, // ORIYA DIGIT ZERO
	0x0B67, // ORIYA DIGIT ONE
	0x0B68, // ORIYA DIGIT TWO
	0x0B69, // ORIYA DIGIT THREE
	0x0B6A, // ORIYA DIGIT FOUR
	0x0B6B, // ORIYA DIGIT FIVE
	0x0B6C, // ORIYA DIGIT SIX
	0x0B6D, // ORIYA DIGIT SEVEN
	0x0B6E, // ORIYA DIGIT EIGHT
	0x0B6F, // ORIYA DIGIT NINE
	0x0BE7, // TAMIL DIGIT ONE
	0x0BE8, // TAMIL DIGIT TWO
	0x0BE9, // TAMIL DIGIT THREE
	0x0BEA, // TAMIL DIGIT FOUR
	0x0BEB, // TAMIL DIGIT FIVE
	0x0BEC, // TAMIL DIGIT SIX
	0x0BED, // TAMIL DIGIT SEVEN
	0x0BEE, // TAMIL DIGIT EIGHT
	0x0BEF, // TAMIL DIGIT NINE
	0x0BF0, // TAMIL NUMBER TEN
	0x0BF1, // TAMIL NUMBER ONE HUNDRED
	0x0BF2, // TAMIL NUMBER ONE THOUSAND
	0x0C66, // TELUGU DIGIT ZERO
	0x0C67, // TELUGU DIGIT ONE
	0x0C68, // TELUGU DIGIT TWO
	0x0C69, // TELUGU DIGIT THREE
	0x0C6A, // TELUGU DIGIT FOUR
	0x0C6B, // TELUGU DIGIT FIVE
	0x0C6C, // TELUGU DIGIT SIX
	0x0C6D, // TELUGU DIGIT SEVEN
	0x0C6E, // TELUGU DIGIT EIGHT
	0x0C6F, // TELUGU DIGIT NINE
	0x0CE6, // KANNADA DIGIT ZERO
	0x0CE7, // KANNADA DIGIT ONE
	0x0CE8, // KANNADA DIGIT TWO
	0x0CE9, // KANNADA DIGIT THREE
	0x0CEA, // KANNADA DIGIT FOUR
	0x0CEB, // KANNADA DIGIT FIVE
	0x0CEC, // KANNADA DIGIT SIX
	0x0CED, // KANNADA DIGIT SEVEN
	0x0CEE, // KANNADA DIGIT EIGHT
	0x0CEF, // KANNADA DIGIT NINE
	0x0D66, // MALAYALAM DIGIT ZERO
	0x0D67, // MALAYALAM DIGIT ONE
	0x0D68, // MALAYALAM DIGIT TWO
	0x0D69, // MALAYALAM DIGIT THREE
	0x0D6A, // MALAYALAM DIGIT FOUR
	0x0D6B, // MALAYALAM DIGIT FIVE
	0x0D6C, // MALAYALAM DIGIT SIX
	0x0D6D, // MALAYALAM DIGIT SEVEN
	0x0D6E, // MALAYALAM DIGIT EIGHT
	0x0D6F, // MALAYALAM DIGIT NINE
	0x0E50, // THAI DIGIT ZERO
	0x0E51, // THAI DIGIT ONE
	0x0E52, // THAI DIGIT TWO
	0x0E53, // THAI DIGIT THREE
	0x0E54, // THAI DIGIT FOUR
	0x0E55, // THAI DIGIT FIVE
	0x0E56, // THAI DIGIT SIX
	0x0E57, // THAI DIGIT SEVEN
	0x0E58, // THAI DIGIT EIGHT
	0x0E59, // THAI DIGIT NINE
	0x0ED0, // LAO DIGIT ZERO
	0x0ED1, // LAO DIGIT ONE
	0x0ED2, // LAO DIGIT TWO
	0x0ED3, // LAO DIGIT THREE
	0x0ED4, // LAO DIGIT FOUR
	0x0ED5, // LAO DIGIT FIVE
	0x0ED6, // LAO DIGIT SIX
	0x0ED7, // LAO DIGIT SEVEN
	0x0ED8, // LAO DIGIT EIGHT
	0x0ED9, // LAO DIGIT NINE
	0xFF10, // FULLWIDTH DIGIT ZERO
	0xFF11, // FULLWIDTH DIGIT ONE
	0xFF12, // FULLWIDTH DIGIT TWO
	0xFF13, // FULLWIDTH DIGIT THREE
	0xFF14, // FULLWIDTH DIGIT FOUR
	0xFF15, // FULLWIDTH DIGIT FIVE
	0xFF16, // FULLWIDTH DIGIT SIX
	0xFF17, // FULLWIDTH DIGIT SEVEN
	0xFF18, // FULLWIDTH DIGIT EIGHT
	0xFF19, // FULLWIDTH DIGIT NINE

	0x3007, // IDEOGRAPHIC NUMBER ZERO
	0x3021, // HANGZHOU NUMERAL ONE
	0x3022, // HANGZHOU NUMERAL TWO
	0x3023, // HANGZHOU NUMERAL THREE
	0x3024, // HANGZHOU NUMERAL FOUR
	0x3025, // HANGZHOU NUMERAL FIVE
	0x3026, // HANGZHOU NUMERAL SIX
	0x3027, // HANGZHOU NUMERAL SEVEN
	0x3028, // HANGZHOU NUMERAL EIGHT
	0x3029, // HANGZHOU NUMERAL NINE
	0
};

// Characters included in unit symbol group
const WCHAR set13[] = {
	0		//we use GetStringTypeEx
};

//Roman inter-word space
#define	brkclsSpaceN	14

const WCHAR set14[] = {
	0x0009,	// TAB
	0x0020, // SPACE
	0x2002, // EN SPACE
	0x2003, // EM SPACE
	0x2004, // THREE-PER-EM SPACE
	0x2005, // FOUR-PER-EM SPACE
	0x2006, // SIX-PER-EM SPACE
	0x2007, // FIGURE SPACE
	0x2008, // PUNCTUATION SPACE
	0x2009, // THIN SPACE
	0x200A, // HAIR SPACE
	0x200B,  // ZERO WIDTH SPACE
	WCH_EMBEDDING, // OBJECT EMBEDDING (0xFFFC)
	0
};

// Roman characters
#define	brkclsAlpha	15

const WCHAR set15[] = {
	0		//we use GetStringTypeEx
};

// So we can easily loop over all Kinsoku categories.
const WCHAR *charCategories[] = {
	set0,
	set1,
	set2,
	set3,
	set4,
	set5,
	set6,
	set7,
	set8,
	set9,
	set10,
	set11,
	set12,
	set13,
	set14,
	set15
};

static const INT classifyChunkSize = 64;
static const INT indexSize = 65536 / classifyChunkSize;
static const INT classifyBitMapSize = indexSize / 8;
static const INT bitmapShift = 6; // 16 - log(indexSize)/log(2)

typedef struct {
	CHAR classifications[classifyChunkSize];		// must be unsigned bytes!
} ClassifyChunk;

static ClassifyChunk *classifyData;					// Chunk array, sparse chrs
static BYTE *classifyIndex;							// Indexes into chunk array


/*
 *	BOOL InitKinsokuClassify()
 *
 *	@func
 *		Map the static character tables into a compact array for
 *		quick lookup of the characters Kinsoku classification.
 *
 *	@comm
 *		Kinsoku classification is necessary for word breaking and
 *		may be neccessary for proportional line layout, Kinsoku style.
 *
 *	@devnote
 *		We break the entire Unicode range in to chunks of characters.
 *		Not all of the chunks will have data in them. We do not
 *		maintain information on empty chunks, therefore we create
 *		a compact, contiguous array of chunks for only the chunks
 *		that do contain information. We prepend 1 empty chunk to the
 *		beginning of this array, where all of the empty chunks map to,
 *		this prevents a contiontional test on NULL data. The lookup
 *		will return 0 for any character not in the tables, so the client
 *		will then need to process the character further in such cases.
 *
 *	@rdesc
 *		return TRUE if we successfully created the lookup table.
 */
BOOL InitKinsokuClassify()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "InitKinsokuClassify");

	WORD	bitMapKey;								// For calcing total chunks
	BYTE	bitData;								// For calcing total chunks
	WCHAR	ch;
	LPCWSTR pWChar;								// Looping over char sets.
	INT		i, j, count;							// Loop support.
	BYTE	classifyBitMap[classifyBitMapSize],		// Temp bitmap.
			*pIndex;								// Index into chunk array.

	// See how many chunks we'll need. We loop over all of the special
	//  characters
	AssertSz(cKinsokuCategories == ARRAY_SIZE(charCategories),
		"InitKinsokuClassify: incorrect Kinsoku-category count");

	ZeroMemory(classifyBitMap, sizeof(classifyBitMap));
	for (i = 0; i < cKinsokuCategories; i++ )
	{
		pWChar = charCategories[i];
		while ( ch = *pWChar++ )
		{
			bitMapKey = ch >> bitmapShift;
			classifyBitMap[bitMapKey >> 3] |= 1 << (bitMapKey & 7);
		}
	}

	// Now that we know how many chunks we'll need, allocate the memory.
	count = 1 + CountMatchingBits((DWORD *)classifyBitMap, (DWORD *)classifyBitMap, sizeof(classifyBitMap)/sizeof(DWORD));
	classifyData = (ClassifyChunk *) PvAlloc( sizeof(ClassifyChunk) * count, GMEM_ZEROINIT);
	classifyIndex = (BYTE *) PvAlloc( sizeof(BYTE) * indexSize, GMEM_ZEROINIT);

	// We failed if we did not get the memory.
	if ( !classifyData || !classifyIndex )
		return FALSE;								// FAILED.

	// Set Default missing value.
	FillMemory( classifyData, -1, sizeof(ClassifyChunk) * count );

	// Init the pointers to the chunks, which are really just indexes into
	//  a contiguous block of memory -- an one-based array of chunks.
	pIndex = classifyIndex;
	count = 1;										// 1 based array.
	for (i = 0; i < sizeof(classifyBitMap); i++ )	// Loop over all bytes.
	{												// Get the bitmap data.
		bitData = classifyBitMap[i];				// For each bit in the byte
		for (j = 0; j < 8; j++, bitData >>= 1, pIndex++)
		{
			if(bitData & 1)			
				*pIndex = count++;					// We used a chunk.
		}
	}
	
	// Store the classifications of each character.
	// Note: classifications are 1 based, a zero value
	//  means the category was not set.
	for (i = 0; i < cKinsokuCategories; i++ )
	{
		pWChar = charCategories[i];					// Loop over all chars in
		while ( ch = *pWChar++ )					//  category.
		{
			bitMapKey = ch >> bitmapShift;
			Assert( classifyIndex[bitMapKey] > 0 );
			Assert( classifyIndex[bitMapKey] < count );

			classifyData[classifyIndex[bitMapKey]].
				classifications[ ch & ( classifyChunkSize-1 )] = (char)i;
		}
	}
	return TRUE;									// Successfully created.
}

void UninitKinsokuClassify()
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "UninitKinsokuClassify");

	FreePv(classifyData);
	FreePv(classifyIndex);
}

/*
 *	KinsokuClassify(ch)
 *
 *	@func
 *		Kinsoku classify the character iff it was a given from
 *		one of the classification tables.
 *
 *	@comm
 *		Hi order bits of ch are used to get an index value used to index
 *		into an array of chunks. Each chunk contains the classifications
 *		for that character as well as some number of characters adjacent
 *		to that character. The low order bits are used to index into
 *		the chunk of adjacent characters.
 *
 *	@devnote
 *		Because of the way we constructed the array, all that we need to
 *		do is look up the data; no conditionals necessary.
 *
 *		The routine is inline to avoid the call overhead. It is static
 *		because it only returns characters from the tables; i.e., this
 *		routine does NOT classify all Unicode characters.
 *
 *	@rdesc
 *		Returns the classification.
 */
static inline INT
KinsokuClassify(
	WCHAR ch )	// @parm char to classify.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "KinsokuClassify");

	return classifyData[ classifyIndex[ ch >> bitmapShift ] ].
			classifications[ ch & ( classifyChunkSize-1 )];
}


#define IsSameNonFEClass(_c1, _c2)	(!(((_c1) ^ (_c2)) & WBF_CLASS))
#define IdeoKanaTypes (C3_HALFWIDTH | C3_FULLWIDTH | C3_KATAKANA | C3_HIRAGANA)
#define IdeoTypes	  (IdeoKanaTypes | C3_IDEOGRAPH)
#define IsIdeographic(_c1) ( 0 != (_c1 & (C3_KATAKANA | C3_HIRAGANA | C3_IDEOGRAPH)) )

/*
 *	IsSameClass(currType1, startType1, currType3, startType3 )
 *
 *	@func	Used to determine word breaks.
 *
 *	@comm	Ideographic chars are all considered to be unique, so that only
 *			one at a time is selected
 */
BOOL IsSameClass(WORD currType1, WORD startType1,
				 WORD currType3, WORD startType3 )
{
	BOOL	fIdeographic = IsIdeographic(currType3);

	// Do classifications for startType3 being ideographic
	if(IsIdeographic(startType3))
	{
		int checkTypes = (currType3 & IdeoTypes) ^ (startType3 & IdeoTypes);

		// We only get picky with non-ideographic Kana chars
		//  C3_HALFWIDTH | C3_FULLWIDTH | C3_KATAKANA | C3_HIRAGANA.
		return fIdeographic && (startType3 & IdeoKanaTypes) &&
			   (!checkTypes || checkTypes == C3_FULLWIDTH || checkTypes == C3_HIRAGANA ||
			   checkTypes == (C3_FULLWIDTH | C3_HIRAGANA));
	}	

	// Do classifications for nonideographic startType3
	return !fIdeographic && IsSameNonFEClass(currType1, startType1);
}

WORD ClassifyChar(TCHAR ch)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "ClassifyChar");
	WORD wRes;

	if (IsKorean(ch))									// special Korean class
		return WBF_KOREAN;

	if (IsThai(ch))
		return 0;

	if (ch == WCH_EMBEDDING)							// Objects
		return 2 | WBF_BREAKAFTER;

	W32->GetStringTypeEx(LOCALE_SYSTEM_DEFAULT, CT_CTYPE1, &ch, 1, &wRes);

	if(wRes & C1_SPACE)
	{
		if(wRes & C1_BLANK)								// Only TAB, BLANK, and
		{												//  nobreak BLANK are here
			if(ch == 0x20)
				return 2 | WBF_BREAKLINE | WBF_ISWHITE;
			if(ch == TAB)
				return 3 | WBF_ISWHITE;
			return 2 | WBF_ISWHITE;
		}
		if(ch == CELL)
			return 3 | WBF_ISWHITE;
		return 4 | WBF_ISWHITE;
	}
	if(wRes & C1_PUNCT && !IsDiacriticOrKashida(ch, 0))
		return ch == '-' ? (1 | WBF_BREAKAFTER) : 1;
	return 0;
}

/*
 *	BatchClassify (pch, cch, pcType3, kinsokuClassifications, pwRes)
 *
 *	@func
 *		Kinsoku classify and ClassifyChar() each character of the given string.
 *
 *	@comm
 *		The Kinsoku classifications are passed to the CanBreak() routine. We
 *		do process in batch to save on overhead.
 *
 *		If the character is not in the Kinsoku classification tables then
 *		GetStringTypeEx is used to classify any remaining character.
 *
 *	@rdesc
 *		Result in out param kinsokuClassifications.
 *		pcType3 result from GetStringTypeEx for CT_CTYPE3
 */
void BatchClassify (
	const WCHAR *pch,	// @parm char string
	INT	  cch,			// @parm Count of chars in string
	WORD *pcType3,		// @parm Result of GetStringTypeEx for CT_CTYPE3
	INT * kinsokuClassifications,	// @parm Result of the classifications
	WORD *pwRes)		// @parm ClassifyChar() result
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "BatchClassify");

	WCHAR	ch;
	WORD	cType3;
	INT		iCategory;
	WORD	wRes;

	Assert( cch < MAX_CLASSIFY_CHARS );
	Assert( pch );
	Assert( kinsokuClassifications );

	// *Note* Using CT_CTYPE1 values alone is unreliable since CT_CTYPE1
	// defines C1_PUNCT for all diacritic characters. According to KDChang,
	// this is by design for POSIX compatibility and it couldn't be changed
	// easily since Win9x shares the same NLS data with NT. (wchao)
	// Therefore we use CT_CTYPE3 data to distinguish diacritics, except on
	// Win9x, for which we use a range check, since GetStringTypeExW isn't
	// supported).

	W32->GetStringTypes(0, pch, cch, pwRes, pcType3);

	while ( cch-- )									// For all ch...
	{
		wRes = *pwRes;
		ch = *pch++;
		
		if(IsKorean(ch))								
			wRes = WBF_KOREAN;						// Special Korean class
		else if (IsThai(ch))
			wRes = 0;								// Thai class
		else if (ch == WCH_EMBEDDING)				// Objects
			wRes = 2 | WBF_BREAKAFTER;
		else if(wRes & C1_SPACE)
		{
			if (wRes & C1_BLANK)
			{
				wRes = 2 | WBF_ISWHITE;
				if(ch == 0x20)
					wRes = 2 | WBF_BREAKLINE | WBF_ISWHITE;
				if(ch == TAB)
					wRes = 3 | WBF_ISWHITE;
			}
			else
				wRes = 4 | WBF_ISWHITE;
		}
		else if(ch == CELL)
			wRes = 3 | WBF_ISWHITE;
		else if((wRes & C1_PUNCT) && !IsDiacriticOrKashida(ch, *pcType3))
			wRes = ch == '-' ? (1 | WBF_BREAKAFTER) : 1;
		else
			wRes = 0;

		*pwRes++ = wRes;

		if(IsKorean(ch))
			iCategory = 11;									
		else
		{
			iCategory = KinsokuClassify(ch);
			if(iCategory < 0)						// If not classified
			{										//  then it is one of:
				cType3 = *pcType3;
				if(cType3 & C3_SYMBOL)
					iCategory = 13;					//  symbol chars,
				else if(cType3 & C3_FullWidth)
					iCategory = 11;					//  ideographic chars,
				else
					iCategory = 15;					//  all other chars.
			}
		}
		*kinsokuClassifications++ = iCategory;
		pcType3++;
	}
}

/*
 *	GetKinsokuClass (ch)
 *
 *	@func
 *		Kinsoku classify ch
 *
 *	@comm
 *		The Kinsoku classifications are passed to the CanBreak() routine. This
 *		single-character routine is for use with LineServices
 *
 *		If the character is not in the Kinsoku classification tables then
 *		GetStringTypeEx is used to classify any remaining character.
 *
 *	@rdesc
 *		Kinsoku classification for ch
 */
INT GetKinsokuClass (
	WCHAR ch)	// @parm char
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "GetKinsokuClassification");

	if(IsKorean(ch))
		return 11;

	// surrogate classification
	if (IN_RANGE(0xD800, ch, 0xDFFF))
		return IN_RANGE(0xDC00, ch, 0xDFFF) ? brkclsClose : brkclsOpen;


	INT iCategory = KinsokuClassify(ch);
	if(iCategory >= 0)
		return iCategory;

	WORD cType3;
	W32->GetStringTypeEx(0, CT_CTYPE3, &ch, 1, &cType3);

	if(cType3 & C3_SYMBOL)
		return 13;							// Symbol chars

	if(cType3 & C3_FullWidth)
		return 11;							// Ideographic chars

	return 15;								// All other chars.
}

/*
 *	CanBreak(class1, class2)
 *
 *	@func
 *		Look into the truth table to see if two consecutive charcters
 *		can have a line break between them.
 *
 *	@comm
 *		This determines whether two successive characters can break a line.
 *		The matrix is taken from JIS X4051 and is based on categorizing
 *		characters into 15 classifications.
 *
 *	@devnote
 *		The table is 1 based.
 *
 *	@rdesc
 *		Returns TRUE if the characters can be broken across a line.
 */
BOOL CanBreak(
	INT class1,		//@parm	Kinsoku classification of character #1
	INT class2 )	//@parm	Kinsoku classification of following character.
{
	TRACEBEGIN(TRCSUBSYSFE, TRCSCOPEINTERN, "CanBreak");

	static const WORD br[16] = {//   fedc ba98 7654 3210
		0x0000,					// 0 0000 0000 0000 0000
		0x0000,					// 1 0000 0000 0000 0000
		0xfd82,					// 2 1111 1101 1000 0010
		0xfd82,					// 3 1111 1101 1000 0010
		0xfd82,					// 4 1111 1101 1000 0010
		0xfd82,					// 5 1111 1101 1000 0010
		0x6d82,					// 6 0110 1101 1000 0010
		0xfd02,					// 7 1111 1101 0000 0010
		0x0000,					// 8 0000 0000 0000 0000
		0xfd82,					// 9 1111 1101 1000 0010
		0xfd83,					// a 1111 1101 1000 0011
		0xfd82,					// b 1111 1101 1000 0010
		0x6d82,					// c 0110 1101 1000 0010
		0x5d82,					// d 0101 1101 1000 0010
		0xfd83,					// e 1111 1101 1000 0011
		0x4d82,					// f 0100 1101 1000 0010
	};
	return (br[class1] >> class2) & 1;
}

/*
 *	IsURLDelimiter(ch)
 *
 *	@func
 *		Punctuation characters are those of sets 0, 1, 2, 4, 5, and 6,
 *		and < or > which we consider to be brackets, not "less" or
 *      "greater" signs. On the other hand; "/" (in set 6) should not be
 *		a delimiter, but rather a part of the URL.
 *
 *	@comm This function is used in URL detection
 *
 *	@rdesc
 *		Returns TRUE if the character is a punctuation mark.
 */
BOOL IsURLDelimiter(
	WCHAR ch)
{
	if (IsKorean(ch))
		return TRUE;

	INT iset = KinsokuClassify(ch);

	return IN_RANGE(0, iset, 2) || (IN_RANGE(4, iset, 6) && ch != '/')
		   || ch == '<' || ch == '>';
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\cmsgflt.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	CMSGFLT.CPP	-- Text Message Implementation |
 *	
 *		Most everything to do with IME message handling.
 *
 *	Original Author: <nl>
 *		Hon Wah Chan
 *
 *	History: <nl>
 *		2/6/98  v-honwch
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */
#include "_common.h"
#include "_cmsgflt.h"
#include "_ime.h"

#define MAX_RECONVERSION_SIZE 100
#define CONTROL(_ch) (_ch - 'A' + 1)

/*
 *	void CreateIMEMessageFilter(ITextMsgFilter **ppMsgFilter)
 *
 *	@func
 *		TextMsgFilter class factory.
 */       
void CreateIMEMessageFilter(ITextMsgFilter **ppMsgFilter)
{
	CTextMsgFilter *pNewFilter = new CTextMsgFilter;
	*ppMsgFilter = pNewFilter ? pNewFilter : NULL;
}

/*
 *	void CTextMsgFilter::~CTextMsgFilter
 *
 *	@mfunc
 *		CTextMsgFilter Destructor
 *			Release objects being used.
 *		
 */
CTextMsgFilter::~CTextMsgFilter ()
{
	if (_hIMCContext)
		ImmAssociateContext(_hwnd, _hIMCContext, _fUsingAIMM);	// Restore IME before exit

	// Release various objects 
	if (_fUsingAIMM)		
		DeactivateAIMM();

	if (_pFilter)
		_pFilter->Release();
	
	if (_pTextSel)
		_pTextSel->Release();
	
	_pFilter = NULL;
	_pTextDoc = NULL;
	_pTextSel = NULL;
	_hwnd = NULL;
	_hIMCContext = NULL;

}

/*
 *	STDMETHODIMP CTextMsgFilter::QueryInterface (riid, ppv)
 *
 *	@mfunc
 *		IUnknown QueryInterface support
 *
 *	@rdesc
 *		NOERROR if interface supported
 *
 */
STDMETHODIMP CTextMsgFilter::QueryInterface (REFIID riid, void ** ppv)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CTextMsgFilter::QueryInterface");

	if( IsEqualIID(riid, IID_IUnknown) )
	{
		*ppv = (IUnknown *)this;
	}
	else if( IsEqualIID(riid, IID_ITextMsgFilter) )
	{
		*ppv = (ITextMsgFilter *)this;
	}
	else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}

	AddRef();

	return NOERROR;
}

/*
 *	STDMETHODIMP_(ULONG) CTextMsgFilter::AddRef
 *
 *	@mfunc
 *		IUnknown AddRef support
 *
 *	@rdesc
 *		Reference count
 */
STDMETHODIMP_(ULONG) CTextMsgFilter::AddRef()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::AddRef");

	return ++_crefs;
}

/*
 *	STDMETHODIMP_(ULONG) CTextMsgFilter::Release()
 *
 *	@mfunc
 *		IUnknown Release support - delete object when reference count is 0
 *
 *	@rdesc
 *		Reference count
 */
STDMETHODIMP_(ULONG) CTextMsgFilter::Release()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CTextMsgFilter::Release");

	_crefs--;

	if( _crefs == 0 )
	{
		delete this;
		return 0;
	}

	return _crefs;
}

/*
 *	STDMETHODIMP_(HRESULT) CTextMsgFilter::AttachDocument(HWND, ITextDocument2)
 *
 *	@mfunc
 *		Attach message filter. Perform genral initialization
 *
 *	@rdesc
 *		NOERROR
 */
STDMETHODIMP_(HRESULT) CTextMsgFilter::AttachDocument( HWND hwnd, ITextDocument2 *pTextDoc)
{
	HRESULT hResult; 

	// Cache the values for possible later use.
	// The TextDocument interface pointer is not AddRefed because it is a back pointer
	// and the lifetime of message filters is assumed to be nested inside text documents	
	_hwnd = hwnd;
	_pTextDoc = pTextDoc;

	// Don't get selection until it is needed
	_pTextSel = NULL;

	_fUnicodeWindow = 0;	
	if (hwnd)
		_fUnicodeWindow = IsWindowUnicode(hwnd);

	_fUsingAIMM = 0; 
	// We will activate AIMM if it has been loaded by previous instances
	// NOTE: we don't support AIMM for windowless mode.
	if (_hwnd && IsAIMMLoaded())
	{
		// activate AIMM
		hResult = ActivateAIMM(FALSE);

		if (hResult == NOERROR)
		{
			DWORD	dwAtom;
			ATOM	aClass;

			// filter client windows
			if (dwAtom = GetClassLong(hwnd, GCW_ATOM))
			{
				aClass = dwAtom;				
				hResult = FilterClientWindowsAIMM(&aClass, 1);
			}
			_fUsingAIMM = 1;
		}
	}

	// Check if current keyboard is MSIME98 or later.
	CheckIMEType(NULL);

	// Initialize some member data
	_fHangulToHanja = FALSE;
	_fIMECancelComplete = FALSE;	
	_fIMEAlwaysNotify = FALSE;
	_hIMCContext = NULL;

	_pTextDoc->GetFEFlags(&_lFEFlags);
	_fRE10Mode = (_lFEFlags & tomRE10Mode);

	// For 1.0 mode IME color 
	memset(_crComp, 0, sizeof(_crComp));
	_crComp[0].crBackground = 0x0ffffff;
	_crComp[0].dwEffects = CFE_UNDERLINE;
	_crComp[1].crBackground = 0x0808080;
	_crComp[2].crBackground = 0x0ffffff;
	_crComp[2].dwEffects = CFE_UNDERLINE;
	_crComp[3].crText = 0x0ffffff;


	_uSystemCodePage = GetACP();

	return NOERROR;
}

/*
 *	STDMETHODIMP_(HRESULT) CTextMsgFilter::HandleMessage(UINT *, WPARAM *, LPARAM *, LRESULT *)
 *
 *	@mfunc
 *		Main Message filter message loop handling
 *
 *	@rdesc
 *		S_OK		if we have handled the message
 *		S_FALSE		if we want the caller to process the message
 */
STDMETHODIMP_(HRESULT) CTextMsgFilter::HandleMessage( 
		UINT *		pmsg,
        WPARAM *	pwparam,
		LPARAM *	plparam,
		LRESULT *	plres)
{
	HRESULT hr = S_FALSE;
	BOOL	bReleaseSelction = FALSE;
	HRESULT hResult;

	// Give other message filters a chance to handle message
	// Stop with the first guy that handles the message
	if (_pFilter)	 
		hr = _pFilter->HandleMessage(pmsg, pwparam, plparam, plres);

	if (hr == S_OK)
		return hr;

 	if (IsIMEComposition())
	{
		// During IME Composition, there are some messages we should
		// not handle.  Also, there are other messages we need to handle by
		// terminating the IME composition first.
		// For WM_KEYDOWN, this is handled inside edit.c OnTxKeyDown().
		switch( *pmsg )
		{
			case WM_COPY:
			case WM_CUT:
			case WM_DROPFILES:
			case EM_REDO:
			case EM_SETCHARFORMAT:			
			case WM_SETFONT:
				return S_OK;					// Just ignore these

			
			case EM_UNDO:
			case WM_UNDO:
				// just terminate and exist for undo cases
				_ime->TerminateIMEComposition(*this, CIme::TERMINATE_NORMAL);
				return S_OK;

			case WM_SETTEXT:
			case WM_CLEAR:
			case EM_STREAMIN:
				// these messages are used to reset our state, so reset
				// IME as well
				_ime->TerminateIMEComposition(*this, CIme::TERMINATE_FORCECANCEL);
				break;

			case EM_SETTEXTEX:
				if (!_fRE10Mode)			// Don't terminate if running in 10 mode			
					_ime->TerminateIMEComposition(*this, CIme::TERMINATE_FORCECANCEL);
				break;

			case WM_SYSKEYDOWN:
				// Don't terminate IME composition on VK_PROCESSKEY (F10) since Japanese 
				// IME will process the F10 key
				if ( *pwparam == VK_PROCESSKEY )
					break;
				// otherwise we want to terminate the IME

			case EM_SETWORDBREAKPROC:
 			case WM_PASTE:
			case EM_PASTESPECIAL:					  			
 			case EM_SCROLL:
			case EM_SCROLLCARET:
 			case WM_VSCROLL:
			case WM_HSCROLL:
			case WM_KILLFOCUS:
			case EM_STREAMOUT:
			case EM_SETREADONLY:
 			case EM_SETSEL:
			case EM_SETPARAFORMAT:
			case WM_INPUTLANGCHANGEREQUEST:	
				_ime->TerminateIMEComposition(*this, CIme::TERMINATE_NORMAL);
				break;

			case WM_KEYDOWN:
				if(GetKeyState(VK_CONTROL) & 0x8000)
				{	
					// During IME Composition, there are some key events we should
					// not handle.  Also, there are other key events we need to handle by
					// terminating the IME composition first.			
					switch((WORD) *pwparam)
					{
					case VK_TAB:
		   			case VK_CLEAR:
					case VK_NUMPAD5:
					case 'A':						// Ctrl-A => select all
					case 'C':						// Ctrl-C => copy
					case 'X':						// Ctrl-X => cut
					case 'Y':						// Ctrl-Y => redo
						return S_OK;				// Just ignore these

					case 'V':						// Ctrl-V => paste
					case 'Z':						// Ctrl-Z => undo	
						_ime->TerminateIMEComposition(*this, CIme::TERMINATE_NORMAL);						
						if ((WORD) *pwparam == 'Z')	// Early exist for undo case
							return S_OK;
					}
				}
				else
				{
					switch((WORD) *pwparam)
					{					
					case VK_F16:
						return S_OK;				// Just ignore these
					
					case VK_BACK:
					case VK_INSERT:					// Ins			
					case VK_LEFT:					// Left arrow
					case VK_RIGHT:					// Right arrow
					case VK_UP:						// Up arrow
					case VK_DOWN:					// Down arrow
					case VK_HOME:					// Home
					case VK_END:					// End
					case VK_PRIOR:					// PgUp
					case VK_NEXT:					// PgDn
					case VK_DELETE:					// Del
					case CONTROL('J'):
					case VK_RETURN:
						_ime->TerminateIMEComposition(*this, CIme::TERMINATE_NORMAL);
						break;
					}
				}
				break;

			default:
				// only need to handle mouse related msgs during composition
				if (IN_RANGE(WM_MOUSEFIRST, *pmsg, WM_MBUTTONDBLCLK) || *pmsg == WM_SETCURSOR)
				{
					bReleaseSelction = GetTxSelection();
					if (_pTextSel)
						hr = IMEMouseCheck( *this, pmsg, pwparam, plparam, plres);
					goto Exit;
				}				
		}
	}

	// Get Fe Flags for ES_NOIME or ES_SELFIME setting
	_lFEFlags = 0;

	// ... Local mucking with msg, params, etc, ...
	switch ( *pmsg )
	{
		case WM_CHAR:
			hr = OnWMChar (pmsg, pwparam, plparam, plres);
			break;

		case WM_IME_CHAR:
			_uKeyBoardCodePage = GetKeyboardCodePage(0x0FFFFFFFF);
			hResult = _pTextDoc->GetFEFlags(&_lFEFlags);
			if ((_lFEFlags & ES_NOIME))
				hr = S_OK;
			else
				hr = OnWMIMEChar (pmsg, pwparam, plparam, plres);
			break;
		
		case WM_IME_STARTCOMPOSITION:
			_uKeyBoardCodePage = GetKeyboardCodePage(0x0FFFFFFFF);
			hResult = _pTextDoc->GetFEFlags(&_lFEFlags);
			if (!(_lFEFlags & ES_SELFIME))
			{				
				bReleaseSelction = GetTxSelection();
				if (_pTextSel)
					hr = StartCompositionGlue (*this);
			}
			break;

		case WM_IME_COMPOSITION:
			_uKeyBoardCodePage = GetKeyboardCodePage(0x0FFFFFFFF);
			hResult = _pTextDoc->GetFEFlags(&_lFEFlags);
			
			if ((_lFEFlags & ES_NOIME) && !IsIMEComposition())
				hr = S_OK;			
			else if (!(_lFEFlags & ES_SELFIME))
			{
				bReleaseSelction = GetTxSelection();
				if (_pTextSel)
				{
					hr = CompositionStringGlue ( *plparam, *this );
					// Turn off Result string bit to avoid WM_IME_CHAR message.
					*plparam &= ~GCS_RESULTSTR;
				}
			}

			if (_hwnd && IsIMEComposition() && _ime->IgnoreIMECharMsg())
			{
				_ime->AcceptIMECharMsg();
				if (fHaveAIMM)
					hr = CallAIMMDefaultWndProc(_hwnd, *pmsg, *pwparam, *plparam, plres);
				else
					*plres = ::DefWindowProc(_hwnd, *pmsg, *pwparam, *plparam);				

				hr = S_OK;
			}

			break;

		case WM_IME_ENDCOMPOSITION:
			hResult = _pTextDoc->GetFEFlags(&_lFEFlags);
			if (!(_lFEFlags & ES_SELFIME))
			{			
				bReleaseSelction = GetTxSelection();
				if (_pTextSel)
					hr = EndCompositionGlue ( *this, FALSE );
			}
			break;

		case WM_IME_NOTIFY:
			hResult = _pTextDoc->GetFEFlags(&_lFEFlags);
			if (!(_lFEFlags & (ES_SELFIME | ES_NOIME)))
			{
				bReleaseSelction = GetTxSelection();
				if (_pTextSel)			
					hr = IMENotifyGlue ( *pwparam, *plparam, *this );
			}
			break;

		case WM_IME_COMPOSITIONFULL:	// Level 2 comp string about to overflow.
			hResult = _pTextDoc->GetFEFlags(&_lFEFlags);
			if (!(_lFEFlags & ES_SELFIME))
			{
				IMECompositionFull ( *this );
			}
			hr = S_FALSE;
			break;

		case WM_KEYDOWN:
			
			bReleaseSelction = GetTxSelection();
			if (_pTextSel)
			{
				if (*pwparam == VK_KANJI)
				{
					hResult = _pTextDoc->GetFEFlags(&_lFEFlags);
					
					_uKeyBoardCodePage = GetKeyboardCodePage(0x0FFFFFFFF);
					// for Korean, need to convert the next Korean Hangul character to Hanja
					if(CP_KOREAN == _uKeyBoardCodePage && !(_lFEFlags & (ES_SELFIME | ES_NOIME)))
						hr = IMEHangeulToHanja ( *this );
				}
			}
			break;

		case WM_INPUTLANGCHANGE: 
			CheckIMEType((HKL)*plparam);
			hr = S_FALSE;
			break;

		case WM_KILLFOCUS:
			OnKillFocus();
			break;
		
		case WM_SETFOCUS:
			OnSetFocus();
			break;

		case EM_SETIMEOPTIONS:
			*plres = OnSetIMEOptions(*pwparam, *plparam);
			hr = S_OK;
			break;

		case EM_GETIMEOPTIONS:
			*plres = OnGetIMEOptions();
			hr = S_OK;
			break;

		case WM_IME_REQUEST:
			hResult = _pTextDoc->GetFEFlags(&_lFEFlags);
			if (!(_lFEFlags & (ES_SELFIME | ES_NOIME)))
			{				
				bReleaseSelction = GetTxSelection();
				if (_pTextSel)
				{
					_uKeyBoardCodePage = GetKeyboardCodePage(0x0FFFFFFFF);
					if (*pwparam == IMR_RECONVERTSTRING || *pwparam == IMR_CONFIRMRECONVERTSTRING
						|| *pwparam == IMR_DOCUMENTFEED)			
						hr = OnIMEReconvert(pmsg, pwparam, plparam, plres, _fUnicodeWindow);	
					else if (*pwparam == IMR_QUERYCHARPOSITION)
						hr = OnIMEQueryPos(pmsg, pwparam, plparam, plres, _fUnicodeWindow);
				}				
			}
			break;

		case EM_RECONVERSION:
			hResult = _pTextDoc->GetFEFlags(&_lFEFlags);
			if (!(_lFEFlags & (ES_SELFIME | ES_NOIME)))
			{
				// Application initiates reconversion
				bReleaseSelction = GetTxSelection();
				if (_pTextSel)
				{
					if (!IsIMEComposition())
					{
						if (_fMSIME && MSIMEReconvertRequestMsg)
							// Use private message if it is available
							IMEMessage( *this, MSIMEReconvertRequestMsg, 0, (LPARAM)_hwnd, TRUE );				
						else
						{
							hr = OnIMEReconvert(pmsg, pwparam, plparam, plres, TRUE);							
							*plres = 0;
						}
					}
				}
			}
			hr = S_OK;
			break;

		case EM_SETLANGOPTIONS:
			// Setup IME related setting.
			// hr is not S_OK so textserv could handle other language setting
			_fIMEAlwaysNotify = (*plparam & IMF_IMEALWAYSSENDNOTIFY) != 0;
			_fIMECancelComplete = (*plparam & IMF_IMECANCELCOMPLETE) != 0;
			*plres = 1;
			break;

		case EM_GETLANGOPTIONS:
			// Report IME related setting.
			// hr is not S_OK so textserv could fill in other language setting
			if ( _fIMECancelComplete ) 
				*plres |= IMF_IMECANCELCOMPLETE;
			if ( _fIMEAlwaysNotify )
				*plres |= IMF_IMEALWAYSSENDNOTIFY;
			break;

		case EM_GETIMECOMPMODE:
			// Get current IME level
			*plres = OnGetIMECompositionMode( *this );
			hr = S_OK;
			break;

		case EM_SETEDITSTYLE:							
			if (*pwparam & SES_USEAIMM)
			{
				if (_hwnd && !_fUsingAIMM && LoadAIMM())
				{
					hResult = _pTextDoc->GetFEFlags(&_lFEFlags);
					if (!(_lFEFlags & ES_NOIME))			// No IME style on?
					{
						// activate AIMM
						hResult = ActivateAIMM(FALSE);

						if (hResult == NOERROR)
						{
							DWORD	dwAtom;
							ATOM	aClass;

							// filter client windows
							if (dwAtom = GetClassLong(_hwnd, GCW_ATOM))
							{
								aClass = dwAtom;				
								hResult = FilterClientWindowsAIMM(&aClass, 1);
							}
							_fUsingAIMM = 1;
						}
					}
				}
			}
			if ((*plparam == 0 || *plparam & SES_NOIME) && _hwnd)
			{
				if (*pwparam & SES_NOIME)
				{
					if (!_hIMCContext)
						_hIMCContext = ImmAssociateContext(_hwnd, NULL, _fUsingAIMM);	// turn off IME									
				}
				else if (*plparam & SES_NOIME)
				{
					if (_hIMCContext)
						ImmAssociateContext(_hwnd, _hIMCContext, _fUsingAIMM);			// turn on IME
					_hIMCContext = NULL;
				}
			}			

			// remove settings that are handled.
			*pwparam &= ~(SES_NOIME | SES_USEAIMM);
			*plparam &= ~(SES_NOIME | SES_USEAIMM);

			// fall thru to return the edit style

		case EM_GETEDITSTYLE:
			if (_hIMCContext)
				*plres = SES_NOIME;			// IME has been turned off
			if (_fUsingAIMM)
				*plres |= SES_USEAIMM;		// AIMM is on

			break;

		case EM_SETIMECOLOR:
			if (_fRE10Mode)
			{
				memcpy(&_crComp, (const void *)(*plparam), sizeof(_crComp));
				*plres = 1;
			}
			hr = S_OK;
			break;

		case EM_GETIMECOLOR:
			if (_fRE10Mode)
			{
				memcpy((void *)(*plparam), &_crComp, sizeof(_crComp));
				*plres = 1;
			}
			hr = S_OK;
			break;

		default:
			if (*pmsg)
			{
				// Look for IME98 private messages
				if (*pmsg == MSIMEReconvertMsg || *pmsg == MSIMEDocFeedMsg
					|| *pmsg == MSIMEQueryPositionMsg)
				{
					hResult = _pTextDoc->GetFEFlags(&_lFEFlags);
					if (!(_lFEFlags & (ES_SELFIME | ES_NOIME)))
					{
						bReleaseSelction = GetTxSelection();
						if (_pTextSel)
						{
							if (*pmsg == MSIMEQueryPositionMsg)
								hr = OnIMEQueryPos(pmsg, pwparam, plparam, plres, TRUE);
							else
								hr = OnIMEReconvert(pmsg, pwparam, plparam, plres, TRUE);
						}
					}
				}
			}
			break;
	}

Exit:
	// Release Selection if we get it for this message
	if (bReleaseSelction && _pTextSel)
	{
		_pTextSel->Release();
		_pTextSel = NULL;
	}

	// Return the value that will cause message to be processed normally
	return hr;
}

/*
 *	HRESULT CTextMsgFilter::AttachMsgFilter(ITextMsgFilter *)
 *
 *	@mfunc
 *		Add another message filter to the chain
 *
 *	@rdesc
 *		NOERROR if added
 */
HRESULT STDMETHODCALLTYPE CTextMsgFilter::AttachMsgFilter( ITextMsgFilter *pMsgFilter)
{
	HRESULT hr = NOERROR;
	if (_pFilter)
		hr = _pFilter->AttachMsgFilter( pMsgFilter );
	else
	{
		_pFilter = pMsgFilter;
		_pFilter->AddRef();
	}
	return hr;
}

/*
 *	HRESULT CTextMsgFilter::OnWMChar(UINT *, WPARAM *, LPARAM *, LRESULT *)
 *
 *	@mfunc
 *		Handle WM_CHAR message - look for Japanese keyboard with Kana key on
 *		Convert the SB Kana to Unicode if needed.
 *
 *	@rdesc
 *		S_FALSE so caller will handle the modified character in wparam
 */
HRESULT CTextMsgFilter::OnWMChar( 
		UINT *		pmsg,
        WPARAM *	pwparam,
		LPARAM *	plparam,
		LRESULT *	plres)
{
	// For Japanese keyboard, if Kana mode is on,
	// Kana characters (single byte Japanese chars) are coming in via WM_CHAR.
	if ( GetKeyState(VK_KANA) & 0x1 )
	{
		_uKeyBoardCodePage = GetKeyboardCodePage(0x0FFFFFFFF);

		if (_uKeyBoardCodePage == CP_JAPAN)
		{
			// check if this is a single byte character.
 			TCHAR	unicodeConvert;
			BYTE	bytes[2];
			bytes[0] = (BYTE)(*pwparam >> 8);	// Interchange DBCS bytes in endian
			bytes[1] = (BYTE)*pwparam;			// independent fashion (use byte array)

			if (!bytes[0])
			{
				if(UnicodeFromMbcs((LPWSTR)&unicodeConvert, 1, 
					(LPCSTR)&bytes[1], 1, _uKeyBoardCodePage) == 1)
					*pwparam = unicodeConvert;
			}
			
			return InputFEChar(*pwparam);
		}
	}

	return S_FALSE;
}

/*
 *	HRESULT CTextMsgFilter::OnWMIMEChar(UINT *, WPARAM *, LPARAM *, LRESULT *)
 *
 *	@mfunc
 *		Handle WM_IMECHAR message - convert the character to unicode.
 *
 *	@rdesc
 *		S_OK - caller to ignore the message
 *		S_FALSE - caller to handle the message.  wparam may contains a new char
 */
HRESULT CTextMsgFilter::OnWMIMEChar( 
		UINT *		pmsg,
        WPARAM *	pwparam,
		LPARAM *	plparam,
		LRESULT *	plres)
{
	TCHAR	unicodeConvert;
	BYTE	bytes[2];

	// We may receive IMECHAR even if we have handled the composition char already.
	// This is the case when the host does not call the DefWinProc with the composition
	// bit masked off.  So, we need to ignore this message to avoid double entry.
	if (IsIMEComposition() && _ime->IgnoreIMECharMsg())
	{
		_ime->SkipIMECharMsg();		// Skip this ime char msg
		return S_OK;	
	}

	bytes[0] = *pwparam >> 8;		// Interchange DBCS bytes in endian
	bytes[1] = *pwparam;			// independent fashion (use byte array)
	
	// need to convert both single-byte KANA and DBC
	if (!bytes[0] || GetTrailBytesCount(bytes[0], _uKeyBoardCodePage))
	{
		if( UnicodeFromMbcs((LPWSTR)&unicodeConvert, 1, 
			bytes[0] == 0 ? (LPCSTR)&bytes[1] : (LPCSTR)bytes,
			bytes[0] == 0 ? 1 : 2,
			_uKeyBoardCodePage) == 1 )
			*pwparam = unicodeConvert;

		return InputFEChar(*pwparam);
	}

	return S_FALSE;
}

/*
 *	HRESULT CTextMsgFilter::OnIMEReconvert(UINT *, WPARAM *, LPARAM *, LRESULT *)
 *
 *	@mfunc
 *		Handle IME Reconversion and Document feed. We only handle Unicode messages.
 *		We use a limit of MAX_RECONVERSION_SIZE(100) characters in both cases.
 *
 *	@rdesc
 *		S_OK		if we have handled the message
 */
HRESULT CTextMsgFilter::OnIMEReconvert( 
		UINT *		pmsg,
        WPARAM *	pwparam,
		LPARAM *	plparam,
		LRESULT *	plres,
		BOOL		fUnicode)
{
	HRESULT		hr = S_OK;
	LPRECONVERTSTRING lpRCS = (LPRECONVERTSTRING)(*plparam);
	long		cbStringSize;
	long		cpMin, cpMax;
	long		cpParaStart, cpParaEnd;
	HRESULT		hResult;
	ITextRange *pTextRange, *pTempTextRange;
	long		cbAdded;				
	BOOL		bDocumentFeed;
	long		cLastChar;
	BOOL		fAdjustedRange = FALSE;

	*plres = 0;

	// NT doesn't support Ansi window when the CP_ACP isn't the same
	// as keyboard codepage.
	if (!fUnicode && !(W32->OnWin9x()) && _uKeyBoardCodePage != _uSystemCodePage)
		return S_OK;

	bDocumentFeed = (MSIMEDocFeedMsg && *pmsg == MSIMEDocFeedMsg)
					|| (*pmsg == WM_IME_REQUEST && *pwparam == IMR_DOCUMENTFEED);

	if (bDocumentFeed && IsIMEComposition() && _ime->GetIMELevel() == IME_LEVEL_3)
	{
		// Composition in progress, use composition string as selection
		cpMin = ((CIme_Lev3 *)_ime)->GetIMECompositionStart();
		cpMax = ((CIme_Lev3 *)_ime)->GetIMECompositionLen() + cpMin;
	}
	else
	{
		// Get current selection
		hResult	= _pTextSel->GetStart(&cpMin);
		hResult	= _pTextSel->GetEnd(&cpMax);
	}

	// Expand to include the current paragraph
	hResult = _pTextDoc->Range(cpMin, cpMax, &pTextRange);
	Assert (pTextRange != NULL);
	if (hResult != NOERROR)
		return S_OK;

	hResult = pTextRange->Expand(tomParagraph, &cbAdded);

	// Fail to get Paragraph, get the story
	// Note:- Expand will return S_FALSE for plain text when
	// the whole story is selected
	if (hResult != NOERROR)		
		hResult = pTextRange->Expand(tomStory, &cbAdded);

	hResult = pTextRange->GetStart(&cpParaStart);
	hResult = pTextRange->GetEnd(&cpParaEnd);

	if (*pwparam == IMR_CONFIRMRECONVERTSTRING)
	{
		*plres = CheckIMEChange(lpRCS, cpParaStart, cpParaEnd, cpMin, cpMax, fUnicode);		
		goto Exit;
	}
		
	// Initialize to hugh number
	_cpReconvertStart = tomForward;

	// Check if Par included	
	hResult = _pTextDoc->Range(cpParaEnd-1, cpParaEnd, &pTempTextRange);
	if (hResult != NOERROR)
		goto Exit;
	Assert (pTempTextRange != NULL);

	hResult	= pTempTextRange->GetChar(&cLastChar);
	pTempTextRange->Release();

	if (hResult == NOERROR && (WCHAR)cLastChar == CR)
	{
		if (cpMax == cpParaEnd)
		{								
			// Par is selected, change selection to exclude the par char
			cpMax--;
			_pTextSel->SetEnd(cpMax);

			if (cpMin > cpMax)
			{
				// Adjust cpMin as well
				cpMin = cpMax;
				_pTextSel->SetStart(cpMin);
			}
		}

		// Get rid of par char 
		cpParaEnd--;
		fAdjustedRange = TRUE;
	}

	// Check for MAX_RECONVERSION_SIZE since we don't want to pass a hugh buffer
	// to IME
	long	cchSelected;

	cchSelected = cpMax - cpMin;
	if (cpParaEnd - cpParaStart > MAX_RECONVERSION_SIZE)
	{
		// Too many character selected, forget it
		if (cchSelected > MAX_RECONVERSION_SIZE)
			goto Exit;

		if (cchSelected == MAX_RECONVERSION_SIZE)
		{
			// Selection reaches the limit
			cpParaStart = cpMin;
			cpParaEnd = cpMax;
		}
		else
		{
			long	cchBeforeSelection = cpMin - cpParaStart;
			long	cchAfterSelection = cpParaEnd - cpMax;
			long	cchNeeded = MAX_RECONVERSION_SIZE - cchSelected;
			
			if (cchBeforeSelection < cchNeeded/2)
			{
				// Put in all characters from the Par start
				// and move Par end
				cpParaEnd = cpParaStart + MAX_RECONVERSION_SIZE - 1;
			}
			else if (cchAfterSelection < cchNeeded/2)
			{
				// Put in all character to the Par end
				// and move Par start
				cpParaStart = cpParaEnd - MAX_RECONVERSION_SIZE + 1;

			}
			else
			{
				// Adjust both end
				cpParaStart = cpMin - cchNeeded/2;
				cpParaEnd = cpParaStart + MAX_RECONVERSION_SIZE - 1;
			}
		}
		fAdjustedRange = TRUE;
	}

	if (fAdjustedRange)
	{
		// Adjust the text range
		hResult	= pTextRange->SetRange(cpParaStart, cpParaEnd);
		
		if (hResult != NOERROR)
			goto Exit;
	}

	cbStringSize = (cpParaEnd - cpParaStart) * 2;

	// No char in current par, forget it.
	if (cbStringSize <= 0)
		goto Exit;

	if (EM_RECONVERSION == *pmsg)
	{
		// RE reconversion msg, allocate the Reconversion buffer
		lpRCS = (LPRECONVERTSTRING) PvAlloc(sizeof(RECONVERTSTRING) + cbStringSize + 2, GMEM_ZEROINIT);
		Assert(lpRCS != NULL);

		if (lpRCS)
			lpRCS->dwSize = sizeof(RECONVERTSTRING) + cbStringSize + 2;
	}

	if (lpRCS)
	{
		BSTR		bstr = NULL;
		LPSTR		lpReconvertBuff;

		hResult = pTextRange->GetText(&bstr);

		if (hResult != NOERROR || bstr == NULL)
		{
			if (EM_RECONVERSION == *pmsg)
				FreePv(lpRCS);
			goto Exit;						// forget it		
		}
		
		if (lpRCS->dwSize - sizeof(RECONVERTSTRING) - 2 < (DWORD)cbStringSize)
			cbStringSize = lpRCS->dwSize - sizeof(RECONVERTSTRING) - 2;
		
		lpReconvertBuff = (LPSTR)(lpRCS) + sizeof(RECONVERTSTRING);

		if (fUnicode)
		{
			// fill in the buffer
			memcpy(lpReconvertBuff, (LPSTR)bstr, cbStringSize);

			*(lpReconvertBuff+cbStringSize) = '\0';
			*(lpReconvertBuff+cbStringSize+1) = '\0';
			
			lpRCS->dwStrLen = (cpParaEnd - cpParaStart);					
			lpRCS->dwCompStrLen = (cpMax - cpMin);
			lpRCS->dwCompStrOffset = (cpMin - cpParaStart)*2;	// byte offset from beginning of string
		}
		else
		{
			// Ansi case, need to find byte offset and Ansi string
			long	cch = WideCharToMultiByte(_uKeyBoardCodePage, 0, bstr, -1, lpReconvertBuff, cbStringSize+1, NULL, NULL);
			Assert (cch > 0);
			if (cch > 0)
			{
				CTempCharBuf tcb;
				char *psz = tcb.GetBuf(cch);

				if (cch > 1 && lpReconvertBuff[cch-1] == '\0')
					cch--;			// Get rid of the null char

				lpRCS->dwStrLen = cch;
				lpRCS->dwCompStrOffset = WideCharToMultiByte(_uKeyBoardCodePage, 0, 
					bstr, cpMin - cpParaStart, psz, cch, NULL, NULL);
				
				lpRCS->dwCompStrLen = 0;
				if (cpMax > cpMin)				
					lpRCS->dwCompStrLen = WideCharToMultiByte(_uKeyBoardCodePage, 0, 
						bstr+cpMin, cpMax - cpMin, psz, cch, NULL, NULL);				
			}
			else
			{
				SysFreeString (bstr);
				if (EM_RECONVERSION == *pmsg)
					FreePv(lpRCS);
				goto Exit;						// forget it
			}
		}

		// Fill in the rest of the RCS struct
		lpRCS->dwVersion = 0;		
		lpRCS->dwStrOffset = sizeof(RECONVERTSTRING);		// byte offset from beginning of struct		
		lpRCS->dwTargetStrLen = lpRCS->dwCompStrLen;
		lpRCS->dwTargetStrOffset = lpRCS->dwCompStrOffset;
		
		*plres = sizeof(RECONVERTSTRING) + cbStringSize + 2;

		// Save this for the CONFIRMRECONVERTSTRING handling
		_cpReconvertStart = cpParaStart;
		_cpReconvertEnd = cpParaEnd;
		
		SysFreeString (bstr);

		if (EM_RECONVERSION == *pmsg)
		{
			HIMC	hIMC = ImmGetContext(_hwnd);

			if (hIMC)
			{
				DWORD imeProperties = ImmGetProperty(GetKeyboardLayout(0x0FFFFFFFF), IGP_SETCOMPSTR, _fUsingAIMM);

				if ((imeProperties & (SCS_CAP_SETRECONVERTSTRING | SCS_CAP_MAKEREAD))
					== (SCS_CAP_SETRECONVERTSTRING | SCS_CAP_MAKEREAD))
				{
					if (ImmSetCompositionStringW(hIMC, SCS_QUERYRECONVERTSTRING, lpRCS, *plres, NULL, 0))
					{
						// Check if there is any change in selection
						CheckIMEChange(lpRCS, cpParaStart, cpParaEnd, cpMin, cpMax, TRUE);
						ImmSetCompositionStringW(hIMC, SCS_SETRECONVERTSTRING, lpRCS, *plres, NULL, 0);
					}
				}
				ImmReleaseContext(_hwnd, hIMC);
			}

			FreePv(lpRCS);
		}
	}
	else
	{
		// return size for IME to allocate the buffer
		*plres = sizeof(RECONVERTSTRING) + cbStringSize + 2;	
	}

Exit:
	pTextRange->Release();

	return hr;
}

/* 
 *  BOOL  CTextMsgFilter::CheckIMEChange(LPRECONVERTSTRING,long,long,long,long)
 *
 *	@mfunc
 *	 	Verify if IME wants to re-adjust the selection
 *
 *	@rdesc
 *		TRUE - allow IME to change the selection
 */
BOOL  CTextMsgFilter::CheckIMEChange(
	LPRECONVERTSTRING	lpRCS,
	long				cpParaStart, 
	long				cpParaEnd,
	long				cpMin,
	long				cpMax,
	BOOL				fUnicode)
{
	long		cpImeSelectStart = 0;
	long		cpImeSelectEnd = 0;
	HRESULT		hResult;	

	if (!lpRCS || _cpReconvertStart == tomForward)
		// Never initialize, forget it
		return FALSE;

	if (fUnicode)
	{
		cpImeSelectStart = _cpReconvertStart + lpRCS->dwCompStrOffset / 2;
		cpImeSelectEnd = cpImeSelectStart + lpRCS->dwCompStrLen;
	}
	else
	{
		// Need to convert the byte offset to char offset.
		ITextRange *pTextRange;
		BSTR		bstr = NULL;

		hResult = _pTextDoc->Range(_cpReconvertStart, _cpReconvertEnd, &pTextRange);
		if (hResult != NOERROR)
			return FALSE;
				
		// Get the text
		hResult = pTextRange->GetText(&bstr);

		if (hResult == S_OK)
		{
			long	cchReconvert = _cpReconvertEnd - _cpReconvertStart + 1;
			CTempCharBuf tcb;
			char *psz = tcb.GetBuf((cchReconvert)*2);
			long cch = WideCharToMultiByte(_uKeyBoardCodePage, 0, 
				bstr, -1, psz, (cchReconvert)*2, NULL, NULL);

			if (cch > 0)
			{
				long dwCompStrOffset, dwCompStrLen;
				CTempWcharBuf	twcb;
				WCHAR			*pwsz = twcb.GetBuf(cchReconvert);

				dwCompStrOffset = MultiByteToWideChar(_uKeyBoardCodePage, 0, 
					psz, lpRCS->dwCompStrOffset, pwsz, cchReconvert);

				dwCompStrLen = MultiByteToWideChar(_uKeyBoardCodePage, 0, 
					psz+lpRCS->dwCompStrOffset, lpRCS->dwCompStrLen, pwsz, cchReconvert);
				
				Assert(dwCompStrOffset > 0 || dwCompStrLen > 0);

				cpImeSelectStart = _cpReconvertStart + dwCompStrOffset;
				cpImeSelectEnd = cpImeSelectStart + dwCompStrLen;
			}
			else
				hResult = S_FALSE;
			
		}

		if (bstr)
			SysFreeString (bstr);
			
		pTextRange->Release();

		if (hResult != S_OK)
			return FALSE;
	}

	if (cpParaStart <= cpImeSelectStart && cpImeSelectEnd <= cpParaEnd)
	{
		if (_pTextSel && (cpImeSelectStart != cpMin || cpImeSelectEnd != cpMax))
		{
			// IME changes selection.
			hResult	= _pTextSel->SetRange(cpImeSelectStart, cpImeSelectEnd);

			if (hResult != NOERROR)
				return FALSE;
		}
		return TRUE;		// Allow Ime to change selection
	}

	return FALSE;
}

/* 
 *  BOOL  CTextMsgFilter::GetTxSelection()
 *
 *	@mfunc
 *	 	Get Selection if we haven't got it before
 *
 *	@rdesc
 *		TRUE if this is first time getting the selection
 *		FALSE if it is already exist or no selection available.
 */
BOOL  CTextMsgFilter::GetTxSelection()
{
	HRESULT hResult;

	if (_pTextSel)
		return FALSE;					// Already there

	hResult = _pTextDoc->GetSelectionEx(&_pTextSel);

	return _pTextSel ? TRUE : FALSE;
}

/*
 *	HRESULT CTextMsgFilter::OnIMEQueryPos(UINT *, WPARAM *, LPARAM *, LRESULT *, BOOL)
 *
 *	@mfunc
 *		Fill in the current character size and window rect. size.  
 *
 *	@rdesc
 *		S_OK
 *		*plres = 0 if we do not filled in data
 */
HRESULT CTextMsgFilter::OnIMEQueryPos( 
		UINT *		pmsg,
        WPARAM *	pwparam,
		LPARAM *	plparam,
		LRESULT *	plres,
		BOOL		fUnicode)		
{
	HRESULT				hResult;
	PIMECHARPOSITION	pIMECharPos = (PIMECHARPOSITION)*plparam;
	long				cpRequest;
	RECT				rcArea;
	ITextRange			*pTextRange = NULL;
	POINT				ptTopPos, ptBottomPos = {0, 0};
	bool				fGetBottomPosFail = false;

	if (pIMECharPos->dwSize != sizeof(IMECHARPOSITION))
		goto Exit;

	// NT doesn't support Ansi window when the CP_ACP isn't the same
	// as keyboard codepage.
	if (!fUnicode && !(W32->OnWin9x()) && _uKeyBoardCodePage != _uSystemCodePage)
		goto Exit;

	if (IsIMEComposition() && _ime->GetIMELevel() == IME_LEVEL_3)
	{
		cpRequest = ((CIme_Lev3 *)_ime)->GetIMECompositionStart();
		if (fUnicode)
			cpRequest += pIMECharPos->dwCharPos;
		else if (pIMECharPos->dwCharPos > 0)
		{
			// Need to convert pIMECharPos->dwCharPos from Acp to Cp
			long	cchComp = ((CIme_Lev3 *)_ime)->GetIMECompositionLen();
			long	cchAcp = (long)(pIMECharPos->dwCharPos);
			BSTR	bstr;
			WCHAR	*pChar;

			if (cchComp)
			{
				hResult = _pTextDoc->Range(cpRequest, cpRequest+cchComp, &pTextRange);
				
				Assert (pTextRange != NULL);				
				if (hResult != NOERROR || !pTextRange)
					goto Exit;
				
				hResult = pTextRange->GetText(&bstr);
				if (hResult != NOERROR )
					goto Exit;

				// The algorithm assumes that for a DBCS charset any character
				// above 128 has two bytes, except for the halfwidth KataKana,
				// which are single bytes in ShiftJis.
				pChar = (WCHAR *)bstr;
				Assert (pChar);

				while (cchAcp > 0 && cchComp > 0)
				{
					cchAcp--;
					if(*pChar >= 128 && (CP_JAPAN != _uKeyBoardCodePage ||
						!IN_RANGE(0xFF61, *pChar, 0xFF9F)))
						cchAcp--;

					pChar++;
					cchComp--;
					cpRequest++;
				}

				SysFreeString (bstr);
				pTextRange->Release();
				pTextRange = NULL;
			}
		}
	}
	else if (pIMECharPos->dwCharPos == 0)
	{
		// Get current selection
		hResult	= _pTextSel->GetStart(&cpRequest);
		if (hResult != NOERROR)
			goto Exit;
	}
	else
		goto Exit;

	// Get requested cp location in screen coordinates
	hResult = _pTextDoc->Range(cpRequest, cpRequest+1, &pTextRange);
	Assert (pTextRange != NULL);	
	if (hResult != NOERROR || !pTextRange)
		goto Exit;
	
	hResult = pTextRange->GetPoint( tomStart+TA_TOP+TA_LEFT,
			&(ptTopPos.x), &(ptTopPos.y) );

	if (hResult != NOERROR)
	{
		// Scroll and try again
		hResult = pTextRange->ScrollIntoView(tomStart);
		if (hResult == NOERROR)
			hResult = pTextRange->GetPoint( tomStart+TA_TOP+TA_LEFT,
				&(ptTopPos.x), &(ptTopPos.y) );
	}

	if (hResult == NOERROR)
	{
		hResult = pTextRange->GetPoint( tomStart+TA_BOTTOM+TA_LEFT,
				&(ptBottomPos.x), &(ptBottomPos.y) );
		if (hResult != NOERROR)
			fGetBottomPosFail = true;
	}

	pIMECharPos->pt = ptTopPos;

	// Get application rect in screen coordinates
	hResult = _pTextDoc->GetClientRect(tomIncludeInset,
				&(rcArea.left), &(rcArea.top),
				&(rcArea.right), &(rcArea.bottom));	

	if (hResult != NOERROR)
		goto Exit;

	// Get line height in pixel
	if (fGetBottomPosFail)
		pIMECharPos->cLineHeight = rcArea.bottom - ptTopPos.y;
	else
		pIMECharPos->cLineHeight = ptBottomPos.y - ptTopPos.y;	

	pIMECharPos->rcDocument = rcArea;

	*plres = TRUE;

Exit:
	if (pTextRange)
		pTextRange->Release();

	return S_OK;
}

/*
 *	CTextMsgFilter::CheckIMEType(HKL hKL)
 *
 *	@mfunc
 *		Check for MSIME98 or later
 *
 */
void CTextMsgFilter::CheckIMEType(
	HKL	hKL)
{
	
	if (!hKL)
		hKL = GetKeyboardLayout(0x0FFFFFFFF);				// Get default HKL if caller pass in NULL

	// initialize to non MS IME
	_fMSIME	= 0;

	if (IsFELCID((WORD)hKL))
	{
		// Check what kind of IME user selected
		if (MSIMEServiceMsg && IMEMessage( *this, MSIMEServiceMsg, 0, 0, FALSE ))
			_fMSIME = 1;

	}
}

/*
 *	CTextMsgFilter::InputFEChar(WCHAR	wchFEChar)
 *
 *	@mfunc
 *		Input the FE character and ensure we have a correct font.
 *
 *	@rdesc
 *		S_OK if handled
 */
HRESULT CTextMsgFilter::InputFEChar(
	WCHAR	wchFEChar)
{
	BOOL	bReleaseSelction = GetTxSelection();
	long	cchExced;
	HRESULT	hr = S_FALSE;
	
	if (wchFEChar > 256 
		&& _pTextSel->CanEdit(NULL) == NOERROR
		&& _pTextDoc->CheckTextLimit(1, &cchExced) == NOERROR
		&& cchExced == 0)
	{
		// setup FE font to handle the FE character
		long		cpMin, cpMax;
		TCHAR		wchFE[2];
		BOOL		fSelect = FALSE;
		ITextRange	*pTextRange = NULL;
		ITextFont	*pTextFont = NULL;
		ITextFont	*pFEFont = NULL;
		HRESULT		hResult = S_FALSE;
		BSTR		bstr = NULL;

		// Inform client IME compostion is on to by-pass some font setting
		// problem in Arabic systems
		_pTextDoc->IMEInProgress(tomTrue);

		wchFE[0] = wchFEChar;
		wchFE[1] = L'\0';				
		
		_pTextSel->GetStart(&cpMin);
		_pTextSel->GetEnd(&cpMax);
		
		// For selection case, we want font to the right of first character
		if (cpMin != cpMax)
		{
			hResult = _pTextDoc->Range(cpMin, cpMin, &pTextRange);
			if (hResult != S_OK)
				goto ERROR_EXIT;

			hResult = pTextRange->GetFont(&pTextFont);

			cpMin++;
			fSelect = TRUE;
		}
		else
			hResult = _pTextSel->GetFont(&pTextFont);

		// Get a duplicate font and setup the correct FE font
		hResult = pTextFont->GetDuplicate(&pFEFont);

		if (hResult != S_OK)
			goto ERROR_EXIT;				

		CIme::CheckKeyboardFontMatching (cpMin, *this, pFEFont);
		
		if (fSelect)
			_pTextSel->SetText(NULL);		// Delete the selection

		bstr = SysAllocString(wchFE);
		if (!bstr)
		{
			hResult = E_OUTOFMEMORY;
			goto ERROR_EXIT;				
		}

		_pTextSel->SetFont(pFEFont);		// Setup FE font
		_pTextSel->TypeText(bstr);			// Input the new FE character
					
ERROR_EXIT:
		if (hResult == S_OK)
			hr = S_OK;

		if (pFEFont)
			pFEFont->Release();

		if (pTextFont)
			pTextFont->Release();

		if (pTextRange)
			pTextRange->Release();

		if (bstr)
			SysFreeString(bstr);

		// Inform client IME compostion is done
		_pTextDoc->IMEInProgress(tomFalse);
	}


	if (bReleaseSelction && _pTextSel)
	{
		_pTextSel->Release();
		_pTextSel = NULL;
	}

	return hr;
}

/*
 *	CTextMsgFilter::OnSetFocus()
 *
 *	@mfunc
 *		Restore the previous keyboard if we are in FORCEREMEMBER mode.  
 *		Otherwise, setup the FE keyboard.
 *		
 */
void CTextMsgFilter::OnSetFocus()
{
	if (!_hwnd)
		return;

	if (_fForceRemember && _fIMEHKL)
	{
		// Restore previous keyboard
		ActivateKeyboardLayout(_fIMEHKL, 0);
		if (IsFELCID((WORD)_fIMEHKL))
		{
			// Set Open status and Conversion mode
			HIMC	hIMC = ImmGetContext(_hwnd);
			if (hIMC)
			{
				if (ImmSetOpenStatus(hIMC, _fIMEEnable, _fUsingAIMM) && _fIMEEnable)
					ImmSetConversionStatus(hIMC, _fIMEConversion, _fIMESentence, _fUsingAIMM); // Set conversion status

				ImmReleaseContext(_hwnd, hIMC);
			}			
		}
	}
	else
		SetupIMEOptions();
}

/*
 *	CTextMsgFilter::OnKillFocus()
 *
 *	@mfunc
 *		If we are in FORCE_REMEMBER mode, save the current keyboard
 *	and conversion setting.
 *		
 */
void CTextMsgFilter::OnKillFocus()
{
	if (!_hwnd)
		return;

	if (_fForceRemember)
	{
		// Get current keyboard
		_fIMEHKL = GetKeyboardLayout(0x0FFFFFFFF);

		if (IsFELCID((WORD)_fIMEHKL))
		{
			// Get Open status
			HIMC	hIMC = ImmGetContext(_hwnd);
			if (hIMC)
			{
				_fIMEEnable = ImmGetOpenStatus(hIMC, _fUsingAIMM);

				if (_fIMEEnable)					
					ImmGetConversionStatus(hIMC, &_fIMEConversion, &_fIMESentence, _fUsingAIMM); // get conversion status

				ImmReleaseContext(_hwnd, hIMC);
			}			
		}
	}
}

/*
 *	CTextMsgFilter::OnSetIMEOptions(WPARAM wparam, LPARAM lparam)
 *
 *	@mfunc
 *	
 *	@rdesc
 */
LRESULT CTextMsgFilter::OnSetIMEOptions(
	WPARAM	wparam,
	LPARAM	lparam)
{
	LRESULT lIMEOptionCurrent = OnGetIMEOptions();
	LRESULT lIMEOptionNew = 0;

	// Mask off bits that we will support for now
	lparam &= (IMF_FORCEACTIVE | IMF_FORCEENABLE | IMF_FORCEREMEMBER);

	switch(wparam)
	{
	case ECOOP_SET:
		lIMEOptionNew = lparam;
		break;

	case ECOOP_OR:
		lIMEOptionNew = lIMEOptionCurrent | lparam;
		break;

	case ECOOP_AND:
		lIMEOptionNew = lIMEOptionCurrent & lparam;
		break;

	case ECOOP_XOR:
		lIMEOptionNew = lIMEOptionCurrent ^ lparam;
		break;

	default:
		return 0;		// Bad option
	}

	if (lIMEOptionNew == lIMEOptionCurrent)			// Nothing change
		return 1;

	_fForceActivate = FALSE;
	if (lIMEOptionNew & IMF_FORCEACTIVE)
		_fForceActivate = TRUE;

	_fForceEnable = FALSE;
	if (lIMEOptionNew & IMF_FORCEENABLE)
		_fForceEnable = TRUE;
	
	_fForceRemember = FALSE;
	if (lIMEOptionNew & IMF_FORCEREMEMBER)
		_fForceRemember = TRUE;

	SetupIMEOptions();

	return 1;
}

/*
 *	CTextMsgFilter::OnGetIMEOptions()
 *
 *	@mfunc
 *	
 *	@rdesc
 */
LRESULT CTextMsgFilter::OnGetIMEOptions()
{
	LRESULT		lres = 0;

	if (_fForceActivate)
		lres |= IMF_FORCEACTIVE;		

	if (_fForceEnable)
		lres |= IMF_FORCEENABLE;

	if (_fForceRemember)
		lres |= IMF_FORCEREMEMBER;

	return lres;
}

/*
 *	CTextMsgFilter::SetupIMEOptions()
 *
 *	@mfunc
 *	
 */
void CTextMsgFilter::SetupIMEOptions()
{
	if (!_hwnd)
		return;

	_uKeyBoardCodePage = GetKeyboardCodePage(0x0FFFFFFFF);	

	if (_fForceEnable)
	{		
		LONG	cpgLocale = GetACP();
		BYTE	bCharSet = (BYTE)GetCharSet(cpgLocale);	

		if (W32->IsFECodePage(cpgLocale))
		{
			if (_uKeyBoardCodePage != (UINT)cpgLocale)
				W32->CheckChangeKeyboardLayout(bCharSet);

			HIMC	hIMC = ImmGetContext(_hwnd);

			if (hIMC)
			{
				if (ImmSetOpenStatus(hIMC, TRUE, _fUsingAIMM) && _fForceActivate)
				{
					// Activate native input mode
					DWORD	dwConversion;
					DWORD	dwSentence;

					if (ImmGetConversionStatus(hIMC, &dwConversion, &dwSentence, _fUsingAIMM))
					{
						dwConversion |= IME_CMODE_NATIVE;
						if (bCharSet == SHIFTJIS_CHARSET)
							dwConversion |= IME_CMODE_FULLSHAPE;
						ImmSetConversionStatus(hIMC, dwConversion, dwSentence, _fUsingAIMM);
					}
				}
				ImmReleaseContext(_hwnd, hIMC);
			}			
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\cbhost.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	LBHOST.CPP -- Text Host for CreateWindow() Rich Edit 
 *		Combo Box Control | 
 *		Implements CCmbBxWinHost message
 *		
 *	Original Author: 
 *		Jerry Kim
 *
 *	History: <nl>
 *		01/30/97 - v-jerrki Created
 *
 *	Set tabs every four (4) columns
 *
 *	Copyright (c) 1997-1998 Microsoft Corporation. All rights reserved.
 */
#include "_common.h"
#include "_host.h"
#include "imm.h"
#include "_format.h"
#include "_edit.h"
#include "_cfpf.h"
#include "_cbhost.h"

ASSERTDATA

// Helper function in edit.cpp
LONG GetECDefaultHeightAndWidth(
	ITextServices *pts,
	HDC hdc,
	LONG lZoomNumerator,
	LONG lZoomDenominator,
	LONG yPixelsPerInch,
	LONG *pxAveWidth,
	LONG *pxOverhang,
	LONG *pxUnderhang);

// For effeciency and to avoid Winnt thunking layer we will call
// the listbox winproc directly
LRESULT CALLBACK RichListBoxWndProc(
	HWND hwnd,
	UINT msg,
	WPARAM wparam,
	LPARAM lparam);

//////////////////////////// System Window Procs ////////////////////////////
/*
 *	RichComboBoxWndProc (hwnd, msg, wparam, lparam)
 *
 *	@mfunc
 *		Handle window messages pertinent to the host and pass others on to
 *		text services. 
 *	#rdesc
 *		LRESULT = (code processed) ? 0 : 1
 */
LRESULT CALLBACK RichComboBoxWndProc(
	HWND hwnd,
	UINT msg,
	WPARAM wparam,
	LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "RichComboBoxWndProc");

	LRESULT	lres = 1;	//signify we didn't handle the message
	HRESULT hr = S_FALSE;
	CCmbBxWinHost *phost = (CCmbBxWinHost *) GetWindowLongPtr(hwnd, ibPed);

#ifdef DEBUG
	Tracef(TRCSEVINFO, "hwnd %lx, msg %lx, wparam %lx, lparam %lx", hwnd, msg, wparam, lparam);
#endif	// DEBUG

	switch(msg)
	{
	case WM_NCCREATE:
		return CCmbBxWinHost::OnNCCreate(hwnd, (CREATESTRUCT *)lparam);

	case WM_CREATE:
		// We may be on a system with no WM_NCCREATE (e.g. WINCE)
		if (!phost)
		{
			(void) CCmbBxWinHost::OnNCCreate(hwnd, (CREATESTRUCT *) lparam);
			phost = (CCmbBxWinHost *) GetWindowLongPtr(hwnd, ibPed);
		}
		break;
		
	case WM_DESTROY:
		if(phost)
			CCmbBxWinHost::OnNCDestroy(phost);
		return 0;
	}

	if (!phost)
		return ::DefWindowProc(hwnd, msg, wparam, lparam);

	// in certain out-of-memory situations, clients may try to re-enter us 
	// with calls.  Just bail on the call if we don't have a text services
	// pointer.
	if(!phost->_pserv)
		return 0;

	// stabilize ourselves
	phost->AddRef();

	switch(msg)
	{
	case WM_MOUSEMOVE:
		if (!phost->OnMouseMove(wparam, lparam))
			break;
		goto serv;

	case WM_LBUTTONUP:
		if (!phost->OnLButtonUp(wparam, lparam))
			break;
		goto serv;

	case WM_MOUSEWHEEL:
		if (!phost->OnMouseWheel(wparam, lparam))
			break;
		goto defproc;

	case WM_LBUTTONDBLCLK:
	case WM_LBUTTONDOWN:
		if (!phost->OnLButtonDown(wparam, lparam))
			goto Exit;
		goto serv;

	case WM_COMMAND:
		if (!phost->OnCommand(wparam, lparam))
			break;
		goto serv;		

	case WM_CREATE:
		lres = phost->OnCreate((CREATESTRUCT*)lparam);
		break;
	
	case WM_KEYDOWN:
		if (!phost->OnKeyDown((WORD) wparam, (DWORD) lparam))
			break;								
		goto serv;						//  give it to text services		   

	case WM_SETTEXT:
		if (phost->_cbType != CCmbBxWinHost::kDropDown)
		{
			lres = CB_ERR;
			break;
		}
		goto serv;
		
	case WM_GETTEXT:
		GETTEXTEX gt;
		if (W32->OnWin9x() || phost->_fANSIwindow)
			W32->AnsiFilter( msg, wparam, lparam, (void *) &gt );
		goto serv;

	case WM_GETTEXTLENGTH:
		GETTEXTLENGTHEX gtl;
		if (W32->OnWin9x() || phost->_fANSIwindow)
			W32->AnsiFilter( msg, wparam, lparam, (void *) &gtl );
		goto serv;
		
	case WM_CHAR:

		if (W32->OnWin9x() || phost->_fANSIwindow)
		{
			CW32System::WM_CHAR_INFO wmci;
			wmci._fAccumulate = phost->_fAccumulateDBC != 0;
			W32->AnsiFilter( msg, wparam, lparam, (void *) &wmci );
			if (wmci._fLeadByte)
			{
				phost->_fAccumulateDBC = TRUE;
				phost->_chLeadByte = wparam << 8;
				goto Exit;					// Wait for trail byte
			}
			else if (wmci._fTrailByte)
			{
				// UNDONE:
				// Need to see what we should do in WM_IME_CHAR
				wparam = phost->_chLeadByte | wparam;
				phost->_fAccumulateDBC = FALSE;
				phost->_chLeadByte = 0;
				msg = WM_IME_CHAR;
				goto serv;
			}
			else if (wmci._fIMEChar)
			{
				msg = WM_IME_CHAR;
				goto serv;
			}
			else if (wmci._fIMEChar)
			{
				msg = WM_IME_CHAR;
				goto serv;
			}
		}
	
		if(!phost->OnChar((WORD) wparam, (DWORD) lparam))
			// processed code: break out
			break;							
		goto serv;							//  else give it to text services

	case WM_DRAWITEM:
		lres = phost->CbMessageItemHandler(NULL, ITEM_MSG_DRAWLIST, wparam, lparam);
		if (lres)
			break;
		goto defproc;

	case WM_DELETEITEM:
		lres = phost->CbMessageItemHandler(NULL, ITEM_MSG_DELETE, wparam, lparam);
		if (lres)
			break;
		goto defproc;		

	case WM_ENABLE:
		if (phost->OnEnable(wparam, lparam))
		{
			if(!wparam ^ phost->_fDisabled)
			{
				// Stated of window changed so invalidate it so it will
				// get redrawn.
				InvalidateRect(phost->_hwnd, NULL, TRUE);
				phost->SetScrollBarsForWmEnable(wparam);

				// Need to enable the listbox window
				::EnableWindow(phost->_hwndList, wparam);
			}
			phost->_fDisabled = !wparam;				// Set disabled flag
			lres = 0;							// Return value for message
		}
											// Fall thru to WM_SYSCOLORCHANGE?
	case WM_SYSCOLORCHANGE:
		//forward message to listbox first then pass to textservice
		SendMessage(phost->_hwndList, msg, wparam, lparam);
		phost->OnSysColorChange();
		goto serv;							// Notify text services that
											//  system colors have changed
	case WM_GETDLGCODE:
		//forward message to listbox first then pass to textservice
		SendMessage(phost->_hwndList, msg, wparam, lparam);
		lres = phost->OnGetDlgCode(wparam, lparam);
		break;

    case WM_STYLECHANGING:
		// Just pass this one to the default window proc
		lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
		break;
		
	case WM_SIZE:
		lres = phost->OnSize(wparam, lparam);
		break;

	case WM_SETCURSOR:
		//	Only set cursor when over us rather than a child; this
		//	helps prevent us from fighting it out with an inplace child
		if((HWND)wparam == hwnd)
		{
			if(!(lres = ::DefWindowProc(hwnd, msg, wparam, lparam)))
				lres = phost->OnSetCursor(wparam, lparam);
		}
		break;

	case WM_SHOWWINDOW:
		hr = phost->OnTxVisibleChange((BOOL)wparam);
		break;

	case WM_NCPAINT:
		lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
		if(phost->TxGetEffects() == TXTEFFECT_SUNKEN && dwMajorVersion < VERS4)
		{
			HDC hdc = GetDC(hwnd);
			if(hdc)
			{
				phost->DrawSunkenBorder(hwnd, hdc);
				ReleaseDC(hwnd, hdc);
			}
		}		
		break;

	case WM_PAINT:
		lres = phost->OnPaint(wparam, lparam);
		break;

	case WM_KILLFOCUS:
		lres = phost->OnKillFocus(wparam, lparam);
		if (!lres)
			goto serv;
		goto defproc;

	case LBCB_TRACKING:
		// release any mousedown stuff
		phost->OnLButtonUp(0, 0);
		phost->_fFocus = 1;
		phost->_fLBCBMessage = 1;
		// Fall through case!!!
		
	case WM_SETFOCUS:
		lres = phost->OnSetFocus(wparam, lparam);		
		if (lres)
			goto defproc;
		goto serv;

	case WM_SYSKEYDOWN:
		if (phost->OnSyskeyDown((WORD)wparam, (DWORD)lparam))
			goto serv;
		break;

	case WM_CAPTURECHANGED:
		if (!phost->OnCaptureChanged(wparam, lparam))
			goto serv;
		break;
		
	//bug fix #4076
	case CB_GETDROPPEDSTATE:
		lres = phost->_fListVisible;
		goto Exit;

	// combo box messages
	case CB_GETEXTENDEDUI:
		lres = phost->CbGetExtendedUI();
		break;

	case CB_SETEXTENDEDUI:
		lres = phost->CbSetExtendedUI(wparam);
		break;
	
    case CB_SETITEMHEIGHT:
		lres = phost->CbSetItemHeight((wparam == (unsigned)-1) ? TRUE : FALSE, (int)lparam);
		break;

	case CB_GETITEMHEIGHT:
		lres = phost->CbGetItemHeight((wparam == (unsigned)-1) ? TRUE : FALSE);
		break;

// Listbox specific messages
    case CB_DELETESTRING:
    	msg = LB_DELETESTRING;
    	goto deflstproc;

    case CB_SETTOPINDEX:
    	msg = LB_SETTOPINDEX;
    	goto deflstproc;

    case CB_GETTOPINDEX:
    	msg = LB_GETTOPINDEX;
    	goto deflstproc;
 
    case CB_GETCOUNT:
    	msg = LB_GETCOUNT;
    	goto deflstproc;
    	
    case CB_GETCURSEL:
    	msg = LB_GETCURSEL;
    	goto deflstproc;
    	
    case CB_GETLBTEXT:
    	msg = LB_GETTEXT;
    	goto deflstproc;
    	
    case CB_GETLBTEXTLEN:
    	msg = LB_GETTEXTLEN;
    	goto deflstproc;
    	
    case CB_INSERTSTRING:
    	msg = LB_INSERTSTRING;
    	goto deflstproc;
    	
    case CB_RESETCONTENT:
    	msg = LB_RESETCONTENT;
    	goto deflstproc;

    case CB_FINDSTRING:
    	msg = LB_FINDSTRING;
    	goto deflstproc;

    case CB_FINDSTRINGEXACT:
    	msg = LB_FINDSTRINGEXACT;
    	goto deflstproc;

    case CB_SELECTSTRING:
    	//bug fix
    	// The system control does 2 things here.  1) selects the requested item
    	// 2) sets the newly selected item to the top of the list
    	lres = CB_ERR;
    	if (phost->_hwndList)
    	{
    		lres = RichListBoxWndProc(phost->_hwndList, LB_SELECTSTRING, wparam, lparam);
    		phost->UpdateEditBox();
    	}
    	break;    	

    case CB_GETITEMDATA:
    	msg = LB_GETITEMDATA;
    	goto deflstproc;

    case CB_SETITEMDATA:
    	msg = LB_SETITEMDATA;
    	goto deflstproc;

    case CB_SETCURSEL:
    	//bug fix
    	// The system control does 2 things here.  1) selects the requested item
    	// 2) sets the newly selected item to the top of the list
    	if (phost->_hwndList)
    	{
    		lres = RichListBoxWndProc(phost->_hwndList, LB_SETCURSEL, wparam, lparam);
    		if (lres != -1)
    			RichListBoxWndProc(phost->_hwndList, LB_SETTOPINDEX, wparam, 0);
    		phost->UpdateEditBox();
    	}
    	break;

	case CB_ADDSTRING:
		msg = LB_ADDSTRING;
		goto deflstproc;

// edit box specific messages
    case CB_GETEDITSEL:
		msg = EM_GETSEL;
		goto serv;

    case CB_LIMITTEXT:
		msg = EM_SETLIMITTEXT;
		goto serv;    	
    
    case CB_SETEDITSEL:
    	if (phost->_cbType == CCmbBxWinHost::kDropDownList)
    	{
    	    lres = CB_ERR;
    		break;
    	}
    	msg = EM_SETSEL;
		// When we are in a dialog box that is empty, EM_SETSEL will not select
		// the final always existing EOP if the control is rich.
		if (phost->_fUseSpecialSetSel &&
			((CTxtEdit *)phost->_pserv)->GetAdjustedTextLength() == 0 &&
			wparam != -1)
		{
			lparam = 0;
			wparam = 0;
		}
		else
		{			
			//parameters are different between CB and EM messages
			wparam = (WPARAM)(signed short)LOWORD(lparam);
			lparam = (LPARAM)(signed short)HIWORD(lparam);
		}
		goto serv;

	
	case EM_SETMARGINS:  //PPT uses this message for the combo box. bug fix #4072
		// We need to keep track of the margins size because we have a minimum inset
		// value bug fix #4659
		if (wparam & EC_LEFTMARGIN)
			phost->_dxLOffset = LOWORD(lparam);
		if (wparam & EC_RIGHTMARGIN)
			phost->_dxROffset = HIWORD(lparam);
		phost->OnSetMargins(wparam, LOWORD(lparam) + phost->_dxLInset, 
			HIWORD(lparam) + phost->_dxRInset);
		break;
		
	case EM_GETOPTIONS:
		lres = phost->OnGetOptions();
		break;
		
	case EM_SETOPTIONS:
		phost->OnSetOptions((WORD) wparam, (DWORD) lparam);
		lres = (phost->_dwStyle & ECO_STYLES);
		if(phost->_fEnableAutoWordSel)
			lres |= ECO_AUTOWORDSELECTION;
		break;

	case EM_HIDESELECTION:
		if(lparam)
		{
			DWORD dwPropertyBits = 0;

			phost->_dwStyle |= ES_NOHIDESEL;
			if(wparam)
			{
				phost->_dwStyle &= ~ES_NOHIDESEL;
				dwPropertyBits = TXTBIT_HIDESELECTION;
			}

			// Notify text services of change in status.
			phost->_pserv->OnTxPropertyBitsChange(TXTBIT_HIDESELECTION, 
				dwPropertyBits);
		}
		goto serv;

	case EM_GETPASSWORDCHAR:
#ifndef NOACCESSIBILITY    
		lres = 0;
		break;
#endif

	// We should ignore any EM_ messages which we don't handle ourselves
	case EM_SETPALETTE:
	case EM_GETRECT:
	case EM_SETBKGNDCOLOR:
	case EM_SETPASSWORDCHAR:
	case EM_SETREADONLY:
	case EM_SETRECTNP:							
	case EM_SETRECT:	
    case CB_GETDROPPEDCONTROLRECT:
    case CB_SETDROPPEDWIDTH:
    case CB_GETDROPPEDWIDTH:
    case CB_INITSTORAGE:
    case CB_GETHORIZONTALEXTENT:
    case CB_SETHORIZONTALEXTENT:        
    case CB_SETLOCALE:
    case CB_GETLOCALE:
		AssertSz(FALSE, "Message not supported");
		//FALL THROUGH!!!

	case WM_STYLECHANGED:
		break;

	case EM_SETTEXTEX:
		phost->OnSetTextEx(wparam, lparam);
		break;

    case CB_SHOWDROPDOWN:
        if (wparam && !phost->_fListVisible)
        {
            phost->ShowListBox(TRUE);
        }
        else if (!wparam && phost->_fListVisible)
        {
            phost->HideListBox(TRUE, FALSE);
        }
        break;

#ifndef NOACCESSIBILITY        
	case WM_GETOBJECT:	
		IUnknown* punk;
		phost->QueryInterface(IID_IUnknown, (void**)&punk);
		Assert(punk);
		lres = W32->LResultFromObject(IID_IUnknown, wparam, (LPUNKNOWN)punk);
		AssertSz(!FAILED((HRESULT)lres), "WM_GETOBJECT message FAILED\n");
		punk->Release();
		break;
#endif		
		
	default:
		//CTxtWinHost message handler
serv:
		hr = phost->_pserv->TxSendMessage(msg, wparam, lparam, &lres);

defproc:
		if(hr == S_FALSE)
		{			
			// Message was not processed by text services so send it
			// to the default window proc.
			lres = ::DefWindowProc(hwnd, msg, wparam, lparam);
		}

		// Need to do some things after we send the message to ITextService
		switch (msg)
		{
		case EM_SETSEL:
			phost->_pserv->TxSendMessage(EM_HIDESELECTION, 0, 0, NULL);
			lres = 1;
			break;

		// Need to return 1 per SDK documentation
		case EM_SETLIMITTEXT:
			lres = 1;
			break;

		case WM_SETFONT:
		{
			// Special border processing. The inset changes based on the size of the
			// defautl character set. So if we got a message that changes the default
			// character set, we need to update the inset.
			// Update our font height member variable with the new fonts height
			// Get the inset information
			HDC hdc = GetDC(hwnd);
			LONG xAveCharWidth = 0;
			LONG yCharHeight = GetECDefaultHeightAndWidth(phost->_pserv, hdc, 1, 1,
				W32->GetYPerInchScreenDC(), &xAveCharWidth, NULL, NULL);
			ReleaseDC(hwnd, hdc);

			if (yCharHeight)
				phost->_dyFont = yCharHeight;

			// force a recalculation of the edit control
			phost->_dyEdit = 0;
			phost->CbCalcControlRects(&phost->_rcWindow, TRUE);

			// force a resize of the control
			phost->_fListVisible = 1;
			phost->HideListBox(FALSE, FALSE);
		}
			goto deflstproc;
			
		case EM_FORMATRANGE:
		case EM_SETPARAFORMAT:
		case EM_SETCHARFORMAT:
		case EM_SETLANGOPTIONS:
		case EM_SETBIDIOPTIONS:
		case EM_SETTYPOGRAPHYOPTIONS:
			goto deflstproc;			
		}
		break;

deflstproc:
		//CLstBxWinHost message handler
		Assert(phost->_hwndList);
		if (phost->_hwndList)
		{
			lres = SendMessage(phost->_hwndList, msg, wparam, lparam);
			
			switch (msg)
			{
			case LB_RESETCONTENT:
				//need to remove the content from the edit box
				phost->_pserv->TxSendMessage(WM_SETTEXT, wparam, NULL, &lres);
				break;

			case LB_SETCURSEL:
				// need to update the edit control
				phost->UpdateEditBox();
				break;	
			}
		}
		break;				
	}	

Exit:
	phost->Release();
	return lres;
}


//////////////// CCmbBxWinHost Creation/Initialization/Destruction ///////////////////////
#ifndef NOACCESSIBILITY
/*
 *	CCmbBxWinHost::QueryInterface(REFIID riid, void **ppv)
 *
 *	@mfunc
 *		
 */
HRESULT CCmbBxWinHost::QueryInterface(REFIID riid, void **ppv)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CTxtWinHost::QueryInterface");
  
  	if(riid == IID_IAccessible)
		*ppv = (IAccessible*)this;
    else if (riid == IID_IDispatch)
		*ppv = (IDispatch*)(IAccessible*)this;
    else if (IsEqualIID(riid, IID_IUnknown))
		*ppv = (IUnknown*)(IAccessible*)this;
    else
        return CTxtWinHost::QueryInterface(riid, ppv);

	AddRef();		
	return NOERROR;
}
#endif

/*
 *	CCmbBxWinHost::OnNCCreate (hwnd, pcs)
 *
 *	@mfunc
 *		Static global method to handle WM_NCCREATE message (see remain.c)
 */
LRESULT CCmbBxWinHost::OnNCCreate(
	HWND hwnd,
	const CREATESTRUCT *pcs)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnNCCreate");


	CCmbBxWinHost *phost = new CCmbBxWinHost();

	if (!phost)
	{
		// Allocation failure.
		return 0;
	}

	if(!phost->Init(hwnd, pcs))					// Stores phost in associated
	{											//  window data
		phost->Shutdown();
		delete phost;
		return 0;
	}
	return TRUE;
}

/*
 *	CCmbBxWinHost::OnNCDestroy (phost)
 *
 *	@mfunc
 *		Static global method to handle WM_NCCREATE message
 *
 *	@devnote
 *		phost ptr is stored in window data (GetWindowLongPtr())
 */
void CCmbBxWinHost::OnNCDestroy(
	CCmbBxWinHost *phost)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnNCDestroy");

	// NOTE:
	//	We have to be careful when we destroy the window because there can be cases
	// when we have a valid hwnd but no host for the hwnd so we have to check for
	// both cases

	if (phost->_plbHost)
	{
		// ALERT!! :The DestroyWindow function does not send the WM_NCDESTROY message for Windows CE		
		phost->_plbHost->Release();
	}
		
	// Destroy list box here so we will get the WM_DELETEITEM before the
	// combo box gets destroyed
	if (phost->_hwndList)
		DestroyWindow(phost->_hwndList);

	phost->Shutdown();
	phost->Release();
	
}

/*
 *	CCmbBxWinHost::CCmbBxWinHost()
 *
 *	@mfunc
 *		constructor
 */
CCmbBxWinHost::CCmbBxWinHost(): CTxtWinHost(), _plbHost(NULL), _hwndList(NULL), _hcurOld(NULL)
{
	_dxLInset = _dxRInset = 0;
	_fIgnoreUpdate = 0;
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::CTxtWinHost");
}

/*
 *	CCmbBxWinHost::~CCmbBxWinHost()
 *
 *	@mfunc
 *		destructor
 */
CCmbBxWinHost::~CCmbBxWinHost()
{
}

/*
 *	CCmbBxWinHost::Init (hwnd, pcs)
 *
 *	@mfunc
 *		Initialize this CCmbBxWinHost
 */
BOOL CCmbBxWinHost::Init(
	HWND hwnd,					//@parm Window handle for this control
	const CREATESTRUCT *pcs)	//@parm Corresponding CREATESTRUCT
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::Init");

	if(!pcs->lpszClass)
		return -1;
		
	_fRightAlign = 0;
	_fListVisible = 0;
	_fOwnerDraw = 0;
	_fFocus = 0;
	_fMousedown = 0;
	_cyList = 0;
	_fDisabled = 0;
	_fNoIntegralHeight = 0;
	_idCtrl = (UINT)(DWORD_PTR) pcs->hMenu;
	_fKeyMaskSet = 0;
	_fMouseMaskSet = 0;
	_fScrollMaskSet = 0;
	_fMousedown = 0;
	_nCursor = -2;
	_fExtendedUI = 0;
	_fLBCBMessage = 0;
	_dxROffset = _dxLOffset = 0;

	// Set pointer back to CCmbBxWinHost from the window
	if(hwnd)
		SetWindowLongPtr(hwnd, ibPed, (INT_PTR)this);
		
	_hwnd = hwnd;

	if(pcs)
	{
		_hwndParent = pcs->hwndParent;
		_dwExStyle	= pcs->dwExStyle;
		_dwStyle	= pcs->style;

		// We need to change our Extended because we don't support most of them
		DWORD dwExStyle = _dwExStyle & (WS_EX_LEFTSCROLLBAR | WS_EX_TOPMOST | WS_EX_RIGHT |
							WS_EX_RTLREADING | WS_EX_CLIENTEDGE); 
		//	NOTE:
		//	  The order in which we check the style flags immulate
		//	WinNT's order.  So please verify with NT order before
		//	reaaranging order.
		if (_dwStyle & CBS_DROPDOWN)
		{
			_cbType = kDropDown;
			if (_dwStyle & CBS_SIMPLE)
				_cbType = kDropDownList;
		}
		else
		{
			AssertSz(FALSE, "CBS_SIMPLE not supported");
		}

		if (_dwStyle & CBS_OWNERDRAWFIXED)
			_fOwnerDraw = 1;
			
		if (_dwStyle & WS_DISABLED)
			_fDisabled = 1;

		if (_dwStyle & CBS_NOINTEGRALHEIGHT)
			_fNoIntegralHeight = 1;

		// the combobox doesn't support ES_RIGHT because its value is the 
		// same as CBS_DROPDOWN!!
		if (_dwExStyle & WS_EX_RIGHT)
		{
			_fRightAlign = 1;
			_dwStyle |= ES_RIGHT;
		}

		// implicitly set the ES_AUTOHSCROLL style bit
		_dwStyle |= ES_AUTOHSCROLL;				
		_dwStyle &= ~ES_AUTOVSCROLL;

		// If we have any kind of border it will always be a 3d border
		if (_dwStyle & WS_BORDER || _dwExStyle & WS_EX_CLIENTEDGE)
		{
			_fBorder = 1;
			_dwStyle &= ~WS_BORDER;
			_dwExStyle |= WS_EX_CLIENTEDGE;
			dwExStyle |= WS_EX_CLIENTEDGE;
		}

		// handle default disabled
		if(_dwStyle & WS_DISABLED)
			_fDisabled = TRUE;

		DWORD dwStyle = _dwStyle;
		// Remove the verticle scroll style for the window
		if (_dwStyle & WS_VSCROLL)
			dwStyle &= ~WS_VSCROLL;

        // Set the window styles
        SetWindowLong(_hwnd, GWL_STYLE, dwStyle);
        SetWindowLong(_hwnd, GWL_EXSTYLE, dwExStyle);
	}

	// Create Text Services component
	if(FAILED(CreateTextServices()))
		return FALSE;

	_xInset = 1;
	_yInset = 1;

	PARAFORMAT PF2;	
	PF2.dwMask = 0;
	if(_dwExStyle & WS_EX_RIGHT)
	{
		PF2.dwMask |= PFM_ALIGNMENT;
		PF2.wAlignment = (WORD)(PFA_RIGHT);	// right or center-aligned
	}

	if(_dwExStyle & WS_EX_RTLREADING)
	{
		PF2.dwMask |= PFM_RTLPARA;
		PF2.wEffects = PFE_RTLPARA;		// RTL reading order
	}

	if (PF2.dwMask)
	{
		PF2.cbSize = sizeof(PARAFORMAT2);
		//  tell text services
		_pserv->TxSendMessage(EM_SETPARAFORMAT, SPF_SETDEFAULT, (LPARAM)&PF2, NULL);
	}
	
	PARAFORMAT PF;							// If left or right alignment,
	if(_fRightAlign)				//  tell text services
	{
		PF.cbSize = sizeof(PARAFORMAT);
		PF.dwMask = PFM_ALIGNMENT;
		PF.wAlignment = (WORD)PFA_RIGHT;
		_pserv->TxSendMessage(EM_SETPARAFORMAT, SPF_SETDEFAULT, (LPARAM)&PF, NULL);
	}

	//bug fix #4644 we want the EN_CHANGE and EN_UPDATE notifications
	_pserv->TxSendMessage(EM_SETEVENTMASK, 0, ENM_UPDATE | ENM_CHANGE, NULL);

	// Tell textservices to turn-on auto font sizing
	_pserv->TxSendMessage(EM_SETLANGOPTIONS, 0, 
			IMF_AUTOKEYBOARD | IMF_AUTOFONT | IMF_AUTOFONTSIZEADJUST | IMF_UIFONTS |
			IMF_IMEALWAYSSENDNOTIFY, NULL);
			
	
	return TRUE;
}


/*
 *	CCmbBxWinHost::OnCreate (pcs)
 *
 *	@mfunc
 *		Handle WM_CREATE message
 *
 *	@rdesc
 *		LRESULT = -1 if failed to in-place activate; else 0
 */
LRESULT CCmbBxWinHost::OnCreate(const CREATESTRUCT *pcs)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnCreate");

	RECT rcClient;

	// sometimes, these values are -1 (from windows itself); just treat them
	// as zero in that case
	LONG cy = (pcs->cy < 0) ? 0 : pcs->cy;
	LONG cx = (pcs->cx < 0) ? 0 : pcs->cx;

	rcClient.top = pcs->y;
	rcClient.bottom = rcClient.top + cy;
	rcClient.left = pcs->x;
	rcClient.right = rcClient.left + cx;

	// Notify Text Services that we are in place active
	if(FAILED(_pserv->OnTxInPlaceActivate(&rcClient)))
		return -1;	

	// Get the font height to base the control heights from
	// Initially the font height is the item height	
	HDC hdc = GetDC(_hwnd);	
	LONG xAveCharWidth = 0;
	_dyFont = GetECDefaultHeightAndWidth(_pserv, hdc, 1, 1,
		W32->GetYPerInchScreenDC(), &xAveCharWidth, NULL, NULL);
	Assert(_dyFont != 0); // _yInset should be zero since listbox's doesn't have yinsets

	ReleaseDC(_hwnd, hdc);
	
	
	// init variables
	_idCtrl = (UINT)(DWORD_PTR)pcs->hMenu;

	// Need to calculate the rects of EVERYTHING!!
	// Force a request of itemHeight
	_rcButton.left = 0;
	_dyEdit = 0;
	_cyList = -1;
	CbCalcControlRects(&rcClient, TRUE);

	// Now lets handle the listbox stuff!
	// create and tranlate styles for combo box to listbox
	DWORD lStyle = WS_BORDER | WS_CHILD | WS_VISIBLE | LBS_NOTIFY | LBS_COMBOBOX | WS_CLIPSIBLINGS;
	if (_dwStyle & CBS_HASSTRINGS)
		lStyle |= LBS_HASSTRINGS;

	if (_dwStyle & CBS_SORT)
		lStyle |= LBS_SORT;

	if (_dwStyle & CBS_DISABLENOSCROLL)
		lStyle |= LBS_DISABLENOSCROLL;

	if (_dwStyle & CBS_NOINTEGRALHEIGHT)
		lStyle |= LBS_NOINTEGRALHEIGHT;

	if (_dwStyle & CBS_OWNERDRAWFIXED)
	{
		_fOwnerDraw;
		lStyle |= LBS_OWNERDRAWFIXED;
	}

	// copy over some window styles
	lStyle |= (_dwStyle & WS_DISABLED);
	lStyle |= (_dwStyle & WS_VSCROLL);
	
	DWORD lExStyle = _dwExStyle & (WS_EX_RIGHT | WS_EX_RTLREADING | WS_EX_LEFTSCROLLBAR);

	//NOTE. It doesn't matter if the listbox is made with the correct size since
	// it's going to get resized anyways
	if (!W32->OnWin9x())
	{
		//WinNT
		_hwndList = ::CreateWindowExW(lExStyle | WS_EX_TOOLWINDOW, L"REListBox20W", 
					NULL, lStyle, _rcList.left, _rcList.top, _rcList.right - _rcList.left,
					_rcList.bottom - _rcList.top, _hwnd, (HMENU)CB_LISTBOXID, NULL, this);
	}
	else
	{
		// Win '95, '98 system
		_hwndList = ::CreateWindowExA(lExStyle | WS_EX_TOOLWINDOW, "REListBox20W", 
					NULL, lStyle, _rcList.left, _rcList.top, _rcList.right - _rcList.left,
					_rcList.bottom - _rcList.top, _hwnd, (HMENU)CB_LISTBOXID, NULL, this);
	}
	
	Assert(_hwndList);
	_plbHost = (CLstBxWinHost *) GetWindowLongPtr(_hwndList, ibPed);
	Assert(_plbHost);
	if (!_plbHost)
		return -1;
		
	// increment reference counter!
	_plbHost->AddRef();

	if (_cbType != kSimple)
		ShowWindow(_hwndList, SW_HIDE);
	SetParent(_hwndList, NULL);
				
	if (_cbType == kDropDownList)
	{			
		AssertSz(!((CTxtEdit*)_pserv)->_fReadOnly, "edit is readonly");
		
		// Tell textservices to select the entire background
		_pserv->TxSendMessage(EM_SETEDITSTYLE, SES_EXTENDBACKCOLOR, SES_EXTENDBACKCOLOR, NULL);	

		// format the paragraph to immulate the system control
		PARAFORMAT2 pf;
		pf.cbSize = sizeof(PARAFORMAT2);
		pf.dwMask = PFM_STARTINDENT;
		pf.dxStartIndent = (1440.0 / W32->GetXPerInchScreenDC());
		_pserv->TxSendMessage(EM_SETPARAFORMAT, SPF_SETDEFAULT, (LPARAM)&pf, NULL);
		_usIMEMode = ES_NOIME;
		// Tell textservices to turnoff ime
		_pserv->TxSendMessage(EM_SETEDITSTYLE, SES_NOIME, SES_NOIME, NULL);	

	}
	else
	{
		// make the richedit control behave like the edit control		
		_pserv->TxSendMessage(EM_SETEDITSTYLE, SES_EMULATESYSEDIT, SES_EMULATESYSEDIT, NULL);
	}

	// Need to resize the list box
	if (_cbType != kSimple)
		SetDropSize(&_rcList);

	return 0;
}


/////////////////////////// CCmbBxWinHost Helper functions /////////////////////////////////
/*
 *	CCmbBxWinHost::GetTextLength ()
 *
 *	@mfunc
 *		returns the text length of the edit control using CR and NOT CRLF
 *
 *	@rdesc
 *		LRESULT = text length
 */
 LRESULT CCmbBxWinHost::GetTextLength()
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::GetTextLength");
 	
 	LRESULT lr = 0;
	GETTEXTLENGTHEX gtl;
	gtl.flags = GTL_NUMCHARS | GTL_PRECISE;
	gtl.codepage = 1200;

#ifdef DEBUG
	HRESULT hr = _pserv->TxSendMessage(EM_GETTEXTLENGTHEX, (WPARAM)&gtl, 0, &lr);
	Assert(hr == NOERROR);
#else
	_pserv->TxSendMessage(EM_GETTEXTLENGTHEX, (WPARAM)&gtl, 0, &lr);
#endif
	return lr;
 }

/*
 *	CCmbBxWinHost::GetEditText (LPTSTR, int)
 *
 *	@mfunc
 *		returns the text length in the edit control in UNICODE
 *
 *	@rdesc
 *		LRESULT = text length copied to passed in buffer
 */
 LRESULT CCmbBxWinHost::GetEditText (LPTSTR szStr, int nSize)
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::GetEditText");

	LRESULT lr = 0;
 	GETTEXTEX gt;
	gt.cb = nSize * sizeof(TCHAR);
	gt.flags = 0;
	gt.codepage = 1200;
	gt.lpDefaultChar = NULL;
	gt.lpUsedDefChar = NULL;

#ifdef DEBUG
	HRESULT hr = _pserv->TxSendMessage(EM_GETTEXTEX, (WPARAM)&gt, (LPARAM)szStr, &lr);
	Assert(hr == NOERROR);
#else
	_pserv->TxSendMessage(EM_GETTEXTEX, (WPARAM)&gt, (LPARAM)szStr, &lr);
#endif
	return lr;
 }
 
 
/*
 *	CCmbBxWinHost::SetDropSize(RECT* prc)
 *
 *	@mfunc
 *		Compute the drop down window's width and max height
 *
 *	@rdesc
 *		BOOL = SUCCESSFUL ? TRUE : FALSE
 */
void CCmbBxWinHost::SetDropSize(RECT* prc)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::SetDropSize");

	_fListVisible = TRUE;
	HideListBox(FALSE, FALSE);
	POINT pt1 = {prc->left, prc->top};
	POINT pt2 = {prc->right, prc->bottom};
	::ClientToScreen(_hwnd, &pt1);
	::ClientToScreen(_hwnd, &pt2);
	MoveWindow(_hwndList, pt1.x, pt1.y, pt2.x - pt1.x,
			pt2.y - pt1.y, FALSE);

}

/*
 *	CCmbBxWinHost::SetSizeEdit(int nLeft, int nTop, int nRight, int nBottom)
 *
 *	@mfunc
 *		sets the edit controls size
 *
 *	@rdesc
 *		BOOL = SUCCESSFUL ? TRUE : FALSE
 */
void CCmbBxWinHost::SetSizeEdit(int nLeft, int nTop, int nRight, int nBottom)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::SizeEdit");

	// Generate default view rect from client rect
	if(_fBorder)
	{
		// Factors in space for borders
  		_rcViewInset.top	= W32->DYtoHimetricY(nTop, W32->GetYPerInchScreenDC());
   		_rcViewInset.bottom	= W32->DYtoHimetricY(nBottom, W32->GetYPerInchScreenDC());
   		_rcViewInset.left	= W32->DXtoHimetricX(nLeft, W32->GetXPerInchScreenDC());
   		_rcViewInset.right	= W32->DXtoHimetricX(nRight, W32->GetXPerInchScreenDC());
	}
	else
	{
		// Default the top and bottom inset to 0 and the left and right
		// to the size of the border.
		_rcViewInset.top = 0;
		_rcViewInset.bottom = 0;
		_rcViewInset.left = W32->DXtoHimetricX(nLeft, W32->GetXPerInchScreenDC());
		_rcViewInset.right = W32->DXtoHimetricX(nRight, W32->GetXPerInchScreenDC());
	}
}

/*
 *	CCmbBxWinHost::CbCalcControlRects(RECT* prc, BOOL bCalcChange)
 *
 *	@mfunc
 *		Calculates the RECT for all the controls.  The rect should
 *	include the non-client area's also
 *
 *	@rdesc
 *		BOOL = SUCCESSFUL ? TRUE : FALSE
 */
BOOL CCmbBxWinHost::CbCalcControlRects(RECT* prc, BOOL bCalcChange)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::CbCalcControlRects");

	// copy over the window rect
	_rcWindow = *prc;

	// Item specific things
	const int smY = GetSystemMetrics(SM_CYEDGE);
	const int smX = GetSystemMetrics(SM_CXEDGE);
	
	_cxCombo = _rcWindow.right - _rcWindow.left;

	if (!_dyEdit)
		_dyEdit = _dyFont + 2 + ((_fBorder) ? (2 * _yInset) : 0);
	
	if (_fOwnerDraw)
	{		
		if (bCalcChange)
		{
            // No height has been defined yet for the static text window.  Send
            // a measure item message to the parent
			MEASUREITEMSTRUCT mis;
            mis.CtlType = ODT_COMBOBOX;
            mis.CtlID = _idCtrl;
            mis.itemID = (UINT)-1;
            mis.itemHeight = _dyEdit;
            mis.itemData = 0;

            SendMessage(_hwndParent, WM_MEASUREITEM, _idCtrl, (LPARAM)&mis);
			_dyEdit = mis.itemHeight;
        }
	}
	else
	{
		// NOTE:
		//	Richedit prevents us from trying to set the itemHeight less than the 
		// font height so we need to take account of this by preventing user from
		// setting height less than font height
		int nyEdit = _dyFont + ((_fBorder) ? 2 * _yInset : 0);
		if (_dyEdit > nyEdit)
		{
			//In order for the highlighting to work properly we need to empty
			//the richedit control
			LRESULT nLen;
			_pserv->TxSendMessage(WM_GETTEXTLENGTH, 0, 0, &nLen);

			TCHAR* pwch = NULL;
			if (nLen && _cbType == kDropDownList)
			{
				pwch = new TCHAR[nLen + 1 /*NULL*/];				
				AssertSz(pwch, "Unable to allocate memory for string");

				if (pwch)
				{				
					// Get the text from richedit and emtpy it
					_pserv->TxSendMessage(WM_GETTEXT, nLen + 1, (LPARAM)pwch, NULL);
					_pserv->TxSendMessage(WM_SETTEXT, 0, NULL, NULL);
				}
				else
				{
					// something bad happened so send a message
					// to client
					TxNotify(EN_ERRSPACE, NULL);	
				}
			}
			else if (_cbType == kDropDown && nLen == 0)
			{
				// we need to insert a dummy character into the richedit
				// control so it won't try to highlight space after
				// the paragraph
				_pserv->TxSendMessage(WM_SETTEXT, 0, (LPARAM)L" ", NULL);
			}
					
		 	// Calculate the difference in size
		 	nyEdit = _dyEdit - nyEdit;				 	

			PARAFORMAT2 pf;			
			pf.cbSize = sizeof(PARAFORMAT2);
			pf.dwMask = PFM_SPACEAFTER;
			pf.dySpaceAfter = (int)(((double)nyEdit * 1440.0) / (double)W32->GetYPerInchScreenDC());
			_pserv->TxSendMessage(EM_SETPARAFORMAT, SPF_SETDEFAULT, (LPARAM)&pf, NULL);

			//Reset the text which was there before in the richedit control
			if (pwch || (_cbType == kDropDown && nLen == 0))
			{
				_pserv->TxSendMessage(WM_SETTEXT, 0, (LPARAM)(pwch ? pwch : NULL), NULL);
				if (pwch)
					delete pwch;
			}
		}
		else
			_dyEdit = nyEdit;	// stabalize ourselves
	}

	// For Bordered Combobox we take account of the clientedge for the top
	// and bottom. And since we want to draw the focus rect within the yellow
	// area we need to subtract 1.
	_cyCombo = min(_dyEdit + ((_fBorder) ? 2 * smY : 0), 
				_rcWindow.bottom - _rcWindow.top); 
	
	// recompute the max height of the dropdown listbox -- full window
    // size MINUS edit/static height
    if (_cyList == -1)        
        _cyList = max((_rcWindow.bottom - _rcWindow.top) - _cyCombo, 0);

	// calculate the rect for the buttons
	if (_cbType != kSimple)
	{
		_rcButton.top = 0;
		_rcButton.bottom = min(_dyEdit, _rcWindow.bottom - _rcWindow.top);
		if (_fRightAlign)
		{
			_rcButton.left = 0;
			_rcButton.right = _rcButton.left + GetSystemMetrics(SM_CXVSCROLL);
		}
		else
		{
			_rcButton.right = _cxCombo - ((_fBorder) ? (2 * smX): 0);
			_rcButton.left = _rcButton.right - GetSystemMetrics(SM_CXVSCROLL);
		}
	}


	// calculate the edit control rect	
	int nTop = _yInset;
	int nBottom = 0;
	_dxLInset = _xInset;
	_dxRInset = _xInset;	
	if (_cbType != kSimple)
	{
		if (_fRightAlign)
			_dxLInset = (_rcButton.right - _rcButton.left) + smX;
		else
			_dxRInset = (_rcButton.right - _rcButton.left) + smX;
	}
	SetSizeEdit(_dxLInset + _dxLOffset, nTop, _dxRInset + _dxROffset, nBottom);

	// calculate the rect for the list box window
	_rcList.left = (_fBorder) ? - smX : 0;
	_rcList.top = _cyCombo - ((_fBorder) ? smY : 0);
	_rcList.right = (_fBorder) ? max(_cxCombo - smX, 0) : _rcWindow.right;
	_rcList.bottom = _cyCombo + _cyList;	

	return TRUE;
}


/*
 *	CCmbBxWinHost::DrawButton(HDC, BOOL)
 *
 *	@mfunc
 *		Draws the combo box button given an hdc
 *
 *	@rdesc
 *		BOOL = SUCCESSFUL ? TRUE : FALSE
 */
 void CCmbBxWinHost::DrawButton(HDC hdc, BOOL bDown)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::DrawButton");

	// Check if we have to draw the drop down button
    if (_cbType != kSimple) 
	{
		BOOL bRelease = !hdc;
		if (!hdc)
			hdc = TxGetDC();

        DrawFrameControl(hdc, &_rcButton, DFC_SCROLL, DFCS_SCROLLCOMBOBOX |
            (bDown ? DFCS_PUSHED | DFCS_FLAT: 0) | (!_fBorder ? DFCS_FLAT : 0) |
            (!_fDisabled ? 0 : DFCS_INACTIVE));

		if (bRelease)
			TxReleaseDC(hdc);
    }
}


/* 
 *	CCmbBxWinHost::TxNotify (iNotify,	pv)
 *
 *	@mfunc
 *		Notify Text Host of various events.  Note that there are
 *		two basic categories of events, "direct" events and 
 *		"delayed" events.  In the case of the combobox we will
 *		notify parent of only two edit notifications; EN_CHANGE 
 *		and EN_UPDATE.  The others will be from the listbox
 *		or be generated because of focus changing
 *
 *
 *	@rdesc	
 *		S_OK - call succeeded <nl>
 *		S_FALSE	-- success, but do some different action
 *		depending on the event type (see below).
 *
 *	@comm
 *		<CBN_DBLCLK> user double-clicks an item in the list box
 *
 *		<CBN_ERRSPACE> The list box cannot allocate enough memory to 
 *		fulfill a request
 *
 *		<CBN_KILLFOCUS> The list box loses the keyboard focus
 *
 *		<CBN_SELENDCANCEL> notification message is sent when the user 
 *		selects an item, but then selects another control or closes the 
 *		dialog box
 *
 *		<CBN_SELCHANGE> notification message is sent when the user changes 
 *		the current selection in the list box of a combo box
 *
 *		<CBN_SETFOCUS> The list box receives the keyboard focus
 *
 *		<CBN_CLOSEUP> This message is sent when the listbox has been closed
 *
 *		<CBN_SELENDOK> notification message is sent when the user selects a 
 *		list item, or selects an item and then closes the list
 *
 *		<CBN_EDITCHANGE> notification message is sent after the user 
 *		has taken an action that may have altered the text in the edit 
 *		control portion of a combo box
 *
 *		<CBN_EDITUPDATE> notification message is sent when the edit control 
 *		portion of a combo box is about to display altered text
 *
 *		<CBN_DROPDOWN> This message is sent when the listbox has been made visible
 */
HRESULT CCmbBxWinHost::TxNotify(
	DWORD iNotify,		//@parm	Event to notify host of.  One of the
						//		EN_XXX values from Win32, e.g., EN_CHANGE
	void *pv)			//@parm In-only parameter with extra data.  Type
						//		dependent on <p iNotify>
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CCmbBxWinHost::TxNotify");
	HRESULT hr = S_FALSE;

	if(_hwndParent)
	{
		// First, handle WM_NOTIFY style notifications
		//WPARAM LOWORD(_idCtrl) ; LPARAM - HWND(COMBO)
		switch(iNotify)
		{
		case EN_CHANGE:
			//update the listbox bug fix #5206
			if (_fIgnoreChange)
			{
				_fIgnoreChange = 0;
				return hr;
			}

			if (_fListVisible && _cbType == kDropDown)
				UpdateListBox(FALSE);
			else if (_cbType == kDropDownList)
			    // don't send notification if dropdownlist
			    return S_FALSE;
			    
			iNotify = CBN_EDITCHANGE;
			goto sndmsg;
			
		case EN_UPDATE:
			//bug fix - we're sending too much CBN_UPDATE notifications
			if (_fIgnoreUpdate)
				return hr;
			if (_cbType == kDropDownList)
			    return S_FALSE;
			    
			iNotify = CBN_EDITUPDATE;
			goto sndmsg;
			
		case EN_ERRSPACE:
			iNotify = (unsigned)CBN_ERRSPACE;
			goto sndmsg;

		case CBN_SELCHANGE: 
		case CBN_SELENDCANCEL:		
		case CBN_CLOSEUP:
		case CBN_DBLCLK:	
		case CBN_DROPDOWN:  
		case CBN_KILLFOCUS:  
		case CBN_SELENDOK:
		case CBN_SETFOCUS:
	
sndmsg:
		hr = SendMessage(_hwndParent, WM_COMMAND, 
						GET_WM_COMMAND_MPS(_idCtrl, _hwnd, iNotify));
		}		
	}
	return hr;
}

/*
 *	CCmbBxWinHost::DrawEditFocus(HDC)
 *
 *	@mfunc
 *		Either draws or notifies owner to draw the focus rect
 *
 *	@rdesc
 *		void
 */
void CCmbBxWinHost::DrawEditFocus(HDC hdc)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::DrawEditFocus");

	BOOL bRelease = FALSE;
	if (!hdc)
	{
		hdc = TxGetDC();
		bRelease = TRUE;
	}

	RECT rc;
	GetClientRect(_hwnd, &rc);

	if (!_fOwnerDraw)
	{
		HiliteEdit(_fFocus);

		if (_cbType == kDropDownList)
		{
			// shrink the focus rect by the inset
			rc.top += _yInset;
			rc.bottom -= _yInset;			
			
			if (_fRightAlign)
				rc.left = _rcButton.right;
			else
				rc.right = _rcButton.left;

			rc.left += _xInset;
			rc.right -= _xInset;

			DrawFocusRect(hdc, &rc);
		}
	}

	if (bRelease)
		TxReleaseDC(hdc);
	
}

/*
 *	CCmbBxWinHost::SetSelectionInfo(BOOL bOk, int nIdx)
 *
 *	@mfunc
 *		Completes the text in the edit box with the closest match from the
 * listbox.  If a prefix match can't be found, the edit control text isn't
 * updated. Assume a DROPDOWN style combo box.
 *
 *	@rdesc
 *		void
 */
void CCmbBxWinHost::SetSelectionInfo(BOOL bOk, int nIdx)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::SetSelectionInfo");
	

	_nCursor = nIdx;
	_bSelOk = bOk;	
}

/*
 *	CCmbBxWinHost::AutoUpdateEdit(int i)
 *
 *	@mfunc
 *		Completes the text in the edit box with the closest match from the
 * listbox.  If a prefix match can't be found, the edit control text isn't
 * updated. Assume a DROPDOWN style combo box.
 *
 *	@rdesc
 *		void
 */
void CCmbBxWinHost::AutoUpdateEdit(int nItem)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::AutoUpdateEdit");

    // We update the edit part of the combo box with the current selection of
    // the list box
	int cch;
	TCHAR* pszText;
	LRESULT lr;

	// find the best matching string in the list box
	if (nItem == -1 || nItem == -2)
	{
		cch = GetTextLength();

		// no text to search so just get out
	    if (!cch)
	    	return;

	    cch++; // account for null character
	    pszText = new TCHAR[cch];
	    AssertSz(pszText, "string allocation failed");
	    if (!pszText) 
	    {
			TxNotify((unsigned)CBN_ERRSPACE, NULL);
			return;
		}

		// get string from edit control and try to find a exact match else a match
		// in the list box
		GetEditText(pszText, cch);
		
	    nItem = RichListBoxWndProc(_hwndList, LB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)pszText);

	    if (nItem == -1)
	    	nItem = RichListBoxWndProc(_hwndList, LB_FINDSTRING, (WPARAM)-1, (LPARAM)pszText);
		delete [] pszText;

		// no match found so just get out
	    if (nItem == -1)         	
	    	return;
    }

	cch = RichListBoxWndProc(_hwndList, LB_GETTEXTLEN, nItem, 0);

	if (cch <= 0)
		return;
		
    cch++; // account for null character
    pszText = new TCHAR[cch];
	AssertSz(pszText, "Unable to allocate string");
	if (!pszText)
	{
		TxNotify((unsigned)CBN_ERRSPACE, NULL);
		return;
	}

	RichListBoxWndProc(_hwndList, LB_GETTEXT, nItem, (LPARAM)pszText);
	_fIgnoreChange = 1;
	_pserv->TxSendMessage(WM_SETTEXT, 0, (LPARAM)pszText, &lr);

   	HiliteEdit(TRUE);

    delete [] pszText;
}

/*
 *	CCmbBxWinHost::HiliteEdit(BOOL)
 *
 *	@mfunc
 *		Sets the hilite background or selects the entire text for the
 *	edit control
 *
 *	@rdesc
 *		void
 */
void CCmbBxWinHost::HiliteEdit(BOOL bSelect)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::HiliteEdit");

	//bug fix 4073
	Assert(!_fOwnerDraw || _cbType == kDropDown);

	if (_cbType != kDropDownList)
	{
		//if bSelect is true else put cursor at beginning of text
		_pserv->TxSendMessage(EM_SETSEL, 0, (LPARAM)((bSelect) ? -1 : 0), NULL);
	}
	else
	{
		//Get the range of the paragraph
		ITextRange* pRange;		
		if (NOERROR != ((CTxtEdit*)_pserv)->Range(0, 0, &pRange))
		{
			AssertSz(FALSE, "unable to get range");
			return;
		}
		Assert(pRange);

		DWORD crFore = (unsigned)tomAutoColor;
		DWORD crBack = (unsigned)tomAutoColor;
		if (bSelect)
		{
			crFore = ::GetSysColor(COLOR_HIGHLIGHTTEXT);
			crBack = ::GetSysColor(COLOR_HIGHLIGHT);
		}

		// Get the entire paragraph
		ITextFont* pFont = NULL;	

		// Select entire text
		CHECKNOERROR(pRange->SetIndex(tomParagraph, 1, 1));
		
		// Set the background and forground color
		CHECKNOERROR(pRange->GetFont(&pFont));
		
		Assert(pFont);
		CHECKNOERROR(pFont->SetBackColor(crBack));
		CHECKNOERROR(pFont->SetForeColor(crFore));

CleanExit:
		// Release pointers
		if (pFont)
			pFont->Release();
		pRange->Release();
	}
}


/*
 *	CCmbBxWinHost::UpdateEditBox()
 *
 *	@mfunc
 *		Updates the editcontrol window so that it contains the text
 * given by the current selection in the listbox.  If the listbox has no
 * selection (ie. -1), then we erase all the text in the editcontrol.
 *
 * hdc is from WM_PAINT messages Begin/End Paint hdc. If null, we should
 * get our own dc.
 *
 *	@rdesc
 *		void
 */
void CCmbBxWinHost::UpdateEditBox()
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::UpdateEditBox");

    Assert(_hwndList);
    Assert(_plbHost);

    // Update the edit box
    if (_cbType == kDropDownList && _fOwnerDraw)
    {
	   	CbMessageItemHandler(NULL, ITEM_MSG_DRAWCOMBO, 0, 0);
	   	return;
	}
    else 
    {
		TCHAR* pszText = NULL;
	   	int nItem = (signed)_plbHost->GetCursor();   	
	    if (nItem != -1)
		{
			int cch = RichListBoxWndProc(_hwndList, LB_GETTEXTLEN, (LPARAM)nItem, 0);
		    pszText = new TCHAR[cch + 1];
			AssertSz(pszText, "allocation failed");

			// just get out if memory allocation failed
			if (!pszText)
			{
				TxNotify((unsigned)CBN_ERRSPACE, NULL);
				return;
			}
			RichListBoxWndProc(_hwndList, LB_GETTEXT, (WPARAM)nItem, (LPARAM)pszText);		
		}
	
    	// if the cursor is on a valid item then update edit with the item text
    	// else we just display a blank text
    	TCHAR szEmpty[] = L"";
    	_fIgnoreChange = 1;
    	_pserv->TxSendMessage(WM_SETTEXT, 0, (LPARAM)((pszText) ? pszText : szEmpty), NULL);
   		DrawEditFocus(NULL);
    	if (pszText)
    		delete pszText;
    }
}

/*
 *	CCmbBxWinHost::UpdateListBox(BOOL)
 *
 *	@mfunc
 *		Updates the list box by searching and moving to the top the text in
 *	edit control.  And possibly pre-selecting the item if bSetSel is set
 *
 *	@rdesc
 *		int = found ? index of item : -1
 */
int CCmbBxWinHost::UpdateListBox(BOOL bSetSel)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::UpdateListBox");

    int nItem = -1;
    int nSel = -1;
	TCHAR* pszText;
	int cch;

	// Get text from edit box
    cch = GetTextLength();
    if (cch) 
    {
    	// add one for null string
        cch++;
        pszText = new TCHAR[cch];
        if (pszText != NULL) 
        {  
        	if (GetEditText(pszText, cch))
        	{
        		//Bypass Winnt thunking layer by calling the function directly
        		nItem = RichListBoxWndProc(_hwndList, LB_FINDSTRING, (WPARAM)-1L, (LPARAM)pszText);
        	}
        	delete [] pszText;        	
        }
        else
        {
			TxNotify((unsigned)CBN_ERRSPACE, NULL);
			return 0;
		}
    }

    if (bSetSel)
        nSel = nItem;

	// update the list box
    RichListBoxWndProc(_hwndList, LB_SETCURSEL, (LPARAM)nSel, 0);
	RichListBoxWndProc(_hwndList, LB_SETTOPINDEX, (LPARAM)max(nItem, 0), 0);	
    return nItem;
}


/*
 *	CCmbBxWinHost::HideListBox(BOOL, BOOL)
 *
 *	@mfunc
 *		Hides the list box
 *
 *	@rdesc
 *		void
 */
BOOL CCmbBxWinHost::HideListBox(BOOL bNotify, BOOL fSelOk)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::HideListBox");

	//send CBN_SELENDOK to all types of comboboxes but only
    // allow CBN_SELENDCANCEL to be sent for droppable comboboxes
	if (bNotify)
	{
		if (fSelOk)
		{
			TxNotify(CBN_SELENDOK, NULL);
		}
		else if (_cbType != kSimple)
		{
			TxNotify(CBN_SELENDCANCEL, NULL);
		}
	}
	
    // return, we don't hide simple combo boxes.
	if (!_fListVisible || _cbType == kSimple) 
    	return TRUE;

    // Tell the listbox to end tracking
    Assert(_plbHost);
	_plbHost->OnCBTracking(LBCBM_END, 0);     	
    
    // Hide the listbox window
    _fListVisible = 0;
    ShowWindow(_hwndList, SW_HIDE);
	if (_fCapture)
	{
		_fCapture = FALSE;
		TxSetCapture(FALSE);
	}

	_fResizing = 1;
    // Invalidate the item area now since SWP() might update stuff.
    // Since the combo is CS_VREDRAW/CS_HREDRAW, a size change will
    // redraw the whole thing, including the item rect.  But if it
    // isn't changing size, we still want to redraw the item anyway
    // to show focus/selection
    if (_cbType == kDropDownList)
	{
		if (!_fOwnerDraw)
			HiliteEdit(_fFocus);
        InvalidateRect(_hwnd, NULL, TRUE);
	}

	//bug fix
	// The button may look depressed so we must redraw the button
	if (_fMousedown)
	{
		_fMousedown = FALSE;
		InvalidateRect(_hwnd, &_rcButton, FALSE);
	}

    SetWindowPos(_hwnd, HWND_TOP, 0, 0, _cxCombo, _cyCombo, 
    	SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);

	_fResizing = 0;

	if (_cbType == kDropDown)
		AutoUpdateEdit(_nCursor);
	_nCursor = -2;

    // In case size didn't change
    UpdateWindow(_hwnd);

    if (bNotify) 
    {
        //Notify parent we will be popping up the combo box.
        TxNotify(CBN_CLOSEUP, NULL);
    }

	// reset back to old cursor if mouse cursor was set
	if (_hcurOld)
	{
		TxSetCursor2(_hcurOld, NULL);
		_hcurOld = NULL;
	}
    return(TRUE);
}



/*
 *	CCmbBxWinHost::ShowListBox(BOOL)
 *
 *	@mfunc
 *		Displays the list box
 *
 *	@rdesc
 *		void
 */
void CCmbBxWinHost::ShowListBox(BOOL fTrack)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::ShowListBox");
	
	Assert(_cbType != kSimple);
	Assert(_hwndList);

	// Notify parent window we are about to drop down the list box
	TxNotify(CBN_DROPDOWN, NULL);

	// force a redraw of the button so it looks depressed
	InvalidateRect(_hwnd, &_rcButton, TRUE);

	_fListVisible = TRUE;
	_fIgnoreChange = 0;

	_bSelOk = 0;
	if (_cbType == kDropDown)
	{
		UpdateListBox(!_fMousedown);
		if (!_fMousedown)
			AutoUpdateEdit(-1);
		_nCursor = _plbHost->GetCursor();

	}
	else
	{
        // Scroll the currently selected item to the top of the listbox.        
		int idx = (signed)_plbHost->GetCursor();
		_nCursor = idx;
		if (idx == -1)
			idx = 0;

		// set the top index if there is something in the list box
		if (_plbHost->GetCount() > 0)
			RichListBoxWndProc(_hwndList, LB_SETTOPINDEX, idx, 0);	

		// We are to lose focus in this case
		_fFocus = 0;
		if (!_fOwnerDraw)
			HiliteEdit(FALSE);
		
	    // We need to invalidate the edit rect so that the focus frame/invert
        // will be turned off when the listbox is visible.  Tandy wants this for
        // his typical reasons...        
        InvalidateRect(_hwnd, NULL, TRUE);        
    }

    // Figure out where to position the dropdown listbox.
    // We want the dropdown to pop below or above the combo
    // Get screen coords
    RECT rcList;
	POINT pt1;
    pt1.x = _rcList.left;
    pt1.y = _rcList.top;

	TxClientToScreen(&pt1);
	rcList.left = pt1.x;
	rcList.top = pt1.y;
	rcList.right = rcList.left + (_rcList.right - _rcList.left);
	rcList.bottom = rcList.top + _cyList;


    // List area
    int cyItem = _plbHost->GetItemHeight();
    AssertSz(cyItem, "LB_GETITEMHEIGHT is returning 0");

    if (cyItem == 0)
    	cyItem = _plbHost->GetFontHeight();

    // Windows NT comment:
    //  we shoulda' just been able to use cyDrop here, but thanks to VB's need
    //  to do things their OWN SPECIAL WAY, we have to keep monitoring the size
    //  of the listbox 'cause VB changes it directly (jeffbog 03/21/94)
    int iHeight = max(_cyList, _rcWindow.bottom - _rcWindow.top);
	DWORD dwMult = (DWORD)RichListBoxWndProc(_hwndList, LB_GETCOUNT, 0, 0);
	
    if (dwMult) 
    {
        dwMult = (DWORD)(LOWORD(dwMult) * cyItem);
        dwMult += GetSystemMetrics(SM_CYEDGE);

        if (dwMult < 0x7FFF)
            iHeight = min(LOWORD(dwMult), iHeight);
    }

    if (!_fNoIntegralHeight) 
    {
        iHeight = ((iHeight - GetSystemMetrics(SM_CYEDGE)) / cyItem) * cyItem + 
        	GetSystemMetrics(SM_CYEDGE);
    }

    //UNDONE: Multi-monitor
    //	We need to change the following code if we are to support multi-monitor
    int yTop;
    int nScreenHeight = GetSystemMetrics(SM_CYFULLSCREEN);    
    if (rcList.top + iHeight <= nScreenHeight) 
    {
        yTop = rcList.top;
        if (!_fBorder)
            yTop -= GetSystemMetrics(SM_CYBORDER);
    } 
    else 
    {
        yTop = max(rcList.top - iHeight - _cyCombo + 
			((_fBorder) ? GetSystemMetrics(SM_CYBORDER) : 0), 0);
    }

    
    SetWindowPos(_hwndList, HWND_TOPMOST, rcList.left,
        yTop, rcList.right - rcList.left, iHeight, 0);

	Assert(_plbHost);
    _plbHost->SetScrollInfo(SB_VERT, FALSE);

	
	if (_cbType == kDropDownList)
		_fFocus = 0;

	// UNDONE:
	// Are we going to support window animation?	
    ShowWindow(_hwndList, SW_SHOW);
	
	// We send a message to the listbox to prepare for tracking
	if (fTrack)
	{		
		Assert(_plbHost);
		// initialize type searching
		_plbHost->InitSearch();
		_plbHost->OnCBTracking(LBCBM_PREPARE, LBCBM_PREPARE_SAVECURSOR | 
						((_cbType == kDropDownList) ? LBCBM_PREPARE_SETFOCUS : 0));
	}
	
	// Since we are about to display the list box change mouse cursor to arrow
	if (!_hcurOld)
		_hcurOld = TxSetCursor2(LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW)), NULL);
}

////////////////////////// Combo box Message Handlers ////////////////////////////////

/*
 *	CCmbBxWinHost::CbSetItemHeight(BOOL, int)
 *
 *	@mfunc
 *		Sets the size of the edit or list box.
 *
 *
 *	@rdesc
 *		LRESULT = successful ? 1 : CB_ERR
 */
LRESULT CCmbBxWinHost::CbSetItemHeight(BOOL bEdit, int nHeight)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::CbSetItemHeight");

	//bug fix #4556
	if (nHeight == 0 || nHeight > 255)
		return CB_ERR;

	// We need to update the height internally
	if (bEdit)
	{
		RECT rc;
		GetClientRect(_hwnd, &rc);
		_dyEdit = nHeight;
		OnSize(0, MAKELONG(rc.right - rc.left, rc.bottom - rc.top));
	}
	else
	{
		RichListBoxWndProc(_hwndList, LB_SETITEMHEIGHT, 0, MAKELPARAM(nHeight, 0));
	}
	return 1;
}

/*
 *	CCmbBxWinHost::CbGetItemHeight(BOOL)
 *
 *	@mfunc
 *		Retrieves the size of the edit or list box.
 *
 *
 *	@rdesc
 *		LRESULT = successful ? 1 : CB_ERR
 */
LRESULT CCmbBxWinHost::CbGetItemHeight(BOOL bEdit)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::CbGetItemHeight");

	// We need to update the height internally
	if (bEdit)
	{
		return _dyEdit;
	}
	else
	{
		return RichListBoxWndProc(_hwndList, LB_GETITEMHEIGHT, 0, 0);
	}
}


/*
 *	CCmbBxWinHost::CbSetExtendedUI(BOOL)
 *
 *	@mfunc
 *		Retrieves the size of the edit or list box.
 *
 *
 *	@rdesc
 *		LRESULT = successful ? CB_OKAY : CB_ERR
 */
LRESULT CCmbBxWinHost::CbSetExtendedUI(BOOL bExtendedUI)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::CbSetExtendedUI");

	// We need to update the height internally
	_fExtendedUI = bExtendedUI ? 1 : 0;
	return CB_OKAY;
}


/*
 *	CCmbBxWinHost::CbMessageItemHandler(int, WPARAM, LPARAM)
 *
 *	@mfunc
 *		Handles any and all WM_DRAWITEM and WM_DELETEITEM messages
 *
 *
 *	@rdesc
 *		LRESULT = whatever the parent window returns
 */
LRESULT CCmbBxWinHost::CbMessageItemHandler(HDC hdc, int ff, WPARAM wparam, LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::CbMessageItemHandler");

	// modify the structure info a bit and pass it to the parent window
    DRAWITEMSTRUCT dis;   
    BOOL bRelease = FALSE;
    UINT msg = WM_DRAWITEM;
	switch (ff)
	{
	case ITEM_MSG_DRAWLIST:
		((LPDRAWITEMSTRUCT)lparam)->CtlType = ODT_COMBOBOX;
	    ((LPDRAWITEMSTRUCT)lparam)->CtlID = _idCtrl;
	    ((LPDRAWITEMSTRUCT)lparam)->hwndItem = _hwnd;	    
	    break;

	case ITEM_MSG_DELETE:
		((LPDELETEITEMSTRUCT)lparam)->CtlType = ODT_COMBOBOX;
	    ((LPDELETEITEMSTRUCT)lparam)->CtlID = _idCtrl;
	    ((LPDELETEITEMSTRUCT)lparam)->hwndItem = _hwnd;
	    msg = WM_DELETEITEM;
	    break;

	case ITEM_MSG_DRAWCOMBO:
		if (!hdc)
	    {
	    	bRelease = TRUE;
	    	hdc = TxGetDC();
	    }
	    //Fill the DRAWITEMSTRUCT with the unchanging constants
	    dis.CtlType = ODT_COMBOBOX;
	    dis.CtlID = _idCtrl;    

	    // Use -1 if an invalid item number is being used.  This is so that the app
	    // can detect if it should draw the caret (which indicates the lb has the
	    // focus) in an empty listbox
	    dis.itemID = _plbHost->GetCursor();
	    dis.itemAction = ODA_DRAWENTIRE;
	    dis.hwndItem = _hwnd;	    
	    dis.hDC = hdc;
		dis.itemData = (_plbHost->GetCount()) ? (((signed)dis.itemID >= 0) ? _plbHost->GetData(dis.itemID) : 0) : 0;
	    dis.itemState = (UINT)((_fFocus && !_fListVisible ? ODS_SELECTED | ODS_FOCUS : 0) |
                    ((_fDisabled) ? ODS_DISABLED : 0) | ODS_COMBOBOXEDIT);
		           
		// Calculate the drawing rect
        TxGetClientRect(&dis.rcItem);
        if (_cbType != kSimple)
        {
        	if (_fRightAlign)
        		dis.rcItem.left = _rcButton.right;
        	else
        		dis.rcItem.right = _rcButton.left;
        }

        // immulate the system by making the HDC invert text if we have focus
		SetBkMode(hdc, OPAQUE);
		PatBlt(hdc, dis.rcItem.left, dis.rcItem.top, dis.rcItem.right - dis.rcItem.left,
                dis.rcItem.bottom - dis.rcItem.top, PATCOPY);

		if (_fFocus && !_fListVisible) 
		{
	        // only do the FillRect if we know its not
	        // ownerdraw item, otherwise we mess up people up
	        // BUT: for Compat's sake we still do this for Win 3.1 guys
            SetBkColor(hdc, GetSysColor(COLOR_HIGHLIGHT));
            SetTextColor(hdc, GetSysColor(COLOR_HIGHLIGHTTEXT));
        } 
        
        // Don't let ownerdraw dudes draw outside of the combo client
        // bounds.
		InflateRect(&dis.rcItem, -1, -1);
        IntersectClipRect(hdc, dis.rcItem.left, dis.rcItem.top, dis.rcItem.right, 
        				dis.rcItem.bottom);
	    lparam = (LPARAM)&dis;		
	}

	LRESULT lres = SendMessage(_hwndParent, msg, _idCtrl, lparam);
	if (bRelease)
		TxReleaseDC(hdc);

	return lres;
}

/////////////////////////// Windows Message Handlers /////////////////////////////////
/* 
 *	CCmbBxWinHost::OnCommand(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Handles notification from listbox and reflects it to the parent of
 *		the combo box
 *
 *	@comm
 *		LRESULT = Handled ? 0 : 1
 *
 *
 */
HRESULT CCmbBxWinHost::OnCommand(WPARAM wparam, LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEEXTERN, "CCmbBxWinHost::OnCommand");
	
	// Filter-out all the messages except Listbox notification messages
	Assert(_hwndParent);
	switch (HIWORD(wparam))
	{	
	case LBN_DBLCLK:
    	TxNotify(CBN_DBLCLK, NULL);
        break;

    case LBN_ERRSPACE:
        TxNotify((unsigned)CBN_ERRSPACE, NULL);
        break;

    case LBN_SELCHANGE:
    case LBN_SELCANCEL:
    	if (!_fListVisible)
			HideListBox(TRUE, TRUE);
    	TxNotify(CBN_SELCHANGE, NULL);
        UpdateEditBox();
        break;

    default:
    	// not handled so pass down the line
        return 1;
	}
	return 0;
}

/*
 *	CCmbBxWinHost::OnEnable(WPARAM, LPARAM)
 *
 *	@mfunc
 *		handles the WM_ENABLE message
 *
 *	@rdesc
 *		LRESULT = Handled ? 0 : 1
 */
LRESULT CCmbBxWinHost::OnEnable(WPARAM wparam, LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnEnable");

	if (_fMousedown) 
	{
        _fMousedown = FALSE;
        DrawButton(NULL, FALSE);

        //
        // Pop combo listbox back up, canceling.
        //
        if (_fListVisible)
            HideListBox(TRUE, FALSE);
    }
    return 1;
}


/*
 *	CCmbBxWinHost::OnChar(WPARAM, LPARAM)
 *
 *	@mfunc
 *		handles the WM_CHAR message
 *
 *	@rdesc
 *		LRESULT = Handled ? 0 : 1
 */
LRESULT CCmbBxWinHost::OnChar(WORD wparam, DWORD lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnChar");

	// Check if we should eat the message or not
	if (_cbType == kDropDownList)
	{
		//bug fix #5318 - ignore delete, insert and clear
		if (((WCHAR)wparam) == VK_DELETE || ((WCHAR)wparam) == VK_INSERT ||
			((WCHAR)wparam) == VK_CLEAR)
			return 0;
			
		// Sending WM_CHAR is BAD!!! call the message handler directly
		// send the character string message to the listbox if visible
		_plbHost->OnChar(LOWORD(wparam), lparam);

		//	If Hi-Ansi need to send a wm_syskeyup message to ITextServices to 
		// stabalize the state
		if (0x80 <= wparam && wparam <= 0xFF && !HIWORD(GetKeyState(VK_MENU)))
		{
			LRESULT lres;
			_pserv->TxSendMessage(WM_SYSKEYUP, VK_MENU, 0xC0000000, &lres);
		}		
		return 0;
	}

	
	if (_cbType == kDropDown)
	{
		if (_fListVisible)
		{
			if (!_fCapture)
			{
				// Tell listbox to reset capturing by ending then starting it up
				_plbHost->OnCBTracking(LBCBM_END, 0);
				_plbHost->OnCBTracking(LBCBM_PREPARE, 0);			
			}

			// Send the message to the edit control iff it's not a tab
			if (((WCHAR)wparam) != VK_TAB)
				_pserv->TxSendMessage(WM_CHAR, wparam, lparam, NULL);

			if (!_fCapture)
			{
				// capture the cursor
				TxSetCapture(TRUE);
				_fCapture = 1;				
			}
		}
		else
		{
			// set the cursel to -1 if it already isn't
			if ((wparam != VK_RETURN) && (_plbHost->GetCursor() != -1))
				RichListBoxWndProc(_hwndList, LB_SETCURSEL, (WPARAM)-1, 0);

			// Send the message to the edit control iff it's not CTRL+i or CTRL+h
			if (((WCHAR)wparam) != VK_TAB)
				_pserv->TxSendMessage(WM_CHAR, wparam, lparam, NULL);
		}		
		return 0;
	}
	return 1;
}

/*
 *	CCmbBxWinHost::OnKeyDown(WPARAM, LPARAM)
 *
 *	@mfunc
 *		handles the WM_KEYDOWN message
 *
 *	@rdesc
 *		LRESULT = Handled ? 0 : 1
 */
LRESULT CCmbBxWinHost::OnKeyDown(WORD wparam, DWORD lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnKeyDown");

	if (_fListVisible && (wparam == VK_RETURN || wparam == VK_ESCAPE))
	{
		if (wparam == VK_RETURN)
			_nCursor = _plbHost->GetCursor();
		HideListBox(TRUE, wparam == VK_RETURN);
		return 0;
	}
	
	// if we are in extended mode and F4 is hit
	// we just ignore it
	if (_fExtendedUI && wparam == VK_F4)
		return 0;
	
	Assert(_plbHost);
	int fExtUI = _fExtendedUI;
	int nCurSel = _plbHost->GetCursor();
	Assert(nCurSel >= -1);
	
	// if we are a dropdownlist combo box then just forward the message on to the 
	// list box 
	if (_cbType == kDropDownList)
	{
		switch (wparam)
		{		
		case VK_F4:
			if (_fListVisible)
				break;;
			fExtUI = 1;
			Assert(fExtUI && !_fListVisible);
			// fall through case		
			
		case VK_DOWN:
			if (fExtUI && !_fListVisible)
			{
				ShowListBox(TRUE);
				TxSetCapture(TRUE);			
				_fCapture = TRUE;
				return 1;			
			}		
			// Fall through case
			
		case VK_UP:
		case VK_NEXT:
		case VK_PRIOR:		
		case VK_RETURN:
		case VK_ESCAPE:	
			break;	

		//bug fix #5318
		/*
		case VK_DELETE:
		case VK_CLEAR:
		case VK_INSERT:
		*/

		default:
			// There no reason for us to pass these keys to ITextServices since the control is suppose
			// to be read-only
			return 0;
		}
	}
	else 
	{
		switch (wparam)
		{		
		case VK_F4:
			if (_fListVisible)
				break;
			fExtUI = 1;
			Assert(fExtUI && !_fListVisible);
			// fall through case		
			
		case VK_DOWN:
			if (fExtUI && !_fListVisible)
			{
				ShowListBox(TRUE);
				TxSetCapture(TRUE);			
				_fCapture = TRUE;
				return 0;			
			}		
			// Fall through case
			
		case VK_UP:
		case VK_NEXT:
		case VK_PRIOR:
			if (_fListVisible)
			{				
				if (_fCapture)
				{
					// release our capture flag and tell lb to start tracking
					_fCapture = 0;
					_plbHost->OnCBTracking(LBCBM_START, _fMousedown);
				}

				// selecting the top index and then sending the keydown to the 
				// listbox causes 2 moves so handle this ourselves
				if (nCurSel == -1)
				{
					RichListBoxWndProc(_hwndList, LB_SETCURSEL, _plbHost->GetTopIndex(), 0);
					UpdateEditBox();
					UpdateCbWindow();
					return 0;
				}
			}
			else
			{
				// if Listbox isn't visible and the listbox cursor is -1
				// then we should try to select the correct item in the list
				// box
				if (nCurSel == -1)
				{
					UpdateListBox(TRUE);
					if (_plbHost->GetCursor() >= 0)
					{
						HiliteEdit(TRUE);
						return 0;
					} else if (!_plbHost->GetCount())
					{
						return 0;
					}
				}
			}
			break;
		
		case VK_RETURN:
		case VK_ESCAPE:	
			break;		

		default:
			// return zero to say we didn't handle this
			return 1;
		}
	}
	// pass message to list box
	_plbHost->OnKeyDown(wparam, lparam, 0);
	UpdateCbWindow();
			
	return 0; 
	
}

/*
 *	CCmbBxWinHost::OnSyskeyDown(WORD, DWORD)
 *
 *	@mfunc
 *		handles the WM_SYSKEYDOWN message
 *
 *	@rdesc
 *		LRESULT = Handled ? 0 : 1
 */
LRESULT CCmbBxWinHost::OnSyskeyDown(WORD wparam, DWORD lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnSyskeyDown");

	if (lparam & 0x20000000L)  /* Check if the alt key is down */ 
	{
	    // Handle Combobox support.  We want alt up or down arrow to behave
	    // like F4 key which completes the combo box selection
		if (lparam & 0x1000000)
		{
			// We just want to ignore keys on the number pad...
	        // This is an extended key such as the arrow keys not on the
	        // numeric keypad so just drop the combobox.
	        if (wparam != VK_DOWN && wparam != VK_UP)
	            return 1;
		}
		else if (GetKeyState(VK_NUMLOCK) & 0x1) 
	    {
	        //If numlock down, just send all system keys to dwp
	        return 1;
	    } 
	    else 
	    {
			if (wparam != VK_DOWN && wparam != VK_UP)
				return 1;	    	
	    }

	    // If the listbox isn't visible, just show it
	    if (!_fListVisible) 
		{
			ShowListBox(TRUE);
			TxSetCapture(TRUE);			
			_fCapture = TRUE;
		}
	    else  	//Ok, the listbox is visible.  So hide the listbox window.
	        HideListBox(TRUE, TRUE);
	    return 0;
	}
	return 1;
}

/*
 *	CCmbBxWinHost::OnCaptureChanged(WPARAM, LPARAM)
 *
 *	@mfunc
 *		handles the WM_CAPTURECHANGED message
 *
 *	@rdesc
 *		LRESULT = Handled ? 0 : 1
 */
LRESULT CCmbBxWinHost::OnCaptureChanged(WPARAM wparam, LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnCaptureChanged");
    if (_fCapture) 
    {   
        // Pop combo listbox back up, canceling.
        if (_fListVisible)
            HideListBox(TRUE, FALSE);
        else
        {
        	_fCapture = FALSE;
   			_fMousedown = FALSE;
        	DrawButton(NULL, FALSE);
        }
		return 0;
    }
	return 1;
}


/*
 *	CCmbBxWinHost::OnMouseMove(WPARAM, LPARAM)
 *
 *	@mfunc
 *		handles the WM_MOUSEMOVE message
 *
 *	@rdesc
 *		LRESULT = Handled ? 0 : 1
 */
LRESULT CCmbBxWinHost::OnMouseMove(WPARAM wparam, LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnMouseMove");

	// We do the following if we have mouse captured or if the listbox is visible
	if (_cbType != kSimple && _fCapture)
	{
		// get the point coordinates of mouse
		POINT pt;
		POINTSTOPOINT(pt, lparam);
		if (_fListVisible)
		{
			// if the listbox is visible visible check if the cursor went over 
			// list box
			RECT rc;
			POINT ptScreen = pt;
			GetWindowRect(_hwndList, &rc);
			TxClientToScreen(&ptScreen);			
			if (PtInRect(&rc, ptScreen))
			{
				// Release the capture state of the mouse
				if (_fCapture)
				{
					_fCapture = FALSE;
					TxSetCapture(FALSE);
				}

				// notify the listbox to start tracking
				Assert(_plbHost);					
				::PostMessage(_hwndList, LBCB_TRACKING, LBCBM_START, _fMousedown);
				_fMousedown = 0;
			}
		}
		DrawButton(NULL, _fMousedown ? PtInRect(&_rcButton, pt) : FALSE);
		return FALSE;
	}
#ifdef DEBUG
	if (_cbType != kSimple)
		Assert(!_fListVisible);
#endif
	return TRUE;
}
	
/*
 *	CCmbBxWinHost::OnLButtonUp(WPARAM, LPARAM)
 *
 *	@mfunc
 *		handles the WM_LBUTTONUP message
 *
 *	@rdesc
 *		LRESULT = Handled ? 0 : 1
 */
LRESULT CCmbBxWinHost::OnLButtonUp(WPARAM wparam, LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnLButtonUp");
 
    if (_fMousedown) 
	{
        _fMousedown = FALSE;
        if (_cbType != kSimple) 
		{
            // If an item in the listbox matches the text in the edit
            // control, scroll it to the top of the listbox. Select the
            // item only if the mouse button isn't down otherwise we
            // will select the item when the mouse button goes up.
			if (_cbType == kDropDown)
			{
				UpdateListBox(TRUE);
				AutoUpdateEdit(-1);		
			}
			
			// if we recieved a mouse up and the listbox is still visible then user 
			// hasn't selected any items from the listbox so don't release the capture yet
			if (_fCapture && !_fListVisible)
			{
				_fCapture = FALSE;
				TxSetCapture(FALSE);
			}

			DrawButton(NULL, FALSE);       
			return FALSE;
		}
    }
	return TRUE;
}

/*
 *	CCmbBxWinHost::OnLButtonDown(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Draws the client edges of the combo box
 *
 *	@rdesc
 *		LRESULT = Handled ? 0 : 1
 */
LRESULT CCmbBxWinHost::OnLButtonDown(WPARAM wparam, LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnLButtonDown");

	// check if we should dropdown the list box
	POINT pt;
	POINTSTOPOINT(pt, lparam);
	
	// if we don't have focus then set the focus first
	if (!_fFocus)
		TxSetFocus();
	_fFocus = 1;

	// listbox is down so pop it back up
	if (_fListVisible)
	{
		return !HideListBox(TRUE, FALSE);		
	}
	else if (_cbType == kDropDownList || (_cbType == kDropDown && PtInRect(&_rcButton, pt)))
	{	
		// need to show listbox
		ShowListBox(TRUE);
		_fMousedown = TRUE;
					
		TxSetCapture(TRUE);			
		_fCapture = TRUE;
		return 0;
	}
	return 1;
}

/*
 *	CCmbBxWinHost::OnMouseWheel(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Draws the client edges of the combo box
 *
 *	@rdesc
 *		LRESULT = Handled ? 0 : 1
 */
LRESULT CCmbBxWinHost::OnMouseWheel(WPARAM wparam, LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnMouseWheel");
	
    // Handle only scrolling.
    if (wparam & (MK_CONTROL | MK_SHIFT))
        return 1;

    // If the listbox is visible, send it the message to scroll.
    // if the listbox is 
	if (_fListVisible)
	{
		_plbHost->OnMouseWheel(wparam, lparam);
		return 0;
	}
		
    // If we're in extended UI mode or the edit control isn't yet created,
    // bail.
    if (_fExtendedUI)
        return 0;

    // Emulate arrow up/down messages to the edit control.
    int i = abs(((short)HIWORD(wparam))/WHEEL_DELTA);
    wparam = ((short)HIWORD(wparam) > 0) ? VK_UP : VK_DOWN;

    while (i-- > 0) 
        OnKeyDown(wparam, lparam);

	return 0;
}


/*
 *	CCmbBxWinHost::OnSetCursor(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Changes the cursor depending on where the cursor is
 *
 *	@rdesc
 *		BOOL = SUCCESSFUL ? TRUE : FALSE
 */
 LRESULT CCmbBxWinHost::OnSetCursor(WPARAM wparam, LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnSetCursor");

	POINT pt;
	GetCursorPos(&pt);
	::ScreenToClient(_hwnd, &pt);

	if ((_cbType == kDropDownList) || 
		(_cbType == kDropDown && ((_fRightAlign) ? _rcButton.right >= pt.x : _rcButton.left <= pt.x)))
	{
		TxSetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW)), NULL);
	}
	else
		_pserv->OnTxSetCursor(DVASPECT_CONTENT,	-1,	NULL, NULL, NULL, NULL,
			NULL, pt.x, pt.y);

	return TRUE;
}

/*
 *	CCmbBxWinHost::OnSetFocus(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Draws the button and sends the WM_DRAWITEM message for owner draw
 *
 *	@rdesc
 *		BOOL = SUCCESSFUL ? TRUE : FALSE
 */
 LRESULT CCmbBxWinHost::OnSetFocus(WPARAM wparam, LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnSetFocus");

    _fFocus = TRUE;

	// Hide the list box
	if (_fListVisible)		    	
    	HideListBox(TRUE, _bSelOk);
    else if (_fOwnerDraw && _cbType == kDropDownList)
    	CbMessageItemHandler(NULL, ITEM_MSG_DRAWCOMBO, 0, 0);
	else    
		DrawEditFocus(NULL);    // Draw the focus 

    // Notify the parent we have the focus iff this function
    // wasn't called in response to LBCB_TRACKING
    if (_fLBCBMessage)
    	_fLBCBMessage = 0;
    else
	    TxNotify(CBN_SETFOCUS, NULL);

	// we return 1 if we are owner draw or if
	// we are a kDropDownList, this is because
	// we have to prevent the message from being passed
	// to _pserv
    return (_cbType == kDropDownList);
}


/*
 *	CCmbBxWinHost::OnKillFocus(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Draws the button and sends the WM_DRAWITEM message for owner draw
 *
 *	@rdesc
 *		BOOL = SUCCESSFUL ? TRUE : FALSE
 */
 LRESULT CCmbBxWinHost::OnKillFocus(WPARAM wparam, LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnKillFocus");

	// if we never had focus or if not list window just get out
	if (_hwndList == NULL)
	      return 0;
		
    if ((HWND)wparam != _hwndList) 
    {
		// We only give up the focus if the new window getting the focus
        // doesn't belong to the combo box.
	    
	    // The combo box is losing the focus.  Send buttonup clicks so that
	    // things release the mouse capture if they have it...  If the
	    // pwndListBox is null, don't do anything.  This occurs if the combo box
	    // is destroyed while it has the focus.
	    OnLButtonUp(0L, 0xFFFFFFFFL);

		if (_fListVisible)
			HideListBox(TRUE, FALSE);		
	}

	//bug fix #4013
	if (!_fFocus)
		return 0;
	_fFocus = FALSE;
	
	// Remove Focus Rect
	if (_cbType != kDropDownList)
	{		
		HiliteEdit(FALSE);

		// Hide any selections
		_pserv->TxSendMessage(EM_HIDESELECTION, 1, 0, NULL);
	}
	else if (_fOwnerDraw)
		CbMessageItemHandler(NULL, ITEM_MSG_DRAWCOMBO, 0, 0);
	else
		DrawEditFocus(NULL);
		
		
	TxNotify(CBN_KILLFOCUS, NULL); 

	if (_cbType == kDropDownList)
		return 1;
	return 0;
}


/*
 *	CCmbBxWinHost::OnSize(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Draws the button and sends the WM_DRAWITEM message for owner draw
 *
 *	@rdesc
 *		BOOL = Processed ? FALSE : TRUE
 */
 LRESULT CCmbBxWinHost::OnSize(WPARAM wparam, LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnCbSize");

    // only deal with this message if we didn't generate the message and
    // the new size is a valid one
    if (!_fResizing && _hwndList)
    {
    	_fResizing = 1;
    	RECT rc;
    	GetWindowRect(_hwnd, &rc);
    	rc.right -= rc.left;
    	rc.bottom -= rc.top;    	
    	rc.left = rc.top = 0;
    	CbCalcControlRects(&rc, FALSE);
    	
    	// Need to resize the list box
		if (_cbType != kSimple)
			SetDropSize(&_rcList);
		_fResizing = 0;
    } 
	_pserv->TxSendMessage(WM_SIZE, wparam, lparam, NULL);
	CTxtWinHost::OnSize(_hwnd, wparam, (int)LOWORD(lparam), (int)HIWORD(lparam));	
	return FALSE;
}

/*
 *	CCmbBxWinHost::OnGetDlgCode(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Draws the button and sends the WM_DRAWITEM message for owner draw
 *
 *	@rdesc
 *		BOOL = SUCCESSFUL ? TRUE : FALSE
 */
 LRESULT CCmbBxWinHost::OnGetDlgCode(WPARAM wparam, LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnGetDlgCode");

	// call the parents GetDlgCode first	
	LRESULT code = DLGC_WANTCHARS | DLGC_WANTARROWS;
	if (_cbType != kDropDownList)
		code |= DLGC_HASSETSEL;

	// If the listbox is dropped and the ENTER key is pressed,
	// we want this message so we can close up the listbox
	if ((lparam != 0) &&
	    (((LPMSG)lparam)->message == WM_KEYDOWN) &&
	    _fListVisible &&
	    ((wparam == VK_RETURN) || (wparam == VK_ESCAPE)))
	{
	    code |= DLGC_WANTMESSAGE;
	}
	_fInDialogBox = TRUE;
		
	return((LRESULT)code);
}

/*
 *	CCmbBxWinHost::OnSetTextEx(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Draws the button and sends the WM_DRAWITEM message for owner draw
 *
 *	@rdesc
 *		BOOL = SUCCESSFUL ? TRUE : FALSE
 */
 LRESULT CCmbBxWinHost::OnSetTextEx(WPARAM wparam, LPARAM lparam)
 {
 	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnSetTextEx");

 	WCHAR* psz = (WCHAR*)lparam;

 	while (*psz != L'\r')
 		psz++;
 	*psz = L'\0';

 	//Send message to host
 	_pserv->TxSendMessage(EM_SETTEXTEX, wparam, lparam, NULL);

	//Set the string back to old and send message to listbox
 	*psz = L'\r';
 	psz++;
 	return ::SendMessage(_hwndList, EM_SETTEXTEX, wparam, (LPARAM)psz);
 }

/*
 *	CCmbBxWinHost::OnPaint(WPARAM, LPARAM)
 *
 *	@mfunc
 *		Draws the button and sends the WM_DRAWITEM message for owner draw
 *
 *	@rdesc
 *		BOOL = processed ? 0 : 1
 */
 LRESULT CCmbBxWinHost::OnPaint(WPARAM wparam, LPARAM lparam)
{
	TRACEBEGIN(TRCSUBSYSHOST, TRCSCOPEINTERN, "CCmbBxWinHost::OnPaint");

	PAINTSTRUCT ps;
	HPALETTE hpalOld = NULL;
	HDC hdc = BeginPaint(_hwnd, &ps);
	RECT rcClient;
	
	// Since we are using the CS_PARENTDC style, make sure
	// the clip region is limited to our client window.
	GetClientRect(_hwnd, &rcClient);
	
	// pass message on to the parentwindow if owner draw
	if (_cbType != kDropDownList || !_fOwnerDraw)
	{
		RECT rcFocus = rcClient;
		
		// Set up the palette for drawing our data
		if (_hpal)
		{
			hpalOld = SelectPalette(hdc, _hpal, TRUE);
			RealizePalette(hdc);
		}

		SaveDC(hdc);

		IntersectClipRect(hdc, rcClient.left, rcClient.top, rcClient.right,
			rcClient.bottom);

		// Fill-in the gap between the button and richedit control
		RECT rcGap;
		if (_fRightAlign)
		{
			rcGap.left = _rcButton.right;
			rcGap.right = rcGap.left + _xInset + 1;
		}
		else
		{
			rcGap.right = _rcButton.left;
			rcGap.left = rcGap.right - _xInset - 1;
		}
		rcGap.top = rcClient.top;
		rcGap.bottom = rcClient.bottom;			
		FillRect(hdc, &rcGap, (HBRUSH)(DWORD_PTR)(((_fDisabled) ? COLOR_BTNFACE : COLOR_WINDOW) + 1));
	
		if (_fFocus && _cbType == kDropDownList)		
		{	
			//First if there is a focus rect then remove the focus rect
			// shrink the focus rect by the inset
			rcFocus.top += _yInset;
			rcFocus.bottom -= _yInset;			
			
			if (_fRightAlign)
				rcFocus.left = _rcButton.right;
			else
				rcFocus.right = _rcButton.left;

			rcFocus.left += _xInset;
			rcFocus.right -= _xInset;

			// We need to erase the focus rect if we haven't already 
			// erased the background
			DrawFocusRect(hdc, &rcFocus);
		}		

		_pserv->TxDraw(
			DVASPECT_CONTENT,  		// Draw Aspect
			-1,						// Lindex
			NULL,					// Info for drawing optimazation
			NULL,					// target device information
			hdc,					// Draw device HDC
			NULL, 				   	// Target device HDC
			(const RECTL *) &rcClient,// Bounding client rectangle
			NULL, 					// Clipping rectangle for metafiles
			&ps.rcPaint,			// Update rectangle
			NULL, 	   				// Call back function
			NULL,					// Call back parameter
			TXTVIEW_ACTIVE);		// What view - the active one!

		// Restore palette if there is one
		if(hpalOld)
			SelectPalette(hdc, hpalOld, TRUE);

		RestoreDC(hdc, -1);

		if(TxGetEffects() == TXTEFFECT_SUNKEN && dwMajorVersion < VERS4)
			DrawSunkenBorder(_hwnd, hdc);

		//Redraw the focus rect, don't have to recalc since we already did above
		if (_fFocus && _cbType == kDropDownList)
			DrawFocusRect(hdc, &rcFocus);

		DrawButton(hdc, _fMousedown);
	}
	else
	{
		// We have to draw the button first because CbMessageItemHandler
		// will perform a IntersectClipRect which will prevent us from
		// drawing the button later
		DrawButton(hdc, _fMousedown);
		
		CbMessageItemHandler(hdc, ITEM_MSG_DRAWCOMBO, 0, 0);
	}
	EndPaint(_hwnd, &ps);

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\coleobj.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module	COLEOBJ.CPP	OLE Object management class implemenation |
 *
 * 	Author:		alexgo 10/24/95
 *
 *	Note:	Much of this code is a port from RichEdit 1.0 sources
 *			(cleaned up a bit, ported to C++, etc.)  So if there's any
 *			bit of strangeness, it's probably there for a reason.
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_edit.h"
#include "_coleobj.h"
#include "_objmgr.h"
#include "_select.h"
#include "_rtext.h"
#include "_disp.h"
#include "_dispprt.h"
#include "_antievt.h"
#include "_dxfrobj.h"

ASSERTDATA

//
// data private to this file
//
static const OLECHAR szSiteFlagsStm[] = OLESTR("RichEditFlags");	

//
// EXCEL clsid's.  We have to make some special purpose hacks
// for XL.
const CLSID rgclsidExcel[] =
{
    { 0x00020810L, 0, 0, {0xC0, 0, 0, 0, 0, 0, 0, 0x46} },  // Excel Worksheet
    { 0x00020811L, 0, 0, {0xC0, 0, 0, 0, 0, 0, 0, 0x46} },  // Excel Chart
    { 0x00020812L, 0, 0, {0xC0, 0, 0, 0, 0, 0, 0, 0x46} },  // Excel App1
    { 0x00020841L, 0, 0, {0xC0, 0, 0, 0, 0, 0, 0, 0x46} },  // Excel App2
};
const INT cclsidExcel = sizeof(rgclsidExcel) / sizeof(rgclsidExcel[0]);


//
//	WordArt CLSID for more special purpose hacks.
//
const GUID CLSID_WordArt =
    { 0x000212F0L, 0, 0, {0xC0, 0, 0, 0, 0, 0, 0, 0x46} };
const GUID CLSID_PaintbrushPicture =
    { 0x0003000AL, 0x0000, 0x0000, { 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 } };
const GUID CLSID_BitmapImage =
    { 0xD3E34B21L, 0x9D75, 0x101A, { 0x8C, 0x3D, 0x00, 0xAA, 0x00, 0x1A, 0x16, 0x52 } };


#define dxyHandle (6) // Object frame handle size
#define dxyFrameDefault  (1) // Object frame width

//
// utility functions
//

/*
 *	IsExcelCLSID (clsid)
 *
 *	@func	checks to see if the given clsid is one of XL's
 *
 *	@rdesc	TRUE/FALSE
 */
BOOL IsExcelCLSID(
	REFGUID clsid)
{
    for(LONG i = 0; i < cclsidExcel; i++)
    {
        if(IsEqualCLSID(clsid, rgclsidExcel[i]))
			return TRUE;
    }
    return FALSE;
}

//
//	PUBLIC methods
//

/*
 *	COleObject::QueryInterface(ridd, ppv)
 *
 *	@mfunc	the standard OLE QueryInterface
 *
 *	@rdesc	NOERROR		<nl>
 *			E_NOINTERFACE
 */
STDMETHODIMP COleObject::QueryInterface(
	REFIID	riid,		//@parm Requested interface ID
	void **	ppv)		//@parm Out parm for result
{
	HRESULT hr = NOERROR;

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::QueryInterface");

    if(IsZombie())
        return CO_E_RELEASED;

	if(!ppv)
		return E_INVALIDARG;
	else
		*ppv = NULL;

	if(IsEqualIID(riid, IID_IUnknown))
		*ppv = (IUnknown *)(IOleClientSite *)this;

	else if(IsEqualIID(riid, IID_IOleClientSite))
		*ppv = (IOleClientSite *)this;

	else if(IsEqualIID(riid, IID_IOleInPlaceSite))
		*ppv = (IOleInPlaceSite *)this;

	else if(IsEqualIID(riid, IID_IAdviseSink))
		*ppv = (IAdviseSink *)this;

	else if(IsEqualIID(riid, IID_IOleWindow))
		*ppv = (IOleWindow *)this;

	else if(IsEqualIID(riid, IID_IRichEditOleCallback))
	{
		// NB!! Returning this pointer in our QI is
		// phenomenally bogus; it breaks fundamental COM
		// identity rules (granted, not many understand them!).
		// Anyway, RichEdit 1.0 did this, so we better.

		TRACEWARNSZ("Returning IRichEditOleCallback interface, COM "
			"identity rules broken!");

		*ppv = _ped->GetRECallback();
	}
	else
		hr = E_NOINTERFACE;

	if(*ppv)
		(*(IUnknown **)ppv)->AddRef();

	return hr;
}

/*
 *	COleObject::AddRef()
 *
 *	@mfunc	Increments reference count
 *
 *	@rdesc	New reference count
 */
STDMETHODIMP_(ULONG) COleObject::AddRef()
{
    ULONG cRef;
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::AddRef");

    cRef = SafeAddRef();
	
	return cRef;
}

/*
 *	COleObject::Release	()
 *
 *	@mfunc	Decrements reference count
 *
 *	@rdesc	New reference count
 */
STDMETHODIMP_(ULONG) COleObject::Release()
{
    ULONG cRef;
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::Release");

	cRef = SafeRelease();

	return cRef;
}

/*
 *	COleObject::SaveObject ()
 *
 *	@mfunc	implemtenation of IOleClientSite::SaveObject
 *
 *	@rdesc	HRESULT
 */
STDMETHODIMP COleObject::SaveObject()
{
	CCallMgr	callmgr(_ped);

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::SaveObject");

	return SafeSaveObject();
}

/*
 *	COleObject::SafeSaveObject ()
 *
 *	@mfunc	implemtenation of IOleClientSite::SaveObject for internal consumption
 *
 *	@rdesc	HRESULT
 */
STDMETHODIMP COleObject::SafeSaveObject()
{
	IPersistStorage *pps;
	HRESULT hr;
	CStabilize stabilize(this);

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::SafeSaveObject");

	if(!_punkobj || !_pstg)
	{
		TRACEWARNSZ("SaveObject called on invalid object");
		return E_UNEXPECTED;
	}

    if(IsZombie())
        return CO_E_RELEASED;

	hr = _punkobj->QueryInterface(IID_IPersistStorage, (void **)&pps);

	TESTANDTRACEHR(hr);

	if(hr == NOERROR)
	{
        if(IsZombie())
            return CO_E_RELEASED;

		SavePrivateState();
		
        if(IsZombie())
            return CO_E_RELEASED;

		hr = OleSave(pps, _pstg, TRUE);
	
	    if(IsZombie())
	        return CO_E_RELEASED;

		TESTANDTRACEHR(hr);

		// note that SaveCompleted is called even if OleSave fails.
		// If both OleSave and SaveCompleted succeed, then go ahead
		// and commit the changes

		if(pps->SaveCompleted(NULL) == NOERROR && hr == NOERROR)
		{
		    if(IsZombie())
		        return CO_E_RELEASED;
			
			hr = _pstg->Commit(STGC_DEFAULT);

			TESTANDTRACEHR(hr);
		}
        pps->Release();
	}
	return hr;
}

/*
 *	COleObject::GetMoniker (dwAssign, dwWhichMoniker, ppmk)
 *
 *	@mfunc	implementation of IOleClientSite::GetMoniker
 *
 *	@rdesc	E_NOTIMPL
 */
STDMETHODIMP COleObject::GetMoniker(
	DWORD		dwAssign,		//@parm	Force an assignment?
	DWORD		dwWhichMoniker,	//@parm	Kind of moniker to get
	IMoniker **	ppmk)			//@parm Out parm for result
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::GetMoniker");

	TRACEWARNSZ("method not implemented!");

	if(ppmk)
		*ppmk = NULL;

	return E_NOTIMPL;
}
	
/*
 *	COleObject::GetContainer(ppcont)
 *
 *	@mfunc	implementation of IOleClientSite::GetContainer
 *
 *	@rdesc	E_NOINTERFACE
 */
STDMETHODIMP COleObject::GetContainer(
	IOleContainer **ppcont)	//@parm	Out parm for result
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::GetContainer");

	TRACEWARNSZ("method not implemented!");

	if(ppcont)
		*ppcont = NULL;

	// richedit 1.0 returns E_NOINTERFACE instead of E_NOTIMPL.  Do
	// the same.

	return E_NOINTERFACE;
}

/*
 *	COleObject::ShowObject()
 *
 *	@mfunc	Implementation of IOleClientSite::ShowObject.
 *
 *	@rdesc	E_NOTIMPL
 */
STDMETHODIMP COleObject::ShowObject()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::ShowObject");

	TRACEWARNSZ("method not implemented!");

	return E_NOTIMPL;
}

/*
 *	COleObject::OnShowWindow (fShow)
 *
 *	@mfunc
 *		implementation of IOleClientSite::OnShowWindow -- notifies
 *		the client site that the object is or is not being shown in its
 *		own application window.  This governs whether or not hatching
 *		should appear around the object in richedit.
 *
 *	@rdesc	HRESULT
 */
STDMETHODIMP COleObject::OnShowWindow(
	BOOL fShow)		//@parm If TRUE, object is being drawn in its own window
{
	DWORD dwFlags = _pi.dwFlags;
	CCallMgr	callmgr(_ped);
	CStabilize stabilize(this);

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::OnShowWindow");

    if(IsZombie())
        return CO_E_RELEASED;

	_pi.dwFlags &= ~REO_OPEN;
	if(fShow)
		_pi.dwFlags |= REO_OPEN;

	// If something changed, redraw object
	if(dwFlags != _pi.dwFlags)
	{
		// Invalidate rect that we're in.
		_ped->TxInvalidateRect(&_rcPos, FALSE);

		// We're not allowed to call invalidate rect by itself without
		// terminating it with a call to update window.However, we don't
		// care at this point if things are redrawn right away.
		_ped->TxUpdateWindow();

		// COMPATIBILITY ISSUE: (alexgo) the RE1.0 code did some funny
		// stuff with undo here.  I don't believe it's necessary to
		// repeat that code with our multi-level undo model,
	}
	return NOERROR;
}

/*
 *	COleObject::RequestNewObjectLayout ()
 *
 *	@mfunc	Implementation of IOleClientSite::RequestNewObjectLayout
 *
 *	@rdesc	E_NOTIMPL
 */
STDMETHODIMP COleObject::RequestNewObjectLayout()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN,
			"COleObject::RequestNewObjectLayout");

	TRACEWARNSZ("method not implemented!");

	return E_NOTIMPL;
}

/*
 *	COleObject::GetWindow(phwnd)
 *
 *	@mfunc	Implementation of IOleInPlaceSite::GetWindow
 *
 *	@rdesc	HRESULT
 */
STDMETHODIMP COleObject::GetWindow(
	HWND *phwnd)	//@parm Where to put window
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::GetWindow");

	// NB! this method is not stabilized.

    if(IsZombie())
        return CO_E_RELEASED;

	if(phwnd)
		return _ped->TxGetWindow(phwnd);

	return E_INVALIDARG;
}

/*
 *	COleObject::ContextSensitiveHelp(fEnterMode)
 *
 *	@mfunc	Implemenation of IOleInPlaceSite::ContextSensitiveHelp
 *
 *	@rdesc	HRESULT
 */
 STDMETHODIMP COleObject::ContextSensitiveHelp(
 	BOOL fEnterMode)	//@parm, If TRUE, then we're in help mode
 {
 	IRichEditOleCallback *precall;
	CCallMgr	callmgr(_ped);
	CStabilize	stabilize(this);

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN,
			"COleObject::ContextSensitiveHelp");

    if(IsZombie())
        return CO_E_RELEASED;

	// If the mode changes
	if(_ped->GetObjectMgr()->GetHelpMode() != fEnterMode)
	{
		_ped->GetObjectMgr()->SetHelpMode(fEnterMode);

		precall = _ped->GetRECallback();
		if(precall)
			return precall->ContextSensitiveHelp(fEnterMode);
	}
	return NOERROR;
}

/*
 *	COleObject::CanInPlaceActivate()
 *
 *	@mfunc	implementation of IOleInPlaceSite::CanInPlaceActivate
 *
 *	@rdesc	NOERROR or S_FALSE
 */
STDMETHODIMP COleObject::CanInPlaceActivate()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN,
			"COleObject::CanInPlaceActivate");

    if(IsZombie())
        return CO_E_RELEASED;

	// If we have a callback && the object is willing to show
	// content, then we can in-place activate

	if(_ped->GetRECallback() && _pi.dvaspect == DVASPECT_CONTENT)
 		return NOERROR;

	return S_FALSE;
}

/*
 *	COleObject::OnInPlaceActivate()
 *
 *	@mfunc	implementation of IOleInPlaceSite::OnInPlaceActivate
 *
 *	@rdesc	noerror
 */
STDMETHODIMP COleObject::OnInPlaceActivate()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::OnInPlaceActivate");
	// assume that in-place objects can never be blank.
	_pi.dwFlags &= ~REO_BLANK;
	_fInPlaceActive = TRUE;

	return NOERROR;
}

/*
 *	COleObject::OnUIActivate ()
 *
 *	@mfunc	implementation of IOleInPlaceSite::OnUIActivate.  Notifies
 *			the container that the object is about to be activated in
 *			place with UI elements suchs as merged menus
 *
 *	@rdesc	HRESULT
 */
STDMETHODIMP COleObject::OnUIActivate()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::OnUIActivate");

	CCallMgr	callmgr(_ped);
	CStabilize	stabilize(this);

    if(IsZombie())
        return CO_E_RELEASED;

	CObjectMgr *		  pobjmgr = _ped->GetObjectMgr();
	IRichEditOleCallback *precall = pobjmgr->GetRECallback();

	if(precall)
	{
		// Force this object to be selected, if it isn't already
		// Update the selection before making the outgoing call
		if(!(_pi.dwFlags & REO_SELECTED))
		{
			CTxtSelection *psel = _ped->GetSel();
			if(psel)
				psel->SetSelection(_cp, _cp + 1);
		}
		precall->ShowContainerUI(FALSE);
	    if(IsZombie())
	        return CO_E_RELEASED;

		// This is an optimization for activating multiple
		pobjmgr->SetShowUIPending(FALSE);

		// RAID 7212
		// We don't want to set the in place active object if we are already in the process of activating the pbject.
		// Otherwise, there will be bad interactions with the code in TxDraw for out of process servers.
		// Note : it may be possible to always set this in ActivateObj but I left this here for those cases wher
		// OnUIActivate may be called directly.
		if (!_fActivateCalled)
		{
			Assert(!pobjmgr->GetInPlaceActiveObject());	
			pobjmgr->SetInPlaceActiveObject(this);
			_pi.dwFlags |= REO_INPLACEACTIVE;
		}

		return NOERROR;
	}
	return E_UNEXPECTED;
}

/*
 *	COleObject::GetWindowContext(ppipframe, ppipuidoc, prcPos, prcClip, pipfinfo)
 *
 *	@mfunc	Implementation of IOleInPlaceSite::GetWindowContext.
 *			Enables the in-place object to retrieve the window
 *			interfaces that form the window object hierarchy.
 *
 *	@rdesc	HRESULT
 */
STDMETHODIMP COleObject::GetWindowContext(
	IOleInPlaceFrame **ppipframe,	//@parm	Where to put in-place frame
	IOleInPlaceUIWindow **ppipuidoc,//@parm Where to put ui window
	LPRECT prcPos,					//@parm Position rect
	LPRECT prcClip,					//@parm Clipping rect
	LPOLEINPLACEFRAMEINFO pipfinfo)	//@parm Accelerator information
{
	CCallMgr	callmgr(_ped);
	CStabilize stabilize(this);
	
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::GetWindowContext");
	
    if(IsZombie())
        return CO_E_RELEASED;

	// Let container verify other parameters; we don't use them
	if(!prcPos || !prcClip)
		return E_INVALIDARG;
		
	IRichEditOleCallback *precall = _ped->GetRECallback();
	if(precall)
	{
		// Recall that there are two rects here in client coordiantes:
		// the rect for this object (_rcPos) and the rect for
		// our main display;
		*prcPos = _rcPos;

		// FUTURE (alexgo); we may need to get this from the
		// display instead to handle the inactive state if we ever
		// want to support embedded objects with the inactive state.
		_ped->TxGetClientRect(prcClip);
		return precall->GetInPlaceContext(ppipframe, ppipuidoc, pipfinfo);
	}
	return E_UNEXPECTED;
}

/*
 *	COleObject::Scroll(sizeScroll)
 *
 *	@mfunc	implementation of IOleInPlaceSite::Scroll
 *
 *	@rdesc 	E_NOTIMPL;
 */
STDMETHODIMP COleObject::Scroll(
	SIZE sizeScroll)	//@parm Amount to scroll
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::Scroll");

	TRACEWARNSZ("method not implemented!");

	return E_NOTIMPL;
}

/*
 *	COleObject::OnUIDeactivate (fUndoable)
 *
 *	@mfunc	implementation of IOleInPlaceSite::OnUIDeactivate.  Notifies
 *			the container that it should re-install its user interface
 *
 *	@rdesc	HRESULT
 */
STDMETHODIMP COleObject::OnUIDeactivate(
	BOOL fUndoable)		//@parm Whether you can undo anything here
{
	CCallMgr	callmgr(_ped);
	CStabilize stabilize(this);

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::OnUIDeactivate");

    if(IsZombie())
        return CO_E_RELEASED;

	CObjectMgr *pobjmgr = _ped->GetObjectMgr();
	IRichEditOleCallback *precall = _ped->GetRECallback();

	if(_fIsPaintBrush)
	{
		// Hack for RAID 3293.  Bitmap object disappears after editing.
		// Apparently paint only triggers OnUIDeactivate and not OnInPlaceDeactivate
		// assume that in-place objects can never be blank.
		_fInPlaceActive = FALSE;
		// Reset REO_INPLACEACTIVE
		_pi.dwFlags &= ~REO_INPLACEACTIVE;
	}

	if(!precall)
		return E_UNEXPECTED;

	if(_ped->TxIsDoubleClickPending())
		_ped->GetObjectMgr()->SetShowUIPending(TRUE);
	else
	{
		// Ignore any errors; the old code did.
		precall->ShowContainerUI(TRUE);

	    if(IsZombie())
	        return CO_E_RELEASED;
	}
	
	pobjmgr->SetInPlaceActiveObject(NULL);

	if (!_fDeactivateCalled)
	{
		// We got here without DeActiveObj. Since to shutdown correctly
		// we need to call this, we do so here.
		DeActivateObj();
	}

	// Get focus back
	_ped->TxSetFocus();

#ifdef DEBUG
	// the OLE undo model is not very compatible with multi-level undo.
	// For simplicity, just ignore stuff.
	if(fUndoable)
	{
		TRACEWARNSZ("Ignoring a request to keep undo from an OLE object");
	}
#endif

	// Some objects draw outside the
	// areas they are supposed to.  So we need to
	// just invalidate everything and redraw.

	_ped->TxInvalidateRect(NULL, TRUE);
	return NOERROR;
}

/*
 *	COleObject::OnInPlaceDeactivate	()
 *
 *	@mfunc	implementation of IOleInPlaceSite::OnInPlaceDeactivate
 *
 *	@rdesc	NOERROR
 */
STDMETHODIMP COleObject::OnInPlaceDeactivate()
{
	CCallMgr	callmgr(_ped);
	CStabilize stabilize(this);

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN,
			"COleObject::OnInPlaceDeactivate");

	_fInPlaceActive = FALSE;

	//Reset REO_INPLACEACTIVE
	_pi.dwFlags &= ~REO_INPLACEACTIVE;

	if(!_punkobj)
		return E_UNEXPECTED;

    if(IsZombie())
        return CO_E_RELEASED;

	// Apparently, WordArt 2.0 had some sizing problems.  The original
	// code has this call to GetExtent-->SetExtent, so I've kept it here.
	
	if(_fIsWordArt2)
	{
		// Ignore errors.  If anything fails, too bad.
		FetchObjectExtents();	// this will reset _sizel
		SetExtent(SE_NOTACTIVATING);
	}

	// Some objects draw outside the
	// areas they are supposed to.  So we need to
	// just invalidate everything and redraw.

	// Note that we do this in UIDeactivate as well; however, the
	// double invalidation is necessary to cover some re-entrancy
	// cases where we might be painted before everything is ready.

	_ped->TxInvalidateRect(NULL, TRUE);
	return NOERROR;
}

/*
 *	COleObject::DiscardUndoState ()
 *
 *	@mfunc	implementation of IOleInPlaceSite::DiscardUndoState.
 *
 *	@rdesc	NOERROR
 */
STDMETHODIMP COleObject::DiscardUndoState()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN,
			"COleObject::DiscardUndoState");

	// Nothing to do here; we don't keep any OLE-undo state as it's
	// not very compatible with multi-level undo.
	
	return NOERROR;
}

/*
 *	COleObject::DeactivateAndUndo ()
 *
 *	@mfunc	implementation of IOleInPlaceSite::DeactivateAndUndo--
 *			called by an active object when the user invokes undo
 *			in the active object
 *
 *	@rdesc	NOERROR	(yep, richedit1.0 ignored all the errors here)
 */
STDMETHODIMP COleObject::DeactivateAndUndo()
{
	CStabilize	stabilize(this);

  	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::DeactivateAndUndo");

    if(IsZombie())
        return CO_E_RELEASED;

	// Ignore error
	_ped->InPlaceDeactivate();

	// COMPATIBILITY ISSUE: we don't bother doing any undo here, as
	// a multi-level undo model is incompatible with OLE undo.

	return NOERROR;
}

/*
 *	COleObject::OnPosRectChange	(prcPos)
 *
 *	@mfunc	implementation of IOleInPlaceSite::OnPosRectChange.  This
 *			method is called by an in-place object when its extents have
 *			changed
 *
 *	@rdesc	HRESULT
 */
STDMETHODIMP COleObject::OnPosRectChange(
	LPCRECT prcPos)
{
	IOleInPlaceObject *pipo;
 	RECT rcClip;
	RECT rcNewPos;
	CCallMgr	callmgr(_ped);
	CStabilize stabilize(this);

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::OnPosRectChange");
	
	if(!prcPos)
		return E_INVALIDARG;

	if(!_punkobj)
		return E_UNEXPECTED;
		
    if(IsZombie())
        return CO_E_RELEASED;

	if(!_ped->fInplaceActive())
		return E_UNEXPECTED;

	// Check to see if the rect moved; we don't allow this, but
	// do allow the object to keep the new size

	rcNewPos = *prcPos;

	if(prcPos->left != _rcPos.left	|| prcPos->top != _rcPos.top)
	{
		rcNewPos.right = rcNewPos.left + (prcPos->right - prcPos->left);
		rcNewPos.bottom = rcNewPos.top + (prcPos->bottom - prcPos->top);		
	}

	_ped->TxGetClientRect(&rcClip);

	HRESULT hr = _punkobj->QueryInterface(IID_IOleInPlaceObject, (void **)&pipo);
	if(hr == NOERROR)
	{
		hr = pipo->SetObjectRects(&rcNewPos, &rcClip);
        pipo->Release();

        // bug fix 6073
        // Need to set viewchange flag so we resize the ole object properly on ITextServices::TxDraw
		CObjectMgr * pobjmgr = _ped->GetObjectMgr();
		if (pobjmgr && pobjmgr->GetInPlaceActiveObject() == this)
			_fViewChange = TRUE;
	}
	return hr;
}

/*
 *	COleObject::OnDataChange (pformatetc, pmedium)
 *
 *	@mfunc	implementation of IAdviseSink::OnDataChange
 *
 *	@rdesc	NOERROR
 */
STDMETHODIMP_(void) COleObject::OnDataChange(
	FORMATETC *pformatetc,		//@parm Format of data that changed
	STGMEDIUM *pmedium)			//@parm Data that changed
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::OnDataChange");
	CCallMgr	callmgr(_ped);

    if(IsZombie())
        return;
	_pi.dwFlags &= ~REO_BLANK;
	// this will also set the modified flag
	_ped->GetCallMgr()->SetChangeEvent(CN_GENERIC);

	return;
}

/*
 *	COleObject::OnViewChange(dwAspect, lindex)
 *
 *	@mfunc	implementation of IAdviseSink::OnViewChange.  Notifies
 *			us that the object's view has changed.
 *
 *	@rdesc	HRESULT
 */
STDMETHODIMP_(void) COleObject::OnViewChange(
	DWORD	dwAspect,		//@parm Aspect that has changed
	LONG	lindex)			//@parm unused
{
	CStabilize	stabilize(this);
	CCallMgr	callmgr(_ped);
		
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::OnViewChange");
	
	if(!_punkobj)
		return;		// E_UNEXPECTED

    if(IsZombie())
        return;

	if (_fInUndo)	// This object has been deleted, forget view change
		return;

	_pi.dwFlags &= ~REO_BLANK;
	// Richedit 1.0 ignored errors on getting object extents

  	FetchObjectExtents();

    // bug fix 6073
    // Need to set viewchange flag so we resize the ole object properly on ITextServices::TxDraw
    CObjectMgr * pobjmgr = _ped->GetObjectMgr();
	if (pobjmgr && pobjmgr->GetInPlaceActiveObject() == this)
		_fViewChange = TRUE;

	CDisplay *pdp = _ped->_pdp;
	if(pdp)
		pdp->OnPostReplaceRange(CP_INFINITE, 0, 0, _cp, _cp + 1);

	_ped->GetCallMgr()->SetChangeEvent(CN_GENERIC);
	return;
}
	
/*
 *	COleObject::OnRename (pmk)
 *
 *	@mfunc	implementation of IAdviseSink::OnRename.  Notifies the container
 *			that the object has been renamed
 *
 *	@rdesc	E_NOTIMPL
 */
STDMETHODIMP_(void) COleObject::OnRename(
	IMoniker *pmk)			//@parm Object's new name
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::OnRename");
	
	TRACEWARNSZ("IAdviseSink::OnRename not implemented!");

	return;	// E_NOTIMPL;
}

/*
 *	COleObject::OnSave ()
 *
 *	@mfunc	implementation of IAdviseSink::OnSave.  Notifies the container
 *			that an object has been saved
 *
 *	@rdesc	NOERROR
 */
STDMETHODIMP_(void) COleObject::OnSave()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::OnSave");
	_pi.dwFlags &= ~REO_BLANK;
}

/*
 *	COleObject::OnClose	()
 *
 *	@mfunc	implementation of IAdviseSink::OnClose.  Notifies the container
 *			that an object has been closed.
 *
 *	@rdesc	NOERROR
 */
STDMETHODIMP_(void) COleObject::OnClose()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::OnClose");
	
    if(IsZombie())
        return;

	// If the object is blank (i.e. no data in it), we don't want to leave
	// it in the backing store--there is nothing for us to draw && therefore
	// nothing for the user to click on!  So just delete the object with
	// a space.  Note that 1.0 actually deleted the object; we'll just
	// replace it with a space to make everything work out right.
	if(_pi.dwFlags & REO_BLANK)
	{
		CCallMgr	callmgr(_ped);
		CStabilize	stabilize(this);
		CRchTxtPtr	rtp(_ped, _cp);

		// We don't want the delete of this object to go on the undo
		// stack.  We use a space so that cp's will work out right for
		// other undo actions.
		rtp.ReplaceRange(1, 1, L" ", NULL, -1);
	}
	_ped->TxSetForegroundWindow();
}
				
/*
 *	COleObject::OnPreReplaceRange
 *
 *	@mfunc	implementation of ITxNotify::OnPreReplaceRange
 *			called before changes are made to the backing store
 */
void COleObject::OnPreReplaceRange(
	LONG cp, 			//@parm cp of the changes
	LONG cchDel,		//@parm #of chars deleted
	LONG cchNew,		//@parm # of chars added
	LONG cpFormatMin, 	//@parm min cp of formatting changes
	LONG cpFormatMax)	//@parm max cp of formatting changes
{
	Assert(_fInUndo == FALSE);
}

/*
 *	COleObject::OnPostReplaceRange
 *
 *	@mfunc	implementation of ITxNotify::OnPostReplaceRange
 *			called after changes are made to the backing store
 *	
 *	@comm	we use this method to keep our cp's up-to-date
 */
void COleObject::OnPostReplaceRange(
	LONG cp, 			//@parm cp of the changes
	LONG cchDel,		//@parm #of chars deleted
	LONG cchNew,		//@parm # of chars added
	LONG cpFormatMin, 	//@parm min cp of formatting changes
	LONG cpFormatMax)	//@parm max cp of formatting changes
{
	// The only case we need to worry about is when changes
	// come before our object

	Assert(_fInUndo == FALSE);

	_fDraw = TRUE;
	if(cp <= _cp)
	{		
		if(cp + cchDel > _cp)
		{
			_fDraw = FALSE;
			return;
		}
		_cp += (cchNew - cchDel);
	}
}
		
/*
 *	COleObject::Zombie ()
 *
 *	@mfunc
 *		Turn this object into a zombie
 *
 */
void COleObject::Zombie ()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::Zombie");

	_ped = NULL;
}

/*
 *	COleObject::COleObject(ped)
 *
 *	@mfunc	constructor
 */
COleObject::COleObject(
	CTxtEdit *ped)	//@parm context for this object
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "COleObject::COleObject");

	AddRef();

	// Most values will be NULL by virtue of the allocator
	_ped = ped;

	CNotifyMgr *pnm = ped->GetNotifyMgr();
	if(pnm)
		pnm->Add((ITxNotify *)this);
}

/*
 *	COleObject::GetObjectData(preobj, dwFlags)
 *
 *	@mfunc	fills out an REOBJECT structure with information relevant
 *			to this object
 *
 *	@rdesc	HRESULT
 */
HRESULT	COleObject::GetObjectData(
	REOBJECT *preobj, 		//@parm Struct to fill out
	DWORD dwFlags)			//@parm Indicate what data is requested
{
	IOleObject *poo = NULL;

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "COleObject::GetObjectData");

	Assert(preobj);
	Assert(_punkobj);

	preobj->cp = _cp;
	
	if(_punkobj->QueryInterface(IID_IOleObject, (void **)&poo) == NOERROR)
	{
		// Don't worry about failures here
		poo->GetUserClassID(&(preobj->clsid));
	}
	
	preobj->dwFlags 	= _pi.dwFlags;
	preobj->dvaspect 	= _pi.dvaspect;
	preobj->dwUser 		= _pi.dwUser;
	preobj->sizel		= _sizel;		

   	if(dwFlags & REO_GETOBJ_POLEOBJ)
	{
		preobj->poleobj = poo;
		if(poo)
			poo->AddRef();
	}
	else
		preobj->poleobj = NULL;

    if(poo)
        poo->Release();

    if(IsZombie())
        return CO_E_RELEASED;

	if(dwFlags & REO_GETOBJ_PSTG)
	{
		preobj->pstg = _pstg;
		if(_pstg)
			_pstg->AddRef();
	}
	else
		preobj->pstg = NULL;

	if(dwFlags & REO_GETOBJ_POLESITE)
	{
		// COMPATIBILITY HACK!!  Note that we don't 'release' any pointer that
		// may already be in the stored in the site.  RichEdit1.0 always sets
		// the value, consequently several apps pass in garbage for the site.
		//
		// If the site was previously set, we will get a reference counting
		// bug, so be sure that doesn't happen!

       	preobj->polesite = (IOleClientSite *)this;
       	AddRef();
 	}
	else
		preobj->polesite = NULL;

	return NOERROR;
}	

/*
 *	COleObject::IsLink()
 *
 *	@mfunc	returns TRUE if the object is a link
 *
 *	@rdesc	BOOL
 */
BOOL COleObject::IsLink()
{
	return !!(_pi.dwFlags & REO_LINK);
}

/*
 *	COleObject::InitFromREOBJECT(cp, preobj)
 *
 *	@mfunc	initializes this object's state from the given
 *			REOBJECT data structure
 *
 *	@rdesc	HRESULT
 */
HRESULT COleObject::InitFromREOBJECT(
	LONG	cp,			//@parm cp for the object
	REOBJECT *preobj)	//@parm	Data to use for initialization
{
	IOleLink *plink;
	HRESULT	hr = E_INVALIDARG;
	CRchTxtPtr rtp(_ped, 0);
	POINT pt;
	
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "COleObject::InitFromREOBJECT");
	
	Assert(_punkobj == NULL);
    if(IsZombie())
        return CO_E_RELEASED;

	_cp = cp;

	if(preobj->poleobj)
		hr = preobj->poleobj->QueryInterface(IID_IUnknown, (void **)&_punkobj);
	else
	{
		_punkobj = (IOleClientSite *) this;
		AddRef();
		hr = NOERROR;
	}

	if(hr != NOERROR)
		return hr;
	
	_pstg = preobj->pstg;
	if(_pstg)
		_pstg->AddRef();

	_pi.dwFlags	 = preobj->dwFlags & REO_READWRITEMASK;
	_pi.dwUser	 = preobj->dwUser;
	_pi.dvaspect = preobj->dvaspect;

	_sizel = preobj->sizel;		// COMPATIBILITY ISSUE: the RE 1.0 code had
								// some stuff to deal with REO_DYNAMICSIZE
								// here. We do not currently support that.
	
	if(_punkobj->QueryInterface(IID_IOleLink, (void **)&plink) == NOERROR)
	{
		_pi.dwFlags |= REO_LINK | REO_LINKAVAILABLE;
		plink->Release();
	}

    if(IsZombie())
        return CO_E_RELEASED;

	if (IsEqualCLSID(preobj->clsid, CLSID_StaticMetafile) ||
		IsEqualCLSID(preobj->clsid, CLSID_StaticDib) ||
		IsEqualCLSID(preobj->clsid, CLSID_Picture_EnhMetafile))
	{
		_pi.dwFlags |= REO_STATIC;
	}
	else if(IsExcelCLSID(preobj->clsid))
		_pi.dwFlags |= REO_GETMETAFILE;

	else if(IsEqualCLSID(preobj->clsid, CLSID_WordArt))
		_fIsWordArt2 = TRUE;

	else if(IsEqualCLSID(preobj->clsid, CLSID_PaintbrushPicture) ||
			IsEqualCLSID(preobj->clsid, CLSID_BitmapImage))
	{
		_fIsPaintBrush = TRUE;

		// These calls will initialize the flag, _fPBUseLocalSizel, which
		// indicates that for this PB object, SetExtent calls are not
		// acknowledged by the object, and we are to use our local value
		// of _sizel as the object extents.
		FetchObjectExtents();
		SetExtent(SE_NOTACTIVATING);
	}

	hr = ConnectObject();

    if(IsZombie())
        return CO_E_RELEASED;

	// This is a bit non-intuitive, but we need to figure out
	// where the object would be so that it can inplace activate correctly.

	if(cp)
		cp--;

	rtp.SetCp(cp);

	pt.x = pt.y = 0;
	if (!_ped->_pdp->IsFrozen())
		_ped->_pdp->PointFromTp(rtp, NULL, FALSE, pt, NULL, TA_TOP);
	_rcPos.top = _rcPos.bottom = pt.y;	//bottom will be set below in
	                                    // FetchExtents
	_rcPos.left = _rcPos.right = pt.x;

	if(preobj->sizel.cx || preobj->sizel.cy)
		_sizel = preobj->sizel;
	else
		FetchObjectExtents();

	if (!_ped->_pdp->IsFrozen())
		ResetPosRect();

    if(IsZombie())
        return CO_E_RELEASED;

	// We don't do the following anymore although it was originally spec'd as the correct
	// behavior for applications in OLE 2.01. The reason is that no one else seems to and
	// it seems to result in some odd behavior.
#if 0
    // Finally, lock down Link objects so they we don't try to refetch their
	// extents from the server.  After initialization, link object size is
	// entirely determined by the container.
	if(_pi.dwFlags & REO_LINK)
    {
        // so we don't call GetExtents on remeasuring.
        _fSetExtent = TRUE;
	}
#endif

	return NOERROR;
}

/*
 *	COleObject::MeasureObj(dypInch, dxpInch, xWidth, yHeight, yDescent)
 *
 * Review: (keithcu) Should yDescentFont be descent of font
 * or descent of entire line? LS does one thing, old measurer
 * does another. I'm hoping that this feature is only used on
 * lines with one font..
 *	@mfunc	calculates the size of this object in device units
 */
void COleObject::MeasureObj(
	long	dypInch,		//@parm	resolution of device
	long	dxpInch,
	LONG &	xWidth,			//@parm Object width
	LONG &	yAscent,		//@parm Object ascent
	LONG &  yDescent,		//@parm Object descent
	SHORT	yDescentFont)	//@parm object's font descent
{
	xWidth = W32->HimetricXtoDX(_sizel.cx, dxpInch);
	LONG yHeight = W32->HimetricYtoDY(_sizel.cy, dypInch);

	if (_pi.dwFlags & REO_BELOWBASELINE)
	{
		yDescent = yDescentFont;
		yAscent = max(0, yHeight - yDescent);
	}
	else //The normal case
	{
		yAscent = yHeight;
		yDescent = 0;
	}
}

/*
 * COleObject::InHandle(x, y, &pt)
 *
 * @mfunc  See if a point is in the rectangle defined by the handle at
 *		the given coordinates.
 *
 * @rdesc True if point is in handle.
 */
BOOL COleObject::InHandle(
	int		x,		//@parm Upper left corner x coordinate of handle box
	int		y,		//@parm Upper left corner y coordinate of handle box
	const POINT &pt)//@parm Point to check
{
    RECT    rc;

    rc.left = x;
    rc.top = y;

	// Add one to bottom right because PtInRect does not consider
	// points on bottom or right to be in rect.
    rc.right = x + dxyHandle + 1;
    rc.bottom = y + dxyHandle + 1;
    return PtInRect(&rc, pt);
}

/*
 *	COleObject::CheckForHandleHit(&pt)
 *
 *	@mfunc	Check for a hit on any of the frame handles.
 *
 *	@rdesc	 NULL if no hit, cursor resource ID if there is a hit.
 */
LPTSTR COleObject::CheckForHandleHit(
	const POINT &pt)	//@parm POINT containing client coord. of the cursor.
{
	RECT	rc;

	// If object is not resizeable, no chance of hitting a resize handle!
	if(!(_pi.dwFlags & REO_RESIZABLE))
		return NULL;

	CopyRect(&rc, &_rcPos);

	if(!_dxyFrame)
		_dxyFrame = dxyFrameDefault;

	// Check to see if point is farther into the interior of the
	// object than the handles extent. If it is we can just bail.
	InflateRect(&rc, -(_dxyFrame + dxyHandle), -(_dxyFrame + dxyHandle));
	if(PtInRect(&rc, pt))
		return NULL;

	// Check to see if point is in any of the handles and
	// return the proper cursor ID if it is.
	InflateRect(&rc, dxyHandle, dxyHandle);

	if(InHandle(rc.left, rc.top, pt) ||
	   InHandle(rc.right-dxyHandle, rc.bottom-dxyHandle, pt))
	{
		return IDC_SIZENWSE;
	}
	if(InHandle(rc.left, rc.top+(rc.bottom-rc.top-dxyHandle)/2, pt) ||
	   InHandle(rc.right-dxyHandle,
			rc.top+(rc.bottom-rc.top-dxyHandle)/2, pt))
	{
		return IDC_SIZEWE;
	}
	if(InHandle(rc.left, rc.bottom-dxyHandle, pt) ||
	   InHandle(rc.right-dxyHandle, rc.top, pt))
	{
		return IDC_SIZENESW;
	}
	if(InHandle(rc.left+(rc.right-rc.left-dxyHandle)/2, rc.top, pt) ||
	   InHandle(rc.left+(rc.right-rc.left-dxyHandle)/2,
			rc.bottom-dxyHandle, pt))
	{
		return IDC_SIZENS;
	}
	return NULL;
}

/*
 * COleObject::DrawHandle(hdc, x, y)
 *
 * @mfunc  Draw a handle on the object frame at the specified coordinate
 */
void COleObject::DrawHandle(
	HDC hdc,	//@parm HDC to be drawn into
	int x,		//@parm x coordinate of upper-left corner of handle box
	int y)		//@parm y coordinate of upper-left corner of handle box
{
    RECT    rc;

	// Draw handle by inverting
    rc.left = x;
    rc.top = y;
    rc.right = x + dxyHandle;
    rc.bottom = y + dxyHandle;
    InvertRect(hdc, (LPRECT)&rc);
}

/*
 *	COleObject::DrawFrame(pdp, hdc, prc)
 *
 *	@mfunc	Draw a frame around the object.  Invert if required and
 *		include handles if required.
 */
void COleObject::DrawFrame(
	const CDisplay *pdp,    //@parm the display to draw to
	HDC             hdc,	//@parm the device context
	RECT           *prc)  //@parm the rect around which to draw
{
	if(_pi.dwFlags & REO_OWNERDRAWSELECT)
		return;

	RECT	rc;
	CopyRect(&rc, prc);

	if(_pi.dwFlags & REO_INVERTEDSELECT)
		InvertRect(hdc, &rc);				//Invert entire object

	else
	{
		// Just the border, so use a null brush
		SaveDC(hdc);
		SetROP2(hdc, R2_NOT);
		SelectObject(hdc, GetStockObject(NULL_BRUSH));
		Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom);
		RestoreDC(hdc, -1);
	}

	if(_pi.dwFlags & REO_RESIZABLE)
	{
		int     bkmodeOld;
		HPEN	hpen;
		LOGPEN	logpen;

		bkmodeOld = SetBkMode(hdc, TRANSPARENT);

		// Get frame width
		_dxyFrame = dxyFrameDefault;
		hpen = (HPEN)GetCurrentObject(hdc, OBJ_PEN);
		if(W32->GetObject(hpen, sizeof(LOGPEN), &logpen))
		{
			if(logpen.lopnWidth.x)
				_dxyFrame = (SHORT)logpen.lopnWidth.x;
		}

		// Draw handles inside rectangle boundary
 		InflateRect(&rc, -_dxyFrame, -_dxyFrame);

		LONG x = rc.left;

		DrawHandle(hdc, x, rc.top);
		DrawHandle(hdc, x, rc.top	 + (rc.bottom - rc.top - dxyHandle)/2);
		DrawHandle(hdc, x, rc.bottom - dxyHandle);

		x = rc.left + (rc.right - rc.left - dxyHandle)/2;
		DrawHandle(hdc, x, rc.top);
		DrawHandle(hdc, x, rc.bottom - dxyHandle);

		x = rc.right - dxyHandle;
		DrawHandle(hdc, x, rc.top);
		DrawHandle(hdc, x, rc.top + (rc.bottom - rc.top - dxyHandle)/2);
		DrawHandle(hdc, x, rc.bottom - dxyHandle);

		SetBkMode(hdc, bkmodeOld);
	}
}


/*
 *	COleObject::CreateDib (hdc)
 *
 *	@mfunc	Create DIB for Windows CE display
 */
void COleObject::CreateDib(
	HDC hdc)
{
	int				nCol = 0;
    BYTE            *pbDib;
	HGLOBAL			hnew = NULL;
	BYTE			*pbSrcBits;
	LPBITMAPINFO	pbmi = (LPBITMAPINFO) GlobalLock(_hdata);
	DWORD			dwPixelsPerRow = 0;
	DWORD			dwPixels = 0;

    if(pbmi->bmiHeader.biBitCount <= 8)
    {
	    nCol = 1 << pbmi->bmiHeader.biBitCount;

		// Calculate the number of pixels.  Account for DWORD alignment
		DWORD dwPixelsPerByte = 8 / pbmi->bmiHeader.biBitCount;
		DWORD dwBitsPerRow = pbmi->bmiHeader.biWidth * pbmi->bmiHeader.biBitCount;
		dwBitsPerRow = (dwBitsPerRow + 7) & ~7;				// Round up to byte boundary
		DWORD dwBytesPerRow = dwBitsPerRow / 8;
		dwBytesPerRow = (dwBytesPerRow + 3) & ~3;			// Round up to DWORD
		dwPixelsPerRow = dwBytesPerRow * dwPixelsPerByte;

		// Double check with original
		#ifdef DEBUG
		DWORD dwBlockSize = GlobalSize(_hdata);
		DWORD dwBitMapBytes = dwBlockSize - sizeof(BITMAPINFOHEADER) - (nCol * sizeof(RGBQUAD));
		DWORD dwBitMapPixels = dwBitMapBytes * dwPixelsPerByte;
		dwPixels = dwPixelsPerRow * pbmi->bmiHeader.biHeight;
		Assert(dwPixels == dwBitMapPixels);
		#endif
    }
	else
		dwPixelsPerRow = pbmi->bmiHeader.biWidth;

	dwPixels = dwPixelsPerRow * pbmi->bmiHeader.biHeight;

	pbSrcBits = (BYTE*)(pbmi) + sizeof(BITMAPINFOHEADER) + (nCol * sizeof(RGBQUAD));

#ifdef TARGET_NT

	// For NT viewing convert four color bitmaps to 16 color bitmap
	if(nCol == 4)
	{
		// First let's figure out how big the new memory block needs to be.
		DWORD cb = sizeof(BITMAPINFOHEADER) + (16 * sizeof(RGBQUAD));
		cb += dwPixels / 2;
		hnew = GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, cb);
	
		// Now locate the interesting places
		LPBITMAPINFO pNewBmi = (LPBITMAPINFO) GlobalLock(hnew);
		BYTE *pNewBits = (BYTE*)(pNewBmi) + sizeof(BITMAPINFOHEADER) + (16 * sizeof(RGBQUAD));

		// Modify the header
		pNewBmi->bmiHeader = pbmi->bmiHeader;
		pNewBmi->bmiHeader.biBitCount = 4;
		pNewBmi->bmiHeader.biClrUsed = 4;

		// Set up the DIB RGB Colors.
		for (int i = 0; i < 16; i++)
		{
			BYTE data = 0;
			switch (i % 4)
			{
			case 0:
				break;
			case 1:
				data = 0x55;
				break;
			case 2:
				data = 0xAA;
				break;
			case 3:
				data = 0xFF;
				break;
			}
			pNewBmi->bmiColors[i].rgbBlue = data;
			pNewBmi->bmiColors[i].rgbGreen = data;
			pNewBmi->bmiColors[i].rgbRed = data;
			pNewBmi->bmiColors[i].rgbReserved = 0;
		}

		// Convert the byte array.
		for (DWORD j = 0; j < dwPixels; j++)
		{
			int iSrcByte = j / 4;

			BYTE bits = pbSrcBits[iSrcByte];
			bits >>= 6 - (j%4) * 2;
			bits &= 0x3;
			int iDstByte = j / 2;
			bits <<= 4 - (j%2) * 4;
			pNewBits[iDstByte] |= bits;
		}
		GlobalUnlock(pbmi);
		pbmi = pNewBmi;
		pbSrcBits = pNewBits;
	}
#endif

	_hdib = CreateDIBSection(hdc, pbmi, DIB_RGB_COLORS, (void**)&pbDib, NULL, 0);
	if(_hdib == NULL)
	{
		_ped->GetCallMgr()->SetOutOfMemory();

        // V-GUYB:
        // Do not attempt to repaint this picture until the user starts typing in the
        // control. This allows the user to dismiss the oom that will appear and then
        // save the document, and then free up some space. If we don't do this here,
        // every time the oom msg is dismissed it will appear again. This doesn't allow
        // the user to save the document unless they can find some memory to free.
        _fDraw = FALSE;

		TRACEWARNSZ("Out of memory creating DIB");
		return;
	}

	DWORD nBytes;

	if(nCol)
	{
		DWORD nPixelsPerByte =  8 / pbmi->bmiHeader.biBitCount;
		nBytes = dwPixels / nPixelsPerByte;
	}
	else
		nBytes =  dwPixels * 4;			// Each pixel occupies 4 bytes in DIB
	CopyMemory(pbDib, pbSrcBits, nBytes);

	GlobalUnlock(pbmi);
	GlobalFree(hnew);
}

/*
 *	COleObject::DrawDib (hdc, prc)
 *
 *	@mfunc	Auxiliary function that draws the dib in the given dc
 */
void COleObject::DrawDib(
	HDC hdc,
	RECT *prc)
{
	if(!_hdib)
		CreateDib(hdc);

	// If _hdib is still NULL, just return.  Maybe out of memory.
	if(!_hdib)
		return;

	HDC hdcMem = CreateCompatibleDC(hdc);
	LPBITMAPINFO	pbmi = (LPBITMAPINFO) LocalLock(_hdata);
	SelectObject(hdcMem, _hdib);
    StretchBlt(hdc, prc->left, prc->top,
			prc->right - prc->left, prc->bottom - prc->top,
			hdcMem, 0, 0, pbmi->bmiHeader.biWidth, pbmi->bmiHeader.biHeight, SRCCOPY);
	GlobalUnlock(pbmi);
	DeleteDC(hdcMem);
}

/*
 *	COleObject::DrawObj (pdp, hdc, fMetafile, ppt, prcRender)
 *
 *	@mfunc	draws the object
 */
void COleObject::DrawObj(
	const CDisplay *pdp,	//@parm Display object for the view
	LONG		dypInch,	//@parm Resolution of device
	LONG		dxpInch,
	HDC			hdc,		//@parm Drawing HDC (can differ from display's)
	BOOL		fMetafile,	//@parm Whether the HDC is a metafile
	POINT *		ppt,		//@parm Top left corner of where to draw
	RECT  *		prcRender,	//@parm Pointer to render rectangle
	LONG		yBaselineLine,
	LONG		yDescentMaxCur)
{
	LONG			 adjust = 0;
	BOOL			 fMultipleSelect = FALSE;
	CObjectMgr *	 pobjmgr = _ped->GetObjectMgr();
	IViewObject *	 pvo;
	CDisplayPrinter *pdpPrint;
	RECT			 rc, rc1;
	LONG			 cpMin, cpMost;
	_ped->GetSelRangeForRender(&cpMin, &cpMost);
	BOOL			 fSelected = _cp >= cpMin && _cp < cpMost;

	SaveDC(hdc);

	if (fSelected)
		SetBkMode(hdc, OPAQUE);

	if(pdp->IsMain() && !(_pi.dwFlags & REO_OWNERDRAWSELECT))
	{
		if(fSelected)
		{
			if(cpMost - cpMin > 1)
				fMultipleSelect = TRUE;

			// The following overwrites the selection colors currently
			// selected into the hdc. We do this for RE 2.0 compatibility,
			// e.g., else selected name links in Outlook appear yellow
			// after the InvertRect() in DrawFrame() (altho the semicolon
			// blanks appear in selection colors). Note: we could define
			// REO_OWNERDRAWSELECT, which would bypass the following 2 lines
			// and suppress the InvertRect below and in DrawFrame(). Then
			// Outlook's From:, To:, and CC: would have correct selection
			// colors throughout.
			::SetTextColor(hdc, _ped->TxGetForeColor());
			::SetBkColor  (hdc, _ped->TxGetBackColor());
		}
	}

	if(_fInPlaceActive || !_fDraw)
	{
		// If we're inplace active, don't do anything; the server is
		// drawing for us. We also don't do anything prior to the fDraw
		// property being set
		return;
	}

	//REVIEW (keithcu) Do we need this?
	//Worse case, update only if pdp->IsMain(). This whole thing is ugly.
	if (pdp->IsMain())
		ResetPosRect(&adjust);		// Update position rectangle

	// Draw object where we are asked within rendering rectangle
	rc.left = ppt->x;
	rc.right = rc.left + W32->HimetricXtoDX(_sizel.cx, dxpInch);

	rc.bottom = ppt->y + yBaselineLine;
	rc.top = rc.bottom - W32->HimetricYtoDY(_sizel.cy, dypInch);

	if (_pi.dwFlags & REO_BELOWBASELINE)
		OffsetRect(&rc, 0, yDescentMaxCur);

	SetTextAlign(hdc, TA_TOP);

	SaveDC(hdc);  // calls to OLE object (IViewObject::Draw or OleDraw) might change HDC

	//Do clipping because OLE doesn't know where to draw
	IntersectClipRect(hdc, prcRender->left, prcRender->top,
					 prcRender->right, prcRender->bottom);

	if(_hdata)
	{
		// This is some Windows CE Dib, let's try the direct approach
		DrawDib(hdc, &rc);
	}
	else if(fMetafile)
	{
		if(_punkobj->QueryInterface(IID_IViewObject, (void **)&pvo)
				== NOERROR)
		{
			pdpPrint = (CDisplayPrinter *)pdp;
			rc1 = pdpPrint->GetPrintPage();

			// Fix up rc for Draw()
			rc1.bottom = rc1.bottom - rc1.top;			
			rc1.right = rc1.right - rc1.left;

			pvo->Draw(_pi.dvaspect, -1, NULL, NULL, 0, hdc, (RECTL *)&rc,
					(RECTL *)&rc1, NULL, 0);
			pvo->Release();
		}
	}
	else
		OleDraw(_punkobj, _pi.dvaspect, hdc, &rc);

	RestoreDC(hdc, -1);

	// Do selection stuff if this is for the main (screen) view.
	if(pdp->IsMain())
	{
		if(_pi.dwFlags & REO_OPEN)
			OleUIDrawShading(&rc, hdc);

		// If the object has been selected by clicking on it, draw
		// a frame and handles around it.  Otherwise, if we are selected
		// as part of a range, invert ourselves.
		if(!fMetafile && pobjmgr->GetSingleSelect() == this)
			DrawFrame(pdp, hdc, &rc);

		else if(fMultipleSelect)
			InvertRect(hdc, &rc);
	}
	RestoreDC(hdc, -1);
}

/*
 *	COleObject::Delete (publdr)
 *
 *	@mfunc	deletes this object from the backing store _without_
 *			making outgoing calls.  The commit on generated anti-events
 *			will handle the outgoing calls
 */
void COleObject::Delete(
	IUndoBuilder *publdr)
{

	Assert(_fInUndo == FALSE);
	_fInUndo = TRUE;

	CNotifyMgr *pnm = _ped->GetNotifyMgr();
	if(pnm)
		pnm->Remove((ITxNotify *)this);

	if(publdr)
	{
		// The anti-event will take care of calling IOO::Close for us
		IAntiEvent *pae = gAEDispenser.CreateReplaceObjectAE(_ped, this);
		if(pae)
			publdr->AddAntiEvent(pae);
	}
	else
	{
		Close(OLECLOSE_NOSAVE);
		MakeZombie();
	}

	// If we're being deleted, we can't be selected anymore
	_pi.dwFlags &= ~REO_SELECTED;
	_fDraw = 0;
}

/*
 *	COleObject::Restore()
 *
 *	@mfunc	restores the object from the undo state back into the
 *			backing store
 *
 *			No outgoing calls will be made
 */
void COleObject::Restore()
{
	Assert(_fInUndo);

	_fInUndo = FALSE;
	_fDraw = TRUE;

	CNotifyMgr *pnm = _ped->GetNotifyMgr();
	if(pnm)
		pnm->Add((ITxNotify *)this);
}

/*
 *	COleObject::SetREOSELECTED (fSelect)
 *
 *	@mfunc	cmember set REO_SELECTED state
 */
void COleObject::SetREOSELECTED(
	BOOL fSelect)
{
	_pi.dwFlags &= ~REO_SELECTED;
	if(fSelect)
		_pi.dwFlags |= REO_SELECTED;
}

/*
 *	COleObject::Close(dwSave)
 *
 *	@mfunc	closes this object
 */
void COleObject::Close(
	DWORD	dwSave)		//same as IOleObject::Close
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "COleObject::Close");

	if(!_punkobj)
		return;

	IOleObject *poo;
	if(_punkobj->QueryInterface(IID_IOleObject, (void **)&poo) == NOERROR)
	{
		poo->Close(dwSave);
		poo->Release();
	}
}

/*
 *	COleObject::ScrollObject(dx, dy, prcScroll)
 *
 *	@mfunc	updates _rcPos if we were scrolled
 */
void COleObject::ScrollObject(
	LONG dx,			//@parm Change in the x direction
	LONG dy,			//@parm Change in the y direction
	LPCRECT prcScroll)	//@parm Rect that is being scrolled
{
	RECT rcInter;

	// If we're inplace active, OnReposition will handle the scrolling
	if(!_fInPlaceActive && !_fGuardPosRect &&
		IntersectRect(&rcInter, &_rcPos, prcScroll))
	{
		OffsetRect(&_rcPos, dx, dy);
	}
}

				
//
//	PRIVATE methods
//
/*
 *	COleObject::~COleObject()
 *
 *	@mfunc	destructor
 */
COleObject::~COleObject()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "COleObject::~COleObject");

	CleanupState();
}

/*
 *	COleObject::SavePrivateState()
 *
 *	@mfunc	Saves information such as the aspect and various flags
 *	into the object's storage.
 *
 *	@devnote	This method is used mostly for compatibility with
 *	richedit 1.0--we save the same information they did.
 *
 *	Also note that this method returns void--even if any particular
 *	call failes, we should be able to "recover" and limp along.
 *	Richedit 1.0 also had this behavior.
 */
void COleObject::SavePrivateState()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "COleObject::SavePrivateState");
	Assert(_pstg);

	IStream *	pstm;
	HRESULT hr = _pstg->CreateStream(szSiteFlagsStm, STGM_READWRITE |
					STGM_CREATE | STGM_SHARE_EXCLUSIVE, 0, 0, &pstm);
    if(IsZombie())
        return;

	if(hr == NOERROR)
	{
		pstm->Write(&_pi, sizeof(PersistedInfo), NULL);
		pstm->Release();
	}
}

/*
 *	COleObject::FetchObjectExtents()
 *
 *	@mfunc 	determines the object's size in himetric.  Typically, this
 *			is achieved via IOleObject::GetExtent, but some error
 *			recovery is implemented
 *
 *	@rdesc	void.  _sizel is updated
 */
void COleObject::FetchObjectExtents()
{
	HRESULT hr = NOERROR;
	IOleObject *poo;
	IViewObject2 *pvo;
	CDisplay *pdp;

    if(IsZombie())
        return;

	// We _don't_ want to make calls to GetExtent if:
	// (1) We have outstanding updates to _sizel for which we
	//		haven't successfully called SetExtent
	// (2) This is a PaintBrush object and the most recent call
	//		to SetExtent for this PB object failed

	if(_fAspectChanged || !(_fSetExtent || (_fIsPaintBrush && _fPBUseLocalSizel)))
	{	
		// try IOleObject::GetExtent as long as we shouldn't try for
		// the metafile first.

		// If this flag was set, it has done its job so turn it off.
		_fAspectChanged = FALSE;

		if(!(_pi.dwFlags & REO_GETMETAFILE))
		{
			hr = _punkobj->QueryInterface(IID_IOleObject, (void **)&poo);
			if(hr == NOERROR)
			{
				hr = poo->GetExtent(_pi.dvaspect, &_sizel);
				poo->Release();
			}
			if(IsZombie())
				return;
		}
		else
			hr = E_FAIL;

		if(hr != NOERROR)
		{
			if(_punkobj->QueryInterface(IID_IViewObject2, (void **)&pvo) == NOERROR)
			{
				hr = pvo->GetExtent(_pi.dvaspect, -1, NULL, &_sizel);
				pvo->Release();
			}
		}

	    if(IsZombie())
	        return;

		if(hr != NOERROR || _sizel.cx == 0 || _sizel.cy == 0)
			_sizel.cx = _sizel.cy = 2000;
	}
	// If _fSetExtent==TRUE, we've made a change to _sizel for which
	// we haven't called IOleObject::SetExtent successfully.  Therefore
	// fall through with existing _sizel.

	// Update our position rectangle
	pdp = _ped->_pdp;

	_rcPos.right  = _rcPos.left + pdp->HimetricXtoDX(_sizel.cx);
	_rcPos.bottom = _rcPos.top  + pdp->HimetricYtoDY(_sizel.cy);
}

/*
 *	COleObject::ConnectObject()
 *
 *	@mfunc	setup the necessary advises to the embedded object.
 *
 *	@rdesc 	HRESULT
 *
 *	@comm	This code is similar to ole2ui's OleStdSetupAdvises
 */
HRESULT COleObject::ConnectObject()
{
	IViewObject *pvo;
	IOleObject *poo;

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "COleObject::ConnectObject");
	
    if(IsZombie())
        return CO_E_RELEASED;
	
	Assert(_punkobj);

	if(_punkobj->QueryInterface(IID_IViewObject, (void **)&pvo) == NOERROR)
	{
		pvo->SetAdvise(_pi.dvaspect, ADVF_PRIMEFIRST, (IAdviseSink *)this);
		pvo->Release();
	}

    if(IsZombie())
        return CO_E_RELEASED;
	
	HRESULT hr = _punkobj->QueryInterface(IID_IOleObject, (void **)&poo);
	if(hr == NOERROR)
	{
		hr = poo->Advise((IAdviseSink *)this, &_dwConn);

		CObjectMgr *pobjmgr = _ped->GetObjectMgr();
		Assert(pobjmgr);

		// The doc may be NULL, but not the app.  Don't do anything
		// if the app name is NULL
		if(pobjmgr->GetAppName())
		{
			hr = poo->SetHostNames(pobjmgr->GetAppName(),
						pobjmgr->GetDocName());
		}
		poo->Release();
	}

    if(IsZombie())
        return CO_E_RELEASED;
	
	OleSetContainedObject(_punkobj, TRUE);
	return hr;
}

/*
 *	COleObject::DisconnectObject
 *
 *	@mfunc	reverses the connections made in ConnectObject and releases
 *			the object.  Note that the object's storage is _NOT_
 *			released.
 */
void COleObject::DisconnectObject()
{
	IOleObject * poo = NULL;
	IViewObject *pvo = NULL;

	if(IsZombie())
		return;		// Already Disconnected.

	if(_punkobj->QueryInterface(IID_IOleObject, (void **)&poo) == NOERROR)
	{
		poo->SetClientSite(NULL);
		if(_dwConn)
			poo->Unadvise(_dwConn);
	
		poo->Release();
	}

	if(_punkobj->QueryInterface(IID_IViewObject, (void **)&pvo) == NOERROR)
	{
		pvo->SetAdvise(_pi.dvaspect, ADVF_PRIMEFIRST, NULL);
		pvo->Release();
	}

	CoDisconnectObject(_punkobj, NULL);
	SafeReleaseAndNULL(&_punkobj);
}

/*
 *	COleObject::MakeZombie()
 *
 *	@mfunc	Force this object to enter a zombie state.  This
 *      is called when we should be gone but aren't.  It cleans
 *      up our state and flags us so we don't do nasty things
 *		between now and the time were are deleted.
 *
 */
void COleObject::MakeZombie()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "COleObject::MakeZombie");

	CleanupState();
    Zombie();
}

/*
 *	COleObject::CleanupState()
 *
 *	@mfunc	Called on delete and when we become zombied.  It cleans
 *		up our member data and any other dependencies that need to
 *		be resolved.
 */
void COleObject::CleanupState()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "COleObject::CleanupState");
	
    if(_ped && !_fInUndo)
	{
		CNotifyMgr *pnm = _ped->GetNotifyMgr();
		if(pnm)
			pnm->Remove((ITxNotify *)this);

		_ped = NULL;
	}

	DisconnectObject();

	if(_pstg)
		SafeReleaseAndNULL((IUnknown**)&_pstg);

	if(_hdib)
	{
		::DeleteObject(_hdib);
		_hdib = NULL;
	}
	GlobalFree(_hdata);
	_hdata = NULL;
	if(_pimageinfo)
	{
		delete _pimageinfo;
		_pimageinfo = NULL;
	}
}	

/*
 *	COleObject::ActivateObj	(uiMsg, wParam, lParam)
 *	
 *	@mfunc Activates the object.
 *
 *	@rdesc
 *		BOOL	Whether object has been activated.
 */
BOOL COleObject::ActivateObj(
	UINT uiMsg,
	WPARAM wParam,
	LPARAM lParam)
{
	LPOLEOBJECT		poo;
	HWND			hwnd;
	MSG				msg;
	DWORD			dwPos;

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "COleObject::AcitvateObj");

	if(_ped->TxGetWindow(&hwnd) != NOERROR)
		return FALSE;

	ResetPosRect();

	// Fill in message structure
	msg.hwnd = hwnd;
	msg.message = uiMsg;
	msg.wParam = wParam;
	msg.lParam = lParam;
	msg.time = GetMessageTime();
	dwPos = GetMessagePos();
	msg.pt.x = (LONG) LOWORD(dwPos);
	msg.pt.y = (LONG) HIWORD(dwPos);

	// Force this object to be selected, if it isn't already
	// Update the selection before making the outgoing call
	if(!(_pi.dwFlags & REO_SELECTED))
	{
		CTxtSelection *psel = _ped->GetSel();
		if(psel)
			psel->SetSelection(_cp, _cp + 1);
	}

	// Execute the primary verb
	if(_punkobj->QueryInterface(IID_IOleObject, (void **)&poo) == NOERROR)
	{
		_fActivateCalled = TRUE;

		// Make sure we tell the object its size has changed if we haven't
		// already notified it.
		if(_fSetExtent)
			SetExtent(SE_ACTIVATING);

		HRESULT	hr;
		hr = poo->DoVerb(OLEIVERB_PRIMARY, &msg, (LPOLECLIENTSITE)this, 0, hwnd, &_rcPos);

#ifndef MACPORT
		if(FAILED(hr))
		{
			ENOLEOPFAILED	enoleopfailed;

			enoleopfailed.iob = _ped->_pobjmgr->FindIndexForCp(GetCp());
			enoleopfailed.lOper = OLEOP_DOVERB;
			enoleopfailed.hr = hr;
	        _ped->TxNotify(EN_OLEOPFAILED, &enoleopfailed);
		}
#endif
	    poo->Release();

		if(_fInPlaceActive && !(_pi.dwFlags & REO_INPLACEACTIVE))
		{
			CObjectMgr *pobjmgr = _ped->GetObjectMgr();
			Assert(!pobjmgr->GetInPlaceActiveObject());	
			pobjmgr->SetInPlaceActiveObject(this);
			_pi.dwFlags |= REO_INPLACEACTIVE;
		}
		_fActivateCalled = FALSE;
	}
	else
		return FALSE;

	return TRUE;
}

/*
 *	COleObject::DeActivateObj
 *	
 *	@mfunc Deactivates the object.
 *
 */
HRESULT COleObject::DeActivateObj(void)
{
	IOleInPlaceObject * pipo;
	IOleObject *poo;
	MSG msg;
	HRESULT hr = NOERROR;

	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEINTERN, "COleObject::DeActivateObj");

	if (_fDeactivateCalled)
	{
		// There are multiple paths through the deactive code. The assumption
		// with this logic is that it is more disconcerting for an app to
		// get multiple deactivate calls than the opposite. This might
		// prove to be an incorrect assumption. This go put in because I
		// added a DeActivateObj call in DeActivateObj where there wasn't
		// one before and I was afraid that this could cause problems because
		// apps might get a call that they didn't have before. It is important
		// to note that the opposite might be the case. (a-rsail).
		return NOERROR;
	}

	_fDeactivateCalled = TRUE;

	ResetPosRect();

	if(_punkobj->QueryInterface(IID_IOleInPlaceObject, (void **)&pipo)
		== NOERROR)
	{
		hr  =_punkobj->QueryInterface(IID_IOleObject, (void **)&poo);
		if(hr == NOERROR)
		{
			// This code is a bit different from 1.0, but seems to
			// make things work a bit better.  Basically, we've taken a leaf
			// from various sample apps and do the most brute force "de-activate"
			// possible (you'd think just one call would be enough ;-)

			// Don't bother with the error return here.
			pipo->UIDeactivate();
			
			// Fake something
			ZeroMemory(&msg, sizeof(MSG));
			msg.message = WM_LBUTTONDOWN;	
			_ped->TxGetWindow(&msg.hwnd);

			// Again, don't bother checking for errors; we need to
			// plow through and get rid of stuff as much as possible.
			poo->DoVerb(OLEIVERB_HIDE, &msg, (IOleClientSite *)this,
			-1, msg.hwnd, &_rcPos);

			// COMPATIBILITY ISSUE (alexgo): the RE1.0 code did some funny
			// stuff with undo here, but I don't think it's necessary now
			// with our multi-level undo model.
			hr = pipo->InPlaceDeactivate();
			poo->Release();
		}
	    pipo->Release();
	}

	_fDeactivateCalled = FALSE;
	return hr;
}

/*
 *	COleObject::Convert (rclsidNew,	lpstrUserTypeNew)
 *
 *	@mfunc	Converts the object to the specified class.  Does reload
 *		the object but does NOT force an update (caller must do this).
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
HRESULT COleObject::Convert(
	REFCLSID rclsidNew,			//@parm Destination clsid
	LPCSTR	 lpstrUserTypeNew)	//@parm New user type name
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::Convert");

	CLIPFORMAT cfOld;
	CLSID clsidOld;
	LPOLESTR szUserTypeOld = NULL;
	HRESULT hr;
	HRESULT hrLatest;
	UsesMakeOLESTR;


	// If object has no storage, return
	if(!_pstg)
		return ResultFromScode(E_INVALIDARG);

	// Read the old class, format, and user type in
	if ((hr = ReadClassStg(_pstg, &clsidOld)) ||
		(hr = ReadFmtUserTypeStg(_pstg, &cfOld, &szUserTypeOld)))
	{
		return hr;
	}

	// Unload object
	Close(OLECLOSE_SAVEIFDIRTY);
	_punkobj->Release();

    if(IsZombie())
        return CO_E_RELEASED;

	// Write new class and user type, but old format, into storage
	if ((hr = WriteClassStg(_pstg, rclsidNew)) ||
		(hr = WriteFmtUserTypeStg(_pstg, cfOld,
			(LPOLESTR) MakeOLESTR(lpstrUserTypeNew))) ||
		(hr = SetConvertStg(_pstg, TRUE)) ||
		((hr = _pstg->Commit(0)) && (hr = _pstg->Commit(STGC_OVERWRITE))))
	{
		// Uh oh, we're in a bad state; rewrite the original info
		(VOID) WriteClassStg(_pstg, clsidOld);
		(VOID) WriteFmtUserTypeStg(_pstg, cfOld, szUserTypeOld);
	}

    if(IsZombie())
        return CO_E_RELEASED;

	// Reload the object and connect. If we can't reload it, delete it.
	hrLatest = OleLoad(_pstg, IID_IOleObject, (LPOLECLIENTSITE) this,
			(void **)&_punkobj);

	if(hrLatest != NOERROR)
	{
		CRchTxtPtr	rtp(_ped, _cp);

		// we don't want the delete of this object to go on the undo
		// stack.  We use a space so that cp's will work out right for
		// other undo actions.
		rtp.ReplaceRange(1, 1, L" ", NULL, -1);
	}
	else
		ConnectObject();

	// Free the old
	CoTaskMemFree(szUserTypeOld);
	return hr ? hr : hrLatest;
}

/*
 *	COleObject::ActivateAs (rclsid, rclsidAs)
 *
 *	@mfunc	Handles a request by the user to activate all objects of a particular
 *		class as objects of another class.
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
HRESULT COleObject::ActivateAs(
	REFCLSID rclsid,
	REFCLSID rclsidAs)
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::ActivateAs");

	IOleObject * poo = NULL;
	CLSID	clsid;

	// Get clsid of object
	HRESULT hr = _punkobj->QueryInterface(IID_IOleObject, (void **)&poo);
	if(hr == NOERROR)
	{
		// NOTE:  We are depending on the behavior of GetUserClassID to
		// return the current clsid of the object (not the TreatAs id).
		// This should hold true as long as long as we haven't reloaded
		// it yet.  If there are problems with ActivateAs in the future,
		// this might be a suspect.
		hr = poo->GetUserClassID(&clsid);
		poo->Release();
	}

	if(hr != NOERROR)
		return hr;
	
    if(IsZombie())
        return CO_E_RELEASED;

	// Check to see if object clsid matches clsid to be treated as something
	// else. If it is we need to unload and reload the object.
	if(IsEqualCLSID(clsid, rclsid))
	{
		// Unload object
		Close(OLECLOSE_SAVEIFDIRTY);
		_punkobj->Release();

		if(IsZombie())
			return CO_E_RELEASED;

		// Reload object and connect. If we can't reload it, delete it.
		hr = OleLoad(_pstg, IID_IOleObject, (LPOLECLIENTSITE) this,
				(void **)&_punkobj);

		if(hr != NOERROR)
		{
			CRchTxtPtr	rtp(_ped, _cp);

			// We don't want the delete of this object to go on the undo
			// stack.  We use a space so that cp's will work out right for
			// other undo actions.
			rtp.ReplaceRange(1, 1, L" ", NULL, -1);
		}
		else
			ConnectObject();
	}
	return hr;
}

/*
 *	COleObject::SetLinkAvailable(fAvailable)
 *
 *	@mfunc
 *		Allows client to tell us whether the link is available or not.
 *
 *	@rdesc
 *		HRESULT				Success code.
 */
HRESULT COleObject::SetLinkAvailable(
	BOOL fAvailable)	//@parm	if TRUE, make object linkable
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::SetLinkAvailable");
	
	// If this is not a link, return
	if(!(_pi.dwFlags & REO_LINK))
		return E_INVALIDARG;

	// Set flag as appropriate
	_pi.dwFlags &= ~REO_LINKAVAILABLE;
	if(fAvailable)
		_pi.dwFlags |= REO_LINKAVAILABLE;

	return NOERROR;
}

/*
 *	COleObject::WriteTextInfoToEditStream(pes)
 *
 *	@mfunc
 *		Used for textize support,  Tries to determine the text
 *		representation for an object and then writes that info
 *		to the given stream.  The only thing this is particularly useful
 *		for is to support richedit1.0's TEXTIZED data format.
 *
 *	@rdesc
 *		LONG				Number of chras written..
 */
LONG COleObject::WriteTextInfoToEditStream(
	EDITSTREAM *pes)
{
	LONG cch;
	LONG cbWritten = 0;
	IOleObject *poo;
	IDataObject *pdataobj = NULL;
	STGMEDIUM med;
	char *pch;			//we only deal with ANSI data here

	HANDLE		hGlobal;

	HRESULT hr = _punkobj->QueryInterface(IID_IOleObject, (void **)&poo);
	if(hr == NOERROR)
	{
		hr = poo->GetClipboardData(0, &pdataobj);
        poo->Release();
	}

	if(FAILED(hr))
	{
		hr = _punkobj->QueryInterface(IID_IDataObject, (void **)&pdataobj);
		if(FAILED(hr))
		{
			pes->dwError = (DWORD) E_FAIL;
			goto Default;
		}
	}

	med.tymed = TYMED_HGLOBAL;
	med.pUnkForRelease = NULL;
	med.hGlobal = NULL;

	hr = pdataobj->GetData(&g_rgFETC[iAnsiFETC], &med);
	if(FAILED(hr))
		pes->dwError = (DWORD)hr;
	else
	{
		hGlobal = med.hGlobal;
		pch = (char *)GlobalLock(hGlobal);
		if(pch)
		{
			for (cch = 0; pch[cch]; cch++);
			pes->dwError = pes->pfnCallback(pes->dwCookie, (BYTE *)pch, cch,
												&cbWritten);
			GlobalUnlock(hGlobal);
		}
		ReleaseStgMedium(&med);
	}

Default:
	if(cbWritten <= 0)
	{
		char ch = ' ';

		pes->pfnCallback(pes->dwCookie, (BYTE *)&ch, sizeof(char), &cbWritten);
		pes->dwError = 0;
	}

    pdataobj->Release();
	return cbWritten;
}

/*
 *	COleObject::SetDvaspect (dvaspect)
 *
 *	@mfunc	Allows client to tell us which aspect to use and force us
 *		to recompute positioning and redraw.
 */
void COleObject::SetDvaspect(
	DWORD dvaspect)	//@parm	the aspect to use
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::SetDvaspect");

	_pi.dvaspect = dvaspect;
	
	// Force FetchObjectExtents to call through
	_fAspectChanged = TRUE;

	// Cause ourselves to redraw and update
	OnViewChange(dvaspect, (DWORD) -1);
}

/*
 *	COleObject::HandsOffStorage
 *
 *	@mfunc	See IPersistStore::HandsOffStorage.
 *
 */
void COleObject::HandsOffStorage(void)
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::HandsOffStorage");

	// Free storage we currently have, if we have one.
	SafeReleaseAndNULL((IUnknown**)&_pstg);
}

/*
 *	COleObject::SaveCompleted
 *
 *	@mfunc	See IPersistStore::SaveCompleted.
 */
void COleObject::SaveCompleted(
	LPSTORAGE lpstg)	//@parm	new storage
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "COleObject::SaveCompleted");

	// Did our caller give us a new storage to remember?
	if(lpstg)
	{
		// Free storage we currently have, if we have one
		if(_pstg)
			SafeReleaseAndNULL((IUnknown**)&_pstg);

		// Remember storage we are given, since we are given one
		lpstg->AddRef();
		_pstg = lpstg;
	}
}

/*
 *	SetAllowedResizeDirections
 *	
 *	@func Resizing helper function
 *
 */
static void SetAllowedResizeDirections(
	const POINT  & pt,
	const RECT   & rc,
	      LPTSTR   lphand,
	      BOOL   & fTop,
	      BOOL   & fBottom,
	      BOOL   & fLeft,
	      BOOL   & fRight)
{
   	fTop = abs(pt.y - rc.top) < abs(pt.y - rc.bottom);
	fBottom = !fTop;
	fLeft = abs(pt.x - rc.left) < abs(pt.x - rc.right);
	fRight = !fLeft;

	if(lphand == IDC_SIZENS)
		fLeft = fRight = FALSE;

	else if(lphand == IDC_SIZEWE)
		fTop = fBottom = FALSE;
}

/*
*	SetRestriction.
 *	
 *	@func Resizing helper function determines bounding rectangle for resizing.
 */
static void SetRestriction(
    RECT  & rc,
	HWND    hwnd,
	DWORD   dwScroll)
{
	GetClientRect(hwnd, &rc);
	InflateRect(&rc, -1, -1);			// So rectangle is visible

	// Allow objects to grow larger than the window in the
	// directions which have scrollbars
	if(dwScroll & WS_HSCROLL)
		rc.right = MAXLONG;

	if(dwScroll & WS_VSCROLL)
		rc.bottom = MAXLONG;
}

/*
 *	Restrict (&pt, &rc)
 *	
 *	@func Resizing helper function bounds a point within a rectangle
 */
static void Restrict(
	POINT  &pt,
	RECT   &rc)
{
	if(pt.x < rc.left)
		pt.x = rc.left;
	else if(pt.x > rc.right)
		pt.x = rc.right;

	if(pt.y < rc.top)
		pt.y = rc.top;
	else if(pt.y > rc.bottom)
		pt.y = rc.bottom;
}

/*
 *	COleObject::HandleResize (&pt)
 *	
 *	@mfunc Deal with object resizing.
 *
 *	@rdesc	BOOL
 */
BOOL COleObject::HandleResize(
	const POINT &pt)
{
	LPTSTR lphand;
	DWORD  dwFlags = _pi.dwFlags;
 	HWND   hwnd;
	RECT   rcOld;
	RECT   rcRestrict;
	BOOL   fTop, fBottom, fLeft, fRight;
	BOOL   fEscape;
	CDisplay *pdp = _ped->_pdp;

	if(!(dwFlags & REO_SELECTED)	||
		!(dwFlags & REO_RESIZABLE)	||
		(lphand = CheckForHandleHit(pt)) == NULL || !pdp)
	{
		return FALSE;
	}
 	
	HDC hdc = pdp->GetDC();
	rcOld = _rcPos;				// Save old size
	_ped->TxGetWindow(&hwnd);
	SetCapture(hwnd);
	
	SetRestriction(rcRestrict, hwnd, _ped->TxGetScrollBars());

	SetAllowedResizeDirections(pt, _rcPos, lphand,
		                       fTop, fBottom, fLeft, fRight);
	
	// Erase and redraw frame without handles.
	DrawFrame(pdp, hdc, &_rcPos);
	_pi.dwFlags = REO_NULL;
	DrawFrame(pdp, hdc, &_rcPos);

	fEscape = FALSE;
	const INT vkey = GetSystemMetrics(SM_SWAPBUTTON) ? VK_RBUTTON : VK_LBUTTON;
	while (GetAsyncKeyState(vkey) & 0x8000)
	{		
		POINT ptLast = pt;
		POINT ptCur;
		MSG msg;

		// Stop if the ESC key has been pressed
		if(GetAsyncKeyState(VK_ESCAPE) & 0x0001)
		{
			fEscape = TRUE;
			break;
		}
		
		GetCursorPos(&ptCur);
		ScreenToClient(hwnd, &ptCur);

// GetCursorPos() isn't supported on WinCE. We have  it hacked to
// be GetMessagePos() which unfortunately in this case will cause
// ptCur to never change. By removing this check we end up drawing
// multiple times when the user pauses during a resize.
#ifndef UNDER_CE
		// If mouse hasn't moved, try again
		if((ptCur.x == ptLast.x) && (ptCur.y == ptLast.y))
			continue;
#endif

		ptLast = ptCur;
		Restrict(ptCur, rcRestrict);

		// Erase old rectangle, update rectangle, and redraw
		DrawFrame(pdp, hdc, &_rcPos);	
		if(fLeft)   _rcPos.left   = ptCur.x;
		if(fRight)  _rcPos.right  = ptCur.x;
		if(fTop)    _rcPos.top    = ptCur.y;
		if(fBottom) _rcPos.bottom = ptCur.y;
		// Keep a minimun width and height
		INT xWidthSys = pdp->GetXWidthSys();
		INT yHeightSys = pdp->GetYHeightSys();
		if(_rcPos.right - _rcPos.left < xWidthSys)
		{
			if(fLeft) _rcPos.left = _rcPos.right - xWidthSys;
			if(fRight) _rcPos.right = _rcPos.left + xWidthSys;
		}
		if(_rcPos.bottom - _rcPos.top < yHeightSys)
		{
			if(fTop) _rcPos.top = _rcPos.bottom - yHeightSys;
			if(fBottom) _rcPos.bottom = _rcPos.top + yHeightSys;
		}

		DrawFrame(pdp, hdc, &_rcPos);
		// FUTURE: (joseogl): It would be cool if we could do something
		// bettter here, but for now, it appears to be necessary.
		Sleep(100);
		
		// Eat input messages
		if (PeekMessage(&msg, 0, WM_KEYFIRST, WM_KEYLAST, PM_REMOVE) ||
			PeekMessage(&msg, 0, WM_MOUSEFIRST,
			                      WM_MOUSELAST, PM_REMOVE | PM_NOYIELD) ||
			PeekMessage(&msg, 0, WM_NCMOUSEFIRST,
			                      WM_NCMOUSELAST, PM_REMOVE | PM_NOYIELD))
		{
			// Break out of the loop if the Escape key was pressed
		    if(msg.message == WM_KEYDOWN && msg.wParam == VK_ESCAPE)
			{
	        	fEscape = TRUE;
				break;
			}
		}
	}

	DrawFrame(pdp, hdc, &_rcPos);
  	ReleaseCapture();
	RECT rcNew = _rcPos;
	_rcPos = rcOld;
 	_pi.dwFlags = dwFlags;

	// If user aborted, then we skip the resizing stuff
	if(fEscape)
		DrawFrame(pdp, hdc, &_rcPos);
	else
	{
		EnableGuardPosRect();
		Resize(rcNew);
		DrawFrame(pdp, hdc, &_rcPos);
		DisableGuardPosRect();
	}
	pdp->ReleaseDC(hdc);
	return TRUE;
}

/*
 *	COleObject::Resize(rcNew)
 *	
 *	@mfunc Set new object size.  Handle undo details.
 */
void COleObject::Resize(
	const RECT &rcNew)
{
	CDisplay *	pdp = _ped->_pdp;
	SIZEL		sizelold = _sizel;

	// Change the size of our internal representation.
	_sizel.cx = pdp->DXtoHimetricX(rcNew.right - rcNew.left);
	_sizel.cy = pdp->DYtoHimetricY(rcNew.bottom - rcNew.top);

	//If size didn't really change, don't do anything else.
	if(_sizel.cx != sizelold.cx || _sizel.cy != sizelold.cy)
	{
		if(_ped->_fUseUndo)
		{
			CGenUndoBuilder undobldr(_ped, UB_AUTOCOMMIT);
			IAntiEvent *pae;

			pae = gAEDispenser.CreateResizeObjectAE(_ped, this, _rcPos);
			if(pae)
				undobldr.AddAntiEvent(pae);
		}
		_rcPos.bottom = _rcPos.top + pdp->HimetricYtoDY(_sizel.cy);
		_rcPos.right = _rcPos.left + pdp->HimetricXtoDX(_sizel.cx);

		SetExtent(SE_NOTACTIVATING);

		// Force a redraw that will stretch the object.
		pdp->OnPostReplaceRange(CP_INFINITE, 0, 0, _cp, _cp + 1);

		_ped->GetCallMgr()->SetChangeEvent(CN_GENERIC);
	}
}

/*
 *	COleObject::OnReposition (dx, dy)
 *	
 *	@mfunc Set object's new position.  May have changed as a result of scrolling.
 */
void COleObject::OnReposition(
	LONG dx,
	LONG dy)
{
	IOleInPlaceObject *pipo;
	RECT rcClip;

	if(!_fInPlaceActive)
	{
		// If we're not inplace active, don't do anything
		return;
	}

	_ped->_pdp->GetViewRect(rcClip);
	_rcPos.left += dx;
	_rcPos.right += dx;
	_rcPos.top += dy;
	_rcPos.bottom += dy;

	if(_punkobj->QueryInterface(IID_IOleInPlaceObject, (void **)&pipo)
		== NOERROR)
	{
		pipo->SetObjectRects(&_rcPos, &rcClip);
        pipo->Release();
	}
}

 /*
 *	COleObject::ResetPosRect(pAdjust)
 *	
 *	@mfunc Recompute the object's position rectangle from its cp.
 */
void COleObject::ResetPosRect(
	 LONG *pAdjust)		//@parm output adjustment needed for positioning below baseline
{
	CRchTxtPtr rtp(_ped, 0);
	POINT pt, pt1;
	LONG yHeight = _ped->_pdp->HimetricYtoDY(_sizel.cy);
	
	rtp.SetCp(_cp);
	if(_ped->_pdp->PointFromTp(rtp, NULL, FALSE, pt, NULL, TA_TOP) == -1)
		return;
	_rcPos.top = pt.y;
	_ped->_pdp->PointFromTp(rtp, NULL, FALSE, pt1, NULL,
		(_pi.dwFlags & REO_BELOWBASELINE) ? TA_BOTTOM : TA_BASELINE);

	if(pAdjust)
		*pAdjust = 0;

	if(pt1.y - pt.y > yHeight)
	{
		// If line is bigger than object move object down.
		_rcPos.top += pt1.y - pt.y - yHeight;
		if(pAdjust)
			*pAdjust = pt1.y - pt.y - yHeight;
	}

	_rcPos.bottom = _rcPos.top + yHeight;
	_rcPos.left = pt.x;
	_rcPos.right = _rcPos.left + _ped->_pdp->HimetricXtoDX(_sizel.cx);
}

#ifdef DEBUG
void COleObject::DbgDump(DWORD id){
	Tracef(TRCSEVNONE, "Object #%d %X: cp = %d , rect = (%d, %d, %d, %d)",id,this,_cp,_rcPos.top,_rcPos.left,_rcPos.bottom,_rcPos.right);
}
#endif

/*	
 *	COleObject:SetExtent(iActivating)
 *
 *	@mfunc A wrapper around IOleObject::SetExtent which makes some additional
 *			checks if the first call to IOleObject::SetExtent fails.
 *
 *	@rdesc HRESULT
 */
HRESULT COleObject::SetExtent(
	int iActivating) //@parm indicates if object is currently being activated
{
	LPOLEOBJECT poo;

	// If we are connected to a link object, the native extent can't be change,
	// so don't bother doing anything here.
	if(_pi.dwFlags & REO_LINK)
	{
		// So we don't call GetExtents on remeasuring.
		_fSetExtent = TRUE;
		return NOERROR;
	}

	HRESULT hr = _punkobj->QueryInterface(IID_IOleObject, (void **)&poo);
	if(hr != NOERROR)
		return hr;

	// If we are about to activate the object, fall through and OleRun the
	// object prior to attempting to SetExtent.  Otherwise, attempt a SetExtent
	// directly.
	if(iActivating == SE_NOTACTIVATING)
	{
		// By default, we will call SetExtent when the object is next activated.
		_fSetExtent = TRUE;

		hr = poo->SetExtent(_pi.dvaspect, &_sizel);

		DWORD dwStatus;

		// If the server is not running we need to to some additional
		// checking. If it was, we do not need to call SetExtent again.

		// Find out if OLEMISC_RECOMPOSEONRESIZE is set.  If it is, we should
		// run the object and call setextent.  If not, we defer calling set
		// extent until we are ready to activate the object.
		if(!(hr == OLE_E_NOTRUNNING &&
			poo->GetMiscStatus(_pi.dvaspect, &dwStatus) == NOERROR &&
			(dwStatus & OLEMISC_RECOMPOSEONRESIZE)))
		{
			goto DontRunAndSetAgain;
		}
		// Fall through and attempt the SetExtent again after running the object
	}

    {
        SIZEL sizelsave = _sizel;
        OleRun(_punkobj);		// This call causes _sizel to be reset
                                // via OLE and FetchObjectExtents.
        _sizel = sizelsave;
    }
	poo->SetExtent(_pi.dvaspect, &_sizel);

DontRunAndSetAgain:
	if((hr == NOERROR) ||
		(iActivating == SE_NOTACTIVATING && hr != OLE_E_NOTRUNNING))
	{
		_fSetExtent = FALSE;
	}
	// If the server is still not running, we try again at
	// activation time.  Otherwise the server has either
	// done its thing or it doesn't do resize.  Either way
	// we don't bother trying again at activation time.

	if(hr == NOERROR && _fIsPaintBrush)
	{
		SIZEL sizelChk;

		poo->GetExtent(_pi.dvaspect, &sizelChk);
		_fPBUseLocalSizel = !(sizelChk.cx == _sizel.cx &&
								sizelChk.cy == _sizel.cy);
		// HACK:  Calls to SetExtent on PaintBrush objects may not
		// 	actually change the object extents.  In such cases,
		//	we will rely on local _sizel for PaintBrush object extents.
	}
	poo->Release();
	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\callmgr.cpp ===
/*
 *
 *	@doc	INTERNAL
 *
 *	@module	CALLMGR.CPP		CCallMgr implementation |
 *
 *	Purpose:  The call manager controls various aspects of
 *		a client call chain, including re-entrancy management,
 *		undo contexts, and change notifications.
 *
 *	Author:	<nl>
 *		alexgo 2/8/96
 *
 *	See the documentation in reimplem.doc for a detailed explanation
 *	of how all this stuff works.
 *
 */

#include "_common.h"
#include "_edit.h"
#include "_m_undo.h"
#include "_callmgr.h"
#include "_select.h"
#include "_disp.h"

ASSERTDATA

/*
 *	CCallMgr::SetChangeEvent
 *
 *	@mfunc	informs the callmgr that some data in the document 
 *			changed.  The fType parameter describes the actual change
 *
 *	@rdesc	void
 */
void CCallMgr::SetChangeEvent(
	CHANGETYPE fType)		//@parm the type of change (e.g. text, etc)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CCallMgr::SetChangeEvent");

	// if another callmgr exists higher up the chain, then 
	// delegate the call to it
	if( _pPrevcallmgr )
	{
		Assert(_fChange == FALSE);
		Assert(_fTextChanged == FALSE);
		_pPrevcallmgr->SetChangeEvent(fType);
	}
	else
	{
		_fChange = TRUE;
		_ped->_fModified = TRUE;
		_ped->_fSaved = FALSE;
		_fTextChanged = !!(fType & CN_TEXTCHANGED);
	}
}

/*
 *	CCallmgr::ClearChangeEvent
 *
 *	@mfunc	If a change happened, then clear the change event bit. 
 *			This allows callers to make changes to the edit control
 *			_without_ having a notifcation fire.  Sometimes, this
 *			is necessary for backwards compatibility.
 *
 *	@devnote	This is a very dangerous method to use.  If _fChange
 *			is set, it may represent more than 1 change; in other words,
 *			other changes than the one that should be ignored.  However,
 *			for all existing uses of this method, earlier changes are
 *			irrelevant.
 */
void CCallMgr::ClearChangeEvent()
{
	if( _pPrevcallmgr )
	{
		Assert(_fChange == FALSE);
		Assert(_fTextChanged == FALSE);
		_pPrevcallmgr->ClearChangeEvent();
	}
	else
	{
		_fChange = FALSE;
		_fTextChanged = FALSE;
		// caller is responsible for setting _fModifed
	}
}

/*
 *	CCallMgr::SetNewUndo
 *
 *	@mfunc	Informs the notification code that a new undo action has
 *			been added to the undo stack
 *
 *	@rdesc	void
 */
void CCallMgr::SetNewUndo()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CCallMgr::SetNewUndo");

	// we should only ever do this once per call
//	It's assert during IME composition in Outlook.  (see bug #3883)
//  Removing the assert does not caused any side effect.
//	Assert(_fNewUndo == FALSE);


	if( _pPrevcallmgr )
	{
		_pPrevcallmgr->SetNewUndo();
	}
	else
	{
		_fNewUndo = TRUE;
	}
}

/*
 *		
 *	CCallMgr::SetNewRedo
 *
 *	@mfunc	Informs the notification code that a new redo action has
 *			been added to the redo stack.
 *
 *	@rdesc	void
 */
void CCallMgr::SetNewRedo()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CCallMgr::SetNewRedo");

	// we should only ever do this once per call.
	// The following assert looks bogus as it is forced to occur when an undo is
	// called with a count greater than 1. Therefore, for now, I (a-rsail) am
	// commenting it out.
	// Assert(_fNewRedo == FALSE);

	if( _pPrevcallmgr )
	{
		_pPrevcallmgr->SetNewRedo();
	}
	else
	{
		_fNewRedo = TRUE;
	}
}

/*
 *	CCallMgr::SetMaxText
 *
 *	@mfunc	Informs the notification code that the max text limit has
 *			been reached.
 *
 *	@rdesc	void
 */
 void CCallMgr::SetMaxText()
 {
     TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CCallMgr::SetMaxText");

	// if there is a call context higher on the stack, delegate to it.

	if( _pPrevcallmgr )
	{
		Assert(_fMaxText == 0);
		_pPrevcallmgr->SetMaxText();
	}
	else
	{
		_fMaxText = TRUE;
	}
}

/*
 *	CCallMgr::SetSelectionChanged
 *
 *	@mfunc	Informs the notification code that the selection has
 *			changed
 *
 *	@rdesc	void
 */
void CCallMgr::SetSelectionChanged()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CCallMgr::SetSelectionChanged");

    AssertSz(_ped->DelayChangeNotification() ? _ped->Get10Mode() : 1, "Flag only should be set in 1.0 mode");        
    if (_ped->DelayChangeNotification())
        return;
	
	// if there is a call context higher on the stack, delegate to it.

	if( _pPrevcallmgr )
	{
		Assert(_fSelChanged == 0);
		_pPrevcallmgr->SetSelectionChanged();
	}
	else
	{
		_fSelChanged = TRUE;
	}
}

/*
 *	CCallMgr::SetOutOfMemory()
 *
 *	@mfunc	Informs the notification code that we were unable to allocate
 *			enough memory.
 *
 *	@rdesc	void
 */
void CCallMgr::SetOutOfMemory()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CCallMgr::SetOutOfMemory");

	// if there is a call context higher on the stack, delegate to it.

	if( _pPrevcallmgr )
	{
		Assert(_fOutOfMemory == 0);
		_pPrevcallmgr->SetOutOfMemory();
	}
	else
	{
		_fOutOfMemory = TRUE;
	}
}

/*
 *	CCallMgr::SetInProtected
 *
 *	@mfunc	Indicates that we are currently processing an EN_PROTECTED
 *			notification
 *
 *	@rdesc	void
 */
void CCallMgr::SetInProtected(BOOL flag)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CCallMgr::SetInProtected");

	if( _pPrevcallmgr )
	{
		_pPrevcallmgr->SetInProtected(flag);
	}
	else
	{
		_fInProtected = flag;
	}
}

/*
 *	CCallMgr:GetInProtected
 *
 *	@mfunc	retrieves the InProtected flag, whether or not we are currently
 *			processing an EN_PROTECTED notification
 *
 *	@rdesc	void
 */
BOOL CCallMgr::GetInProtected()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CCallMgr::GetInProtected");

	if( _pPrevcallmgr )
	{
		return _pPrevcallmgr->GetInProtected();
	}
	else
	{
		return _fInProtected;
	}
}	

/*
 *	CCallMgr::RegisterComponent
 *
 *	@mfunc	Registers a subsystem component implementing IReEntrantComponent.
 *			This enables this call manager to inform those objects about
 *			relevant changes in our re-entrancy status.
 *
 *	@rdesc	void
 *
 */
void CCallMgr::RegisterComponent(
	IReEntrantComponent *pcomp,	//@parm The component to register
	CompName name)				//@parm The name for the component
{
	pcomp->_idName = name;
	pcomp->_pnext = _pcomplist;
	_pcomplist = pcomp;
}

/*
 *	CCallMgr::RevokeComponent
 *
 *	@mfunc	Removes a subsystem component from the list of components.  The
 *			component must have been previously registered with _this_
 *			call context.
 *
 *	@rdesc	void
 */
void CCallMgr::RevokeComponent(
	IReEntrantComponent *pcomp)	//@parm The component to remove
{
	IReEntrantComponent *plist, **ppprev;
	plist = _pcomplist;
	ppprev = &_pcomplist;

	while( plist != NULL )
	{
		if( plist == pcomp )
		{
			*ppprev = plist->_pnext;
			break;
		}
		ppprev = &(plist->_pnext);
		plist = plist->_pnext;
	} 
}

/*
 *	CCallMgr::GetComponent
 *
 *	@mfunc	Retrieves the earliest instance of a registered sub-component.
 *
 *	@rdesc	A pointer to the component, if one has been registered.  NULL
 *			otherwise.
 */
IReEntrantComponent *CCallMgr::GetComponent(
	CompName name)				//@parm the subsystem to look for
{
	IReEntrantComponent *plist = _pcomplist;

	while( plist != NULL )
	{
		if( plist->_idName == name )
		{
			return plist;
		}
		plist = plist->_pnext;
	}

	// hmm, didn't find anything.  Try contexts higher up, if we're
	// the top context, then just return NULL.

	if( _pPrevcallmgr )
	{
		return _pPrevcallmgr->GetComponent(name);
	}
	return NULL;
}


/*
 *	CCallMgr::CCallMgr
 *
 *	@mfunc	Constructor
 *
 *	@rdesc	void
 */
CCallMgr::CCallMgr(CTxtEdit *ped)
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CCallMgr::");

	// set everthing to NULL
	ZeroMemory(this, sizeof(CCallMgr));

	if(ped)								// If ped is NULL, a zombie has
	{									//  been entered
		_ped = ped;
		_pPrevcallmgr = ped->_pcallmgr;
		ped->_pcallmgr = this;
		NotifyEnterContext();
	}
}

/*
 *	CCallMgr::~CCallMgr
 *
 *	@mfunc	Destructor.  If appropriate, we will fire any cached
 *			notifications and cause the edit object to be destroyed.
 *
 *	@rdesc	void
 */
CCallMgr::~CCallMgr()
{
    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CCallMgr::");

	if(IsZombie())					// No reentrancy with Zombies
		return;

	if( _pPrevcallmgr )
	{
		// we don't allow these flags to be set in re-entrant call
		// states
		Assert(_fMaxText == FALSE);
		Assert(_fSelChanged == FALSE);
		Assert(_fTextChanged == FALSE);
		Assert(_fChange == FALSE);
		Assert(_fNewRedo == FALSE);
		Assert(_fNewUndo == FALSE);
		Assert(_fOutOfMemory == FALSE);

		// set the ped to the next level of the call state
		_ped->_pcallmgr = _pPrevcallmgr;
	
		return;
	}

	// we're the top level. Note that we explicity do not
	// have an overall guard for cases where we are re-entered
	// while firing these notifications.  This is necessary for
	// better 1.0 compatibility and for Forms^3, which wants
	// to 'guard' their implementation of ITextHost::TxNotify and
	// ignore any notifications that happen while they are 
	// processing our notifications.  Make sense?

	_ped->_pcallmgr = NULL;

	// Process our internal notifications
	if(_ped->_fUpdateSelection)
	{	
		CTxtSelection *psel = _ped->GetSel();

		_ped->_fUpdateSelection = FALSE;

		if(psel && !_ped->_pdp->IsFrozen() && !_fOutOfMemory )
		{
			// this may cause an out of memory, so set things
			// up for that
			CCallMgr callmgr(_ped);
			psel->Update(FALSE);
		}
	}

	// Now fire any external notifications that may be necessary
	if( _fChange || _fSelChanged || _fMaxText || _fOutOfMemory )
	{
		SendAllNotifications();
	}

	// finally, we should check to see if we should delete the 
	// CTxtEdit instance.

	if( _ped->_unk._cRefs == 0 && !_ped->_fSelfDestruct)
	{
		delete _ped;
	}
}

//
//	PRIVATE methods
//

/*
 *	CCallMgr::SendAllNotifications
 *
 *	@mfunc	sends notifications for any cached notification bits.
 *
 *	@rdesc	void
 */
void CCallMgr::SendAllNotifications()
{
	ITextHost *phost = _ped->GetHost();
	CHANGENOTIFY	cn;

    TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CCallMgr::");

	//
	// COMPATIBILITY ISSUE: The ordering of these events _may_
	// be an issue.  I've attempted to preserve the ordering
	// that the original code would use, but we have ~many~ more
	// control paths, so it's difficult.
	//
	if(	_fMaxText )
	{			
		// Beep if we are to emulate the system edit control
		if (_ped->_fSystemEditBeep)
			_ped->Beep();
		phost->TxNotify(EN_MAXTEXT, NULL);
	}
	
	if( _fSelChanged )
	{ 		
		if( (_ped->_dwEventMask & ENM_SELCHANGE) && !(_ped->_fSuppressNotify))
		{
			SELCHANGE selchg;

			ZeroMemory(&selchg, sizeof(SELCHANGE));

			_ped->GetSel()->SetSelectionInfo(&selchg);
			
			if (_ped->Get10Mode())
			{
				selchg.chrg.cpMin = _ped->GetAcpFromCp(selchg.chrg.cpMin);
				selchg.chrg.cpMost = _ped->GetAcpFromCp(selchg.chrg.cpMost);
			}

			phost->TxNotify(EN_SELCHANGE, &selchg);
		}
	}

	if( _fOutOfMemory && !_ped->GetOOMNotified())
	{
		_fNewUndo = 0;
		_fNewRedo = 0;
		_ped->ClearUndo(NULL);
		_ped->_pdp->InvalidateRecalc();
		_ped->SetOOMNotified(TRUE);
		phost->TxNotify(EN_ERRSPACE, NULL);
		_ped->SetOOMNotified(FALSE);
	}

	if( _fChange )
	{
		if( (_ped->_dwEventMask & ENM_CHANGE) && !(_ped->_fSuppressNotify))
		{
			cn.dwChangeType = 0;
			cn.pvCookieData = 0;
			
			if( _fNewUndo )
			{
				Assert(_ped->_pundo);
				cn.dwChangeType |= CN_NEWUNDO;
				cn.pvCookieData = _ped->_pundo->GetTopAECookie();

			}
			else if( _fNewRedo )
			{
				Assert(_ped->_predo);
				cn.dwChangeType |= CN_NEWREDO;
				cn.pvCookieData = _ped->_predo->GetTopAECookie();
			}

			if( _fTextChanged )
			{
				cn.dwChangeType |= CN_TEXTCHANGED;
			}
			_ped->_dwEventMask &= ~ENM_CHANGE;
			phost->TxNotify(EN_CHANGE, &cn);
			_ped->_dwEventMask |= ENM_CHANGE;
		}
	}
}

/*
 *	CCallMgr::NotifyEnterContext
 *
 *	@mfunc	Notify any registered components that a new context
 *			has been entered.
 *
 *	@rdesc	void
 */
void CCallMgr::NotifyEnterContext()
{
	IReEntrantComponent *pcomp = _pcomplist;

	while( pcomp )
	{
		pcomp->OnEnterContext();
		pcomp = pcomp->_pnext;
	}

	if( _pPrevcallmgr )
	{
		_pPrevcallmgr->NotifyEnterContext();
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\cfpf.cpp ===
/*
 *	@doc	INTERNAL
 *
 *	@module	CFPF.C -- -- RichEdit CCharFormat and CParaFormat Classes |
 *
 *	Created: <nl>
 *		9/1995 -- Murray Sargent <nl>
 *
 *	@devnote
 *		The this ptr for all methods points to an internal format class, i.e.,
 *		either a CCharFormat or a CParaFormat, which uses the cbSize field as
 *		a reference count.  The pCF or pPF argument points at an external
 *		CCharFormat or CParaFormat class, that is, pCF->cbSize and pPF->cbSize
 *		give the size of their structure.  The code still assumes that both
 *		internal and external forms are derived from the CHARFORMAT(2) and
 *		PARAFORMAT(2) API structures, so some redesign would be necessary to
 *		obtain a more space-efficient internal form.
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_array.h"					// for fumemmov()
#include "_rtfconv.h"				// for IsCharSetValid()
#include "_font.h"					// for GetFontNameIndex(), GetFontName()

ASSERTDATA


// Table of formatting info for Normal and Heading styles
const STYLEFORMAT g_Style[] =		// {dwEffects; yHeight}
{							// Measurements in points
	{CFE_BOLD,				14},	// Heading 1
	{CFE_BOLD + CFE_ITALIC,	12},	// Heading 2
	{0,						12},	// Heading 3
	{CFE_BOLD,				12},	// Heading 4
	{0,						11},	// Heading 5
	{CFE_ITALIC,			11},	// Heading 6
	{0,						 0},	// Heading 7
	{CFE_ITALIC,			 0},	// Heading 8
	{CFE_BOLD + CFE_ITALIC,	 9}		// Heading 9
};


BOOL IsValidTwip(LONG dl)
{
	static const LONG dlMax =  0x00FFFFFF;
	static const LONG dlMin = -0x00FFFFFF;
	if (dl > dlMax || dl < dlMin)
		return FALSE;
	return TRUE;
}

//------------------------- CCharFormat Class -----------------------------------

/*
 *	CCharFormat::Apply(pCF, dwMask, dwMask2)
 *
 *	@mfunc
 *		Apply *<p pCF> to this CCharFormat as specified by nonzero bits in
 *		dwMask and dwMask2
 *
 *	@devnote
 *		Autocolor is dealt with through a neat little hack made possible
 *		by the choice CFE_AUTOCOLOR = CFM_COLOR (see richedit.h).  Hence
 *		if <p pCF>->dwMask specifies color, it automatically resets autocolor
 *		provided (<p pCF>->dwEffects & CFE_AUTOCOLOR) is zero.
 *
 *		*<p pCF> is an external CCharFormat, i.e., it's either a CHARFORMAT
 *		or a CHARFORMAT2 with the appropriate size given by cbSize. But
 *		this CCharFormat is internal and cbSize is used as a reference count.
 */
HRESULT CCharFormat::Apply (
	const CCharFormat *pCF,	//@parm	CCharFormat to apply to this CF
	DWORD dwMask,			//@parm Mask corresponding to CHARFORMAT2
	DWORD dwMask2)			//@parm Mask for additional internal parms
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CCharFormat::Apply");

	DWORD	dwEffectMask = dwMask & CFM_EFFECTS2;
	bool	fNewCharset = false;

	// Reset effect bits to be modified and OR in supplied values
	_dwEffects &= ~dwEffectMask;
	_dwEffects |= pCF->_dwEffects & dwEffectMask;

	// Ditto for additional effects given by dwMask2
	dwEffectMask = dwMask2 & 0xBBFC0000;	// Don't allow autocolors, sub/sups
	_dwEffects	&= ~dwEffectMask;
	_dwEffects	|= pCF->_dwEffects & dwEffectMask;

	// If CFM_BOLD is specified, it overrides the font weight
	if(dwMask & CFM_BOLD)
		_wWeight = (pCF->_dwEffects & CFE_BOLD) ? FW_BOLD : FW_NORMAL;

	// Handle CFM_COLOR since it's overloaded with CFE_AUTOCOLOR
	if(dwMask & CFM_COLOR)
		_crTextColor = pCF->_crTextColor;

	if(dwMask & ~CFM_EFFECTS)				// Early out if only dwEffects
	{										//  is modified. Note that
		if(dwMask & CFM_SIZE)				//  CFM_EFFECTS includes CFM_COLOR
		{
			// If dwMask2 CFM2_USABLEFONT bit is set, pCF->_yHeight (from
			// EM_SETFONTSIZE wparam) is signed increment in points.
			_yHeight = dwMask2 & CFM2_USABLEFONT
					? GetUsableFontHeight(_yHeight, pCF->_yHeight)
					: pCF->_yHeight;
		}

		if(dwMask & CFM_OFFSET)
			_yOffset = pCF->_yOffset;

		if((dwMask & CFM_CHARSET) && IsCharSetValid(pCF->_bCharSet) &&

			// Caller guarantees no check needed
			(dwMask2 & (CFM2_NOCHARSETCHECK | CFM2_MATCHFONT) ||

			// Caller is itemizer. Change to ANSI_CHARSET only if current is BiDi,
			// dont change if current is DBCS/FE charset or symbol.
			(dwMask2 & CFM2_SCRIPT && 
			 (!pCF->_bCharSet && IsBiDiCharSet(_bCharSet) || 
			  pCF->_bCharSet && !IsFECharSet(_bCharSet) && !IsSymbolOrOEM(_bCharSet) && !(_dwEffects & CFE_RUNISDBCS))) ||

			// Caller is not itemizer. Allow consistent direction
			(!(dwMask2 & CFM2_SCRIPT) && 
			 (!(IsRTLCharSet(_bCharSet) ^ IsRTLCharSet(pCF->_bCharSet)) ||
			  IsSymbolOrOEM(pCF->_bCharSet)))))
		{
			fNewCharset = TRUE;
			_bCharSet = pCF->_bCharSet;
		}
			
		if ((dwMask2 & (CFM2_MATCHFONT | CFM2_ADJUSTFONTSIZE)) == (CFM2_MATCHFONT | CFM2_ADJUSTFONTSIZE) &&
			_bCharSet != pCF->_bCharSet && (dwMask & CFM_SIZE))
		{
			// Check if we need to adjust the font size
			_yHeight = W32->GetPreferredFontHeight(
				(dwMask2 & CFM2_UIFONT) != 0,
				pCF->_bCharSet,
				_bCharSet,
				_yHeight);
		}

		if(dwMask & CFM_FACE)
		{
			_bPitchAndFamily = pCF->_bPitchAndFamily;
			_iFont = pCF->_iFont;
			
			WCHAR wch = GetFontName((LONG)_iFont)[0];
			
			if (!fNewCharset && wch == L'\0')				
			{
				// API to choose default font								
				INT		uCpg = GetLocaleCodePage();
				SHORT	iDefFont;
				BYTE	yDefHeight;
				BYTE	bDefPitchAndFamily;

				// Get default font name and charset
				bool	fr = W32->GetPreferredFontInfo(
							uCpg, FALSE, iDefFont, 
							(BYTE&)yDefHeight, bDefPitchAndFamily );
					
				if (fr) 
				{
					_bCharSet = GetCharSet(uCpg);
					_iFont = iDefFont;
						
					if(!(dwMask & CFM_SIZE) || _yHeight < yDefHeight * 20)	// Setup default height if needed.
						_yHeight = yDefHeight * 20;

					_bPitchAndFamily = bDefPitchAndFamily;
				}				
			}
			else if (GetCharFlags(wch) & fFE && !IsFECharSet(_bCharSet))
			{
				// make sure that we dont end up having DBCS facename with Non-FE charset
				DWORD dwFontSig;
				if (GetFontSignatureFromFace(_iFont, &dwFontSig))
				{
					dwFontSig &= (fFE >> 8);	// Only interest in FE charset
					if (dwFontSig)
						_bCharSet = GetFirstAvailCharSet(dwFontSig);
				}
			}
		}

		if (!(dwMask2 & CFM2_CHARFORMAT) &&
			(dwMask & ~CFM_ALL))					// CHARFORMAT2 extensions
		{
			if((dwMask & (CFM_WEIGHT | CFM_BOLD)) == CFM_WEIGHT) 
			{			
				_wWeight		= pCF->_wWeight;
				_dwEffects	   |= CFE_BOLD;			// Set above-average
				if(_wWeight < 551)					//  weights to bold
					_dwEffects &= ~CFE_BOLD;
			}

			if(dwMask & CFM_BACKCOLOR)
				_crBackColor	= pCF->_crBackColor;

			if(dwMask & CFM_LCID)
				_lcid			= pCF->_lcid;

			if(dwMask & CFM_SPACING)
				_sSpacing		= pCF->_sSpacing;

			if(dwMask & CFM_KERNING)
				_wKerning		= pCF->_wKerning;

			if(dwMask & CFM_STYLE)
				_sStyle			= pCF->_sStyle;

			if(dwMask & CFM_UNDERLINETYPE)
			{
				_bUnderlineType	= pCF->_bUnderlineType;
				if(!(dwMask & CFM_UNDERLINE))		// If CFE_UNDERLINE
				{									//  isn't defined,
					_dwEffects	&= ~CFE_UNDERLINE;	//  set it according to
					if(_bUnderlineType)				//  bUnderlineType
						_dwEffects |= CFE_UNDERLINE;
				}
			}

			if((dwMask & CFM_ANIMATION) && pCF->_bAnimation <= 18)
				_bAnimation		= pCF->_bAnimation;

			if(dwMask & CFM_REVAUTHOR)
				_bRevAuthor		= pCF->_bRevAuthor;
    	}
	}

	if(dwMask2 & CFM2_SCRIPT)
		_wScript = pCF->_wScript;

	return NOERROR;
}

/*
 *	CCharFormat::ApplyDefaultStyle(Style)
 *
 *	@mfunc	
 *		Set default style properties in this CCharFormat
 */
void CCharFormat::ApplyDefaultStyle (
	LONG Style)		//@parm Style to use
{
	Assert(IsKnownStyle(Style));

	if(IsHeadingStyle(Style))
	{
		LONG i = -Style + STYLE_HEADING_1;
		_dwEffects = (_dwEffects & 0xFFFFFF00) | g_Style[i].bEffects;
		_wWeight = (_dwEffects & CFE_BOLD) ? FW_BOLD : FW_NORMAL;

		if(g_Style[i].bHeight)
			_yHeight = g_Style[i].bHeight * 20;

		DWORD dwFontSig;				
		LONG  iFont = _iFont;			// Save _iFont in case Arial doesn't
		_iFont = IFONT_ARIAL;			//  support _bCharSet

		GetFontSignatureFromFace(_iFont, &dwFontSig);
		if(GetFontSig(_bCharSet) & dwFontSig)
			_bPitchAndFamily = FF_SWISS;// Arial supports _bCharSet
		else
			_iFont = iFont;				// Restore iFont
	}
}

/*
 *	CCharFormat::Compare(pCF)
 *
 *	@mfunc
 *		Compare this CCharFormat to *<p pCF>
 *
 *	@rdesc
 *		TRUE if they are the same not including _cRefs
 */
BOOL CCharFormat::Compare (
	const CCharFormat *pCF) const	//@parm	CCharFormat to compare this
{									//  CCharFormat to
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CCharFormat::Compare");

	return !CompareMemory(this, pCF, sizeof(CCharFormat));
}

/*
 *	CCharFormat::Delta(pCF, fCHARFORMAT)
 *
 *	@mfunc
 *		Calculate dwMask for differences between this CCharformat and
 *		*<p pCF>
 *
 *	@rdesc
 *		return dwMask of differences (1 bit means a difference)
 */
DWORD CCharFormat::Delta (
	CCharFormat *pCF,		//@parm	CCharFormat to compare this one to
	BOOL fCHARFORMAT) const	//@parm Only compare CHARFORMAT members
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CCharFormat::Delta");
												// Collect bits for properties
	LONG dw = _dwEffects ^ pCF->_dwEffects;		//  that change. Note: auto
												//  color is handled since
	if(_yHeight		!= pCF->_yHeight)			//  CFM_COLOR = CFE_AUTOCOLOR
		dw |= CFM_SIZE;

	if(_yOffset		!= pCF->_yOffset)
		dw |= CFM_OFFSET;

	if(_crTextColor	!= pCF->_crTextColor)
		dw |= CFM_COLOR;

	if(_bCharSet	!= pCF->_bCharSet)
		dw |= CFM_CHARSET;

	if(_iFont		!= pCF->_iFont)
		dw |= CFM_FACE;

	if(fCHARFORMAT)
		return dw;							// Done with CHARFORMAT stuff

	if(_crBackColor	!= pCF->_crBackColor)	// CHARFORMAT2 stuff
		dw |= CFM_BACKCOLOR;

	if(_wKerning	!= pCF->_wKerning)
		dw |= CFM_KERNING;

	if(_lcid		!= pCF->_lcid)
		dw |= CFM_LCID;

	if(_wWeight		!= pCF->_wWeight)
		dw |= CFM_WEIGHT;

	if(_sSpacing	!= pCF->_sSpacing)
		dw |= CFM_SPACING;

	if(_sStyle		!= pCF->_sStyle)
		dw |= CFM_STYLE;

	if(_bUnderlineType != pCF->_bUnderlineType)
		dw |= CFM_UNDERLINETYPE;

	if(_bAnimation	!= pCF->_bAnimation)
		dw |= CFM_ANIMATION;

	if(_bRevAuthor	!= pCF->_bRevAuthor)
		dw |= CFM_REVAUTHOR;

	return dw;
}

/*
 *	CCharFormat::fSetStyle(dwMask)
 *
 *	@mfunc
 *		return TRUE iff pCF specifies that the style should be set. See
 *		code for list of conditions for this to be true
 *
 *	@rdesc
 *		TRUE iff pCF specifies that the style _sStyle should be set
 */
BOOL CCharFormat::fSetStyle(DWORD dwMask, DWORD dwMask2) const
{
	return	dwMask != CFM_ALL2		&&
			dwMask &  CFM_STYLE		&&
			!(dwMask2 & CFM2_CHARFORMAT) &&
			IsKnownStyle(_sStyle);
}

/*
 *	CCharFormat::Get(pCF, CodePage)
 *
 *	@mfunc
 *		Copy this CCharFormat to the CHARFORMAT or CHARFORMAT2 *<p pCF>
 */
void CCharFormat::Get (
	CHARFORMAT2 *pCF2,		//@parm CHARFORMAT to copy this CCharFormat to
	UINT CodePage) const
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CCharFormat::Get");

	pCF2->dwMask		= CFM_ALL;				// Use CHARFORMAT
	pCF2->dwEffects		= _dwEffects;
	pCF2->yHeight		= _yHeight;
	pCF2->yOffset		= _yOffset;
	pCF2->crTextColor	= _crTextColor;
	pCF2->bCharSet		= GetGdiCharSet(_bCharSet);
	pCF2->bPitchAndFamily = _bPitchAndFamily;

	UINT cb = pCF2->cbSize;
	const WCHAR *pch = GetFontName((LONG)_iFont);

	AssertSz((CodePage != 1200) ^ IsValidCharFormatW(pCF2),
		"CCharFormat::Get: wrong codepage for CHARFORMAT");
	
	if(CodePage != 1200)
	{
		if(_dwEffects & CFE_FACENAMEISDBCS)
		{
			// The face name is actually DBCS stuffed into the unicode
			// buffer, so simply un-stuff this DBCS into the ANSI string
			char *pachDst = (char *)pCF2->szFaceName;

			while(*pch)
				*pachDst++ = *pch++;

			*pachDst = 0;
		}
		else
		{
			MbcsFromUnicode((char *)pCF2->szFaceName, LF_FACESIZE,
							pch, -1, CodePage, UN_NOOBJECTS);
		}
	}
	else
		wcscpy(pCF2->szFaceName, pch);
	
	if (cb == sizeof(CHARFORMATW) || cb == sizeof(CHARFORMATA))	// We're done
		return;

	char *pvoid = (char *)&pCF2->wWeight;
	if(pCF2->cbSize == sizeof(CHARFORMAT2A))
		pvoid -= sizeof(CHARFORMAT2W) - sizeof(CHARFORMAT2A);
	else
		Assert(pCF2->cbSize == sizeof(CHARFORMAT2));// Better be a CHARFORMAT2

	pCF2->dwMask = CFM_ALL2;
	CopyMemory(pvoid, &_wWeight, 3*sizeof(DWORD));
	CopyMemory(pvoid + 4*sizeof(DWORD),  &_sStyle,  2*sizeof(DWORD));
	*(DWORD *)(pvoid + 3*sizeof(DWORD)) = 0;
}

/*
 *	CCharFormat::InitDefault(hfont)
 *
 *	@mfunc	
 *		Initialize this CCharFormat with information coming from the font
 *		<p hfont>
 *	
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : E_FAIL
 */
HRESULT CCharFormat::InitDefault (
	HFONT hfont)		//@parm Handle to font info to use
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CCharFormat::InitDefault");

	LOGFONT lf;
	BOOL	fUseStockFont = hfont == NULL;

	ZeroMemory(this, sizeof(CCharFormat));

	// If hfont isn't defined, get LOGFONT for default font
	if(!hfont)
		hfont = W32->GetSystemFont();

	// Get LOGFONT for passed hfont
	if(!W32->GetObject(hfont, sizeof(LOGFONT), &lf))
		return E_FAIL;

	_yHeight = (lf.lfHeight * LY_PER_INCH) / W32->GetYPerInchScreenDC();
	if(_yHeight <= 0)
		_yHeight = -_yHeight;
	else if (fUseStockFont)		// This is Cell Height for System Font case
		_yHeight -= (W32->GetSysFontLeading() * LY_PER_INCH) / W32->GetYPerInchScreenDC();
	else
	{
		// This is Cell Height, need to get the character height by subtracting 
		// the tm.tmInternalLeading.
		CLock		lock;
		HDC			hdc = W32->GetScreenDC();
		HFONT		hOldFont = SelectFont(hdc, hfont);
		TEXTMETRIC	tm;

		if(hOldFont)
		{
			if(GetTextMetrics(hdc, &tm))			
    			_yHeight -= (tm.tmInternalLeading * LY_PER_INCH) / W32->GetYPerInchScreenDC();

			SelectFont(hdc, hOldFont); 
		}
	}

#ifndef MACPORTStyle
	_dwEffects = (CFM_EFFECTS | CFE_AUTOBACKCOLOR) & ~(CFE_PROTECTED | CFE_LINK);

#else
	_dwEffects = (CFM_EFFECTS | CFE_AUTOBACKCOLOR | CFE_OUTLINE | CFE_SHADOW)
					& ~(CFE_PROTECTED | CFE_LINK);
	if(!(lf.lfWeight & FW_OUTLINE))
		_dwEffects &= ~CFE_OUTLINE;
	if (!(lf.lfWeight & FW_SHADOW))
		_dwEffects &= ~CFE_SHADOW;
#endif

	if(lf.lfWeight < FW_BOLD)
		_dwEffects &= ~CFE_BOLD;

	if(!lf.lfItalic)
		_dwEffects &= ~CFE_ITALIC;

	if(!lf.lfUnderline)
		_dwEffects &= ~CFE_UNDERLINE;

	if(!lf.lfStrikeOut)
		_dwEffects &= ~CFE_STRIKEOUT;

	_wWeight		= (WORD)lf.lfWeight;
	_lcid			= GetSystemDefaultLCID();
	_bCharSet		= lf.lfCharSet;
	_bPitchAndFamily= lf.lfPitchAndFamily;
	_iFont			= GetFontNameIndex(lf.lfFaceName);
	_bUnderlineType	= CFU_UNDERLINE;			// Default solid underlines
												// Are gated by CFE_UNDERLINE

	// Qualify the charformat produced by incoming hfont before exit.
	// We did this to make sure that the charformat we derived from hfont is usable
	// since caller can send us bad font like given facename can't handle given charset.
	if (!fUseStockFont)
	{
		DWORD dwFontSig;
		if (GetFontSignatureFromFace(_iFont, &dwFontSig) &&
			!(GetFontSig(_bCharSet) & dwFontSig))
			_bCharSet = GetFirstAvailCharSet(dwFontSig);
	}

	return NOERROR;
}

/*
 *	CCharFormat::Set(pCF, CodePage)
 *
 *	@mfunc
 *		Copy the CHARFORMAT or CHARFORMAT2 *<p pCF> to this CCharFormat 
 */
void CCharFormat::Set (
	const CHARFORMAT2 *pCF2, 	//@parm	CHARFORMAT to copy to this CCharFormat
	UINT CodePage)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CCharFormat::Set");
	
	_dwEffects			= pCF2->dwEffects;
	_bCharSet			= pCF2->bCharSet;
	_bPitchAndFamily	= pCF2->bPitchAndFamily;
	if(pCF2->dwMask & CFM_FACE)
	{
		AssertSz((CodePage != 1200) ^ IsValidCharFormatW(pCF2),
			"CCharFormat::Set: wrong codepage for CHARFORMAT");

		if(CodePage != 1200)
		{
			WCHAR sz[LF_FACESIZE + 1];
			UnicodeFromMbcs(sz, LF_FACESIZE, (char *)pCF2->szFaceName, LF_FACESIZE,
							CodePage);
			_iFont		= GetFontNameIndex(sz);
		}
		else
			_iFont		= GetFontNameIndex(pCF2->szFaceName);
	}
	_yHeight			= Get16BitTwips(pCF2->yHeight);
	_yOffset			= Get16BitTwips(pCF2->yOffset);
	_crTextColor		= pCF2->crTextColor;
	
	UINT cb = pCF2->cbSize;
	if(cb == sizeof(CHARFORMATW) || cb == sizeof(CHARFORMATA))
	{
		_dwEffects |= CFE_AUTOBACKCOLOR;
		_bUnderlineType = CFU_UNDERLINE;
		ZeroMemory((LPBYTE)&_wWeight,
			sizeof(CCharFormat) - offsetof(CCharFormat, _wWeight));
		return;
	}

	char *pvoid = (char *)&pCF2->wWeight;
	if(pCF2->cbSize == sizeof(CHARFORMAT2A))
		pvoid -= sizeof(CHARFORMAT2W) - sizeof(CHARFORMAT2A);
	else
		Assert(pCF2->cbSize == sizeof(CHARFORMAT2));// Better be a CHARFORMAT2

	CopyMemory(&_wWeight, pvoid, 3*sizeof(DWORD));
	CopyMemory(&_sStyle,  pvoid + 4*sizeof(DWORD),  2*sizeof(DWORD));
}


//------------------------- CParaFormat Class -----------------------------------

/*
 *	CParaFormat::AddTab(tbPos, tbAln, tbLdr)
 *
 *	@mfunc
 *		Add tabstop at position <p tbPos>, alignment type <p tbAln>, and
 *		leader style <p tbLdr>
 *
 *	@rdesc
 *		(success) ? NOERROR : S_FALSE
 *
 *	@devnote
 *		Tab struct that overlays LONG in internal _rgxTabs is
 *
 *			DWORD	tabPos : 24;
 *			DWORD	tabType : 4;
 *			DWORD	tabLeader : 4;
 */
HRESULT CParaFormat::AddTab (
	LONG	tbPos,		//@parm New tab position
	LONG	tbAln,		//@parm New tab alignment type
	LONG	tbLdr,		//@parm New tab leader style
	BOOL	fInTable,	//@parm True if simulating cells
	LONG *	prgxTabs)	//@parm Where the tabs are
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormat::AddTab");

	if (!fInTable &&
		((DWORD)tbAln > tomAlignBar ||				// Validate arguments
		 (DWORD)tbLdr > tomEquals ||				// Comparing DWORDs causes
		 (DWORD)tbPos > 0xffffff || !tbPos))		//  negative values to be
	{												//  treated as invalid
		return E_INVALIDARG;
	}

	LONG iTab;
	LONG tbValue = tbPos + (tbAln << 24) + (tbLdr << 28);

	for(iTab = 0; iTab < _bTabCount &&			// Determine where to
		tbPos > GetTabPos(prgxTabs[iTab]); 		//  insert new tabstop
		iTab++) ;

	if(iTab >= MAX_TAB_STOPS)
		return S_FALSE;

	LONG tbPosCurrent = GetTabPos(prgxTabs[iTab]);
	if(iTab == _bTabCount || tbPosCurrent != tbPos)
	{
		if(_bTabCount >= MAX_TAB_STOPS)
			return S_FALSE;

		MoveMemory(&prgxTabs[iTab + 1],			// Shift array down
			&prgxTabs[iTab],					//  (unless iTab = Count)
			(_bTabCount - iTab)*sizeof(LONG));

		_bTabCount++;							// Increment tab count
	}
	prgxTabs[iTab] = tbValue;
	return NOERROR;
}

/*
 *	CParaFormat::Apply(pPF)
 *
 *	@mfunc
 *		Apply *<p pPF> to this CParaFormat as specified by nonzero bits in
 *		<p pPF>->dwMask
 */
HRESULT CParaFormat::Apply (
	const CParaFormat *pPF,	//@parm CParaFormat to apply to this PF
	DWORD	dwMask)			//@parm mask to use
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormat::Apply");

	const DWORD dwMaskApply	= dwMask;
	BOOL		fPF = dwMask & PFM_PARAFORMAT;
	WORD		wEffectMask;

	if(dwMaskApply & PFM_NUMBERING)
		_wNumbering = pPF->_wNumbering;

	if(dwMaskApply & PFM_OFFSET)
	{
		if (!IsValidTwip(pPF->_dxOffset))
			return E_INVALIDARG;
		_dxOffset = pPF->_dxOffset;
	}

	if(dwMaskApply & PFM_STARTINDENT)
	{
		if (!IsValidTwip(pPF->_dxStartIndent))
			return E_INVALIDARG;

		_dxStartIndent = pPF->_dxStartIndent;
	}
	else if(dwMaskApply & PFM_OFFSETINDENT)
	{
		if (!IsValidTwip(pPF->_dxStartIndent))
			return E_INVALIDARG;

		// bug fix #5761
		LONG dx = max(0, _dxStartIndent + pPF->_dxStartIndent);

		// Disallow shifts that move start of first or subsequent lines left of left margin.
		// Normally we just make indent zero in paraformat check below, 
		//	but in the case of bullet we want some space left.
		
		if(!_wNumbering || dx + _dxOffset >= 0)
			_dxStartIndent = dx;
	}

	if(dwMaskApply & PFM_RIGHTINDENT)
	{
		if (!IsValidTwip(pPF->_dxRightIndent))
			return E_INVALIDARG;

		_dxRightIndent = pPF->_dxRightIndent;
	}

	if(dwMaskApply & PFM_ALIGNMENT)
	{
		if(!fPF && !IN_RANGE(PFA_LEFT, pPF->_bAlignment, PFA_SNAP_GRID))
		{
			TRACEERRORSZ("CParaFormat::Apply: invalid Alignment ignored");
			return E_INVALIDARG;
		}
		if(pPF->_bAlignment <= PFA_SNAP_GRID)
			_bAlignment = pPF->_bAlignment;
	}

	// Save whether this is a table now.
	BOOL fInTablePrev = InTable();

	if((dwMaskApply & PFM_TABSTOPS) && !fInTablePrev)
	{
		_bTabCount = (BYTE)min(pPF->_bTabCount, MAX_TAB_STOPS);
		_bTabCount = (BYTE)max(_bTabCount, 0);
		_iTabs	   = pPF->_iTabs;
		AssertSz(!_bTabCount || _iTabs >= 0,
			"CParaFormat::Apply: illegal _iTabs value");
	}

	// AymanA: 11/7/96 Moved the wEffects set before the possible return NOERROR.
	wEffectMask	= (WORD)(dwMaskApply >> 16);	// Reset effect bits to be
	_wEffects &= ~wEffectMask;					//  modified and OR in
	_wEffects |= pPF->_wEffects & wEffectMask;	//  supplied values

	if(InTable())
		_wEffects &= ~PFE_RTLPARA;				// Tables use paras for rows

	else if(fInTablePrev)
	{
		// This was a table now it isn't. We must dump the tab information
		// because it is totally bogus.
		_iTabs = -1;
		_bTabCount = 0;
	}

	if ((dwMaskApply & PFM_RTLPARA) && !(dwMaskApply & PFM_ALIGNMENT) &&
		_bAlignment != PFA_CENTER)
	{
		_bAlignment = IsRtlPara() ? PFA_RIGHT : PFA_LEFT;
	}

	// PARAFORMAT check
	if(fPF)
	{
		if(dwMaskApply & (PFM_STARTINDENT | PFM_OFFSET))
		{
			if(_dxStartIndent < 0)				// Don't let indent go
				_dxStartIndent = 0;				//  negative

			if(_dxStartIndent + _dxOffset < 0)	// Don't let indent +
				_dxOffset = -_dxStartIndent;	//  offset go negative
		}
		return NOERROR;							// Nothing more for
	}											//  PARAFORMAT

	// PARAFORMAT2 extensions
	if(dwMaskApply & PFM_SPACEBEFORE)
	{
		_dySpaceBefore = 0;

		if (pPF->_dySpaceBefore > 0)
			_dySpaceBefore	= pPF->_dySpaceBefore;
	}

	if(dwMaskApply & PFM_SPACEAFTER)
	{
		_dySpaceAfter = 0;

		if (pPF->_dySpaceAfter > 0)
			_dySpaceAfter	= pPF->_dySpaceAfter;
	}

	if(dwMaskApply & PFM_LINESPACING)
	{
		_dyLineSpacing	  = pPF->_dyLineSpacing;
		_bLineSpacingRule = pPF->_bLineSpacingRule;
	}

	if(dwMaskApply & PFM_OUTLINELEVEL)
		_bOutlineLevel	= pPF->_bOutlineLevel;

	if(dwMaskApply & PFM_STYLE)
		HandleStyle(pPF->_sStyle);

	Assert((_bOutlineLevel & 1) ^ IsHeadingStyle(_sStyle));

	if(dwMaskApply & PFM_SHADING)
	{
		_wShadingWeight	= pPF->_wShadingWeight;
		_wShadingStyle	= pPF->_wShadingStyle;
	}

	if(dwMaskApply & PFM_NUMBERINGSTART)
		_wNumberingStart = pPF->_wNumberingStart;

	if(dwMaskApply & PFM_NUMBERINGSTYLE)
		_wNumberingStyle = pPF->_wNumberingStyle;

	if(dwMaskApply & PFM_NUMBERINGTAB)
		_wNumberingTab	= pPF->_wNumberingTab;

	if(dwMaskApply & PFM_BORDER)
	{
		_dwBorderColor	= pPF->_dwBorderColor;
		_wBorders		= pPF->_wBorders;
		_wBorderSpace	= pPF->_wBorderSpace;
		_wBorderWidth	= pPF->_wBorderWidth;
	}

#ifdef DEBUG
	ValidateTabs();
#endif // DEBUG

	return NOERROR;
}

/*
 *	CParaFormat::ApplyDefaultStyle(Style)
 *
 *	@mfunc	
 *		Copy default properties for Style
 */
void CParaFormat::ApplyDefaultStyle (
	LONG Style)		//@parm Style to apply
{
	Assert(IsKnownStyle(Style));

	if(IsHeadingStyle(Style))				// Set Style's dySpaceBefore,
	{										//  dySpaceAfter (in twips)
		_dySpaceBefore = 12*20;				//  (same for all headings)
		_dySpaceAfter  =  3*20;
		_wNumbering	   = 0;					// No numbering
	}
}

/*
 *	CParaFormat::DeleteTab(tbPos)
 *
 *	@mfunc
 *		Delete tabstop at position <p tbPos>
 *
 *	@rdesc
 *		(success) ? NOERROR : S_FALSE
 */
HRESULT CParaFormat::DeleteTab (
	LONG	tbPos,			//@parm Tab position to delete
	LONG *	prgxTabs)		//@parm Tab array to use
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormat::DeleteTab");

	if(tbPos <= 0)
		return E_INVALIDARG;

	LONG Count	= _bTabCount;
	for(LONG iTab = 0; iTab < Count; iTab++)	// Find tabstop for position
	{
		if(GetTabPos(prgxTabs[iTab]) == tbPos)
		{
			MoveMemory(&prgxTabs[iTab],			// Shift array down
				&prgxTabs[iTab + 1],			//  (unless iTab is last tab)
				(Count - iTab - 1)*sizeof(LONG));
			_bTabCount--;						// Decrement tab count and
			return NOERROR;						//  signal no error
		}
	}
	return S_FALSE;
}

/*
 *	CParaFormat::Delta(pPF)
 *
 *	@mfunc
 *		return mask of differences between this CParaFormat and *<p pPF>.
 *		1-bits indicate corresponding parameters differ; 0 indicates they
 *		are the same
 *
 *	@rdesc
 *		mask of differences between this CParaFormat and *<p pPF>
 */
DWORD CParaFormat::Delta (
	CParaFormat *pPF,		 		//@parm	CParaFormat to compare this
	BOOL		fPARAFORMAT) const	//		CParaFormat to
{									
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormat::Delta");

	LONG dwT = 0;								// No differences yet

	if(_wNumbering	  != pPF->_wNumbering)
		dwT |= PFM_NUMBERING;					// _wNumbering values differ

	if(_dxStartIndent != pPF->_dxStartIndent)
		dwT |= PFM_STARTINDENT;					// ...

	if(_dxRightIndent != pPF->_dxRightIndent)
		dwT |= PFM_RIGHTINDENT;

	if(_dxOffset	  != pPF->_dxOffset)
		dwT |= PFM_OFFSET;

	if(_bAlignment	  != pPF->_bAlignment)
		dwT |= PFM_ALIGNMENT;

	AssertSz(pPF->_bTabCount >= 0 && pPF->_bTabCount <= MAX_TAB_STOPS,
		"RTR::GetParaFormat(): illegal tab count");

	if (_bTabCount != pPF->_bTabCount)
		dwT |= PFM_TABSTOPS;
	else if (_bTabCount > 0)
	{
		const LONG	*pTabs1 = GetTabs();
		const LONG	*pTabs2 = pPF->GetTabs();
		if (pTabs1 != pTabs2 &&
			(pTabs1 == 0 || pTabs2 == 0 || CompareMemory(pTabs1, pTabs2, _bTabCount * sizeof(LONG))))
			dwT |= PFM_TABSTOPS;
	}

	dwT |= (_wEffects ^ pPF->_wEffects) << 16;


	if(!fPARAFORMAT)
	{
		if(_dySpaceBefore	!= pPF->_dySpaceBefore)
			dwT |= PFM_SPACEBEFORE;

		if(_dySpaceAfter	!= pPF->_dySpaceAfter)
			dwT |= PFM_SPACEAFTER;

		if (_dyLineSpacing	!= pPF->_dyLineSpacing	||
		   _bLineSpacingRule!= pPF->_bLineSpacingRule)
		{
			dwT |= PFM_LINESPACING;
		}

		if(_sStyle			!= pPF->_sStyle)
			dwT |= PFM_STYLE;

		if (_wShadingWeight	!= pPF->_wShadingWeight ||
			_wShadingStyle	!= pPF->_wShadingStyle)
		{
			dwT |= PFM_SHADING;
		}

		if(_wNumberingStart	!= pPF->_wNumberingStart)
			dwT |= PFM_NUMBERINGSTART;

		if(_wNumberingStyle	!= pPF->_wNumberingStyle)
			dwT |= PFM_NUMBERINGSTYLE;

		if(_wNumberingTab	!= pPF->_wNumberingTab)
			dwT |= PFM_NUMBERINGTAB;

		if (_wBorders		!= pPF->_wBorders	 ||
			_wBorderWidth	!= pPF->_wBorderWidth ||
			_wBorderSpace	!= pPF->_wBorderSpace ||
			_dwBorderColor	!= pPF->_dwBorderColor)
		{
			dwT |= PFM_BORDER;
		}
	}

	return dwT;
}		

#define PFM_IGNORE	(PFM_OUTLINELEVEL | PFM_COLLAPSED | PFM_PARAFORMAT | PFM_BOX)

/*
 *	CParaFormat::fSetStyle()
 *
 *	@mfunc
 *		Return TRUE iff this PF specifies that the style should be set.
 *		See code for list of conditions for this to be true
 *
 *	@rdesc
 *		TRUE iff pCF specifies that the style _sStyle should be set
 */
BOOL CParaFormat::fSetStyle(DWORD dwMask) const
{
	return	(dwMask & ~PFM_IGNORE) != PFM_ALL2	&&
			dwMask &  PFM_STYLE					&&
			!(dwMask & PFM_PARAFORMAT)			&&
			IsKnownStyle(_sStyle);
}

/*
 *	CParaFormat::Get(pPF)
 *
 *	@mfunc
 *		Copy this CParaFormat to *<p pPF>
 */
void CParaFormat::Get (
	PARAFORMAT2 *pPF2) const	//@parm	PARAFORMAT2 to copy this CParaFormat to
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormat::Get");

	LONG cb = pPF2->cbSize;

	pPF2->dwMask = PFM_ALL2;					// Default PARAFORMAT2
	if(cb != sizeof(PARAFORMAT2))				// It isn't
	{
		pPF2->dwMask = PFM_ALL;					// Make it PARAFORMAT
		Assert(cb == sizeof(PARAFORMAT));		// It better be a PARAFORMAT
	}
	CopyMemory(&pPF2->wNumbering, &_wNumbering, (char *)&_bAlignment - (char *)&_wNumbering);
	pPF2->wAlignment = _bAlignment;
	pPF2->cTabCount	= _bTabCount;

	LONG cb1 = _bTabCount*sizeof(LONG);
	if(_bTabCount)
	{
		AssertSz(_iTabs >= 0,
			"CParaFormat::Get: illegal _iTabs value");
		CopyMemory(pPF2->rgxTabs, GetTabsCache()->Deref(_iTabs), cb1);
	}
	ZeroMemory(pPF2->rgxTabs + _bTabCount, MAX_TAB_STOPS*sizeof(LONG) - cb1);
	CopyMemory(&pPF2->dySpaceBefore, &_dySpaceBefore,
			   cb - offsetof(PARAFORMAT2, dySpaceBefore));
}

/*
 *	CParaFormat::GetTab (iTab, ptbPos, ptbAln, ptbLdr)
 *
 *	@mfunc
 *		Get tab parameters for the <p iTab> th tab, that is, set *<p ptbPos>,
 *		*<p ptbAln>, and *<p ptbLdr> equal to the <p iTab> th tab's
 *		displacement, alignment type, and leader style, respectively.  The
 *		displacement is given in twips.
 *
 *	@rdesc
 *		HRESULT = (no <p iTab> tab)	? E_INVALIDARG : NOERROR
 */
HRESULT CParaFormat::GetTab (
	long	iTab,				//@parm Index of tab to retrieve info for
	long *	ptbPos,				//@parm Out parm to receive tab displacement
	long *	ptbAln,				//@parm Out parm to receive tab alignment type
	long *	ptbLdr,				//@parm Out parm to receive tab leader style
	const LONG *prgxTabs) const	//@parm Tab array
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEEXTERN, "CParaFormat::GetTab");

	AssertSz(ptbPos && ptbAln && ptbLdr,
		"CParaFormat::GetTab: illegal arguments");

	if(iTab < 0)									// Get tab previous to, at,
	{												//  or subsequent to the
		if(iTab < tomTabBack)						//  position *ptbPos
			return E_INVALIDARG;

		LONG i;
		LONG tbPos = *ptbPos;
		LONG tbPosi;

		*ptbPos = 0;								// Default tab not found
		for(i = 0; i < _bTabCount &&				// Find *ptbPos
			tbPos > GetTabPos(prgxTabs[i]); 
			i++) ;

		tbPosi = GetTabPos(prgxTabs[i]);			// tbPos <= tbPosi
		if(iTab == tomTabBack)						// Get tab info for tab
			i--;									//  previous to tbPos
		else if(iTab == tomTabNext)					// Get tab info for tab
		{											//  following tbPos
			if(tbPos == tbPosi)
				i++;
		}
		else if(tbPos != tbPosi)					// tomTabHere
			return S_FALSE;

		iTab = i;		
	}
	if((DWORD)iTab >= (DWORD)_bTabCount)			// DWORD cast also
		return E_INVALIDARG;						//  catches values < 0

	iTab = prgxTabs[iTab];
	*ptbPos = GetTabPos(iTab);
	*ptbAln = GetTabAlign(iTab);
	*ptbLdr = GetTabLdr(iTab);
	return NOERROR;
}

/*
 *	CParaFormat::GetTabs ()
 *
 *	@mfunc
 *		Get ptr to tab array.  Use GetTabPos(), GetTabAlign(), and
 *		GetTabLdr() to access the tab position, alignment, and leader
 *		type, respectively.
 *
 *	@rdesc
 *		Ptr to tab array.
 */
const LONG * CParaFormat::GetTabs () const
{
	return GetTabsCache()->Deref(_iTabs);
}

/*
 *	CParaFormat::HandleStyle(Style)
 *
 *	@func
 *		If Style is a promote/demote command, i.e., if abs((char)Style)
 *			<= # heading styles - 1, add (char)Style to	sStyle (if heading)
 *			and to bOutlineLevel (subject to defined max and min values);
 *		else sStyle = Style.
 *
 *	@rdesc
 *		return TRUE iff sStyle or bOutlineLevel changed
 *
 *	@devnote
 *		Heading styles are -2 (heading 1) through -10 (heading 9), which
 *		with TOM and WOM. Heading outline levels are 0, 2,..., 16,
 *		corresponding to headings 1 through 9 (NHSTYLES), respectively,
 *		while text that follows has outline levels 1, 3,..., 17.  This value
 *		is used for indentation. Collapsed text has the PFE_COLLAPSED bit set.
 */
BOOL CParaFormat::HandleStyle(
	LONG Style)		//@parm Style, promote/demote code, or collapse-level code
{
	if(IsStyleCommand(Style))					// Set collapse level
	{											
		WORD wEffectsSave = _wEffects;			

		Style = (char)Style;					// Sign extend low byte
		if(IN_RANGE(1, Style, NHSTYLES))
		{
			_wEffects &= ~PFE_COLLAPSED;
			if((_bOutlineLevel & 1) || _bOutlineLevel > 2*(Style - 1))
				_wEffects |= PFE_COLLAPSED;		// Collapse nonheadings and
		}										//  higher numbered headings
		else if(Style == -1)
			_wEffects &= ~PFE_COLLAPSED;		// Expand all

		return _wEffects != wEffectsSave;		// Return whether something
	}											//  changed

	// Ordinary Style specification
	BYTE bLevel = _bOutlineLevel;
	_bOutlineLevel |= 1;						// Default not a heading
	if(IsHeadingStyle(Style))					// Headings have levels
	{											//  0, 2,..., 16, while the
		_bOutlineLevel = -2*(Style				//  text that follows has
						 - STYLE_HEADING_1);	//  1, 3,..., 17.
	}
	if(_sStyle == Style && bLevel == _bOutlineLevel)
		return FALSE;							// No change

	_sStyle = (SHORT)Style;						
	return TRUE;
}

/*
 *	CParaFormat::InitDefault(wDefEffects)
 *
 *	@mfunc
 *		Initialize this CParaFormat with default paragraph formatting
 *
 *	@rdesc
 *		HRESULT = (if success) ? NOERROR : E_FAIL
 */
HRESULT CParaFormat::InitDefault(
	WORD wDefEffects)
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormat::InitDefault");
	
	ZeroMemory(this, sizeof(CParaFormat));
	_bAlignment		= PFA_LEFT;
	_sStyle			= STYLE_NORMAL;			// Default style
	_wEffects		= wDefEffects;
	_bOutlineLevel	= 1;					// Default highest text outline
	_iTabs			= -1;					//  level
											
#if lDefaultTab <= 0
#error "default tab (lDefaultTab) must be > 0"
#endif

	return NOERROR;
}

/*
 *	CParaFormat::NumToStr(pch, n)
 *
 *	@mfunc	
 *		Convert the list number n to a string taking into consideration
 *		CParaFormat::wNumbering, wNumberingStart, and wNumberingStyle
 *	
 *	@rdesc
 *		cch of string converted
 */
LONG CParaFormat::NumToStr(
	TCHAR *	pch,				//@parm Target string
	LONG	n,					//@parm Number + 1 to convert
	DWORD   grf) const			//@parm Collection of flags
{
	if(IsNumberSuppressed())
	{
		*pch = 0;
		return 0;								// Number/bullet suppressed
	}

	if(!n)										// Bullet of some kind
	{											// CParaFormat::wNumbering
		*pch++ = (_wNumbering > ' ')			//  values > ' ' are Unicode
			   ? _wNumbering : 0x00B7;			//  bullets. Else use bullet
		return 1;								//  in symbol font
	}

	// Numbering of some kind
	//							 i  ii  iii  iv v  vi  vii  viii   ix
	const BYTE RomanCode[]	  = {1, 5, 0x15, 9, 2, 6, 0x16, 0x56, 0xd};
	const char RomanLetter[] = "ivxlcdmno";
	BOOL		fRtlPara = IsRtlPara() && !(grf & fRtfWrite);
	LONG		RomanOffset = 0;
	LONG		cch	= 0;						// No chars yet
	WCHAR		ch	= fRtlPara && (grf & fIndicDigits) ? 0x0660 : '0';	
												// Default char code offset
	LONG		d	= 1;						// Divisor
	LONG		r	= 10;						// Default radix 
	LONG   		quot, rem;						// ldiv result
	LONG		Style = (_wNumberingStyle << 8) & 0xF0000;

	n--;										// Convert to number offset
	if(Style == tomListParentheses ||			// Numbering like: (x)
	   fRtlPara && Style == 0)					// or 1) in bidi text.
	{										
		cch = 1;								// Store leading lparen
		*pch++ = '(';
	}
	else if (Style == tomListPeriod && fRtlPara)
	{
		cch = 1;
		*pch++ = '.';
		Style = tomListPlain;
	}

	if(_wNumbering == tomListNumberAsSequence)
		ch = _wNumberingStart;					// Needs generalizations, e.g.,
												//  appropriate radix
	else
	{
		n += _wNumberingStart;
		if(IN_RANGE(tomListNumberAsLCLetter, _wNumbering, tomListNumberAsUCLetter))
		{
			ch = (_wNumbering == tomListNumberAsLCLetter) ? 'a' : 'A';
			if(_wNumberingStart >= 1)
				n--;
			r = 26;								// LC or UC alphabetic number
		}										// Radix 26
	}

	while(d < n)
	{
		d *= r;									// d = smallest power of r > n
		RomanOffset += 2;
	}
	if(n && d > n)
	{
		d /= r;
		RomanOffset -= 2;
	}

	while(d)
	{
		quot = n / d;
		rem = n % d;
		if(IN_RANGE(tomListNumberAsLCRoman, _wNumbering, tomListNumberAsUCRoman))
		{
			if(quot)
			{
				n = RomanCode[quot - 1];
				while(n)
				{
					ch = RomanLetter[(n & 3) + RomanOffset - 1];
					if(_wNumbering == tomListNumberAsUCRoman)
						ch &= 0x5F;
					*pch++ = ch;
					n >>= 2;
					cch++;
				}
			}
			RomanOffset -= 2;
		}
		else
		{
			n = quot + ch;
			if(r == 26 && d > 1)				// If alphabetic higher-order
				n--;							//  digit, base it on 'a' or 'A'
			*pch++ = (WORD)n;					// Store digit
			cch++;
		}
		n = rem;								// Setup remainder
		d /= r;
	}
	if (Style != tomListPlain &&				// Trailing text
		(!fRtlPara || Style))
	{											// We only do rparen or period
		*pch++ = (Style == tomListPeriod) ? '.' : ')';

		cch++;
	}
	
	*pch = 0;									// Null terminate for RTF writer
	return cch;
}

/*
 *	CParaFormat::Set(pPF)
 *
 *	@mfunc
 *		Copy PARAFORMAT or PARAFORMAT2 *<p pPF> to this CParaFormat 
 */
void CParaFormat::Set (
	const PARAFORMAT2 *pPF2) 	//@parm	PARAFORMAT to copy to this CParaFormat
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormat::Set");

	CopyMemory(&_wNumbering, &pPF2->wNumbering,
			   (char *)&_bAlignment - (char *)&_wNumbering);
	_bAlignment = (BYTE)pPF2->wAlignment;

	_iTabs = -1;
	_bTabCount = 0;

	if((pPF2->dwMask & PFM_TABSTOPS) && pPF2->cTabCount)
	{
		_bTabCount = (BYTE)min(MAX_TAB_STOPS, (BYTE)pPF2->cTabCount);
		_iTabs = GetTabsCache()->Cache(pPF2->rgxTabs, _bTabCount);
	}

	if(pPF2->dwMask & ~(PFM_ALL | PFM_PARAFORMAT))
	{
		CopyMemory(&_dySpaceBefore, &pPF2->dySpaceBefore,
			sizeof(CParaFormat) - offsetof(CParaFormat, _dySpaceBefore));
	}

#ifdef DEBUG
	ValidateTabs();
#endif // DEBUG
}

/*
 *	CParaFormat::UpdateNumber(n, pPF)
 *
 *	@mfunc
 *		Return new value of number for paragraph described by this PF
 *		following a paragraph described by pPF
 *
 *	@rdesc
 *		New number for paragraph described by this PF
 */
LONG CParaFormat::UpdateNumber (
	LONG  n,						//@parm Current value of number
	const CParaFormat *pPF) const	//@parm Previous CParaFormat
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CParaFormat::UpdateNumber");

	if(!IsListNumbered())			
		return 0;						// No numbering

	if(IsNumberSuppressed())
		return n;						// Number is suppressed, so no change

	if (!pPF || _wNumbering != pPF->_wNumbering ||
		(_wNumberingStyle != pPF->_wNumberingStyle && !pPF->IsNumberSuppressed()) ||
		_wNumberingStart != pPF->_wNumberingStart)
	{									// Numbering type or style
		return 1;						//  changed, so start over
	}
	return n + 1;						// Same kind of numbering,
}

#ifdef DEBUG
/*
 *	CParaFormat::ValidateTabs()
 *
 *	@mfunc
 *		Makes sure that a set of tabs would make sense for a non-table
 *		paragraph. Is called in places where we have set the tabs.
 *
 *	@rdesc
 *		None.
 */
void CParaFormat::ValidateTabs()
{
	if (_wEffects & PFE_TABLE)
	{
		// It would be nice to assert something reasonable here. However, the
		// rtf reader insists on setting things inconsistenly and I don't
		// have time at the moment to figure out why. (a-rsail)
		//	AssertSz((_bTabCount != 0),
		//	"CParaFormat::ValidateTabs: table with invalid tab count ");
		
		return;
	}

	// Non-table case.

	// It would be nice to assert on the consistency between these _bTabCount and _iTabs
	// but rtf reader has troubles with this. 
	//	AssertSz(((_bTabCount != 0) && (-1 != _iTabs)) || ((-1 == _iTabs) && (0 == _bTabCount)), 
	//	"CParaFormat::ValidateTabs: tab count and default tab index inconsistent");

	if (-1 == _iTabs)
	{
		// No tabs to validate so we are done.
		return;
	}

	const LONG *prgtabs = GetTabs();

	AssertSz(prgtabs != NULL, "CParaFormat::ValidateTabs: missing tab table");

	for (int i = 0; i < _bTabCount; i++)
	{
		AssertSz(GetTabAlign(prgtabs[i]) <= tomAlignBar,
			"CParaFormat::ValidateTabs: Invalid tab being set");
	}
}
#endif // DEBUG

//------------------------- Helper Functions -----------------------------------

// Defines and fixed font size details for increasing/decreasing font size
#define PWD_FONTSIZEPOINTMIN    1
// The following corresponds to the max signed 2-byte TWIP value, (32760)
#define PWD_FONTSIZEPOINTMAX    1638    

typedef struct tagfsFixup
{
    BYTE EndValue;
    BYTE Delta;
}
FSFIXUP;

const FSFIXUP fsFixups[] =
{
    12, 1,
    28, 2,
    36, 0,
    48, 0,
    72, 0,
    80, 0,
  	 0, 10			// EndValue = 0 case is treated as "infinite"
};

#define PWD_FONTSIZEMAXFIXUPS   (sizeof(fsFixups)/sizeof(fsFixups[0]))

/*
 *	GetUsableFontHeight(ySrcHeight, lPointChange)
 *
 *	@func
 *		Return a font size for setting text or insertion point attributes
 *
 *	@rdesc
 *		New TWIPS height
 *
 *	@devnote
 *		Copied from WinCE RichEdit code (written by V-GUYB)
 */
LONG GetUsableFontHeight(
	LONG ySrcHeight,		//@parm Current font size in twips
	LONG lPointChange)		//@parm Increase in pt size, (-ve if shrinking)
{
	LONG	EndValue;
	LONG	Delta;
    int		i;
    LONG	yRetHeight;

    // Input height in twips here, (TWentIeths of a Point).
    // Note, a Point is a 1/72th of an inch. To make these
    // calculations clearer, use point sizes here. Input height
    // in twips is always divisible by 20 (NOTE (MS3): maybe with
	// a truncation, since RTF uses half-point units).
    yRetHeight = (ySrcHeight / 20) + lPointChange;

    // Fix new font size to match sizes used by Word95
    for(i = 0; i < PWD_FONTSIZEMAXFIXUPS; ++i)
    {
		EndValue = fsFixups[i].EndValue;
		Delta	 = fsFixups[i].Delta;

        // Does new height lie in this range of point sizes?
        if(yRetHeight <= EndValue || !EndValue)
        {
            // If new height = EndValue, then it doesn't need adjusting
            if(yRetHeight != EndValue)
            {
                // Adjust new height to fit this range of point sizes. If
                // Delta = 1, all point sizes in this range stay as they are.
                if(!Delta)
                {
                    // Everything in this range is rounded to the EndValue
                    yRetHeight = fsFixups[(lPointChange > 0 ?
                                    i : max(i - 1, 0))].EndValue;
                }
                else if(Delta != 1)
                {
                    // Round new height to next delta in this range
                    yRetHeight = ((yRetHeight +
                        (lPointChange > 0 ? Delta - 1 : 0))
                                / Delta) * Delta;
                }
            }
            break;
        }
    }

    // Limit the new text size. Note, if we fix the text size
    // now, then we won't take any special action if we change
    // the text size later in the other direction. For example,
    // we shrink chars with size 1 and 2. They both change to
    // size 1. Then we grow them both to 2. So they are the
    // same size now, even though they weren't before. This
    // matches Word95 behavior.
    yRetHeight = max(yRetHeight, PWD_FONTSIZEPOINTMIN);
    yRetHeight = min(yRetHeight, PWD_FONTSIZEPOINTMAX);

    return yRetHeight*20;			// Return value in twips
}

/*
 *	IsValidCharFormatW(pCF)
 *
 *	@func
 *		Return TRUE iff the structure *<p pCF> has the correct size to be
 *		a CHARFORMAT or a CHARFORMAT2
 *
 *	@rdesc
 *		Return TRUE if *<p pCF> is a valid CHARFORMAT(2)
 */
BOOL IsValidCharFormatW (
	const CHARFORMAT * pCF) 		//@parm CHARFORMAT to validate
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "IsValidCharFormat");

	return pCF && (pCF->cbSize == sizeof(CHARFORMATW) ||
				   pCF->cbSize == sizeof(CHARFORMAT2W));
}

/*
 *	IsValidCharFormatA(pCFA)
 *
 *	@func
 *		Return TRUE iff the structure *<p pCF> has the correct size to be
 *		a CHARFORMATA or a CHARFORMAT2A
 *
 *	@rdesc
 *		Return TRUE if *<p pCF> is a valid CHARFORMAT(2)A
 */
BOOL IsValidCharFormatA (
	const CHARFORMATA * pCFA) 	//@parm CHARFORMATA to validate
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "IsValidCharFormatA");

	return pCFA && (pCFA->cbSize == sizeof(CHARFORMATA) ||
					pCFA->cbSize == sizeof(CHARFORMAT2A));
}

/*
 *	IsValidParaFormat(pPF)
 *
 *	@func
 *		Return TRUE iff the structure *<p pPF> has the correct size to be
 *		a PARAFORMAT or a PARAFORMAT2
 *
 *	@rdesc
 *		Return TRUE if *<p pPF> is a valid PARAFORMAT(2)
 */
BOOL IsValidParaFormat (
	const PARAFORMAT * pPF)		//@parm PARAFORMAT to validate
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "IsValidParaFormat");

	if (pPF && (pPF->cbSize == sizeof(PARAFORMAT) ||
				pPF->cbSize == sizeof(PARAFORMAT2)))
	{
		return TRUE;
	}
	TRACEERRORSZ("!!!!!!!!!!! bogus PARAFORMAT from client !!!!!!!!!!!!!");
	return FALSE;
}

/*
 *	Get16BitTwips(dy)
 *
 *	@func
 *		Return dy if |dy| < 32768; else return 32767, i.e., max value
 *		that fits into a SHORT
 *
 *	@rdesc
 *		dy if abs(cy) < 32768; else 32767
 */
SHORT Get16BitTwips(LONG dy)
{
	return abs(dy) < 32768 ? (SHORT)dy : 32767;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\devdsc.cpp ===
/*
 *	DEVDSC.C
 *	
 *	Purpose:
 *		CDevDesc (Device Descriptor) class
 *	
 *	Owner:
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 */

#include "_common.h"
#include "_devdsc.h"
#include "_edit.h"
#include "_font.h"

ASSERTDATA

BOOL CDevDesc::SetDC(HDC hdc, LONG dxpInch, LONG dypInch)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDevDesc::SetDC");

	AssertSz((NULL == hdc) || (GetDeviceCaps(hdc, TECHNOLOGY) != DT_METAFILE),
		"CDevDesc::SetDC attempting to set a metafile");

	_hdc = hdc;
	if(!_hdc)
	{
	    if(!_ped->_fInPlaceActive || !(hdc = _ped->TxGetDC()))
        {
            _dxpInch = _dypInch = 0;
    	    return FALSE;
        }
    }

	if (dxpInch == -1)
	{
		// Get device metrics - these should both succeed
		_dxpInch = (SHORT)GetDeviceCaps(hdc, LOGPIXELSX);
		AssertSz(_dxpInch != 0, "CDevDesc::SetDC _dxpInch is 0");
	}
	else
		_dxpInch = dxpInch;

	if (dypInch == -1)
	{
		_dypInch = (SHORT)GetDeviceCaps(hdc, LOGPIXELSY);
		AssertSz(_dypInch != 0, "CDevDesc::SetDC _dypInch is 0");
	}
	else
		_dypInch = dypInch;

	if(!_dxpInch || !_dypInch)
		return FALSE;

	// Release DC if we got the window DC
	if(!_hdc)
		_ped->TxReleaseDC(hdc);

	return TRUE;
}


void CDevDesc::SetMetafileDC(
	HDC hdcMetafile,
	LONG xMeasurePerInch,
	LONG yMeasurePerInch)
{
	_fMetafile = TRUE;
	_hdc = hdcMetafile;
	_dxpInch = (SHORT) xMeasurePerInch;
	_dypInch = (SHORT) yMeasurePerInch;
}

HDC CDevDesc::GetScreenDC() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDevDesc::GetScreenDC");

	Assert(!_hdc);
	Assert(_ped);
	return _ped->TxGetDC();
}

VOID CDevDesc::ReleaseScreenDC(HDC hdc) const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDevDesc::ReleaseScreenDC");

	Assert(!_hdc);
	Assert(_ped);
	_ped->TxReleaseDC(hdc);
}

LONG CDevDesc::DXtoLX(LONG x) const	
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDevDesc::DXtoLX");

    AssertSz(_dxpInch, "CDevDesc::DXtoLX() - hdc has not been set");
    return ((x * LX_PER_INCH) * 2 + _dxpInch) / (2 * _dxpInch);
}

LONG CDevDesc::DYtoLY(LONG y) const	
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDevDesc::DYtoLY");

    AssertSz(_dypInch, "CDevDesc::DYtoLY() - hdc has not been set");
    return ((y * LY_PER_INCH) * 2 + _dypInch) / (2 * _dypInch);
}

void CDevDesc::DPtoLP(POINT &ptDest, const POINT &ptSrc) const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDevDesc::DPtoLP");

    ptDest.x = DXtoLX(ptSrc.x);    
    ptDest.y = DYtoLY(ptSrc.y);    
}

void CDevDesc::DRtoLR(RECT &rcDest, const RECT &rcSrc) const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDevDesc::DRtoLR");

    rcDest.left = DXtoLX(rcSrc.left);    
    rcDest.right = DXtoLX(rcSrc.right);    
    rcDest.top = DYtoLY(rcSrc.top);    
    rcDest.bottom = DYtoLY(rcSrc.bottom);    
}

#ifdef DEBUG
LONG CDevDesc::LXtoDX(LONG x) const	
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDevDesc::LXtoDX");

    AssertSz(_dxpInch, "CDevDesc::LXtoDX() - hdc has not been set");
    return ((x * _dxpInch) + LX_PER_INCH / 2) / LX_PER_INCH;
}

LONG CDevDesc::LYtoDY(LONG y) const	
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDevDesc::LYtoDY");

    AssertSz(_dypInch, "CDevDesc::LYtoDY() - hdc has not been set");
    return ((y * _dypInch) + LY_PER_INCH / 2) / LY_PER_INCH;
}
#endif  // DEBUG

void CDevDesc::LPtoDP(POINT &ptDest, const POINT &ptSrc) const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDevDesc::LPtoDP");

    ptDest.x = LXtoDX(ptSrc.x);    
    ptDest.y = LYtoDY(ptSrc.y);    
}

void CDevDesc::LRtoDR(RECT &rcDest, const RECT &rcSrc) const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDevDesc::LRtoDR");

    rcDest.left = LXtoDX(rcSrc.left);    
    rcDest.right = LXtoDX(rcSrc.right);    
    rcDest.top = LYtoDY(rcSrc.top);    
    rcDest.bottom = LYtoDY(rcSrc.bottom);    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\debug.cpp ===
/*
 *	DEBUG.CPP
 *	
 *	Purpose:
 *		RICHEDIT debugging support--commented out in ship builds
 *
 *	History: <nl>
 *		7/29/98	KeithCu Wrote it stealing much from Rich Arneson's code
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"

//Module is empty if this is a retail build.
#if defined(DEBUG) || defined(_RELEASE_ASSERTS_)

DWORD dwDebugOptions = 0;         //Debug option flags
PFNASSERTHOOK pfnAssert = NULL;   //Assert hook function
PFNTRACEHOOK pfnTrace = NULL;     //Trace hook function

// Static variables
static HINSTANCE ghMod;                        //Dll module handle
static DWORD TlsIndex;                      //Debug output indent level
static HANDLE hLogFile = NULL;              //Log file handle
static BOOL fIgnoreAsserts = FALSE;         //Ignore all asserts if true
static CRITICAL_SECTION csLog;              //Critical section for log file i/o
static CRITICAL_SECTION csAssert;           //Critical section for asserts
static HANDLE hEventAssert1 = NULL;         //Event for assert syncing
static HANDLE hEventAssert2 = NULL;         //Event for assert syncing
static HWND hwndAssert = NULL;           	//Assert dialog window handle
static HANDLE hAssertThrd = NULL;           //Assert thread handle
static char szAssert[MAXDEBUGSTRLEN];       //Assert message buffer
static int idAssert = -1;                   //Assert button pressed by user
DWORD WINAPI AssertThread(LPVOID lParam);	//Assert thread entry point
static BOOL fDllDetach = FALSE;				//True if we are in dll detach

//Strings for subsystem element of message
static char* TrcSubsys [] =
{
    "",
    "Display",
    "Wrapper",
    "Edit",
    "TextServices",
    "TOM",
    "OLE Object Support",
    "Store",
    "Selection",
    "WinHost",
    "DataXfer",
    "MultiUndo",
    "Range",
    "Util",
    "Notification Mgr.",
    "RTF Reader",
    "RTF Writer",
    "Printing",
    "Far East",
	"Font"
};

//Strings for severity element of message
static char* TrcSeverity [] =
{
    "",
    "WARNING",
    "ERROR",
    "ASSERT",
    "INFO",
	"MEMORY"
};

//Strings for scope element of message
static char* TrcScope [] =
{
    "",
    "External",
    "Internal"
};

//Structure for lookup tables
typedef struct
{
    DWORD dwKey;
    char * sz;
} TabElem;

//Lookup table for CTrace param strings
static TabElem TrcParamTab [] = 
{
//Richedit Messages
    {(DWORD)EM_GETLIMITTEXT, "EM_GETLIMITTEXT"},
    {(DWORD)EM_POSFROMCHAR, "EM_POSFROMCHAR"},
    {(DWORD)EM_CHARFROMPOS, "EM_CHARFROMPOS"},
    {(DWORD)EM_SCROLLCARET, "EM_SCROLLCARET"},
    {(DWORD)EM_CANPASTE, "EM_CANPASTE"},
    {(DWORD)EM_DISPLAYBAND, "EM_DISPLAYBAND"},
    {(DWORD)EM_EXGETSEL, "EM_EXGETSEL"},
    {(DWORD)EM_EXLIMITTEXT, "EM_EXLIMITTEXT"},
    {(DWORD)EM_EXLINEFROMCHAR, "EM_EXLINEFROMCHAR"},
    {(DWORD)EM_EXSETSEL, "EM_EXSETSEL"},
    {(DWORD)EM_FINDTEXT, "EM_FINDTEXT"},
    {(DWORD)EM_FORMATRANGE, "EM_FORMATRANGE"},
    {(DWORD)EM_GETCHARFORMAT, "EM_GETCHARFORMAT"},
    {(DWORD)EM_GETEVENTMASK, "EM_GETEVENTMASK"},
    {(DWORD)EM_GETOLEINTERFACE, "EM_GETOLEINTERFACE"},
    {(DWORD)EM_GETPARAFORMAT, "EM_GETPARAFORMAT"},
    {(DWORD)EM_GETSELTEXT, "EM_GETSELTEXT"},
    {(DWORD)EM_HIDESELECTION, "EM_HIDESELECTION"},
    {(DWORD)EM_PASTESPECIAL, "EM_PASTESPECIAL"},
    {(DWORD)EM_REQUESTRESIZE, "EM_REQUESTRESIZE"},
    {(DWORD)EM_SELECTIONTYPE, "EM_SELECTIONTYPE"},
    {(DWORD)EM_SETBKGNDCOLOR, "EM_SETBKGNDCOLOR"},
    {(DWORD)EM_SETCHARFORMAT, "EM_SETCHARFORMAT"},
    {(DWORD)EM_SETEVENTMASK, "EM_SETEVENTMASK"},
    {(DWORD)EM_SETOLECALLBACK, "EM_SETOLECALLBACK"},
    {(DWORD)EM_SETPARAFORMAT, "EM_SETPARAFORMAT"},
    {(DWORD)EM_SETTARGETDEVICE, "EM_SETTARGETDEVICE"},
    {(DWORD)EM_STREAMIN, "EM_STREAMIN"},
    {(DWORD)EM_STREAMOUT, "EM_STREAMOUT"},
    {(DWORD)EM_GETTEXTRANGE, "EM_GETTEXTRANGE"},
    {(DWORD)EM_FINDWORDBREAK, "EM_FINDWORDBREAK"},
    {(DWORD)EM_SETOPTIONS, "EM_SETOPTIONS"},
    {(DWORD)EM_GETOPTIONS, "EM_GETOPTIONS"},
    {(DWORD)EM_FINDTEXTEX, "EM_FINDTEXTEX"},
    {(DWORD)EM_GETWORDBREAKPROCEX, "EM_GETWORDBREAKPROCEX"},
    {(DWORD)EM_SETWORDBREAKPROCEX, "EM_SETWORDBREAKPROCEX"},
    {(DWORD)EM_SETUNDOLIMIT, "EM_SETUNDOLIMIT"},
    {(DWORD)EM_REDO, "EM_REDO"},
    {(DWORD)EM_CANREDO, "EM_CANREDO"},
    {(DWORD)EM_SETPUNCTUATION, "EM_SETPUNCTUATION"},
    {(DWORD)EM_GETPUNCTUATION, "EM_GETPUNCTUATION"},
    {(DWORD)EM_SETWORDWRAPMODE, "EM_SETWORDWRAPMODE"},
    {(DWORD)EM_GETWORDWRAPMODE, "EM_GETWORDWRAPMODE"},
    {(DWORD)EM_SETIMECOLOR, "EM_SETIMECOLOR"},
    {(DWORD)EM_GETIMECOLOR, "EM_GETIMECOLOR"},
    {(DWORD)EM_SETIMEOPTIONS, "EM_SETIMEOPTIONS"},
    {(DWORD)EM_GETIMEOPTIONS, "EM_GETIMEOPTIONS"},
    {(DWORD)EN_MSGFILTER, "EN_MSGFILTER"},
    {(DWORD)EN_REQUESTRESIZE, "EN_REQUESTRESIZE"},
    {(DWORD)EN_SELCHANGE, "EN_SELCHANGE"},
    {(DWORD)EN_DROPFILES, "EN_DROPFILES"},
    {(DWORD)EN_PROTECTED, "EN_PROTECTED"},
    {(DWORD)EN_CORRECTTEXT, "EN_CORRECTTEXT"},
    {(DWORD)EN_STOPNOUNDO, "EN_STOPNOUNDO"},
    {(DWORD)EN_IMECHANGE, "EN_IMECHANGE"},
    {(DWORD)EN_SAVECLIPBOARD, "EN_SAVECLIPBOARD"},
    {(DWORD)EN_OLEOPFAILED, "EN_OLEOPFAILED"},

//Window Messages

	{(DWORD)WM_NULL, "WM_NULL"},
	{(DWORD)WM_CREATE, "WM_CREATE"},
	{(DWORD)WM_DESTROY, "WM_DESTROY"},
	{(DWORD)WM_MOVE, "WM_MOVE"},
	{(DWORD)WM_SIZE, "WM_SIZE"},
	{(DWORD)WM_ACTIVATE, "WM_ACTIVATE"},
	{(DWORD)WM_SETFOCUS, "WM_SETFOCUS"},
	{(DWORD)WM_KILLFOCUS, "WM_KILLFOCUS"},
	{(DWORD)WM_ENABLE, "WM_ENABLE"},
	{(DWORD)WM_SETREDRAW, "WM_SETREDRAW"},
	{(DWORD)WM_SETTEXT, "WM_SETTEXT"},
	{(DWORD)WM_GETTEXT, "WM_GETTEXT"},
	{(DWORD)WM_GETTEXTLENGTH, "WM_GETTEXTLENGTH"},
	{(DWORD)WM_PAINT, "WM_PAINT"},
	{(DWORD)WM_CLOSE, "WM_CLOSE"},
	{(DWORD)WM_QUERYENDSESSION, "WM_QUERYENDSESSION"},
	{(DWORD)WM_QUIT, "WM_QUIT"},
	{(DWORD)WM_QUERYOPEN, "WM_QUERYOPEN"},
	{(DWORD)WM_ERASEBKGND, "WM_ERASEBKGND"},
	{(DWORD)WM_SYSCOLORCHANGE, "WM_SYSCOLORCHANGE"},
	{(DWORD)WM_ENDSESSION, "WM_ENDSESSION"},
	{(DWORD)WM_SHOWWINDOW, "WM_SHOWWINDOW"},
	{(DWORD)WM_WININICHANGE, "WM_WININICHANGE"},
	{(DWORD)WM_SETTINGCHANGE, "WM_SETTINGCHANGE"},
	{(DWORD)WM_DEVMODECHANGE, "WM_DEVMODECHANGE"},
	{(DWORD)WM_ACTIVATEAPP, "WM_ACTIVATEAPP"},
	{(DWORD)WM_FONTCHANGE, "WM_FONTCHANGE"},
	{(DWORD)WM_TIMECHANGE, "WM_TIMECHANGE"},
	{(DWORD)WM_CANCELMODE, "WM_CANCELMODE"},
	{(DWORD)WM_SETCURSOR, "WM_SETCURSOR"},
	{(DWORD)WM_MOUSEACTIVATE, "WM_MOUSEACTIVATE"},
	{(DWORD)WM_CHILDACTIVATE, "WM_CHILDACTIVATE"},
	{(DWORD)WM_QUEUESYNC, "WM_QUEUESYNC"},
	{(DWORD)WM_GETMINMAXINFO, "WM_GETMINMAXINFO"},
	{(DWORD)WM_PAINTICON, "WM_PAINTICON"},
	{(DWORD)WM_ICONERASEBKGND, "WM_ICONERASEBKGND"},
	{(DWORD)WM_NEXTDLGCTL, "WM_NEXTDLGCTL"},
	{(DWORD)WM_SPOOLERSTATUS, "WM_SPOOLERSTATUS"},
	{(DWORD)WM_DRAWITEM, "WM_DRAWITEM"},
	{(DWORD)WM_MEASUREITEM, "WM_MEASUREITEM"},
	{(DWORD)WM_DELETEITEM, "WM_DELETEITEM"},
	{(DWORD)WM_VKEYTOITEM, "WM_VKEYTOITEM"},
	{(DWORD)WM_CHARTOITEM, "WM_CHARTOITEM"},
	{(DWORD)WM_SETFONT, "WM_SETFONT"},
	{(DWORD)WM_GETFONT, "WM_GETFONT"},
	{(DWORD)WM_SETHOTKEY, "WM_SETHOTKEY"},
	{(DWORD)WM_GETHOTKEY, "WM_GETHOTKEY"},
	{(DWORD)WM_QUERYDRAGICON, "WM_QUERYDRAGICON"},
	{(DWORD)WM_COMPAREITEM, "WM_COMPAREITEM"},
	{(DWORD)WM_COMPACTING, "WM_COMPACTING"},
	{(DWORD)WM_COMMNOTIFY, "WM_COMMNOTIFY"},
	{(DWORD)WM_WINDOWPOSCHANGING, "WM_WINDOWPOSCHANGING"},
	{(DWORD)WM_WINDOWPOSCHANGED, "WM_WINDOWPOSCHANGED"},
	{(DWORD)WM_POWER, "WM_POWER"},
	{(DWORD)WM_COPYDATA, "WM_COPYDATA"},
	{(DWORD)WM_CANCELJOURNAL, "WM_CANCELJOURNAL"},
	{(DWORD)WM_NOTIFY, "WM_NOTIFY"},
	{(DWORD)WM_INPUTLANGCHANGEREQUEST, "WM_INPUTLANGCHANGEREQUEST"},
	{(DWORD)WM_INPUTLANGCHANGE, "WM_INPUTLANGCHANGE"},
	{(DWORD)WM_TCARD, "WM_TCARD"},
	{(DWORD)WM_HELP, "WM_HELP"},
	{(DWORD)WM_USERCHANGED, "WM_USERCHANGED"},
	{(DWORD)WM_NOTIFYFORMAT, "WM_NOTIFYFORMAT"},
	{(DWORD)WM_CONTEXTMENU, "WM_CONTEXTMENU"},
	{(DWORD)WM_STYLECHANGING, "WM_STYLECHANGING"},
	{(DWORD)WM_STYLECHANGED, "WM_STYLECHANGED"},
	{(DWORD)WM_DISPLAYCHANGE, "WM_DISPLAYCHANGE"},
	{(DWORD)WM_GETICON, "WM_GETICON"},
	{(DWORD)WM_SETICON, "WM_SETICON"},
	{(DWORD)WM_NCCREATE, "WM_NCCREATE"},
	{(DWORD)WM_NCDESTROY, "WM_NCDESTROY"},
	{(DWORD)WM_NCCALCSIZE, "WM_NCCALCSIZE"},
	{(DWORD)WM_NCHITTEST, "WM_NCHITTEST"},
	{(DWORD)WM_NCPAINT, "WM_NCPAINT"},
	{(DWORD)WM_NCACTIVATE, "WM_NCACTIVATE"},
	{(DWORD)WM_GETDLGCODE, "WM_GETDLGCODE"},
	{(DWORD)WM_NCMOUSEMOVE, "WM_NCMOUSEMOVE"},
	{(DWORD)WM_NCLBUTTONDOWN, "WM_NCLBUTTONDOWN"},
	{(DWORD)WM_NCLBUTTONUP, "WM_NCLBUTTONUP"},
	{(DWORD)WM_NCLBUTTONDBLCLK, "WM_NCLBUTTONDBLCLK"},
	{(DWORD)WM_NCRBUTTONDOWN, "WM_NCRBUTTONDOWN"},
	{(DWORD)WM_NCRBUTTONUP, "WM_NCRBUTTONUP"},
	{(DWORD)WM_NCRBUTTONDBLCLK, "WM_NCRBUTTONDBLCLK"},
	{(DWORD)WM_NCMBUTTONDOWN, "WM_NCMBUTTONDOWN"},
	{(DWORD)WM_NCMBUTTONUP, "WM_NCMBUTTONUP"},
	{(DWORD)WM_NCMBUTTONDBLCLK, "WM_NCMBUTTONDBLCLK"},
	{(DWORD)WM_KEYFIRST, "WM_KEYFIRST"},
	{(DWORD)WM_KEYDOWN, "WM_KEYDOWN"},
	{(DWORD)WM_KEYUP, "WM_KEYUP"},
	{(DWORD)WM_CHAR, "WM_CHAR"},
	{(DWORD)WM_DEADCHAR, "WM_DEADCHAR"},
	{(DWORD)WM_SYSKEYDOWN, "WM_SYSKEYDOWN"},
	{(DWORD)WM_SYSKEYUP, "WM_SYSKEYUP"},
	{(DWORD)WM_SYSCHAR, "WM_SYSCHAR"},
	{(DWORD)WM_SYSDEADCHAR, "WM_SYSDEADCHAR"},
	{(DWORD)WM_KEYLAST, "WM_KEYLAST"},
	{(DWORD)WM_IME_STARTCOMPOSITION, "WM_IME_STARTCOMPOSITION"},
	{(DWORD)WM_IME_ENDCOMPOSITION, "WM_IME_ENDCOMPOSITION"},
	{(DWORD)WM_IME_COMPOSITION, "WM_IME_COMPOSITION"},
	{(DWORD)WM_IME_KEYLAST, "WM_IME_KEYLAST"},
	{(DWORD)WM_INITDIALOG, "WM_INITDIALOG"},
	{(DWORD)WM_COMMAND, "WM_COMMAND"},
	{(DWORD)WM_SYSCOMMAND, "WM_SYSCOMMAND"},
	{(DWORD)WM_TIMER, "WM_TIMER"},
	{(DWORD)WM_HSCROLL, "WM_HSCROLL"},
	{(DWORD)WM_VSCROLL, "WM_VSCROLL"},
	{(DWORD)WM_INITMENU, "WM_INITMENU"},
	{(DWORD)WM_INITMENUPOPUP, "WM_INITMENUPOPUP"},
	{(DWORD)WM_MENUSELECT, "WM_MENUSELECT"},
	{(DWORD)WM_MENUCHAR, "WM_MENUCHAR"},
	{(DWORD)WM_ENTERIDLE, "WM_ENTERIDLE"},
	{(DWORD)WM_CTLCOLORMSGBOX, "WM_CTLCOLORMSGBOX"},
	{(DWORD)WM_CTLCOLOREDIT, "WM_CTLCOLOREDIT"},
	{(DWORD)WM_CTLCOLORLISTBOX, "WM_CTLCOLORLISTBOX"},
	{(DWORD)WM_CTLCOLORBTN, "WM_CTLCOLORBTN"},
	{(DWORD)WM_CTLCOLORDLG, "WM_CTLCOLORDLG"},
	{(DWORD)WM_CTLCOLORSCROLLBAR, "WM_CTLCOLORSCROLLBAR"},
	{(DWORD)WM_CTLCOLORSTATIC, "WM_CTLCOLORSTATIC"},
	{(DWORD)WM_MOUSEFIRST, "WM_MOUSEFIRST"},
	{(DWORD)WM_MOUSEMOVE, "WM_MOUSEMOVE"},
	{(DWORD)WM_LBUTTONDOWN, "WM_LBUTTONDOWN"},
	{(DWORD)WM_LBUTTONUP, "WM_LBUTTONUP"},
	{(DWORD)WM_LBUTTONDBLCLK, "WM_LBUTTONDBLCLK"},
	{(DWORD)WM_RBUTTONDOWN, "WM_RBUTTONDOWN"},
	{(DWORD)WM_RBUTTONUP, "WM_RBUTTONUP"},
	{(DWORD)WM_RBUTTONDBLCLK, "WM_RBUTTONDBLCLK"},
	{(DWORD)WM_MBUTTONDOWN, "WM_MBUTTONDOWN"},
	{(DWORD)WM_MBUTTONUP, "WM_MBUTTONUP"},
	{(DWORD)WM_MBUTTONDBLCLK, "WM_MBUTTONDBLCLK"},
	{(DWORD)WM_MOUSELAST, "WM_MOUSELAST"},
	{(DWORD)WM_PARENTNOTIFY, "WM_PARENTNOTIFY"},
	{(DWORD)WM_ENTERMENULOOP, "WM_ENTERMENULOOP"},
	{(DWORD)WM_EXITMENULOOP, "WM_EXITMENULOOP"},
	{(DWORD)WM_NEXTMENU, "WM_NEXTMENU"},
	{(DWORD)WM_SIZING, "WM_SIZING"},
	{(DWORD)WM_CAPTURECHANGED, "WM_CAPTURECHANGED"},
	{(DWORD)WM_MOVING, "WM_MOVING"},
	{(DWORD)WM_POWERBROADCAST, "WM_POWERBROADCAST"},
	{(DWORD)WM_DEVICECHANGE, "WM_DEVICECHANGE"},
	{(DWORD)WM_IME_SETCONTEXT, "WM_IME_SETCONTEXT"},
	{(DWORD)WM_IME_NOTIFY, "WM_IME_NOTIFY"},
	{(DWORD)WM_IME_CONTROL, "WM_IME_CONTROL"},
	{(DWORD)WM_IME_COMPOSITIONFULL, "WM_IME_COMPOSITIONFULL"},
	{(DWORD)WM_IME_SELECT, "WM_IME_SELECT"},
	{(DWORD)WM_IME_CHAR, "WM_IME_CHAR"},
	{(DWORD)WM_IME_KEYDOWN, "WM_IME_KEYDOWN"},
	{(DWORD)WM_IME_KEYUP, "WM_IME_KEYUP"},
	{(DWORD)WM_MDICREATE, "WM_MDICREATE"},
	{(DWORD)WM_MDIDESTROY, "WM_MDIDESTROY"},
	{(DWORD)WM_MDIACTIVATE, "WM_MDIACTIVATE"},
	{(DWORD)WM_MDIRESTORE, "WM_MDIRESTORE"},
	{(DWORD)WM_MDINEXT, "WM_MDINEXT"},
	{(DWORD)WM_MDIMAXIMIZE, "WM_MDIMAXIMIZE"},
	{(DWORD)WM_MDITILE, "WM_MDITILE"},
	{(DWORD)WM_MDICASCADE, "WM_MDICASCADE"},
	{(DWORD)WM_MDIICONARRANGE, "WM_MDIICONARRANGE"},
	{(DWORD)WM_MDIGETACTIVE, "WM_MDIGETACTIVE"},
	{(DWORD)WM_MDISETMENU, "WM_MDISETMENU"},
	{(DWORD)WM_ENTERSIZEMOVE, "WM_ENTERSIZEMOVE"},
	{(DWORD)WM_EXITSIZEMOVE, "WM_EXITSIZEMOVE"},
	{(DWORD)WM_DROPFILES, "WM_DROPFILES"},
	{(DWORD)WM_MDIREFRESHMENU, "WM_MDIREFRESHMENU"},
	{(DWORD)WM_CUT, "WM_CUT"},
	{(DWORD)WM_COPY, "WM_COPY"},
	{(DWORD)WM_PASTE, "WM_PASTE"},
	{(DWORD)WM_CLEAR, "WM_CLEAR"},
	{(DWORD)WM_UNDO, "WM_UNDO"},
	{(DWORD)WM_RENDERFORMAT, "WM_RENDERFORMAT"},
	{(DWORD)WM_RENDERALLFORMATS, "WM_RENDERALLFORMATS"},
	{(DWORD)WM_DESTROYCLIPBOARD, "WM_DESTROYCLIPBOARD"},
	{(DWORD)WM_DRAWCLIPBOARD, "WM_DRAWCLIPBOARD"},
	{(DWORD)WM_PAINTCLIPBOARD, "WM_PAINTCLIPBOARD"},
	{(DWORD)WM_VSCROLLCLIPBOARD, "WM_VSCROLLCLIPBOARD"},
	{(DWORD)WM_SIZECLIPBOARD, "WM_SIZECLIPBOARD"},
	{(DWORD)WM_ASKCBFORMATNAME, "WM_ASKCBFORMATNAME"},
	{(DWORD)WM_CHANGECBCHAIN, "WM_CHANGECBCHAIN"},
	{(DWORD)WM_HSCROLLCLIPBOARD, "WM_HSCROLLCLIPBOARD"},
	{(DWORD)WM_QUERYNEWPALETTE, "WM_QUERYNEWPALETTE"},
	{(DWORD)WM_PALETTEISCHANGING, "WM_PALETTEISCHANGING"},
	{(DWORD)WM_PALETTECHANGED, "WM_PALETTECHANGED"},
	{(DWORD)WM_HOTKEY, "WM_HOTKEY"},
	{(DWORD)WM_PRINT, "WM_PRINT"},
	{(DWORD)WM_PRINTCLIENT, "WM_PRINTCLIENT"},
	{(DWORD)WM_HANDHELDFIRST, "WM_HANDHELDFIRST"},
	{(DWORD)WM_HANDHELDLAST, "WM_HANDHELDLAST"},
	{(DWORD)WM_AFXFIRST, "WM_AFXFIRST"},
	{(DWORD)WM_AFXLAST, "WM_AFXLAST"},
	{(DWORD)WM_PENWINFIRST, "WM_PENWINFIRST"},
	{(DWORD)WM_PENWINLAST, "WM_PENWINLAST"},
	{(DWORD)WM_APP, "WM_APP"}
};

// release + asserts build has no memory checking
#ifndef _RELEASE_ASSERTS_

void DlgDisplayVrgmst(HWND hListMemory)
{
	char szTemp[300];
	int cbTotal = 0;
	for(int imst = 0; vrgmst[imst].szFile != 0; imst++)
		{
		cbTotal += vrgmst[imst].cbAlloc;
		wsprintfA(szTemp, "%6.d   %s", vrgmst[imst].cbAlloc, vrgmst[imst].szFile);
		SendMessage(hListMemory, LB_ADDSTRING, 0,  (LPARAM) szTemp);
		}

	wsprintfA(szTemp, "%6.d   %s", cbTotal, "--- Total ---");
	SendMessage(hListMemory, LB_ADDSTRING, 0,  (LPARAM) szTemp);
}

HFONT hf = 0;

INT_PTR CALLBACK FDlgRicheditDebugCentral(HWND hdlg, UINT message, WPARAM wParam, LPARAM lParam)
{
	HWND hListMemory;
	switch (message)
		{
		case WM_INITDIALOG:
			hListMemory = GetDlgItem(hdlg, IDC_MEMORY_STATISTICS);
			LOGFONTA lf;
			ZeroMemory(&lf, sizeof(lf));
			lf.lfHeight = 14;
			memcpy(lf.lfFaceName, "Courier New", 12);
			hf = CreateFontIndirectA(&lf);
			SendMessage(hListMemory, WM_SETFONT, (WPARAM)hf, FALSE);
			UpdateMst();
			DlgDisplayVrgmst(hListMemory);
			return FALSE;

		case WM_COMMAND:
			switch (wParam)
				{
				case IDOK:
					EndDialog(hdlg, IDOK);
					return TRUE;
				case IDCANCEL:
					EndDialog(hdlg, IDCANCEL);
					return TRUE;
				}
			break;
		}

	return FALSE;
}

void RicheditDebugCentral(void)
{
	DialogBoxA(hinstRE, MAKEINTRESOURCEA(IDD_DEBUG), NULL, FDlgRicheditDebugCentral);
	DeleteObject(hf);
}

#endif //!_RELEASE_ASSERTS_


/*
 *  DebugMain
 *	
 *  @mfunc
 *      Dll entry point.  See Win32 SDK documentation for details.
 *          hDLL - handle of DLL
 *          dwReason - indicates why DLL called
 *          lpReserved - reserved
 *
 *  @rdesc
 *      TRUE (always)
 *
 */
BOOL WINAPI DebugMain (HINSTANCE hDLL, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            //
            // DLL is attaching to the address space of the current process.
            //
            ghMod = hDLL;
            TlsIndex = TlsAlloc();
            TlsSetValue(TlsIndex, (LPVOID)-1);
            InitializeCriticalSection(&csLog);
            InitializeCriticalSection(&csAssert);

			//Create a separate thread to handle asserts.
            //We use events to halt the the asserting thread
            //during an assert, and to halt the assert thread the rest of
            //the time.  Note that these are autoreset events.
            hEventAssert1= CreateEvent(NULL, FALSE, FALSE, NULL);
            hEventAssert2= CreateEvent(NULL, FALSE, FALSE, NULL);

            INITDEBUGSERVICES(OPTUSEDEFAULTS, NULL, NULL);

            break;
        }

        case DLL_THREAD_ATTACH:
        {

            //
            // A new thread is being created in the current process.
            //
            TlsSetValue(TlsIndex, (LPVOID)-1);
            break;
        }

        case DLL_THREAD_DETACH:
        {
            //
            // A thread is exiting cleanly.
            //
            break;
        }

        case DLL_PROCESS_DETACH:
        {
            //
            // The calling process is detaching the DLL from its address space.
            //
			fDllDetach = TRUE;

            //Clean up after ourselves.
            TlsFree(TlsIndex);
            SETLOGGING(FALSE);

			//Clean up the assert thread stuff.
            if (NULL != hAssertThrd)
                TerminateThread(hAssertThrd, 0);
            if (NULL != hEventAssert1)
                CloseHandle(hEventAssert1);
            if (NULL != hEventAssert2)
                CloseHandle(hEventAssert2);

            DeleteCriticalSection(&csLog);
            DeleteCriticalSection(&csAssert);

            break;
        }
    }   

    return TRUE;
}


//This is not in release asserts build
#ifndef _RELEASE_ASSERTS_

/*
 *  SetLogging
 *	
 *  @mfunc
 *      This function starts and stops logging of output from
 *      the debug services.  If logging is being started, it
 *      creates a new file for logging (path and name specified
 *      in win.ini).  fStartLog is TRUE and logging is already
 *      on, or fStartLog is FALSE and logging is off, this
 *      nothing happens.
 *
 *      fStartLog - TRUE to start logging, FALSE to stop logging.
 *
 */
void WINAPI SetLogging(BOOL fStartLog)
{
    //Don't start logging if it's already on.
    if (fStartLog && !fLogging)
    {
        char szLogFile[MAX_PATH];

        //Set option flag telling everyone we're on
        dwDebugOptions |= OPTLOGGINGON;

        //Get file name
        GetProfileStringA("RICHEDIT DEBUG", "LOGFILE", "", szLogFile, MAX_PATH);

        //Create new file
        hLogFile = CreateFileA(szLogFile, GENERIC_READ | GENERIC_WRITE,
            FILE_SHARE_READ | FILE_SHARE_WRITE,
            NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

        //If we didn't succed creating the file, reset flags and tell user.
        if (INVALID_HANDLE_VALUE == hLogFile)
        {
            dwDebugOptions &= ~OPTLOGGINGON;
            MessageBoxA(NULL, "Unable to open log file.", "Richedit Debug", MB_OK);
        }
    }
    //Don't stop logging if it's not on.
    else if (!fStartLog && fLogging)
    {
        //Set option flag telling everyone we're off, and close file.
        dwDebugOptions &= ~OPTLOGGINGON;
        CloseHandle(hLogFile);
    }
}

#endif //!_RELEASE_ASSERTS_


/*
 *  InitDebugServices
 *	
 *  @mfunc
 *      This function initializes the options for the debug
 *      services.  If this function is not called, all optional
 *      debug services are left off by default.
 *      If OPTUSEDEFAULTS is specified for dwOpts, options are
 *      loaded from win.ini, otherwise  the caller specified
 *      options are set.  If the caller wishes to specify options
 *      they must specify all options they want turned on.  Any
 *      options not explicitly specified will be turned off.
 *      The function also takes a pointer to an assert hook
 *      function and a trace hook function.
 *
 *      dwOpts - Debug options to be set.
 *      pfnAssertHook - Pointer to assert hook function (NULL if none).
 *      pfnTraceHook - Pointer to trace hook function (NULL if none).
 *
 */
DllExport void WINAPI InitDebugServices(DWORD dwOpts,
    PFNASSERTHOOK pfnAssertHook, PFNTRACEHOOK pfnTraceHook)
{
    // Check to see if OPTUSEDEFAULTS was specified.  If so, get
    // values from win.ini.  Otherwise, set options to values
    // specified by caller.
    if (dwOpts & OPTUSEDEFAULTS)
    {
        SETLOGGING(GetProfileIntA("RICHEDIT DEBUG", "LOGGING", 0));
        SETVERBOSE(GetProfileIntA("RICHEDIT DEBUG", "VERBOSE", 0));
        SETINFO(GetProfileIntA("RICHEDIT DEBUG", "INFO", 0));
        SETMEMORY(GetProfileIntA("RICHEDIT DEBUG", "MEMORY", 0));
        SETTRACING(GetProfileIntA("RICHEDIT DEBUG", "TRACE", 0));
        SETTRACEEXT(GetProfileIntA("RICHEDIT DEBUG", "TRACEEXT", 0));
        SETOPT(OPTTRACEDISP, GetProfileIntA("RICHEDIT DEBUG", "TRACEDISP", 0));
        SETOPT(OPTTRACEWRAP, GetProfileIntA("RICHEDIT DEBUG", "TRACEWRAP", 0));
        SETOPT(OPTTRACEEDIT, GetProfileIntA("RICHEDIT DEBUG", "TRACEEDIT", 0));
        SETOPT(OPTTRACETS, GetProfileIntA("RICHEDIT DEBUG", "TRACETS", 0));
        SETOPT(OPTTRACETOM, GetProfileIntA("RICHEDIT DEBUG", "TRACETOM", 0));
        SETOPT(OPTTRACEOLE, GetProfileIntA("RICHEDIT DEBUG", "TRACEOLE", 0));
        SETOPT(OPTTRACEBACK, GetProfileIntA("RICHEDIT DEBUG", "TRACEBACK", 0));
        SETOPT(OPTTRACESEL, GetProfileIntA("RICHEDIT DEBUG", "TRACESEL", 0));
        SETOPT(OPTTRACEHOST, GetProfileIntA("RICHEDIT DEBUG", "TRACEHOST", 0));
        SETOPT(OPTTRACEDTE, GetProfileIntA("RICHEDIT DEBUG", "TRACEDTE", 0));
        SETOPT(OPTTRACEUNDO, GetProfileIntA("RICHEDIT DEBUG", "TRACEUNDO", 0));
        SETOPT(OPTTRACERANG, GetProfileIntA("RICHEDIT DEBUG", "TRACERANG", 0));
        SETOPT(OPTTRACEUTIL, GetProfileIntA("RICHEDIT DEBUG", "TRACEUTIL", 0));
        SETOPT(OPTTRACENOTM, GetProfileIntA("RICHEDIT DEBUG", "TRACENOTM", 0));
        SETOPT(OPTTRACERTFR, GetProfileIntA("RICHEDIT DEBUG", "TRACERTFR", 0));
        SETOPT(OPTTRACERTFW, GetProfileIntA("RICHEDIT DEBUG", "TRACERTFW", 0));
        SETOPT(OPTTRACEPRT, GetProfileIntA("RICHEDIT DEBUG", "TRACEPRT", 0));
        SETOPT(OPTTRACEFE, GetProfileIntA("RICHEDIT DEBUG", "TRACEFE", 0));
        SETOPT(OPTTRACEFONT, GetProfileIntA("RICHEDIT DEBUG", "TRACEFONT", 0));
    }
    else
    {
        //Set up logging before we set dwDebugOptions because
        //SetLogging will not turn logging on if the flag
        //indicates it is already on.
        SETLOGGING(dwOpts & OPTLOGGINGON);
        dwDebugOptions = dwOpts;
    }

    SETASSERTFN(pfnAssertHook);
    SETTRACEFN(pfnTraceHook);
}


/*
 *  AssertProc
 *	
 *  @mfunc
 *      This is the dialog proc for the assert message.
/ *
 *      lParam - The string to display in the dialog.
 *
 */
BOOL CALLBACK AssertProc(HWND hwndDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message)
    {
        case WM_INITDIALOG:
            {
                RECT rcDlg, rcDesk;

                GetWindowRect(hwndDlg, &rcDlg);
                GetWindowRect(GetDesktopWindow(), &rcDesk);

                SetWindowPos(hwndDlg, HWND_TOP,
                ((rcDesk.right - rcDesk.left ) - (rcDlg.right - rcDlg.left))/2,
                ((rcDesk.bottom - rcDesk.top ) - (rcDlg.bottom - rcDlg.top))/2,
                0, 0, SWP_NOSIZE);


                if (NULL != lParam)
                    SetDlgItemTextA(hwndDlg, IDC_MSG, (LPSTR)lParam);

                //Sometimes we don't always end up on top.  I don't know why.
                SetForegroundWindow(hwndDlg);                
            }
            break;

        case WM_COMMAND:
            //Kill dialog and return button id that was pressed.
            EndDialog(hwndDlg, LOWORD(wParam));
            break;

        default:
            return FALSE;
    }
    return TRUE;
}


/*
 *  AssertThread
 *	
 *  @mfunc
 *      This is the entry point for the thread created for the
 *      assert dialog.
 *
 *      lParam - Data passed to thread...not used.
 *
 *  @rdesc
 *      Should not return.  It will be explicitly terminated.
 *
 */
DWORD WINAPI AssertThread(LPVOID lParam)
{
    //This should run until it is explicitly terminated in
    //process detach.
    while(TRUE)
    {
		//We go into a wait state until the event is signaled,
		//which means we are handling an assert.
        WaitForSingleObject(hEventAssert1, INFINITE);
        idAssert = DialogBoxParamA(ghMod, MAKEINTRESOURCEA(IDD_ASSERT),
            NULL, (DLGPROC)AssertProc, (LPARAM)szAssert);
		//The asserting thread will be waiting on this event so
		//set it to allow the asserting thread continue.
        SetEvent(hEventAssert2);
    }

    return 0;
}


char * __cdecl strrchr (
        const char * string,
        int ch
        )
{
        char *start = (char *)string;

        while (*string++)                       /* find end of string */
                ;
                                                /* search towards front */
        while (--string != start && *string != (char)ch)
                ;

        if (*string == (char)ch)                /* char found ? */
                return( (char *)string );

        return(NULL);
}

/*
 *  AssertSzFn
 *	
 *  @mfunc
 *      Display a message for the user and give the
 *      option to abort, ignore, or ignore all.
 *      Selecting ignore all causes all asserts to be
 *      ignored from that time forward.  It cannot be
 *      reset.  If the assert dialog cannot be created
 *      A message box is used.  The message box has one
 *      button (OK) which will cause an abort.
 *
 *      szFile - the file the warning occured in.
 *      iLine - the line number the warning occured at.
 *      szUserMsg - User define message string
 *
 */
void AssertSzFn(LPSTR szUserMsg, LPSTR szFile, int iLine)
{
    char szModuleName[MAX_PATH];
    char * pszModuleName;
    DWORD pid;
    DWORD tid;
    DWORD dwAssertTID;

    //Check to see if an assert hook has been set. If it has, call
    //it with pointers to all our parameters (they can be modified
    //this way if desired).  If the hook returns false, return.
    //Otherwise, continue with our assert with the potentially
    //modified parameters.
    if (NULL != pfnAssert)
        if (!pfnAssert(szUserMsg, szFile, &iLine))
            return;


    if( NULL == hAssertThrd )
    {
        if( NULL != hEventAssert1 && NULL != hEventAssert2)
        {
            hAssertThrd = CreateThread(NULL, 0, AssertThread,
                NULL, 0, &dwAssertTID);
        }
    }

    //This critical section will prevent us from being entered simultaneously
    //by multiple threads.  This alone will not prevent reentrance by our own thread
    //once the assert dialog is up. Under normal circumstances a special thread
    //exists to run the assert dialog and Event objects are used to halt this
    //thread while the assert dialog is up (see WaitForSingleObject
    //further down).  If the assert thread does not exist, a MessageBox is used
    //and we can be reentered (this is a fallback position and there's
    //not much we can do about it).
    EnterCriticalSection(&csAssert);

    pid = GetCurrentProcessId();
    tid = GetCurrentThreadId();

    //Get the module name to include in assert message.
    if (GetModuleFileNameA(NULL, szModuleName, MAX_PATH))
    {
        pszModuleName = strrchr(szModuleName, '\\');
        if (!pszModuleName)
        {
            pszModuleName = szModuleName;
        }
        else
        {
            pszModuleName++;
        }
    }
    else
    {
        pszModuleName = "Unknown";
    }


    //Send a message to the debug output and build a string for the
    //assert dialog.  The string depends on whether the user provided
    //a message.
    if (NULL != szUserMsg)
    {
		TRACEASSERTSZ(szUserMsg, szFile, iLine);
        sprintf(szAssert,
            "PROCESS: %s, PID: %d, TID: %d\nFILE: %s (%d)\n%s\n",
             pszModuleName, pid, tid, szFile, iLine, szUserMsg);
    }
    else
    {
		TRACEASSERT(szFile, iLine);
        sprintf(szAssert,
            "PROCESS: %s, PID: %d, TID: %d\nFILE: %s (%d)\n",
             pszModuleName, pid, tid, szFile, iLine);
    }


    //If the user did not disable asserts on a previous assert,
    //put up a dialog with the assert message.
    if (!fIgnoreAsserts)
    {
        idAssert = -1;

		//If we are in the middle of process detach, the assert thread
		//will not execute so pop the dialog here ourselves.  Presumably there
		//is little change of reentrancy at this point.  If we are not
		//in process detach, let the assert thread handle the assert.
		if (fDllDetach)
		{
            idAssert = DialogBoxParamA(ghMod, MAKEINTRESOURCEA(IDD_ASSERT),
                NULL, (DLGPROC)AssertProc, (LPARAM)szAssert);
		}
        else
        {
            SetEvent(hEventAssert1);
            WaitForSingleObject(hEventAssert2, INFINITE);
        }

        //The assert thread doesn't exist or the dialogbox create failed so
        //use a message box instead.  In this case, since we
        //are obviously having problems, we are only going to
        //give the user one choice...abort.
        if (-1 == idAssert)
        {
            idAssert = MessageBoxA(NULL,
                             szAssert,
                             "Richedit Assert - (retry will be ignored)",
                              MB_SETFOREGROUND | MB_TASKMODAL |
                              MB_ICONEXCLAMATION | MB_ABORTRETRYIGNORE);

            //
            // If id == 0, then an error occurred.  There are two possibilities
            // that can cause the error:  Access Denied, which means that this
            // process does not have access to the default desktop, and everything
            // else (usually out of memory).
            //
            if (!idAssert)
            {
                if (GetLastError() == ERROR_ACCESS_DENIED)
                {
                    //
                    // Retry this one with the SERVICE_NOTIFICATION flag on.  That
                    // should get us to the right desktop.
                    //
                    idAssert = MessageBoxA(   NULL,
                                        szAssert,
                                        "Richedit Assert - (retry will be ignored)",
                                        MB_SETFOREGROUND | MB_TASKMODAL | MB_ICONEXCLAMATION | 
                                        MB_ABORTRETRYIGNORE);

                }
            }
        }

        if (idAssert == ID_IGNOREALL)
        {
            fIgnoreAsserts = TRUE;
        }

        if (idAssert == IDABORT )
        {
            //This will cause a break when debugging, and
            //an exception leading to termination otherwise.
            DebugBreak();
			return;
        }
    }

    LeaveCriticalSection(&csAssert);
}


/*
 *  TabLookup
 *	
 *  @mfunc
 *      This function searches an array of TabElem
 *      structures looking for an entry whose key
 *      matches the one we were given. If found, it
 *      copies the string associated with the key into
 *      the supplied buffer.
 *      
 *      Table - TabElem pointer to start of array.
 *      TabSize - Size of array in bytes.
 *      dwKey - Key to match.
 *      szBuf - Buffer to hold string (assumed MAXDEBUGSTRLEN in size).
 *
 *  @rdesc
 *      FALSE if key not found, TRUE if found.
 *
 */
BOOL TabLookup(TabElem * Table, UINT TabSize, DWORD dwKey, LPSTR szBuf)
{
    BOOL fRet = FALSE;
    UINT cTab, index;
    
    cTab = TabSize/sizeof(TabElem);

    for (index = 0; index < cTab; index++)
    {
        if (Table[index].dwKey == dwKey)
            break;
    }

    if (index < cTab)
    {
        lstrcpyA(szBuf, Table[index].sz);
        fRet = TRUE;
    }

    return fRet;
}

/*
 *  GetHResultSz
 *	
 *  @mfunc
 *      This function fills a buffer with a string associated
 *      with a given HRESULT.  This string can then be used
 *      in the output from TraceMsg.
 *      
 *      hr - HRESULT on which the string will be based.
 *      szBuf - Buffer to hold string (MAXDEBUGSTRLEN in size).
 *
 */
void GetHResultSz(HRESULT hr, LPSTR szBuf)
{
    // Build string based on FormatMessageA
    if (!FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, NULL, (DWORD)hr,
        MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
        szBuf, MAXDEBUGSTRLEN, NULL))
    {
        // Build default string
        sprintf(szBuf, "hr = %d: Unrecognized HRESULT.", hr);
    }
    else
    {
        int cch;
        char * pch;

        //Need to get rid of the CRLF from FormatMessageA.
        pch = szBuf;
        cch = strlen(szBuf);
        pch += (cch - 2);
        *pch = '\0';
    }
}


/*
 *  GetParamSz
 *	
 *  @mfunc
 *      This function fills a buffer with a string associated
 *      with a param from the text message handler.
 *      This string can then be used in the output from
 *      TraceMsg.
 *      
 *      dwParam - param on which the string will be based.
 *      szBuf - Buffer to hold string (MAXDEBUGSTRLEN in size).
 */
void GetParamSz(DWORD dwParam, LPSTR szBuf)
{
    char szTemp[MAXDEBUGSTRLEN];

    if (!TabLookup(TrcParamTab, sizeof(TrcParamTab), (DWORD)dwParam, szTemp))
	{
        sprintf(szBuf, "PARAM = %d: Unrecognized PARAM.", dwParam);
	}
	else
	{
        sprintf(szBuf, "PARAM: %s", szTemp);
	}
}

/*
 *  GetDefaultSz
 *	
 *  @mfunc
 *      This function fills a buffer with a string associated
 *      with either the value from GetLastError, or with a
 *      default string. This string can then be used in the
 *      output from TraceMsg.
 *      
 *      dwError - Value from GetLastError.
 *      szBuf - Buffer to hold string (MAXDEBUGSTRLEN in size).
 *
 */
void GetDefaultSz(DWORD dwError, LPSTR szBuf)
{
    //Check to see if we have an error value
    if (dwError)
    {
        // Build string based on FormatMessageA
        if (!FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM, NULL, dwError,
            MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
            szBuf, MAXDEBUGSTRLEN, NULL))
        {
            // Build default string
            lstrcpyA(szBuf, "Reason unknown.");
        }
        else
        {
            int cch;
            char * pch;

            //Need to get rid of the CRLF from FormatMessageA.
            pch = szBuf;
            cch = strlen(szBuf);
            pch += (cch - 2);
            *pch = '\0';
        }
    }
    else
    {
        // Build default string
        lstrcpyA(szBuf, "Reason unknown.");
    }
}

//The following are not used by the release with asserts build
#ifndef _RELEASE_ASSERTS_

/*
 *  GetDataSz
 *	
 *  @mfunc
 *      This function fills a buffer with a string representing
 *      data passed to TraceMsg in one of it's DWORDS data
 *      parameters. This string can then be used in the
 *      output from TraceMsg.
 *      
 *      uDataType - This is the type of data we are dealing with.
 *      dwData - This is the data itself.
 *      szBuf - Buffer to hold string (MAXDEBUGSTRLEN in size).
 *
 */
void GetDataSz(UINT uDataType, DWORD dwData, LPSTR szBuf)
{
    switch (uDataType)
    {
        // Data is an HRESULT
        case TRCDATAHRESULT:
            GetHResultSz((HRESULT)dwData, szBuf);
            break;

        // Data is a string (copy to szBuf and pass it through)
        case TRCDATASTRING:
            lstrcpyA(szBuf, (LPSTR)(DWORD_PTR)dwData);
            break;

        // Data is a parameter value
        case TRCDATAPARAM:
            GetParamSz(dwData, szBuf);
            break;

        // Get string based on GetLastError
        case TRCDATADEFAULT:
        default:
            GetDefaultSz(dwData, szBuf);
            break;
    }
}


/*
 *  LogDebugString
 *	
 *  @mfunc
 *      This function writes a string to the log file.  The file must
 *      be opened already and hLogFile must contain the handle.
 *      
 *      szDebugMsg - String to write to log file.
 *
 */
void LogDebugString(LPSTR szDebugMsg)
{
    if ((NULL != hLogFile) && (INVALID_HANDLE_VALUE != hLogFile))
    {
        DWORD dwMsgBytes, dwBytes;

        dwMsgBytes = strlen(szDebugMsg)*sizeof(char);

        //Prevent other threads from trying to write at same time.
        EnterCriticalSection(&csLog);
        SetFilePointer(hLogFile, 0, NULL, FILE_END);
        WriteFile (hLogFile, szDebugMsg, dwMsgBytes, &dwBytes, NULL);
        LeaveCriticalSection(&csLog);
    }
}


/*
 *  TraceMsg
 *	
 *  @mfunc
 *      This is the central message generating facility for
 *      the debug tools.  All messages to the debug output
 *      or log file are generated here. This function takes
 *      a DWORD (dwFlags) that consists of packed values that determine
 *      the kind of message to generated.  It takes two DWORD
 *      data parameters that can contain several different
 *      types of data (string, HRESULT, etc.)  These are interpreted
 *      using dwFlags. It also takes the file and line associated with
 *      the point in the source where it was called.
 *      
 *      dwFlags - Packed values tell us how to generate the message.
 *      dwData1 - The first of two data parameters.
 *      dwData2 - The second of two data parameters.
 *      szFile  - File name we were called from.
 *      iLine   - Line number we were called from.
 *
 */
void TraceMsg(DWORD dwFlags, DWORD dwData1, DWORD dwData2,
    LPSTR szFile, int iLine)
{
    //The following three buffers are used to build our message.
    char szTemp[MAXDEBUGSTRLEN];
    char szTemp2[MAXDEBUGSTRLEN];
    char szDebugMsg[MAXDEBUGSTRLEN];
    char* pch;
    int cch;
    TrcFlags trcf; //Used to decode dwFlags
    DWORD pid;
    DWORD tid;
    DWORD dwError;
    int indent, tls;
    
    //Check to see if a Trace hook has been set. If it has, call
    //it with pointers to all our parameters (they can be modified
    //this way if desired).  If the hook returns false, return.
    //Otherwise, continue with our message output with the potentially
    //modified parameters.
    if (NULL != pfnTrace)
        if (!pfnTrace(&dwFlags, &dwData1, &dwData2, szFile, &iLine))
            return;

    trcf.dw = dwFlags;

    //Return if this is an informational message and they are disabled.
    if ((TRCSEVINFO == trcf.fields.uSeverity) && !fInfo)
        return;

     // Call GetLastError now in case we need it later.
    // This way api calls downstream won't disturb the value
    // we need.
    dwError = GetLastError();
    pid = GetCurrentProcessId();
    tid = GetCurrentThreadId();
    szTemp[0] = '\0';
    szTemp2[0] = '\0';
    szDebugMsg[0] = '\0';

    // Handle indentation (TLSindent is set by CTrace)
    tls = (int)(DWORD_PTR)TlsGetValue(TlsIndex);
    indent = (tls < 0 ? 0 : tls);
    memset(szDebugMsg, ' ', 2*indent*sizeof(char));
    szDebugMsg[2*indent] = '\0';

    // Handle severity (Warning, Error, etc.)
    if (TRCSEVNONE != trcf.fields.uSeverity)
    {
        sprintf(szTemp, "%s: ", TrcSeverity[trcf.fields.uSeverity]);
        strcat(szDebugMsg, szTemp);
    }
    
    // Interpret the first data value
    if (TRCDATANONE != trcf.fields.uData1)
    {
        if (TRCDATADEFAULT == trcf.fields.uData1)
            dwData1 = dwError;
        GetDataSz(trcf.fields.uData1, dwData1, szTemp2);
        lstrcpyA(szTemp, szDebugMsg);
        wsprintfA(szDebugMsg, "%s%s ", szTemp, szTemp2);
    }

    // Interpret the second data value.
    if (TRCDATANONE != trcf.fields.uData2)
    {
        if (TRCDATADEFAULT == trcf.fields.uData2)
            dwData2 = dwError;
        GetDataSz(trcf.fields.uData2, dwData2, szTemp2);
        lstrcpyA(szTemp, szDebugMsg);
        wsprintfA(szDebugMsg, "%s%s", szTemp, szTemp2);
    }

    if (fVerbose)
    {
        // Handle scope (Internal/External call)
        if (TRCSCOPENONE != trcf.fields.uScope)
        {
            sprintf(szTemp, "SCOPE: %s ", TrcScope[trcf.fields.uScope]);
            strcat(szDebugMsg, szTemp);
        }

        // Handle subsytem (TOM, ITextServices, etc.)
        if (TRCSUBSYSNONE != trcf.fields.uSubSystem)
        {
            sprintf(szTemp, "SUBSYSTEM: %s ", TrcSubsys[trcf.fields.uSubSystem]);
            strcat(szDebugMsg, szTemp);
        }

        // Handle process ID, thread ID, file and line.
        sprintf(szTemp, "PID: %u TID: %u ", pid, tid);
        strcat(szDebugMsg, szTemp);
    }

    // Up to now there is no real danger of overflowing our buffer since
    // we were dealing with strings of small size.  Now we will be running
    // in to paths and user strings.  We will use _snprintf to concatonate
    // new stuff to our message.  This is not the most effecient way since
    // it involves alot of copying, but it is a fairly simple way to keep
    // adding to our string without having to worry about how much room is
    // left in the buffer.  It will truncate if we go past the end.
    if (NULL != szFile)
    {
        lstrcpyA(szTemp, szDebugMsg);

        if (0 != iLine)
        {
            wsprintfA(szDebugMsg, "%sFILE: %s (%u) ",
                szTemp, szFile, iLine);
        }
        else
        {
            wsprintfA(szDebugMsg, "%sFILE: %s ",
                szTemp, szFile);
        }
    }

    // Append a CRLF to the end of the string (make sure we don't overflow)
    cch = strlen(szDebugMsg);
    pch = szDebugMsg;
    if (cch < (MAXDEBUGSTRLEN - 3))
        pch += cch;
    else
        pch += (MAXDEBUGSTRLEN - 3);

    lstrcpyA(pch, "\r\n");

    if (fLogging)
        LogDebugString(szDebugMsg);

    // Write to debug output.
    OutputDebugStringA(szDebugMsg);
}

/*
 *	Tracef
 *
 *	@mfunc:
 *      The given format string and parameters are used to render a
 *      string into a buffer. This string is passed to TraceMsg.
 *      The severity parameter determines the type of message.  The
 *      following values are valid: TRCSEVWARN, TRCSEVERR, TRCSEVINFO.
 *	
 *	Arguments:
 *      dwSev   Severity of message.
 *		szFmt	Format string for wvsprintf (qqv)
 */
void Tracef(DWORD dwSev, LPSTR szFmt, ...)
{
	va_list	valMarker;
    char rgchTraceTagBuffer[MAXDEBUGSTRLEN];

	//	format out a string
	va_start(valMarker, szFmt);
	wvsprintfA(rgchTraceTagBuffer, szFmt, valMarker);
	va_end(valMarker);

	if (dwSev == TRCSEVERR)
		TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVERR, TRCSCOPENONE,
		    TRCDATASTRING, TRCDATANONE), (DWORD)(DWORD_PTR)(rgchTraceTagBuffer),
		    (DWORD)0, NULL, 0);
	else if (dwSev == TRCSEVWARN)
		TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVWARN, TRCSCOPENONE,
		    TRCDATASTRING, TRCDATANONE), (DWORD)(DWORD_PTR)(rgchTraceTagBuffer),
		    (DWORD)0, NULL, 0);
    else if (dwSev == TRCSEVINFO)
		TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVINFO, TRCSCOPENONE,
		    TRCDATASTRING, TRCDATANONE), (DWORD)(DWORD_PTR)(rgchTraceTagBuffer),
		    (DWORD)0, NULL, 0);
	else if (dwSev == TRCSEVMEM)
		TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVMEM, TRCSCOPENONE,
		    TRCDATASTRING, TRCDATANONE), (DWORD)(DWORD_PTR)(rgchTraceTagBuffer),
		    (DWORD)0, NULL, 0);
	else
		TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVNONE, TRCSCOPENONE,
		    TRCDATASTRING, TRCDATANONE), (DWORD)(DWORD_PTR)(rgchTraceTagBuffer),
		    (DWORD)0, NULL, 0);
}

/*
 *	TraceError
 *
 *	@mfunc:
 *		This function is for compatibility with old debug functionality.
 *      An error message is generated and sent to TraceMsg.
 *	
 */
void TraceError(LPSTR sz, LONG sc)
{
	if (FAILED(sc))
	{
        char rgchTraceTagBuffer[MAXDEBUGSTRLEN];

		wsprintfA(rgchTraceTagBuffer,
				  "%s, error=%ld (%#08lx).", sz, sc, sc);
		TraceMsg(MAKEFLAGS(TRCSUBSYSNONE, TRCSEVERR, TRCSCOPENONE,
		    TRCDATASTRING, TRCDATANONE), (DWORD)(DWORD_PTR)(rgchTraceTagBuffer),
		    (DWORD)0, NULL, 0);
	}
}

/*
 *  CheckTrace
 *	
 *  @mfunc
 *      This function checks to see if tracing should be performed
 *      in a function given the debug options set and the subsystem
 *      the function is in.
 *      ptrcf   - Pointer to TrcFlags structure passed to CTrace.
 *
 *  @rdesc
 *      True if tracing should be performed, false otherwise.
 *
 */
static BOOL CheckTrace(TrcFlags * ptrcf)
{
    DWORD dwOpt;

    //Set dwOpt to the correct value for the subsytem we are
    //in.
    switch (ptrcf->fields.uSubSystem)
    {
        case TRCSUBSYSDISP: dwOpt = OPTTRACEDISP;   break;
        case TRCSUBSYSWRAP: dwOpt = OPTTRACEWRAP;   break;
        case TRCSUBSYSEDIT: dwOpt = OPTTRACEEDIT;   break;
        case TRCSUBSYSTS:   dwOpt = OPTTRACETS;     break;
        case TRCSUBSYSTOM:  dwOpt = OPTTRACETOM;    break;
        case TRCSUBSYSOLE:  dwOpt = OPTTRACEOLE;    break;
        case TRCSUBSYSBACK: dwOpt = OPTTRACEBACK;   break;
        case TRCSUBSYSSEL:  dwOpt = OPTTRACESEL;    break;
        case TRCSUBSYSHOST: dwOpt = OPTTRACEHOST;   break;
        case TRCSUBSYSDTE:  dwOpt = OPTTRACEDTE;    break;
        case TRCSUBSYSUNDO: dwOpt = OPTTRACEUNDO;   break;
        case TRCSUBSYSRANG: dwOpt = OPTTRACERANG;   break;
        case TRCSUBSYSUTIL: dwOpt = OPTTRACEUTIL;   break;
        case TRCSUBSYSNOTM: dwOpt = OPTTRACENOTM;   break;
        case TRCSUBSYSRTFR: dwOpt = OPTTRACERTFR;   break;
        case TRCSUBSYSRTFW: dwOpt = OPTTRACERTFW;   break;
        case TRCSUBSYSPRT:  dwOpt = OPTTRACEPRT;    break;
        case TRCSUBSYSFE:   dwOpt = OPTTRACEFE;     break;
        case TRCSUBSYSFONT: dwOpt = OPTTRACEFONT;   break;
        default:
             return FALSE;
    }

    //If there is no tracing at any level enabled, return false.
    if (!ISOPTSET(dwOpt) && !fTrace
        && !(fTraceExt && (ptrcf->fields.uScope == TRCSCOPEEXTERN)))
        return FALSE;

    return TRUE;
}

/*
 *  CTrace::CTrace
 *	
 *  @mfunc
 *      This constructor is used to generate output about the function
 *      it is called from.  Creating an instance of this class on the
 *      stack at the beginning of a function, will cause a trace message
 *      to be sent to the debug output.  When the function returns, the
 *      destructor will be called automatically and another message
 *      will be sent to the debug output.
 *      This constructor takes several parameters to pass on to
 *      TraceMsg and it also stores certain data for use by the destructor.
 *      
 *      dwFlags - Packed values tell us how to generate the message.
 *      dw1     - The first of two data parameters.  This must be
 *                the name of the function we were called from.
 *      dw2     - The second of two data parameters.  This will be either
 *                unused or it will be a parameter to be interpreted by
 *                TraceMsg.
 *      szFile  - File name we were called from.
 *
 */
CTrace::CTrace(DWORD dwFlags, DWORD dw1, DWORD dw2, LPSTR szFile)
{
    char szFunc[80];
    int tls;

    trcf.dw = dwFlags;

    //Return if tracing is not enabled.
    if (!CheckTrace(&trcf))
        return;

    //Increment indentation level on entrance to function
    tls = (int)(DWORD_PTR)TlsGetValue(TlsIndex);
    tls++;
    TlsSetValue(TlsIndex, (LPVOID)(DWORD_PTR)tls);

    szFunc[0] = '\0';
    lstrcpyA(szFileName, szFile);
    lstrcpyA(szFuncName, (LPSTR)(DWORD_PTR)dw1);

    sprintf(szFunc, "IN : %s.", szFuncName);

    TraceMsg (trcf.dw, (DWORD)(DWORD_PTR)szFunc, dw2, szFileName, 0);
}


/*
 *  CTrace::~CTrace
 *	
 *  @mfunc
 *      This destructor is used to generate output about the function
 *      it is called from.  Creating an instance of this class on the
 *      stack at the beginning of a function, will cause a trace message
 *      to be sent to the debug output.  When the function returns, the
 *      destructor will be called automatically and another message
 *      will be sent to the debug output.
 *
 *
 */
CTrace::~CTrace()
{
    char szFunc[80];
    int tls;

    //Return if tracing is not enabled.
    if (!CheckTrace(&trcf))
        return;

    szFunc[0] = '\0';
    sprintf(szFunc, "OUT: %s.", szFuncName);

    trcf.fields.uData2 = TRCDATANONE;
    TraceMsg (trcf.dw, (DWORD)(DWORD_PTR)szFunc, 0, szFileName, 0);

    //Decrement indentation level on exit from function
    tls = (int)(DWORD_PTR)TlsGetValue(TlsIndex);
    tls--;
    TlsSetValue(TlsIndex, (LPVOID)(DWORD_PTR)tls);
}

#endif //!_RELEASE_ASSERTS_

#endif // !!(DEBUG) && !! _RELEASE_ASSERTS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\dispprt.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module	dispprt.cpp	-- Special logic for printer object |
 *  
 *  Authors:
 *      Original RichEdit code: David R. Fulmer
 *      Christian Fortini
 *      Jon Matousek
 */
#include "_common.h"
#include "_dispprt.h"
#include "_edit.h"
#include "_font.h"
#include "_measure.h"
#include "_render.h"
#include "_select.h"

#define PARA_NUMBER_NOT_SET ((WORD) -1)

ASSERTDATA

/*
 *	CDisplayPrinter::CDisplayPrinter(ped, hdc, x, y, prtcon)
 *
 *	@mfunc
 *		Contructs a object that can be used to print a text control
 */
CDisplayPrinter::CDisplayPrinter (
	CTxtEdit* ped, 
	HDC hdc, 			//@parm HDC for drawing
	LONG x, 			//@parm Max width to draw
	LONG y, 			//@parm Max height to draw
	SPrintControl prtcon//@parm Special controls for this print object
)	
		: CDisplayML( ped ), _prtcon(prtcon)
{
	TRACEBEGIN(TRCSUBSYSPRT, TRCSCOPEINTERN, "CDisplayPrinter::CDisplayPrinter");

	Assert ( hdc );

	_fNoUpdateView = TRUE;
	_xWidthMax  = x;
	_yHeightMax = y;
	_wNumber = PARA_NUMBER_NOT_SET;
}

/*
 *	CDisplayPrinter::SetPrintDimensions(prc)
 *
 *	@mfunc
 *		Set area to print.
 */
void CDisplayPrinter::SetPrintDimensions(
	RECT *prc)			//@parm dimensions of current area to print to.
{
	_xWidthMax  = prc->right - prc->left;
	_yHeightMax = prc->bottom - prc->top;
}

/*
 *	CDisplayPrinter::FormatRange(cpFirst, cpMost)
 *
 *	@mfunc
 *		Format a range of text into this display and used only for printing.
 *
 *	@rdesc
 *		actual end of range position (updated)	
 */
LONG CDisplayPrinter::FormatRange(
	LONG cpFirst, 		//@parm Start of text range
	LONG cpMost,		//@parm End of text range
	BOOL fWidowOrphanControl)	//@parm If TRUE, suppress widow/orphan
{
	TRACEBEGIN(TRCSUBSYSPRT, TRCSCOPEINTERN, "CDisplayPrinter::FormatRange");

	LONG		cch;
	WCHAR		ch;
	BOOL		fFirstInPara = TRUE;
	CLine		liTarget;
	CLine *		pliNew = NULL;
	LONG		yHeightRnd;
	LONG		yHeightTgt;
	BOOL		fBindCp = FALSE;
	const CDevDesc *pdd = GetDdTarget() ? GetDdTarget() : this;

	// Set client height for zooming
	_yHeightClient = this->LYtoDY(_yHeightMax);

	// Set maximum in terms of target DC.
	LONG	yMax = pdd->LYtoDY(_yHeightMax);

	if(cpMost < 0)
		cpMost = _ped->GetTextLength();

	CMeasurer me(this);
	
	cpFirst = me.SetCp(cpFirst);		// Validate cpFirst while setting me
	ch = me.GetChar();

	// TODO: COMPATIBILITY ISSUE:  Richedit 1.0 adjusted to before a
	// CRLF/CRCRLF boundary.  if_ped->fUseCRLF(), adjust accordingly

	if(fBindCp)
	{
		cpFirst = me.GetCp();
		me._rpCF.BindToCp(cpFirst);
		me._rpPF.BindToCp(cpFirst);
	}

	_cpMin = cpFirst;
	_cpFirstVisible = cpFirst;
	
	yHeightTgt = 0;
	yHeightRnd = 0;
	if(me.GetCp())
		fFirstInPara = me._rpTX.IsAfterEOP();

	// Clear line CArray
	Clear(AF_DELETEMEM);

	// Assume that we will break on words
	UINT uiBreakAtWord = MEASURE_BREAKATWORD;

	if(_prtcon._fPrintFromDraw)
	{
		// This is from Draw so we want to take inset into account
		LONG xWidthView = _xWidthMax;

		GetViewDim(xWidthView, yMax);
		_xWidthView = (SHORT) xWidthView;

		// Restore client height
		_yHeightClient = this->LYtoDY(_yHeightMax);
	}
	else			// Message-based printing always does word wrap
		SetWordWrap(TRUE);

	// Set paragraph numbering. This is a fairly difficult problem
	// because printing can start anywhere and end anywhere. However,
	// most printing will involve a contiguous range of pages. Therefore,
	// we cache the paragraph number and the cp for that number and
	// only resort to looking in the line array if the cached information
	// has become invalid.
	if ((PARA_NUMBER_NOT_SET == _wNumber) || (cpFirst != _cpForNumber))
	{
		CLinePtr rp(_ped->_pdp);
		rp.RpSetCp(cpFirst, FALSE);
		_wNumber = rp.GetNumber();
		_cpForNumber = cpFirst;
	}
	
	me.SetNumber(_wNumber);
	
	while(me.GetCp() < cpMost)
	{
		// Add one new line
		pliNew = Add(1, NULL);
		if(!pliNew)
		{
			_ped->GetCallMgr()->SetOutOfMemory();
			goto err;
		}

		// Store the current number of the paragraph. We do it
		// here because we have to measure and that potentially
		// updates the number of the paragraph in the measurer
		// for a line that might not be on the page.
		_wNumber = me.GetNumber();

		// Stuff some text into this new line
		if(!pliNew->Measure(me, cpMost - me.GetCp(), -1,
				uiBreakAtWord | (fFirstInPara ? MEASURE_FIRSTINPARA : 0), 
				&liTarget))
		{
			Assert(FALSE);
			goto err;
		}

		// Note, we always put at least one line on a page. Otherwise, if the 
		// first line is too big, we would cause our client to infinite loop
		// because we would never advance the print cp.
		if(_cel > 1 && (yHeightTgt + liTarget._yHeight > yMax))
		{
			cch = -pliNew->_cch;		// Bump last line to next page
			_cel--;						// One less line

#if 0
			CLine *pli = pliNew - 1;	// Point at previous line

			// If this line and the previous one are in the same para and
			// either this one ends in an EOP or the previous one starts
			// a para, bump both to following page (widow/orphan)
			if(fWidowOrphanControl)
			{
				if(_cel > 1 && !fFirstInPara &&
				   (pli->_bFlags & fliFirstInPara || (pliNew->_bFlags & fliHasEOP)))
				{
					cch -= pli->_cch;
					_cel--;					// One less line
					pli--;					// Point to previous line
				}
				if(_cel > 1 && pli->_nHeading)
				{							// Don't end page with a heading
					cch -= pli->_cch;
					_cel--;					// One less line
				}
			}
#endif
			me.Advance(cch);			// Move back over lines discarded
			break;
		}

		fFirstInPara = (pliNew->_bFlags & fliHasEOP);

		yHeightTgt += liTarget._yHeight;
		yHeightRnd += pliNew->_yHeight;
		if (me.GetPrevChar() == FF)
			break;
	}

	// If there was no text, then add a single blank line
	if(!pliNew)
	{
		pliNew = Add(1, NULL);
		if(!pliNew)
		{
			_ped->GetCallMgr()->SetOutOfMemory();
			goto err;
		}
		me.NewLine(fFirstInPara);
		*pliNew = me._li;
	}

	// Update display height
	_yHeight = yHeightRnd;

	// Update display width
	_xWidth = CalcDisplayWidth();

	cpMost = me.GetCp();
	_cpCalcMax = cpMost;
	_yCalcMax = _yHeight;

	// Update paragraph caching information.
	_cpForNumber = cpMost;

	return cpMost;

err:
	Clear(AF_DELETEMEM);
	_xWidth = 0;
	_yHeight = 0;
	return -1;
}

/*
 *	CDisplayPrinter::GetNaturalSize(hdcDraw, hicTarget, dwMode, pwidth, pheight)
 *
 *	@mfunc
 *		Recalculate display to input width & height for TXTNS_FITTOCONTENT.
 *
 *	@rdesc
 *		S_OK - Call completed successfully <nl>
 *
 *	@devnote
 *		This assumes that FormatRange was called just prior to this.
 */
HRESULT	CDisplayPrinter::GetNaturalSize(
	HDC hdcDraw,		//@parm DC for drawing
	HDC hicTarget,		//@parm DC for information
	DWORD dwMode,		//@parm Type of natural size required
	LONG *pwidth,		//@parm Width in device units to use for fitting 
	LONG *pheight)		//@parm Height in device units to use for fitting
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayPrinter::GetNaturalSize");

	*pwidth = _xWidth;
	*pheight = _yHeight;
	return S_OK;
}

/*
 *	CDisplayPrinter::IsPrinter()
 *
 *	@mfunc
 *		Returns whether this is a printer
 *
 *	@rdesc
 *		TRUE - is a display to a printer
 *		FALSE - is not a display to a printer
 */
BOOL CDisplayPrinter::IsPrinter() const
{
	AssertSz(_hdc, "CDisplayPrinter::IsPrinter no hdc set");
	
	return GetDeviceCaps(_hdc, TECHNOLOGY) == DT_RASPRINTER;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\disp.cpp ===
/*
 *	DISP.CPP
 *	
 *	Purpose:
 *		CDisplay class
 *	
 *	Owner:
 *		Original RichEdit code: David R. Fulmer
 *		Christian Fortini
 *		Murray Sargent
 *		Jon Matousek - smooth scrolling.
 *
 *	Copyright (c) 1995-1998 Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_disp.h"
#include "_edit.h"
#include "_select.h"
#include "_font.h"
#include "_measure.h"
#include "_osdc.h"
#include "_dfreeze.h"

ASSERTDATA

// Decimal point precision of smooth scrolling calculations.
#define SMOOTH_PRECISION (100000L)


// ===========================  Invariant stuff  ======================================================

#define DEBUG_CLASSNAME CDisplay
#include "_invar.h"

#ifdef DEBUG
BOOL
CDisplay::Invariant( void ) const
{
	AssertSz(_yHeightView >= 0, "CDisplay::Invariant invalid _yHeightView");
	AssertSz(_yHeightClient	>= 0, 
		"CDisplay::Invariant invalid _yHeightClient");

	return TRUE;
}
#endif

// Constant used to build the rectangle used for determining if a hit is close
// to the text.
#define HIT_CLOSE_RECT_INC	5


// Auto scroll constants
#define dwAutoScrollUp		1
#define dwAutoScrollDown	2
#define dwAutoScrollLeft	3
#define dwAutoScrollRight	4


// ===========================  CLed  =====================================================


void CLed::SetMax(
	const CDisplay * const pdp)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CLed::SetMax");

	_cpMatchNew	 = _cpMatchOld	= pdp->_ped->GetTextLength();
	_iliMatchNew = _iliMatchOld = max(0, pdp->LineCount() - 1);
	_yMatchNew	 = _yMatchOld	= pdp->GetHeight();
}


// ===========================  CDisplay  =====================================================


DWORD 	CDisplay::_dwTimeScrollNext;	// time for next scroll step
DWORD 	CDisplay::_dwScrollLast;		// last scroll action

/*
 *	CDisplay::ConvertYPosToMax(xPos)
 *
 *	@mfunc	
 *		Calculate real scroll position from scroll position
 *
 *	@rdesc
 *		X position from scroll
 *
 *	@devnote
 *		This routine exists because the thumb position messages
 *		are limited to 16-bits so we extrapolate when the Y position
 *		gets greater than that.
 */
LONG CDisplay::ConvertScrollToXPos(
	LONG xPos)		//@parm Scroll position 
{
	LONG xMax = GetMaxXScroll();

	// Has maximum scroll range exceeded 16-bits?
	if (xMax >= _UI16_MAX)
	{
		// Yes - Extrapolate to the "real" x Positioin
		xPos = MulDiv(xPos, xMax, _UI16_MAX);
	}
	return xPos;
}

/*
 *	CDisplay::ConvertXPosToScrollPos(xPos)
 *
 *	@mfunc	
 *		Calculate scroll position from X position in document.
 *
 *	@rdesc
 *		Scroll position from X position
 *
 *	@devnote
 *		This routine exists because the thumb position messages
 *		are limited to 16-bits so we extrapolate when the Y position
 *		gets greater than that.
 *
 */
LONG CDisplay::ConvertXPosToScrollPos(
	LONG xPos)		//@parm Y position in document
{
	LONG xMax = GetMaxXScroll();

	// Has maximum scroll range exceeded 16-bits?
	if(xMax >= _UI16_MAX)
	{
		// Yes - Extrapolate to the scroll bar position		
		xPos = MulDiv(xPos, _UI16_MAX, xMax);
	}
	return xPos;
}

/*
 *	CDisplay::ConvertYPosToMax(yPos)
 *
 *	@mfunc	
 *		Calculate the real scroll position from the scroll position
 *
 *	@rdesc
 *		Y position from scroll
 *
 *	@devnote
 *		This routine exists because the thumb position messages
 *		are limited to 16-bits so we extrapolate when the Y position
 *		gets greater than that.
 */
LONG CDisplay::ConvertYPosToScrollPos(
	LONG yPos)		//@parm Scroll position 
{
	// Default is single line edit control which cannot have Y-Scroll bars
	return 0;
}

CDisplay::CDisplay (CTxtEdit* ped) :
	CDevDesc (ped)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::CDisplay");

	_TEST_INVARIANT_
	_fRecalcDone = TRUE;
}

CDisplay::~CDisplay()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::~CDisplay");
				 
	_TEST_INVARIANT_
	
	CNotifyMgr *pnm = _ped->GetNotifyMgr();
	if(pnm)
		pnm->Remove(this);

	CheckRemoveSmoothVScroll();

	if (_padc)
		delete _padc;

#ifdef LINESERVICES
	if (g_pols)
		g_pols->DestroyLine(this);
#endif
}

/*
 *	CDisplay::InitFromDisplay(pdp)
 *
 *	@mfunc initialize this display from another display instance.
 *
 *	@comment
 *			copy *only* the members that will remain constant
 *		   	between two different display instances.  Currently, that
 *			is only the view variables and device descriptor info.
 */
void CDisplay::InitFromDisplay(
	const CDisplay *pdp)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::InitFromDisplay");

	_xWidthView		= pdp->_xWidthView;
	_yHeightView	= pdp->_yHeightView;
	_yHeightClient	= pdp->_yHeightClient;

	// Don't save DC; just coordinate information.
	_dxpInch		= pdp->_dxpInch;
	_dypInch		= pdp->_dypInch;

	// If display we are copying from is active display,
	// then this new display is the active display.
	_fActive		= pdp->_fActive;
}

/*
 *	CDisplay::Init()
 *
 *	@mfunc Initializes CDisplay
 *
 *	@rdesc
 *		TRUE iff initialization succeeded
 */
BOOL CDisplay::Init()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::Init");

	CNotifyMgr *pnm = _ped->GetNotifyMgr();
	if(pnm)
		pnm->Add(this);

	return TRUE;
}

/*
 *	CDisplay::GetSelBarInPixels()
 *
 *	@mfunc
 *		Helper that returns size of selection bar in device units.
 *
 *	@rdesc
 *		Size of selection bar (is 0 if none).
 */
LONG CDisplay::GetSelBarInPixels()
{
	return HimetricXtoDX(_ped->TxGetSelectionBarWidth());
}


//================================  Device drivers  ===================================
/*
 *	CDisplay::SetMainTargetDC(hdc, xWidthMax)
 *
 *	@mfunc
 *		Sets a target device for this display and updates view 
 *
 *  Note:
 *      No support for targetDC in the base CDisplay class.
 *
 *	Note:
 *		Target device can't be a metafile (can get char width out of a 
 *		metafile)
 *
 *	@rdesc
 *		TRUE if success
 */
BOOL CDisplay::SetMainTargetDC(
	HDC	 hdc,			//@parm Target DC, NULL for same as rendering device
	LONG xWidthMax)		//@parm Max width of lines (not used if target device is screen)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::SetMainTargetDC");

	_TEST_INVARIANT_

	return TRUE;
}

BOOL CDisplay::SetTargetDC(
	HDC hdc, LONG dxpInch, LONG dypInch)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::SetTargetDC");

	_TEST_INVARIANT_

	return TRUE;
}

/* 
 *	CDisplay::SetDrawInfo(pdi, dwDrawAspect, lindex, pvAspect, ptd, hicTargetDev)
 *
 *	@mfunc
 *		Sets the drawing information into the display
 *
 *	@rdesc	
 *		void - this cannot fail
 *
 *	@devnote
 *		The key point to this routine is that the caller of this routine
 *		is the owner of the memory for the drawing information. It is the
 *		callers responsiblity to call ReleaseDrawInfo to tell the display
 *		that it is done with the drawing information.
 */
void CDisplay::SetDrawInfo(
	CDrawInfo *pdi,		//@parm memory for draw info if there is not one already
	DWORD dwDrawAspect,	//@parm draw aspect
	LONG  lindex,		//@parm currently unused
	void *pvAspect,		//@parm info for drawing optimizations (OCX 96)
	DVTARGETDEVICE *ptd,//@parm information on target device								
	HDC hicTargetDev)	//@parm	target information context
{
	HDC hicTargetToUse = hicTargetDev;
	const CDevDesc *pdd;

	// Set up the target device if we need to use the default
	if ((NULL == hicTargetToUse))
	{
		pdd = GetDdTarget();
		if(pdd)
			hicTargetToUse = pdd->GetDC();	
	}

	if (NULL == _pdi)
	{
		// Draw structure not yet allocated so use the one
		// passed in
		_pdi = pdi;
	}

	// Reset the parameters
	_pdi->Init(
		dwDrawAspect,
		lindex,
		pvAspect,
		ptd,
		hicTargetToUse);
}

/* 
 *	CDisplay::ReleaseDrawInfo ()
 *
 *	@mfunc
 *		Releases drawing information from display
 *
 *	@rdesc	
 *		void - this cannot fail
 *
 *	@devnote
 *		Since the display does not own the memory for the drawing information,
 *		this only NULLs out the pointer in the drawing information pointer. It
 *		is the responsiblity of the caller to free the memory for the drawing
 *		information.
 */
void CDisplay::ReleaseDrawInfo()
{
	if(_pdi && !_pdi->Release())
	{
		// This object is no longer referenced so we toss our reference.
		_pdi = NULL;
	}
}

/* 
 *	CDisplay::GetTargetDev ()
 *
 *	@mfunc
 *		Get the target device if one is available
 *
 *	@rdesc	
 *		Pointer to device description object or NULL if none is available.
 *
 *	@devnote
 *		This uses the draw info if it is available and then the main target DC
 *		if it is available.
 */
const CDevDesc*CDisplay::GetTargetDev() const
{
	const CDevDesc *pdd = NULL;

	if(_pdi && _pdi->GetTargetDD())
		pdd = _pdi->GetTargetDD();

	return pdd ? pdd : GetDdTarget();
}


//================================  Background Recalc  ===================================
/*
 *	CDisplay::StepBackgroundRecalc()
 *
 *	@mfunc
 *		Steps background line recalc (at GetCp()CalcMax position)
 *		Called by timer proc. No effect for base class
 *
 *	??? CF - Should use an idle thread
 */
void CDisplay::StepBackgroundRecalc()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::StepBackgroundRecalc");

	_TEST_INVARIANT_
}

/*
 *	CDisplay::WaitForRecalc(cpMax, yMax)
 *
 *	@mfunc
 *		Ensures that lines are recalced until a specific character
 *		position or ypos. Always TRUE for base CDisplay class.
 *						
 *	@rdesc
 *		TRUE if success
 */
BOOL CDisplay::WaitForRecalc(
	LONG cpMax,		//@parm Position recalc up to (-1 to ignore)
	LONG yMax)		//@parm ypos to recalc up to (-1 to ignore)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::WaitForRecalc");

	_TEST_INVARIANT_

	return TRUE;
}

/*
 *	CDisplay::WaitForRecalcIli(ili)
 *
 *	@mfunc
 *		Returns TRUE if lines were recalc'd up to ili
 *      Always the case for base CDisplay class.
 */
BOOL CDisplay::WaitForRecalcIli(
	LONG ili)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::WaitForRecalcIli");

	_TEST_INVARIANT_

    return TRUE;
}

/*
 *	CDisplay::WaitForRecalcView()
 *
 *	Purpose
 *		Ensure visible lines are completly recalced
 *      Always the case for base CDisplay class
 */
BOOL CDisplay::WaitForRecalcView()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::WaitForRecalcView");

	_TEST_INVARIANT_

	return TRUE;
}


//====================================  Rendering  =======================================
/*
 * 	CDisplay::Draw(hdcDraw, hicTargetDev, prcClient, prcWBounds,
 *				   prcUpdate, pfnContinue, dwContinue)
 *	@mfunc
 *		General drawing method called by IViewObject::Draw() or in
 *		response to WM_PAINT
 *
 *	@rdesc
 *		HRESULT
 */
HRESULT	CDisplay::Draw(
	HDC		hdcDraw,			//@parm	Rendering device context
	HDC		hicTargetDev,		//@parm	Target information context
	LPCRECT	prcClient,			//@parm	Bounding (client) rectangle
	LPCRECT	prcWBounds,			//@parm Clipping rect for metafiles
    LPCRECT prcUpdate,			//@parm	Dirty rect inside prcClient
	BOOL (CALLBACK *pfnContinue)(DWORD),//@parm Callback for interrupting
								//	long display (currently unused)
	DWORD	dwContinue)			//@parm	Param to pass to pfnContinue
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::Draw");

	_TEST_INVARIANT_

	HRESULT hr = S_OK;

	// Store current depth in drawing locally so we can tell
	// whether we need to actually render.
	DWORD dwDepthThisDraw = _pdi->GetDrawDepth();

    RECT rcView, rcClient, rcRender;
	CTxtSelection *psel = _ped->GetSelNC();

    // Get client rect
    if(prcClient)
    	rcClient = *prcClient;
    else
    {
        AssertSz(_ped->_fInPlaceActive, 
        	"CDisplay::GetViewRect() - Not in-place and !prcClient");
        _ped->TxGetClientRect(&rcClient);
    }

	if(!prcWBounds)		// No metafile, so just set rendering DC
	{
		if(!SetDC(hdcDraw))
		{
			hr = E_FAIL;
			goto Cleanup;
		}
	}
	else				// Rendering to a metafile
	{
		//Forms^3 draws using screen resolution, while OLE specifies HIMETRIC
		long dxpInch = GetPed()->fInOurHost() ? 2540 : W32->GetXPerInchScreenDC();
		long dypInch = GetPed()->fInOurHost() ? 2540 : W32->GetYPerInchScreenDC();

		SetWindowOrgEx(hdcDraw, prcWBounds->left, prcWBounds->top, NULL);
		SetWindowExtEx(hdcDraw, prcWBounds->right, prcWBounds->bottom, NULL);

		SetMetafileDC(hdcDraw, dxpInch, dypInch);
	}		

	// Compute view rectangle (rcView) from client rectangle (account for
	// inset and selection bar width)
  	GetViewRect(rcView, &rcClient);

	// If this view is not active and it is not to be recalc'd then
	// we only decide to use it if the size matches and return S_FALSE
	// if it doesn't so the caller can create a new display to use for
	// drawing.
	if(!IsActive() && !_fNeedRecalc)
	{
		if (rcView.right - rcView.left != GetViewWidth() ||
			rcView.bottom - rcView.top != GetViewHeight())
		{
			hr = S_FALSE;
			goto Cleanup;
		}
	}

	// Make sure our client rectangle is set correctly.
	_yHeightClient = rcClient.bottom - rcClient.top;

    // Recalc view 
    // bug fix #5521
    // RecalcView can potentially call RequestResize which would
    // change the client rect.  Send rect down to update the client rect
    if(!RecalcView(rcView, &rcClient))
		goto Cleanup;

	if(dwDepthThisDraw != _pdi->GetDrawDepth())
	{
		// A draw happened recursively to this draw. Therefore,
		// the screen has already been rendered so we don't need
		// to do anything more here.
		goto Cleanup;
	}

    // Compute rect to render
    if(!prcUpdate)						// Update full view
        rcRender = rcClient;			
	else								// Clip rendering to client rect 
	{
        if(!IntersectRect(&rcRender, &rcClient, prcUpdate))
            goto Cleanup;
    }
    
    if(psel)
        psel->ClearCchPending();

    if(IsMain())
        _ped->TxNotify( EN_UPDATE, NULL );

    // Now render
    Render(rcView, rcRender);

	// Update cursor if we need to
	if(_fUpdateCaret)
	{
		// The caret only belongs in an active view with
		// a selection on a control that has the focus
		if (IsActive() && psel && _ped->_fFocus)
		{
			// Update the caret if there is a selection object.
			// Note: we only scroll the caret into view, if
			// it was previously in the view. This avoids having
			// window pop to caret if it is resized and the
			// caret is not in the view.
			psel->UpdateCaret(psel->IsCaretInView());
		}
		_fUpdateCaret = FALSE;
	}

Cleanup:

   	// Reset DC in device descriptor
 	ResetDC();

	return hr;
}	


//====================================  View Recalc  ===================================
/*
 *	CDisplay::UpdateViewRectState(prcClient)
 *
 *	@mfunc	Compares new view to cached and updates the view as well as the
 *	what type of view recalculation needs to occur.
 */
void CDisplay::UpdateViewRectState(
	const RECT *prcClient)	//@parm New client rectangle
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::UpdateViewRectState");

    // Check whether the view rect has changed since last rendering
    // If width has changed, need complete line recalc.
    // If height has changed, recalc all visible and update scrollbars
    if(prcClient->right - prcClient->left != _xWidthView)
    {
        _xWidthView = (SHORT)(prcClient->right - prcClient->left);
        _fViewChanged = TRUE;            
        _fNeedRecalc = TRUE;    // need full recalc
    }

    if(prcClient->bottom - prcClient->top != _yHeightView) 
    {
        _yHeightView = prcClient->bottom - prcClient->top;

		// The height can go negative when there is an inset and
		// the client rect is very small. We just set it to 0 because
		// that is the smallest the view can actually get.
		if (_yHeightView < 0)
			_yHeightView = 0;

        _fViewChanged = TRUE;
    } 
}

/*
 *	CDisplay::ReDrawOnRectChange
 *
 *	@mfunc	Compares new view to cached and updates the display both
 *	internal and visible state appropriately.
 */
void CDisplay::ReDrawOnRectChange( 
	HDC hicTarget,			//@param Target device
	const RECT *prcClient)	//@param New client rectangle
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::ReDrawOnRectChange");

	_TEST_INVARIANT_

    RECT rcView;

	// Convert client rect to our view rect
  	GetViewRect(rcView, prcClient);

	// Update the x and y coordinates of the view based on the client rect
	UpdateViewRectState(&rcView);

	if(_fNeedRecalc || _fViewChanged)
	{
		// The client rect changed in some way so lets update our client
		// rect height for zoom.
		_yHeightClient = prcClient->bottom - prcClient->top;

		// Remeasure but don't update scroll bars now.
		RecalcView(FALSE);

		// Forms does not want the screen to reflect what the user clicked on
		// or moved the cursor to so we oblige them by not updating the screen
		// here but waiting for some future action to do so.
	}
}

/*
 *	CDisplay::RecalcView(rcView)
 *
 *	@mfunc
 *		RecalcView after the view rect changed
 *
 *	@rdesc
 *		TRUE if success
 */
BOOL CDisplay::RecalcView (
	const RECT &rcView, RECT* prcClient)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::RecalcView");

	_TEST_INVARIANT_

	// Update the x and y coordinates of the view based on the client rect
	UpdateViewRectState(&rcView);

	// Ensure lines are recalced
	if(_fNeedRecalc)
	{
		// Display got recalculated so the caret needs to be repositioned.
		_fUpdateCaret = TRUE;
    	return RecalcView(TRUE, prcClient);
	}
	if(_fViewChanged)
	{
		// The scroll bars are up to date so we can turn off the notification.
		_fViewChanged = FALSE;

		// A height change was noticed in UpdateViewRectState so make sure
		// the horizontal scroll bar (if any is correct).
		UpdateScrollBar(SB_VERT);
	}
    return WaitForRecalcView();
}


//====================================  View Update  ===================================

/*
 *	CDisplay::UpdateView()
 *
 *	@mfunc
 *		Fully recalc all lines and update the visible part of the display 
 *		(the "view") on the screen.
 *
 *	Returns:
 *		TRUE if success
 */
BOOL CDisplay::UpdateView()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::UpdateView");

	_TEST_INVARIANT_

	if(_fNoUpdateView)
		return TRUE;

	if(!_ped->_fInPlaceActive)
    {
        // If not active, just invalidate everything
        InvalidateRecalc();
        _ped->TxInvalidateRect(NULL, FALSE);
		_ped->TxUpdateWindow();
        return TRUE;
    }

	if(_ped->_pdp->IsFrozen())
	{
		_ped->_pdp->SetNeedRedisplayOnThaw(TRUE);
		return TRUE;
	}

	// If we get here, we are updating some general characteristic of the
	// display and so we want the cursor updated as well as the general
	// change; otherwise the cursor will land up in the wrong place.
	_fUpdateCaret = TRUE;

	RECT rcView;

	// Get view rectangle
  	GetViewRect(rcView, NULL);
	
	// Update size of view, which could have changed
	UpdateViewRectState(&rcView);

    // From here on we better be in place
    Assert(_ped->_fInPlaceActive);

	if(!CDevDesc::IsValid())
	{
		// Make our device valid
		SetDC(NULL);
	}

    // Recalc everything
    RecalcView(TRUE);

	// Invalidate entire view
	_ped->TxInvalidateRect (NULL, FALSE);
	
	return TRUE;
}

/*
 *	CDisplay::RoundToLine(hdc, width, pheight)
 *
 *	@mfunc
 *		Calculate number of default lines to fit in input height
 *
 *	@rdesc
 *		S_OK - Call completed successfully <nl>
 */
HRESULT CDisplay::RoundToLine(
	HDC hdc, 			//@parm DC for the window
	LONG width,			//@parm in - width of window; out max width
	LONG *pheight)		//@parm in - proposed height; out - actual
{
	CLock lock;					// Uses global (shared) FontCache
	SetDC(hdc);					// Set DC

	// Set height temporarily so zoom factor will work out
	LONG yOrigHeightClient = SetClientHeight((SHORT) *pheight);

	// Use this to adjust for inset height
	LONG yAdjForInset = *pheight;

	// Get rectangle adjusted for insets
	GetViewDim(width, *pheight);

	// Save proposed height
	LONG yProposed = *pheight;

	// Calc inset adjusted height
	yAdjForInset -= yProposed;

	// Get font
	const CCharFormat *pCF = _ped->GetCharFormat(-1);

	Assert(pCF);

	// Get font cache object
	LONG dypInch = MulDiv(GetDeviceCaps(hdc, LOGPIXELSY), GetZoomNumerator(), GetZoomDenominator());

	CCcs *pccs = fc().GetCcs(pCF, dypInch);
	SHORT	yAdjustFE = pccs->AdjustFEHeight(!_ped->fUseUIFont() && _ped->_pdp->IsMultiLine());
	
	// Get height of font
	LONG yHeight = pccs->_yHeight + (yAdjustFE << 1);;

	// All we wanted is the height and we have got it so dump the
	// font cache entry
	pccs->Release();

	// Figure out how many lines fit into the input height
	LONG cLines = yProposed / yHeight;

	// See if we need to round up
	if(yProposed % yHeight || !cLines)
		cLines++;

	// Set height to new value
	*pheight = yHeight * cLines + yAdjForInset;

	// Set client height back to what it was
	SetClientHeight(yOrigHeightClient);

	// Reset the DC
	ResetDC();

	return NOERROR;
}


//=============================  Client and view rectangles  ===========================

/*
 * 	CDisplay::OnClientRectChange(&rcClient)
 *
 *	@mfunc
 *		Update when either the client rectangle changes
 *      >>> Should be called only when in-place active <<<
 */
void CDisplay::OnClientRectChange(
	const RECT &rcClient)	//@parm New client rectangle
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::OnClientRectChange");

	_TEST_INVARIANT_

    RECT rcView;
    
	AssertSz(_ped->_fInPlaceActive, "CDisplay::OnClientRectChange() called when not in-place active");

	// Make sure our client rectangle is set correctly.
	_yHeightClient = rcClient.bottom - rcClient.top;

    // Use view rect change notification
	GetViewRect(rcView);

	// Make sure that we will have a selection object at this point
	_ped->GetSel();

 	// Update when view rectangle changes
	OnViewRectChange(rcView);
}

/*
 * 	CDisplay::OnViewRectChange(&rcView)
 *
 *	@mfunc
 *		Update when either the view rectangle changes
 *  
 *  Arguments:
 *      rcView   new view rectangle, in:
 *               - log units (twips) rel. to top/left of client rect if not in-place
 *               - containing window client coords if in-place active
 */
void CDisplay::OnViewRectChange(
	const RECT &rcView)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::OnViewRectChange");

	_TEST_INVARIANT_

    if(!_ped->_fInPlaceActive)
        // We'll adjust the view rect during next Draw.
        return;

	CTxtSelection *psel = _ped->GetSelNC();
	const BOOL fCaretShowing = psel ? psel->ShowCaret(FALSE) : FALSE;
	const BOOL fCaretInView = fCaretShowing ? psel->IsCaretInView() : FALSE;
    RECT rcV = rcView;
	COleObject *pipo;

	// Factor in selection bar space
	if (_ped->IsSelectionBarRight())
		rcV.right -= GetSelBarInPixels();
	else
		rcV.left += GetSelBarInPixels();

	// Recalc with new view rectangle
    // ??? What if this fails ?
    RecalcView(rcView);
	
	// Repaint window before showing the caret
    _ped->TxInvalidateRect(NULL, FALSE);  // ??? for now, we could be smarter 
	_ped->TxUpdateWindow();

	// Reposition the caret
	if(fCaretShowing)
	{
	    Assert(psel);
		psel->ShowCaret(TRUE);
		psel->UpdateCaret(fCaretInView);
	}

	// FUTURE: since we're now repositioning in place active 
	// objects every time we draw, this call seems to be 
	// superfluous (AndreiB)

	// Tell object subsystem to reposition any in place objects
	if( _ped->HasObjects() )
	{
		pipo = _ped->GetObjectMgr()->GetInPlaceActiveObject();
		if(pipo)
			pipo->OnReposition( 0, 0 );
	}
}

/*
 * 	CDisplay::RequestResize()
 *
 *	@mfunc
 *		Forces the control to resize vertically so that all text fit into it
 *
 *	@rdesc
 *		HRESULT = (autosize) ? TxNotify(EN_REQUESTRESIZE, &resize) : S_OK
 */
HRESULT CDisplay::RequestResize()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::RequestResize");

	_TEST_INVARIANT_

	if(_ped->TxGetAutoSize())
	{
		REQRESIZE resize;

		// If word wrapping is on, then the width is the normal
		// client width.  Otherwise, it's the width of the longest
		// line plus the width of the caret.
		DWORD width = GetWordWrap() ? _xWidthView : GetWidth() + dxCaret;

		// Get view inset for adjusting width
	 	RECT rcInset;
		_ped->TxGetViewInset(&rcInset, this);
		
		resize.nmhdr.hwndFrom = NULL;
		resize.nmhdr.idFrom = NULL;
		resize.nmhdr.code = EN_REQUESTRESIZE;

		resize.rc.top = 0;
		resize.rc.left = 0;
		resize.rc.bottom = GetResizeHeight();

		// 1.0 COMPATABILITY
        // 1.0 included the borders when requesting resize
        if (_ped->Get10Mode())
        {
            AssertSz(_ped->fInplaceActive(), "In 1.0 mode but not inplace active!!");
            HWND hwnd = NULL;
            _ped->TxGetWindow(&hwnd);
            if (hwnd)
            {
                RECT rcClient, rcWindow;
                _ped->TxGetClientRect(&rcClient);                
                GetWindowRect(hwnd, &rcWindow);
                width = rcClient.right;
                resize.rc.bottom += max(rcWindow.bottom - rcWindow.top - rcClient.bottom, 0);
				resize.rc.bottom += rcInset.bottom + rcInset.top;
				resize.rc.right = rcWindow.right - rcWindow.left;
			} 			
			else 
				resize.rc.right = width;
        }
		else
		{
			// Adjust width by inset and selection bar 
			resize.rc.right = width + rcInset.left + rcInset.right
				+ GetSelBarInPixels();	
		}
  
  		return _ped->TxNotify(EN_REQUESTRESIZE, &resize);
	}
	return S_OK;
}

/*
 *	CDisplay::GetViewRect(RECT &rcView, LPCRECT prcClient)
 *
 *	@mfunc
 *		Compute and return the view rectangle in window's client 
 *      area coordinates.
 *
 *	@comm
 *      prcClient is client rect (in window's client coords), which can be
 *		NULL if we are in-place.
 */
void CDisplay::GetViewRect(
	RECT &	rcView,		//@parm Reference to rect to return
	LPCRECT prcClient)	//@parm Client rect (in window's client coords)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::GetViewRect");

	_TEST_INVARIANT_

    RECT rcInset;
    
    // If client rect wasn't passed in, get it from host
    if(prcClient)
        rcView = *prcClient;
    else
    {
        AssertSz(_ped->_fInPlaceActive,
			"CDisplay::GetViewRect() - Not in-place and !prcClient");
        _ped->TxGetClientRect(&rcView);
    }

	// Make sure height is set
	_yHeightClient = rcView.bottom - rcView.top;
    
    // Ask host for view inset and convert to device coordinates
    _ped->TxGetViewInset(&rcInset, this);
    
    rcView.left	  += rcInset.left;			// Add in inset offsets
    rcView.top	  += rcInset.top;			// rcView is in device coords
    rcView.right  -= rcInset.right;
    rcView.bottom -= rcInset.bottom;

	// Add in selection bar space
	if (_ped->IsSelectionBarRight())
		rcView.right -= GetSelBarInPixels();
	else
		rcView.left += GetSelBarInPixels();
}


//===============================  Scrolling  ==============================

/*
 *	CDisplay::VScroll(wCode, yPos)
 *
 *	@mfunc
 *		Scroll the view vertically in response to a scrollbar event
 *      >>> Should be called when in-place active only <<<
 *
 *  Note:
 *      No support for vertical scroll in base CDisplay. No action.
 *
 *	@rdesc
 *		LRESULT formatted for WM_VSCROLL message		
 */
LRESULT CDisplay::VScroll(
	WORD wCode,	   //@parm Scrollbar event code
	LONG yPos)	   //@parm Thumb position (yPos < 0 for EM_SCROLL behavior)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::VScroll");

	_TEST_INVARIANT_

    return 0;
}

/*
 *	CDisplay::HScroll(wCode, xPos)
 *
 *	@mfunc
 *		Scroll view horizontally in response to a scrollbar event
 *      >>> Should be called when in-place active only <<<
 */
void CDisplay::HScroll(
	WORD wCode,	   //@parm Scrollbar event code
	LONG xPos)	   //@parm Thumb position 
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::HScroll");

	_TEST_INVARIANT_

	BOOL fTracking = FALSE;
	LONG xScroll = _xScroll;

	if (xPos != 0)
	{
		// Convert x position from scroll bar to offset horizontally
		// in the document.
		xPos = ConvertScrollToXPos(xPos);
	}
    
    AssertSz(_ped->_fInPlaceActive, "CDisplay::HScroll() called when not in place");

	switch(wCode)
	{
	case SB_BOTTOM:
		xScroll = GetWidth();
		break;

	case SB_LINEDOWN:
		// Future: Make this depend on a the current first visible character
		xScroll += GetXWidthSys();
		break;

	case SB_LINEUP:
		// Future: Make this depend on a the current first visible character
		xScroll -= GetXWidthSys();
		break;

	case SB_PAGEDOWN:
		xScroll += _xWidthView;
		break;

	case SB_PAGEUP:
		xScroll -= _xWidthView;
		break;

	case SB_THUMBTRACK:
	case SB_THUMBPOSITION:
		if(xPos < 0)
			return;
		xScroll = xPos;
		fTracking = TRUE;
		break;

	case SB_TOP:
		xScroll = 0;
		break;

	case SB_ENDSCROLL:
		UpdateScrollBar(SB_HORZ);
		return;

	default:
		return;
	}

	if (xScroll < 0)
	{
		// xScroll is the new proposed scrolling position and
		// therefore cannot be less than 0.
		xScroll = 0;
	}

	ScrollView(xScroll, -1, fTracking, FALSE);

	// force position update if we just finished a track
	if(wCode == SB_THUMBPOSITION)
		UpdateScrollBar(SB_HORZ);
}


/*
 *	CDisplayML::SmoothVScroll ( int direction, WORD cLines,
 *								int speedNum, int speedDenom, BOOL fAdditive )
 *
 *	@mfunc
 *		Setup to handle fractional scrolls, at a particular speed. This was
 *		probably initiated via a Magellan mouse roller movement, or a MButton
 *		down message.
 */
void CDisplay::SmoothVScroll ( int direction, WORD cLines, int speedNum, int speedDenom, BOOL fMouseRoller )
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CDisplay::SmoothVScroll");

	int yDelta;
	int cLinesAndDir;

	int	smoothYDelta;

	Assert ( speedDenom );

	if ( IsVScrollEnabled() )						// Can scroll vertically?
	{
		_fFinishSmoothVScroll = FALSE;				// We're smoothing again.

													// Get total pixels.
		if ( CheckInstallSmoothVScroll() )			// Install periodic update
		{
			_totalSmoothVScroll		= 0;
			_nextSmoothVScroll		= 0;
		}
													// Pixels per epoch
		cLinesAndDir = (direction < 0) ? cLines : -cLines;

		if( cLines )
		{
			yDelta = CalcYLineScrollDelta ( cLinesAndDir, FALSE );
		}
		else
		{
			yDelta = (direction < 0 ) ? _yHeightClient : -_yHeightClient;
			cLines = 1;		// for the MulDiv calculation below.
		}

		if ( yDelta )								// If something to scroll.
		{
			smoothYDelta = MulDiv( SMOOTH_PRECISION,// NB-Because no FLOAT type
								MulDiv(yDelta, speedNum, speedDenom), cLines);

			_smoothYDelta				= smoothYDelta;
			if ( fMouseRoller )						// roller event.
			{										//  -> additive.
				_totalSmoothVScroll		+= yDelta;
				_continuedSmoothYDelta	= 0;
				_continuedSmoothVScroll	= 0;
			}										// mButton event
			else
			{
				if ( 0 == _totalSmoothVScroll )
					_totalSmoothVScroll		= yDelta;

				_continuedSmoothYDelta	= smoothYDelta;
				_continuedSmoothVScroll	= yDelta;	
			}
		}
	}
}

/*
 *	CDisplay::SmoothVScrollUpdate()
 *
 *	@mfunc
 *		Supports SmoothVScroll. Scroll a small number of pixels.
 *		We are called via a periodic timing task.
 */
void CDisplay::SmoothVScrollUpdate()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CDisplay::SmoothVScrollUpdate");

	LONG	yDelta;									//  Magellan mouse.
	BOOL	fImmediateUpdate = FALSE;
	
	_nextSmoothVScroll += _smoothYDelta;
													// Remove fractional amt.
	yDelta = _nextSmoothVScroll / SMOOTH_PRECISION;

													// Don't overshoot.
	if ( 0 == _continuedSmoothVScroll
		&& (	(_totalSmoothVScroll <= 0 && yDelta < _totalSmoothVScroll)
			||	(_totalSmoothVScroll >= 0 && yDelta > _totalSmoothVScroll)) )
	{
		yDelta = _totalSmoothVScroll;
	}
											 
	if ( yDelta )									// Scroll yDelta, the
	{												//  integral amount.
		_totalSmoothVScroll -= yDelta;
		_nextSmoothVScroll -= yDelta * SMOOTH_PRECISION;
		FractionalScrollView( yDelta );
	}
	else if ( 0 == _totalSmoothVScroll )			// Starting to wind down?
	{
		 _nextSmoothVScroll -= _smoothYDelta;
		 fImmediateUpdate = TRUE;
	}
													// Finished scrolling?
	if ( (yDelta <= 0 && _totalSmoothVScroll >= 0) || (yDelta >= 0 && _totalSmoothVScroll <= 0 ) )
	{
		LONG cLinesAndDir;

		if ( _continuedSmoothYDelta )				// mButton continuation.
		{
			_smoothYDelta = _continuedSmoothYDelta;
			_totalSmoothVScroll += _continuedSmoothVScroll;
		}
		else
		{
			if ( _continuedSmoothVScroll )
			{
				_fFinishSmoothVScroll	= TRUE;		// Winding down scroll.     
				_continuedSmoothVScroll = 0;		
													// Last line's remainder... 
				cLinesAndDir = _smoothYDelta < 0 ? -1 : 1;
				_totalSmoothVScroll = CalcYLineScrollDelta ( cLinesAndDir, TRUE );

													// check for line boundry.
				if ( _totalSmoothVScroll
					==	CalcYLineScrollDelta ( cLinesAndDir, FALSE ) )
				{
					_totalSmoothVScroll = 0;
				}

				if ( fImmediateUpdate )				// do 'this' epochs scroll.
					SmoothVScrollUpdate();
			}
			else
			{
				CheckRemoveSmoothVScroll();			// All done, remove timer.
			}
		}
	}
}

/*
 *	CDisplay::FinishSmoothVScroll
 *
 *	@mfunc
 *		Cause smooth scroll to finish off the last fractional lines worth of
 *		scrolling and then stop.
 */
VOID CDisplay::FinishSmoothVScroll( )
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CDisplay::FinishSmoothVScroll");

													// any non-zero value.

	if ( !_fFinishSmoothVScroll && _totalSmoothVScroll )
	{
		_fFinishSmoothVScroll	= TRUE;
		_continuedSmoothVScroll = 1;					
		_continuedSmoothYDelta	= 0;				// So smooth scroll stops.
		_totalSmoothVScroll		= 0;
	}
}

/*
 *	CTxtEdit::CheckInstallSmoothScroll()
 *
 *	@mfunc
 *		Install a new smooth scroll timer if not already scrolling.
 */
BOOL CDisplay::CheckInstallSmoothVScroll()
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CDisplay::CheckInstallSmoothVScroll");

	_TEST_INVARIANT_
	
	BOOL	fJustInstalled = FALSE;

	if(!_fSmoothVScroll && _ped->TxSetTimer(RETID_SMOOTHSCROLL, 25))
	{
		_fSmoothVScroll = TRUE;
		fJustInstalled = TRUE;
	}

	return fJustInstalled;
}

/*
 *	CTxtEdit::CheckRemoveSmoothVScroll ( )
 *
 *	@mfunc
 *		Finish smooth scroll. If not a forced stop, then check
 *		to see if smooth scrolling should continue, and if so, setup
 *		to continue smooth scrolling.
 */
VOID CDisplay::CheckRemoveSmoothVScroll ( )
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CDisplay::CheckRemoveSmoothVScroll");

	_TEST_INVARIANT_

	if(	_fSmoothVScroll )
	{
		ScrollToLineStart( _continuedSmoothVScroll );	// Ensure stopped on a line.

		_ped->TxKillTimer(RETID_SMOOTHSCROLL);
		_fSmoothVScroll = FALSE;
	}
}

/*
 *	CDisplay::LineScroll(cli, cch)
 *
 *	@mfunc
 *		Scroll the view horizontally in response to a scrollbar event
 *
 *  Note:
 *      No support for vertical scroll in base CDisplay. No action.
 */
void CDisplay::LineScroll(
	LONG cli,	//@parm Count of lines to scroll vertically
	LONG cch)	//@parm Count of chars to scroll horizontally
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::LineScroll");

	_TEST_INVARIANT_

    return;
}

void CDisplay::FractionalScrollView (
	LONG yDelta )
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::FractionalScrollView");

	_TEST_INVARIANT_

    return;
}

VOID CDisplay::ScrollToLineStart ( LONG iDirection )
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::ScrollToLineStart");

	_TEST_INVARIANT_

    return;
}

LONG CDisplay::CalcYLineScrollDelta ( LONG cli, BOOL fFractionalFirst )
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::CalcYLineScrollDelta");

	_TEST_INVARIANT_

    return 0;
}

/*
 *	CDisplay::DragScroll(ppt)
 *
 *	@mfunc
 *		Auto scroll when dragging the mouse out of the visible view
 *
 *	Arguments:
 *		ppt 	mouse position (in client coordinates)
 */
BOOL CDisplay::DragScroll(const POINT * ppt)	
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::DragScroll");

	_TEST_INVARIANT_

	const DWORD dwTime = GetTickCount();
	BOOL fScrolled = FALSE;
	DWORD dwScroll = 0;
	RECT rc;
    int nScrollInset;

    AssertSz(_ped->_fInPlaceActive, "CDisplay::DragScroll() called when not in-place");

    GetViewRect(rc);
    nScrollInset = (int)W32->GetScrollInset();
	InflateRect(&rc, - nScrollInset, - nScrollInset);

	if(_fVScrollEnabled && (_ped->TxGetScrollBars() & ES_AUTOVSCROLL))
	{
    	const yScroll = ConvertYPosToScrollPos(GetYScroll());

		if(ppt->y <= rc.top)
		{
			dwScroll = dwAutoScrollUp;
		}
		else if(ppt->y > rc.bottom) 
		{
			LONG yMax = GetScrollRange(SB_VERT);
			if(yScroll < yMax)
				dwScroll = dwAutoScrollDown;
		}
	}
	
	if(!dwScroll && _fHScrollEnabled && (_ped->TxGetScrollBars() & ES_AUTOHSCROLL))
	{
    	const xScroll = ConvertXPosToScrollPos(GetXScroll());

		if((ppt->x <= rc.left) && (xScroll > 0))
		{
			dwScroll = dwAutoScrollLeft;
		}
		else if(ppt->x > rc.right) 
		{
			LONG xMax = GetScrollRange(SB_HORZ);
			if(xScroll < xMax)
    			dwScroll = dwAutoScrollRight;
		}
	}

	if(dwScroll)
	{
		if(_dwScrollLast != dwScroll)
		{
			// entered or moved to a different auto scroll area
			// reset delay counter
			TRACEINFOSZ("enter auto scroll area");
			_dwTimeScrollNext = dwTime + cmsecScrollDelay;
		}
		else if(dwTime >= _dwTimeScrollNext)
		{
			WORD wScrollCode = SB_LINEDOWN;

			switch(dwScroll)
			{
			case dwAutoScrollUp:
				wScrollCode = SB_LINEUP;
				// fall through to dwAutoScrollDown
			case dwAutoScrollDown:
				// OnVScroll() doesn't scroll enough for our desires
				VScroll(wScrollCode, 0);
				VScroll(wScrollCode, 0);
				break;

			case dwAutoScrollLeft:
				wScrollCode = SB_LINEUP;
				// fall through to dwAutoScrollRight
			case dwAutoScrollRight:
				// HScroll() doesn't scroll enough for our desires
				HScroll(wScrollCode, 0);
				HScroll(wScrollCode, 0);
				HScroll(wScrollCode, 0);
				HScroll(wScrollCode, 0);
				break;
#ifdef DEBUG
			default:
				Tracef(TRCSEVWARN, "Unexpected dwScroll %lx", dwScroll);
				TRACEERRSZSC("Unexpected dwScroll", E_INVALIDARG);
				break;
#endif
			}
			// reset interval counter
			_dwTimeScrollNext = dwTime + cmsecScrollInterval;
			fScrolled = TRUE;
		}
	}
#ifdef DEBUG
	else if(_dwScrollLast)
		TRACEINFOSZ("moved out of auto scroll area");
#endif
	_dwScrollLast = dwScroll;

	return fScrolled;
}

/*
 *	CDisplay::AutoScroll(pt, xScrollInset, yScrollInset)
 *
 *	@mfunc:
 *		Given the current point, determine whether we need to
 *		scroll the client area.
 *
 *	Requires:
 *		This function should only be called during a drag drop
 *		operation.
 *
 *	@rdesc
 *		True if we are in the drag scrolling hot zone, false otherwise.
 *
 */
#define ScrollUp	0x0001	//These eight macros indicate the areas
#define ScrollDown	0x0010	//of the drag scrolling hot zone that tell
#define ScrollLeft	0x0100	//which direction to scroll.
#define ScrollRight 0x1000	//The last four are ambiguous (the corners)
#define ScrollUL	0x0101	//and require a little extra work.
#define ScrollUR	0x1001
#define ScrollDL	0x0110
#define ScrollDR	0x1010

BOOL CDisplay::AutoScroll(
	POINT pt,				 //@parm Cursor location in client coordinates
	const WORD xScrollInset,
	const WORD yScrollInset)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDisplay::AutoScroll");

	static DWORD hotticks = 0;			//Ticks when we entered hot zone.
	static DWORD lastscrollticks = 0;	//Ticks when we last scroll.
	static DWORD lastticks = 0;			//Ticks when last called.
	DWORD delta;						//Ticks since last called.
	DWORD ticks;						//GetTickCount ticks.
	RECT rcClient;						//Client rect of control.
	WORD wScrollDir = 0;				//Scroll direction.
	BOOL fScroll = FALSE;				//TRUE if we should try to scroll this time.
    BOOL fEnabled = FALSE;              //TRUE if scrolling is possible

	//Get the current ticks and calculate ticks since last called.
	//Note that if _drags does not have valid data this will be a
	//bogus value, but that is handled later.
	ticks = GetTickCount();
	delta = ticks - lastticks;
	lastticks = ticks;

	//Don't do anything if no ticks since last time we were called.
	if (delta)
	{
		// Get our client rect.
		_ped->TxGetClientRect(&rcClient);

		//Find out if we are in the hot zone.
		//Note that if we are in one of the corners
		//we will indicate two scrolling directions.
		//This ambiguity will be sorted out later.
		//For now we just want to know if we are in
		//the zone.
		if (pt.x <= (LONG)(rcClient.left + xScrollInset))
			wScrollDir |= (WORD)ScrollLeft;
		else if (pt.x >= (LONG)(rcClient.right - xScrollInset))
			wScrollDir |= (WORD)ScrollRight;

		if (pt.y <= (LONG)(rcClient.top + yScrollInset))
			wScrollDir |= (WORD)ScrollUp;
		else if (pt.y >= (LONG)(rcClient.bottom - yScrollInset))
			wScrollDir |= (WORD)ScrollDown;
			
		//If we are somewhere in the hot zone.
		if (wScrollDir)
		{
			//If we just entered hotzone remember the current ticks.
			if (!hotticks)
				hotticks = ticks;

			//If we have been in the hot zone long enough, and
			//the required interval since the last scroll has elapsed
			//allow another scroll. Note that if we haven't scrolled yet,
			//lastscrollticks will be zero so the delta is virtually
			//guaranteed to be greater than ScrollInterval.
			if ((ticks - hotticks) >= (DWORD)W32->GetScrollDelay() &&
			    (ticks - lastscrollticks) >= (DWORD)W32->GetScrollInterval())
				fScroll = TRUE;

    		//If we are in one of the corners, we scroll
    		//in the direction of the edge we are closest
    		//to.
    		switch (wScrollDir)
    		{
    			case ScrollUL:
    			{
    				if ((pt.y - rcClient.top) <= (pt.x - rcClient.left))
    					wScrollDir = ScrollUp;
    				else
    					wScrollDir = ScrollLeft;
    				break;
    			}
    			case ScrollUR:
    			{
    				if ((pt.y - rcClient.top) <= (rcClient.right - pt.x))
    					wScrollDir = ScrollUp;
    				else
    					wScrollDir = ScrollRight;
    				break;
    			}
    			case ScrollDL:
    			{
    				if ((rcClient.bottom - pt.y) <= (pt.x - rcClient.left))
    					wScrollDir = ScrollDown;
    				else
    					wScrollDir = ScrollLeft;
    				break;
    			}
    			case ScrollDR:
    			{
    				if ((rcClient.bottom - pt.y) <= (rcClient.right - pt.x))
    					wScrollDir = ScrollDown;
    				else
    					wScrollDir = ScrollRight;
    				break;
    			}
    		}
		}
		else
		{
			//We aren't in the hot zone so reset hotticks as a
			//flag so we know the first time we reenter it.
			hotticks = 0;
		}

        //Do processing for horizontal scrolling if necessary
		if (wScrollDir == ScrollLeft || wScrollDir == ScrollRight)
		{
            LONG xRange, xScroll, dx;

            xScroll = ConvertXPosToScrollPos(GetXScroll());
            xRange = GetScrollRange(SB_HORZ);
			dx = W32->GetScrollHAmount();

            fEnabled = IsHScrollEnabled();
            if (wScrollDir == ScrollLeft)
            {
                fEnabled = fEnabled && (xScroll > 0);
               	xScroll -= dx;
                xScroll = max(xScroll, 0);
            }
            else
            {
                fEnabled = fEnabled && (xScroll < xRange);
				xScroll += dx;
                xScroll = min(xScroll, xRange);
            }

            //Do the actual scrolling if necessary.
			if (fEnabled && fScroll)
			{
                HScroll(SB_THUMBPOSITION, xScroll);
				lastscrollticks = ticks;
			}
		}
        //Do processing for Vertical scrolling if necessary
        else if (wScrollDir == ScrollUp || wScrollDir == ScrollDown)
		{
            LONG yRange, yScroll, dy;

            yScroll = ConvertYPosToScrollPos(GetYScroll());
            yRange = GetScrollRange(SB_VERT);
    		dy = W32->GetScrollVAmount();
	
            fEnabled = IsVScrollEnabled();
            if (wScrollDir == ScrollUp)
            {
                fEnabled = fEnabled && (yScroll > 0);
                yScroll -= dy;
                yScroll = max(yScroll, 0);
            }
            else
            {
                fEnabled = fEnabled && (yScroll < yRange);
    			yScroll += dy;
                yScroll = min(yScroll, yRange);
            }

	        //Do the actual scrolling if necessary.
    		if (fEnabled && fScroll)
			{
				// We need to scroll fractionally because the scroll logic tries
				// to put a full line on the top and if the scroll amount is less
				// than a full line, the scrolling will get stuck on that line.
				ScrollView(_xScroll, yScroll, FALSE, TRUE);
				lastscrollticks = ticks;
			}
		}
	}

	return fEnabled;
}

/*
 *	CDisplay::AdjustToDisplayLastLine(yBase, yScroll)
 *
 *	@mfunc
 *		Calculate the yscroll necessary to get the last line to display
 *
 *	@rdesc
 *		Updated yScroll
 *
 *	@devnote:
 *		This method is only really useful for ML displays. This method
 *		here is a placeholder which does nothing which is useful for
 *		all other displays.
 */
LONG CDisplay::AdjustToDisplayLastLine(
	LONG yBase,			//@parm Actual yScroll to display
	LONG yScroll)		//@parm Proposed amount to scroll
{
	return yScroll;
}

/*
 *	CDisplay::GetScrollRange(nBar)
 *
 *	@mfunc
 *		Returns the max part of a scrollbar range
 *      No scrollbar support in the base class: returns 0.
 *
 *	@rdesc
 *		LONG max part of scrollbar range
 */
LONG CDisplay::GetScrollRange(
	INT nBar) const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::GetScrollRange");

	_TEST_INVARIANT_

    return 0;
}

/*
 *	CDisplay::UpdateScrollBar(nBar, fUpdateRange)
 *
 *	@mfunc
 *		Update either the horizontal or vertial scroll bar
 *		Also figure whether the scroll bar should be visible or not
 *      No scrollbar support in the base class: no action.
 *
 *	@rdesc
 *		BOOL
 */
BOOL CDisplay::UpdateScrollBar(
	INT	 nBar,
	BOOL fUpdateRange)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::UpdateScrollBar");

	_TEST_INVARIANT_

	return TRUE;
}

/*
 *	CDisplay::GetZoomDenominator()
 *
 *	@mfunc
 *		Get zoom denominator  
 *
 *	@rdesc
 *		Returns zoom denominator
 *
 *	@devnote:
 *		FUTURE: (Ricksa) we should investigate how to cache this data since
 *				the display needs to keep a temporary zoom denominator anyway.
 */
LONG CDisplay::GetZoomDenominator() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::GetZoomDenominator");

	if(_ped->GetZoomDenominator())				// Simple EM_SETZOOM API
		return _ped->GetZoomDenominator();		//  supercedes complicated
												//  Forms^3 API
	// Default zoom to error case. The error case is a very low
	// probability event that we can do nothing to recover. So we 
	// just set the value to something reasonable and continue.
	LONG lZoomDenominator = _yHeightClient;

	// Is temporary zoom denominator set?
	if(INVALID_ZOOM_DENOMINATOR == _lTempZoomDenominator)
	{
		// No - Get extent size from host
		SIZEL sizelExtent;
		if(SUCCEEDED(_ped->TxGetExtent(&sizelExtent)))
		{
			// Convert height to device units. Note that by definition, we
			// can ignore horizontal extents so we do. Use CDevDesc conversion
			// to avoid infinite recursion
			lZoomDenominator = CDevDesc::HimetricYtoDY(sizelExtent.cy);
		}
	}
	else	// Temporary zoom denominator is set: use it
		lZoomDenominator = CDevDesc::HimetricYtoDY(_lTempZoomDenominator);

	return lZoomDenominator > 0 ? lZoomDenominator : 1;
}

/*
 *	CDisplay::GetZoomNumerator()
 *
 *	@mfunc
 *		Get zoom numerator  
 *
 *	@rdesc
 *		Returns zoom numerator
 */
LONG CDisplay::GetZoomNumerator() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::GetZoomNumerator");

	if(_ped->GetZoomNumerator())				// Simple EM_SETZOOM API
		return _ped->GetZoomNumerator();		//  supercedes complicated
												//  Forms^3 API
	return _yHeightClient > 0 ? _yHeightClient : 1;
}

/*
 *	CDisplay::Zoom(x)
 *
 *	@mfunc
 *		Get zoomed x  
 *
 *	@rdesc
 *		Returns zoomed x
 */
// REVIEW (keithcu) Why does Zoom do anything when we are in print preview?
LONG CDisplay::Zoom(LONG x) const
{
	return MulDiv(x, GetZoomNumerator(), GetZoomDenominator());
}

/*
 *	CDisplay::UnZoom(x)
 *
 *	@mfunc
 *		Get unzoomed x  
 *
 *	@rdesc
 *		Returns unzoomed x
 */
LONG CDisplay::UnZoom(LONG x) const
{
	return MulDiv(x, GetZoomDenominator(), GetZoomNumerator());
}

/*
 *	CDisplay::HimetricXtoDX(xHimetric)
 *
 *	@mfunc
 *		Get device x coordinate corresponding to Himetric x coordinate  
 *
 *	@rdesc
 *		Returns device coordinate
 */
LONG CDisplay::HimetricXtoDX(
	LONG xHimetric) const
{
	return CDevDesc::HimetricXtoDX(Zoom(xHimetric));
}

/*
 *	CDisplay::HimetricYtoDY(yHimetric)
 *
 *	@mfunc
 *		Get device y coordinate corresponding to Himetric y coordinate  
 *
 *	@rdesc
 *		Returns device coordinate
 */
LONG CDisplay::HimetricYtoDY(
	LONG yHimetric) const
{
	return CDevDesc::HimetricYtoDY(Zoom(yHimetric));
}

/*
 *	CDisplay::DXtoHimetricX(dx)
 *
 *	@mfunc
 *		Get Himetric x coordinate corresponding to device x coordinate  
 *
 *	@rdesc
 *		Returns Himetric coordinate
 */
LONG CDisplay::DXtoHimetricX(
	LONG dx) const
{
	return UnZoom(CDevDesc::DXtoHimetricX(dx));
}

/*
 *	CDisplay::DXtoHimetricX(dy)
 *
 *	@mfunc
 *		Get Himetric y coordinate corresponding to device y coordinate  
 *
 *	@rdesc
 *		Returns Himetric coordinate
 */
LONG CDisplay::DYtoHimetricY(
	LONG dy) const
{
	return UnZoom(CDevDesc::DYtoHimetricY(dy));
}

/*
 *	CDisplay::SetClientHeight(yNewClientHeight)
 *
 *	@mfunc
 *		Reset height of client rectangle
 *
 *	@rdesc
 *		Returns previous height of the client rectangle
 */
LONG CDisplay::SetClientHeight(
	LONG yNewClientHeight)	//@parm New height for the client rectangle.
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::SetClientHeight");

	LONG yOldHeight = _yHeightClient;
	_yHeightClient = yNewClientHeight;
	return yOldHeight;
}

/*
 *	CDisplay::GetCachedSize(pdwWidth, pdwHeight)
 *
 *	@mfunc		calculates the cached client size (since it's not really
 *				cached :-)
 *
 *	@rdesc
 *		HRESULT = NOERROR
 */
 HRESULT CDisplay::GetCachedSize( 
 	DWORD *pdwWidth,  	//@parm	where to put the width
 	DWORD *pdwHeight)	//@parm where to put the height
 {
 	RECT rcInset;

	_ped->TxGetViewInset(&rcInset, this);

	*pdwHeight = _yHeightClient;
	*pdwWidth  = _xWidthView + rcInset.left + rcInset.right 
		+ GetSelBarInPixels();

	return NOERROR;
}

/*
 *	CDisplay::TransparentHitTest(hdc, prcClient, pt, pHitResult)
 *
 *	@mfunc
 *		Determine if the hit is on a transparent control
 *
 *	@rdesc
 *		Returns HRESULT of call usually S_OK.
 *
 *	@devnote
 *		FUTURE: This code needs to be investigated for possible optimizations.
 *
 *		This code is assumes that all remeasuring needed has been done before 
 *		this routine is called.
 */
HRESULT CDisplay::TransparentHitTest(
	HDC		hdc,		//@parm DC for actual drawing
	LPCRECT prcClient,	//@parm Client rectangle for rendering
	POINT	pt,			//@parm Point to hittest against
	DWORD *	pHitResult)	//@parm	Result of the hit test see TXTHITRESULT 
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::TransparentHitTest");

	COLORREF	 crBackground = _ped->TxGetBackColor();
	HDC			 hdcMem = NULL;
	HRESULT		 hr = E_FAIL;
	int			 iRow;
	COffScreenDC osdc;
	RECT		 rcClient;
	RECT		 rcRender;
	RECT		 rcView;

	// Render view to a memory DC
	// Compute zero based client rectangle
	rcClient.left	= 0;
	rcClient.top	= 0;
	rcClient.right  = prcClient->right  - prcClient->left;
	rcClient.bottom = prcClient->bottom - prcClient->top;

	// Create a memory DC
	hdcMem = osdc.Init(hdc, rcClient.right, rcClient.bottom, crBackground);
	if(!hdcMem)
		goto Cleanup;

	// Initialize display
	osdc.FillBitmap(rcClient.bottom, crBackground);

	// Set the DC to the memory DC
	SetDC(hdcMem);

	// Get view rectangle that we need for rendering
  	GetViewRect(rcView, &rcClient);

	// Adjust point to be relative to the memory display
	pt.x -= prcClient->left;
	pt.y -= prcClient->top;

	// Initalize box around point. Note that we only really need to render
	// the data inside this box because this is the only area that we will
	// test.
	rcRender.top = pt.y - HIT_CLOSE_RECT_INC;
	if (rcRender.top < 0)
		rcRender.top = 0;

	rcRender.bottom = pt.y + HIT_CLOSE_RECT_INC;
	if (rcRender.bottom > rcClient.bottom)
		rcRender.bottom = rcClient.bottom;	

	rcRender.left = pt.x - HIT_CLOSE_RECT_INC;
	if (rcRender.left < 0)
		rcRender.left = 0;

	rcRender.right = pt.x + HIT_CLOSE_RECT_INC;
	if (rcRender.right > rcClient.right)
		rcRender.right = rcClient.right;

    // Now render
    Render(rcView, rcRender);

	// Hit test
	// Assume no hit
	*pHitResult = TXTHITRESULT_TRANSPARENT;

	// At this point we won't fail this
	hr = S_OK;

	// Is there an exact hit?
	if (GetPixel(hdcMem, pt.x, pt.y) != crBackground)
	{
		*pHitResult = TXTHITRESULT_HIT;
		goto Cleanup;
	}

	// Is it close? We determine closeness by putting
	// a 10 x 10 pixel box around the hit point and 
	// seeing if there is a hit there.

	// Loop examining each bit in the box to see if it is on.
	for (iRow = rcRender.top; iRow <= rcRender.bottom; iRow++)
	{
		for (int iCol = rcRender.left; iCol <= rcRender.right; iCol++)
		{
			if (GetPixel(hdcMem, iCol, iRow) != crBackground)
			{
				*pHitResult = TXTHITRESULT_CLOSE;
				goto Cleanup;
			}
		}
	}

Cleanup:
	ResetDC();
	return hr;
}

//============================ ITxNotify Interface ==========================
/*
 *	CDisplay::OnPreReplaceRange(cp, cchDel, cchNew, cpFormatMin, cpFormatMax)
 *
 *	@mfunc
 *		Preprocess a change in backing store
 *
 *	@devnote
 *		This display doesn't care about before changes
 */
void CDisplay::OnPreReplaceRange( 
	LONG cp, 			//@parm cp where ReplaceRange starts ("cpMin")
	LONG cchDel,		//@parm Count of chars after cp that are deleted
	LONG cchNew,		//@parm Count of chars inserted after cp
	LONG cpFormatMin,	//@parm cpMin  for a formatting change
	LONG cpFormatMax)	//@parm cpMost for a formatting change
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::OnPreReplaceRange");

	// Display doesn't care about before the fact
}

/*
 *	CDisplay::OnPostReplaceRange(cp, cchDel, cchNew, cpFormatMin, cpFormatMax)
 *
 *	@mfunc
 *		Process a change to the backing store as it applies to the display
 */
void CDisplay::OnPostReplaceRange( 
	LONG cp, 			//@parm cp where ReplaceRange starts ("cpMin")
	LONG cchDel,		//@parm Count of chars after cp that are deleted
	LONG cchNew,		//@parm Count of chars inserted after cp
	LONG cpFormatMin,	//@parm cpMin  for a formatting change
	LONG cpFormatMax)	//@parm cpMost for a formatting change
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::OnPostReplaceRange");

	// There is one NO-OP's for the display:
	// currently loading a file.
	//
	// We NO-OP the load case because loading an RTF file can consist
	// of potentially very many small actions as we peice together
	// the various bits of formatted text.  Once done, the load code
	// will go through and do an update-all to the display.
	Assert (cp != CONVERT_TO_PLAIN);			// Handled with PreReplace notifications

	// Figure out range needed to update
	LONG cpNew = min(cp, cpFormatMin);

	if(CP_INFINITE == cpNew)
	{
		// If both cp's are infinite we don't need to bother with
		// this operation.
		return;
	}

	if(!_ped->_fInPlaceActive)
    {
        // If not active, just invalidate everything
        InvalidateRecalc();
        _ped->TxInvalidateRect(NULL, FALSE);
		_ped->TxUpdateWindow();
        return;
    }

	// Adjust cp for further calculations
	if(CP_INFINITE == cp)
		cp = 0;

	// find the new max end of the original region.
	LONG	cpForEnd = max( (cp + cchDel), cpFormatMax);

	// Number of deleted characters is the difference between the previous two
	LONG cchDelForDisplay = cpForEnd - cpNew;

	// The number deleted is simply number of new characters adjusted by
	// the change in the number of characters.
	LONG cchNewForDisplay = cchDelForDisplay + (cchNew - cchDel);

#ifdef LINESERVICES
	if (g_pols)
		g_pols->DestroyLine(this);
#endif

	if(_padc)
	{
		// Display is frozen so accumulate the change instead of actually
		// displaying it on the screen.
		_padc->UpdateRecalcRegion(cpNew, cchDelForDisplay, cchNewForDisplay);
		return;
	}		

	// Tell display to update
	CRchTxtPtr tp(_ped, cpNew);

	UpdateView(tp, cchDelForDisplay, cchNewForDisplay);
}

/*
 *	CDisplay::SetWordWrap(fWordWrap)
 *
 *	@mfunc
 *		Sets the no wrap flag
 *
 *	@devnote
 *		We will always allow the property to be set but we will not
 *		necessarily pay attention. In other words, word wrap has no
 *		effect on a single line edit control.
 */
void CDisplay::SetWordWrap(
	BOOL fWordWrap)		//@param TRUE - turn on word wrap.
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::SetWordWrap");

	AssertSz((fWordWrap == TRUE) ||	(fWordWrap == FALSE),
		"CDisplay::SetWordWrap bad input flag");

	// Set nowrap to whatever is coming in.
	_fWordWrap = fWordWrap;
}

/*
 *	CDisplay::GetWordWrap()
 *
 *	@mfunc
 *		Return state of word wrap property
 *
 *	@rdesc
 *		TRUE - word wrap is on
 *		FALSE - word wrap is is off.
 *
 *	@devnote
 *		Derived classes such as CDisplaySL override this.
 */
BOOL CDisplay::GetWordWrap() const
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplay::GetWordWrap");

	return _fWordWrap;
}

/*
 *	CDisplay::GetViewDim()
 *
 *	@mfunc
 *		Return the height & width of view adjusted for view inset
 */
void CDisplay::GetViewDim(
	LONG& widthView,		//@parm Where to return the width
	LONG& heightView)		//@parm Where to return the height
{
	// We build a client rectangle to take advantage of GetViewRect routine
	// which really does all the work for us.
	RECT rcClient;
	rcClient.left = 0;
	rcClient.top = 0;
	rcClient.right = widthView;
	rcClient.bottom = heightView;

	// Take into account inset and selection bar. The parameters here are a bit
	// of a trick. The second parameter gets copied into the first and since
	// we don't need the original client rect we save a rect off the stack.
	GetViewRect(rcClient, &rcClient);

	widthView = rcClient.right - rcClient.left;
	heightView = rcClient.bottom - rcClient.top;
}

/*
 *	CDisplay::SaveUpdateCaret (fScrollIntoView)
 *
 *	@mfunc	Save UpdateCaret parameter so update caret can be called
 *			after the display is thawed.
 *
 *	@rdesc	None.
 *
 *	@devnote
 *			This should only be called if IsFrozen is true.
 */
void CDisplay::SaveUpdateCaret(
	BOOL fScrollIntoView)
{
#ifdef DEBUG
	if (_padc == NULL)
	{
		TRACEERRORSZ("CDisplay::SaveUpdateCaret called on thawed display");
	}
#endif // DEBUG
	if(_padc)
		_padc->SaveUpdateCaret(fScrollIntoView);
}

/*
 *	CDisplay::SetNeedRedisplayOnThaw
 *
 *	@mfunc
 *		Automatically redisplay control on thaw
 */
void CDisplay::SetNeedRedisplayOnThaw(BOOL fNeedRedisplay)
{
	Assert (_padc);
	_padc->SetNeedRedisplayOnThaw(fNeedRedisplay);
}

/*
 *	CDisplay::Freeze
 *
 *	@mfunc
 *		Prevent any updates from occuring in the display
 */
void CDisplay::Freeze()
{
	if(NULL == _padc)
	{
		// Allocate object to keep track of changes
		_padc = new CAccumDisplayChanges();

		// We can now return because the accum object has a reference
		// or the memory allocation failed. If the memory allocation 
		// failed, This really isn't a catastrophe because all it means 
		// is that things will get displayed ugly temporarily, so we can 
		// pretend it didn't happen.
		return;
	}

	// Tell object that an additional freeze has occurred.
	_padc->AddRef();
}

/*
 *	CDisplay::Thaw()
 *
 *	@mfunc
 *		If this is the last thaw, then cause display to be updated.
 *
 */
void CDisplay::Thaw()
{
	BOOL fUpdateCaret, fScrollIntoView, fNeedRedisplay;
	LONG cp, cchNew, cchDel;
	CTxtSelection *psel;

	if(_padc)
	{
		// Release reference to accum object
		if(_padc->Release() == 0)
		{
			// Last thaw so we need to update display

			// Get the changes
			_padc->GetUpdateRegion(&cp, &cchDel, &cchNew, 
				&fUpdateCaret, &fScrollIntoView, &fNeedRedisplay);

			// Clear the object - note we do this before
			// the update just on the off chance that
			// a new freeze manages to get in during the 
			// update of the display.
			delete _padc;
			_padc = NULL;

			if(cp != CP_INFINITE)
			{
				// Display changed
				if(!_ped->fInplaceActive())
				{
					// Are not inplace active so we need to put this operation
					// off till a more appropriate time.

					InvalidateRecalc();
					_ped->TxInvalidateRect(NULL, FALSE);
					_ped->TxUpdateWindow();
					return;
				}
				// Update display
				CRchTxtPtr rtp(_ped, cp);
				if(!UpdateView(rtp, cchDel, cchNew))
					return;							// Update failed
			}

			if (fNeedRedisplay)
				_ped->TxInvalidateRect(NULL, FALSE);

			// Did selection request a caret update?
			if(fUpdateCaret && _ped->fInplaceActive())
			{
				psel = _ped->GetSel();
				psel->UpdateCaret(fScrollIntoView);
			}
		}
	}
}

/*
 *	CDisplay::IsPrinter
 *
 *	@mfunc
 *		Returns whether this is a printer
 *
 *	@rdesc
 *		TRUE - is a display to a printer
 *		FALSE - is not a display to a printer
 *
 *	@devnote
 *		No display except a display	CDisplayPrinter should
 *		ever have a chance to return TRUE to this function.
 */
BOOL CDisplay::IsPrinter() const
{
	return FALSE;
}

/*
 *	CDisplay::Zombie ()
 *
 *	@mfunc
 *		Turn this object into a zombie
 */
void CDisplay::Zombie ()
{
	TRACEBEGIN(TRCSUBSYSOLE, TRCSCOPEEXTERN, "CDisplay::Zombie");

}

/*
 *	CDisplay::IsHScrollEnabled ()
 *
 *	@mfunc
 *		Return whether horizontal scroll bar is enabled
 *
 *	@rdesc
 *		TRUE - yes
 *		FALSE - no
 *
 *	@devnote
 *		The reason for this routine is that _fHScrollEnabled means
 *		to scroll text and can be set even if there is no scroll
 *		bar. Therefore, we need to look at the host properties
 *		as well to tell use whether this means there are scroll
 *		bars.
 */
BOOL CDisplay::IsHScrollEnabled()	  
{
	return _fHScrollEnabled && ((_ped->TxGetScrollBars() & WS_HSCROLL) != 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\doc.cpp ===
/*
 *	@doc INTERNAL
 *
 *	@module DOC.C	CTxtStory and CTxtArray implementation |
 *	
 *	Original Authors: <nl>
 *		Original RichEdit code: David R. Fulmer <nl>
 *		Christian Fortini	<nl>
 *		Murray Sargent <nl>
 *
 *	History: <nl>
 *		6/25/95	alexgo	Cleanup and reorganization
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_doc.h"
#include "_format.h"

ASSERTDATA

// ===========================  Invariant stuff  ======================

#define DEBUG_CLASSNAME CTxtArray
#include "_invar.h"

// ========================  CTxtArray class  =========================

#ifdef DEBUG

/*
 *	CTxtArray::Invariant
 *
 *	@mfunc	Tests CTxtArray's state
 *
 *	@rdesc	Returns TRUE always; failures are indicated by Asserts
 *			Actually in this routine, we return count of chars in blocks
 *			since we need this value for one check.
 */
BOOL CTxtArray::Invariant() const
{
	static LONG	numTests = 0;
	numTests++;				// How many times we've been called.

	LONG cch = 0;
	LONG iMax = Count();

	if(iMax > 0)
	{
		CTxtBlk *ptb = Elem(0);

		// ptb shouldn't be NULL since we're within Count elements
		Assert(ptb);

		for(LONG i = 0; i < iMax; i++, ptb++)
		{
			LONG cchCurr = ptb->_cch;
			cch += cchCurr;
			
			Assert ( cchCurr >= 0 );
			Assert ( cchCurr <= CchOfCb(ptb->_cbBlock) );

			// While we're here, check range of interblock gaps
			Assert (ptb->_ibGap >= 0);
			Assert (ptb->_ibGap <= ptb->_cbBlock);

			LONG cchGap = CchOfCb(ptb->_ibGap);
			Assert ( cchGap >= 0 );
			Assert ( cchGap <= cchCurr );
		}
	}
	return cch;
}

#endif	// DEBUG

/*
 *	CTxtArray::CTxtArray()
 *	
 *	@mfunc		Text array constructor
 *	
 */
CTxtArray::CTxtArray() : CArray<CTxtBlk> ()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtArray::CTxtArray()");

	AssertSz(CchOfCb(cbBlockMost) - cchGapInitial >= cchBlkInitmGapI * 2, 
		"cchBlockMax - cchGapInitial must be at least (cchBlockInitial - cchGapInitial) * 2");

	Assert(!_cchText && !_iCF && !_iPF);
	// Make sure we have no data to initialize
	Assert(sizeof(CTxtArray) == sizeof(CArray<CTxtBlk>) + sizeof(_cchText) + 2*sizeof(_iCF));
}

/*
 *	CTxtArray::~CTxtArray
 *	
 *	@mfunc		Text array destructor
 */
CTxtArray::~CTxtArray()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtArray::~CTxtArray");

	LONG itb = Count();
	while(itb--)
	{
		Assert(Elem(itb) != NULL);
		Elem(itb)->FreeBlock();
	}
}

/*
 *	CTxtArray::CalcTextLength()
 *	
 *	@mfunc		Computes and return length of text in this text array
 *
 *	@rdesc		Count of character in this text array
 *
 *	@devnote	This call may be computationally expensive; we have to
 *				sum up the character sizes of all of the text blocks in
 *				the array.
 */
LONG CTxtArray::CalcTextLength() const
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtArray::GetCch");

	_TEST_INVARIANT_
		
	LONG itb = Count();
	if(!itb)
		return 0;

	LONG	 cch;
	CTxtBlk *ptb = Elem(0);

	for(cch = 0; itb--; ptb++) 
		cch += ptb->_cch;

	return cch;
}

/*
 *	CTxtArray::AddBlock(itbNew, cb)
 *	
 *	@mfunc		create new text block
 *	
 *	@rdesc
 *		FALSE if block could not be added
 *		non-FALSE otherwise
 *	
 *	@comm 
 *	Side Effects:  
 *		moves text block array
 */
BOOL CTxtArray::AddBlock(
	LONG	itbNew,		//@parm	index of the new block 
	LONG	cb)			//@parm size of new block; if <lt>= 0, default is used
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtArray::AddBlock");

	_TEST_INVARIANT_

	CTxtBlk *ptb;

	if(cb <= 0)
		cb = cbBlockInitial;

	AssertSz(cb > 0, "CTxtArray::AddBlock() - adding block of size zero");
	AssertSz(cb <= cbBlockMost, "CTxtArray::AddBlock() - block too big");

	ptb = Insert(itbNew, 1);

	if(!ptb || !ptb->InitBlock(cb))
	{	
		TRACEERRSZSC("TXTARRAT::AddBlock() - unable to allocate new block", E_OUTOFMEMORY);
		return FALSE;
	}
	return TRUE;
}

/*
 *	CTxtArray::SplitBlock(itb, ichSplit, cchFirst, cchLast, fStreaming)
 *	
 *	@mfunc		split a text block into two
 *	
 *	@rdesc
 *		FALSE if the block could not be split <nl>
 *		non-FALSE otherwise
 *	
 *	@comm
 *	Side Effects: <nl>
 *		moves text block array
 */
BOOL CTxtArray::SplitBlock(
	LONG itb, 			//@parm	index of the block to split
	LONG ichSplit,	 	//@parm	character index within block at which to split
	LONG cchFirst, 		//@parm desired extra space in first block
	LONG cchLast, 		//@parm desired extra space in new block
	BOOL fStreaming)	//@parm TRUE if streaming in new text
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtArray::SplitBlock");

	_TEST_INVARIANT_

	LPBYTE pbSrc;
	LPBYTE pbDst;
	CTxtBlk *ptb, *ptb1;

	AssertSz(ichSplit > 0 || cchFirst > 0, "CTxtArray::SplitBlock(): splitting at beginning, but not adding anything");

	AssertSz(itb >= 0, "CTxtArray::SplitBlock(): negative itb");
	ptb = Elem(itb);

	// compute size for first half

	AssertSz(cchFirst + ichSplit <= CchOfCb(cbBlockMost),
		"CTxtArray::SplitBlock(): first size too large");
	cchFirst += ichSplit + cchGapInitial;
	cchFirst = min(cchFirst, CchOfCb(cbBlockMost));

	// compute size for second half

	AssertSz(cchLast + ptb->_cch - ichSplit <= CchOfCb(cbBlockMost),
		"CTxtArray::SplitBlock(): second size too large");
	cchLast += ptb->_cch - ichSplit + cchGapInitial;
	cchLast = min(cchLast, CchOfCb(cbBlockMost));

	// Allocate second block and move text to it
	
	// If streaming in, allocate a block that's as big as possible so that
	// subsequent additions of text are faster. We always fall back to
	// smaller allocations so this won't cause unnecessary errors. When
	// we're done streaming we compress blocks, so this won't leave	a
	// big empty gap.  NOTE: ***** moves rgtb *****
	if(fStreaming)
	{
		LONG cb = cbBlockMost;
		const LONG cbMin = CbOfCch(cchLast);

		while(cb >= cbMin && !AddBlock(itb + 1, cb))
			cb -= cbBlockCombine;
		if(cb >= cbMin)
			goto got_block;
	}
	if(!AddBlock(itb + 1, CbOfCch(cchLast)))
	{
		TRACEERRSZSC("CTxtArray::SplitBlock(): unabled to add new block", E_FAIL);
		return FALSE;
	}

got_block:
	ptb1 = Elem(itb+1);	// recompute ptb after rgtb moves
	ptb = Elem(itb);	// recompute ptb after rgtb moves
	ptb1->_cch = ptb->_cch - ichSplit;
	ptb1->_ibGap = 0;
	pbDst = (LPBYTE) (ptb1->_pch - ptb1->_cch) + ptb1->_cbBlock;
	ptb->MoveGap(ptb->_cch); // make sure pch points to a continuous block of all text in ptb.
	pbSrc = (LPBYTE) (ptb->_pch + ichSplit);
	CopyMemory(pbDst, pbSrc, CbOfCch(ptb1->_cch));
	ptb->_cch = ichSplit;
	ptb->_ibGap = CbOfCch(ichSplit);

	// Resize first block
	if(CbOfCch(cchFirst) != ptb->_cbBlock)
	{
//$ FUTURE: don't resize unless growing or shrinking considerably
		if(!ptb->ResizeBlock(CbOfCch(cchFirst)))
		{
			TRACEERRSZSC("TXTARRA::SplitBlock(): unabled to resize block", E_OUTOFMEMORY);
			return FALSE;
		}
	}
	return TRUE;
}

/*
 *	CTxtArray::ShrinkBlocks()
 *	
 *	@mfunc		Shrink all blocks to their minimal size
 */
void CTxtArray::ShrinkBlocks()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtArray::ShrinkBlocks");

	_TEST_INVARIANT_

	LONG itb = Count();
	CTxtBlk *ptb;

	while(itb--)
	{
		ptb = Elem(itb);
		Assert(ptb);
		ptb->ResizeBlock(CbOfCch(ptb->_cch));
	}
}

/*
 *	CTxtArray::RemoveBlocks(itbFirst, ctbDel)
 *	
 *	@mfunc		remove a range of text blocks
 *	
 *	@rdesc
 *		nothing
 *	
 *	@comm Side Effects: <nl>
 *		moves text block array
 */
void CTxtArray::RemoveBlocks(
	LONG itbFirst, 		//@parm index of first block to remove
	LONG ctbDel)			//@parm	number of blocks to remove
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtArray::RemoveBlocks");

	_TEST_INVARIANT_

	LONG itb = itbFirst;
	LONG ctb = ctbDel;

	AssertSz(itb + ctb <= Count(), "CTxtArray::RemoveBlocks(): not enough blocks");

	while(ctb--)
	{
		Assert(Elem(itb) != NULL);
		Elem(itb++)->FreeBlock();
	}
	
	Remove(itbFirst, ctbDel);
}

/*
 *	CTxtArray::CombineBlocks(itb)
 *	
 *	@mfunc		combine adjacent text blocks
 *	
 *	@rdesc
 *		nothing
 *	
 *	@comm 
 *	Side Effects: <nl>
 *		moves text block array
 *	
 *	@devnote
 *		scans blocks from itb - 1 through itb + 1 trying to combine
 *		adjacent blocks
 */
void CTxtArray::CombineBlocks(
	LONG itb)		//@parm	index of the first block modified
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtArray::CombineBlocks");

	_TEST_INVARIANT_

	LONG ctb;
	LONG cbT;
	CTxtBlk *ptb, *ptb1;

	if(itb > 0)
		itb--;

	ctb = min(3, Count() - itb);
	if(ctb <= 1)
		return;

	for(; ctb > 1; ctb--)
	{
		ptb  = Elem(itb);							// Can we combine current
		ptb1 = Elem(itb+1);							//  and next blocks ?
		cbT = CbOfCch(ptb->_cch + ptb1->_cch + cchGapInitial);
		if(cbT <= cbBlockInitial)
		{											// Yes
			if(cbT != ptb->_cbBlock && !ptb->ResizeBlock(cbT))
				continue;
			ptb ->MoveGap(ptb->_cch);				// Move gaps at ends of
			ptb1->MoveGap(ptb1->_cch);				//  both blocks
			CopyMemory(ptb->_pch + ptb->_cch,		// Copy next block text
				ptb1->_pch,	CbOfCch(ptb1->_cch));	//  into current block
			ptb->_cch += ptb1->_cch;
			ptb->_ibGap += CbOfCch(ptb1->_cch);
			RemoveBlocks(itb+1, 1);					// Remove next block
		}
		else
			itb++;
	}
}

/*
 *	CTxtArray::GetChunk(ppch, cch, pchChunk, cchCopy)
 *	
 *	@mfunc
 *		Get content of text chunk in this text array into a string	
 *	
 *	@rdesc
 *		remaining count of characters to get
 */
LONG CTxtArray::GetChunk(
	TCHAR **ppch, 			//@parm ptr to ptr to buffer to copy text chunk into
	LONG cch, 				//@parm length of pch buffer
	TCHAR *pchChunk, 		//@parm ptr to text chunk
	LONG cchCopy) const	//@parm count of characters in chunk
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtArray::GetChunk");

	_TEST_INVARIANT_

	if(cch > 0 && cchCopy > 0)
	{
		if(cch < cchCopy)
			cchCopy = cch;						// Copy less than full chunk
		CopyMemory(*ppch, pchChunk, cchCopy*sizeof(TCHAR));
		*ppch	+= cchCopy;						// Adjust target buffer ptr
		cch		-= cchCopy;						// Fewer chars to copy
	}
	return cch;									// Remaining count to copy
}

const CCharFormat* CTxtArray::GetCharFormat(LONG iCF)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtArray::GetCharFormat");

	const CCharFormat *	pCF;
	
	if(iCF < 0)
		iCF = _iCF;
	Assert(iCF >= 0);

	if(FAILED(GetCharFormatCache()->Deref(iCF, &pCF)))
	{
		AssertSz(FALSE, "CTxtArray::GetCharFormat: couldn't deref iCF");
		pCF = NULL;
	}
	return pCF;
}

const CParaFormat* CTxtArray::GetParaFormat(LONG iPF)
{
	TRACEBEGIN(TRCSUBSYSEDIT, TRCSCOPEINTERN, "CTxtArray::GetParaFormat");

	const CParaFormat *	pPF;
	
	if(iPF < 0)
		iPF = _iPF;
	Assert(iPF >= 0);

	if(FAILED(GetParaFormatCache()->Deref(iPF, &pPF)))
	{
		AssertSz(FALSE, "CTxtArray::GetParaFormat: couldn't deref iPF");
		pPF = NULL;
	}
	return pPF;
}


// ========================  CTxtBlk class  =================================
/*
 *	CTxtBlk::InitBlock(cb)
 *	
 *	@mfunc
 *		Initialize this text block
 *
 *	@rdesc
 *		TRUE if success, FALSE if allocation failed
 */
BOOL CTxtBlk::InitBlock(
	LONG cb)			//@parm	initial size of the text block
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtBlk::InitBlock");

	_pch	= NULL;
	_cch	= 0;
	_ibGap	= 0;
	_cbBlock= cb;

	if(cb)
		_pch = (TCHAR*)PvAlloc(cb, GMEM_ZEROINIT);
	return _pch != 0;
}

/*
 *	CTxtBlk::FreeBlock()
 *	
 *	@mfunc
 *		Free this text block
 *	
 *	@rdesc
 *		nothing
 */
VOID CTxtBlk::FreeBlock()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtBlk::FreeBlock");

	FreePv(_pch);
	_pch	= NULL;
	_cch	= 0;
	_ibGap	= 0;
	_cbBlock= 0;
}

/*
 *	CTxtBlk::MoveGap(ichGap)
 *	
 *	@mfunc
 *		move gap in this text block
 *	
 *	@rdesc
 *		nothing
 */
void CTxtBlk::MoveGap(
	LONG ichGap)			//@parm	new position for the gap
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtBlk::MoveGap");

	LONG cbMove;
	LONG ibGapNew = CbOfCch(ichGap);
	LPBYTE pbFrom = (LPBYTE) _pch;
	LPBYTE pbTo;

	if(ibGapNew == _ibGap)
		return;

	if(ibGapNew < _ibGap)
	{
		cbMove = _ibGap - ibGapNew;
		pbFrom += ibGapNew;
		pbTo = pbFrom + _cbBlock - CbOfCch(_cch);
	}
	else
	{
		cbMove = ibGapNew - _ibGap;
		pbTo = pbFrom + _ibGap;
		pbFrom = pbTo + _cbBlock - CbOfCch(_cch);
	}

	MoveMemory(pbTo, pbFrom, cbMove);
	_ibGap = ibGapNew;
}


/*
 *	CTxtBlk::ResizeBlock(cbNew)
 *	
 *	@mfunc
 *		resize this text block
 *	
 *	@rdesc	
 *		FALSE if block could not be resized <nl>
 *		non-FALSE otherwise
 *	
 *	@comm
 * 	Side Effects: <nl>
 *		moves text block
 */
BOOL CTxtBlk::ResizeBlock(
	LONG cbNew)		//@parm	the new size
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtBlk::ResizeBlock");

	TCHAR *pch;
	LONG cbMove;

	AssertSz(cbNew > 0, "resizing block to size <= 0");
	AssertSz(cbNew <= cbBlockMost, "CTxtBlk::ResizeBlock() - block too big");

	if(cbNew < _cbBlock)
	{
		if(_ibGap != CbOfCch(_cch))
		{
			// move text after gap down so that it doesn't get dropped

			cbMove = CbOfCch(_cch) - _ibGap;
			pch = _pch + CchOfCb(_cbBlock - cbMove);
			MoveMemory(pch - CchOfCb(_cbBlock - cbNew), pch, cbMove);
		}
		_cbBlock = cbNew;
	}
	pch = (TCHAR*)PvReAlloc(_pch, cbNew);
	if(!pch)
		return _cbBlock == cbNew;	// FALSE if grow, TRUE if shrink

	_pch = pch;
	if(cbNew > _cbBlock)
	{
		if(_ibGap != CbOfCch(_cch))		// Move text after gap to end so that
		{								// we don't end up with two gaps
			cbMove = CbOfCch(_cch) - _ibGap;
			pch += CchOfCb(_cbBlock - cbMove);
			MoveMemory(pch + CchOfCb(cbNew - _cbBlock), pch, cbMove);
		}
		_cbBlock = cbNew;
	}
	return TRUE;
}


// ========================  CTxtStory class  ============================
/* 
 *	CTxtStory::CTxtStory
 *
 *	@mfunc	Constructor
 *
 *	@devnote	Automatically allocates a text array.  If we want to have a
 *	completely empty edit control, then don't allocate a story.  NB!
 *	
 */
CTxtStory::CTxtStory()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtStory::CTxtStory");

	_pCFRuns = NULL;
	_pPFRuns = NULL;
}

/*
 *	CTxtStory::~CTxtStory
 *
 *	@mfunc	Destructor
 */
CTxtStory::~CTxtStory()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtStory::~CTxtStory");

	// Remove formatting.
	DeleteFormatRuns();
}

/*
 *	DeleteRuns ()
 *
 *	@mfunc
 *		Helper function for DeleteFormatRuns() below.  Releases
 *		formats used by format run collection before deleting the
 *		collection
 */
void DeleteRuns(CFormatRuns *pRuns, IFormatCache *pf)
{
    if(pRuns)									// Format runs may exist
	{
		LONG n = pRuns->Count();
		if(n)
		{
			CFormatRun *pRun = pRuns->Elem(0);
			for( ; n--; pRun++)
				pf->Release(pRun->_iFormat);	// Free run's format
		}
        delete pRuns;
	}	
}

/*
 *	CTxtStory::DeleteFormatRuns ()
 *
 *	@mfunc	Convert to plain - remove format runs
 */
void CTxtStory::DeleteFormatRuns()
{
	TRACEBEGIN(TRCSUBSYSBACK, TRCSCOPEINTERN, "CTxtStory::ConvertToPlain");

	DeleteRuns(_pCFRuns, GetCharFormatCache());
	DeleteRuns(_pPFRuns, GetParaFormatCache());

	_pCFRuns = NULL;
	_pPFRuns = NULL;
}


#ifdef DEBUG
//This dumps the contents of the CTxtStory
//TxtBlk & FormatRun arrays to the debug output.
void CTxtStory::DbgDumpStory(void)
{
	CTxtBlk * pblk;
	CFormatRun * pcfr;
	CFormatRun * ppfr;
	LONG ctxtr = 0;
	LONG ccfr = 0;
	LONG cpfr = 0;
	LONG i;

	ctxtr = _TxtArray.Count();

	if (_pCFRuns)
		ccfr = _pCFRuns->Count();
	if (_pPFRuns)
		cpfr = _pPFRuns->Count();

	for(i = 0; i < ctxtr; i++)
	{
		pblk = (CTxtBlk*)_TxtArray.Elem(i);
		Tracef(TRCSEVNONE, "TxtBlk #%d: cch = %d.", (i + 1), pblk->_cch);
	}	

	for(i = 0; i < ccfr; i++)
	{
		pcfr = (CFormatRun*)_pCFRuns->Elem(i);
		Tracef(TRCSEVNONE, "CFR #%d: cch = %d, iFormat = %d.",(i + 1), pcfr->_cch, pcfr->_iFormat);
	}	

	for(i = 0; i < cpfr; i++)
	{
		ppfr = (CFormatRun*)_pPFRuns->Elem(i);
		Tracef(TRCSEVNONE, "PFR #%d: cch = %d, iFormat = %d.",(i + 1), ppfr->_cch, ppfr->_iFormat);
			
	}
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\dfreeze.cpp ===
/*	@doc INTERNAL
 *
 *	@module _DFREEZE.CPP  Implementation for classes handle freezing the display |
 *	
 *	This module implements non-inline members used by logic to handle freezing the display
 *
 *	History: <nl>
 *		2/8/96	ricksa	Created
 *
 *	Copyright (c) 1995-1997, Microsoft Corporation. All rights reserved.
 */
#include	"_common.h"
#include	"_disp.h"
#include	"_dfreeze.h"

ASSERTDATA

/*
 *	CAccumDisplayChanges::GetUpdateRegion(pcpStart, pcchDel, pcchNew,
 *										  pfUpdateCaret, pfScrollIntoView)
 *	@mfunc
 *		Get region for display to update
 */
void CAccumDisplayChanges::GetUpdateRegion(
	LONG *pcpStart,			//@parm where to put the cpStart
	LONG *pcchDel,			//@parm where to put the del char count
	LONG *pcchNew,			//@parm where to put the new char count
	BOOL *pfUpdateCaret,	//@parm whether caret update is needed
	BOOL *pfScrollIntoView,	//@parm whether to scroll caret into view
	BOOL *pfNeedRedisplay)	//@parm whether it needs redisplay
{
	LONG cchDel;
	*pcpStart = _cpMin;

	if(pfUpdateCaret)
		*pfUpdateCaret = _fUpdateCaret;
	if(pfScrollIntoView)
		*pfScrollIntoView = _fScrollIntoView;
	if (pfNeedRedisplay)
		*pfNeedRedisplay = _fNeedRedisplay;

	if(_cpMin == CP_INFINITE)
		return;

	cchDel = _cpMax - _cpMin;

	if(pcchDel)
		*pcchDel =  cchDel;

	*pcchNew = cchDel + _delta;

	_cpMin = CP_INFINITE;
}

/*
 *	CAccumDisplayChanges::UpdateRecalcRegion(cpStartNew, cchDel, cchNew)
 *
 *	@mfunc
 *		Merge new update with region to be recalculated
 */
void CAccumDisplayChanges::UpdateRecalcRegion(
	LONG cpStartNew,	//@parm Start of update
	LONG cchDel,		//@parm Count of chars to delete
	LONG cchNew)		//@parm Count of chars to add
{
	if(CP_INFINITE == _cpMin)
	{
		// Object is empty so just assign values
		_cpMin = cpStartNew;
		_cpMax = cpStartNew + cchDel;
		_delta = cchNew - cchDel;
		return;
	}

	// The basic idea of this algorithm is to merge the updates so that
	// they appear to the display sub-system as if only one replace range
	// has occured. To do this we keep track of the start of the update 
	// (_cpMin) relative to the original text and the end of the update 
	// (_cpMax) relative to the original text and the change  in the count 
	// of text (_delta). We can recreate cchDel from _cpMost - _cpMin and 
	// cchNew from cchDel + _delta.

	// Do we need to update _cpMin? - we only need to update _cpMin if the
	// current update begins before the last update because the final update
	// need only know the very start of the range updated.
	if(cpStartNew < _cpMin)
		_cpMin = cpStartNew;

	// Do we need to udpate _cpMax? - we only need to update _cpMax if the
	// current update implies a _cpMax that is greater than the current one.
	// Note that because prior updates affect where the _cpMax is located
	// we need to compare againt the proposed _cpMax against the current
	// _cpMax adjusted by the change in the text since the beginning of the
	// updates.
	if(cpStartNew + cchDel > _cpMax + _delta)
		_cpMax = cpStartNew + cchDel - _delta;

	// Increment the total change by the change for this update.
	_delta += cchNew - cchDel;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\dragdrp.cpp ===
/*
 *	DRAGDRP.C
 *
 *	Purpose:
 *		Implementation of Richedit's OLE drag drop objects (namely,
 *		the drop target and drop source objects)
 *
 *	Author:
 *		alexgo (4/24/95)
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_edit.h"
#include "_dragdrp.h"
#include "_disp.h"
#include "_select.h"
#include "_font.h"
#include "_measure.h"

ASSERTDATA

//
//	CDropSource PUBLIC methods
//

/*
 *	CDropSource::QueryInterface (riid, ppv)
 */

STDMETHODIMP CDropSource::QueryInterface(REFIID riid, void ** ppv)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropSource::QueryInterface");

	if( IsEqualIID(riid, IID_IUnknown) )
	{
		*ppv = (IUnknown *)this;
	}
	else if( IsEqualIID(riid, IID_IDropSource) )
	{
		*ppv = (IDropSource *)this;
	}
	else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}

	AddRef();
	return NOERROR;
}

/*
 *	CDropSource::AddRef
 */
STDMETHODIMP_(ULONG) CDropSource::AddRef()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropSource::AddRef");

	return ++_crefs;
}

/*
 *	CDropSource::Release
 *
 *	@devnote.  Do not even think about making an outgoing call here.
 *			   If you do, be sure make sure all callers use a 
 *			   SafeReleaseAndNULL (null the pointer before releasing)
 *			   technique to avoid re-entrancy problems.
 */
STDMETHODIMP_(ULONG) CDropSource::Release()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropSource::Release");

	_crefs--;

	if( _crefs == 0 )
	{
		delete this;
		return 0;
	}

	return _crefs;
}

/*
 *	CDropSource::QueryContinueDrag (fEscapePressed, grfKeyState)
 *
 *	Purpose:
 *		determines whether or not to continue a drag drop operation
 *
 *	Algorithm:
 *		if the escape key has been pressed, cancel 
 *		if the left mouse button has been release, then attempt to 
 *			do a drop
 */
STDMETHODIMP CDropSource::QueryContinueDrag(BOOL fEscapePressed, 
	DWORD grfKeyState)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropSource::QueryContinueDrag");

    if (fEscapePressed)
	{
        return DRAGDROP_S_CANCEL;
	}
    else if (!(grfKeyState & MK_LBUTTON) && !(grfKeyState & MK_RBUTTON))
	{
        return DRAGDROP_S_DROP;
	}
    else
	{
        return NOERROR;
	}
}

/*
 *	CDropSource::GiveFeedback (dwEffect)
 *
 *	Purpose:
 *		gives feedback during a drag drop operation
 *
 *	Notes:
 *		FUTURE (alexgo): maybe put in some neater feedback effects
 *		than the standard OLE stuff??
 */
STDMETHODIMP CDropSource::GiveFeedback(DWORD dwEffect)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropSource::GiveFeedback");

	return DRAGDROP_S_USEDEFAULTCURSORS;
}

/*
 *	CDropSource::CDropSource
 */
CDropSource::CDropSource()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropSource::CDropSource");

	_crefs = 1;
}

//
//	CDropSource PRIVATE methods
//

/*
 *	CDropSource::~CDropSource
 */
CDropSource::~CDropSource()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropSource::~CDropSource");

	;
}


//
//	CDropTarget PUBLIC methods
//

/*
 *	CDropTarget::QueryInterface (riid, ppv)
 */
STDMETHODIMP CDropTarget::QueryInterface (REFIID riid, void ** ppv)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::QueryInterface");

	if( IsEqualIID(riid, IID_IUnknown) )
	{
		*ppv = (IUnknown *)this;
	}
	else if( IsEqualIID(riid, IID_IDropTarget) )
	{
		*ppv = (IDropTarget *)this;
	}
	else
	{
		*ppv = NULL;
		return E_NOINTERFACE;
	}

	AddRef();

	return NOERROR;
}

/*
 *	CDropTarget::AddRef
 */
STDMETHODIMP_(ULONG) CDropTarget::AddRef()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::AddRef");

	return ++_crefs;
}

/*
 *	CDropTarget::Release()
 */
STDMETHODIMP_(ULONG) CDropTarget::Release()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::Release");

	_crefs--;

	if( _crefs == 0 )
	{
		delete this;
		return 0;
	}

	return _crefs;
}

/*
 *	CDropTarget::DragEnter (pdo, grfKeyState, pt, pdwEffect)
 *
 *	Purpose: 
 *		called when OLE drag drop enters our "window"
 *
 *	Algorithm:
 *		first we check to see if the data object being transferred contains
 *		any data that we support.  Then we verify that the 'type' of drag
 *		is acceptable (i.e., currently, we do not accept links).
 *
 *
 *	FUTURE: (alexgo): we may want to accept links as well.
 */
STDMETHODIMP CDropTarget::DragEnter(IDataObject *pdo, DWORD grfKeyState,
            POINTL pt, DWORD *pdwEffect)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::DragEnter");

	// We don't have a position yet.
	_cpCur = -1;

	HRESULT hr = NOERROR;
	DWORD result;
	CTxtSelection *psel;

	// At drag enter time, we should have no cached info about what the data
	// object supports.  This flag should be cleared in DragLeave.  Note
	// that we slightly override _dwFlags, as it's possible for a data object
	// given during drag drop to also generate DOI_NONE.

	if( !_ped )
	{
		return CO_E_RELEASED;
	}
	 
	Assert(_pcallmgr == NULL);
	Assert(_dwFlags == 0);

	_pcallmgr = new CCallMgr(_ped);

	if( !_pcallmgr )
	{
		return E_OUTOFMEMORY;
	}

	// Find out if we can paste the object
	result = _ped->GetDTE()->CanPaste(pdo, 0, RECO_DROP);

	if( result )
	{
		if( result == DF_CLIENTCONTROL )
		{
			_dwFlags |= DF_CLIENTCONTROL;
		}

		// Create the object that implements the drag caret
		_pdrgcrt = new CDropCaret(_ped);

		if ((NULL == _pdrgcrt) || !_pdrgcrt->Init())
		{
			// Initialization failed so go without a caret
			delete _pdrgcrt;
			_pdrgcrt = NULL;
		}
				
		// cache the current selection so we can restore it on return
		psel = _ped->GetSel();
		Assert(psel);

		_cpSel	= psel->GetCp();
		_cchSel	= psel->GetCch();
		_dwFlags |= DF_CANDROP;

		// just call DragOver to handle our visual feedback
		hr = DragOver(grfKeyState, pt, pdwEffect);
	}
	else if (_ped->fInOurHost())
	{
		// Just tell the caller that we can't drop.
		*pdwEffect = DROPEFFECT_NONE;
	}
	else
	{
		// this is new behaviour for Win95 OLE; if we don't 
		// understand anything about the data object given to us,
		// we return S_FALSE to allow our parent to give the
		// drag drop a try.

		// In theory, only forms^3 uses this information and
		// this return exposes an error in NT OLE, therefore,
		// we only do this now when not in our own host.
		
		hr = S_FALSE;
	}

	if( hr != NOERROR )
	{
		delete _pcallmgr;
		_pcallmgr = NULL;
		_dwFlags = 0;
	}

	return hr;
}

/*
 *	CDropTarget::DragOver (grfKeyState, pt, pdwEffect)
 *
 *	Purpose:
 *		handles the visual feedback for a drag drop operation zooming
 *		around over text
 *
 *	FUTURE (alexgo): maybe we should do some snazzy visuals here
 */
STDMETHODIMP CDropTarget::DragOver(DWORD grfKeyState, POINTL pt, 
		DWORD *pdwEffect)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::DragOver");

	LONG	cpCur = _cpCur;

	if( !_ped )
	{
		return CO_E_RELEASED;
	}
	Assert(_pcallmgr);

	// note if we're doing right mouse drag drop; note that we 
	// can't do this in UpdateEffect as it's called from Drop
	// as well (and the mouse button is up then!)
	if( (grfKeyState & MK_RBUTTON) )
	{
		_dwFlags |= DF_RIGHTMOUSEDRAG;
	}
	else
	{
		_dwFlags &= ~DF_RIGHTMOUSEDRAG;
	}

	UpdateEffect(grfKeyState, pt, pdwEffect);

	// only draw if we've changed position	
	if( *pdwEffect != DROPEFFECT_NONE 
		&& ((cpCur != _cpCur) 
			|| (_pdrgcrt && _pdrgcrt->NoCaret())))
	{
		DrawFeedback();
	}	

	return NOERROR;
}

/*
 *	CDropTarget::DragLeave
 *
 *	Purpose:
 *		called when the mouse leaves our window during drag drop.  Here we clean
 *		up any temporary state setup for the drag operation.
 */
STDMETHODIMP CDropTarget::DragLeave()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::DragLeave");

	CTxtSelection *psel = _ped->GetSel();

	if( !_ped )
	{
		return CO_E_RELEASED;
	}
	Assert(_pcallmgr);

	_dwFlags = 0;

	// now restore the selection

	psel->SetSelection(_cpSel - _cchSel, _cpSel);
	psel->Update(FALSE);

	_cpSel = _cchSel = 0;

	delete _pcallmgr;
	_pcallmgr = NULL;

	delete _pdrgcrt;
	_pdrgcrt = NULL;

	return NOERROR;
}

/*
 *	CDropTarget::Drop (pdo, grfKeyState, pt, pdwEffect)
 *
 *	@mfunc
 *		called when the mouse button is released.  We should attempt
 *		to 'paste' the data object into a selection corresponding to
 *		the mouse location
 *
 *	@devnote
 *		first, we make sure that we can still do a paste (via UpdateEffect).
 *		If so, then set the selection to the current point and then insert
 *		the text.
 *
 *	@rdesc
 *		HRESULT
 */
STDMETHODIMP CDropTarget::Drop(
	IDataObject *pdo,
	DWORD		 grfKeyState, 
	POINTL		 ptl,
	DWORD *		 pdwEffect)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::Drop");

	HRESULT	hr = NOERROR;

	if( !_ped )
		return CO_E_RELEASED;

	Assert(_pcallmgr);
	CDropCleanup cleanup(this);

	// see if we can still drop
	UpdateEffect(grfKeyState, ptl, pdwEffect);

	// UpdateEffect will show a drop cursor but at this point we don't need one
	// so we hide the drop cursor here.
	if (_pdrgcrt)
		_pdrgcrt->HideCaret();

	if (_dwFlags & DF_OVERSOURCE)
	{
		*pdwEffect = DROPEFFECT_NONE;
		_dwFlags = 0;
		return NOERROR;
	}
	
	if(*pdwEffect & (DROPEFFECT_COPY | DROPEFFECT_MOVE | DROPEFFECT_LINK))
	{
		IUndoBuilder *	publdr;
		CGenUndoBuilder undobldr( _ped, UB_AUTOCOMMIT, &publdr);
		// If this is a right mouse drag drop; handle that
		if(_dwFlags & DF_RIGHTMOUSEDRAG)
		{
			hr = HandleRightMouseDrop(pdo, ptl);

			// If S_FALSE is returned, treat drag drop normally
			if( hr != S_FALSE )
				goto Exit;
		}

		// Get an undo builder.  If we already have one cached, that means
		// we are dropping onto the same edit instance that started the drag
		// In this case, we want to use the cached undo builder so that 
		// a drag move can be undone as one "operation".

		if(_publdr)
			publdr = _publdr;

		CTxtSelection *psel = _ped->GetSel();
		psel->SetSelection(_cpCur, _cpCur);
		
		if( !_ped->IsProtectedRange(WM_PASTE, 0, 0, psel) )
		{
			hr = _ped->PasteDataObjectToRange(pdo, (CTxtRange *)psel, 
					0, NULL, publdr, PDOR_DROP);
		}

		// If we are dropping onto ourselves, the UI specifies
		// that we should select the entire range dragged.  We use
		// _publdr as an easy way to tell if the drop originated from
		// this instance

		if(SUCCEEDED(hr) && _pdrgcrt)
		{
			// If the drop worked, then we don't want to restore the area
			// where the drop caret used to be since this is not out of date.
			_pdrgcrt->CancelRestoreCaretArea();
		}		

		// Now set the selection anti-events. If the selection preceded the
		// paste poiont subtract its length from the redo position, since
		// the selection will get deleted if we are doing a DRAGMOVE within
		// this instance.
		LONG cpNext  = psel->GetCp();
		LONG cchNext = cpNext - _cpCur;
		if(_cpSel < _cpCur && _publdr && (*pdwEffect & DROPEFFECT_MOVE))
			cpNext -= abs(_cchSel);

		HandleSelectionAEInfo(_ped, publdr, _cpCur, 0, cpNext, cchNext,
							  SELAE_FORCEREPLACE);
		if(_publdr)
		{
			// If we are doing a drag move, then *don't* set the
			// selection directly on the screen--doing so will result in
			// unsightly UI--we'll set the selection to one spot, draw it
			// and then immediately move the selection somewhere else.

			// In this case, just change where the selection range exists.
			// Floating ranges and the drag-move code in ldte.c will take
			// care of the rest.

			if( *pdwEffect == DROPEFFECT_COPY )
				psel->SetSelection(_cpCur, psel->GetCp());
			else
				psel->Set(psel->GetCp(), cchNext);
		}
		else if(publdr)
		{
			// The drop call landed in us from outside, so we need
			// to fire the appropriate notifications.  First, however,
			// commit the undo builder.

			publdr->SetNameID(UID_DRAGDROP);
			publdr->Done();

			if(SUCCEEDED(hr))
			{
				// Make this window the foreground window after the drop. Note
				// that the host needs to support ITextHost2 to really get to
				// be the foreground window. If they don't this is a no-op.
				_ped->TxSetForegroundWindow();
			}
		}

		// If nothing changed on the drop && the effect is a move, then return
		// failure. This is an ugly hack to improve drag-move scenarios; if
		// nothing happened on the drop, then chances are, you don't want
		// to have the correspong "Cut" happen on the drag source side.
		//
		// Of course, this relies on the drag source responding gracefully to
		// E_FAIL w/o hitting too much trauma.
		if (*pdwEffect == DROPEFFECT_MOVE && 
			!_ped->GetCallMgr()->GetChangeEvent() )
		{
			hr = E_FAIL;
		}
	}

Exit:
	_dwFlags = 0;
	return hr;
}

/*
 *	CDropTarget::CDropTarget (ped)
 *
 */
CDropTarget::CDropTarget(CTxtEdit *ped)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::CDropTarget");

	_ped 		= ped;
	_crefs 		= 1;
	_dwFlags 	= 0;
	_publdr 	= NULL;
	_cpMin		= -1;
	_cpMost		= -1;
	_pcallmgr	= NULL;
}


/*
 *	CDropTarget::SetDragInfo (publdr, cpMin, cpMost)
 *
 *	Purpose:
 *		allows the data transfer engine to cache important information
 *		about a drag drop with this drop target.
 *
 *	Arguments:
 *		publdr		-- the undo builder for the operation.  With this
 *					   intra-instance drag drop operations can be treated
 *					   as a single user action
 *		cpMin		-- the minimim character position of the range that is
 *					   being dragged.  With this and cpMost, we can disable
 *					   dragging into the range that is being dragged!
 *		cpMost		-- the max character position
 *
 *	Notes:
 *		this method must be called again in order to clear the cached info
 *
 *		-1 for cpMin and cpMost will "clear" those values (as 0 is a valid cp)
 */

void CDropTarget::SetDragInfo( IUndoBuilder *publdr, LONG cpMin, LONG cpMost )
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::SetDragInfo");

	_publdr = publdr;
	_cpMin 	= cpMin;
	_cpMost	= cpMost;
}

/*
 *	CDropTarget::Zombie
 *
 *	@mfunc	This method clears the state in this drop target object.  It is
 *			used to recover 'gracefully' from reference counting errors
 */
void CDropTarget::Zombie()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::Zombie");

	_ped = NULL;
	if( _pcallmgr )
	{
		delete _pcallmgr;
		_pcallmgr = NULL;
	}
}

//
//	CDropTarget PRIVATE methods
//

/*
 *	CDropTarget::~CDropTarget
 */
CDropTarget::~CDropTarget()
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::~CDropTarget");

	;
}

/*
 *	CDropTarget::ConvertScreenPtToClientPt (pptScreen, pptClient)
 *
 *	Purpose:
 *		OLE drag drop sends points in using screen coordinates.  However,
 *		all of our display code internally relies on client coordinates
 *		(i.e. the coordinates relative to the window that we are being
 *		drawn in).  This routine will convert between the two
 *
 *	Notes:
 *		the client coordinates use a POINT structure instead of POINTL.
 *		while nominally they are the same, OLE uses POINTL and the display
 *		engine uses POINT. 
 *
 */

void CDropTarget::ConvertScreenPtToClientPt( POINTL *pptScreen, 
	POINT *pptClient )
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::ConvertScreenPtToClientPt");

	POINT ptS;

	pptClient->x = ptS.x = pptScreen->x;
	pptClient->y = ptS.y = pptScreen->y;

	_ped->TxScreenToClient(pptClient);

	return;
}

/*
 *	CDropTarget::UpdateEffect (grfKeyState, pt, pdwEffect)
 *
 *	Purpose:
 *		given the keyboard state and point, and knowledge of what
 *		the data object being transferred can offer, calculate
 *		the correct drag drop feedback.
 *
 *	Requires:
 *		this function should only be called during a drag drop 
 *		operation; doing otherwise will simply result in a return
 *		of DROPEFFECT_NONE.
 *
 */

void CDropTarget::UpdateEffect( DWORD grfKeyState, POINTL ptl, 
		DWORD *pdwEffect)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::UpdateEffect");

	POINT pt;
	BOOL fHot;
	WORD nScrollInset;
	HRESULT hr;
	LPRICHEDITOLECALLBACK const precall = _ped->GetRECallback();

	pt.x = ptl.x;
	pt.y = ptl.y;

	// first, find out where we are
	ConvertScreenPtToClientPt(&ptl, &pt);

	_cpCur = _ped->_pdp->CpFromPoint(pt, NULL, NULL, NULL, FALSE);

	// if we are on top of the range that is being
	// dragged, then remeber it for later
	_dwFlags &= ~DF_OVERSOURCE;
	if( _cpCur > _cpMin && _cpCur < _cpMost )
	{
		_dwFlags |= DF_OVERSOURCE;
	}

	// Scroll if we need to and remember if we are in the hot zone.
	nScrollInset = W32->GetScrollInset();

	if (_pdrgcrt != NULL)
	{
		_pdrgcrt->HideCaret();
	}

	fHot = _ped->_pdp->AutoScroll(pt, nScrollInset, nScrollInset);

	if (_pdrgcrt != NULL)
	{
		if (((_dwFlags & DF_OVERSOURCE) == 0) && !fHot)
		{
			_pdrgcrt->ShowCaret();
		}
		else
		{
			// The hide above restored the caret so we just
			// need to turn off the caret while we are over the
			// source.
			_pdrgcrt->CancelRestoreCaretArea();
		}
	}

	// Let the client set the effect if it wants, but first, we need
	// to check for protection.

	if( _ped->IsRich() )
	{
		// we don't allow dropping onto protected text.  Note that
		// the _edges_ of a protected range may be dragged to; therefore,
		// we need to check for protection at _cpCur and _cpCur-1.
		// If both cp's are protected, then we are inside a protected
		// range.
		CTxtRange rg(_ped, _cpCur, 0);
		LONG iProt;

		if( (iProt = rg.IsProtected(1)) == CTxtRange::PROTECTED_YES || 
			iProt == CTxtRange::PROTECTED_ASK )
		{
		  	rg.Advance(-1);

			// if we're at the BOD or if the CF of the preceding cp
			// is PROTECTED
			if(!_cpCur || 
				(iProt = rg.IsProtected(-1)) == CTxtRange::PROTECTED_YES ||
				iProt == CTxtRange::PROTECTED_ASK)
			{
				// give the caller a chance to do something if the
				// ENM_PROTECTED mask is set.
				if( iProt == CTxtRange::PROTECTED_YES || 
					!_ped->IsProtectionCheckingEnabled() || 
					_ped->QueryUseProtection(&rg, WM_MOUSEMOVE,0, 0) )
				{ 
					*pdwEffect = DROPEFFECT_NONE;
					goto Exit;
				}
			}
		}
	}

	if( precall )
	{
		hr = precall->GetDragDropEffect(FALSE, grfKeyState, pdwEffect);
		// Note : RichEdit 1.0 does not check the return code of this call.
		// If callback specified a single effect, use it.
		// Otherwise pick one ourselves.

		// trick: (x & (x-1)) is non-zero if more than one bit is set.
		if (!(*pdwEffect & (*pdwEffect - 1) ))
		{
			goto Exit;
		}
	}
	
	// If we don't know anything about the data object or the control
	// is read-only, set the effect to none.
	// If the client is handling this, we don't worry about read-only.
	if (!(_dwFlags & DF_CLIENTCONTROL) &&
		 ( !(_dwFlags & DF_CANDROP) || _ped->TxGetReadOnly()))
	{
		*pdwEffect = DROPEFFECT_NONE;
		_cpCur = -1;
		// no need to do anything else
		return;
	}

	// if we are on top of the range that is being
	// dragged, then we can't drop there!
	if( _dwFlags & DF_OVERSOURCE )
	{
		*pdwEffect = DROPEFFECT_NONE;
		goto Exit;
	}


	// now check the keyboard state and the requested drop effects.

	if( (_dwFlags & DF_CANDROP) )
	{
		// if we can paste plain text, then see if a MOVE or COPY
		// operation was requested and set the right effect.  Note
		// that we prefer MOVEs over COPY's in accordance with OLE
		// UI guidelines.

		// we do not yet support linking
		if( (grfKeyState & MK_CONTROL) && (grfKeyState & MK_SHIFT) )
		{
			//COMPATIBILITY: Richedit 1.0 did not appear to support drag
			//linking correctly.
			*pdwEffect = DROPEFFECT_NONE;
		}
		else if( !(grfKeyState & MK_CONTROL) && 
			(*pdwEffect & DROPEFFECT_MOVE) )
		{
			// if the control key is *not* depressed, then assume a "move"
			// operation (note that shift and alt or no keys will also give
			// a move) iff the source supports move.

			*pdwEffect = DROPEFFECT_MOVE;
		}
		else if( (grfKeyState & MK_CONTROL) && !((grfKeyState & MK_ALT) &&
			(grfKeyState & MK_SHIFT)) && (*pdwEffect & DROPEFFECT_COPY) )
		{
			// if only the control key is down and we're allowed to do a copy,
			// then do a copy
			*pdwEffect = DROPEFFECT_COPY;
		}
		else if( !(grfKeyState & MK_CONTROL) && 
			(*pdwEffect & DROPEFFECT_COPY) )
		{
			// if the control key is *not* depressed, and we are *not* allowed
			// to do a move (note that this if comes below the second one), then
			// do a COPY operation (if available)
			*pdwEffect = DROPEFFECT_COPY;
		}
		else
		{
			// not a combination that we support
			*pdwEffect = DROPEFFECT_NONE;
		}
	}
	else
	{
		*pdwEffect = DROPEFFECT_NONE;
	}

Exit:	

	//Add the scrolling effect if we are in the hot zone.
	if (fHot)
	{
		*pdwEffect |= DROPEFFECT_SCROLL;
	}
}

/*
 *	CDropTarget::DrawFeedback
 *
 *	Purpose:
 *		draws any feeback necessary on the target side (specifically, setting the
 *		cursor
 *
 *	Notes:
 *		assumes _cpCur is correctly set.
 */

void CDropTarget::DrawFeedback(void)
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropTarget::DrawFeedback");

	if (_pdrgcrt != NULL)
	{
		// We need to indicate a drop location because a drop is possible
		_pdrgcrt->DrawCaret(_cpCur);
	}
}

/*
 *	CDropTarget::HandleRightMouseDrop
 *
 *	@mfunc	Handles calling back to the client to get a context menu 
 *			for a right-mouse drag drop.
 *
 *	@rdesc	HRESULT
 */
HRESULT CDropTarget::HandleRightMouseDrop(
	IDataObject *pdo,		//@parm the data object to drop
	POINTL ptl)				//@parm the location of the drop (screen coords)
{
	LPRICHEDITOLECALLBACK precall = NULL;
	CHARRANGE cr = {_cpCur, _cpCur};
	HMENU hmenu = NULL;
	HWND hwnd, hwndParent;

	precall = _ped->GetRECallback();

	if( !precall || _ped->Get10Mode() )
	{
		return S_FALSE;
	}

	// HACK ALERT! evil pointer casting going on here.
	precall->GetContextMenu( GCM_RIGHTMOUSEDROP, (IOleObject *)(void *)pdo, 
			&cr, &hmenu);

	if( hmenu && _ped->TxGetWindow(&hwnd) == NOERROR )
	{
		hwndParent = GetParent(hwnd);
		if( !hwndParent )
		{
			hwndParent = hwnd;
		}

		TrackPopupMenu(hmenu, TPM_LEFTALIGN | TPM_RIGHTBUTTON, 
			ptl.x, ptl.y, 0, hwndParent, NULL);

		return NOERROR;
	}
	
	return S_FALSE;
}

/*
 *	CDropCaret::DrawCaret
 *
 *	Purpose:
 *		Draws a "caret" to indicate where the drop will occur.
 *
 */

CDropCaret::CDropCaret(
	CTxtEdit *ped)			//@parm Edit control
		: _ped(ped), _yHeight(-1), _hdcWindow(NULL)
{
	// Header does all the work
}

/*
 *	CDropCaret::~CDropCaret
 *
 *	Purpose:
 *		Clean up caret object
 *
 */

CDropCaret::~CDropCaret()
{
	if (_hdcWindow != NULL)
	{
		// Restore the any updated window area
		HideCaret();

		// Free the DC we held on to
		_ped->_pdp->ReleaseDC(_hdcWindow);
	}
}

/*
 *	CDropCaret::Init
 *
 *	Purpose:
 *		Do initialization that can fail
 *
 */

BOOL CDropCaret::Init()
{
	// Get the DC for the window
	_hdcWindow = _ped->_pdp->GetDC();

	if (NULL == _hdcWindow)
	{
		// Could not get a DC, we are toast.
		AssertSz(FALSE, "CDropCaret::Init could not get hdc"); 
		return FALSE;
	}

	// Keep pixels per inch since we will need it
	_yPixelsPerInch = GetDeviceCaps(_hdcWindow, LOGPIXELSY);

	// Set the default maximum size
	_yHeightMax = DEFAULT_DROPCARET_MAXHEIGHT;

	// Preallocate a bitmap for saving screen
	return (_osdc.Init(
		_hdcWindow,
		WIDTH_DROPCARET,
		DEFAULT_DROPCARET_MAXHEIGHT,
		CLR_INVALID) != NULL);
}

/*
 *	CDropCaret::DrawCaret (cpCur)
 *
 *	@mfunc
 *		Draws a "caret" to indicate where the drop will occur.
 */
void CDropCaret::DrawCaret(
	LONG cpCur)				//@parm current cp of where drop would occur
{
	TRACEBEGIN(TRCSUBSYSDTE, TRCSCOPEINTERN, "CDropCaret::DrawCaret");

	CLock		lock;					// Uses global (shared) FontCache
	CDisplay *	pdp = _ped->_pdp;
	POINT		ptNew;
	RECT		rcClient;
	CLinePtr	rp(pdp);
	CRchTxtPtr	rtp(_ped, cpCur);

	// Restore old caret position bits and save new caret position bits
	HideCaret();

	// We no longer have a caret to restore
	_yHeight = -1;

	// Get new cp from point
	pdp->PointFromTp(rtp, NULL, FALSE, ptNew, &rp, TA_TOP | TA_LOGICAL);

	// Get client rectangle
	_ped->TxGetClientRect(&rcClient);
	
	// Figure out height of new caret

	// Get charformat
	const CCharFormat *pCF = rtp.GetCF();

	// Get zoomed height
	LONG dypInch = MulDiv(_yPixelsPerInch, pdp->GetZoomNumerator(), pdp->GetZoomDenominator());
	CCcs *pccs = fc().GetCcs(pCF, dypInch);

	if (NULL == pccs)
	{
		// We can't do anything sensible so give up.
		return;
	}

	// Convert height in charformat to height on screen
	LONG yHeight = pdp->LXtoDX(pCF->_yHeight);
	
	LONG yOffset, yAdjust;
	pccs->GetOffset(pCF, dypInch, &yOffset, &yAdjust);

	// Save new position
	ptNew.y += (rp->_yHeight - rp->_yDescent 
		+ pccs->_yDescent - yHeight - yOffset - yAdjust);

	// Release cache entry since we are done with it.
	pccs->Release();

	// Check if new point is in the client rectangle
	if(!PtInRect(&rcClient, ptNew))
		return;

	// Save new height
	_yHeight = yHeight;

	// Save the new caret position
	_ptCaret.x = ptNew.x;
	_ptCaret.y = ptNew.y;

	// Is current bit map big enough to hold the bit map we want to put in?
	if(yHeight > _yHeightMax)
	{
		// No - reallocate the bitmap.
		if(!_osdc.Realloc(WIDTH_DROPCARET, yHeight))
		{
			// Reallocation failed - no visual feedback for now
			AssertSz(FALSE, "CDropCaret::DrawCaret bitmap reallocation failed");
			return;
		}
		_yHeightMax = yHeight;
	}

	// Save bits at new caret position
	_osdc.Get(_hdcWindow, _ptCaret.x, _ptCaret.y, WIDTH_DROPCARET, yHeight);

	// Actually put caret on screen
	ShowCaret();
}


/*
 *	CDropCaret::ShowCaret
 *
 *	Purpose:
 *		Actually draw caret on the screen
 *
 */

void CDropCaret::ShowCaret()
{
#if defined(DEBUG) || defined(_RELEASE_ASSERTS_)
	BOOL fSuccess;
#endif // DEBUG

	// Don't show the caret if the height says that there is no caret to show.
	if (-1 == _yHeight)
	{
		return;
	}

	// Create a pen
	HPEN hPenCaret = CreatePen(PS_SOLID, WIDTH_DROPCARET, 0);

	if (NULL == hPenCaret)
	{
		// Call failed, this isn't really catastrophic so just don't
		// draw the caret.
		AssertSz(FALSE, "CDropCaret::DrawCaret could not create pen");
		return;
	}

	// Put the dotted pen in the DC
	HPEN hPenOld = (HPEN) SelectObject(_hdcWindow, hPenCaret);
														   
	if (NULL == hPenOld)
	{
		// Call failed, this isn't really catastrophic so just don't
		// draw the caret.
		AssertSz(FALSE, "CDropCaret::DrawCaret SelectObject failed");
		goto DeleteObject;
	}

	// Move the drawing pen to where to draw the caret
#if defined(DEBUG) || defined(_RELEASE_ASSERTS_)
	fSuccess =
#endif // DEBUG

	MoveToEx(_hdcWindow, _ptCaret.x, _ptCaret.y, NULL);

	AssertSz(fSuccess, "CDropCaret::DrawCaret MoveToEx failed");

	// Draw the line
#if defined(DEBUG) || defined(_RELEASE_ASSERTS_)
	fSuccess =
#endif // DEBUG

	LineTo(_hdcWindow, _ptCaret.x, _ptCaret.y + _yHeight);

	AssertSz(fSuccess, "CDropCaret::DrawCaret LineTo failed");

	// Restore the current pen
#if defined(DEBUG) || defined(_RELEASE_ASSERTS_)
	hPenCaret = (HPEN)
#endif // DEBUG

	SelectObject(_hdcWindow, hPenOld);

	AssertSz(hPenCaret != NULL, 
		"CDropCaret::DrawCaret Restore Original Pen failed");

DeleteObject:

	// Dump the pen
#if defined(DEBUG) || defined(_RELEASE_ASSERTS_)
	fSuccess =
#endif // DEBUG

	DeleteObject(hPenCaret);

	AssertSz(fSuccess, 
		"CDropCaret::DrawCaret Could not delete dotted Pen");
}

/*
 *	CDropCaret::HideCaret
 *
 *	Purpose:
 *		Restore caret area after cursor has moved
 *
 */
void CDropCaret::HideCaret()
{
	if (_yHeight != -1)
	{
		_osdc.RenderBitMap(_hdcWindow, _ptCaret.x, _ptCaret.y, WIDTH_DROPCARET, 
			_yHeight);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\richedit\re30\dispml.cpp ===
/*  
 *	@doc INTERNAL
 *
 *	@module	DISPML.CPP -- CDisplayML class |
 *
 *		This is the Multi-line display engine.  See disp.c for the base class
 *		methods and dispsl.c for the single-line display engine.
 *	
 *	Owner:<nl>
 *		RichEdit 1.0 code: David R. Fulmer
 *		Christian Fortini (initial conversion to C++)
 *		Murray Sargent
 *		Rick Sailor (for most of RE 2.0)
 *
 *	Copyright (c) 1995-1998, Microsoft Corporation. All rights reserved.
 */

#include "_common.h"
#include "_dispml.h"
#include "_edit.h"
#include "_font.h"
#include "_measure.h"
#include "_render.h"
#include "_select.h"
#include "_dfreeze.h"

/*
#include "icecap.h"

class CCapProfile
{
public:
	CCapProfile() { StartProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID); }
	~CCapProfile() { StopProfile(PROFILE_THREADLEVEL, PROFILE_CURRENTID); }
};
*/
ASSERTDATA

//
//	Invariant support
//
#define DEBUG_CLASSNAME	CDisplayML
#include "_invar.h"

// Timer tick counts for background task
#define cmsecBgndInterval 	300
#define cmsecBgndBusy 		100

// Lines ahead
const LONG cExtraBeforeLazy = 60;

// If we need to calc at least this many characters, then put up a wait
// cursor.  NB!  4096 is not a measured number; it just seemed like a good
// one.
#define NUMCHARFORWAITCURSOR	4096	

#ifndef DEBUG
#define CheckView()
#define	CheckLineArray()
#endif
	

// ===========================  CDisplayML  =====================================================

#ifdef DEBUG
/*
 *	CDisplayML::Invariant
 *
 *	@mfunc	Make sure the display is in a valid state
 *
 *	@rdesc	TRUE if the tests succeeded, FALSE otherwise
 */
BOOL CDisplayML::Invariant(void) const
{
	CDisplay::Invariant();

	return TRUE;
}
#endif // DEBUG

/*
 *	CDisplayML::CalcScrollHeight()
 *
 *	@mfunc	
 *		Calculate the maximum Y scroll position.
 *
 *	@rdesc
 *		Maximum possible scrolling position
 *
 *	@devnote
 *		This routine exists because plain text controls do not have
 *		the auto-EOP and so the scroll height is different than
 *		the height of the control if the text ends in an EOP type
 *		character.
 */
LONG CDisplayML::CalcScrollHeight(LONG yHeight) const
{
	// The max scroll height for plain text controls is calculated
	// differently because they don't have an automatic EOP character.
	if(!_ped->IsRich() && Count())
	{
		// If last character is an EOP, bump scroll height
		CLine *lp = Elem(Count() - 1);	// Get last line in array
		if(lp->_cchEOP)
			yHeight += lp->GetHeight();
	}
	return yHeight;
}

/*
 *	CDisplayML::GetMaxYScroll()
 *
 *	@mfunc	
 *		Calculate the maximum Y scroll position.
 *
 *	@rdesc
 *		Maximum possible scrolling position
 *
 *	@devnote
 *		This routine exists because we may have to come back and modify this 
 *		calculation for 1.0 compatibility. If we do, this routine only needs
 *		to be changed in one place rather than the three at which it is used.
 *
 */
inline LONG CDisplayML::GetMaxYScroll() const
{
	// The following code is turn off because we don't want to support 
	// 1.0 mode unless someone complained about it.  
#if 0		
 	if (_ped->Get10Mode())
	{
		// Ensure last line is always visible
		// (use dy as temp to calculate max scroll)
		yScroll = Elem(max(0, Count() - 1))->_yHeight;

		if(yScroll > _yHeightView)
			yScroll = _yHeightView;

		yScroll = _yHeight - yScroll;
	}
#endif //0

	return CalcScrollHeight(_yHeight);
}

/*
 *	CDisplayML::ConvertScrollToYPos()
 *
 *	@mfunc	
 *		Calculate the real scroll position from the scroll position
 *
 *	@rdesc
 *		Y position from scroll
 *
 *	@devnote
 *		This routine exists because the thumb position messages
 *		are limited to 16-bits so we extrapolate when the Y position
 *		gets greater than that.
 */
LONG CDisplayML::ConvertScrollToYPos(
	LONG yPos)		//@parm Scroll position 
{
	// Get maximum scroll range
	LONG yRange = GetMaxYScroll();

	// Has maximum scroll range exceeded 16-bits?
	if(yRange >= _UI16_MAX)
	{
		// Yes - Extrapolate to "real" yPos		
		yPos = MulDiv(yPos, yRange, _UI16_MAX);
	}
	return yPos;
}

/*
 *	CDisplayML::ConvertYPosToScrollPos()
 *
 *	@mfunc	
 *		Calculate the scroll position from the Y position in the document.
 *
 *	@rdesc
 *		Scroll position from Y position
 *
 *	@devnote
 *		This routine exists because the thumb position messages
 *		are limited to 16-bits so we extrapolate when the Y position
 *		gets greater than that.
 *
 */
inline LONG CDisplayML::ConvertYPosToScrollPos(
	LONG yPos)		//@parm Y position in document
{
	// Get maximum scroll range
	LONG yRange = GetMaxYScroll();

	// Has maximum scroll range exceeded 16-bits?
	if(yRange >= _UI16_MAX)
	{
		// Yes - Extrapolate to "real" yPos		
		yPos = MulDiv(yPos, _UI16_MAX, yRange);
	}
	return yPos;
}

CDisplayML::CDisplayML (CTxtEdit* ped)
  : CDisplay (ped), _pddTarget(NULL)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::CDisplayML");

	Assert(!_xWidthMax && !_yHeightMax);

	_fMultiLine = TRUE;
}

CDisplayML::~CDisplayML()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::~CDisplayML");

	delete _pddTarget;
}

/*
 *	CDisplayML::Init()
 *
 *	@mfunc	
 *		Init this display for the screen
 *
 *	@rdesc
 *		TRUE iff initialization succeeded
 */
BOOL CDisplayML::Init()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::Init");

	// Initialize our base class
	if(!CDisplay::Init())
		return FALSE;

	AssertSz(_ped, "CDisplayML::Init(): _ped not initialized in display");
	// Verify allocation zeroed memory out
	Assert(!_yCalcMax && !_xWidth && !_yHeight && !_cpMin);
	Assert(!_fBgndRecalc && !_fVScrollEnabled && !_fHScrollEnabled);

	// The printer view is not main, therefore we do this to make
	// sure scroll bars are not created for print views.
	DWORD dwScrollBars = _ped->TxGetScrollBars();

	if(IsMain() && (dwScrollBars & ES_DISABLENOSCROLL))
	{
		if(dwScrollBars & WS_VSCROLL)
		{
			// This causes wlm to assert on the mac. something about 
			// scrollbar being disabled
			_ped->TxSetScrollRange (SB_VERT, 0, 1, TRUE);
			_ped->TxEnableScrollBar(SB_VERT, ESB_DISABLE_BOTH);
		}

		// Set horizontal scroll range and pos
		// ??? - CF need fixing for windowless case
		if(dwScrollBars & WS_HSCROLL) 
		{
			_ped->TxSetScrollRange (SB_HORZ, 0, 1, TRUE);
			_ped->TxEnableScrollBar(SB_HORZ, ESB_DISABLE_BOTH);
		}
	}

	SetWordWrap(_ped->TxGetWordWrap());
	_cpFirstVisible = _cpMin;
	
	Assert(!_xScroll && !_yScroll && !_iliFirstVisible &&
		   !_cpFirstVisible && !_dyFirstVisible);

    _TEST_INVARIANT_

	return TRUE;
}


//================================  Device drivers  ===================================
/*
 *	CDisplayML::SetMainTargetDC(hdc, xWidthMax)
 *
 *	@mfunc
 *		Sets a target device for this display and updates view 
 *
 *	@devnote
 *		Target device can't be a metafile (can get char width out of a 
 *		metafile)
 *
 *	@rdesc
 *		TRUE if success
 */
BOOL CDisplayML::SetMainTargetDC (
	HDC hdc,			//@parm Target DC, NULL for same as rendering device
	LONG xWidthMax)		//@parm Max line width (not used for screen)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::SetMainTargetDC");

	if(SetTargetDC(hdc))
	{
		// This is here because this is what RE 1.0 did. 
		SetWordWrap(hdc || !xWidthMax);

		// If xWidthMax is greater than zero, then the caller is
		// trying to set the maximum width of the window (for measuring,
		// line breaking, etc.)  However,in order to make our measuring
		// algorithms more reasonable, we force the max size to be
		// *at least* as wide as the width of a character.
		// Note that xWidthMax = 0 means use the view rect width
		_xWidthMax = (xWidthMax <= 0) ? 0 : max(DXtoLX(GetXWidthSys()), 
												xWidthMax);
		// Need to do a full recalc. If it fails, it fails, the lines are
		// left in a reasonable state. No need to call WaitForRecalc()
		// because UpdateView() starts at position zero and we're always
		// calc'd up to there
		CDisplay::UpdateView();

		// Caret/selection has most likely moved
		CTxtSelection *psel = _ped->GetSelNC();
		if(psel) 
			psel->UpdateCaret(FALSE);
		return TRUE;
	}
	return FALSE;
}

// Useful for both main and printing devices. jonmat 6/08/1995
BOOL CDisplayML::SetTargetDC( HDC hdc, LONG dxpInch, LONG dypInch)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::SetTargetDC");

	CDevDesc *pddTarget = NULL;

	// Don't allow metafiles to be set as the target device
	if(hdc && GetDeviceCaps(hdc, TECHNOLOGY) == DT_METAFILE)
		return FALSE;

	if(hdc)
	{
		// Allocate device first to see if we can. We don't want to change
		// our state if this is going to fail.
		pddTarget = new CDevDesc(_ped);
		if(!pddTarget)
			return FALSE;				// We couldn't so we are done
	}

	// Remove any cached information for the old target device
	if(_pddTarget)
	{
		delete _pddTarget;
		_pddTarget = NULL;
	}
	if(hdc)
	{
		_pddTarget = pddTarget;			// Update device because we have one
		_pddTarget->SetDC(hdc, dxpInch, dypInch);
	}
	return TRUE;
}

//=================================  Line recalc  ==============================
/*
 *	CDisplayML::RecalcScrollBars()
 *
 *	@mfunc
 *		Recalculate the scroll bars if the view has changed.
 *
 *
 *	@devnote	There is a possibility of recursion here, so we
 *				need to protect ourselves.
 *
 *	To visualize this, consider two types of characters, 'a' characters 
 *	which are small in height and 'A' 's which are really tall, but the same 
 *	width as an 'a'. So if I have
 *
 *	a a A						<nl>
 *	A							<nl>
 *
 *	I'll get a calced size that's basically 2 * heightof(A).
 *	With a scrollbar, this could wordwrap to 
 *
 *	a a							<nl>
 *	A A							<nl>
 *
 *	which is of calced size heightof(A) + heightof(a); this is
 *	obviously less than the height in the first case.
 */
void CDisplayML::RecalcScrollBars()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::RecalcScrollBars");

	if(_fViewChanged)
	{
  		_fViewChanged = FALSE;
		UpdateScrollBar(SB_VERT, TRUE);
    	UpdateScrollBar(SB_HORZ, TRUE);
    }
}

/*
 *	CDisplayML::RecalcLines(fWait)
 *
 *	@mfunc
 *		Recalc all line breaks. 
 *		This method does a lazy calc after the last visible line
 *		except for a bottomless control
 *
 *	@rdesc
 *		TRUE if success
 */
BOOL CDisplayML::RecalcLines (
	BOOL fWait)		//@parm Recalc lines down to _cpWait/_yWait; then be lazy
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::RecalcLines");

	LONG		cliWait = cExtraBeforeLazy;			// Extra lines before being lazy
	BOOL		fDone = TRUE;
	BOOL		fFirstInPara = TRUE;
	CLine *		pliNew = NULL;
	LONG		xWidth;
	LONG		yHeight = 0;
    LONG        cchText = _ped->GetTextLength();
	BOOL		fWaitingForFirstVisible = TRUE;
	LONG		yHeightView = _yHeightView;
	LONG		yHeightScrollOld = GetMaxYScroll();
	LONG		yHeightScrollNew;

	Remove(0, -1);							// Remove all old lines from *this
	_yCalcMax = 0;							// Set both maxes to start of text
	_cpCalcMax = 0;

	// Don't stop at bottom of view if we're bottomless and active
	if(!_ped->TxGetAutoSize() && IsActive())
	{
		// Be lazy - don't bother going past visible portion
		_cpWait = -1;
		_yWait = -1;
		fWait = TRUE;
	}

	// Init measurer at cp = 0
	CMeasurer me(this);
	me.SetNumber(0);
 	
	// The following loop generates new lines
	while(me.GetCp() < cchText)
	{
		// Add one new line
		pliNew = Add(1, NULL);
		if (!pliNew)
		{
			_ped->GetCallMgr()->SetOutOfMemory();
			TRACEWARNSZ("Out of memory Recalc'ing lines");
			goto err;
		}

		// Stuff text into new line
		UINT uiFlags = MEASURE_BREAKATWORD | 
						(fFirstInPara ? MEASURE_FIRSTINPARA : 0);

    	Tracef(TRCSEVINFO, "Measuring new line from cp = %d", me.GetCp());

		if(!pliNew->Measure(me, -1, -1, uiFlags))
		{
			Assert(FALSE);
			goto err;
		}

		fFirstInPara = pliNew->_bFlags & fliHasEOP;
		yHeight += pliNew->GetHeight();
		_cpCalcMax = me.GetCp();

		if(fWait)
		{
			// Do we want to do a background recalc? - the answer is yes if
			// three things are true: (1) We have recalc'd beyond the old first
			// visible character, (2) We have recalc'd beyond the visible 
			// portion of the screen and (3) we have gone beyond the next
			// cExtraBeforeLazy lines to make page down go faster.

			if(fWaitingForFirstVisible)
			{
				if(me.GetCp() > _cpFirstVisible)
				{
					_yWait = yHeight + yHeightView;
					fWaitingForFirstVisible = FALSE;
				}
			}
			else if(yHeight > _yWait && cliWait-- <= 0)
			{
				fDone = FALSE;
				break;
			}
		}
	}

	_yCalcMax = yHeight;
	_fRecalcDone = fDone;
    _fNeedRecalc = FALSE;
	yHeightScrollNew = CalcScrollHeight(yHeight);

	if(fDone && (yHeight != _yHeight || yHeightScrollNew != yHeightScrollOld)
		|| yHeightScrollNew > yHeightScrollOld)
	{
		_fViewChanged = TRUE;
	}

	_yHeight = yHeight;
	xWidth = CalcDisplayWidth();
    if(fDone && xWidth != _xWidth || xWidth > _xWidth)
    {
        _xWidth = xWidth;
		_fViewChanged = TRUE;
    }    

	Tracef(TRCSEVINFO, "CDisplayML::RecalcLine() - Done. Recalced down to line #%d", Count());

	if(!fDone)						// if not done, do rest in background
		fDone = StartBackgroundRecalc();

	if(fDone)
	{
		_yWait = -1;
		_cpWait = -1;
		CheckLineArray();
		_fLineRecalcErr = FALSE;
	}

#ifdef DEBUG
	if( 1 )
    {
		_TEST_INVARIANT_
	}
	//Array memory allocation tracking
	{
	void **pv = (void**)((char*)this + sizeof(CDisplay));
	PvSet(*pv);
	}
#endif

	return TRUE;

err:
	TRACEERRORSZ("CDisplayML::RecalcLines() failed");

	if(!_fLineRecalcErr)
	{
		_cpCalcMax = me.GetCp();
		_yCalcMax = yHeight;
		_fLineRecalcErr = TRUE;
		_ped->GetCallMgr()->SetOutOfMemory();
		_fLineRecalcErr = FALSE;			//  fix up CArray & bail
	}
	return FALSE;
}

/*
 *	CDisplayML::RecalcLines(rtp, cchOld, cchNew, fBackground, fWait, pled)
 *
 *	@mfunc
 *		Recompute line breaks after text modification
 *
 *	@rdesc
 *		TRUE if success
 *
 *	@devnote
 *		Most people call this the trickiest piece of code in RichEdit...
 */						     
BOOL CDisplayML::RecalcLines (
	const CRchTxtPtr &rtp,	//@parm Where change happened
	LONG cchOld,			//@parm Count of chars deleted
	LONG cchNew,			//@parm Count of chars added
	BOOL fBackground,		//@parm This method called as background process
	BOOL fWait,				//@parm Recalc lines down to _cpWait/_yWait; then be lazy
	CLed *pled)				//@parm Returns edit impact on lines (can be NULL)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::RecalcLines");

	LONG		cchEdit;
	LONG		cchSkip;
	LONG		cliBackedUp = 0;
	LONG		cliWait = cExtraBeforeLazy;	
	BOOL		fDone = TRUE;
	BOOL		fFirstInPara = TRUE;
	LONG		ili;
	CLed		led;
	LONG		lT;							// long Temporary
	CLine *		pliNew;
	CLinePtr	rpOld(this);
	LONG		xWidth;
	LONG		yHeight;
	LONG		yHeightPrev = 0;
    LONG        cchText = _ped->GetTextLength();
    UINT        uiFlags;
	BOOL 		fReplaceResult;
	BOOL		fTryForMatch = TRUE;
	LONG		yHeightScrollOld = GetMaxYScroll();
	LONG		yHeightScrollNew;
	WORD		wNumber = 0;
	CLineArray	rgliNew;
	DWORD		dwBgndTickMax = fBackground ? GetTickCount() + cmsecBgndBusy : 0;

	if(!pled)
		pled = &led;

#if defined(DEBUG) || defined(_RELEASE_ASSERTS_)
	LONG cp = rtp.GetCp();

	if(cp > _cpCalcMax)
		Tracef(TRCSEVERR, "rtp %ld, _cpCalcMax %ld", cp, _cpCalcMax);

	AssertSz(cp <= _cpCalcMax, 
		"CDisplayML::RecalcLines Caller didn't setup RecalcLines()");

	AssertSz(!(fWait && fBackground),
		"CDisplayML::RecalcLines wait and background both true");

	AssertSz(!(fWait && (-1 == _cpWait) && (-1 == _yWait)),
		"CDisplayML::RecalcLines background recalc parms invalid");
#endif

	// We will not use background recalc if this is already a background recalc,
	// or if the control is not active or if this is an auto sized control.
	if(!IsActive() || _ped->TxGetAutoSize())
		fWait = FALSE;

	// Init line pointer on old CLineArray and backup to start of line
	rpOld.RpSetCp(rtp.GetCp(), FALSE);
	cchSkip = rpOld.RpGetIch();
	rpOld.RpAdvanceCp(-cchSkip);			// Point rp at 1st char in line

	ili = rpOld;							// Save line # at change for
	if(ili && (IsInOutlineView() ||			//  numbering. Back up if not
		rtp.GetPF()->IsListNumbered()))		//  first number in list or if
	{										//  in OutlineView (Outline
		ili--;								//  symbol may change)
	}

	// Back up at least one line in case we can now fit more on it
	// If on a line border, e.g., just inserted an EOP, backup 2; else 1
	lT = !cchSkip + 1;

	while(lT-- > 0 && rpOld > 0 && (!rpOld[-1]._cchEOP || ili < rpOld))
	{
		cliBackedUp++;
		rpOld--;
		cchSkip += rpOld->_cch;
	}

	// Init measurer at rtp
	CMeasurer me(this, rtp);

	me.Advance(-cchSkip);					// Point at start of text to measure
	cchEdit = cchNew + cchSkip;				// Number of chars affected by edit
	me.SetNumber(rpOld.GetNumber());		// Initialize list number
	
	// Determine whether we're on first line of paragraph
	if(rpOld > 0)
	{
		fFirstInPara = rpOld[-1]._bFlags & fliHasEOP;
	}

	yHeight = YposFromLine(rpOld);

	// Update first-affected and pre-edit-match lines in pled
	pled->_iliFirst = rpOld;
	pled->_cpFirst	= pled->_cpMatchOld	= me.GetCp();
	pled->_yFirst	= pled->_yMatchOld	= yHeight;
	AssertSz(pled->_yFirst >= 0, "CDisplayML::RecalcLines _yFirst < 0");
	
	Tracef(TRCSEVINFO, "Start recalcing from line #%d, cp=%d", pled->_iliFirst, pled->_cpFirst);

	// In case of error, set both maxes to where we are now
	_yCalcMax = yHeight;
	_cpCalcMax = me.GetCp();

	// If we are past the requested area to recalc and background recalc is
	// allowed, then just go directly to background recalc. If there is no
	// height, we just go a head and calculate some lines anyway. This
	// prevents any weird background recalcs from occuring when it is
	// unnecessary to go into background recalc.
	if(fWait && _yWait > 0 && yHeight > _yWait && me.GetCp() > _cpWait)
	{
		_yHeight = yHeight;
		rpOld.Remove(-1);	// Remove all old lines from here on
		StartBackgroundRecalc();		// Start up the background recalc		
		pled->SetMax(this);
		return TRUE;
	}

    pliNew = NULL;

	// The following loop generates new lines for each line we backed
	// up over and for lines directly affected by edit
	while(cchEdit > 0)
	{
		pliNew = rgliNew.Add(1, NULL);		// Add one new line
		if (!pliNew)
		{
			TRACEWARNSZ("CDisplayML::RecalcLines unable to alloc additional CLine in CLineArray");
			goto errspace;
		}

		// Can't reuse old results if we've got a target device
		// For SPEED: it'd be nice to cache a few values when we do have a
		// target device - a good caching heuristic could halve the measuring
		const LONG cchNonWhite = rpOld.IsValid()
							   ? rpOld->_cch - rpOld->_cchWhite
							   : 0;
		uiFlags = MEASURE_BREAKATWORD | (fFirstInPara ? MEASURE_FIRSTINPARA : 0);

		if (cchSkip > 0 && cchSkip >= cchNonWhite && !IsInOutlineView() && 
			!_ped->fUseLineServices() && (!_pddTarget || !_pddTarget->IsValid()))
		{
			me.NewLine(*rpOld);				// Don't remeasure anything we
			me.Advance(cchNonWhite);		//  already have valid info on
			me._li._cch = cchNonWhite;
			me._li._xWidth = rpOld->_xWidth;

			// Clear out any of the old flags _except_ for tabs and OLE or
			// OffScreen. Note that this algorithm is somewhat bogus; there 
			// is no guarantee that the line still matches the flag state.  
			// However,those flags are simply 'hints'--i.e. the line _may_ 
			// be in that state.  Keeping those flags set will result
			// in a minor slowdown for rendering the line.
			me._li._bFlags &= (fliHasTabs | fliHasOle | fliUseOffScreenDC | fliHasSpecialChars);

			if(rpOld->_bFlags & fliOffScreenOnce)
				me._li._bFlags &= ~fliUseOffScreenDC;
			me._li._cchEOP = 0;
			uiFlags |= MEASURE_DONTINIT;	// CLine part of me already init'd
		}

		// Stuff text into new line
    	Tracef(TRCSEVINFO, "Measuring new line from cp = %d", me.GetCp());

		if(!pliNew->Measure(me, -1, -1, uiFlags))
		{
			Assert(FALSE);
			goto err;
		}

		if(!pliNew->_cch)
		{
			TRACEWARNSZ(
           "CDisplayML::RecalcLines measure returned a zero length line");
			goto errspace;
		}

		fFirstInPara = pliNew->_bFlags & fliHasEOP;
		yHeightPrev	 = yHeight;
		yHeight		+= pliNew->GetHeight();
		cchEdit		-= pliNew->_cch;
		AssertSz(cchEdit + me.GetCp() <= cchText,
			"CDisplayML::RecalcLines: want to measure beyond EOD");

		// Calculate on what line the edit started. We do this because
		// we want to render the first edited line off screen so if
		// the line is being edited via the keyboard we don't clip
		// any characters.
		if(cchSkip > 0)
		{
			// Check whether we backed up and the line we are examining
			// changed at all. Even if it didn't change in outline view
			// have to redraw in case outline symbol changes
			if (cliBackedUp && cchSkip >= pliNew->_cch && 
				pliNew->IsEqual(*rpOld) && !IsInOutlineView())
			{
				// Perfect match, this line was not the first edited.
               	Tracef(TRCSEVINFO, "New line matched old line #%d", (LONG)rpOld);

				cchSkip -= rpOld->_cch;

				// Update first affected line and match in pled
				pled->_iliFirst++;
				pled->_cpFirst	  += rpOld->_cch;
				pled->_cpMatchOld += rpOld->_cch;
				pled->_yFirst	  += rpOld->GetHeight();
				AssertSz(pled->_yFirst >= 0, "CDisplayML::RecalcLines _yFirst < 0");
				pled->_yMatchOld  += rpOld->GetHeight();
				cliBackedUp--;
			
				rgliNew.Clear(AF_KEEPMEM);		// Discard new line
				if(!(rpOld++))					// Next line
					cchSkip = 0;
			}
			else								// No match in the line, so 
				cchSkip = 0;					//  this line is the first to
		}										//  be edited

		if(fBackground && GetTickCount() >= dwBgndTickMax)
		{
			fDone = FALSE;						// took too long, stop for now
			goto no_match;
		}

		if (fWait && yHeight > _yWait && me.GetCp() > _cpWait &&
			cliWait-- <= 0)
		{
			// Not really done, just past region we're waiting for
			// so let background recalc take it from here
			fDone = FALSE;
			goto no_match;
		}
	}											// while(cchEdit > 0) { }

   	Tracef(TRCSEVINFO, "Done recalcing edited text. Created %d new lines", rgliNew.Count());

	// Edit lines have been exhausted.  Continue breaking lines,
	// but try to match new & old breaks

	wNumber = me._wNumber;
	while(me.GetCp() < cchText)
	{
		// Assume there are no matches to try for
		BOOL frpOldValid = FALSE;

		// If we run out of runs, then no match is possible. Therefore, 
		// we only try for a match as long as we have runs.
		if(fTryForMatch)
		{
			// We are trying for a match so assume that there
			// is a match after all
			frpOldValid = TRUE;

			// Look for match in old line break CArray
			lT = me.GetCp() - cchNew + cchOld;
			while (rpOld.IsValid() && pled->_cpMatchOld < lT)
			{
				pled->_yMatchOld  += rpOld->GetHeight();
				pled->_cpMatchOld += rpOld->_cch;

				if(!rpOld.NextRun())
				{
					// No more line array entries so we can give up on
					// trying to match for good.
					fTryForMatch = FALSE;
					frpOldValid = FALSE;
					break;
				}
			} 
		}

		// If perfect match, stop.
		if (frpOldValid && rpOld.IsValid() && pled->_cpMatchOld == lT && 
			rpOld->_cch && me._wNumber == rpOld->_bNumber)
		{
           	Tracef(TRCSEVINFO, "Found match with old line #%d", rpOld.GetLineIndex());

			// Update fliFirstInPara flag in 1st old line that matches.  Note
			// that if the new array doesn't have any lines, we have to look
			// into the line array preceding the current change.
			rpOld->_bFlags |= fliFirstInPara;
			if(rgliNew.Count() > 0) 
			{
				if(!(rgliNew.Elem(rgliNew.Count() - 1)->_bFlags & fliHasEOP))
					rpOld->_bFlags &= ~fliFirstInPara;
			}
			else if( rpOld >= pled->_iliFirst && pled->_iliFirst )
			{
				if(!(rpOld[pled->_iliFirst - rpOld -1]._bFlags & fliHasEOP))
					rpOld->_bFlags &= ~fliFirstInPara;
			}

			pled->_iliMatchOld = rpOld;

			// Replace old lines by new ones
			lT = rpOld - pled->_iliFirst;
			rpOld = pled->_iliFirst;
			if(!rpOld.Replace (lT, &rgliNew))
			{
				TRACEWARNSZ("CDisplayML::RecalcLines unable to alloc additional CLines in rpOld");
				goto errspace;
			}
			frpOldValid = rpOld.ChgRun(rgliNew.Count());
			rgliNew.Clear(AF_KEEPMEM);	 		// Clear aux array

			// Remember information about match after editing
			Assert((cp = rpOld.CalculateCp()) == me.GetCp());
			pled->_yMatchNew	= yHeight;
			pled->_yMatchNewTop = yHeightPrev;
			pled->_iliMatchNew	= rpOld;
			pled->_cpMatchNew	= me.GetCp();

			// Compute height and cp after all matches
			_cpCalcMax = me.GetCp();

			if(frpOldValid && rpOld.IsValid())
			{
				do
				{
					yHeight	   += rpOld->GetHeight();
					_cpCalcMax += rpOld->_cch;
				}
				while( rpOld.NextRun() );
			}

			// Make sure _cpCalcMax is sane after the above update
			AssertSz(_cpCalcMax <= cchText, 
				"CDisplayML::RecalcLines match extends beyond EOF");

			// We stop calculating here.Note that if _cpCalcMax < size 
			// of text, this means a background recalc is in progress.
			// We will let that background recalc get the arrays
			// fully in sync.  

			AssertSz(_cpCalcMax == cchText || _fBgndRecalc,
					"CDisplayML::Match less but no background recalc");

			if(_cpCalcMax != cchText)
			{
				// This is going to be finished by the background recalc
				// so set the done flag appropriately.
				fDone = FALSE;
			}
			goto match;
		}

		// Add a new line
		pliNew = rgliNew.Add(1, NULL);
		if(!pliNew)
		{
			TRACEWARNSZ("CDisplayML::RecalcLines unable to alloc additional CLine in CLineArray");
			goto errspace;
		}

    	Tracef(TRCSEVINFO, "Measuring new line from cp = %d", me.GetCp());

		// Stuff some text into new line
		wNumber = me._wNumber;
		if(!pliNew->Measure(me, -1, -1, MEASURE_BREAKATWORD | 
							(fFirstInPara ? MEASURE_FIRSTINPARA : 0)))
		{
			Assert(FALSE);
			goto err;
		}
		
		fFirstInPara = pliNew->_bFlags & fliHasEOP;
		yHeight += pliNew->GetHeight();

		if(fBackground && GetTickCount() >= (DWORD)dwBgndTickMax)
		{
			fDone = FALSE;			// Took too long, stop for now
			break;
		}

		if(fWait && yHeight > _yWait && me.GetCp() > _cpWait
			&& cliWait-- <= 0)
		{							// Not really done, just past region we're
			fDone = FALSE;			//  waiting for so let background recalc
			break;					//  take it from here
		}
	}								// while(me < cchText) ...

no_match:
	// Didn't find match: whole line array from _iliFirst needs to be changed
	pled->_iliMatchOld	= Count(); 
	pled->_cpMatchOld	= cchText;
	pled->_yMatchNew	= yHeight;
	pled->_yMatchNewTop = yHeightPrev;
	pled->_yMatchOld	= _yHeight;
	_cpCalcMax			= me.GetCp();

	// Replace old lines by new ones
	rpOld = pled->_iliFirst;

	// We store the result from the replace because although it can fail the 
	// fields used for first visible must be set to something sensible whether 
	// the replace fails or not. Further, the setting up of the first visible 
	// fields must happen after the Replace because the lines could have 
	// changed in length which in turns means that the first visible position
	// has failed.

	fReplaceResult = rpOld.Replace(-1, &rgliNew);

	// _iliMatchNew & _cpMatchNew are used for first visible constants so we
	// need to set them to something reasonable. In particular the rendering
	// logic expects _cpMatchNew to be set to the first character of the first
	// visible line. rpOld is used because it is convenient.

	// Note we can't use RpBindToCp at this point because the first visible
	// information is messed up because we may have changed the line that
	// the first visible cp is on. 
	rpOld.BindToCp(me.GetCp());
	pled->_iliMatchNew = rpOld.GetLineIndex();
	pled->_cpMatchNew = me.GetCp() - rpOld.RpGetIch();

	if (!fReplaceResult)
	{
		TRACEERRORSZ("CDisplayML::RecalcLines rpOld.Replace() failed");
		goto errspace;
	}

    // Adjust first affected line if this line is gone
    // after replacing by new lines
    if(pled->_iliFirst >= Count() && Count() > 0)
    {
        Assert(pled->_iliFirst == Count());
        pled->_iliFirst = Count() - 1;
		pliNew = Elem(pled->_iliFirst);
        pled->_yFirst -= pliNew->GetHeight();
		AssertSz(pled->_yFirst >= 0, "CDisplayML::RecalcLines _yFirst < 0");
        pled->_cpFirst -= pliNew->_cch;
    }
    
match:
	_fRecalcDone = fDone;
    _fNeedRecalc = FALSE;
	_yCalcMax = yHeight;

	Tracef(TRCSEVINFO, "CDisplayML::RecalcLine(rtp, ...) - Done. Recalced down to line #%d", Count() - 1);

	// Clear wait fields since we want caller's to set them up.
	_yWait = -1;
	_cpWait = -1;

	if(fDone && fBackground)
	{
		TRACEINFOSZ("Background line recalc done");
		_ped->TxKillTimer(RETID_BGND_RECALC);
		_fBgndRecalc = FALSE;
		_fRecalcDone = TRUE;
	}

	// Determine display height and update scrollbar
	yHeightScrollNew = CalcScrollHeight(yHeight);

	if (_fViewChanged ||
		fDone && (yHeight != _yHeight || yHeightScrollNew != yHeightScrollOld)
		|| yHeightScrollNew > yHeightScrollOld) 
	{
	    //!NOTE:
	    // UpdateScrollBar can cause a resize of the window by hiding or showing
	    // scrollbars.  As a consequence of resizing the lines may get recalculated
	    // therefore updating _yHeight to a new value, something != to yHeight.
		_yHeight = yHeight;
   		UpdateScrollBar(SB_VERT, TRUE);
	}
	else
	    _yHeight = yHeight;     // Guarantee heights agree

	// Determine display width and update scrollbar
	xWidth = CalcDisplayWidth();
    if(_fViewChanged || (fDone && xWidth != _xWidth) || xWidth > _xWidth)
    {
        _xWidth = xWidth;
   		UpdateScrollBar(SB_HORZ, TRUE);
    }    

    _fViewChanged = FALSE;

	// If not done, do the rest in background
	if(!fDone && !fBackground)
		fDone = StartBackgroundRecalc();

	if(fDone)
	{
		CheckLineArray();
		_fLineRecalcErr = FALSE;
	}

#ifdef DEBUG
	if( 1 )
    {
		_TEST_INVARIANT_
	}
#endif // DEBUG

	return TRUE;

errspace:
	_ped->GetCallMgr()->SetOutOfMemory();
	_fNeedRecalc = TRUE;
	_cpCalcMax = _yCalcMax = 0;
	_fLineRecalcErr = TRUE;

err:
	if(!_fLineRecalcErr)
	{
		_cpCalcMax = me.GetCp();
		_yCalcMax = yHeight;
	}

	TRACEERRORSZ("CDisplayML::RecalcLines() failed");

	if(!_fLineRecalcErr)
	{
		_fLineRecalcErr = TRUE;
		_ped->GetCallMgr()->SetOutOfMemory();
		_fLineRecalcErr = FALSE;			//  fix up CArray & bail
	}
	pled->SetMax(this);

	return FALSE;
}

/*
 *	CDisplayML::CalcDisplayWidth()
 *
 *	@mfunc
 *		Calculates width of this display by walking line CArray and
 *		returning widest line.  Used for horizontal scrollbar routines.
 *
 *	@rdesc
 *		Widest line width in display
 */
LONG CDisplayML::CalcDisplayWidth ()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::CalcDisplayWidth");

	LONG	ili = Count();
	CLine *	pli;
	LONG	xWidth = 0, lineWidth;

	if(ili)
	{
		// Note: pli++ breaks array encapsulation (pli = Elem(ili) doesn't,
		// but is a bit slower)
		pli = Elem(0);
		for(xWidth = 0; ili--; pli++)
		{
			lineWidth = pli->_xLeft + pli->_xWidth + pli->_xLineOverhang;
			xWidth = max(xWidth, lineWidth);
		}
	}
    return xWidth;
}

/*
 *	CDisplayML::StartBackgroundRecalc()
 *
 *	@mfunc
 *		Starts background line recalc (at _cpCalcMax position)
 *
 *	@rdesc
 *		TRUE if done with background recalc
 */
BOOL CDisplayML::StartBackgroundRecalc()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::StartBackgroundRecalc");

	if(_fBgndRecalc)
		return FALSE;					// Already in background recalc

	AssertSz(_cpCalcMax <= _ped->GetTextLength(),
		"CDisplayML::StartBackgroundRecalc _cpCalcMax > Text Length");

	if(_cpCalcMax == _ped->GetTextLength())
		return TRUE;					// Enough chars are recalc'd

	if(!_ped->TxSetTimer(RETID_BGND_RECALC, cmsecBgndInterval))
	{
		// Could not instantiate a timer so wait for recalculation
		WaitForRecalc(_ped->GetTextLength(), -1);
		return TRUE;
	}

	_fRecalcDone = FALSE;
	_fBgndRecalc = TRUE;
	return FALSE;
}

/*
 *	CDisplayML::StepBackgroundRecalc()
 *
 *	@mfunc
 *		Steps background line recalc (at _cpCalcMax position)
 *		Called by timer proc and also when going inactive.
 */
void CDisplayML::StepBackgroundRecalc()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::StepBackgroundRecalc");

    _TEST_INVARIANT_
	
	if(!_fBgndRecalc)					// Not in background recalc,
		return;							//  so don't do anything

	LONG cch = _ped->GetTextLength() - _cpCalcMax;

	// Don't try recalc when processing OOM or had an error doing recalc or
	// if we are asserting.
#ifdef DEBUG
	if(_fInBkgndRecalc || _fLineRecalcErr)
	{
		if(_fInBkgndRecalc)
			TRACEINFOSZ("avoiding reentrant background recalc");
		else
			TRACEINFOSZ("OOM: not stepping recalc");
		return;
	}
#else
	if(_fInBkgndRecalc || _fLineRecalcErr)
		return;
#endif

	_fInBkgndRecalc = TRUE;
	if(!IsActive())
	{
		// Background recalc is over if we are no longer active	because
		// we can no longer get the information we need for recalculating.
		// But, if we are half recalc'd we need to set ourselves up to 
		// recalc again when we go active.
		InvalidateRecalc();
		cch = 0;
	}

	// Background recalc is over if no more chars or no longer active
	if(cch <= 0)
	{
		TRACEINFOSZ("Background line recalc done");
		_ped->TxKillTimer(RETID_BGND_RECALC);
		_fBgndRecalc = FALSE;
		_fRecalcDone = TRUE;
		_fInBkgndRecalc = FALSE;
		CheckLineArray();
		return;
	}

	CRchTxtPtr tp(_ped, _cpCalcMax);
	RecalcLines(tp, cch, cch, TRUE, FALSE, NULL);

	_fInBkgndRecalc = FALSE;
}

/*
 *	CDisplayML::WaitForRecalc(cpMax, yMax)
 *
 *	@mfunc
 *		Ensures that lines are recalced until a specific character
 *		position or ypos.
 *
 *	@rdesc
 *		success
 */
BOOL CDisplayML::WaitForRecalc(
	LONG cpMax,		//@parm Position recalc up to (-1 to ignore)
	LONG yMax)		//@parm ypos to recalc up to (-1 to ignore)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::WaitForRecalc");

    _TEST_INVARIANT_

	if(IsFrozen() || !_ped->fInplaceActive())
		return TRUE;

	BOOL fReturn = TRUE;
	LONG cch;

	if((yMax  < 0 || yMax  >= _yCalcMax) &&
	   (cpMax < 0 || cpMax >= _cpCalcMax))
    {
    	cch = _ped->GetTextLength() - _cpCalcMax;
    	if(cch > 0 || Count() == 0)
    	{
    		HCURSOR hcur = NULL;
			BOOL fSetCursor = (cch > NUMCHARFORWAITCURSOR);

    		_cpWait = cpMax;
    		_yWait = yMax;
		
			if(fSetCursor)
    			hcur = SetCursor(LoadCursor(0, IDC_WAIT));
    		TRACEINFOSZ("Lazy recalc");
		
    		if(!_cpCalcMax || _fNeedRecalc)
			{
    			fReturn = RecalcLines(TRUE);
				RebindFirstVisible();
				if(!fReturn)
					InitVars();
			}
    		else			
    		{
    			CRchTxtPtr rtp(_ped, _cpCalcMax);
    			fReturn = RecalcLines(rtp, cch, cch, FALSE, TRUE, NULL);
    		}

			if(fSetCursor)
    			SetCursor(hcur);
    	}
		else if(!cch)
		{
			// If there was nothing else to calc, make sure that we think
			// recalc is done.
#ifdef DEBUG
			if( !_fRecalcDone )
			{
				TRACEWARNSZ("For some reason we didn't think background "
					"recalc was done, but it was!!");
			}
#endif // DEBUG
			_fRecalcDone = TRUE;
		}
    }

	// If view rect changed, make sure to update scrollbars
	RecalcScrollBars();

	return fReturn;
}

/*
 *	CDisplayML::WaitForRecalcIli(ili)
 *
 *	@mfunc
 *		Wait until line array is recalculated up to line <p ili>
 *
 *	@rdesc
 *		Returns TRUE if lines were recalc'd up to ili
 */
BOOL CDisplayML::WaitForRecalcIli (
	LONG ili)		//@parm Line index to recalculate line array up to
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::WaitForRecalcIli");

	LONG cchGuess;

	while(!_fRecalcDone && ili >= Count())
	{
		// just go ahead and recalc everything.
		cchGuess = _ped->GetTextLength();
		if(IsFrozen() || !WaitForRecalc(cchGuess, -1))
			return FALSE;
	}
	return ili < Count();
}

/*
 *	CDisplayML::WaitForRecalcView()
 *
 *	@mfunc
 *		Ensure visible lines are completly recalced
 *
 *	@rdesc TRUE iff successful
 */
BOOL CDisplayML::WaitForRecalcView()
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::WaitForRecalcView");

	return WaitForRecalc(-1, _yScroll + _yHeightView);
}

/*
 *	CDisplayML::InitLinePtr ( CLinePtr & plp )
 *
 *	@mfunc
 *		Initialize a CLinePtr properly
 */
void CDisplayML::InitLinePtr (
	CLinePtr & plp )		//@parm Ptr to line to initialize
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::InitLinePtr");

    plp.Init( *this );
}

/*
 *	CDisplayML::GetLineText(ili, pchBuff, cchMost)
 *
 *	@mfunc
 *		Copy given line of this display into a character buffer
 *
 *	@rdesc
 *		number of character copied
 */
LONG CDisplayML::GetLineText(
	LONG ili,			//@parm Line to get text of
	TCHAR *pchBuff,		//@parm Buffer to stuff text into
	LONG cchMost)		//@parm Length of buffer
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::GetLineText");
    
	_TEST_INVARIANT_

	CTxtPtr tp (_ped, 0);

	// FUTURE (alexgo, ricksa): This is called from EM_GETLINE whose parameter
	// is a WPARAM which is unsigned we need to fix the type of ili.

	if(ili >= 0 && (ili < Count() || WaitForRecalcIli(ili)))
	{
		cchMost = min(cchMost, Elem(ili)->_cch);
		if(cchMost > 0)
		{
			tp.SetCp(CpFromLine(ili, NULL));
			return tp.GetText(cchMost, pchBuff);
		}
	}
	*pchBuff = TEXT('\0');
	return 0;
}

/*
 *	CDisplayML::LineCount
 *
 *	@mfunc	returns the number of lines in this control.  Note that for plain
 *			text mode, we will add on an extra line of the last character is
 *			a CR.  This is for compatibility with MLE
 *
 *	@rdesc	LONG
 */
LONG CDisplayML::LineCount() const
{
	LONG cLine = Count();

	if (!_ped->IsRich() && (!cLine || 	   // If plain text with no lines
		 Elem(cLine - 1)->_cchEOP))		   //  or last line ending with a CR,
	{									   //  then inc line count
		cLine++;
	}
	return cLine;
}

// ================================  Line info retrieval  ====================================

/*
 *	CDisplayML::YposFromLine(ili)
 *
 *	@mfunc
 *		Computes top of line position
 *
 *	@rdesc
 *		top position of given line (relative to the first line)
 */
LONG CDisplayML::YposFromLine(
	LONG ili) 		//@parm Line we're interested in
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::YposFromLine");
    _TEST_INVARIANT_

	if(!WaitForRecalcIli(ili))			// out of range, use last valid line
	{
		ili = Count() - 1;
		ili = (ili > 0) ? ili : 0;
	}

	LONG	cli	= ili - _iliFirstVisible;
	CLine *	pli = Elem(_iliFirstVisible);
	LONG	yPos = _yScroll + _dyFirstVisible;

	while(cli > 0)
	{
		yPos += pli->GetHeight();
		cli--;
		pli++;
	}
	while(cli < 0)
	{	
		pli--;
		yPos -= pli->GetHeight();
		cli++;
	}

	AssertSz(yPos >= 0, "CDisplayML::YposFromLine height less than 0");

	return yPos;
}

/*
 *	CDisplayML::CpFromLine(ili, pyHeight)
 *
 *	@mfunc
 *		Computes cp at start of given line 
 *		(and top of line position relative to this display)
 *
 *	@rdesc
 *		cp of given line
 */
LONG CDisplayML::CpFromLine (
	LONG ili,		//@parm Line we're interested in (if <lt> 0 means caret line)
	LONG *pyHeight)	//@parm Returns top of line relative to display 
					//  	(NULL if don't want that info)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::CpFromLine");

    _TEST_INVARIANT_
						
	LONG cli;
	LONG y = _yScroll + _dyFirstVisible;
	LONG cp = _cpFirstVisible;
	CLine *pli;
	LONG iStart = _iliFirstVisible;

	cli = ili - _iliFirstVisible;
	if(cli < 0 && -cli >= ili)
	{
		// Closer to first line than to first visible line,
		// so start at the first line
		cli = ili;
		y = 0;
		cp = 0;
		iStart = 0;
	}
	else if( cli <= 0 )
	{
		CheckView();
		for(ili = _iliFirstVisible-1; cli < 0; cli++, ili--)
		{
			pli = Elem(ili);
			y -= pli->GetHeight();
			cp -= pli->_cch;
		}
		goto end;
	}

	for(ili = iStart; cli > 0; cli--, ili++)
	{
		pli = Elem(ili);
		if(!IsMain() || !WaitForRecalcIli(ili))
			break;
		y += pli->GetHeight();
		cp += pli->_cch;
	}

end:
	if(pyHeight)
		*pyHeight = y;

	return cp;
}

/*
 *	CDisplayML::LineFromYPos(yPos, pyLine, pcpFirst)
 *
 *	@mfunc
 *		Computes line at given y position. Returns top of line ypos
 *		cp at start of line cp, and line index.
 *
 *	@rdesc
 *		index of line found
 */
LONG CDisplayML::LineFromYpos (
	LONG yPos,			//@parm Ypos to look for (relative to first line)
	LONG *pyLine,		//@parm Returns ypos at top of line /r first line (can be NULL)
	LONG *pcpFirst)		//@parm Returns cp at start of line (can be NULL)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::LineFromYpos");

    _TEST_INVARIANT_

	LONG cpLi;
	LONG dy;
	LONG ili = 0;
	LONG yLi;
	CLine *pli;

	if(!WaitForRecalc(-1, _yScroll))
	{
		yLi = 0;
		cpLi = 0;
		goto done;
	}

	cpLi = _cpFirstVisible;
	ili = _iliFirstVisible;
	yLi = _yScroll + _dyFirstVisible;
	dy = yPos - yLi;
	
	if(dy < 0 && -dy <= _yScroll)
	{
		// Closer to first visible line than to first line:
		// go backwards from first visible line.
		while(yPos < yLi && ili > 0)
		{
			pli = Elem(--ili);
			yLi -= pli->GetHeight();
			cpLi -= pli->_cch;
		}
	}
	else
	{
		if(dy < 0)
		{
			// Closer to first line than to first visible line:
			// so start at first line.
			cpLi = _cpMin;
			yLi = 0;
			ili = 0;
		}
		pli = Elem(ili);
		while(yPos > yLi && ili < Count()-1)
		{
			yLi += pli->GetHeight();
			cpLi += pli->_cch;
			ili++;
			pli++;
		}
		if(yPos < yLi && ili > 0)
		{
			ili--;
			pli--;
			yLi -= pli->GetHeight();
			cpLi -= pli->_cch;
		}
	}

done:
	if(pyLine)
		*pyLine = yLi;

	if(pcpFirst)
		*pcpFirst = cpLi;

	return ili;
}

/*
 *	CDisplayML::LineFromCp(cp, fAtEnd)
 *
 *	@mfunc
 *		Computes line containing given cp.
 *
 *	@rdesc
 *		index of line found, -1 if no line at that cp.
 */
LONG CDisplayML::LineFromCp(
	LONG cp,		//@parm cp to look for
	BOOL fAtEnd)	//@parm If true, return previous line for ambiguous cp
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::LineFromCp");
    
	_TEST_INVARIANT_

	CLinePtr rp(this);
	
	if(!WaitForRecalc(cp, -1) || !rp.RpSetCp(cp, fAtEnd))
		return -1;

	return (LONG)rp;
}


//==============================  Point <-> cp conversion  ==============================
/*
 *	CDisplayML::CpFromPoint(pt, prcClient, ptp, prp, fAllowEOL, pHit, pdx)
 *
 *	@mfunc
 *		Determine cp at given point
 *
 *	@devnote
 *      --- Use when in-place active only ---
 *
 *	@rdesc
 *		Computed cp, -1 if failed
 */
LONG CDisplayML::CpFromPoint(
	POINT		pt,			//@parm Point to compute cp at (client coords)
	const RECT *prcClient,	//@parm Client rectangle (can be NULL if active).
	CRchTxtPtr * const ptp,	//@parm Returns text pointer at cp (may be NULL)
	CLinePtr * const prp,	//@parm Returns line pointer at cp (may be NULL)
	BOOL		fAllowEOL,	//@parm Click at EOL returns cp after CRLF
	HITTEST *	phit,		//@parm Out parm for hit-test value
	CDispDim *	pdispdim,	//@parm Out parm for display dimensions
	LONG	   *pcpActual)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::CpFromPoint");

    _TEST_INVARIANT_

	LONG		cp;
	LONG		cch = 0;
    RECT        rcView;
	HITTEST		hit = HT_Nothing;

	GetViewRect(rcView, prcClient);

	// Get line under hit
	int y = pt.y;
	pt.y += _yScroll - rcView.top;

	LONG yLine;
	LONG ili = LineFromYpos(pt.y, &yLine, &cp);
    if(ili < 0)
        return -1;

	if(y >= rcView.top && y <= rcView.bottom)
	{
	    pt.y -= yLine;

		CLine *pli = Elem(ili);

		AssertSz(pli || !ili, "CDisplayML::CpFromPoint invalid line pointer");

		if(pli)
		{
			CMeasurer me(this);					// Create measurer
			me.SetCp(cp);

			// Transform to galley coordinates

			// Adjust coordinate relative to where the view starts from.
			pt.x -= rcView.left;

			// Is x coordinate within the view?
			if (pt.x >= 0)
			{
				// Adjust by the scroll value
				pt.x += _xScroll;
			}

			// Get character in line
			cch = pli->CchFromXpos(me, pt, pdispdim, &hit, pcpActual);
			// Don't allow click at EOL to select EOL marker and take into
			// account single line edits as well
			if(!fAllowEOL && cch == pli->_cch && pli->_cchEOP)
			{
				// Adjust position on line by amount backed up. OK for
				// me._rpCF and me._rpPF to get out of sync with me._rpTX,
				// since they're not needed for me.GetCp().
				cch += me._rpTX.BackupCpCRLF();
			}
			cp = me.GetCp();
		}
	}
	if(ptp)
        ptp->SetCp(cp);
	if(prp)
		prp->RpSet(ili, cch);
	if (phit)
		*phit = hit;

	return cp;	
}

/*
 *	CDisplayML::PointFromTp(rtp, prcClient, fAtEnd, pt, prp, taMode)
 *
 *	@mfunc
 *		Determine coordinates at given tp
 *
 *	@devnote
 *      --- Use when in-place active only ---
 *
 *	@rdesc
 *		line index at cp, -1 if error
 */
LONG CDisplayML::PointFromTp(
	const CRchTxtPtr &rtp,	//@parm Text ptr to get coordinates at
	const RECT *prcClient,	//@parm Client rectangle (can be NULL if active).
	BOOL		fAtEnd,		//@parm Return end of prev line for ambiguous cp
	POINT &		pt,			//@parm Returns point at cp in client coords
	CLinePtr * const prp,	//@parm Returns line pointer at tp (may be null)
	UINT		taMode,		//@parm Text Align mode: top, baseline, bottom
	CDispDim *	pdispdim)	//@parm Out parm for display dimensions
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::PointFromTp");

    _TEST_INVARIANT_

	LONG	 dy = 0;
	RECT	 rcView;
	CLinePtr rp(this);

    if(!WaitForRecalc(rtp.GetCp(), -1) || !rp.RpSetCp(rtp.GetCp(), fAtEnd))
		return -1;

    AssertSz(_ped->_fInPlaceActive || prcClient, 
		"CDisplayML::PointFromTp() called with invalid client rect");

    GetViewRect(rcView, prcClient);

	pt.x = rcView.left - _xScroll;
	pt.y = YposFromLine(rp) - _yScroll + rcView.top;

	CMeasurer me(this, rtp);
	me.Advance(-rp.RpGetIch());		// Backup to start of line		
	me.NewLine(*rp);				// Measure from there to where we are

	LONG xCalc = rp->XposFromCch(me, rp.RpGetIch(), taMode, pdispdim, &dy);

	if(pt.x + xCalc <= rcView.right || !GetWordWrap() || GetTargetDev())
	{
		// Width is in view or there is no wordwrap so just
		// add the length to the point.
		pt.x += xCalc;
	}
	else
	{
		// Remember we ignore trailing spaces at the end of the line in
		// the width, therefore the x value that MeasureText finds can 
		// be greater than the width in the line so we truncate to the 
		// previously calculated width which will ignore the spaces.
		pt.x += rp->_xLeft + rp->_xWidth; // We *don't* worry about xLineOverhang here
	}

	pt.y += dy;

	if(prp)
		*prp = rp;
	return rp;
}


//====================================  Rendering  =======================================

/*
 *	CDisplayML::Render(rcView, rcRender)
 *
 *	@mfunc	
 *		Searches paragraph boundaries around a range
 */
void CDisplayML::Render (
	const RECT &rcView,		//@parm View RECT
	const RECT &rcRender)	//@parm RECT to render (must be container in
							//		client rect)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::Render");

    _TEST_INVARIANT_
								
    LONG	cp;
	BOOL	fLinesToRender = TRUE;
	LONG	lCount = Count();
	CTxtSelection *psel = _ped->GetSelNC();
	POINT	pt;
	LONG	yBottomOfRender;
	LONG	yHeightForBitmap = 0;
	LONG	yHeightForLine;
    LONG	yLine;
	LONG	yRenderHeight = rcRender.top + _yScroll - rcView.top;

    if(psel)
		psel->ClearCchPending();
        
	// Review (murrays) this routine is called twice from disp.cpp (once for
	// rendering and once for transparent hit testing) and once from edit.cpp
	// (for printing).  Only the display rendering needs to notify the 
	// update and it does it there.  So the following is either undesired or
	// redundant, i.e., should be deleted.
	// Fire event "updating"
	//if(IsMain())
	//	_ped->TxNotify(EN_UPDATE, NULL);

	// Calculate line and cp to start display at
   	LONG ili = LineFromYpos(rcRender.top + _yScroll - rcView.top, &yLine, &cp);
	CLine *pli = Elem(ili);
	LONG yLi = pli ? pli->GetHeight() : 0;		// Null == some forms^3 empty control
	yLi = max(yLi, 0);

	if(yRenderHeight > yLine + yLi)
		fLinesToRender = FALSE;

	// Calculate point where text will start being displayed
   	pt.x = rcView.left - _xScroll;
   	pt.y = rcView.top  - _yScroll + yLine;
	yBottomOfRender = BottomOfRender(rcView, rcRender);

	// We only need check for whether we want to offscreen render if the
	// control is not transparent. Remember if the control is transparent,
	// the rendering of mixed character formats  will work because characters
	// in adjoining runs are only truncated if ExtTextOut is trying to clear
	// the display area at the same time.
	if (!IsMetafile() && IsMain() && !IsTransparent())
	{
		// Initialize height counter to first position to display
		yLi = pt.y;

		// Loop through visible lines until we have examined entire
		// line array or we have exceeded visible height
		CLine *pli = Elem(ili);
		for (LONG iliLoop = ili; 
			iliLoop < lCount && yLi < yBottomOfRender; iliLoop++, pli++)
		{
			if(pli->_fCollapsed)
				continue;
			
			yHeightForLine = pli->_yHeight;	// Get local copy of line height
			if(pli->_bFlags & fliUseOffScreenDC)
				yHeightForBitmap = max(yHeightForLine, yHeightForBitmap);

	        yLi += yHeightForLine;
		}
	}

	// Create renderer
	CRenderer re(this);

	// Prepare renderer
	if(!re.StartRender(rcView, rcRender, yHeightForBitmap))
		return;
	
	// Init renderer at start of first line to render
	re.SetCurPoint(pt);
   	cp = re.SetCp(cp);
    yLi = pt.y;

	if(fLinesToRender)
	{
		// Render each line in update rectangle
		for (; ili < lCount; ili++)
		{
			if (!Elem(ili)->Render(re) ||
				re.GetCurPoint().y >= yBottomOfRender)
			{
				break;
			}
#ifdef DEBUG
			cp  += Elem(ili)->_cch;
			yLi += Elem(ili)->GetHeight();

			// Rich controls with password characters stop at EOPs, 
			// so re.GetCp() may be less than cp.
			AssertSz(_ped->IsRich() && _ped->fUsePassword() || re.GetCp() == cp, 
				"CDisplayML::RenderView() - cp out of sync with line table");
			pt = re.GetCurPoint();
			AssertSz(pt.y == yLi,
				"CDisplayML::RenderView() - y out of sync with line table");
#endif
		}
	}
	re.EndRender();						  // Finish rendering
}


//===================================  View Updating  ===================================

/*
 *	CDisplayML::RecalcView(fUpdateScrollBars)
 *
 *	@mfunc
 *		Recalc all lines breaks and update first visible line
 *
 *	@rdesc
 *		TRUE if success
 */
BOOL CDisplayML::RecalcView(
	BOOL fUpdateScrollBars, RECT* prc)
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::RecalcView");

	BOOL fRet = TRUE;
	LONG yHeightOld = _yHeight;
	LONG yScrollHeightOld = GetMaxYScroll();
	LONG xWidthOld = _xWidth;

	// Full recalc lines
	if(!RecalcLines())
	{
		// We're in deep trouble now, the recalc failed. Let's try to get out
		// of this with our head still mostly attached
		InitVars();
		fRet = FALSE;
        goto Done;
	}

	if(!_ped->GetTextLength())			// This is an empty control so
		CreateEmptyLine();				//  create one empty line

    // Force _xScroll = 0 if x scroll range is smaller than the view width
    if(_xWidth <= _xWidthView)
        _xScroll = 0;

	RebindFirstVisible();

	CheckView();

	// We only need to resize if the size needed to display the object has 
	// changed.
	if (yHeightOld != _yHeight || yScrollHeightOld != GetMaxYScroll() ||
		xWidthOld  != _xWidth)
	{
		if(FAILED(RequestResize()))
			_ped->GetCallMgr()->SetOutOfMemory();
		else if (prc && _ped->_fInOurHost)/*bug fix# 5830, forms3 relies on old behavior*/
			_ped->TxGetClientRect(prc);
	}

Done:

    // Now update scrollbars
	if(fUpdateScrollBars)
		RecalcScrollBars();

    return fRet;
}

/*
 *	CDisplayML::UpdateView(&rtp, cchOld, cchNew)
 *
 *	@mfunc
 *		Recalc lines and update the visible part of the display 
 *		(the "view") on the screen.
 *
 *	@devnote
 *      --- Use when in-place active only ---
 *
 *	@rdesc
 *		TRUE if success
 */
BOOL CDisplayML::UpdateView(
	const CRchTxtPtr &rtp,	//@parm Text ptr where change happened
	LONG cchOld,				//@parm Count of chars deleted
	LONG cchNew)				//@parm Count of chars inserted
{
	TRACEBEGIN(TRCSUBSYSDISP, TRCSCOPEINTERN, "CDisplayML::UpdateView");

	BOOL fReturn = TRUE;
	BOOL fRecalcVisible = TRUE;
	RECT rcClient;
    RECT rcView;
	CLed led;
	CTxtSelection *psel = _ped->GetSelNC();
	LONG cpStartOfUpdate = rtp.GetCp();
	BOOL fNeedViewChange = FALSE;
	LONG yHeightOld = _yHeight;
	LONG yScrollHeightOld = GetMaxYScroll();
	LONG xWidthOld = _xWidth;
	LONG yScrollOld = _yScroll;
	LO