      Suppressed ++;
                        }
                        MemFree (g_hHeap, 0, Data);
                    }
                }
            } while (EnumNextRegValue (&ev));
        }
        CloseRegKey (ExtensionsKey);
    }
    if (Processed && (Processed == Suppressed)) {
        MemDbBuildKey (key, MEMDB_CATEGORY_TMP_SUPPRESS, ParentKeyName, SubKeyName, NULL);
        MemDbDeleteTree (key);
        MemDbSetValue (key, 0);
        return TRUE;
    }
    return FALSE;
}

BOOL
pIsShellExKeySuppressed (
    IN      HKEY ParentKey,
    IN      PCTSTR ParentKeyName,
    IN      PCTSTR SubKeyName
    )
{
    REGKEY_ENUM e;
    DWORD Processed, Suppressed;
    HKEY ShellExKey;
    HKEY SubKey;
    PTSTR key;
    BOOL result = FALSE;
    PCTSTR Data;

    ShellExKey = OpenRegKey (ParentKey, SubKeyName);

    Processed = Suppressed = 0;

    if (ShellExKey) {

        if (EnumFirstRegKey (&e, ShellExKey)) {
            do {
                Processed ++;

                //
                // See if the key itself is a suppressed GUID
                //
                if (pIsGuidSuppressed (e.SubKeyName)) {
                    DEBUGMSG ((DBG_OLEREG, "ProgID %s has incompatible shell extension %s", ParentKeyName, e.SubKeyName));
                    MemDbSetValueEx (
                        MEMDB_CATEGORY_TMP_SUPPRESS,
                        ParentKeyName,
                        SubKeyName,
                        e.SubKeyName,
                        0,
                        NULL);
                    Suppressed ++;
                    continue;
                }

                //
                // See if the default value is a suppressed GUID
                //
                SubKey = OpenRegKey (ShellExKey, e.SubKeyName);

                if (SubKey) {
                    Data = (PCTSTR) GetRegKeyData (SubKey, S_EMPTY);

                    if (Data) {
                        if (pIsGuidSuppressed (Data)) {
                            DEBUGMSG ((DBG_OLEREG, "ProgID %s has incompatible shell extension %s", ParentKeyName, Data));
                            MemDbSetValueEx (
                                MEMDB_CATEGORY_TMP_SUPPRESS,
                                ParentKeyName,
                                SubKeyName,
                                e.SubKeyName,
                                0,
                                NULL);
                            Suppressed ++;
                            MemFree (g_hHeap, 0, Data);
                            CloseRegKey (SubKey);
                            continue;
                        }
                        MemFree (g_hHeap, 0, Data);
                    }
                    CloseRegKey (SubKey);
                }

                //
                // Call recursively on this subkey
                //
                key = JoinPaths (ParentKeyName, SubKeyName);
                if (pIsShellExKeySuppressed (ShellExKey, key, e.SubKeyName)) {
                    MemDbSetValueEx (
                        MEMDB_CATEGORY_TMP_SUPPRESS,
                        ParentKeyName,
                        SubKeyName,
                        e.SubKeyName,
                        0,
                        NULL);
                    Suppressed ++;
                }
                FreePathString (key);


            } while (EnumNextRegKey (&e));
            if (Processed && (Processed == Suppressed)) {
                key = (PTSTR)AllocPathString (MEMDB_MAX);
                MemDbBuildKey (key, MEMDB_CATEGORY_TMP_SUPPRESS, ParentKeyName, SubKeyName, NULL);
                MemDbDeleteTree (key);
                MemDbSetValue (key, 0);
                FreePathString (key);
                result = TRUE;
            }
        }
        CloseRegKey (ShellExKey);
    }
    return result;
}

BOOL
pProcessProgIdSuppression (
    VOID
    )
{
    REGKEY_ENUM e;
    REGKEY_ENUM subKey;
    HKEY ProgIdKey;
    DWORD Processed, Suppressed;
    TCHAR key [MEMDB_MAX];
    MEMDB_ENUM memEnum;
    BOOL HarmlessKeyFound;
    BOOL ActiveSuppression;
    DWORD Count = 0;

    if (EnumFirstRegKeyStr (&e, TEXT("HKCR"))) {
        do {
            if (StringIMatch (e.SubKeyName, TEXT("CLSID"))) {
                continue;
            }
            if (StringIMatch (e.SubKeyName, TEXT("Interface"))) {
                continue;
            }
            if (StringIMatch (e.SubKeyName, TEXT("Applications"))) {
                continue;
            }
            if (StringIMatch (e.SubKeyName, TEXT("TypeLib"))) {
                continue;
            }
            if (_tcsnextc (e.SubKeyName) == TEXT('.')) {
                continue;
            }
            ProgIdKey = OpenRegKey (e.KeyHandle, e.SubKeyName);

            if (ProgIdKey) {

                Processed = 0;
                Suppressed = 0;
                HarmlessKeyFound = 0;
                ActiveSuppression = FALSE;

                if (EnumFirstRegKey (&subKey, ProgIdKey)) {
                    do {
                        Processed ++;

                        if (StringIMatch (subKey.SubKeyName, TEXT("CLSID"))) {
                            if (pIsCLSIDSuppressed (ProgIdKey, e.SubKeyName, subKey.SubKeyName)) {
                                AbortRegKeyEnum (&subKey);
                                Processed = Suppressed = 1;
                                HarmlessKeyFound = 0;
                                ActiveSuppression = TRUE;
                                break;
                            }
                        }
                        if (StringIMatch (subKey.SubKeyName, TEXT("Shell"))) {
                            if (pIsShellKeySuppressed (ProgIdKey, e.SubKeyName, subKey.SubKeyName)) {
                                ActiveSuppression = TRUE;
                                Suppressed ++;
                            }
                        }
                        if (StringIMatch (subKey.SubKeyName, TEXT("Protocol"))) {
                            if (pIsProtocolKeySuppressed (ProgIdKey, e.SubKeyName, subKey.SubKeyName)) {
                                ActiveSuppression = TRUE;
                                Suppressed ++;
                            }
                        }
                        if (StringIMatch (subKey.SubKeyName, TEXT("Extensions"))) {
                            if (pIsExtensionsKeySuppressed (ProgIdKey, e.SubKeyName, subKey.SubKeyName)) {
                                ActiveSuppression = TRUE;
                                Suppressed ++;
                            }
                        }
                        if (StringIMatch (subKey.SubKeyName, TEXT("ShellEx"))) {
                            if (pIsShellExKeySuppressed (ProgIdKey, e.SubKeyName, subKey.SubKeyName)) {
                                ActiveSuppression = TRUE;
                                Suppressed ++;
                            }
                        }
                        if (StringIMatch (subKey.SubKeyName, TEXT("DefaultIcon"))) {
                            HarmlessKeyFound ++;
                        }
                        if (StringIMatch (subKey.SubKeyName, TEXT("Insertable"))) {
                            HarmlessKeyFound ++;
                        }
                        if (StringIMatch (subKey.SubKeyName, TEXT("NotInsertable"))) {
                            HarmlessKeyFound ++;
                        }
                        if (StringIMatch (subKey.SubKeyName, TEXT("ShellFolder"))) {
                            HarmlessKeyFound ++;
                        }

                    } while (EnumNextRegKey (&subKey));
                }
                if (ActiveSuppression && (Processed == (Suppressed + HarmlessKeyFound))) {
                    pSuppressProgId (e.SubKeyName);
                } else {
                    MemDbBuildKey (key, MEMDB_CATEGORY_TMP_SUPPRESS, e.SubKeyName, TEXT("*"), NULL);
                    if (MemDbEnumFirstValue (&memEnum, key, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
                        do {
                            MemDbBuildKey (key, MEMDB_CATEGORY_HKLM, TEXT("SOFTWARE\\Classes"), e.SubKeyName, memEnum.szName);
                            Suppress95RegSetting (key, NULL);
                        } while (MemDbEnumNextValue (&memEnum));
                    }
                }
                MemDbBuildKey (key, MEMDB_CATEGORY_TMP_SUPPRESS, e.SubKeyName, NULL, NULL);
                MemDbDeleteTree (key);

                CloseRegKey (ProgIdKey);
            }
            Count++;
            if (!(Count % 64)) {
                TickProgressBar ();
            }
        } while (EnumNextRegKey (&e));
    }
    return TRUE;
}


BOOL
pIsGuidSuppressed (
    PCTSTR GuidStr
    )

/*++

Routine Description:

  Determines if a GUID is suppressed or not, and also determines if a
  GUID is handled by a migration DLL.

Arguments:

  GuidStr - Specifies the GUID to look up, which may or may not contain
            the surrounding braces

Return Value:

  TRUE if the specified GUID is suppressed, or FALSE if it is not.

  The return value is FALSE if the GUID is handled by a migration DLL.

--*/

{
    TCHAR Node[MEMDB_MAX];
    TCHAR FixedGuid[MAX_GUID];

    if (!FixGuid (GuidStr, FixedGuid)) {
        return FALSE;
    }

    if (pIgnoreGuid (FixedGuid)) {
        return FALSE;
    }

    MemDbBuildKey (
        Node,
        MEMDB_CATEGORY_GUIDS,
        NULL,
        NULL,
        FixedGuid
        );

    return MemDbGetValue (Node, NULL);
}


BOOL
pScanSubKeysForIncompatibleGuids (
    IN      PCTSTR ParentKey
    )

/*++

Routine Description:

  Suppresses the subkeys of the supplied parent key that have text
  referencing an incompatible GUID.

Arguments:

  ParentKey - Specifies the parent to enumerate keys for

Return Value:

  TRUE if everything is OK, or FALSE if an unexpected error occurred during
  processing.

--*/

{
    REGKEY_ENUM e;
    TCHAR Node[MEMDB_MAX];

    //
    // Enumerate the keys in ParentKey
    //

    if (EnumFirstRegKeyStr (&e, ParentKey)) {
        do {
            if (pIsGuidSuppressed (e.SubKeyName)) {
                //
                // Suppress the enumerated subkey
                //

                wsprintf (Node, TEXT("%s\\%s"), ParentKey, e.SubKeyName);
                Suppress95RegSetting (Node, NULL);
            }
        } while (EnumNextRegKey (&e));
    }

    return TRUE;
}


BOOL
pScanValueNamesForIncompatibleGuids (
    IN      PCTSTR ParentKey
    )

/*++

Routine Description:

  Suppresses the values of the supplied parent key that have value names
  referencing an incompatible GUID.

Arguments:

  ParentKey - Specifies the parent to enumerate values of

Return Value:

  TRUE if everything is OK, or FALSE if an unexpected error occurred during
  processing.

--*/

{
    REGVALUE_ENUM e;
    HKEY Key;

    //
    // Enumerate the values in ParentKey
    //

    Key = OpenRegKeyStr (ParentKey);

    if (Key) {
        if (EnumFirstRegValue (&e, Key)) {

            do {

                if (pIsGuidSuppressed (e.ValueName)) {
                    //
                    // Suppress the enumerated value
                    //

                    Suppress95RegSetting (ParentKey, e.ValueName);
                }

            } while (EnumNextRegValue (&e));
        }

        CloseRegKey (Key);
    }

    return TRUE;
}


BOOL
pScanValueDataForIncompatibleGuids (
    IN      PCTSTR ParentKey
    )

/*++

Routine Description:

  Suppresses the values of the supplied parent key that have value data
  referencing an incompatible GUID.

Arguments:

  ParentKey - Specifies the parent to enumerate values of

Return Value:

  TRUE if everything is OK, or FALSE if an unexpected error occurred during
  processing.

--*/

{
    REGVALUE_ENUM e;
    HKEY Key;
    PCTSTR Data;

    //
    // Enumerate the values in ParentKey
    //

    Key = OpenRegKeyStr (ParentKey);

    if (Key) {
        if (EnumFirstRegValue (&e, Key)) {
            do {
                Data = GetRegValueString (Key, e.ValueName);
                if (Data) {

                    if (pIsGuidSuppressed (Data)) {
                        //
                        // Suppress the enumerated value
                        //

                        Suppress95RegSetting (ParentKey, e.ValueName);
                    }

                    MemFree (g_hHeap, 0, Data);
                }
            } while (EnumNextRegValue (&e));
        }

        CloseRegKey (Key);
    }

    return TRUE;
}


BOOL
pCheckDefaultValueForIncompatibleGuids (
    IN      PCTSTR KeyStr
    )

/*++

Routine Description:

  Suppresses the specified key if its default value is a suppressed GUID.

Arguments:

  KeyStr - Specifies key string to process

Return Value:

  TRUE if everything is OK, or FALSE if an unexpected error occurred during
  processing.

--*/

{
    PCTSTR Data;
    HKEY Key;

    //
    // Examine the default value of KeyStr
    //

    Key = OpenRegKeyStr (KeyStr);
    if (Key) {
        Data = GetRegValueString (Key, S_EMPTY);
        CloseRegKey (Key);
    } else {
        Data = NULL;
    }

    if (Data) {
        if (pIsGuidSuppressed (Data)) {
            //
            // Suppress the specified reg key
            //

            Suppress95RegSetting (KeyStr, NULL);
        }

        MemFree (g_hHeap, 0, Data);
    }

    return TRUE;
}


BOOL
pScanDefaultValuesForIncompatibleGuids (
    IN      PCTSTR ParentKey
    )

/*++

Routine Description:

  Suppresses subkeys that have a default value that is a suppressed GUID.

Arguments:

  ParentKey - Specifies key string to process

Return Value:

  TRUE if everything is OK, or FALSE if an unexpected error occurred during
  processing.

--*/

{
    REGKEY_ENUM e;
    TCHAR Node[MEMDB_MAX];
    PCTSTR Data;
    HKEY Key;

    //
    // Enumerate the keys in ParentKey
    //

    if (EnumFirstRegKeyStr (&e, ParentKey)) {
        do {
            Key = OpenRegKey (e.KeyHandle, e.SubKeyName);
            if (Key) {
                Data = GetRegValueString (Key, S_EMPTY);
            } else {
                Data = NULL;
            }
            CloseRegKey (Key);

            if (Data) {
                if (pIsGuidSuppressed (Data)) {
                    //
                    // Suppress the enumerated subkey
                    //

                    wsprintf (Node, TEXT("%s\\%s"), ParentKey, e.SubKeyName);
                    Suppress95RegSetting (Node, NULL);
                }

                MemFree (g_hHeap, 0, Data);
            }
        } while (EnumNextRegKey (&e));
    }

    return TRUE;
}



BOOL
pProcessExplorerSuppression (
    VOID
    )

/*++

Routine Description:

  Suppresses the settings in

    HKLM\Software\Microsoft\Windows\CurrentVersion\Explorer\ShellExecuteHooks

  that reference incompatible GUIDs.

Arguments:

  none

Return Value:

  TRUE if everything is OK, or FALSE if an unexpected error occurred during
  processing.

--*/

{
    BOOL b = TRUE;

    //
    // Suppress Win9x-specific value data in CSSFilters
    //

    if (b) {
        b = pScanValueDataForIncompatibleGuids (S_EXPLORER_CSSFILTERS);
    }

    //
    // Suppress Win9x-specific keys in Desktop\NameSpace
    //

    if (b) {
        b = pScanSubKeysForIncompatibleGuids (S_EXPLORER_DESKTOP_NAMESPACE);
    }

    //
    // Suppress key of FileTypesPropertySheetHook if default value is Win9x-specific
    //

    if (b) {
        b = pCheckDefaultValueForIncompatibleGuids (S_EXPLORER_FILETYPESPROPERTYSHEETHOOK);
    }

    //
    // Suppress subkeys of FindExtensions if default value is Win9x-specific
    //

    if (b) {
        b = pScanDefaultValuesForIncompatibleGuids (S_EXPLORER_FINDEXTENSIONS);
    }

    //
    // Scan MyComputer\NameSpace for subkeys or subkeys with default values
    // pointing to incompatible GUIDs.
    //

    if (b) {
        b = pScanSubKeysForIncompatibleGuids (S_EXPLORER_MYCOMPUTER_NAMESPACE);
    }
    if (b) {
        b = pScanDefaultValuesForIncompatibleGuids (S_EXPLORER_MYCOMPUTER_NAMESPACE);
    }

    //
    // Scan NetworkNeighborhood\NameSpace for subkeys or subkeys with default values
    // pointing to incompatible GUIDs.
    //

    if (b) {
        b = pScanSubKeysForIncompatibleGuids (S_EXPLORER_NETWORKNEIGHBORHOOD_NAMESPACE);
    }
    if (b) {
        b = pScanDefaultValuesForIncompatibleGuids (S_EXPLORER_NETWORKNEIGHBORHOOD_NAMESPACE);
    }


    //
    // Suppress values that reference incompatible GUIDs
    //

    if (b) {
        b = pScanValueNamesForIncompatibleGuids (S_EXPLORER_NEWSHORTCUTHANDLERS);
    }

    //
    // Scan RemoteComputer\NameSpace for subkeys or subkeys with default values
    // pointing to incompatible GUIDs.
    //

    if (b) {
        b = pScanSubKeysForIncompatibleGuids (S_EXPLORER_REMOTECOMPUTER_NAMESPACE);
    }
    if (b) {
        b = pScanDefaultValuesForIncompatibleGuids (S_EXPLORER_REMOTECOMPUTER_NAMESPACE);
    }

    //
    // Scan ShellExecuteHooks for value names referencing incompatible GUIDs
    //

    if (b) {
        b = pScanValueNamesForIncompatibleGuids (S_EXPLORER_SHELLEXECUTEHOOKS);
    }

    //
    // Scan ShellIconOverlayIdentifiers for subkeys with default values referencing
    // incompatible GUIDs
    //

    if (b) {
        b = pScanDefaultValuesForIncompatibleGuids (S_EXPLORER_SHELLICONOVERLAYIDENTIFIERS);
    }

    //
    // Scan VolumeCaches for subkeys with default values referencing
    // incompatible GUIDs
    //

    if (b) {
        b = pScanDefaultValuesForIncompatibleGuids (S_EXPLORER_VOLUMECACHES);
    }

    //
    // Scan ExtShellViews for subkeys that reference incompatible GUIDs
    //

    if (b) {
        b = pScanSubKeysForIncompatibleGuids (S_EXTSHELLVIEWS);
    }

    //
    // Scan Shell Extensions\Approved for value names referencing incompatible
    // GUIDs
    //

    if (b) {
        b = pScanValueNamesForIncompatibleGuids (S_SHELLEXTENSIONS_APPROVED);
    }

    //
    // Scan ShellServiceObjectDelayLoad for value data referencing incompatible
    // GUIDs
    //

    if (b) {
        b = pScanValueDataForIncompatibleGuids (S_SHELLSERVICEOBJECTDELAYLOAD);
    }


    return b;
}


BOOL
ExtractIconIntoDatFile (
    IN      PCTSTR LongPath,
    IN      INT IconIndex,
    IN OUT  PICON_EXTRACT_CONTEXT Context,
    OUT     PINT NewIconIndex                   OPTIONAL
    )

/*++

Routine Description:

  ExtractIconIntoDatFile preserves a Win9x icon by extracting it from the 9x
  system. If the EXE and icon index pair are known good, then this function
  returns FALSE. Otherwise, this function extracts the icon and saves it into
  a DAT file for processing in GUI mode setup. If icon extraction fails, then
  the default generic icon from shell32.dll is used.

Arguments:

  LongPath - Specifies the full path to the PE image

  IconIndex - Specifies the icon index to extract. Negative index values
              provide a specific icon resource ID. Positive index values
              indicate which icon, where 0 is the first icon, 1 is the second
              icon, and so on.

  Context - Specifies the extraction context that gives the DAT file and other
            info (used by icon extraction utilities).

  NewIconIndex - Receives the new icon index in
                 %windir%\system32\migicons.exe, if the function returns TRUE.
                 Zero otherwise.

Return Value:

  TRUE if the icon was extracted, or if the icon could not be extracted but
  the icon is not known-good. (The default generic icon is used in this case.)

  FALSE if the icon is known-good and does not need to be extracted.

--*/

{
    MULTISZ_ENUM MultiSz;
    TCHAR Node[MEMDB_MAX];
    TCHAR IconId[256];
    TCHAR IconIndexStr[32];
    PCTSTR IconList;
    PCTSTR extPtr;
    INT i;
    DWORD Offset;
    static WORD Seq = 0;
    DWORD OrgSeq;
    BOOL result = FALSE;
    BOOL needDefaultIcon = FALSE;

    if (NewIconIndex) {
        *NewIconIndex = 0;
    }

    __try {
        //
        // Is this a compatible icon binary? If so, return FALSE.
        //

        if (IsIconKnownGood (LongPath, IconIndex)) {
            __leave;
        }

        //
        // From this point on, if we fail to extract the icon, use the default.
        //

        needDefaultIcon = TRUE;

        if (!Seq) {
            //
            // Extract the icon from shell32.dll for the default icon. This is
            // the "generic app" icon. We keep the Win9x generic icon instead
            // of the updated NT generic icon, so there is a clear indication
            // that we failed to extract the right thing from Win9x.
            //

            DEBUGMSG ((DBG_OLEREG, "DefaultIconExtraction: Extracting a default icon"));

            Offset = SetFilePointer (Context->IconImageFile, 0, NULL, FILE_CURRENT);

            wsprintf (Node, TEXT("%s\\system\\shell32.dll"), g_WinDir);

            if (!CopyIcon (Context, Node, TEXT("#1"), 0)) {
                DEBUGMSG ((
                    DBG_ERROR,
                    "DefaultIconExtraction: Can't extract default icon from %s",
                    Node
                    ));
            } else {
                MemDbBuildKey (
                    Node,
                    MEMDB_CATEGORY_ICONS,
                    TEXT("%s\\system\\shell32.dll"),
                    TEXT("0"),
                    NULL
                    );

                MemDbSetValueAndFlags (Node, Offset, Seq, 0xffff);
                Seq++;
            }
        }

        //
        // Has the icon been extracted already?
        //

        extPtr = GetFileExtensionFromPath (LongPath);

        if ((IconIndex >= 0) && extPtr && (!StringIMatch (extPtr, TEXT("ICO")))) {
            //
            // IconIndex specifies sequential order; get list of
            // resource IDs and find the right one.
            //

            IconList = ExtractIconNamesFromFile (LongPath, &Context->IconList);
            i = IconIndex;

            IconId[0] = 0;

            if (IconList) {

                if (EnumFirstMultiSz (&MultiSz, IconList)) {
                    while (i > 0) {
                        if (!EnumNextMultiSz (&MultiSz)) {
                            break;
                        }
                        i--;
                    }

                    if (!i) {
                        StringCopy (IconId, MultiSz.CurrentString);
                    }
                    ELSE_DEBUGMSG ((DBG_OLEREG, "Icon %i not found in %s", i, LongPath));
                }
            }
            ELSE_DEBUGMSG ((DBG_OLEREG, "Icon %i not found in %s", i, LongPath));

        } else {
            //
            // IconIndex specifies resource ID
            //

            wsprintf (IconId, TEXT("#%i"), -IconIndex);
        }

        if (!IconId[0]) {
            //
            // Failed to find icon or failed to read icon index from EXE
            //

            __leave;
        }

        wsprintf (IconIndexStr, TEXT("%i"), IconIndex);
        MemDbBuildKey (Node, MEMDB_CATEGORY_ICONS, LongPath, IconIndexStr, NULL);

        if (!MemDbGetValueAndFlags (Node, NULL, &OrgSeq)) {
            //
            // Extract the icon and save it in a file.  During GUI
            // mode, the icon will be saved to a resource-only DLL.
            //

            DEBUGMSG ((
                DBG_OLEREG,
                "Extracting default icon %s in file %s",
                IconId,
                LongPath
                ));

            Offset = SetFilePointer (Context->IconImageFile, 0, NULL, FILE_CURRENT);

            if (!CopyIcon (Context, LongPath, IconId, 0)) {
                DEBUGMSG ((
                    DBG_OLEREG,
                    "DefaultIconExtraction: CopyIcon failed for %s, %i (%s)!",
                    LongPath,
                    IconIndex,
                    IconId
                    ));
                __leave;
            }

            if (NewIconIndex) {
                *NewIconIndex = (INT) (UINT) Seq;
            }

            MemDbBuildKey (
                Node,
                MEMDB_CATEGORY_ICONS,
                LongPath,
                IconIndexStr,
                NULL
                );

            MemDbSetValueAndFlags (Node, Offset, Seq, 0xffff);
            Seq++;

        } else {
            if (NewIconIndex) {
                *NewIconIndex = (INT) (UINT) OrgSeq;
            }
        }

        result = TRUE;
    }
    __finally {
        //
        // Even if we fail, return success if we want the caller to use
        // the default icon (at index 0).
        //

        result |= needDefaultIcon;
    }

    return result;
}


VOID
pExtractDefaultIcon (
    PCTSTR Data,
    PICON_EXTRACT_CONTEXT Context
    )
{
    TCHAR ArgZero[MAX_CMDLINE];
    TCHAR LongPath[MAX_TCHAR_PATH];
    INT IconIndex;
    PCTSTR p;
    BOOL LongPathFound = FALSE;

    //
    // Determine if the first arg of the command line points to a
    // deleted file or a file to be replaced
    //

    ExtractArgZeroEx (Data, ArgZero, TEXT(","), FALSE);
    p = (PCTSTR) ((PBYTE) Data + ByteCount (ArgZero));
    while (*p == TEXT(' ')) {
        p++;
    }

    if (*p == TEXT(',')) {
        IconIndex = _ttoi (_tcsinc (p));
    } else {
        IconIndex = 0;
    }

    if (!_tcschr (ArgZero, TEXT('\\'))) {
        if (SearchPath (NULL, ArgZero, NULL, MAX_TCHAR_PATH, LongPath, NULL)) {
            LongPathFound = TRUE;
        }
    }

    if (LongPathFound || OurGetLongPathName (ArgZero, LongPath, MAX_TCHAR_PATH)) {

        if (FILESTATUS_UNCHANGED != GetFileStatusOnNt (LongPath)) {
            ExtractIconIntoDatFile (
                LongPath,
                IconIndex,
                Context,
                NULL
                );
        }
    }
}


VOID
pExtractAllDefaultIcons (
    IN      HKEY ParentKey
    )
{
    HKEY DefaultIconKey;
    REGVALUE_ENUM e;
    PCTSTR Data;

    DefaultIconKey = OpenRegKey (ParentKey, TEXT("DefaultIcon"));

    if (DefaultIconKey) {
        //
        // Check all values in DefaultIcon
        //

        if (EnumFirstRegValue (&e, DefaultIconKey)) {

            do {

                Data = (PCTSTR) GetRegValueString (DefaultIconKey, e.ValueName);

                if (Data) {
                    pExtractDefaultIcon (Data, &g_IconContext);
                    MemFree (g_hHeap, 0, Data);
                }
            } while (EnumNextRegValue (&e));

        }

        CloseRegKey (DefaultIconKey);
    }

}


BOOL
pDefaultIconPreservation (
    VOID
    )

/*++

Routine Description:

  This routine scans the DefaultIcon setting of OLE classes and identifies
  any default icon that will be lost by deletion.  A copy of the icon is
  stored away in a directory called MigIcons.

Arguments:

  none

Return Value:

  TRUE unless an unexpected error occurs.

--*/

{
    REGKEY_ENUM e;
    HKEY ProgIdKey;
    TCHAR key[MEMDB_MAX];
    DWORD value;

    //
    // Scan all ProgIDs, looking for default icons that are currently
    // set for deletion.  Once found, don't delete the icon, but instead
    // copy the image to  %windir%\setup\temp\migicons.
    //

    if (EnumFirstRegKeyStr (&e, TEXT("HKCR"))) {

        do {
            //
            // We extract the icons for all ProgIds that survive on NT.
            //
            MemDbBuildKey (key, MEMDB_CATEGORY_PROGIDS, e.SubKeyName, NULL, NULL);
            if (!MemDbGetValue (key, &value) ||
                (value != PROGID_SUPPRESSED)
                ) {

                ProgIdKey = OpenRegKey (e.KeyHandle, e.SubKeyName);
                if (ProgIdKey) {
                    pExtractAllDefaultIcons (ProgIdKey);
                    CloseRegKey (ProgIdKey);
                }
            }

        } while (EnumNextRegKey (&e));
    }

    if (EnumFirstRegKeyStr (&e, TEXT("HKCR\\CLSID"))) {

        do {
            //
            // We extract the icons for all GUIDs (even for the suppressed ones).
            // The reason is that if NT installs this GUID we do want to replace
            // the NT default icon with the 9x icon.
            //

            ProgIdKey = OpenRegKey (e.KeyHandle, e.SubKeyName);

            if (ProgIdKey) {
                pExtractAllDefaultIcons (ProgIdKey);
                CloseRegKey (ProgIdKey);
            }

        } while (EnumNextRegKey (&e));
    }

    return TRUE;
}



BOOL
pActiveSetupProcessing (
    VOID
    )

/*++

Routine Description:

  This routine scans the Active Setup key and suppresses incompatible GUIDs
  and Installed Components subkeys that reference deleted files.  If a
  stub path references an INF, we preserve the INF.

Arguments:

  none

Return Value:

  TRUE unless an unexpected error occurs.

--*/

{
    REGKEY_ENUM e;
    HKEY InstalledComponentKey;
    PCTSTR Data;
    TCHAR ArgZero[MAX_CMDLINE];
    TCHAR LongPath[MAX_TCHAR_PATH];
    TCHAR Node[MEMDB_MAX];
    PCTSTR p;
    PTSTR q;
    PTSTR DupText;
    DWORD status;

    //
    // Scan all Installed Components
    //

    if (EnumFirstRegKeyStr (&e, S_ACTIVESETUP)) {
        do {
            //
            // Determine if the GUID is suppressed, and if it is, suppress
            // the entire Installed Components setting
            //

            if (pIsGuidSuppressed (e.SubKeyName)) {
                wsprintf (Node, TEXT("%s\\%s"), S_ACTIVESETUP, e.SubKeyName);
                Suppress95RegSetting (Node, NULL);
                continue;
            }

            //
            // Get StubPath and determine if it references incompatible files
            //

            InstalledComponentKey = OpenRegKey (e.KeyHandle, e.SubKeyName);

            if (InstalledComponentKey) {
                __try {
                    Data = GetRegValueString (InstalledComponentKey, TEXT("StubPath"));

                    if (Data) {
                        __try {
                            //
                            // Determine if the first arg of the command line points to a
                            // deleted file
                            //

                            ExtractArgZeroEx (Data, ArgZero, TEXT(","), FALSE);
                            if (OurGetLongPathName (ArgZero, LongPath, MAX_TCHAR_PATH)) {

                                status = GetFileStatusOnNt (LongPath);
                                if ((status & FILESTATUS_DELETED) == FILESTATUS_DELETED) {
                                    //
                                    // Suppress this key
                                    //

                                    wsprintf (Node, TEXT("%s\\%s"), S_ACTIVESETUP, e.SubKeyName);
                                    Suppress95RegSetting (Node, NULL);
                                    continue;
                                }
                            }

                            DupText = NULL;

                            //
                            // Scan command line for an LaunchINFSectionEx reference
                            //

                            p = _tcsistr (Data, TEXT("LaunchINF"));
                            if (p) {
                                p = _tcschr (p, TEXT(' '));
                            }
                            if (p) {
                                while (*p == TEXT(' ')) {
                                    p = _tcsinc (p);
                                }

                                //
                                // Instead of deleting this file, lets move it
                                //

                                DupText = DuplicateText (p);
                                q = _tcschr (DupText, TEXT(','));
                                if (q) {
                                    *q = 0;
                                }
                            }

                            if (!DupText) {
                                p = _tcsistr (Data, TEXT("InstallHInfSection"));
                                if (p) {
                                    p = _tcschr (p, TEXT(' '));
                                    if (p) {
                                        p = _tcschr (_tcsinc (p), TEXT(' '));
                                        // p points to end of section name or NULL
                                    }
                                    if (p) {
                                        p = _tcschr (_tcsinc (p), TEXT(' '));
                                        // p points to end of number of NULL
                                    }
                                    if (p) {
                                        p = _tcsinc (p);
                                        DupText = DuplicateText (p);
                                    }
                                }
                            }

                            if (DupText) {

                                if (OurGetLongPathName (DupText, LongPath, MAX_TCHAR_PATH)) {

                                    status = GetFileStatusOnNt (LongPath);
                                    if ((status & FILESTATUS_DELETED) == FILESTATUS_DELETED) {
                                        //
                                        // Suppress the setting
                                        //
                                        wsprintf (Node, TEXT("%s\\%s"), S_ACTIVESETUP, e.SubKeyName);
                                        Suppress95RegSetting (Node, NULL);
                                    }
                                }

                                FreeText (DupText);
                            }
                        }
                        __finally {
                            MemFree (g_hHeap, 0, Data);
                        }
                    }
                }
                __finally {
                    CloseRegKey (InstalledComponentKey);
                }
            }
        } while (EnumNextRegKey (&e));
    }

    return TRUE;
}




#ifdef DEBUG

PCTSTR g_ProgIdFileRefKeys[] = {
    g_DefaultIcon,
    NULL
};

TCHAR g_BaseInterface[] = TEXT("BaseInterface");
TCHAR g_ProxyStubClsId[] = TEXT("ProxyStubClsId");
TCHAR g_ProxyStubClsId32[] = TEXT("ProxyStubClsId32");
TCHAR g_TypeLib[] = TEXT("ProxyStubClsId32");

PCTSTR g_InterfaceRefKeys[] = {
    g_BaseInterface,
    g_ProxyStubClsId,
    g_ProxyStubClsId32,
    g_TypeLib,
    NULL
};


BOOL
pProcessOleWarnings (
    VOID
    )

/*++

Routine Description:

  For checked builds, this routine examines the linkage of the entire
  OLE registry and identifies problems such as abandoned links and
  broken inheritance.

Arguments:

  none

Return Value:

  TRUE unless an unexpected error occurs.

--*/

{
    REGKEY_ENUM e;
    HKEY ClsIdKey;
    HKEY InterfaceKey;
    PCTSTR Data;
    TCHAR Node[MEMDB_MAX];
    BOOL Suppressed;
    INT i;

    //
    // Search HKCR\CLSID for problems
    //

    if (EnumFirstRegKeyStr (&e, TEXT("HKCR\\CLSID"))) {
        do {
            //
            // Verify key is not garbage
            //

            if (!FixGuid (e.SubKeyName, e.SubKeyName)) {
                continue;
            }

            ClsIdKey = OpenRegKey (e.KeyHandle, e.SubKeyName);

            //
            // Determine if this GUID is suppressed
            //

            MemDbBuildKey (Node, MEMDB_CATEGORY_GUIDS, NULL, NULL, e.SubKeyName);
            Suppressed = MemDbGetValue (Node, NULL);

            if (ClsIdKey) {

                if (!Suppressed) {
                    //
                    // Unsuppressed GUID checks
                    //

                    // AutoConvertTo
                    Data = (PCTSTR) GetRegKeyData (ClsIdKey, TEXT("AutoConvertTo"));
                    if (Data) {
                        //
                        // Check if AutoConvertTo is pointing to suppressed GUID
                        //

                        MemDbBuildKey (Node, MEMDB_CATEGORY_GUIDS, NULL, NULL, Data);
                        if (MemDbGetValue (Node, NULL)) {
                            DEBUGMSG ((DBG_WARNING,
                                       "GUID %s points to deleted GUID %s",
                                       e.SubKeyName, Data
                                       ));

                            pAddOleWarning (
                                MSG_OBJECT_POINTS_TO_DELETED_GUID,
                                ClsIdKey,
                                e.SubKeyName
                                );
                        }

                        MemFree (g_hHeap, 0, Data);
                    }

                    // File references
                    for (i = 0 ; g_FileRefKeys[i] ; i++) {
                        Data = (PCTSTR) GetRegKeyData (ClsIdKey, g_FileRefKeys[i]);
                        if (Data) {
                            //
                            // Check if the file in Data is in Win9xFileLocation for
                            // all users
                            //
                            pSuppressGuidIfCmdLineBad (
                                NULL,
                                Data,
                                ClsIdKey,
                                e.SubKeyName
                                );

                            MemFree (g_hHeap, 0, Data);
                        }
                    }
                } else {
                    //
                    // Suppressed GUID checks
                    //

                    Data = (PCTSTR) GetRegKeyData (ClsIdKey, TEXT("Interface"));
                    if (Data) {
                        MemDbBuildKey (Node, MEMDB_CATEGORY_GUIDS, NULL, NULL, Data);
                        if (MemDbGetValue (Node, NULL)) {
                            DEBUGMSG ((DBG_WARNING,
                                       "Suppressed GUID %s has Interface reference "
                                            "to unsuppressed %s (potential leak)",
                                       e.SubKeyName, Data));
                            pAddOleWarning (MSG_GUID_LEAK, ClsIdKey, e.SubKeyName);
                        }

                        MemFree (g_hHeap, 0, Data);
                    }
                }

                CloseRegKey (ClsIdKey);
            }

        } while (EnumNextRegKey (&e));
    }

    //
    // Look for problems with an HKCR\Interface entry
    //

    if (EnumFirstRegKeyStr (&e, TEXT("HKCR\\Interface"))) {
        do {
            InterfaceKey = OpenRegKey (e.KeyHandle, e.SubKeyName);

            MemDbBuildKey (Node, MEMDB_CATEGORY_GUIDS, NULL, NULL, e.SubKeyName);
            Suppressed = MemDbGetValue (Node, NULL);

            if (InterfaceKey) {

                for (i = 0 ; g_InterfaceRefKeys[i] ; i++) {
                    Data = (PCTSTR) GetRegKeyData (
                                            InterfaceKey,
                                            g_InterfaceRefKeys[i]
                                            );

                    if (Data) {
                        //
                        // Check if reference to other GUID is suppressed
                        //

                        MemDbBuildKey (Node, MEMDB_CATEGORY_GUIDS, NULL, NULL, Data);
                        if (MemDbGetValue (Node, NULL)) {
                            if (!Suppressed) {
                                TCHAR CompleteKey[MAX_REGISTRY_KEY];

                                //
                                // Interface is not suppressed, but it points to a
                                // suppressed interface.
                                //

                                wsprintf (
                                    CompleteKey,
                                    TEXT("HKCR\\Interface\\%s"),
                                    e.SubKeyName
                                    );

                                DEBUGMSG ((
                                    DBG_WARNING,
                                    "GUID %s %s subkey points to suppressed GUID %s",
                                     e.SubKeyName,
                                     g_InterfaceRefKeys[i],
                                     Data
                                     ));

                                pAddOleWarning (
                                     MSG_INTERFACE_BROKEN,
                                     InterfaceKey,
                                     CompleteKey
                                     );
                            }
                        } else {
                            if (Suppressed) {
                                TCHAR CompleteKey[MAX_REGISTRY_KEY];

                                //
                                // Interface is suppressed, but it points to an
                                // unsuppressed interface.
                                //

                                wsprintf (
                                    CompleteKey,
                                    TEXT("HKCR\\Interface\\%s"),
                                    e.SubKeyName
                                    );

                                DEBUGMSG ((
                                    DBG_WARNING,
                                    "Suppressed GUID %s %s subkey points to "
                                        "unsuppressed GUID %s (potential leak)",
                                    e.SubKeyName,
                                    g_InterfaceRefKeys[i],
                                    Data
                                    ));

                                pAddOleWarning (
                                    MSG_POTENTIAL_INTERFACE_LEAK,
                                    InterfaceKey,
                                    CompleteKey
                                    );
                            }
                        }

                        MemFree (g_hHeap, 0, Data);
                    }
                }

                CloseRegKey (InterfaceKey);
            }
        } while (EnumNextRegKey (&e));
    }

    return TRUE;
}
#endif


VOID
pProcessAutoSuppress (
    IN OUT  HASHTABLE StrTab
    )

/*++

Routine Description:

  Performs a number of tests to identify OLE objects that are not compatible
  with Windows NT.  The tests are based on a list of incompatible files stored
  in memdb.  Any OLE object that depends on a file that will not exist on NT
  is automatically suppressed.

Arguments:

  StrTab - Specifies the string table that holds suppressed GUIDs

Return Value:

  none

--*/

{
    REGKEY_ENUM e, eVer, eNr;
    HKEY ClsIdKey;
    HKEY TypeLibKey;
    HKEY VerKey;
    HKEY NrKey;
    HKEY SubSysKey;
    TCHAR Node[MEMDB_MAX];
    BOOL Suppressed;
    PCTSTR Data;
    BOOL ValidNr;
    BOOL ValidVer;
    BOOL ValidGUID;

    //
    // Search HKCR\CLSID for objects that require a Win95-specific binary
    //

    DEBUGMSG ((DBG_OLEREG, "Looking for CLSID problems..."));

    if (EnumFirstRegKeyStr (&e, TEXT("HKCR\\CLSID"))) {
        do {
            //
            // Verify key is not garbage
            //

            if (!FixGuid (e.SubKeyName, e.SubKeyName)) {
                DEBUGMSG ((
                    DBG_OLEREG,
                    "Garbage key ignored: HKCR\\CLSID\\%s",
                    e.SubKeyName
                    ));

                continue;
            }

            ClsIdKey = OpenRegKey (e.KeyHandle, e.SubKeyName);

            //
            // Determine if this GUID is suppressed
            //

            MemDbBuildKey (Node, MEMDB_CATEGORY_GUIDS, NULL, NULL, e.SubKeyName);
            Suppressed = MemDbGetValue (Node, NULL);

            if (ClsIdKey) {

                if (!Suppressed) {
                    //
                    // Unsuppressed GUID checks
                    //

                    // AutoConvertTo
                    Data = (PCTSTR) GetRegKeyData (ClsIdKey, TEXT("AutoConvertTo"));
                    if (Data) {
                        //
                        // Check if AutoConvertTo is pointing to suppressed GUID
                        //

                        MemDbBuildKey (Node, MEMDB_CATEGORY_GUIDS, NULL, NULL, Data);
                        if (MemDbGetValue (Node, NULL)) {

                            DEBUGMSG ((
                                DBG_OLEREG,
                                "GUID %s points to deleted GUID %s -> "
                                    "Auto-suppressed",
                                e.SubKeyName,
                                Data
                                ));

                            pAddGuidToTable (StrTab, e.SubKeyName);
                        }

                        MemFree (g_hHeap, 0, Data);
                    }

                    // File references
                    pSuppressGuidIfBadCmdLine (StrTab, ClsIdKey, e.SubKeyName);
                }

                CloseRegKey (ClsIdKey);
            }

        } while (EnumNextRegKey (&e));
    }

    DEBUGMSG ((DBG_OLEREG, "Looking for TypeLib problems..."));

    if (EnumFirstRegKeyStr (&e, TEXT("HKCR\\TypeLib"))) {
        do {
            //
            // Verify key is not garbage
            //

            if (!FixGuid (e.SubKeyName, e.SubKeyName)) {
                DEBUGMSG ((
                    DBG_OLEREG,
                    "Garbage key ignored: HKCR\\TypeLib\\%s",
                    e.SubKeyName
                    ));

                continue;
            }

            TypeLibKey = OpenRegKey (e.KeyHandle, e.SubKeyName);

            if (TypeLibKey) {

                MemDbBuildKey (Node, MEMDB_CATEGORY_GUIDS, NULL, NULL, e.SubKeyName);
                Suppressed = MemDbGetValue (Node, NULL);

                if (!Suppressed) {

                    ValidGUID = FALSE;

                    //
                    // Enumerating all versions
                    //
                    if (EnumFirstRegKey (&eVer, TypeLibKey)) {
                        do {

                            VerKey = OpenRegKey (eVer.KeyHandle, eVer.SubKeyName);

                            if (VerKey) {

                                ValidVer = FALSE;

                                //
                                // Enumerating all subkeys except HELPDIR and FLAGS
                                //
                                if (EnumFirstRegKey (&eNr, VerKey)) {
                                    do {
                                        if (StringIMatch (eNr.SubKeyName, TEXT("FLAGS"))) {
                                            continue;
                                        }
                                        if (StringIMatch (eNr.SubKeyName, TEXT("HELPDIR"))) {
                                            continue;
                                        }

                                        NrKey = OpenRegKey (eNr.KeyHandle, eNr.SubKeyName);

                                        if (NrKey) {

                                            ValidNr = FALSE;

                                            SubSysKey = OpenRegKey (NrKey, TEXT("win16"));

                                            if (SubSysKey) {

                                                Data = GetRegValueString (SubSysKey, TEXT(""));

                                                if (Data) {

                                                    if (pIsCmdLineBad (Data)) {

                                                        wsprintf (
                                                            Node,
                                                            "%s\\SOFTWARE\\Classes\\TypeLib\\%s\\%s\\%s\\%s",
                                                            MEMDB_CATEGORY_HKLM,
                                                            e.SubKeyName,
                                                            eVer.SubKeyName,
                                                            eNr.SubKeyName,
                                                            TEXT("win16")
                                                            );
                                                        Suppress95RegSetting(Node, NULL);
                                                    }
                                                    else {
                                                        ValidNr = TRUE;
                                                    }
                                                    MemFree (g_hHeap, 0, Data);
                                                }

                                                CloseRegKey (SubSysKey);
                                            }

                                            SubSysKey = OpenRegKey (NrKey, TEXT("win32"));

                                            if (SubSysKey) {

                                                Data = GetRegValueString (SubSysKey, TEXT(""));

                                                if (Data) {

                                                    if (pIsCmdLineBad (Data)) {

                                                        wsprintf (
                                                            Node,
                                                            "%s\\SOFTWARE\\Classes\\TypeLib\\%s\\%s\\%s\\%s",
                                                            MEMDB_CATEGORY_HKLM,
                                                            e.SubKeyName,
                                                            eVer.SubKeyName,
                                                            eNr.SubKeyName,
                                                            TEXT("win32")
                                                            );
                                                        Suppress95RegSetting(Node, NULL);
                                                    }
                                                    else {
                                                        ValidNr = TRUE;
                                                    }
                                                    MemFree (g_hHeap, 0, Data);
                                                }

                                                CloseRegKey (SubSysKey);
                                            }

                                            CloseRegKey (NrKey);

                                            if (!ValidNr) {
                                                wsprintf (
                                                    Node,
                                                    "%s\\SOFTWARE\\Classes\\TypeLib\\%s\\%s\\%s",
                                                    MEMDB_CATEGORY_HKLM,
                                                    e.SubKeyName,
                                                    eVer.SubKeyName,
                                                    eNr.SubKeyName
                                                    );
                                                Suppress95RegSetting(Node, NULL);
                                            }
                                            else {
                                                ValidVer = TRUE;
                                            }
                                        }

                                    } while (EnumNextRegKey (&eNr));
                                }

                                CloseRegKey (VerKey);

                                if (!ValidVer) {
                                    wsprintf (
                                        Node,
                                        "%s\\SOFTWARE\\Classes\\TypeLib\\%s\\%s",
                                        MEMDB_CATEGORY_HKLM,
                                        e.SubKeyName,
                                        eVer.SubKeyName
                                        );
                                    Suppress95RegSetting(Node, NULL);
                                }
                                else {
                                    ValidGUID = TRUE;
                                }
                            }
                        } while (EnumNextRegKey (&eVer));
                    }

                    if (!ValidGUID) {

                        DEBUGMSG ((
                            DBG_OLEREG,
                            "TypeLib GUID %s is suppressed",
                            e.SubKeyName
                            ));

                        MemDbSetValueEx (MEMDB_CATEGORY_GUIDS, NULL, NULL, e.SubKeyName, 0, NULL);
                    }
                }

                CloseRegKey (TypeLibKey);
            }

        } while (EnumNextRegKey (&e));
    }

}



BOOL
pGetFirstRegKeyThatHasGuid (
    OUT     PGUIDKEYSEARCH EnumPtr,
    IN      HKEY RootKey
    )

/*++

Routine Description:

  pGetFirstRegKeyThatHasGuid starts an enumeration of an OLE object's
  ShellEx subkey.  This subkey has zero or more handlers, and each
  handler has zero or more GUIDs.  This ShellEx enumerator returns
  the first GUID subkey found under the supplied root.

Arguments:

  EnumPtr   - An uninitialized GUIDKEYSEARCH struct that is used
              to maintain enumeration state and to report the match
              found.
  RootKey   - The registry key to begin enumerating at.

Return Value:

  TRUE if a GUID was found in a handler that is a subkey of RootKey, or
  FALSE if no GUIDs were found.

--*/

{
    EnumPtr->State = GUIDKEYSEARCH_FIRST_HANDLER;
    EnumPtr->RootKey = RootKey;
    return pGetNextRegKeyThatHasGuid (EnumPtr);
}


BOOL
pGetNextRegKeyThatHasGuid (
    IN OUT  PGUIDKEYSEARCH EnumPtr
    )

/*++

Routine Description:

  The "next" enumerator for ShellEx registry key enumeration.  This
  enumerator returns the next instance of a GUID in the registry
  (under an OLE object's ShellEx subkey).

Arguments:

  EnumPtr - The GUIDKEYSEARCH structure used to begin the search.
            If a GUID is found, this structure holds the location
            of the GUID key found.

Return Value:

  TRUE if a subkey identifying a GUID was found, or FALSE if no
  more instances exist.

--*/

{
    BOOL Found = FALSE;

    do {
        switch (EnumPtr->State) {

        case GUIDKEYSEARCH_FIRST_HANDLER:
            //
            // Get the name of the first handler
            //

            if (!EnumFirstRegKey (&EnumPtr->Handlers, EnumPtr->RootKey)) {
                return FALSE;
            }

            EnumPtr->State = GUIDKEYSEARCH_FIRST_GUID;
            break;

        case GUIDKEYSEARCH_NEXT_HANDLER:
            //
            // Get the name of the next handler
            //

            if (!EnumNextRegKey (&EnumPtr->Handlers)) {
                return FALSE;
            }

            EnumPtr->State = GUIDKEYSEARCH_FIRST_GUID;
            break;

        case GUIDKEYSEARCH_FIRST_GUID:
            //
            // Begin GUID key enumeration
            //

            EnumPtr->HandlerKey = OpenRegKey (EnumPtr->Handlers.KeyHandle,
                                              EnumPtr->Handlers.SubKeyName);

            // Assume no GUIDs
            EnumPtr->State = GUIDKEYSEARCH_NEXT_HANDLER;

            if (EnumPtr->HandlerKey) {

                if (EnumFirstRegKey (&EnumPtr->Guids, EnumPtr->HandlerKey)) {
                    //
                    // There is at least one key that may be a GUID in this handler
                    //
                    Found = FixGuid (EnumPtr->Guids.SubKeyName, EnumPtr->Guids.SubKeyName);
                    EnumPtr->State = GUIDKEYSEARCH_NEXT_GUID;
                } else {
                    CloseRegKey (EnumPtr->HandlerKey);
                }
            }
            break;

        case GUIDKEYSEARCH_NEXT_GUID:
            //
            // Continue GUID key enumeration
            //

            if (!EnumNextRegKey (&EnumPtr->Guids)) {
                CloseRegKey (EnumPtr->HandlerKey);
                EnumPtr->State = GUIDKEYSEARCH_NEXT_HANDLER;
            } else {
                Found = FixGuid (EnumPtr->Guids.SubKeyName, EnumPtr->Guids.SubKeyName);
            }
            break;
        }
    } while (!Found);

    EnumPtr->KeyName = EnumPtr->Guids.SubKeyName;

    return TRUE;
}


DWORD
pCountGuids (
    IN      PGUIDKEYSEARCH EnumPtr
    )

/*++

Routine Description:

  Given a valid EnumPtr, this function will count the total number
  of GUIDs in the current handler.

Arguments:

  EnumPtr - Must be a valid GUIDKEYSEARCH structure, prepared by
            pGetFirstRegKeyThatHasGuid or pGetNextRegKeyThatHasGuid.

Return Value:

  The count of valid GUIDs for the current handler.

--*/

{
    REGKEY_ENUM e;
    DWORD Count = 0;

    //
    // Count the number of GUIDs in the current handler
    //

    if (EnumPtr->State == GUIDKEYSEARCH_NEXT_GUID) {
        if (EnumFirstRegKey (&e, EnumPtr->HandlerKey)) {
            do {
                Count++;
            } while (EnumNextRegKey (&e));
        }
    }

    return Count;
}


BOOL
pFillHashTableWithKeyNames (
    OUT     HASHTABLE Table,
    IN      HINF InfFile,
    IN      PCTSTR Section
    )

/*++

Routine Description:

  A general-purpose INF-to-string table copy routine.  Takes the keys
  in a given section and adds them to the supplied string table.

Arguments:

  Table     - A pointer to an initialize string table
  InfFile   - The handle to an open INF file
  Section   - Section within the INF file containing strings

Return Value:

  TRUE if no errors were encountered.

--*/

{
    INFCONTEXT ic;
    TCHAR Key[MAX_ENCODED_RULE];

    if (SetupFindFirstLine (InfFile, Section, NULL, &ic)) {
        do {
            if (SetupGetStringField (&ic, 0, Key, MAX_ENCODED_RULE, NULL)) {
                HtAddString (Table, Key);
            }
            ELSE_DEBUGMSG ((
                DBG_WARNING,
                "No key for line in section %s (line %u)",
                Section,
                ic.Line
                ));

        } while (SetupFindNextLine (&ic, &ic));
    }
    ELSE_DEBUGMSG ((DBG_WARNING, "Section %s is empty", Section));

    return TRUE;
}


BOOL
pSuppressProgId (
    PCTSTR ProgIdName
    )

/*++

Routine Description:

  Suppresses a ProgID registry key.

Arguments:

  ProgIdName  - The name of the OLE ProgID to suppress

Return Value:

  TRUE if ProgIdName is a valid ProgID on the system.

--*/

{
    TCHAR RegKey[MAX_REGISTRY_KEY];
    HKEY ProgIdKey;
    TCHAR MemDbKey[MEMDB_MAX];

    if (*ProgIdName) {
        wsprintf (RegKey, TEXT("HKCR\\%s"), ProgIdName);
        ProgIdKey = OpenRegKeyStr (RegKey);

        if (ProgIdKey) {
            CloseRegKey (ProgIdKey);
            DEBUGMSG ((DBG_OLEREG, "Suppressing ProgId: %s", ProgIdName));
            MemDbSetValueEx (MEMDB_CATEGORY_PROGIDS, NULL, NULL, ProgIdName, PROGID_SUPPRESSED, NULL);

            MemDbBuildKey(MemDbKey,MEMDB_CATEGORY_HKLM, TEXT("SOFTWARE\\Classes"), NULL, ProgIdName);
            Suppress95RegSetting(MemDbKey,NULL);
            return TRUE;
        }
    }

    return FALSE;
}


VOID
pSuppressGuidInClsId (
    IN      PCTSTR Guid
    )

/*++

Routine Description:

  Does all the work necessary to suppress a GUID and its associated
  ProgID (if it has one).

Arguments:

  Guid - The string identifing a GUID that is in HKCR\CLSID

Return Value:

  none

--*/

{
    TCHAR Node[MEMDB_MAX];
    MEMDB_ENUM e;
    HKEY GuidKey;
    PCTSTR Data;

    MYASSERT (IsGuid (Guid, TRUE));

    if (pIgnoreGuid (Guid)) {
        return;
    }

    //
    //  - Remove it from UGUIDS memdb category
    //  - Add it to GUIDS memdb category
    //  - Suppress HKLM\SOFTWARE\Classes\CLSID\<GUID>
    //  - Suppress HKLM\SOFTWARE\Classes\Interface\<GUID>
    //

    // Suppress all TreatAs GUIDs
    if (MemDbGetValueEx (&e, MEMDB_CATEGORY_UNSUP_GUIDS, Guid, NULL)) {
        do {
            pSuppressGuidInClsId (e.szName);
        } while (MemDbEnumNextValue (&e));
    }

    // Remove TreatAs GUIDs
    MemDbBuildKey (Node, MEMDB_CATEGORY_UNSUP_GUIDS, Guid, NULL, NULL);
    MemDbDeleteTree (Node);

    // Add to suppressed GUID category and to registry suppression
    MemDbSetValueEx (MEMDB_CATEGORY_GUIDS, NULL, NULL, Guid, 0, NULL);

    // Get ProgID of GUID
    wsprintf (Node, TEXT("HKCR\\CLSID\\%s"), Guid);
    GuidKey = OpenRegKeyStr (Node);
    if (GuidKey) {
        BOOL ProgIdFound = FALSE;

        // Suppress ProgIDs
        Data = (PCTSTR) GetRegKeyData (GuidKey, TEXT("ProgID"));
        if (Data) {
            ProgIdFound |= pSuppressProgId (Data);
            MemFree (g_hHeap, 0, Data);
        }

        // Version-independent ProgIDs
        Data = (PCTSTR) GetRegKeyData (GuidKey, TEXT("VersionIndependentProgID"));
        if (Data) {
            ProgIdFound |= pSuppressProgId (Data);
            MemFree (g_hHeap, 0, Data);
        }

        // Possibly the default name
        Data = (PCTSTR) GetRegValueData (GuidKey, TEXT(""));
        if (Data) {
            ProgIdFound |= pSuppressProgId (Data);
            MemFree (g_hHeap, 0, Data);
        }

        DEBUGMSG_IF ((
            !ProgIdFound,
            DBG_OLEREG,
            "The suppressed registry key %s has no associated ProgID",
            Node
            ));

        CloseRegKey (GuidKey);
    }
}


VOID
pAddUnsuppressedTreatAsGuid (
    PCTSTR Guid,
    PCTSTR TreatAsGuid
    )

/*++

Routine Description:

  Keeps track of unsuppressed TreatAs GUIDs that need further processing.

Arguments:

  Guid          - A string identifying the GUID that should be treated as
                  another GUID
  TreatAsGuid   - The replacement GUID

Return Value:

  none

--*/

{
    MemDbSetValueEx (MEMDB_CATEGORY_UNSUP_GUIDS, Guid, NULL, TreatAsGuid, 0, NULL);
}


VOID
pRemoveUnsuppressedTreatAsGuids (
    VOID
    )

/*++

Routine Description:

  Cleanup function for unsuppressed GUIDs.

Arguments:

  none

Return Value:

  none

--*/

{
    TCHAR Node[MEMDB_MAX];

    MemDbBuildKey (Node, MEMDB_CATEGORY_UNSUP_GUIDS, NULL, NULL, NULL);
    MemDbDeleteTree (Node);
}


VOID
pAddOleWarning (
    IN      WORD MsgId,
    IN      HKEY Object,            OPTIONAL
    IN      PCTSTR KeyName
    )

/*++

Routine Description:

  Adds a warning to the incompatibility report.  It loads the human-readable
  name from the specified OLE registry key.  The message is formatted with
  the human-readable object name as the first parameter and the registry
  location as the second parameter.

Arguments:

  MsgID     - Supplies the ID of the message to display

  Object    - Specifies the handle of a registry key whos default value
              is a human-readable object name.

  KeyName   - The registry key location

Return Value:

  none

--*/

{
    PCTSTR Data;

    if (Object) {
        Data = (PCTSTR) GetRegValueData (Object, S_EMPTY);
    } else {
        Data = NULL;
    }

    LOG ((LOG_WARNING, (PCSTR)MsgId, Data ? Data : S_EMPTY, KeyName, g_Win95Name));

    if (Data) {
        MemFree (g_hHeap, 0, Data);
    }
}


VOID
pSuppressGuidIfBadCmdLine (
    IN      HASHTABLE StrTab,
    IN      HKEY ClsIdKey,
    IN      PCTSTR GuidStr
    )

/*++

Routine Description:

  Suppresses the specified GUID if its CLSID settings reference a Win9x-
  specific binary.  The suppression is written to a string table which
  is later transfered to memdb.  The transfer operation suppresses all
  linkage to the GUID.

Arguments:

  StrTab    - The table that holds a list of suppressed GUIDs

  ClsIdKey  - The registry handle of a subkey of HKCR\CLSID

  GuidStr   - The GUID to suppress if an invalid command line is found

Return Value:

  none

--*/

{
    PCTSTR Data;
    INT i;
    BOOL b;

    MYASSERT (IsGuid (GuidStr, TRUE));

    if (pIgnoreGuid (GuidStr)) {
        return;
    }

    for (i = 0 ; g_FileRefKeys[i] ; i++) {
        Data = (PCTSTR) GetRegKeyData (ClsIdKey, g_FileRefKeys[i]);
        if (Data) {
            //
            // Check if the file in Data is in Win9xFileLocation for any user
            //

            b = pSuppressGuidIfCmdLineBad (
                    StrTab,
                    Data,
                    ClsIdKey,
                    GuidStr
                    );

            MemFree (g_hHeap, 0, Data);

            if (b) {
                return;
            }
        }
    }
}


VOID
pSuppressProgIdWithBadCmdLine (
    IN      HKEY ProgId,
    IN      PCTSTR ProgIdStr
    )

/*++

Routine Description:

  Suppresses the specified ProgId if it references a Win9x-specific binary.
  The suppression is written directly to memdb.

  This function is called after all Suppressed GUIDs have been processed,
  and is used to suppress OLE objects that are not caught by an invalid
  HKCR\CLSID entry.

Arguments:

  ProgId    - The registry handle of a subkey of the root of HKCR

  ProgIdStr - The name of the ProgID key to suppress if a bad cmd line is
              found.

Return Value:

  none

--*/


{
    PCTSTR Data;
    INT i;

    for (i = 0 ; g_FileRefKeys[i]; i++) {

        Data = (PCTSTR) GetRegKeyData (ProgId, g_FileRefKeys[i]);
        if (Data) {
            //
            // Check if the file in Data is in Win9xFileLocation for any user
            //

            if (pIsCmdLineBad (Data)) {
                DEBUGMSG ((DBG_OLEREG, "ProgID %s has incompatible command line %s", ProgId, Data));

                pSuppressProgId (ProgIdStr);
                break;
            }

            MemFree (g_hHeap, 0, Data);
        }
    }
}


VOID
pAddGuidToTable (
    IN      HASHTABLE Table,
    IN      PCTSTR GuidStr
    )

/*++

Routine Description:

  Adds a GUID to a string table.  For checked builds, it does a quick
  test to see how many GUIDs get suppressed more than once.

Arguments:

  Table   - Specifies table that receives the GUID entry

  GuidStr - Specifies the string of the GUID

Return Value:

  none

--*/

{
#ifdef DEBUG
    //
    // Just for yuks, let's see if we're wasting time by suppressing
    // an already suppressed GUID...
    //

    DWORD rc;

    if (HtFindString (Table, GuidStr)) {
        DEBUGMSG ((DBG_OLEREG, "FYI - GUID %s is already suppressed", GuidStr));
    }

    MYASSERT (IsGuid (GuidStr, TRUE));
#endif


    HtAddString (Table, GuidStr);
}


BOOL
pSuppressGuidIfCmdLineBad (
    IN OUT  HASHTABLE StrTab,           OPTIONAL
    IN      PCTSTR CmdLine,
    IN      HKEY DescriptionKey,
    IN      PCTSTR GuidStr              OPTIONAL
    )

/*++

Routine Description:

  Suppresses an OLE object if the specified command line contains a Win9x-
  specific binary.  Only the first argument of the command line is examined;
  an other arguments that cannot be upgraded are ignored.

Arguments:

  StrTab         - Specifies the table that holds the list of suppressed GUIDs.
                   If NULL, a warning will be displayed, and GuidKey must not be
                   NULL.

  CmdLine        - Specifies the command line to examine

  DescriptionKey - Specifies a key whos default value is the description of the
                   object.

  GuidStr        - Specifies the GUID string. This parameter is optional only
                   if StrTab is NULL.

Return Value:

  TRUE if CmdLine is incompatible, FALSE otherwise.

--*/

{
    BOOL b = FALSE;

    if (GuidStr) {
        MYASSERT (IsGuid (GuidStr, TRUE));

        if (pIgnoreGuid (GuidStr)) {
            return TRUE;
        }
    }

    if (pIsCmdLineBad (CmdLine)) {
        //
        // OLE object points to deleted file
        //

        b = TRUE;

        if (!StrTab) {
            // Warning!!
            DEBUGMSG ((DBG_WARNING,
                       "Reg key %s points to deleted file %s",
                       GuidStr, CmdLine));

            pAddOleWarning (
                MSG_OBJECT_POINTS_TO_DELETED_FILE,
                DescriptionKey,
                GuidStr
                );

        } else {
            MYASSERT (GuidStr);

            DEBUGMSG ((
                DBG_OLEREG,
                "Auto-suppressed %s because it requires a Win9x-specific file: %s",
                GuidStr,
                CmdLine
                ));

            pAddGuidToTable (StrTab, GuidStr);
        }
    }

    return b;
}


BOOL
pSearchSubkeyDataForBadFiles (
    IN OUT  HASHTABLE SuppressTable,
    IN      HKEY KeyHandle,
    IN      PCTSTR LastKey,
    IN      PCTSTR GuidStr,
    IN      HKEY DescriptionKey
    )

/*++

Routine Description:

  Scans a number of OLE settings for bad command lines, including the
  object's command and the default icon binary.  If a reference to a
  Win9x-specific binary is detected, the GUID is suppressed.

  This function recurses through all subkeys of the OLE object.

Arguments:

  SuppressTable  - Specifies the table that holds the suppressed GUID list

  KeyHandle      - An open registry key of an OLE object to be examined
                   recursively.

  LastKey        - Specifies the name of the OLE object's subkey being
                   processed.  Special processing is done for some subkeys.

  GuidStr        - The GUID of the OLE object.

  DescriptionKey - A handle to the key who's default value identifies the
                   OLE object's key.

Return Value:

  TRUE if an incompatible cmd line was found, FALSE otherwise.

--*/

{
    REGKEY_ENUM ek;
    REGVALUE_ENUM ev;
    HKEY SubKeyHandle;
    PCTSTR Data;
    BOOL b;

    MYASSERT (IsGuid (GuidStr, FALSE));

    if (StringIMatch (LastKey, TEXT("Command")) ||
        StringIMatch (LastKey, g_DefaultIcon)
        ) {
        if (EnumFirstRegValue (&ev, KeyHandle)) {
            do {
                Data = (PCTSTR) GetRegValueData (KeyHandle, ev.ValueName);
                if (Data) {
                    // If this thing has a path name somewhere, process it
                    b = pSuppressGuidIfCmdLineBad (
                            SuppressTable,
                            Data,
                            DescriptionKey,
                            GuidStr
                            );

                    MemFree (g_hHeap, 0, Data);

                    if (b) {
                        return TRUE;
                    }
                }
            } while (EnumNextRegValue (&ev));
        }
    }

    if (EnumFirstRegKey (&ek, KeyHandle)) {
        do {
            SubKeyHandle = OpenRegKey (ek.KeyHandle, ek.SubKeyName);
            if (SubKeyHandle) {
                b = pSearchSubkeyDataForBadFiles (
                        SuppressTable,
                        SubKeyHandle,
                        ek.SubKeyName,
                        GuidStr,
                        DescriptionKey
                        );

                CloseRegKey (SubKeyHandle);

                if (b) {
                    AbortRegKeyEnum (&ek);
                    return TRUE;
                }
            }
        } while (EnumNextRegKey (&ek));
    }

    return FALSE;
}



BOOL
pIsCmdLineBadEx (
    IN      PCTSTR CmdLine,
    OUT     PBOOL  UsableIsvCmdLine OPTIONAL
    )

/*++

Routine Description:

  Determines if the specified command line's first argument is listed in
  memdb's Win9xFileLocation category.  If it is listed, and the file is
  marked for permanent removal, TRUE is returned.  If it is not listed,
  or if it is listed but has an NT equivalent, FALSE is returned.

Arguments:

  CmdLine           - Specifies the command line to examine
  UsableIsvCmdLine  - Optional variable that receives wether the
                      command line contains a compatible third
                      party cmd line.

Return Value:

  TRUE if command line requires Win9x-specific binaries, FALSE if
  the command line uses a valid binary or is not a command line.

--*/

{
    BOOL FileMarked = FALSE;
    TCHAR ArgZero[MAX_CMDLINE];
    TCHAR LongPath[MAX_TCHAR_PATH];
    DWORD status;


    if (UsableIsvCmdLine) {
        *UsableIsvCmdLine = FALSE;
    }

    //
    // Determine if the first arg of the command line points to a
    // deleted (or moved) file
    //

    ExtractArgZeroEx (CmdLine, ArgZero, TEXT(","), FALSE);

    if (OurGetLongPathName (ArgZero, LongPath, MAX_TCHAR_PATH)) {
        status = GetFileStatusOnNt (LongPath);
        if ((status & FILESTATUS_DELETED) == FILESTATUS_DELETED) {
            return TRUE;
        }
        else if (UsableIsvCmdLine) {

            status = GetOperationsOnPath (LongPath);
            if ((status & OPERATION_OS_FILE) != OPERATION_OS_FILE) {
                *UsableIsvCmdLine = TRUE;
            }
        }
    }
    ELSE_DEBUGMSG ((
        DBG_OLEREG,
        "pIsCmdLineBad: Cannot get full path name; assuming %s is not a command line",
        ArgZero
        ));

    return FALSE;

}



BOOL
pIsCmdLineBad (
    IN      PCTSTR CmdLine
    )
{
    return pIsCmdLineBadEx (CmdLine, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\sysmig\ras.c ===
/*++

Copyright (c) 1997-2001 Microsoft Corporation

Module Name:

    ras.c

Abstract:

    ras.c runs as a part of w95upg.dll in winnt32.exe during Win9x migrations.
    Saves connectoid information for later retrieval during Guimode setup.

Author:

    Marc R. Whitten (marcw) 23-Nov-1997

Revision History:

    Marc R. Whitten marcw 23-Jul-1998 - Major cleanup.
    Jeff Sigman           09-Apr-2001 - Whistler cleanup.

      Whistler bugs:
        34270  Win9x: Upgrade: Require Data Encryption setting for VPN
               connections is not migrated
        125693 UpgLab9x: DUN Connectoids don't migrate selected modem properly
               from Win9x
        208318 Win9x Upg: Username and Password for DUN connectoid not migrated
               from Win9x to Whistler

--*/

#include "pch.h" // Pre-compiled

//
// Macros
//
#define PAESMMCFG(pAE) ((PSMMCFG)(((PBYTE)pAE)+(pAE->uOffSMMCfg)))
#define PAESMM(pAE) ((PSTR)(((PBYTE)pAE)+(pAE->uOffSMM)))
#define PAEDI(pAE) ((PDEVICEINFO)(((PBYTE)pAE)+(pAE->uOffDI    )))
#define PAEAREA(pAE)    ((PSTR)(((PBYTE)pAE)+(pAE->uOffArea)))
#define PAEPHONE(pAE)   ((PSTR)(((PBYTE)pAE)+(pAE->uOffPhone)))
#define DECRYPTENTRY(x, y, z)   EnDecryptEntry(x, (LPBYTE)y, z)

typedef LPVOID HPWL;
typedef HPWL* LPHPWL;

typedef struct {
    DWORD Size;
    DWORD Unknown1;
    DWORD ModemUiOptions;         // num seconds in high byte.
    DWORD Unknown3;               // 0 = Not Set.
    DWORD Unknown4;
    DWORD Unknown5;
    DWORD ConnectionSpeed;
    DWORD UnknownFlowControlData; //Somehow related to flow control.
    DWORD Unknown8;
    DWORD Unknown9;
    DWORD Unknown10;
    DWORD Unknown11;
    DWORD Unknown12;
    DWORD Unknown13;
    DWORD Unknown14;
    DWORD Unknown15;
    DWORD Unknown16;
    DWORD Unknown17;
    DWORD Unknown18;
    DWORD dwCallSetupFailTimer; // Num seconds to wait before cancel if not
                                // connected. (0xFF equals off.)
    DWORD dwInactivityTimeout;  // 0 = Not Set.
    DWORD Unknown21;
    DWORD SpeakerVolume;        // 0|1
    DWORD ConfigOptions;
    DWORD Unknown24;
    DWORD Unknown25;
    DWORD Unknown26;
} MODEMDEVINFO, *PMODEMDEVINFO;

DEFINE_GUID(GUID_DEVCLASS_MODEM,
 0x4d36e96dL, 0xe325, 0x11ce, 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 );

//
// Globals
//
POOLHANDLE g_RasPool;
BOOL       g_RasInstalled = FALSE;
BOOL       g_MultilinkEnabled;
HINSTANCE  g_RasApi32 = NULL;

DWORD (* g_RnaGetDefaultAutodialConnection) (
    LPBYTE  lpBuf,
    DWORD   cb,
    LPDWORD lpdwOptions
    );

//
// Routines and structures for dealing with the Addresses\<entry> blob..
//
// AddrEntry serves as a header for the entire block of data in the <entry>
// blob. entries in it are offsets to the strings which follow it..in many
// cases (i.e. all of the *Off* members...)
//
typedef struct  _AddrEntry {
    DWORD       dwVersion;
    DWORD       dwCountryCode;
    UINT        uOffArea;
    UINT        uOffPhone;
    DWORD       dwCountryID;
    UINT        uOffSMMCfg;
    UINT        uOffSMM;
    UINT        uOffDI;
}   ADDRENTRY, *PADDRENTRY;

typedef struct _SubConnEntry {
    DWORD       dwSize;
    DWORD       dwFlags;
    char        szDeviceType[RAS_MaxDeviceType+1];
    char        szDeviceName[RAS_MaxDeviceName+1];
    char        szLocal[RAS_MaxPhoneNumber+1];
}   SUBCONNENTRY, *PSUBCONNENTRY;

typedef struct _IPData {
    DWORD     dwSize;
    DWORD     fdwTCPIP;
    DWORD     dwIPAddr;
    DWORD     dwDNSAddr;
    DWORD     dwDNSAddrAlt;
    DWORD     dwWINSAddr;
    DWORD     dwWINSAddrAlt;
}   IPDATA, *PIPDATA;

typedef struct  _DEVICEINFO {
    DWORD       dwVersion;
    UINT        uSize;
    char        szDeviceName[RAS_MaxDeviceName+1];
    char        szDeviceType[RAS_MaxDeviceType+1];
}   DEVICEINFO, *PDEVICEINFO;

typedef struct  _SMMCFG {
    DWORD       dwSize;
    DWORD       fdwOptions;
    DWORD       fdwProtocols;
}   SMMCFG, *PSMMCFG;

static BYTE NEAR PASCAL GenerateEncryptKey (LPSTR szKey)
{
    BYTE   bKey;
    LPBYTE lpKey;

    for (bKey = 0, lpKey = (LPBYTE)szKey; *lpKey != 0; lpKey++)
    {
        bKey += *lpKey;
    };

    return bKey;
}

DWORD NEAR PASCAL
EnDecryptEntry (
    LPSTR  szEntry,
    LPBYTE lpEnt,
    DWORD  cb
    )
{
    BYTE   bKey;

    //
    // Generate the encryption key from the entry name
    //
    bKey = GenerateEncryptKey(szEntry);
    //
    // Encrypt the address entry one byte at a time
    //
    for (;cb > 0; cb--, lpEnt++)
    {
        *lpEnt ^= bKey;
    };
    return ERROR_SUCCESS;
}

//
// Find out if current connection is the default connection for current user
//
// Whistler 417479 RAS upgrade code does not migrate the default
// internet connection setting from WinME to XP
//
BOOL
IsDefInternetCon(
    IN PCTSTR szEntry
    )
{
    BOOL bRet = FALSE;

    if (g_RnaGetDefaultAutodialConnection && szEntry)
    {
        DWORD dwAutodialOptions;
        UCHAR szDefEntry[MAX_PATH + 1];

        //
        // Whistler bug: 417745 INTL:Win9x Upg: DBCS chars cause User,Domain,
        // Passwrds to not be migrated for DUN
        //
        if (!g_RnaGetDefaultAutodialConnection(szDefEntry, MAX_PATH,
            &dwAutodialOptions) && StringIMatch (szEntry, szDefEntry))
        {
            bRet = TRUE;
        }
    }

    return bRet;
}

HKEY
FindCurrentKey (
    IN HKEY   hkKey,
    IN PCTSTR pszString,
    IN PCTSTR pszPath
    )
{
    HKEY  hkResult = NULL;
    HKEY  hkTemp = hkKey;
    TCHAR szPath[MAX_PATH + 1];
    PTSTR pszTemp = NULL;
    REGKEY_ENUM e;

    do
    {
        pszTemp = GetRegValueString (hkTemp, S_FRIENDLYNAME);
        if (pszTemp && StringIMatch (pszString, pszTemp))
        {
            hkResult = hkTemp;
            hkTemp = NULL;
            break;
        }

        if (!EnumFirstRegKey (&e, hkTemp)) {break;}

        do
        {
            if (pszTemp)
            {
                MemFree (g_hHeap, 0, pszTemp);
                pszTemp = NULL;
            }

            if (hkResult)
            {
                CloseRegKey(hkResult);
                hkResult = NULL;
            }

            sprintf(szPath, "%s\\%s", pszPath, e.SubKeyName );
            hkResult = OpenRegKeyStr (szPath);
            if (!hkResult) {break;}

            pszTemp = GetRegValueString (hkResult, S_FRIENDLYNAME);
            if (pszTemp && StringIMatch (pszString, pszTemp))
            {
                // Success
                break;
            }
            else
            {
                CloseRegKey(hkResult);
                hkResult = NULL;
            }

        } while (EnumNextRegKey (&e));

    } while (FALSE);
    //
    // Clean up
    //
    if (pszTemp)
    {
        MemFree (g_hHeap, 0, pszTemp);
    }
    if (hkTemp)
    {
        CloseRegKey(hkTemp);
    }

    return hkResult;
}

PTSTR
GetInfoFromFriendlyName (
    IN PCTSTR pszFriendlyName,
    IN BOOL   bType
    )
{
    HKEY     hkEnum = NULL;
    DWORD    i = 0;
    TCHAR    szData[MAX_PATH + 1];
    TCHAR    szPath[MAX_PATH + 1];
    PTSTR    pszTemp = NULL;
    PTSTR    pszReturn = NULL;
    LPGUID   pguidModem = (LPGUID)&GUID_DEVCLASS_MODEM;
    HDEVINFO hdi;
    SP_DEVINFO_DATA devInfoData = {sizeof (devInfoData), 0};

    hdi = SetupDiGetClassDevs (pguidModem, NULL, NULL, DIGCF_PRESENT);
    if (INVALID_HANDLE_VALUE == hdi)
    {
        return NULL;
    }

    while (SetupDiEnumDeviceInfo (hdi, i++, &devInfoData))
    {
        if (!SetupDiGetDeviceRegistryProperty (
                hdi, &devInfoData, SPDRP_FRIENDLYNAME,
                NULL, (PBYTE)szData, MAX_PATH, NULL) ||
            lstrcmp (szData, pszFriendlyName) )
        {
            continue;
        }

        if (!SetupDiGetDeviceRegistryProperty (
                hdi, &devInfoData, SPDRP_HARDWAREID,
                NULL, (PBYTE)szData, MAX_PATH, NULL) )
        {
            break;
        }

        sprintf(szPath, "%s\\%s", S_ENUM, szData );
        hkEnum = OpenRegKeyStr (szPath);
        if (!hkEnum) {break;}

        hkEnum = FindCurrentKey (hkEnum, pszFriendlyName, szPath);
        if (!hkEnum) {break;}

        if (bType)
        {
            pszTemp = GetRegValueString (hkEnum, S_PARENTDEVNODE);
            if (pszTemp)
            {
                pszReturn = PoolMemDuplicateString (g_RasPool, pszTemp);
                break;
            }

            pszReturn = PoolMemDuplicateString (g_RasPool, szData);
            break;
        }
        else
        {
            pszTemp = GetRegValueString (hkEnum, S_ATTACHEDTO);
            if (pszTemp)
            {
                pszReturn = PoolMemDuplicateString (g_RasPool, pszTemp);
                break;
            }

            pszTemp = GetRegValueString (hkEnum, S_DRIVER);
            if (pszTemp)
            {
                HKEY  key = NULL;
                PTSTR pszAttach = NULL;

                sprintf(szPath, "%s\\%s", S_SERVICECLASS, pszTemp);
                key = OpenRegKeyStr (szPath);
                if (!key) {break;}

                pszAttach = GetRegValueString (key, S_ATTACHEDTO);
                if (!pszAttach)
                {
                    CloseRegKey(key);
                    break;
                }

                pszReturn = PoolMemDuplicateString (g_RasPool, pszAttach);
                MemFree (g_hHeap, 0, pszAttach);
                CloseRegKey(key);
            }

            break;
        }
    }
    //
    // Clean up
    //
    if (bType && pszReturn)
    {
        BOOL  bFisrt = FALSE;
        PTSTR p;

        for (p = pszReturn; '\0' != *p; p++ )
        {
            if (*p != '\\') {continue;}

            if (!bFisrt)
            {
                bFisrt = TRUE;
            }
            else
            {
                //
                // Remove rest of PnpId string, not needed
                //
                *p = '\0';
                break;
            }
        }
    }

    if (pszTemp)
    {
        MemFree (g_hHeap, 0, pszTemp);
    }

    if (hkEnum)
    {
        CloseRegKey(hkEnum);
    }

    if (INVALID_HANDLE_VALUE != hdi)
    {
        SetupDiDestroyDeviceInfoList (hdi);
    }

    return pszReturn;
}

PTSTR
GetComPort (
    IN PCTSTR DriverDesc
    )
{
    PTSTR rPort = NULL;

    rPort = GetInfoFromFriendlyName(DriverDesc, FALSE);

    if (!rPort)
    {
        rPort = S_EMPTY;
        DEBUGMSG ((DBG_WARNING, "Could not find com port for device %s."));
    }

    return rPort;
}

VOID
pInitLibs (
    VOID
    )
{
    do {
        //
        // Load in rasapi32.dll, not fatal if we fail
        //
        // Whistler 417479 RAS upgrade code does not migrate the default
        // internet connection setting from WinME to XP
        //
        g_RasApi32 = LoadLibrary(S_RASAPI32LIB);
        if (!g_RasApi32) {

            g_RnaGetDefaultAutodialConnection = NULL;
            DEBUGMSG((S_DBG_RAS,"Migrate Ras: could not load library %s. Default Internet Connection will not be migrated.",
                      S_RASAPI32LIB));
        }
        //
        // RASAPI32 was loaded..now, get the relevant apis, not fatal if we fail
        //
        else
        {
            (FARPROC) g_RnaGetDefaultAutodialConnection = GetProcAddress(
                g_RasApi32,
                S_RNAGETDEFAUTODIALCON
                );
            if (!g_RnaGetDefaultAutodialConnection) {

                DEBUGMSG((S_DBG_RAS,"Migrate Ras: could not load Procedure %s. Default Internet Connection will not be migrated.",
                          S_RNAGETDEFAUTODIALCON));
            }
        }

    } while ( FALSE );

    return;
}

VOID
pCleanUpLibs (
    VOID
    )
{
    //
    // Whistler 417479 RAS upgrade code does not migrate the default
    // internet connection setting from WinME to XP
    //
    if (g_RasApi32) {
        FreeLibrary(g_RasApi32);
    }
}

VOID
pSaveConnectionDataToMemDb (
    IN PCTSTR User,
    IN PCTSTR Entry,
    IN PCTSTR ValueName,
    IN DWORD  ValueType,
    IN PBYTE  Value
    )
{
    DWORD offset;
    TCHAR key[MEMDB_MAX];

    MemDbBuildKey (key, MEMDB_CATEGORY_RAS_INFO, User, Entry, ValueName);

    switch (ValueType) {

        case REG_SZ:
        case REG_MULTI_SZ:
        case REG_EXPAND_SZ:

            DEBUGMSG ((S_DBG_RAS, "String Data - %s = %s", ValueName,
                       (PCTSTR) Value));

            if (!MemDbSetValueEx (MEMDB_CATEGORY_RAS_DATA, (PCTSTR) Value,
                                  NULL, NULL, 0, &offset)) {
                DEBUGMSG ((DBG_ERROR, "Error saving ras data into memdb."));
            }

            if (!MemDbSetValueAndFlags (key, offset, (WORD) REG_SZ, 0)) {
                DEBUGMSG ((DBG_ERROR, "Error saving ras data into memdb."));
            }


            break;

        case REG_DWORD:

            DEBUGMSG ((S_DBG_RAS, "DWORD Data - %s = %u", ValueName,
                       (DWORD) Value));

            if (!MemDbSetValueAndFlags (key, (DWORD)Value, (WORD)ValueType,0)){
                DEBUGMSG ((DBG_ERROR, "Error saving ras data into memdb."));
            }

            break;

        case REG_BINARY:

            DEBUGMSG ((S_DBG_RAS, "Binary data for %s.", ValueName));

            if (StringIMatch (S_IPINFO, ValueName)) {
                //
                // Save IP address information.
                //
                pSaveConnectionDataToMemDb (User, Entry, S_IP_FTCPIP,
                    REG_DWORD, (PBYTE) ((PIPDATA) Value)->fdwTCPIP);
                pSaveConnectionDataToMemDb (User, Entry, S_IP_IPADDR,
                    REG_DWORD, (PBYTE) ((PIPDATA) Value)->dwIPAddr);
                pSaveConnectionDataToMemDb (User, Entry, S_IP_DNSADDR,
                    REG_DWORD, (PBYTE) ((PIPDATA) Value)->dwDNSAddr);
                pSaveConnectionDataToMemDb (User, Entry, S_IP_DNSADDR2,
                    REG_DWORD, (PBYTE) ((PIPDATA) Value)->dwDNSAddrAlt);
                pSaveConnectionDataToMemDb (User, Entry, S_IP_WINSADDR,
                    REG_DWORD, (PBYTE) ((PIPDATA) Value)->dwWINSAddr);
                pSaveConnectionDataToMemDb (User, Entry, S_IP_WINSADDR2,
                    REG_DWORD, (PBYTE) ((PIPDATA) Value)->dwWINSAddrAlt);

            } else if (StringIMatch (S_TERMINAL, ValueName)) {
                //
                // save information on the showcmd state. This will tell us how
                // to set the ui display.
                //
                pSaveConnectionDataToMemDb (User, Entry, ValueName, REG_DWORD,
                    (PBYTE) ((PWINDOWPLACEMENT) Value)->showCmd);

            } else if (StringIMatch (S_MODE, ValueName)) {
                //
                // This value tells what to do with scripting.
                //
                pSaveConnectionDataToMemDb (User, Entry, ValueName, REG_DWORD,
                    (PBYTE)  *((PDWORD) Value));

            } else if (StringIMatch (S_MULTILINK, ValueName)) {
                //
                //  Save wether or not multilink is enabled.
                //
                pSaveConnectionDataToMemDb (User, Entry, ValueName, REG_DWORD,
                    (PBYTE)  *((PDWORD) Value));
            //
            // Whistler bug: 417745 INTL:Win9x Upg: DBCS chars cause User,
            // Domain, Passwrds to not be migrated for DUN
            //
            } else if (StringIMatch (S_PBE_REDIALATTEMPTS, ValueName)) {
                //
                // Save the number of redial attempts
                //
                pSaveConnectionDataToMemDb (User, Entry, S_REDIAL_TRY, REG_DWORD,
                    (PBYTE)  *((PDWORD) Value));
            //
            // Whistler bug: 417745 INTL:Win9x Upg: DBCS chars cause User,
            // Domain, Passwrds to not be migrated for DUN
            //
            } else if (StringIMatch (S_REDIAL_WAIT, ValueName)) {
                //
                // Save the number of seconds to wait for redial
                //
                pSaveConnectionDataToMemDb (User, Entry, ValueName, REG_DWORD,
                    (PBYTE)  *((PDWORD) Value));

            } ELSE_DEBUGMSG ((DBG_WARNING, "Don't know how to handle binary data %s. It will be ignored.",
                              ValueName));

            break;

        default:
            DEBUGMSG ((DBG_WHOOPS, "Unknown type of registry data found in RAS settings. %s",
                       ValueName));
            break;
    }
}

BOOL
pGetRasEntrySettings (
    IN PUSERENUM EnumPtr,
    IN HKEY      Key,
    IN PCTSTR    EntryName
    )
{
    REGVALUE_ENUM e;
    PBYTE curData = NULL;
    BOOL rSuccess = TRUE;

    DEBUGMSG ((S_DBG_RAS, "---Processing %s's entry settings: %s---",
               EnumPtr->FixedUserName, EntryName));

    if (EnumFirstRegValue (&e, Key)) {

        do {
            //
            // Get the data for this entry.
            //
            curData = GetRegValueData (Key, e.ValueName);

            if (curData) {
                //
                // Whistler bug: 417745 INTL:Win9x Upg: DBCS chars cause User,
                // Domain, Passwrds to not be migrated for DUN
                //
                if (StringIMatch (S_MULTILINK, e.ValueName) &&
                         !g_MultilinkEnabled) {

                    pSaveConnectionDataToMemDb (EnumPtr->FixedUserName,
                        EntryName, e.ValueName, REG_DWORD, 0);
                }
                else {

                    pSaveConnectionDataToMemDb (
                        EnumPtr->FixedUserName, EntryName, e.ValueName, e.Type,
                        e.Type == REG_DWORD ? (PBYTE) (*((PDWORD)curData)) :
                        curData);
                }

                MemFree (g_hHeap, 0, curData);
            }

        } while (EnumNextRegValue (&e));
    }

    return rSuccess;
}

BOOL
pGetRasEntryAddressInfo (
    IN PUSERENUM EnumPtr,
    IN HKEY      Key,
    IN PCTSTR    EntryName
    )
{
    BOOL          rSuccess = TRUE;
    HKEY          subEntriesKey = NULL;
    UINT          count = 0, type = 0, sequencer = 0;
    PBYTE         data = NULL;
    PTSTR         subEntriesKeyStr = NULL;
    TCHAR         buffer[MAX_TCHAR_PATH];
    PCTSTR        group;
    PSMMCFG       smmCfg = NULL;
    PADDRENTRY    entry = NULL;
    PDEVICEINFO   devInfo = NULL;
    REGVALUE_ENUM e, eSubEntries;
    PSUBCONNENTRY subEntry = NULL;
    PMODEMDEVINFO modemInfo;

    //
    // First we have to get the real entry name. It must match exactly even
    // case. Unfortunately, it isn't neccessarily a given that the case between
    // HKR\RemoteAccess\Profiles\<Foo> and HKR\RemoteAccess\Addresses\[Foo] is
    // the same. The registry apis will of course work fine because they work
    // case insensitively. However, I will be unable to decrypt the value if I
    // use the wrong name.
    //
    if (EnumFirstRegValue (&e, Key)) {

        do {

            if (StringIMatch (e.ValueName, EntryName)) {
                //
                // Found the correct entry. Use it.
                //
                data = GetRegValueBinary (Key, e.ValueName);

                if (data) {

                    DEBUGMSG ((S_DBG_RAS, "-----Processing entry: %s-----",
                               e.ValueName));
                    //
                    // Whistler 417479 RAS upgrade code does not migrate the default
                    // internet connection setting from WinME to XP
                    //
                    pSaveConnectionDataToMemDb (
                        EnumPtr->FixedUserName, EntryName, S_DEFINTERNETCON,
                        REG_DWORD, (PBYTE) IsDefInternetCon(EntryName));

                    entry = (PADDRENTRY) data;
                    DECRYPTENTRY(e.ValueName, entry, e.DataSize);

                    smmCfg  = PAESMMCFG(entry);
                    devInfo = PAEDI(entry);

                    pSaveConnectionDataToMemDb (
                        EnumPtr->FixedUserName, EntryName, S_PHONE_NUMBER,
                        REG_SZ, (PBYTE) PAEPHONE(entry));
                    pSaveConnectionDataToMemDb (
                        EnumPtr->FixedUserName, EntryName, S_AREA_CODE, REG_SZ,
                        (PBYTE) PAEAREA(entry));
                    pSaveConnectionDataToMemDb (
                        EnumPtr->FixedUserName, EntryName, S_SMM, REG_SZ,
                        (PBYTE) PAESMM(entry));
                    pSaveConnectionDataToMemDb (
                        EnumPtr->FixedUserName, EntryName, S_COUNTRY_CODE,
                        REG_DWORD, (PBYTE) entry->dwCountryCode);
                    pSaveConnectionDataToMemDb (
                        EnumPtr->FixedUserName, EntryName, S_COUNTRY_ID,
                        REG_DWORD, (PBYTE) entry->dwCountryID);
                    pSaveConnectionDataToMemDb (
                        EnumPtr->FixedUserName, EntryName, S_DEVICE_NAME,
                        REG_SZ, (PBYTE) devInfo->szDeviceName);
                    pSaveConnectionDataToMemDb (
                        EnumPtr->FixedUserName, EntryName, S_DEVICE_TYPE,
                        REG_SZ, (PBYTE) devInfo->szDeviceType);
                    pSaveConnectionDataToMemDb (
                        EnumPtr->FixedUserName, EntryName, S_PROTOCOLS,
                        REG_DWORD, (PBYTE) smmCfg->fdwProtocols);
                    pSaveConnectionDataToMemDb (
                        EnumPtr->FixedUserName, EntryName, S_SMM_OPTIONS,
                        REG_DWORD, (PBYTE) smmCfg->fdwOptions);
                    //
                    // Save device information away.
                    //
                    if (StringIMatch (devInfo->szDeviceType, S_MODEM)) {

                        PTSTR pszPnpId = NULL;

                        pszPnpId = GetInfoFromFriendlyName(
                                        devInfo->szDeviceName, TRUE);
                        if (pszPnpId)
                        {
                            pSaveConnectionDataToMemDb (
                                EnumPtr->FixedUserName, EntryName,
                                S_DEVICE_ID, REG_SZ, (PBYTE) pszPnpId);
                        }

                        modemInfo = (PMODEMDEVINFO) (devInfo->szDeviceType +
                                                     RAS_MaxDeviceType + 3);

                        if (modemInfo->Size >= sizeof (MODEMDEVINFO)) {
                            DEBUGMSG_IF ((modemInfo->Size >
                               sizeof (MODEMDEVINFO), S_DBG_RAS,
                               "Structure size larger than our known size."));

                            pSaveConnectionDataToMemDb (EnumPtr->FixedUserName,
                                EntryName, S_MODEM_UI_OPTIONS, REG_DWORD,
                                (PBYTE) modemInfo->ModemUiOptions);
                            pSaveConnectionDataToMemDb (EnumPtr->FixedUserName,
                                EntryName, S_MODEM_SPEED, REG_DWORD,
                                (PBYTE) modemInfo->ConnectionSpeed);
                            pSaveConnectionDataToMemDb (EnumPtr->FixedUserName,
                                EntryName, S_MODEM_SPEAKER_VOLUME, REG_DWORD,
                                (PBYTE) modemInfo->SpeakerVolume);
                            pSaveConnectionDataToMemDb (EnumPtr->FixedUserName,
                                EntryName, S_MODEM_IDLE_DISCONNECT_SECONDS,
                                REG_DWORD,
                                (PBYTE) modemInfo->dwInactivityTimeout);
                            pSaveConnectionDataToMemDb (EnumPtr->FixedUserName,
                                EntryName, S_MODEM_CANCEL_SECONDS, REG_DWORD,
                                (PBYTE) modemInfo->dwCallSetupFailTimer);
                            pSaveConnectionDataToMemDb (EnumPtr->FixedUserName,
                                EntryName, S_MODEM_CFG_OPTIONS, REG_DWORD,
                                (PBYTE) modemInfo->ConfigOptions);
                            pSaveConnectionDataToMemDb (EnumPtr->FixedUserName,
                                EntryName, S_MODEM_COM_PORT, REG_SZ,
                                (PBYTE) GetComPort (devInfo->szDeviceName));
                        }
                        ELSE_DEBUGMSG ((DBG_WHOOPS, "No modem configuration data saved. Size smaller than known structure. Investigate."));
                    }
                    //
                    // If SMM is not SLIP, CSLIP or PPP, we need to add a
                    // message to the upgrade report.
                    //
                    if (!StringIMatch (PAESMM(entry), S_SLIP)&&
                        !StringIMatch (PAESMM(entry), S_PPP) &&
                        !StringIMatch (PAESMM(entry), S_CSLIP)) {
                        //
                        // Add message for this connection entry.
                        //
                        group = BuildMessageGroup (
                                    MSG_LOSTSETTINGS_ROOT,
                                    MSG_CONNECTION_BADPROTOCOL_SUBGROUP,
                                    EntryName
                                    );

                        if (group) {

                            MsgMgr_ObjectMsg_Add (
                                EntryName,
                                group,
                                S_EMPTY
                                );

                            FreeText (group);
                        }
                    }
                }
                //
                // Check to see if there are any sub-entries for this
                // connection (MULTILINK settings..)
                //
                // Luckily, we don't have to do the same enumeration of these
                // entries as we had to above to get around the case
                // sensitivity bug. the 9x code uses the address key name above
                // for encryption/decryption.
                //
                sequencer = 1;
                g_MultilinkEnabled = FALSE;

                if (data && !StringIMatch (PAESMM(entry), S_PPP))
                {
                    DEBUGMSG ((S_DBG_RAS, "Not using PPP, disabling Multi-Link"));
                    pSaveConnectionDataToMemDb (EnumPtr->FixedUserName,
                        EntryName, S_DEVICECOUNT, REG_DWORD,
                        (PBYTE) sequencer);

                    MemFree (g_hHeap, 0, data);
                    data = NULL;
                    break;
                }

                subEntriesKeyStr = JoinPaths (S_SUBENTRIES, e.ValueName);
                if (subEntriesKeyStr)
                {
                    subEntriesKey = OpenRegKey (Key, subEntriesKeyStr);
                    FreePathString (subEntriesKeyStr);
                }

                if (subEntriesKey) {
                    DEBUGMSG ((S_DBG_RAS, "Multi-Link Subentries found for entry %s. Processing.",
                               e.ValueName));
                    g_MultilinkEnabled = TRUE;

                    if (EnumFirstRegValue (&eSubEntries, subEntriesKey)) {

                        do {

                            data = GetRegValueBinary (subEntriesKey,
                                    eSubEntries.ValueName);

                            if (data) {
                                PTSTR pszPnpId = NULL;

                                subEntry = (PSUBCONNENTRY) data;
                                DECRYPTENTRY (e.ValueName, subEntry,
                                    eSubEntries.DataSize);

                                wsprintf (buffer, "ml%d%s",sequencer,
                                    S_DEVICE_TYPE);
                                pSaveConnectionDataToMemDb (
                                    EnumPtr->FixedUserName, EntryName, buffer,
                                    REG_SZ, (PBYTE) subEntry->szDeviceType);

                                wsprintf (buffer, "ml%d%s",sequencer,
                                    S_DEVICE_NAME);
                                pSaveConnectionDataToMemDb (
                                    EnumPtr->FixedUserName, EntryName, buffer,
                                    REG_SZ, (PBYTE) subEntry->szDeviceName);

                                pszPnpId = GetInfoFromFriendlyName(
                                            subEntry->szDeviceName, TRUE);
                                if (pszPnpId)
                                {
                                    wsprintf (buffer, "ml%d%s",sequencer,
                                        S_DEVICE_ID);
                                    pSaveConnectionDataToMemDb (
                                        EnumPtr->FixedUserName, EntryName,
                                        buffer, REG_SZ, (PBYTE) pszPnpId);
                                }

                                wsprintf (buffer, "ml%d%s",sequencer,
                                    S_PHONE_NUMBER);
                                pSaveConnectionDataToMemDb (
                                    EnumPtr->FixedUserName, EntryName, buffer,
                                    REG_SZ, (PBYTE) subEntry->szLocal);

                                wsprintf (buffer, "ml%d%s",sequencer,
                                    S_MODEM_COM_PORT);
                                pSaveConnectionDataToMemDb (
                                    EnumPtr->FixedUserName, EntryName, buffer,
                                    REG_SZ, (PBYTE)
                                    GetComPort (subEntry->szDeviceName));

                                MemFree (g_hHeap, 0, data);
                                data = NULL;
                            }

                            sequencer++;

                        } while (EnumNextRegValue (&eSubEntries));
                    }

                    CloseRegKey (subEntriesKey);
                }
                //
                // Save away the number of devices associated with this
                // connection
                //
                pSaveConnectionDataToMemDb (EnumPtr->FixedUserName, EntryName,
                    S_DEVICECOUNT, REG_DWORD, (PBYTE) sequencer);
                //
                // We're done. Break out of the enumeration.
                //
                break;
            }

        } while (EnumNextRegValue (&e));
    }

    return rSuccess;
}

BOOL
pGetPerConnectionSettings (
    IN PUSERENUM EnumPtr
    )
{
    HKEY          profileKey;
    HKEY          entryKey = NULL;
    HKEY          addressKey = NULL;
    BOOL          rSuccess = TRUE;
    REGVALUE_ENUM e;

    DEBUGMSG((S_DBG_RAS, "Gathering per-connection RAS Setting Information"));

    //
    // Open needed registry keys.
    //
    profileKey = OpenRegKey (EnumPtr->UserRegKey, S_PROFILE_KEY);
    addressKey = OpenRegKey (EnumPtr->UserRegKey, S_ADDRESSES_KEY);

    if (addressKey) {
        //
        // Enumerate each entry for this user.
        //
        if (EnumFirstRegValue (&e, addressKey)) {
            do {
                //
                // Get base connection info -- stored as binary blob under
                // address key. All connections will have this info -- It
                // contains such things as the phone number, area code, dialing
                // rules, etc.. It does not matter wether the connection has
                // been used or not.
                //
                rSuccess &= pGetRasEntryAddressInfo (EnumPtr,
                                addressKey, e.ValueName );

                if (profileKey) {
                    //
                    // Under the profile key are negotiated options for the
                    // connection. This key will only exist if the entry has
                    // actually been connected to by the user.
                    //
                    entryKey = OpenRegKey (profileKey, e.ValueName);

                    if (entryKey) {

                        rSuccess &= pGetRasEntrySettings ( EnumPtr, entryKey,
                                        e.ValueName );
                        CloseRegKey (entryKey);
                    }
                }

            } while (EnumNextRegValue (&e));
        }
    }
    ELSE_DEBUGMSG ((DBG_WARNING, "pGetPerConnectionSettings: Unable to access needed registry info for user %s.",
                    EnumPtr->FixedUserName));
    //
    // Clean up resources.
    //
    if (addressKey) {
        CloseRegKey (addressKey);
    }

    if (profileKey) {
        CloseRegKey (profileKey);
    }

    return rSuccess;
}

BOOL
pGetPerUserSettings (
    IN PUSERENUM EnumPtr
    )
{
    HKEY settingsKey;
    PDWORD data;
    BOOL rSuccess = TRUE;

    DEBUGMSG ((S_DBG_RAS, "Gathering per-user RAS data for %s.",
               EnumPtr->UserName));

    settingsKey = OpenRegKey (EnumPtr->UserRegKey, S_REMOTE_ACCESS_KEY);

    if (settingsKey) {
        //
        // Get UI settings.
        //
        data = (PDWORD) GetRegValueBinary (settingsKey, S_DIALUI);
        //
        // Save Dial User Interface info into memdb for this user.
        //
        if (data) {

            DEBUGMSG ((S_DBG_RAS, "DWORD Data - %s = %u", S_DIALUI, *data));

            rSuccess &= MemDbSetValueEx (
                MEMDB_CATEGORY_RAS_INFO,
                MEMDB_FIELD_USER_SETTINGS,
                EnumPtr->FixedUserName,
                S_DIALUI,
                *data,
                NULL
                );

            MemFree (g_hHeap, 0, data);
        }
        ELSE_DEBUGMSG ((S_DBG_RAS, "No user UI settings found for %s.",
                        EnumPtr->UserName));
        //
        // Get Redial information.
        //
        data = (PDWORD) GetRegValueBinary (settingsKey, S_ENABLE_REDIAL);

        if (data) {

            DEBUGMSG ((S_DBG_RAS, "DWORD Data - %s = %u", S_ENABLE_REDIAL,
                       *data));

            rSuccess &= MemDbSetValueEx (
                MEMDB_CATEGORY_RAS_INFO,
                MEMDB_FIELD_USER_SETTINGS,
                EnumPtr->FixedUserName,
                S_ENABLE_REDIAL,
                *data,
                NULL
                );

            MemFree (g_hHeap, 0, data);
        }
        ELSE_DEBUGMSG ((S_DBG_RAS, "No user redial information found for %s.",
                        EnumPtr->UserName));

        data = (PDWORD) GetRegValueBinary (settingsKey, S_REDIAL_TRY);

        if (data) {

            DEBUGMSG ((S_DBG_RAS, "DWORD Data - %s = %u", S_REDIAL_TRY,
                       *data));

            rSuccess &= MemDbSetValueEx (
                MEMDB_CATEGORY_RAS_INFO,
                MEMDB_FIELD_USER_SETTINGS,
                EnumPtr->FixedUserName,
                S_REDIAL_TRY,
                *data,
                NULL
                );

            MemFree (g_hHeap, 0, data);
        }
        ELSE_DEBUGMSG ((S_DBG_RAS, "No user redial information found for %s.",
                        EnumPtr->UserName));

        data = (PDWORD) GetRegValueBinary (settingsKey, S_REDIAL_WAIT);

        if (data) {

            DEBUGMSG ((S_DBG_RAS, "DWORD Data - %s = %u", S_REDIAL_WAIT,
                       HIWORD(*data) * 60 + LOWORD(*data)));

            MemDbSetValueEx (
                MEMDB_CATEGORY_RAS_INFO,
                MEMDB_FIELD_USER_SETTINGS,
                EnumPtr->FixedUserName,
                S_REDIAL_WAIT,
                HIWORD(*data) * 60 + LOWORD(*data),
                NULL
                );

            MemFree (g_hHeap, 0, data);
        }
        ELSE_DEBUGMSG ((S_DBG_RAS, "No user redial information found for %s.",
                        EnumPtr->UserName));
        //
        // Get implicit connection information. (Controls wether connection ui
        // should be displayed or not)
        //
        data = (PDWORD) GetRegValueBinary (settingsKey, S_ENABLE_IMPLICIT);

        if (data) {

            DEBUGMSG ((S_DBG_RAS, "DWORD Data - %s = %u", S_ENABLE_IMPLICIT,
                       *data));

            MemDbSetValueEx (
                MEMDB_CATEGORY_RAS_INFO,
                MEMDB_FIELD_USER_SETTINGS,
                EnumPtr->FixedUserName,
                S_ENABLE_IMPLICIT,
                *data,
                NULL
                );

            MemFree(g_hHeap,0,data);
        }
        ELSE_DEBUGMSG ((S_DBG_RAS, "No user implicit connection information found for %s.",
                        EnumPtr->UserName));

        CloseRegKey(settingsKey);
    }

    return rSuccess;
}

DWORD
ProcessRasSettings (
    IN DWORD     Request,
    IN PUSERENUM EnumPtr
    )
{
    DWORD rc = ERROR_SUCCESS;

    switch (Request) {

    case REQUEST_QUERYTICKS:

        return TICKS_RAS_PREPARE_REPORT;

    case REQUEST_BEGINUSERPROCESSING:
        //
        // We are about to be called for each user. Do necessary
        // initialization.
        //
        // Initialize our pool and get information from libraries.
        //
        g_RasPool = PoolMemInitNamedPool (TEXT("RAS - Win9x Side"));
        MYASSERT( g_RasPool);

        pInitLibs();
        g_RasInstalled = IsRasInstalled();

        return ERROR_SUCCESS;

    case REQUEST_RUN:
        //
        // Gather RAS information for this user.
        //
        if (g_RasInstalled && EnumPtr -> AccountType & NAMED_USER) {

            __try {

                pGetPerUserSettings (EnumPtr);
                pGetPerConnectionSettings (EnumPtr);
            }
            __except (TRUE) {
                DEBUGMSG ((DBG_WHOOPS, "Caught an exception while processing ras settings."));
            }
        }

        return ERROR_SUCCESS;

    case REQUEST_ENDUSERPROCESSING:
        //
        // Clean up our resources.
        //
        pCleanUpLibs();
        PoolMemDestroyPool(g_RasPool);

        return ERROR_SUCCESS;

    default:

        DEBUGMSG ((DBG_ERROR, "Bad parameter in Ras_PrepareReport"));
    }
    return 0;
}

BOOL
IsRasInstalled (
    void
    )
{
    HKEY testKey = NULL;
    BOOL rf = FALSE;

    testKey = OpenRegKeyStr(S_SERVICEREMOTEACCESS);

    if (testKey) {
        //
        // Open key succeeded. Assume RAS is installed.
        //
        rf = TRUE;
        CloseRegKey(testKey);
    }

    return rf;
}

BOOL
WINAPI
Ras_Entry (
    IN HINSTANCE hinstDLL,
    IN DWORD     dwReason,
    IN LPVOID    lpv
    )
{
    BOOL rSuccess = TRUE;

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:

        break;

    case DLL_PROCESS_DETACH:

        //
        // Clean up resources that we used.
        //

        break;
    }

    return rSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\sysmig\sysmig.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    sysmig.c

Abstract:

    System migration functions for Win95

Author:

    Jim Schmidt (jimschm) 13-Feb-1997

Revision History:

    jimschm     09-Mar-2001 Redesigned file list code to support LDID enumeration in
                            a clear way
    marcw       18-Mar-1999 Boot16 now set to BOOT16_YES unless it has been
                            explicitly set to BOOT16_NO or the partition will
                            be converted to NTFS.
    jimschm     23-Sep-1998 Updated for new fileops code
    jimschm     12-May-1998 Added .386 warning
    calinn      19-Nov-1997 Added pSaveDosFiles, will move DOS files out of the way
                            during upgrade
    marcw       21-Jul-1997 Added end-processing of special keys.
                            (e.g. HKLM\Software\Microsoft\CurrentVersion\RUN)
    jimschm     20-Jun-1997 Hooked up user loop and saved user
                            names to memdb
--*/

#include "pch.h"
#include "sysmigp.h"
#include "progbar.h"
#include "regops.h"
#include "oleregp.h"

#include <mmsystem.h>


typedef struct TAG_DIRPATH {
    struct TAG_DIRPATH *Next;
    TCHAR DirPath[];
} DIRIDPATH, *PDIRIDPATH;

typedef struct TAG_DIRID {
    struct TAG_DIRID *Next;
    PDIRIDPATH FirstDirPath;
    UINT DirId;
} DIRIDMAP, *PDIRIDMAP;

typedef struct {
    PDIRIDPATH LastMatch;
    PCTSTR SubPath;
    PTSTR ResultBuffer;
} DIRNAME_ENUM, *PDIRNAME_ENUM;

UINT *g_Boot16;
UINT g_ProgressBarTime;
PDIRIDMAP g_HeadDirId;
PDIRIDMAP g_TailDirId;
POOLHANDLE g_DirIdPool;
PDIRIDMAP g_LastIdPtr;


BOOL
pWarnAboutOldDrivers (
    VOID
    );

VOID
pAddNtFile (
    IN      PCTSTR Dir,             OPTIONAL
    IN      PCTSTR FileName,        OPTIONAL
    IN      BOOL BackupThisFile,
    IN      BOOL CleanThisFile,
    IN      BOOL OsFile
    );


BOOL
WINAPI
SysMig_Entry (
    IN HINSTANCE hinstDLL,
    IN DWORD dwReason,
    IN LPVOID lpv
    )

/*++

Routine Description:

  SysMig_Entry is a DllMain-like init funciton, called by w95upg\dll.
  This function is called at process attach and detach.

Arguments:

  hinstDLL - (OS-supplied) instance handle for the DLL
  dwReason - (OS-supplied) indicates attach or detatch from process or
             thread
  lpv      - unused

Return Value:

  Return value is always TRUE (indicating successful init).

--*/

{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        g_DirIdPool = PoolMemInitNamedPool ("FileList");
        break;


    case DLL_PROCESS_DETACH:
        TerminateCacheFolderTracking();

        if (g_DirIdPool) {
            PoolMemDestroyPool (g_DirIdPool);
        }
        break;
    }

    return TRUE;
}


BOOL
pPreserveShellIcons (
    VOID
    )

/*++

Routine Description:

  This routine scans the Shell Icons for references to files that
  are expected to be deleted.  If a reference is found, the file is
  removed from the deleted list, and marked to be moved to
  %windir%\migicons\shl<n>.

Arguments:

  none

Return Value:

  none

--*/

{
    REGVALUE_ENUM e;
    HKEY ShellIcons;
    PCTSTR Data;
    TCHAR ArgZero[MAX_CMDLINE];
    DWORD Binary = 0;
    INT IconIndex;
    PCTSTR p;

    //
    // Scan all ProgIDs, looking for default icons that are currently
    // set for deletion.  Once found, save the icon.
    //

    ShellIcons = OpenRegKeyStr (S_SHELL_ICONS_REG_KEY);

    if (ShellIcons) {
        if (EnumFirstRegValue (&e, ShellIcons)) {
            do {
                Data = (PCTSTR) GetRegValueDataOfType (ShellIcons, e.ValueName, REG_SZ);
                if (Data) {
                    ExtractArgZero (Data, ArgZero);

                    if (FILESTATUS_UNCHANGED != GetFileStatusOnNt (ArgZero)) {

                        p = _tcschr (Data, TEXT(','));
                        if (p) {
                            IconIndex = _ttoi (_tcsinc (p));
                        } else {
                            IconIndex = 0;
                        }

                        //
                        // Extract will fail only if the icon is known good
                        //

                        if (ExtractIconIntoDatFile (
                                ArgZero,
                                IconIndex,
                                &g_IconContext,
                                NULL
                                )) {
                            DEBUGMSG ((DBG_SYSMIG, "Preserving shell icon file %s", ArgZero));
                        }
                    }

                    MemFree (g_hHeap, 0, Data);
                }
            } while (EnumNextRegValue (&e));
        }

        CloseRegKey (ShellIcons);
    }

    return TRUE;
}


BOOL
pMoveStaticFiles (
    VOID
    )
{
    BOOL        rSuccess = TRUE;
    INFSTRUCT   is = INITINFSTRUCT_POOLHANDLE;
    PCTSTR      from;
    PCTSTR      to;
    PCTSTR      fromExpanded;
    PCTSTR      toExpanded;
    PCTSTR      toFinalDest;
    PTSTR       Pattern;
    FILE_ENUM   e;


    //
    // Cycle through all of the entries in the static move files section.
    //
    if (InfFindFirstLine(g_Win95UpgInf,S_STATIC_MOVE_FILES,NULL,&is)) {

        do {

            //
            // For each entry, check to see if the file exists. If it does,
            // add it into the memdb move file section.
            //
            from = InfGetStringField(&is,0);
            to = InfGetStringField(&is,1);

            if (from && to) {

                fromExpanded = ExpandEnvironmentText(from);
                toExpanded = ExpandEnvironmentText(to);

                Pattern = _tcsrchr (fromExpanded, TEXT('\\'));
                //
                // full path please
                //
                MYASSERT (Pattern);
                if (!Pattern) {
                    continue;
                }

                *Pattern = 0;
                Pattern++;

                if (EnumFirstFile (&e, fromExpanded, Pattern)) {
                    do {
                        if (!StringIMatch (e.FileName, Pattern)) {
                            //
                            // pattern specified
                            //
                            toFinalDest = JoinPaths (toExpanded, e.FileName);
                        } else {
                            toFinalDest = toExpanded;
                        }

                        if (!IsFileMarkedAsHandled (e.FullPath)) {
                            //
                            // Remove general operations, then mark for move
                            //

                            RemoveOperationsFromPath (
                                e.FullPath,
                                OPERATION_FILE_DELETE|
                                    OPERATION_FILE_MOVE|
                                    OPERATION_FILE_MOVE_BY_NT|
                                    OPERATION_FILE_MOVE_SHELL_FOLDER|
                                    OPERATION_CREATE_FILE
                                );

                            MarkFileForMove (e.FullPath, toFinalDest);
                        }

                        if (toFinalDest != toExpanded) {
                            FreePathString (toFinalDest);
                        }

                    } while (EnumNextFile (&e));
                }

                --Pattern;
                *Pattern = TEXT('\\');

                FreeText (toExpanded);
                FreeText (fromExpanded);
            }

        } while (InfFindNextLine(&is));
    }

    InfCleanUpInfStruct(&is);

    return rSuccess;
}


DWORD
MoveStaticFiles (
    IN DWORD Request
    )
{

    switch (Request) {
    case REQUEST_QUERYTICKS:
        return TICKS_MOVE_STATIC_FILES;
    case REQUEST_RUN:
        if (!pMoveStaticFiles ()) {
            return GetLastError ();
        }
        else {
            return ERROR_SUCCESS;
        }
    default:
        DEBUGMSG ((DBG_ERROR, "Bad parameter in MoveStaticFiles."));
    }
    return 0;


}


BOOL
pCopyStaticFiles (
    VOID
    )
{
    BOOL        rSuccess = TRUE;
    INFSTRUCT   is = INITINFSTRUCT_POOLHANDLE;
    PCTSTR      from;
    PCTSTR      to;
    PCTSTR      fromExpanded;
    PCTSTR      toExpanded;
    PCTSTR      toFinalDest;
    PTSTR       Pattern;
    FILE_ENUM   e;


    //
    // Cycle through all of the entries in the static copy files section.
    //
    if (InfFindFirstLine(g_Win95UpgInf,S_STATIC_COPY_FILES,NULL,&is)) {

        do {

            //
            // For each entry, check to see if the file exists. If it does,
            // add it into the memdb copy file section.
            //
            from = InfGetStringField(&is,0);
            to = InfGetStringField(&is,1);

            if (from && to) {

                fromExpanded = ExpandEnvironmentText(from);
                toExpanded = ExpandEnvironmentText(to);

                Pattern = _tcsrchr (fromExpanded, TEXT('\\'));
                //
                // full path please
                //
                MYASSERT (Pattern);
                if (!Pattern) {
                    continue;
                }

                *Pattern = 0;
                Pattern++;

                if (EnumFirstFile (&e, fromExpanded, Pattern)) {
                    do {
                        if (!StringIMatch (e.FileName, Pattern)) {
                            //
                            // pattern specified
                            //
                            toFinalDest = JoinPaths (toExpanded, e.FileName);
                        } else {
                            toFinalDest = toExpanded;
                        }

                        if (!IsFileMarkedForOperation (e.FullPath, OPERATION_FILE_DELETE)) {
                            MarkFileForCopy (e.FullPath, toFinalDest);
                        }

                        if (toFinalDest != toExpanded) {
                            FreePathString (toFinalDest);
                        }

                    } while (EnumNextFile (&e));
                }

                --Pattern;
                *Pattern = TEXT('\\');

                FreeText (toExpanded);
                FreeText (fromExpanded);
            }

        } while (InfFindNextLine(&is));
    }

    InfCleanUpInfStruct(&is);

    return rSuccess;
}


DWORD
CopyStaticFiles (
    IN DWORD Request
    )
{

    switch (Request) {
    case REQUEST_QUERYTICKS:
        return TICKS_COPY_STATIC_FILES;
    case REQUEST_RUN:
        if (!pCopyStaticFiles ()) {
            return GetLastError ();
        }
        else {
            return ERROR_SUCCESS;
        }
    default:
        DEBUGMSG ((DBG_ERROR, "Bad parameter in CopyStaticFiles."));
    }
    return 0;


}


DWORD
PreserveShellIcons (
    IN      DWORD Request
    )
{
    switch (Request) {
    case REQUEST_QUERYTICKS:
        return TICKS_PRESERVE_SHELL_ICONS;
    case REQUEST_RUN:
        if (!pPreserveShellIcons ()) {
            return GetLastError ();
        }
        else {
            return ERROR_SUCCESS;
        }
    default:
        DEBUGMSG ((DBG_ERROR, "Bad parameter in PreserveShellIcons"));
    }
    return 0;
}


PCTSTR
GetWindowsInfDir(
    VOID
    )
{
    PTSTR WindowsInfDir = NULL;

    /*

    NTBUG9:419428 - This registry entry is a semi-colon list of INF paths, and
                    it can contain Win9x source media INFs on OEM machines.

    WindowsInfDir = (PTSTR) GetRegData (S_WINDOWS_CURRENTVERSION, S_DEVICEPATH);

    */

    if (!WindowsInfDir) {
        WindowsInfDir = (PTSTR) MemAlloc (g_hHeap, 0, SizeOfString (g_WinDir) + sizeof (S_INF));
        StringCopy (WindowsInfDir, g_WinDir);
        StringCopy (AppendWack (WindowsInfDir), S_INF);
    }

    return WindowsInfDir;
}


#ifndef SM_CMONITORS
#define SM_CMONITORS            80
#endif

BOOL
pProcessMiscMessages (
    VOID
    )

/*++

Routine Description:

  pProcessMiscMessages performs runtime tests for items that are
  incompatible, and it adds messages when the tests succeed.

Arguments:

  None.

Return Value:

  Always TRUE.

--*/

{
    PCTSTR Group;
    PCTSTR Message;
    OSVERSIONINFO Version;
    WORD CodePage;
    LCID Locale;

    if (GetSystemMetrics (SM_CMONITORS) > 1) {
        //
        // On Win95 and OSR2, GetSystemMetrics returns 0.
        //

        Group = BuildMessageGroup (MSG_INSTALL_NOTES_ROOT, MSG_MULTI_MONITOR_UNSUPPORTED_SUBGROUP, NULL);
        Message = GetStringResource (MSG_MULTI_MONITOR_UNSUPPORTED);

        if (Message && Group) {
            MsgMgr_ObjectMsg_Add (TEXT("*MultiMonitor"), Group, Message);
        }

        FreeText (Group);
        FreeStringResource (Message);
    }

    pWarnAboutOldDrivers();

    //
    // Save platform info
    //

    Version.dwOSVersionInfoSize = sizeof (Version);
    GetVersionEx (&Version);

    MemDbSetValueEx (
        MEMDB_CATEGORY_STATE,
        MEMDB_ITEM_MAJOR_VERSION,
        NULL,
        NULL,
        Version.dwMajorVersion,
        NULL
        );

    MemDbSetValueEx (
        MEMDB_CATEGORY_STATE,
        MEMDB_ITEM_MINOR_VERSION,
        NULL,
        NULL,
        Version.dwMinorVersion,
        NULL
        );

    MemDbSetValueEx (
        MEMDB_CATEGORY_STATE,
        MEMDB_ITEM_BUILD_NUMBER,
        NULL,
        NULL,
        Version.dwBuildNumber,
        NULL
        );

    MemDbSetValueEx (
        MEMDB_CATEGORY_STATE,
        MEMDB_ITEM_PLATFORM_ID,
        NULL,
        NULL,
        Version.dwPlatformId,
        NULL
        );

    MemDbSetValueEx (
        MEMDB_CATEGORY_STATE,
        MEMDB_ITEM_VERSION_TEXT,
        NULL,
        Version.szCSDVersion,
        0,
        NULL
        );


    GetGlobalCodePage (&CodePage, &Locale);

    MemDbSetValueEx (
        MEMDB_CATEGORY_STATE,
        MEMDB_ITEM_CODE_PAGE,
        NULL,
        NULL,
        CodePage,
        NULL
        );

    MemDbSetValueEx (
        MEMDB_CATEGORY_STATE,
        MEMDB_ITEM_LOCALE,
        NULL,
        NULL,
        Locale,
        NULL
        );

    //
    // Bad hard disk warning
    //

    if (!g_ConfigOptions.GoodDrive && HwComp_ReportIncompatibleController()) {

        //
        // Turn on boot loader flag
        //

        WriteInfKey (WINNT_DATA, WINNT_D_WIN95UNSUPHDC, S_ONE);

    }

    return TRUE;
}


DWORD
ProcessMiscMessages (
    IN      DWORD Request
    )
{
    switch (Request) {
    case REQUEST_QUERYTICKS:
        return TICKS_MISC_MESSAGES;

    case REQUEST_RUN:
        if (!pProcessMiscMessages()) {
            return GetLastError ();
        }
        else {
            return ERROR_SUCCESS;
        }
    default:
        DEBUGMSG ((DBG_ERROR, "Bad parameter in ProcessSpecialKeys"));
    }
    return 0;
}




BOOL
pDeleteWinDirWackInf (
    VOID
    )
{
    PCTSTR WindowsInfDir;
    FILE_ENUM e;
    DWORD count = 0;

    //
    // Delete all contents of c:\windows\inf.
    //
    WindowsInfDir = GetWindowsInfDir();

    if (!WindowsInfDir) {
        return FALSE;
    }

    if (EnumFirstFile (&e, WindowsInfDir, NULL)) {
        do {
            MarkFileForDelete (e.FullPath);
            count++;
            if (!(count % 32)) {
                TickProgressBar ();
            }
        } while (EnumNextFile (&e));
    }

    MemFree (g_hHeap, 0, WindowsInfDir);

    return TRUE;
}

DWORD
DeleteWinDirWackInf (
    IN      DWORD Request
    )
{
    switch (Request) {
    case REQUEST_QUERYTICKS:
        return TICKS_DELETE_WIN_DIR_WACK_INF;
    case REQUEST_RUN:
        if (!pDeleteWinDirWackInf ()) {
            return GetLastError ();
        }
        else {
            return ERROR_SUCCESS;
        }
    default:
        DEBUGMSG ((DBG_ERROR, "Bad parameter in DeleteWinDirWackInf"));
    }
    return 0;
}


BOOL
pMoveWindowsIniFiles (
    VOID
    )
{
    WIN32_FIND_DATA fd;
    HANDLE FindHandle;
    TCHAR WinDirPattern[MAX_TCHAR_PATH];
    TCHAR FullPath[MAX_TCHAR_PATH];
    TCHAR Key[MEMDB_MAX];
    INFCONTEXT context;
    DWORD result;
    BOOL b = FALSE;

    //
    // build suppression table
    //
    if (SetupFindFirstLine (g_Win95UpgInf, S_INI_FILES_IGNORE, NULL, &context)) {

        do {
            if (SetupGetStringField (&context, 0, Key, MEMDB_MAX, NULL)) {
                MemDbSetValueEx (
                    MEMDB_CATEGORY_INIFILES_IGNORE,
                    Key,
                    NULL,
                    NULL,
                    0,
                    NULL
                    );
            }
        } while (SetupFindNextLine (&context, &context));
    }

    //
    // Scan %windir% for files
    //

    wsprintf (WinDirPattern, TEXT("%s\\*.ini"), g_WinDir);
    FindHandle = FindFirstFile (WinDirPattern, &fd);

    if (FindHandle != INVALID_HANDLE_VALUE) {
        __try {
            do {

                //
                // don't move and process specific INI files
                //
                MemDbBuildKey (Key, MEMDB_CATEGORY_INIFILES_IGNORE, fd.cFileName, NULL, NULL);
                if (!MemDbGetValue (Key, &result)) {
                    wsprintf (FullPath, TEXT("%s\\%s"), g_WinDir, fd.cFileName);

                    if (CanSetOperation (FullPath, OPERATION_TEMP_PATH)) {

                        //
                        // see bug 317646
                        //
#ifdef DEBUG
                        if (StringIMatch (fd.cFileName, TEXT("netcfg.ini"))) {
                            continue;
                        }
#endif
                        MarkFileForTemporaryMove (FullPath, FullPath, g_TempDir);
                        MarkFileForBackup (FullPath);
                    }
                }
                ELSE_DEBUGMSG ((DBG_NAUSEA, "Ini File Ignored : %s\\%s", g_WinDir, fd.cFileName));

            } while (FindNextFile (FindHandle, &fd));

            b = TRUE;
        }

        __finally {
            FindClose (FindHandle);
        }
    }

    return b;
}


DWORD
MoveWindowsIniFiles (
    IN      DWORD Request
    )
{
    switch (Request) {
    case REQUEST_QUERYTICKS:
        return TICKS_MOVE_INI_FILES;
    case REQUEST_RUN:
        if (!pMoveWindowsIniFiles ()) {
            return GetLastError ();
        }
        else {
            return ERROR_SUCCESS;
        }
    default:
        DEBUGMSG ((DBG_ERROR, "Bad parameter in MoveWindowsIniFiles"));
    }
    return 0;
}



PTSTR
pFindDosFile (
    IN      PTSTR FileName
    )
{
    WIN32_FIND_DATA findFileData;
    PTSTR fullPathName = NULL;
    PTSTR fullFileName = NULL;

    HANDLE findHandle;

    fullPathName = AllocPathString (MAX_TCHAR_PATH);
    fullFileName = AllocPathString (MAX_TCHAR_PATH);

    _tcsncpy (fullPathName, g_WinDir, MAX_TCHAR_PATH/sizeof (fullPathName [0]));
    fullFileName = JoinPaths (fullPathName, FileName);

    findHandle = FindFirstFile (fullFileName, &findFileData);

    if (findHandle != INVALID_HANDLE_VALUE) {
        FindClose (&findFileData);
        FreePathString (fullPathName);
        return fullFileName;
    }

    FreePathString (fullFileName);

    StringCat (fullPathName, S_BOOT16_COMMAND_DIR);
    fullFileName = JoinPaths (fullPathName, FileName);

    findHandle = FindFirstFile (fullFileName, &findFileData);

    if (findHandle != INVALID_HANDLE_VALUE) {
        FindClose (&findFileData);
        FreePathString (fullPathName);
        return fullFileName;
    }

    FreePathString (fullPathName);
    FreePathString (fullFileName);

    return NULL;

}


BOOL
pSaveDosFile (
    IN      PTSTR FileName,
    IN      PTSTR FullFileName,
    IN      PTSTR TempPath
    )
{
    PTSTR newFileName = NULL;

    newFileName = JoinPaths (TempPath, FileName);

    if (!CopyFile (FullFileName, newFileName, FALSE)) {
        DEBUGMSG ((DBG_WARNING, "BOOT16 : Cannot copy %s to %s", FullFileName, newFileName));
    }

    FreePathString (newFileName);

    return TRUE;

}


VOID
pReportNoBoot16 (
    VOID
    )
/*
    This function will report that BOOT16 option will not be available because the file system is going
    to be converted to NTFS.
*/
{
    PCTSTR ReportEntry;
    PCTSTR ReportTitle;
    PCTSTR Message;
    PCTSTR Group;
    PTSTR argArray[1];

    ReportEntry = GetStringResource (MSG_INSTALL_NOTES_ROOT);

    if (ReportEntry) {

        argArray [0] = g_Win95Name;
        ReportTitle = (PCTSTR)ParseMessageID (MSG_NO_BOOT16_WARNING_SUBGROUP, argArray);

        if (ReportTitle) {

            Message = (PCTSTR)ParseMessageID  (MSG_NO_BOOT16_WARNING, argArray);

            if (Message) {

                Group = JoinPaths (ReportEntry, ReportTitle);

                if (Group) {
                    MsgMgr_ObjectMsg_Add (TEXT("*NoBoot16"), Group, Message);
                    FreePathString (Group);
                }
                FreeStringResourcePtrA (&Message);
            }
            FreeStringResourcePtrA (&ReportTitle);
        }
        FreeStringResource (ReportEntry);
    }
}


#define S_IOFILE        TEXT("IO.SYS")
#define S_MSDOSFILE     TEXT("MSDOS.SYS")
#define S_CONFIG_SYS    TEXT("CONFIG.SYS")
#define S_AUTOEXEC_BAT  TEXT("AUTOEXEC.BAT")

VOID
pMarkDosFileForChange (
    IN      PCTSTR FileName
    )
{
    pAddNtFile (g_BootDrivePath, FileName, TRUE, TRUE, TRUE);
}


BOOL
pSaveDosFiles (
    VOID
    )
{
    HINF WkstaMigInf = INVALID_HANDLE_VALUE;
    PTSTR boot16TempPath = NULL;
    INFCONTEXT infContext;
    PTSTR fileName = NULL;
    PTSTR fullFileName = NULL;
    PTSTR wkstaMigSource = NULL;
    PTSTR wkstaMigTarget = NULL;
    DWORD result;
    TCHAR dir[MAX_PATH];

    //
    // For restore purposes, mark MSDOS environment as a Win9x OS file
    //

    pMarkDosFileForChange (S_IOFILE);
    pMarkDosFileForChange (S_MSDOSFILE);
    pMarkDosFileForChange (S_AUTOEXEC_BAT);
    pMarkDosFileForChange (S_CONFIG_SYS);

    //
    // Now create a backup dir
    //

    if ((*g_Boot16 == BOOT16_YES) && (*g_ForceNTFSConversion)) {

        WriteInfKey (S_WIN9XUPGUSEROPTIONS, TEXT("boot16"), S_NO);
        //
        // We no longer report the no boot16 message.
        //
        //pReportNoBoot16 ();
        //
        return TRUE;
    }

    if (*g_Boot16 == BOOT16_NO) {
        WriteInfKey (S_WIN9XUPGUSEROPTIONS, TEXT("boot16"), S_NO);
    }
    else
    if (*g_Boot16 == BOOT16_YES) {
        WriteInfKey (S_WIN9XUPGUSEROPTIONS, TEXT("boot16"), S_YES);
    }
    else {
        WriteInfKey (S_WIN9XUPGUSEROPTIONS, TEXT("boot16"), S_BOOT16_AUTOMATIC);
    }


    __try {

        //prepare our temporary directory for saving dos7 files
        boot16TempPath = JoinPaths (g_TempDir, S_BOOT16_DOS_DIR);
        if (!CreateDirectory (boot16TempPath, NULL) && (GetLastError()!=ERROR_ALREADY_EXISTS)) {
            LOG ((LOG_ERROR,"BOOT16 : Unable to create temporary directory %s",boot16TempPath));
            __leave;
        }

        fileName = AllocPathString (MAX_TCHAR_PATH);

        //load the files needed for booting in a 16 bit environment. The files are listed
        //in wkstamig.inf section [Win95-DOS files]

        wkstaMigSource = JoinPaths (SOURCEDIRECTORY(0), S_WKSTAMIG_INF);
        wkstaMigTarget = JoinPaths (g_TempDir, S_WKSTAMIG_INF);
        result = SetupDecompressOrCopyFile (wkstaMigSource, wkstaMigTarget, 0);
        if ((result != ERROR_SUCCESS) && (result != ERROR_ALREADY_EXISTS)) {
            LOG ((LOG_ERROR,"BOOT16 : Unable to decompress WKSTAMIG.INF"));
            __leave;
        }

        WkstaMigInf = InfOpenInfFile (wkstaMigTarget);
        if (WkstaMigInf == INVALID_HANDLE_VALUE) {
            LOG ((LOG_ERROR,"BOOT16 : WKSTAMIG.INF could not be opened"));
            __leave;
        }

        //read the section, for every file we are trying to find it in either %windir% or
        //%windir%\command. If we find it, we'll just copy it to a safe place
        if (!SetupFindFirstLine (
                WkstaMigInf,
                S_BOOT16_SECTION,
                NULL,
                &infContext
                )) {
            LOG ((LOG_ERROR,"Cannot read from %s section (WKSTAMIG.INF)",S_BOOT16_SECTION));
            return TRUE;
        }

        do {
            if (SetupGetStringField (
                    &infContext,
                    0,
                    fileName,
                    MAX_TCHAR_PATH/sizeof(fileName[0]),
                    NULL
                    )) {
                //see if we can find this file either in %windir% or in %windir%\command
                fullFileName = pFindDosFile (fileName);

                if (fullFileName != NULL) {
                    pSaveDosFile (fileName, fullFileName, boot16TempPath);
                    FreePathString (fullFileName);
                    fullFileName = NULL;
                }
            }
        }
        while (SetupFindNextLine (&infContext, &infContext));

        //OK, now save io.sys.
        fullFileName = AllocPathString (MAX_TCHAR_PATH);
        StringCopy (fullFileName, g_BootDrivePath);
        StringCat (fullFileName, S_IOFILE);
        pSaveDosFile (S_IOFILE, fullFileName, boot16TempPath);

        FreePathString (fullFileName);
        fullFileName = NULL;

    }
    __finally {
        if (WkstaMigInf != INVALID_HANDLE_VALUE) {
            InfCloseInfFile (WkstaMigInf);
        }
        if (boot16TempPath) {
            FreePathString (boot16TempPath);
        }
        if (wkstaMigSource) {
            FreePathString (wkstaMigSource);
        }
        if (wkstaMigTarget) {
            DeleteFile (wkstaMigTarget);
            FreePathString (wkstaMigTarget);
        }
        if (fileName) {
            FreePathString (fileName);
        }

    }

    return TRUE;
}

DWORD
SaveDosFiles (
    IN      DWORD Request
    )
{
    if (REPORTONLY()) {
        return 0;
    }

    switch (Request) {
    case REQUEST_QUERYTICKS:
        return TICKS_SAVE_DOS_FILES;
    case REQUEST_RUN:
        if (!pSaveDosFiles ()) {
            return GetLastError ();
        }
        else {
            return ERROR_SUCCESS;
        }
    default:
        DEBUGMSG ((DBG_ERROR, "Bad parameter in SaveDosFiles"));
    }
    return 0;
}



DWORD
InitWin95Registry (
    IN      DWORD Request
    )
{
    switch (Request) {
    case REQUEST_QUERYTICKS:
        return TICKS_INIT_WIN95_REGISTRY;
    case REQUEST_RUN:
        return Win95RegInit (g_WinDir, ISMILLENNIUM());
    default:
        DEBUGMSG ((DBG_ERROR, "Bad parameter in InitWin95Registry"));
    }
    return 0;
}


PDIRIDMAP
pFindDirId (
    IN      UINT DirId,
    IN      PDIRIDMAP BestGuess,    OPTIONAL
    IN      BOOL Create
    )
{
    PDIRIDMAP map;

    MYASSERT (Create || (g_HeadDirId && g_TailDirId));

    //
    // Find the existing dir ID. Check the caller's best guess first.
    //

    if (BestGuess && BestGuess->DirId == DirId) {
        return BestGuess;
    }

    map = g_HeadDirId;
    while (map) {
        if (map->DirId == DirId) {
            return map;
        }

        map = map->Next;
    }

    if (!Create) {
        return NULL;
    }

    //
    // Insert a new dir ID struct at the end of the list
    //

    map = (PDIRIDMAP) PoolMemGetAlignedMemory (g_DirIdPool, sizeof (DIRIDMAP));

    if (g_TailDirId) {
        g_TailDirId->Next = map;
    } else {
        g_HeadDirId = map;
    }

    g_TailDirId = map;
    map->Next = NULL;

    map->FirstDirPath = NULL;
    map->DirId = DirId;

    return map;
}


VOID
pInsertDirIdPath (
    IN      UINT DirId,
    IN      PCTSTR DirPath,
    IN OUT  PDIRIDMAP *BestGuess
    )
{
    PDIRIDPATH pathStruct;
    PDIRIDPATH existingPathStruct;
    PDIRIDMAP dirIdMap;

    //
    // Locate the dir ID structure, then append the DirPath to the
    // list of paths for the ID
    //

    dirIdMap = pFindDirId (DirId, *BestGuess, TRUE);
    MYASSERT (dirIdMap);
    *BestGuess = dirIdMap;

    existingPathStruct = dirIdMap->FirstDirPath;
    while (existingPathStruct) {
        if (StringIMatch (existingPathStruct->DirPath, DirPath)) {
            return;
        }

        existingPathStruct = existingPathStruct->Next;
    }

    pathStruct = (PDIRIDPATH) PoolMemGetAlignedMemory (
                                    g_DirIdPool,
                                    sizeof (DIRIDPATH) + SizeOfString (DirPath)
                                    );

    pathStruct->Next = dirIdMap->FirstDirPath;
    dirIdMap->FirstDirPath = pathStruct;
    StringCopy (pathStruct->DirPath, DirPath);
}


BOOL
pConvertFirstDirName (
    OUT     PDIRNAME_ENUM EnumPtr,
    IN      PCTSTR DirNameWithId,
    OUT     PTSTR DirNameWithPath,
    IN OUT  PDIRIDMAP *LastDirIdMatch,
    IN      BOOL Convert11To1501
    )
{
    UINT id;
    PDIRIDMAP idToPath;

    EnumPtr->ResultBuffer = DirNameWithPath;
    EnumPtr->LastMatch = NULL;

    //
    // Find the dir ID in the list of all dir IDs
    //

    id = _tcstoul (DirNameWithId, (PTSTR *) (&EnumPtr->SubPath), 10);

    if (!id) {
        DEBUGMSG ((DBG_WARNING, "Dir ID %s is not valid", DirNameWithId));
        return FALSE;
    }

    DEBUGMSG_IF ((
        EnumPtr->SubPath[0] != TEXT('\\') && EnumPtr->SubPath[0],
        DBG_WHOOPS,
        "Error in filelist.dat: non-numeric characters following LDID: %s",
        DirNameWithId
        ));

    if (Convert11To1501 && id == 11) {
        id = 1501;
    }

    idToPath = pFindDirId (id, *LastDirIdMatch, FALSE);
    if (!idToPath || !(idToPath->FirstDirPath)) {
        DEBUGMSG ((DBG_WARNING, "Dir ID %s is not in the list and might not exist on the system", DirNameWithId));
        return FALSE;
    }

    *LastDirIdMatch = idToPath;
    EnumPtr->LastMatch = idToPath->FirstDirPath;

    wsprintf (EnumPtr->ResultBuffer, TEXT("%s%s"), EnumPtr->LastMatch->DirPath, EnumPtr->SubPath);
    return TRUE;
}


BOOL
pConvertNextDirName (
    IN OUT  PDIRNAME_ENUM EnumPtr
    )
{
    if (EnumPtr->LastMatch) {
        EnumPtr->LastMatch = EnumPtr->LastMatch->Next;
    }

    if (!EnumPtr->LastMatch) {
        return FALSE;
    }

    wsprintf (EnumPtr->ResultBuffer, TEXT("%s%s"), EnumPtr->LastMatch->DirPath, EnumPtr->SubPath);
    return TRUE;
}


typedef struct _KNOWN_DIRS {
    PCSTR DirId;
    PCSTR *Translation;
}
KNOWN_DIRS, *PKNOWN_DIRS;

KNOWN_DIRS g_KnownDirs [] = {
    {"10"   , &g_WinDir},
    {"11"   , &g_System32Dir},
    {"12"   , &g_DriversDir},
    {"17"   , &g_InfDir},
    {"18"   , &g_HelpDir},
    {"20"   , &g_FontsDir},
    {"21"   , &g_ViewersDir},
    {"23"   , &g_ColorDir},
    {"24"   , &g_WinDrive},
    {"25"   , &g_SharedDir},
    {"30"   , &g_BootDrive},
    {"50"   , &g_SystemDir},
    {"51"   , &g_SpoolDir},
    {"52"   , &g_SpoolDriversDir},
    {"53"   , &g_ProfileDirNt},
    {"54"   , &g_BootDrive},
    {"55"   , &g_PrintProcDir},
    {"1501" , &g_SystemDir},
    {"1501" , &g_System32Dir},
    {"7523" , &g_ProfileDir},
    {"7523" , &g_CommonProfileDir},
    {"16422", &g_ProgramFilesDir},
    {"16427", &g_ProgramFilesCommonDir},
    {"66002", &g_System32Dir},
    {"66003", &g_ColorDir},
    {NULL,  NULL}
    };

typedef struct {
    PCSTR ShellFolderName;
    PCSTR DirId;
} SHELL_TO_DIRS, *PSHELL_TO_DIRS;

SHELL_TO_DIRS g_ShellToDirs[] = {
    {"Administrative Tools", "7501"},
    {"Common Administrative Tools", "7501"},
    {"AppData", "7502"},
    {"Common AppData", "7502"},
    {"Cache", "7503"},
    {"Cookies", "7504"},
    {"Desktop", "7505"},
    {"Common Desktop", "7505"},
    {"Favorites", "7506"},
    {"Common Favorites", "7506"},
    {"Fonts", "7507"},
    {"History", "7508"},
    {"Local AppData", "7509"},
    {"Local Settings", "7510"},
    {"My Music", "7511"},
    {"CommonMusic", "7511"},
    {"My Pictures", "7512"},
    {"CommonPictures", "7512"},
    {"My Video", "7513"},
    {"CommonVideo", "7513"},
    {"NetHood", "7514"},
    {"Personal", "7515"},
    {"Common Personal", "7515"},
    {"Common Documents", "7515"},
    {"PrintHood", "7516"},
    {"Programs", "7517"},
    {"Common Programs", "7517"},
    {"Recent", "7518"},
    {"SendTo", "7519"},
    {"Start Menu", "7520"},
    {"Common Start Menu", "7520"},
    {"Startup", "7521"},
    {"Common Startup", "7521"},
    {"Templates", "7522"},
    {"Common Templates", "7522"},
    {"Profiles", "7523"},
    {"Common Profiles", "7523"},
    {NULL, NULL}
    };

VOID
pAddKnownShellFolder (
    IN      PCTSTR ShellFolderName,
    IN      PCTSTR SrcPath
    )
{
    PSHELL_TO_DIRS p;

    //
    // Translate shell folder name into a dir ID
    //

    for (p = g_ShellToDirs ; p->ShellFolderName ; p++) {
        if (StringIMatch (ShellFolderName, p->ShellFolderName)) {
            break;
        }
    }

    if (!p->ShellFolderName) {
        DEBUGMSG ((DBG_ERROR, "This system has an unsupported shell folder tag: %s", ShellFolderName));
        return;
    }

    //
    // Record dir ID to path match in grow list
    //

    pInsertDirIdPath (_tcstoul (p->DirId, NULL, 10), SrcPath, &g_LastIdPtr);
}


VOID
pInitKnownDirs (
    VOID
    )
{
    USERENUM eUser;
    SF_ENUM e;
    PKNOWN_DIRS p;

    //
    // Add all fixed known dirs to grow lists
    //

    for (p = g_KnownDirs ; p->DirId ; p++) {
        pInsertDirIdPath (_tcstoul (p->DirId, NULL, 10), *(p->Translation), &g_LastIdPtr);
    }

    //
    // Enumerate all users and put their shell folders in a known dirs struct
    //

    if (EnumFirstUser (&eUser, ENUMUSER_ENABLE_NAME_FIX)) {
        do {
            if (!(eUser.AccountType & INVALID_ACCOUNT)) {

                if (eUser.AccountType & NAMED_USER) {
                    //
                    // Process the shell folders for this migrated user
                    //

                    if (EnumFirstRegShellFolder (&e, &eUser)) {
                        do {
                            pAddKnownShellFolder (e.sfName, e.sfPath);
                        } while (EnumNextRegShellFolder (&e));
                    }
                }
            }
        } while (!CANCELLED() && EnumNextUser (&eUser));

        if (EnumFirstRegShellFolder (&e, NULL)) {
            do {
                pAddKnownShellFolder (e.sfName, e.sfPath);
            } while (!CANCELLED() && EnumNextRegShellFolder (&e));
        }
    }
}


VOID
pCleanUpKnownDirs (
    VOID
    )
{
    if (g_DirIdPool) {
        PoolMemDestroyPool (g_DirIdPool);
        g_DirIdPool = NULL;
        g_HeadDirId = NULL;
        g_TailDirId = NULL;
    }
}


VOID
pAddNtFile (
    IN      PCTSTR Dir,             OPTIONAL
    IN      PCTSTR FileName,        OPTIONAL
    IN      BOOL BackupThisFile,
    IN      BOOL CleanThisFile,
    IN      BOOL OsFile
    )
{
    TCHAR copyOfFileName[MAX_PATH];
    PTSTR p;
    PCTSTR fullPath;
    BOOL freePath = FALSE;
    DWORD offset;
    TCHAR key[MEMDB_MAX];
    DWORD value;

    if (!Dir || !FileName) {
        if (!Dir) {
            MYASSERT (FileName);
            fullPath = FileName;
        } else {
            fullPath = Dir;
        }

        StringCopy (copyOfFileName, fullPath);

        p = _tcsrchr (copyOfFileName, TEXT('\\'));
        if (p) {
            *p = 0;
            Dir = copyOfFileName;
            FileName = p + 1;
        } else {
            DEBUGMSG ((DBG_WHOOPS, "Incomplete file name passed as NT OS file: %s", fullPath));
            return;
        }

    } else {
        fullPath = NULL;
    }

    MYASSERT (Dir);
    MYASSERT (FileName);

    if (OsFile) {
        MemDbSetValueEx (
            MEMDB_CATEGORY_NT_DIRS,
            Dir,
            NULL,
            NULL,
            0,
            &offset
            );

        MemDbSetValueEx (
            MEMDB_CATEGORY_NT_FILES,
            FileName,
            NULL,
            NULL,
            offset,
            NULL
            );
    }

    if (BackupThisFile || CleanThisFile) {
        if (!fullPath) {
            fullPath = JoinPaths (Dir, FileName);
            freePath = TRUE;
        }

        if (BackupThisFile) {
            //
            // If the file exists, back it up (and don't clean it)
            //

            if (DoesFileExist (fullPath)) {
                MarkFileForBackup (fullPath);
                CleanThisFile = FALSE;
            }
        }

        if (CleanThisFile) {
            //
            // Clean will cause the NT-installed file to be deleted
            //

            if (!DoesFileExist (fullPath)) {
                MemDbBuildKey (
                    key,
                    MEMDB_CATEGORY_CLEAN_OUT,
                    fullPath,
                    NULL,
                    NULL
                    );

                if (MemDbGetValue (key, &value)) {
                    if (value) {
                        DEBUGMSG ((
                            DBG_WARNING,
                            "File %s already in uninstall cleanout list with type %u",
                            fullPath,
                            value
                            ));
                    }

                    return;
                }

                MemDbSetValue (key, 0);
            }
        }

        if (freePath) {
            FreePathString (fullPath);
        }
    }
}


VOID
pAddNtPath (
    IN      PCTSTR DirName,
    IN      BOOL ForceAsOsFile,
    IN      BOOL WholeTree,
    IN      BOOL ForceDirClean,
    IN      PCTSTR FilePattern,     OPTIONAL
    IN      BOOL ForceFileClean     OPTIONAL
    )
{
    TREE_ENUM e;
    TCHAR rootDir[MAX_PATH];
    PTSTR p;
    BOOL b;
    UINT type;
    TCHAR key[MEMDB_MAX];
    DWORD value;

    MYASSERT (!_tcschr (DirName, TEXT('*')));

    if (IsDriveExcluded (DirName)) {
        DEBUGMSG ((DBG_VERBOSE, "Skipping %s because it is excluded", DirName));
        return;
    }

    if (!IsDriveAccessible (DirName)) {
        DEBUGMSG ((DBG_VERBOSE, "Skipping %s because it is not accessible", DirName));
        return;
    }

    if (!WholeTree) {
        b = EnumFirstFileInTreeEx (&e, DirName, FilePattern, FALSE, FALSE, 1);
    } else {
        b = EnumFirstFileInTree (&e, DirName, FilePattern, FALSE);
    }

    if (b) {
        do {
            if (e.Directory) {
                continue;
            }

            StringCopy (rootDir, e.FullPath);
            p = _tcsrchr (rootDir, TEXT('\\'));
            if (p) {
                *p = 0;

                //
                // Limit the file size to 5MB
                //

                if (e.FindData->nFileSizeHigh == 0 &&
                    e.FindData->nFileSizeLow <= 5242880
                    ) {

                    pAddNtFile (rootDir, e.Name, TRUE, ForceFileClean, ForceAsOsFile);

                }
                ELSE_DEBUGMSG ((
                    DBG_WARNING,
                    "Not backing up big file %s. It is %I64u bytes.",
                    e.FullPath,
                    (ULONGLONG) e.FindData->nFileSizeHigh << 32 | (ULONGLONG) e.FindData->nFileSizeLow
                    ));
            }

        } while (EnumNextFileInTree (&e));
    }

    if (ForceDirClean) {
        type = WholeTree ? BACKUP_AND_CLEAN_TREE : BACKUP_AND_CLEAN_SUBDIR;
    } else if (WholeTree) {
        type = BACKUP_SUBDIRECTORY_TREE;
    } else {
        type = BACKUP_SUBDIRECTORY_FILES;
    }

    MemDbBuildKey (
        key,
        MEMDB_CATEGORY_CLEAN_OUT,
        DirName,
        NULL,
        NULL
        );

    if (MemDbGetValue (key, &value)) {
        if (!value && type) {
            DEBUGMSG ((
                DBG_WARNING,
                "NT File %s already in uninstall cleanout list, overriding with type %u",
                DirName,
                type
                ));
        } else {
            if (value != type) {
                DEBUGMSG ((
                    DBG_WARNING,
                    "NT File %s already in uninstall cleanout list with type %u",
                    DirName,
                    value
                    ));
            }

            return;
        }
    }

    MemDbSetValue (key, type);
}


VOID
pAddEmptyDirsTree (
    IN      PCTSTR RootDir
    )
{
    TREE_ENUM e;
    DWORD attribs;
    TCHAR key[MEMDB_MAX];
    DWORD value;

    if (IsDriveExcluded (RootDir)) {
        DEBUGMSG ((DBG_VERBOSE, "Skipping empty dir tree of %s because it is excluded", RootDir));
        return;
    }

    if (!IsDriveAccessible (RootDir)) {
        DEBUGMSG ((DBG_VERBOSE, "Skipping empty dir tree of %s because it is not accessible", RootDir));
        return;
    }

    if (DoesFileExist (RootDir)) {
        if (EnumFirstFileInTreeEx (
                &e,
                RootDir,
                NULL,
                FALSE,
                FALSE,
                FILE_ENUM_ALL_LEVELS
                )) {
            do {
                if (e.Directory) {
                    AddDirPathToEmptyDirsCategory (e.FullPath, TRUE, FALSE);
                }
            } while (EnumNextFileInTree (&e));
        } else {
            attribs = GetFileAttributes (RootDir);
            if (attribs == FILE_ATTRIBUTE_DIRECTORY ||
                attribs == INVALID_ATTRIBUTES
                ) {
                attribs = 0;
            }

            MemDbBuildKey (
                key,
                MEMDB_CATEGORY_EMPTY_DIRS,
                RootDir,
                NULL,
                NULL
                );

            if (MemDbGetValue (key, &value)) {
                if (value) {
                    DEBUGMSG_IF ((
                        value != attribs,
                        DBG_ERROR,
                        "Ignoring conflict in empty dirs for %s",
                        RootDir
                        ));

                    return;
                }
            }

            MemDbSetValue (key, attribs);
        }
    }
    ELSE_DEBUGMSG ((DBG_SYSMIG, "Uninstall: dir does not exist: %s", RootDir));
}


BOOL
ReadNtFilesEx (
    IN      PCSTR FileListName,    //optional, if null default is opened
    IN      BOOL ConvertPath
    )
{
    PCSTR fileListName = NULL;
    PCSTR fileListTmp = NULL;
    HANDLE fileHandle = NULL;
    HANDLE mapHandle = NULL;
    PCSTR filePointer = NULL;
    PCSTR dirPointer = NULL;
    PCSTR filePtr = NULL;
    DWORD offset;
    DWORD version;
    BOOL result = FALSE;
    CHAR dirName [MEMDB_MAX];
    PSTR p;
    UINT u;
    INFSTRUCT is = INITINFSTRUCT_POOLHANDLE;
    PCTSTR fileName;
    PCTSTR fileLoc;
    PCTSTR dirId;
    PCTSTR field3;
    PCTSTR field4;
    BOOL forceAsOsFile;
    BOOL forceDirClean;
    DIRNAME_ENUM nameEnum;
    BOOL treeMode;
    HINF drvIndex;
    MEMDB_ENUM memdbEnum;
    DWORD fileAttributes;
    PCTSTR fullPath;
    PCTSTR systemPath;
    BOOL b;
    PDIRIDMAP lastMatch = NULL;
    UINT ticks = 0;

    __try {

        pInitKnownDirs();

        //
        // add to this list the dirs listed in [WinntDirectories] section of txtsetup.sif
        //
        if (InfFindFirstLine(g_TxtSetupSif, S_WINNTDIRECTORIES, NULL, &is)) {

            //
            // all locations are relative to %windir%
            // prepare %windir%\
            //
            StringCopy (dirName, g_WinDir);
            p = GetEndOfString (dirName);
            *p++ = TEXT('\\');

            do {

                ticks++;
                if ((ticks & 255) == 0) {
                    if (!TickProgressBarDelta (TICKS_READ_NT_FILES / 50)) {
                        __leave;
                    }
                }

                //
                // For each entry, add the dir in memdb
                //
                fileLoc = InfGetStringField(&is, 1);

                //
                // ignore special entry "\"
                //
                if (fileLoc && !StringMatch(fileLoc, TEXT("\\"))) {

                    StringCopy (p, fileLoc);

                    MemDbSetValueEx (
                        MEMDB_CATEGORY_NT_DIRS,
                        dirName,
                        NULL,
                        NULL,
                        0,
                        NULL
                        );

                    pAddNtFile (NULL, dirName, FALSE, TRUE, FALSE);
                }

            } while (InfFindNextLine(&is));
        }

        if (FileListName != NULL) {
            filePointer = MapFileIntoMemory (FileListName, &fileHandle, &mapHandle);
        }
        else {
            for (u = 0 ; !fileListName && u < SOURCEDIRECTORYCOUNT() ; u++) {

                fileListName = JoinPaths (SOURCEDIRECTORY(u), S_FILELIST_UNCOMPRESSED);
                if (DoesFileExist (fileListName)) {
                    break;
                }
                FreePathString (fileListName);
                fileListName = JoinPaths (SOURCEDIRECTORY(u), S_FILELIST_COMPRESSED);
                if (DoesFileExist (fileListName)) {
                    fileListTmp = JoinPaths (g_TempDir, S_FILELIST_UNCOMPRESSED);
                    if (SetupDecompressOrCopyFile (fileListName, fileListTmp, 0) == NO_ERROR) {
                        FreePathString (fileListName);
                        fileListName = fileListTmp;
                        break;
                    }
                    DEBUGMSG ((DBG_ERROR, "Can't copy %s to %s", fileListName, fileListTmp));
                    __leave;
                }
                FreePathString (fileListName);
                fileListName = NULL;
            }
            if (!fileListName) {
                SetLastError (ERROR_FILE_NOT_FOUND);
                DEBUGMSG ((DBG_ERROR, "Can't find %s", fileListName));
                __leave;
            }
            filePointer = MapFileIntoMemory (fileListName, &fileHandle, &mapHandle);

            if (!fileListTmp) {
                FreePathString (fileListName);
            }
        }
        filePtr = filePointer;
        if (filePointer == NULL) {
            DEBUGMSG ((DBG_ERROR, "Invalid file format: %s", fileListName));
            __leave;
        }
        version = *((PDWORD) filePointer);
        filePointer += sizeof (DWORD);
        __try {
            if (version >= 1) {
                while (*filePointer != 0) {
                    ticks++;
                    if ((ticks & 255) == 0) {
                        if (!TickProgressBarDelta (TICKS_READ_NT_FILES / 50)) {
                            __leave;
                        }
                    }

                    dirPointer = filePointer;
                    filePointer = GetEndOfString (filePointer) + 1;

                    if (ConvertPath) {
                        //
                        // First loop: add the OS file exactly as it is in filelist.dat
                        //

                        if (pConvertFirstDirName (&nameEnum, dirPointer, dirName, &lastMatch, FALSE)) {
                            do {
                                pAddNtFile (dirName, filePointer, FALSE, FALSE, TRUE);
                            } while (pConvertNextDirName (&nameEnum));
                        }

                        //
                        // Second loop: add the file for backup, implementing the special system/system32 hack
                        //

                        if (pConvertFirstDirName (&nameEnum, dirPointer, dirName, &lastMatch, TRUE)) {
                            do {
                                pAddNtFile (dirName, filePointer, TRUE, FALSE, FALSE);
                            } while (pConvertNextDirName (&nameEnum));
                        }
                    } else {
                        pAddNtFile (dirPointer, filePointer, TRUE, FALSE, TRUE);
                    }

                    filePointer = GetEndOfString (filePointer) + 1;
                }

                if (version >= 2) {
                    filePointer ++;
                    while (*filePointer != 0) {
                        ticks++;
                        if ((ticks & 255) == 0) {
                            if (!TickProgressBarDelta (TICKS_READ_NT_FILES / 50)) {
                                __leave;
                            }
                        }

                        MemDbSetValueEx (
                            MEMDB_CATEGORY_NT_FILES_EXCEPT,
                            filePointer,
                            NULL,
                            NULL,
                            0,
                            NULL
                            );
                        filePointer = GetEndOfString (filePointer) + 1;
                    }

                    if (version >= 3) {
                        ticks++;
                        if ((ticks & 255) == 0) {
                            if (!TickProgressBarDelta (TICKS_READ_NT_FILES / 50)) {
                                __leave;
                            }
                        }

                        filePointer ++;
                        while (*filePointer != 0) {
                            dirPointer = filePointer;
                            filePointer = GetEndOfString (filePointer) + 1;

                            if (ConvertPath) {
                                if (pConvertFirstDirName (&nameEnum, dirPointer, dirName, &lastMatch, TRUE)) {
                                    do {
                                        pAddNtFile (dirName, filePointer, TRUE, FALSE, FALSE);
                                    } while (pConvertNextDirName (&nameEnum));
                                }
                            } else {
                                pAddNtFile (dirPointer, filePointer, TRUE, FALSE, FALSE);
                            }

                            filePointer = GetEndOfString (filePointer) + 1;
                        }
                    }
                }
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER){
            LOG ((LOG_ERROR, "Access violation while reading NT file list."));
            __leave;
        }

        if (CANCELLED()) {
            __leave;
        }

        // so far so good. Let's read static installed section from win95upg.inf
        MYASSERT (g_Win95UpgInf);

        //
        // Cycle through all of the entries in the StaticInstalledFiles section.
        //
        if (InfFindFirstLine(g_Win95UpgInf,S_STATIC_INSTALLED_FILES,NULL,&is)) {

            do {

                ticks++;
                if ((ticks & 255) == 0) {
                    if (!TickProgressBarDelta (TICKS_READ_NT_FILES / 50)) {
                        __leave;
                    }
                }

                //
                // For each entry, add the file with it's location in memdb
                //
                fileName = InfGetStringField(&is,1);
                fileLoc = InfGetStringField(&is,2);

                if (fileName && fileLoc) {
                    if (ConvertPath) {
                        if (pConvertFirstDirName (&nameEnum, fileLoc, dirName, &lastMatch, FALSE)) {
                            do {
                                pAddNtFile (dirName, fileName, TRUE, FALSE, TRUE);
                            } while (pConvertNextDirName (&nameEnum));
                        }
                    } else {
                        pAddNtFile (fileLoc, fileName, TRUE, FALSE, TRUE);
                    }
                }

            } while (InfFindNextLine(&is));
        }

        //
        // Add the files in drvindex.inf
        //

        drvIndex = InfOpenInfInAllSources (TEXT("drvindex.inf"));

        if (drvIndex == INVALID_HANDLE_VALUE) {
            LOG ((LOG_ERROR, "Can't open drvindex.inf."));
            return FALSE;
        }

        if (InfFindFirstLine (drvIndex, TEXT("driver"), NULL, &is)) {
            do {
                ticks++;
                if ((ticks & 255) == 0) {
                    if (!TickProgressBarDelta (TICKS_READ_NT_FILES / 50)) {
                        __leave;
                    }
                }

                fileName = InfGetStringField (&is, 1);

                //
                // Is this drive file already listed in the file list?
                //

                wsprintf (dirName, MEMDB_CATEGORY_NT_FILES TEXT("\\%s"), fileName);
                if (MemDbGetValue (dirName, NULL)) {
                    DEBUGMSG ((DBG_SYSMIG, "%s is listed in drivers and in filelist.dat", fileName));
                } else {
                    //
                    // Add this file
                    //

                    pAddNtFile (g_DriversDir, fileName, TRUE, TRUE, TRUE);
                }

            } while (InfFindNextLine (&is));
        }

        InfCloseInfFile (drvIndex);

        //
        // This code marks files to be backed up, because they aren't being caught
        // through the regular mechanisms of setup.
        //

        if (InfFindFirstLine (g_Win95UpgInf, TEXT("Backup"), NULL, &is)) {
            do {

                ticks++;
                if ((ticks & 255) == 0) {
                    if (!TickProgressBarDelta (TICKS_READ_NT_FILES / 50)) {
                        __leave;
                    }
                }

                InfResetInfStruct (&is);

                dirId = InfGetStringField (&is, 1);
                fileName = InfGetStringField (&is, 2);
                field3 = InfGetStringField (&is, 3);
                field4 = InfGetStringField (&is, 4);

                if (dirId && *dirId == 0) {
                    dirId = NULL;
                }

                if (fileName && *fileName == 0) {
                    fileName = NULL;
                }

                if (field3 && *field3 == 0) {
                    field3 = NULL;
                }

                if (field4 && *field4 == 0) {
                    field4 = NULL;
                }

                if (!dirId) {
                    continue;
                }

#ifdef DEBUG
                if (!fileName) {
                    p = _tcsrchr (dirId, TEXT('\\'));
                    if (!p) {
                        p = (PTSTR) dirId;
                    }

                    p = _tcschr (p, TEXT('.'));
                    if (p) {
                        DEBUGMSG ((DBG_WHOOPS, "%s should be a dir spec, but it looks like it has a file.", dirId));
                    }
                }
#endif

                if (field3) {
                    forceAsOsFile = _ttoi (field3) != 0;
                } else {
                    forceAsOsFile = FALSE;
                }

                if (field4) {
                    forceDirClean = _ttoi (field4) != 0;
                } else {
                    forceDirClean = FALSE;
                }

                treeMode = FALSE;

                p = _tcsrchr (dirId, TEXT('\\'));
                if (p && p[1] == TEXT('*') && !p[2]) {
                    *p = 0;
                    treeMode = TRUE;
                } else {
                    p = NULL;
                }

                if (ConvertPath) {
                    if (pConvertFirstDirName (&nameEnum, dirId, dirName, &lastMatch, FALSE)) {
                        do {
                            if (fileName && !treeMode) {
                                if (_tcsrchr (fileName, TEXT('*')) || _tcsrchr (fileName, TEXT('?'))) {
                                    //
                                    //Add files that match "fileName" pattern from "dirName" directory only
                                    //
                                    pAddNtPath (dirName, forceAsOsFile, FALSE, FALSE, fileName, TRUE);
                                } else {
                                    //
                                    //Add only one file "fileName"
                                    //
                                    pAddNtFile (dirName, fileName, TRUE, TRUE, forceAsOsFile);
                                }
                            } else {
                                if (INVALID_ATTRIBUTES == GetFileAttributes (dirName)) {
                                    if (dirName[0] && dirName[1] == TEXT(':')) {
                                        pAddNtPath (dirName, FALSE, treeMode, forceDirClean, NULL, FALSE);
                                    }
                                } else {
                                    //
                                    //Add all files that match "fileName" pattern from whole tree starting from "dirName"
                                    //
                                    pAddNtPath (dirName, forceAsOsFile, treeMode, forceDirClean, fileName, FALSE);
                                }
                            }
                        } while (pConvertNextDirName (&nameEnum));
                    }
                }

            } while (InfFindNextLine (&is));
        }

        //
        // In some cases, NT components create empty directories for future use.
        // Some of them aren't ever used. Because setup does not know about
        // them, we list the special cases in a win95upg.inf section called
        // [Uninstall.Delete].
        //
        // For each entry, record the files or empty directories that need to be
        // removed in an uninstall. If an directory is specified but is not empty,
        // then it won't be altered during uninstall.
        //

        if (InfFindFirstLine (g_Win95UpgInf, TEXT("Uninstall.Delete"), NULL, &is)) {
            do {
                ticks++;
                if ((ticks & 255) == 0) {
                    if (!TickProgressBarDelta (TICKS_READ_NT_FILES / 50)) {
                        __leave;
                    }
                }

                dirId = InfGetStringField (&is, 1);
                fileName = InfGetStringField (&is, 2);

                if (!dirId || *dirId == 0) {
                    continue;
                }

                if (fileName && *fileName == 0) {
                    fileName = NULL;
                }

                if (ConvertPath) {
                    if (pConvertFirstDirName (&nameEnum, dirId, dirName, &lastMatch, FALSE)) {
                        do {
                            pAddNtFile (dirName, fileName, FALSE, TRUE, FALSE);
                        } while (pConvertNextDirName (&nameEnum));
                    }
                }

            } while (InfFindNextLine (&is));
        }

        if (InfFindFirstLine (g_Win95UpgInf, TEXT("Uninstall.KeepEmptyDirs"), NULL, &is)) {
            do {
                ticks++;
                if ((ticks & 255) == 0) {
                    if (!TickProgressBarDelta (TICKS_READ_NT_FILES / 50)) {
                        __leave;
                    }
                }

                dirId = InfGetStringField (&is, 1);

                if (!dirId || *dirId == 0) {
                    continue;
                }

                if (ConvertPath) {
                    if (pConvertFirstDirName (&nameEnum, dirId, dirName, &lastMatch, FALSE)) {
                        do {
                            pAddEmptyDirsTree (dirName);
                        } while (pConvertNextDirName (&nameEnum));
                    }
                }

            } while (InfFindNextLine (&is));
        }

        result = TRUE;

    }
    __finally {
        UnmapFile ((PVOID)filePtr, fileHandle, mapHandle);
        if (fileListTmp) {
            DeleteFile (fileListTmp);
            FreePathString (fileListTmp);
            fileListTmp = NULL;
        }

        InfCleanUpInfStruct(&is);
        pCleanUpKnownDirs();
    }

    return CANCELLED() ? FALSE : result;
}

DWORD
ReadNtFiles (
    IN      DWORD Request
    )
{
    DWORD ticks = 0;

    switch (Request) {
    case REQUEST_QUERYTICKS:
        return TICKS_READ_NT_FILES;

    case REQUEST_RUN:
        ProgressBar_SetComponentById (MSG_PREPARING_LIST);
        ProgressBar_SetSubComponent (NULL);
        if (!ReadNtFilesEx (NULL, TRUE)) {
            return GetLastError ();
        }
        else {
            return ERROR_SUCCESS;
        }

    default:
        DEBUGMSG ((DBG_ERROR, "Bad parameter in ReadNtFiles"));
    }

    return 0;
}


BOOL
pIsDriverKnown (
    IN      PCTSTR DriverFileName,
    IN      PCTSTR FullPath,
    IN      BOOL DeleteMeansKnown
    )
{
    HANDLE h;
    DWORD Status;

    //
    // Does DriverFileName have an extension?  We require one.
    // If no dot exists, then we assume this is something an OEM added.
    //

    if (!_tcschr (DriverFileName, TEXT('.'))) {
        return TRUE;
    }

    //
    // Is this file in migdb?
    //

    if (IsKnownMigDbFile (DriverFileName)) {
        return TRUE;
    }

    //
    // Is it going to be processed?
    //

    Status = GetFileStatusOnNt (FullPath);

    if (Status != FILESTATUS_UNCHANGED) {
        //
        // If marked for delete, and DeleteMeansKnown is FALSE, then
        // we consider the file unknown because it is simply being
        // deleted as a cleanup step.
        //
        // If DeleteMeansKnown is TRUE, then the caller assumes that
        // a file marked for delete is a known driver.
        //

        if (!(Status == FILESTATUS_DELETED) || DeleteMeansKnown) {
            return TRUE;
        }
    }

    //
    // Make sure this is a NE header (or the more common case, the LE
    // header)
    //

    h = OpenNeFile (FullPath);
    if (!h) {
        DEBUGMSG ((DBG_WARNING, "%s is not a NE file", FullPath));

        //
        // Is this a PE file?  If so, the last error will be
        // ERROR_BAD_EXE_FORMAT.
        //

        if (GetLastError() == ERROR_BAD_EXE_FORMAT) {
            return FALSE;
        }

        DEBUGMSG ((DBG_WARNING, "%s is not a PE file", FullPath));
        return TRUE;
    }

    CloseNeFile (h);

    return FALSE;
}



BOOL
pWarnAboutOldDrivers (
    VOID
    )
{
    HINF Inf;
    TCHAR Path[MAX_TCHAR_PATH];
    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;
    BOOL b = FALSE;
    PCTSTR Data;
    PCTSTR DriverFile;
    BOOL OldDriverFound = FALSE;
    PCTSTR Group;
    PCTSTR Message;
    TCHAR FullPath[MAX_TCHAR_PATH];
    GROWBUFFER FileList = GROWBUF_INIT;
    PTSTR p;

    wsprintf (Path, TEXT("%s\\system.ini"), g_WinDir);

    Inf = InfOpenInfFile (Path);
    if (Inf != INVALID_HANDLE_VALUE) {
        if (InfFindFirstLine (Inf, TEXT("386Enh"), NULL, &is)) {
            do {
                Data = InfGetStringField (&is, 1);
                if (Data) {
                    //
                    // Determine if device driver is known
                    //

                    if (_tcsnextc (Data) != TEXT('*')) {
                        DriverFile = GetFileNameFromPath (Data);

                        if (!_tcschr (Data, TEXT(':'))) {
                            if (!SearchPath (
                                    NULL,
                                    DriverFile,
                                    NULL,
                                    MAX_TCHAR_PATH,
                                    FullPath,
                                    NULL
                                    )) {
                                _tcssafecpy (FullPath, Data, MAX_TCHAR_PATH);
                            }
                        } else {
                            _tcssafecpy (FullPath, Data, MAX_TCHAR_PATH);
                        }

                        if (!pIsDriverKnown (DriverFile, FullPath, TRUE)) {
                            //
                            // Unidentified driver; log it and turn on
                            // incompatibility message.
                            //

                            p = (PTSTR) GrowBuffer (&FileList, ByteCount (FullPath) + 7 * sizeof (TCHAR));
                            if (p) {
                                wsprintf (p, TEXT("    %s\r\n"), FullPath);
                                FileList.End -= sizeof (TCHAR);
                            }

                            OldDriverFound = TRUE;
                            MsgMgr_LinkObjectWithContext (TEXT("*386ENH"), Data);
                        } else {
                            DEBUGMSG ((DBG_NAUSEA, "Driver %s is known", Data));
                        }
                    }
                }

            } while (InfFindNextLine (&is));
        }
        ELSE_DEBUGMSG ((DBG_ERROR, "pWarnAboutOldDrivers: Cannot open %s", Path));

        InfCloseInfFile (Inf);
        InfCleanUpInfStruct (&is);

        b = TRUE;
    }

/*NTBUG9:155050
    if (OldDriverFound) {
        LOG ((LOG_INFORMATION, (PCSTR)MSG_386ENH_DRIVER_LOG, FileList.Buf));

        Group = BuildMessageGroup (MSG_INCOMPATIBLE_HARDWARE_ROOT, MSG_OLD_DRIVER_FOUND_SUBGROUP, NULL);
        Message = GetStringResource (MSG_OLD_DRIVER_FOUND_MESSAGE);

        if (Message && Group) {
            MsgMgr_ContextMsg_Add (TEXT("*386ENH"), Group, Message);
        }

        FreeText (Group);
        FreeStringResource (Message);
    }
*/

    FreeGrowBuffer (&FileList);

    return b;
}

DWORD
MoveSystemRegistry (
    IN DWORD    Request
    )
{
    PCTSTR path = NULL;

    switch (Request) {

    case REQUEST_QUERYTICKS:

        return TICKS_MOVE_SYSTEMREGISTRY;

    case REQUEST_RUN:

        path = JoinPaths (g_WinDir, S_SYSTEMDAT);
        MarkHiveForTemporaryMove (path, g_TempDir, NULL, TRUE, FALSE);
        FreePathString (path);
        //
        // on Millennium, also save classes.dat hive
        //
        path = JoinPaths (g_WinDir, S_CLASSESDAT);
        MarkHiveForTemporaryMove (path, g_TempDir, NULL, TRUE, FALSE);
        FreePathString (path);

        return ERROR_SUCCESS;
    }

    return 0;
}


VOID
pProcessJoystick (
    PJOYSTICK_ENUM EnumPtr
    )
{
    PCTSTR Group;
    TCHAR FullPath[MAX_TCHAR_PATH];

    //
    // Is this joystick compatible?
    //

    if (!_tcschr (EnumPtr->JoystickDriver, TEXT('\\'))) {
        if (!SearchPath (NULL, EnumPtr->JoystickDriver, NULL, MAX_TCHAR_PATH, FullPath, NULL)) {
            StringCopy (FullPath, EnumPtr->JoystickDriver);
        }
    } else {
        StringCopy (FullPath, EnumPtr->JoystickDriver);
    }

    if (!pIsDriverKnown (GetFileNameFromPath (FullPath), FullPath, FALSE)) {
        LOG ((
            LOG_INFORMATION,
            "Joystick driver for %s is not known: %s",
            EnumPtr->JoystickName,
            FullPath
            ));

        Group = BuildMessageGroup (
                    MSG_INCOMPATIBLE_HARDWARE_ROOT,
                    MSG_JOYSTICK_SUBGROUP,
                    EnumPtr->JoystickName
                    );

        MsgMgr_ObjectMsg_Add (
            FullPath,
            Group,
            NULL
            );

        FreeText (Group);
    }
}


DWORD
ReportIncompatibleJoysticks (
    IN DWORD    Request
    )
{
    JOYSTICK_ENUM e;

    switch (Request) {

    case REQUEST_QUERYTICKS:

        return TICKS_JOYSTICK_DETECTION;

    case REQUEST_RUN:

        if (EnumFirstJoystick (&e)) {

            do {

                pProcessJoystick (&e);

            } while (EnumNextJoystick (&e));
        }

        return ERROR_SUCCESS;
    }

    return 0;
}


DWORD
TwainCheck (
    DWORD Request
    )
{
    TWAINDATASOURCE_ENUM e;
    PCTSTR Group;

    if (Request == REQUEST_QUERYTICKS) {
        return TICKS_TWAIN;
    } else if (Request != REQUEST_RUN) {
        return 0;
    }

    if (EnumFirstTwainDataSource (&e)) {
        do {

            if (!TreatAsGood (e.DataSourceModule) &&
                !pIsDriverKnown (
                    GetFileNameFromPath (e.DataSourceModule),
                    e.DataSourceModule,
                    FALSE
                )) {

                //
                // Nobody handled the file.  Generate a warning.
                //

                Group = BuildMessageGroup (
                            MSG_INCOMPATIBLE_HARDWARE_ROOT,
                            MSG_TWAIN_SUBGROUP,
                            e.DisplayName
                            );

                MsgMgr_ObjectMsg_Add (
                    e.DataSourceModule,
                    Group,
                    NULL
                    );

                MarkFileForDelete (e.DataSourceModule);

                FreeText (Group);
            }
        } while (EnumNextTwainDataSource (&e));
    }

    return ERROR_SUCCESS;
}


DWORD
ProcessRecycleBins (
    DWORD Request
    )
{

    ACCESSIBLE_DRIVE_ENUM e;
    TREE_ENUM eFiles;
    BOOL recycleFound;
    UINT filesDeleted;
    TCHAR recycledInfo[] = TEXT("x:\\recycled\\INFO");
    TCHAR recyclerInfo[] = TEXT("x:\\recycler\\INFO");
    TCHAR recycledInfo2[] = TEXT("x:\\recycled\\INFO2");
    TCHAR recyclerInfo2[] = TEXT("x:\\recycler\\INFO2");
    TCHAR recycled[] = TEXT("x:\\recycled");
    TCHAR recycler[] = TEXT("x:\\recycler");
    PTSTR dir;
    PCTSTR args[1];
    PCTSTR message;
    PCTSTR group;


    if (Request == REQUEST_QUERYTICKS) {

        return TICKS_RECYCLEBINS;
    }
    else if (Request != REQUEST_RUN) {

        return 0;
    }
    recycleFound = FALSE;
    filesDeleted = 0;

    //
    // Enumerate through each of the accessible drives looking for
    // a directory called RECYCLED or RECYCLER on the root.
    //
    if (GetFirstAccessibleDriveEx (&e, TRUE)) {

        do {
            dir = NULL;

            //
            // See if there is any recycle information to examine on
            // this drive.
            //
            recycledInfo[0] = *e->Drive;
            recyclerInfo[0] = *e->Drive;
            recycledInfo2[0] = *e->Drive;
            recyclerInfo2[0] = *e->Drive;

            recycler[0] = *e->Drive;
            recycled[0] = *e->Drive;
            if (DoesFileExist (recycledInfo) || DoesFileExist (recycledInfo2)) {
                dir = recycled;
            }
            else if (DoesFileExist(recyclerInfo) || DoesFileExist (recyclerInfo2)) {
                dir = recycler;
            }

            if (dir) {
                if (IsDriveExcluded (dir)) {
                    DEBUGMSG ((DBG_VERBOSE, "Skipping recycle dir %s because it is excluded", dir));
                    dir = NULL;
                } else if (!IsDriveAccessible (dir)) {
                    DEBUGMSG ((DBG_VERBOSE, "Skipping recycle dir %s because it is not accessible", dir));
                    dir = NULL;
                }
            }

            if (dir && EnumFirstFileInTree (&eFiles, dir, NULL, FALSE)) {

                //
                // We have work to do, Enumerate the files and mark them for
                // deletion.
                //
                do {

                    //
                    // Mark the file for deletion, tally up the saved bytes, and free the space on the drive.
                    //
                    filesDeleted++;
                    FreeSpace (eFiles.FullPath,(eFiles.FindData->nFileSizeHigh * MAXDWORD) + eFiles.FindData->nFileSizeLow);

                    //
                    // only display Recycle Bin warning if there are visible files there
                    //
                    if (!(eFiles.FindData->dwFileAttributes & FILE_ATTRIBUTE_HIDDEN)) {
                        recycleFound = TRUE;
                    }


                } while (EnumNextFileInTree (&eFiles));

                //
                // We are going to delete all of this directory.
                //
                MemDbSetValueEx (MEMDB_CATEGORY_FULL_DIR_DELETES, dir, NULL, NULL, 0, NULL);

            }

        } while (GetNextAccessibleDrive (&e));
    }

    if (recycleFound) {

        //
        // We need to provide the user with a message.
        //
        wsprintf(recycled,"%d",filesDeleted);
        args[0] = recycled;
        group = BuildMessageGroup (MSG_INSTALL_NOTES_ROOT, MSG_RECYCLE_BIN_SUBGROUP, NULL);
        message = ParseMessageID (MSG_RECYCLED_FILES_WILL_BE_DELETED, args);

        if (message && group) {
            MsgMgr_ObjectMsg_Add (TEXT("*RECYCLEBIN"), group, message);

            FreeText (group);
            FreeStringResource (message);
        }
    }

    return 0;
}


DWORD
AnswerFileDetection (
    IN DWORD    Request
    )
{
    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;
    TCHAR KeyStr[MAX_REGISTRY_KEY];
    TCHAR EncodedKeyStr[MAX_ENCODED_RULE];
    TCHAR ValueName[MAX_REGISTRY_VALUE_NAME];
    TCHAR EncodedValueName[MAX_ENCODED_RULE];
    PTSTR ValueDataPattern = NULL;
    PBYTE ValueData = NULL;
    PTSTR ValueDataStr = NULL;
    PCTSTR p;
    PTSTR q;
    HKEY Key = NULL;
    BOOL DefaultValue;
    TCHAR SectionName[MAX_INF_SECTION_NAME];
    TCHAR InfKey[MAX_INF_KEY_NAME];
    TCHAR InfKeyData[MAX_INF_KEY_NAME];
    DWORD Type;
    DWORD Size;
    BOOL Match;
    UINT u;

    switch (Request) {

    case REQUEST_QUERYTICKS:

        return TICKS_ANSWER_FILE_DETECTION;

    case REQUEST_RUN:

        if (InfFindFirstLine (g_Win95UpgInf, S_ANSWER_FILE_DETECTION, NULL, &is)) {
            do {
                __try {
                    //
                    // The first field has the key and optional value, encoded
                    // in the standard usermig.inf and wkstamig.inf syntax
                    //

                    DefaultValue = FALSE;

                    p = InfGetStringField (&is, 1);
                    if (!p || *p == 0) {
                        continue;
                    }

                    StackStringCopy (EncodedKeyStr, p);
                    q = _tcschr (EncodedKeyStr, TEXT('['));

                    if (q) {
                        StringCopy (EncodedValueName, SkipSpace (q + 1));
                        *q = 0;

                        q = _tcschr (EncodedValueName, TEXT(']'));
                        if (q) {
                            *q = 0;
                        }
                        ELSE_DEBUGMSG ((
                            DBG_WHOOPS,
                            "Unmatched square brackets in %s (see [%s])",
                            p,
                            S_ANSWER_FILE_DETECTION
                            ));

                        if (*EncodedValueName == 0) {
                            DefaultValue = TRUE;
                        } else {
                            q = (PTSTR) SkipSpaceR (EncodedValueName, NULL);
                            if (q) {
                                *_mbsinc (q) = 0;
                            }
                        }

                    } else {
                        *EncodedValueName = 0;
                    }

                    q = (PTSTR) SkipSpaceR (EncodedKeyStr, NULL);
                    if (q) {
                        *_mbsinc (q) = 0;
                    }

                    DecodeRuleChars (KeyStr, EncodedKeyStr);
                    DecodeRuleChars (ValueName, EncodedValueName);

                    //
                    // The second field has the optional value data.  If it
                    // is empty, then the value data is not tested.
                    //

                    p = InfGetStringField (&is, 2);
                    if (p && *p) {
                        ValueDataPattern = AllocText (CharCount (p) + 1);
                        StringCopy (ValueDataPattern, p);
                    } else {
                        ValueDataPattern = NULL;
                    }

                    //
                    // The third field has the section name
                    //

                    p = InfGetStringField (&is, 3);
                    if (!p || *p == 0) {
                        DEBUGMSG ((DBG_WHOOPS, "Section %s lacks a section name", S_ANSWER_FILE_DETECTION));
                        continue;
                    }

                    StackStringCopy (SectionName, p);

                    //
                    // The fourth field gives the INF key name
                    //

                    p = InfGetStringField (&is, 4);
                    if (!p || *p == 0) {
                        DEBUGMSG ((DBG_WHOOPS, "Section %s lacks an INF key", S_ANSWER_FILE_DETECTION));
                        continue;
                    }

                    StackStringCopy (InfKey, p);

                    //
                    // The fifth field is optional and gives the INF value name.
                    // The default is 1.
                    //

                    p = InfGetStringField (&is, 5);
                    if (p && *p != 0) {
                        StackStringCopy (InfKeyData, p);
                    } else {
                        StringCopy (InfKeyData, TEXT("1"));
                    }

                    //
                    // Data is gathered.  Now test the rule.
                    //

                    DEBUGMSG ((
                        DBG_NAUSEA,
                        "Testing answer file setting.\n"
                            "Key: %s\n"
                            "Value Name: %s\n"
                            "Value Data: %s\n"
                            "Section: %s\n"
                            "Key: %s\n"
                            "Key Value: %s",
                        KeyStr,
                        *ValueName ? ValueName : DefaultValue ? TEXT("<default>") : TEXT("<unspecified>"),
                        ValueDataPattern ? ValueDataPattern : TEXT("<unspecified>"),
                        SectionName,
                        InfKey,
                        InfKeyData
                        ));

                    Match = FALSE;

                    Key = OpenRegKeyStr (KeyStr);

                    if (Key) {

                        //
                        // Test the value name
                        //

                        if (*ValueName || DefaultValue) {

                            if (GetRegValueTypeAndSize (Key, ValueName, &Type, &Size)) {
                                //
                                // Test the value data
                                //

                                if (ValueDataPattern) {
                                    //
                                    // Get the data
                                    //

                                    ValueData = GetRegValueData (Key, ValueName);
                                    if (!ValueData) {
                                        MYASSERT (FALSE);
                                        continue;
                                    }

                                    //
                                    // Create the string
                                    //

                                    switch (Type) {
                                    case REG_SZ:
                                    case REG_EXPAND_SZ:
                                        ValueDataStr = DuplicateText ((PCTSTR) ValueData);
                                        break;

                                    case REG_DWORD:
                                        ValueDataStr = AllocText (11);
                                        wsprintf (ValueDataStr, TEXT("0x%08X"), *((PDWORD) ValueData));
                                        break;

                                    default:
                                        ValueDataStr = AllocText (3 * (max (1, Size)));
                                        q = ValueDataStr;

                                        for (u = 0 ; u < Size ; u++) {
                                            if (u) {
                                                *q++ = TEXT(' ');
                                            }

                                            wsprintf (q, TEXT("%02X"), ValueData[u]);
                                            q += 2;
                                        }

                                        *q = 0;
                                        break;
                                    }

                                    //
                                    // Pattern-match the string
                                    //

                                    if (IsPatternMatch (ValueDataPattern, ValueDataStr)) {
                                        DEBUGMSG ((DBG_NAUSEA, "Key, value name and value data found"));
                                        Match = TRUE;
                                    }
                                    ELSE_DEBUGMSG ((
                                        DBG_NAUSEA,
                                        "Value data %s did not match %s",
                                        ValueDataStr,
                                        ValueDataPattern
                                        ));

                                } else {

                                    DEBUGMSG ((DBG_NAUSEA, "Key and value name found"));
                                    Match = TRUE;
                                }


                            }
                            ELSE_DEBUGMSG ((DBG_NAUSEA, "Value name not found, rc=%u", GetLastError()));

                        } else {
                            DEBUGMSG ((DBG_NAUSEA, "Key found"));
                            Match = TRUE;
                        }

                    }
                    ELSE_DEBUGMSG ((DBG_NAUSEA, "Key not found, rc=%u", GetLastError()));

                    if (Match) {
                        WriteInfKey (SectionName, InfKey, InfKeyData);
                    }

                }
                __finally {
                    if (Key) {
                        CloseRegKey (Key);
                        Key = NULL;
                    }

                    FreeText (ValueDataPattern);
                    ValueDataPattern = NULL;

                    if (ValueData) {
                        MemFree (g_hHeap, 0, ValueData);
                        ValueData = NULL;
                    }

                    FreeText (ValueDataStr);
                    ValueDataStr = NULL;
                }
            } while (InfFindNextLine (&is));
        }

        InfCleanUpInfStruct (&is);

        return ERROR_SUCCESS;

    }

    return 0;
}


VOID
pAppendIniFiles (
    IN      HINF Inf,
    IN      PCTSTR Section,
    IN      PCTSTR MemDbCategory
    )

/*++

Routine Description:

  pAppendIniFiles reads from the specified INF from given section and appends
  INI patterns to the multisz list IniFiles.

Arguments:

  Inf - Specifies the source INF handle

  Section  - Specifies the section in that INF

  MemDbCategory - Specifies the category in which to store INI patterns from that section

Return Value:

  none

--*/

{
    INFCONTEXT ctx;
    TCHAR Field[MEMDB_MAX];
    TCHAR IniPattern[MAX_PATH];
    PTSTR IniPath;

    if (SetupFindFirstLine (Inf, Section, NULL, &ctx)) {
        do {
            //
            // INI file name is in the first value
            //
            if (SetupGetStringField (&ctx, 1, Field, MEMDB_MAX, NULL) && Field[0]) {
                //
                // now convert env vars
                //
                if (ExpandEnvironmentStrings (Field, IniPattern, MAX_PATH) > MAX_PATH) {
                    DEBUGMSG ((
                        DBG_ERROR,
                        "pAppendIniFiles: Invalid INI dir name in wkstamig.inf section [%s]; name too long",
                        Section
                        ));
                    MYASSERT (FALSE);
                    continue;
                }
                IniPath = IniPattern;
                //
                // to speed up things while scanning file system, only check filenames
                // with extension .INI; that means this section should only contain
                // filenames with .INI extension (if a file with a different extension
                // is needed, GatherIniFiles needs to be modified together
                // with this function, i.e. to create here a list of extensions to be
                // searched for)
                //
                MYASSERT (StringIMatch(GetDotExtensionFromPath (IniPattern), TEXT(".INI")));
                //
                // check for empty directory name
                //
                if (!_tcschr (IniPattern, TEXT('\\'))) {
                    //
                    // no dir name provided, assume %windir%
                    // reuse Field
                    //
                    StringCopy (Field, g_WinDir);
                    //
                    // construct new path
                    //
                    StringCopy (AppendWack (Field), IniPattern);
                    IniPath = Field;
                }
                //
                // append filename to provided grow buffer
                //
                MemDbSetValueEx (MemDbCategory, IniPath, NULL, NULL, 0, NULL);
            }
        } while (SetupFindNextLine (&ctx, &ctx));
    }
}


BOOL
pCreateIniCategories (
    )

/*++

Routine Description:

  pCreateIniCategories appends to multisz buffers that will
  hold the patterns of INI files on which actions will be later performed on NT.

Arguments:

  none

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    HINF WkstaMigInf = INVALID_HANDLE_VALUE;
    PTSTR wkstaMigSource = NULL;
    PTSTR wkstaMigTarget = NULL;
    DWORD result;
    BOOL b = FALSE;

    __try {
        wkstaMigSource = JoinPaths (SOURCEDIRECTORY(0), S_WKSTAMIG_INF);
        wkstaMigTarget = JoinPaths (g_TempDir, S_WKSTAMIG_INF);
        result = SetupDecompressOrCopyFile (wkstaMigSource, wkstaMigTarget, 0);
        if ((result != ERROR_SUCCESS) && (result != ERROR_ALREADY_EXISTS)) {
            LOG ((LOG_ERROR, "INI ACTIONS: Unable to decompress %s", wkstaMigSource));
            __leave;
        }

        WkstaMigInf = InfOpenInfFile (wkstaMigTarget);
        if (WkstaMigInf == INVALID_HANDLE_VALUE) {
            LOG ((LOG_ERROR, "INI ACTIONS: %s could not be opened", wkstaMigTarget));
            __leave;
        }

        pAppendIniFiles (WkstaMigInf, S_INIFILES_ACTIONS_FIRST, MEMDB_CATEGORY_INIFILES_ACT_FIRST);
        pAppendIniFiles (WkstaMigInf, S_INIFILES_ACTIONS_LAST, MEMDB_CATEGORY_INIFILES_ACT_LAST);

        b = TRUE;
    }
    __finally {
        result = GetLastError ();
        if (WkstaMigInf != INVALID_HANDLE_VALUE) {
            InfCloseInfFile (WkstaMigInf);
        }
        if (wkstaMigTarget) {
            DeleteFile (wkstaMigTarget);
            FreePathString (wkstaMigTarget);
        }
        if (wkstaMigSource) {
            FreePathString (wkstaMigSource);
        }
        SetLastError (result);
    }

    return b;
}


DWORD
InitIniProcessing (
    IN DWORD    Request
    )
{
    switch (Request) {

    case REQUEST_QUERYTICKS:

        return TICKS_INITINIPROCESSING;

    case REQUEST_RUN:

        if (!pCreateIniCategories ()) {
            return GetLastError ();
        }

        return ERROR_SUCCESS;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\sysmig\oleregp.h ===
//
// Structures for GUID search code
//

#define GUIDKEYSEARCH_FIRST_HANDLER     0       // the first time through enumeration

#define GUIDKEYSEARCH_FIRST_GUID        1       // ready to enumerate the first GUID in the handler

#define GUIDKEYSEARCH_NEXT_GUID         2       // enumerating one or more GUIDs in a handler
                                                // The handler registry key is always valid in this case

#define GUIDKEYSEARCH_NEXT_HANDLER      3       // ready to enumerate next handler

typedef struct {
    LPCTSTR KeyName;
    REGKEY_ENUM Handlers;
    REGKEY_ENUM Guids;
    HKEY HandlerKey;
    DWORD State;
    HKEY RootKey;
} GUIDKEYSEARCH, *PGUIDKEYSEARCH;


//
// Private routines to perform registry suppression
//

BOOL
pIsGuidSuppressed (
    PCTSTR GuidStr
    );

BOOL
pProcessGuidSuppressList (
    VOID
    );

BOOL
pProcessFileExtensionSuppression (
    VOID
    );

BOOL
pProcessOleWarnings (
    VOID
    );

VOID
pProcessAutoSuppress (
    IN OUT  HASHTABLE StrTab
    );

BOOL
pProcessProgIdSuppression (
    VOID
    );

BOOL
pProcessExplorerSuppression (
    VOID
    );

BOOL
pSuppressLinksToSuppressedGuids (
    VOID
    );


BOOL
pIsCmdLineBad (
    IN      LPCTSTR CmdLine
    );

BOOL
pIsCmdLineBadEx (
    IN      LPCTSTR CmdLine,
    OUT     PBOOL IsvCmdLine        OPTIONAL
    );


VOID
pSuppressProgIdWithBadCmdLine (
    IN      HKEY ProgId,
    IN      LPCTSTR ProgIdStr
    );

BOOL
pIsGuid (
    LPCTSTR Key
    );

BOOL
pIsGuidWithoutBraces (
    IN      LPCTSTR Data
    );


BOOL
pGetFirstRegKeyThatHasGuid (
    OUT     PGUIDKEYSEARCH EnumPtr,
    IN      HKEY RootKey
    );

BOOL
pGetNextRegKeyThatHasGuid (
    IN OUT  PGUIDKEYSEARCH EnumPtr
    );

DWORD
pCountGuids (
    IN      PGUIDKEYSEARCH EnumPtr
    );


BOOL
pFillHashTableWithKeyNames (
    OUT     HASHTABLE Table,
    IN      HINF InfFile,
    IN      LPCTSTR Section
    );

BOOL
pSuppressProgId (
    LPCTSTR ProgIdName
    );

VOID
pSuppressGuidInClsId (
    IN      LPCTSTR Guid
    );

VOID
pAddUnsuppressedTreatAsGuid (
    LPCTSTR Guid,
    LPCTSTR TreatAsGuid
    );

VOID
pRemoveUnsuppressedTreatAsGuids (
    VOID
    );

VOID
pAddOleWarning (
    IN      WORD MsgId,
    IN      HKEY Object,            OPTIONAL
    IN      LPCTSTR KeyName
    );

VOID
pSuppressGuidIfBadCmdLine (
    IN      HASHTABLE StrTab,
    IN      HKEY ClsIdKey,
    IN      LPCTSTR GuidStr
    );

VOID
pSuppressProgIdWithBadCmdLine (
    IN      HKEY ProgId,
    IN      LPCTSTR ProgIdStr
    );

BOOL
pSuppressGuidIfCmdLineBad (
    IN OUT  HASHTABLE StrTab,       OPTIONAL
    IN      LPCTSTR CmdLine,
    IN      HKEY DescriptionKey,
    IN      LPCTSTR GuidStr         OPTIONAL
    );

VOID
pAddGuidToTable (
    IN      HASHTABLE Table,
    IN      LPCTSTR GuidStr
    );

BOOL
pSearchSubkeyDataForBadFiles (
    IN OUT  HASHTABLE SuppressTable,
    IN      HKEY KeyHandle,
    IN      LPCTSTR LastKey,
    IN      LPCTSTR GuidStr,
    IN      HKEY DescriptionKey
    );

BOOL
pIsCmdLineBad (
    IN      LPCTSTR CmdLine
    );

BOOL
pFindShortName (
    IN      LPCTSTR WhatToFind,
    OUT     LPTSTR Buffer
    );

BOOL
pGetLongPathName (
    IN      LPCTSTR ShortPath,
    OUT     LPTSTR Buffer
    );

BOOL
pDefaultIconPreservation (
    VOID
    );

BOOL
pActiveSetupProcessing (
    VOID
    );

BOOL
pIsShellExKeySuppressed (
    IN      HKEY ParentKey,
    IN      PCTSTR ParentKeyName,
    IN      PCTSTR SubKeyName
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\sysmig\sysmigp.h ===
//
// sysmigp.h - private prototypes
//
#define DBG_SYSMIG "SysMig"

extern PCTSTR g_UserProfileRoot;

//
// shares.c
//

DWORD
SaveShares (
    IN      DWORD Request
    );



//
// olereg.c
//

DWORD
SuppressOleGuids (
    IN      DWORD Request
    );

//
// condmsg.c
//


DWORD
ConditionalIncompatibilities(
    IN      DWORD Request
    );

DWORD
HardwareProfileWarning (
    IN      DWORD Request
    );

DWORD
UnsupportedProtocolsWarning (
    IN      DWORD Request
    );

DWORD
SaveMMSettings_User (
    DWORD Request,
    PUSERENUM EnumPtr
    );

DWORD
SaveMMSettings_System (
    IN      DWORD Request
    );

DWORD
BadNamesWarning (
    IN      DWORD Request
    );


VOID
MsgSettingsIncomplete (
    IN      PCTSTR UserDatPath,
    IN      PCTSTR UserName,
    IN      BOOL CompletelyBusted
    );


VOID
InitGlobalPaths (
    VOID
    );

BOOL
AddShellFolder (
    PCTSTR ValueName,
    PCTSTR FolderName
    );


//
// userenum.c
//

typedef struct {
    PCTSTR sfName;
    PCTSTR sfPath;
    HKEY SfKey;
    REGVALUE_ENUM SfKeyEnum;
    PUSERENUM EnumPtr;
    BOOL FirstCall;
    BOOL VirtualSF;
    BOOL ProfileSF;
    BOOL sfCollapse;
    INFCONTEXT Context;
    HASHTABLE enumeratedSf;
} SF_ENUM, *PSF_ENUM;

BOOL
EnumFirstRegShellFolder (
    IN OUT  PSF_ENUM e,
    IN      PUSERENUM EnumPtr
    );

BOOL
EnumNextRegShellFolder (
    IN OUT  PSF_ENUM e
    );

BOOL
EnumAbortRegShellFolder (
    IN OUT  PSF_ENUM e
    );



//
// userloop.c
//

VOID
TerminateCacheFolderTracking (
    VOID
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\sysmig\userloop.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  userloop.c

Abstract:

  This module implements a user loop that performs two fundamental operations:

    1. Queue up instructions for user shell folder migration
    2. Queue up instructions for registry migration

  The user loop also calls SysMig_MigrateUser, so special per-user code can be
  added easily.

Author:

    Calin Negreanu (calinn)     15-Aug-1998     (complete redesign)

Revision History:

    Ovidiu Temereanca (ovidiut) 18-May-1999     (support for shell folders as migration dirs)

--*/

#include "pch.h"
#include "sysmigp.h"
#include "merge.h"

#define DBG_USERLOOP "User Loop"


#define SHELL_FOLDER_FILTERS                                \
    DEFMAC(pSendToFilter)                                   \
    DEFMAC(pDirRenameFilter)                                \
    DEFMAC(pRecordCacheFolders)                             \


typedef enum {
    GLOBAL_INITIALIZE,
    PER_FOLDER_INITIALIZE,
    PROCESS_PATH,
    PER_FOLDER_TERMINATE,
    GLOBAL_TERMINATE
} CALL_CONTEXT;


#define SHELLFILTER_OK              0
#define SHELLFILTER_SKIP_FILE       1
#define SHELLFILTER_SKIP_DIRECTORY  2

#define MAX_SHELLFOLDER_NAME        64

typedef struct {
    IN      PCTSTR FixedUserName;                   OPTIONAL
    IN      PCTSTR ShellFolderIdentifier;
    IN OUT  TCHAR TempSourcePath[MEMDB_MAX];
    IN OUT  TCHAR DestinationPath[MEMDB_MAX];
    IN      PCTSTR SrcRootPath;
    IN      PCTSTR DestRootPath;
    IN OUT  DWORD Attributes;
    IN OUT  DWORD State;
    IN      CALL_CONTEXT Context;
} PROFILE_MERGE_DATA, *PPROFILE_MERGE_DATA;

typedef DWORD(PROFILEMERGEFILTER_PROTOTYPE)(IN OUT PPROFILE_MERGE_DATA Data);
typedef PROFILEMERGEFILTER_PROTOTYPE * PROFILEMERGEFILTER;

typedef struct {
    PROFILEMERGEFILTER Fn;
    DWORD State;
} SHELL_FOLDER_FILTER, *PSHELL_FOLDER_FILTER;


#define DEFMAC(fn)      PROFILEMERGEFILTER_PROTOTYPE fn;

SHELL_FOLDER_FILTERS

#undef DEFMAC



#define DEFMAC(fn)      {fn},

static SHELL_FOLDER_FILTER g_Filters[] = {
    SHELL_FOLDER_FILTERS /* , */
    {NULL}
};

#undef DEFMAC



#define MAP_FLAG_EXPAND             0x0001
#define MAP_PARENT_FIELD            0x0002
#define MAP_ARG_MUST_BE_ONE         0x0004
#define MAP_ARG_MUST_BE_ZERO        0x0008
#define MAP_RECORD_IN_MEMDB         0x0010
#define MAP_REVERSE                 0x0020
#define MAP_FLAG_NONE               0

typedef enum {
    DEFAULT_COMMON          = 0x0001,
    DEFAULT_PER_USER        = 0x0002,
    DEFAULT_ALT_COMMON      = 0x0010,
    DEFAULT_ALT_PER_USER    = 0x0020
} WHICHDEFAULT;

#define ANY_COMMON      (DEFAULT_COMMON|DEFAULT_ALT_COMMON)
#define ANY_PER_USER    (DEFAULT_PER_USER|DEFAULT_ALT_PER_USER)
#define ANY_DEFAULT     (ANY_COMMON|ANY_PER_USER)

#define SFSTRUCT(e) ((PSHELLFOLDER) e.dwValue)

typedef struct _SHELLFOLDER {
    PCTSTR Name;
    PCTSTR FixedUserName;
    PCTSTR UserName;
    PCTSTR SrcPath;
    PCTSTR DestPath;
    PCTSTR TempPath;
    BOOL CanBeCollapsed;
    BOOL MergedIntoOtherShellFolder;
    BOOL SourceExists;
    struct _SHELLFOLDER *Next;
}  SHELLFOLDER, *PSHELLFOLDER;


PSHELLFOLDER g_ShellFolders = NULL;
POOLHANDLE g_SFPool = NULL;
PCTSTR g_UserProfileRoot;
UINT g_SfSequencer = 0;
DWORD g_TotalUsers = 0;
HASHTABLE g_SkippedTable;
HASHTABLE g_MassiveDirTable;
HASHTABLE g_PreservedSfTable;
HASHTABLE g_DirRenameTable;
HASHTABLE g_CollapseRestrictions;
PMAPSTRUCT g_ShortNameMap;
PMAPSTRUCT g_SfRenameMap;
PMAPSTRUCT g_DefaultDirMap;
PMAPSTRUCT g_AlternateCommonDirMap;
PMAPSTRUCT g_AlternatePerUserDirMap;
PMAPSTRUCT g_DefaultShortDirMap;
PMAPSTRUCT g_CommonFromPerUserMap;
PMAPSTRUCT g_PerUserFromCommonMap;
GROWLIST g_CollisionPriorityList;
PMAPSTRUCT g_CacheShellFolders;         // used by the HTML file edit helper in migapp\helpers.c

BOOL
pIsPerUserWanted (
    IN      PCTSTR ShellFolderTag
    );


VOID
MsgSettingsIncomplete (
    IN      PCTSTR UserDatPath,
    IN      PCTSTR UserName,
    IN      BOOL CompletelyBusted
    )

/*++

Routine Description:

  MsgSettingsIncomplete adds a message to the incompatibility
  report when a user is found that cannot be migrated.

Arguments:

  UserDatPath - Specifies the location of the invalid user's registry

  UserName - Specifies the name of the bad user

  CompletelyBusted - Specifies TRUE if the bad user cannot be migrated at
                     all, or FALSE if only their shell settings are damaged.

Return Value:

  none

--*/

{
    PCTSTR MsgGroup = NULL;
    PCTSTR SubGroup = NULL;
    PCTSTR RootGroup = NULL;
    PCTSTR tempRoot = NULL;
    PCTSTR NoUserName = NULL;

    MYASSERT(UserDatPath);

    //
    // Sanitize user name
    //

    __try {
        NoUserName = GetStringResource (MSG_REG_SETTINGS_EMPTY_USER);
        RootGroup = GetStringResource (MSG_INSTALL_NOTES_ROOT);
        SubGroup  = GetStringResource (CompletelyBusted ?
                                            MSG_REG_SETTINGS_SUBGROUP :
                                            MSG_SHELL_SETTINGS_SUBGROUP
                                       );
        if (!NoUserName || !RootGroup || !SubGroup) {
            MYASSERT (FALSE);
            __leave;
        }

        if (!UserName || !UserName[0]) {
            UserName = NoUserName;
        }

        //
        // Build Install Notes\User Accounts\User Name
        //

        tempRoot = JoinPaths (RootGroup, SubGroup);
        MsgGroup = JoinPaths (tempRoot, UserName);
        FreePathString (tempRoot);

        //
        // Send message to report, and turn off all other messages for the user
        // account.
        //
        MsgMgr_ObjectMsg_Add (UserDatPath, MsgGroup, S_EMPTY);

        HandleObject (UserName, TEXT("UserName"));
    }
    __finally {
        //
        // Clean up
        //
        FreeStringResource (NoUserName);
        FreeStringResource (RootGroup);
        FreeStringResource (SubGroup);
        FreePathString (MsgGroup);
    }
}


HASHTABLE
pCreateSfList (
    IN      PCTSTR SectionName,
    IN      BOOL ExpandEnvVars
    )
{
    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;
    PCTSTR unexpandedData;
    TCHAR expandedPath[MEMDB_MAX];
    HASHTABLE Table;

    Table = HtAlloc();

    //
    // Load the entire INF section and copy it to the string table
    //

    if (InfFindFirstLine (g_Win95UpgInf, SectionName, NULL, &is)) {
        do {
            unexpandedData = InfGetStringField (&is, 1);

            if (unexpandedData) {

                //
                // Expand the data only if the user wants it to be expanded
                //

                if (ExpandEnvVars) {
                    ExpandNtEnvironmentVariables (unexpandedData, expandedPath, sizeof (expandedPath));
                    HtAddString (Table, expandedPath);
                } else {
                    HtAddString (Table, unexpandedData);
                }
            }

        } while (InfFindNextLine (&is));
    }

    InfCleanUpInfStruct (&is);

    return Table;
}


VOID
pDestroySfList (
    IN      HASHTABLE Table
    )
{
    HtFree (Table);
}

BOOL
pCreateDirRenameTable (
    VOID
    )
{
    INFSTRUCT is = INITINFSTRUCT_POOLHANDLE;
    PCTSTR sfId, sfWhere, sfPath9x, sfPathNt;
    PCTSTR tempPath1, tempPath2, NtPath;

    g_DirRenameTable = HtAllocWithData (sizeof (PCTSTR));

    if (InfFindFirstLine (g_Win95UpgInf, S_DIRRENAMESECT, NULL, &is)) {
        do {
            sfId = InfGetStringField (&is, 1);
            sfWhere = InfGetStringField (&is, 2);
            sfPath9x = InfGetStringField (&is, 3);
            sfPathNt = InfGetStringField (&is, 4);
            if (sfId && sfWhere && sfPath9x && sfPathNt) {
                tempPath1 = JoinPaths (sfId, sfWhere);
                tempPath2 = JoinPaths (tempPath1, sfPath9x);
                NtPath = PoolMemDuplicateString (g_SFPool, sfPathNt);

                HtAddStringAndData (g_DirRenameTable, tempPath2, &NtPath);

                FreePathString (tempPath2);
                FreePathString (tempPath1);
            }
            InfResetInfStruct (&is);
        } while (InfFindNextLine (&is));
    }

    InfCleanUpInfStruct (&is);

    return TRUE;
}


VOID
pCreateSfMapWorker (
    IN      DWORD MapFlags,
    IN OUT  PMAPSTRUCT Map,
    IN      PINFSTRUCT InfStruct,
    IN      UINT ReplaceField
    )
{
    PCTSTR searchStr;
    PCTSTR replaceStr;
    TCHAR expandedReplaceStr[MEMDB_MAX];
    TCHAR replaceRootPath[MAX_TCHAR_PATH];
    PCTSTR replaceRoot = NULL;
    PCTSTR fullReplaceStr = NULL;
    PCTSTR fieldData;
    DWORD offset1;
    DWORD offset2;

    if (MapFlags & MAP_ARG_MUST_BE_ZERO) {
        //
        // Screen out entries that don't have zero in ReplaceField + 1
        //

        fieldData = InfGetStringField (InfStruct, ReplaceField + 1);
        if (fieldData && _ttoi (fieldData)) {
            return;
        }
    }

    if (MapFlags & MAP_ARG_MUST_BE_ONE) {
        //
        // Screen out entries that don't have one in ReplaceField + 1
        //

        fieldData = InfGetStringField (InfStruct, ReplaceField + 1);
        if (!fieldData || (_ttoi (fieldData) != 1)) {
            return;
        }
    }

    if (MapFlags & MAP_PARENT_FIELD) {
        //
        // Check (replace field - 1) and if it is not empty, get the parent
        //

        MYASSERT (g_DefaultDirMap);

        replaceRoot = InfGetStringField (InfStruct, ReplaceField - 1);

        if (replaceRoot && *replaceRoot) {

            StringCopy (replaceRootPath, replaceRoot);
            replaceRoot = replaceRootPath;

            if (!MappingSearchAndReplace (Map, replaceRootPath, sizeof (replaceRootPath))) {
                if (!MappingSearchAndReplace (g_DefaultDirMap, replaceRootPath, sizeof (replaceRootPath))) {
                    replaceRoot = NULL;
                }
            }

        } else {
            replaceRoot = NULL;
        }
    }

    //
    // Add search/replace string pair to map
    //

    searchStr = InfGetStringField (InfStruct, 0);
    replaceStr = InfGetStringField (InfStruct, ReplaceField);
    if (!replaceStr) {
        replaceStr = TEXT("");
    }

    if (MapFlags & MAP_FLAG_EXPAND) {
        if (ExpandNtEnvironmentVariables (replaceStr, expandedReplaceStr, sizeof (expandedReplaceStr))) {
            replaceStr = expandedReplaceStr;
        }
    }

    if (replaceRoot) {
        fullReplaceStr = JoinPaths (replaceRoot, replaceStr);
        replaceStr = fullReplaceStr;
    }

    if (MapFlags & MAP_REVERSE) {
        AddStringMappingPair (Map, replaceStr, searchStr);
    } else {
        AddStringMappingPair (Map, searchStr, replaceStr);
    }

    if (MapFlags & MAP_RECORD_IN_MEMDB) {
        MYASSERT (!(MapFlags & MAP_REVERSE));

        MemDbSetValueEx (
            MEMDB_CATEGORY_SF_COMMON,
            replaceStr,
            NULL,
            NULL,
            0,
            &offset1
            );

        MemDbSetValueEx (
            MEMDB_CATEGORY_SF_PERUSER,
            searchStr,
            NULL,
            NULL,
            offset1,
            &offset2
            );

        // knowing implementation of memdb, this will not change offset1
        MemDbSetValueEx (
            MEMDB_CATEGORY_SF_COMMON,
            replaceStr,
            NULL,
            NULL,
            offset2,
            NULL
            );
    }

    FreePathString (fullReplaceStr);
}


PMAPSTRUCT
pCreateSfMap (
    IN      PCTSTR SectionName,
    IN      UINT ReplaceField,
    IN      DWORD MapFlags
    )
{
    INFSTRUCT is = INITINFSTRUCT_POOLHANDLE;
    PMAPSTRUCT Map;
    TCHAR versionSectionName[256];

    Map = CreateStringMapping();
    if (!Map) {
        return NULL;
    }

    //
    // Load the entire INF section and add the mapping for each line
    //

    if (InfFindFirstLine (g_Win95UpgInf, SectionName, NULL, &is)) {
        do {
            pCreateSfMapWorker (MapFlags, Map, &is, ReplaceField);
        } while (InfFindNextLine (&is));
    }

    //
    // ... and for the specific Win9x Version
    //

    versionSectionName[0] = 0;

    if (ISWIN95_GOLDEN()) {
        wsprintf (versionSectionName, TEXT("%s.Win95"), SectionName);
    } else if (ISWIN95_OSR2()) {
        wsprintf (versionSectionName, TEXT("%s.Win95Osr2"), SectionName);
    } else if (ISMEMPHIS()) {
        wsprintf (versionSectionName, TEXT("%s.Win98"), SectionName);
    } else if (ISMILLENNIUM()) {
        wsprintf (versionSectionName, TEXT("%s.Me"), SectionName);
    }

    if (versionSectionName[0] &&
        InfFindFirstLine (g_Win95UpgInf, versionSectionName, NULL, &is)
        ) {
        do {
            pCreateSfMapWorker (MapFlags, Map, &is, ReplaceField);
        } while (InfFindNextLine (&is));
    }

    InfCleanUpInfStruct (&is);

    return Map;
}


VOID
pDestroySfMap (
    IN      PMAPSTRUCT Map
    )
{
    DestroyStringMapping (Map);
}


VOID
pCreatePriorityList (
    VOID
    )
{
    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;
    PCTSTR data;

    if (InfFindFirstLine (g_Win95UpgInf, S_SHELL_FOLDER_PRIORITY, NULL, &is)) {
        do {
            data = InfGetStringField (&is, 1);
            if (data && *data) {
                GrowListAppendString (&g_CollisionPriorityList, data);
            }
        } while (InfFindNextLine (&is));
    }

    InfCleanUpInfStruct (&is);
}


BOOL
pTestRule (
    IN      PINFSTRUCT InfStruct,
    OUT     PBOOL TestResult
    )
{
    PCTSTR keyStr;
    PCTSTR valueName;
    PCTSTR test;
    PBYTE valueData = NULL;
    DWORD dataSize;
    DWORD dataType;
    HKEY key = NULL;
    BOOL not = FALSE;

    *TestResult = FALSE;

    //
    // Get instructions from INF
    //

    keyStr = InfGetStringField (InfStruct, 1);
    if (!keyStr || *keyStr == 0) {
        DEBUGMSG ((DBG_WHOOPS, "Missing Key field in ShellFolders.ConditionalPreserve"));
        return FALSE;
    }

    valueName = InfGetStringField (InfStruct, 2);
    if (!valueName) {
        DEBUGMSG ((DBG_WHOOPS, "Missing ValueName field in ShellFolders.ConditionalPreserve"));
        return FALSE;
    }

    test = InfGetStringField (InfStruct, 3);
    if (!test || *test == 0) {
        DEBUGMSG ((DBG_WHOOPS, "Missing Test field in ShellFolders.ConditionalPreserve"));
        return FALSE;
    }

    //
    // Execute instructions
    //

    __try {
        //
        // Process NOT arg
        //

        MYASSERT (test && *test);

        if (test[0] == TEXT('!')) {
            not = TRUE;
            test++;
        }

        //
        // Fetch registry data
        //

        MYASSERT (keyStr && *keyStr);

        key = OpenRegKeyStr (keyStr);
        if (!key) {
            DEBUGMSG ((DBG_VERBOSE, "%s does not exist", keyStr));
            __leave;
        }

        MYASSERT (valueName);

        if (!StringIMatch (test, TEXT("KEY"))) {
            valueData = GetRegValueData (key, valueName);

            if (!valueData) {
                DEBUGMSG ((DBG_VERBOSE, "%s [%s] does not exist", keyStr, valueName));
                __leave;
            }

            if (!GetRegValueTypeAndSize (key, valueName, &dataType, &dataSize)) {
                DEBUGMSG ((DBG_ERROR, "Failed to get type/size of %s [%s]", keyStr, valueName));
                __leave;
            }
        }

        //
        // Perform tests
        //

        if (StringIMatch (test, TEXT("KEY"))) {
            *TestResult = TRUE;
        } else if (StringIMatch (test, TEXT("VALUE"))) {
            if (valueData) {
                *TestResult = TRUE;
            }
        } else if (StringIMatch (test, TEXT("PATH"))) {
            if (valueData && (dataType == REG_SZ || dataType == REG_NONE)) {
                //
                // Registry wrapper apis make sure the string is nul terminated
                //

                *TestResult = DoesFileExist ((PCTSTR) valueData);
            }
        } else {
            DEBUGMSG ((DBG_WHOOPS, "Unexpected rule in ShellFolders.ConditionalPreserve: '%s'", test));
        }
    }
    __finally {
        if (key) {
            CloseRegKey (key);
        }

        if (valueData) {
            FreeMem (valueData);
        }
    }

    if (not) {
        *TestResult = !(*TestResult);
    }

    return TRUE;
}

BOOL
pTestRuleOrSection (
    IN      HINF Inf,
    IN      PINFSTRUCT InfStruct,
    OUT     PUINT ShellFolderField,
    OUT     PBOOL TestResult
    )
{
    INFSTRUCT sectionInfStruct = INITINFSTRUCT_POOLHANDLE;
    PCTSTR field1;
    PCTSTR decoratedSection;
    TCHAR number[32];
    UINT u;
    BOOL processed = FALSE;
    BOOL result = FALSE;
    BOOL foundSection;

    *TestResult = FALSE;
    *ShellFolderField = 2;      // start with assumption line is in <section>,<shellfolder> format

    field1 = InfGetStringField (InfStruct, 1);
    if (!field1 || *field1 == 0) {
        DEBUGMSG ((DBG_WHOOPS, "Empty field 1 in ShellFolders.ConditionalPreserve"));
        return FALSE;
    }

    __try {
        //
        // Test this field for an AND section
        //

        for (u = 1, foundSection = TRUE ; foundSection ; u++) {

            wsprintf (number, TEXT(".%u"), u);
            decoratedSection = JoinText (field1, number);

            if (InfFindFirstLine (Inf, decoratedSection, NULL, &sectionInfStruct)) {

                //
                // flag that this is processed, and reset the test result for the
                // next section (which we just found)
                //

                processed = TRUE;
                *TestResult = FALSE;

                //
                // locate the first line that is true
                //

                do {
                    if (!pTestRule (&sectionInfStruct, TestResult)) {
                        __leave;
                    }

                    if (*TestResult) {
                        break;
                    }
                } while (InfFindNextLine (&sectionInfStruct));

            } else {
                foundSection = FALSE;
            }

            FreeText (decoratedSection);
        }

        //
        // Test this field for an OR section
        //

        if (!processed) {
            if (InfFindFirstLine (Inf, field1, NULL, &sectionInfStruct)) {

                processed = TRUE;

                //
                // locate the first line that is true
                //

                do {
                    if (!pTestRule (&sectionInfStruct, TestResult)) {
                        __leave;
                    }

                    if (*TestResult) {
                        break;
                    }
                } while (InfFindNextLine (&sectionInfStruct));
            }
        }

        //
        // Finally process the line if it is not an AND or OR section
        //

        if (!processed) {
            *ShellFolderField = 4;      // line is in <key>,<value>,<test>,<shellfolder> format
            if (!pTestRule (&sectionInfStruct, TestResult)) {
                __leave;
            }
        }

        result = TRUE;
    }
    __finally {
        InfCleanUpInfStruct (&sectionInfStruct);
    }

    return result;
}

BOOL
pPopulateConditionalPreserveTable (
    IN      HASHTABLE Table
    )
{
    INFSTRUCT is = INITINFSTRUCT_POOLHANDLE;
    UINT tagField;
    PCTSTR multiSz;
    MULTISZ_ENUM e;
    BOOL testResult;
    BOOL result = FALSE;

    __try {
        if (InfFindFirstLine (g_Win95UpgInf, TEXT("ShellFolders.ConditionalPreserve"), NULL, &is)) {
            do {

                if (!pTestRuleOrSection (g_Win95UpgInf, &is, &tagField, &testResult)) {
                    __leave;
                }

                if (!testResult) {
                    continue;
                }

                //
                // Add multi-sz of tags to preserve table
                //

                multiSz = InfGetMultiSzField (&is, tagField);

                if (!multiSz) {
                    DEBUGMSG ((DBG_WHOOPS, "ShellFolders.ConditionalPreserve line is missing shell folder tags"));
                } else {
                    if (EnumFirstMultiSz (&e, multiSz)) {
                        do {
                            DEBUGMSG ((DBG_VERBOSE, "Dynamically preserving %s", e.CurrentString));
                            HtAddString (Table, e.CurrentString);
                        } while (EnumNextMultiSz (&e));
                    }
                }

            } while (InfFindNextLine (&is));
        }

        result = TRUE;
    }
    __finally {
        InfCleanUpInfStruct (&is);
    }

    return result;
}



BOOL
pCreateSfTables (
    VOID
    )
{
    g_SkippedTable            = pCreateSfList (S_SHELL_FOLDERS_SKIPPED, FALSE);
    g_PreservedSfTable        = pCreateSfList (S_SHELL_FOLDERS_PRESERVED, FALSE);
    g_MassiveDirTable         = pCreateSfList (S_SHELL_FOLDERS_MASSIVE, TRUE);
    g_CollapseRestrictions    = pCreateSfList (S_SHELL_FOLDERS_DONT_COLLAPSE, FALSE);

    if (!pPopulateConditionalPreserveTable (g_PreservedSfTable)) {
        LOG ((LOG_ERROR, "An INF syntax error in ShellFolders.ConditionalPreserve caused setup to fail"));
        return FALSE;
    }

    //
    // String maps are useful for in-place conversion of a string to another
    // string. We are about to establish maps for all INF-driven shell folder
    // data.
    //
    // The INF syntaxes defined for shell folders are the following:
    //
    // <search>=<replace>
    // <search>=<don't care>,<replace>
    // <search>=<parent>,<replace>,<arg>
    //
    // The second arg to pCreateSfMap specifies the <replace> string field.
    // The field before the replace string field is the <parent> field, if
    // MAP_PARENT_FIELD is specified. The field after the <replace> field is
    // the <arg> field, and is used with MAP_ARG_MUST_BE_ZERO or
    // MAP_ARG_MUST_BE_ONE.
    //
    // MAP_FLAG_NONE just creates a simple A to B string mapping.
    // MAP_FLAG_EXPAND causes NT environment expansion on the replace string.
    // MAP_ARG_MUST_BE_ZERO or MAP_ARG_MUST_BE_ONE restrict the map to entries
    // which have a 0 or 1 in the arg field, respectively.
    //

    g_ShortNameMap            = pCreateSfMap (S_SHELL_FOLDERS_SHORT, 1, MAP_FLAG_NONE);
    g_SfRenameMap             = pCreateSfMap (S_SHELL_FOLDERS_RENAMED, 1, MAP_FLAG_NONE);
    g_DefaultDirMap           = pCreateSfMap (S_SHELL_FOLDERS_DEFAULT, 1, MAP_FLAG_EXPAND);
    g_AlternateCommonDirMap   = pCreateSfMap (S_SHELL_FOLDERS_ALT_DEFAULT, 2, MAP_FLAG_EXPAND|MAP_PARENT_FIELD|MAP_ARG_MUST_BE_ZERO);
    g_AlternatePerUserDirMap  = pCreateSfMap (S_SHELL_FOLDERS_ALT_DEFAULT, 2, MAP_FLAG_EXPAND|MAP_PARENT_FIELD|MAP_ARG_MUST_BE_ONE);
    g_DefaultShortDirMap      = pCreateSfMap (S_SHELL_FOLDERS_DEFAULT, 2, MAP_FLAG_EXPAND);
    g_CommonFromPerUserMap    = pCreateSfMap (S_SHELL_FOLDERS_PERUSER_TO_COMMON, 1, MAP_RECORD_IN_MEMDB);
    g_PerUserFromCommonMap    = pCreateSfMap (S_SHELL_FOLDERS_PERUSER_TO_COMMON, 1, MAP_REVERSE);

    pCreatePriorityList ();

    return  g_SkippedTable &&
            g_PreservedSfTable &&
            g_MassiveDirTable &&
            g_CollapseRestrictions &&
            g_ShortNameMap &&
            g_SfRenameMap &&
            g_DefaultDirMap &&
            g_AlternateCommonDirMap &&
            g_AlternatePerUserDirMap &&
            g_CommonFromPerUserMap &&
            g_PerUserFromCommonMap &&
            g_DefaultShortDirMap;
}


VOID
pDestroySfTables (
    VOID
    )
{
    pDestroySfList (g_SkippedTable);
    pDestroySfList (g_PreservedSfTable);
    pDestroySfList (g_MassiveDirTable);
    pDestroySfList (g_CollapseRestrictions);
    pDestroySfMap (g_ShortNameMap);
    pDestroySfMap (g_SfRenameMap);
    pDestroySfMap (g_DefaultDirMap);
    pDestroySfMap (g_AlternateCommonDirMap);
    pDestroySfMap (g_AlternatePerUserDirMap);
    pDestroySfMap (g_CommonFromPerUserMap);
    pDestroySfMap (g_PerUserFromCommonMap);
    pDestroySfMap (g_DefaultShortDirMap);
    FreeGrowList (&g_CollisionPriorityList);
}


BOOL
pIsSkippedSf (
    IN      PCTSTR ShellFolderName
    )

/*++

Routine Description:

  pIsSkippedSf returns if a shell folder needs to be skipped from processing.

Arguments:

  ShellFolderName - Specifies the shell folder identifer to check

Return Value:

  TRUE if the shell folder needs to be skipped, FALSE otherwise

--*/

{
    return HtFindString (g_SkippedTable, ShellFolderName) != 0;
}


BOOL
pIsMassiveDir (
    IN      PCTSTR ShellFolderPath
    )

/*++

Routine Description:

  pIsMassiveDir returns if a certain path should not be moved to a temporary
  location during migration.  Usually this is the case for directories like
  %windir% or %windir%\system.

Arguments:

  ShellFolderPath - Specifies the path to check

Return Value:

  TRUE if the path should not be moved, FALSE otherwise

--*/

{
    return HtFindString (g_MassiveDirTable, ShellFolderPath) != 0;
}


BOOL
pIsPreservedSf (
    IN      PCTSTR ShellFolderName
    )

/*++

Routine Description:

  pIsPreservedSf returns if a shell folder location needs to be preserved.

Arguments:

  ShellFolderName - Specifies the shell folder identifer to check

Return Value:

  TRUE if the shell folder location needs to be preserved, FALSE otherwise

--*/

{
    return HtFindString (g_PreservedSfTable, ShellFolderName) != 0;
}


BOOL
pShortFileNames (
    VOID
    )

/*++

Routine Description:

  pShortFileNames returns TRUE if we are on a system that does not allow long file names.

Arguments:

  none

Return Value:

  TRUE if the system does not allow long file names, FALSE otherwise

--*/

{
    //
    // It is unclear how the OS decides to use short filenames for
    // shell folders.  Assuming this never is the case.
    //

    return FALSE;
}


PCTSTR
pGetShellFolderLongName (
    IN      PCTSTR ShortName
    )

/*++

Routine Description:

  pGetShellFolderLongName transforms a short format shell folder into
  the long format. The short format is only used on systems that don't
  allow long file names.

Arguments:

  ShortName - Specifies the shell folder short name.

Return Value:

  Shell folder long name.  Caller must free via FreePathString.

--*/

{
    TCHAR longName [MEMDB_MAX];

    if (pShortFileNames()) {
        StringCopy (longName, ShortName);
        MappingSearchAndReplace (g_ShortNameMap, longName, sizeof (longName));
    } else {
        longName[0] = 0;
    }

    return DuplicatePathString (longName[0] ? longName : ShortName, 0);
}


UINT
pGetShellFolderPriority (
    IN      PCTSTR ShellFolderName
    )
{
    PCTSTR *strArray;
    UINT arraySize;
    UINT u;

    strArray = GrowListGetStringPtrArray (&g_CollisionPriorityList);

    if (strArray) {
        arraySize = GrowListGetSize (&g_CollisionPriorityList);

        for (u = 0 ; u < arraySize ; u++) {
            if (StringIMatch (strArray[u], ShellFolderName)) {
                return u;
            }
        }
    }

    return 0xFFFFFFFF;
}


BOOL
pGetDefaultLocation (
    IN      PCTSTR ShellFolderName,
    OUT     PCTSTR *LocalizedFolderName,        OPTIONAL
    IN      WHICHDEFAULT WhichDefault
    )

/*++

Routine Description:

  pGetDefaultLocation returns the default location for a certain shell
  folder.

Arguments:

  ShellFolderName - specifies the shell folder identifer, which can be
                    a long identifier or a short identifier, depending
                    on the mode determined by pShortFileNames.

  LocalizedFolderName - receives the localized name of shell folder

  WhichDefault - specifies the default to return:
                    DEFAULT_PER_USER or DEFAULT_COMMON - the standard default
                        location, such as c:\windows\Start Menu
                    DEFAULT_ALT_COMMON - the alternate common default, defined
                        by [ShellFolders.AlternateDefault].
                    DEFAULT_ALT_PER_USER - the alternate per-user default,
                        defined by [ShellFolders.AlternateDefault].

Return Value:

  The default location for the shell folder. LocalizedFolderName points to a
  subpath, rooted from %windir% or the user's profile root, or it points to a
  full path (second character is a colon). Caller must free via
  FreePathString.

--*/

{
    TCHAR defaultPath[MEMDB_MAX];
    BOOL Result;

    StringCopy (defaultPath, ShellFolderName);

    switch (WhichDefault) {

    case DEFAULT_ALT_COMMON:
        Result = MappingSearchAndReplace (g_AlternateCommonDirMap, defaultPath, sizeof (defaultPath));
        break;

    case DEFAULT_ALT_PER_USER:
        Result = MappingSearchAndReplace (g_AlternatePerUserDirMap, defaultPath, sizeof (defaultPath));
        break;

    default:
        if (pShortFileNames()) {
            Result = MappingSearchAndReplace (g_DefaultShortDirMap, defaultPath, sizeof (defaultPath));
        } else {
            Result = MappingSearchAndReplace (g_DefaultDirMap, defaultPath, sizeof (defaultPath));
        }
        break;
    }

    if (LocalizedFolderName) {
        if (Result) {
            *LocalizedFolderName = DuplicatePathString (defaultPath, 0);
        } else {
            *LocalizedFolderName = NULL;
        }
    }

    return Result;
}


BOOL
pTestDefaultLocationWorker (
    IN      PCTSTR UserName,            OPTIONAL
    IN      PCTSTR FullPathOrSubDir,
    IN      PCTSTR PathToTest
    )
{
    TCHAR tempPath[MEMDB_MAX];
    PCTSTR defaultPath;

    //
    // Compute the full path. It might be specified, or if not, it is either
    // a subdir of %windir% or a subdir of %windir%\profiles\<username>.
    //

    if (FullPathOrSubDir[0] && FullPathOrSubDir[1] == TEXT(':')) {
        defaultPath = FullPathOrSubDir;
    } else {

        if (UserName) {
            wsprintf (tempPath, TEXT("%s\\%s"), g_WinDir, S_PROFILES);
            if (StringIMatch (PathToTest, tempPath)) {
                return TRUE;
            }

            AppendWack (tempPath);

            return StringIPrefix (PathToTest, tempPath);

        } else {
            if (FullPathOrSubDir[0]) {
                wsprintf (tempPath, TEXT("%s\\%s"), g_WinDir, FullPathOrSubDir);
            } else {
                wsprintf (tempPath, TEXT("%s"), g_WinDir);
            }
        }

        defaultPath = tempPath;
    }

    return StringIMatch (defaultPath, PathToTest);
}


BOOL
pIsTheDefaultLocation (
    IN      PCTSTR ShellFolderName,
    IN      PCTSTR ShellFolderPath,
    IN      PCTSTR UserName,            OPTIONAL
    IN      WHICHDEFAULT WhichDefault
    )

/*++

Routine Description:

  pIsTheDefaultLocation returns if a shell folder points to the default location.

Arguments:

  ShellFolderName - Specifies the shell folder identifier

  ShellFolderPath - Specifies the path to compare against the default

  UserName - Specifies the current user

  WhichDefault - Specifies the default location to test (typically
                 ANY_COMMON or ANY_PER_USER).

Return Value:

  TRUE if the shell folder points to the default location, FALSE otherwise.

--*/

{
    PCTSTR subDir = NULL;
    TCHAR fullPath[MEMDB_MAX];
    BOOL Result = FALSE;
    BOOL fullPathReturned;

    if (StringIMatch (ShellFolderName, S_SF_PROFILES) ||
        StringIMatch (ShellFolderName, S_SF_COMMON_PROFILES)
        ) {
        return TRUE;
    }

    __try {
        if (WhichDefault & DEFAULT_COMMON) {

            if (pGetDefaultLocation (ShellFolderName, &subDir, DEFAULT_COMMON)) {

                if (pTestDefaultLocationWorker (NULL, subDir, ShellFolderPath)) {
                    Result = TRUE;
                    __leave;
                }
            }
        }

        if (WhichDefault & DEFAULT_ALT_COMMON) {

            if (pGetDefaultLocation (ShellFolderName, &subDir, DEFAULT_ALT_COMMON)) {

                if (pTestDefaultLocationWorker (NULL, subDir, ShellFolderPath)) {
                    Result = TRUE;
                    __leave;
                }
            }
        }

        if (UserName) {
            if (WhichDefault & DEFAULT_PER_USER) {

                if (pGetDefaultLocation (ShellFolderName, &subDir, DEFAULT_PER_USER)) {

                    if (pTestDefaultLocationWorker (UserName, subDir, ShellFolderPath)) {
                        Result = TRUE;
                        __leave;
                    }
                }
            }

            if (WhichDefault & DEFAULT_ALT_PER_USER) {

                if (pGetDefaultLocation (ShellFolderName, &subDir, DEFAULT_ALT_PER_USER)) {

                    if (pTestDefaultLocationWorker (UserName, subDir, ShellFolderPath)) {
                        Result = TRUE;
                        __leave;
                    }
                }
            }
        }

        MYASSERT (!Result);
    }
    __finally {
        FreePathString (subDir);
    }

#ifdef DEBUG
    if (!Result) {
        if (WhichDefault == ANY_DEFAULT) {
            DEBUGMSG ((DBG_USERLOOP, "%s (%s) is not in any default location", ShellFolderPath, ShellFolderName));
        } else if (WhichDefault == ANY_PER_USER) {
            DEBUGMSG ((DBG_USERLOOP, "%s (%s) is not in any per-user location", ShellFolderPath, ShellFolderName));
        } else if (WhichDefault == ANY_COMMON) {
            DEBUGMSG ((DBG_USERLOOP, "%s (%s) is not in any common location", ShellFolderPath, ShellFolderName));
        } else {
            if (WhichDefault & DEFAULT_COMMON) {
                DEBUGMSG ((DBG_USERLOOP, "%s (%s) is not in default common location", ShellFolderPath, ShellFolderName));
            }
            if (WhichDefault & DEFAULT_ALT_COMMON) {
                DEBUGMSG ((DBG_USERLOOP, "%s (%s) is not in default alternate common location", ShellFolderPath, ShellFolderName));
            }
            if (WhichDefault & DEFAULT_PER_USER) {
                DEBUGMSG ((DBG_USERLOOP, "%s (%s) is not in default per-user location", ShellFolderPath, ShellFolderName));
            }
            if (WhichDefault & DEFAULT_ALT_PER_USER) {
                DEBUGMSG ((DBG_USERLOOP, "%s (%s) is not in default alternate per-user location", ShellFolderPath, ShellFolderName));
            }
        }
    }
#endif

    return Result;
}


PCTSTR
pGetNtName (
    IN      PCTSTR ShellFolderName
    )

/*++

Routine Description:

  pGetNtName returns the name of the shell folder used on NT.

Arguments:

  ShellFolderName - Specifies the Win9x shell folder identifier

Return Value:

  A pointer to the NT identifer.  The caller must free this value via
  FreePathString.

--*/

{
    TCHAR ntName[MEMDB_MAX];

    StringCopy (ntName, ShellFolderName);
    MappingSearchAndReplace (g_SfRenameMap, ntName, sizeof (ntName));

    return DuplicatePathString (ntName, 0);
}


BOOL
pIsNtShellFolder (
    IN      PCTSTR ShellFolderName,
    IN      BOOL PerUser,
    IN      BOOL IsNtName
    )

/*++

Routine Description:

  pIsNtShellFolder returns if a shell folder is also installed by NT.

Arguments:

  ShellFolderName - Specifies the NT shell folder identifier

  PerUser - Specifies TRUE if the shell folder is per-user, FALSE if it is
        common.

  IsNtName - Specifies TRUE if ShellFolderName is an NT name, FALSE if it is a
        Win9x name.

Return Value:

  TRUE if the shell folder is installed by NT, FALSE otherwise.

--*/

{
    INFCONTEXT context;
    PCTSTR ntName;
    BOOL result;

    if (IsNtName) {
        ntName = ShellFolderName;
    } else {
        ntName = pGetNtName (ShellFolderName);
    }

    result = SetupFindFirstLine (
                g_Win95UpgInf,
                PerUser?S_SHELL_FOLDERS_NTINSTALLED_USER:S_SHELL_FOLDERS_NTINSTALLED_COMMON,
                ntName,
                &context
                );

    if (ntName != ShellFolderName) {
        FreePathString (ntName);
    }

    return result;
}

BOOL
pIsPerUserWanted (
    IN      PCTSTR ShellFolderTag
    )
{
    return HtFindString (g_CollapseRestrictions, ShellFolderTag) != 0;
}


BOOL
pGetNtShellFolderPath (
    IN      PCTSTR ShellFolderName,
    IN      PCTSTR FixedUserName,
    OUT     PTSTR Buffer,
    IN      DWORD BufferSize
    )

/*++

Routine Description:

  pGetNtShellFolderPath returns the path where the shell folder is installed.

Arguments:

  ShellFolderName - Specifies the NT shell folder identifier

  Buffer - Receives the NT shell folder path

  BufferSize - Specifies the size of Buffer, in bytes

Return Value:

  TRUE if the shell folder identifier maps to a path, or FALSE if not.

--*/

{
    TCHAR node[MEMDB_MAX];
    PCTSTR ntName;
    BOOL result = FALSE;

    ntName = pGetNtName (ShellFolderName);

    __try {

        if (!pIsNtShellFolder (ntName, FixedUserName?TRUE:FALSE, TRUE)) {
            return FALSE;
        }

        wsprintf (node, TEXT("<%s>%s"), ntName, FixedUserName?FixedUserName:S_DOT_ALLUSERS);
        ExpandNtEnvironmentVariables (node, node, MEMDB_MAX);

        _tcssafecpy (Buffer, node, BufferSize / sizeof (TCHAR));

        result = TRUE;
    }
    __finally {
        FreePathString (ntName);
    }


    return result;
}


BOOL
pIsValidPath (
    PCTSTR Path
    )
{
    PCTSTR currPtr;

    if (!Path || !(*Path)) {
        return FALSE;
    }

    currPtr = Path;
    do {
        if ((*currPtr == TEXT(',')) ||
            (*currPtr == TEXT(';')) ||
            (*currPtr == TEXT('<')) ||
            (*currPtr == TEXT('>')) ||
            (*currPtr == TEXT('|')) ||
            (*currPtr == TEXT('?')) ||
            (*currPtr == TEXT('*'))
            ) {
            return FALSE;
        }
        currPtr = _tcsinc (currPtr);
    }
    while (*currPtr);
    return TRUE;
}

BOOL
pEnumProfileShellFolder (
    IN OUT  PSF_ENUM e
    )
{
    PCTSTR ProfilePath;
    PCTSTR enumPath;

    if (e->FirstCall) {

        e->sfName = DuplicatePathString (
                        e->EnumPtr ? S_SF_PROFILES : S_SF_COMMON_PROFILES,
                        0
                        );

        e->FirstCall = FALSE;

        ProfilePath = JoinPaths (g_WinDir, S_PROFILES);

        if (e->EnumPtr) {
            e->sfPath = JoinPaths (ProfilePath, e->EnumPtr->UserName);
            FreePathString (ProfilePath);
        } else {
            e->sfPath = ProfilePath;
        }

        //
        // if this folder exists, enumerate it, otherwise end the enum
        //

        if (((!e->EnumPtr) || (!e->EnumPtr->CommonProfilesEnabled)) && DoesFileExist (e->sfPath)) {
            enumPath = PoolMemDuplicateString (g_SFPool, e->sfPath);
            HtAddStringAndData (e->enumeratedSf, e->sfName, &enumPath);

            return TRUE;
        }
    }

    FreePathString (e->sfName);
    e->sfName = NULL;
    FreePathString (e->sfPath);
    e->sfPath = NULL;
    return FALSE;
}


BOOL
pEnumNextVirtualShellFolder (
    IN OUT  PSF_ENUM e
    )
{
    TCHAR SfName[MEMDB_MAX];
    TCHAR SfParent[MEMDB_MAX];
    TCHAR SfPath[MEMDB_MAX];
    PCTSTR SfFullPath = NULL;
    PCTSTR SfParentPath = NULL;
    INT HasToExist;
    INT PerUser;
    PCTSTR argList[3]={"SystemDrive", g_WinDrive, NULL};
    PCTSTR pathExp  = NULL;
    DWORD dontCare;
    PCTSTR enumPath;

    if (!e->ProfileSF) {

        if (!e->FirstCall) {
            FreePathString (e->sfPath);
            e->sfPath = NULL;
            FreePathString (e->sfName);
            e->sfName = NULL;
        }

        while (e->FirstCall?SetupFindFirstLine (g_Win95UpgInf, S_VIRTUAL_SF, NULL, &e->Context):SetupFindNextLine (&e->Context, &e->Context)) {
            e->FirstCall = FALSE;

            if ((SetupGetStringField (&e->Context, 0, SfName, MEMDB_MAX, &dontCare)) &&
                (SetupGetStringField (&e->Context, 1, SfParent, MEMDB_MAX, &dontCare)) &&
                (SetupGetStringField (&e->Context, 2, SfPath, MEMDB_MAX, &dontCare))
                ) {

                if (!SfName[0] || HtFindStringAndData (e->enumeratedSf, SfName, NULL)) {
                    // this shell folder was already enumerated
                    continue;
                }

                if (!SetupGetIntField (&e->Context, 3, &PerUser)) {
                    PerUser = FALSE;
                }

                if (PerUser && (!e->EnumPtr)) {
                    continue;
                }

                if (!PerUser && (e->EnumPtr)) {
                    continue;
                }

                if (!SetupGetIntField (&e->Context, 4, &HasToExist)) {
                    HasToExist = FALSE;
                }

                pathExp = ExpandEnvironmentTextExA (SfPath, argList);

                if (SfParent[0]) {
                    if (!HtFindStringAndData (e->enumeratedSf, SfParent, (PVOID) &SfParentPath)) {
                        DEBUGMSG ((DBG_WARNING, "Virtual SF parent not found: %s", SfParent));
                        FreeText (pathExp);
                        continue;
                    }
                    SfFullPath = JoinPaths (SfParentPath, pathExp);
                } else if (pathExp[0] && pathExp[1] == TEXT(':')) {
                    SfFullPath = DuplicatePathString (pathExp, 0);
                } else {
                    SfFullPath = JoinPaths (g_WinDir, pathExp);
                }

                FreeText (pathExp);

                if (HasToExist && !DoesFileExist (SfFullPath)) {
                    // ISSUE: not sure what this code path does -- is it right?
                    // it is not used in the INF right now.
                    e->FirstCall = TRUE;
                    e->ProfileSF = TRUE;
                    FreePathString (SfFullPath);
                    return pEnumProfileShellFolder (e);
                }

                e->sfPath = SfFullPath;
                e->sfName = DuplicatePathString (SfName, 0);

                enumPath = PoolMemDuplicateString (g_SFPool, e->sfPath);
                HtAddStringAndData (e->enumeratedSf, e->sfName, &enumPath);

                return TRUE;
            }
        }
        e->FirstCall = TRUE;
        e->ProfileSF = TRUE;
    }
    return pEnumProfileShellFolder (e);
}

BOOL
pEnumFirstVirtualShellFolder (
    IN OUT  PSF_ENUM e
    )
{
    e->VirtualSF = TRUE;
    MYASSERT (g_Win95UpgInf);
    e->FirstCall = TRUE;
    return pEnumNextVirtualShellFolder (e);
}

VOID
pAbortEnumVirtualShellFolder (
    IN OUT  PSF_ENUM e
    )
{
    HASHTABLE_ENUM h;

    if (e->enumeratedSf) {
        if (EnumFirstHashTableString (&h, e->enumeratedSf)) {
            do {
                PoolMemReleaseMemory (g_SFPool, *((PTSTR *)h.ExtraData));
            } while (EnumNextHashTableString (&h));
        }
        HtFree (e->enumeratedSf);
        e->enumeratedSf = NULL;
    }
}


PVOID
pPathPoolAllocator (
    IN      DWORD Size
    )
{
    return (PVOID) AllocPathString (Size / sizeof (TCHAR));
}

VOID
pPathPoolDeAllocator (
    IN      PCVOID Mem
    )
{
    FreePathString ((PCTSTR) Mem);
}

PBYTE
pPathPoolGetRegValueDataOfType (
    IN      HKEY hKey,
    IN      PCSTR Value,
    IN      DWORD MustBeType
    )
{
    return GetRegValueDataOfType2 (
                hKey,
                Value,
                MustBeType,
                pPathPoolAllocator,
                pPathPoolDeAllocator
                );
}


#define PathPoolGetRegValueString(key,valuename) (PTSTR) pPathPoolGetRegValueDataOfType((key),(valuename),REG_SZ)
#define PathPoolGetRegValueBinary(key,valuename) (PBYTE) pPathPoolGetRegValueDataOfType((key),(valuename),REG_BINARY)

PCTSTR
pGetRegValuePath (
    IN      HKEY Key,
    IN      PCTSTR Value
    )
{
    PCTSTR data;
    DWORD type;
    DWORD size;
    BOOL b = TRUE;

    //
    // the data may be stored as bytes (each byte a CHAR)
    // if REG_BINARY value ending with 0, treat it as a string
    //
    if (!GetRegValueTypeAndSize (Key, Value, &type, &size)) {
        return NULL;
    }

    switch (type) {
    case REG_SZ:
        data = PathPoolGetRegValueString (Key, Value);
        break;
    case REG_BINARY:
        if (size) {
            data = (PCTSTR)PathPoolGetRegValueBinary (Key, Value);
            b = (data && data[(size / sizeof (TCHAR)) - 1] == 0);
        } else {
            b = FALSE;
        }
        break;
    default:
        data = NULL;
    }

    b = b && pIsValidPath (data);

    if (!b) {
        //
        // invalid data
        //
        if (data) {
            pPathPoolDeAllocator (data);
            data = NULL;
        }
    }

    return data;
}


/*++

Routine Description:

  EnumFirstRegShellFolder and EnumNextRegShellFolder are enumeration routines that
  enumerate all shell folders per system or for a particular user.

Arguments:

  e         - enumeration structure
  EnumPtr   - user enumeration structure

Return Value:

  Both routines return TRUE if a new shell folder could be found, FALSE otherwise

--*/


BOOL
EnumNextRegShellFolder (
    IN OUT  PSF_ENUM e
    );

BOOL
EnumFirstRegShellFolder (
    IN OUT  PSF_ENUM e,
    IN      PUSERENUM EnumPtr
    )
{
    BOOL b = FALSE;
    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;

    e->EnumPtr = EnumPtr;
    e->VirtualSF = FALSE;
    e->ProfileSF = FALSE;
    e->FirstCall = FALSE;

    e->sfCollapse = TRUE;

    e->enumeratedSf = HtAllocWithData (sizeof (PCTSTR));

    if (EnumPtr) {
        e->SfKey = OpenRegKey (EnumPtr->UserRegKey, S_SHELL_FOLDERS_KEY_USER);
    } else {
        e->SfKey = OpenRegKeyStr (S_SHELL_FOLDERS_KEY_SYSTEM);
    }

    if (!e->SfKey) {
        b = pEnumFirstVirtualShellFolder (e);
        if (b) {
            e->sfCollapse = !InfFindFirstLine (
                                g_Win95UpgInf,
                                S_ONE_USER_SHELL_FOLDERS,
                                e->sfName,
                                &is
                                );
            InfCleanUpInfStruct (&is);
        }
    }
    e->FirstCall = TRUE;

    return EnumNextRegShellFolder (e);
}


BOOL
EnumNextRegShellFolder (
    IN OUT  PSF_ENUM e
    )
{
    HKEY UsfKey;
    BOOL b = FALSE;
    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;
    PCTSTR enumPath;

    if (!e->VirtualSF) {

        if (!e->FirstCall) {
            FreePathString (e->sfName);
            e->sfName = NULL;
            FreePathString (e->sfPath);
            e->sfPath = NULL;
        }

        do {
            if (e->FirstCall?EnumFirstRegValue (&e->SfKeyEnum, e->SfKey):EnumNextRegValue (&e->SfKeyEnum)) {

                e->sfName = pGetShellFolderLongName (e->SfKeyEnum.ValueName);
                e->sfPath = NULL;

                if (e->EnumPtr) {
                    UsfKey = OpenRegKey (e->EnumPtr->UserRegKey, S_USHELL_FOLDERS_KEY_USER);
                } else {
                    UsfKey = OpenRegKeyStr (S_USHELL_FOLDERS_KEY_SYSTEM);
                }

                if (UsfKey) {
                    e->sfPath = pGetRegValuePath (UsfKey, e->SfKeyEnum.ValueName);
                    CloseRegKey (UsfKey);
                }

                if (e->sfPath == NULL) {
                    e->sfPath = pGetRegValuePath (e->SfKey, e->SfKeyEnum.ValueName);
                }

                if (e->sfPath != NULL) {

                    b = TRUE;

                    enumPath = PoolMemDuplicateString (g_SFPool, e->sfPath);
                    HtAddStringAndData (e->enumeratedSf, e->sfName, &enumPath);
                }

            } else {

                CloseRegKey (e->SfKey);
                b = pEnumFirstVirtualShellFolder (e);
            }

            e->FirstCall = FALSE;

        } while (e->sfPath == NULL && !e->VirtualSF);

    } else {
        b = pEnumNextVirtualShellFolder (e);
    }

    if (b) {
        e->sfCollapse = !InfFindFirstLine (
                            g_Win95UpgInf,
                            S_ONE_USER_SHELL_FOLDERS,
                            e->sfName,
                            &is
                            );
        InfCleanUpInfStruct (&is);
    }

    return b;
}

BOOL
EnumAbortRegShellFolder (
    IN OUT  PSF_ENUM e
    )
{
    pAbortEnumVirtualShellFolder (e);
    return TRUE;
}


VOID
pRecordShellFolderInMemDb (
    IN      PSHELLFOLDER psf
    )
{
    TCHAR Node[MEMDB_MAX];

    g_SfSequencer++;
    wsprintf (
        Node,
        TEXT("%s\\%s\\%s\\\001%u"),
        MEMDB_CATEGORY_SF_ORDER_NAME_SRC,
        psf->Name,
        psf->SrcPath,
        g_SfSequencer
        );

    MemDbSetValue (Node, (DWORD) psf);

    g_SfSequencer++;
    wsprintf (
        Node,
        TEXT("%s\\%s\\\001%u"),
        MEMDB_CATEGORY_SF_ORDER_SRC,
        psf->SrcPath,
        g_SfSequencer
        );

    MemDbSetValue (Node, (DWORD) psf);
}


VOID
pGatherCommonShellFoldersData (
    VOID
    )

/*++

Routine Description:

  pGatherCommonShellFoldersData walks the system shell folders creating a
  linked list with data that will be used later.

Arguments:

  none

Return Value:

  none

--*/

{
    SF_ENUM e;
    TCHAR Node[MEMDB_MAX];
    PSHELLFOLDER psf;
    PTSTR endStr;

    if (EnumFirstRegShellFolder (&e, NULL)) {
        do {
            if (!pIsSkippedSf (e.sfName)) {

                // if this is the startup group, store this
                if (StringIMatch (e.sfName, S_SYSTEM_STARTUP)) {
                    MemDbSetValueEx (MEMDB_CATEGORY_SF_STARTUP, e.sfPath, TEXT("*"), NULL, 0, NULL);
                }

                psf = (PSHELLFOLDER) PoolMemGetMemory (g_SFPool, sizeof (SHELLFOLDER));

                ZeroMemory (psf, sizeof (SHELLFOLDER));

                //
                // CanBeCollapsed does not make sense for common shell folders,
                // since collapsing is the action of moving per-user folders
                // into the common folder.
                //
                psf->CanBeCollapsed = TRUE;

                psf->Next = g_ShellFolders;
                g_ShellFolders = psf;

                psf->Name = PoolMemDuplicateString (g_SFPool, e.sfName);
                psf->SrcPath = PoolMemDuplicateString (g_SFPool, e.sfPath);
                endStr = GetEndOfString (psf->SrcPath);
                endStr = _tcsdec (psf->SrcPath, endStr);
                if (endStr && (_tcsnextc (endStr) == TEXT('\\')) && ((endStr - psf->SrcPath) > 2) ) {
                    *endStr = 0;
                }

                //
                // Determine destination, either the NT default location, or
                // the current location.
                //

                if (!pIsMassiveDir (psf->SrcPath) &&
                    !pIsPreservedSf (psf->Name) &&
                    pIsTheDefaultLocation (psf->Name, psf->SrcPath, NULL, ANY_COMMON) &&
                    pIsNtShellFolder (psf->Name, FALSE, FALSE)
                    ) {

                    pGetNtShellFolderPath (psf->Name, NULL, Node, sizeof (Node));
                    psf->DestPath = PoolMemDuplicateString (g_SFPool, Node);
                }

                if (!psf->DestPath) {
                    psf->DestPath = PoolMemDuplicateString (g_SFPool, psf->SrcPath);
                }

                //
                // Save references to memdb
                //

                pRecordShellFolderInMemDb (psf);

                AddShellFolder (psf->Name, psf->SrcPath);
            }

        } while (EnumNextRegShellFolder (&e));
    }
    EnumAbortRegShellFolder (&e);
}


VOID
pGatherUserShellFoldersData (
    IN      PUSERENUM EnumPtr
    )

/*++

Routine Description:

  pGatherUserShellFoldersData walks the shell folders for a user, creating a
  linked list with data that will be used later.

Arguments:

  EnumPtr - User enumeration structure

Return Value:

  None

--*/

{
    SF_ENUM e;
    TCHAR Node[MEMDB_MAX];
    PSHELLFOLDER psf;
    UINT driveClusterSize;
    UINT infClusterSize;
    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;
    UINT fieldIndex;
    UINT sfSize;
    PTSTR endStr;

    g_TotalUsers++;

    if (EnumFirstRegShellFolder (&e, EnumPtr)) {
        do {
            if (!pIsSkippedSf (e.sfName)) {

                // if this is the startup group, store this
                if (StringIMatch (e.sfName, S_USER_STARTUP)) {
                    MemDbSetValueEx (MEMDB_CATEGORY_SF_STARTUP, e.sfPath, TEXT("*"), NULL, 0, NULL);
                }

                psf = (PSHELLFOLDER) PoolMemGetMemory (g_SFPool, sizeof (SHELLFOLDER));

                ZeroMemory (psf, sizeof (SHELLFOLDER));

                psf->CanBeCollapsed = e.sfCollapse;

                psf->Next = g_ShellFolders;
                g_ShellFolders = psf;

                psf->Name = PoolMemDuplicateString (g_SFPool, e.sfName);
                psf->FixedUserName = PoolMemDuplicateString (g_SFPool, EnumPtr->FixedUserName);
                psf->UserName = PoolMemDuplicateString (g_SFPool, EnumPtr->UserName);
                psf->SrcPath = PoolMemDuplicateString (g_SFPool, e.sfPath);
                endStr = GetEndOfString (psf->SrcPath);
                endStr = _tcsdec (psf->SrcPath, endStr);
                if (endStr && (_tcsnextc (endStr) == TEXT('\\')) && ((endStr - psf->SrcPath) > 2) ) {
                    *endStr = 0;
                }

                //
                // Determine destination, either the NT default location or
                // the current Win9x location
                //

                if (!pIsMassiveDir (psf->Name) &&
                    !pIsPreservedSf (psf->Name) &&
                    pIsTheDefaultLocation (psf->Name, psf->SrcPath, EnumPtr->UserName, ANY_DEFAULT) &&
                    pIsNtShellFolder (psf->Name, TRUE, FALSE)
                    ) {

                    pGetNtShellFolderPath (psf->Name, EnumPtr->FixedUserName, Node, sizeof (Node));
                    psf->DestPath = PoolMemDuplicateString (g_SFPool, Node);
                } else {
                    psf->DestPath = PoolMemDuplicateString (g_SFPool, psf->SrcPath);

                    //
                    // Now let's see if the preserved directory is on a different drive. If yes,
                    // we will need some additional space on that drive to copy files from the
                    // default NT shell folder
                    //
                    if ((pIsNtShellFolder (psf->Name, TRUE, FALSE)) &&
                        (_totupper (psf->SrcPath[0]) != _totupper (g_WinDir[0]))
                        ) {

                        driveClusterSize = QueryClusterSize (psf->SrcPath);

                        if (driveClusterSize) {

                            MYASSERT (g_Win95UpgInf);

                            if (InfFindFirstLine (g_Win95UpgInf, S_SHELL_FOLDERS_DISK_SPACE, psf->Name, &is)) {

                                infClusterSize = 256;
                                fieldIndex = 1;
                                sfSize = 0;

                                while (infClusterSize < driveClusterSize) {

                                    if (!InfGetIntField (&is, fieldIndex, &sfSize)) {
                                        break;
                                    }
                                    fieldIndex ++;
                                    infClusterSize *= 2;
                                }
                                if (sfSize) {
                                    UseSpace (psf->SrcPath, sfSize);
                                }
                            }

                            InfCleanUpInfStruct (&is);
                        }
                    }
                }

                //
                // Save references to memdb
                //

                pRecordShellFolderInMemDb (psf);

                AddShellFolder (psf->Name, psf->SrcPath);
            }

        } while (EnumNextRegShellFolder (&e));
    }
    EnumAbortRegShellFolder (&e);
}


BOOL
pPreserveAllShellFolders (
    PCTSTR ShellFolderName,
    PCTSTR ShellFolderPath
    )

/*++

Routine Description:

  pPreserveAllShellFolders walks the shell folders structures preserving
  the location for all the shell folders that match the arguments.

Arguments:

  ShellFolderName - Specifies the Win9x shell folder identifier to preserve

  ShellFolderPath - Specifies the shell folder path to preserve

Return Value:

  Always TRUE.

--*/

{
    TCHAR Node[MEMDB_MAX];
    PSHELLFOLDER psf;
    MEMDB_ENUM enumSF;

    MemDbBuildKey (
        Node,
        MEMDB_CATEGORY_SF_ORDER_NAME_SRC,
        ShellFolderName,
        ShellFolderPath,
        TEXT("*")
        );

    if (MemDbEnumFirstValue (&enumSF, Node, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
        do {
            psf = SFSTRUCT(enumSF);
            if (psf->FixedUserName) {
                psf->DestPath = psf->SrcPath;
            }
        } while (MemDbEnumNextValue (&enumSF));
    }

    return TRUE;
}


BOOL
pCollapseAllShellFolders (
    PCTSTR ShellFolderName,
    PCTSTR ShellFolderCommonName,
    PCTSTR ShellFolderPath,
    PCTSTR UserName         OPTIONAL // only if we have only one user
    )

/*++

Routine Description:

  pCollapseAllShellFolders collapses a number of user shell folders into
  a system shell folder.

Arguments:

  ShellFolderName - Specifies the Win9x shell folder identifier

  ShellFolderCommonName - Specifies the Win9x shell folder identifier that
                          has "Common" in it

  ShellFolderPath - Specifies the common shell folder source path.

Return Value:

  TRUE if successfull, FALSE if not.

--*/

{
    TCHAR Node[MEMDB_MAX];
    PSHELLFOLDER psf;
    MEMDB_ENUM enumSF;

    //
    // First step. Search the list of shell folders eliminating the
    // ones that are per-user and contain the data matching the caller's
    // arguments.  Then we build a common structure.
    //

    psf = g_ShellFolders;

    while (psf) {
        if ((psf->Name) &&
            (psf->FixedUserName) &&
            (StringIMatch (psf->Name, ShellFolderName)) &&
            (StringIMatch (psf->SrcPath, ShellFolderPath))
            ) {
            //
            // Eliminate the folders that will actually become All Users
            // on NT.  We will delete the memdb index entries just before
            // returning (see below).
            //

            psf->Name = NULL;
        }
        psf = psf->Next;
    }

    //
    // Add the common shell folder to the list
    //

    psf = (PSHELLFOLDER) PoolMemGetMemory (g_SFPool, sizeof (SHELLFOLDER));

    ZeroMemory (psf, sizeof (SHELLFOLDER));

    psf->CanBeCollapsed = TRUE;

    psf->Next = g_ShellFolders;
    g_ShellFolders = psf;

    psf->Name = PoolMemDuplicateString (g_SFPool, ShellFolderCommonName);
    psf->SrcPath = PoolMemDuplicateString (g_SFPool, ShellFolderPath);

    if (!pIsPreservedSf (ShellFolderCommonName) &&
        pIsTheDefaultLocation (ShellFolderName, ShellFolderPath, UserName, ANY_COMMON)
        ) {
        pGetNtShellFolderPath (ShellFolderCommonName, NULL, Node, sizeof (Node));
        psf->DestPath = PoolMemDuplicateString (g_SFPool, Node);
    }

    if (!psf->DestPath) {
        psf->DestPath = PoolMemDuplicateString (g_SFPool, ShellFolderPath);
    }

    //
    // Before adding the new node to the index in memdb, look if a common
    // shell folder with this name already exists. If it does, we will
    // take the destination path from there, otherwise, we will use the
    // current one.
    //

    MemDbBuildKey (
        Node,
        MEMDB_CATEGORY_SF_ORDER_NAME_SRC,
        ShellFolderCommonName,
        TEXT("*"),
        NULL
        );

    if (MemDbEnumFirstValue (&enumSF, Node, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
        if (!StringIMatch (psf->DestPath, SFSTRUCT(enumSF)->DestPath)) {
            //
            // This case occurs when a common folder was previously preserved
            //

            psf->DestPath = PoolMemDuplicateString (
                                g_SFPool,
                                SFSTRUCT(enumSF)->DestPath
                                );
        }
    }

    //
    // Save references to memdb
    //

    pRecordShellFolderInMemDb (psf);

    //
    // Finally eliminate all MemDb entries for the deleted structures.
    //

    MemDbBuildKey (
        Node,
        MEMDB_CATEGORY_SF_ORDER_NAME_SRC,
        ShellFolderName,
        ShellFolderPath,
        NULL
        );

    MemDbDeleteTree (Node);

    return TRUE;
}


VOID
pComputeCommonName (
    OUT     PTSTR Buffer,
    IN      PCTSTR PerUserName
    )
{
    MYASSERT(g_CommonFromPerUserMap);

    StringCopy (Buffer, PerUserName);
    if (MappingSearchAndReplace (g_CommonFromPerUserMap, Buffer, MAX_SHELLFOLDER_NAME)) {
        return;
    }

    wsprintf (Buffer, TEXT("%s %s"), TEXT("Common"), PerUserName);
    return;
}


VOID
pComputePerUserName (
    OUT     PTSTR Buffer,
    IN      PCTSTR CommonName
    )
{
    MYASSERT(g_PerUserFromCommonMap);

    StringCopy (Buffer, CommonName);
    if (MappingSearchAndReplace (g_PerUserFromCommonMap, Buffer, MAX_SHELLFOLDER_NAME)) {
        return;
    }

    if (StringIPrefix (CommonName, TEXT("Common"))) {
        CommonName += 6;
        if (_tcsnextc (CommonName) == TEXT(' ')) {
            CommonName++;
        }

        StringCopy (Buffer, CommonName);
    }

    return;
}


BOOL
pIsPerUserSf (
    IN      PCTSTR TagName
    )
{
    TCHAR testBuf[MAX_SHELLFOLDER_NAME];

    //
    // Tag is common if it has a "Common" prefix or can be mapped from g_PerUserFromCommonMap
    //

    if (StringIPrefix (TagName, TEXT("Common"))) {
        return FALSE;
    }

    StringCopy (testBuf, TagName);
    if (MappingSearchAndReplace (g_PerUserFromCommonMap, testBuf, MAX_SHELLFOLDER_NAME)) {
        return FALSE;
    }

    return TRUE;
}


VOID
pProcessShellFoldersInfo (
    VOID
    )

/*++

Routine Description:

  pProcessShellFoldersInfo walks the shell folders structures, rearranging
  the structures and/or modifying the destination paths.  This function is
  called after all shell folders have been identified.  The purpose is to
  move all common shell folders to All Users, and to preserve the locations
  of shell folders that are non-standard.

Arguments:

  None

Return Value:

  None

--*/

{
    TCHAR lastSfName[MAX_SHELLFOLDER_NAME];
    TCHAR node[MEMDB_MAX];
    TCHAR lastPath[MAX_TCHAR_PATH];
    TCHAR commonName[MAX_SHELLFOLDER_NAME];
    MEMDB_ENUM enumSF;
    DWORD UsersWithIdenticalPaths;
    DWORD UsersWithDefaultCommonPath;
    DWORD UsersWithFolder;
    PSHELLFOLDER lastSf;
    PSHELLFOLDER testSf;
    BOOL sentinel;
    DWORD extraUsers = 0;

    if (CANCELLED()) {
        return;
    }

    //
    // Enumerate the SHELLFOLDER structures, ordered by sorted shell folder name, and
    // see if all users point to the same source path.
    //

    MemDbBuildKey (node, MEMDB_CATEGORY_SF_ORDER_NAME_SRC, TEXT("*"), NULL, NULL);

    if (MemDbEnumFirstValue (&enumSF, node, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
        lastSfName[0] = 0;
        lastPath[0] = 0;
        UsersWithIdenticalPaths = 0;
        UsersWithDefaultCommonPath = 0;
        UsersWithFolder = 0;
        lastSf = NULL;
        sentinel = FALSE;
        extraUsers = 0;

        for (;;) {

            testSf = SFSTRUCT(enumSF);

            if (sentinel || !StringIMatch (lastSfName, testSf->Name)) {
                //
                // This shell folder is not the same as the previous folder,
                // or the sentinel triggered one final test.
                //

                DEBUGMSG ((DBG_USERLOOP, "%u users have shell folder %s", UsersWithFolder, lastSfName));

                if (UsersWithDefaultCommonPath == (g_TotalUsers + extraUsers)) {
                    //
                    // If lastSf is non-NULL, then we know it is per-user and the previous
                    // shell folder maps to one or more users, and all users point to
                    // the same place.
                    //

                    if (lastSf) {

                        //
                        // If this shell folder is forced to be per-user, then
                        // don't collapse it into the common location if there
                        // is only one user. Otherwise, point all users to the
                        // NT All Users shell folder, and leave the per-user
                        // location empty.
                        //

                        if (UsersWithDefaultCommonPath > 1 || !pIsPerUserWanted (lastSf->Name)) {
                            pComputeCommonName (commonName, lastSf->Name);

                            if (pIsNtShellFolder (commonName, FALSE, FALSE)) {
                                //
                                // All users point to the same shell folder, and the shell
                                // folder is a default location.  Therefore, make sure they
                                // all are mapped to NT's All Users location.
                                //

                                pCollapseAllShellFolders (
                                    lastSf->Name,
                                    commonName,
                                    lastSf->SrcPath,
                                    (UsersWithDefaultCommonPath == 1)?lastSf->UserName:NULL
                                    );
                            }
                        }
                    }

                } else {
                    //
                    // If 2 or more users point to this location, but not all users
                    // point here, then preserve all uses of this shell folder/source
                    // path pair.
                    //

                    if (UsersWithIdenticalPaths > 1) {
                        DEBUGMSG ((
                            DBG_USERLOOP,
                            "%u users point to %s for %s (common), and %u point to default location, but there are %u users %s",
                            UsersWithIdenticalPaths,
                            lastSf->SrcPath,
                            lastSf->Name,
                            UsersWithDefaultCommonPath,
                            g_TotalUsers,
                            extraUsers ? TEXT("plus <default>") : TEXT("")
                            ));

                        pPreserveAllShellFolders (lastSf->Name, lastSf->SrcPath);
                    }
                }

                //
                // We have to break out now when sentinel is TRUE.  This is our
                // only exit condition for this loop.
                //

                if (sentinel) {
                    break;
                }

                //
                // Keep track of the name of the shell folder (for comparison the
                // next time through the loop)
                //

                StringCopy (lastSfName, testSf->Name);
                StringCopy (lastPath, testSf->SrcPath);
                UsersWithIdenticalPaths = 0;
                UsersWithDefaultCommonPath = 0;
                UsersWithFolder = 0;
                extraUsers = 0;
                lastSf = NULL;              // works without this, but added for less tests
            }

            UsersWithFolder++;

            //
            // Is this a per-user shell folder?
            //

            if (testSf->FixedUserName) {
                //
                // Yes, compare its path against the previous path
                //

                if (StringIMatch (lastPath, testSf->SrcPath)) {

                    UsersWithIdenticalPaths++;

                    if (pIsTheDefaultLocation (testSf->Name, testSf->SrcPath, testSf->FixedUserName, ANY_COMMON)) {
                        if (testSf->CanBeCollapsed) {
                            UsersWithDefaultCommonPath++;
                        } else {
                            DEBUGMSG ((
                                DBG_USERLOOP,
                                "User %s uses the default common path for %s, but it can't be collapsed",
                                testSf->FixedUserName,
                                testSf->Name
                                ));
                        }
                    }
                    ELSE_DEBUGMSG ((
                        DBG_USERLOOP,
                        "User %s does not use the default common path for %s",
                        testSf->FixedUserName,
                        testSf->Name
                        ));

                } else {
                    //
                    // At least two users have different paths.  Were there 2 or
                    // more users using the same path?  If so, preserve that path.
                    //

                    if (UsersWithIdenticalPaths > 1) {
                        DEBUGMSG ((
                            DBG_USERLOOP,
                            "%u users point to %s for %s (per-user), but there are %u users %s",
                            UsersWithIdenticalPaths,
                            lastSf->SrcPath,
                            lastSf->Name,
                            g_TotalUsers,
                            extraUsers ? TEXT("plus <default>") : TEXT("")
                            ));

                        pPreserveAllShellFolders (lastSf->Name, lastSf->SrcPath);
                    }

                    //
                    // Now we must compare against a different path
                    //

                    UsersWithIdenticalPaths = 1;
                    StringCopy (lastPath, testSf->SrcPath);
                }

                lastSf = testSf;
            } else {
                extraUsers = 1;
                UsersWithIdenticalPaths = 1;
                if (pIsTheDefaultLocation (testSf->Name, testSf->SrcPath, testSf->FixedUserName, ANY_COMMON)) {
                    UsersWithDefaultCommonPath++;
                }
                ELSE_DEBUGMSG ((
                    DBG_USERLOOP,
                    "User %s does not use the default common path for %s",
                    testSf->FixedUserName,
                    testSf->Name
                    ));
            }

            if (!MemDbEnumNextValue (&enumSF)) {
                //
                // We're just about done.
                //
                // This will cause us to test the last shell folder,
                // and then break out of the loop:
                //

                sentinel = TRUE;
            }
        }
    }
}


VOID
pIgnoreShellFolder (
    PSHELLFOLDER DisableSf
    )
{
    TREE_ENUM treeEnum;
    BOOL fileFound;
    TCHAR buffer[MAX_TCHAR_PATH];
    DWORD status;

    if (DisableSf && DisableSf->DestPath) {

        DEBUGMSG_IF ((
            DisableSf->UserName != NULL,
            DBG_USERLOOP,
            "Disabling %s for %s because it should be empty",
            DisableSf->Name,
            DisableSf->UserName
            ));

        if (StringIMatch (DisableSf->Name, TEXT("Personal"))) {

            //
            // Check if source has at least one file that belongs
            // to the user
            //

            if (EnumFirstFileInTreeEx (
                    &treeEnum,
                    DisableSf->SrcPath,
                    NULL,
                    FALSE,
                    FALSE,
                    FILE_ENUM_ALL_LEVELS
                    )) {

                fileFound = FALSE;

                do {
                    if (CANCELLED()) {
                        AbortEnumFileInTree (&treeEnum);
                        return;
                    }

                    if (!treeEnum.Directory) {
                        status = GetFileStatusOnNt (treeEnum.FullPath);

                        status &= FILESTATUS_DELETED|
                                  FILESTATUS_NTINSTALLED|
                                  FILESTATUS_REPLACED;

                        if (!status) {

                            fileFound = TRUE;
                            AbortEnumFileInTree (&treeEnum);
                            break;

                        }
                    }
                } while (EnumNextFileInTree (&treeEnum));

                if (fileFound &&
                    pGetNtShellFolderPath (
                        DisableSf->Name,
                        DisableSf->FixedUserName,
                        buffer,
                        sizeof (buffer)
                        )) {
                    //
                    // At least one file -- add warning text file
                    //

                    MemDbSetValueEx (
                        MEMDB_CATEGORY_MYDOCS_WARNING,
                        DisableSf->FixedUserName,
                        buffer,
                        NULL,
                        0,
                        NULL
                        );
                }
            }
        }

        DisableSf->DestPath = NULL;
    }
}



VOID
pResolveSourceCollisions (
    VOID
    )

/*++

Routine Description:

  pResolveSourceCollisions walks the list of shell folders and redirects
  destinations when source paths collide. If a source path of one shell
  folder matches another, and one of the paths is status "merged," then the
  other should be the same. By definition, given one source path, we cannot
  have a merge to two separate locations.

  NOTE: Merge simply means the source path is different from the dest path.

  After resolving collisions, this function scans the SFs again, eliminating
  common folders that are redirected to per-user locations, if that per-user
  location is in its default location.

Arguments:

  None.

Return Value:

  None.

--*/

{
    MEMDB_ENUM enumSF;
    GROWBUFFER sfPtrList = GROWBUF_INIT;
    PSHELLFOLDER thisSf;
    PSHELLFOLDER compareSf;
    PSHELLFOLDER disableSf;
    PSHELLFOLDER commonSf;
    PSHELLFOLDER perUserSf;
    PSHELLFOLDER *listPtr;
    INT i;
    INT j;
    INT count;
    INT lookAhead;
    TCHAR node[MEMDB_MAX];
    BOOL thisMoved;
    BOOL compareMoved;
    UINT p1, p2;
    TCHAR commonName[MAX_SHELLFOLDER_NAME];
    TCHAR perUserName[MAX_SHELLFOLDER_NAME];
    INT duplicates;
    INT total;

    if (CANCELLED()) {
        return;
    }

    //
    // Put the shell folder pointers into an array
    //

    MemDbBuildKey (node, MEMDB_CATEGORY_SF_ORDER_NAME_SRC, TEXT("*"), NULL, NULL);

    if (MemDbEnumFirstValue (&enumSF, node, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
        do {
            listPtr = (PSHELLFOLDER *) GrowBuffer (&sfPtrList, sizeof (PSHELLFOLDER));
            *listPtr = SFSTRUCT(enumSF);

        } while (MemDbEnumNextValue (&enumSF));
    }

    count = (sfPtrList.End / sizeof (PSHELLFOLDER)) - 1;
    listPtr = (PSHELLFOLDER *) sfPtrList.Buf;

    for (i = 0 ; i <= count ; i++) {
        thisSf = listPtr[i];
        thisSf->SourceExists = DoesFileExist (thisSf->SrcPath);
    }

    //
    // Eliminate shell folders that have per user shell folder names but
    // don't have a user.
    //

    for (i = 0 ; i < count ; i++) {
        perUserSf = listPtr[i];

        if (pIsPerUserSf (perUserSf->Name) && perUserSf->UserName == NULL) {
            pIgnoreShellFolder (perUserSf);
        }
    }

    //
    // Scan for a common shell folder that has the same source location of
    // two or more per-user shell folders. When this case is found, discard
    // the whole set, so they are preserved.
    //

    for (i = 0 ; i < count ; i++) {
        commonSf = listPtr[i];

        //
        // Has this sf been processed already? Or is it just a logical folder?
        // Or is it per-user?
        //

        if (commonSf->MergedIntoOtherShellFolder) {
            continue;
        }

        if (!commonSf->SourceExists) {
            continue;
        }

        if (!commonSf->DestPath) {
            continue;
        }

        if (pIsPerUserSf (commonSf->Name)) {
            continue;
        }

        pComputePerUserName (perUserName, commonSf->Name);

        //
        // Count all the per-user shell folders that have the same source path
        // as the common. If it is just one, then we're going to use the
        // per-user location instead of the common location. If it is more
        // than one, but not all, then we're going to preserve the location
        // for the path. If it is everyone, then we're going to use the common
        // location.
        //

        duplicates = 0;
        total = 0;

        for (j = 0 ; j <= count ; j++) {
            perUserSf = listPtr[j];

            if (perUserSf == commonSf) {
                continue;
            }

            if (!perUserSf->DestPath) {
                continue;
            }

            if (!StringIMatch (perUserSf->Name, perUserName)) {
                continue;
            }

            total++;
            if (StringIMatch (commonSf->SrcPath, perUserSf->SrcPath)) {
                duplicates++;
            }
        }

        if (duplicates <= 1) {
            //
            // Do nothing (resolved later)
            //
        } else {

            DEBUGMSG_IF ((
                duplicates < total,
                DBG_USERLOOP,
                "Preserving all references to %s for shell folder %s, because some (but not all) users point to the same path",
                commonSf->SrcPath,
                perUserName
                ));

            DEBUGMSG_IF ((
                duplicates == total,
                DBG_USERLOOP,
                "All users use common location %s",
                commonSf->SrcPath
                ));

            for (j = 0 ; j <= count ; j++) {
                perUserSf = listPtr[j];

                if (perUserSf == commonSf) {
                    continue;
                }

                if (!perUserSf->DestPath) {
                    continue;
                }

                if (!StringIMatch (perUserSf->Name, perUserName)) {
                    continue;
                }

                if (duplicates < total) {
                    //
                    // Preserve the location to this source path
                    //

                    if (StringIMatch (commonSf->SrcPath, perUserSf->SrcPath)) {
                        perUserSf->DestPath = perUserSf->SrcPath;
                    }

                } else {
                    //
                    // Everyone points to the common location; use it
                    // by disabling the per-user shell folder entry.
                    //

                    MYASSERT (StringIMatch (commonSf->SrcPath, perUserSf->SrcPath));
                    pIgnoreShellFolder (perUserSf);
                }
            }

            if (duplicates < total) {
                //
                // Discard all migration to the common shell folder
                //
                pIgnoreShellFolder (commonSf);
            }
        }
    }

    //
    // Walk the array. For each pair of shell folders that have the same
    // source location, make the dest location the same if it is not the same
    // as source.
    //

    for (i = 0 ; i < count ; i++) {
        thisSf = listPtr[i];

        //
        // Has this sf been processed already? Or is it just a logical folder?
        //

        if (thisSf->MergedIntoOtherShellFolder) {
            continue;
        }

        if (!thisSf->SourceExists) {
            continue;
        }

        if (!thisSf->DestPath) {
            continue;
        }

        //
        // Look through all other SFs on the list. If a pair of SFs have the
        // same source, then see if one is moved but the other is preserved.
        // In that case, move them both.
        //

        for (lookAhead = i + 1 ; lookAhead <= count ; lookAhead++) {
            compareSf = listPtr[lookAhead];

            if (!compareSf->SourceExists) {
                continue;
            }

            if (!compareSf->DestPath) {
                continue;
            }


            if (StringIMatch (thisSf->SrcPath, compareSf->SrcPath)) {
                DEBUGMSG ((
                    DBG_USERLOOP,
                    "%s for %s and %s for %s both point to %s",
                    thisSf->Name,
                    thisSf->UserName,
                    compareSf->Name,
                    compareSf->UserName,
                    thisSf->SrcPath
                    ));

                thisMoved = !StringIMatch (thisSf->SrcPath, thisSf->DestPath);
                compareMoved = !StringIMatch (compareSf->SrcPath, compareSf->DestPath);

                if (thisMoved && compareMoved && !StringIMatch (thisSf->DestPath, compareSf->DestPath)) {
                    //
                    // Need to fix this dest contradiction with a prority table
                    //

                    p1 = pGetShellFolderPriority (thisSf->Name);
                    p2 = pGetShellFolderPriority (compareSf->Name);

                    if (p1 > p2) {
                        //
                        // Use compareSf over thisSf
                        //

                        DEBUGMSG ((DBG_USERLOOP, "Destination collision: %s overpowers %s", compareSf->Name, thisSf->Name));
                        thisSf->DestPath = compareSf->DestPath;

                    } else if (p1 < p2) {
                        //
                        // Use thisSf over compareSf
                        //

                        DEBUGMSG ((DBG_USERLOOP, "Destination collision: %s overpowers %s", thisSf->Name, compareSf->Name));
                        compareSf->DestPath = thisSf->DestPath;

                    } else {
                        DEBUGMSG ((DBG_WHOOPS, "Missing priority for both %s and %s", thisSf->Name, compareSf->Name));
                    }


                } else if (thisMoved != compareMoved) {

                    DEBUGMSG ((
                        DBG_USERLOOP,
                        "%s for %s redirected from %s to %s",
                        thisMoved ? compareSf->Name : thisSf->Name,
                        thisMoved ? compareSf->UserName : thisSf->UserName,
                        thisMoved ? compareSf->DestPath : thisSf->DestPath,
                        thisMoved ? thisSf->DestPath : compareSf->DestPath
                        ));

                    disableSf = NULL;

                    if (thisMoved) {
                        //
                        // thisSf is merged but compareSf is preserved. If compareSf is a per-user
                        // shell folder, and thisSf is common, then ignore compareSf, because thisSf
                        // will take care of the move. We don't want two shell folders pointing to
                        // the same place.
                        //

                        if (pIsPerUserSf (compareSf->Name) && !pIsPerUserSf (thisSf->Name)) {
                            disableSf = compareSf;
                        } else {
                            compareSf->DestPath = thisSf->DestPath;
                        }
                    } else {
                        //
                        // inverse case of above
                        //
                        if (pIsPerUserSf (thisSf->Name) && !pIsPerUserSf (compareSf->Name)) {
                            disableSf = thisSf;
                        } else {
                            thisSf->DestPath = compareSf->DestPath;
                        }
                    }

                    thisSf->MergedIntoOtherShellFolder = TRUE;
                    compareSf->MergedIntoOtherShellFolder = TRUE;

                    pIgnoreShellFolder (disableSf);
                }
            }
        }
    }

    //
    // Now fix this problem: does a common shell folder point to a per-user
    // destination, and the per-user destination points to its default
    // location? If so, remove the common shell folder from migration.
    //

    for (i = 0 ; i <= count ; i++) {
        thisSf = listPtr[i];

        if (!thisSf->DestPath) {
            continue;
        }

        //
        // If source does not exist, force dest to NULL
        //

        if (thisSf->SourceExists == FALSE) {
            if (thisSf->DestPath[0] != '\\' || thisSf->DestPath[1] != '\\') {
                thisSf->DestPath = NULL;
            }
            continue;
        }

        if (thisSf->UserName == NULL) {
            continue;
        }

        //
        // We found a per-user shell folder. Is it merged? If so, find its
        // common equivalent, and check if that is merged. If yes, delete the
        // common sf.
        //

        if (StringIMatch (thisSf->SrcPath, thisSf->DestPath)) {
            continue;       // per-user folder is preserved; ignore it
        }

        DEBUGMSG ((DBG_USERLOOP, "Processing common/per-user collisions for %s", thisSf->Name));

        pComputeCommonName (commonName, thisSf->Name);

        for (j = 0 ; j <= count ; j++) {
            if (j == i) {
                continue;
            }

            compareSf = listPtr[j];
            if (compareSf->UserName != NULL) {
                continue;
            }

            if (compareSf->DestPath == NULL) {
                continue;
            }

            if (!StringIMatch (compareSf->Name, commonName)) {
                continue;
            }

            if (!StringIMatch (thisSf->SrcPath, compareSf->SrcPath)) {
                //
                // Different source paths -- don't touch
                //
                continue;
            }

            if (!StringIMatch (compareSf->SrcPath, compareSf->DestPath) &&
                StringIMatch (thisSf->DestPath, compareSf->DestPath)
                ) {
                //
                // The dest is the same, and common is not preserved, so
                // remove the common folder
                //

                DEBUGMSG ((
                    DBG_USERLOOP,
                    "Common dest %s is the same as the per-user dest, deleting common",
                    compareSf->DestPath
                    ));
                pIgnoreShellFolder (compareSf);
            }
        }
    }

    FreeGrowBuffer (&sfPtrList);
}


BOOL
pRecordUserShellFolder (
    IN      PCTSTR ShellFolderName,
    IN      PCTSTR FixedUserName,
    IN      PCTSTR ShellFolderSrc,
    IN      PCTSTR ShellFolderOriginalSrc,
    IN      PCTSTR ShellFolderDest
    )
{
    TCHAR node[MEMDB_MAX];
    UINT sequencer;

    MemDbBuildKey (node, FixedUserName?FixedUserName:S_DOT_ALLUSERS, ShellFolderName, NULL, NULL);
    if (IsFileMarkedForOperation (node, OPERATION_SHELL_FOLDER)) {
        sequencer = GetSequencerFromPath (node);
    }
    else {
        sequencer = AddOperationToPath (node, OPERATION_SHELL_FOLDER);
        AddPropertyToPathEx (sequencer, OPERATION_SHELL_FOLDER, ShellFolderDest, MEMDB_CATEGORY_SHELLFOLDERS_DEST);
    }

    AddPropertyToPathEx (sequencer, OPERATION_SHELL_FOLDER, ShellFolderOriginalSrc, MEMDB_CATEGORY_SHELLFOLDERS_ORIGINAL_SRC);

    AddPropertyToPathEx (sequencer, OPERATION_SHELL_FOLDER, ShellFolderSrc, MEMDB_CATEGORY_SHELLFOLDERS_SRC);

    return TRUE;
}


//
// These globals are used to record an empty directory. Every time we come across a directory we store
// the directory name and we set g_EmptyDir to true. When we come across a file we reset g_EmptyDir.
// If, when we come across another directory, g_EmptyDir is set it means that the previous directory was
// empty.
//

PTSTR g_EmptyDirName = NULL;
BOOL g_EmptyDir = FALSE;

BOOL
pIsParent (
    IN      PCTSTR Parent,
    IN      PCTSTR Son
    )
{
    UINT parentLen;

    parentLen = ByteCount (Parent);

    if (StringIMatchByteCount (Parent, Son, parentLen)) {
        if (Son [parentLen] == '\\') {
            return TRUE;
        }
    }
    return FALSE;
}


BOOL
pCheckTemporaryInternetFiles (
    IN      PSHELLFOLDER ShellFolder
    )
{
/*
    TREE_ENUM e;
    DWORD fileCount = 0;
    DWORD startCount;
    BOOL expired = FALSE;
*/
    //
    // Don't migrate temporary internet files under any circumstances
    //

    return FALSE;

/*
    MYASSERT (ShellFolder);

    startCount = GetTickCount ();

    if (EnumFirstFileInTreeEx (&e, ShellFolder->SrcPath, NULL, FALSE, FALSE, FILE_ENUM_ALL_LEVELS)) {

        do {

            if (GetTickCount () - startCount > 1000) {

                AbortEnumFileInTree (&e);
                expired = TRUE;
                break;
            }

            fileCount++;

        } while (EnumNextFileInTree (&e));
    }

    return !expired;
*/
}


BOOL
pMoveShellFolder (
    IN      PSHELLFOLDER ShellFolder
    )
{
    TREE_ENUM e;
    TCHAR Node[MEMDB_MAX];
    UINT SrcBytes;
    PCTSTR NewDest;
    PCTSTR p;
    PROFILE_MERGE_DATA Data;
    PSHELL_FOLDER_FILTER Filter;
    DWORD d;

    //
    // Don't scan shell folders on inaccessible drives
    //
    if (!IsDriveAccessible (ShellFolder->SrcPath)) {
        return TRUE;
    }

    //
    // Don't scan shell folders pointing to massive dirs
    //
    if (pIsMassiveDir (ShellFolder->SrcPath)) {
        return TRUE;
    }

    //
    // Test to ensure that Temporary Internet Files isn't too huge.
    //
    if (StringIMatch (ShellFolder->Name, TEXT("CACHE")) && !pCheckTemporaryInternetFiles (ShellFolder)) {

        DEBUGMSG ((DBG_WARNING, "Temporary Internet Files will be removed during textmode."));
        ExcludePath (g_ExclusionValue, ShellFolder->SrcPath);
        MemDbSetValueEx (MEMDB_CATEGORY_FULL_DIR_DELETES, ShellFolder->SrcPath, NULL, NULL, 0, NULL);
        return TRUE;

    }

    g_EmptyDir = FALSE;
    g_EmptyDirName = AllocPathString (MEMDB_MAX);

    if (!StringIMatch (ShellFolder->SrcPath, ShellFolder->DestPath)) {
        MarkFileForShellFolderMove (ShellFolder->SrcPath, ShellFolder->DestPath);
    }

    //
    // Init the filter data struct
    //
    ZeroMemory (&Data, sizeof (Data));

    Data.FixedUserName = ShellFolder->FixedUserName;
    Data.ShellFolderIdentifier = ShellFolder->Name;
    Data.Context = PER_FOLDER_INITIALIZE;
    _tcssafecpy (Data.TempSourcePath, ShellFolder->SrcPath, MEMDB_MAX);
    _tcssafecpy (Data.DestinationPath, ShellFolder->DestPath, MEMDB_MAX);
    Data.SrcRootPath = ShellFolder->SrcPath;
    Data.DestRootPath = ShellFolder->DestPath;

    //
    // Call filters for init
    //

    for (Filter = g_Filters ; Filter->Fn ; Filter++) {
        Data.State = 0;
        Filter->Fn (&Data);
        Filter->State = Data.State;
    }

    if (EnumFirstFileInTreeEx (&e, ShellFolder->SrcPath, NULL, FALSE, FALSE, FILE_ENUM_ALL_LEVELS)) {

        do {
            if (CANCELLED()) {
                AbortEnumFileInTree (&e);
                return FALSE;
            }

            if (e.Directory) {
                MemDbBuildKey (Node, MEMDB_CATEGORY_SHELL_FOLDERS_MOVED, e.FullPath, NULL, NULL);

                if (MemDbGetValue (Node, NULL)) {
                    DEBUGMSG ((DBG_USERLOOP, "%s already moved", e.FullPath));
                    AbortEnumCurrentDir (&e);
                    continue;
                }
            }

            if (IsFileMarkedForOperation (e.FullPath, ALL_DELETE_OPERATIONS|ALL_MOVE_OPERATIONS)) {
                //
                // File is already going to be deleted or moved; ignore shell folder migration
                //
                continue;
            }

            //
            // Generate the symbolic destination, and add an external file move
            // operation.  It also records the source from destination linkage.
            //

            SrcBytes = ByteCount (ShellFolder->SrcPath);

            p = (PCTSTR) ((PBYTE) e.FullPath + SrcBytes);
            if (*p == TEXT('\\')) {
                p++;
            }

            NewDest = JoinPaths (ShellFolder->DestPath, p);

            Data.Attributes = e.FindData->dwFileAttributes;
            _tcssafecpy (Data.TempSourcePath, e.FullPath, MEMDB_MAX);
            _tcssafecpy (Data.DestinationPath, NewDest, MEMDB_MAX);
            Data.Context = PROCESS_PATH;

            FreePathString (NewDest);
            NewDest = NULL;

            //
            // Allow filters to change source or dest, or to skip copy
            //

            for (Filter = g_Filters ; Filter->Fn ; Filter++) {
                Data.State = Filter->State;
                d = Filter->Fn (&Data);
                Filter->State = Data.State;

                if (d == SHELLFILTER_SKIP_FILE) {
                    break;
                }
                if (d == SHELLFILTER_SKIP_DIRECTORY) {
                    AbortEnumCurrentDir (&e);
                    break;
                }
            }

            if (!Filter->Fn) {
                if (!StringIMatch (e.FullPath, Data.DestinationPath)) {
                    if (!IsFileMarkedForDelete (e.FullPath)) {
                        MarkFileForShellFolderMove (e.FullPath, Data.DestinationPath);
                    }
                }

                if (e.Directory) {
                    if (g_EmptyDir && (!pIsParent (g_EmptyDirName, Data.DestinationPath))) {
                        MarkDirectoryAsPreserved (g_EmptyDirName);
                    }
                    g_EmptyDir = TRUE;
                    _tcssafecpy (g_EmptyDirName, Data.DestinationPath, MEMDB_MAX);
                }
            } else {
                //
                // we don't need this file on NT side
                // let's delete it in text mode setup.
                //
                MarkFileForDelete (e.FullPath);
            }
            if (!e.Directory) {
                g_EmptyDir = FALSE;
            }

        } while (EnumNextFileInTree (&e));
    }

    //
    // Call filters one last time
    //

    Data.Attributes = 0;
    Data.TempSourcePath[0] = 0;
    Data.DestinationPath[0] = 0;
    Data.Context = PER_FOLDER_TERMINATE;
    _tcssafecpy (Data.TempSourcePath, ShellFolder->SrcPath, MAX_TCHAR_PATH);
    _tcssafecpy (Data.DestinationPath, ShellFolder->DestPath, MAX_TCHAR_PATH);

    for (Filter = g_Filters ; Filter->Fn ; Filter++) {
        Data.State = Filter->State;
        Filter->Fn (&Data);
        Filter->State = Data.State;
    }

    if (g_EmptyDir) {
        MarkDirectoryAsPreserved (g_EmptyDirName);
    }

    FreePathString (g_EmptyDirName);
    g_EmptyDirName = NULL;

    return TRUE;
}


VOID
pLoadSFMigDirs (
    VOID
    )
{
    INFCONTEXT ctx;
    TCHAR SFName[MAX_SHELLFOLDER_NAME];
    TCHAR SubDirBuffer[MAX_PATH];
    PCTSTR SubDir;
    INT Levels;

    if (SetupFindFirstLine (g_Win95UpgInf, S_SHELLFOLDERSMIGRATIONDIRS, NULL, &ctx)) {
        do {
            if (SetupGetStringField (&ctx, 1, SFName, MAX_PATH, NULL) && SFName[0]) {
                if (SetupGetStringField (&ctx, 2, SubDirBuffer, MAX_PATH, NULL) && SubDirBuffer[0]) {
                    SubDir = SubDirBuffer;
                } else {
                    SubDir = NULL;
                }

                if (SetupGetIntField (&ctx, 3, &Levels) && Levels == 1) {
                    //
                    // the whole subtree
                    //
                    Levels = MAX_DEEP_LEVELS;
                } else {
                    Levels = 0;
                }

                //
                // add this info to memdb
                //
                MemDbSetValueEx (MEMDB_CATEGORY_SFMIGDIRS, SFName, SubDir, NULL, Levels, NULL);
            }
        } while (SetupFindNextLine (&ctx, &ctx));
    }
}


VOID
pExecuteShellFoldersMove (
    VOID
    )
{
    GROWBUFFER Pointers = GROWBUF_INIT;
    INT Pos;
    PSHELLFOLDER psf, oldPsf;
    TCHAR Node[MEMDB_MAX];
    UINT Sequencer = 0;
    TCHAR TempPath[MEMDB_MAX];
    MEMDB_ENUM enumSF;
    PROFILE_MERGE_DATA Data;
    PSHELL_FOLDER_FILTER Filter;
    PCTSTR MigPath;
    DWORD Levels;
    HASHTABLE tagNames;
    TCHAR uniqueTagName[MAX_SHELLFOLDER_NAME + MAX_USER_NAME + 5];
    PTSTR numPtr;
    UINT sequencer;

    if (CANCELLED()) {
        return;
    }

    //
    // Prepare a list of pointers, so we can process them in
    // reverse order
    //

    MemDbBuildKey (Node, MEMDB_CATEGORY_SF_ORDER_SRC, TEXT("*"), NULL, NULL);
    if (MemDbEnumFirstValue (&enumSF, Node, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {

        do {

            GrowBufAppendDword (&Pointers, enumSF.dwValue);

        } while (MemDbEnumNextValue (&enumSF));
    }

    tagNames = HtAlloc();

    //
    // Call filters for global init
    //

    ZeroMemory (&Data, sizeof (Data));
    Data.Context = GLOBAL_INITIALIZE;

    for (Filter = g_Filters ; Filter->Fn ; Filter++) {
        Data.State = 0;
        Filter->Fn (&Data);
        Filter->State = Data.State;
    }

    //
    // Now loop through all the pointers starting at the end
    //

    for (Pos = (INT) Pointers.End - sizeof (DWORD) ; Pos >= 0 ; Pos -= sizeof (DWORD)) {

        if (CANCELLED()) {
            break;
        }

        psf = *((PSHELLFOLDER *) (Pointers.Buf + Pos));

        //
        // Now process the current shell folder
        //

        if ((psf->Name == NULL) || (psf->DestPath == NULL)) {
            //
            // this is an obsolete shell folder structure, leftover from
            // collapsing or collision cleanup
            //
            continue;
        }

        //
        // Was this already processed? If so, skip it.
        //
        MemDbBuildKey (
            Node,
            MEMDB_CATEGORY_SHELL_FOLDERS_MOVED,
            psf->SrcPath,
            NULL,
            NULL
            );

        if (MemDbGetValue (Node, (PDWORD)(&oldPsf))) {

            DEBUGMSG ((DBG_USERLOOP, "%s already moved", psf->SrcPath));
            psf->TempPath = oldPsf->TempPath;

        } else {

            MemDbSetValueEx (
                MEMDB_CATEGORY_SHELL_FOLDERS_MOVED,
                psf->SrcPath,
                NULL,
                NULL,
                (DWORD) psf,
                NULL
                );

            //
            // Now let's enumerate the shell folder content and see if we need
            // to mark some file as moved. We do that if the shell folder
            // is not preserved or if some of the filters modify the name of
            // some files.
            //

            pMoveShellFolder (psf);

            //
            // Now see if this one is in WinNt way. If so, move it to a temporary location.
            //

            if ((!pIsMassiveDir (psf->SrcPath)) &&
                (_totupper (psf->SrcPath[0]) == _totupper (g_WinDir[0]))
                ) {

                StringCopy (uniqueTagName, psf->FixedUserName ? psf->FixedUserName : TEXT(".system"));
                StringCopy (AppendWack (uniqueTagName), psf->Name);

                sequencer = 1;
                numPtr = GetEndOfString (uniqueTagName);

                while (HtFindString (tagNames, uniqueTagName)) {
                    sequencer++;
                    wsprintf (numPtr, TEXT(" %u"), sequencer);
                }

                HtAddString (tagNames, uniqueTagName);

                ComputeTemporaryPathA (
                    psf->SrcPath,
                    psf->SrcPath,
                    uniqueTagName,
                    g_TempDir,
                    TempPath
                    );

                DEBUGMSG ((DBG_USERLOOP, "Moving shell folder %s from %s to %s", psf->Name, psf->SrcPath, TempPath));

                MarkShellFolderForMove (psf->SrcPath, TempPath);
                psf->TempPath = PoolMemDuplicateString (g_SFPool, TempPath);
            }

        }

        //
        // Record the shell folder in all cases, so it can be filtered in GUI mode.
        //

        pRecordUserShellFolder (
            psf->Name,
            psf->FixedUserName,
            psf->TempPath?psf->TempPath:psf->SrcPath,
            psf->SrcPath,
            psf->DestPath
            );

        //
        // check if this SF (or a subdir) is a migration path
        //
        MemDbBuildKey (Node, MEMDB_CATEGORY_SFMIGDIRS, psf->Name, NULL, NULL);
        if (MemDbGetValue (Node, &Levels)) {
            AddMigrationPath (psf->SrcPath, Levels);
        }
        if (MemDbGetValueEx (&enumSF, MEMDB_CATEGORY_SFMIGDIRS, psf->Name, NULL)) {
            do {
                if (enumSF.szName[0]) {
                    MigPath = JoinPaths (psf->SrcPath, enumSF.szName);
                } else {
                    MigPath = psf->SrcPath;
                }
                AddMigrationPath (MigPath, enumSF.dwValue);
                if (enumSF.szName[0]) {
                    FreePathString (MigPath);
                }
            } while (MemDbEnumNextValue (&enumSF));
        }
    }

    //
    // Call filters for global terminate
    //

    Data.Context = GLOBAL_TERMINATE;

    for (Filter = g_Filters ; Filter->Fn ; Filter++) {
        Data.State = Filter->State;
        Filter->Fn (&Data);
    }

    //
    // Clean up
    //

    FreeGrowBuffer (&Pointers);
    HtFree (tagNames);
}


VOID
pMoveUserHive (
    IN      PUSERENUM EnumPtr
    )
{
    //
    // Save the user profile directory name
    //

    MemDbSetValueEx (
        MEMDB_CATEGORY_USER_PROFILE_EXT,
        EnumPtr->FixedUserName,
        NULL,
        EnumPtr->ProfileDirName,
        0,
        NULL
        );

    //
    // Tell winnt.sif to relocate this Win9x user's user.dat. And, if the directory
    // containing user.dat is a per-user profile directory (i.e., if it is a subdir of
    // %WinDir%\profiles, and specifically NOT %WinDir%), then also relocate any files
    // at the same level as user.dat.
    //
    MarkHiveForTemporaryMove (
        EnumPtr->UserDatPath,
        g_TempDir,
        EnumPtr->FixedUserName,
        EnumPtr->DefaultUserHive,
        EnumPtr->CreateAccountOnly
        );
}


DWORD
MigrateShellFolders (
    IN      DWORD     Request
    )
{
    USERENUM e;
    DWORD Ticks;
    TCHAR key [MEMDB_MAX];
    PSHELLFOLDER psf;
    MEMDB_ENUM enumSF;


    if (!g_SFPool) {
        g_SFPool = PoolMemInitNamedPool ("Shell Folders Pool");
        PoolMemDisableTracking (g_SFPool);
    }

    if (Request == REQUEST_QUERYTICKS) {

        Ticks = 0;
        if (EnumFirstUser (&e, ENUMUSER_ENABLE_NAME_FIX)) {
            do {
                Ticks += TICKS_USERPROFILE_MIGRATION;
            } while (EnumNextUser (&e));
        }
        return Ticks ? Ticks : 200;

    } else if (Request != REQUEST_RUN) {
        return ERROR_SUCCESS;
    }


    if (!pCreateSfTables ()) {
        LOG ((LOG_ERROR, "Can't initialize shell folder table"));
        return ERROR_OPEN_FAILED;
    }

    if (!pCreateDirRenameTable ()) {
        LOG ((LOG_ERROR, "Can't create shell folder rename table"));
        return ERROR_OPEN_FAILED;
    }

    pGatherCommonShellFoldersData ();

    TickProgressBar ();

    if (EnumFirstUser (&e, ENUMUSER_ENABLE_NAME_FIX)) {
        do {

            if (!(e.AccountType & INVALID_ACCOUNT)) {

                InitNtUserEnvironment (&e);

                if (e.AccountType & NAMED_USER) {
                    //
                    // Process the shell folders for this migrated user
                    //

                    pGatherUserShellFoldersData (&e);

                } else if ((e.AccountType & DEFAULT_USER) &&
                           (e.AccountType & CURRENT_USER) &&
                           (e.AccountType & ADMINISTRATOR)
                           ) {

                    if (!e.RealAdminAccountExists) {
                        //
                        // Process the shell folders for the default user
                        // (there are no named users)
                        //

                        pGatherUserShellFoldersData (&e);
                    }

                }

                //
                // Move the hive for all valid users
                //
                pMoveUserHive (&e);

                TerminateNtUserEnvironment();

                TickProgressBar ();
            }

        } while (!CANCELLED() && EnumNextUser (&e));
    }

    pProcessShellFoldersInfo();
    pResolveSourceCollisions();

    TickProgressBar ();

    MemDbBuildKey (key, MEMDB_CATEGORY_SF_ORDER_NAME_SRC, TEXT("*"), NULL, NULL);
    if (MemDbEnumFirstValue (&enumSF, key, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
        do {
            psf = (PSHELLFOLDER) enumSF.dwValue;
            if (psf->Name) {
                LOG ((
                    LOG_INFORMATION,
                    "Shell folder: %s\n"
                        "      Status: %s\n"
                        "        User: %s\n"
                        "      Source: %s %s\n"
                        " Destination: %s\n"
                        "    Combined: %s",
                    psf->Name,
                    psf->DestPath ? (StringICompare (psf->SrcPath, psf->DestPath) == 0?TEXT("Preserved"):TEXT("Merged")) : TEXT("Ignored"),
                    psf->FixedUserName ? psf->FixedUserName : TEXT("(all)"),
                    psf->SrcPath,
                    psf->SourceExists ? TEXT("") : TEXT("[does not exist]"),
                    psf->DestPath,
                    psf->MergedIntoOtherShellFolder ? TEXT("YES") : TEXT("NO")
                    ));
            }
        } while (MemDbEnumNextValue (&enumSF));
    }

    //
    // load SF Migration Dirs into memdb, in the temporary hive
    //
    pLoadSFMigDirs ();

    pExecuteShellFoldersMove();

    pDestroySfTables();

    HtFree (g_DirRenameTable);

    PoolMemDestroyPool (g_SFPool);
    g_SFPool = NULL;

    return CANCELLED() ? ERROR_CANCELLED : ERROR_SUCCESS;
}


DWORD
pSendToFilter (
    IN OUT  PPROFILE_MERGE_DATA Data
    )
{
    PCTSTR filePtr;
    static shouldProcess = FALSE;
    INFCONTEXT context;

    switch (Data->Context) {

    case PER_FOLDER_INITIALIZE:
        if (StringIMatch (Data->ShellFolderIdentifier, S_SENDTO)) {
            shouldProcess = TRUE;
        } else {
            shouldProcess = FALSE;
        }
        break;

    case PROCESS_PATH:
        if (shouldProcess) {
            filePtr = GetFileNameFromPath (Data->TempSourcePath);
            if (SetupFindFirstLine (g_Win95UpgInf, S_SENDTO_SUPPRESS, filePtr, &context)) {
                return SHELLFILTER_SKIP_FILE;
            }
        }
        break;

    case PER_FOLDER_TERMINATE:
        shouldProcess = FALSE;
        break;
    }

    return SHELLFILTER_OK;
}

PSTR
pSkipPath (
    IN      PSTR SrcPath,
    IN      PCSTR RootPath
    )
{
    PSTR p;
    PCSTR q;

    p = SrcPath;
    q = RootPath;
    while (_mbsnextc (p) == _mbsnextc (q)) {
        p = _mbsinc (p);
        q = _mbsinc (q);
    }
    if (_mbsnextc (p) == '\\') {
        p = _mbsinc (p);
    }
    return p;
}

DWORD
pDirRenameFilter (
    IN OUT  PPROFILE_MERGE_DATA Data
    )
{
    PSTR wackPtr, dirPtr, pathPtr, NtDir;
    PCSTR searchStr;
    CHAR NewDestPath [MEMDB_MAX] = "";

    switch (Data->Context) {

    case PER_FOLDER_INITIALIZE:
        break;

    case PROCESS_PATH:
        pathPtr = pSkipPath (Data->DestinationPath, Data->DestRootPath);
        StringCopy (NewDestPath, Data->DestRootPath);
        dirPtr = pathPtr;
        wackPtr = _mbschr (pathPtr, '\\');
        if (wackPtr) {
            *wackPtr = 0;
        }
        while (dirPtr) {
            StringCat (NewDestPath, "\\");
            searchStr = JoinPaths (Data->ShellFolderIdentifier, pathPtr);
            if (HtFindStringAndData (g_DirRenameTable, searchStr, &NtDir)) {
                StringCat (NewDestPath, NtDir);
            } else {
                StringCat (NewDestPath, dirPtr);
            }
            FreePathString (searchStr);
            if (wackPtr) {
                *wackPtr = '\\';
                dirPtr = _mbsinc (wackPtr);
                wackPtr = _mbschr (dirPtr, '\\');
                if (wackPtr) {
                    *wackPtr = 0;
                }
            } else {
                dirPtr = NULL;
            }
        }
        _mbssafecpy (Data->DestinationPath, NewDestPath, MEMDB_MAX);
        break;

    case PER_FOLDER_TERMINATE:
        break;
    }

    return SHELLFILTER_OK;
}


DWORD
pKatakanaFilter (
    IN OUT  PPROFILE_MERGE_DATA Data
    )
{
    PCTSTR newName;
    PCTSTR filePtr;

    switch (Data->Context) {

    case PER_FOLDER_INITIALIZE:
        break;

    case PROCESS_PATH:
        //
        // On JPN systems we are going to convert paths from SB Katakana to DB Katakana,
        // starting after the root path of the shell folder.
        //
        if (GetACP() == 932) { // this is only for JPN builds

            //
            // We only do the conversion for directories and for files that are not hidden
            //
            if ((Data->Attributes & FILE_ATTRIBUTE_DIRECTORY) ||
                ((Data->Attributes & FILE_ATTRIBUTE_HIDDEN) == 0)
                ) {
                filePtr = NULL;
            } else {
                filePtr = GetFileNameFromPath (Data->DestinationPath);
            }
            newName = ConvertSBtoDB (Data->DestRootPath, Data->DestinationPath, filePtr);
            _tcssafecpy (Data->DestinationPath, newName, MEMDB_MAX);
            FreePathString (newName);
        }
        break;

    case PER_FOLDER_TERMINATE:
        break;
    }

    return SHELLFILTER_OK;
}


PCTSTR
GenerateNewFileName (
    IN      PCTSTR OldName,
    IN OUT  PWORD Sequencer,
    IN      BOOL CheckExistence
    )
{
    PCTSTR extPtr;
    PTSTR newName;
    PTSTR result;

    extPtr = GetFileExtensionFromPath (OldName);

    if (!extPtr) {
        extPtr = GetEndOfString (OldName);
    }
    else {
        extPtr = _tcsdec (OldName, extPtr);
    }
    newName = DuplicatePathString (OldName, 0);
    result  = DuplicatePathString (OldName, 10);
    StringCopyAB (newName, OldName, extPtr);

    do {
        (*Sequencer) ++;
        wsprintf (result, TEXT("%s (%u)%s"), newName, *Sequencer, extPtr);
    } while ((CheckExistence) && (DoesFileExist (result)));
    FreePathString (newName);
    return result;
}


DWORD
pCollisionDetection (
    IN OUT  PPROFILE_MERGE_DATA Data
    )
{
    WORD Sequencer;
    PCTSTR NewName;
    PCTSTR OldName;
    TCHAR key[MEMDB_MAX];

    switch (Data->Context) {

    case PER_FOLDER_INITIALIZE:
        break;

    case PROCESS_PATH:
        Sequencer = 0;
        NewName = DuplicatePathString (Data->DestinationPath, 0);
        for (;;) {
            MemDbBuildKey (key, MEMDB_CATEGORY_SF_FILES_DEST, NewName, NULL, NULL);
            if (MemDbGetValue (key, NULL)) {
                OldName = NewName;
                NewName = GenerateNewFileName (OldName, &Sequencer, FALSE);
                FreePathString (OldName);
            }
            else {
                MemDbSetValue (key, 0);
                break;
            }
        }
        _tcssafecpy (Data->DestinationPath, NewName, MEMDB_MAX);
        FreePathString (NewName);
        break;

    case PER_FOLDER_TERMINATE:
        break;
    }

    return SHELLFILTER_OK;
}


DWORD
pRecordCacheFolders (
    IN OUT  PPROFILE_MERGE_DATA Data
    )
{
    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;
    PTSTR path;

    switch (Data->Context) {

    case GLOBAL_INITIALIZE:
        //
        // Cleanup is done with a special function below
        //

        g_CacheShellFolders = CreateStringMapping();
        break;

    case PER_FOLDER_INITIALIZE:
        //
        // If this shell folder is in the HtmlCaches list, then add it to the
        // string mapping (mapping it to a static string). The string mapping
        // provides a fast and easy way to test a full file path against a
        // list of directories.
        //

        if (InfFindFirstLine (
                g_Win95UpgInf,
                TEXT("ShellFolders.HtmlCaches"),
                Data->ShellFolderIdentifier,
                &is
                )) {

            path = DuplicatePathString (Data->SrcRootPath, 1);
            AppendWack (path);

            AddStringMappingPair (g_CacheShellFolders, path, TEXT(""));
            DEBUGMSG ((DBG_NAUSEA, "%s is an HTML cache", path));

            FreePathString (path);
        }
        break;
    }

    return SHELLFILTER_OK;
}


VOID
TerminateCacheFolderTracking (
    VOID
    )
{
    if (g_CacheShellFolders) {
        DestroyStringMapping (g_CacheShellFolders);
        g_CacheShellFolders = NULL;
    }
}


PCTSTR
ShellFolderGetPath (
    IN      PUSERENUM EnumPtr,
    IN      PCTSTR ShellFolderId
    )
{
    HKEY sfKey, sfUserKey;
    SF_ENUM e;
    PCTSTR path = NULL;

    //
    // first attempt to get the path from HKR\...\User Shell Folders
    //
    sfUserKey = OpenRegKey (EnumPtr->UserRegKey, S_USHELL_FOLDERS_KEY_USER);
    if (sfUserKey) {
        path = pGetRegValuePath (sfUserKey, ShellFolderId);
        CloseRegKey (sfUserKey);
    }

    //
    // if that fails, try to get it from HKR\...\Shell Folders
    //
    if (!path) {
        sfKey = OpenRegKey (EnumPtr->UserRegKey, S_SHELL_FOLDERS_KEY_USER);
        if (sfKey) {
            path = pGetRegValuePath (sfKey, ShellFolderId);
            CloseRegKey (sfKey);
        }
    }

    //
    // if that fails too, maybe it's a virtual SF
    //
    if (!path) {
        if (!g_SFPool) {
            g_SFPool = PoolMemInitNamedPool ("Shell Folders Pool");
            PoolMemDisableTracking (g_SFPool);
        }
        ZeroMemory (&e, sizeof (e));
        e.EnumPtr = EnumPtr;
        e.enumeratedSf = HtAllocWithData (sizeof (PCTSTR));
        if (pEnumFirstVirtualShellFolder (&e)) {
            do {
                if (StringIMatch (e.sfName, ShellFolderId)) {
                    //
                    // found it
                    //
                    path = DuplicatePathString (e.sfPath, 0);
                    pAbortEnumVirtualShellFolder (&e);
                    break;
                }
            } while (pEnumNextVirtualShellFolder (&e));
        }
    }

    return path;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\sysmig\shares.c ===
#include "pch.h"
#include "sysmigp.h"

// Win95-specific (in the SDK)
#include <svrapi.h>

//
// Types for LAN Man structs
//

typedef struct access_info_2 ACCESS_INFO_2;
typedef struct access_list_2 ACCESS_LIST_2;
typedef struct share_info_50 SHARE_INFO_50;

//
// Flags that help determine when custom access is enabled
//

#define READ_ACCESS_FLAGS   0x0081
#define READ_ACCESS_MASK    0x7fff
#define FULL_ACCESS_FLAGS   0x00b7
#define FULL_ACCESS_MASK    0x7fff



//
// Types for dynamically loading SVRAPI.DLL
//

typedef DWORD(NETSHAREENUM_PROTOTYPE)(
                 const char FAR *     pszServer,
                 short                sLevel,
                 char FAR *           pbBuffer,
                 unsigned short       cbBuffer,
                 unsigned short FAR * pcEntriesRead,
                 unsigned short FAR * pcTotalAvail
                 );
typedef NETSHAREENUM_PROTOTYPE * NETSHAREENUM_PROC;

typedef DWORD(NETACCESSENUM_PROTOTYPE)(
                  const char FAR *     pszServer,
                  char FAR *           pszBasePath,
                  short                fsRecursive,
                  short                sLevel,
                  char FAR *           pbBuffer,
                  unsigned short       cbBuffer,
                  unsigned short FAR * pcEntriesRead,
                  unsigned short FAR * pcTotalAvail
                  );
typedef NETACCESSENUM_PROTOTYPE * NETACCESSENUM_PROC;

HANDLE g_SvrApiDll;
NETSHAREENUM_PROC  pNetShareEnum;
NETACCESSENUM_PROC pNetAccessEnum;

BOOL
pLoadSvrApiDll (
    VOID
    )

/*++

  Routine Description:

    Loads up svrapi.dll if it exsits and obtains the entry points for
    NetShareEnum and NetAccessEnum.

  Arguments:

    none

  Return value:

    TRUE if the DLL was loaded, or FALSE if the DLL could not be loaded
    for any reason.

--*/

{
    BOOL b;

    g_SvrApiDll = LoadLibrary (S_SVRAPI_DLL);
    if (!g_SvrApiDll) {
        return FALSE;
    }

    pNetShareEnum = (NETSHAREENUM_PROC) GetProcAddress (g_SvrApiDll, S_ANSI_NETSHAREENUM);
    pNetAccessEnum = (NETACCESSENUM_PROC) GetProcAddress (g_SvrApiDll, S_ANSI_NETACCESSENUM);

    b = (pNetShareEnum != NULL) && (pNetAccessEnum != NULL);

    if (!b) {
        FreeLibrary (g_SvrApiDll);
        g_SvrApiDll = NULL;
    }

    return b;
}

VOID
pFreeSvrApiDll (
    VOID
    )
{
    if (g_SvrApiDll) {
        FreeLibrary (g_SvrApiDll);
        g_SvrApiDll = NULL;
    }
}


VOID
pAddIncompatibilityAlert (
    DWORD MessageId,
    PCTSTR Share,
    PCTSTR Path
    )
{
    PCTSTR Group;
    PCTSTR Warning;
    PCTSTR Args[2];
    PCTSTR Object;

    Args[0] = Share;
    Args[1] = Path;

    Warning = ParseMessageID (MessageId, Args);
    Group = BuildMessageGroup (MSG_INSTALL_NOTES_ROOT, MSG_NET_SHARES_SUBGROUP, Share);

    Object = JoinPaths (TEXT("*SHARES"), Share);

    MYASSERT (Warning);
    MYASSERT (Group);
    MYASSERT (Object);

    MsgMgr_ObjectMsg_Add (Object, Group, Warning);

    FreeStringResource (Warning);
    FreeText (Group);

    FreePathString (Object);
}


DWORD
pSaveShares (
    VOID
    )

/*++

  Routine Description:

    Enumerates all shares on the machine and saves them to MemDb.

    In password-access mode, the shares are preserved but the passwords
    are not.  An incompatibility message is generated if a password is
    lost.

    In user-level-access mode, the shares are preserved and the name of
    each user who has permission to the share is written to memdb.  If
    the user has custom access permission flags, an incompatibility
    message is generated, and the user gets the least restrictive
    security that matches the custom access flags.

  Arguments:

    none

  Return value:

    TRUE if the shares were enumerated successfully, or FALSE if a failure
    occurs from a Net API.

--*/

{
    CHAR Buf[16384];   // static because NetShareEnum is unreliable
    SHARE_INFO_50 *psi;
    DWORD rc = ERROR_SUCCESS;
    WORD wEntriesRead;
    WORD wEntriesAvailable;
    WORD Flags;
    TCHAR MemDbKey[MEMDB_MAX];
    BOOL LostCustomAccess = FALSE;
    MBCHAR ch;
    PCSTR ntPath;
    BOOL skip;

    if (!pLoadSvrApiDll()) {
        DEBUGMSG ((DBG_WARNING, "SvrApi.Dll was not loaded.  Net shares are not preserved."));
        return ERROR_SUCCESS;
    }

    __try {
        rc = pNetShareEnum (NULL,
                            50,
                            Buf,
                            sizeof (Buf),
                            &wEntriesRead,
                            &wEntriesAvailable
                            );

        if (rc != ERROR_SUCCESS) {
            if (rc == NERR_ServerNotStarted) {

                rc = ERROR_SUCCESS;
                __leave;
            }

            LOG ((LOG_ERROR, "Failure while enumerating network shares."));
            __leave;
        }

        if (wEntriesAvailable != 0 && wEntriesRead != wEntriesAvailable) {

            LOG ((
                LOG_ERROR,
                "Could not read all available shares! Available: %d, Read: %d",
                wEntriesAvailable,
                wEntriesRead
                ));
        }

        while (wEntriesRead) {
            wEntriesRead--;
            psi = (SHARE_INFO_50 *) Buf;
            psi = &psi[wEntriesRead];

            DEBUGMSG ((DBG_NAUSEA, "Processing share %s (%s)", psi->shi50_netname, psi->shi50_path));

            // Require share to be a user-defined, persistent disk share
            if ((psi->shi50_flags & SHI50F_SYSTEM) ||
                !(psi->shi50_flags & SHI50F_PERSIST) ||
                (psi->shi50_type != STYPE_DISKTREE &&
                 psi->shi50_type != STYPE_PRINTQ)
                ) {
                continue;
            }

            //
            // Verify folder will not be in %windir% on NT
            //

            ntPath = GetPathStringOnNt (psi->shi50_path);
            if (!ntPath) {
                MYASSERT (FALSE);
                continue;
            }

            skip = FALSE;

            if (StringIPrefix (ntPath, g_WinDir)) {
                ch = _mbsnextc (ntPath + g_WinDirWackChars - 1);
                if (ch == 0 || ch == '\\') {

                    DEBUGMSG ((DBG_VERBOSE, "Skipping share %s because it is in %%windir%%", psi->shi50_netname));
                    skip = TRUE;
                }
            }

            FreePathString (ntPath);
            if (skip) {
                continue;
            }

            //
            // Process passwords
            //

            if (!(psi->shi50_flags & SHI50F_ACLS)) {
                //
                // Skip if passwords are specified
                //

                if (psi->shi50_rw_password[0] && psi->shi50_ro_password[0]) {
                    LOG ((LOG_WARNING, "Skipping share %s because it is guarded by share-level passwords", psi->shi50_netname));
                    continue;
                }

                if (psi->shi50_rw_password[0] &&
                    (psi->shi50_flags & SHI50F_ACCESSMASK) == SHI50F_FULL
                    ) {
                    LOG ((LOG_WARNING, "Skipping full access share %s because it is guarded by a password", psi->shi50_netname));
                    continue;
                }

                if (psi->shi50_ro_password[0] &&
                    (psi->shi50_flags & SHI50F_ACCESSMASK) == SHI50F_RDONLY
                    ) {
                    LOG ((LOG_WARNING, "Skipping read-only share %s because it is guarded by a password", psi->shi50_netname));
                    continue;
                }
            }

            //
            // Mark directory to be preserved, so we don't delete it if we remove other
            // things and make it empty.
            //

            MarkDirectoryAsPreserved (psi->shi50_path);

            //
            // Save the remark, path, type and access
            //

            MemDbSetValueEx (MEMDB_CATEGORY_NETSHARES, psi->shi50_netname,
                             MEMDB_FIELD_REMARK, psi->shi50_remark,0,NULL);

            MemDbSetValueEx (MEMDB_CATEGORY_NETSHARES, psi->shi50_netname,
                             MEMDB_FIELD_PATH, psi->shi50_path,0,NULL);

            MemDbSetValueEx (MEMDB_CATEGORY_NETSHARES, psi->shi50_netname,
                             MEMDB_FIELD_TYPE, NULL, psi->shi50_type, NULL);

            if ((psi->shi50_flags & SHI50F_ACCESSMASK) == SHI50F_ACCESSMASK) {
                CHAR AccessInfoBuf[16384];
                WORD wItemsAvail, wItemsRead;
                ACCESS_INFO_2 *pai;
                ACCESS_LIST_2 *pal;

                //
                // Obtain entire access list and write it to memdb
                //

                rc = pNetAccessEnum (NULL,
                                     psi->shi50_path,
                                     0,
                                     2,
                                     AccessInfoBuf,
                                     sizeof (AccessInfoBuf),
                                     &wItemsRead,
                                     &wItemsAvail
                                     );

                //
                // If this call fails with not loaded, we have password-level
                // security (so we don't need to enumerate the ACLs).
                //

                if (rc != NERR_ACFNotLoaded) {

                    if (rc != ERROR_SUCCESS) {
                        //
                        //
                        //
                        LOG ((LOG_ERROR, "Failure while enumerating network access for %s, rc=%u", psi->shi50_path, rc));
                        pAddIncompatibilityAlert (
                            MSG_INVALID_ACL_LIST,
                            psi->shi50_netname,
                            psi->shi50_path
                            );

                    } else {
                        int i;

                        if (wItemsAvail != wItemsRead) {
                            LOG ((LOG_ERROR, "More access items are available than what can be listed."));
                        }

                        // An interesting characteristic!
                        DEBUGMSG_IF ((wItemsRead != 1, DBG_WHOOPS, "Warning: wItemsRead == %u", wItemsRead));

                        // Structure has one ACCESS_INFO_2 struct followed by one or more
                        // ACCESS_LIST_2 structs
                        pai = (ACCESS_INFO_2 *) AccessInfoBuf;
                        pal = (ACCESS_LIST_2 *) (&pai[1]);

                        for (i = 0 ; i < pai->acc2_count ; i++) {
                            //
                            // Add incompatibility messages for Custom access rights
                            //

                            DEBUGMSG ((DBG_NAUSEA, "Share %s, Access flags: %x",
                                      psi->shi50_netname, pal->acl2_access));

                            Flags = pal->acl2_access & READ_ACCESS_FLAGS;

                            if (Flags && Flags != READ_ACCESS_FLAGS) {
                                LostCustomAccess = TRUE;
                            }

                            Flags = pal->acl2_access & FULL_ACCESS_FLAGS;

                            if (Flags && Flags != FULL_ACCESS_FLAGS) {
                                LostCustomAccess = TRUE;
                            }

                            //
                            // Write NetShares\<share>\ACL\<user/group> to memdb,
                            // using the 32-bit key value to hold the access flags.
                            //

                            wsprintf (MemDbKey, TEXT("%s\\%s\\%s\\%s"), MEMDB_CATEGORY_NETSHARES,
                                      psi->shi50_netname, MEMDB_FIELD_ACCESS_LIST, pal->acl2_ugname);

                            MemDbSetValue (MemDbKey, pal->acl2_access);

                            //
                            // Write to KnownDomain\<user/group> unless the user or group
                            // is an asterisk.
                            //

                            if (StringCompare (pal->acl2_ugname, TEXT("*"))) {
                                MemDbSetValueEx (
                                    MEMDB_CATEGORY_KNOWNDOMAIN,
                                    pal->acl2_ugname,
                                    NULL,
                                    NULL,
                                    0,
                                    NULL
                                    );
                            }

                            pal++;
                        }

                        psi->shi50_flags |= SHI50F_ACLS;
                    }
                }
            }

            //
            // Write share flags (SHI50F_*)
            //

            wsprintf (MemDbKey, TEXT("%s\\%s"), MEMDB_CATEGORY_NETSHARES, psi->shi50_netname);
            if (!MemDbSetValue (MemDbKey, psi->shi50_flags)) {
                LOG ((LOG_ERROR, "Failure while saving share information to database."));
            }

            if (!(psi->shi50_flags & SHI50F_ACLS)) {
                //
                // Write password-level permissions
                //

                if (psi->shi50_rw_password[0]) {
                    MemDbSetValueEx (MEMDB_CATEGORY_NETSHARES, psi->shi50_netname,
                                     MEMDB_FIELD_RW_PASSWORD, psi->shi50_rw_password,
                                     0,NULL);
                }

                if (psi->shi50_ro_password[0]) {
                    MemDbSetValueEx (MEMDB_CATEGORY_NETSHARES, psi->shi50_netname,
                                     MEMDB_FIELD_RO_PASSWORD, psi->shi50_ro_password,
                                     0,NULL);
                }

                if (psi->shi50_ro_password[0] || psi->shi50_rw_password[0]) {
                    pAddIncompatibilityAlert (
                        MSG_LOST_SHARE_PASSWORDS,
                        psi->shi50_netname,
                        psi->shi50_path
                        );
                }
            }

            if (LostCustomAccess) {
                LostCustomAccess = FALSE;
                pAddIncompatibilityAlert (
                    MSG_LOST_ACCESS_FLAGS,
                    psi->shi50_netname,
                    psi->shi50_path
                    );
            }

            rc = ERROR_SUCCESS;
        }
    }
    __finally {
        pFreeSvrApiDll();
    }

    return rc;
}


DWORD
SaveShares (
    IN      DWORD Request
    )
{
    switch (Request) {
    case REQUEST_QUERYTICKS:
        return TICKS_SAVE_SHARES;
    case REQUEST_RUN:
        return pSaveShares ();
    default:
        DEBUGMSG ((DBG_ERROR, "Bad parameter in SaveShares"));
    }
    return 0;
}


VOID
WkstaMig (
    VOID
    )

/*++

  Routine Description:

    This routine provides a single location to add additional routines
    needed to perform workstation migration.

  Arguments:

    none

  Return value:

    none - Error path is not yet implemented.

--*/

{
    if (pSaveShares() != ERROR_SUCCESS) {
        DEBUGMSG ((DBG_WHOOPS, "SaveShares failed, error ignored."));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\sysmig\timezone.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    timezone.c

Abstract:

    This module is responsible for managing the mapping of timezones from windows 9x to
    windows Nt. Because of the fact that the timezone strings are different between the
    several different platforms (Win9x Win98 WinNt) and because it is important to end
    users that there timezone setting accurately reflect there geographic location, a
    somewhat complex method of mapping timezones is needed.


Author:

    Marc R. Whitten (marcw) 09-Jul-1998

Revision History:

    marcw       18-Aug-1998 Added timezone enum, support for retaining
                            fixed matches.

--*/

#include "pch.h"


#define DBG_TIMEZONE "TimeZone"


#define S_FIRSTBOOT TEXT("!!!First Boot!!!")

TCHAR g_TimeZoneMap[20] = TEXT("");
TCHAR g_CurrentTimeZone[MAX_TIMEZONE] = TEXT("");
BOOL  g_TimeZoneMapped = FALSE;



//
// Variable used by tztest tool.
//
HANDLE g_TzTestHiveSftInf = NULL;

BOOL
pBuildNtTimeZoneData (
    VOID
    )


/*++

Routine Description:

  pBuildNtTimeZone data reads the timezone information that is stored in
  hivesft.inf and organizes it into memdb. This data is used to look up
  display names of timezone indices.

Arguments:

  None.

Return Value:

  TRUE if the function completes successfully, FALSE
  otherwise.


--*/


{
    HINF inf = INVALID_HANDLE_VALUE;
    INFSTRUCT is = INITINFSTRUCT_POOLHANDLE;
    BOOL rSuccess = FALSE;
    PTSTR key = NULL;
    PTSTR value = NULL;
    PTSTR desc = NULL;
    PTSTR index = NULL;
    BOOL timeZonesFound = FALSE;
    TCHAR paddedIndex[20];
    PTSTR p = NULL;
    UINT i = 0;
    UINT count = 0;

    if (!g_TzTestHiveSftInf) {
        //
        // First, Read data from hivesft.inf.
        //
        inf = InfOpenInfInAllSources (S_HIVESFT_INF);
    }
    else {

        inf = g_TzTestHiveSftInf;
    }

    if (inf == INVALID_HANDLE_VALUE) {
        LOG ((LOG_ERROR, "Cannot load hivesoft.inf. Unable to build timezone information." ));
        return FALSE;
    }


    if (InfFindFirstLine (inf, S_ADDREG, NULL, &is)) {

        do {

            //
            // Cycle through all of the lines looking for timezone information.
            //
            key = InfGetStringField (&is, 2);

            if (key && IsPatternMatch (TEXT("*Time Zones*"), key)) {

                //
                // Remember that we have found the first timezone entry.
                //
                timeZonesFound = TRUE;

                //
                // Now, get value. We care about "display" and "index"
                //
                value = InfGetStringField (&is, 3);

                if (!value) {
                    continue;
                }

                if (StringIMatch (value, S_DISPLAY)) {

                    //
                    // display string found.
                    //
                    desc = InfGetStringField (&is, 5);

                } else if (StringIMatch (value, S_INDEX)) {

                    //
                    // index value found.
                    //
                    index = InfGetStringField (&is, 5);
                }

                if (index && desc) {

                    //
                    // Make sure the index is 0 padded.
                    //
                    count = 3 - TcharCount (index);
                    p = paddedIndex;
                    for (i=0; i<count; i++) {
                        *p = TEXT('0');
                        p = _tcsinc (p);
                    }
                    StringCopy (p, index);

                    //
                    // we have all the information we need. Save this entry into memdb.
                    //
                    MemDbSetValueEx (MEMDB_CATEGORY_NT_TIMEZONES, paddedIndex, desc, NULL, 0, NULL);
                    index = NULL;
                    desc = NULL;

                }

            } else {

                //
                // Keep memory usage low.
                //
                InfResetInfStruct (&is);

                if (key) {
                    if (timeZonesFound) {
                        //
                        // We have gathered all of the timezone information from hivesft.inf
                        // we can abort our loop at this point.
                        //
                        break;
                    }
                }
            }

        } while (InfFindNextLine(&is));

    } ELSE_DEBUGMSG ((DBG_ERROR, "[%s] not found in hivesft.inf!",S_ADDREG));


    //
    // Clean up resources
    //
    InfCleanUpInfStruct (&is);
    InfCloseInfFile (inf);


    return TRUE;

}

BOOL
pBuild9xTimeZoneData (
    VOID
    )

/*++

Routine Description:

  pBuild9xTimeZone Data is responsible for reading the time zone information
  that is stored in win95upg.inf and organizing it into memdb. The timezone
  enumeration routines then use this data in order to find all Nt timezones
  that can map to a particular 9x timezone.

Arguments:

  None.

Return Value:

  TRUE if the data is successfully stored in memdb, FALSE
  otherwise.


--*/


{

    INFSTRUCT is = INITINFSTRUCT_POOLHANDLE;
    PTSTR desc = NULL;
    PTSTR index = NULL;
    UINT count = 0;
    PTSTR p = NULL;

    //
    // Now, read in information about win9x registry mappings.
    //
    if (InfFindFirstLine (g_Win95UpgInf, S_TIMEZONEMAPPINGS, NULL, &is)) {

        do {

            //
            // Get the display name and matching index(es) for this timezone.
            //
            desc  = InfGetStringField (&is,0);
            index = InfGetStringField (&is,1);

            //
            // Enumerate the indices and save them into memdb.
            //
            count = 0;
            while (index) {

                p = _tcschr (index, TEXT(','));
                if (p) {

                    *p = 0;
                }

                MemDbSetValueEx (
                    MEMDB_CATEGORY_9X_TIMEZONES,
                    desc,
                    MEMDB_FIELD_INDEX,
                    index,
                    0,
                    NULL
                    );

                count++;

                if (p) {
                    index = _tcsinc(p);
                }
                else {
                    //
                    // Save away the count of possible nt timezones for this 9x timezone.
                    //

                    MemDbSetValueEx (
                        MEMDB_CATEGORY_9X_TIMEZONES,
                        desc,
                        MEMDB_FIELD_COUNT,
                        NULL,
                        count,
                        NULL
                        );

                    index = NULL;
                }
            }

        } while (InfFindNextLine (&is));

    }

    //
    // Clean up resources.
    //
    InfCleanUpInfStruct (&is);

    return TRUE;
}


BOOL
pGetCurrentTimeZone (
    VOID
    )

/*++

Routine Description:

  pGetCurrentTimeZone retrieves the user's timezone from the windows 9x
  registry. The enumeration routines use this timezone in order to enumerate
  the possible matching timezones in the INF.

Arguments:

  None.

Return Value:

  TRUE if the function successfully retrieves the user's password, FALSE
  otherwise.

--*/


{
    BOOL rSuccess = TRUE;
    PCTSTR displayName = NULL;
    REGTREE_ENUM eTree;
    PCTSTR valueName = NULL;
    PCTSTR value = NULL;
    PCTSTR curTimeZone = NULL;
    HKEY  hKey = NULL;




    //
    // Get the current timezone name, and set the valuename to the correct string.
    //
    hKey = OpenRegKeyStr (S_TIMEZONEINFORMATION);

    if (!hKey) {

        LOG ((LOG_ERROR, "Unable to open %s key.", S_TIMEZONEINFORMATION));
        return FALSE;
    }


    if ((curTimeZone = GetRegValueString (hKey, S_STANDARDNAME)) && !StringIMatch (curTimeZone, S_FIRSTBOOT)) {

        //
        // standard time. We need to look under the "STD" value to match this.
        //
        valueName = S_STD;

    } else if ((curTimeZone = GetRegValueString (hKey, S_DAYLIGHTNAME)) && !StringIMatch (curTimeZone, S_FIRSTBOOT)) {

        //
        // Daylight Savings Time. We need to look under the "DLT" value to match this.
        //
        valueName = S_DLT;

    } else {

        CloseRegKey (hKey);
        hKey = OpenRegKeyStr (TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Time Zones"));
        if (hKey) {

            if (curTimeZone = GetRegValueString (hKey, TEXT(""))) {
                valueName = S_STD;
            }

        }

        if (!valueName) {

            //
            // No timezone found!
            //
            DEBUGMSG((DBG_WHOOPS,"Unable to get Timezone name..User will have to enter timezone in GUI mode."));
            return FALSE;
        }
    }
    __try {

        //
        // Now we have to search through the timezones key and find the key that has a value equal to
        // the current timezone name. A big pain.
        //
        if (EnumFirstRegKeyInTree (&eTree, S_TIMEZONES)) {
            do {

                //
                // For each subkey, we must look for the string in valueName and
                // see if it matches.
                //
                value = GetRegValueString (eTree.CurrentKey->KeyHandle, valueName);
                if (value) {

                    if (StringIMatch (value, curTimeZone)) {

                        //
                        // We found the key we were looking for and we can finally
                        // gather the data we need.
                        //
                        displayName = GetRegValueString (eTree.CurrentKey->KeyHandle, S_DISPLAY);
                        if (!displayName) {
                            DEBUGMSG((DBG_WHOOPS,"Error! Timezone key found, but no Display value!"));
                            AbortRegKeyTreeEnum (&eTree);
                            rSuccess = FALSE;
                            __leave;
                        }

                        //
                        // Save away the current Timezone and leave the loop. We are done.
                        //
                        StringCopy (g_CurrentTimeZone, displayName);
                        AbortRegKeyTreeEnum (&eTree);
                        break;
                    }
                    MemFree (g_hHeap, 0, value);
                    value = NULL;

                }

            } while (EnumNextRegKeyInTree (&eTree));
        }

    } __finally {

        if (curTimeZone) {
            MemFree (g_hHeap, 0, curTimeZone);
        }

        if (value) {
            MemFree (g_hHeap, 0, value);
        }

        if (displayName) {
            MemFree (g_hHeap, 0, displayName);
        }

        CloseRegKey (hKey);
    }

    return rSuccess;
}




BOOL
pInitTimeZoneData (
    VOID
    )

/*++

Routine Description:

  pInitTimeZoneData is responsible for performing all of the initialization
  necessary to use the time zone enumeration routines.

Arguments:

  None.

Return Value:

  TRUE if initialization completes successfully, FALSE otherwise.

--*/


{
    BOOL rSuccess = TRUE;

    //
    // First, fill memdb with timezone
    // information regarding winnt and win9x
    // (from hivesft.inf and win95upg.inf)
    //
    if (!pBuildNtTimeZoneData ()) {

        LOG ((LOG_ERROR, "Unable to gather nt timezone information."));
        rSuccess = FALSE;
    }

    if (!pBuild9xTimeZoneData ()) {

        LOG ((LOG_ERROR, "Unable to gather 9x timezone information."));
        rSuccess = FALSE;
    }

    //
    // Next, get the user's timezone.
    //
    if (!pGetCurrentTimeZone ()) {
        LOG ((LOG_ERROR, "Failure trying to retrieve timezone information."));
        rSuccess = FALSE;
    }

    return rSuccess;

}

BOOL
pEnumFirstNtTimeZone (
    OUT PTIMEZONE_ENUM EnumPtr
    )
{
    BOOL rSuccess = FALSE;
    PTSTR p;

    EnumPtr -> MapCount = 0;
    if (MemDbEnumFirstValue (&(EnumPtr -> Enum), MEMDB_CATEGORY_NT_TIMEZONES"\\*", MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
        do {
            EnumPtr -> MapCount++;
        } while (MemDbEnumNextValue (&(EnumPtr -> Enum)));
    }
    else {
        return FALSE;
    }

    MemDbEnumFirstValue (&(EnumPtr -> Enum), MEMDB_CATEGORY_NT_TIMEZONES"\\*", MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY);

    p = _tcschr (EnumPtr->Enum.szName,TEXT('\\'));
    if (!p) {
        return FALSE;
    }

    *p = 0;
    EnumPtr -> MapIndex = EnumPtr -> Enum.szName;
    StringCopy (EnumPtr -> NtTimeZone, _tcsinc(p));

    return TRUE;
}


BOOL
pEnumNextNtTimeZone (
    OUT PTIMEZONE_ENUM EnumPtr
    )
{

    PTSTR p;

    if (!MemDbEnumNextValue(&EnumPtr -> Enum)) {
        return FALSE;
    }

    p = _tcschr (EnumPtr->Enum.szName,TEXT('\\'));
    if (!p) {
        return FALSE;
    }

    *p = 0;
    EnumPtr -> MapIndex = EnumPtr -> Enum.szName;
    StringCopy (EnumPtr -> NtTimeZone, _tcsinc(p));

    return TRUE;

}


BOOL
EnumFirstTimeZone (
    OUT PTIMEZONE_ENUM EnumPtr,
    IN  DWORD          Flags
    )

/*++

Routine Description:

  EnumFirstTimeZone/EnumNextTimeZone enumerate the Nt timezones that can match the
  user's current Windows 9x time zone. In most cases, there will be only one,
  but, in some cases, there can be several.

Arguments:

  EnumPtr - A pointer to a valid timezone enumeration structure. This
            variable holds the necessary state between timezone enumeration
            calls.

Return Value:

  TRUE if there are any timezones to enumerate, FALSE otherwise.

--*/


{
    BOOL rSuccess = FALSE;
    TCHAR key[MEMDB_MAX];
    static BOOL firstTime = TRUE;

    if (firstTime) {
        if (!pInitTimeZoneData ()) {
            LOG ((LOG_ERROR, "Error initializing timezone data."));
            return FALSE;
        }

        firstTime = FALSE;
    }

    MYASSERT (EnumPtr);

    EnumPtr -> CurTimeZone = g_CurrentTimeZone;
    EnumPtr -> Flags = Flags;

    if (Flags & TZFLAG_ENUM_ALL) {
        return pEnumFirstNtTimeZone (EnumPtr);
    }


    if ((Flags & TZFLAG_USE_FORCED_MAPPINGS) && g_TimeZoneMapped) {

        //
        // We have a force mapping, so mapcount is 1.
        //
        EnumPtr -> MapCount = 1;
    }
    else {

        //
        // Get count of matches.
        //
        MemDbBuildKey (key, MEMDB_CATEGORY_9X_TIMEZONES, EnumPtr -> CurTimeZone, MEMDB_FIELD_COUNT, NULL);

        if (!MemDbGetValue (key, &(EnumPtr -> MapCount))) {

            DEBUGMSG ((
                DBG_WARNING,
                "EnumFirstTimeZone: Could not retrieve count of nt timezone matches from memdb for %s.",
                EnumPtr -> CurTimeZone
                ));

            return FALSE;
        }
    }

    DEBUGMSG ((DBG_TIMEZONE, "%d Nt time zones match the win9x timezone %s.", EnumPtr -> MapCount, EnumPtr -> CurTimeZone));


    if ((Flags & TZFLAG_USE_FORCED_MAPPINGS) && g_TimeZoneMapped) {

        //
        // Use the previously forced mapping.
        //
        EnumPtr -> MapIndex = g_TimeZoneMap;


    } else {


        //
        // Now, enumerate the matching map indexes in memdb.
        //
        rSuccess = MemDbGetValueEx (
                        &(EnumPtr -> Enum),
                        MEMDB_CATEGORY_9X_TIMEZONES,
                        EnumPtr -> CurTimeZone,
                        MEMDB_FIELD_INDEX
                        );

        if (!rSuccess) {
            return FALSE;
        }


        EnumPtr -> MapIndex = EnumPtr -> Enum.szName;


    }

    //
    // Get the NT display string for this map index.
    //

    rSuccess = MemDbGetEndpointValueEx (MEMDB_CATEGORY_NT_TIMEZONES, EnumPtr->MapIndex, NULL, EnumPtr->NtTimeZone);

    return  rSuccess;
}



BOOL
EnumNextTimeZone (
    IN OUT PTIMEZONE_ENUM EnumPtr
    )

{

    if (EnumPtr -> Flags & TZFLAG_ENUM_ALL) {
        return pEnumNextNtTimeZone (EnumPtr);
    }

    if ((EnumPtr -> Flags & TZFLAG_USE_FORCED_MAPPINGS) && g_TimeZoneMapped) {
        return FALSE;
    }

    if (!MemDbEnumNextValue (&(EnumPtr->Enum))) {
        return FALSE;
    }

    EnumPtr->MapIndex = EnumPtr->Enum.szName;

    return MemDbGetEndpointValueEx (MEMDB_CATEGORY_NT_TIMEZONES, EnumPtr->MapIndex, NULL, EnumPtr->NtTimeZone);

}

BOOL
ForceTimeZoneMap (
    IN PCTSTR NtTimeZone
    )

/*++

Routine Description:

  ForceTimeZoneMap forces the mapping of a particular 9x timezone to a
  particular Nt timezone. This function is used in cases where there are
  multiple nt timezones that could map to a particular 9x timezone.

Arguments:

  NtTimeZone - String containing the timezone to force mapping to.

Return Value:

  TRUE if the function successfully updated the timezone mapping, FALSE
  otherwise.

--*/


{
    TIMEZONE_ENUM e;
    //
    // Find index that matches this timezone.
    //

    if (EnumFirstTimeZone (&e, TZFLAG_ENUM_ALL)) {

        do {

            if (StringIMatch (NtTimeZone, e.NtTimeZone)) {

                //
                // this is the index we need.
                //

                StringCopy (g_TimeZoneMap, e.MapIndex);
                g_TimeZoneMapped = TRUE;

                 break;

            }

        } while (EnumNextTimeZone (&e));
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\ui\msgmgr.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    MsgMgr.c

Abstract:

    Message Manager allows messages to be conditioned on some setup event.
    Messages are of two kinds:

        1)  Those that depend on the migration status of ONE system object
            -- a directory or registry key, for example.

        2)  Those that depend on GROUPS of objects.

    We're using the phrase "Handleable Object" (HO) to mean something in the
    Win95 system capable of having a migration status -- of being "handled."
    HOs can be either files, directories, or registry keys with optional value
    names.  HOs are always stored as strings. In the case of registry keys,
    strings are always "encoded" to guarantee they contain only lower-ANSI
    printable chars.

    A "Conditional Message Context" (or Context) is the association between
    one or more HOs and a message, which will be printed if all HOs are not
    eventually handled.

    A message has two parts: a title (called "Component")
    describe the group of HOs and an associated message, which is to be printed
    if the HOs are not all marked "handled".

    An Object Message Block (OMB) is a structure that
    describes the pairing of a HO with either a Context or a message.

    The string table 'g_HandledObjects' records which HOs are handled.

    Here are the Message Manager's externally visible functions:

    MsgMgr_Init()

        Called once at the start of Win9x setup to initialize Message Manager.

    MsgMgr_Cleanup()

        Called once in Win9x setup, after software-incompatibility message have
        been displayed. Frees the resources owned by Message Manager.

    MsgMgr_ContextMsg_Add(
            ContextName,     // Context, e.g., "Plugin[Corel][Draw]"
            ComponentName,   // Message title, e.g., "Corel Draw"
            Message);        // Message text, e.g., "Corel Draw doesn't..."

        Creates a context and message text.

    MsgMgr_LinkObjectWithContext(
            ContextName,     // Context
            ObjectName);     // HO

        Records the fact that the context message depends on the handled
        state of the HO, ObjectName.

    MsgMgr_ObjectMsg_Add(
            ObjectName,      // HO, e.g., C:\\corel\draw.exe
            ComponentName,   // Message title, e.g., "Corel Draw"
            Message);        // Message text, e.g., "Draw.exe doesn't ..."

        Associates a message with a single HO.

    IsReportObjectHandled (Object)
            Checks to see if a specific object has been marked as handled.

    IsReportObjectIncompatible (Object)
            Checks to see if a specific object is in the list of incompatible objects.

  Implementation:

    Contexts are stored in StringTables. The Context name is the
    key; pointers to the component name and message text are in extra data.

    The association between HOs, on one hand, and contexts and messages on
    the other, is stored in a table of Object Message Blocks, or OMBs.

    During Win9x setup, OMBs are added, and objects are independently
    marked as "handled". When all info has been collected, the list of
    handled objects is compared with the list of OMBs. Object messages are
    displayed if their object has not been handled; Context messages are
    displayed if at least SOME of their objects have not been handled.

Author:

    Mike Condra 20-May-1997

Revision History:

    marcw       08-Mar-1999 Added support for handling Answer File items.
    jimschm     15-Jan-1999 Moved code from migdll9x.c to here (more centralized)
    jimschm     23-Dec-1998 Cleaned up
    jimschm     23-Sep-1998 Revised to use new fileops
    calinn      15-Jan-1997 Modified MsgMgr_ObjectMsg_Add to get a null message
    mikeco      24-Sep-1997 Re-enabled context message code
    marcw       21-Jul-1997 Added IsIncompatibleObject/IsReportObjectHandled functions.

--*/

#include "pch.h"
#include "uip.h"

#define DBG_MSGMGR "MsgMgr"

#define S_MSG_STRING_MAPS TEXT("Report String Mappings")


typedef struct {
    PCTSTR Component;
    PCTSTR Message;
} CONTEXT_DATA, *P_CONTEXT_DATA;

//
// Object Message Block (OMBs). An OMB describes a Handleable Object's relation to a
// message. Either the OMB itself contains a message, or it points to a context with a
// message.

// For Handleable Object there is at most one OMB with a message. This amounts to saying
// that Handleable Objects have only one message. However, Handleable Objects may refer
// to (i.e., participate in) more than one context.
//
typedef struct {
    // Flags that are set in the process of deciding when a context's message should
    // be displayed.
    BOOL Disabled;
    PTSTR Object;
    PTSTR Context;
    PTSTR Component;
    PTSTR Description;
} OBJ_MSG_BLOCK, *P_OBJ_MSG_BLOCK;


////////////////////// PUBLIC INTERFACE DESCRIPTION //////////////////////////
//
// Defined for callers in inc\msgmgr.c
//

//
// Function marks an object as "handled"
//


DWORD
pDfsGetFileAttributes (
    IN      PCTSTR Object
    );


HASHTABLE g_ContextMsgs = NULL;
HASHTABLE g_LinkTargetDesc = NULL;
PVOID g_MsgMgrPool = NULL;
HASHTABLE g_HandledObjects = NULL;
HASHTABLE g_BlockingObjects = NULL;
HASHTABLE g_ElevatedObjects = NULL;
INT g_OmbEntriesMax = 0;
INT g_OmbEntries = 0;
P_OBJ_MSG_BLOCK *g_OmbList = NULL;
BOOL g_BlockingAppFound = FALSE;
PMAPSTRUCT g_MsgMgrMap = NULL;


BOOL
pAddBadSoftwareWrapper (
    IN  PCTSTR Object,
    IN  PCTSTR Component,
    IN  PCTSTR Message
    )
{
    DWORD offset;
    BOOL includeInShortReport = FALSE;

    if (HtFindString (g_BlockingObjects, Object)) {
        g_BlockingAppFound = TRUE;
    }

    if (HtFindString (g_ElevatedObjects, Object)) {
        includeInShortReport = TRUE;
    }

    //
    // add this info to memdb first
    //
    MemDbSetValueEx (MEMDB_CATEGORY_COMPATREPORT, MEMDB_ITEM_COMPONENTS, Component, NULL, 0, &offset);
    MemDbSetValueEx (MEMDB_CATEGORY_COMPATREPORT, MEMDB_ITEM_OBJECTS, Object, NULL, offset, NULL);

    return AddBadSoftware (Component, Message, includeInShortReport);
}


typedef enum {
    OT_FILE,
    OT_DIRECTORY,
    OT_REGISTRY,
    OT_INIFILE,
    OT_GUID,
    OT_USERNAME,
    OT_REPORT,
    OT_ANSWERFILE,
    OT_BADGUID
} OBJECT_TYPE;

VOID
pOmbAdd(
        IN PCTSTR Object,
        IN PCTSTR Context,
        IN PCTSTR Component,
        IN PCTSTR Description
        );

VOID
pSuppressObjectReferences (
    VOID
    );

VOID
pDisplayObjectMsgs (
    VOID
    );

BOOL
pFindLinkTargetDescription(
    IN      PCTSTR Target,
    OUT     PCTSTR* StrDesc
    );

BOOL
IsWacked(
    IN PCTSTR str
    );



BOOL
pTranslateThisRoot (
    PCSTR UnFixedRegKey,
    PCSTR RootWithWack,
    PCSTR NewRoot,
    PSTR *FixedRegKey
    )
{
    UINT RootByteLen;

    RootByteLen = ByteCountA (RootWithWack);

    if (StringIMatchByteCountA (RootWithWack, UnFixedRegKey, RootByteLen)) {

        *FixedRegKey = DuplicateTextA (UnFixedRegKey);
        StringCopyA (*FixedRegKey, NewRoot);
        StringCopyA (AppendWackA (*FixedRegKey), (PCSTR) ((PBYTE) UnFixedRegKey + RootByteLen));

        return TRUE;
    }

    return FALSE;
}


PSTR
pTranslateRoots (
    PCSTR UnFixedRegKey
    )
{
    PSTR FixedRegKey;

    if (pTranslateThisRoot (UnFixedRegKey, "HKEY_LOCAL_MACHINE\\", "HKLM", &FixedRegKey) ||
        pTranslateThisRoot (UnFixedRegKey, "HKEY_CLASSES_ROOT\\", "HKLM\\Software\\Classes", &FixedRegKey) ||
        pTranslateThisRoot (UnFixedRegKey, "HKCR\\", "HKLM\\Software\\Classes", &FixedRegKey) ||
        pTranslateThisRoot (UnFixedRegKey, "HKEY_ROOT\\", "HKR", &FixedRegKey) ||
        pTranslateThisRoot (UnFixedRegKey, "HKEY_CURRENT_USER\\", "HKR", &FixedRegKey) ||
        pTranslateThisRoot (UnFixedRegKey, "HKCU\\", "HKR", &FixedRegKey) ||
        pTranslateThisRoot (UnFixedRegKey, "HKEY_CURRENT_CONFIG\\", "HKLM\\System\\CurrentControlSet", &FixedRegKey) ||
        pTranslateThisRoot (UnFixedRegKey, "HKCC\\", "HKLM\\System\\CurrentControlSet", &FixedRegKey)
        ) {
        FreeText (UnFixedRegKey);
        return FixedRegKey;
    }

    return (PSTR) UnFixedRegKey;
}

VOID
ElevateObject (
    IN      PCTSTR Object
    )

/*++

Routine Description:

  ElevateObject puts a file in the elevated object table, so that
  it will always appear on the short version of the report summary.

Arguments:

  Object - Specifies a caller-encoded object string

Return Value:

  None.

--*/

{
    HtAddString (g_ElevatedObjects, Object);
}


VOID
HandleReportObject (
    IN      PCTSTR Object
    )

/*++

Routine Description:

  HandleReportObject adds a caller-encoded object string to the handled hash
  table.  This causes any message for the object to be suppressed.

Arguments:

  Object - Specifies a caller-encoded object string

Return Value:

  None.

--*/

{
    HtAddString (g_HandledObjects, Object);
}


VOID
AddBlockingObject (
    IN      PCTSTR Object
    )

/*++

Routine Description:

  AddBlockingObject adds a file to be a blocking file. If this file is not handled there
  will be a warning box after user report page.

Arguments:

  Object - Specifies a caller-encoded object string

Return Value:

  None.

--*/

{
    HtAddString (g_BlockingObjects, Object);
}


VOID
HandleObject(
    IN      PCTSTR Object,
    IN      PCTSTR ObjectType
    )

/*++

Routine Description:

  HandleObject adds a caller-encoded object string to the handled hash table,
  and also marks a file as handled in fileops, if Object is a file.

Arguments:

  Object - Specifies a caller-encoded object string

  ObjectType - Specifies the object type (File, Directory, Registry, Report)

Return Value:

  None.

--*/

{
    DWORD Attribs;
    OBJECT_TYPE Type;
    PTSTR p;
    TCHAR LongPath[MAX_TCHAR_PATH];
    BOOL SuppressRegistry = TRUE;
    CHAR IniPath[MAX_MBCHAR_PATH * 2];
    BOOL IniSaved;
    PCSTR ValueName, SectionName;
    TCHAR Node[MEMDB_MAX];
    PTSTR FixedObject;
    TREE_ENUM Files;
    DWORD attribs;

    if (StringIMatch (ObjectType, TEXT("File"))) {

        Type = OT_FILE;

    } else if (StringIMatch (ObjectType, TEXT("Directory"))) {

        Type = OT_DIRECTORY;

    } else if (StringIMatch (ObjectType, TEXT("Registry"))) {

        Type = OT_REGISTRY;

    } else if (StringIMatch (ObjectType, TEXT("IniFile"))) {

        Type = OT_INIFILE;

    } else if (StringIMatch (ObjectType, TEXT("GUID"))) {

        Type = OT_GUID;

    } else if (StringIMatch (ObjectType, TEXT("BADGUID"))) {

        Type = OT_BADGUID;

    } else if (StringIMatch (ObjectType, TEXT("UserName"))) {

        Type = OT_USERNAME;

    } else if (StringIMatch (ObjectType, TEXT("Report"))) {

        Type = OT_REGISTRY;
        SuppressRegistry = FALSE;

    } else if (StringIMatch (ObjectType, TEXT("AnswerFile"))) {

        Type = OT_ANSWERFILE;

    } else {

        DEBUGMSG ((DBG_ERROR, "Object %s ignored; invalid object type: %s", Object, ObjectType));
        return;

    }

    if (Type == OT_FILE || Type == OT_DIRECTORY) {

        if (!OurGetLongPathName (
                Object,
                LongPath,
                sizeof (LongPath) / sizeof (LongPath[0])
                )) {

            DEBUGMSG ((DBG_ERROR, "Object %s ignored; invalid path", Object));
            return;

        }

        Attribs = pDfsGetFileAttributes (LongPath);

        if (Attribs != INVALID_ATTRIBUTES && !(Attribs & FILE_ATTRIBUTE_DIRECTORY)) {

            //
            // It's got to be a file, not a directory!
            //

            DontTouchThisFile (LongPath);
            MarkPathAsHandled (LongPath);
            MarkFileForBackup (LongPath);
            DEBUGMSG ((DBG_MSGMGR, "Backing up %s", LongPath));

        } else if (Attribs != INVALID_ATTRIBUTES) {

            //
            // LongPath is a directory.  If its the root, %windir%, %windir%\system or
            // Program Files, then ignore it.
            //

            p = _tcschr (LongPath, TEXT('\\'));
            if (p) {
                p = _tcschr (p + 1, TEXT('\\'));
            }

            if (!p) {
                DEBUGMSG ((DBG_ERROR, "Object %s ignored, can't handle root dirs", Object));
                return;
            }

            if (!StringIMatchA (LongPath, g_WinDir) &&
                !StringIMatchA (LongPath, g_SystemDir) &&
                !StringIMatchA (LongPath, g_ProgramFilesDir)
                ) {

                if (IsDriveExcluded (LongPath)) {
                    DEBUGMSG ((DBG_WARNING, "Skipping handled dir %s because it is excluded", LongPath));
                } else if (!IsDriveAccessible (LongPath)) {
                    DEBUGMSG ((DBG_WARNING, "Skipping handled dir %s because it is not accessible", LongPath));
                } else {

                    //
                    // Let's enumerate this tree and do the right thing
                    //
                    if (EnumFirstFileInTree (&Files, LongPath, NULL, TRUE)) {
                        do {
                            DontTouchThisFile (Files.FullPath);
                            MarkPathAsHandled (Files.FullPath);

                            //
                            // back up file, or make sure empty dir is restored
                            //

                            if (g_ConfigOptions.EnableBackup != TRISTATE_NO) {

                                if (!Files.Directory) {
                                    DEBUGMSG ((DBG_MSGMGR, "Backing up %s", Files.FullPath));
                                    MarkFileForBackup (Files.FullPath);
                                } else {
                                    DEBUGMSG ((DBG_MSGMGR, "Preserving possible empty dir %s", Files.FullPath));

                                    attribs = Files.FindData->dwFileAttributes;
                                    if (attribs == FILE_ATTRIBUTE_DIRECTORY) {
                                        attribs = 0;
                                    }

                                    MemDbSetValueEx (
                                        MEMDB_CATEGORY_EMPTY_DIRS,
                                        Files.FullPath,
                                        NULL,
                                        NULL,
                                        attribs,
                                        NULL
                                        );
                                }
                            }

                        } while (EnumNextFileInTree (&Files));
                    }
                }

                DontTouchThisFile (LongPath);
                MarkPathAsHandled (LongPath);

            } else {

                DEBUGMSG ((DBG_ERROR, "Object %s ignored, can't handle big dirs", Object));
                return;
            }

            //
            // Put an ending wack on the object so it handles all subitems in the report
            //

            LongPath[MAX_TCHAR_PATH - 2] = 0;
            AppendPathWack (LongPath);

        } else {

            DEBUGMSG ((
                DBG_WARNING,
                "Object %s ignored; it does not exist or is not a complete local path (%s)",
                Object,
                LongPath
                ));

            return;

        }

        //
        // Make sure messages for the file or dir are removed
        //

        HandleReportObject (LongPath);

    } else if (Type == OT_REGISTRY) {

        if (_tcsnextc (Object) == '*') {

            HandleReportObject (Object);

        } else {

            if (!_tcschr (Object, '[')) {
                //
                // This reg object does not have a value
                //

                FixedObject = AllocText (SizeOfStringA (Object) + sizeof (CHAR)*2);
                MYASSERT (FixedObject);
                StringCopy (FixedObject, Object);
                AppendWack (FixedObject);

                FixedObject = pTranslateRoots (FixedObject);
                MYASSERT (FixedObject);

                //
                // Handle messages for the registry key and all of its subkeys
                //

                HandleReportObject (FixedObject);

                //
                // Put a star on it so the entire node is suppressed
                //

                StringCat (FixedObject, "*");

            } else {

                //
                // This reg object has a value
                //

                FixedObject = DuplicateText (Object);
                MYASSERT (FixedObject);

                FixedObject = pTranslateRoots (FixedObject);
                MYASSERT (FixedObject);

                HandleReportObject (FixedObject);
            }

            //
            // Make sure registry key is not suppressed
            //

            if (SuppressRegistry) {
                Suppress95Object (FixedObject);
            }

            FreeText (FixedObject);
        }

    } else if (Type == OT_GUID) {

        if (!IsGuid (Object, TRUE)) {

            DEBUGMSG ((DBG_ERROR, "Object %s ignored because it's not a GUID", Object));
            return;
        }

        HandleReportObject (Object);

    } else if (Type == OT_BADGUID) {

        if (!IsGuid (Object, TRUE)) {

            DEBUGMSG ((DBG_ERROR, "Object %s ignored because it's not a GUID", Object));
            return;
        }

        MemDbBuildKey (
            Node,
            MEMDB_CATEGORY_GUIDS,
            NULL,
            NULL,
            Object
            );

        MemDbSetValue (Node, 0);

    } else if (Type == OT_USERNAME) {

        Node[0] = TEXT('|');
        _tcssafecpy (Node + 1, Object, MAX_PATH);

        HandleReportObject (Node);

    } else if (Type == OT_INIFILE) {

        IniSaved = FALSE;
        ValueName = NULL;
        SectionName = NULL;

        //
        // Verify the INI file exists
        //

        StringCopyByteCount (IniPath, Object, sizeof (IniPath));

        //
        // Inf INI file is a path without section, then give an error
        //

        if (OurGetLongPathName (
                IniPath,
                LongPath,
                sizeof (LongPath) / sizeof (LongPath[0])
                )) {

            DEBUGMSG ((DBG_ERROR, "INI file object %s ignored, must have section", Object));
            return;
        }

        //
        // Get the ValueName or SectionName
        //

        p = _tcsrchr (IniPath, TEXT('\\'));
        if (p) {
            *p = 0;
            ValueName = p + 1;

            if (!OurGetLongPathName (
                    IniPath,
                    LongPath,
                    sizeof (LongPath) / sizeof (LongPath[0])
                    )) {

                //
                // IniPath does not exist, must have both ValueName and SectionName
                //

                p = _tcsrchr (IniPath, TEXT('\\'));

                if (p) {
                    //
                    // We now have both ValueName and SectionName, IniPath must point
                    // to a valid file
                    //

                    *p = 0;
                    SectionName = p + 1;

                    if (!OurGetLongPathName (
                            IniPath,
                            LongPath,
                            sizeof (LongPath) / sizeof (LongPath[0])
                            )) {

                        DEBUGMSG ((DBG_ERROR, "INI file object %s ignored, INI file not found", Object));
                        return;

                    }

                } else {

                    DEBUGMSG ((DBG_ERROR, "INI file object %s ignored, bad INI file", Object));
                    return;

                }

            } else {
                //
                // IniPath does exist, we know we only have a SectionName
                //

                SectionName = ValueName;
                ValueName = TEXT("*");
            }

        } else {
            //
            // No wacks in Object!!
            //

            DEBUGMSG ((DBG_ERROR, "INI file object %s ignored, bad object", Object));
            return;
        }

        //
        // Suppress the INI file settings from NT, and make sure report entries
        // that come from INI files are also suppressed
        //

        MemDbBuildKey (
            Node,
            MEMDB_CATEGORY_SUPPRESS_INI_MAPPINGS,
            IniPath,
            SectionName,
            ValueName
            );


        MemDbSetValue (Node, 0);
        HandleReportObject (Node);

    } else if (Type == OT_ANSWERFILE) {

        StringCopy (Node, Object);
        p = _tcschr (Node, TEXT('\\'));

        if (p) {

            *p = 0;
            ValueName = _tcsinc (p);
        }
        else {

            ValueName = TEXT("*");
        }

        SectionName = Node;

        MemDbSetValueEx (
            MEMDB_CATEGORY_SUPPRESS_ANSWER_FILE_SETTINGS,
            SectionName,
            ValueName,
            NULL,
            0,
            NULL
            );
    }
    ELSE_DEBUGMSG ((DBG_WHOOPS, "Object type %u for %s not recognized.", Type, Object));
}


VOID
MsgMgr_Init (
    VOID
    )
{
    // Build message pool
    g_MsgMgrPool = PoolMemInitNamedPool ("Message Manager");

    // Table of handled objects
    g_HandledObjects = HtAlloc();

    // Table of blocking objects
    g_BlockingObjects = HtAlloc();

    // Table of objects to put on short summary
    g_ElevatedObjects = HtAlloc();

    // Context messages init
    g_ContextMsgs = HtAllocWithData (sizeof(PCTSTR));

    // Link-target description init
    g_LinkTargetDesc = HtAllocWithData (sizeof(PVOID));

    // Bad Software Init
    g_OmbEntriesMax = 25;
    g_OmbEntries = 0;
    g_OmbList = MemAlloc(
                    g_hHeap,
                    0,
                    g_OmbEntriesMax * sizeof(P_OBJ_MSG_BLOCK)
                    );
}

VOID
pAddStaticHandledObjects (
    VOID
    )
{
    INFSTRUCT is = INITINFSTRUCT_POOLHANDLE;
    PCTSTR object;

    if (InfFindFirstLine (g_Win95UpgInf, TEXT("IgnoreInReport"), NULL, &is)) {
        do {

            object = InfGetStringField (&is, 0);

            if (object) {
                HandleObject (object, TEXT("Report"));
            }

        } while (InfFindNextLine (&is));

        InfCleanUpInfStruct (&is);
    }
}

VOID
MsgMgr_Resolve (
    VOID
    )
{
    pAddStaticHandledObjects ();
    pSuppressObjectReferences(); // disable references to handled objects
    pDisplayObjectMsgs();        // print object & context msgs & enabled object refs
}


VOID
MsgMgr_Cleanup (
    VOID
    )
{
    // Context message cleanup
    HtFree (g_ContextMsgs);
    g_ContextMsgs = NULL;

    PoolMemDestroyPool(g_MsgMgrPool);
    g_MsgMgrPool = NULL;

    // Table of blocking objects
    HtFree (g_BlockingObjects);
    g_BlockingObjects = NULL;

    // Table of elevated objects
    HtFree (g_ElevatedObjects);
    g_ElevatedObjects = NULL;

    // Table of handled objects
    HtFree (g_HandledObjects);
    g_HandledObjects = NULL;

    // Link description cleanup
    HtFree (g_LinkTargetDesc);
    g_LinkTargetDesc = NULL;

    // Object-message list. Note, entries on list are entirely
    // from g_MsgMgrPool.
    if (NULL != g_OmbList) {
        MemFree(g_hHeap, 0, g_OmbList);
        g_OmbList = NULL;
    }

    if (g_MsgMgrMap) {

        DestroyStringMapping (g_MsgMgrMap);
    }

}


VOID
MsgMgr_ObjectMsg_Add(
    IN      PCTSTR Object,
    IN      PCTSTR Component,
    IN      PCTSTR Message
    )
{

    MYASSERT(Object);
    MYASSERT(Component);

    pOmbAdd(
        Object,
        TEXT(""), // context
        Component,
        Message
        );
}


PCTSTR
pGetMassagedComponent (
    IN PCTSTR Component
    )
{

    TCHAR tempBuffer[MAX_TCHAR_PATH];
    PCTSTR rString = NULL;

    if (!Component) {
        return NULL;
    }

    // Do string search and replacement and make own copy of the component.
    if (MappingSearchAndReplaceEx (
            g_MsgMgrMap,
            Component,
            tempBuffer,
            0,
            NULL,
            sizeof (tempBuffer),
            STRMAP_ANY_MATCH,
            NULL,
            NULL
            )) {
        DEBUGMSG ((DBG_MSGMGR, "Mapped %s to %s.", Component, tempBuffer));
        rString = PoolMemDuplicateString(g_MsgMgrPool, tempBuffer);
    }
    else {
        rString = PoolMemDuplicateString(g_MsgMgrPool, Component);
    }




    return rString;

}

VOID
MsgMgr_ContextMsg_Add(
    IN      PCTSTR Context,
    IN      PCTSTR Component,
    IN      PCTSTR Message
    )
{
    P_CONTEXT_DATA ContextData;


    MYASSERT(Context);
    MYASSERT(Component);

    // Get a structure to hold the componentand message string pointers
    ContextData = PoolMemGetMemory(g_MsgMgrPool, sizeof(CONTEXT_DATA));


    // Do string search and replacement and make own copy of the component.
    ContextData->Component = pGetMassagedComponent (Component);

    // Make own copy of message
    if (Message != NULL) {
        ContextData->Message = PoolMemDuplicateString(g_MsgMgrPool, Message);
    }
    else {
        ContextData->Message = NULL;
    }

    //
    // Debug message
    //
    DEBUGMSG ((
        DBG_MSGMGR,
        "MsgMgr_ContextMsg_Add\n"
            "  obj: '%s'\n"
            "  ctx: '%s'\n"
            "  cmp: '%s'\n"
            "  msg: '%s'\n",
        TEXT(""),
        Context,
        Component,
        Message ? Message : TEXT("<No message>")
        ));

    //
    // Save component named and message in string table
    //

    HtAddStringAndData (
        g_ContextMsgs,
        Context,
        &ContextData
        );

}


BOOL
IsReportObjectHandled (
    IN PCTSTR Object
    )
{
    HASHTABLE_ENUM e;
    PCTSTR p, q, r;
    PCTSTR End;
    PTSTR LowerCaseObject;
    BOOL b = FALSE;

    //
    // Check g_HandledObjects for:
    //
    // 1. An exact match
    // 2. The handled object is the root of Object
    //

    if (HtFindString (g_HandledObjects, Object)) {
        return TRUE;
    }

    //
    // We know the hash table stores its strings in lower case
    //

    LowerCaseObject = JoinPaths (Object, TEXT(""));
    _tcslwr (LowerCaseObject);

    __try {

        if (HtFindString (g_HandledObjects, LowerCaseObject)) {
            b = TRUE;
            __leave;
        }

        End = GetEndOfString (LowerCaseObject);

        if (EnumFirstHashTableString (&e, g_HandledObjects)) {
            do {

                p = LowerCaseObject;
                q = e.String;

                // Guard against empty hash table strings
                if (*q == 0) {
                    continue;
                }

                r = NULL;

                //
                // Check for substring match
                //

                while (*q && p < End) {

                    r = q;
                    if (_tcsnextc (p) != _tcsnextc (q)) {
                        break;
                    }

                    p = _tcsinc (p);
                    q = _tcsinc (q);
                }

                //
                // We know the hash string cannot match identically, since
                // we checked for an exact match earlier.  To have a match,
                // the hash string must be shorter than the object string,
                // it must end in a wack, and *q must point to the nul.
                //

                MYASSERT (r);

                if (*q == 0 && _tcsnextc (r) == TEXT('\\')) {
                    MYASSERT (p < End);
                    b = TRUE;
                    __leave;
                }

            } while (EnumNextHashTableString (&e));
        }
    }
    __finally {
        FreePathString (LowerCaseObject);
    }

    return b;
}


BOOL
IsReportObjectIncompatible (
    IN PCTSTR   Object
    )
{

    BOOL rIsIncompatible = FALSE;
    DWORD i;

    //
    // First, the "handled" test... Check to see if the object is in the
    // handled object table. If it is, then we can return FALSE.
    //
    if (!IsReportObjectHandled(Object)) {

        //
        // It wasn't in the table. Now we have to look the hard way!
        // Traverse the list of incompatible objects and look for one
        // that matches.
        //
        for (i=0; i < (DWORD) g_OmbEntries; i++) {

            //
            // If the current object in the incompatible list ends in a wack, do a
            // prefix match. if the current incompatible object is a prefix of Object,
            // then Object is incompatible.
            //
            if (IsWacked((g_OmbList[i])->Object)) {
                if (StringIMatchCharCount((g_OmbList[i])->Object,Object,CharCount((g_OmbList[i])->Object))) {
                    rIsIncompatible = TRUE;
                }
            }
            else {
                //
                // The current object does not end in a wack. Therefore, it is necessary
                // to have a complete match.
                //
                if (StringIMatch((g_OmbList[i])->Object,Object)) {
                    rIsIncompatible = TRUE;
                }
            }
        }
    }

    return rIsIncompatible;
}

BOOL
pContextMsg_Find(
    IN      PCTSTR Context,
    OUT     PCTSTR* Component,
    OUT     PCTSTR* Message
    )
{
    P_CONTEXT_DATA ContextData;

    if (HtFindStringAndData (g_ContextMsgs, Context, &ContextData)) {
        *Component = ContextData->Component;
        *Message = ContextData->Message;

        return TRUE;
    }

    return FALSE;
}

BOOL
IsWacked(
    IN      PCTSTR str
    )
{
    PCTSTR pWack = _tcsrchr(str,_T('\\'));
    return (NULL != pWack && 0 == *(pWack+1));
}


//
// This function is called for each Handled object in HandledObject.
// Objects are final or non-final, which can be known by looking for a final
// wack. It is caller's responsibility to ensure that directories and registry
// entries without value-names are wacked. This allows us to blow away (marked
// as handled) any other object with the wacked HO as a prefix.
//

BOOL
pDisplayContextMsgs_Callback(
    IN HASHTABLE stringTable,
    IN HASHITEM stringId,
    IN PCTSTR Context,
    IN PVOID extraData,
    IN UINT extraDataSize,
    IN LPARAM lParam
    )
{
    INT i;
    P_OBJ_MSG_BLOCK Omb;

    P_CONTEXT_DATA Data = *(P_CONTEXT_DATA*)extraData;

    //
    // Debug message
    //
    DEBUGMSG ((
        DBG_MSGMGR,
        "pDisplayContextMsgs_Callback\n"
            "  ctx: '%s'\n"
            "  cmp: '%s'\n"
            "  msg: '%s'\n",
        Context,
        Data->Component,
        Data->Message
        ));

    //
    // Loop through the OMBs, looking for an enabled reference with our context.
    // If found, print our message.
    //
    for (i = 0; i < g_OmbEntries; i++) {

        Omb = *(g_OmbList + i);

        //
        // If enabled and matches our context, print us
        //
        if (!Omb->Disabled && StringIMatch (Context, Omb->Context)) {

            //
            // Debug message
            //
            DEBUGMSG((
                DBG_MSGMGR,
                "pDisplayContextMsgs_Callback: DISPLAYING\n"
                    "  dsa: %d\n"
                    "  ctx: '%s'\n"
                    "  cmp: '%s'\n"
                    "  msg: '%s'\n",
                Omb->Disabled,
                Omb->Context,
                Data->Component,
                Data->Message
                ));

            pAddBadSoftwareWrapper (
                Omb->Object,
                Data->Component,
                Data->Message
                );

            break;
        }
    }

    UNREFERENCED_PARAMETER(stringTable);
    UNREFERENCED_PARAMETER(stringId);
    UNREFERENCED_PARAMETER(extraData);
    UNREFERENCED_PARAMETER(lParam);

    return TRUE;
}

//
// This function is called for each Handled object in HandledObject.
// Objects are final or non-final, which can be known by looking for a final
// wack. It is caller's responsibility to ensure that directories and registry
// entries without value-names are wacked. This allows us to blow away (marked
// as handled) any other object with the wacked HO as a prefix.
//
BOOL
pSuppressObjectReferences_Callback(
    IN      HASHITEM stringTable,
    IN      HASHTABLE stringId,
    IN      PCTSTR HandledObject,
    IN      PVOID extraData,
    IN      UINT extraDataSize,
    IN      LPARAM lParam
    )
{
    INT nHandledLen;
    BOOL IsNonFinalNode;
    INT i;
    P_OBJ_MSG_BLOCK Omb;

    UNREFERENCED_PARAMETER(stringTable);
    UNREFERENCED_PARAMETER(stringId);
    UNREFERENCED_PARAMETER(extraData);
    UNREFERENCED_PARAMETER(lParam);

    //
    // Find whether the HO is capable of having children.  This is known by looking
    // for a final wack.
    //
    IsNonFinalNode = IsWacked(HandledObject);

    //
    // Find how long it is (outside the following loop)
    //
    nHandledLen = ByteCount(HandledObject) - 1;

    //
    // Loop thru the list of messages. Apply one of two tests, depending on
    // on whether the handled object is non-final.
    //
    for (i = 0; i < g_OmbEntries; i++) {
        Omb = *(g_OmbList + i);

        // If disabled skip
        if (!Omb->Disabled) {

            if (IsNonFinalNode) {
                if (StringIMatchCharCount(
                        Omb->Object,   // key to deferred message
                        HandledObject,  // a handled object
                        nHandledLen
                        ) && (Omb->Object[nHandledLen] == 0 || Omb->Object[nHandledLen] == '\\')) {

                    DEBUGMSG((
                        DBG_MSGMGR,
                        "pSuppressObjectReferences_Callback: SUPPRESSING NON-FINAL\n"
                            "  obj: '%s'\n"
                            "  why: '%s'\n"
                            "  ctx: '%s'\n"
                            "  cmp: '%s'\n"
                            "  msg: '%s'\n",
                        Omb->Object,
                        HandledObject,
                        Omb->Context,
                        Omb->Component,
                        Omb->Description
                        ));

                    Omb->Disabled =  TRUE;
                }

            } else {

                //
                // When the handled object is a file (not a dir), then an exact match
                // must exist with Key for the message to be suppressed.
                //
                if (StringIMatch (Omb->Object, HandledObject)) {

                    DEBUGMSG((
                        DBG_MSGMGR, "pSuppressObjectReferences_Callback: SUPPRESSING FINAL\n"
                            "  obj: '%s'\n"
                            "  why: '%s'\n"
                            "  ctx: '%s'\n"
                            "  cmp: '%s'\n"
                            "  msg: '%s'\n",
                        Omb->Object,
                        HandledObject,
                        Omb->Context,
                        Omb->Component,
                        Omb->Description
                        ));

                    Omb->Disabled =  TRUE;
                }
            }
        }
    }

    return TRUE;
}


VOID
MsgMgr_LinkObjectWithContext(
    IN      PCTSTR Context,
    IN      PCTSTR Object
    )
{
    MYASSERT(Context);
    MYASSERT(Object);

    //
    // Debug message
    //
    DEBUGMSG ((
        DBG_MSGMGR,
        "MsgMgr_LinkObjectWithContext: ADD\n"
            "  obj: '%s'\n"
            "  ctx: '%s'\n",
        Object,
        Context
        ));

    pOmbAdd (Object, Context, TEXT(""), TEXT(""));
}


DWORD
pDfsGetFileAttributes (
    IN      PCTSTR Object
    )
{
    TCHAR RootPath[4];
    DWORD Attribs;

    if (!Object[0] || !Object[1] || !Object[2]) {
        return INVALID_ATTRIBUTES;
    }

    RootPath[0] = Object[0];
    RootPath[1] = Object[1];
    RootPath[2] = Object[2];
    RootPath[3] = 0;

    if (GetDriveType (RootPath) != DRIVE_FIXED) {
        DEBUGMSG ((DBG_VERBOSE, "%s is not a local path", Object));
        Attribs = INVALID_ATTRIBUTES;
    } else {

        Attribs = GetFileAttributes (Object);

    }

    return Attribs;
}

//
// Function adds an Object Message Block (OMB) to the list of all OMBs.
// If the OMB doesn't refer to a context, then any OMB already in the list
// with a message for the same object, is disabled. In this way, there is
// only one message per handleable object.
//
VOID
pOmbAdd(
    IN PCTSTR Object,
    IN PCTSTR Context,
    IN PCTSTR Component,
    IN PCTSTR Description
    )
{

    TCHAR ObjectWackedIfDir[MAX_ENCODED_RULE];
    P_OBJ_MSG_BLOCK Omb;
    P_OBJ_MSG_BLOCK OmbTemp;
    DWORD Attribs;
    INT i;

    DEBUGMSG ((
        DBG_MSGMGR,
        "pOmbAdd: ADD\n"
            "  obj: '%s'\n"
            "  ctx: '%s'\n"
            "  cmp: '%s'\n"
            "  msg: '%s'\n",
        Object,
        Context,
        Component,
        Description
        ));

    //
    // Make sure our copy of the key is wacked when it's a directory.
    //
    StringCopy(ObjectWackedIfDir, Object);

    Attribs = pDfsGetFileAttributes (Object);

    if (Attribs != INVALID_ATTRIBUTES && (Attribs & FILE_ATTRIBUTE_DIRECTORY)) {
        AppendWack(ObjectWackedIfDir);
    }

    //
    // Disable any messages already received which have the same
    // Object and Context.
    //

    for (i = 0; i < g_OmbEntries; i++) {
        OmbTemp = *(g_OmbList + i);

        if (StringIMatch(OmbTemp->Object, ObjectWackedIfDir) &&
            StringIMatch(OmbTemp->Context, Context)
            ) {

            OmbTemp->Disabled = TRUE;
        }
    }

    //
    // Allocate message block
    //
    Omb = PoolMemGetMemory(
                g_MsgMgrPool,
                sizeof(OBJ_MSG_BLOCK)
                );
    //
    // Complete block
    //
    Omb->Disabled = FALSE;

    Omb->Object = PoolMemDuplicateString(g_MsgMgrPool, ObjectWackedIfDir);
    Omb->Context = PoolMemDuplicateString(g_MsgMgrPool, Context);
    Omb->Component = (PTSTR) pGetMassagedComponent (Component);

    if (Description != NULL) {
        Omb->Description = PoolMemDuplicateString(g_MsgMgrPool, Description);
    } else {
        Omb->Description = NULL;
    }

    //
    // Grow the message list if necessary
    //
    if (g_OmbEntries >= g_OmbEntriesMax) {

        g_OmbEntriesMax += 25;

        g_OmbList = MemReAlloc(
                        g_hHeap,
                        0,
                        g_OmbList,
                        g_OmbEntriesMax * sizeof(P_OBJ_MSG_BLOCK)
                        );
    }

    //
    // Save block
    //
    *(g_OmbList + g_OmbEntries) = Omb;

    //
    // Bump the list size
    //
    g_OmbEntries++;
}



//
// Function:
//   1)  walks the list of deferred message entries. If an entry has no context
// and remains enabled, its Object message is printed.
//   2)  walks he g_ContextMsgs table is walked. For each, g_OmbList is
// traversed; if any entry is enabled and has a matching context, the context
// message is printed.
//
VOID
pDisplayObjectMsgs (
    VOID
    )
{
    PTSTR ComponentNameFromLink;
    BOOL ComponentIsLinkTarget;
    P_OBJ_MSG_BLOCK Omb;
    INT i;

    //
    // Find entries with no context. If they are enabled: 1) print the message;
    // 2) disable the entries so they will be skipped in the steps that follow.
    //
    for (i = 0; i < g_OmbEntries; i++) {

        Omb = *(g_OmbList + i);

        if (!Omb->Disabled && !(*Omb->Context)) {

            //
            // Print the message.
            //
            // Before printing, attempt to replace the ->Component string
            // with one taken from a shell link, if available. This functionality,
            // if expanded, could be broken into a separate function.
            //

            ComponentIsLinkTarget = pFindLinkTargetDescription(
                                        Omb->Component,         // component may be link target
                                        &ComponentNameFromLink  // if so, this may be more descriptive
                                        );

            if (ComponentIsLinkTarget) {

                DEBUGMSG((
                    DBG_MSGMGR,
                    "MsgMgr_pResolveContextAndPrint: DISPLAYING #1\n"
                        "  cmp: '%s'\n"
                        "  msg: '%s'\n",
                    ComponentNameFromLink,
                    Omb->Description
                    ));

                // Use the link description
                pAddBadSoftwareWrapper (
                    Omb->Object,
                    ComponentNameFromLink,
                    Omb->Description
                    );

                LOG ((
                    LOG_INFORMATION,
                    (PCSTR)MSG_MSGMGR_ADD,
                    Omb->Object,
                    Omb->Description
                    ));

            } else {

                DEBUGMSG((
                    DBG_MSGMGR,
                    "MsgMgr_pResolveContextAndPrint: DISPLAYING #2\n"
                        "  obj: '%s'\n"
                        "  cmp: '%s'\n"
                        "  msg: '%s'\n",
                    Omb->Object,
                    Omb->Component,
                    Omb->Description
                    ));

                // Use Omb->Component as the description (the default case)
                pAddBadSoftwareWrapper (
                    Omb->Object,
                    Omb->Component,
                    Omb->Description
                    );

                LOG ((
                    LOG_INFORMATION,
                    (PCSTR)MSG_MSGMGR_ADD,
                    Omb->Object,
                    Omb->Component,
                    Omb->Description
                    ));
            }

            //
            // Disable the entry so we'll skip it in the following steps
            //
            Omb->Disabled = TRUE;
        }
    }

    //
    // Enumerate tabContextMsg. For each entry, look through g_OmbList to see if any
    // entries that refer to it are still enabled. If there is/are any such entries,
    // print the message for that context.
    //

    EnumHashTableWithCallback (
        g_ContextMsgs,
        pDisplayContextMsgs_Callback,
        0
        );

}



//
// Function enumerates the list of handled objects, and calls a function to
// supress object references which are (or are children of) the enumerated
// object. This should be called AFTER all migrate.dll's have run on the
// Win95 side.
//
static
VOID
pSuppressObjectReferences (
    VOID
    )
{
    //
    // This function disables messages in g_OmbList
    //
    EnumHashTableWithCallback (
        g_HandledObjects,
        pSuppressObjectReferences_Callback,
        0
        );
}



VOID
LnkTargToDescription_Add (
    IN      PCTSTR Target,
    IN      PCTSTR strDesc
    )
{
    PTSTR DescCopy;

    // Make own copy of description
    DescCopy = PoolMemDuplicateString(
                    g_MsgMgrPool,
                    strDesc
                    );

    // Save description
    HtAddStringAndData (g_LinkTargetDesc, Target, &DescCopy);
}



BOOL
pFindLinkTargetDescription(
    IN      PCTSTR Target,
    OUT     PCTSTR* StrDesc
    )
{
    return HtFindStringAndData (g_LinkTargetDesc, Target, (PVOID) StrDesc) != 0;
}

VOID
MsgMgr_InitStringMap (
    VOID
    )
{
    INFSTRUCT   is = INITINFSTRUCT_POOLHANDLE;
    PCTSTR from, to;

    if (g_Win95UpgInf == INVALID_HANDLE_VALUE) {
        MYASSERT (g_ToolMode);
        return;
    }

    g_MsgMgrMap = CreateStringMapping ();

    if (InfFindFirstLine (g_Win95UpgInf, S_MSG_STRING_MAPS, NULL, &is)) {

        do {

            from = InfGetStringField (&is, 0);
            to = InfGetStringField (&is, 1);

            if (from && to) {
                AddStringMappingPair (g_MsgMgrMap, from, to);
            }

        } while (InfFindNextLine (&is));

        InfCleanUpInfStruct (&is);
    }
}

BOOL
MsgMgr_EnumFirstObject (
    OUT     PMSGMGROBJENUM EnumPtr
    )
{
    EnumPtr->Index = 0;
    return MsgMgr_EnumNextObject (EnumPtr);
}

BOOL
MsgMgr_EnumNextObject (
    IN OUT  PMSGMGROBJENUM EnumPtr
    )
{
    if (EnumPtr->Index >= g_OmbEntries) {
        return FALSE;
    }
    EnumPtr->Disabled = g_OmbList[EnumPtr->Index]->Disabled;
    EnumPtr->Object = g_OmbList[EnumPtr->Index]->Object;
    EnumPtr->Context = g_OmbList[EnumPtr->Index]->Context;
    EnumPtr->Index++;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\ui\copythrd.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    copythrd.c

Abstract:

    CopyThread routine copies files needed to support migration modules.  This
    thread runs in the background while the user is reading the backup instructions,
    or while WINNT32 is doing some work.  Any file copied is added to the
    CancelFileDelete category of memdb, so it will be cleaned up and the user's
    machine will look exactly like it did before WINNT32 ran.

Author:

    Jim Schmidt (jimschm) 17-Mar-1997

Revision History:

    jimschm     09-Apr-1998     Added DidCopyThreadFail
    jimschm     03-Dec-1997     Added g_CopyThreadHasStarted

--*/

#include "pch.h"
#include "uip.h"

//
// Local prototypes
//

VOID CopyRuntimeDlls (VOID);

//
// Local variables
//


static HANDLE g_CopyThreadHandle;
static BOOL g_CopyThreadHasStarted = FALSE;
BOOL g_CopyThreadError;


//
// Implementation
//


BOOL
DidCopyThreadFail (
    VOID
    )
{
    return g_CopyThreadError;
}


DWORD
pCopyThread (
    PVOID p
    )

/*++

Routine Description:

  pCopyThread is the routine that is called when the copy worker thread
  is created.  Its job is to call all processing functions that need
  to complete before the user supplies migration DLLs.

  Currently the only processing necessary is to copy the runtime DLLs
  that migration DLLs may need.

Arguments:

  p - Unused

Return Value:

  Zero (don't care)

--*/

{
    CopyRuntimeDlls();
    return 0;
}


VOID
StartCopyThread (
    VOID
    )

/*++

Routine Description:

  StartCopyThread creates a worker thread that copies the runtime DLLs
  specified in win95upg.inf.  If the worker thread was already started,
  this routine does nothing.

Arguments:

  none

Return Value:

  none

--*/

{
    DWORD DontCare;

    if (!g_CopyThreadHasStarted) {
        //
        // Launch thread if it has not been launched previously
        //

        g_CopyThreadHandle = CreateThread (NULL, 0, pCopyThread, NULL, 0, &DontCare);
        g_CopyThreadHasStarted = TRUE;
    }
}


VOID
EndCopyThread (
    VOID
    )

/*++

Routine Description:

  EndCopyThread waits for the worker thread to finish its copying before
  returning.

Arguments:

  none

Return Value:

  none

--*/

{
    if (!g_CopyThreadHandle) {
        return;
    }

    TurnOnWaitCursor();

    WaitForSingleObject (g_CopyThreadHandle, INFINITE);
    CloseHandle (g_CopyThreadHandle);
    g_CopyThreadHandle = NULL;

    TurnOffWaitCursor();
}




VOID
CopyRuntimeDlls (
    VOID
    )

/*++

Routine Description:

  CopyRuntimeDlls enumerates the runtime DLL names in win95upg.inf and
  copies them to the appropriate destination on the local disk.

  This routine runs in a background worker thread and may not display
  UI.  The failure case we care about is lack of disk space, and if we
  can't copy the runtimes, it is safe to assume we won't get much
  further.  (Also, WINNT32 may have already verified there is a lot
  of space available.)

  Any file that is copied is also added to the CancelFileDelete
  category so it is cleaned up on cancel of Setup.

  The routines called by this proc must all be thread-safe!!

Arguments:

  none

Return Value:

  none

--*/

{
    INFSTRUCT is = INITINFSTRUCT_POOLHANDLE;
    PTSTR DirName;
    PCTSTR Winnt32FileName;
    TCHAR DataBuf[MEMDB_MAX];
    PTSTR FileName = NULL;
    PTSTR SourceName = NULL;
    PTSTR DestName = NULL;
    PTSTR Number = NULL;
    PCTSTR DestFileName;
    LONG DirArraySize;
    LONG l;
    TCHAR Key[MEMDB_MAX];
    DWORD rc;
    INT sysLocale;
    PTSTR localeStr = NULL;
    TCHAR InstallSectionName[128];

    if (g_Win95UpgInf == INVALID_HANDLE_VALUE) {
        LOG ((LOG_ERROR, "Win95upg.inf not open!"));
        return;
    }

    //
    // Build path list from [Win95.Directories]
    //

    // Get number of lines in this section
    DirArraySize = SetupGetLineCount (g_Win95UpgInf, S_WIN95_DIRECTORIES);
    if (DirArraySize == -1) {
        LOG ((LOG_ERROR, "%s does not exist in win95upg.inf", S_WIN95_DIRECTORIES));
        return;
    }

    // For each line, add number to temp memdb category (used for sorting)
    for (l = 0 ; l < DirArraySize ; l++) {
        if (!InfGetLineByIndex (g_Win95UpgInf, S_WIN95_DIRECTORIES, l, &is)) {

            LOG ((LOG_ERROR,"Failed to retrive line from win95upg.inf. (line %i)",l+1));

        } else {

            Number = InfGetStringField(&is,0);
            FileName = InfGetStringField(&is,1);

            if (Number && FileName) {


                //
                // Line is valid, expand dir name and add it to memdb
                //
                DirName = JoinPaths (g_WinDir, FileName);

                if (CharCount (DirName) > MEMDB_MAX / 2) {
                    DEBUGMSG ((DBG_WHOOPS, "DirName is really long: %s", DirName));
                }
                else {
                    wsprintf (
                        Key,
                        TEXT("%s\\%08u\\%s"),
                        S_MEMDB_TEMP_RUNTIME_DLLS,
                        _ttoi (Number),
                        DirName
                        );

                    DEBUGMSG ((DBG_NAUSEA, "Adding %s to memdb", Key));
                    MemDbSetValue (Key, 0);
                }

                FreePathString (DirName);
            }
        }
    }

    //
    // Enumerate [Win95.Install] section or [Win95.Install.ReportOnly] if in
    // report-only mode.
    //

    StringCopy (InstallSectionName, S_WIN95_INSTALL);
    if (REPORTONLY()) {
        StringCat (InstallSectionName, TEXT(".ReportOnly"));
    }

    if (InfFindFirstLine (g_Win95UpgInf, InstallSectionName, NULL, &is)) {
        do {

            FileName = InfGetStringField(&is,0);
            Number   = InfGetStringField(&is,1);

            if (FileName && Number) {
                //
                // Look up Number in memdb and copy src to dest
                //

                wsprintf (Key, TEXT("%08u"), _ttoi (Number));

                if (MemDbGetEndpointValueEx (
                        S_MEMDB_TEMP_RUNTIME_DLLS,
                        Key,
                        NULL,
                        DataBuf
                        )) {

                    SourceName = JoinPaths (SOURCEDIRECTORY(0), FileName);

                    if (_tcschr (FileName, TEXT('\\'))) {
                        DestFileName = GetFileNameFromPath (FileName);
                    } else {
                        DestFileName = FileName;
                    }

                    DestName = JoinPaths (DataBuf, DestFileName);

                    __try {

                        //
                        // Verify international field if it exists
                        //


                        localeStr = InfGetMultiSzField(&is,2);

                        if (localeStr && *localeStr) {

                            sysLocale = GetSystemDefaultLCID();

                            while (*localeStr) {

                                if (_ttoi(localeStr) == sysLocale) {

                                    break;
                                }

                                localeStr = GetEndOfString (localeStr) + 1;
                            }

                            if (!*localeStr) {

                                DEBUGMSG ((
                                    DBG_NAUSEA,
                                    "CopyRuntimeDlls: Locale %s not supported",
                                    localeStr
                                    ));

                                continue;
                            }
                        }

                        // If user cancels, we just get out
                        if (*g_CancelFlagPtr) {
                            return;
                        }

                        if (0xffffffff == GetFileAttributes (DestName)) {

                            rc = SetupDecompressOrCopyFile (SourceName, DestName, 0);

                            if (rc == 2) {
                                DEBUGMSG ((DBG_VERBOSE, "Can't copy %s to %s", SourceName, DestName));

                                FreePathString (SourceName);
                                Winnt32FileName = JoinPaths (TEXT("WINNT32"), FileName);
                                MYASSERT (Winnt32FileName);

                                SourceName = JoinPaths (SOURCEDIRECTORY(0), Winnt32FileName);
                                MYASSERT (SourceName);
                                FreePathString (Winnt32FileName);

                                DEBUGMSG ((DBG_VERBOSE, "Trying to copy %s to %s", SourceName, DestName));
                                rc = SetupDecompressOrCopyFile (SourceName, DestName, 0);
                            }


                            if (rc != ERROR_SUCCESS && rc != ERROR_SHARING_VIOLATION) {
                                SetLastError (rc);
                                if (rc != ERROR_FILE_EXISTS) {
                                    LOG ((
                                        LOG_ERROR,
                                        "Error while copying runtime dlls. Can't copy %s to %s",
                                        SourceName,
                                        DestName
                                        ));
                                }

                                g_CopyThreadError = TRUE;
                                LOG ((LOG_ERROR, (PCSTR)MSG_FILE_COPY_ERROR_LOG, SourceName, DestName));
                            }
                            else {
                                DEBUGMSG ((
                                    DBG_NAUSEA,
                                    "%s copied to %s",
                                    SourceName,
                                    DestName
                                    ));

                                MemDbSetValueEx (
                                    MEMDB_CATEGORY_CANCELFILEDEL,
                                    NULL,
                                    NULL,
                                    DestName,
                                    0,
                                    NULL
                                    );
                            }
                        }
                        ELSE_DEBUGMSG ((
                            DBG_VERBOSE,
                            "GetFileAttributes failed for %s. Gle: %u (%xh)",
                            DestName,
                            GetLastError(),
                            GetLastError()
                            ));
                    }
                    __finally {
                        FreePathString (SourceName);
                        FreePathString (DestName);
                    }
                }
                ELSE_DEBUGMSG ((
                    DBG_ERROR,
                    "CopyRuntimeDlls: Directory %s not indexed in memdb",
                    Number
                    ));
            }

        } while (InfFindNextLine (&is));
    }

    InfCleanUpInfStruct(&is);

    //
    // Blow away temp memdb category
    //

    MemDbDeleteTree (S_MEMDB_TEMP_RUNTIME_DLLS);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\ui\uip.h ===
// uip.h - private interfaces for ui.lib

//
// Defines
//

#define REGISTRY_DLL                    0xfffffffe


//
// definition of Level used for report generation routines
//

#define REPORTLEVEL_NONE                    0x0000
#define REPORTLEVEL_BLOCKING                0x0001
#define REPORTLEVEL_ERROR                   0x0002
#define REPORTLEVEL_WARNING                 0x0004
#define REPORTLEVEL_INFORMATION             0x0008
#define REPORTLEVEL_VERBOSE                 0x0010

#define REPORTLEVEL_ALL                     0x001F

#define REPORTLEVEL_IN_SHORT_LIST           0x1000

//
// Private routines
//

BOOL InitCompatTable (void);
void FreeCompatTable (void);



BOOL
SaveReport (
    IN      HWND Parent,        OPTIONAL // Either Parent or Path must be specified.
    IN      LPCTSTR Path        OPTIONAL
    );

BOOL
PrintReport (
    IN      HWND Parent,
    IN      DWORD Level
    );

BOOL
AreThereAnyBlockingIssues(
    VOID
    );

PCTSTR
CreateReportText (
    IN      BOOL HtmlFormat,
    IN      UINT TotalColumns,
    IN      DWORD Level,
    IN      BOOL ListFormat
    );

VOID
FreeReportText (
    VOID
    );


VOID
StartCopyThread (
    VOID
    );


VOID
EndCopyThread (
    VOID
    );

DWORD
UI_ReportThread (
    LPVOID p
    );

VOID
BuildPunctTable (
    VOID
    );

VOID
FreePunctTable (
    VOID
    );

DWORD
UI_CreateNewHwCompDat (
    LPVOID p
    );

BOOL
IsIncompatibleHardwarePresent (
    VOID
    );

typedef DWORD(WINAPI *THREADPROC)(LPVOID Param);

typedef struct {
    //
    // IN params to SearchingDlgProc
    //

    PCTSTR SearchStr;
    PTSTR MatchStr;
    THREADPROC ThreadProc;

    //
    // Dialog info set by SearchingDlgProc and
    // queried by ThreadProc
    //

    HWND hdlg;
    HANDLE CancelEvent;
    HANDLE ThreadHandle;

    //
    // OUT params from ThreadProc
    //

    UINT ActiveMatches;
    BOOL MatchFound;
} SEARCHING_THREAD_DATA, *PSEARCHING_THREAD_DATA;

LONG
SearchForMigrationDlls (
    IN      HWND Parent,
    IN      PCTSTR SearchPath,
    OUT     UINT *ActiveModulesFound,
    OUT     PBOOL OneValidDllFound
    );


LONG
SearchForDomain (
    IN      HWND Parent,
    IN      PCTSTR ComputerName,
    OUT     BOOL *AccountFound,
    OUT     PTSTR DomainName
    );




#define WMX_REPORT_COMPLETE         (WM_APP+20)
#define WMX_UPDATE_LIST             (WM_APP+21)
#define WMX_DIALOG_VISIBLE          (WM_APP+22)
#define WMX_THREAD_DONE             (WM_APP+23)
#define WMX_ADDLINE                 (WM_APP+24)
#define WMX_GOTO                    (WM_APP+25)
#define WMX_WAIT_FOR_THREAD_TO_DIE  (WM_APP+26)
#define WMX_ENABLE_CONTROLS         (WM_APP+27)
#define WMX_ALL_LINES_PAINTED       (WM_APP+28)
#define WMX_INIT_DIALOG             (WM_APP+29)
#define WMX_CLEANUP                 (WM_APP+30)
#define WMX_WIN95_WORKAROUND        (WM_APP+31)
#define WMX_RESTART_SETUP           (WM_APP+32)

//
// imported from winnt32.h
//
#define WMX_FINISHBUTTON        (WMX_PLUGIN_FIRST-8)
#define WMX_UNATTENDED          (WMX_PLUGIN_FIRST-9)
#define WMX_NEXTBUTTON          (WMX_PLUGIN_FIRST-10)
#define WMX_BACKBUTTON          (WMX_PLUGIN_FIRST-11)



BOOL
UI_BackupPageProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
UI_HwCompDatPageProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

UI_BadHardDrivePageProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

UI_BadCdRomPageProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

UI_NameCollisionPageProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
UI_HardwareDriverPageProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
UI_UpgradeModulePageProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
UI_ScanningPageProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
UI_ResultsPageProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
UI_BackupYesNoPageProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
UI_BackupDriveSelectionProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
UI_BackupImpossibleInfoProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
UI_BackupImpExceedLimitProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

BOOL
UI_LastPageProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

LPCTSTR UI_GetMemDbDat (void);

LPARAM
HardwareDlg (
    IN      HWND Parent
    );

LPARAM
UpgradeModuleDlg (
    IN      HWND Parent
    );


LPARAM
DiskSpaceDlg (
    HWND Parent
    );

LPARAM
WarningDlg (
    HWND Parent
    );

LPARAM
SoftBlockDlg (
    HWND Parent
    );

LPARAM
IncompatibleDevicesDlg (
    HWND Parent
    );

LPARAM
ResultsDlg (
    IN      HWND Parent,
    IN      PCTSTR Bookmark
    );

extern HWND g_InfoPageHwnd;
extern int g_nCompliantDllsEncountered;
extern int g_nCompliantDllsEncounteredThisEnum;
extern BOOL g_UIQuitSetup;

LRESULT
CALLBACK
TextViewProc (
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    );

#define ATTRIB_NORMAL       0
#define ATTRIB_BOLD         1
#define ATTRIB_UNDERLINED   2

typedef struct {
    UINT Indent;
    UINT LastCharAttribs;
    UINT HangingIndent;
    BOOL AnchorWrap;
    BOOL Painted;
} LINEATTRIBS, *PLINEATTRIBS;


//
// Change name dialog
//

typedef struct {
    PCTSTR NameGroup;
    PCTSTR OrgName;
    PCTSTR LastNewName;
    PTSTR NewNameBuf;
} CHANGE_NAME_PARAMS, *PCHANGE_NAME_PARAMS;

BOOL
ChangeNameDlg (
    IN      HWND Parent,
    IN      PCTSTR NameGroup,
    IN      PCTSTR OrgName,
    IN OUT  PTSTR NewName
    );

//
// Credentials dialog
//

#define MAX_PASSWORD        64

typedef struct {
    BOOL Change;
    TCHAR DomainName[MAX_COMPUTER_NAME + 1];
    TCHAR AdminName[MAX_SERVER_NAME + 1 + MAX_USER_NAME + 1];
    TCHAR Password[MAX_PASSWORD + 1];
} CREDENTIALS, *PCREDENTIALS;

BOOL
CredentialsDlg (
    IN      HWND Parent,
    IN OUT  PCREDENTIALS Credentials
    );

VOID
EnableDlgItem (
    HWND hdlg,
    UINT Id,
    BOOL Enable,
    UINT FocusId
    );

VOID
ShowDlgItem (
    HWND hdlg,
    UINT Id,
    INT Show,
    UINT FocusId
    );

LONG
SearchForDrivers (
    IN      HWND Parent,
    IN      PCTSTR SearchPathStr,
    OUT     BOOL *DriversFound
    );

VOID
RegisterTextViewer (
    VOID
    );

VOID
AddStringToTextView (
    IN      HWND hwnd,
    IN      PCTSTR Text
    );


#ifdef PRERELEASE

DWORD
DoAutoStressDlg (
    PVOID Foo
    );

#endif

BOOL
IsPunct (
    MBCHAR Char
    );


typedef struct {
    //
    // public data
    //
    PCTSTR Entry;
    DWORD Level;
    BOOL Header;
    //
    // private data
    //
    PTSTR Next;
    TCHAR ReplacedChar;
} LISTREPORTENTRY_ENUM, *PLISTREPORTENTRY_ENUM;

BOOL
EnumFirstListEntry (
    OUT     PLISTREPORTENTRY_ENUM EnumPtr,
    IN      PCTSTR ListReportText
    );

BOOL
EnumNextListEntry (
    IN OUT  PLISTREPORTENTRY_ENUM EnumPtr
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\ui\ui.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    ui.c

Abstract:

    The UI library contains all Win9x-side user interface code.  UI_GetWizardPages
    is called by WINNT32 allowing the migration module to add its own wizard pages.
    UI_ReportThread is the thread that performs all report-phase migration processing.
    UI_Cleanup is called by WINNT32 when the user chooses to abort setup.  The rest
    of the functions in this module support the progress bar.

Author:

    Jim Schmidt (jimschm) 04-Mar-1997

Revision History:

    Marc R. Whitten (marcw) 08-Jul-1998 - Ambigous Timezone page added.
    Jim Schmidt (jimschm)   21-Jan-1998 - Created macro expansion list for wizard pages
    Jim Schmidt (jimschm)   29-Jul-1997 - Moved accessible drives to here
    Marc R. Whitten (marcw) 25-Apr-1997 - Ras migration added.
    Marc R. Whitten (marcw) 21-Apr-1997 - hwcomp stuff moved to new wiz page.
                                          Checks for usable hdd and cdrom added.
    Marc R. Whitten (marcw) 14-Apr-1997 - Progress Bar handling revamped.

--*/

#include "pch.h"
#include "uip.h"
#include "drives.h"

extern BOOL g_Terminated;

/*++

Macro Expansion List Description:

  PAGE_LIST lists each wizard page that will appear in any UI, in the order it appears
  in the wizard.

Line Syntax:

   DEFMAC(DlgId, WizProc, Flags)

Arguments:

   DlgId - Specifies the ID of a dialog.  May not be zero.  May be 1 if WizProc
           is NULL.

   WizProc - Specifies wizard proc for dialog ID.  May be NULL to skip processing
             of page.

   Flags - Specifies one of the following:

           OPTIONAL_PAGE - Specifies page is not critical to the upgrade or
                           incompatibility report

           REQUIRED_PAGE - Specifies page is required for the upgrade to work
                           properly.


           Flags may also specify START_GROUP, a flag that begins a new group
           of wizard pages to pass back to WINNT32.  Subsequent lines that do not
           have the START_GROUP flag are also added to the group.

           Currently there are exactly three groups.  See winnt32p.h for details.

Variables Generated From List:

    g_PageArray

--*/

#define PAGE_LIST                                                                           \
    DEFMAC(IDD_BACKUP_PAGE,                     UI_BackupPageProc,          START_GROUP|OPTIONAL_PAGE)  \
    DEFMAC(IDD_HWCOMPDAT_PAGE,                  UI_HwCompDatPageProc,       START_GROUP|REQUIRED_PAGE)  \
    DEFMAC(IDD_BADCDROM_PAGE,                   UI_BadCdRomPageProc,        OPTIONAL_PAGE)              \
    DEFMAC(IDD_NAME_COLLISION_PAGE,             UI_NameCollisionPageProc,   REQUIRED_PAGE)              \
    DEFMAC(IDD_BAD_TIMEZONE_PAGE,               UI_BadTimeZonePageProc,     OPTIONAL_PAGE)              \
    DEFMAC(IDD_PREDOMAIN_PAGE,                  UI_PreDomainPageProc,       REQUIRED_PAGE)              \
    DEFMAC(IDD_DOMAIN_PAGE,                     UI_DomainPageProc,          REQUIRED_PAGE)              \
    DEFMAC(IDD_SUPPLY_MIGDLL_PAGE2,             UI_UpgradeModulePageProc,   OPTIONAL_PAGE)              \
    DEFMAC(IDD_SCANNING_PAGE,                   UI_ScanningPageProc,        START_GROUP|REQUIRED_PAGE)  \
    DEFMAC(IDD_SUPPLY_DRIVER_PAGE2,             UI_HardwareDriverPageProc,  OPTIONAL_PAGE)              \
    DEFMAC(IDD_BACKUP_YES_NO_PAGE,              UI_BackupYesNoPageProc,     REQUIRED_PAGE)              \
    DEFMAC(IDD_BACKUP_DRIVE_SELECTION_PAGE,     UI_BackupDriveSelectionProc,REQUIRED_PAGE)              \
    DEFMAC(IDD_BACKUP_IMPOSSIBLE_INFO_PAGE,     UI_BackupImpossibleInfoProc,REQUIRED_PAGE)              \
    DEFMAC(IDD_BACKUP_IMPOSSIBLE_INFO_1_PAGE,   UI_BackupImpExceedLimitProc,REQUIRED_PAGE)              \
    DEFMAC(IDD_RESULTS_PAGE2,                   UI_ResultsPageProc,         REQUIRED_PAGE)              \
    DEFMAC(IDD_LAST_PAGE,                       UI_LastPageProc,            OPTIONAL_PAGE)              \

//    DEFMAC(IDD_BADHARDDRIVE_PAGE,   UI_BadHardDrivePageProc,    OPTIONAL_PAGE)              \

//
// Create the macro expansion that defines g_PageArray
//

typedef BOOL(WINNT32_WIZARDPAGE_PROC_PROTOTYPE)(HWND hdlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
typedef WINNT32_WIZARDPAGE_PROC_PROTOTYPE *WINNT32_WIZARDPAGE_PROC;

#define START_GROUP     0x0001
#define OPTIONAL_PAGE   0x0002
#define REQUIRED_PAGE   0x0000

typedef struct {
    UINT DlgId;
    WINNT32_WIZARDPAGE_PROC WizProc;
    DWORD Flags;
} WIZPAGE_DEFINITION, *PWIZPAGE_DEFINITION;

#define DEFMAC(id,fn,flags) WINNT32_WIZARDPAGE_PROC_PROTOTYPE fn;

PAGE_LIST

#undef DEFMAC


#define DEFMAC(id,fn,flags) {id,fn,flags},

WIZPAGE_DEFINITION g_PageArray[] = {
    PAGE_LIST /* , */
    {0, NULL, 0}
};

#undef DEFMAC

//
// Globals
//

HANDLE g_WorkerThreadHandle = NULL;


//
// Implementation
//

BOOL
WINAPI
UI_Entry (
    IN      HINSTANCE hinstDLL,
    IN      DWORD dwReason,
    IN      PVOID lpv
    )
{
    switch (dwReason) {

    case DLL_PROCESS_ATTACH:
        if (!InitCompatTable()) {
            return FALSE;
        }
        MsgMgr_Init();
        RegisterTextViewer();
        break;

    case DLL_PROCESS_DETACH:
        FreeCompatTable();
        MsgMgr_Cleanup();
        FreePunctTable();
        break;
    }

    return TRUE;
}


DWORD
UI_GetWizardPages (
    OUT    UINT *FirstCountPtr,
    OUT    PROPSHEETPAGE **FirstArray,
    OUT    UINT *SecondCountPtr,
    OUT    PROPSHEETPAGE **SecondArray,
    OUT    UINT *ThirdCountPtr,
    OUT    PROPSHEETPAGE **ThirdArray
    )

/*++

Routine Description:

  UI_GetWizardPages is called by WINNT32 when it is preparing the wizard (very
  early in Setup).  It inserts pages we give it into its wizard page array and
  then creates the wizard.  Eventually our wizard procs get called (see wizproc.c)
  no matter if we are upgrading or not.

  The first array comes right after the user chooses to upgrade or not to upgrade.
  The second array comes after the user has specified the source directory.
  The third array comes after DOSNET.INF has been processed.

Arguments:

  FirstCountPtr - Receives the number of elements of FirstArray

  FirstArray - Receives a pointer to an initialized array of PROPSHEETPAGE elements.
               These pages are inserted immediately after the page giving the user
               a choice to upgrade.

  SecondCountPtr - Receives the number of elements of SecondArray

  SecondArray - Receives a pointer to an initialized array of PROPSHEETPAGE elements.
                These pages are inserted immediately after the NT media directory has
                been chosen.

  ThirdCountPtr - Receives the number of elements of ThridArray

  ThirdArray - Receives a pointer to an initialized array of PROPSHEETPAGE elements.
               These pages are inserted immediately after the DOSNET.INF processing
               page.

Return Value:

  Win32 status code.

--*/

{
    static PROPSHEETPAGE StaticPageArray[32];
    INT i, j, k;
    UINT *CountPtrs[3];
    PROPSHEETPAGE **PageArrayPtrs[3];

    CountPtrs[0] = FirstCountPtr;
    CountPtrs[1] = SecondCountPtr;
    CountPtrs[2] = ThirdCountPtr;

    PageArrayPtrs[0] = FirstArray;
    PageArrayPtrs[1] = SecondArray;
    PageArrayPtrs[2] = ThirdArray;

    MYASSERT (g_PageArray[0].Flags & START_GROUP);

    for (i = 0, j = -1, k = 0 ; g_PageArray[i].DlgId ; i++) {
        MYASSERT (k < 32);

        //
        // Set the array start pointer
        //

        if (g_PageArray[i].Flags & START_GROUP) {
            j++;
            MYASSERT (j >= 0 && j <= 2);

            *CountPtrs[j] = 0;
            *PageArrayPtrs[j] = &StaticPageArray[k];
        }

        //
        // Allow group to be skipped with NULL function.  Also, guard against
        // array declaration bug.
        //

        if (!g_PageArray[i].WizProc || j < 0 || j > 2) {
            continue;
        }

        ZeroMemory (&StaticPageArray[k], sizeof (PROPSHEETPAGE));
        StaticPageArray[k].dwSize = sizeof (PROPSHEETPAGE);
        StaticPageArray[k].dwFlags = PSP_DEFAULT;
        StaticPageArray[k].hInstance = g_hInst;
        StaticPageArray[k].pszTemplate = MAKEINTRESOURCE(g_PageArray[i].DlgId);
        StaticPageArray[k].pfnDlgProc  = g_PageArray[i].WizProc;

        k++;
        *CountPtrs[j] += 1;
    }

    return ERROR_SUCCESS;
}


DWORD
UI_CreateNewHwCompDat (
    PVOID p
    )
{
    HWND  hdlg;
    DWORD rc = ERROR_SUCCESS;
    UINT SliceId;

    hdlg = (HWND) p;

    __try {

        //
        // This code executes only when the hwcomp.dat file needs to
        // be rebuilt.  It runs in a separate thread so the UI is
        // responsive.
        //

        InitializeProgressBar (
            GetDlgItem (hdlg, IDC_PROGRESS),
            GetDlgItem (hdlg, IDC_COMPONENT),
            GetDlgItem (hdlg, IDC_SUBCOMPONENT),
            g_CancelFlagPtr
            );

        ProgressBar_SetComponentById(MSG_PREPARING_LIST);
        ProgressBar_SetSubComponent(NULL);

        SliceId = RegisterProgressBarSlice (HwComp_GetProgressMax());

        BeginSliceProcessing (SliceId);

        if (!CreateNtHardwareList (
                SOURCEDIRECTORYARRAY(),
                SOURCEDIRECTORYCOUNT(),
                NULL,
                REGULAR_OUTPUT
                )) {
            DEBUGMSG ((DBG_ERROR, "hwcomp.dat could not be generated"));
            rc = GetLastError();
        }

        EndSliceProcessing();

        ProgressBar_SetComponent(NULL);
        ProgressBar_SetSubComponent(NULL);

        TerminateProgressBar();
    }
    __finally {
        SetLastError (rc);

        if (!(*g_CancelFlagPtr)) {
            //
            // Advance the page when no error, otherwise cancel WINNT32
            //
            PostMessage (hdlg, WMX_REPORT_COMPLETE, 0, rc);

            DEBUGMSG_IF ((
                rc != ERROR_SUCCESS,
                DBG_ERROR,
                "Error in UI_CreateNewHwCompDat caused setup to terminate"
                ));
        }
    }

    return rc;
}


DWORD
UI_ReportThread (
    PVOID p
    )
{
    HWND hdlg;
    DWORD rc = ERROR_SUCCESS;
    TCHAR TextRc[32];

    hdlg = (HWND) p;

    //
    // Start the progress bar
    //

    InitializeProgressBar (
        GetDlgItem (hdlg, IDC_PROGRESS),
        GetDlgItem (hdlg, IDC_COMPONENT),
        GetDlgItem (hdlg, IDC_SUBCOMPONENT),
        g_CancelFlagPtr
        );

    ProgressBar_SetComponentById(MSG_PREPARING_LIST);
    PrepareProcessingProgressBar();

    //
    // Process each component
    //


    __try {

        DEBUGLOGTIME (("Starting System First Routines"));
        rc = RunSysFirstMigrationRoutines ();
        if (rc != ERROR_SUCCESS) {
            __leave;
        }

        DEBUGLOGTIME (("Starting user functions"));
        rc = RunUserMigrationRoutines ();
        if (rc != ERROR_SUCCESS) {
            __leave;
        }

        DEBUGLOGTIME (("Starting System Last Routines"));
        rc = RunSysLastMigrationRoutines ();
        if (rc != ERROR_SUCCESS) {
            __leave;
        }

        ProgressBar_SetComponent(NULL);
        ProgressBar_SetSubComponent(NULL);
     }
    __finally {
        TerminateProgressBar();

        SetLastError (rc);

        if (rc == ERROR_CANCELLED) {
            PostMessage (hdlg, WMX_REPORT_COMPLETE, 0, rc);
            DEBUGMSG ((DBG_VERBOSE, "User requested to cancel"));
        }
        else if (!(*g_CancelFlagPtr)) {
            //
            // Advance the page when no error, otherwise cancel WINNT32
            //
            if (rc == 5 || rc == 32 || rc == 53 || rc == 54 || rc == 55 ||
                rc == 65 || rc == 66 || rc == 67 || rc == 68 || rc == 88 ||
                rc == 123 || rc == 148 || rc == 1203 || rc == 1222 ||
                rc == 123 || rc == 2250
                ) {

                //
                // The error is caused by some sort of network or device
                // failure.  Give a general Access Denied message.
                //

                LOG ((LOG_ERROR, (PCSTR)MSG_ACCESS_DENIED));

            } else if (rc != ERROR_SUCCESS) {

                //
                // Woah, totally unexpected error.  Call Microsoft!!
                //

                if (rc < 1024) {
                    wsprintf (TextRc, TEXT("%u"), rc);
                } else {
                    wsprintf (TextRc, TEXT("0%Xh"), rc);
                }

                LOG ((LOG_ERROR, __FUNCTION__ " failed, rc=%u", rc));
                LOG ((LOG_FATAL_ERROR, (PCSTR)MSG_UNEXPECTED_ERROR_ENCOUNTERED, TextRc));
            }

            PostMessage (hdlg, WMX_REPORT_COMPLETE, 0, rc);
            DEBUGMSG_IF ((
                rc != ERROR_SUCCESS,
                DBG_ERROR,
                "Error in UI_ReportThread caused setup to terminate"
                ));
        }
    }

    return rc;
}






PCTSTR UI_GetMemDbDat (void)
{
    static TCHAR FileName[MAX_TCHAR_PATH];

    StringCopy (FileName, g_TempDir);
    StringCopy (AppendWack (FileName), S_NTSETUPDAT);

    return FileName;
}


//
// WINNT32 calls this from a cleanup thread
//

VOID
UI_Cleanup(
    VOID
    )
{
    MEMDB_ENUM e;

    // Stop the worker thread
    if (g_WorkerThreadHandle) {
        MYASSERT (*g_CancelFlagPtr);

        WaitForSingleObject (g_WorkerThreadHandle, INFINITE);
        CloseHandle (g_WorkerThreadHandle);
        g_WorkerThreadHandle = NULL;
    }

    // Require the background copy thread to complete
    EndCopyThread();

    if (!g_Terminated) {
        // Delete anything in CancelFileDel
        if (*g_CancelFlagPtr) {
            if (MemDbGetValueEx (&e, MEMDB_CATEGORY_CANCELFILEDEL, NULL, NULL)) {
                do {
                    SetFileAttributes (e.szName, FILE_ATTRIBUTE_NORMAL);
                    DeleteFile (e.szName);
                } while (MemDbEnumNextValue (&e));
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\ui\prntsave.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    prntsave.c

Abstract:

    Routines to print or save the incompatibility reports.  Functions
    PrintReport and SaveReport are called when the user clicks
    Save As... or Print... buttons in the UI.  We then present
    a common dialog box to the user and perform the operation.

Author:

    Jim Schmidt (jimschm) 13-Mar-1997

Revision History:

--*/

#include "pch.h"
#include "uip.h"

#include <commdlg.h>
#include <winspool.h>



#define DBG_PRINTSAVE   "Print/Save"


GROWBUFFER g_PunctTable = GROWBUF_INIT;


VOID
BuildPunctTable (
    VOID
    )
{
    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;
    WORD cp;
    TCHAR cpString[16];
    PTSTR p;
    PTSTR q;
    MULTISZ_ENUM e;
    DWORD d;

    GetGlobalCodePage (&cp, NULL);

    wsprintf (cpString, TEXT("%u"), (UINT) cp);
    g_PunctTable.End = 0;

    if (InfFindFirstLine (g_Win95UpgInf, TEXT("Wrap Exceptions"), cpString, &is)) {

        p = InfGetMultiSzField (&is, 1);

        if (EnumFirstMultiSz (&e, p)) {

            do {

                p = (PTSTR) e.CurrentString;

                while (*p) {

                    q = p;

                    if (StringIPrefix (p, TEXT("0x"))) {
                        d = _tcstoul (p + 2, &p, 16);
                    } else {
                        d = _tcstoul (p, &p, 10);
                    }

                    if (q == p) {
                        break;
                    }

                    GrowBufAppendDword (&g_PunctTable, d);

                    if (*p) {
                        p = (PTSTR) SkipSpace (p);
                    }

                    if (*p == TEXT(',')) {
                        p++;
                    }
                }

            } while (EnumNextMultiSz (&e));
        }
    }

    GrowBufAppendDword (&g_PunctTable, 0);

    InfCleanUpInfStruct (&is);
}


VOID
FreePunctTable (
    VOID
    )
{
    FreeGrowBuffer (&g_PunctTable);
}


BOOL
IsPunct (
    MBCHAR Char
    )
{
    PDWORD p;

    if (_ismbcpunct (Char)) {
        return TRUE;
    }

    p = (PDWORD) g_PunctTable.Buf;

    if (p) {
        while (*p) {

            if (*p == Char) {
                return TRUE;
            }

            p++;
        }
    }

    return FALSE;
}


BOOL
pGetSaveAsName (
    IN     HWND ParentWnd,
    IN OUT PTSTR Buffer
    )

/*++

Routine Description:

  Calls common dialog box to obtain the file name in which to save
  the compatibility report text file.

Arguments:

  ParentWnd  - A handle to the parent of the save as dialog
  Buffer     - A caller-supplied buffer.  Supplies a file name to
               initialize the common dialog box with, and receives
               the file name the user chose to use.

Return Value:

  TRUE if the user clicked OK, or FALSE if the user canceled or an
  error occurred.

--*/

{
    TCHAR CwdSave[MAX_TCHAR_PATH];
    OPENFILENAME ofn;
    BOOL SaveFlag;
    TCHAR Filter[512];
    PCTSTR FilterResStr;
    PTSTR p;
    TCHAR desktopFolder[MAX_TCHAR_PATH];
    LPITEMIDLIST pIDL;
    BOOL b = FALSE;

#define MAX_EXT 3

    PCTSTR ext[MAX_EXT];
    INT i = 0;

    FilterResStr = GetStringResource (MSG_FILE_NAME_FILTER);
    if (FilterResStr) {
        StringCopy (Filter, FilterResStr);
        FreeStringResource (FilterResStr);
    } else {
        MYASSERT (FALSE);
        Filter[0] = 0;
    }

    for (p = Filter ; *p ; p = _tcsinc (p)) {
        if (*p == TEXT('|')) {
            *p = 0;
        }
    }
    for (p = Filter; *p; p = GetEndOfString (p) + 1) {
        if (i & 1) {
            //
            // skip the * in "*.ext"
            // if extension is "*.*" reduce that to an empty string (no extension)
            //
            MYASSERT (i / 2 < MAX_EXT);
            ext[i / 2] = _tcsinc (p);
            if (StringMatch (ext[i / 2], TEXT(".*"))) {
                ext[i / 2] = S_EMPTY;
            }
        }
        i++;
    }

    if (SHGetSpecialFolderLocation (ParentWnd, CSIDL_DESKTOP, &pIDL) == S_OK) {
        LPMALLOC pMalloc;
        b = SHGetPathFromIDList (pIDL, desktopFolder);
        if (SHGetMalloc (&pMalloc) == S_OK) {
            IMalloc_Free (pMalloc, pIDL);
            IMalloc_Release (pMalloc);
        }
    }
    if (!b) {
        desktopFolder[0] = 0;
    }

    // Initialize OPENFILENAME
    ZeroMemory (&ofn, sizeof(OPENFILENAME));
    ofn.lStructSize = sizeof(OPENFILENAME);
    ofn.hwndOwner = ParentWnd;
    ofn.lpstrFile = Buffer;
    ofn.lpstrFilter = Filter;
    ofn.nMaxFile = MAX_TCHAR_PATH;

    // Force to begin at Desktop
//  ofn.lpstrInitialDir = TEXT("::{20D04FE0-3AEA-1069-A2D8-08002B30309D}");
    ofn.lpstrInitialDir = desktopFolder;
    ofn.Flags = OFN_NOCHANGEDIR |       // leave the CWD unchanged
                OFN_EXPLORER |
                OFN_OVERWRITEPROMPT |
                OFN_HIDEREADONLY;

    // Let user select disk or directory
    GetCurrentDirectory (sizeof (CwdSave), CwdSave);
    SaveFlag = GetSaveFileName (&ofn);
    SetCurrentDirectory (CwdSave);

    //
    // if no extension provided, append the default one
    // this was selected by the user and returned in ofn.nFilterIndex
    //

#define DEFAULT_EXTENSION   TEXT(".htm")

    p = (PTSTR)GetFileNameFromPath (Buffer);
    if (!p) {
        p = Buffer;
    }
    if (!_tcschr (p, TEXT('.'))) {
        if (SizeOfString (Buffer) + sizeof (DEFAULT_EXTENSION) <= MAX_TCHAR_PATH * sizeof (TCHAR)) {
            if (ofn.nFilterIndex >= MAX_EXT + 1) {
                ofn.nFilterIndex = 1;
            }
            StringCat (p, ext[ofn.nFilterIndex - 1]);
        }
    }
    return SaveFlag;
}


UINT
pCreateWordWrappedString (
    OUT     PTSTR Buffer,
    IN      PCTSTR Str,
    IN      UINT FirstLineSize,
    IN      UINT RestLineSize
    )

/*++

Routine Description:

  Converts a string to a series of lines, where no line is bigger
  than LineSize.  If a buffer is not supplied, this function estimates
  the number of bytes needed.

  If the code page is a far-east code page, then lines are broken at any
  multi-byte character, as well as at the spaces.

Arguments:

  Buffer   - If non-NULL, supplies address of buffer big enough to hold
            enlarged, wrapped string.  If NULL, parameter is ignored.


  Str      - Supplies the string that needs to be wrapped.

  FirstLineSize - Specifies the max size the first line can be.

  RestLineSize - Specifies the max size the remaining lines can be.

Return Value:

  The size of the string copied to Buffer including the terminating NULL,
  or the size of the needed buffer if Buffer is NULL.

--*/

{
    PCTSTR p, Start;
    UINT Col;
    PCTSTR LastSpace;
    CHARTYPE c;
    UINT Size;
    BOOL PrevCharMb;
    UINT LineSize;

    LineSize = FirstLineSize;

    p = Str;
    if (!p)
        return 0;
    Size = SizeOfString(Str);

    if (Buffer) {
        *Buffer = 0;
    }

    while (*p) {
        // Beginning of line
        Col = 0;
        LastSpace = NULL;
        Start = p;
        PrevCharMb = FALSE;

        do {
            // Is this a hard-coded line break?
            c = _tcsnextc (p);
            if (c == TEXT('\r') || c == TEXT('\n')) {
                LastSpace = p;
                p = _tcsinc (p);

                if (c == TEXT('\r') && _tcsnextc (p) == TEXT('\n')) {
                    p = _tcsinc (p);
                } else {
                    Size += sizeof (TCHAR);
                }

                c = TEXT('\n');
                break;
            }
            else if (_istspace (c)) {
                LastSpace = p;
            }
            else if (IsLeadByte (*p)) {
                // MB chars are usually two cols wide
                Col++;

                if (PrevCharMb) {
                    //
                    // If this char is not punctuation, then we can
                    // break here
                    //

                    if (!IsPunct (c)) {
                        LastSpace = p;
                    }
                }

                PrevCharMb = TRUE;
            }
            else {
                if (PrevCharMb) {
                    LastSpace = p;
                }

                PrevCharMb = FALSE;
            }

            // Continue until line gets too long
            Col++;
            p = _tcsinc (p);
        } while (*p && Col < LineSize);

        // If no more text, or line that has no space needs to be broken
        if (!(*p) || (c != TEXT('\n') && !LastSpace)) {
            LastSpace = p;
        }

        if (Buffer) {
            StringCopyAB (Buffer, Start, LastSpace);
            Buffer = GetEndOfString (Buffer);
        }

        if (*p && c != TEXT('\n')) {
            p = LastSpace;
            Size += sizeof (TCHAR) * 2;
        }

        // remove space at start of wrapped line
        while (_tcsnextc (p) == TEXT(' ')) {
            Size -= sizeof (TCHAR);
            p = _tcsinc (p);
        }

        if (Buffer && *p) {
            Buffer = _tcsappend (Buffer, TEXT("\r\n"));
        }

        LineSize = RestLineSize;
    }

    return Size;
}


PCTSTR
CreateIndentedString (
    IN     PCTSTR UnwrappedStr,
    IN     UINT Indent,
    IN     INT HangingIndent,
    IN     UINT LineLen
    )

/*++

Routine Description:

  Takes an unwrapped string, word-wraps it (via pCreateWordWrappedString),
  inserts spaces before each line, optionally skipping the first line.

  If the code page is a far-east code page, then lines are broken at any
  multi-byte character, as well as at the spaces.

Arguments:

  UnwrappedStr  - A pointer to the string that is to be word-wrapped and
                  adjusted with space inserts.
  Indent        - The number of spaces to insert before each line.
  HangingIndent - The adjustment made to the indent after the first line
  LineLen       - The maximum line size.  Spaces must always be smaller
                  than LineLen (and should be considerably smaller).
  FirstLine     - If TRUE, the first line is indented.  If FALSE, the
                  first line is skipped ("hanging indent").

Return Value:

  A pointer to the indented string, or NULL if MemAlloc failed.  The
  caller must free the string with MemFree.

--*/

{
    UINT Size;
    UINT Count;
    PCTSTR p, q;
    PTSTR d;
    PTSTR Dest;
    PTSTR Str;
    UINT FirstLineLen;
    UINT RestLineLen;
    UINT FirstLineIndent;
    UINT RestLineIndent;
    UINT RealIndent;

    if (!UnwrappedStr) {
        return NULL;
    }

    MYASSERT ((INT)Indent + HangingIndent >= 0);
    FirstLineIndent = Indent;
    RestLineIndent = Indent + HangingIndent;

    MYASSERT (LineLen > FirstLineIndent);
    MYASSERT (LineLen > RestLineIndent);
    FirstLineLen = LineLen - FirstLineIndent;
    RestLineLen = LineLen - RestLineIndent;

    //
    // Estimate line size, then do the wrapping
    //

    Str = (PTSTR) MemAlloc (
                      g_hHeap,
                      0,
                      pCreateWordWrappedString (
                            NULL,
                            UnwrappedStr,
                            FirstLineLen,
                            RestLineLen
                            )
                      );

    if (!Str) {
        return NULL;
    }

    pCreateWordWrappedString (
        Str,
        UnwrappedStr,
        FirstLineLen,
        RestLineLen
        );

    if (!FirstLineIndent && !RestLineIndent) {
        return Str;
    }

    //
    // Count number of lines
    //

    for (Count = 1, p = Str ; *p ; p = _tcsinc (p)) {
        if (*p == TEXT('\n')) {
            Count++;
        }
    }

    //
    // Allocate a new buffer that is big enough for all the indented text
    //

    Size = max (FirstLineIndent, RestLineIndent) * Count + SizeOfString (Str);
    Dest = MemAlloc (g_hHeap, 0, Size);
    if (Dest) {

        *Dest = 0;

        //
        // Indent each line
        //

        p = Str;
        d = Dest;

        RealIndent = FirstLineIndent;

        while (*p) {
            for (Count = 0 ; Count < RealIndent ; Count++) {
                *d++ = TEXT(' ');
            }

            q = _tcschr (p, TEXT('\n'));
            if (!q) {
                q = GetEndOfString (p);
            } else {
                q = _tcsinc (q);
            }

            StringCopyAB (d, p, q);
            d = GetEndOfString (d);

            p = q;

            RealIndent = RestLineIndent;
        }
    }

    MemFree (g_hHeap, 0, Str);
    return Dest;
}


BOOL
pSaveReportToDisk (
    IN      HWND Parent,
    IN      PCTSTR FileSpec,
    IN      BOOL Html,
    IN      DWORD MinLevel
    )
{
    HANDLE File;
    BOOL b;
    PCTSTR Msg;

    //
    // Create the report file
    //

    File = CreateFile (
                FileSpec,
                GENERIC_WRITE,
                0,
                NULL,
                CREATE_ALWAYS,
                FILE_ATTRIBUTE_NORMAL,
                NULL
                );

    if (File == INVALID_HANDLE_VALUE) {
        LOG ((LOG_ERROR, "Error while saving report to %s", FileSpec));
        return FALSE;
    }

    //
    // Save the report text to disk
    //

    b = FALSE;

    Msg = CreateReportText (Html, 70, MinLevel, FALSE);

    if (Msg) {
        b = WriteFileString (File, Msg);
    }
    FreeReportText();

    //
    // Close the file and alert the user to save errors!
    //

    CloseHandle (File);

    return b;
}


BOOL
SaveReport (
    IN      HWND Parent,    OPTIONAL
    IN      PCTSTR Path    OPTIONAL
    )

/*++

Routine Description:

  Obtains a file name from the user via common Save As dialog,
  creates the file and writes an incompatibility list to disk.

Arguments:

  Parent    - The parent of the common dialog box. Optional If this is NULL,
              no UI is displayed.
  Path      - The path to save to. If this is NULL, parent must be specified.

Return Value:

  TRUE if the report was saved, or FALSE if the user canceled the
  operation or the save failed.  The user is alerted when the
  save fails.

--*/

{
    TCHAR Buffer[MAX_TCHAR_PATH + 4];
    PCTSTR Str;
    BOOL b;
    DWORD attributes;
    PTSTR p;
    BOOL saved = FALSE;
    BOOL bSaveBothFormats = FALSE;

    MYASSERT(Parent != NULL || Path != NULL);

    //
    // Obtain a path, or use caller-supplied path
    //

    if (Path) {
        attributes = GetFileAttributes(Path);
    }

    if (!Path || attributes != 0xFFFFFFFF && (attributes & FILE_ATTRIBUTE_DIRECTORY)) {
        if (Path) {
            StringCopy(Buffer,Path);
            AppendPathWack(Buffer);
            bSaveBothFormats = TRUE;
        } else {
            Buffer[0] = 0;
        }
        Str = GetStringResource (MSG_DEFAULT_REPORT_FILE);
        MYASSERT (Str);
        if (!Str) {
            return FALSE;
        }
        StringCat (Buffer, Str);
        FreeStringResource (Str);
    } else {
        StringCopy(Buffer,Path);
	}

    if (Parent) {
        if (!pGetSaveAsName (Parent, Buffer)) {
            return FALSE;
        }
    }

    p = _tcsrchr (Buffer, TEXT('.'));
    if (!p || _tcschr (p, TEXT('\\'))) {
        p = GetEndOfString (Buffer);
    }

    //
    // Save as text, if extension is .txt
    //

    if (StringIMatch (p, TEXT(".txt"))) {
        b = pSaveReportToDisk (Parent, Buffer, FALSE, REPORTLEVEL_VERBOSE);

        if (Parent) {
            saved = b;
        }
    } else {
        b = TRUE;
    }

    //
    // Save as HTML unless user chose to save as .txt
    //

    if (b && !saved) {
        if (!Parent && p) {
            StringCopy (p, TEXT(".htm"));
        }

        b = pSaveReportToDisk (Parent, Buffer, TRUE, REPORTLEVEL_VERBOSE);
    }

    if (bSaveBothFormats) {
        StringCopy (p, TEXT(".txt"));
        b = pSaveReportToDisk (Parent, Buffer, FALSE, REPORTLEVEL_VERBOSE);
    }

    if (!b) {
        if (Parent) {
            ResourceMessageBox (Parent, MSG_CANT_SAVE, MB_OK, NULL);
        }
    }

    return TRUE;
}


VOID
pFreePrintMem (
    IN OUT  PRINTDLG *ppd
    )

/*++

Routine Description:

  Frees all memory associated with PRINTDLG structure.

Arguments:

  ppd - Pointer to PRINTDLG structure.

Return Value:

  none

--*/

{
    if (ppd->hDevMode) {
        GlobalFree (ppd->hDevMode);
        ppd->hDevMode = NULL;
    }

    if(ppd->hDevNames) {
        GlobalFree (ppd->hDevNames);
        ppd->hDevNames = NULL;
    }
}


VOID
pInitPrintDlgStruct (
    OUT     PRINTDLG *ppd,
    IN      HWND Parent,
    IN      DWORD Flags
    )

/*++

Routine Description:

  Initializes PRINTDLG structure, setting the owner window and
  print dialog flags.

Arguments:

  ppd    - Pointer to PRINTDLG structure to be initialized
  Parent - Handle to parent window for the dialog
  Flags  - PrintDlg flags (PD_*)

Return Value:

  none (structure is initialized)

--*/

{
    ZeroMemory (ppd, sizeof (PRINTDLG));
    ppd->lStructSize = sizeof (PRINTDLG);
    ppd->hwndOwner = Parent;
    ppd->Flags = Flags;
    ppd->hInstance = g_hInst;
}


HDC
pGetPrintDC (
    IN      HWND Parent
    )

/*++

Routine Description:

  Displays common dialog box to the user, and if the user chooses
  a printer, returns a device context handle.

Arguments:

  Parent - The parent of the common dialog to be displayed

Return Value:

  A handle to a device context of the chosen printer, or NULL if the
  user canceled printing.

--*/

{
    PRINTDLG pd;

    pInitPrintDlgStruct (
        &pd,
        Parent,
        PD_ALLPAGES|PD_NOPAGENUMS|PD_NOSELECTION|PD_RETURNDC
        );

    if (PrintDlg (&pd)) {
        pFreePrintMem (&pd);
        return pd.hDC;
    }

    return NULL;
}


typedef struct {
    HDC         hdc;
    INT         Page;
    INT         Line;
    RECT        HeaderRect;     // in logical units
    RECT        PrintableRect;  // in logical units
    TEXTMETRIC  tm;
    INT         LineHeight;
    INT         TotalLines;     // printable height/line height
    INT         TotalCols;      // printable width/char width
    HFONT       FontHandle;
    BOOL        PageActive;
} PRINT_POSITION, *PPRINT_POSITION;

PCTSTR
pDrawLineText (
    IN OUT  PPRINT_POSITION PrintPos,
    IN      PCTSTR Text,
    IN      DWORD Flags,
    IN      BOOL Header
    )

/*++

Routine Description:

  Draws a single line of text on a printer device context and
  returns a pointer to the next line or nul terminator.

Arguments:

  PrintPos  - A pointer to the current PRINT_POSITION structure
              that gives page position settings.
  Text      - A pointer to the text string containing the line.
  Flags     - Additional DrawText flags (DT_LEFT, DT_CENTER,
              DT_RIGHT and/or DT_RTLREADING)
  Header    - TRUE if text should be written to header, or
              FALSE if it should be written to the current line

Return Value:

  A pointer to the next line within the string, a pointer to the
  nul terminator, or NULL if an error occurred.

--*/

{
    RECT rect;
    PCTSTR p;
    CHARTYPE ch;

    if (Header) {
        CopyMemory (&rect, &PrintPos->HeaderRect, sizeof (RECT));
    } else {
        CopyMemory (&rect, &PrintPos->PrintableRect, sizeof (RECT));
        rect.top += PrintPos->LineHeight * PrintPos->Line;
    }

    Flags = Flags & (DT_CENTER|DT_LEFT|DT_RIGHT|DT_RTLREADING);
    Flags |= DT_TOP|DT_EDITCONTROL|DT_NOPREFIX|DT_EXTERNALLEADING;

    for (ch = 0, p = Text ; *p ; p = _tcsinc (p)) {
        ch = _tcsnextc (p);
        if (ch == TEXT('\n') || ch == TEXT('\r')) {
            break;
        }
    }

    if (p != Text) {
        if (!DrawText (PrintPos->hdc, Text, p - Text, &rect, Flags)) {
            LOG ((LOG_ERROR, "Failure while sending text to printer."));
            return NULL;
        }
    }

    // Skip past line break
    if (ch == TEXT('\r')) {
        p = _tcsinc (p);
        ch = _tcsnextc (p);
    }

    if (ch == TEXT('\n')) {
        p = _tcsinc (p);
    }

    return p;
}


BOOL
pPrintString (
    IN OUT  PPRINT_POSITION PrintPos,
    IN      PCTSTR MultiLineString
    )

/*++

Routine Description:

  Dumps a multi-line string to the printer.  If necessary, the
  string may be printed on a new page.  This function tries to
  eliminate widows and orphans by printing the entire string
  on the same page if possible.

Arguments:

  PrintPos        - The current position information, describing
                    the printer device context, page number, line
                    number and metrics.

  MultiLineString - A pointer to the string to print.

Return Value:

  TRUE if printing was successful, or FALSE if an error occurrred.

--*/

{
    INT LineCount;
    PCTSTR p;
    PCTSTR Str;
    PCTSTR Args[1];
    TCHAR Buffer[32];
    CHARTYPE ch;
    HDC hdc;

    hdc = PrintPos->hdc;

    //
    // Count lines in MultiLineString
    //

    ch = TEXT('\n');
    for (LineCount = 0, p = MultiLineString ; *p ; p = _tcsinc (p)) {
        ch = _tcsnextc (p);
        if (ch == TEXT('\n')) {
            LineCount++;
        }
    }

    if (ch != TEXT('\n')) {
        LineCount++;
    }

    //
    // Widow/orphan suppression: If all lines do not fit on

    // the page, and we are more than half way down the page,
    // roll to the next page.
    //
    if (PrintPos->Line + LineCount > PrintPos->TotalLines) {
        if (PrintPos->Line > PrintPos->TotalLines / 2) {
            // Move to next page
            EndPage (hdc);
            PrintPos->PageActive = FALSE;
            PrintPos->Page++;
            PrintPos->Line = 0;
        }
    }

    //
    // Send each line in MultiLineString
    //

    while (*MultiLineString) {

        //
        // Draw header if necessary
        //

        if (!PrintPos->Line) {
            StartPage (hdc);
            PrintPos->PageActive = TRUE;

            SetMapMode (hdc, MM_TWIPS);
            SelectObject (hdc, PrintPos->FontHandle);
            SetBkMode (hdc, TRANSPARENT);

            //Rectangle (hdc, PrintPos->HeaderRect.left, PrintPos->HeaderRect.top, PrintPos->HeaderRect.right, PrintPos->HeaderRect.bottom);
            //Rectangle (hdc, PrintPos->PrintableRect.left, PrintPos->PrintableRect.top, PrintPos->PrintableRect.right, PrintPos->PrintableRect.bottom);

            wsprintf (Buffer, TEXT("%u"), PrintPos->Page);
            Args[0] = Buffer;

            // Left side
            Str = ParseMessageID (
                        MSG_REPORT_HEADER_LEFT,
                        Args
                        );

            if (Str && *Str) {
                p = pDrawLineText (PrintPos, Str, DT_LEFT, TRUE);

                if (!p) {
                    return FALSE;
                }
            }

            // Center
            Str = ParseMessageID (
                        MSG_REPORT_HEADER_CENTER,
                        Args
                        );

            if (Str && *Str) {

                p = pDrawLineText (PrintPos, Str, DT_CENTER, TRUE);

                if (!p) {
                    return FALSE;
                }
            }

            // Right side
            Str = ParseMessageID (
                        MSG_REPORT_HEADER_RIGHT,
                        Args
                        );

            if (Str && *Str) {

                p = pDrawLineText (PrintPos, Str, DT_RIGHT, TRUE);

                if (!p) {
                    return FALSE;
                }
            }
        }

        //
        // Draw line
        //

        MultiLineString = pDrawLineText (
                            PrintPos,
                            MultiLineString,
                            DT_LEFT,
                            FALSE
                            );

        if (!MultiLineString) {
            return FALSE;
        }

        PrintPos->Line++;
        if (PrintPos->Line >= PrintPos->TotalLines) {
            EndPage (hdc);
            PrintPos->PageActive = FALSE;
            PrintPos->Page++;
            PrintPos->Line = 0;
        }
    }

    return TRUE;
}


VOID
pCalculatePageMetrics (
    IN OUT  PPRINT_POSITION PrintPos
    )

/*++

Routine Description:

  Calculates all the page metrics (margins, header position,
  line count, col count, etc).  Positions are in TWIPS and
  counts are in characters or lines.

Arguments:

  PrintPos - Pointer to PRINT_POSITION structure which gives
             the printer device context.  Structure receives
             metrics.

Return Value:

  none

--*/

{
    INT WidthPixels, HeightPixels;
    INT DpiX, DpiY;
    INT UnprintableLeftPixels, UnprintableTopPixels;
    POINT TempPoint;
    HDC hdc;

    hdc = PrintPos->hdc;

    //
    // Make no assumptions about hdc
    //

    SetMapMode (hdc, MM_TWIPS);
    SelectObject (hdc, PrintPos->FontHandle);
    GetTextMetrics (hdc, &PrintPos->tm);

    //
    // Get device dimensions
    //

    DpiX = GetDeviceCaps (hdc, LOGPIXELSX);
    DpiY = GetDeviceCaps (hdc, LOGPIXELSY);
    UnprintableLeftPixels = GetDeviceCaps (hdc, PHYSICALOFFSETX);
    UnprintableTopPixels  = GetDeviceCaps (hdc, PHYSICALOFFSETY);
    WidthPixels  = GetDeviceCaps (hdc, PHYSICALWIDTH);
    HeightPixels = GetDeviceCaps (hdc, PHYSICALHEIGHT);

    // Calulate 3/4 inch left/right margins
    PrintPos->HeaderRect.left   = (DpiX * 3 / 4) - UnprintableLeftPixels;
    PrintPos->HeaderRect.right  = WidthPixels - (DpiX * 3 / 4) - UnprintableLeftPixels;

    // Calculate 1/2 inch top margin for header
    PrintPos->HeaderRect.top    = (DpiY / 2) - UnprintableTopPixels;
    PrintPos->HeaderRect.bottom = DpiY - UnprintableTopPixels;

    // Convert pixels (device units) into logical units
    DPtoLP (hdc, (LPPOINT) (&PrintPos->HeaderRect), 2);

    // Copy header's left & right margins to printable rect
    // Copy header's bottom margin to printable rect's top margin
    PrintPos->PrintableRect.left  = PrintPos->HeaderRect.left;
    PrintPos->PrintableRect.right = PrintPos->HeaderRect.right;
    PrintPos->PrintableRect.top   = PrintPos->HeaderRect.bottom;

    // Calculate printable rect's bottom margin (3/4 inch)
    TempPoint.x = 0;
    TempPoint.y = HeightPixels - (DpiY * 3 / 4) - UnprintableTopPixels;
    DPtoLP (hdc, &TempPoint, 1);
    PrintPos->PrintableRect.bottom = TempPoint.y;

    PrintPos->LineHeight = -(PrintPos->tm.tmHeight + PrintPos->tm.tmInternalLeading + PrintPos->tm.tmExternalLeading);
    MYASSERT (PrintPos->LineHeight);

    PrintPos->TotalLines = (PrintPos->PrintableRect.bottom - PrintPos->PrintableRect.top) / PrintPos->LineHeight;
    PrintPos->TotalCols  = (PrintPos->PrintableRect.right - PrintPos->PrintableRect.left) / PrintPos->tm.tmAveCharWidth;

}


BOOL
PrintReport (
    IN      HWND Parent,
    IN      DWORD Level
    )

/*++

Routine Description:

  Obtains a printer from the user via common Print dialog,
  starts the print job and sends an incompatibility list to
  one or more pages.

Arguments:

  Parent    - A handle to the parent of the print dialog

Return Value:

  TRUE if printing completed, or FALSE if it was canceled or an
  error occurred.

--*/

{
    HDC hdc;
    PRINT_POSITION pp;
    LOGFONT Font;
    BOOL b;
    DOCINFO di;
    INT JobId;
    PCTSTR Msg;
    HANDLE DefaultUiFont;

    hdc = pGetPrintDC (Parent);
    if (!hdc) {
        return FALSE;         // user canceled print dialog
    }

    if (!BeginMessageProcessing()) {
        // unexpected out-of-memory
        DeleteDC (hdc);
        return FALSE;
    }

    //
    // Initialize PRINT_POSITION
    //

    b = TRUE;
    TurnOnWaitCursor();

    ZeroMemory (&pp, sizeof (pp));
    pp.hdc = hdc;
    pp.Page = 1;

    //
    // Start doc
    //

    ZeroMemory (&di, sizeof (di));
    di.cbSize = sizeof (di);
    di.lpszDocName = GetStringResource (MSG_REPORT_DOC_NAME);
    MYASSERT (di.lpszDocName);
    if (di.lpszDocName) {

        JobId = StartDoc (hdc, &di);
        if (!JobId) {
            LOG ((LOG_ERROR, "Cannot start print job."));
            ResourceMessageBox (Parent, MSG_CANT_PRINT, MB_OK, NULL);
            b = FALSE;
        }
    } else {
        //
        // not enough memory
        //
        JobId = 0;
        b = FALSE;
    }

    if (b) {
        //
        // Create font
        //

        ZeroMemory (&Font, sizeof (Font));
        DefaultUiFont = (HFONT) GetStockObject (DEFAULT_GUI_FONT);
        if (DefaultUiFont) {
            GetObject (DefaultUiFont, sizeof (Font), &Font);


            Font.lfHeight         = 12 * 20;        // height in TWIPS (1/20 of a point)
            Font.lfWeight         = FW_NORMAL;
            Font.lfOutPrecision   = OUT_TT_PRECIS;
            Font.lfPitchAndFamily = FIXED_PITCH|FF_MODERN;

            pp.FontHandle = CreateFontIndirect (&Font);
            if (!pp.FontHandle) {
                LOG ((LOG_ERROR, "Cannot create font for print operation."));
                //
                // deferred this call to the end
                //
                //ResourceMessageBox (Parent, MSG_CANT_PRINT, MB_OK, NULL);
                b = FALSE;
            }
        } else {
            b = FALSE;
        }
    }

    if (b) {
        //
        // Create page metrics
        //

        pCalculatePageMetrics (&pp);

        DEBUGMSG ((DBG_PRINTSAVE, "PrintReport: LineHeight=%i", pp.LineHeight));
        DEBUGMSG ((DBG_PRINTSAVE, "PrintReport: TotalLines=%i", pp.TotalLines));
        DEBUGMSG ((DBG_PRINTSAVE, "PrintReport: TotalCols=%i", pp.TotalCols));
        DEBUGMSG ((DBG_PRINTSAVE, "PrintReport: Header rect: (%i, %i)-(%i, %i)", pp.HeaderRect.left, pp.HeaderRect.top, pp.HeaderRect.right, pp.HeaderRect.bottom));
        DEBUGMSG ((DBG_PRINTSAVE, "PrintReport: Printable rect: (%i, %i)-(%i, %i)", pp.PrintableRect.left, pp.PrintableRect.top, pp.PrintableRect.right, pp.PrintableRect.bottom));

        //
        // Print the report
        //

        Msg = CreateReportText (FALSE, pp.TotalCols, Level, FALSE);
        if (Msg) {
            b = pPrintString (&pp, Msg);
        }
        FreeReportText();
    }

    if (JobId) {
        if (b) {
            if (pp.PageActive) {
                EndPage (hdc);
            }

            EndDoc (hdc);
        } else {
            AbortDoc (hdc);
        }
    }

    DeleteDC (hdc);
    if (pp.FontHandle) {
        DeleteObject (pp.FontHandle);
    }

    TurnOffWaitCursor();

    if (!b) {
        ResourceMessageBox (Parent, MSG_CANT_PRINT, MB_OK, NULL);
    }

    EndMessageProcessing();
    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\ui\report.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    report.c

Abstract:

    This module contains routines that prepare the text that goes
    in the incompatibility report.  The text is displayed as details.

Author:

    Jim Schmidt (jimschm) 28-Oct-1997

Revision History:

    ovidiut     27-Sep-2000 Added Level member to GENERIC_LIST struct
    ovidiut     20-May-1999 Added Flags member to GENERIC_LIST struct
    jimschm     23-Sep-1998 TWAIN group
    jimschm     02-Mar-1998 Added Auto Uninstall group
    jimschm     12-Jan-1998 Reorganized to force messages into a defined message group

--*/

#include "pch.h"
#include "uip.h"

#define DBG_REPORT      "ReportMsg"

#define MAX_SPACES      32
#define MAX_MSGGROUP    2048



//
// ROOT_MSGGROUPS lists all well-defined message groups.  These are the only groups
// that can appear as a root in the report.  Root groups are formatted so their name
// appears with a horizontal line directly under it.  Subgroups are then listed for
// the group.
//
// For example, Installation Notes is a root-level group.  There are several subgroups
// of Installation Notes, and each subgroup might be formatted differently.  Some may
// list several items, while others might have indented detailed descriptions.
//
// Each group can be split into zero or more defined subgroups, and zero or more
// undefined subgroups.  A defined subgroup is one that either has a handler declared
// below in SUBGROUP_HANDLERS, or it is a list, defined in SUBGROUP_LISTS below.
// If a group is split this way, then there can be introduction text placed above
// all defined subgroups, and there can also be introduction text placed above
// all undefined subgroups.
//
// For example, the Incompatible Hardware category might be split as follows:
//
//      Incompatible Hardware                               (A)
//      ---------------------
//      The following hardware is bad:                      (B)
//          a                                               (S)
//          b                                               (S)
//          c                                               (S)
//
//      Contact the manufacturer.                           (B)
//
//      The following hardware has limited functionality:   (A)
//
//      foo video                                           (S)
//          This device does not have 1280x1024 mode on NT. (M)
//
// In the example above, the text "Incompatible Hardware" and the underline would
// come from the group's intro text.  The text "The following hardware is bad"
// comes from the hardware list subgroup intro.  Then a, b and c come from the
// subgroup's subgroup. "Contact the manuafacturer" comes from the subgroup's conclusion
// text.  Then "The following hardware" text comes from the group's other intro.  And
// finally the remaining text comes from undefined subgroups (foo video in this case).
//
// NOTES:
// (A) indicates the message was specified in the ROOT_MSGGROUPS macro
// (B) indicates the message was specified in the SUBGROUPS_LIST macro
// (S) indicates the text was specified as the last subgroup in a MsgMgr call
// (M) indicates the message was specified in a MsgMgr call
//
// DO NOT change ROOT_MSGGROUPS unless you know what you are doing.
//
// Syntax:  (one of the following)
//
//  NO_TEXT(<msgid>)        - Group has no intro text
//  HAS_INTRO(<msgid>)      - Group has intro text
//  HAS_OTHER(<msgid>)      - Group has intro text for undefined subgroups
//  HAS_BOTH(<msgid)        - Group has both types of intro text
//
// The following MSG_* strings are required to be defined in msg.mc:
//
// NO_TEXT - <msgid>_ROOT
// HAS_INTRO - <msgid>_ROOT, <msgid>_INTRO, <msgid>_INTRO_HTML
// HAS_OTHER - <msgid>_ROOT, <msgid>_OTHER, <msgid>_OTHER_HTML
// HAS_BOTH -  <msgid>_ROOT, <msgid>_INTRO, <msgid>_INTRO_HTML, <msgid>_OTHER, <msgid>_OTHER_HTML
//

//
// REMEMBER: _ROOT, _INTRO, _INTRO_HTML, _OTHER and _OTHER_HTML are appended to
//           the constants in ROOT_MSGGROUPS, as described above.
//

#if 0

    HAS_INTRO(MSG_MUST_UNINSTALL, REPORTLEVEL_BLOCKING)     \
    NO_TEXT(MSG_REINSTALL_BLOCK, REPORTLEVEL_BLOCKING)      \

#endif

#define ROOT_MSGGROUPS                                      \
    HAS_OTHER(MSG_BLOCKING_ITEMS, REPORTLEVEL_BLOCKING)     \
    HAS_BOTH(MSG_INCOMPATIBLE_HARDWARE, REPORTLEVEL_ERROR)  \
    HAS_INTRO(MSG_INCOMPATIBLE, REPORTLEVEL_WARNING)        \
    HAS_INTRO(MSG_REINSTALL, REPORTLEVEL_WARNING)           \
    HAS_INTRO(MSG_LOSTSETTINGS, REPORTLEVEL_WARNING)        \
    HAS_INTRO(MSG_MISC_WARNINGS, REPORTLEVEL_WARNING)       \
    HAS_INTRO(MSG_MINOR_PROBLEM, REPORTLEVEL_VERBOSE)       \
    HAS_INTRO(MSG_DOS_DESIGNED, REPORTLEVEL_VERBOSE)        \
    HAS_INTRO(MSG_INSTALL_NOTES, REPORTLEVEL_VERBOSE)       \
    HAS_INTRO(MSG_MIGDLL, REPORTLEVEL_VERBOSE)              \
    NO_TEXT(MSG_UNKNOWN, REPORTLEVEL_VERBOSE)               \


//
// SUBGROUP_HANDLERS declares special formatting handlers, which format text of subgroup
// messages.  There are two common default handlers that are used by most subgroups --
// the generic list handler and the default message handler.  If your subgroup requires
// unique message formatting, define your handler in SUBGROUP_HANDLERS.
//
// Syntax:
//
//  DECLARE(<groupid>, fn, <DWORD arg>)
//
// groupid specifies the exact text used for display and can be either a group or
// a subgroup of one of the groups defined above in ROOT_MSGGROUPS.  The report
// generation code will search each segment of the group name for the specified string.
//
// For example, MSG_NAMECHANGE_WARNING_GROUP is "Names That Will Change" and is in the
// Installation Notes group.  By specifying this string ID, and a handler function,
// the handler is called all name change messages, and the report generation code
// will process the name change messages during the formatting of Installation Notes.
//


#define SUBGROUP_HANDLERS                                                       \
    DECLARE(MSG_UNSUPPORTED_HARDWARE_PNP_SUBGROUP, pAddPnpHardwareToReport, 0)  \
    DECLARE(MSG_INCOMPATIBLE_HARDWARE_PNP_SUBGROUP, pAddPnpHardwareToReport, 1) \
    DECLARE(MSG_REINSTALL_HARDWARE_PNP_SUBGROUP, pAddPnpHardwareToReport, 2)    \
    DECLARE(0, pDefaultHandler, 0)


//
// *This is where changes are commonly made*
//
// SUBGROUP_LISTS define the string IDs for the intro text and summary text for
// the message subgroup (text not needed for root groups).  This step puts your subgroup
// in the correct root-level group.
//
// If you have a simple list, you only need to add an entry to this macro expansion
// list, then you're done.  The generic list handler will be processed for your
// subgroup.
//
// NOTE: You must put all info in the group when calling message manager APIs.  That
//       is, the group should be formatted as <group>\<subgroup>\<list-item>.
//
// Syntax:
//
//  DECLARE(<rootid>, <toptext>, <toptext-html>, <bottomtext>, <bottomtext-html>, <formatargs>, <flags>, <level>)
//
// Specify zero for no message.  If you specify zero for plain text, you must
// also specify zero for the html text.
//
// Use flags to specify additional features, like RF_BOLDITEMS to display items in
// bold case.
//

#define SUBGROUP_LISTS                                  \
    DECLARE(                                            \
        MSG_BLOCKING_HARDWARE_SUBGROUP,                 \
        MSG_BLOCKING_HARDWARE_INTRO,                    \
        MSG_BLOCKING_HARDWARE_INTRO_HTML,               \
        MSG_UNINDENT,                                   \
        MSG_UNINDENT_HTML,                              \
        NULL,                                           \
        RF_BOLDITEMS | RF_ENABLEMSG | RF_USEROOT,       \
        REPORTLEVEL_BLOCKING                            \
        )                                               \
    DECLARE(                                            \
        MSG_MUST_UNINSTALL_ROOT,                        \
        MSG_MUST_UNINSTALL_INTRO,                       \
        MSG_MUST_UNINSTALL_INTRO_HTML,                  \
        MSG_UNINDENT,                                   \
        MSG_UNINDENT_HTML,                              \
        NULL,                                           \
        RF_BOLDITEMS | RF_ENABLEMSG | RF_USEROOT,       \
        REPORTLEVEL_BLOCKING                            \
        )                                               \
    DECLARE(                                            \
        MSG_REINSTALL_BLOCK_ROOT,                       \
        MSG_REPORT_REINSTALL_BLOCK_INSTRUCTIONS,        \
        MSG_REPORT_REINSTALL_BLOCK_INSTRUCTIONS_HTML,   \
        MSG_UNINDENT,                                   \
        MSG_UNINDENT_HTML,                              \
        NULL,                                           \
        RF_BOLDITEMS | RF_ENABLEMSG | RF_USEROOT,       \
        REPORTLEVEL_BLOCKING                            \
        )                                               \
    DECLARE(                                            \
        MSG_INCOMPATIBLE_DETAIL_SUBGROUP,               \
        MSG_REPORT_BEGIN_INDENT,                        \
        MSG_REPORT_BEGIN_INDENT_HTML,                   \
        MSG_UNINDENT,                                   \
        MSG_UNINDENT_HTML,                              \
        NULL,                                           \
        RF_BOLDITEMS | RF_ENABLEMSG | RF_USEROOT,       \
        REPORTLEVEL_WARNING                             \
        )                                               \
    DECLARE(                                            \
        MSG_REINSTALL_DETAIL_SUBGROUP,                  \
        MSG_REPORT_BEGIN_INDENT,                        \
        MSG_REPORT_BEGIN_INDENT_HTML,                   \
        MSG_UNINDENT,                                   \
        MSG_UNINDENT_HTML,                              \
        NULL,                                           \
        RF_BOLDITEMS | RF_ENABLEMSG | RF_USEROOT,       \
        REPORTLEVEL_WARNING                             \
        )                                               \
    DECLARE(                                            \
        MSG_REINSTALL_LIST_SUBGROUP,                    \
        MSG_REPORT_BEGIN_INDENT,                        \
        MSG_REPORT_BEGIN_INDENT_HTML,                   \
        MSG_UNINDENT,                                   \
        MSG_UNINDENT_HTML,                              \
        NULL,                                           \
        RF_BOLDITEMS | RF_USEROOT,                      \
        REPORTLEVEL_WARNING                             \
        )                                               \
    DECLARE(                                            \
        MSG_UNKNOWN_ROOT,                               \
        MSG_REPORT_UNKNOWN_INSTRUCTIONS,                \
        MSG_REPORT_UNKNOWN_INSTRUCTIONS_HTML,           \
        0,                                              \
        0,                                              \
        NULL,                                           \
        RF_BOLDITEMS,                                   \
        REPORTLEVEL_VERBOSE                             \
        )                                               \
    DECLARE(                                            \
        MSG_HWPROFILES_SUBGROUP,                        \
        MSG_HWPROFILES_INTRO,                           \
        MSG_HWPROFILES_INTRO_HTML,                      \
        MSG_UNINDENT2,                                  \
        MSG_UNINDENT2_HTML,                             \
        NULL,                                           \
        RF_BOLDITEMS,                                   \
        REPORTLEVEL_VERBOSE                             \
        )                                               \
    DECLARE(                                            \
        MSG_REG_SETTINGS_SUBGROUP,                      \
        MSG_REG_SETTINGS_INCOMPLETE,                    \
        MSG_REG_SETTINGS_INCOMPLETE_HTML,               \
        MSG_UNINDENT2,                                  \
        MSG_UNINDENT2_HTML,                             \
        NULL,                                           \
        RF_BOLDITEMS,                                   \
        REPORTLEVEL_INFORMATION                         \
        )                                               \
    DECLARE(                                            \
        MSG_SHELL_SETTINGS_SUBGROUP,                    \
        MSG_SHELL_SETTINGS_INCOMPLETE,                  \
        MSG_SHELL_SETTINGS_INCOMPLETE_HTML,             \
        MSG_UNINDENT2,                                  \
        MSG_UNINDENT2_HTML,                             \
        NULL,                                           \
        RF_BOLDITEMS,                                   \
        REPORTLEVEL_INFORMATION                         \
        )                                               \
    DECLARE(                                            \
        MSG_DRIVE_EXCLUDED_SUBGROUP,                    \
        MSG_DRIVE_EXCLUDED_INTRO,                       \
        MSG_DRIVE_EXCLUDED_INTRO_HTML,                  \
        MSG_UNINDENT2,                                  \
        MSG_UNINDENT2_HTML,                             \
        NULL,                                           \
        RF_BOLDITEMS,                                   \
        REPORTLEVEL_VERBOSE                             \
        )                                               \
    DECLARE(                                            \
        MSG_DRIVE_NETWORK_SUBGROUP,                     \
        MSG_DRIVE_NETWORK_INTRO,                        \
        MSG_DRIVE_NETWORK_INTRO_HTML,                   \
        MSG_UNINDENT2,                                  \
        MSG_UNINDENT2_HTML,                             \
        NULL,                                           \
        RF_BOLDITEMS,                                   \
        REPORTLEVEL_VERBOSE                             \
        )                                               \
    DECLARE(                                            \
        MSG_DRIVE_RAM_SUBGROUP,                         \
        MSG_DRIVE_RAM_INTRO,                            \
        MSG_DRIVE_RAM_INTRO_HTML,                       \
        MSG_UNINDENT2,                                  \
        MSG_UNINDENT2_HTML,                             \
        NULL,                                           \
        RF_BOLDITEMS,                                   \
        REPORTLEVEL_VERBOSE                             \
        )                                               \
    DECLARE(                                            \
        MSG_DRIVE_SUBST_SUBGROUP,                       \
        MSG_DRIVE_SUBST_INTRO,                          \
        MSG_DRIVE_SUBST_INTRO_HTML,                     \
        MSG_UNINDENT2,                                  \
        MSG_UNINDENT2_HTML,                             \
        NULL,                                           \
        RF_BOLDITEMS,                                   \
        REPORTLEVEL_VERBOSE                             \
        )                                               \
    DECLARE(                                            \
        MSG_DRIVE_INACCESSIBLE_SUBGROUP,                \
        MSG_DRIVE_INACCESSIBLE_INTRO,                   \
        MSG_DRIVE_INACCESSIBLE_INTRO_HTML,              \
        MSG_UNINDENT2,                                  \
        MSG_UNINDENT2_HTML,                             \
        NULL,                                           \
        RF_BOLDITEMS,                                   \
        REPORTLEVEL_VERBOSE                             \
        )                                               \
    DECLARE(                                            \
        MSG_HELPFILES_SUBGROUP,                         \
        MSG_HELPFILES_INTRO,                            \
        MSG_HELPFILES_INTRO_HTML,                       \
        MSG_UNINDENT2,                                  \
        MSG_UNINDENT2_HTML,                             \
        NULL,                                           \
        RF_BOLDITEMS,                                   \
        REPORTLEVEL_VERBOSE                             \
        )                                               \
    DECLARE(                                            \
        MSG_TWAIN_SUBGROUP,                             \
        MSG_TWAIN_DEVICES_UNKNOWN,                      \
        MSG_TWAIN_DEVICES_UNKNOWN_HTML,                 \
        MSG_UNINDENT2,                                  \
        MSG_UNINDENT2_HTML,                             \
        NULL,                                           \
        RF_BOLDITEMS,                                   \
        REPORTLEVEL_ERROR                               \
        )                                               \
    DECLARE(                                            \
        MSG_JOYSTICK_SUBGROUP,                          \
        MSG_JOYSTICK_DEVICE_UNKNOWN,                    \
        MSG_JOYSTICK_DEVICE_UNKNOWN_HTML,               \
        MSG_UNINDENT2,                                  \
        MSG_UNINDENT2_HTML,                             \
        NULL,                                           \
        RF_BOLDITEMS,                                   \
        REPORTLEVEL_ERROR                               \
        )                                               \
    DECLARE(                                            \
        MSG_CONNECTION_BADPROTOCOL_SUBGROUP,            \
        MSG_CONNECTION_BADPROTOCOL_INTRO,               \
        MSG_CONNECTION_BADPROTOCOL_INTRO_HTML,          \
        MSG_UNINDENT2,                                  \
        MSG_UNINDENT2_HTML,                             \
        NULL,                                           \
        RF_BOLDITEMS,                                   \
        REPORTLEVEL_WARNING                             \
        )                                               \
    DECLARE(                                            \
        MSG_CONNECTION_PASSWORD_SUBGROUP,               \
        MSG_CONNECTION_PASSWORD_INTRO,                  \
        MSG_CONNECTION_PASSWORD_INTRO_HTML,             \
        MSG_UNINDENT2,                                  \
        MSG_UNINDENT2_HTML,                             \
        NULL,                                           \
        RF_BOLDITEMS,                                   \
        REPORTLEVEL_WARNING                             \
        )                                               \
    DECLARE(                                            \
        MSG_RUNNING_MIGRATION_DLLS_SUBGROUP,            \
        MSG_RUNNING_MIGRATION_DLLS_INTRO,               \
        MSG_RUNNING_MIGRATION_DLLS_INTRO_HTML,          \
        MSG_UNINDENT2,                                  \
        MSG_UNINDENT2_HTML,                             \
        NULL,                                           \
        RF_BOLDITEMS,                                   \
        REPORTLEVEL_VERBOSE                             \
        )                                               \
    DECLARE(                                            \
        MSG_TOTALLY_INCOMPATIBLE_SUBGROUP,              \
        MSG_TOTALLY_INCOMPATIBLE_INTRO,                 \
        MSG_TOTALLY_INCOMPATIBLE_INTRO_HTML,            \
        MSG_TOTALLY_INCOMPATIBLE_TRAIL,                 \
        MSG_TOTALLY_INCOMPATIBLE_TRAIL_HTML,            \
        NULL,                                           \
        RF_BOLDITEMS | RF_ENABLEMSG,                    \
        REPORTLEVEL_WARNING                             \
        )                                               \
    DECLARE(                                            \
        MSG_INCOMPATIBLE_PREINSTALLED_UTIL_SUBGROUP,    \
        MSG_PREINSTALLED_UTIL_INSTRUCTIONS,             \
        MSG_PREINSTALLED_UTIL_INSTRUCTIONS_HTML,        \
        MSG_UNINDENT2,                                  \
        MSG_UNINDENT2_HTML,                             \
        NULL,                                           \
        RF_BOLDITEMS,                                   \
        REPORTLEVEL_VERBOSE                             \
        )                                               \
    DECLARE(                                            \
        MSG_INCOMPATIBLE_UTIL_SIMILAR_FEATURE_SUBGROUP, \
        MSG_PREINSTALLED_SIMILAR_FEATURE,               \
        MSG_PREINSTALLED_SIMILAR_FEATURE_HTML,          \
        MSG_UNINDENT2,                                  \
        MSG_UNINDENT2_HTML,                             \
        NULL,                                           \
        RF_BOLDITEMS,                                   \
        REPORTLEVEL_VERBOSE                             \
        )                                               \
    DECLARE(                                            \
        MSG_INCOMPATIBLE_HW_UTIL_SUBGROUP,              \
        MSG_HW_UTIL_INTRO,                              \
        MSG_HW_UTIL_INTRO_HTML,                         \
        MSG_UNINDENT2,                                  \
        MSG_UNINDENT2_HTML,                             \
        NULL,                                           \
        RF_BOLDITEMS,                                   \
        REPORTLEVEL_VERBOSE                             \
        )                                               \
    DECLARE(                                            \
        MSG_REMOVED_FOR_SAFETY_SUBGROUP,                \
        MSG_REMOVED_FOR_SAFETY_INTRO,                   \
        MSG_REMOVED_FOR_SAFETY_INTRO_HTML,              \
        MSG_UNINDENT,                                   \
        MSG_UNINDENT_HTML,                              \
        NULL,                                           \
        RF_BOLDITEMS,                                   \
        REPORTLEVEL_INFORMATION                         \
        )                                               \
    DECLARE(                                            \
        MSG_DIRECTORY_COLLISION_SUBGROUP,               \
        MSG_DIRECTORY_COLLISION_INTRO,                  \
        MSG_DIRECTORY_COLLISION_INTRO_HTML,             \
        MSG_UNINDENT,                                   \
        MSG_UNINDENT_HTML,                              \
        NULL,                                           \
        RF_USESUBGROUP,                                 \
        REPORTLEVEL_VERBOSE                             \
        )                                               \
    DECLARE(                                            \
        MSG_BACKUP_DETECTED_LIST_SUBGROUP,              \
        MSG_BACKUP_DETECTED_INTRO,                      \
        MSG_BACKUP_DETECTED_INTRO_HTML,                 \
        MSG_BACKUP_DETECTED_TRAIL,                      \
        MSG_BACKUP_DETECTED_TRAIL_HTML,                 \
        g_BackupDetectedFormatArgs,                     \
        RF_BOLDITEMS,                                   \
        REPORTLEVEL_VERBOSE                             \
        )                                               \
    DECLARE(                                            \
        MSG_NAMECHANGE_WARNING_GROUP,                   \
        MSG_REPORT_NAMECHANGE,                          \
        MSG_REPORT_NAMECHANGE_HTML,                     \
        MSG_UNINDENT2,                                  \
        MSG_UNINDENT2_HTML,                             \
        NULL,                                           \
        RF_BOLDITEMS,                                   \
        REPORTLEVEL_INFORMATION                         \
        )                                               \



//
// Declare an array of message groups
//

typedef struct {
    DWORD GroupLevel;
    UINT MsgGroup;
    UINT IntroId;
    UINT IntroIdHtml;
    UINT OtherId;
    UINT OtherIdHtml;

    // members initialized to zero
    UINT NameLen;
    PCTSTR Name;
    PCTSTR IntroIdStr;
    PCTSTR IntroIdHtmlStr;
    PCTSTR OtherIdStr;
    PCTSTR OtherIdHtmlStr;
} MSGGROUP_PROPS, *PMSGGROUP_PROPS;




#define NO_TEXT(root,level)       {level,root##_ROOT},
#define HAS_INTRO(root,level)     {level,root##_ROOT, root##_INTRO, root##_INTRO_HTML},
#define HAS_OTHER(root,level)     {level,root##_ROOT, 0, 0, root##_OTHER, root##_OTHER_HTML},
#define HAS_BOTH(root,level)      {level,root##_ROOT, root##_INTRO, root##_INTRO_HTML, root##_OTHER, root##_OTHER_HTML},

MSGGROUP_PROPS g_MsgGroupRoot[] = {
    ROOT_MSGGROUPS /* , */
    {0,0,0,0,0,0}
};

#undef NO_TEXT
#undef HAS_INTRO
#undef HAS_OTHER
#undef HAS_BOTH


//
// Declare the handler prototypes
//

typedef enum {
    INIT,
    PROCESS_ITEM,
    CLEANUP
} CALLCONTEXT;

typedef BOOL(SUBGROUP_HANDLER_PROTOTYPE)(
                IN      CALLCONTEXT Context,
                IN      PMSGGROUP_PROPS Group,
                IN OUT  PGROWBUFFER StringBufPtr,
                IN      PCTSTR SubGroup,
                IN      PCTSTR Message,
                IN      DWORD Level,
                IN      BOOL HtmlFormat,
                IN OUT  PVOID *State,
                IN      DWORD Arg
                );

typedef SUBGROUP_HANDLER_PROTOTYPE * SUBGROUP_HANDLER;

#define DECLARE(msgid,fn,arg) SUBGROUP_HANDLER_PROTOTYPE fn;

SUBGROUP_HANDLERS

#undef DECLARE

//
// Declare the message ID array
//

#define DECLARE(msgid,fn,arg) {fn, msgid, (DWORD) (arg)},

typedef struct {
    SUBGROUP_HANDLER Fn;
    UINT Id;
    DWORD Arg;

    // rest are init'd with zeros
    PCTSTR SubGroupStr;
    UINT SubGroupStrLen;
    PVOID State;
} HANDLER_LIST, *PHANDLER_LIST;

HANDLER_LIST g_HandlerNames[] = {
    SUBGROUP_HANDLERS /* , */
    {NULL, 0, 0, 0}
};

#undef DECLARE

//
// Declare array of generic lists
//

typedef struct {
    UINT Id;
    PCTSTR SubGroupStr;
    UINT SubGroupStrLen;
    UINT IntroId;
    UINT IntroIdHtml;
    UINT ConclusionId;
    UINT ConclusionIdHtml;
    PCTSTR **FormatArgs;
    DWORD Flags;
    DWORD ListLevel;
} GENERIC_LIST, *PGENERIC_LIST;

//
// definition of flags in GENERIC_LIST.Flags
//
#define RF_BOLDITEMS    0x0001
#define RF_ENABLEMSG    0x0002
#define RF_MSGFIRST     0x0004
#define RF_USEROOT      0x0008
#define RF_USESUBGROUP  0x0010
#define RF_INDENTMSG    0x0020

//
// macros to test flags
//
#define FLAGSET_BOLDITEMS(Flags)            ((Flags & RF_BOLDITEMS) != 0)
#define FLAGSET_ENABLE_MESSAGE_ITEMS(Flags) ((Flags & RF_ENABLEMSG) != 0)
#define FLAGSET_MESSAGE_ITEMS_FIRST(Flags)  ((Flags & RF_MSGFIRST) != 0)
#define FLAGSET_USEROOT(Flags)              ((Flags & RF_USEROOT) != 0)
#define FLAGSET_USESUBGROUP(Flags)          ((Flags & RF_USESUBGROUP) != 0)
#define FLAGSET_INDENT_MESSAGE(Flags)       ((Flags & RF_INDENTMSG) != 0)

//
// this is the array of pointers to strings for formatting MSG_BACKUP_DETECTED_SUBGROUP
// they are the same for all 4 IDs (MSG_BACKUP_DETECTED_INTRO etc.)
//
static PCTSTR g_BackupDetectedFormatArgsAllIDs[1] = {
    g_Win95Name
};

static PCTSTR *g_BackupDetectedFormatArgs[4] = {
    g_BackupDetectedFormatArgsAllIDs,
    g_BackupDetectedFormatArgsAllIDs,
    g_BackupDetectedFormatArgsAllIDs,
    g_BackupDetectedFormatArgsAllIDs
};

#define DECLARE(rootid,intro,introhtml,conclusion,conclusionhtml,formatargs,flags,level)   {rootid, NULL, 0, intro, introhtml, conclusion, conclusionhtml, formatargs, flags, level},

GENERIC_LIST g_GenericList[] = {
    SUBGROUP_LISTS /* , */
    {0, NULL, 0, 0, 0, 0, 0, NULL, 0, 0}
};

#undef DECLARE



#define SUBGROUP_REPORT_LEVELS                                                  \
    DECLARE(MSG_NETWORK_PROTOCOLS, REPORTLEVEL_WARNING)                         \


#define ONEBITSET(x)        ((x) && !((x) & ((x) - 1)))
#define LEVELTOMASK(x)      (((x) << 1) - 1)

//
// Types
//

typedef struct {
    GROWLIST List;
    GROWLIST MessageItems;
    GROWLIST Messages;
} ITEMLIST, *PITEMLIST;

typedef struct {
    TCHAR LastClass[MEMDB_MAX];
} PNPFORMATSTATE, *PPNPFORMATSTATE;


typedef struct {
    PCTSTR  HtmlTagStr;
    UINT    Length;
} HTMLTAG, *PHTMLTAG;

typedef struct {
    UINT    MessageId;
    PCTSTR  MessageStr;
    UINT    MessageLength;
    DWORD   ReportLevel;
} MAPMESSAGETOREPORTLEVEL, *PMAPMESSAGETOREPORTLEVEL;

//
// Globals
//

static UINT g_TotalCols;
static GROWBUFFER g_ReportString = GROWBUF_INIT;
static TCHAR g_LastMsgGroupBuf[MAX_MSGGROUP];
static BOOL g_ListFormat;

#define DECLARE(messageid,reportlevel)   {messageid, NULL, 0, reportlevel},

static MAPMESSAGETOREPORTLEVEL g_MapMessageToLevel[] = {
    SUBGROUP_REPORT_LEVELS
    {0, NULL, 0, 0}
};

#undef DECLARE


//
// Local prototypes
//

VOID
pLoadAllHandlerStrings (
    VOID
    );

VOID
pFreeAllHandlerStrings (
    VOID
    );

PMSGGROUP_PROPS
pFindMsgGroupStruct (
    IN      PCTSTR MsgGroup
    );

PMSGGROUP_PROPS
pFindMsgGroupStructById (
    IN      UINT GroupId
    );

PCTSTR
pEncodeMessage (
    IN      PCTSTR Message,
    IN      BOOL HtmlFormat
    );

//
// Implementation
//



POOLHANDLE g_MessagePool;

BOOL
InitCompatTable (
    VOID
    )

/*++

Routine Description:

  InitCompatTable initializes the resources needed to hold the incompatibility
  report in memory.

Arguments:

  none

Return Value:

  TRUE if the init succeeded, or FALSE if it failed.

--*/

{
    g_MessagePool = PoolMemInitNamedPool ("Incompatibility Messages");
    if (!g_MessagePool) {
        return FALSE;
    }

    pLoadAllHandlerStrings();

    return MemDbCreateTemporaryKey (MEMDB_CATEGORY_REPORT);
}


VOID
FreeCompatTable (
    VOID
    )

/*++

Routine Description:

  FreeCompatTable frees the resources used to hold incompatibility messages.

Arguments:

  none

Return Value:

  none

--*/

{
    PoolMemDestroyPool (g_MessagePool);
    pFreeAllHandlerStrings();
}


PMAPMESSAGETOREPORTLEVEL
pGetMapStructFromMessageGroup (
    IN      PCTSTR FullMsgGroup
    )

/*++

Routine Description:

  pGetMapStructFromMessageGroup returns a pointer to the MAPMESSAGETOREPORTLEVEL
  associated with the given message group.

Arguments:

  FullMsgGroup - Specifies the name of the message group in question

Return Value:

  A pointer to the associated struct, if any; NULL if not found

--*/

{
    PMAPMESSAGETOREPORTLEVEL pMap;
    PCTSTR p;
    CHARTYPE ch;

    if (!FullMsgGroup) {
        return FALSE;
    }

    for (pMap = g_MapMessageToLevel; pMap->MessageId; pMap++) {

        if (StringIMatchCharCount (
                FullMsgGroup,
                pMap->MessageStr,
                pMap->MessageLength
                )) {

            p = CharCountToPointer (FullMsgGroup, pMap->MessageLength);
            ch = _tcsnextc (p);

            if (ch == TEXT('\\') || ch == 0) {
                return pMap;
            }
        }
    }

    return NULL;
}


BOOL
pIsThisTheGenericList (
    IN      PCTSTR FullMsgGroup,
    IN      PGENERIC_LIST List
    )

/*++

Routine Description:

  pIsThisTheGenericList compares the specified message group list name
  against the specified message group.

Arguments:

  FullMsgGroup - Specifies the name of the message group in question

  List - Specifies the message group list to compare against FullMsgGroup

Return Value:

  TRUE if List handles the FullMsgGroup message, or FALSE if not.

--*/

{
    PCTSTR p;
    CHARTYPE ch;

    if (!List) {
        return FALSE;
    }

    if (StringIMatchCharCount (
            FullMsgGroup,
            List->SubGroupStr,
            List->SubGroupStrLen
            )) {

        p = CharCountToPointer (FullMsgGroup, List->SubGroupStrLen);
        ch = _tcsnextc (p);

        if (ch == TEXT('\\') || ch == 0) {
            return TRUE;
        }
    }

    return FALSE;
}


PGENERIC_LIST
pSearchForGenericList (
    IN      PCTSTR Str
    )

/*++

Routine Description:

  pSearchForGenericList scans the list of generic lists for one that can
  handle the current message group.  A pointer to the generic list structure is
  returned.

Arguments:

  Str - Specifies the message group to locate a handler for, and may include
        backslashes and subgroups.

Return Value:

  A pointer to the generic list structure if found, or NULL if no generic
  list exists for the message group.

--*/

{
    PGENERIC_LIST List;

    for (List = g_GenericList ; List->Id ; List++) {
        if (pIsThisTheGenericList (Str, List)) {
            return List;
        }
    }

    return NULL;
}



BOOL
AddBadSoftware (
    IN  PCTSTR MessageGroup,
    IN  PCTSTR Message,         OPTIONAL
    IN  BOOL IncludeOnShortReport
    )

/*++

Routine Description:

  AddBadSoftware adds a message to the incompatibility report data structures.
  It duplicates Message into a pool, and indexes the message by message group
  with memdb.

Arguments:

  MessageGroup - Specifies the name of the message group, and may include
                 subgroups.  The root of MessageGroup must be a defined category.
                 See ROOT_MSGGROUPS above.

  Message - Specifies the text for the message, if any.

  IncludeOnShortReport - Specifies TRUE if the message should appear in the list
                         view of the short report.

Return Value:

  TRUE if the operation succeeded, or FALSE if it failed.

--*/

{
    UINT BytesNeeded;
    PCTSTR DupMsg;
    TCHAR FilteredMessageGroup[MEMDB_MAX];
    PMSGGROUP_PROPS Group;
    TCHAR key[MEMDB_MAX];
    PGENERIC_LIST list = NULL;
    PTSTR p;
    PMAPMESSAGETOREPORTLEVEL pMap;
    DWORD level = REPORTLEVEL_NONE;

    if (Message && Message[0] == 0) {
        Message = NULL;
    }

    Group = pFindMsgGroupStruct (MessageGroup);
    if (!Group) {
        //
        // This message group is illegal.  Assume that it is from a migration DLL,
        // and put it in the Upgrade Module Information group.
        //

        Group = pFindMsgGroupStructById (MSG_INSTALL_NOTES_ROOT);
        MYASSERT (Group);

        wsprintf (FilteredMessageGroup, TEXT("%s\\%s"), Group->Name, MessageGroup);
    } else {
        StringCopy (FilteredMessageGroup, MessageGroup);
    }

    if (Message) {
        BytesNeeded = SizeOfString (Message);

        DupMsg = PoolMemDuplicateString (g_MessagePool, Message);
        if (!DupMsg) {
            return FALSE;
        }

        DEBUGMSG ((DBG_REPORT, "%s: %s", FilteredMessageGroup, Message));

    } else {
        DupMsg = NULL;
        DEBUGMSG ((DBG_REPORT, "%s", FilteredMessageGroup));
    }

    //
    // Check to see if there is a handler for all messages in the message
    // group.
    //

    p = _tcschr (MessageGroup, TEXT('\\'));
    if (p) {
        p = _tcsinc (p);
        list = pSearchForGenericList (p);
        if (list) {
            level = list->ListLevel;
        }
    }
    if (level == REPORTLEVEL_NONE) {
        list = pSearchForGenericList (MessageGroup);
        if (list) {
            level = list->ListLevel;
        }
    }
    if (level == REPORTLEVEL_NONE) {
        pMap = pGetMapStructFromMessageGroup (MessageGroup);
        if (pMap) {
            level = pMap->ReportLevel;
        }
    }
    if (level == REPORTLEVEL_NONE) {
        level = Group->GroupLevel;
    }

    MYASSERT (ONEBITSET (level));

    if (IncludeOnShortReport) {
        level |= REPORTLEVEL_IN_SHORT_LIST;
    }

    MemDbBuildKey (key, MEMDB_CATEGORY_REPORT, FilteredMessageGroup, NULL, NULL);
    return MemDbSetValueAndFlags (key, (DWORD) DupMsg, level, REPORTLEVEL_ALL);
}


VOID
pCutAfterFirstLine (
    IN      PTSTR Message
    )
{
    PTSTR p = _tcsstr (Message, TEXT("\r\n"));
    if (p) {
        *p = 0;
    }
}


BOOL
pEnumMessageWorker (
    IN OUT  PREPORT_MESSAGE_ENUM EnumPtr
    )

/*++

Routine Description:

  pEnumMessageWorker completes an enumeration by filling in members of the
  enum structure.  This routine is common to message enumerations.

  Do not use the Message member of the enumeration structure, as its contents
  are undefined.

Arguments:

  EnumPtr - Specifies a paritly completed enumeration structure that needs
            the rest of its members updated.

Return Value:

  TRUE if the message should be processed, FALSE otherwise.

--*/

{
    if (!(EnumPtr->e.UserFlags & EnumPtr->EnumLevel)) {
        return FALSE;
    }

    StringCopy (EnumPtr->MsgGroup, EnumPtr->e.szName);

    //
    // Value has pointer to message, or is NULL
    //

    EnumPtr->Message = (PCTSTR) EnumPtr->e.dwValue;

    return TRUE;
}

BOOL
EnumFirstMessage (
    OUT     PREPORT_MESSAGE_ENUM EnumPtr,
    IN      PCTSTR RootCategory,            OPTIONAL
    IN      DWORD LevelMask
    )

/*++

Routine Description:

  EnumFirstMessage begins an enumeration of all message group names in
  the migration report, including subgroups.  The Message member of the
  enum structure will point to the actual message, or NULL if none
  exists.

Arguments:

  EnumPtr - Receives the enumerated message, with the members set as follows:

                MsgGroup - Receives the name of the message group.  If
                           RootCategory is specified, MsgGroup will contain
                           the subgroup of RootCategory.  If no subgroup exists,
                           MsgGroup will be an empty string.

                Message - Points to the message text, or NULL if no message text
                          exists.

  RootCategory - Specifies a specific message group to enumerate.  It may also
                 contain subgroups, separated by backslashes.

  LevelMask - Specifies which report severity levels to list. If 0 is specified, all
              levels are enumerated.

Return Value:

  TRUE if a message was enumerated, or FALSE if not.

Remarks:

  The enumeration does not allocate any resources, so it can be abandoned at
  any time.

--*/

{
    EnumPtr->EnumLevel = LevelMask ? LevelMask : REPORTLEVEL_ALL;

    if (MemDbGetValueEx (
            &EnumPtr->e,
            MEMDB_CATEGORY_REPORT,
            RootCategory,
            NULL
            )) {
        do {
            if (pEnumMessageWorker (EnumPtr)) {
                return TRUE;
            }
        } while (MemDbEnumNextValue (&EnumPtr->e));
    }

    return FALSE;
}

BOOL
EnumNextMessage (
    IN OUT  PREPORT_MESSAGE_ENUM EnumPtr
    )

/*++

Routine Description:

  EnumNextMessage continues the enumeration started by EnumFirstMessage.

Arguments:

  EnumPtr - Specifies the current enumeration state, receives the enumerated item.

Return Value:

  TRUE if another message was enumerated, or FALSE if not.

--*/

{
    while (MemDbEnumNextValue (&EnumPtr->e)) {
        if (pEnumMessageWorker (EnumPtr)) {
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
EnumFirstRootMsgGroup (
    OUT     PREPORT_MESSAGE_ENUM EnumPtr,
    IN      DWORD LevelMask
    )

/*++

Routine Description:

  EnumFirstRootMsgGroup begins an enumeration of all message group names in
  the migration report, but does not enumerate subgroups.

Arguments:

  EnumPtr - Receives the enumerated item.  In particular, the MsgGroup
            member will contain the name of the message group.

  LevelMask - Specifies which error levels to enumerate (blocking, errors,
              warnings, etc.)

Return Value:

  TRUE if a message group was enumerated, or FALSE if not.

Remarks:

  The enumeration does not allocate any resources, so it can be abandoned at
  any time.

--*/

{
    ZeroMemory (EnumPtr, sizeof (REPORT_MESSAGE_ENUM));
    EnumPtr->EnumLevel = LevelMask;

    return EnumNextRootMsgGroup (EnumPtr);
}


BOOL
EnumNextRootMsgGroup (
    IN OUT  PREPORT_MESSAGE_ENUM EnumPtr
    )

/*++

Routine Description:

  EnumNextRootMsgGroup continues an enumeration of message group names.

Arguments:

  EnumPtr - Specifies an enumeration structure that was first updated by
            EnumFirstRootMsgGroup, and optionally updated by previous
            calls to EnumNextRootMsgGroup.

Return Value:

  TRUE if another message group was enumerated, or FALSE no more groups
  exist.

--*/


{
    REPORT_MESSAGE_ENUM e;

    while (g_MsgGroupRoot[EnumPtr->Index].MsgGroup) {
        //
        // Determine if g_MsgGroupRoot[i].Name has messages to display
        //

        if (EnumFirstMessage (&e, g_MsgGroupRoot[EnumPtr->Index].Name, EnumPtr->EnumLevel)) {
            StringCopy (EnumPtr->MsgGroup, g_MsgGroupRoot[EnumPtr->Index].Name);
            EnumPtr->Message = NULL;

            EnumPtr->Index++;
            return TRUE;
        }

        EnumPtr->Index++;
    }

    return FALSE;
}


BOOL
pAppendStringToGrowBuf (
    IN OUT  PGROWBUFFER StringBuf,
    IN      PCTSTR String
    )

/*++

Routine Description:

  pAppendStringToGrowBuf is called by handler functions
  to add formatted text to a report buffer.

Arguments:

  StringBuf - Specifies the current report to append text to.

  String - Specifies the text to append.

Return Value:

  TRUE if the allocation succeeded, or FALSE if it failed.

--*/

{
    PTSTR Buf;

    if (!String || *String == 0) {
        return TRUE;
    }

    if (StringBuf->End) {
        StringBuf->End -= sizeof (TCHAR);
    }

    Buf = (PTSTR) GrowBuffer (StringBuf, SizeOfString (String));
    if (!Buf) {
        return FALSE;
    }

    StringCopy (Buf, String);
    return TRUE;
}


BOOL
pStartHeaderLine (
    IN OUT  PGROWBUFFER StringBuf
    )
{
    return pAppendStringToGrowBuf (StringBuf, TEXT("<H>"));
}

BOOL
pWriteNewLine (
    IN OUT  PGROWBUFFER StringBuf
    )
{
    return pAppendStringToGrowBuf (StringBuf, TEXT("\r\n"));
}

BOOL
pDumpDwordToGrowBuf (
    IN OUT  PGROWBUFFER StringBuf,
    IN      DWORD Dword
    )
{
    TCHAR buffer[12];

    wsprintf (buffer, TEXT("<%lu>"), Dword);
    return pAppendStringToGrowBuf (StringBuf, buffer);
}

BOOL
pWrapStringToGrowBuf (
    IN OUT  PGROWBUFFER StringBuf,
    IN      PCTSTR String,
    IN      UINT Indent,
    IN      INT HangingIndent
    )

/*++

Routine Description:

  pWrapStringToGrowBuf is called by handler functions
  to add plain text to a report buffer.

Arguments:

  StringBuf - Specifies the current report to append text to.

  String - Specifies the text to append.

  Indent - Specifies number of characters to indent text, may
           be zero.

  HangingIndent - Specifies the adjustment to be made to Indent
                  after the first line is processed.

Return Value:

  TRUE if the allocation succeeded, or FALSE if it failed.

--*/

{
    PTSTR Buf;
    PCTSTR WrappedStr;

    if (!String || *String == 0) {
        return TRUE;
    }

    WrappedStr = CreateIndentedString (String, Indent, HangingIndent, g_TotalCols);
    if (!WrappedStr) {
        return FALSE;
    }

    if (StringBuf->End) {
        StringBuf->End -= sizeof (TCHAR);
    }

    Buf = (PTSTR) GrowBuffer (StringBuf, SizeOfString (WrappedStr));

    if (!Buf) {
        MemFree (g_hHeap, 0, WrappedStr);
        return FALSE;
    }

    StringCopy (Buf, WrappedStr);
    MemFree (g_hHeap, 0, WrappedStr);
    return TRUE;
}


PTSTR
pFindEndOfGroup (
    IN      PCTSTR Group
    )

/*++

Routine Description:

  pFindEndOfGroup returns the end of a piece of a group string.

Arguments:

  Group - Specifies the start of the message group to find the end of.

Return Value:

  A pointer to the nul or backslash terminating the message group.

--*/

{
    PTSTR p;

    p = _tcschr (Group, TEXT('\\'));
    if (!p) {
        p = GetEndOfString (Group);
    }

    return p;
}


PTSTR
pFindNextGroup (
    IN      PCTSTR Group
    )

/*++

Routine Description:

  pFindNextGroup returns a pointer to the next piece of a message group.  In
  other words, it locates the next backslash, advances one more character, and
  returns the pointer to the rest of the string.

Arguments:

  Group - Specifies the start of the current message group

Return Value:

  A pointer to the next piece of the group, or a pointer to the nul terminator
  if no more pieces exist.

--*/


{
    PTSTR Next;

    Next = pFindEndOfGroup (Group);
    if (*Next) {
        Next = _tcsinc (Next);
    }

    return Next;
}


PTSTR
pExtractNextMsgGroup (
    IN      PCTSTR Group,
    OUT     PCTSTR *NextGroup       OPTIONAL
    )

/*++

Routine Description:

  pExtractNextMsgGroup locates the start and end of the current message group
  piece, copies it into a new buffer, and returns a pointer to the next piece.

Arguments:

  Group - Specifies the start of the current message group piece

  NextGroup - Receives a pointer to the next message group piece

Return Value:

  A pointer to the newly allocated string.  The caller must free this by
  calling FreePathString.

--*/


{
    PCTSTR p;
    PTSTR Base;

    p = pFindEndOfGroup (Group);

    //
    // Duplicate the subgroup
    //

    Base = AllocPathString (p - Group + 1);
    if (Base) {
        StringCopyAB (Base, Group, p);
    }

    //
    // Supply caller with a pointer to the next subgroup,
    // or a pointer to the nul character.
    //

    if (NextGroup) {
        if (*p) {
            p = _tcsinc (p);
        }

        *NextGroup = p;
    }

    return Base;
}


VOID
pLoadHandlerStringWorker (
    IN      UINT MessageId,
    IN      UINT RootId,
    OUT     PCTSTR *Str
    )
{
    if (MessageId && MessageId != RootId) {
        *Str = GetStringResource (MessageId);
    } else {
        *Str = NULL;
    }
}

VOID
pLoadAllHandlerStrings (
    VOID
    )

/*++

Routine Description:

  pLoadAllHandlerStrings loads the string resources needed by all handlers.
  The pointers are saved in a global array, and are used during
  CreateReportText.  When this module terminates, the global array is freed.

Arguments:

  none

Return Value:

  none

--*/


{
    INT i;
    PTSTR p;

    for (i = 0 ; g_HandlerNames[i].Id ; i++) {
        g_HandlerNames[i].SubGroupStr = GetStringResource (g_HandlerNames[i].Id);
        MYASSERT (g_HandlerNames[i].SubGroupStr);
        g_HandlerNames[i].SubGroupStrLen = CharCount (g_HandlerNames[i].SubGroupStr);
    }

    for (i = 0 ; g_GenericList[i].Id ; i++) {
        g_GenericList[i].SubGroupStr = GetStringResource (g_GenericList[i].Id);
        MYASSERT (g_GenericList[i].SubGroupStr);
        g_GenericList[i].SubGroupStrLen = CharCount (g_GenericList[i].SubGroupStr);
    }

    for (i = 0 ; g_MsgGroupRoot[i].MsgGroup ; i++) {
        g_MsgGroupRoot[i].Name = GetStringResource (g_MsgGroupRoot[i].MsgGroup);
        MYASSERT (g_MsgGroupRoot[i].Name);
        g_MsgGroupRoot[i].NameLen = CharCount (g_MsgGroupRoot[i].Name);

        pLoadHandlerStringWorker (
            g_MsgGroupRoot[i].IntroId,
            g_MsgGroupRoot[i].MsgGroup,
            &g_MsgGroupRoot[i].IntroIdStr
            );

        pLoadHandlerStringWorker (
            g_MsgGroupRoot[i].IntroIdHtml,
            g_MsgGroupRoot[i].MsgGroup,
            &g_MsgGroupRoot[i].IntroIdHtmlStr
            );

        pLoadHandlerStringWorker (
            g_MsgGroupRoot[i].OtherId,
            g_MsgGroupRoot[i].MsgGroup,
            &g_MsgGroupRoot[i].OtherIdStr
            );

        pLoadHandlerStringWorker (
            g_MsgGroupRoot[i].OtherIdHtml,
            g_MsgGroupRoot[i].MsgGroup,
            &g_MsgGroupRoot[i].OtherIdHtmlStr
            );
    }

    for (i = 0; g_MapMessageToLevel[i].MessageId; i++) {
        g_MapMessageToLevel[i].MessageStr = GetStringResource (g_MapMessageToLevel[i].MessageId);
        MYASSERT (g_MapMessageToLevel[i].MessageStr);
        p = _tcschr (g_MapMessageToLevel[i].MessageStr, TEXT('\\'));
        if (p) {
            *p = 0;
        }
        g_MapMessageToLevel[i].MessageLength = CharCount (g_MapMessageToLevel[i].MessageStr);
    }
}


VOID
pFreeAllHandlerStrings (
    VOID
    )

/*++

Routine Description:

  pFreeAllHandlerStrings cleans up the global array of string
  resources before process termination.

Arguments:

  none

Return Value:

  none

--*/

{
    INT i;

    for (i = 0 ; g_HandlerNames[i].Id ; i++) {
        FreeStringResource (g_HandlerNames[i].SubGroupStr);
        g_HandlerNames[i].SubGroupStr = NULL;
        g_HandlerNames[i].SubGroupStrLen = 0;
    }

    for (i = 0 ; g_GenericList[i].Id ; i++) {
        FreeStringResource (g_GenericList[i].SubGroupStr);
        g_GenericList[i].SubGroupStr = NULL;
        g_GenericList[i].SubGroupStrLen = 0;
    }

    for (i = 0 ; g_MsgGroupRoot[i].MsgGroup ; i++) {
        FreeStringResource (g_MsgGroupRoot[i].Name);
        FreeStringResource (g_MsgGroupRoot[i].IntroIdStr);
        FreeStringResource (g_MsgGroupRoot[i].IntroIdHtmlStr);
        FreeStringResource (g_MsgGroupRoot[i].OtherIdStr);
        FreeStringResource (g_MsgGroupRoot[i].OtherIdHtmlStr);

        g_MsgGroupRoot[i].Name = NULL;
        g_MsgGroupRoot[i].NameLen = 0;
        g_MsgGroupRoot[i].IntroIdStr = NULL;
        g_MsgGroupRoot[i].IntroIdHtmlStr = NULL;
        g_MsgGroupRoot[i].OtherIdStr = NULL;
        g_MsgGroupRoot[i].OtherIdHtmlStr = NULL;
    }

    for (i = 0; g_MapMessageToLevel[i].MessageId; i++) {
        FreeStringResource (g_MapMessageToLevel[i].MessageStr);
        g_MapMessageToLevel[i].MessageStr = NULL;
    }
}


BOOL
pIsThisTheHandler (
    IN      PCTSTR FullMsgGroup,
    IN      PHANDLER_LIST Handler
    )

/*++

Routine Description:

  pIsThisTheHandler compares the specified message group handler name against
  the specified message group.

Arguments:

  FullMsgGroup - Specifies the name of the message group in question

  Handler - Specifies the message group handler to compare against FullMsgGroup

Return Value:

  TRUE if Handler handles the FullMsgGroup message, or FALSE if not.

--*/

{
    PCTSTR p;
    CHARTYPE ch;

    if (!Handler) {
        return FALSE;
    }

    if (StringIMatchCharCount (
            FullMsgGroup,
            Handler->SubGroupStr,
            Handler->SubGroupStrLen
            )) {

        p = CharCountToPointer (FullMsgGroup, Handler->SubGroupStrLen);
        ch = _tcsnextc (p);

        if (ch == TEXT('\\') || ch == 0) {
            return TRUE;
        }
    }

    return FALSE;
}


PHANDLER_LIST
pSearchForMsgGroupHandler (
    IN      PCTSTR Str
    )

/*++

Routine Description:

  pSearchForMsgGroupHandler scans the list of handlers for one that can
  handle the current message group.  A pointer to the handler structure is
  returned.

Arguments:

  Str - Specifies the message group to locate a handler for, and may include
        backslashes and subgroups.

Return Value:

  A pointer to the handler struct if found, or the default handler if no
  handler exists for the message group.

--*/

{
    PHANDLER_LIST Handler;

    for (Handler = g_HandlerNames ; Handler->Id ; Handler++) {
        if (pIsThisTheHandler (Str, Handler)) {
            break;
        }
    }

    return Handler;
}


PMSGGROUP_PROPS
pFindMsgGroupStruct (
    IN      PCTSTR MsgGroup
    )

/*++

Routine Desciption:

  pFindMsgGroupStruct returns the pointer to the root message group structure,
  which defines attributes about the message group, such as introduction text
  and intro text for the non-handled messages.

Arguments:

  MsgGroup - Specifies the text name of the message group, which may include
             sub groups

Return Value:

  A pointer to the root message group struct, or NULL if it is not defined.

--*/

{
    PCTSTR p;
    CHARTYPE ch;
    PMSGGROUP_PROPS Group;

    for (Group = g_MsgGroupRoot ; Group->MsgGroup ; Group++) {
        if (StringIMatchCharCount (MsgGroup, Group->Name, Group->NameLen)) {
            p = CharCountToPointer (MsgGroup, Group->NameLen);
            ch = _tcsnextc (p);
            if (ch == TEXT('\\') || ch == 0) {
                return Group;
            }
        }
    }

    return NULL;
}


PMSGGROUP_PROPS
pFindMsgGroupStructById (
    IN      UINT MsgGroupId
    )

/*++

Routine Desciption:

  pFindMsgGroupStructById returns the pointer to the root message group structure,
  which defines attributes about the message group, such as introduction text
  and intro text for the non-handled messages.  It searches based on the string
  ID of the group.

Arguments:

  MsgGroupId - Specifies the MSG_* constant of the group to find

Return Value:

  A pointer to the root message group struct, or NULL if it is not defined.

--*/

{
    PMSGGROUP_PROPS Group;

    for (Group = g_MsgGroupRoot ; Group->MsgGroup ; Group++) {
        if (Group->MsgGroup == MsgGroupId) {
            return Group;
        }
    }

    return NULL;
}


BOOL
pAddMsgGroupString (
    IN OUT  PGROWBUFFER StringBuf,
    IN      PMSGGROUP_PROPS Group,
    IN      PCTSTR MsgGroup,
    IN      BOOL HtmlFormat,
    IN      DWORD Level
    )

/*++

Routine Description:

  pAddMsgGroupString formats a message group into a heirarchy
  for the report.  That is, if group is a string such as:

    foo\bar\moo

  then the following text is added to the report:

    foo
      bar
        moo

  If HtmlFormat is TRUE, then the bold attribute is enabled
  for the group string.

Arguments:

  StringBuf - Specifies the current report to append text to.

  Group - Specifies the group properties of this item

  MsgGroup - Specifies the message group to add to the report

  HtmlFormat - Specifies TRUE if the message group should be formatted
               with HTML tags, or FALSE if it should be plain
               text.

  Level - Specifies the severity of the message

Return Value:

  TRUE if multiple lines were added, or FALSE if zero or one line was added.

--*/

{
    UINT Spaces = 0;
    TCHAR SpaceBuf[MAX_SPACES * 6];
    PCTSTR SubMsgGroup = NULL;
    PCTSTR LastSubMsgGroup = NULL;
    PCTSTR NextMsgGroup;
    PCTSTR LastMsgGroup;
    PCTSTR Msg = NULL;
    TCHAR SummaryStrHeader[512] = TEXT("");
    TCHAR SummaryStrItem[512] = TEXT("");
    UINT lineCount = 0;

    Level &= REPORTLEVEL_ALL;
    MYASSERT (ONEBITSET (Level));

    NextMsgGroup = MsgGroup;
    LastMsgGroup = g_LastMsgGroupBuf;

    if (HtmlFormat) {
        pAppendStringToGrowBuf (StringBuf, TEXT("<B>"));
    }

    if (g_ListFormat) {
        StackStringCopy (SummaryStrHeader, Group->Name);
    }

    SpaceBuf[0] = 0;

    while (*NextMsgGroup) {
        __try {
            SubMsgGroup = pExtractNextMsgGroup (NextMsgGroup, &NextMsgGroup);
            if (*LastMsgGroup) {
                LastSubMsgGroup = pExtractNextMsgGroup (LastMsgGroup, &LastMsgGroup);

                if (StringIMatch (LastSubMsgGroup, SubMsgGroup)) {
                    continue;
                }

                if (!Spaces) {
                    if (!HtmlFormat) {
                        pAppendStringToGrowBuf (StringBuf, TEXT("\r\n"));
                    }
                }

                LastMsgGroup = GetEndOfString (LastMsgGroup);
            }

            //
            // Add indenting
            //

            if (Spaces) {
                pAppendStringToGrowBuf (StringBuf, SpaceBuf);
            }

            //
            // Add subgroup
            //

            Msg = NULL;
            if (!g_ListFormat) {
                if (HtmlFormat) {
                    pAppendStringToGrowBuf (StringBuf, SubMsgGroup);
                } else {
                    Msg = pEncodeMessage (SubMsgGroup, FALSE);
                    pAppendStringToGrowBuf (StringBuf, Msg);
                }
            } else {
                if (*NextMsgGroup) {
                    StringCopy (SummaryStrHeader, SubMsgGroup);
                } else {
                    StringCopy (SummaryStrItem, SubMsgGroup);
                }
            }

            if (HtmlFormat) {
                pAppendStringToGrowBuf (StringBuf, TEXT("<BR>\r\n"));
            } else {
                pAppendStringToGrowBuf (StringBuf, TEXT("\r\n"));
            }
        }

        __finally {

            if (HtmlFormat) {
                StringCat (SpaceBuf, TEXT("&nbsp;"));
                StringCat (SpaceBuf, TEXT("&nbsp;"));
            } else {
                SpaceBuf[Spaces] = TEXT(' ');
                SpaceBuf[Spaces+1] = TEXT(' ');
                SpaceBuf[Spaces+2] = 0;
            }

            lineCount++;
            Spaces += 2;
            MYASSERT (Spaces < MAX_SPACES - 2);

            FreePathString (SubMsgGroup);
            FreePathString (LastSubMsgGroup);

            SubMsgGroup = NULL;
            LastSubMsgGroup = NULL;

            if (Msg) {
                FreeText (Msg);
                Msg = NULL;
            }
        }
    }

    if (g_ListFormat) {
        if (SummaryStrHeader[0] && SummaryStrItem[0]) {
            pStartHeaderLine (StringBuf);
            pDumpDwordToGrowBuf (StringBuf, Level);
            Msg = pEncodeMessage (SummaryStrHeader, FALSE);
            pAppendStringToGrowBuf (StringBuf, Msg);
            FreeText (Msg);
            pAppendStringToGrowBuf (StringBuf, TEXT("\r\n"));

            pDumpDwordToGrowBuf (StringBuf, Level);
            Msg = pEncodeMessage (SummaryStrItem, FALSE);
            pAppendStringToGrowBuf (StringBuf, Msg);
            FreeText (Msg);
            pAppendStringToGrowBuf (StringBuf, TEXT("\r\n"));
        }
    }

    if (HtmlFormat) {
        //
        // Add a closing </B> just in case title is missing it.
        //

        pAppendStringToGrowBuf (StringBuf, TEXT("</B>"));
    }

    StringCopy (g_LastMsgGroupBuf, MsgGroup);
    return lineCount != 1;
}


PCTSTR
pEscapeHtmlTitleText (
    IN      PCTSTR UnescapedText
    )
{
    UINT Count;
    PCTSTR p;
    PTSTR Buf;
    PTSTR q;
    CHARTYPE ch;
    BOOL Escape;

    //
    // Escape everything EXCEPT the <B> and </B> tags, which are used in
    // subgroup formatting. This includes ampersands.
    //

    //
    // count all of the tags that we wish to change < into &lt;
    //

    Count = 1;
    p = UnescapedText;
    while (*p) {
        ch = _tcsnextc (p);

        if (ch == TEXT('<')) {
            if (!StringIMatchCharCount (p, TEXT("</B>"), 4) &&
                !StringIMatchCharCount (p, TEXT("<B>"), 3)
                ) {
                Count++;
            }
        } else if (ch == TEXT('&')) {
            Count++;
        }

        p = _tcsinc (p);
    }

    //
    // Allocate a dest buffer
    //

    Buf = AllocText (CharCount (UnescapedText) + (Count * 5) + 1);
    MYASSERT (Buf);

    p = UnescapedText;
    q = Buf;

    //
    // Transfer unescaped text into output buffer, leaving only
    // the tags we want. Convert ampersand into &amp;.
    //

    while (*p) {
        ch = _tcsnextc (p);
        Escape = FALSE;

        if (ch == TEXT('<')) {
            if (!StringIMatchCharCount (p, TEXT("</B>"), 4) &&
                !StringIMatchCharCount (p, TEXT("<B>"), 3)
                ) {
                Escape = TRUE;
            }
        } else if (ch == TEXT('&')) {
            Escape = TRUE;
        }

        if (Escape) {
            if (ch == TEXT('<')) {
                StringCopy (q, TEXT("&lt;"));
            } else {
                StringCopy (q, TEXT("&amp;"));
            }

            q = GetEndOfString (q);
        } else {
            _copytchar (q, p);
            q = _tcsinc (q);
        }

        p = _tcsinc (p);
    }

    *q = 0;

    return Buf;
}


BOOL
pGenericItemList (
    IN      CALLCONTEXT Context,
    IN OUT  PGROWBUFFER StringBuf,
    IN      PCTSTR SubGroup,
    IN      PCTSTR Message,
    IN      DWORD Level,
    IN      BOOL HtmlFormat,
    IN OUT  PVOID *State,
    IN      UINT MsgIdTop,
    IN      UINT MsgIdTopHtml,
    IN      UINT MsgIdBottom,
    IN      UINT MsgIdBottomHtml,
    IN      PCTSTR **FormatArgs,            OPTIONAL
    IN      DWORD Flags,
    IN      PMSGGROUP_PROPS Props
    )

/*++

Routine Description:

  pGenericItemList formats a group of messages in the following
  format:

  Group
    SubGroup

        <intro>

            Item 1
            Item 2
            Item n

        <conclusion>


  The <intro> and <conclusion> are optional.

  The subgroups are declared in SUBGROUP_LISTS at the top of this
  file.

Arguments:

  Context - Specifies the way the handler is being called,
            either to initialize, process an item or clean up.

  StringBuf - Specifies the current report.  Append text to
              this buffer via the pAppendStringToGrowBuf
              routine.

  SubGroup - Specifies the text of the subgrup

  Message - Specifies the message text

  Level - Specifies the severity level of Message (info, error, etc.)

  HtmlFormat - Specifies TRUE if the text should be written
               with HTML formatting tags, or FALSE if the
               text should be formatted as plain text.
               (See CreateReport comments for HTML tag
               info.)

  State - A pointer to state, defined by the handler.  State
          holds an arbitrary 32-bit value that the handler
          maintains.  Typically the handler allocates a
          struct when Context is INIT, then uses the struct
          for each PROCESS_ITEM, and finally cleans up the
          allocation when Context is CLEANUP.

  MsgIdTop - Specifies the ID of text that should appear above
             the top of the list.  This includes the section
             title.  This message ID should contain plain text.
             Zero indicates no text.

  MsgIdTopHtml - Specifies the ID of text that is the same as
                 MsgIdTop, except it must be formatted with
                 HTML tags.  If MsgIdTop is zero, MsgIdTopHtml
                 must also be zero.

  MsgIdBottom - Similar to MsgIdTop, except specifies ID of
                text at the bottom of the list.  Zero indicates
                no text.

  MsgIdBottomHtml - Specifies the same text as MsgIdBottom, except
                    formatted with HTML tags.  If MsgIdBottom is
                    zero, MsgIdBottomHtml must also be zero.

  FormatArgs - Specifies an optional pointer to an array of 4 pointers,
               each associated with the previous MsgIds (first with MsgIdTop a.s.o.)
               If not NULL, each one points to an array of actual strings to replace
               the placeholders in the message (%1 -> first string in this array a.s.o.)

  Flags - Specifies a list of flags used for formatting (like bold case items)

Return Value:

  TRUE if the handler was successful, or FALSE if an
  error occurs.

--*/

{
    PITEMLIST Items;
    PCTSTR Msg;
    UINT Count;
    UINT u;
    PCTSTR EncodedText;
    PGROWLIST currentList;
    BOOL bMessageItems;
    INT pass;
    PCTSTR altMsg;
    BOOL headerAdded = FALSE;
    BOOL footerAdded = FALSE;

    Level &= REPORTLEVEL_ALL;
    MYASSERT (ONEBITSET (Level));

    Items = *((PITEMLIST *) State);

    switch (Context) {
    case INIT:
        //
        // Allocate grow list to hold all hardware
        //

        MYASSERT (!Items);
        Items = (PITEMLIST) MemAlloc (
                                g_hHeap,
                                HEAP_ZERO_MEMORY,
                                sizeof (ITEMLIST)
                                );
        break;

    case PROCESS_ITEM:
        MYASSERT (Items);

        //
        // Add the subgroup to the grow list
        //


        if (HtmlFormat) {
            Msg = pEscapeHtmlTitleText (SubGroup);
        } else {
            Msg = pEncodeMessage (SubGroup, FALSE);
        }

        if (FLAGSET_ENABLE_MESSAGE_ITEMS (Flags) && Message && *Message) {
            GrowListAppendString (&Items->MessageItems, Msg);
            GrowListAppendString (&Items->Messages, Message);
        } else {
            GrowListAppendString (&Items->List, Msg);
        }

        FreeText (Msg);
        break;

    case CLEANUP:
        MYASSERT (Items);

        //
        // Add instructions, then add each item in the grow list
        //

        for (pass = 0; pass < 2; pass++) {

            //
            // are we processing message items this step, or just list entries?
            //
            bMessageItems = FLAGSET_MESSAGE_ITEMS_FIRST (Flags) && pass == 0 ||
                            !FLAGSET_MESSAGE_ITEMS_FIRST (Flags) && pass != 0;

            if (bMessageItems) {
                currentList = &Items->MessageItems;
            } else {
                currentList = &Items->List;
            }

            Count = GrowListGetSize (currentList);

            if (Count) {
                if (HtmlFormat) {
                    //pAppendStringToGrowBuf (StringBuf, TEXT("<UL>"));

                    if (bMessageItems) {
                        if (HtmlFormat && FLAGSET_INDENT_MESSAGE (Flags)) {
                            pAppendStringToGrowBuf (StringBuf, TEXT("<UL>"));
                        }
                    }
                }

                if (!headerAdded) {

                    headerAdded = TRUE;

                    if (MsgIdTop && MsgIdTopHtml) {
                        //
                        // check if FormatArgs and the corresponding pointer for MsgId are not NULL
                        //
                        if (FormatArgs && (HtmlFormat ? FormatArgs[1] : FormatArgs[0])) {
                            Msg = ParseMessageID (
                                        HtmlFormat ? MsgIdTopHtml : MsgIdTop,
                                        HtmlFormat ? FormatArgs[1] : FormatArgs[0]
                                        );
                        } else {
                            Msg = GetStringResource (HtmlFormat ? MsgIdTopHtml : MsgIdTop);
                        }

                        if (Msg) {
                            altMsg = Msg;

                            if (g_ListFormat) {
                                pStartHeaderLine (StringBuf);
                                pDumpDwordToGrowBuf (StringBuf, Level);

                                //
                                // Determine heading from the root group, the subgroup
                                // or the message text (depending on macro expansion
                                // list flags)
                                //

                                if (FLAGSET_USESUBGROUP (Flags)) {
                                    //
                                    // Get text from the root group
                                    //

                                    MYASSERT (!FLAGSET_USEROOT (Flags));
                                    altMsg = SubGroup;
                                } else if (FLAGSET_USEROOT (Flags)) {
                                    //
                                    // Get text from the subgroup
                                    //

                                    MYASSERT (!FLAGSET_USESUBGROUP (Flags));
                                    altMsg = Props->Name;
                                } else {
                                    //
                                    // We assume that the plain text message has a heading
                                    // that gives the text to put in the list view.
                                    //

                                    pCutAfterFirstLine ((PTSTR)altMsg);
                                }

                                altMsg = pEncodeMessage (altMsg, FALSE);
                            }

                            if (HtmlFormat) {
                                pAppendStringToGrowBuf (StringBuf, altMsg);
                            } else {
                                pWrapStringToGrowBuf (StringBuf, altMsg, 0, 0);
                            }

                            if (g_ListFormat) {
                                pWriteNewLine (StringBuf);
                                FreeText (altMsg);
                            }

                            FreeStringResource (Msg);
                        }
                    } else if (g_ListFormat) {
                        //
                        // No detailed heading; get list view text (just
                        // like above). NOTE: there is no message text.
                        //

                        pStartHeaderLine (StringBuf);
                        pDumpDwordToGrowBuf (StringBuf, Level);

                        if (FLAGSET_USESUBGROUP (Flags)) {
                            MYASSERT (!FLAGSET_USEROOT (Flags));
                            altMsg = SubGroup;
                        } else {
                            MYASSERT (FLAGSET_USEROOT (Flags));
                            altMsg = Props->Name;
                        }

                        pAppendStringToGrowBuf (StringBuf, altMsg);
                        pWriteNewLine (StringBuf);
                    }
                }

                for (u = 0 ; u < Count ; u++) {

                    if (g_ListFormat) {
                        pDumpDwordToGrowBuf (StringBuf, Level);
                    }

                    if (!bMessageItems) {
                        if (HtmlFormat) {
                            if (FLAGSET_BOLDITEMS(Flags)) {
                                pAppendStringToGrowBuf (StringBuf, TEXT("<B>"));
                            }
                            pAppendStringToGrowBuf (StringBuf, GrowListGetString (currentList, u));
                            if (FLAGSET_BOLDITEMS(Flags)) {
                                pAppendStringToGrowBuf (StringBuf, TEXT("</B>"));
                            }

                            pAppendStringToGrowBuf (StringBuf, TEXT("<BR>"));
                        } else {
                            EncodedText = pEncodeMessage (GrowListGetString (currentList, u), FALSE);
                            if (EncodedText) {
                                pWrapStringToGrowBuf (StringBuf, EncodedText, 4, 2);
                                FreeText (EncodedText);
                            }
                        }
                    } else {
                        if (HtmlFormat) {
                            if (FLAGSET_BOLDITEMS(Flags)) {
                                pAppendStringToGrowBuf (StringBuf, TEXT("<B>"));
                            }
                        }

                        if (HtmlFormat) {
                            pAppendStringToGrowBuf (StringBuf, GrowListGetString (currentList, u));
                        } else {
                            EncodedText = pEncodeMessage (GrowListGetString (currentList, u), FALSE);
                            if (EncodedText) {
                                pWrapStringToGrowBuf (StringBuf, EncodedText, 0, 0);
                                FreeText (EncodedText);
                            }
                        }

                        if (HtmlFormat) {
                            if (FLAGSET_BOLDITEMS(Flags)) {
                                pAppendStringToGrowBuf (StringBuf, TEXT("</B>"));
                            }

                            pAppendStringToGrowBuf (StringBuf, TEXT("<BR>"));
                        }
                        //
                        // now add the message itself
                        //
                        if (!g_ListFormat) {
                            EncodedText = pEncodeMessage (GrowListGetString (&Items->Messages, u), HtmlFormat);
                            if (EncodedText) {
                                pAppendStringToGrowBuf (StringBuf, TEXT("\r\n"));
                                if (HtmlFormat) {

                                    pAppendStringToGrowBuf (StringBuf, EncodedText);
                                    if (Count == (u - 1) && FLAGSET_INDENT_MESSAGE (Flags)) {
                                        pAppendStringToGrowBuf (StringBuf, TEXT("<BR>"));
                                    } else {
                                        pAppendStringToGrowBuf (StringBuf, TEXT("<P>"));
                                    }

                                } else {
                                    pWrapStringToGrowBuf (StringBuf, EncodedText, 4, 0);
                                    pAppendStringToGrowBuf (StringBuf, TEXT("\r\n"));
                                }
                                FreeText (EncodedText);
                            }
                        }
                    }

                    pAppendStringToGrowBuf (StringBuf, TEXT("\r\n"));
                }

                if (!bMessageItems) {
                    //
                    // Terminate the list
                    //

                    if (HtmlFormat) {
                        if (FLAGSET_BOLDITEMS(Flags)) {
                            pAppendStringToGrowBuf (StringBuf, TEXT("</B>"));
                        }
                        pAppendStringToGrowBuf (StringBuf, TEXT("</UL>"));
                    }

                    pAppendStringToGrowBuf (StringBuf, TEXT("\r\n"));

                } else {
                    //
                    // Terminate the messages
                    //

                    if (HtmlFormat) {
                        //pAppendStringToGrowBuf (StringBuf, TEXT("</UL>"));

                        if (FLAGSET_INDENT_MESSAGE (Flags)) {
                            pAppendStringToGrowBuf (StringBuf, TEXT("</UL>"));
                        }
                    }

                    pAppendStringToGrowBuf (StringBuf, TEXT("\r\n"));
                }

                if (!g_ListFormat && !footerAdded) {
                    footerAdded = TRUE;

                    if (MsgIdBottom && MsgIdBottomHtml) {
                        //
                        // check if FormatArgs and the corresponding pointer for MsgId are not NULL
                        //
                        if (FormatArgs && (HtmlFormat ? FormatArgs[3] : FormatArgs[2])) {
                            Msg = ParseMessageID (
                                        HtmlFormat ? MsgIdBottomHtml : MsgIdBottom,
                                        HtmlFormat ? FormatArgs[3] : FormatArgs[2]
                                        );
                        } else {
                            Msg = GetStringResource (HtmlFormat ? MsgIdBottomHtml : MsgIdBottom);
                        }

                        if (Msg) {
                            if (HtmlFormat) {
                                pAppendStringToGrowBuf (StringBuf, Msg);
                            } else {
                                pWrapStringToGrowBuf (StringBuf, Msg, 0, 0);
                            }

                            FreeStringResource (Msg);
                        }
                    }
                }
            }
        }

        //
        // Free the grow list
        //

        FreeGrowList (&Items->List);
        FreeGrowList (&Items->MessageItems);
        FreeGrowList (&Items->Messages);
        MemFree (g_hHeap, 0, Items);
        Items = NULL;
        break;
    }

    *((PITEMLIST *) State) = Items;

    return TRUE;
}


VOID
pCleanUpOtherDevices (
    VOID
    )
{
    MEMDB_ENUM e;
    HASHTABLE Table;
    PCTSTR Str;
    TCHAR ReportRoot[MEMDB_MAX];
    TCHAR Pattern[MEMDB_MAX];
    TCHAR OtherDevices[MEMDB_MAX];
    UINT Bytes;
    PCTSTR p;

    //
    // Prepare the report root Hardware\Incompatible Hardware\Other devices
    //

    Str = GetStringResource (MSG_INCOMPATIBLE_HARDWARE_ROOT);
    MYASSERT (Str);
    if (!Str) {
        return;
    }
    StringCopy (ReportRoot, Str);
    FreeStringResource (Str);

    Str = GetStringResource (MSG_INCOMPATIBLE_HARDWARE_PNP_SUBGROUP);
    MYASSERT (Str);
    if (!Str) {
        return;
    }
    StringCopy (AppendWack (ReportRoot), Str);
    FreeStringResource (Str);

    Str = GetStringResource (MSG_UNKNOWN_DEVICE_CLASS);
    MYASSERT (Str);
    if (!Str) {
        return;
    }
    StringCopy (OtherDevices, Str);
    FreeStringResource (Str);

    //
    // Enumerate the entries in this root
    //

    if (MemDbGetValueEx (&e, MEMDB_CATEGORY_REPORT, ReportRoot, OtherDevices)) {

        Table = HtAlloc();

        do {
            //
            // Add the device name to the table
            //

            HtAddString (Table, e.szName);

        } while (MemDbEnumNextValue (&e));

        //
        // Now search all other classes of the report
        //

        MemDbBuildKey (Pattern, MEMDB_CATEGORY_REPORT, ReportRoot, TEXT("*"), NULL);
        AppendWack (OtherDevices);
        Bytes = (PBYTE) GetEndOfString (OtherDevices) - (PBYTE) OtherDevices;

        if (MemDbEnumFirstValue (&e, Pattern, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
            do {

                //
                // Skip "Other devices"
                //

                if (StringIMatchByteCount (e.szName, OtherDevices, Bytes)) {
                    continue;
                }

                p = _tcschr (e.szName, TEXT('\\'));
                MYASSERT (p);

                if (p) {
                    p = _tcsinc (p);

                    if (HtFindString (Table, p)) {
                        //
                        // This is a match, so remove the Other devices entry
                        //

                        StringCopy (Pattern, MEMDB_CATEGORY_REPORT);
                        StringCopy (AppendWack (Pattern), ReportRoot);
                        StringCopy (AppendWack (Pattern), OtherDevices);
                        StringCopy (AppendWack (Pattern), p);

                        //
                        // NOTE: This delete is safe because we know we cannot be
                        //       enumerating this node.
                        //

                        MemDbDeleteValue (Pattern);
                    }
                }

            } while (MemDbEnumNextValue (&e));
        }
    }
}


BOOL
pAddPnpHardwareToReport (
    IN      CALLCONTEXT Context,
    IN      PMSGGROUP_PROPS Group,
    IN OUT  PGROWBUFFER StringBuf,
    IN      PCTSTR SubGroup,
    IN      PCTSTR Message,
    IN      DWORD Level,
    IN      BOOL HtmlFormat,
    IN OUT  PVOID *State,
    IN      DWORD Arg
    )

/*++

Routine Description:

  pAddPnpHardwareToReport formats the incompatible PNP hardware differently
  than the generic lists.  The format includes the hardware class, followed
  by device names, which are indented an extra two spaces.

Arguments:

  Context - Specifies the way the handler is being called, either to
            initialize, process an item or clean up.

  StringBuf - Specifies the current report.  Append text to this buffer via
              the pAppendStringToGrowBuf routine.

  Group - Specifies the group properties of this item

  SubGroup - Specifies the message subgroup, and does not include the root
             message group.

  Message - Specifies the message text

  Level - Specifies the severity level of Message (info, error, etc.)

  HtmlFormat - Specifies TRUE if the text should be written with HTML
               formatting tags, or FALSE if the text should be formatted as
               plain text.  (See CreateReport comments for HTML tag info.)

  State - Holds a pointer to the formatting state.

  Arg - The DWORD argument from the macro expansion list

Return Value:

  TRUE if the handler was successful, or FALSE if an error occurs.

--*/

{
    PPNPFORMATSTATE FormatState;
    PCTSTR p;
    PCTSTR Msg;
    TCHAR Class[MEMDB_MAX];
    UINT MsgIdTop;
    UINT MsgIdTopHtml;
    UINT MsgIdBottom;
    UINT MsgIdBottomHtml;
    PCTSTR EncodedText;
    TCHAR fmtLine[1024];
    PCTSTR msg;

    Level &= REPORTLEVEL_ALL;
    MYASSERT (ONEBITSET (Level));

    switch (Arg) {

    case 0:
        MsgIdTop = MSG_HARDWARE_UNSUPPORTED_INSTRUCTIONS;
        MsgIdTopHtml = MSG_HARDWARE_UNSUPPORTED_INSTRUCTIONS_HTML;
        MsgIdBottom = MSG_HARDWARE_UNSUPPORTED_INSTRUCTIONS2;
        MsgIdBottomHtml = MSG_HARDWARE_UNSUPPORTED_INSTRUCTIONS_HTML2;
        break;

    default:
    case 1:
        MsgIdTop = MSG_HARDWARE_PNP_INSTRUCTIONS;
        MsgIdTopHtml = MSG_HARDWARE_PNP_INSTRUCTIONS_HTML;
        MsgIdBottom = MSG_HARDWARE_PNP_INSTRUCTIONS2;
        MsgIdBottomHtml = MSG_HARDWARE_PNP_INSTRUCTIONS2_HTML;
        break;

    case 2:
        MsgIdTop = MSG_HARDWARE_REINSTALL_PNP_INSTRUCTIONS;
        MsgIdTopHtml = MSG_HARDWARE_REINSTALL_PNP_INSTRUCTIONS_HTML;
        MsgIdBottom = MSG_HARDWARE_REINSTALL_PNP_INSTRUCTIONS2;
        MsgIdBottomHtml = MSG_HARDWARE_REINSTALL_PNP_INSTRUCTIONS_HTML2;
        //
        // make this a warning icon
        //
        Level = REPORTLEVEL_WARNING;
        break;
    }

    switch (Context) {

    case INIT:
        FormatState = MemAlloc (g_hHeap, 0, sizeof (PNPFORMATSTATE));
        ZeroMemory (FormatState, sizeof (PNPFORMATSTATE));

        *State = FormatState;

        //
        // Special filtering is performed on Other devices, to remove
        // duplicates.  If we find that something in Other devices is
        // listed in another device class, we remove the copy in
        // Other devices.
        //

        pCleanUpOtherDevices();
        break;

    case PROCESS_ITEM:
        FormatState = *((PPNPFORMATSTATE *) State);

        p = _tcschr (SubGroup, TEXT('\\'));
        MYASSERT (p);

        if (!p) {
            break;
        }

        StringCopyAB (Class, SubGroup, p);
        p = _tcsinc (p);

        if (!StringMatch (Class, FormatState->LastClass)) {

            //
            // End the previous class
            //

            if (*FormatState->LastClass) {
                if (HtmlFormat) {
                    pAppendStringToGrowBuf (StringBuf, TEXT("<BR></UL>\r\n"));
                } else {
                    pAppendStringToGrowBuf (StringBuf, TEXT("\r\n"));
                }

            } else if (MsgIdTop) {

                //
                // The very first message gets a heading
                //

                Msg = GetStringResource (HtmlFormat ? MsgIdTopHtml : MsgIdTop);
                if (Msg) {
                    if (g_ListFormat) {
                        pStartHeaderLine (StringBuf);
                        pDumpDwordToGrowBuf (StringBuf, Level);
                        pCutAfterFirstLine ((PTSTR)Msg);
                        msg = pEncodeMessage (Msg, FALSE);
                    }

                    if (HtmlFormat) {
                        pAppendStringToGrowBuf (StringBuf, Msg);
                    } else {
                        pWrapStringToGrowBuf (StringBuf, Msg, 0, 0);
                    }

                    if (g_ListFormat) {
                        pWriteNewLine (StringBuf);
                        FreeText (msg);
                    }

                    FreeStringResource (Msg);
                }
            }

            //
            // Begin a new class
            //

            StringCopy (FormatState->LastClass, Class);

            if (!g_ListFormat) {
                if (HtmlFormat) {
                    pAppendStringToGrowBuf (StringBuf, TEXT("<UL><B>"));
                    pAppendStringToGrowBuf (StringBuf, Class);
                    pAppendStringToGrowBuf (StringBuf, TEXT("</B><BR>"));
                } else {

                    EncodedText = pEncodeMessage (Class, FALSE);
                    if (EncodedText) {
                        pWrapStringToGrowBuf (StringBuf, EncodedText, 4, 2);
                        FreeText (EncodedText);
                    }

                }
            }

            pAppendStringToGrowBuf (StringBuf, TEXT("\r\n"));
        }

        //
        // Add the device name
        //

        if (!g_ListFormat) {
            if (HtmlFormat) {
                pAppendStringToGrowBuf (StringBuf, TEXT("&nbsp;&nbsp;"));
            }

            if (HtmlFormat) {
                pAppendStringToGrowBuf (StringBuf, p);
                pAppendStringToGrowBuf (StringBuf, TEXT("<BR>"));
            } else {
                EncodedText = pEncodeMessage (p, HtmlFormat);
                if (EncodedText) {
                    pWrapStringToGrowBuf (StringBuf, EncodedText, 6, 2);
                    FreeText (EncodedText);
                }
            }
        } else {
            pDumpDwordToGrowBuf (StringBuf, Level);
            EncodedText = pEncodeMessage (p, FALSE);
            _sntprintf (fmtLine, 1024, TEXT("%s (%s)"), EncodedText ? EncodedText : p, Class);
            FreeText (EncodedText);
            pAppendStringToGrowBuf (StringBuf, fmtLine);
        }

        pAppendStringToGrowBuf (StringBuf, TEXT("\r\n"));
        break;

    case CLEANUP:

        FormatState = *((PPNPFORMATSTATE *) State);

        if (FormatState) {

            if (!g_ListFormat) {
                if (*FormatState->LastClass) {
                    if (HtmlFormat) {
                        pAppendStringToGrowBuf (StringBuf, TEXT("</UL>\r\n"));
                    } else {
                        pAppendStringToGrowBuf (StringBuf, TEXT("\r\n"));
                    }
                }

                //
                // Append optional footer text
                //

                if (MsgIdBottom) {
                    Msg = GetStringResource (HtmlFormat ? MsgIdBottomHtml : MsgIdBottom);
                    if (Msg) {
                        if (HtmlFormat) {
                            pAppendStringToGrowBuf (StringBuf, Msg);
                        } else {
                            pWrapStringToGrowBuf (StringBuf, Msg, 0, 0);
                        }

                        FreeStringResource (Msg);
                    }
                }
            }

            MemFree (g_hHeap, 0, FormatState);
        }

        break;
    }

    return TRUE;
}


PCTSTR
pFindEndOfTag (
    IN      PCTSTR Tag
    )
{
    BOOL quoteMode;
    CHARTYPE ch;

    quoteMode = FALSE;

    do {
        Tag = _tcsinc (Tag);
        ch = _tcsnextc (Tag);

        if (ch == TEXT('\"')) {
            quoteMode = !quoteMode;
        } else if (!quoteMode && ch == TEXT('>')) {
            break;
        }
    } while (ch);

    return Tag;
}


PCTSTR
pEncodeMessage (
    IN      PCTSTR Message,
    IN      BOOL HtmlFormat
    )

/*++

Routine Description:

  pEncodeMessage removes the unsupported HTML tags from Message, and returns a
  text pool string.  If plain text is required, all HTML tags are removed from
  Message, and all HTML-escaped characters are converted into normal text.

  If Message contains leading space, and the caller wants an HTML return
  string, then the leading space is converted in to non-breaking space
  characters.

Arguments:

  Message - Specifies the text to convert

  HtmlFormat - Specifies TRUE if the return value should be in HTML, or FALSE
               if it should be in plain text.

Return Value:

  A pointer to a text pool allocated string.  The caller must
  free this pointer with FreeText.

--*/

{
    PCTSTR p, r;
    PCTSTR mnemonic;
    PTSTR q;
    BOOL processed;
    PTSTR Buf;
    CHARTYPE ch;
    BOOL Copy;
    PCTSTR semicolon;
    PCTSTR closeBracket;
    PCTSTR endOfMnemonic;
    UINT leadingSpaces;

    leadingSpaces = 0;

    if (HtmlFormat) {
        p = Message;

        while (*p) {
            if (_istspace (_tcsnextc (Message))) {
                leadingSpaces++;
            } else if (_tcsnextc (Message) == TEXT('<')) {
                // ignore html tags
                p = pFindEndOfTag (p);
            } else {
                // first printable character -- stop
                break;
            }

            p = _tcsinc (p);
        }
    }

    //
    // Allocate an output buffer. AllocText takes the number of logical
    // characters as input; the terminating nul is a character.
    //

    Buf = AllocText (CharCount (Message) + (leadingSpaces * 6) + 1);
    if (!Buf) {
        return NULL;
    }

    p = Message;
    q = Buf;

    while (*p) {

        ch = _tcsnextc (p);
        processed = FALSE;

        //
        // If caller wants plain text, remove HTML encodings and tags
        //

        if (!HtmlFormat) {
            if (ch == TEXT('&')) {
                //
                // Convert ampersand-encoded characters
                //

                semicolon = _tcschr (p + 1, TEXT(';'));
                mnemonic = p + 1;

                if (semicolon) {
                    processed = TRUE;

                    if (StringMatchAB (TEXT("lt"), mnemonic, semicolon)) {
                        *q++ = TEXT('<');
                    } else if (StringMatchAB (TEXT("gt"), mnemonic, semicolon)) {
                        *q++ = TEXT('>');
                    } else if (StringMatchAB (TEXT("amp"), mnemonic, semicolon)) {
                        *q++ = TEXT('&');
                    } else if (StringMatchAB (TEXT("quot"), mnemonic, semicolon)) {
                        *q++ = TEXT('\"');
                    } else if (StringMatchAB (TEXT("apos"), mnemonic, semicolon)) {
                        *q++ = TEXT('\'');
                    } else if (StringMatchAB (TEXT("nbsp"), mnemonic, semicolon)) {
                        *q++ = TEXT(' ');
                    } else {
                        processed = FALSE;
                    }

                    if (processed) {
                        // move p to the last character of the mnemonic
                        p = semicolon;
                    }
                }

            } else if (ch == TEXT('<')) {
                //
                // Hop over HTML tag and its arguments, leaving p on the
                // closing angle bracket or terminating nul
                //

                p = pFindEndOfTag (p);
                processed = TRUE;
            }

        }

        //
        // If the caller wants an HTML return string, strip out all
        // unsupported tags. Convert leading spaces into &nbsp;.
        //

        else {

            if (ch == TEXT('<')) {

                closeBracket = pFindEndOfTag (p);
                mnemonic = p + 1;

                endOfMnemonic = p;
                while (!_istspace (_tcsnextc (endOfMnemonic))) {
                    endOfMnemonic = _tcsinc (endOfMnemonic);
                    if (endOfMnemonic == closeBracket) {
                        break;
                    }
                }

                //
                // if a known good tag, copy it, otherwise skip it
                //

                if (StringIMatchAB (TEXT("A"), mnemonic, endOfMnemonic) ||
                    StringIMatchAB (TEXT("/A"), mnemonic, endOfMnemonic) ||
                    StringIMatchAB (TEXT("P"), mnemonic, endOfMnemonic) ||
                    StringIMatchAB (TEXT("/P"), mnemonic, endOfMnemonic) ||
                    StringIMatchAB (TEXT("BR"), mnemonic, endOfMnemonic) ||
                    StringIMatchAB (TEXT("/BR"), mnemonic, endOfMnemonic)
                    ) {
                    StringCopyAB (q, p, _tcsinc (closeBracket));
                    q = GetEndOfString (q);
                    processed = TRUE;
                }

                p = closeBracket;

            } else if (leadingSpaces && _istspace (ch)) {
                StringCopy (q, TEXT("&nbsp;"));
                q = GetEndOfString (q);
                processed = TRUE;
            } else {
                // first printable character -- turn off leading space conversion
                leadingSpaces = 0;
            }
        }

        //
        // If not processed, copy the character
        //

        if (!processed) {
            _copytchar (q, p);
            q = _tcsinc (q);
        }

        if (*p) {
            p = _tcsinc (p);
        }
    }

    *q = 0;

    return Buf;
}


BOOL
pDefaultHandler (
    IN      CALLCONTEXT Context,
    IN      PMSGGROUP_PROPS Group,
    IN OUT  PGROWBUFFER StringBuf,
    IN      PCTSTR SubGroup,
    IN      PCTSTR Message,
    IN      DWORD Level,
    IN      BOOL HtmlFormat,
    IN OUT  PVOID *State,
    IN      DWORD Arg
    )

/*++

Routine Description:

  pDefaultHandler formats all messages that are not handled
  in some other way.  The formatting is simple -- the message group
  is added to the report in bold, and the text is placed
  below the message group.

  All text for the default handler appears at the end of the
  incompatibility report.

Arguments:

  Context - Specifies the way the handler is being called, either to
            initialize, process an item or clean up.

  Group - Specifies the group properties of this item

  StringBuf - Specifies the current report.  Append text to this buffer via
              the pAppendStringToGrowBuf routine.

  SubGroup - Specifies the message subgroup, and does not include the root
             message group.

  Message - Specifies the message text

  Level - Specifies the severity level of Message (info, error, etc.)

  HtmlFormat - Specifies TRUE if the text should be written with HTML
               formatting tags, or FALSE if the text should be formatted as
               plain text.  (See CreateReport comments for HTML tag info.)

  State - A pointer to state, defined by the handler.  State holds an arbitrary
          32-bit value that the handler maintains.  Typically the handler
          allocates a struct when Context is INIT, then uses the struct for
          each PROCESS_ITEM, and finally cleans up the allocation when Context
          is CLEANUP.

  Arg - The DWORD argument from the macro expansion list

Return Value:

  TRUE if the handler was successful, or FALSE if an error occurs.

--*/

{
    PCTSTR EncodedMessage;
    BOOL indent;

    Level &= REPORTLEVEL_ALL;
    MYASSERT (ONEBITSET (Level));

    if (Context != PROCESS_ITEM) {
        return TRUE;
    }

    //
    // Build message group string
    //

    if (HtmlFormat) {
        pAppendStringToGrowBuf (StringBuf, TEXT("<UL>"));
    }

    indent = pAddMsgGroupString (StringBuf, Group, SubGroup, HtmlFormat, Level);

    if (Message) {
        //
        // Add details
        //

        if (!g_ListFormat) {
            if (HtmlFormat) {
                if (indent) {
                    pAppendStringToGrowBuf (StringBuf, TEXT("<UL>"));
                }
            } else {
                pAppendStringToGrowBuf (StringBuf, TEXT("\r\n"));
            }

            EncodedMessage = pEncodeMessage (Message, HtmlFormat);

            if (EncodedMessage) {
                if (HtmlFormat) {
                    pAppendStringToGrowBuf (StringBuf, EncodedMessage);
                    pAppendStringToGrowBuf (StringBuf, TEXT("<BR>\r\n"));
                } else {
                    pWrapStringToGrowBuf (StringBuf, EncodedMessage, 4, 0);
                }

                FreeText (EncodedMessage);
            }

            if (HtmlFormat) {
                if (indent) {
                    pAppendStringToGrowBuf (StringBuf, TEXT("</UL>"));
                }
            } else {
                pAppendStringToGrowBuf (StringBuf, TEXT("\r\n"));
            }
        }
    }

    if (HtmlFormat) {
        pAppendStringToGrowBuf (StringBuf, TEXT("</UL>"));
    }

    pAppendStringToGrowBuf (StringBuf, TEXT("\r\n"));

    return TRUE;
}


BOOL
pProcessGenericList (
    IN OUT  PGROWBUFFER StringBuf,
    IN      BOOL HtmlFormat,
    IN      PMSGGROUP_PROPS Props,
    IN      PGENERIC_LIST List,
    IN      DWORD LevelMask
    )

/*++

Routine Description:

  pProcessGenericList calls the pGenericItemList handler for every message in the
  message group/subgroup.

  An example of a group:

    Installation Notes

  An example of a subgroup:

    Name Changes

  The combined name, as stored in memdb:

    Installation Notes\Name Changes

  All messages for a group are processed if the message group name (specified
  by Props->Name) and subgroup name (specified by List->SubGroupStr) are identical.
  If they are different, only the subgroup messages are processed, providing the
  capatiblity to format a single message group in multiple ways.

Arguments:

  StringBuf - Specifies the GROWBUFFER holding the current report.
              Receives all additional text.

  HtmlFormat - Specifies TRUE if the caller wants the text to
               contain HTML characters, or FALSE if not.

  Props - Specifies the poperties of the group to process.

  List - Specifies the generic list attributes, including the subgroup name and
         intro/conclusion text ids.

  LevelMask - Specifies the severity mask of the messages to process

Return Value:

  TRUE if at least one message was processed, FALSE otherwise.

--*/

{
    REPORT_MESSAGE_ENUM e;
    TCHAR Node[MEMDB_MAX];
    PVOID State = NULL;
    BOOL result = FALSE;

    MYASSERT (List->SubGroupStr);

    if (!StringMatch (List->SubGroupStr, Props->Name)) {
        wsprintf (Node, TEXT("%s\\%s"), Props->Name, List->SubGroupStr);
    } else {
        StringCopy (Node, List->SubGroupStr);
    }

    if (EnumFirstMessage (&e, Node, LevelMask)) {

        result = TRUE;

        pGenericItemList (
            INIT,
            StringBuf,
            List->SubGroupStr,
            NULL,
            e.e.UserFlags,
            HtmlFormat,
            &State,
            List->IntroId,
            List->IntroIdHtml,
            List->ConclusionId,
            List->ConclusionIdHtml,
            List->FormatArgs,
            List->Flags,
            Props
            );

        do {

            pGenericItemList (
                PROCESS_ITEM,
                StringBuf,
                e.MsgGroup,
                e.Message,
                e.e.UserFlags,
                HtmlFormat,
                &State,
                List->IntroId,
                List->IntroIdHtml,
                List->ConclusionId,
                List->ConclusionIdHtml,
                List->FormatArgs,
                List->Flags,
                Props
                );

        } while (EnumNextMessage (&e));

        pGenericItemList (
            CLEANUP,
            StringBuf,
            List->SubGroupStr,
            NULL,
            e.e.UserFlags,
            HtmlFormat,
            &State,
            List->IntroId,
            List->IntroIdHtml,
            List->ConclusionId,
            List->ConclusionIdHtml,
            List->FormatArgs,
            List->Flags,
            Props
            );

    }

    return result;
}


BOOL
pProcessMessageHandler (
    IN OUT  PGROWBUFFER StringBuf,
    IN      BOOL HtmlFormat,
    IN      PMSGGROUP_PROPS Props,
    IN      PHANDLER_LIST Handler,
    IN      DWORD LevelMask
    )

/*++

Routine Description:

  pProcessMessageHandler calls the handler for every message in the
  message group/subgroup that the function wants to handle.

  An example of a group:

    Installation Notes

  An example of a subgroup:

    Name Changes

  The combined name, as stored in memdb:

    Installation Notes\Name Changes

  All messages for a group are processed if the message group name (specified
  by Props->Name) and subgroup name (specified by List->SubGroupStr) are identical.
  If they are different, only the subgroup messages are processed, providing the
  capatiblity to format a single message group in multiple ways.

Arguments:

  StringBuf - Specifies the GROWBUFFER holding the current report.
              Receives all additional text.

  HtmlFormat - Specifies TRUE if the caller wants the text to
               contain HTML characters, or FALSE if not.

  Props - Specifies the poperties of the group to process.

  Handler - Specifies the handler attributes, including the function name
            and subgroup name.

  LevelMask - Specifies the severity of the messages to include, or 0 to
              include all messages

Return Value:

  TRUE if at least one message was processed, FALSE otherwise.

--*/

{
    REPORT_MESSAGE_ENUM e;
    TCHAR Node[MEMDB_MAX];
    BOOL result = FALSE;

    MYASSERT (Handler->SubGroupStr);
    MYASSERT (Handler->Fn);

    if (!StringMatch (Handler->SubGroupStr, Props->Name)) {
        wsprintf (Node, TEXT("%s\\%s"), Props->Name, Handler->SubGroupStr);
    } else {
        StringCopy (Node, Handler->SubGroupStr);
    }

    if (EnumFirstMessage (&e, Node, LevelMask)) {

        result = TRUE;

        Handler->Fn (
            INIT,
            Props,
            StringBuf,
            NULL,
            NULL,
            e.e.UserFlags,
            HtmlFormat,
            &Handler->State,
            Handler->Arg
            );

        do {

            Handler->Fn (
                PROCESS_ITEM,
                Props,
                StringBuf,
                e.MsgGroup,
                e.Message,
                e.e.UserFlags,
                HtmlFormat,
                &Handler->State,
                Handler->Arg
                );

        } while (EnumNextMessage (&e));

        Handler->Fn (
            CLEANUP,
            Props,
            StringBuf,
            NULL,
            NULL,
            e.e.UserFlags,
            HtmlFormat,
            &Handler->State,
            Handler->Arg
            );
    }

    return result;
}


BOOL
pAddMsgGroupToReport (
    IN OUT  PGROWBUFFER StringBuf,
    IN      BOOL HtmlFormat,
    IN      PMSGGROUP_PROPS Props,
    IN      DWORD LevelMask
    )

/*++

Routine Description:

  pAddMsgGroupToReport adds messages for the specified message group
  to the report.  It first enumerates all messages in the group,
  and each one that has a handler is processed first.  After that,
  any remaining messages are put in an "other" section.

Arguments:

  StringBuf - Specifies the GROWBUFFER holding the current report.
              Receives all additional text.

  HtmlFormat - Specifies TRUE if the caller wants the text to
               contain HTML characters, or FALSE if not.

  Props - Specifies the poperties of the group to process.

  LevelMask - Specifies a mask to restrict processing, or 0 to
              process all messages

Return Value:

  TRUE if at least one message was added, FALSE otherwise.

--*/

{
    REPORT_MESSAGE_ENUM e;
    UINT Pass;
    BOOL AddOtherText;
    PHANDLER_LIST Handler;
    PGENERIC_LIST List;
    BOOL result = FALSE;

    //
    // Check to see if there is a handler for all messages in the message
    // group.
    //

    List = pSearchForGenericList (Props->Name);
    if (List) {
        return pProcessGenericList (
                    StringBuf,
                    HtmlFormat,
                    Props,
                    List,
                    LevelMask
                    );
    }

    Handler = pSearchForMsgGroupHandler (Props->Name);
    if (Handler->Fn != pDefaultHandler) {
        return pProcessMessageHandler (
                    StringBuf,
                    HtmlFormat,
                    Props,
                    Handler,
                    LevelMask
                    );
    }

    //
    // Since there is no handler for all messages, call the handlers for
    // subgroups, then call the default handler for the unhandled messages.
    //
    // Two passes, one for the handled messages, and another for the
    // unhandled messages.
    //

    for (Pass = 1 ; Pass <= 2 ; Pass++) {

        AddOtherText = (Pass == 2);

        //
        // Enumerate all messages in the group
        //

        Handler = NULL;
        List = NULL;

        if (EnumFirstMessage (&e, Props->Name, LevelMask)) {

            result = TRUE;

            do {
                //
                // Is this the same message group that was used last time through
                // the loop?  If so, continue enumerating, because this
                // message group is done.
                //

                if ((Handler && pIsThisTheHandler (e.MsgGroup, Handler)) ||
                    (List && pIsThisTheGenericList (e.MsgGroup, List))
                    ) {
                    continue;
                }

                //
                // Is this group a generic list?  For Pass 1, we add the list; for
                // pass 2 we just continue;
                //

                List = pSearchForGenericList (e.MsgGroup);
                if (List) {
                    Handler = NULL;

                    if (Pass == 1) {
                        pProcessGenericList (
                            StringBuf,
                            HtmlFormat,
                            Props,
                            List,
                            LevelMask
                            );
                    }

                    continue;
                }

                //
                // Does this group have a handler?  Pass 1 requires one, and
                // pass 2 requires no handler.
                //

                Handler = pSearchForMsgGroupHandler (e.MsgGroup);

                if (Handler->Fn == pDefaultHandler) {
                    if (Pass == 1) {
                        continue;
                    }
                } else if (Pass == 2) {
                    continue;
                }

                //
                // Add the "other" intro?
                //

                if (!g_ListFormat) {
                    if (AddOtherText) {
                        AddOtherText = FALSE;

                        if (HtmlFormat && Props->OtherIdHtmlStr) {
                            pAppendStringToGrowBuf (StringBuf, Props->OtherIdHtmlStr);
                        } else if (!HtmlFormat && Props->OtherIdStr) {
                            pWrapStringToGrowBuf (StringBuf, Props->OtherIdStr, 0, 0);
                        }
                    }
                }

                //
                // If handler exists, process all messages
                //

                if (Handler->Fn != pDefaultHandler) {
                    pProcessMessageHandler (
                        StringBuf,
                        HtmlFormat,
                        Props,
                        Handler,
                        LevelMask
                        );
                } else {
                    //
                    // Call the default handler
                    //

                    Handler->Fn (
                        PROCESS_ITEM,
                        Props,
                        StringBuf,
                        e.MsgGroup,
                        e.Message,
                        e.e.UserFlags,
                        HtmlFormat,
                        &Handler->State,
                        Handler->Arg
                        );
                }

            } while (EnumNextMessage (&e));
        }
    }

    return result;
}



typedef enum {
    FORMAT_HTML,
    FORMAT_PLAIN_TEXT,
    FORMAT_LIST
} REPORTFORMAT;


BOOL
pCreateReportTextWorker (
    IN      REPORTFORMAT Format,
    IN      UINT TotalCols,         OPTIONAL
    IN      DWORD LevelMask
    )

/*++

Routine Description:

  pCreateReportTextWorker prepares a buffer for the incompatibility report
  text.  It enumerates messages that match the severity requested, then
  performs special formatting, and dumps the remaining incompatibilities to
  a global buffer. The buffer is then used to display, print or save.

  A subset of HTML is supported if HtmlFormat is TRUE. Specifically, the
  following tags are inserted into the report text:

  <B>  - Bold
  <U>  - Underline
  <HR> - Line break
  <UL> - Indented list

  No other HTML tags are recognized.

  The caller must free the return buffer by calling FreeReportText. Also,
  CreateReportText uses a single global buffer and therefore cannot be called
  more than once.  Instead, the caller must use the text and/or duplicate it,
  then call FreeReportText, before calling CreateReportText a second time.

Arguments:

  Format - Specifies which type of report to generate

  TotalCols - Specifies the number of cols for a plain text report

  LevelMask - Specifies which severity levels to add (verbose, error,
              blocking) or zero for all levels

Return Value:

  TRUE if at least one message was added, FALSE otherwise.

--*/

{
    REPORT_MESSAGE_ENUM MsgGroups;
    PMSGGROUP_PROPS Props;
    REPORT_MESSAGE_ENUM e;
    PTSTR TempStr;
    BOOL HtmlFormat;
    UINT oldEnd;
    BOOL result = FALSE;

    if (!LevelMask) {
        return FALSE;
    }

    HtmlFormat = (Format == FORMAT_HTML);

    //
    // Add report details
    //

    if (EnumFirstRootMsgGroup (&e, LevelMask)) {
        do {
            g_LastMsgGroupBuf[0] = 0;

            //
            // Obtain message group properties.  If no properties exist, then ignore the message.
            //

            Props = pFindMsgGroupStruct (e.MsgGroup);
            if (!Props) {
                DEBUGMSG ((DBG_WHOOPS, "Group %s is not supported as a root", e.MsgGroup));
                continue;
            }

            //
            // Add bookmark for base group
            //

            oldEnd = g_ReportString.End;

            if (!g_ListFormat) {
                if (HtmlFormat) {

                    TempStr = AllocText (6 + CharCount (e.MsgGroup) + 1);
                    if (TempStr) {
                        wsprintf (TempStr, TEXT("<A NAME=\"%s\">"), e.MsgGroup);
                        pAppendStringToGrowBuf (&g_ReportString, TempStr);
                        FreeText (TempStr);
                    }
                }
                //
                // Is there an intro string?  If so, add it.
                //

                if (HtmlFormat && Props->IntroIdHtmlStr) {
                    pAppendStringToGrowBuf (&g_ReportString, Props->IntroIdHtmlStr);
                } else if (!HtmlFormat && Props->IntroIdStr) {
                    pWrapStringToGrowBuf (&g_ReportString, Props->IntroIdStr, 0, 0);
                }
            }

            //
            // Add all messages in this group to the report
            //

            if (!pAddMsgGroupToReport (
                    &g_ReportString,
                    HtmlFormat,
                    Props,
                    LevelMask
                    )) {
                //
                // No messages -- back out heading text
                //

                if (oldEnd) {
                    g_ReportString.End = 0;
                } else {
                    FreeGrowBuffer (&g_ReportString);
                }
            } else {
                result = TRUE;
            }

        } while (EnumNextRootMsgGroup (&e));
    }

    return result;
}


VOID
FreeReportText (
    VOID
    )

/*++

Routine Description:

  FreeReportText frees the memory allocated by CreateReportText.

Arguments:

  none

Return Value:

  none

--*/

{
    FreeGrowBuffer (&g_ReportString);
}


VOID
pAddHeadingToReport (
    IN OUT  PGROWBUFFER Buffer,
    IN      BOOL HtmlFormat,
    IN      UINT PlainTextId,
    IN      UINT HtmlId
    )
{
    PCTSTR msg;

    if (HtmlFormat) {
        msg = GetStringResource (HtmlId);
        pAppendStringToGrowBuf (Buffer, msg);
    } else {
        msg = GetStringResource (PlainTextId);
        pWrapStringToGrowBuf (Buffer, msg, 0, 0);
    }

    FreeStringResource (msg);
}


VOID
pMoveReportTextToGrowBuf (
    IN OUT  PGROWBUFFER SourceBuffer,
    IN OUT  PGROWBUFFER DestBuffer
    )
{
    UINT end;
    UINT trim = 0;

    end = DestBuffer->End;
    if (end) {
        trim = sizeof (TCHAR);
        end -= trim;
    }

    if (!GrowBuffer (DestBuffer, SourceBuffer->End - trim)) {
        return;
    }

    CopyMemory (DestBuffer->Buf + end, SourceBuffer->Buf, SourceBuffer->End);
    SourceBuffer->End = 0;
}


VOID
pAddTocEntry (
    IN OUT  PGROWBUFFER Buffer,
    IN      PCTSTR Bookmark,
    IN      UINT MessageId,
    IN      BOOL HtmlFormat
    )
{
    PCTSTR msg;

    msg = GetStringResource (MessageId);

    if (HtmlFormat) {
        pAppendStringToGrowBuf (Buffer, TEXT("<A HREF=\"#"));
        pAppendStringToGrowBuf (Buffer, Bookmark);
        pAppendStringToGrowBuf (Buffer, TEXT("\">"));
        pAppendStringToGrowBuf (Buffer, msg);
        pAppendStringToGrowBuf (Buffer, TEXT("</A><BR>\r\n"));
    } else {
        pWrapStringToGrowBuf (Buffer, msg, 8, 2);
        pAppendStringToGrowBuf (Buffer, TEXT("\r\n"));
    }
}

BOOL
AreThereAnyBlockingIssues(
    VOID
    )
{
    REPORT_MESSAGE_ENUM e;

    if(EnumFirstRootMsgGroup (&e, REPORTLEVEL_BLOCKING)) {
        return TRUE;
    }

    return FALSE;
}


PCTSTR
CreateReportText (
    IN      BOOL HtmlFormat,
    IN      UINT TotalCols,
    IN      DWORD Level,
    IN      BOOL ListFormat
    )
{
    REPORTFORMAT format;
    GROWBUFFER fullReport = GROWBUF_INIT;
    PCTSTR argArray[1];
    PCTSTR msg;
    PCTSTR subMsg = NULL;
    REPORT_MESSAGE_ENUM msgGroups;
    PBYTE dest;
    DWORD levelMask;
    UINT end;
    BOOL blocking = FALSE;
    BOOL warning = FALSE;
    BOOL info = FALSE;

    //
    // Intialize
    //

    if (HtmlFormat) {
        format = FORMAT_HTML;
    } else if (ListFormat) {
        format = FORMAT_LIST;
    } else {
        format = FORMAT_PLAIN_TEXT;
    }

    g_ListFormat = ListFormat;

    if (TotalCols) {
        g_TotalCols = TotalCols;
    } else {
        g_TotalCols = g_ListFormat ? 0x7fffffff : 70;
    }

    //
    // Create the report body
    //

    FreeReportText();

    //
    // test for no incompatibilities
    //

    MYASSERT (ONEBITSET (Level));
    levelMask = LEVELTOMASK (Level);

    if (ListFormat) {
        levelMask |= REPORTLEVEL_IN_SHORT_LIST;
    }

    if (!EnumFirstRootMsgGroup (&msgGroups, levelMask)) {
        if (!ListFormat) {
            pAddHeadingToReport (
                &g_ReportString,
                HtmlFormat,
                MSG_NO_INCOMPATIBILITIES,
                MSG_NO_INCOMPATIBILITIES
                );
        }

        return (PCTSTR) g_ReportString.Buf;
    }

    if (ListFormat) {
        //
        // In list format, create the report in one pass
        //

        pCreateReportTextWorker (format, TotalCols, levelMask);

        return (PCTSTR) g_ReportString.Buf;
    }

    //
    // In HTML or plain text, create the body of the report by making 3
    // passes. The first pass is for blocking issues, the second is for
    // warnings, and the third is for information.
    //
    // We put the report in a temporary buffer (fullReport), because after the
    // body is prepared, we then can prepare the table of contents.
    //

    // blocking section
    if (pCreateReportTextWorker (
            format,
            TotalCols,
            REPORTLEVEL_BLOCKING & levelMask
            )) {

        blocking = TRUE;

        if (HtmlFormat) {
            pAppendStringToGrowBuf (&fullReport, TEXT("<A NAME=\"blocking\">"));
        }

        pAddHeadingToReport (
            &fullReport,
            HtmlFormat,
            MSG_BLOCKING_INTRO,
            MSG_BLOCKING_INTRO_HTML
            );

        pMoveReportTextToGrowBuf (&g_ReportString, &fullReport);
    }

    // warning section

    if (pCreateReportTextWorker (
            format,
            TotalCols,
            (REPORTLEVEL_ERROR|REPORTLEVEL_WARNING) & levelMask
            )) {

        warning = TRUE;

        if (HtmlFormat) {
            pAppendStringToGrowBuf (&fullReport, TEXT("<A NAME=\"warning\">"));
        }

        pAddHeadingToReport (
            &fullReport,
            HtmlFormat,
            MSG_WARNING_INTRO,
            MSG_WARNING_INTRO_HTML
            );

        pMoveReportTextToGrowBuf (&g_ReportString, &fullReport);
    }

    // info section
    if (pCreateReportTextWorker (
            format,
            TotalCols,
            (REPORTLEVEL_INFORMATION|REPORTLEVEL_VERBOSE) & levelMask
            )) {

        info = TRUE;

        if (HtmlFormat) {
            pAppendStringToGrowBuf (&fullReport, TEXT("<A NAME=\"info\">"));
        }

        pAddHeadingToReport (
            &fullReport,
            HtmlFormat,
            MSG_INFO_INTRO,
            MSG_INFO_INTRO_HTML
            );

        pMoveReportTextToGrowBuf (&g_ReportString, &fullReport);
    }

    //
    // Now produce the complete report (with table of contents)
    //

    MYASSERT (!g_ReportString.End);
    MYASSERT (fullReport.End);

    //
    // add the heading text
    //

    if (HtmlFormat) {
        pAppendStringToGrowBuf (&g_ReportString, TEXT("<A NAME=\"top\">"));
    }

    if (blocking) {
        //
        // add instructions based on the presence of blocking issues
        //

        if (HtmlFormat) {
            argArray[0] = GetStringResource (g_PersonalSKU ?
                                                MSG_PER_SUPPORT_LINK_HTML :
                                                MSG_PRO_SUPPORT_LINK_HTML
                                            );

            msg = ParseMessageID (MSG_REPORT_BLOCKING_INSTRUCTIONS_HTML, argArray);

            pAppendStringToGrowBuf (&g_ReportString, msg);

        } else{
            argArray[0] = GetStringResource (g_PersonalSKU ?
                                                MSG_PER_SUPPORT_LINK :
                                                MSG_PRO_SUPPORT_LINK
                                            );

            msg = ParseMessageID (MSG_REPORT_BLOCKING_INSTRUCTIONS, argArray);

            pWrapStringToGrowBuf (&g_ReportString, msg, 0, 0);
        }

        FreeStringResource (argArray[0]);
        FreeStringResource (msg);

    } else {
        //
        // add instructions for just warnings and information
        //

        if (HtmlFormat) {
            msg = GetStringResource (MSG_REPORT_GENERAL_INSTRUCTIONS_HTML);
            pAppendStringToGrowBuf (&g_ReportString, msg);
        } else {
            msg = GetStringResource (MSG_REPORT_GENERAL_INSTRUCTIONS);
            pWrapStringToGrowBuf (&g_ReportString, msg, 0, 0);
        }

        FreeStringResource (msg);

        if (HtmlFormat) {
            msg = GetStringResource (MSG_CONTENTS_TITLE_HTML);
            pAppendStringToGrowBuf (&g_ReportString, msg);
        } else {
            msg = GetStringResource (MSG_CONTENTS_TITLE);
            pWrapStringToGrowBuf (&g_ReportString, msg, 0, 0);
        }

        FreeStringResource (msg);

    }

    //
    // add table of contents
    //

    if (HtmlFormat) {
        pAppendStringToGrowBuf (&g_ReportString, TEXT("<UL>"));
    }

    if (blocking) {
        pAddTocEntry (&g_ReportString, TEXT("blocking"), MSG_BLOCKING_TOC, HtmlFormat);
    }

    if (warning) {
        pAddTocEntry (&g_ReportString, TEXT("warning"), MSG_WARNING_TOC, HtmlFormat);
    }

    if (info) {
        pAddTocEntry (&g_ReportString, TEXT("info"), MSG_INFO_TOC, HtmlFormat);
    }

    if (HtmlFormat) {
        pAppendStringToGrowBuf (&g_ReportString, TEXT("</UL>"));
    }

    pAppendStringToGrowBuf (&g_ReportString, TEXT("\r\n"));

    //
    // add bottom of heading text
    //

    if (!blocking) {

        if (HtmlFormat) {
            argArray[0] = GetStringResource (g_PersonalSKU ?
                                                MSG_PER_SUPPORT_LINK_HTML :
                                                MSG_PRO_SUPPORT_LINK_HTML
                                            );

            msg = ParseMessageID (MSG_REPORT_GENERAL_INSTRUCTIONS_END_HTML, argArray);

            pAppendStringToGrowBuf (&g_ReportString, msg);

        } else{
            argArray[0] = GetStringResource (g_PersonalSKU ?
                                                MSG_PER_SUPPORT_LINK :
                                                MSG_PRO_SUPPORT_LINK
                                            );

            msg = ParseMessageID (MSG_REPORT_GENERAL_INSTRUCTIONS_END, argArray);

            pWrapStringToGrowBuf (&g_ReportString, msg, 0, 0);
        }

        FreeStringResource (argArray[0]);
        FreeStringResource (msg);

        if (g_ConfigOptions.EnableBackup) {
            if (HtmlFormat) {
                subMsg = GetStringResource (MSG_REPORT_BACKUP_INSTRUCTIONS_HTML);
                pAppendStringToGrowBuf (&g_ReportString, subMsg);
            } else {
                subMsg = GetStringResource (MSG_REPORT_BACKUP_INSTRUCTIONS);
                pWrapStringToGrowBuf (&g_ReportString, subMsg, 0, 0);
            }
            FreeStringResource (subMsg);
        }
    }

    //
    // add body text
    //

    pMoveReportTextToGrowBuf (&fullReport, &g_ReportString);

    //
    // Clean up temp buffer and return
    //

    FreeGrowBuffer (&fullReport);

    return (PCTSTR) g_ReportString.Buf;
}


BOOL
IsIncompatibleHardwarePresent (
    VOID
    )
{
    REPORT_MESSAGE_ENUM msgGroups;
    PCTSTR msg;
    BOOL result = FALSE;

    if (EnumFirstRootMsgGroup (&msgGroups, 0)) {
        msg = GetStringResource (MSG_INCOMPATIBLE_HARDWARE_ROOT);

        do {
            if (StringMatch (msg, msgGroups.MsgGroup)){
                result = TRUE;
                break;
            }
        } while (EnumNextRootMsgGroup (&msgGroups));

        FreeStringResource (msg);
    }

    return result;
}


PCTSTR
BuildMessageGroup (
    IN      UINT RootGroupId,
    IN      UINT SubGroupId,            OPTIONAL
    IN      PCTSTR Item                 OPTIONAL
    )

/*++

Routine Description:

  BuildMessageGroup returns a string generated by loading the string resources
  for the specified group ID, subgroup ID and Item string.

Arguments:

  RootGroupId - Specifies the message resource ID of the root group.  Must be
                one of the defined roots.  (See the top of this file.)

  SubGroup - Specifies a message resource ID of a string to append to the
             root.

  Item - Specifies a string to append to the end of the string, used to
         uniquely identify a message.

Return Value:

  A pointer to the message group string.  Caller must free the string via
  FreeText.

--*/

{
    PCTSTR RootGroup;
    PCTSTR SubGroup;
    PCTSTR Group;

    RootGroup = GetStringResource (RootGroupId);
    MYASSERT (RootGroup);
    if (!RootGroup) {
        return NULL;
    }

    if (SubGroupId) {
        SubGroup = GetStringResource (SubGroupId);
        MYASSERT (SubGroup);
    } else {
        SubGroup = NULL;
    }

    if (SubGroup) {
        Group = JoinTextEx (NULL, RootGroup, SubGroup, TEXT("\\"), 0, NULL);
        MYASSERT (Group);
        FreeStringResource (SubGroup);
    } else {
        Group = DuplicateText (RootGroup);
    }

    FreeStringResource (RootGroup);

    if (Item) {
        RootGroup = Group;
        Group = JoinTextEx (NULL, RootGroup, Item, TEXT("\\"), 0, NULL);
        MYASSERT (Group);

        FreeText (RootGroup);
    }

    return Group;
}


BOOL
IsPreDefinedMessageGroup (
    IN      PCTSTR Group
    )
{
    return pFindMsgGroupStruct (Group) != NULL;
}

PCTSTR
GetPreDefinedMessageGroupText (
    IN      UINT GroupNumber
    )
{
    PMSGGROUP_PROPS Props;

    //
    // GroupNumber is an externally used value.  Migration DLLs may hard-code
    // this number.  If necessary, here is where translation is done when
    // the groups change.
    //

    // No translation is necessary today

    Props = pFindMsgGroupStructById (GroupNumber);

    return Props ? Props->Name : NULL;
}


BOOL
IsReportEmpty (
    IN      DWORD Level
    )
{
    REPORT_MESSAGE_ENUM e;
    DWORD levelMask;

    MYASSERT (ONEBITSET (Level));
    levelMask = LEVELTOMASK (Level);

    return !EnumFirstMessage (&e, NULL, levelMask);
}


BOOL
EnumFirstListEntry (
    OUT     PLISTREPORTENTRY_ENUM EnumPtr,
    IN      PCTSTR ListReportText
    )
{
    if (!ListReportText || !*ListReportText) {
        return FALSE;
    }
    EnumPtr->Next = (PTSTR)ListReportText;
    EnumPtr->ReplacedChar = 0;
    return EnumNextListEntry (EnumPtr);
}

BOOL
EnumNextListEntry (
    IN OUT  PLISTREPORTENTRY_ENUM EnumPtr
    )
{
    INT n;

    if (!EnumPtr->Next) {
        return FALSE;
    }

    EnumPtr->Entry = EnumPtr->Next;
    if (EnumPtr->ReplacedChar) {
        *EnumPtr->Next = EnumPtr->ReplacedChar;
        EnumPtr->ReplacedChar = 0;
        EnumPtr->Entry += sizeof (TEXT("\r\n")) / sizeof (TCHAR) - 1;
    }

    EnumPtr->Next = _tcsstr (EnumPtr->Entry, TEXT("\r\n"));
    if (EnumPtr->Next) {
        EnumPtr->ReplacedChar = *EnumPtr->Next;
        *EnumPtr->Next = 0;
    }

    EnumPtr->Entry = SkipSpace (EnumPtr->Entry);

    EnumPtr->Header = StringMatchCharCount (
                            EnumPtr->Entry,
                            TEXT("<H>"),
                            sizeof (TEXT("<H>")) / sizeof (TCHAR) - 1
                            );
    if (EnumPtr->Header) {
        EnumPtr->Entry += sizeof (TEXT("<H>")) / sizeof (TCHAR) - 1;
    }

    if (_stscanf (EnumPtr->Entry, TEXT("<%lu>%n"), &EnumPtr->Level, &n) == 1) {
        EnumPtr->Entry += n;
    } else {
        EnumPtr->Level = REPORTLEVEL_NONE;
    }

    EnumPtr->Level &= REPORTLEVEL_ALL;          // screen out REPORTLEVEL_IN_SHORT_LIST

    EnumPtr->Entry = SkipSpace (EnumPtr->Entry);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\ui\textview.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    textview.c

Abstract:

    The code in this module implements a simple text view control
    that supports a few HTML-style tags.  The caller sets the control
    font with WM_SETFONT, then adds text line-by-line by sending
    WMX_ADDLINE messages, and finally sends a WMX_GOTO to jump to
    a specific bookmark.

    WMX_ADDLINE

        wParam: Specifies a pointer to a LINEATTRIBS struct, or
                NULL if the last line's attributes are to be
                used.  (If no lines exist and wParam is NULL,
                default attributes are used.)

        lParam: Specifes a pointer to the text to add.

        Return Value: The number of bytes of the lParam string
                      that are visible in the control.


        The text can contain the following HTML-style tags:

        <B>                 - Turns on BOLD
        </B>                - Turns off BOLD
        <U>                 - Turns on UNDERLINE
        </U>                - Turns off UNDERLINE
        <UL>                - Indents text
        </UL>               - Unindents text
        <HR>                - A separator line
        <A name=bookmark>   - Specifies a bookmark (see WMX_GOTO)
        <BR>                - Adds a line break


        Line-feed and carriage-return characters are interpreted as <BR>.

    WMX_GOTO

        wParam: Unused

        lParam: Specifies a pointer to the string specifing the bookmark
                to jump to.

        Return Value: Always zero.

Author:

    Jim Schmidt (jimschm) 28-Oct-1997

Revision History:

    jimschm     23-Sep-1998 IDC_HAND collision fix (now IDC_OUR_HAND)

--*/

#include "pch.h"
#include "uip.h"

#include <shellapi.h>


UINT g_HangingIndentPixels;
PCTSTR g_HangingIndentString = TEXT("    ");
UINT g_FarEastFudgeFactor;
extern BOOL g_Terminated;

#define COMMAND_BOLD            1
#define COMMAND_BOLD_END        2
#define COMMAND_UNDERLINE       3
#define COMMAND_UNDERLINE_END   4
#define COMMAND_HORZ_RULE       5
#define COMMAND_ANCHOR          6
#define COMMAND_ANCHOR_END      7
#define COMMAND_INDENT          8
#define COMMAND_UNINDENT        9
#define COMMAND_LIST_ITEM       10
#define COMMAND_LIST_ITEM_END   11
#define COMMAND_LINE_BREAK      12
#define COMMAND_WHITESPACE      13
#define COMMAND_PARAGRAPH       14
#define COMMAND_ESCAPED_CHAR    15


typedef struct {
    BYTE Command;
    PCTSTR Text;
    UINT TextLen;
} TAG, *PTAG;

TAG g_TagList[] = {
    {COMMAND_BOLD,          TEXT("B"),      0},
    {COMMAND_BOLD_END,      TEXT("/B"),     0},
    {COMMAND_UNDERLINE,     TEXT("U"),      0},
    {COMMAND_UNDERLINE_END, TEXT("/U"),     0},
    {COMMAND_HORZ_RULE,     TEXT("HR"),     0},
    {COMMAND_ANCHOR,        TEXT("A"),      0},
    {COMMAND_ANCHOR_END,    TEXT("/A"),     0},
    {COMMAND_INDENT,        TEXT("UL"),     0},
    {COMMAND_UNINDENT,      TEXT("/UL"),    0},
    {COMMAND_LIST_ITEM,     TEXT("LI"),     0},
    {COMMAND_LIST_ITEM_END, TEXT("/LI"),    0},
    {COMMAND_LINE_BREAK,    TEXT("BR"),     0},
    {COMMAND_PARAGRAPH,     TEXT("P"),      0},
    {0,                     NULL,           0}
};

#define MAX_URL         4096
#define MAX_BOOKMARK    128

typedef struct {
    RECT Rect;
    TCHAR Url[MAX_URL];
    TCHAR Bookmark[MAX_BOOKMARK];
} HOTLINK, *PHOTLINK;


PCTSTR
pParseHtmlArgs (
    IN      PCTSTR Start,
    IN      PCTSTR End
    )
{
    PTSTR MultiSz;
    PCTSTR ArgStart;
    PCTSTR ArgEnd;
    PTSTR p;
    BOOL Quotes;
    UINT Size;
    CHARTYPE ch;

    Size = (End - Start) * 2;
    MultiSz = AllocPathString (Size);
    if (!MultiSz) {
        return NULL;
    }

    p = MultiSz;

    do {
        while (*Start && _istspace (_tcsnextc (Start))) {
            Start = _tcsinc (Start);
        }

        if (*Start == 0) {
            break;
        }

        ArgStart = Start;
        ArgEnd = ArgStart;
        Quotes = FALSE;

        while (*ArgEnd) {
            if (_tcsnextc (ArgEnd) == TEXT('\"')) {
                Quotes = !Quotes;
            } else if (!Quotes) {
                ch = _tcsnextc (ArgEnd);
                if (_istspace (ch) || ch == TEXT('>')) {
                    break;
                }
            }

            ArgEnd = _tcsinc (ArgEnd);
        }

        if (ArgEnd > ArgStart) {
            StringCopyAB (p, ArgStart, ArgEnd);
            p = GetEndOfString (p) + 1;
        }

        Start = ArgEnd;

    } while (*Start && _tcsnextc (Start) != TEXT('>'));

    *p = 0;
    MYASSERT ((UINT) (p - MultiSz) < Size);

    return MultiSz;
}

PCTSTR
pGetNextHtmlToken (
    IN      PCTSTR Arg,
    OUT     PTSTR Key,
    IN      PCTSTR Delimiters       OPTIONAL
    )
{
    BOOL Quotes;
    PCTSTR ArgStart, ArgEnd, ArgEndSpaceTrimmed;
    PCTSTR ArgStartPlusOne;
    PCTSTR Delim;
    CHARTYPE ch;

    ArgStart = SkipSpace (Arg);
    ArgEnd = ArgStart;
    ArgEndSpaceTrimmed = ArgEnd;
    Quotes = FALSE;

    while (*ArgEnd) {
        ch = _tcsnextc (ArgEnd);

        if (Delimiters) {
            Delim = Delimiters;
            while (*Delim) {
                if (ch == _tcsnextc (Delim)) {
                    break;
                }
                Delim = _tcsinc (Delim);
            }

            if (*Delim) {
                ch = 0;
            }
        }

        if (ch == 0) {
            break;
        }

        if (!_istspace (ch)) {
            ArgEndSpaceTrimmed = ArgEnd;
        }

        ArgEnd = _tcsinc (ArgEnd);
    }

    //
    // Copy arg, stripping surrounding quotes
    //

    ArgEndSpaceTrimmed = _tcsinc (ArgEndSpaceTrimmed);

    if (_tcsnextc (Key) != TEXT('\"')) {
        StringCopyAB (Key, ArgStart, ArgEndSpaceTrimmed);
    } else {
        ArgEndSpaceTrimmed = _tcsdec2 (ArgStart, ArgEndSpaceTrimmed);
        if (!ArgEndSpaceTrimmed) {
            ArgEndSpaceTrimmed = ArgStart;
        } else if (_tcsnextc (ArgEndSpaceTrimmed) != TEXT('\"')) {
            ArgEndSpaceTrimmed = _tcsinc (ArgEndSpaceTrimmed);
        }

        ArgStartPlusOne = _tcsinc (ArgStart);
        StringCopyAB (Key, ArgStartPlusOne, ArgEndSpaceTrimmed);
    }

    if (*ArgEnd) {
        ArgEnd = _tcsinc (ArgEnd);
    }

    return ArgEnd;
}

VOID
pGetHtmlKeyAndValue (
    IN      PCTSTR Arg,
    OUT     PTSTR Key,
    OUT     PTSTR Value
    )
{
    PTSTR p;

    Arg = pGetNextHtmlToken (Arg, Key, TEXT("="));
    MYASSERT (Arg);

    if (_tcsnextc (Arg) == TEXT('\"')) {
        //
        // De-quote the arg
        //

        StringCopy (Value, _tcsinc (Arg));
        p = _tcsrchr (Value, 0);
        p = _tcsdec2 (Value, p);
        if (p && _tcsnextc (p) == TEXT('\"')) {
            *p = 0;
        }

    } else {
        StringCopy (Value, Arg);
    }
}


PCTSTR
pGetHtmlCommandOrChar (
    IN      PCTSTR String,
    OUT     CHARTYPE *Command,
    OUT     CHARTYPE *Char,
    OUT     PTSTR *CommandArg           OPTIONAL
    )

/*++

Routine Description:

  pGetHtmlCommandOrChar parses HTML text is String, returing the HTML tag
  command, printable character, pointer to the next token, HTML tag arguments
  and a pointer to the end of the current token.

Arguments:

  String - Specifies the string containing HTML

  Command - Receives the HTML tag command (COMMAND_* constant)
            or zero if the next token is not a tag

  Char - Receives the next printable character, or zero if the next token is
         not a printable character. Whitespace is both a command and a
         printable character. The rest are either one or the other.

  CommandArg - Receives a multi-sz of command arguments

Return Value:

  A pointer to the first non-whitespace character of the next token, or
  NULL if no more tokens exist.

--*/

{
    CHARTYPE ch;
    PCTSTR p, q;
    BOOL Quoted;
    CHARTYPE ch2;
    INT i;
    PCTSTR semicolon;

    if (CommandArg) {
        *CommandArg = NULL;
    }

    ch = _tcsnextc (String);
    *Command = 0;

    if (ch == 0) {
        i = 0;
    }

    if (_istspace (ch)) {

        *Command = COMMAND_WHITESPACE;
        ch = TEXT(' ');

    } else if (ch == TEXT('&')) {
        //
        // Convert HTML character escapes:
        //
        // &lt; &gt; &amp; &quot; &apos; &nbsp;
        //

        semicolon = _tcschr (String + 1, TEXT(';'));

        if (semicolon) {
            *Char = 0;

            if (StringMatchAB (TEXT("lt"), String + 1, semicolon)) {
                *Char = TEXT('<');
            } else if (StringMatchAB (TEXT("gt"), String + 1, semicolon)) {
                *Char = TEXT('>');
            } else if (StringMatchAB (TEXT("amp"), String + 1, semicolon)) {
                *Char = TEXT('&');
            } else if (StringMatchAB (TEXT("quot"), String + 1, semicolon)) {
                *Char = TEXT('\"');
            } else if (StringMatchAB (TEXT("apos"), String + 1, semicolon)) {
                *Char = TEXT('\'');
            } else if (StringMatchAB (TEXT("nbsp"), String + 1, semicolon)) {
                *Char = TEXT(' ');
            }

            if (*Char) {
                *Command = COMMAND_ESCAPED_CHAR;
                return _tcsinc (semicolon);
            }
        }
    } else if (ch == TEXT('<')) {

        p = SkipSpace (_tcsinc (String));
        ch = 0;

        if (*p) {

            q = NULL;

            for (i = 0 ; g_TagList[i].Text ; i++) {
                if (StringIMatchTcharCount (g_TagList[i].Text, p, g_TagList[i].TextLen)) {
                    q = p + g_TagList[i].TextLen;

                    ch2 = _tcsnextc (q);
                    if (!_istspace (ch2) && ch2 != TEXT('>')) {
                        continue;
                    }

                    Quoted = FALSE;
                    while (*q) {
                        ch2 = _tcsnextc (q);
                        if (ch2 == TEXT('\"')) {
                            Quoted = !Quoted;
                        } else if (!Quoted) {
                            if (ch2 == TEXT('>')) {
                                break;
                            }
                        }

                        q = _tcsinc (q);
                    }

                    if (*q) {
                        p += g_TagList[i].TextLen;
                        p = SkipSpace (p);
                        break;
                    }
                }
            }

            if (!g_TagList[i].Text) {
                //
                // Ignore unsupported tag
                //

                p = _tcschr (String, TEXT('>'));
                if (!p) {
                    p = GetEndOfString (String);
                }
            } else {
                //
                // Found a tag
                //

                String = p;
                *Command = g_TagList[i].Command;
                p = q;
                MYASSERT (p);

                if (CommandArg && String < p) {
                    *CommandArg = (PTSTR) pParseHtmlArgs (String, p);
                }
            }
        }

        String = p;
    }

    *Char = ch;

    //
    // Skip block of spaces
    //

    if (_istspace (ch)) {

        do {
            String = _tcsinc (String);
        } while (_istspace (_tcsnextc (String)));

        return *String ? String : NULL;
    } else if (*String) {
        return _tcsinc (String);
    }

    return NULL;
}

PCTSTR
pStripFormatting (
    PCTSTR String
    )
{
    PTSTR NewString;
    PCTSTR Start, p, q;
    PTSTR d;
    CHARTYPE Char, Command;
    UINT tchars;

    //
    // Duplicate String, removing the <B> and <U> commands
    //

    NewString = AllocPathString (SizeOfString (String));

    Start = String;
    d = NewString;
    p = Start;

    do {
        q = pGetHtmlCommandOrChar (p, &Command, &Char, NULL);

        if (!Char || Command == COMMAND_WHITESPACE || Command == COMMAND_ESCAPED_CHAR) {
            if (Start < p) {
                tchars = p - Start;
                CopyMemory (d, Start, tchars * sizeof (TCHAR));
                d += tchars;
            }

            if (Char) {
                *d++ = (TCHAR) Char;
            }

            Start = q;
        }

        p = q;
    } while (p);

    *d = 0;

    return NewString;
}


VOID
pCreateFontsIfNecessary (
    HDC hdc,
    HFONT BaseFont,
    PTEXTMETRIC ptm,
    HFONT *hFontNormal,
    HFONT *hFontBold,
    HFONT *hFontUnderlined
    )
{
    LOGFONT lf;
    TCHAR FaceName[LF_FACESIZE];
    SIZE Extent;

    if (!BaseFont) {
        BaseFont = GetStockObject (DEFAULT_GUI_FONT);
    }

    if (BaseFont) {
        SelectObject (hdc, BaseFont);
    }
    GetTextMetrics (hdc, ptm);

    if (!(*hFontNormal)) {
        ZeroMemory (&lf, sizeof (lf));
        GetTextFace (hdc, LF_FACESIZE, FaceName);
        GetObject (BaseFont, sizeof (lf), &lf);

        lf.lfHeight = ptm->tmHeight;
        lf.lfWeight = FW_NORMAL;
        StringCopy (lf.lfFaceName, FaceName);
        *hFontNormal = CreateFontIndirect (&lf);

        lf.lfWeight = FW_BOLD;
        *hFontBold = CreateFontIndirect (&lf);

        lf.lfWeight = FW_NORMAL;
        lf.lfUnderline = 1;
        *hFontUnderlined = CreateFontIndirect (&lf);

        SelectObject (hdc, *hFontNormal);
        GetTextExtentPoint32 (hdc, g_HangingIndentString, TcharCount (g_HangingIndentString), &Extent);
        g_HangingIndentPixels = Extent.cx;

        if (GetACP() == 932) {
            g_FarEastFudgeFactor = ptm->tmAveCharWidth;
        } else {
            g_FarEastFudgeFactor = 0;
        }

    }
}

INT
pComputeCharBytes (
    IN      CHARTYPE Char
    )
{
    if ((WORD) Char > 255) {
        return 2;
    }
    return 1;
}


typedef struct {
    BOOL InListItem;
    INT InUnorderedList;
    BOOL NextLineBlank;
    BOOL LastWasBlankLine;
} PARSESTATE, *PPARSESTATE;

PCTSTR
pFindFirstCharThatDoesNotFit (
    IN      INT Margin,
    IN      PGROWLIST ListPtr,
    IN      PGROWBUFFER AttribsList,
    IN      HASHTABLE BookmarkTable,
    IN      HWND hwnd,
    IN      HFONT hFontNormal,
    IN      HFONT hFontBold,
    IN      HFONT hFontUnderlined,
    IN      PCTSTR p,
    IN      INT x,
    OUT     PTEXTMETRIC ptm,
    OUT     PRECT prect,
    IN OUT  PLINEATTRIBS LineAttribs,
    IN OUT  PPARSESTATE ParseState
    )
{
    HDC hdc;
    PCTSTR endOfLine;
    PCTSTR wordWrapBreakPos;
    PCTSTR q;
    PCTSTR Arg;
    CHARTYPE Char, Command;
    SIZE Extent;
    UINT Size;
    PLINEATTRIBS PrevLineAttribs;
    SCROLLINFO si;
    PCTSTR FirstChar;
    PTSTR CommandBuf;
    PTSTR AnchorKey;
    PTSTR AnchorVal;
    UINT Count;
    INT ScrollBarPixels;
    BOOL PrevCharMb = FALSE;
    BOOL printableFound = FALSE;
    BOOL newLine;
    BOOL lastWasBlankLine;
    TCHAR oneChar;
    UINT prevCommand = 0;

    if (ParseState->NextLineBlank) {
        ParseState->LastWasBlankLine = TRUE;
        ParseState->NextLineBlank = FALSE;

        return p;
    }

    lastWasBlankLine = ParseState->LastWasBlankLine;
    ParseState->LastWasBlankLine = FALSE;

    //
    // Get display DC and initialize metrics
    //

    hdc = CreateDC (TEXT("display"), NULL, NULL, NULL);
    ParseState->NextLineBlank = FALSE;

    //
    // Select font of previous line
    //

    Size = GrowListGetSize (ListPtr);

    if (!Size) {
        if (hdc) {
            SelectObject (hdc, hFontNormal);
        }
        LineAttribs->LastCharAttribs = ATTRIB_NORMAL;
    } else {
        PrevLineAttribs = (PLINEATTRIBS) AttribsList->Buf + (Size - 1);
        LineAttribs->LastCharAttribs = PrevLineAttribs->LastCharAttribs;

        if (hdc) {
            if (PrevLineAttribs->LastCharAttribs == ATTRIB_BOLD) {
                SelectObject (hdc, hFontBold);
            } else if (PrevLineAttribs->LastCharAttribs == ATTRIB_UNDERLINED) {
                SelectObject (hdc, hFontUnderlined);
            } else {
                SelectObject (hdc, hFontNormal);
            }
        }
    }

    //
    // Get metrics
    //

    ZeroMemory (&si, sizeof (si));
    si.cbSize = sizeof (si);
    si.fMask = SIF_ALL;
    GetScrollInfo (hwnd, SB_VERT, &si);

    GetTextMetrics (hdc, ptm);
    GetClientRect (hwnd, prect);

    //
    // Account for scroll bar and right margin if scroll bar is
    // not yet visible
    //

    if (si.nMax < (INT) si.nPage || !si.nPage) {
        ScrollBarPixels = GetSystemMetrics (SM_CXVSCROLL);
        if (prect->right - prect->left > ScrollBarPixels * 2) {
            prect->right -= ScrollBarPixels;
        }
    }

    if (prect->right - prect->left > Margin * 2) {
        prect->right -= Margin;
    }

    //
    // Adjust if this is a far east system, because GetTextExtent doesn't
    // return the correct number of pixels.
    //

    prect->right -= g_FarEastFudgeFactor;

    //
    // Count characters until line is completely processed
    //

    MYASSERT (!_istspace (_tcsnextc (p)));

    FirstChar = p;
    endOfLine = p;
    wordWrapBreakPos = NULL;

    while (p && (INT) x < prect->right) {
        q = pGetHtmlCommandOrChar (
                p,                                  // current string position
                &Command,
                &Char,
                &CommandBuf
                );

        if (prevCommand == COMMAND_UNINDENT &&
            Command != COMMAND_UNINDENT &&
            Command != COMMAND_INDENT &&
            (Command != COMMAND_WHITESPACE || printableFound) &&
            Command != COMMAND_LINE_BREAK &&
            Command != COMMAND_PARAGRAPH &&
            !ParseState->InUnorderedList &&
            !lastWasBlankLine
            ) {

            Command = COMMAND_LINE_BREAK;
            q = p;
            Char = 0;
        }

        if (!Char) {

            if (q != p) {
                if (prevCommand == COMMAND_UNINDENT &&
                    Command == COMMAND_INDENT &&
                    !ParseState->InUnorderedList &&
                    !lastWasBlankLine
                    ) {

                    Command = COMMAND_LINE_BREAK;
                    q = p;

                } else if (ParseState->InListItem) {

                    MYASSERT (ParseState->InUnorderedList);

                    switch (Command) {

                    case COMMAND_PARAGRAPH:
                    case COMMAND_LINE_BREAK:
                    case COMMAND_UNINDENT:
                    case COMMAND_LIST_ITEM:
                        //
                        // Terminate the list item
                        //

                        Command = COMMAND_LIST_ITEM_END;
                        q = p;
                        break;
                    }

                } else if (Command == COMMAND_INDENT) {

                    //
                    // Before indenting, start a new line
                    //

                    if (printableFound) {
                        Command = COMMAND_LINE_BREAK;
                        q = p;
                    }

                } else if (Command == COMMAND_UNINDENT) {
                    //
                    // Before unindenting, complete the current line
                    //

                    if (printableFound) {
                        Command = COMMAND_LINE_BREAK;
                        q = p;
                    }
                }
            }

            //
            // Process tag
            //

            newLine = FALSE;

            switch (Command) {
            case 0:
                break;

            case COMMAND_BOLD:
                if (hdc) {
                    SelectObject (hdc, hFontBold);
                }
                LineAttribs->LastCharAttribs = ATTRIB_BOLD;
                break;

            case COMMAND_UNDERLINE:
                if (hdc) {
                    SelectObject (hdc, hFontUnderlined);
                }
                LineAttribs->LastCharAttribs = ATTRIB_UNDERLINED;
                break;

            case COMMAND_PARAGRAPH:
                ParseState->NextLineBlank = TRUE;
                newLine = TRUE;
                break;

            case COMMAND_LINE_BREAK:
            case COMMAND_HORZ_RULE:
                newLine = TRUE;
                break;

            case COMMAND_INDENT:
                ParseState->InUnorderedList += 1;

                if ((INT) (LineAttribs->Indent) < ptm->tmHeight * 20) {
                    LineAttribs->Indent += ptm->tmHeight * 2;
                    x += ptm->tmHeight * 2;
                }
                break;

            case COMMAND_LIST_ITEM:
                if (ParseState->InUnorderedList) {
                    LineAttribs->HangingIndent += g_HangingIndentPixels;
                    ParseState->InListItem = TRUE;
                }
                break;

            case COMMAND_LIST_ITEM_END:
                if (ParseState->InUnorderedList) {
                    LineAttribs->HangingIndent -= g_HangingIndentPixels;
                    ParseState->InListItem = FALSE;
                    newLine = TRUE;
                }

                break;

            case COMMAND_UNINDENT:
                if (ParseState->InUnorderedList) {
                    MYASSERT (!(ParseState->InListItem));

                    ParseState->InUnorderedList -= 1;

                    if ((INT) (LineAttribs->Indent) > ptm->tmHeight * 2) {
                        LineAttribs->Indent -= ptm->tmHeight * 2;
                        x -= ptm->tmHeight * 2;
                    }

                    //if (!lastWasBlankLine || printableFound) {
                    //    newLine = TRUE;
                    //}
                }
                break;

            case COMMAND_ANCHOR:
                if (CommandBuf) {
                    Arg = CommandBuf;

                    while (*Arg) {
                        //
                        // Search for a NAME arg
                        //

                        Count = TcharCount (Arg);
                        AnchorKey = AllocText (Count);
                        AnchorVal = AllocText (Count);

                        if (!AnchorKey || !AnchorVal) {
                            FreeText (AnchorKey);
                            FreeText (AnchorVal);
                            break;
                        }

                        pGetHtmlKeyAndValue (Arg, AnchorKey, AnchorVal);

                        if (StringIMatch (TEXT("NAME"), AnchorKey)) {

                            HtAddStringAndData (BookmarkTable, AnchorVal, &Size);

                        } else if (StringIMatch (TEXT("HREF"), AnchorKey)) {
                            LineAttribs->AnchorWrap = TRUE;
                        }

                        FreeText (AnchorKey);
                        FreeText (AnchorVal);

                        Arg += Count + 1;
                    }
                }

                break;

            case COMMAND_ANCHOR_END:
                LineAttribs->AnchorWrap = FALSE;
                break;

            case COMMAND_BOLD_END:
            case COMMAND_UNDERLINE_END:
                if (hdc) {
                    SelectObject (hdc, hFontNormal);
                }
                LineAttribs->LastCharAttribs = ATTRIB_NORMAL;
                break;
            }

            FreePathString (CommandBuf);

            prevCommand = Command;

            if (newLine) {
                if (q) {
                    endOfLine = q;
                } else {
                    endOfLine = GetEndOfString (p);
                }

                wordWrapBreakPos = NULL;
                break;
            }

        } else {
            //
            // Char is non-zero, so display it
            //

            if (printableFound || Command != COMMAND_WHITESPACE) {

                printableFound = TRUE;
                prevCommand = Command;

                if (Command) {
                    oneChar = (TCHAR) Char;
                    GetTextExtentPoint32 (hdc, &oneChar, 1, &Extent);
                } else {
                    GetTextExtentPoint32 (hdc, p, pComputeCharBytes (Char), &Extent);
                }
                x += Extent.cx;

                if (_istspace (Char)) {
                    wordWrapBreakPos = q;
                } else if (IsLeadByte (*q)) {
                    if (PrevCharMb && !IsPunct (_tcsnextc (q))) {
                        wordWrapBreakPos = q;
                    }
                    PrevCharMb = TRUE;
                } else {
                    PrevCharMb = FALSE;
                }
            }
        }

        if (q) {
            endOfLine = q;
        } else {
            endOfLine = GetEndOfString (endOfLine);
            wordWrapBreakPos = NULL;
        }

        p = q;
    }

    DeleteDC (hdc);

    if (wordWrapBreakPos) {
        return wordWrapBreakPos;
    }

    return endOfLine;
}


VOID
pRegisterHotLink (
    IN      PGROWBUFFER HotLinkArray,
    IN      PRECT HotRect,
    IN      PCTSTR UrlLink,
    IN      PCTSTR BookmarkLink
    )
{
    PHOTLINK HotLink;

    HotLink = (PHOTLINK) GrowBuffer (HotLinkArray, sizeof (HOTLINK));
    if (!HotLink) {
        return;
    }

    HotLink->Rect = *HotRect;

    if (UrlLink) {
        StringCopy (HotLink->Url, UrlLink);
    } else {
        HotLink->Url[0] = 0;
    }

    if (BookmarkLink) {
        StringCopy (HotLink->Bookmark, BookmarkLink);
    } else {
        HotLink->Bookmark[0] = 0;
    }
}


PHOTLINK
pFindHotLink (
    IN      PGROWBUFFER HotLinkArray,
    IN      UINT x,
    IN      UINT y
    )
{
    PHOTLINK HotLink;
    UINT u;

    HotLink = (PHOTLINK) HotLinkArray->Buf;

    for (u = 0 ; u < HotLinkArray->End ; u += sizeof (HOTLINK)) {
        if (x >= (UINT) HotLink->Rect.left && x < (UINT) HotLink->Rect.right &&
            y >= (UINT) HotLink->Rect.top && y < (UINT) HotLink->Rect.bottom
            ) {
            break;
        }

        HotLink++;
    }

    if (u >= HotLinkArray->End) {
        HotLink = NULL;
    }

    return HotLink;
}

BOOL
pLaunchedAddRemovePrograms (
    IN      PCTSTR CmdLine
    )
{
    return CmdLine && _tcsstr (CmdLine, TEXT("appwiz.cpl"));
}


typedef struct {
    HASHTABLE BookmarkTable;
    UINT LineHeight;
    HFONT hFont;
    HFONT hFontNormal;
    HFONT hFontBold;
    HFONT hFontUnderlined;
    GROWLIST List;
    GROWBUFFER AttribsList;
    GROWBUFFER HotLinkArray;
    BOOL UrlEnabled;
    INT Margin;
    PARSESTATE ParseState;
} TEXTVIEW_STATE, *PTEXTVIEW_STATE;

LRESULT
CALLBACK
TextViewProc (
    HWND hwnd,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    PAINTSTRUCT ps;
    HDC hdc;
    TEXTMETRIC tm;
    SCROLLINFO si;
    RECT rect;
    RECT FillRect;
    UINT Pos;
    UINT End;
    INT x, y;
    INT i;
    PCTSTR TrueStart, Start, Last;
    PCTSTR p, q;
    UINT Tchars;
    CHARTYPE Char, Command;
    UINT PrevHangingIndent;
    SIZE Extent;
    PLINEATTRIBS LineAttribs;
    PLINEATTRIBS PrevLineAttribs;
    HPEN OldPen;
    HBRUSH FillBrush;
    HPEN ShadowPen;
    HPEN HighlightPen;
    PTEXTVIEW_STATE s;
    UINT LineHeight;
    PHOTLINK HotLink;
    BOOL Hot;
    RECT HotRect;
    PCTSTR UrlLink;
    PCTSTR BookmarkLink;
    PTSTR CommandBuf;
    PCTSTR Arg;
    TCHAR Href[MAX_URL];
    PTSTR AnchorKey;
    PTSTR AnchorVal;
    UINT Count;
    HKEY TempKey;
    DWORD GrowListSize;
    PCTSTR ShellArgs;
    LONG l;
    BOOL b;
    PTSTR text;
    UINT textSize;
    BOOL printableFound;
    TCHAR oneChar;

    s = (PTEXTVIEW_STATE) GetWindowLong (hwnd, GWL_USERDATA);
    if (s) {
        LineHeight = s->LineHeight;
    } else {
        LineHeight = 0;
    }

    switch (uMsg) {

    case WM_CREATE:
        for (i = 0 ; g_TagList[i].Text ; i++) {
            g_TagList[i].TextLen = TcharCount (g_TagList[i].Text);
        }

        s = (PTEXTVIEW_STATE) MemAlloc (g_hHeap, HEAP_ZERO_MEMORY, sizeof (TEXTVIEW_STATE));
        SetWindowLong (hwnd, GWL_USERDATA, (LONG) s);

        TempKey = OpenRegKeyStr (TEXT("HKCR\\.URL"));
        if (TempKey) {
            CloseRegKey (TempKey);
        }

        s->UrlEnabled = (TempKey != NULL);

        ZeroMemory (&si, sizeof (si));
        si.fMask = SIF_RANGE;

        s->BookmarkTable = HtAllocWithData (sizeof (DWORD));
        if (!s->BookmarkTable) {
            return -1;
        }

        // WM_SETFONT does a bunch of work, including populating the text
        SendMessage (
            hwnd,
            WM_SETFONT,
            SendMessage (GetParent (hwnd), WM_GETFONT, 0, 0),
            0
            );

        return 0;

    case WM_GETDLGCODE:
        return DLGC_WANTARROWS;

    case WMX_GOTO:
        //
        // Determine if text is in bookmark table
        //

        if (!lParam) {
            return 0;
        }

        if (HtFindStringAndData (s->BookmarkTable, (PCTSTR) lParam, &Pos)) {

            PostMessage (
                hwnd,
                WM_VSCROLL,
                MAKELPARAM (SB_THUMBPOSITION, (WORD) Pos),
                (LPARAM) hwnd
                );

        }

        return 0;


    case WMX_ADDLINE:
        //
        // Init
        //

        l = GetWindowLong (hwnd, GWL_STYLE) & WS_BORDER;
        if (!l) {
            l = GetWindowLong (hwnd, GWL_EXSTYLE) & (WS_EX_DLGMODALFRAME|WS_EX_WINDOWEDGE|WS_EX_CLIENTEDGE|WS_EX_STATICEDGE);
        }

        if (!s->Margin && l) {
            s->Margin = s->LineHeight / 2;
        }

        Start = (PCTSTR) lParam;

        // ignore leading space
        TrueStart = Start;

        while (_istspace (_tcsnextc (Start))) {
            Start = _tcsinc (Start);
        }

        PrevLineAttribs = NULL;
        if (s->AttribsList.End) {
            MYASSERT (s->AttribsList.End >= sizeof (LINEATTRIBS));
            PrevLineAttribs = (PLINEATTRIBS) (s->AttribsList.Buf +
                                              s->AttribsList.End -
                                              sizeof (LINEATTRIBS)
                                              );
        }

        //
        // Copy line attributes (optional) to our Attribs list; ignore errors.
        //

        LineAttribs = (PLINEATTRIBS) GrowBuffer (&s->AttribsList, sizeof (LINEATTRIBS));
        if (!LineAttribs) {
            return 0;
        }

        //
        // Copy previous line's attributes
        //

        ZeroMemory (LineAttribs, sizeof (LINEATTRIBS));

        if (PrevLineAttribs) {
            LineAttribs->AnchorWrap    = PrevLineAttribs->AnchorWrap;
            LineAttribs->Indent        = PrevLineAttribs->Indent;
            LineAttribs->HangingIndent = PrevLineAttribs->HangingIndent;
            PrevHangingIndent = PrevLineAttribs->HangingIndent;
        } else {
            LineAttribs->Indent = s->Margin;
            LineAttribs->HangingIndent = 0;
            PrevHangingIndent = 0;
        }

        x = LineAttribs->Indent + PrevHangingIndent;

        //
        // Find the first character that does not fit on the line
        //

        Last = pFindFirstCharThatDoesNotFit (
                    s->Margin,
                    &s->List,
                    &s->AttribsList,
                    s->BookmarkTable,
                    hwnd,
                    s->hFontNormal,
                    s->hFontBold,
                    s->hFontUnderlined,
                    Start,
                    (INT) x,
                    &tm,
                    &rect,
                    LineAttribs,
                    &s->ParseState
                    );

        //
        // Update the vertical scroll bar
        //

        MYASSERT (LineHeight);

        ZeroMemory (&si, sizeof (si));
        si.cbSize = sizeof (si);
        si.fMask = SIF_RANGE|SIF_PAGE;
        si.nMin = 0;
        si.nPage = rect.bottom / LineHeight;
        si.nMax = GrowListGetSize (&s->List);

        SetScrollInfo (hwnd, SB_VERT, &si, TRUE);

        //
        // Copy the string (or as much that is visible) to our
        // grow list
        //

        GrowListAppendStringAB (&s->List, Start, Last);

        //
        // Return the number of bytes copied
        //

        return Last - TrueStart;

    case WMX_ALL_LINES_PAINTED:
        //
        // Scan all the lines, returning 0 if at least one has Painted == FALSE
        //

        LineAttribs = (PLINEATTRIBS) s->AttribsList.Buf;
        if (!LineAttribs) {
            return 1;
        }

        for (Pos = 0 ; Pos < s->AttribsList.End ; Pos += sizeof (LINEATTRIBS)) {
            LineAttribs = (PLINEATTRIBS) (s->AttribsList.Buf + Pos);
            if (!LineAttribs->Painted) {
                return 0;
            }
        }

        return 1;

    case WM_ERASEBKGND:
        return 0;

    case WM_KEYDOWN:
        switch (wParam) {
        case VK_DOWN:
            PostMessage (hwnd, WM_VSCROLL, SB_LINEDOWN, 0);
            return 0;

        case VK_UP:
            PostMessage (hwnd, WM_VSCROLL, SB_LINEUP, 0);
            return 0;

        case VK_NEXT:
            PostMessage (hwnd, WM_VSCROLL, SB_PAGEDOWN, 0);
            return 0;

        case VK_PRIOR:
            PostMessage (hwnd, WM_VSCROLL, SB_PAGEUP, 0);
            return 0;

        case VK_HOME:
            PostMessage (hwnd, WM_VSCROLL, SB_TOP, 0);
            return 0;

        case VK_END:
            PostMessage (hwnd, WM_VSCROLL, SB_BOTTOM, 0);
            return 0;
        }

        break;


    case WM_SETFONT:
        s->hFont = (HFONT) wParam;

        if (s->hFontNormal) {
            DeleteObject (s->hFontNormal);
            s->hFontNormal = NULL;
        }

        if (s->hFontBold) {
            DeleteObject (s->hFontBold);
            s->hFontBold = NULL;
        }

        if (s->hFontUnderlined) {
            DeleteObject (s->hFontUnderlined);
            s->hFontUnderlined = NULL;
        }

        hdc = CreateDC (TEXT("display"), NULL, NULL, NULL);
        if (hdc) {
            pCreateFontsIfNecessary (hdc, s->hFont, &tm, &s->hFontNormal, &s->hFontBold, &s->hFontUnderlined);
            s->LineHeight = tm.tmHeight;

            DeleteDC (hdc);
        } else {
            s->LineHeight = 0;
        }

        if (lParam) {
            InvalidateRect (hwnd, NULL, FALSE);
        }

        if (s->AttribsList.End == 0) {
            textSize = GetWindowTextLength (hwnd);
            text = (PTSTR) MemAllocUninit ((textSize + 1) * sizeof (TCHAR));
            GetWindowText (hwnd, text, textSize + 1);
            AddStringToTextView (hwnd, text);
            FreeMem (text);
        }

        return 0;


    case WM_MOUSEMOVE:
        //
        // Search array of hit test rectangles
        //

        x = LOWORD(lParam);
        y = HIWORD(lParam);

        HotLink = pFindHotLink (&s->HotLinkArray, x, y);

        if (HotLink) {
            SetCursor (LoadCursor (g_hInst, MAKEINTRESOURCE (IDC_OUR_HAND)));
        } else {
            SetCursor (LoadCursor (NULL, MAKEINTRESOURCE (IDC_ARROW)));
        }

        break;

    case WM_LBUTTONDOWN:
        //
        // Search array of hit test rectangles
        //

        x = LOWORD(lParam);
        y = HIWORD(lParam);

        HotLink = pFindHotLink (&s->HotLinkArray, x, y);

        if (HotLink) {
            if (HotLink->Url[0]) {
                if (!StringIMatchCharCount (TEXT("file:"), HotLink->Url, 5)) {
                    ShellExecute (hwnd, TEXT("open"), HotLink->Url, NULL, NULL, 0);
                } else {
                    ShellArgs = &HotLink->Url[5];
                    if (*ShellArgs == TEXT('/')) {
                        ShellArgs++;
                    }
                    if (*ShellArgs == TEXT('/')) {
                        ShellArgs++;
                    }

                    ShellArgs = ExtractArgZero (ShellArgs, Href);
                    //
                    // if we're launching the Add/Remove programs applet,
                    // warn users they'll have to restart setup (RAID # 293357)
                    //
                    b = TRUE;
                    if (!UNATTENDED() &&
                        !REPORTONLY() &&
                        !g_UIQuitSetup &&
                        pLaunchedAddRemovePrograms (ShellArgs)
                        ) {
                        if (IDYES == ResourceMessageBox (
                                        hwnd,
                                        MSG_RESTART_IF_CONTINUE_APPWIZCPL,
                                        MB_YESNO | MB_ICONQUESTION,
                                        NULL
                                        )) {
                            LOG ((LOG_INFORMATION, "User launched Add/Remove Programs applet; setup will terminate"));
                            PostMessage (GetParent (hwnd), WMX_RESTART_SETUP, FALSE, TRUE);
                        } else {
                            b = FALSE;
                        }
                    }
                    if (b) {
                        ShellExecute (hwnd, TEXT("open"), Href, ShellArgs, NULL, 0);
                    }
                }
            } else if (HotLink->Bookmark) {
                SendMessage (hwnd, WMX_GOTO, 0, (LPARAM) HotLink->Bookmark);
            }
        }

        break;

    case WM_SETTEXT:
        SendMessage (hwnd, WMX_CLEANUP, 0, 0);
        DefWindowProc (hwnd, uMsg, wParam, lParam);
        SendMessage (hwnd, WM_CREATE, 0, 0);
        return 0;

    case WM_PAINT:
        FillBrush = CreateSolidBrush (GetSysColor (COLOR_BTNFACE));
        ShadowPen = CreatePen (PS_SOLID, 1, GetSysColor (COLOR_3DSHADOW));
        HighlightPen = CreatePen (PS_SOLID, 1, GetSysColor (COLOR_3DHILIGHT));

        hdc = BeginPaint (hwnd, &ps);
        pCreateFontsIfNecessary (hdc, s->hFont, &tm, &s->hFontNormal, &s->hFontBold, &s->hFontUnderlined);
        s->LineHeight = LineHeight = tm.tmHeight;
        GetClientRect (hwnd, &rect);

        //
        // Select colors
        //

        SetBkColor (hdc, GetSysColor (COLOR_BTNFACE));
        SetTextColor (hdc, GetSysColor (COLOR_WINDOWTEXT));

        if (FillBrush) {
            SelectObject (hdc, FillBrush);
        }

        SelectObject (hdc, GetStockObject (NULL_PEN));

        //
        // Get scroll position
        //

        ZeroMemory (&si, sizeof (si));
        si.cbSize = sizeof (si);
        si.fMask = SIF_PAGE|SIF_POS;
        GetScrollInfo (hwnd, SB_VERT, &si);

        End = (UINT) si.nPos + si.nPage + 1;
        GrowListSize = GrowListGetSize (&s->List);
        End = min (End, GrowListSize);
        y = 0;

        //
        // Select font of previous line.  Move up if anchor wrap is on.
        //

        if (si.nPos) {
            do {
                LineAttribs = (PLINEATTRIBS) s->AttribsList.Buf + (si.nPos - 1);
                if (LineAttribs->AnchorWrap) {
                    si.nPos--;
                    y -= LineHeight;
                } else {
                    break;
                }
            } while (si.nPos > 0);
        }

        if (si.nPos) {
            LineAttribs = (PLINEATTRIBS) s->AttribsList.Buf + (si.nPos - 1);

            if (LineAttribs->LastCharAttribs == ATTRIB_BOLD) {
                SelectObject (hdc, s->hFontBold);
            } else if (LineAttribs->LastCharAttribs == ATTRIB_UNDERLINED) {
                SelectObject (hdc, s->hFontUnderlined);
            } else {
                SelectObject (hdc, s->hFontNormal);
            }
        } else {
            SelectObject (hdc, s->hFontNormal);
        }

        //
        // Paint!
        //

        Hot = FALSE;
        s->HotLinkArray.End = 0;
        BookmarkLink = UrlLink = NULL;

        for (Pos = (UINT) si.nPos ; Pos < End ; Pos++) {
            p = GrowListGetString (&s->List, Pos);
            printableFound = FALSE;

            LineAttribs = (PLINEATTRIBS) s->AttribsList.Buf + Pos;

            //
            // Compute hanging indent using previous line
            //

            if (Pos > 0) {
                PrevLineAttribs = (PLINEATTRIBS) ((PLINEATTRIBS) s->AttribsList.Buf + Pos - 1);
                PrevHangingIndent = PrevLineAttribs->HangingIndent;
            } else {
                PrevHangingIndent = 0;
            }

            //
            // Compute starting index
            //

            if (LineAttribs) {
                x = LineAttribs->Indent + PrevHangingIndent;
                LineAttribs->Painted = TRUE;
            } else {
                x = s->Margin;
            }

            //
            // Compute blank area
            //

            if (x > 0) {
                FillRect.left = 0;
                FillRect.right = x;
                FillRect.top = y;
                FillRect.bottom = y + LineHeight;

                Rectangle (hdc, FillRect.left, FillRect.top, FillRect.right + 1, FillRect.bottom + 1);
            }

            //
            // Multiline hotlink
            //

            if (Hot) {
                HotRect.left = x;
                HotRect.top = y;
            }

            //
            // Compute text block
            //

            Start = p;

            while (p) {
                q = pGetHtmlCommandOrChar (p, &Command, &Char, &CommandBuf);

                if (!Char || Command == COMMAND_WHITESPACE || Command == COMMAND_ESCAPED_CHAR) {
                    //
                    // If this is the end of of a block of text, paint it.
                    //

                    MYASSERT (Start);

                    Tchars = p - Start;

                    if (Tchars) {
                        TextOut (hdc, x, y, Start, Tchars);
                        GetTextExtentPoint32 (hdc, Start, Tchars, &Extent);

                        x += Extent.cx;
                        if (x > rect.right) {
                            break;
                        }
                    }

                    Start = q;
                    oneChar = 0;

                    if (printableFound && Command == COMMAND_WHITESPACE) {
                        oneChar = TEXT(' ');
                    } else if (Command == COMMAND_ESCAPED_CHAR) {
                        oneChar = (TCHAR) Char;
                    }

                    if (oneChar) {

                        TextOut (hdc, x, y, &oneChar, 1);
                        GetTextExtentPoint32 (hdc, &oneChar, 1, &Extent);

                        x += Extent.cx;
                        if (x > rect.right) {
                            break;
                        }
                    }

                } else {
                    printableFound = TRUE;
                }

                switch (Command) {
                case 0:
                case COMMAND_WHITESPACE:
                case COMMAND_ESCAPED_CHAR:
                    break;

                case COMMAND_ANCHOR:
                    //
                    // Does this anchor have an HREF?
                    //

                    if (CommandBuf) {
                        Arg = CommandBuf;

                        Href[0] = 0;

                        while (Href[0] == 0 && *Arg) {
                            //
                            // Search for a HREF arg
                            //

                            Count = TcharCount (Arg);
                            AnchorKey = AllocText (Count);
                            AnchorVal = AllocText (Count);

                            if (!AnchorKey || !AnchorVal) {
                                FreeText (AnchorKey);
                                FreeText (AnchorVal);
                                break;
                            }

                            pGetHtmlKeyAndValue (Arg, AnchorKey, AnchorVal);

                            if (StringIMatch (TEXT("HREF"), AnchorKey)) {
                                _tcssafecpy (Href, AnchorVal, MAX_URL);
                            }

                            FreeText (AnchorKey);
                            FreeText (AnchorVal);

                            Arg += Count + 1;
                        }

                        if (Href[0]) {
                            //
                            // Does HREF point to a bookmark?
                            //

                            BookmarkLink = UrlLink = NULL;

                            if (_tcsnextc (Href) == TEXT('#')) {
                                BookmarkLink = SkipSpace (_tcsinc (Href));
                            } else {
                                if (s->UrlEnabled) {
                                    UrlLink = Href;
                                }
                            }

                            //
                            // If either BookmarkLink or Url is non-NULL, then turn on
                            // link font and color
                            //

                            if (BookmarkLink || UrlLink) {
                                HotRect.left = x;
                                HotRect.top = y;
                                Hot = TRUE;

                                SelectObject (hdc, s->hFontUnderlined);
                                SetTextColor (hdc, GetSysColor (COLOR_HIGHLIGHT));
                            }
                        }
                    }

                    break;

                case COMMAND_BOLD:
                    SelectObject (hdc, s->hFontBold);
                    break;

                case COMMAND_UNDERLINE:
                    SelectObject (hdc, s->hFontUnderlined);
                    break;

                case COMMAND_HORZ_RULE:
                    FillRect.left = rect.left;
                    FillRect.right = rect.right;
                    FillRect.top = y;
                    FillRect.bottom = y + LineHeight;

                    Rectangle (hdc, FillRect.left, FillRect.top, FillRect.right + 1, FillRect.bottom + 1);

                    OldPen = (HPEN) SelectObject (hdc, ShadowPen);
                    MoveToEx (hdc, rect.left + 3, y + LineHeight / 2, NULL);
                    LineTo (hdc, rect.right - 3, y + LineHeight / 2);
                    SelectObject (hdc, HighlightPen);
                    MoveToEx (hdc, rect.left + 3, y + LineHeight / 2 + 1, NULL);
                    LineTo (hdc, rect.right - 3, y + LineHeight / 2 + 1);
                    SelectObject (hdc, OldPen);

                    x = rect.right;
                    break;

                case COMMAND_ANCHOR_END:
                    SelectObject (hdc, s->hFontNormal);
                    SetTextColor (hdc, GetSysColor (COLOR_WINDOWTEXT));

                    if (Hot) {
                        Hot = FALSE;
                        HotRect.right = x;
                        HotRect.bottom = y + LineHeight;

                        pRegisterHotLink (&s->HotLinkArray, &HotRect, UrlLink, BookmarkLink);
                    }
                    break;

                case COMMAND_BOLD_END:
                case COMMAND_UNDERLINE_END:
                    SelectObject (hdc, s->hFontNormal);
                    break;
                }

                FreePathString (CommandBuf);

                p = q;
            }

            //
            // Hot link that extends to multiple lines
            //

            if (Hot) {
                HotRect.right = x;
                HotRect.bottom = y + LineHeight;
                pRegisterHotLink (&s->HotLinkArray, &HotRect, UrlLink, BookmarkLink);
            }

            //
            // Fill blank area to end of line
            //

            if (x < rect.right) {
                FillRect.left = x;
                FillRect.right = rect.right;
                FillRect.top = y;
                FillRect.bottom = y + LineHeight;

                Rectangle (hdc, FillRect.left, FillRect.top, FillRect.right + 1, FillRect.bottom + 1);
            }

            y += LineHeight;
        }

        //
        // Fill blank area to bottom of window
        //

        if (y < rect.bottom) {
             FillRect.left = 0;
             FillRect.right = rect.right;
             FillRect.top = y;
             FillRect.bottom = rect.bottom;

             Rectangle (hdc, FillRect.left, FillRect.top, FillRect.right + 1, FillRect.bottom + 1);
        }

        //
        // Cleanup
        //

        if (FillBrush) {
            DeleteObject (FillBrush);
        }

        if (ShadowPen) {
            DeleteObject (ShadowPen);
            ShadowPen = NULL;
        }

        if (HighlightPen) {
            DeleteObject (HighlightPen);
            HighlightPen = NULL;
        }

        EndPaint (hwnd, &ps);
        return 0;

    case WM_VSCROLL:
        Pos = HIWORD (wParam);

        ZeroMemory (&si, sizeof (si));
        si.cbSize = sizeof (si);
        si.fMask = SIF_ALL;
        GetScrollInfo (hwnd, SB_VERT, &si);
        i = si.nMax - (INT) si.nPage + 1;

        si.fMask = 0;

        switch (LOWORD (wParam)) {
        case SB_PAGEDOWN:
            if (si.nPos + (INT) si.nPage < i) {
                si.nPos += si.nPage;
                ScrollWindow (hwnd, 0, -((INT) LineHeight * (INT) si.nPage), NULL, NULL);
                si.fMask = SIF_POS;
                break;
            }

            // fall through!

        case SB_BOTTOM:
            if (si.nPos < i) {
                InvalidateRect (hwnd, NULL, FALSE);
                si.nPos = i;
                si.fMask = SIF_POS;
            }
            break;

        case SB_LINEDOWN:
            if (si.nPos < i) {
                si.nPos += 1;
                ScrollWindow (hwnd, 0, -((INT) LineHeight), NULL, NULL);
                si.fMask = SIF_POS;
            }

            break;

        case SB_LINEUP:
            if (si.nPos > si.nMin) {
                si.nPos -= 1;
                ScrollWindow (hwnd, 0, (INT) LineHeight, NULL, NULL);
                si.fMask = SIF_POS;
            }

            break;

        case SB_THUMBTRACK:
        case SB_THUMBPOSITION:
            if ((INT) Pos != si.nPos) {
                InvalidateRect (hwnd, NULL, FALSE);
                si.nPos = (INT) Pos;
                si.fMask = SIF_POS;
            }
            break;

        case SB_PAGEUP:
            if (si.nPos >= si.nMin + (INT) si.nPage) {
                si.nPos -= si.nPage;
                ScrollWindow (hwnd, 0, (INT) LineHeight * si.nPage, NULL, NULL);
                si.fMask = SIF_POS;
                break;
            }

            // fall through

        case SB_TOP:
            if (si.nPos > si.nMin) {
                ScrollWindow (hwnd, 0, (INT) LineHeight * si.nPos, NULL, NULL);
                si.nPos = si.nMin;
                si.fMask = SIF_POS;
            }
            break;
        }

        if (si.fMask) {
            SetScrollInfo (hwnd, SB_VERT, &si, TRUE);
        }
        break;

    case WM_DESTROY:
    case WMX_CLEANUP:
        if (!g_Terminated) {
            if (s) {
                if (s->hFontNormal) {
                    DeleteObject (s->hFontNormal);
                    s->hFontNormal = NULL;
                }

                if (s->hFontBold) {
                    DeleteObject (s->hFontBold);
                    s->hFontBold = NULL;
                }

                if (s->hFontUnderlined) {
                    DeleteObject (s->hFontUnderlined);
                    s->hFontUnderlined = NULL;
                }

                FreeGrowBuffer (&s->AttribsList);
                FreeGrowBuffer (&s->HotLinkArray);
                FreeGrowList (&s->List);

                if (s->BookmarkTable) {
                    HtFree (s->BookmarkTable);
                    s->BookmarkTable = NULL;
                }

                MemFree (g_hHeap, 0, s);
                SetWindowLong (hwnd, GWL_USERDATA, 0);
            }
        }
        break;

    }

    return DefWindowProc (hwnd, uMsg, wParam, lParam);
}


VOID
RegisterTextViewer (
    VOID
    )
{
    static WNDCLASS wc;

    if (!wc.lpfnWndProc) {
        wc.lpfnWndProc = TextViewProc;
        wc.hInstance = g_hInst;
        wc.hCursor = NULL;
        wc.hbrBackground = (HBRUSH) COLOR_WINDOW;
        wc.lpszClassName = S_TEXTVIEW_CLASS;

        RegisterClass (&wc);

        //
        // We don't ever clean this up... and that's OK.
        //
    }
}



PCTSTR
AddLineToTextView (
    HWND hwnd,
    PCTSTR Text
    )
{
    PCTSTR TextEnd;

    TextEnd = Text + SendMessage (hwnd, WMX_ADDLINE, 0, (LPARAM) Text);

    if (*TextEnd == 0) {
        return NULL;
    }

    return TextEnd;
}

VOID
AddStringToTextView (
    IN      HWND hwnd,
    IN      PCTSTR String
    )
{
    PCTSTR p;

    if (!hwnd) {
        return;
    }

    if (String && *String) {
        for (p = String ; p ; p = AddLineToTextView (hwnd, p)) {
            // empty
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\ui\wizdlg.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    wizdlg.c

Abstract:

    This module implements the dialog box procedures needed for the Win9x side
    of the upgrade.

Author:

    Jim Schmidt (jimschm) 17-Mar-1997

Revision History:

    jimschm     29-Sep-1998     Domain credentials dialog
    jimschm     24-Dec-1997     Added ChangeNameDlg functionality

--*/

#include "pch.h"
#include "uip.h"
#include <commdlg.h>

//
// Globals
//

HWND g_UiTextViewCtrl;

#define USER_NAME_SIZE  (MAX_USER_NAME + 1 + MAX_SERVER_NAME)

//
// Local function prototypes
//

VOID
AppendMigDllNameToList (
    IN      PCTSTR strName
    );


LONG
SearchForDrivers (
    IN      HWND Parent,
    IN      PCTSTR SearchPathStr,
    OUT     BOOL *DriversFound
    );

BOOL
CALLBACK
pChangeNameDlgProc (
    IN      HWND hdlg,
    IN      UINT uMsg,
    IN      WPARAM wParam,
    IN      LPARAM lParam
    );

BOOL
CALLBACK
pCredentialsDlgProc (
    IN      HWND hdlg,
    IN      UINT uMsg,
    IN      WPARAM wParam,
    IN      LPARAM lParam
    );


//
// Implementation
//


VOID
UI_InsertItemsIntoListCtrl (
    IN      HWND ListCtrl,
    IN      INT Item,
    IN      LPTSTR ItemStrs,            // tab-separated list
    IN      LPARAM lParam
    )

/*++

  This function is not used, but is useful and we should keep it around
  just in case a list control is used later.

Routine Description:

  Parses a string that has tab characters separating columns and inserts
  the string into a multiple column list control.

Arguments:

  ListCtrl  - Specifies the handle to the list control

  Item      - Specifies the position where the string is insert in the list

  ItemStrs  - Specifies a tab-delimited list of strings to be inserted.  The
              string is split at the tabs.  The tabs are temporarilty replaced
              with nuls but the string is not changed.

  lParam    - Specifies a value to associate with the list item.

Return Value:

  none

--*/

{
    LPTSTR Start, End;
    TCHAR tc;
    LV_ITEM item;
    int i;

    ZeroMemory (&item, sizeof (item));
    item.iItem = Item;
    item.lParam = lParam;

    Start = (LPTSTR) ItemStrs;
    i = 0;
    do  {
        End = _tcschr (Start, TEXT('\t'));
        if (!End)
            End = GetEndOfString (Start);

        tc = (TCHAR) _tcsnextc (End);
        *End = 0;

        item.iSubItem = i;
        i++;
        item.pszText = Start;
        if (i != 1) {
            item.mask = LVIF_TEXT;
            ListView_SetItem (ListCtrl, &item);
        }
        else {
            item.mask = LVIF_TEXT|LVIF_PARAM;
            Item = ListView_InsertItem (ListCtrl, &item);
            item.iItem = Item;
        }

        Start = _tcsinc (End);
        *End = tc;
    } while (tc);
}



//
// Warning dialog proc
//

BOOL
CALLBACK
WarningProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    switch (uMsg) {
    case WM_INITDIALOG:
        CenterWindow (hdlg, GetDesktopWindow());
        return FALSE;

    case WM_COMMAND:
        EndDialog (hdlg, LOWORD (wParam));
        break;
    }

    return FALSE;
}

LPARAM
WarningDlg (
    HWND Parent
    )
{
    return DialogBox (g_hInst, MAKEINTRESOURCE(IDD_CONSIDERING_DLG), Parent, WarningProc);
}

LPARAM
SoftBlockDlg (
    HWND Parent
    )
{
    return DialogBox (g_hInst, MAKEINTRESOURCE(IDD_APPBLOCK_DLG), Parent, WarningProc);
}


LPARAM
IncompatibleDevicesDlg (
    HWND Parent
    )
{
    return DialogBox (g_hInst, MAKEINTRESOURCE(IDD_INCOMPATIBLE_DEVICES), Parent, WarningProc);
}


BOOL
CALLBACK
DiskSpaceProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    BOOL dialogDone = FALSE;
    static PCTSTR message = NULL;

    switch (uMsg) {
    case WM_INITDIALOG:

        CenterWindow (hdlg, GetDesktopWindow());
        message = GetNotEnoughSpaceMessage ();
        SetWindowText (GetDlgItem (hdlg, IDC_SPACE_NEEDED), message);

        return FALSE;

    case WM_COMMAND:

        dialogDone = TRUE;
        break;
    }


    if (dialogDone) {
        //
        // free resources.
        //
        FreeStringResource (message);
        EndDialog (hdlg, LOWORD (wParam));
    }

    return FALSE;
}


LPARAM
DiskSpaceDlg (
    IN HWND Parent
    )
{
    return DialogBox (g_hInst, MAKEINTRESOURCE(IDD_DISKSPACE_DLG), Parent, DiskSpaceProc);

}




//
// Results dialog proc
//

#define IDC_TEXTVIEW    5101
#define WMX_FILL_TEXTVIEW       (WM_USER+512)


DWORD
WINAPI
pSearchForDrivers (
    PVOID Param
    )
{
    PSEARCHING_THREAD_DATA Data;
    BOOL b;

    Data = (PSEARCHING_THREAD_DATA) Param;

    Data->CancelEvent = CreateEvent (NULL, FALSE, FALSE, NULL);
    if (!Data->CancelEvent) {
        DEBUGMSG ((DBG_ERROR, "pSearchForMigrationDlls: Could not create cancel event"));
        return 0;
    }

    b = ScanPathForDrivers (
            Data->hdlg,
            Data->SearchStr,
            g_TempDir,
            Data->CancelEvent
            );

    PostMessage (Data->hdlg, WMX_THREAD_DONE, 0, GetLastError());
    Data->ActiveMatches = b ? 1 : 0;
    Data->MatchFound = b;

    return 0;
}


BOOL
CALLBACK
UpgradeModuleDlgProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    BROWSEINFO bi;
    REGVALUE_ENUM eValue;
    MIGDLL_ENUM e;
    RECT ListRect;
    LPITEMIDLIST ItemIdList;
    HKEY Key;
    HWND List;
    PCTSTR Data;
    TCHAR SearchPathStr[MAX_TCHAR_PATH];
    TCHAR Node[MEMDB_MAX];
    LONG Index;
    LONG TopIndex;
    LONG ItemData;
    UINT ActiveModulesFound;
    BOOL OneModuleFound;
    UINT Length;
    LONG rc;

    switch (uMsg) {
    case WM_INITDIALOG:
        SendMessage (hdlg, WMX_UPDATE_LIST, 0, 0);
        return FALSE;

    case WMX_UPDATE_LIST:
        //
        // Enumerate all migration DLLs and shove the program ID in list box
        //

        List = GetDlgItem (hdlg, IDC_LIST);
        SendMessage (List, LB_RESETCONTENT, 0, 0);
        EnableWindow (GetDlgItem (hdlg, IDC_REMOVE), FALSE);

        if (EnumFirstMigrationDll (&e)) {
            EnableWindow (List, TRUE);

            do {
                Index = SendMessage (List, LB_ADDSTRING, 0, (LPARAM) e.ProductId);
                SendMessage (List, LB_SETITEMDATA, Index, (LPARAM) e.Id);
            } while (EnumNextMigrationDll (&e));
        }

        //
        // Enumerate all migration DLLs pre-loaded in the registry, and add them
        // to the list box if they haven't been "removed" by the user
        //

        Key = OpenRegKeyStr (S_PREINSTALLED_MIGRATION_DLLS);
        if (Key) {
            if (EnumFirstRegValue (&eValue, Key)) {
                do {
                    //
                    // Suppressed?  If not, add to list.
                    //

                    MemDbBuildKey (
                        Node,
                        MEMDB_CATEGORY_DISABLED_MIGDLLS,
                        NULL,                                   // no item
                        NULL,                                   // no field
                        eValue.ValueName
                        );

                    if (!MemDbGetValue (Node, NULL)) {
                        Index = SendMessage (List, LB_ADDSTRING, 0, (LPARAM) eValue.ValueName);
                        SendMessage (List, LB_SETITEMDATA, Index, (LPARAM) REGISTRY_DLL);
                    }
                } while (EnumNextRegValue (&eValue));
            }

            CloseRegKey (Key);
        }

        if (SendMessage (List, LB_GETCOUNT, 0, 0) == 0) {
            EnableWindow (List, FALSE);
        }

        return TRUE;

    case WM_COMMAND:
        switch (LOWORD (wParam)) {
        case IDOK:
        case IDCANCEL:
            EndDialog (hdlg, IDOK);
            return TRUE;

        case IDC_LIST:
            if (HIWORD (wParam) == LBN_SELCHANGE) {
                EnableWindow (GetDlgItem (hdlg, IDC_REMOVE), TRUE);
            }
            break;

        case IDC_REMOVE:
            //
            // Delete item from internal memory structure
            // or keep registry-loaded DLL from running
            //

            List = GetDlgItem (hdlg, IDC_LIST);
            SendMessage (List, WM_SETREDRAW, FALSE, 0);

            Index = SendMessage (List, LB_GETCURSEL, 0, 0);
            MYASSERT (Index != LB_ERR);
            ItemData = (LONG) SendMessage (List, LB_GETITEMDATA, Index, 0);

            //
            // If ItemData is REGISTRY_DLL, then suppress the DLL.
            // Otherwise, delete loaded migration DLL
            //

            if (ItemData == REGISTRY_DLL) {
                Length = SendMessage (List, LB_GETTEXTLEN, Index, 0) + 1;
                Data = AllocText (Length);
                if (Data) {
                    SendMessage (List, LB_GETTEXT, Index, (LPARAM) Data);
                    MemDbSetValueEx (MEMDB_CATEGORY_DISABLED_MIGDLLS, NULL, NULL, Data, 0, NULL);
                    FreeText (Data);
                }
            } else {
                RemoveDllFromList (ItemData);
            }

            //
            // Update the list box
            //

            TopIndex = SendMessage (List, LB_GETTOPINDEX, 0, 0);
            SendMessage (hdlg, WMX_UPDATE_LIST, 0, 0);
            SendMessage (List, LB_SETTOPINDEX, (WPARAM) TopIndex, 0);

            //
            // Disable remove button
            //

            SetFocus (GetDlgItem (hdlg, IDC_HAVE_DISK));
            EnableWindow (GetDlgItem (hdlg, IDC_REMOVE), FALSE);

            //
            // Redraw list box
            //

            SendMessage (List, WM_SETREDRAW, TRUE, 0);
            GetWindowRect (List, &ListRect);
            ScreenToClient (hdlg, (LPPOINT) &ListRect);
            ScreenToClient (hdlg, ((LPPOINT) &ListRect) + 1);

            InvalidateRect (hdlg, &ListRect, FALSE);
            break;

        case IDC_HAVE_DISK:
            ZeroMemory (&bi, sizeof (bi));

            bi.hwndOwner = hdlg;
            bi.pszDisplayName = SearchPathStr;
            bi.lpszTitle = GetStringResource (MSG_UPGRADE_MODULE_DLG_TITLE);
            bi.ulFlags = BIF_RETURNONLYFSDIRS;

            do {
                ItemIdList = SHBrowseForFolder (&bi);
                if (!ItemIdList) {
                    break;
                }

                TurnOnWaitCursor();
                __try {
                    if (!SHGetPathFromIDList (ItemIdList, SearchPathStr) ||
                        *SearchPathStr == 0
                        ) {
                        //
                        // Message box -- please reselect
                        //
                        OkBox (hdlg, MSG_BAD_SEARCH_PATH);
                        continue;
                    }

                    rc = SearchForMigrationDlls (
                            hdlg,
                            SearchPathStr,
                            &ActiveModulesFound,
                            &OneModuleFound
                            );

                    //
                    // If the search was successful, update the list, or
                    // tell the user why the list is not changing.
                    //
                    // If the search was not successful, the search UI
                    // already gave the error message, so we just continue
                    // silently.
                    //

                    if (!OneModuleFound) {
                        if (rc == ERROR_SUCCESS) {
                            OkBox (hdlg, MSG_NO_MODULES_FOUND);
                        }
                    } else if (!ActiveModulesFound) {
                        if (rc == ERROR_SUCCESS) {
                            OkBox (hdlg, MSG_NO_NECESSARY_MODULES_FOUND);
                        }
                    } else {
                        SendMessage (hdlg, WMX_UPDATE_LIST, 0, 0);
                    }

                    break;
                }
                __finally {
                    TurnOffWaitCursor();
                }
            } while (TRUE);

            return TRUE;

        }
    }

    return FALSE;
}


BOOL
CALLBACK
SearchingDlgProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    HWND Animation;
    DWORD ThreadId;
    static PSEARCHING_THREAD_DATA ThreadData;

    switch (uMsg) {

    case WM_INITDIALOG:
        //
        // Initialize thread data struct
        //

        ThreadData = (PSEARCHING_THREAD_DATA) lParam;
        ThreadData->hdlg = hdlg;

        if (!ThreadData->CancelEvent) {
            ThreadData->CancelEvent = CreateEvent (NULL, TRUE, FALSE, NULL);
            MYASSERT (ThreadData->CancelEvent);
        }

        //
        // Load the avi resource for the animation.
        //
        Animation = GetDlgItem (hdlg, IDC_ANIMATE);
        Animate_Open (Animation, MAKEINTRESOURCE(IDA_FIND_COMP));
        PostMessage (hdlg, WMX_DIALOG_VISIBLE, 0, 0);

        return FALSE;

    case WMX_DIALOG_VISIBLE:
        ThreadData->ThreadHandle = CreateThread (
                                       NULL,
                                       0,
                                       ThreadData->ThreadProc,
                                       (PVOID) ThreadData,
                                       0,
                                       &ThreadId
                                       );

        if (!ThreadData->ThreadHandle) {
            LOG ((LOG_ERROR, "Failed to create thread for migration dll search."));
            EndDialog (hdlg, IDCANCEL);
        }

        return TRUE;

    case WMX_THREAD_DONE:
        EndDialog (hdlg, lParam);
        return TRUE;


    case WMX_WAIT_FOR_THREAD_TO_DIE:
        if (WAIT_OBJECT_0 == WaitForSingleObject (ThreadData->ThreadHandle, 50)) {
            TurnOffWaitCursor();
            EndDialog (hdlg, lParam);
        } else {
            PostMessage (hdlg, WMX_WAIT_FOR_THREAD_TO_DIE, wParam, lParam);
        }
        return TRUE;

    case WM_COMMAND:
        switch (LOWORD (wParam)) {
        case IDCANCEL:
            //
            // Set cancel event
            //

            SetEvent (ThreadData->CancelEvent);

            //
            // Stop the animation
            //

            UpdateWindow (hdlg);
            Animation = GetDlgItem (hdlg, IDC_ANIMATE);
            Animate_Stop (Animation);

            //
            // Loop until thread dies
            //

            PostMessage (hdlg, WMX_WAIT_FOR_THREAD_TO_DIE, 0, ERROR_CANCELLED);
            TurnOnWaitCursor();

            return TRUE;
        }
        break;

    case WM_DESTROY:
        if (ThreadData->CancelEvent) {
            CloseHandle (ThreadData->CancelEvent);
            ThreadData->CancelEvent = NULL;
        }
        if (ThreadData->ThreadHandle) {
            CloseHandle (ThreadData->ThreadHandle);
            ThreadData->ThreadHandle = NULL;
        }

        break;

    }

    return FALSE;
}

DWORD
WINAPI
pSearchForMigrationDlls (
    PVOID Param
    )
{
    PSEARCHING_THREAD_DATA Data;
    HWND OldParent;
    LONG rc;

    Data = (PSEARCHING_THREAD_DATA) Param;

    OldParent = g_ParentWnd;
    g_ParentWnd = Data->hdlg;
    LogReInit (&g_ParentWnd, NULL);

    __try {
        //
        // Open event handle, closed by thread owner
        //

        Data->CancelEvent = CreateEvent (NULL, TRUE, FALSE, NULL);
        if (!Data->CancelEvent) {
            DEBUGMSG ((DBG_ERROR, "pSearchForMigrationDlls: Could not create cancel event"));
            __leave;
        }

        Data->ActiveMatches = ScanPathForMigrationDlls (
                                    Data->SearchStr,
                                    Data->CancelEvent,
                                    &Data->MatchFound
                                    );

        if (WaitForSingleObject (Data->CancelEvent, 0) != WAIT_OBJECT_0) {
            rc = GetLastError();
            PostMessage (Data->hdlg, WMX_THREAD_DONE, 0, rc);
        }
    }
    __finally {
        LogReInit (&OldParent, NULL);
    }

    return 0;
}


LONG
SearchForMigrationDlls (
    IN      HWND Parent,
    IN      PCTSTR SearchPathStr,
    OUT     UINT *ActiveModulesFound,
    OUT     PBOOL OneValidDllFound
    )
{
    SEARCHING_THREAD_DATA Data;
    LONG rc;

    if (!SearchPathStr || *SearchPathStr == 0) {
        return IDNO;
    }

    ZeroMemory (&Data, sizeof (Data));

    Data.SearchStr = SearchPathStr;
    Data.ThreadProc = pSearchForMigrationDlls;

    rc = DialogBoxParam (
            g_hInst,
            MAKEINTRESOURCE(IDD_SEARCHING_DLG),
            Parent,
            SearchingDlgProc,
            (LPARAM) &Data
            );

    *ActiveModulesFound = Data.ActiveMatches;
    *OneValidDllFound = Data.MatchFound;

    return rc;
}


LONG
SearchForDrivers (
    IN      HWND Parent,
    IN      PCTSTR SearchPathStr,
    OUT     BOOL *DriversFound
    )
{
    SEARCHING_THREAD_DATA Data;
    LONG rc;

    if (!SearchPathStr || *SearchPathStr == 0) {
        return IDNO;
    }

    ZeroMemory (&Data, sizeof (Data));

    Data.SearchStr = SearchPathStr;
    Data.ThreadProc = pSearchForDrivers;

    rc = DialogBoxParam (
            g_hInst,
            MAKEINTRESOURCE(IDD_SEARCHING_DLG),
            Parent,
            SearchingDlgProc,
            (LPARAM) &Data
            );

    *DriversFound = Data.MatchFound;

    return rc;
}


DWORD
WINAPI
pSearchForDomainThread (
    PVOID Param
    )
{
    PSEARCHING_THREAD_DATA Data;
    LONG rc;
    NETRESOURCE_ENUM e;

    Data = (PSEARCHING_THREAD_DATA) Param;
    Data->ActiveMatches = 0;

    __try {
        //
        // Search all workgroups and domains for a computer account.
        //

        if (EnumFirstNetResource (&e, 0, 0, 0)) {
            do {
                if (WaitForSingleObject (Data->CancelEvent, 0) == WAIT_OBJECT_0) {
                    AbortNetResourceEnum (&e);
                    SetLastError (ERROR_CANCELLED);
                    __leave;
                }

                if (e.Domain) {
                    if (1 == DoesComputerAccountExistOnDomain (e.RemoteName, Data->SearchStr, FALSE)) {
                        //
                        // Return first match
                        //

                        DEBUGMSG ((DBG_NAUSEA, "Account found for %s on %s", Data->SearchStr, e.RemoteName));

                        StringCopy (Data->MatchStr, e.RemoteName);
                        Data->ActiveMatches = 1;

                        AbortNetResourceEnum (&e);
                        SetLastError (ERROR_SUCCESS);

                        __leave;
                    }

                    DEBUGMSG ((DBG_NAUSEA, "%s does not have an account for %s", e.RemoteName, Data->SearchStr));
                }
            } while (EnumNextNetResource (&e));
        }
    }
    __finally {
        Data->MatchFound = (Data->ActiveMatches != 0);

        if (WaitForSingleObject (Data->CancelEvent, 0) != WAIT_OBJECT_0) {
            rc = GetLastError();
            PostMessage (Data->hdlg, WMX_THREAD_DONE, 0, rc);
        }
    }

    return 0;
}


LONG
SearchForDomain (
    IN      HWND Parent,
    IN      PCTSTR ComputerName,
    OUT     BOOL *AccountFound,
    OUT     PTSTR DomainName
    )
{
    SEARCHING_THREAD_DATA Data;
    LONG rc;

    ZeroMemory (&Data, sizeof (Data));

    Data.SearchStr = ComputerName;
    Data.ThreadProc = pSearchForDomainThread;
    Data.MatchStr = DomainName;

    rc = DialogBoxParam (
            g_hInst,
            MAKEINTRESOURCE(IDD_SEARCHING_DLG),
            Parent,
            SearchingDlgProc,
            (LPARAM) &Data
            );

    *AccountFound = Data.MatchFound;

    return rc;
}


BOOL
ChangeNameDlg (
    IN      HWND Parent,
    IN      PCTSTR NameGroup,
    IN      PCTSTR OrgName,
    IN OUT  PTSTR NewName
    )

/*++

Routine Description:

  ChangeNameDlg creates a dialog to allow the user to alter Setup-
  generated replacement names.

Arguments:

  Parent - Specifies handle to the parent window for the dialog

  NameGroup - Specifies the name group being processed, used to
              verify the new name does not collide with an existing
              name in the name group.

  OrgName - Specifies the original name as it was found on the Win9x
            machine

  NewName - Specifies the Setup-recommended new name, or the last change
            made by the user.  Receives the user's change.

Return Value:

  TRUE if the name was changed, or FALSE if no change was made.

--*/

{
    TCHAR NewNameBackup[MEMDB_MAX];
    CHANGE_NAME_PARAMS Data;

    StringCopy (NewNameBackup, NewName);

    Data.NameGroup   = NameGroup;
    Data.OrgName     = OrgName;
    Data.LastNewName = NewNameBackup;
    Data.NewNameBuf  = NewName;

    DialogBoxParam (
         g_hInst,
         MAKEINTRESOURCE (IDD_NAME_CHANGE_DLG),
         Parent,
         pChangeNameDlgProc,
         (LPARAM) &Data
         );

    return !StringMatch (NewNameBackup, NewName);
}


BOOL
CALLBACK
pChangeNameDlgProc (
    IN      HWND hdlg,
    IN      UINT uMsg,
    IN      WPARAM wParam,
    IN      LPARAM lParam
    )

/*++

Routine Description:

  pChangeNameDlgProc implements the dialog procedure for the change
  name dialog.  There are two cases handled by this code:

  1. The WM_INITDIALOG message handler initializes the edit
     control with the text from the last change to the name.

  2. The IDOK command handler verifies that the supplied name
     does not collide with an existing name in the group.

Arguments:

  hdlg - Specifies the dialog handle

  uMsg - Specifies the message to process

  wParam - Specifies message-specific data

  lParam - Specifies message-specific data

Return Value:

  TRUE if the message was handled by this procedure, or FALSE
  if the system should handle the message.

--*/

{
    static PCHANGE_NAME_PARAMS Data;
    TCHAR NewName[MEMDB_MAX];

    switch (uMsg) {

    case WM_INITDIALOG:
        //
        // Initialize data struct
        //

        Data = (PCHANGE_NAME_PARAMS) lParam;

        //
        // Fill the dialog box controls
        //

        SetDlgItemText (hdlg, IDC_ORIGINAL_NAME, Data->OrgName);
        SetDlgItemText (hdlg, IDC_NEW_NAME, Data->LastNewName);

        return FALSE;       // let system set the focus

    case WM_COMMAND:
        switch (LOWORD (wParam)) {
        case IDOK:
            //
            // Obtain the new name, and make sure it is legal.
            //

            GetDlgItemText (
                hdlg,
                IDC_NEW_NAME,
                NewName,
                sizeof (NewName) / sizeof (NewName[0])
                );

            //
            // If user changed the name, verify name is not in the name group
            //

            if (!StringIMatch (NewName, Data->LastNewName)) {

                if (!ValidateName (hdlg, Data->NameGroup, NewName)) {
                    return TRUE;
                }
            }

            //
            // Copy name to buffer and close dialog
            //

            StringCopy (Data->NewNameBuf, NewName);
            EndDialog (hdlg, IDOK);
            return TRUE;

        case IDCANCEL:
            EndDialog (hdlg, IDCANCEL);
            return TRUE;
        }
        break;

    }

    return FALSE;
}


BOOL
CredentialsDlg (
    IN      HWND Parent,
    IN OUT  PCREDENTIALS Credentials
    )

/*++

Routine Description:

  CredentialsDlg creates a dialog to allow the user to enter computer
  domain credentials, which are used in GUI mode to join the computer
  to a domain.

Arguments:

  Parent - Specifies handle to the parent window for the dialog

  Credentials - Specifies the credentials to use, receives the user's
                changes

Return Value:

  TRUE if a name was changed, or FALSE if no change was made.

--*/

{
    Credentials->Change = TRUE;

    DialogBoxParam (
         g_hInst,
         MAKEINTRESOURCE (IDD_DOMAIN_CREDENTIALS_DLG),
         Parent,
         pCredentialsDlgProc,
         (LPARAM) Credentials
         );

    return Credentials->Change;
}


VOID
pRemoveWhitespace (
    IN OUT  PTSTR String
    )
{
    PCTSTR Start;
    PCTSTR End;

    Start = SkipSpace (String);

    if (Start != String) {
        End = GetEndOfString (Start) + 1;
        MoveMemory (String, Start, (PBYTE) End - (PBYTE) Start);
    }

    TruncateTrailingSpace (String);
}


BOOL
CALLBACK
pCredentialsDlgProc (
    IN      HWND hdlg,
    IN      UINT uMsg,
    IN      WPARAM wParam,
    IN      LPARAM lParam
    )

/*++

Routine Description:

  pCredentialsDlgProc implements the dialog procedure for the
  administrator credentials dialog.  There are two cases handled
  by this code:

  1. The WM_INITDIALOG message handler initializes the edit
     control with the text from the last change.

  2. The IDOK command handler gets the domain credentials and
     returns them to the caller.

Arguments:

  hdlg - Specifies the dialog handle

  uMsg - Specifies the message to process

  wParam - Specifies message-specific data

  lParam - Specifies message-specific data

Return Value:

  TRUE if the message was handled by this procedure, or FALSE
  if the system should handle the message.

--*/

{
    static PCREDENTIALS Credentials;
    CREDENTIALS Temp;
    //LONG rc;
    //TCHAR ComputerName[MAX_COMPUTER_NAME + 1];
    TCHAR UserName[USER_NAME_SIZE];
    TCHAR CurrentUserName[MAX_USER_NAME];
    TCHAR Domain[USER_NAME_SIZE];
    DWORD Size;
    PTSTR p;

    switch (uMsg) {

    case WM_INITDIALOG:
        //
        // Initialize data struct
        //

        Credentials = (PCREDENTIALS) lParam;

        //
        // Fill the dialog box controls
        //

        //SendMessage (GetDlgItem (hdlg, IDC_DOMAIN), EM_LIMITTEXT, MAX_COMPUTER_NAME, 0);
        SendMessage (GetDlgItem (hdlg, IDC_USER_NAME), EM_LIMITTEXT, USER_NAME_SIZE, 0);
        SendMessage (GetDlgItem (hdlg, IDC_PASSWORD), EM_LIMITTEXT, MAX_PASSWORD, 0);

        //SetDlgItemText (hdlg, IDC_DOMAIN, Credentials->DomainName);
        SetDlgItemText (hdlg, IDC_USER_NAME, Credentials->AdminName);
        SetDlgItemText (hdlg, IDC_PASSWORD, Credentials->Password);

        Credentials->Change = FALSE;

        return FALSE;       // let system set the focus

    case WM_COMMAND:
        switch (LOWORD (wParam)) {
        case IDOK:
            //
            // Obtain the new text
            //

            CopyMemory (&Temp, Credentials, sizeof (CREDENTIALS));

            /*
            GetDlgItemText (
                hdlg,
                IDC_DOMAIN,
                Temp.DomainName,
                sizeof (Temp.DomainName) / sizeof (Temp.DomainName[0])
                );
            */

            GetDlgItemText (
                hdlg,
                IDC_USER_NAME,
                Domain,
                ARRAYSIZE(Domain)
                );

            GetDlgItemText (
                hdlg,
                IDC_PASSWORD,
                Temp.Password,
                ARRAYSIZE(Temp.Password)
                );

            p = _tcschr (Domain, TEXT('\\'));
            if (p) {
                *p = 0;
                StringCopy (UserName, p + 1);
            } else {
                StringCopy (UserName, Domain);
                *Domain = 0;
            }

            pRemoveWhitespace (Domain);
            pRemoveWhitespace (UserName);

            if (!*UserName && !*Temp.Password) {
                EndDialog (hdlg, IDCANCEL);
                return TRUE;
            }

            if (*Domain) {

                if (!ValidateDomainNameChars (Domain)) {
                    OkBox (hdlg, MSG_USER_IS_BOGUS);
                    return TRUE;
                }
            }

            if (!ValidateUserNameChars (UserName)) {
                OkBox (hdlg, MSG_USER_IS_BOGUS);
                return TRUE;
            }

            if (*Domain) {

                wsprintf (Temp.AdminName, TEXT("%s\\%s"), Domain, UserName);

            } else {

                StringCopy (Temp.AdminName, UserName);

            }

            Size = sizeof (CurrentUserName);
            GetUserName (CurrentUserName, &Size);

            if (StringIMatch (CurrentUserName, UserName)) {
                if (IDNO == YesNoBox (hdlg, MSG_USER_IS_CURRENT_USER)) {
                    OkBox (hdlg, MSG_CONTACT_NET_ADMIN);
                    return TRUE;
                }
            }

            /*
            if (!ValidateName (hdlg, TEXT("ComputerDomain"), Temp.DomainName)) {
                OkBox (hdlg, MSG_SPECIFIED_DOMAIN_RESPONSE_POPUP);
                return TRUE;
            }

            GetUpgradeComputerName (ComputerName);
            rc = DoesComputerAccountExistOnDomain (Temp.DomainName, ComputerName, TRUE);

            if (rc == -1) {
                OkBox (hdlg, MSG_SPECIFIED_DOMAIN_RESPONSE_POPUP);
                return TRUE;
            }
            */

            CopyMemory (Credentials, &Temp, sizeof (CREDENTIALS));
            Credentials->Change = TRUE;

            EndDialog (hdlg, IDOK);
            return TRUE;

        case IDCANCEL:
            EndDialog (hdlg, IDCANCEL);
            return TRUE;
        }
        break;

    }

    return FALSE;
}


BOOL
CALLBACK
UntrustedDllProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    UINT Control;

    switch (uMsg) {
    case WM_INITDIALOG:
        CheckDlgButton (hdlg, IDC_DONT_TRUST_IT, BST_CHECKED);
        return FALSE;

    case WM_COMMAND:
        switch (LOWORD (wParam)) {
        case IDOK:
            Control = IDC_DONT_TRUST_IT;
            if (IsDlgButtonChecked (hdlg, Control) == BST_UNCHECKED) {
                Control = IDC_TRUST_IT;
                if (IsDlgButtonChecked (hdlg, Control) == BST_UNCHECKED) {
                    Control = IDC_TRUST_ANY;
                }
            }

            EndDialog (hdlg, Control);
            break;

        case IDCANCEL:
            EndDialog (hdlg, IDCANCEL);
            return TRUE;
        }

        break;
    }

    return FALSE;
}


UINT
UI_UntrustedDll (
    IN      PCTSTR DllPath
    )

/*++

Routine Description:

  UI_UntrustedDll asks the user if they give permission to trust an upgrade
  module that does not have a digital signature, or is not trusted by the
  system.

Arguments:

  DllPath - Specifies path to DLL that is not trusted

Return Value:

  The control ID of the option selected by the user.

--*/

{
    return IDC_TRUST_ANY;       // temporary -- trust them all

    /*
    if (g_ParentWnd == NULL) {
        return IDC_TRUST_ANY;       // temporary -- trust them all
    }

    return DialogBox (g_hInst, MAKEINTRESOURCE(IDD_TRUST_FAIL_DLG), g_ParentWnd, UntrustedDllProc);
    */
}


#ifdef PRERELEASE

BOOL
CALLBACK
AutoStressDlgProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    TCHAR Data[1024];
    DWORD Flags;
    HKEY Key;
    PCTSTR User;
    DWORD Size;

    switch (uMsg) {
    case WM_INITDIALOG:
        Key = OpenRegKeyStr (S_MSNP32);
        if (Key) {

            Data[0] = 0;

            User  = GetRegValueData (Key, S_AUTHENTICATING_AGENT);
            if (User) {
                StringCopy (Data, User);
                MemFree (g_hHeap, 0, User);

                Size = MAX_USER_NAME;
                GetUserName (AppendWack (Data), &Size);

                SetDlgItemText (hdlg, IDC_USERNAME, Data);
            }

            CloseRegKey (Key);
        }

        return FALSE;

    case WM_COMMAND:
        switch (LOWORD (wParam)) {
        case IDOK:

            GetDlgItemText (hdlg, IDC_USERNAME, Data, 1024);
            MemDbSetValueEx (MEMDB_CATEGORY_STATE, S_AUTOSTRESS_USER, Data, NULL, 0, NULL);

            GetDlgItemText (hdlg, IDC_PASSWORD, Data, 1024);
            MemDbSetValueEx (MEMDB_CATEGORY_STATE, S_AUTOSTRESS_PASSWORD, Data, NULL, 0, NULL);

            GetDlgItemText (hdlg, IDC_OFFICE, Data, 1024);
            MemDbSetValueEx (MEMDB_CATEGORY_STATE, S_AUTOSTRESS_OFFICE, Data, NULL, 0, NULL);

            GetDlgItemText (hdlg, IDC_DBGMACHINE, Data, 1024);
            MemDbSetValueEx (MEMDB_CATEGORY_STATE, S_AUTOSTRESS_DBG, Data, NULL, 0, NULL);

            Flags = 0;
            if (IsDlgButtonChecked (hdlg, IDC_PRIVATE) == BST_CHECKED) {
                Flags |= AUTOSTRESS_PRIVATE;
            }
            if (IsDlgButtonChecked (hdlg, IDC_MANUAL_TESTS) == BST_CHECKED) {
                Flags |= AUTOSTRESS_MANUAL_TESTS;
            }

            wsprintf (Data, TEXT("%u"), Flags);
            MemDbSetValueEx (MEMDB_CATEGORY_STATE, S_AUTOSTRESS_FLAGS, Data, NULL, 0, NULL);

            EndDialog (hdlg, IDOK);
            break;
        }

        break;
    }

    return FALSE;
}


DWORD
DoAutoStressDlg (
    PVOID Unused
    )
{
    DialogBox (g_hInst, MAKEINTRESOURCE(IDD_STRESS), g_ParentWndAlwaysValid, AutoStressDlgProc);
    return 0;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\dll\makefile.inc ===
obj\$(TARGET_DIRECTORY)\w95upgnt.res: w95upgnt.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\ui\wizproc.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    wizproc.c

Abstract:

    This module implements the wizard page procedures needed for the Win9x side
    of the upgrade.

Author:

    Jim Schmidt (jimschm) 17-Mar-1997

Revision History:

    jimschm     24-Jun-1999 Added UI_PreDomainPageProc
    jimschm     15-Sep-1998 Resource dump
    marcw       15-Sep-1998 Anti-virus checker changes
    marcw       18-Aug-1998 Changed BadTimeZone to list box.
    marcw       08-Jul-1998 Added UI_BadTimeZonePageProc
    jimschm     21-Jan-1998 Added UI_DomainPageProc
    jimschm     08-Jan-1998 Moved deferred init to init9x.lib
    jimschm     24-Dec-1997 Added UI_NameCollisionPageProc functionality

--*/

#include "pch.h"
#include "uip.h"
#include "memdb.h"
#include "encrypt.h"

//
// Enums
//
typedef enum {
    BIP_DONOT,
    BIP_NOT_ENOUGH_SPACE,
    BIP_SIZE_EXCEED_LIMIT
} BACKUP_IMPOSSIBLE_PAGE;


//
// Defines
//

#define WMX_PAGE_VISIBLE (WMX_PLUGIN_FIRST+0)
#define MAX_NUMBER_OF_DRIVES    ('Z' - 'B')
#define NESSESSARY_DISK_SPACE_TO_BACKUP_UNCOMPRESSED    (512<<20) //512MB
#define MAX_BACKUP_IMAGE_SIZE_FOR_BACKUP                (((LONGLONG)2048)<<20) //2048GB
#define MAX_AMOUNT_OF_TIME_TO_TRY_CONSTRUCT_UNDO_DIR    1000
#define PROPSHEET_NEXT_BUTTON_ID    0x3024

#define MAX_LISTVIEW_TEXT       1024
#define IMAGE_INDENT            2
#define TEXT_INDENT             2
#define TEXT_EXTRA_TAIL_SPACE   2

#define LINEATTR_BOLD           0x0001
#define LINEATTR_INDENTED       0x0002
#define LINEATTR_ALTCOLOR       0x0004

//
// Globals
//

extern HANDLE g_WorkerThreadHandle;
extern ULARGE_INTEGER g_SpaceNeededForSlowBackup;
extern ULARGE_INTEGER g_SpaceNeededForFastBackup;
extern ULARGE_INTEGER g_SpaceNeededForUpgrade;
extern DWORD g_MasterSequencer;

HWND g_ParentWndAlwaysValid = NULL;
HWND g_Winnt32Wnd = NULL;
HWND g_TextViewInDialog = NULL;
BOOL g_DomainSkipped = FALSE;
BOOL g_Offline = FALSE;
BOOL g_SilentBackupMode = FALSE;
BOOL g_UIQuitSetup = FALSE;
BOOL g_IncompatibleDevicesWarning = FALSE;
BACKUP_IMPOSSIBLE_PAGE g_ShowBackupImpossiblePage = BIP_DONOT;

WNDPROC OldProgressProc;
BOOL
NewProgessProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );

#ifdef PRERELEASE
HANDLE g_AutoStressHandle;
#endif


//
// Prototypes
//

VOID
SaveConfigurationForBeta (
    VOID
    );

//
// Implementation
//

void SetupBBProgressText(HWND hdlg, UINT id)
{
    PCTSTR string = NULL;
    string = GetStringResource (id);
    if (string)
    {
        SendMessage(GetParent(hdlg),WMX_SETPROGRESSTEXT,0,(LPARAM)string);
        FreeStringResource (string);
    }
}

BOOL
pAbortSetup (
    HWND hdlg
    )
{
    SETCANCEL();
    PropSheet_PressButton (GetParent (hdlg), PSBTN_CANCEL);
    return TRUE;
}



// BackupPageProc does not allow the user to actually perform a backup


BOOL
UI_BackupPageProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static BOOL InitSent = FALSE;
    HKEY UrlKey;
    HWND TextView;


    __try {

        switch (uMsg) {


        case WMX_INIT_DIALOG:
            UrlKey = OpenRegKeyStr (TEXT("HKCR\\.URL"));
            TextView = GetDlgItem (hdlg, IDC_HOTLINK);

            if (UrlKey) {
                CloseRegKey (UrlKey);
            } else {
                ShowWindow (TextView, SW_HIDE);
            }
            return FALSE;

        case WMX_ACTIVATEPAGE:

            if (wParam) {
                if (!UPGRADE() || CANCELLED()) {
                    return FALSE;
                }

                 if (!InitSent) {
                    SendMessage (hdlg, WMX_INIT_DIALOG, 0, 0);
                    InitSent = TRUE;
                }

                g_ParentWndAlwaysValid = GetParent (hdlg);
                SetOutOfMemoryParent (g_ParentWndAlwaysValid);


                //
                // Skip this page in unattended mode.
                //
                if (UNATTENDED() || TYPICAL()) {
                    return FALSE;
                }

                //
                // Fill in text of the IDC_TEXT1 control
                //

                //ArgArray[0] = g_Win95Name;
                //ParseMessageInWnd (GetDlgItem (hdlg, IDC_TEXT1), ArgArray);

                // On activate, turn on next and back
                PropSheet_SetWizButtons (GetParent(hdlg), PSWIZB_NEXT|PSWIZB_BACK);
            } else {
                DEBUGLOGTIME(("Backup Wizard Page done."));
            }

            return TRUE;
        }

    } __except (1) {

        LOG ((LOG_WARNING, "An unhandled exception occurred during the processing of the Backup Page."));
        SafeModeExceptionOccured ();

    }


    return FALSE;
}

BOOL
UI_HwCompDatPageProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    DWORD threadId;
    static BOOL HwReportGenerated = FALSE;
    static BOOL DeferredInitExecuted = FALSE;
    PCTSTR ArgArray[1];


    __try {
        switch (uMsg) {

        case WMX_ACTIVATEPAGE:
            if (wParam) {
                if (!UPGRADE() || CANCELLED()) {
                    return FALSE;
                }



                //
                // Block upgrades of Server
                //
                // This case usually does not detect server.  If WINNT32 ever updates the
                // Server variable earlier, this will work.
                //

                if (*g_ProductType == NT_SERVER) {
                    ArgArray[0] = g_Win95Name;

                    ResourceMessageBox (
                        g_ParentWnd,
                        MSG_SERVER_UPGRADE_UNSUPPORTED_INIT,
                        MB_OK|MB_ICONSTOP|MB_SETFOREGROUND,
                        ArgArray
                        );

                    return pAbortSetup (hdlg);
                }

                TurnOnWaitCursor();
                SendMessage(GetParent (hdlg), WMX_BBTEXT, (WPARAM)TRUE, 0);

                __try {
                    if (!DeferredInitExecuted) {
                        DeferredInitExecuted = TRUE;

                        DEBUGLOGTIME(("Deferred init..."));

                        //
                        // This page is the first page that gets control from WINNT32 after
                        // the INIT routine. We _must_ use this opportunity to do any delayed
                        // initialization that may be necessary.
                        //

                        if (!DeferredInit (hdlg)) {
                            return pAbortSetup (hdlg);
                        }

                        BuildPunctTable();
                    }


                    DEBUGLOGTIME(("HWCOMP.DAT Wizard Page..."));

                    if (HwReportGenerated) {
                        //
                        // The code below was already processed
                        //

                        return FALSE;
                    }

                    HwReportGenerated = TRUE;

                    //
                    // Determine if hwcomp.dat needs to be rebuilt, and if it does, determine the progress bar
                    // ticks.  If it does not need to be rebuilt, b will be FALSE.
                    //
                    // hwcomp.dat is rebuilt whenever there is an INF file that is changed from the ones shipped
                    // with NT.  Internally, this includes the INFs that are compressed, so consequently anyone
                    // who installs off the corpnet automatically gets their hwcomp.dat rebuilt.
                    //

                    if (!HwComp_DoesDatFileNeedRebuilding()) {

                        HwComp_ScanForCriticalDevices();

                        DEBUGMSG((DBG_NAUSEA,"UI_HwCompDatPageProc: Skipping page since INF files do not nead to be read."));
                        return FALSE;
                    }

                    //
                    // On activate, disable next and back
                    //
                    PropSheet_SetWizButtons (GetParent(hdlg), 0);
                    PostMessage (hdlg, WMX_PAGE_VISIBLE, 0, 0);
                }
                __finally {
                    TurnOffWaitCursor();
                }
            }

            return TRUE;

        case WMX_PAGE_VISIBLE:

            //
            // Create thread that does the work
            //

            UpdateWindow (hdlg);
            OldProgressProc = (WNDPROC)SetWindowLongPtr(GetDlgItem(hdlg, IDC_PROGRESS),GWLP_WNDPROC,(LONG_PTR)NewProgessProc);
            SetupBBProgressText(hdlg, MSG_HWCOMP_TEXT);
            SendMessage(GetParent(hdlg), WMX_BBPROGRESSGAUGE, SW_SHOW, 0);

            g_WorkerThreadHandle = CreateThread (
                                       NULL,
                                       0,
                                       UI_CreateNewHwCompDat,
                                       (PVOID) hdlg,
                                       0,
                                       &threadId
                                       );

            break;

        case WMX_REPORT_COMPLETE:
            SetWindowLongPtr(GetDlgItem(hdlg, IDC_PROGRESS),GWLP_WNDPROC,(LONG_PTR)OldProgressProc );
            SendMessage(GetParent(hdlg),WMX_SETPROGRESSTEXT,0,0);
            SendMessage(GetParent(hdlg), WMX_BBPROGRESSGAUGE, SW_HIDE, 0);
            if (g_WorkerThreadHandle != NULL) {
                CloseHandle (g_WorkerThreadHandle);
                g_WorkerThreadHandle = NULL;
            }

            if (lParam != ERROR_SUCCESS) {
                // For errors, cancel WINNT32
                LOG ((LOG_ERROR, "Report code failed!"));
                return pAbortSetup (hdlg);
            }
            else {
                HwComp_ScanForCriticalDevices();

                // Automatically move to the next wizard page when done
                PropSheet_PressButton (GetParent (hdlg), PSBTN_NEXT);
            }

            break;

        }
    } __except (1) {

        LOG ((LOG_WARNING, "An unhandled exception occurred during the processing of the Hardware Scanning Page."));
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_UNEXPECTED_ERROR_ENCOUNTERED_NORC));
        SafeModeExceptionOccured ();
        return pAbortSetup (hdlg);

    }

    return FALSE;
}


BOOL
UI_BadTimeZonePageProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{

    HWND timeZoneList;
    TCHAR timeZone[MAX_TIMEZONE];
    TIMEZONE_ENUM e;
    INT index;
    static BOOL firstTime = TRUE;
    PCTSTR unknown = NULL;

    __try {
        switch (uMsg) {

        case WMX_ACTIVATEPAGE:

            if (wParam) {

                if (!UPGRADE() || CANCELLED()) {
                    return FALSE;
                }

                DEBUGLOGTIME(("Bad Time Zone Wizard Page..."));

                //
                // Skip this page if in Unattended ReportOnly mode.
                //
                if (UNATTENDED() && REPORTONLY()) {
                    return FALSE;
                }

                if (UNATTENDED()) {
                    return FALSE;
                }



                if (EnumFirstTimeZone (&e, 0) || EnumFirstTimeZone(&e, TZFLAG_ENUM_ALL)) {

                    if (e.MapCount == 1 && *e.CurTimeZone) {
                        //
                        // Timezone is not ambiguous. Skip page.
                        //
                        return FALSE;
                    }

                    if (firstTime) {

                        //
                        // Disable the next button until something is selected.
                        //
                        PropSheet_SetWizButtons (GetParent(hdlg), 0);

                        firstTime = FALSE;

                        timeZoneList = GetDlgItem (hdlg, IDC_TIMEZONE_LIST);

                        if (!*e.CurTimeZone) {
                            unknown = GetStringResource (MSG_TIMEZONE_UNKNOWN);
                        }

                        SetWindowText (GetDlgItem (hdlg, IDC_CURTIMEZONE), *e.CurTimeZone ? e.CurTimeZone : unknown);

                        if (unknown) {
                            FreeStringResource (unknown);
                        }


                        do {

                            SendMessage (timeZoneList, LB_ADDSTRING, 0, (LPARAM) e.NtTimeZone);

                        } while (EnumNextTimeZone (&e));
                    }
                    // Stop the bill board and make sure the wizard shows again.
                    SendMessage(GetParent (hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);

                }
                else {
                    return FALSE;
                }



            }
            else {

                //
                // Get users selection and map it in.
                //
                timeZoneList = GetDlgItem (hdlg, IDC_TIMEZONE_LIST);
                index = (INT) SendMessage (timeZoneList, LB_GETCURSEL, 0, 0);
                SendMessage (timeZoneList, LB_GETTEXT, index, (LPARAM) timeZone);
                DEBUGMSG ((DBG_NAUSEA,"User selected %s timezone.", timeZone));
                ForceTimeZoneMap(timeZone);


                return TRUE;
            }

            return TRUE;
            break;

        case WM_COMMAND:

            switch (HIWORD(wParam)) {

            case CBN_SELCHANGE:

                //
                // Something has been selected. We will let them pass this page now.
                //
                PropSheet_SetWizButtons (GetParent(hdlg), PSWIZB_NEXT);

                break;

            }

            return TRUE;
            break;
        }
    } __except (1) {

        LOG ((LOG_WARNING, "An unhandled exception occurred during the processing of the Timezone Page."));
        SafeModeExceptionOccured ();
    }

    return FALSE;
}


BOOL
UI_BadHardDrivePageProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{

    __try {


        switch (uMsg) {

        case WMX_ACTIVATEPAGE:
            if (wParam) {
                if (!UPGRADE() || CANCELLED()) {
                    return FALSE;
                }

                DEBUGLOGTIME(("Bad Hdd Wizard Page..."));

                //
                // Scan for critical hardware (i.e. compatible hard disk) after we are sure the hwcomp.dat
                // file matches the INFs.
                //

                if (!HwComp_ScanForCriticalDevices()) {
                    LOG ((LOG_ERROR,"Aborting since Setup was unable to find critical devices."));
                    return pAbortSetup (hdlg);
                }

                //
                // Skip this page if there is a usable HardDrive.
                //

                if (g_ConfigOptions.GoodDrive || HwComp_NtUsableHardDriveExists()) {
                    DEBUGMSG((DBG_NAUSEA,"UI_BadHardDrivePageProc: Skipping page since a usable Hard Drive exists."));
                    return FALSE;
                }

                //
                // Skip this page if in Unattended ReportOnly mode.
                //
                if (UNATTENDED() && REPORTONLY()) {
                    return FALSE;
                }

                //
                // On activate, disable back and set the cancel flag pointer to true.
                //
                SETCANCEL(); // Non-standard, normal cases use pAbortSetup
                DEBUGMSG ((DBG_ERROR, "Bad hard drive caused setup to exit!"));
                PropSheet_SetWizButtons (GetParent(hdlg),0);
            }

            return TRUE;
            break;

        }

    } __except (1) {

        LOG ((LOG_WARNING, "An unhandled exception occurred during the processing of the Incompatible Harddrive Page."));
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_UNEXPECTED_ERROR_ENCOUNTERED_NORC));
        SafeModeExceptionOccured ();
        pAbortSetup (hdlg);
    }
    return FALSE;
}

BOOL
UI_BadCdRomPageProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{

    __try {
        switch (uMsg) {

        case WMX_ACTIVATEPAGE:
            if (wParam) {
                if (!UPGRADE() || CANCELLED()) {
                    return FALSE;
                }

                DEBUGLOGTIME(("Bad CdRom Wizard Page..."));

                //
                // Skip this page if invalid CdRom will not stop upgrade.
                //
                if (!HwComp_NtUsableCdRomDriveExists() && *g_CdRomInstallPtr) {

                    *g_CdRomInstallPtr = FALSE;
                    *g_MakeLocalSourcePtr = TRUE;

                    if (UNATTENDED()) {
                        return FALSE;
                    }
                }
                else if (HwComp_MakeLocalSourceDeviceExists () && *g_CdRomInstallPtr) {

                    *g_CdRomInstallPtr = FALSE;
                    *g_MakeLocalSourcePtr = TRUE;

                    return FALSE;
                }
                else {

                    DEBUGMSG((DBG_NAUSEA,"UI_BadCdRomDrivePageProc: Skipping page since a usable CdRom exists or is not needed."));
                    return FALSE;
                }
                //
                // On activate, disable next and back
                //
                PropSheet_SetWizButtons (GetParent(hdlg), PSWIZB_NEXT);
                PostMessage (hdlg, WMX_PAGE_VISIBLE, 0, 0);
            }
            else {

                //
                // Switch to LocalSource mode.
                //
                *g_CdRomInstallPtr = FALSE;
                *g_MakeLocalSourcePtr = TRUE;

            }

            return TRUE;
            break;

        }
    } __except (1) {

        LOG ((LOG_WARNING, "An unhandled exception occurred during the processing of the Incompatible CDRom Drive Page."));
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_UNEXPECTED_ERROR_ENCOUNTERED_NORC));
        SafeModeExceptionOccured ();
        pAbortSetup (hdlg);
    }

    return FALSE;
}


VOID
EnableDlgItem (
    HWND hdlg,
    UINT Id,
    BOOL Enable,
    UINT FocusId
    )
{
    HWND Control;

    Control = GetDlgItem (hdlg, Id);
    if (!Control) {
        DEBUGMSG ((DBG_WHOOPS, "Control ID %u missing!", Id));
        return;
    }

    if (!Enable && GetFocus() == Control) {
        SetFocus (GetDlgItem (hdlg, FocusId));
    }

    if ((Enable && IsWindowVisible (Control)) ||
        !Enable
        ) {
        EnableWindow (Control, Enable);
    }
}

VOID
ShowDlgItem (
    HWND hdlg,
    UINT Id,
    INT Show,
    UINT FocusId
    )
{
    if (Show == SW_HIDE) {
        EnableDlgItem (hdlg, Id, FALSE, FocusId);
    }

    ShowWindow (GetDlgItem (hdlg, Id), Show);

    if (Show == SW_SHOW) {
        EnableDlgItem (hdlg, Id, TRUE, FocusId);
    }
}


BOOL
UI_HardwareDriverPageProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    BROWSEINFO bi;
    HARDWARE_ENUM e;
    LPITEMIDLIST ItemIdList;
    HWND List;
    PCTSTR ModifiedDescription;
    PCTSTR ArgArray[2];
    PCTSTR ListText;
    TCHAR SearchPathStr[MAX_TCHAR_PATH];
    UINT Index;
    DWORD rc;
    BOOL DriverFound;
    BOOL b;
    static BOOL InitSent = FALSE;
    DEVNODESTRING_ENUM DevNodeStr;
    GROWBUFFER ResBuf = GROWBUF_INIT;
    PCTSTR ResText;

    __try {
        switch (uMsg) {

        case WMX_INIT_DIALOG:
    #if 0
            GetWindowRect (GetDlgItem (hdlg, IDC_LIST), &ShortSize);
            LongSize = ShortSize;

            ScreenToClient (hdlg, (PPOINT) &ShortSize);
            ScreenToClient (hdlg, ((PPOINT) &ShortSize) + 1);

            GetWindowRect (GetDlgItem (hdlg, IDC_OFFLINE_HELP), &HelpPos);
            LongSize.bottom = HelpPos.bottom;

            ScreenToClient (hdlg, (PPOINT) &LongSize);
            ScreenToClient (hdlg, ((PPOINT) &LongSize) + 1);
    #endif

            SendMessage (hdlg, WMX_UPDATE_LIST, 0, 0);
            return FALSE;

        case WMX_UPDATE_LIST:
            List = GetDlgItem (hdlg, IDC_LIST);
            SendMessage (List, LB_RESETCONTENT, 0, 0);

            if (EnumFirstHardware (&e, ENUM_INCOMPATIBLE_DEVICES, ENUM_WANT_ONLINE_FLAG)) {
                do {
                    //
                    // See if the registry key for this device was handled by a
                    // migration DLL
                    //

                    if (IsReportObjectHandled (e.FullKey)) {
                        continue;
                    }

                    //
                    // See if the user has supplied a driver that will
                    // support this device
                    //

                    if (FindUserSuppliedDriver (
                            e.HardwareID,
                            e.CompatibleIDs
                            )) {

                        continue;

                    }

                    //
                    // Not supported -- add to report
                    //

                    if (e.DeviceDesc) {
                        ArgArray[0] = e.DeviceDesc;
                        ModifiedDescription = ParseMessageID (MSG_OFFLINE_DEVICE_PLAIN, ArgArray);

                        if (!e.Online) {
                            ListText = ModifiedDescription;
                        } else {
                            ListText = e.DeviceDesc;
                        }

                        //
                        // Has this text already been listed?  We don't need to list
                        // the device type more than once, even if the user has multiple
                        // instances of the hardware installed.  Also, if we happened to
                        // add text that says the device is off line, and then we come
                        // across one that is online, we delete the offline message and
                        // put in the unaltered device description.
                        //
                        //

                        Index = SendMessage (List, LB_FINDSTRINGEXACT, 0, (LPARAM) e.DeviceDesc);
                        if (Index == LB_ERR) {
                            Index = SendMessage (List, LB_FINDSTRINGEXACT, 0, (LPARAM) ModifiedDescription);

                            if (ListText != ModifiedDescription && Index != LB_ERR) {
                                SendMessage (List, LB_DELETESTRING, Index, 0);
                                Index = LB_ERR;
                            }
                        }

                        if (Index == LB_ERR) {
                            Index = SendMessage (List, LB_ADDSTRING, 0, (LPARAM) ListText);
                            SendMessage (List, LB_SETITEMDATA, Index, (LPARAM) e.Online);
                        }

                        FreeStringResource (ModifiedDescription);

                        //
                        // Dump resources to setupact.log
                        //

                        if (EnumFirstDevNodeString (&DevNodeStr, e.FullKey)) {

                            do {
                                ArgArray[0] = DevNodeStr.ResourceName;
                                ArgArray[1] = DevNodeStr.Value;

                                ResText = ParseMessageID (
                                              MSG_RESOURCE_ITEM_LOG,
                                              ArgArray
                                              );

                                GrowBufAppendString (&ResBuf, ResText);

                                FreeStringResource (ResText);

                            } while (EnumNextDevNodeString (&DevNodeStr));

                            LOG ((
                                LOG_INFORMATION,
                                (PCSTR)MSG_RESOURCE_HEADER_LOG,
                                ListText,
                                e.Mfg,
                                e.Class,
                                ResBuf.Buf
                                ));

                            FreeGrowBuffer (&ResBuf);

                        }
                    }
                } while (EnumNextHardware (&e));
            }

    #if 0
            //
            // Scan list for one line that has item data of TRUE
            //

            Count = SendMessage (List, LB_GETCOUNT, 0, 0);
            for (Index = 0 ; Index < Count ; Index++) {
                if (!SendMessage (List, LB_GETITEMDATA, Index, 0)) {
                    break;
                }
            }

            if (Index < Count) {
                //
                // Show "not currently present" info
                //

                ShowDlgItem (hdlg, IDC_NOTE, SW_SHOW, IDC_HAVE_DISK);
                ShowDlgItem (hdlg, IDC_OFFLINE_HELP, SW_SHOW, IDC_HAVE_DISK);

                SetWindowPos (
                    List,
                    NULL,
                    0,
                    0,
                    ShortSize.right - ShortSize.left,
                    ShortSize.bottom - ShortSize.top,
                    SWP_NOZORDER|SWP_NOMOVE
                    );
            } else {
                //
                // Hide "not currently present" info
                //

                ShowDlgItem (hdlg, IDC_NOTE, SW_HIDE, IDC_HAVE_DISK);
                ShowDlgItem (hdlg, IDC_OFFLINE_HELP, SW_HIDE, IDC_HAVE_DISK);

                SetWindowPos (
                    List,
                    NULL,
                    0,
                    0,
                    LongSize.right - LongSize.left,
                    LongSize.bottom - LongSize.top,
                    SWP_NOZORDER|SWP_NOMOVE
                    );
            }
    #endif

            return TRUE;

        case WM_COMMAND:
            switch (LOWORD (wParam)) {
            case IDOK:
            case IDCANCEL:
                EndDialog (hdlg, IDOK);
                return TRUE;

            case IDC_HAVE_DISK:
                ZeroMemory (&bi, sizeof (bi));

                bi.hwndOwner = hdlg;
                bi.pszDisplayName = SearchPathStr;
                bi.lpszTitle = GetStringResource (MSG_DRIVER_DLG_TITLE);
                bi.ulFlags = BIF_RETURNONLYFSDIRS;

                do {
                    ItemIdList = SHBrowseForFolder (&bi);
                    if (!ItemIdList) {
                        break;
                    }

                    TurnOnWaitCursor();
                    __try {
                        if (!SHGetPathFromIDList (ItemIdList, SearchPathStr) ||
                            *SearchPathStr == 0
                            ) {
                            //
                            // Message box -- please reselect
                            //
                            OkBox (hdlg, MSG_BAD_SEARCH_PATH);
                            ItemIdList = NULL;
                        }
                    }
                    __finally {
                        TurnOffWaitCursor();
                    }

                } while (!ItemIdList);

                if (ItemIdList) {
                    rc = SearchForDrivers (hdlg, SearchPathStr, &DriverFound);

                    if (DriverFound) {
                        SendMessage (hdlg, WMX_UPDATE_LIST, 0, 0);
                    } else {
                        //
                        // Message box -- no driver found
                        //

                        if (rc == ERROR_DISK_FULL) {
                            OkBox (hdlg, MSG_DISK_FULL);
                        } else if (rc != ERROR_CANCELLED) {
                            OkBox (hdlg, MSG_NO_DRIVERS_FOUND);
                        }
                    }

                }

                return TRUE;
            }
            break;

        case WMX_ACTIVATEPAGE:
            b = FALSE;

            if (wParam) {
                if (!UPGRADE() || CANCELLED()) {
                    return FALSE;
                }

                DEBUGLOGTIME(("Hardware Wizard Page..."));

                //
                // check if any missing drivers are available from the Dynamic Update
                //

                if (g_DynamicUpdateDrivers) {
                    if (!AppendDynamicSuppliedDrivers (g_DynamicUpdateDrivers)) {
                        LOG ((
                            LOG_ERROR,
                            "AppendDynamicSuppliedDrivers failed; some downloaded drivers might be reported as missing"
                            ));
                    }
                }

                //
                // prepare Hardware compat report
                //
                HwComp_PrepareReport ();

                // On activate, turn on next
                PropSheet_SetWizButtons (GetParent(hdlg), PSWIZB_NEXT);

#if 0
                if (!InitSent) {
                    SendMessage (hdlg, WMX_INIT_DIALOG, 0, 0);
                    InitSent = TRUE;
                }


                __try {
                    //
                    // If in unattended mode, skip this page.
                    //
                    if (UNATTENDED() || REPORTONLY()) {
                        __leave;
                    }

                    //
                    // Unless an incompatibile device is found, skip this page.
                    //

                    if (EnumFirstHardware (&e, ENUM_INCOMPATIBLE_DEVICES, ENUM_DONT_WANT_DEV_FIELDS)) {
                        do {
                            if (!IsReportObjectHandled (e.FullKey)) {
                                //
                                // Incompatible device found
                                //

                                AbortHardwareEnum (&e);
                                b = TRUE;
                                __leave;
                            }

                        } while (EnumNextHardware (&e));
                    }
                }
                __finally {
                    if (!b) {
                        //
                        // Because this page will be skipped, generate the hardware report now
                        //

                        HwComp_PrepareReport();
                    }
                }
            } else {

                //
                // If a floppy disk was inserted, require user to eject it.
                //

                EjectDriverMedia (NULL);        // NULL == "on any removable media path"

                HwComp_PrepareReport();
                b = TRUE;
#endif
            }

            return b;
        }

    } __except (1) {

        LOG ((LOG_WARNING, "An unhandled exception occurred during the processing of the Provide Driver Page."));
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_UNEXPECTED_ERROR_ENCOUNTERED_NORC));
        SafeModeExceptionOccured ();
        pAbortSetup (hdlg);
    }
    return FALSE;
}


BOOL
UI_UpgradeModulePageProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    BOOL Enable;
    BROWSEINFO bi;
    PRELOADED_DLL_ENUM PreLoadedEnum;
    MIGDLL_ENUM e;
    RECT ListRect;
    LPITEMIDLIST ItemIdList;
    HWND List;
    PCTSTR Data;
    TCHAR SearchPathStr[MAX_TCHAR_PATH];
    LONG Index;
    LONG TopIndex;
    LONG ItemData;
    UINT ActiveModulesFound;
    UINT Length;
    LONG rc;
    INT Show;
    BOOL OneModuleFound;
    static BOOL InitSent = FALSE;

    __try {
        switch (uMsg) {

        case WMX_INIT_DIALOG:

            CheckDlgButton (hdlg, IDC_HAVE_MIGDLLS, BST_CHECKED);
            CheckDlgButton (hdlg, IDC_NO_MIGDLLS, BST_UNCHECKED);

            SendMessage (hdlg, WMX_UPDATE_LIST, 0, 0);
            SendMessage (hdlg, WMX_ENABLE_CONTROLS, 0, 0);
            break;

        case WMX_ENABLE_CONTROLS:

            //
            // Enable/disable the controls
            //

            Enable = IsDlgButtonChecked (hdlg, IDC_HAVE_MIGDLLS) == BST_CHECKED;

            if (Enable) {
                Show = SW_SHOW;
            } else {
                Show = SW_HIDE;
            }

            ShowDlgItem (hdlg, IDC_TITLE, Show, IDC_HAVE_DISK);
            ShowDlgItem (hdlg, IDC_PACK_LIST, Show, IDC_HAVE_DISK);
            ShowDlgItem (hdlg, IDC_HAVE_DISK, Show, IDC_HAVE_DISK);

            //
            // Special case -- show, then determine disable state
            //

            if (Enable) {
                Enable = SendMessage (GetDlgItem (hdlg, IDC_PACK_LIST), LB_GETCURSEL, 0, 0) != LB_ERR;
            }

            ShowWindow (GetDlgItem (hdlg, IDC_REMOVE), Show);
            EnableDlgItem (hdlg, IDC_REMOVE, Enable, IDC_HAVE_DISK);

            break;

        case WM_COMMAND:
            switch (LOWORD (wParam)) {

            case IDC_HAVE_MIGDLLS:
            case IDC_NO_MIGDLLS:
                if (HIWORD (wParam) == BN_CLICKED) {
                    SendMessage (hdlg, WMX_ENABLE_CONTROLS, 0, 0);
                }
                break;

            case IDC_PACK_LIST:
                if (HIWORD (wParam) == LBN_SELCHANGE) {
                    EnableDlgItem (hdlg, IDC_REMOVE, TRUE, IDC_HAVE_DISK);
                }
                break;

            case IDC_REMOVE:
                //
                // Delete item from internal memory structure
                // or keep registry-loaded DLL from running
                //

                List = GetDlgItem (hdlg, IDC_PACK_LIST);
                SendMessage (List, WM_SETREDRAW, FALSE, 0);

                Index = SendMessage (List, LB_GETCURSEL, 0, 0);
                MYASSERT (Index != LB_ERR);
                ItemData = (LONG) SendMessage (List, LB_GETITEMDATA, Index, 0);

                //
                // If ItemData is REGISTRY_DLL, then suppress the DLL.
                // Otherwise, delete loaded migration DLL
                //

                if (ItemData == REGISTRY_DLL) {
                    Length = SendMessage (List, LB_GETTEXTLEN, Index, 0) + 1;
                    Data = AllocText (Length);
                    if (Data) {
                        SendMessage (List, LB_GETTEXT, Index, (LPARAM) Data);
                        MemDbSetValueEx (MEMDB_CATEGORY_DISABLED_MIGDLLS, NULL, NULL, Data, 0, NULL);
                        FreeText (Data);
                    }
                } else {
                    RemoveDllFromList (ItemData);
                }

                //
                // Update the list box
                //

                TopIndex = SendMessage (List, LB_GETTOPINDEX, 0, 0);
                SendMessage (hdlg, WMX_UPDATE_LIST, 0, 0);
                SendMessage (List, LB_SETTOPINDEX, (WPARAM) TopIndex, 0);

                //
                // Disable remove button
                //

                SetFocus (GetDlgItem (hdlg, IDC_HAVE_DISK));
                EnableDlgItem (hdlg, IDC_REMOVE, FALSE, IDC_HAVE_DISK);

                //
                // Go back to no if all items were removed
                //

                if (!SendMessage (List, LB_GETCOUNT, 0, 0)) {
                    CheckDlgButton (hdlg, IDC_HAVE_MIGDLLS, BST_UNCHECKED);
                    CheckDlgButton (hdlg, IDC_NO_MIGDLLS, BST_CHECKED);
                }

                //
                // Redraw list box
                //

                SendMessage (List, WM_SETREDRAW, TRUE, 0);
                GetWindowRect (List, &ListRect);
                ScreenToClient (hdlg, (LPPOINT) &ListRect);
                ScreenToClient (hdlg, ((LPPOINT) &ListRect) + 1);

                InvalidateRect (hdlg, &ListRect, FALSE);
                break;

            case IDC_HAVE_DISK:
                ZeroMemory (&bi, sizeof (bi));

                bi.hwndOwner = hdlg;
                bi.pszDisplayName = SearchPathStr;
                bi.lpszTitle = GetStringResource (MSG_UPGRADE_MODULE_DLG_TITLE);
                bi.ulFlags = BIF_RETURNONLYFSDIRS;

                do {
                    ItemIdList = SHBrowseForFolder (&bi);
                    if (!ItemIdList) {
                        break;
                    }

                    TurnOnWaitCursor();
                    __try {
                        if (!SHGetPathFromIDList (ItemIdList, SearchPathStr) ||
                            *SearchPathStr == 0
                            ) {
                            //
                            // Message box -- please reselect
                            //
                            OkBox (hdlg, MSG_BAD_SEARCH_PATH);
                            continue;
                        }

                        rc = SearchForMigrationDlls (
                                hdlg,
                                SearchPathStr,
                                &ActiveModulesFound,
                                &OneModuleFound
                                );

                        //
                        // If the search was successful, update the list, or
                        // tell the user why the list is not changing.
                        //
                        // If the search was not successful, the search UI
                        // already gave the error message, so we just continue
                        // silently.
                        //

                        if (!OneModuleFound) {
                            if (rc == ERROR_SUCCESS) {
                                OkBox (hdlg, MSG_NO_MODULES_FOUND);
                            }
                        } else if (!ActiveModulesFound) {
                            if (rc == ERROR_SUCCESS) {
                                OkBox (hdlg, MSG_NO_NECESSARY_MODULES_FOUND);
                            }
                        } else {
                            SendMessage (hdlg, WMX_UPDATE_LIST, 0, 0);
                        }

                        break;
                    }
                    __finally {
                        TurnOffWaitCursor();
                    }
                } while (TRUE);

                return TRUE;

            }
            break;

        case WMX_ACTIVATEPAGE:
            if (wParam) {
                if (!UPGRADE() || CANCELLED() || REPORTONLY() || !g_ConfigOptions.TestDlls) {
                    return FALSE;
                }

                DEBUGLOGTIME(("Upgrade Module Wizard Page..."));

                if (!InitSent) {
                    SendMessage (hdlg, WMX_INIT_DIALOG, 0, 0);
                    InitSent = TRUE;
                }

                // On activate, turn on next and back
                PropSheet_SetWizButtons (GetParent(hdlg), PSWIZB_NEXT|PSWIZB_BACK);

                // Verify copy thread is running
                StartCopyThread();

                // Require that background copy thread to complete
                EndCopyThread();

                // Fail if error
                if (DidCopyThreadFail()) {
                    OkBox (hdlg, MSG_FILE_COPY_ERROR);

                    //
                    // Abort setup (disabled for internal builds)
                    //

                    return pAbortSetup (hdlg);
                }

                //
                // If in unattended mode, skip this page.
                //
                if (UNATTENDED()) {
                    return FALSE;
                }
            }

            SendMessage(GetParent (hdlg), WMX_BBTEXT, (WPARAM)!wParam, 0);

            return TRUE;

        case WMX_UPDATE_LIST:
            //
            // Enumerate all migration DLLs and shove the program ID in list box
            //

            List = GetDlgItem (hdlg, IDC_PACK_LIST);
            SendMessage (List, LB_RESETCONTENT, 0, 0);
            EnableDlgItem (hdlg, IDC_REMOVE, FALSE, IDC_HAVE_DISK);

            if (EnumFirstMigrationDll (&e)) {
                EnableDlgItem (hdlg, IDC_PACK_LIST, TRUE, IDC_HAVE_DISK);

                CheckDlgButton (hdlg, IDC_HAVE_MIGDLLS, BST_CHECKED);
                CheckDlgButton (hdlg, IDC_NO_MIGDLLS, BST_UNCHECKED);
                EnableDlgItem (hdlg, IDC_HAVE_MIGDLLS, FALSE, IDC_HAVE_DISK);
                EnableDlgItem (hdlg, IDC_NO_MIGDLLS, FALSE, IDC_HAVE_DISK);


                do {
                    Index = SendMessage (List, LB_ADDSTRING, 0, (LPARAM) e.ProductId);
                    SendMessage (List, LB_SETITEMDATA, Index, (LPARAM) e.Id);
                } while (EnumNextMigrationDll (&e));
            } else {
                EnableDlgItem (hdlg, IDC_HAVE_MIGDLLS, TRUE, IDC_HAVE_DISK);
                EnableDlgItem (hdlg, IDC_NO_MIGDLLS, TRUE, IDC_HAVE_DISK);
            }

            //
            // Enumerate all migration DLLs pre-loaded in the registry, and add them
            // to the list box if they haven't been "removed" by the user
            //

            if (EnumFirstPreLoadedDll (&PreLoadedEnum)) {
                do {
                    Index = SendMessage (List, LB_ADDSTRING, 0, (LPARAM) PreLoadedEnum.eValue.ValueName);
                    SendMessage (List, LB_SETITEMDATA, Index, (LPARAM) REGISTRY_DLL);
                } while (EnumNextPreLoadedDll (&PreLoadedEnum));
            }

            if (SendMessage (List, LB_GETCOUNT, 0, 0) == 0) {
                EnableDlgItem (hdlg, IDC_PACK_LIST, FALSE, IDC_HAVE_DISK);
            }

            return TRUE;
        }
    } __except (1) {

        LOG ((LOG_WARNING, "An unhandled exception occurred during the processing of the Provide Upgrade Packs Page."));
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_UNEXPECTED_ERROR_ENCOUNTERED_NORC));
        SafeModeExceptionOccured ();
        pAbortSetup (hdlg);
    }

    return FALSE;
}


typedef struct {
    INT     TotalWidth;
    INT     CategoryWidth;
    INT     CurrentNameWidth;
    INT     NewNameWidth;
} LISTMETRICS, *PLISTMETRICS;


VOID
pUpdateNameCollisionListBox (
    IN      HWND List,
    OUT     PLISTMETRICS ListMetrics            OPTIONAL
    )

/*++

Routine Description:

  pUpdateNameCollisionListBox fills the specified list box with the all names
  that are going to change during the upgrade.


Arguments:

  List - Specifies the handle to the list box to fill.  This list box must
         have tabs enabled.

  ListMetrics - Receives the max width of the text in each column, plus the
                total list width

Return Value:

  none

--*/

{
    INT TopIndex;
    INT SelIndex;
    INT NewIndex;
    INVALID_NAME_ENUM e;
    TCHAR ListLine[MEMDB_MAX];
    HDC hdc;
    RECT rect;
    SIZE size;
    TCHAR OriginalNameTrimmed[24 * 2];
    UINT OriginalNameLen;

    //
    // Obtain current positions if list is being refreshed
    //

    if (SendMessage (List, LB_GETCOUNT, 0, 0)) {
        TopIndex = (INT) SendMessage (List, LB_GETTOPINDEX, 0, 0);
        SelIndex = (INT) SendMessage (List, LB_GETCURSEL, 0, 0);
    } else {
        TopIndex = 0;
        SelIndex = -1;
    }

    //
    // If necessary, compute the tab positions
    //

    if (ListMetrics) {
        hdc = GetDC (List);
        if (hdc) {
            SelectObject (hdc, (HFONT) SendMessage (List, WM_GETFONT, 0, 0));
        }
        ListMetrics->CategoryWidth = 0;
        ListMetrics->CurrentNameWidth = 0;
        ListMetrics->NewNameWidth = 0;

        GetClientRect (List, &rect);
        ListMetrics->TotalWidth = rect.right - rect.left;
    } else {
        hdc = NULL;
    }

    //
    // Reset the content and refill the list
    //

    SendMessage (List, WM_SETREDRAW, FALSE, 0);
    SendMessage (List, LB_RESETCONTENT, 0, 0);

    if (EnumFirstInvalidName (&e)) {
        do {
            //
            // Trim the original name to 20 characters
            //

            _tcssafecpy (OriginalNameTrimmed, e.OriginalName, 20);
            OriginalNameLen = CharCount (OriginalNameTrimmed);
            if (OriginalNameLen < CharCount (e.OriginalName)) {
                StringCat (OriginalNameTrimmed, TEXT("..."));
                OriginalNameLen += 3;
            }

            //
            // If necessary, compute size of text
            //

            if (hdc) {
                GetTextExtentPoint32 (hdc, e.DisplayGroupName, CharCount (e.DisplayGroupName), &size);
                ListMetrics->CategoryWidth = max (ListMetrics->CategoryWidth, size.cx);

                GetTextExtentPoint32 (hdc, OriginalNameTrimmed, OriginalNameLen, &size);
                ListMetrics->CurrentNameWidth = max (ListMetrics->CurrentNameWidth, size.cx);

                GetTextExtentPoint32 (hdc, e.NewName, CharCount (e.NewName), &size);
                ListMetrics->NewNameWidth = max (ListMetrics->NewNameWidth, size.cx);
            }

            //
            // Fill the list box
            //

            wsprintf (ListLine, TEXT("%s\t%s\t%s"), e.DisplayGroupName, OriginalNameTrimmed, e.NewName);

            NewIndex = SendMessage (List, LB_ADDSTRING, 0, (LPARAM) ListLine);
            SendMessage (List, LB_SETITEMDATA, NewIndex, e.Identifier);

        } while (EnumNextInvalidName (&e));
    }

    //
    // Restore current positions
    //

    SendMessage (List, LB_SETTOPINDEX, (WPARAM) TopIndex, 0);
    SendMessage (List, LB_SETCURSEL, (WPARAM) SelIndex, 0);
    SendMessage (List, WM_SETREDRAW, TRUE, 0);

    //
    // Clean up device context
    //

    if (hdc) {
        ReleaseDC (List, hdc);
    }
}


INT
pGetDialogBaseUnitsX (
    HWND hdlg
    )
{
    HDC hdc;
    static BOOL AlreadyComputed;
    static INT LastBaseUnits;
    SIZE size;

    if (AlreadyComputed) {
        return LastBaseUnits;
    }

    hdc = GetDC (hdlg);
    if (!hdc) {
        DEBUGMSG ((DBG_WHOOPS, "pGetDialogBaseUnitsX: Cannot get hdc from dialog handle"));
        return GetDialogBaseUnits();
    }

    SelectObject (hdc, (HFONT) SendMessage (hdlg, WM_GETFONT, 0, 0));
    GetTextExtentPoint32 (hdc, TEXT("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"), 52, &size);
    LastBaseUnits = (size.cx / 26 + 1) / 2;

    AlreadyComputed = TRUE;

    return LastBaseUnits;
}


INT
pPixelToDialogHorz (
    HWND hdlg,
    INT Pixels
    )
{
    return (Pixels * 4) / pGetDialogBaseUnitsX (hdlg);
}


INT
pDialogToPixelHorz (
    HWND hdlg,
    INT DlgUnits
    )
{
    return (DlgUnits * pGetDialogBaseUnitsX (hdlg)) / 4;
}


VOID
pGetChildWindowRect (
    IN      HWND hwnd,
    OUT     PRECT rect
    )
{
    RECT ParentRect, ChildRect;
    HWND hdlg;

    hdlg = GetParent(hwnd);

    GetWindowRect (hwnd, &ChildRect);
    GetClientRect (hdlg, &ParentRect);
    ClientToScreen (hdlg, (PPOINT) &ParentRect);
    ClientToScreen (hdlg, ((PPOINT) &ParentRect) + 1);

    rect->left   = ChildRect.left - ParentRect.left;
    rect->top    = ChildRect.top - ParentRect.top;
    rect->right  = ChildRect.right - ParentRect.right;
    rect->bottom = ChildRect.bottom - ParentRect.bottom;
}


BOOL
pIsMsRedirectorInstalled (
    VOID
    )
{
    HKEY Key;
    BOOL b = FALSE;

    Key = OpenRegKeyStr (TEXT("HKLM\\System\\CurrentControlSet\\Services\\MSNP32\\NetworkProvider"));

    if (Key) {

        b = TRUE;
        CloseRegKey (Key);
    }

    return b;
}


VOID
pSanitizeHelpText (
    HWND TextViewCtrl,
    PCTSTR Text
    )
{
    PTSTR FixedText;
    PCTSTR p;
    PCTSTR p2;
    PCTSTR End;
    PTSTR q;
    BOOL FindClose = FALSE;
    BOOL RequireEnd;

    FixedText = AllocText (SizeOfString (Text));

    p = Text;
    q = FixedText;
    End = GetEndOfString (p);

    while (p < End) {
        if (FindClose) {
            if (_tcsnextc (p) == TEXT('>')) {
                FindClose = FALSE;
            }
        } else {

            //
            // Allow only <A ...>, <B> and <P> tags, or any </xxx> tag
            //

            if (_tcsnextc (p) == TEXT('<')) {

                p2 = SkipSpace (_tcsinc (p));
                RequireEnd = FALSE;

                switch (_totlower (_tcsnextc (p2))) {

                case TEXT('b'):
                case TEXT('p'):
                    //
                    // Require close bracket
                    //

                    p2 = SkipSpace (_tcsinc (p2));
                    if (_tcsnextc (p2) != TEXT('>')) {
                        FindClose = TRUE;
                    }
                    break;

                case TEXT('a'):
                    //
                    // Require space after A.  Control will figure out
                    // if the anchor is valid or not.
                    //

                    p2 = _tcsinc (p2);
                    if (!_istspace (_tcsnextc (p2))) {
                        FindClose = TRUE;
                    }

                    RequireEnd = TRUE;
                    break;

                case TEXT('/'):
                    //
                    // Don't care about this
                    //

                    RequireEnd = TRUE;
                    break;

                default:
                    //
                    // Unsupported tag, or at least one we don't want
                    // used.
                    //

                    FindClose = TRUE;
                    break;
                }

                if (RequireEnd) {
                    while (p2 < End) {
                        if (_tcsnextc (p2) == TEXT('>')) {
                            break;
                        }

                        p2 = _tcsinc (p2);
                    }

                    if (p2 >= End) {
                        FindClose = TRUE;
                    }
                }

                if (FindClose) {
                    //
                    // We just went into the mode where we have to
                    // skip the tag.  So continue without incrementing.
                    //

                    continue;
                }
            }

            //
            // Good character -- copy it
            //

            _copytchar (q, p);
            q = _tcsinc (q);
        }

        p = _tcsinc (p);
    }

    *q = 0;
    SetWindowText (TextViewCtrl, FixedText);

    FreeText (FixedText);
}



VOID
pFillDomainHelpText (
    HWND TextViewCtrl
    )
{
    HINF Inf;
    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;
    PCTSTR Str;
    BOOL Filled = FALSE;

    __try {
        //
        // If unattend or command line switch specified, use it
        //

        if (g_ConfigOptions.DomainJoinText) {
            if (*g_ConfigOptions.DomainJoinText) {
                pSanitizeHelpText (TextViewCtrl, g_ConfigOptions.DomainJoinText);
                Filled = TRUE;
                __leave;
            }
        }

        //
        // Try opening INF in source directory.  If it does not exist,
        // try %windir%\INF dir.
        //

        Inf = InfOpenInfInAllSources (S_OPTIONS_INF);

        if (Inf == INVALID_HANDLE_VALUE) {
            Inf = InfOpenInfFile (S_OPTIONS_INF);
        }

        if (Inf != INVALID_HANDLE_VALUE) {

            //
            // Get the alternate text
            //

            if (InfFindFirstLine (Inf, TEXT("Wizard"), TEXT("DomainJoinText"), &is)) {
                Str = InfGetLineText (&is);
                if (Str && *Str) {
                    pSanitizeHelpText (TextViewCtrl, Str);
                    Filled = TRUE;
                }
            }

            InfCleanUpInfStruct (&is);
            InfCloseInfFile (Inf);
        }
    }
    __finally {
        if (!Filled) {
            Str = GetStringResource (MSG_DOMAIN_HELP);
            MYASSERT (Str);

            if (Str) {
                pSanitizeHelpText (TextViewCtrl, Str);
            }
        }
    }
}


BOOL
UI_PreDomainPageProc (
    IN      HWND hdlg,
    IN      UINT uMsg,
    IN      WPARAM wParam,
    IN      LPARAM lParam
    )

/*++

Routine Description:

  UI_PreDomainPageProc implements a wizard page that:

  (A) Alerts the user that they need a computer account to participate on
      a domain with Windows NT

  (B) Offers them an ability to skip joining a domain, and go into
      workgroup mode.

  Before showing this page, we check to see if the Workgroup setting
  already has the correct domain name in it.

Arguments:

  hdlg - Handle to the wizard page; its parent is the wizard frame

  uMsg - Message to process

  wParam - Message data

  lParam - Message data

Return Value:

  TRUE if the message was handled, or FALSE if not.

  Exception:
    WMX_ACTIVATEPAGE - If called for activation, return of FALSE causes the
                       page to be skipped; TRUE causes page to be processed.

                       If called for deactivation, return of FALSE causes the
                       page not to be deactivated; TRUE causes page to be
                       deactivated.

--*/

{
    TCHAR ComputerName[MAX_COMPUTER_NAME + 1];
    static BOOL Initialized = FALSE;
    LONG rc;
    static CREDENTIALS Credentials;
    PCTSTR ArgArray[1];

    __try {
        switch (uMsg) {

        case WMX_ACTIVATEPAGE:
            if (wParam) {
                if (!UPGRADE() || CANCELLED() || g_DomainSkipped) {
                    return FALSE;
                }

                //
                // Personal upgrades go to workgroup.
                // (regardless if unattended or not...)
                //
                if (*g_ProductFlavor == PERSONAL_PRODUCTTYPE)
                {
                    g_ConfigOptions.ForceWorkgroup = TRUE;
                }

                //
                // If unattended mode, the user must generate a computer account themselves,
                // or already have it generated by an administrator.  We cannot provide UI
                // to resolve this issue.
                //

                if (UNATTENDED() || REPORTONLY()) {
                    g_DomainSkipped = TRUE;
                    return FALSE;
                }

                //
                // If force workgroup mode specified via answer file, skip this page
                //

                if (g_ConfigOptions.ForceWorkgroup && !Initialized) {
                    g_DomainSkipped = TRUE;
                    return FALSE;
                }

                //
                // let this page be visible even on typical upgrade cases
                //
#if 0
                if(TYPICAL())
                {
                    g_DomainSkipped = TRUE;
                    return FALSE;
                }
#endif
                //
                // Validate the domain name in Workgroup
                //

                DEBUGLOGTIME(("Pre-domain resolution page..."));

                if (!GetUpgradeComputerName (ComputerName)) {
                    g_DomainSkipped = TRUE;
                    return FALSE;
                }

                if (!Initialized) {
                    //
                    // Put all the in-use names (user names, comptuer name, etc)
                    // in memdb
                    //

                    CreateNameTables();

                    //
                    // Check for a computer that is offline
                    //

                    g_Offline |= IsComputerOffline();
                }

                if (!GetUpgradeDomainName (Credentials.DomainName) ||
#if 0
                    IsOriginalDomainNameValid() ||
#endif
                    !pIsMsRedirectorInstalled()
                    ) {

                    //
                    // Domain logon is not enabled or is valid
                    //

                    Initialized = TRUE;
                    g_DomainSkipped = TRUE;
                    return FALSE;
                }

                if (!Initialized) {
                    Initialized = TRUE;

                    if (g_Offline) {
                        g_ConfigOptions.ForceWorkgroup = TRUE;
                        g_DomainSkipped = TRUE;
                        return FALSE;
                    }
#if 0
                    rc = DoesComputerAccountExistOnDomain (Credentials.DomainName, ComputerName, TRUE);
                    if (rc == 1) {
                        //
                        // There is already an account for this computer on the user domain.
                        //

                        ChangeName (GetDomainIdentifier(), Credentials.DomainName);
                        g_DomainSkipped = TRUE;
                        return FALSE;
                    }
#endif
                    //
                    // We have now determined that there is no account for the computer.
                    // Initialize the wizard page controls.
                    //

                    ArgArray[0] = Credentials.DomainName;

                    //ParseMessageInWnd (GetDlgItem (hdlg, IDC_TEXT2), ArgArray);
                    //ParseMessageInWnd (GetDlgItem (hdlg, IDC_TEXT3), ArgArray);

                    CheckDlgButton (hdlg, IsComputerOffline() ? IDC_JOIN_WORKGROUP : IDC_JOIN_DOMAIN, BST_CHECKED);
                }

                // Stop the bill board and make sure the wizard shows again.
                SendMessage(GetParent (hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);
                //
                // On activate, turn on next and back
                //
                PropSheet_SetWizButtons (GetParent(hdlg), PSWIZB_NEXT);

            } else {
                if (!UPGRADE() || CANCELLED() || UNATTENDED() || lParam == PSN_WIZBACK) {
                    return TRUE;
                }

                //
                // Force workgroup?
                //

                if (IsDlgButtonChecked (hdlg, IDC_JOIN_DOMAIN) == BST_CHECKED) {

                    g_ConfigOptions.ForceWorkgroup = FALSE;
                    g_Offline = FALSE;

                } else {

                    g_ConfigOptions.ForceWorkgroup = TRUE;
                    g_Offline = TRUE;

                }

                DEBUGLOGTIME(("Pre-domain resolution page done."));
            }

            return TRUE;
        }
    } __except (1) {

        LOG ((LOG_WARNING, "An unhandled exception occurred during the processing of the Pre-Domain Page."));
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_UNEXPECTED_ERROR_ENCOUNTERED_NORC));
        SafeModeExceptionOccured ();
        pAbortSetup (hdlg);
    }

    return FALSE;
}


BOOL
UI_DomainPageProc (
    IN      HWND hdlg,
    IN      UINT uMsg,
    IN      WPARAM wParam,
    IN      LPARAM lParam
    )

/*++

Routine Description:

  UI_DomainPageProc implements a wizard page that:

  (A) Asks to select find an existing computer account, or to provide
      information to create a computer account.

  (B) Offers them an ability to enter the credentials to create an account,
      or provide the name of a domain that has an account.

  Before showing this page, we verify it is supposed to show up by
  checking several special conditions where the page is not necessary.

Arguments:

  hdlg - Handle to the wizard page; its parent is the wizard frame

  uMsg - Message to process

  wParam - Message data

  lParam - Message data

Return Value:

  TRUE if the message was handled, or FALSE if not.

  Exception:
    WMX_ACTIVATEPAGE - If called for activation, return of FALSE causes the
                       page to be skipped; TRUE causes page to be processed.

                       If called for deactivation, return of FALSE causes the
                       page not to be deactivated; TRUE causes page to be
                       deactivated.

--*/

{
    TCHAR ComputerName[MAX_COMPUTER_NAME + 1];
    static BOOL Initialized = FALSE;
    static BOOL Skipped = FALSE;
    LONG rc;
    static CREDENTIALS Credentials;
    BOOL createAccount;
    PCTSTR ArgArray[1];

    __try {
        switch (uMsg) {

        case WMX_ACTIVATEPAGE:
            if (wParam) {
                if (!UPGRADE() || CANCELLED() || Skipped || g_DomainSkipped) {
                    return FALSE;
                }

                //
                // If unattended mode, the user must generate a computer account themselves,
                // or already have it generated by an administrator.  We cannot provide UI
                // to resolve this issue.
                //

                if (UNATTENDED() || REPORTONLY()) {
                    Skipped = TRUE;
                    return FALSE;
                }

                //
                // If computer is offline, skip this page
                //

                if (g_Offline) {
                    //
                    // The offline state can change depending on the
                    // use of back/next.
                    //

                    return FALSE;
                }

                //
                // Validate the domain name in Workgroup
                //

                DEBUGLOGTIME(("Domain resolution page..."));

                if (!GetUpgradeComputerName (ComputerName)) {
                    Skipped = TRUE;
                    return FALSE;
                }

                SetDlgItemText (hdlg, IDC_COMPUTER_NAME, ComputerName);

                if (!GetUpgradeDomainName (Credentials.DomainName)) {

                    //
                    // Domain logon is not enabled or is valid
                    //

                    Initialized = TRUE;
                    Skipped = TRUE;
                    return FALSE;
                }

                if (!Initialized) {
                    Initialized = TRUE;

                    //
                    // We have now determined that there is no account for the computer.
                    // Initialize the wizard page controls.
                    //

                    SendMessage (GetDlgItem (hdlg, IDC_DOMAIN), EM_LIMITTEXT, MAX_COMPUTER_NAME, 0);
                    //SetDlgItemText (hdlg, IDC_DOMAIN, Credentials.DomainName);

                    ArgArray[0] = ComputerName;
                    //ParseMessageInWnd (GetDlgItem (hdlg, IDC_SPECIFY_DOMAIN), ArgArray);

                    CheckDlgButton (hdlg, IDC_SPECIFY_DOMAIN, BST_CHECKED);
                    SetDlgItemText (hdlg, IDC_DOMAIN, Credentials.DomainName);
                    //CheckDlgButton (hdlg, IDC_IGNORE, BST_UNCHECKED);
                    CheckDlgButton (hdlg, IDC_SKIP, BST_UNCHECKED);

                    pFillDomainHelpText (GetDlgItem (hdlg, IDC_DOMAIN_HELP));
                }

                //
                // On activate, turn on next and back
                //

                PropSheet_SetWizButtons (GetParent(hdlg), PSWIZB_NEXT|PSWIZB_BACK);

            } else {
                if (!UPGRADE() || CANCELLED() || UNATTENDED() || lParam == PSN_WIZBACK) {
                    return TRUE;
                }

                EnableDomainChecks();
                g_ConfigOptions.ForceWorkgroup = FALSE;

                if (IsDlgButtonChecked (hdlg, IDC_SKIP) == BST_CHECKED) {
                    DisableDomainChecks();
                    g_ConfigOptions.ForceWorkgroup = TRUE;
                }

                GetDlgItemText (hdlg, IDC_COMPUTER_NAME, ComputerName, sizeof (ComputerName) / sizeof (ComputerName[0]));
                GetDlgItemText (hdlg, IDC_DOMAIN, Credentials.DomainName, sizeof (Credentials.DomainName) / sizeof (Credentials.DomainName[0]));

                //
                // Use hardcoded domain?
                //

                createAccount = FALSE;

                if (IsDlgButtonChecked (hdlg, IDC_SPECIFY_DOMAIN) == BST_CHECKED) {

                    if (*Credentials.DomainName) {
                        rc = DoesComputerAccountExistOnDomain (Credentials.DomainName, ComputerName, TRUE);
                    } else {
                        OkBox (hdlg, MSG_PLEASE_SPECIFY_A_DOMAIN);
                        SetFocus (GetDlgItem (hdlg, IDC_DOMAIN));
                        return FALSE;
                    }

                    if (rc == -1) {
                        //
                        // The user specified a bogus domain
                        //

                        OkBox (hdlg, MSG_DOMAIN_NOT_RESPONDING_POPUP);
                        SetFocus (GetDlgItem (hdlg, IDC_DOMAIN));
                        return FALSE;

                    } else if (rc == 0) {
                        //
                        // Account does not exist on specified domain
                        //

                        if (IDYES == YesNoBox (hdlg, MSG_ACCOUNT_NOT_FOUND_POPUP)) {
                            createAccount = TRUE;
                        } else {
                            SetFocus (GetDlgItem (hdlg, IDC_DOMAIN));
                            return FALSE;
                        }

                    } else {
                        //
                        // Domain is valid and account exists, use it.
                        //

                        ChangeName (GetDomainIdentifier(), Credentials.DomainName);
                    }
                }

                //
                // Display credentials dialog
                //

                //if (IsDlgButtonChecked (hdlg, IDC_IGNORE) == BST_CHECKED) {
                if (createAccount) {

                    TCHAR owfPwd[STRING_ENCODED_PASSWORD_SIZE];
                    PCTSTR encrypted;

                    EnableDomainChecks();

                    if (!CredentialsDlg (hdlg, &Credentials)) {
                        return FALSE;
                    }

                    DisableDomainChecks();

                    MYASSERT (*Credentials.DomainName);

                    if (GetDomainIdentifier()) {
                        ChangeName (GetDomainIdentifier(), Credentials.DomainName);
                    }

                    if (*Credentials.AdminName) {
                        if (g_ConfigOptions.EnableEncryption) {
                            StringEncodeOwfPassword (Credentials.Password, owfPwd, NULL);
                            encrypted = WINNT_A_YES;
                        } else {
                            StringCopy (owfPwd, Credentials.Password);
                            encrypted = WINNT_A_NO;
                        }
                        WriteInfKey (S_PAGE_IDENTIFICATION, S_DOMAIN_ACCT_CREATE, WINNT_A_YES);
                        WriteInfKey (S_PAGE_IDENTIFICATION, S_DOMAIN_ADMIN, Credentials.AdminName);
                        WriteInfKey (S_PAGE_IDENTIFICATION, S_DOMAIN_ADMIN_PW, owfPwd);
                        WriteInfKey (S_PAGE_IDENTIFICATION, S_ENCRYPTED_DOMAIN_ADMIN_PW, encrypted);
                    }
                }

                DEBUGLOGTIME(("Domain resolution page done."));
            }

            return TRUE;

        case WM_COMMAND:
            switch (LOWORD (wParam)) {

            case IDC_DOMAIN:
                if (HIWORD (wParam) == EN_CHANGE) {
                    CheckDlgButton (hdlg, IDC_SPECIFY_DOMAIN, BST_CHECKED);
                    CheckDlgButton (hdlg, IDC_SKIP, BST_UNCHECKED);
                }
                break;

            case IDC_CHANGE:
                CredentialsDlg (hdlg, &Credentials);
                break;

            }
            break;
        }
    } __except (1) {

        LOG ((LOG_WARNING, "An unhandled exception occurred during the processing of the Domain Page."));
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_UNEXPECTED_ERROR_ENCOUNTERED_NORC));
        SafeModeExceptionOccured ();
        pAbortSetup (hdlg);
    }

    return FALSE;
}


BOOL
UI_NameCollisionPageProc (
    IN      HWND hdlg,
    IN      UINT uMsg,
    IN      WPARAM wParam,
    IN      LPARAM lParam
    )

/*++

Routine Description:

  NameCollisionPageProc presents a wizard page when one or more incompatible
  names are found on the Win9x machine.  Setup automatically generates
  replacement names, so this page is used to adjust what Setup comes up with.

  If there are no incompatible names found on the Win9x machine, or if
  Setup is in unattended mode, this page is skipped.

  The following names are tested:

    Computer Name - Must be alpha-numeric, or with dash or underscore.
                    Spaces are not permitted.

    Computer Domain - If machine is set to participate in an NT domain, then
                      Setup must guess at what the correct computer domain
                      is, since Win9x does not enforce this name.

    User Names - Setup checks each user name to make sure it is valid.   Most
                 of the problems are conflicts with NT group names, such as
                 Guests.


Arguments:

  hdlg - Handle to the wizard page; its parent is the wizard frame

  uMsg - Message to process

  wParam - Message data

  lParam - Message data

Return Value:

  TRUE if the message was handled, or FALSE if not.

  Exception:
    WMX_ACTIVATEPAGE - If called for activation, return of FALSE causes the
                       page to be skipped; TRUE causes page to be processed.

                       If called for deactivation, return of FALSE causes the
                       page not to be deactivated; TRUE causes page to be
                       deactivated.

--*/

{
    static BOOL Initialized = FALSE;
    static BOOL Skipped = FALSE;
    static HWND List;
    INT Index;
    DWORD Identifier;
    TCHAR NameGroup[MEMDB_MAX];
    TCHAR OrgName[MEMDB_MAX];
    TCHAR NewName[MEMDB_MAX];
    LISTMETRICS ListMetrics;
    INT Tabs[2];
    RECT CategoryRect, CurrentNameRect, NewNameRect;
    INT PixelSpace;
    INT MaxWidth;
    INT MaxColWidth;

    __try {
        switch (uMsg) {

        case WMX_ACTIVATEPAGE:
            if (wParam) {
                if (!UPGRADE() || CANCELLED() || Skipped) {
                    return FALSE;
                }

                DEBUGLOGTIME(("Name collision page..."));

                //
                // Determine if there are any incompatible names on the machine
                //

                List = GetDlgItem (hdlg, IDC_NAME_LIST);

                if (!Initialized) {
                    CreateNameTables();
                }

                //
                // Skip this page in unattended mode.  Also skip this page if there are
                // no incompatible names.
                //
                if (UNATTENDED() || IsIncompatibleNamesTableEmpty() || REPORTONLY()) {
                    DEBUGMSG_IF ((IsIncompatibleNamesTableEmpty(), DBG_VERBOSE, "No incompatible names"));
                    Initialized = TRUE;
                    Skipped = TRUE;

                    //
                    // This is a workaround for a Win95 Gold bug
                    //

                    if (ISWIN95_GOLDEN()) {
                        PostMessage (hdlg, WMX_WIN95_WORKAROUND, 0, 0);
                        return TRUE;
                    } else {
                        return FALSE;
                    }
                }

                if (!Initialized) {
                    //
                    // Initialize list box
                    //

                    pUpdateNameCollisionListBox (List, &ListMetrics);

                    //
                    // Set tab stops
                    //

                    PixelSpace = pDialogToPixelHorz (hdlg, 8);
                    ListMetrics.CategoryWidth += PixelSpace;
                    ListMetrics.CurrentNameWidth += PixelSpace;

                    MaxWidth = ListMetrics.CategoryWidth +
                               ListMetrics.CurrentNameWidth +
                               ListMetrics.NewNameWidth;

                    MaxColWidth = max (ListMetrics.CategoryWidth, ListMetrics.CurrentNameWidth);
                    MaxColWidth = max (MaxColWidth, ListMetrics.NewNameWidth);

                    DEBUGMSG_IF ((
                        MaxWidth > ListMetrics.TotalWidth,
                        DBG_WHOOPS,
                        "NameCollisionPage: Text got truncated"
                        ));

                    Tabs[0] = ListMetrics.TotalWidth / 3;

                    if (Tabs[0] < MaxColWidth) {
                        Tabs[0] = pPixelToDialogHorz (hdlg, ListMetrics.CategoryWidth);
                        Tabs[1] = pPixelToDialogHorz (hdlg, ListMetrics.CurrentNameWidth) + Tabs[0];
                    } else {
                        Tabs[0] = pPixelToDialogHorz (hdlg, Tabs[0]);
                        Tabs[1] = Tabs[0] * 2;
                    }

                    SendMessage (List, LB_SETTABSTOPS, 2, (LPARAM) Tabs);

                    //
                    // Adjust titles
                    //

                    pGetChildWindowRect (GetDlgItem (hdlg, IDC_CATEGORY), &CategoryRect);
                    pGetChildWindowRect (GetDlgItem (hdlg, IDC_CURRENTNAME), &CurrentNameRect);
                    pGetChildWindowRect (GetDlgItem (hdlg, IDC_NEWNAME), &NewNameRect);

                    CurrentNameRect.left = CategoryRect.left + pDialogToPixelHorz (hdlg, Tabs[0]);
                    NewNameRect.left     = CategoryRect.left + pDialogToPixelHorz (hdlg, Tabs[1]);

                    SetWindowPos (
                        GetDlgItem (hdlg, IDC_CURRENTNAME),
                        NULL,
                        CurrentNameRect.left,
                        CurrentNameRect.top,
                        0,
                        0,
                        SWP_NOSIZE|SWP_NOZORDER
                        );

                    SetWindowPos (
                        GetDlgItem (hdlg, IDC_NEWNAME),
                        NULL,
                        NewNameRect.left,
                        NewNameRect.top,
                        0,
                        0,
                        SWP_NOSIZE|SWP_NOZORDER
                        );

                    EnableDlgItem (hdlg, IDC_CHANGE, FALSE, IDC_NAME_LIST);
                } else {
                    pUpdateNameCollisionListBox (List, &ListMetrics);
                }

                //
                // On activate, turn on next and back
                //

                PropSheet_SetWizButtons (GetParent(hdlg), PSWIZB_NEXT);
                Initialized = TRUE;

                // Stop the bill board and make sure the wizard shows again.
                SendMessage(GetParent (hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);


            } else {
                if (!CANCELLED() && (lParam != PSN_WIZBACK && !WarnAboutBadNames (hdlg))) {
                    return FALSE;
                }

                DEBUGLOGTIME(("Name collision page done."));
            }

            return TRUE;

        case WMX_WIN95_WORKAROUND:
            PostMessage (GetParent (hdlg), PSM_PRESSBUTTON, PSBTN_NEXT, 0);
            return TRUE;

        case WM_COMMAND:
            switch (LOWORD (wParam)) {

            case IDC_NAME_LIST:
                switch (HIWORD (wParam)) {
                case LBN_SELCHANGE:
                    EnableDlgItem (hdlg, IDC_CHANGE, TRUE, IDC_NAME_LIST);
                    return TRUE;

                case LBN_DBLCLK:
                    PostMessage (
                        hdlg,
                        WM_COMMAND,
                        MAKELPARAM (IDC_CHANGE, BN_CLICKED),
                        (LPARAM) GetDlgItem (hdlg, IDC_CHANGE)
                        );
                    return TRUE;
                }
                break;

            case IDC_CHANGE:
                if (HIWORD (wParam) == BN_CLICKED) {
                    //
                    // Get memdb offset stored with list item.
                    //

                    Index = (INT) SendMessage (List, LB_GETCURSEL, 0, 0);
                    MYASSERT (Index != LB_ERR);
                    Identifier = (DWORD) SendMessage (List, LB_GETITEMDATA, (WPARAM) Index, 0);
                    MYASSERT (Identifier != LB_ERR);

                    //
                    // Generate names.  The original name's value points to the new name.
                    //

                    GetNamesFromIdentifier (Identifier, NameGroup, OrgName, NewName);

                    //
                    // Now call dialog to allow the name change
                    //

                    if (ChangeNameDlg (hdlg, NameGroup, OrgName, NewName)) {
                        //
                        // The user has chosen to change the name.
                        //

                        ChangeName (Identifier, NewName);

                        pUpdateNameCollisionListBox (List, NULL);
                    }
                }
                return TRUE;
            }
            break;
        }
    } __except (1) {

        LOG ((LOG_WARNING, "An unhandled exception occurred during the processing of the Name Collision Page."));
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_UNEXPECTED_ERROR_ENCOUNTERED_NORC));
        SafeModeExceptionOccured ();
        pAbortSetup (hdlg);
    }
    return FALSE;
}


BOOL
UI_ScanningPageProc (
    IN      HWND hdlg,
    IN      UINT uMsg,
    IN      WPARAM wParam,
    IN      LPARAM lParam
    )

/*++

Routine Description:

  ScanningPageProc initialiizes the progress bar, starts the report building
  thread, and automatically advances to the next page when the thread completes.

Arguments:

  hdlg - Handle to the wizard page; its parent is the wizard frame

  uMsg - Message to process

  wParam - Message data

  lParam - Message data

Return Value:

  TRUE if the message was handled, or FALSE if not.

  Exception:
    WMX_ACTIVATEPAGE - If called for activation, return of FALSE causes the
                       page to be skipped; TRUE causes page to be processed.

                       If called for deactivation, return of FALSE causes the
                       page not to be deactivated; TRUE causes page to be
                       deactivated.

--*/

{
    DWORD dwThreadId;
    PCTSTR ArgArray[1];
    static BOOL InitSent = FALSE;

    __try {
        switch (uMsg) {

        case WMX_INIT_DIALOG:
            g_WorkerThreadHandle = NULL;
            return TRUE;

        case WMX_ACTIVATEPAGE:
            if (wParam) {
                if (!UPGRADE() || CANCELLED()) {
                    return FALSE;
                }

                if (!InitSent) {
                    SendMessage (hdlg, WMX_INIT_DIALOG, 0, 0);
                    InitSent = TRUE;
                }

                g_Winnt32Wnd = GetParent (hdlg);

                //
                // Block upgrades of Server
                //

                // enable the billboard text if we can.
                // If we could, hide the wizard.
                //
                SendMessage(GetParent (hdlg), WMX_BBTEXT, (WPARAM)TRUE, 0);
                if (*g_ProductType == NT_SERVER) {
                    ArgArray[0] = g_Win95Name;

                    ResourceMessageBox (
                        g_ParentWnd,
                        MSG_SERVER_UPGRADE_UNSUPPORTED_INIT,
                        MB_OK|MB_ICONSTOP|MB_SETFOREGROUND,
                        ArgArray
                        );

                    return pAbortSetup (hdlg);
                }

                DEBUGLOGTIME(("File System Scan Wizard Page..."));

                // Make sure background thread is done
                EndCopyThread();

                // On activate, disable next and back
                PropSheet_SetWizButtons (GetParent(hdlg), 0);
                PostMessage (hdlg, WMX_PAGE_VISIBLE, 0, 0);

                //
                // If ReportOnly mode, set a friendly message on this page.
                //
                if (g_ConfigOptions.ReportOnly) {
                    PCTSTR reportFileName;
                    PCTSTR Args[1];
                    PCTSTR string;

                    reportFileName = JoinPaths(g_WinDir,S_UPGRADETXT);
                    if (reportFileName) {

                        Args[0] = (g_ConfigOptions.SaveReportTo && *g_ConfigOptions.SaveReportTo) ? g_ConfigOptions.SaveReportTo : reportFileName;
                        string = ParseMessageID(MSG_BUILDING_REPORT_MESSAGE,Args);

                        if (string) {
                            SetWindowText(GetDlgItem(hdlg,IDC_REPORTNOTE),string);
                        }

                        FreePathString(reportFileName);

                    }
                    ELSE_DEBUGMSG((DBG_ERROR,"Not even enough memory for a simple join paths..not good."));
                }


            } else {
                // On terminate, save state
                if (!CANCELLED() && !REPORTONLY()) {
                    MemDbSetValue (
                        MEMDB_CATEGORY_STATE TEXT("\\") MEMDB_ITEM_MASTER_SEQUENCER,
                        g_MasterSequencer
                        );

                    if (!MemDbSave (UI_GetMemDbDat())) {
                        pAbortSetup (hdlg);
                    }
                }
            }

            return TRUE;

        case WMX_PAGE_VISIBLE:

    #ifdef PRERELEASE
            //
            // If autostress option enabled, provide dialog
            //

            if (g_ConfigOptions.AutoStress) {
                g_AutoStressHandle = CreateThread (
                                        NULL,
                                        0,
                                        DoAutoStressDlg,
                                        NULL,
                                        0,
                                        &dwThreadId
                                        );
            }
    #endif

            SendMessage(GetParent (hdlg), WMX_BB_ADVANCE_SETUPPHASE, 0, 0);

            // Estimate time required
            UpdateWindow (GetParent (hdlg)); // make sure page is fully painted
            OldProgressProc = (WNDPROC)SetWindowLongPtr(GetDlgItem(hdlg, IDC_PROGRESS),GWLP_WNDPROC,(LONG_PTR)NewProgessProc);
            SetupBBProgressText(hdlg, MSG_UPGRADEREPORT_TEXT);
            SendMessage(GetParent(hdlg), WMX_BBPROGRESSGAUGE, SW_SHOW, 0);
            // Create thread that does the work
            g_WorkerThreadHandle = CreateThread (NULL,
                                                0,
                                                UI_ReportThread,
                                                (PVOID) hdlg,
                                                0,
                                                &dwThreadId
                                                );
            break;

        case WMX_REPORT_COMPLETE:

    #ifdef PRERELEASE
            if (g_AutoStressHandle) {
                if (WaitForSingleObject (g_AutoStressHandle, 10) != WAIT_OBJECT_0) {
                    PostMessage (hdlg, uMsg, wParam, lParam);
                    break;
                }

                CloseHandle (g_AutoStressHandle);
            }
    #endif
            SendMessage(GetParent(hdlg),WMX_SETPROGRESSTEXT,0,0);
            SendMessage(GetParent(hdlg), WMX_BBPROGRESSGAUGE, SW_HIDE, 0);
            SetWindowLongPtr(GetDlgItem(hdlg, IDC_PROGRESS),GWLP_WNDPROC,(LONG_PTR)OldProgressProc );
            if (g_WorkerThreadHandle != NULL) {
                CloseHandle (g_WorkerThreadHandle);
                g_WorkerThreadHandle = NULL;
            }

            if (lParam != ERROR_SUCCESS) {
                // For errors, cancel WINNT32
                if (lParam != ERROR_CANCELLED) {
                    LOG ((LOG_ERROR, "Thread running Winnt32 report failed."));
                }
                return pAbortSetup (hdlg);
            }
            else {
                // Automatically move to the next wizard page when done
                PropSheet_PressButton (GetParent (hdlg), PSBTN_NEXT);
            }

            break;
        }
    } __except (1) {

        LOG ((LOG_WARNING, "An unhandled exception occurred during the processing of the Scanning Page."));
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_UNEXPECTED_ERROR_ENCOUNTERED_NORC));
        SafeModeExceptionOccured ();
        pAbortSetup (hdlg);
    }

    return FALSE;
}

BOOL
pFillListControl (
    IN      HWND ListHandle,
    OUT     PDWORD SeverityLevel            OPTIONAL
    )

/*++

Routine Description:

  pFillListControl enumerates all the incompatibility messages and
  fills the message group list box with the root-level components.

Arguments:

  List - Specifies the list to receive the message group list
  SeverityLevel - Receives an array of REPORTLEVEL_* bits reflecting listview content

Return Value:

  Returns TRUE if at least one item was added, or FALSE if no items were added.

--*/

{
    LISTREPORTENTRY_ENUM e;
    UINT iBullet, iBlocking, iIncompHw, iWarning, iReinstall;
    UINT count = 0;
    PCTSTR listEntries;
    DWORD lowestLevel;
    PCTSTR text;

    SendMessage (ListHandle, LB_RESETCONTENT, 0, 0);

    lowestLevel = (g_ConfigOptions.ShowReport == TRISTATE_PARTIAL) ? REPORTLEVEL_ERROR : REPORTLEVEL_INFORMATION;

    listEntries = CreateReportText (
                    FALSE,
                    0,
                    lowestLevel,
                    TRUE
                    );

    if (SeverityLevel) {
        *SeverityLevel = REPORTLEVEL_NONE;
    }

    if (EnumFirstListEntry (&e, listEntries)) {

        HIMAGELIST hIml;
        LV_COLUMN lvc = {0};
        LV_ITEM lvi = {0};
        RECT rect;
        SIZE size;
        DWORD max = 0;
        DWORD cxIcon = GetSystemMetrics (SM_CXSMICON);
        DWORD dwExtra = IMAGE_INDENT + cxIcon + TEXT_INDENT;
        HDC hdc = GetDC (ListHandle);
        HFONT font = GetStockObject (DEFAULT_GUI_FONT);
        HFONT prevFont = NULL;
        HFONT boldFont = NULL;
        LOGFONT lf;

        if (font) {
            GetObject (font, sizeof (lf), &lf);
            lf.lfWeight += FW_BOLD - FW_NORMAL;
            boldFont = CreateFontIndirect (&lf);
        }

#ifdef LIST_BKGND_BTNFACE_COLOR
        ListView_SetBkColor (ListHandle, GetSysColor (COLOR_BTNFACE));
#endif
        GetClientRect (ListHandle, &rect);
        lvc.mask = LVCF_WIDTH;
        lvc.cx = rect.right - rect.left - dwExtra;
        ListView_InsertColumn (ListHandle, 0, &lvc);

        hIml = ImageList_Create (
                    GetSystemMetrics (SM_CXSMICON),
                    GetSystemMetrics (SM_CYSMICON),
                    ILC_COLOR | ILC_MASK,
                    4,
                    1
                    );
        ListView_SetImageList (ListHandle, hIml, LVSIL_SMALL);
        iBullet = ImageList_AddIcon (hIml, LoadIcon (g_hInst, MAKEINTRESOURCE (IDI_BULLET)));
        iBlocking = ImageList_AddIcon (hIml, LoadIcon (NULL, IDI_ERROR));
        iIncompHw = ImageList_AddIcon (hIml, LoadIcon (g_hInst, MAKEINTRESOURCE (IDI_INCOMPHW)));
        iWarning = ImageList_AddIcon (hIml, LoadIcon (NULL, IDI_WARNING));
        iReinstall = ImageList_AddIcon (hIml, LoadIcon (g_hInst, MAKEINTRESOURCE(IDI_FLOPPY_INSTALL)));

        lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE | LVIF_INDENT;
        lvi.stateMask = 0;

        do {
            if (!e.Entry[0]) {
                continue;
            }

            lvi.pszText = (PTSTR)e.Entry;
            lvi.iItem = count;
            lvi.lParam = 0;
            if (e.Header) {
                lvi.iIndent = 0;
                switch (e.Level) {
                case REPORTLEVEL_INFORMATION:
                    lvi.iImage = iReinstall;
                    break;
                case REPORTLEVEL_WARNING:
                    lvi.iImage = iWarning;
                    break;
                case REPORTLEVEL_ERROR:
                    lvi.iImage = iIncompHw;
                    break;
                case REPORTLEVEL_BLOCKING:
                    lvi.iImage = iBlocking;
                    break;
                default:
                    MYASSERT (FALSE);
                    lvi.iImage = -1;
                    e.Level = REPORTLEVEL_NONE;
                }
                if (SeverityLevel) {
                    *SeverityLevel |= e.Level;
                }
                lvi.lParam |= LINEATTR_BOLD;
            } else {
                lvi.iIndent = 1;
                lvi.iImage = iBullet;
                lvi.lParam |= LINEATTR_INDENTED;
            }

            if (ListView_InsertItem (ListHandle, &lvi) != -1) {
                count++;

                if (font) {
                    if (lvi.lParam & LINEATTR_BOLD) {
                        //
                        // draw the text in bold
                        //
                        if (boldFont) {
                            prevFont = SelectObject (hdc, boldFont);
                        } else {
                            prevFont = SelectObject (hdc, font);
                        }
                    } else {
                        prevFont = SelectObject (hdc, font);
                    }
                }

                if (GetTextExtentPoint32 (hdc, e.Entry, lstrlen (e.Entry), &size)) {
                    DWORD width = lvi.iIndent * cxIcon + dwExtra + size.cx + TEXT_EXTRA_TAIL_SPACE;
                    if (max < width) {
                        max = width;
                    }
                }

                if (prevFont) {
                    SelectObject (hdc, prevFont);
                    prevFont = NULL;
                }
            }
        } while (EnumNextListEntry (&e));

        ReleaseDC (ListHandle, hdc);

        if (max > (DWORD)lvc.cx) {
            ListView_SetColumnWidth (ListHandle, 0, max);
        }
    }

    FreeReportText ();

    return count > 0;
}


DWORD
pReviewOrQuitMsgBox(
    IN  HWND    hDlg,
    IN  DWORD   dwMsgID
    )
{
    DWORD rc;
    PCTSTR button1;
    PCTSTR button2;
    PCTSTR message;

    button1 = GetStringResource (MSG_REVIEW_BUTTON);
    button2 = GetStringResource (MSG_QUIT_BUTTON);
    message = GetStringResource (dwMsgID);

    MYASSERT(message && button2 && button1);

    rc = TwoButtonBox (hDlg, message, button1, button2);

    FreeStringResource (button1);
    FreeStringResource (button2);
    FreeStringResource (message);

    return rc;
}

BOOL
pIsBlockingIssue(
    VOID
    )
{
    return (g_NotEnoughDiskSpace ||
            g_BlockingFileFound ||
            g_BlockingHardwareFound ||
            g_UnknownOs ||
            g_OtherOsExists);
}

BOOL
pShowNotEnoughSpaceMessage(
    IN  HWND hDlg
    )
{
    static bDetermineSpaceUsageReported = FALSE;

    if(REPORTONLY()){
        return TRUE;
    }

    if(!bDetermineSpaceUsageReported){
        bDetermineSpaceUsageReported = TRUE;
        DetermineSpaceUsagePostReport ();
        if(g_NotEnoughDiskSpace){
            if(!UNATTENDED()){
                if(GetNotEnoughSpaceMessage()){
                    DiskSpaceDlg(hDlg);
                }
                else{
                    MYASSERT (FALSE);
                }
            }
            LOG ((LOG_WARNING, "User cannot continue because there is not enough disk space."));
            return FALSE;
        }
    }

    return TRUE;
}

BOOL
pDoPostReportProcessing (
    HWND hdlg,
    HWND UiTextViewCtrl,
    BOOL WarningGiven,
    PBOOL TurnOffUnattend   OPTIONAL
    )

/*++

Routine Description:

  pDoPostReportProcessing contains all of the code that needs to be run after
  the report has been generated for the user but before continuing on with
  the upgrade. This includes tasks like checking to make sure there is enough
  disk space, that there aren't files installed that we can't continue with,
  that the user actually looked at the report, etc. This code is run in both
  the attended and unattended case. Make sure your additions are properly
  protected by the unattended flag if needed.

Arguments:

  hdlg           - the dialog window.
  UiTextViewCtrl - The window to the report text.
  WarningGiven   - Wether the user has looked at the report or saved it.
  TurnOffUnattend - Wether we should return to attended mode.

Return Value:

  TRUE if it is ok to proceed with the upgrade, FALSE otherwise.

--*/



{


    DWORD rc;
    static BOOL firstTime = TRUE;


    //
    // Make sure we only do these checks once.
    //
    if (!firstTime) {
        return TRUE;
    }

    firstTime = FALSE;

    //
    // If cancelled, no reason to continue.
    //
    if (CANCELLED()) {

        return FALSE;
    }

    //
    // If ReportOnly mode, prepare to get out of setup.
    //
    if (REPORTONLY()) {

        pAbortSetup (hdlg);
        DEBUGMSG ((DBG_NAUSEA, "Report Only mode caused setup to exit!"));
        return FALSE;
    }

    //
    // Make sure there was enough space to continue setup. They have
    // to free it up now, or setup will not continue.
    //
    if(!pShowNotEnoughSpaceMessage(hdlg)){
        pAbortSetup (hdlg);
        return FALSE;
    }

    //
    // Make sure we don't let them continue if they had blocking files on there computer.
    // (Applications that must be uninstalled before we can continue..)
    //
    if (g_BlockingFileFound) {

        if (UNATTENDED()) {

            rc = pReviewOrQuitMsgBox(hdlg, MSG_BLOCKING_FILE_BLOCK_UNATTENDED);
            if (rc == IDBUTTON1) {

                //
                // User wants to review the report.
                //
                g_BlockingFileFound = FALSE;
                if (TurnOffUnattend) {
                    *TurnOffUnattend = TRUE;
                }

                return FALSE;
            }
            else {

                //
                // User just wants to cancel.
                //
                pAbortSetup (hdlg);
                DEBUGMSG ((DBG_WARNING, "User cannot continue because of blocking files. Setup is exiting."));
                return FALSE;
            }
        }
        else {

            rc = pReviewOrQuitMsgBox(hdlg, MSG_BLOCKING_FILE_BLOCK);
            if(rc != IDBUTTON1){
                pAbortSetup (hdlg);
            }
            else{
                firstTime = TRUE;
            }
            DEBUGMSG ((DBG_WARNING, "User cannot continue because of blocking files. Setup is exiting."));
            return FALSE;

        }
    }

    //
    // Make sure we don't let them continue if they had blocking files on there computer.
    // (Applications that must be uninstalled before we can continue..)
    //
    if (g_BlockingHardwareFound) {

        if (UNATTENDED()) {

            rc = pReviewOrQuitMsgBox(hdlg, MSG_BLOCKING_HARDWARE_BLOCK_UNATTENDED);
            if (rc == IDBUTTON1) {

                //
                // User wants to review the report.
                //
                g_BlockingHardwareFound = FALSE;
                if (TurnOffUnattend) {
                    *TurnOffUnattend = TRUE;
                }

                return FALSE;
            }
            else {

                //
                // User just wants to cancel.
                //
                pAbortSetup (hdlg);
                DEBUGMSG ((DBG_WARNING, "User cannot continue because of blocking files. Setup is exiting."));
                return FALSE;
            }
        }
        else {

            rc = pReviewOrQuitMsgBox(hdlg, MSG_BLOCKING_HARDWARE_BLOCK);
            if(rc != IDBUTTON1){
                pAbortSetup (hdlg);
            }
            else{
                firstTime = TRUE;
            }
            DEBUGMSG ((DBG_WARNING, "User cannot continue because of blocking files. Setup is exiting."));
            return FALSE;

        }
    }

    //
    // Make sure we don't let them continue if they had an unknown OS version. Block setup.
    //
    if (g_UnknownOs) {

        if(UNATTENDED()){
            rc = OkBox (hdlg, MSG_UNKNOWN_OS);
            pAbortSetup (hdlg);
        }
        else{
            rc = pReviewOrQuitMsgBox(hdlg, MSG_UNKNOWN_OS);
            if(rc != IDBUTTON1){
                pAbortSetup (hdlg);
            }
            else{
                firstTime = TRUE;
            }
        }

        DEBUGMSG ((DBG_WARNING, "User cannot continue because his OS version is unsupported. Setup is exiting."));
        return FALSE;
    }

    if (g_OtherOsExists) {

        //
        // If this is non-empty, we need to block them from upgrading.
        //
        if(UNATTENDED()){
            OkBox (hdlg, MSG_OTHER_OS_FOUND_POPUP);
            pAbortSetup (hdlg);
        }
        else{
            rc = pReviewOrQuitMsgBox(hdlg, MSG_OTHER_OS_FOUND_POPUP);
            if(rc != IDBUTTON1){
                pAbortSetup (hdlg);
            }
            else{
                firstTime = TRUE;
            }
        }

        DEBUGMSG ((DBG_WARNING, "User cannot continue because he has another OS installed. Setup is exiting."));
        return FALSE;

    }



    //
    // Make sure you put code that needs to run only in the ATTENDED case in the block below.
    //
    if (!UNATTENDED()) {

        //
        // If the user has some app that must be uninstalled before upgrading, make
        // sure that we warn them about the problem.
        //
        if (g_BlockingAppFound) {

            WarningGiven = TRUE;
            rc = SoftBlockDlg (hdlg);

            if (rc == IDNO) {
                DEBUGMSG ((DBG_WARNING, "User wants to uninstall the apps!"));
                return pAbortSetup (hdlg);
            }

            if (rc == IDCANCEL) {
                return FALSE;
            }

            MYASSERT (rc == IDOK);
        }

        if (!WarningGiven) {
            //
            // No popup if (A) the user scrolled all the way through, or
            //             (B) the user saved/printed the report
            //

            if (SendMessage (UiTextViewCtrl, WMX_ALL_LINES_PAINTED, 0, 0)) {
                WarningGiven = TRUE;
            }
        }


        if (!WarningGiven) {
            WarningGiven = TRUE;

            rc = WarningDlg (hdlg);

            if (rc == IDNO) {
                DEBUGMSG ((DBG_WARNING, "User doesn't like incompatibilities!"));
                return pAbortSetup (hdlg);
            }

            if (rc == IDCANCEL) {
                return FALSE;
            }

            MYASSERT (rc == IDOK);
        }

        //
        // last thing: warn them if there are any incompatible devices
        //
        if (g_IncompatibleDevicesWarning) {

            g_IncompatibleDevicesWarning = FALSE;

            rc = IncompatibleDevicesDlg (hdlg);

            if (rc == IDOK) {
                //
                // switch to Detailed report view
                //
                if (IsWindowVisible (GetDlgItem (hdlg, IDC_DETAILS))) {
                    PostMessage (hdlg, WM_COMMAND, MAKELONG (IDC_DETAILS, BN_CLICKED), 0);
                }
                return FALSE;
            }

            if (rc == IDNO) {
                DEBUGMSG ((DBG_WARNING, "User doesn't like hardware incompatibilities!"));
                return pAbortSetup (hdlg);
            }

            MYASSERT (rc == IDYES);
        }
    }

    //
    // Don't continue if there are blocking issues
    //

    if (AreThereAnyBlockingIssues()) {
        return pAbortSetup (hdlg);
    }

    return TRUE;


}

BOOL
pMeasureItemHeight (
    INT*        ItemHeight
    )
{
    static INT g_ItemHeight = 0;
    TEXTMETRIC tm;
    HFONT font;
    HDC hdc;
    BOOL b = FALSE;

    if (!g_ItemHeight) {
        font = GetStockObject (DEFAULT_GUI_FONT);
        if (font) {
            hdc = GetDC (NULL);
            if (hdc) {
                HFONT hFontPrev = SelectObject (hdc, font);
                GetTextMetrics (hdc, &tm);
                g_ItemHeight = max (tm.tmHeight, GetSystemMetrics (SM_CYSMICON));
                SelectObject (hdc, hFontPrev);
                ReleaseDC (NULL, hdc);
            }
        }
    }

    if (g_ItemHeight) {
        *ItemHeight = g_ItemHeight;
        b = TRUE;
    }
    return b;
}


BOOL
UI_ResultsPageProc (
    IN      HWND hdlg,
    IN      UINT uMsg,
    IN      WPARAM wParam,
    IN      LPARAM lParam
    )

/*++

Routine Description:

  UI_ResultsPageProc is the wizard window procedure that is called to
  present the incompatibility report.  This procedure fills in a
  list control with all root incompatibility components.  When the user
  clicks Full Report, a dialog appears displaying the complete report
  text.

Arguments:

  hdlg      - Specifies the dialog handle

  uMsg      - Specifies the message to process

  wParam    - Specifies the wParam data associated with the message

  lParam    - Specifies the lParam data associated with the message

Return Value:

  WMX_ACTIVATEPAGE: On activation (wParam is TRUE), returns FALSE if
                    page is to be skipped; returns TRUE if page is
                    to be processed.

                    On deactivation (wParam is FALSE), returns FALSE
                    if the page is not to be deactivated; returns
                    TRUE if the page is to be deactivated.

  WM_NOTIFY:        Returns FALSE

  WM_COMMAND:       Returns TRUE if command is processed; FALSE if
                    command is not processed.

  Others:           Returns FALSE.

--*/

{
    static BOOL Initialized;
    PCTSTR Msg;
    static BOOL WarningGiven = TRUE;
    static HWND UiTextViewCtrl;
    static BOOL TurnOffUnattend = FALSE;
    static HWND g_RestoreParent = NULL;
    PCTSTR FinishText;
    BOOL bUiReportEmpty;
    DWORD severityLevel;
    HWND listHandle, listHeaderText;
    HWND thisBtn, otherBtn;
    RECT rect;
    HFONT font, boldFont, prevFont;
    LOGFONT lf;
    DWORD lowestLevel;
    TCHAR textBuf[96];
    SYSTEMTIME currentTime;
    HKEY key;
    PCTSTR ArgArray[1];

    __try {
        switch (uMsg) {
        case WMX_ACTIVATEPAGE:
            if (wParam) {
                if (!UPGRADE() || CANCELLED()) {
                    return FALSE;
                }

                DEBUGLOGTIME(("Results Wizard Page..."));

                if (!Initialized) {
                    Initialized = TRUE;
                    TurnOnWaitCursor ();

                    //
                    // Convert message manager struct into report items
                    //

                    MsgMgr_Resolve ();

                    if(TRISTATE_NO == g_ConfigOptions.ShowReport && AreThereAnyBlockingIssues()){
                        g_ConfigOptions.ShowReport = TRISTATE_PARTIAL;
                    }
                    //
                    // switch button text if necessary, update static text
                    //

                    if (g_ConfigOptions.ShowReport == TRISTATE_PARTIAL) {
                        Msg = GetStringResource (MSG_FULL_REPORT_BUTTON);
                        SetDlgItemText (hdlg, IDC_DETAILS, Msg);
                        FreeStringResource (Msg);

                        Msg = GetStringResource (MSG_FULL_REPORT_TEXT);
                        SetDlgItemText (hdlg, IDC_REPORT_HEADER, Msg);
                        FreeStringResource (Msg);
                    }

                    //
                    // save the report in config.dmp now
                    //
                    SaveConfigurationForBeta ();

                    //
                    // If SaveReportTo was specified in our unattend parameters, then
                    // save the reports there now.
                    //
                    if (g_ConfigOptions.SaveReportTo && *g_ConfigOptions.SaveReportTo) {

                        //
                        // Save reports.
                        //
                        if (!SaveReport (NULL, g_ConfigOptions.SaveReportTo)) {
                            DEBUGMSG((DBG_WARNING,"SaveReport failed."));
                        }
                    }

                    //
                    // In all cases, we save it to the windows directory unconditionally.
                    //
                    if (!SaveReport (NULL, g_WinDir)) {
                        DEBUGMSG((DBG_WARNING,"SaveReport failed."));
                    } else {

                        DEBUGMSG ((DBG_VERBOSE, "Report saved to %s", g_WinDir));

                        //
                        // In report only mode, output the current time, so
                        // the report is skipped in normal setup
                        //

                        if (REPORTONLY()) {
                            GetSystemTime (&currentTime);

                            key = CreateRegKeyStr (TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Setup"));
                            if (key) {
                                RegSetValueEx (
                                    key,
                                    TEXT("LastReportTime"),
                                    0,
                                    REG_BINARY,
                                    (PBYTE) (&currentTime),
                                    sizeof (currentTime)
                                    );

                                CloseRegKey (key);
                            }
                        }
                    }

                    TurnOffWaitCursor ();

                    if (g_ConfigOptions.ShowReport == TRISTATE_NO) {
                        return FALSE;
                    }

                    //
                    // Prepare page for display
                    //

                    SendMessage (hdlg, DM_SETDEFID, IDOK, 0);

                    UiTextViewCtrl = GetDlgItem (hdlg, IDC_PLACEHOLDER);
                    MYASSERT (UiTextViewCtrl);
                    g_TextViewInDialog = UiTextViewCtrl;

                    SetFocus (UiTextViewCtrl);

                    //
                    // Prepare output text
                    //

                    Msg = CreateReportText (
                            TRUE,
                            0,
                            REPORTLEVEL_VERBOSE,
                            FALSE
                            );
                    if (Msg) {
                        AddStringToTextView (UiTextViewCtrl, Msg);
                    }
                    FreeReportText ();

                }

                // Enable next
                PropSheet_SetWizButtons (GetParent(hdlg), PSWIZB_NEXT);

                // Fill in list view control
                bUiReportEmpty = TRUE;
                severityLevel = REPORTLEVEL_NONE;
                listHandle = GetDlgItem (hdlg, IDC_ROOT_LIST);
                if (listHandle) {
                    bUiReportEmpty = !pFillListControl (listHandle, &severityLevel);
                }

                //
                // If unattended mode, skip page.
                // Also skip it if the report is empty
                //
                if (*g_UnattendSwitchSpecified && !g_ConfigOptions.PauseAtReport ||
                    !REPORTONLY() && bUiReportEmpty
                    ) {

                    if (g_ConfigOptions.ReportOnly) {
                        *g_AbortFlagPtr = TRUE;
                        PostMessage (GetParent (hdlg), PSM_PRESSBUTTON, PSBTN_NEXT, 0);
                    }
                    else {

                        //
                        // ***DO NOT*** put code here, put it in pDoPostReportProcessing instead.
                        //
                        pDoPostReportProcessing (hdlg, UiTextViewCtrl, WarningGiven, &TurnOffUnattend);

                        //
                        // if TurnOffUnattend was set, this means we want to cancel the upgrade, but give the
                        // user a chance to check out the report.
                        //
                        if (TurnOffUnattend) {

                            SendMessage(GetParent (hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);
                            return TRUE;
                        }
                        else {
                            return FALSE;
                        }
                    }
                }

                //
                // If ReportOnly mode, turn on Finish button
                //
                if (REPORTONLY()) {
                    FinishText = GetStringResource (MSG_FINISH);
                    if (FinishText) {
                        EnableWindow (GetDlgItem(GetParent(hdlg),IDCANCEL), FALSE);
                        SetWindowText (GetDlgItem(GetParent(hdlg), PROPSHEET_NEXT_BUTTON_ID), FinishText);
                        FreeStringResource (FinishText);
                    }
                    if (*g_UnattendSwitchSpecified) {
                        PostMessage (GetParent (hdlg), PSM_PRESSBUTTON, PSBTN_NEXT, 0);
                    }                         //
                } else {
                    //
                    // check if any incompatible hardware is displayed in the report
                    //
                    g_IncompatibleDevicesWarning = IsIncompatibleHardwarePresent();
                }

                // Stop the bill board and make sure the wizard shows again.
                SendMessage(GetParent (hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);
                PropSheet_SetWizButtons (GetParent(hdlg), PSWIZB_NEXT);

                if(pIsBlockingIssue()){
                    FinishText = GetStringResource (MSG_FINISH);
                    if(FinishText){
                        SetWindowText(GetDlgItem(GetParent(hdlg), PROPSHEET_NEXT_BUTTON_ID), FinishText);
                        FreeStringResource (FinishText);
                    }
                }
                if (bUiReportEmpty) {
                    //
                    // if the list report is empty, only show the detailed report
                    // switch view first
                    //
                    SendMessage (hdlg, WM_COMMAND, MAKELONG (IDC_DETAILS, BN_CLICKED), 0);
                    //
                    // then disable and hide both buttons
                    //
                    EnableWindow (GetDlgItem (hdlg, IDC_DETAILS), FALSE);
                    EnableWindow (GetDlgItem (hdlg, IDC_HIDEDETAILS), FALSE);
                    ShowWindow (GetDlgItem (hdlg, IDC_DETAILS), SW_HIDE);
                    ShowWindow (GetDlgItem (hdlg, IDC_HIDEDETAILS), SW_HIDE);
                } else {
                    //
                    // set the proper List header based on severity of content
                    //
                    MYASSERT (severityLevel != REPORTLEVEL_NONE);
                    if (severityLevel & REPORTLEVEL_BLOCKING) {
                        //
                        // need to update the default header (which is set for "Warnings")
                        //
                        if (g_ConfigOptions.ShowReport == TRISTATE_PARTIAL) {
                            Msg = GetStringResource (MSG_REPORT_HEADER_BLOCKING_ISSUES_SHORT);
                        } else {
                            Msg = GetStringResource (MSG_REPORT_HEADER_BLOCKING_ISSUES);
                        }

                        listHeaderText = GetDlgItem (hdlg, IDC_REPORT_HEADER);
                        SetDlgItemText (hdlg, IDC_REPORT_HEADER, Msg);
                        FreeStringResource (Msg);
                    }
                    //
                    // now set text attributes (bold, color etc)
                    //
                    font = (HFONT)SendDlgItemMessage (
                                    hdlg,
                                    IDC_REPORT_HEADER,
                                    WM_GETFONT,
                                    0,
                                    0
                                    );
                    if (!font) {
                        font = GetStockObject (SYSTEM_FONT);
                    }
                    if (font) {
                        //
                        // draw the text in bold
                        //
                        GetObject (font, sizeof (lf), &lf);
                        lf.lfWeight += FW_BOLD - FW_NORMAL;
                        boldFont = CreateFontIndirect (&lf);
                        if (boldFont) {
                            font = (HFONT)SendDlgItemMessage (
                                            hdlg,
                                            IDC_REPORT_HEADER,
                                            WM_SETFONT,
                                            (WPARAM)boldFont,
                                            MAKELONG (FALSE, 0)
                                            );
                        }
                    }
                }
            }
            else {

                //
                // In all cases, we save it to the windows directory unconditionally.
                //
                if (!SaveReport (NULL, g_WinDir)) {
                    DEBUGMSG((DBG_WARNING,"SaveReport failed."));
                }

                if (g_UIQuitSetup) {
                    //
                    // quit setup for a specific reason
                    //
                    pAbortSetup (hdlg);
                    return TRUE;
                }

                if (TurnOffUnattend) {
                    //
                    // We turned off unattend earlier so that the user could view the report. Now exit setup.
                    //
                    pAbortSetup (hdlg);
                    return TRUE;
                }

                //
                // ***DO NOT*** put code here, put it in pDoPostReportProcessing instead.
                //
                if (!CANCELLED()) {
                    return pDoPostReportProcessing (hdlg, UiTextViewCtrl, WarningGiven, NULL);
                }
                else {
                    return TRUE;
                }
            }

            return TRUE;

        case WM_MEASUREITEM:
            {
                LPMEASUREITEMSTRUCT mis = (LPMEASUREITEMSTRUCT)lParam;
                return pMeasureItemHeight (&mis->itemHeight);
            }

        case WM_DRAWITEM:
            {
                LPDRAWITEMSTRUCT dis = (LPDRAWITEMSTRUCT)lParam;
                if (dis->itemAction == ODA_DRAWENTIRE) {
                    if (dis->itemID != -1) {
                        TCHAR text[MAX_LISTVIEW_TEXT];
                        LVITEM lvi;
                        boldFont = NULL;
                        prevFont = NULL;

                        ZeroMemory (&lvi, sizeof (lvi));
                        lvi.iItem = dis->itemID;
                        lvi.mask = LVIF_TEXT | LVIF_PARAM | LVIF_IMAGE | LVIF_INDENT;
                        lvi.pszText = text;
                        lvi.cchTextMax = MAX_LISTVIEW_TEXT;
                        if (ListView_GetItem (dis->hwndItem, &lvi)) {
                            INT xStart, yStart;
                            HIMAGELIST hImgList;
                            INT itemHeight;
                            SIZE size;

                            xStart = dis->rcItem.left + IMAGE_INDENT;
                            yStart = dis->rcItem.top;
                            if (pMeasureItemHeight (&itemHeight)) {
                                font = GetStockObject (DEFAULT_GUI_FONT);
                                if (font) {
                                    if (lvi.lParam & LINEATTR_BOLD) {
                                        //
                                        // draw the text in bold
                                        //
                                        GetObject (font, sizeof (lf), &lf);
                                        lf.lfWeight += FW_BOLD - FW_NORMAL;
                                        boldFont = CreateFontIndirect (&lf);
                                        if (boldFont) {
                                            prevFont = SelectObject (dis->hDC, boldFont);
                                        } else {
                                            prevFont = SelectObject (dis->hDC, font);
                                        }
                                    } else {
                                        prevFont = SelectObject (dis->hDC, font);
                                    }
                                }
                                SetTextColor (
                                    dis->hDC,
                                    lvi.lParam & LINEATTR_ALTCOLOR ? RGB (255, 0, 0) : GetSysColor (COLOR_WINDOWTEXT)
                                    );
                                if (lvi.lParam & LINEATTR_INDENTED) {
                                    xStart += GetSystemMetrics (SM_CXSMICON);
                                }
                                hImgList = ListView_GetImageList (dis->hwndItem, LVSIL_SMALL);
                                ImageList_Draw (hImgList, lvi.iImage, dis->hDC, xStart, yStart, ILD_TRANSPARENT);
                                xStart += GetSystemMetrics (SM_CXSMICON) + TEXT_INDENT;
                                GetTextExtentPoint32 (dis->hDC, text, lstrlen (text), &size);
                                if (itemHeight > size.cy) {
                                    yStart += (itemHeight - size.cy + 1) / 2;
                                }
                                TextOut (dis->hDC, xStart, yStart, text, lstrlen (text));
                                if (prevFont) {
                                    SelectObject (dis->hDC, prevFont);
                                }
                                if (boldFont) {
                                    DeleteObject (boldFont);
                                }
                            }
                        }
                    } else {
                        return FALSE;
                    }
                }
                return TRUE;
            }

        case WM_NOTIFY:
            if (wParam == IDC_ROOT_LIST) {
                LPNMHDR hdr = (LPNMHDR)lParam;
                if (hdr->code == NM_DBLCLK) {
                    //
                    // act just like IDC_DETAILS
                    //
                    SendMessage (hdlg, WM_COMMAND, MAKELONG (IDC_DETAILS, BN_CLICKED), 0);
                }
            }
            break;

        case WM_COMMAND:
            switch (LOWORD (wParam)) {

            case IDC_SAVE_AS:
                if (HIWORD (wParam) == BN_CLICKED) {
                    SaveReport (hdlg, NULL);
                    WarningGiven = TRUE;
                    g_IncompatibleDevicesWarning = FALSE;
                }
                return TRUE;

            case IDC_PRINT:
                if (HIWORD (wParam) == BN_CLICKED) {
                    PrintReport (hdlg, REPORTLEVEL_VERBOSE);
                    WarningGiven = TRUE;
                    g_IncompatibleDevicesWarning = FALSE;
                }
                return TRUE;

            case IDC_DETAILS:
            case IDC_HIDEDETAILS:
                if (HIWORD (wParam) == BN_CLICKED) {
                    BOOL bShowDetails = LOWORD (wParam) == IDC_DETAILS;
                    BOOL bSetFocus;
                    listHandle = GetDlgItem (hdlg, IDC_ROOT_LIST);
                    listHeaderText = GetDlgItem (hdlg, IDC_REPORT_HEADER);
                    UiTextViewCtrl = GetDlgItem (hdlg, IDC_PLACEHOLDER);
                    thisBtn = GetDlgItem (hdlg, LOWORD (wParam));
                    otherBtn = GetDlgItem (hdlg, bShowDetails ? IDC_HIDEDETAILS : IDC_DETAILS);
                    MYASSERT (listHandle && listHeaderText && UiTextViewCtrl && thisBtn && otherBtn);
                    if (listHandle && listHeaderText && UiTextViewCtrl && thisBtn && otherBtn) {
                        MYASSERT (!IsWindowVisible (bShowDetails ? UiTextViewCtrl : listHandle));
                        MYASSERT (!IsWindowVisible (otherBtn));
                        bSetFocus = GetFocus () == thisBtn;
                        ShowWindow (UiTextViewCtrl, bShowDetails ? SW_SHOW : SW_HIDE);
                        ShowWindow (listHandle, bShowDetails ? SW_HIDE : SW_SHOW);
                        ShowWindow (listHeaderText, bShowDetails ? SW_HIDE : SW_SHOW);
                        if (GetWindowRect (thisBtn, &rect)) {
                            ScreenToClient (hdlg, (LPPOINT)&rect.left);
                            ScreenToClient (hdlg, (LPPOINT)&rect.right);
                            MoveWindow (otherBtn, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, FALSE);
                        }
                        ShowWindow (otherBtn, SW_SHOW);
                        ShowWindow (thisBtn, SW_HIDE);
                        if (bSetFocus) {
                            SetFocus (otherBtn);
                        }
                        g_IncompatibleDevicesWarning = FALSE;
                    }
                }
                return TRUE;

            }
            break;

       case WMX_RESTART_SETUP:
            //
            // some control determined that the user took some action
            // that requires setup to terminate at this point
            // wParam indicates if setup should terminate right away (if TRUE)
            // or if it will terminate when user presses Next (if FALSE)
            //
            if (wParam) {
               pAbortSetup (hdlg);
            } else {
               g_UIQuitSetup = TRUE;

               if (lParam) {
                   //
                   // the billboard window should be made invisible,
                   // so the user can see the whole screen
                   //
                    HWND hwndWizard = GetParent(hdlg);
                    HWND hwndBillboard = GetParent(hwndWizard);
                    if (hwndBillboard && IsWindowVisible (hwndBillboard)) {
                        SetParent (hwndWizard, NULL);
                        ShowWindow (hwndBillboard, SW_HIDE);
                        g_RestoreParent = hwndBillboard;
                    }
                }
            }

            break;

       case WMX_NEXTBUTTON:
            if (g_RestoreParent) {
                //
                // restore the old parent relationship, so things work as expected
                //
                HWND hwndWizard = GetParent(hdlg);
                if (hwndWizard) {
                    DWORD style;
                    ShowWindow (g_RestoreParent, SW_SHOW);
                    g_RestoreParent = NULL;
                    SetForegroundWindow (hwndWizard);
                }
            }
            break;

       default:
            break;
        }
    } __except (1) {

        LOG ((LOG_WARNING, "An unhandled exception occurred during the processing of the Results Page."));
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_UNEXPECTED_ERROR_ENCOUNTERED_NORC));
        SafeModeExceptionOccured ();
        pAbortSetup (hdlg);
    }
    return FALSE;
}

//
//Backup Local Functions
//

BOOL
GetListOfNonRemovableDrivesWithAvailableSpace(
    OUT     PCHAR DriveLetterArray,
    OUT     PUINT NumberOfDrives,
    IN      UINT SizeOfArrays
    )
{
    UINT LogicalDrives;
    CHAR DriveName[] = "?:\\";
    ULARGE_INTEGER FreeBytesAvailable;
    ULARGE_INTEGER TotalNumberOfBytes;
    ULARGE_INTEGER TotalNumberOfFreeBytes;
    UINT i;

    if(!DriveLetterArray || !NumberOfDrives) {
        return FALSE;
    }

    if(!(LogicalDrives = GetLogicalDrives())) {
        return FALSE;
    }

    *NumberOfDrives = 0;
    for(i = 0; LogicalDrives && ((*NumberOfDrives) < SizeOfArrays); LogicalDrives >>= 1, i++){
        if(LogicalDrives&1) {
            DriveName[0] = 'A' + (char)i;
            if(DRIVE_FIXED != GetDriveType(DriveName)) {
                continue;
            }

            *DriveLetterArray++ = DriveName[0];
            (*NumberOfDrives)++;
        }
    }

    return TRUE;
}


BOOL
IsBackUpPossible(
    OUT     PCHAR DriveLetterArray,                     OPTIONAL
    OUT     PULARGE_INTEGER AvailableSpaceOut,          OPTIONAL
    OUT     PUINT NumberOfDrivesOut,                    OPTIONAL
    OUT     PBOOL IsPossibleBackupWithoutCompression,   OPTIONAL
    IN      UINT SizeOfArrays                           OPTIONAL
    )
{
    CHAR Drives[MAX_NUMBER_OF_DRIVES];
    UINT NumberOfDrives = 0;
    UINT NumberAvailableDrives;
    UINT i;
    ULARGE_INTEGER finalFreeSpace;
    BOOL Result;
    TCHAR rootPath[] = TEXT("?:\\");
    INT BackupDiskPadding;
    ULARGE_INTEGER BackupDiskSpacePaddingInBytes;
    BOOL IsExceedMaxSize = FALSE;

    if(g_SpaceNeededForSlowBackup.QuadPart >= MAX_BACKUP_IMAGE_SIZE_FOR_BACKUP){
        return FALSE;
    }

    //
    // Now find a place for the backup
    //

    if(!GetListOfNonRemovableDrivesWithAvailableSpace(
            Drives,
            &NumberOfDrives,
            ARRAYSIZE(Drives))) {
        return FALSE;
    }

	
    if(IsPossibleBackupWithoutCompression){
        if(g_ConfigOptions.DisableCompression == TRISTATE_REQUIRED) {
            BackupDiskSpacePaddingInBytes.QuadPart = 0;
        }
        else{
            if(GetUninstallMetrics(NULL, NULL, &BackupDiskPadding)) {
                BackupDiskSpacePaddingInBytes.QuadPart = BackupDiskPadding;
    	        BackupDiskSpacePaddingInBytes.QuadPart <<= 20;
            }
            else {
                BackupDiskSpacePaddingInBytes.QuadPart = NESSESSARY_DISK_SPACE_TO_BACKUP_UNCOMPRESSED;
            }
        }
    }

    DEBUGMSG((DBG_VERBOSE, "Available %d NonRemovable Drives/Space:", NumberOfDrives));

    if(g_SpaceNeededForFastBackup.QuadPart >= MAX_BACKUP_IMAGE_SIZE_FOR_BACKUP){
        IsExceedMaxSize = TRUE;
    }
    else{
        IsExceedMaxSize = FALSE;
    }

    for (NumberAvailableDrives = 0, Result = FALSE, i = 0; i < NumberOfDrives; i++) {
        rootPath[0] = Drives[i];

        DEBUGMSG ((DBG_VERBOSE, "QuerySpace:%I64i vs SpaceForSlowBackup:%I64i", QuerySpace (rootPath), (LONGLONG) g_SpaceNeededForSlowBackup.QuadPart));

        if (QuerySpace (rootPath) > (LONGLONG) g_SpaceNeededForSlowBackup.QuadPart) {
            Result = TRUE;
            NumberAvailableDrives++;

            if (IsPossibleBackupWithoutCompression != NULL) {

                if (QuerySpace (rootPath) > (LONGLONG) (g_SpaceNeededForFastBackup.QuadPart +
                                                        BackupDiskSpacePaddingInBytes.QuadPart) &&
                    !IsExceedMaxSize) {
                    *IsPossibleBackupWithoutCompression++ = TRUE;
                    DEBUGMSG ((DBG_VERBOSE, "Backup is possible without compression on drive %c", Drives[i]));
                } else {
                    *IsPossibleBackupWithoutCompression++ = FALSE;
                    DEBUGMSG ((DBG_VERBOSE, "Uncompresed backup is NOT possible on drive %c", Drives[i]));
                }
            }

            if (SizeOfArrays > NumberAvailableDrives) {
                if (DriveLetterArray) {
                    *DriveLetterArray++ = Drives[i];
                }

                if(AvailableSpaceOut) {
                    AvailableSpaceOut->QuadPart = QuerySpace (rootPath);
                    AvailableSpaceOut++;
                }
            }
        }
    }

    if (NumberOfDrivesOut) {
        *NumberOfDrivesOut = NumberAvailableDrives;
    }

    return Result;
}

PTSTR
pConstructPathForBackup(
    IN      TCHAR DriveLetter
    )
{
    static TCHAR pathForBackup[MAX_PATH];
    WIN32_FIND_DATA win32FindData;
    HANDLE handleOfDir;
    INT i;

    for(i = 0; i < MAX_AMOUNT_OF_TIME_TO_TRY_CONSTRUCT_UNDO_DIR; i++){
        wsprintf(pathForBackup, i? TEXT("%c:\\undo%d"): TEXT("%c:\\undo"), DriveLetter, i);

        handleOfDir = FindFirstFile(pathForBackup, &win32FindData);

        if(INVALID_HANDLE_VALUE == handleOfDir){
            break;
        }
        else{
            FindClose(handleOfDir);
        }
    }

    if(i == MAX_AMOUNT_OF_TIME_TO_TRY_CONSTRUCT_UNDO_DIR){
        MYASSERT(FALSE);
        DEBUGMSG((DBG_ERROR, "Can't construct directory for backup"));
        return NULL;
    }

    return pathForBackup;
}

BOOL
UI_BackupYesNoPageProc (
    IN      HWND hdlg,
    IN      UINT uMsg,
    IN      WPARAM wParam,
    IN      LPARAM lParam
    )

/*++

Routine Description:

  UI_BackupYesNoPageProc is the wizard window procedure that is called to
  backup asking page. User can choose to do backup or not. In the unattended
  case, this page will not appear, but we do some validation for the backup
  impossible page.

Arguments:

  hdlg      - Specifies the dialog handle

  uMsg      - Specifies the message to process

  wParam    - Specifies the wParam data associated with the message

  lParam    - Specifies the lParam data associated with the message

Return Value:

  WMX_ACTIVATEPAGE: On activation (wParam is TRUE), returns FALSE if
                    page is to be skipped; returns TRUE if page is
                    to be processed.

                    On deactivation (wParam is FALSE), returns FALSE
                    if the page is not to be deactivated; returns
                    TRUE if the page is to be deactivated.

  WM_NOTIFY:        Returns FALSE

  WM_COMMAND:       Returns TRUE if command is processed; FALSE if
                    command is not processed.

  Others:           Returns FALSE.

--*/

{
    TCHAR DiskSpaceString[10];
    HWND hButtonWnd;
    PCTSTR ArgArray[1];
    PCTSTR Msg;
    TCHAR DiskSpace[32];
    static BOOL initialized;
    CHAR Drives[MAX_NUMBER_OF_DRIVES];
    ULARGE_INTEGER AvailableSpace[ARRAYSIZE(Drives)];
    static UINT NumberAvailableDrives;
    static TCHAR winDrivePath[16];
    UINT i;
    PSTR pathForBackupTemp;
    BOOL IsExceedMaxBackupImageSize;

    __try {
        switch (uMsg) {

        case WMX_ACTIVATEPAGE:
            if (wParam) {
                if (!UPGRADE() || CANCELLED()) {
                    return FALSE;
                }

                //
                // If answer file specifies backup choice, then skip page.
                // TRISTATE_YES is the "automatic" setting for the answer
                // file.
                //

                if (g_SilentBackupMode) {
                    //
                    // We do not expect to enter this condition, because we
                    // are the ones who set silent mode. There should never be
                    // a condition where silent mode is on and the user can
                    // click Back on the wizard.
                    //

                    MYASSERT (FALSE);
                    return FALSE;
                }

                DEBUGLOGTIME(("Backup Yes/No Wizard Page..."));

                if (!initialized) {

                    NumberAvailableDrives = 0;

                    if (IsBackUpPossible (
                                Drives,
                                AvailableSpace,
                                &NumberAvailableDrives,
                                NULL,
                                ARRAYSIZE(Drives)
                                )) {
                        //
                        // Backup is possible, but we have not yet taken into
                        // consideration the backup path setting from the
                        // answer file. Preserve the REQUIRED state.
                        //

                        if (g_ConfigOptions.EnableBackup == TRISTATE_REQUIRED) {
                            g_ConfigOptions.EnableBackup = TRISTATE_YES;
                        }

                        if (!g_ConfigOptions.PathForBackup || !g_ConfigOptions.PathForBackup[0]) {
                            //
                            // If backup is possible on the system drive, then
                            // continue silently.
                            //

                            for (i = 0; i < NumberAvailableDrives; i++) {
                                //
                                // Setup does not bother user, if we find possibility
                                // to have %undo% dir on %windir% drive.
                                //
                                if (_totlower (Drives[i]) == _totlower (g_WinDir[0])) {
                                    g_SilentBackupMode = TRUE;
                                    pathForBackupTemp = pConstructPathForBackup(g_WinDir[0]);
                                    if(pathForBackupTemp){
                                        StringCopy(winDrivePath, pathForBackupTemp);
                                        g_ConfigOptions.PathForBackup = winDrivePath;
                                    }ELSE_DEBUGMSG((DBG_ERROR, "Can't construct directory for backup."));

                                    return FALSE;
                                }
                            }
                        }

                    } else {
                        //
                        // If we are running unattended, and backup is
                        // required, then stop right now.
                        //
                        // If we are running with UI, and backup is required,
                        // skip this page and head directly to the Backup
                        // Impossible page.
                        //

                        // Set the answer to NO because backup is not
                        // possible. In unattend mode, we'll just continue
                        // with setup, without a backup.
                        g_ConfigOptions.EnableBackup = TRISTATE_NO;

                        if(g_SpaceNeededForSlowBackup.QuadPart >= MAX_BACKUP_IMAGE_SIZE_FOR_BACKUP){
                            g_ShowBackupImpossiblePage = BIP_SIZE_EXCEED_LIMIT;
                        }
                        else{
                            g_ShowBackupImpossiblePage = BIP_NOT_ENOUGH_SPACE;
                        }

                        if (g_ConfigOptions.EnableBackup == TRISTATE_REQUIRED && UNATTENDED()) {
                            LOG ((LOG_ERROR, (PCSTR) MSG_STOP_BECAUSE_CANT_BACK_UP));
                            pAbortSetup (hdlg);
                        }

                        //
                        // If setup does not finds enough disk space to install system,
                        // it shows NotEnoughSpaceMessage dialog, with only QuitSetup button,
                        // only in non-unattended case.
                        //
                        if(!pShowNotEnoughSpaceMessage(hdlg)){
                            pAbortSetup (hdlg);
                            return FALSE;
                        }

                        return FALSE;
                    }

                    //
                    // If unattended, skip this page
                    //

                    if (UNATTENDED()) {
                        return FALSE;
                    }

                    //
                    // Fill the wizard page with disk space info
                    //

                    wsprintf (DiskSpace, TEXT("%d"), (UINT)(g_SpaceNeededForSlowBackup.QuadPart / (1<<20)));

                    ArgArray[0] = DiskSpace;
                    Msg = ParseMessageID (MSG_DISK_SPACE, ArgArray);
                    if (Msg) {
                        SetWindowText(GetDlgItem(hdlg, IDC_DISKSPACE), Msg);
                        FreeStringResource (Msg);
                    }
                    ELSE_DEBUGMSG ((DBG_ERROR, "Unable to load string resource on BackupYesNoPage wizard page. Check localization."));

                    hButtonWnd = GetDlgItem (hdlg, g_ConfigOptions.EnableBackup != TRISTATE_NO ?
                                                                IDC_BACKUP_YES: IDC_BACKUP_NO);
                    SetFocus (hButtonWnd);
                    SendMessage (hButtonWnd, BM_SETCHECK, BST_CHECKED, 0);

                    initialized = TRUE;
                }

                MYASSERT (!UNATTENDED());

                //
                // Enable next, disable back
                //

                PropSheet_SetWizButtons (GetParent(hdlg), PSWIZB_NEXT);

                //
                // Stop the billboard and make sure the wizard shows again.
                //

                SendMessage(GetParent (hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);

            } else {
                //
                // Collect the user's choice (if it was presented to them)
                //

                if (initialized) {
                    if (IsDlgButtonChecked (hdlg, IDC_BACKUP_YES) == BST_CHECKED) {
                        g_ConfigOptions.EnableBackup = TRISTATE_YES;
                    } else {
                        g_ConfigOptions.EnableBackup = TRISTATE_NO;
                    }
                }
            }

            return TRUE;

       default:
            break;
        }
    } __except (1) {

        LOG ((LOG_WARNING, "An unhandled exception occurred during the processing of the Backup Yes/No Page."));
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_UNEXPECTED_ERROR_ENCOUNTERED_NORC));
        SafeModeExceptionOccured ();
        pAbortSetup (hdlg);
    }

    return FALSE;
}

BOOL
UI_BackupDriveSelectionProc (
    IN      HWND hdlg,
    IN      UINT uMsg,
    IN      WPARAM wParam,
    IN      LPARAM lParam
    )

/*++

Routine Description:

  UI_BackupDriveSelectionProc is the wizard window procedure that is called to
  choose backup drive.

Arguments:

  hdlg      - Specifies the dialog handle

  uMsg      - Specifies the message to process

  wParam    - Specifies the wParam data associated with the message

  lParam    - Specifies the lParam data associated with the message

Return Value:

  WMX_ACTIVATEPAGE: On activation (wParam is TRUE), returns FALSE if
                    page is to be skipped; returns TRUE if page is
                    to be processed.

                    On deactivation (wParam is FALSE), returns FALSE
                    if the page is not to be deactivated; returns
                    TRUE if the page is to be deactivated.

  WM_NOTIFY:        Returns FALSE

  WM_COMMAND:       Returns TRUE if command is processed; FALSE if
                    command is not processed.

  Others:           Returns FALSE.

--*/

{
    TCHAR DiskSpaceString[32];
    HWND hButtonWnd;
    HWND hFirstRadioButton;
    HWND hRadioButton;
    HWND hDefaultRadioButton;
    DWORD TemplateStyle;
    DWORD TemplateStyleEx;
    HFONT hFontOfFirstRadioButton;
    static CHAR Drives[MAX_NUMBER_OF_DRIVES];
    static BOOL IsPossibleBackupWithoutCompression[MAX_NUMBER_OF_DRIVES];
    ULARGE_INTEGER AvailableSpace[ARRAYSIZE(Drives)];
    static UINT NumberAvailableDrives;
    RECT EtalonRadioButtonRect;
    RECT PageRect;
    POINT pointForTransform;
    UINT NumberOfPossibleRadioButtonsByVertical;
    UINT widthRadio;
    UINT heightRadio;
    UINT xOffset;
    UINT yOffset;
    UINT i;
    PCTSTR PathForBackupImage;
    PCTSTR ArgArray[2];
    PCTSTR Msg;
    TCHAR DiskSpace[32];
    TCHAR DriveText[32];
    static BOOL backupPathSet = FALSE;
    static TCHAR PathForBackup[MAX_PATH];
    BOOL b;
    BOOL disableCompression;
    static BOOL initialized;
    TCHAR selectedDrive;
    PSTR pathForBackupTemp;


    __try {
        switch (uMsg) {

        case WMX_ACTIVATEPAGE:
            if (wParam) {
                if (!UPGRADE() || CANCELLED()) {
                    return FALSE;
                }

                DEBUGLOGTIME(("Backup Drive Selection Wizard Page..."));

                b = TRUE;

                if(g_ShowBackupImpossiblePage != BIP_DONOT){
                    b = FALSE;
                }

                //
                // Validate length of PathForBackup
                //

                if (b && !initialized) {
                    //
                    // Obtain the available drive list
                    //

                    NumberAvailableDrives = 0;
                    if (!IsBackUpPossible (
                            Drives,
                            AvailableSpace,
                            &NumberAvailableDrives,
                            IsPossibleBackupWithoutCompression,
                            ARRAYSIZE(Drives)
                            )) {

                        //
                        // This is unexpected, because the Yes/No page did
                        // the work of validating if backup is possible.
                        //

                        MYASSERT (FALSE);
                        g_ConfigOptions.EnableBackup = TRISTATE_NO;
                        g_ShowBackupImpossiblePage = BIP_NOT_ENOUGH_SPACE;
                        b = FALSE;

                    }
                }

                if (b && g_SilentBackupMode || g_ConfigOptions.EnableBackup == TRISTATE_NO) {
                    //
                    // Skip drive selection page -- we already have the
                    // proper backup settings. Proceed to the deactivate
                    // routine so that backup is written to the SIF.
                    //

                    b = FALSE;
                    backupPathSet = TRUE;
                    MYASSERT (g_ConfigOptions.PathForBackup);
                }

                if (b && !initialized) {
                    //
                    // Validate the PathForBackup setting. If it is not
                    // specified, then allow the user to choose the backup
                    // drive (or continue with first valid choice if
                    // unattended).
                    //

                    if (g_ConfigOptions.PathForBackup && *g_ConfigOptions.PathForBackup == 0) {
                        g_ConfigOptions.PathForBackup = NULL;
                    }

                    if (g_ConfigOptions.PathForBackup) {
                        //
                        // Check path length restriction
                        //

                        if (TcharCount (g_ConfigOptions.PathForBackup) >= (MAX_PATH - 26)) {
                            g_ConfigOptions.PathForBackup = NULL;
                            LOG ((
                                LOG_ERROR,
                                (PCSTR) MSG_LONG_BACKUP_PATH,
                                g_ConfigOptions.PathForBackup
                                ));
                            pAbortSetup (hdlg);
                            return FALSE;
                        }

                        backupPathSet = TRUE;

                        for (i = 0; i < NumberAvailableDrives; i++) {
                            if(_totlower(g_ConfigOptions.PathForBackup[0]) == _totlower(Drives[i])) {
                                break;
                            }
                        }

                        if (i == NumberAvailableDrives) {
                            //
                            // Backup impossible on g_ConfigOptions.PathForBackup drive.
                            // If backup is required, fail setup now.
                            //

                            if (TRISTATE_REQUIRED == g_ConfigOptions.EnableBackup){
                                LOG ((
                                    LOG_ERROR,
                                    (PCSTR) MSG_STOP_BECAUSE_CANT_BACK_UP_2,
                                    g_ConfigOptions.PathForBackup
                                    ));
                                pAbortSetup (hdlg);
                                return FALSE;
                            }

                            //
                            // otherwise continue without a backup and skip this page too
                            //

                            g_ConfigOptions.EnableBackup = TRISTATE_NO;
                            b = FALSE;
                        }

                        if(UNATTENDED()){
                            b = FALSE;
                        }

                    } else {

                        //
                        // No backup path was specified. If unattended
                        // mode, pick first choice and skip this page.
                        //

                        if (UNATTENDED()) {
                            //wsprintf (PathForBackup, TEXT("%c:\\undo"), Drives[0]);
                            pathForBackupTemp = pConstructPathForBackup(Drives[0]);
                            if(pathForBackupTemp){
                                StringCopy(PathForBackup, pathForBackupTemp);
                                DEBUGMSG ((DBG_VERBOSE, "Selecting drive %c and path %s for backup, ", Drives[0], PathForBackup));

                                g_ConfigOptions.PathForBackup = PathForBackup;
                                backupPathSet = TRUE;
                            }ELSE_DEBUGMSG((DBG_ERROR, "Can't construct directory for backup."));

                            b = FALSE;
                        }
                    }
                }

                if (!b) {   // page not needed
                    //
                    // Send private deactivate msg to ourselves and return FALSE
                    //
                    SendMessage (hdlg, uMsg, FALSE, 0);
                    return FALSE;
                }

                if (!initialized) {
                    //
                    // At this point we know we must present this page to the user.
                    //
                    // The code below dynamically generates controls based on how many
                    // drives we have to present. This code can only run once.
                    //

                    GetClientRect (hdlg, &PageRect);

                    hFirstRadioButton = GetDlgItem(hdlg, IDC_BACKUP_FIRST);
                    GetWindowRect (hFirstRadioButton, &EtalonRadioButtonRect);

                    widthRadio = EtalonRadioButtonRect.right - EtalonRadioButtonRect.left;
                    heightRadio = EtalonRadioButtonRect.bottom - EtalonRadioButtonRect.top;

                    pointForTransform.x = EtalonRadioButtonRect.left;
                    pointForTransform.y = EtalonRadioButtonRect.top;

                    MapWindowPoints (NULL, hdlg, &pointForTransform, 1);

                    NumberOfPossibleRadioButtonsByVertical = (PageRect.bottom - pointForTransform.y) /
                                                             (EtalonRadioButtonRect.bottom - EtalonRadioButtonRect.top);

                    hFontOfFirstRadioButton = (HFONT) SendMessage(hFirstRadioButton, WM_GETFONT, 0, 0);
                    hDefaultRadioButton = 0;
                    TemplateStyle = GetWindowLong(hFirstRadioButton, GWL_STYLE);
                    TemplateStyleEx = GetWindowLong(hFirstRadioButton, GWL_EXSTYLE);

                    for(i = 0; i < NumberAvailableDrives; i++) {

                        wsprintf(DriveText, TEXT("%c:\\"), Drives[i]);
                        wsprintf(DiskSpace, TEXT("%d"), (UINT)(AvailableSpace[i].QuadPart / (1 << 20)));

                        ArgArray[0] = DriveText;
                        ArgArray[1] = DiskSpace;
                        Msg = ParseMessageID (MSG_DISK_AND_FREE_DISK_SPACE, ArgArray);
                        if (Msg) {

                            if(!i){
                                SetWindowText(hFirstRadioButton, Msg);
                                hRadioButton = hFirstRadioButton;
                            }
                            else {

                                xOffset = i / NumberOfPossibleRadioButtonsByVertical;
                                yOffset = i % NumberOfPossibleRadioButtonsByVertical;

                                hRadioButton = CreateWindowEx(
                                                        TemplateStyleEx,
                                                        TEXT("Button"),
                                                        Msg,
                                                        TemplateStyle,
                                                        xOffset * widthRadio + pointForTransform.x,
                                                        yOffset * heightRadio + pointForTransform.y,
                                                        widthRadio,
                                                        heightRadio,
                                                        hdlg,
                                                        (HMENU) (IDC_BACKUP_FIRST + i),
                                                        g_hInst,
                                                        NULL
                                                        );
                                SendMessage(
                                    hRadioButton,
                                    WM_SETFONT,
                                    (WPARAM) hFontOfFirstRadioButton,
                                    TRUE
                                    );
                            }

                            SetWindowLong (hRadioButton, GWL_USERDATA, (LONG) Drives[i]);

                            FreeStringResource (Msg);
                        }
                        ELSE_DEBUGMSG ((DBG_ERROR, "Unable to load string resource on BackupDriveSelection wizard page. Check localization."));

                        if(Drives[i] == g_WinDir[0]) {
                            hDefaultRadioButton = hRadioButton;
                        }
                    }

                    if(!hDefaultRadioButton) {
                        hDefaultRadioButton = hFirstRadioButton;
                    }

                    SendMessage (hdlg, WM_NEXTDLGCTL, (WPARAM) hDefaultRadioButton, 1L);
                    SendMessage (hDefaultRadioButton, BM_SETCHECK, BST_CHECKED, 0);

                    wsprintf(DiskSpace, TEXT("%d"), (UINT)(g_SpaceNeededForSlowBackup.QuadPart / (1<<20)));
                    ArgArray[0] = DiskSpace;
                    Msg = ParseMessageID (MSG_DISK_SPACE, ArgArray);
                    if (Msg) {
                        SetWindowText(GetDlgItem(hdlg, IDC_DISKSPACE), Msg);
                        FreeStringResource (Msg);
                    }
                    ELSE_DEBUGMSG ((DBG_ERROR, "Unable to load string resource on BackupDriveSelection wizard page. Check localization."));

                    initialized = TRUE;
                }

                //
                // Enable next, disable back
                //

                PropSheet_SetWizButtons (GetParent(hdlg), PSWIZB_BACK | PSWIZB_NEXT);

                //
                // Stop the billboard and make sure the wizard shows again.
                //

                SendMessage(GetParent (hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);

            } else {
                //
                // Deactivating... this is were we output the backup options
                // to winnt.sif.
                //

                if (g_ConfigOptions.EnableBackup && !backupPathSet) {

                    MYASSERT (!g_SilentBackupMode);
                    MYASSERT (!UNATTENDED());

                    //
                    // Compute the new path for backup by getting the UI choice
                    //

                    g_ConfigOptions.PathForBackup = PathForBackup;

                    selectedDrive = g_WinDir[0];

                    for (i = 0 ; i < NumberAvailableDrives ; i++) {

                        if (IsDlgButtonChecked (hdlg, IDC_BACKUP_FIRST + i)) {
                            selectedDrive = (TCHAR) GetWindowLong (
                                                        GetDlgItem (hdlg, IDC_BACKUP_FIRST + i),
                                                        GWL_USERDATA
                                                        );
                            break;
                        }
                    }

                    //wsprintf (PathForBackup, TEXT("%c:\\undo"), selectedDrive);
                    pathForBackupTemp = pConstructPathForBackup(selectedDrive);
                    if(pathForBackupTemp){
                        StringCopy(PathForBackup, pathForBackupTemp);
                    }ELSE_DEBUGMSG((DBG_ERROR, "Can't construct directory for backup."));
                }

                //
                // Write the proper setting to winnt.sif
                //

                if (g_ConfigOptions.PathForBackup && g_ConfigOptions.EnableBackup) {

                    WriteInfKey (S_WIN9XUPGUSEROPTIONS, S_ENABLE_BACKUP, S_YES);

                    PathForBackupImage = JoinPaths (g_ConfigOptions.PathForBackup, TEXT("backup.cab"));

                    WriteInfKey (WINNT_DATA, WINNT_D_BACKUP_IMAGE, PathForBackupImage);
                    WriteInfKey (S_WIN9XUPGUSEROPTIONS, S_PATH_FOR_BACKUP, g_ConfigOptions.PathForBackup);

                    disableCompression = FALSE;
                    if (g_ConfigOptions.DisableCompression != TRISTATE_NO){
                        for(i = 0; i < NumberAvailableDrives; i++){

                            if (_totlower (Drives[i]) == _totlower (g_ConfigOptions.PathForBackup[0])){
                                disableCompression = IsPossibleBackupWithoutCompression[i];

                                DEBUGMSG ((DBG_VERBOSE, "Info for PathForBackup found; disableCompression=%u", (UINT) disableCompression));
                                break;
                            }
                        }
                    }

                    WriteInfKey (
                        S_WIN9XUPGUSEROPTIONS,
                        WINNT_D_DISABLE_BACKUP_COMPRESSION,
                        disableCompression? S_YES: S_NO
                        );

                    if (disableCompression) {
                        if (!UseSpace (PathForBackupImage, g_SpaceNeededForFastBackup.QuadPart)) {
                            FreeSpace (PathForBackupImage, g_SpaceNeededForFastBackup.QuadPart);
                            MYASSERT (FALSE);
                        }
                    } else {
                        if (!UseSpace (PathForBackupImage, g_SpaceNeededForSlowBackup.QuadPart)) {
                            FreeSpace (PathForBackupImage, g_SpaceNeededForSlowBackup.QuadPart);
                            MYASSERT (FALSE);
                        }
                    }

                    FreePathString (PathForBackupImage);

                } else {
                    WriteInfKey (S_WIN9XUPGUSEROPTIONS, S_ENABLE_BACKUP, S_NO);
                    WriteInfKey (S_WIN9XUPGUSEROPTIONS, WINNT_D_DISABLE_BACKUP_COMPRESSION, S_NO);

                    WriteInfKey (WINNT_DATA, WINNT_D_BACKUP_LIST, NULL);
                    WriteInfKey (WINNT_DATA, WINNT_D_BACKUP_IMAGE, NULL);
                    WriteInfKey (S_WIN9XUPGUSEROPTIONS, S_PATH_FOR_BACKUP, NULL);
                }
            }

            return TRUE;

       default:
            break;
        }
    } __except (1) {

        LOG ((LOG_WARNING, "An unhandled exception occurred during the processing of the BackupDriveSelection Page."));
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_UNEXPECTED_ERROR_ENCOUNTERED_NORC));
        SafeModeExceptionOccured ();
        pAbortSetup (hdlg);
    }

    return FALSE;
}
// LastPageProc is used for the last page special case

BOOL
UI_BackupImpossibleInfoProc (
    IN      HWND hdlg,
    IN      UINT uMsg,
    IN      WPARAM wParam,
    IN      LPARAM lParam
    )

/*++

Routine Description:

  UI_BackupImpossibleInfo is the wizard window procedure that is called to
  show message that backup impossible

Arguments:

  hdlg      - Specifies the dialog handle

  uMsg      - Specifies the message to process

  wParam    - Specifies the wParam data associated with the message

  lParam    - Specifies the lParam data associated with the message

Return Value:

  WMX_ACTIVATEPAGE: On activation (wParam is TRUE), returns FALSE if
                    page is to be skipped; returns TRUE if page is
                    to be processed.

                    On deactivation (wParam is FALSE), returns FALSE
                    if the page is not to be deactivated; returns
                    TRUE if the page is to be deactivated.

  WM_NOTIFY:        Returns FALSE

  WM_COMMAND:       Returns TRUE if command is processed; FALSE if
                    command is not processed.

  Others:           Returns FALSE.

--*/

{
    PCTSTR ArgArray[1];
    PCTSTR Msg;
    TCHAR DiskSpace[32];
    INT i;

    __try {
        switch (uMsg) {

        case WMX_ACTIVATEPAGE:
            if (wParam) {
                if (!UPGRADE() || CANCELLED()) {
                    return FALSE;
                }

                //
                // If unattended mode, skip page.
                //
                if (UNATTENDED()) {
                    return FALSE;
                }

                if(g_ShowBackupImpossiblePage != BIP_NOT_ENOUGH_SPACE) {
                    return FALSE;
                }

                DEBUGLOGTIME(("BackupImpossibleInfo Wizard Page..."));

                wsprintf(DiskSpace, TEXT("%d"), (UINT)(g_SpaceNeededForSlowBackup.QuadPart / (1<<20)));
                ArgArray[0] = DiskSpace;
                ParseMessageInWnd (GetDlgItem(hdlg, IDC_DISKSPACE), ArgArray);

                PropSheet_SetWizButtons (GetParent(hdlg), PSWIZB_NEXT);

                //
                // Stop the billboard and make sure the wizard shows again.
                //

                SendMessage(GetParent (hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);

            }
            return TRUE;

       default:
            break;
        }
    } __except (1) {

        LOG ((LOG_WARNING, "An unhandled exception occurred during the processing of the BackupImpossibleInfo Page."));
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_UNEXPECTED_ERROR_ENCOUNTERED_NORC));
        SafeModeExceptionOccured ();
        pAbortSetup (hdlg);
    }

    return FALSE;
}

BOOL
UI_BackupImpExceedLimitProc (
    IN      HWND hdlg,
    IN      UINT uMsg,
    IN      WPARAM wParam,
    IN      LPARAM lParam
    )

/*++

Routine Description:

  UI_BackupImpExceedLimitProc is the wizard window procedure that is called to
  show message that backup impossible

Arguments:

  hdlg      - Specifies the dialog handle

  uMsg      - Specifies the message to process

  wParam    - Specifies the wParam data associated with the message

  lParam    - Specifies the lParam data associated with the message

Return Value:

  WMX_ACTIVATEPAGE: On activation (wParam is TRUE), returns FALSE if
                    page is to be skipped; returns TRUE if page is
                    to be processed.

                    On deactivation (wParam is FALSE), returns FALSE
                    if the page is not to be deactivated; returns
                    TRUE if the page is to be deactivated.

  WM_NOTIFY:        Returns FALSE

  WM_COMMAND:       Returns TRUE if command is processed; FALSE if
                    command is not processed.

  Others:           Returns FALSE.

--*/

{
    PCTSTR ArgArray[1];
    PCTSTR Msg;
    TCHAR DiskSpace[32];
    INT i;

    __try {
        switch (uMsg) {

        case WMX_ACTIVATEPAGE:
            if (wParam) {
                if (!UPGRADE() || CANCELLED()) {
                    return FALSE;
                }

                //
                // If unattended mode, skip page.
                //
                if (UNATTENDED()) {
                    return FALSE;
                }

                if(g_ShowBackupImpossiblePage != BIP_SIZE_EXCEED_LIMIT) {
                    return FALSE;
                }

                DEBUGLOGTIME(("BackupImpExceedLimit Wizard Page..."));

                wsprintf(DiskSpace, TEXT("%d"), (UINT)(g_SpaceNeededForSlowBackup.QuadPart / (1<<20)));
                ArgArray[0] = DiskSpace;
                ParseMessageInWnd (GetDlgItem(hdlg, IDC_DISKSPACE), ArgArray);

                PropSheet_SetWizButtons (GetParent(hdlg), PSWIZB_NEXT);

                //
                // Stop the billboard and make sure the wizard shows again.
                //

                SendMessage(GetParent (hdlg), WMX_BBTEXT, (WPARAM)FALSE, 0);

            }
            return TRUE;

       default:
            break;
        }
    } __except (1) {

        LOG ((LOG_WARNING, "An unhandled exception occurred during the processing of the BackupImpExceedLimit Page."));
        LOG ((LOG_FATAL_ERROR, (PCSTR) MSG_UNEXPECTED_ERROR_ENCOUNTERED_NORC));
        SafeModeExceptionOccured ();
        pAbortSetup (hdlg);
    }

    return FALSE;
}

BOOL
UI_LastPageProc (
    HWND hdlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam
    )
{
    PCTSTR ArgArray[3];
    PCTSTR Msg;
    TCHAR Num1[32];
    TCHAR Num2[32];
    UINT LowEstimate;
    UINT HighEstimate;
    UINT MsgId;

    __try {
        switch (uMsg) {

        case WMX_ACTIVATEPAGE:
            if (wParam) {
                if (!UPGRADE()) {
                    return FALSE;
                }

                if (CANCELLED()) {
                    PostMessage (GetParent (hdlg), PSM_PRESSBUTTON, PSBTN_CANCEL, 0);
                }

                MYASSERT (!REPORTONLY());

                if (UNATTENDED() || TYPICAL()) {

                    //
                    // Make sure we clean up the data in the report.
                    //
                    if (g_TextViewInDialog) {
                        SendMessage (g_TextViewInDialog, WMX_CLEANUP, 0, 0);
                        g_TextViewInDialog = NULL;
                    }
                    return FALSE;
                }

                DEBUGLOGTIME(("Last Wizard Page..."));

                //
                // Compute the time estimate
                //

                DEBUGMSG ((DBG_VERBOSE, "g_ProgressBarTime: %u", g_ProgressBarTime));

                LowEstimate = (g_ProgressBarTime - 70000) / 12000;
                LowEstimate = (LowEstimate / 5) * 5;
                LowEstimate = min (LowEstimate, 45);
                LowEstimate += 30;

                HighEstimate = LowEstimate + 15;

                DEBUGMSG ((DBG_VERBOSE, "GUI mode time estimate: %u to %u mins", LowEstimate, HighEstimate));

                //
                // Fill in text of the IDC_TEXT1 control
                //

                wsprintf (Num1, TEXT("%u"), LowEstimate);
                wsprintf (Num2, TEXT("%u"), HighEstimate);

                ArgArray[0] = Num1;
                ArgArray[1] = Num2;
                ArgArray[2] = g_Win95Name;

                if (g_ForceNTFSConversion && *g_ForceNTFSConversion) {
                    MsgId = MSG_LAST_PAGE_WITH_NTFS_CONVERSION;
                }
                else {
                    MsgId = MSG_LAST_PAGE;
                }

                Msg = ParseMessageID (MsgId, ArgArray);
                if (Msg) {
                    SetDlgItemText (hdlg, IDC_TEXT1, Msg);
                    FreeStringResource (Msg);
                }
                ELSE_DEBUGMSG ((DBG_ERROR, "Unable to load string resource on last wizard page. Check localization."));

                PropSheet_SetWizButtons (GetParent(hdlg), PSWIZB_NEXT|PSWIZB_BACK);

            } else {
                if (lParam != PSN_WIZBACK && g_TextViewInDialog) {
                    SendMessage (g_TextViewInDialog, WMX_CLEANUP, 0, 0);
                    g_TextViewInDialog = NULL;
                }
            }

            return TRUE;
        }
    } __except (1) {

        LOG ((LOG_WARNING, "An unhandled exception occurred during the processing of the Last Page."));
        SafeModeExceptionOccured ();
    }
    return FALSE;
}


BOOL
NewProgessProc(
    IN HWND   hdlg,
    IN UINT   msg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    HWND hwndWizard = GetParent(hdlg);
    hwndWizard = GetParent(hwndWizard);
    if (hwndWizard)
    {
        switch (msg)
        {
            case PBM_DELTAPOS:
                SendMessage(hwndWizard,WMX_PBM_DELTAPOS,wParam,lParam);
                break;
            case PBM_SETRANGE:
                SendMessage(hwndWizard,WMX_PBM_SETRANGE,wParam,lParam);
                break;
            case PBM_STEPIT:
                SendMessage(hwndWizard,WMX_PBM_STEPIT,wParam,lParam);
                break;
            case PBM_SETPOS:
                SendMessage(hwndWizard,WMX_PBM_SETPOS,wParam,lParam);
                break;
            case PBM_SETSTEP:
                SendMessage(hwndWizard,WMX_PBM_SETSTEP,wParam,lParam);
                break;
        }
    }
    return (BOOL)CallWindowProc(OldProgressProc,hdlg,msg,wParam,lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\commonnt\file.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    file.c

Abstract:

    General file-related functions.

Author:

    Souren Aghajanyan   12-Jul-2001

Revision History:

    sourenag    12-Jul-2001 RenameOperation supports function

--*/

#include "pch.h"

#define UNDO_FILE_NAME  L"UNDO_GUIMODE.TXT"


BOOL
pRenameOnRestartOfGuiMode (
    IN OUT  HANDLE *UndoHandlePtr,      OPTIONAL
    IN      PCWSTR PathName,
    IN      PCWSTR PathNameNew          OPTIONAL
    )
{
    DWORD dontCare;
    BOOL result;
    static WCHAR undoFilePath[MAX_PATH];
    BYTE signUnicode[] = {0xff, 0xfe};
    DWORD filePos;
    HANDLE undoHandle;

    if (!PathName) {
        MYASSERT (FALSE);
        return FALSE;
    }

    if (!UndoHandlePtr || !(*UndoHandlePtr)) {

        if (!undoFilePath[0]) {
            //
            // Create the path to the journal file
            //

            wsprintfW (undoFilePath, L"%s\\" UNDO_FILE_NAME, g_System32Dir);
        }

        //
        // Open the journal file
        //

        undoHandle = CreateFileW (
                        undoFilePath,
                        GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );

        if (undoHandle == INVALID_HANDLE_VALUE) {
            LOG ((LOG_ERROR, "Failed to open journal file %s", undoFilePath));
            return FALSE;
        }

        MYASSERT (undoHandle);      // never NULL

    } else {
        undoHandle = *UndoHandlePtr;
    }

    //
    // Move to the end of the journal, and if the journal is empty, write the UNICODE header
    //

    filePos = SetFilePointer (undoHandle, 0, NULL, FILE_END);

    if (!filePos) {
        result = WriteFile (undoHandle, signUnicode, sizeof(signUnicode), &dontCare, NULL);
    } else {
        result = TRUE;
    }

    //
    // Output the move or delete operation
    //

    result = result && WriteFile (
                            undoHandle,
                            L"\\??\\",
                            8,
                            &dontCare,
                            NULL
                            );

    result = result && WriteFile (
                            undoHandle,
                            PathName,
                            ByteCountW (PathName),
                            &dontCare,
                            NULL
                            );

    result = result && WriteFile (
                            undoHandle,
                            L"\r\n",
                            4,
                            &dontCare,
                            NULL
                            );

    if (PathNameNew) {
        result = result && WriteFile (
                                undoHandle,
                                L"\\??\\",
                                8,
                                &dontCare,
                                NULL
                                );

        result = result && WriteFile (
                                undoHandle,
                                PathNameNew,
                                ByteCountW (PathNameNew),
                                &dontCare,
                                NULL
                                );
    }

    result = result && WriteFile (
                            undoHandle,
                            L"\r\n",
                            4,
                            &dontCare,
                            NULL
                            );

    if (!result) {
        //
        // On failure, log an error and truncate the file
        //

        LOGW ((
            LOG_ERROR,
            "Failed to record move in restart journal: %s to %s",
            PathName,
            PathNameNew
            ));

        SetFilePointer (undoHandle, filePos, NULL, FILE_BEGIN);
        SetEndOfFile (undoHandle);
    }

    if (UndoHandlePtr) {

        if (!(*UndoHandlePtr)) {
            //
            // If caller did not pass in handle, then we opened it.
            //

            if (result) {
                *UndoHandlePtr = undoHandle;        // give ownership to caller
            } else {
                FlushFileBuffers (undoHandle);
                CloseHandle (undoHandle);           // fail; don't leak handle
            }
        }

    } else {
        //
        // Caller wants to record just one move
        //

        FlushFileBuffers (undoHandle);
        CloseHandle (undoHandle);
    }

    return result;
}


BOOL
RenameOnRestartOfGuiMode (
    IN      PCWSTR PathName,
    IN      PCWSTR PathNameNew          OPTIONAL
    )
{
    return pRenameOnRestartOfGuiMode (NULL, PathName, PathNameNew);
}

BOOL
RenameListOnRestartOfGuiMode (
    IN      PGROWLIST SourceList,
    IN      PGROWLIST DestList
    )
{
    UINT u;
    UINT count;
    PCWSTR source;
    PCWSTR dest;
    HANDLE journal = NULL;

    count = GrowListGetSize (SourceList);
    for (u = 0 ; u < count ; u++) {

        source = GrowListGetString (SourceList, u);
        if (!source) {
            continue;
        }

        dest = GrowListGetString (DestList, u);

        if (!pRenameOnRestartOfGuiMode (&journal, source, dest)) {
            break;
        }
    }

    if (journal) {
        FlushFileBuffers (journal);
        CloseHandle (journal);
    }

    return u == count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\winntsif\buildinf.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    buildinf.c

Abstract:

    The functions in this file are a set of APIs to build an INF,
    merge existing INFs, and write the INF to disk.

Author:

    Jim Schmidt (jimschm) 20-Sept-1996

Revision History:

    marcw       30-Jun-1999 pWriteDelAndMoveFiles is now done in a seperate function so that
                            it can be on the progress bar and not cause an uncomfortable delay
                            after the user passes the progress bar.
    marcw       09-Feb-1999 Filter out quotes in values -- Not supported by inf parser
                            in NTLDR.
    ovidiut     03-Feb-1999 Ensure that directory collision moves are done first
                            in mov/del files.
    jimschm     23-Sep-1998 Updated for new fileops
    marcw       23-Jul-1998 Removed lots of intermediary conversions (MB->W->MB->W)
                            in writing the win9xmov and win9xdel txt files.
                            (Fixes problems with certain characters that were messed
                            up in the translations.)
    marcw       10-Jun-1998 Added support for multiple keys with the same name.
    marcw       08-Apr-1998 Fixed problems associated with some conversions.
    marcw       08-Apr-1998 All values are automatically quoted now..Matches winnt32 behavior.
    calinn      25-Mar-1998 fixed unicode header writing error
    marcw       16-Dec-1997 pWriteDelAndMoveFiles now writes to a unicode file instead of winnt.sif.
    mikeco      11-Nov-1997 DBCS issues.
    jimschm     21-Jul-1997 pWriteDelAndMoveFiles (see fileops.c in memdb)
    mikeco      10-Jun-1997 DBCS issues.
    marcw       09-Apr-1997 Performance tuned memdb usage.
    marcw       01-Apr-1997 Re-engineered this code..Now memdb based. shorter.
                            also added smart-merge for migration DLLs.
    jimschm     03-Jan-1997 Re-enabled memory-based INF building code

--*/
#include "pch.h"

#define MAX_LINE_LENGTH 512
#define MIN_SPLIT_COL   490
#define MAX_OEM_PATH    (MAX_PATH*2)

#define WACKREPLACECHAR 2
#define REPLACE_WACKS   TRUE
#define RESTORE_WACKS   FALSE

#define SECTION_NAME_SIZE 8192


//
// These levels refer to the MEMDB_ENUM structure component nCurPos.
// They were determined empirically in test to be the correct values
//
#define SECTIONLEVEL    3
#define KEYLEVEL        4
#define VALUELEVEL      5

#define BUILDINF_UNIQUEKEY_PREFIX TEXT("~BUILDINF~UNIQUE~")
#define BUILDINF_NULLKEY_PREFIX TEXT("~BUILDINF~NULLKEY~")
#define BUILDINF_UNIQUEKEY_PREFIX_SIZE  17


TCHAR g_DblQuote[] = TEXT("\"");
TCHAR g_Comments[] = TEXT(";\r\n; Setup-generated migration INF file\r\n;\r\n\r\n");

extern HINF g_Win95UpgInf;
BOOL g_AnswerFileAlreadyWritten;


BOOL pWriteStrToFile (HANDLE File, PCTSTR String, BOOL ConvertToUnicode);
BOOL pWriteSectionString (HANDLE File, PCTSTR szString, BOOL ConvertToUnicode, BOOL Quote);
BOOL pWriteSections (HANDLE File,BOOL ConvertToUnicode);
BOOL pWriteDelAndMoveFiles (VOID);


BOOL
WINAPI
BuildInf_Entry(IN HINSTANCE hinstDLL,
         IN DWORD dwReason,
         IN LPVOID lpv)

/*++

Routine Description:

  DllMain is called after the C runtime is initialized, and its purpose
  is to initialize the globals for this process.  For this DLL, it
  initializes g_hInst and g_hHeap.

Arguments:

  hinstDLL  - (OS-supplied) Instance handle for the DLL
  dwReason  - (OS-supplied) Type of initialization or termination
  lpv       - (OS-supplied) Unused

Return Value:

  TRUE because DLL always initializes properly.

--*/

{
    switch (dwReason) {

    case DLL_PROCESS_ATTACH:
        g_AnswerFileAlreadyWritten = FALSE;
        break;

    case DLL_PROCESS_DETACH:
        break;
    }

    UNREFERENCED_PARAMETER(hinstDLL);
    UNREFERENCED_PARAMETER(lpv);

    return TRUE;
}

VOID
pHandleWacks(
    IN OUT  PSTR String,
    IN      BOOL Operation
    )

/*++

Routine Description:

  pHandleWack is a simple helper function who's purpose is to remove/restore
  the wacks in a string. This is necessary because there are cases where we
  want to have wacks in keys and values without invoking the memdb
  functionality of using those wacks to indicate new tree nodes.

Arguments:

  String    - The string to perform the replacement on.
  Operation - set to REPLACE_WACKS if the function should replace the wacks
              in a string and RESTORE_WACKS if they should restore them.

Return Value:

  None.

--*/


{

    TCHAR findChar;
    TCHAR replaceChar;
    PSTR  curChar;


    //
    // Set find and replace chars based on operation.
    //
    if (Operation == REPLACE_WACKS) {

        findChar    = TEXT('\\');
        replaceChar = TEXT(WACKREPLACECHAR);
    }
    else {

        findChar    = TEXT(WACKREPLACECHAR);
        replaceChar = TEXT('\\');
    }

    if ((curChar = _tcschr(String,findChar)) != NULL) {
        do {
            *curChar = replaceChar;
        } while ((curChar = _tcschr(curChar,findChar)) != NULL);
    }
}

BOOL
WriteInfToDisk (
    IN PCTSTR OutputFile
    )

/*++

Routine Description:

  WriteInfToDisk outputs the memory based INF file that has been built to disk.

Arguments:

  OutputFile - A full path to the output INF file.

Return Value:

  Returns TRUE if the INF file was successfully written, or FALSE
  if an I/O error was encountered.  Call GetLastError upon failure
  for a Win32 error code.

--*/

{
    HANDLE      hFile;
    MEMDB_ENUM  e;
    BOOL        b = FALSE;
    TCHAR       category[MEMDB_MAX];

    if (g_AnswerFileAlreadyWritten) {
        LOG ((LOG_ERROR,"Answer file has already been written to disk."));
        return FALSE;
    }

    //
    // set flag indicating that answerfile is closed for business.
    //
    g_AnswerFileAlreadyWritten = TRUE;

    //
    // Write an INF
    //
    hFile = CreateFile (OutputFile,
                        GENERIC_WRITE,
                        0,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL);

    if (hFile != INVALID_HANDLE_VALUE) {

        __try {

#ifdef UNICODE
            //
            // Write UNICODE signature
            //

            if (!pWriteStrToFile (hFile, (LPCTSTR) "\xff\xfe\0",FALSE))
                __leave;
#endif

            //
            // Write comments
            //

            if (!pWriteStrToFile (hFile, g_Comments,FALSE))
                __leave;

            //
            // Write out sections.
            //


            if (!pWriteSections (hFile,FALSE))
                __leave;


            //
            // Delete Answer file parts of memdb.
            //


            MemDbDeleteTree(MEMDB_CATEGORY_UNATTENDRESTRICTRIONS);
            MemDbDeleteTree(MEMDB_CATEGORY_AF_VALUES);
            if (MemDbEnumItems(&e,MEMDB_CATEGORY_AF_SECTIONS)) {
                do {

                    wsprintf(category,S_ANSWERFILE_SECTIONMASK,e.szName);
                    MemDbDeleteTree(category);

                } while (MemDbEnumNextValue(&e));

            }

            MemDbDeleteTree(MEMDB_CATEGORY_AF_SECTIONS);


            b = TRUE;       // indicate success
        }

        __finally {
            CloseHandle (hFile);
        }
    }

    return b;
}




BOOL
pWriteStrToFile (
    IN HANDLE       File,
    IN LPCTSTR      String,
    IN BOOL         ConvertToUnicode
    )

/*++

Routine Description:

  pWriteStrToFile takes a zero-terminated string and writes it
  to the open file indicated by File. Optionally, the function can
  convert its string argument into a unicode string.

Arguments:

  File  - A handle to an open file with write permission.
  String  - A pointer to the string to write.  The string is written
           to the file, but the zero terminator is not written to
           the file.
  ConvertToUnicode - True if you wish to convert to unicode, false otherwise.

Return Value:

  TRUE if the write succeeds, or FALSE if an I/O error occurred.
  GetLastError() can be used to get more error information.

--*/

{

    DWORD   bytesWritten    = 0;
    DWORD   size            = 0;
    BOOL    rFlag           = TRUE;
    PBYTE   data            = NULL;
    WCHAR   unicodeString[MEMDB_MAX];

    if (ConvertToUnicode) {

        size = _mbslen(String);

        MultiByteToWideChar (
             CP_OEMCP,
             0,
             String,
             -1,
             unicodeString,
             MEMDB_MAX
             );


        data = (PBYTE) unicodeString;
        size = ByteCountW(unicodeString);
    }
    else {
        data = (PBYTE) String;
        size = ByteCount(String);
    }

    rFlag = WriteFile (File, data, size, &bytesWritten, NULL);
    if (bytesWritten != size) {
        rFlag = FALSE;
    }


    return rFlag;
}


BOOL
pIsDoubledChar (
    CHARTYPE Char
    )

/*++

Routine Description:

  This simple function simply returns true if the character in question is a
  double quote or a percent sign.

Arguments:

  Char - The character in question.

Return Value:



--*/


{

    return Char == TEXT('\"') || Char == TEXT('%');
}


BOOL
pWriteSectionString (
    HANDLE  File,
    LPCTSTR String,
    BOOL    ConvertToUnicode,
    BOOL    Quote
    )

/*++

Routine Description:

  pWriteSectionString writes a line in a section to disk.

  If the string has a character that requires quote mode, the
  string is surrounded by quotes, and all literal quotes and
  percent signs are doubled-up.

Arguments:

  File   - A handle to an open file with write permission.
  String - A pointer to the string holding the section line.
  ConvertToUnicode - TRUE if the line in question should be
    converted to UNICODE, FALSE otherwise.
  Quote  - Automatically Quotes the string if set to TRUE.

Return Value:

  TRUE if the write succeeds, or FALSE if an I/O error occurred.
  GetLastError() can be used to get more error information.

--*/

{
    TCHAR buffer[256];
    int i;
    int doubles;
    PTSTR dest;
    CHARTYPE tc;


    //
    // Initialize variables first time through the loop.
    //
    doubles = 0;
    dest = buffer;



    while (*String) {

        //
        // Add initial quote
        //
        if (Quote) {
            StringCopy (dest, g_DblQuote);
            dest = _tcsinc (dest);
        }

        //
        // Copy as many characters as can fit on the line
        //
        tc = 0;

        for (i = 0 ; *String && i + doubles < MAX_LINE_LENGTH ; i++) {
            if (i + doubles > MIN_SPLIT_COL)
                tc = _tcsnextc (String);

            //
            // Double up certain characters when in quote mode
            //
            if (Quote && pIsDoubledChar (_tcsnextc (String))) {

                doubles++;
                //
                // Copy a UNICODE/MBCS char, leaving src in place
                //
                _tcsncpy (dest, String, (_tcsinc(String)-String));
                dest = _tcsinc (dest);
            }

            //
            // Copy a UNICODE/MBCS char, advancing src/tgt
            //
            _tcsncpy (dest, String, (_tcsinc(String)-String));
            dest = _tcsinc (dest);
            String = _tcsinc (String);

            //
            // Test split condition (NOTE: tc == 0 when i + doubles <= MIN_SPLIT_COL)
            //
            if (tc && (tc == TEXT(',') || tc == TEXT(' ') || tc == TEXT('\\'))) {

                break;
            }
        }

        //
        // Add a trailing quote
        //
        if (Quote) {

            StringCopy (dest, g_DblQuote);
            dest = _tcsinc (dest);

        }

        //
        // Add trailing wack if line is split
        //
        if (*String) {
            *dest = TEXT('\\');
            dest = _tcsinc (dest);
        }

        *dest = 0;

        //
        // Write line to disk
        //
        if (!pWriteStrToFile (File, buffer,ConvertToUnicode)) {
            DEBUGMSG ((DBG_ERROR, "pWriteSectionString: pWriteStrToFile failed"));
            return FALSE;
        }

        //
        // Reset for next time through the while loop
        //
        doubles = 0;
        dest = buffer;
    }

    return TRUE;
}



BOOL
pWriteSections (
    IN HANDLE File,
    IN BOOL   ConvertToUnicode
    )

/*++

Routine Description:

  pWriteSections enumerates all of the sections stored by previous calls to
  WriteInfKey and WriteInfKeyEx, and writes these sections to the open file
  specified by File.

Arguments:

  File  - An open file.
  ConvertToUnicode - Set to TRUE if the lines should be converted to UNICODE, FALSE otherwise.

Return Value:

  TRUE if the write succeeds, or FALSE if an I/O error occurred.
  GetLastError() can be used to get more error information.

--*/


{
    MEMDB_ENUM  e;
    TCHAR       buffer[MAX_TCHAR_PATH];
    PTSTR       sectionName;
    PTSTR       p;
    BOOL        firstTime = FALSE;
    BOOL        nullKey = FALSE;


    //
    // enumerate the memdb sections and keys section.
    //
    if (MemDbEnumFirstValue (&e, MEMDB_CATEGORY_AF_SECTIONS, MEMDB_ALL_SUBLEVELS, MEMDB_ALL_BUT_PROXY)) {
        do {

            switch(e.PosCount) {

            case SECTIONLEVEL:
                //
                // Write the Section Name to the File, surrounded by Brackets.
                //
                if (!pWriteStrToFile (File, TEXT("\r\n\r\n"),ConvertToUnicode)) {
                    DEBUGMSG ((DBG_ERROR, "pWriteSections: pWriteStrToFile failed"));
                    return FALSE;
                }

                if (!pWriteStrToFile (File, TEXT("["),ConvertToUnicode)) {
                    DEBUGMSG ((DBG_ERROR, "pWriteSections: pWriteStrToFile failed"));
                    return FALSE;
                }

                if ((sectionName = _tcschr(e.szName,TEXT('\\'))) == NULL || (sectionName = _tcsinc(sectionName)) == NULL) {
                    LOG ((LOG_ERROR,"Invalid section name for answer file."));
                    return FALSE;
                }

                //
                // put wacks back in if necessary.
                //
                pHandleWacks(sectionName,RESTORE_WACKS);

                if (!pWriteStrToFile (File, sectionName,ConvertToUnicode)) {
                    DEBUGMSG ((DBG_ERROR, "pWriteSections: pWriteStrToFile failed"));
                    return FALSE;
                }

                if (!pWriteStrToFile (File, TEXT("]"),ConvertToUnicode)) {
                    DEBUGMSG ((DBG_ERROR, "pWriteSections: pWriteStrToFile failed"));
                    return FALSE;
                }
                break;

            case KEYLEVEL:
                //
                // Key name.
                //
                if (!pWriteStrToFile (File, TEXT("\r\n"),ConvertToUnicode)) {
                    DEBUGMSG ((DBG_ERROR, "pWriteSections: pWriteStrToFile failed"));
                    return FALSE;
                }

                if (!MemDbBuildKeyFromOffset(e.dwValue,buffer,1,NULL)) {
                    DEBUGMSG((DBG_ERROR,"pWriteSections: MemDb failure!"));
                    return FALSE;
                }

                //
                // Skip NULL keys
                //

                if (!StringMatch (buffer, BUILDINF_NULLKEY_PREFIX)) {
                    //
                    // Strip out "uniqueified" prefix, if present.
                    //
                    if (!StringCompareTcharCount(BUILDINF_UNIQUEKEY_PREFIX,buffer,BUILDINF_UNIQUEKEY_PREFIX_SIZE)) {

                        p = buffer + BUILDINF_UNIQUEKEY_PREFIX_SIZE + 4;

                    }
                    else {

                        p = buffer;

                    }

                    if (!pWriteSectionString(File,p,ConvertToUnicode,FALSE)) {
                        DEBUGMSG((DBG_ERROR,"WriteSections: pWriteStrToFile failed"));
                        return FALSE;
                    }

                    nullKey = FALSE;
                } else {
                    nullKey = TRUE;
                }

                firstTime = TRUE;
                break;

            case VALUELEVEL:

                //
                // Value.
                //
                if (MemDbBuildKeyFromOffset(e.dwValue,buffer,1,NULL)) {


                    if (!nullKey) {
                        if (!pWriteStrToFile(File, (firstTime ? TEXT("=") : TEXT(",")),ConvertToUnicode)) {
                            DEBUGMSG((DBG_ERROR,"pWriteSections: pWriteStrToFile failed"));
                            return FALSE;
                        }
                    }

                    firstTime = FALSE;

                    if (!pWriteSectionString(File, buffer,ConvertToUnicode,TRUE)) {
                        DEBUGMSG((DBG_ERROR,"pWriteSections: pWriteSectionString failed."));
                        return FALSE;
                    }

                }
                break;
            default:
                //
                // Not a bug if it gets to this case, we just don't care.
                //
                break;
            }

        } while (MemDbEnumNextValue(&e));
    }

    pWriteStrToFile (File, TEXT("\r\n\r\n"),ConvertToUnicode);

    return TRUE;
}

BOOL
pRestrictedKey (
    IN PCTSTR Section,
    IN PCTSTR Key
    )

/*++

Routine Description:

  pRestrictedKey returns TRUE if a key is restricted in win95upg.inf and FALSE
  otherwise. Certain keys are restricted to prevent migration dlls from
  overwriting important upgrade information.

Arguments:

  Section - A string containing the section to be written.
  Key     - A String containing the Key to be written.

Return Value:

  TRUE if the key is restricted, and FALSE otherwise.

--*/



{
    TCHAR memDbKey[MEMDB_MAX+1];

    MemDbBuildKey(memDbKey,MEMDB_CATEGORY_UNATTENDRESTRICTRIONS,Section,Key,NULL);

    return MemDbGetPatternValue(memDbKey,NULL);
}

BOOL
pDoMerge (
    IN PCTSTR InputFile,
    IN BOOL    Restricted
    )
{

/*++

Routine Description:

  pDoMerge is responsible for merging in information from a file into the
  currently maintained answer file in memdb. The data being added from file
  will take precidence over what has already been written. Therefore, if a
  section/key pair is added that has previously been added, the new
  section/key will take precedence. The one caveat is that if Restricted is
  set to true, only keys that are not restricted in win95upg.inf may be
  merged in.

Arguments:

  InputFile  - The name of the file containing answerfile data to be merged
               into memdb.
  Restricted - TRUE if Answer File Restrictions should be applied to the
               file, FALSE otherwise.

Return Value:

  TRUE  if the merge was successful, FALSE otherwise.

--*/



    HINF hInf = INVALID_HANDLE_VALUE;
    PTSTR sectionNames;
    PTSTR stringKey;
    PTSTR currentField;
    PTSTR workBuffer;
    POOLHANDLE pool = NULL;
    PTSTR firstValue;
    DWORD fieldCount;
    DWORD valueSectionIndex = 0;
    DWORD index;
    PTSTR currentSection;
    INFCONTEXT ic;
    BOOL b = FALSE;
    BOOL result = FALSE;

    __try {

        //
        // Make sure the answer file has not already been written to the disk.
        //
        if (g_AnswerFileAlreadyWritten) {
            LOG ((LOG_ERROR,"Answer file has already been written to disk."));
            SetLastError (ERROR_SUCCESS);
            __leave;
        }

        pool = PoolMemInitNamedPool ("SIF Merge");
        if (!pool) {
            __leave;
        }

        sectionNames = (PTSTR) PoolMemGetMemory (pool, SECTION_NAME_SIZE * sizeof (TCHAR));
        stringKey    = (PTSTR) PoolMemGetMemory (pool, MEMDB_MAX * sizeof (TCHAR));
        currentField = (PTSTR) PoolMemGetMemory (pool, MEMDB_MAX * sizeof (TCHAR));
        workBuffer   = (PTSTR) PoolMemGetMemory (pool, MEMDB_MAX * sizeof (TCHAR));

        if (!sectionNames || !stringKey || !currentField || !workBuffer) {
            __leave;
        }

        GetPrivateProfileSectionNames (sectionNames, SECTION_NAME_SIZE, InputFile);

        hInf = InfOpenInfFile (InputFile);
        if (hInf == INVALID_HANDLE_VALUE) {
            LOG ((LOG_ERROR, "Can't open %s for merge", InputFile));
            __leave;
        }

        //
        // Loop through each section name, get each line and add it
        //

        for (currentSection = sectionNames ; *currentSection ; currentSection = GetEndOfString (currentSection) + 1) {

            //
            // Get each line in the section and add it to memory
            //

            if (SetupFindFirstLine (hInf, currentSection, NULL, &ic)) {
                do  {

                    fieldCount = SetupGetFieldCount(&ic);

                    //
                    // Get the StringKey
                    //

                    SetupGetStringField(&ic,0,stringKey,MEMDB_MAX,NULL);
                    b = SetupGetStringField(&ic,1,currentField,MEMDB_MAX,NULL);
                    firstValue = currentField;

                    //
                    // If key and value are the same, we might not have an equals.
                    // Due to setupapi limitations, we have to use another INF
                    // parser to determine this case.
                    //

                    if (StringMatch (stringKey, firstValue)) {
                        if (!GetPrivateProfileString (
                                currentSection,
                                firstValue,
                                TEXT(""),
                                workBuffer,
                                MEMDB_MAX,
                                InputFile
                                )) {

                            valueSectionIndex = WriteInfKey (currentSection, NULL, currentField);
                            DEBUGMSG_IF ((!valueSectionIndex, DBG_ERROR, "AnswerFile: WriteInfKey returned 0"));

                            continue;
                        }
                    }

                    if (!Restricted || !pRestrictedKey(currentSection,stringKey)) {

                        //
                        // Write the first line first, remember the valuesectionid from it.
                        //
                        if (b) {
                            valueSectionIndex = WriteInfKey(currentSection,stringKey,firstValue);
                            DEBUGMSG_IF((!valueSectionIndex,DBG_ERROR,"AnswerFile: WriteInfKey returned 0..."));
                        }

                        for (index = 2;index <= fieldCount;index++) {

                            b = SetupGetStringField(&ic,index,currentField,MEMDB_MAX,NULL);
                            if (b) {

                                WriteInfKeyEx(currentSection,stringKey,currentField,valueSectionIndex,FALSE);
                            }
                        }

                        //
                        // Kludge to make sure that we respect the JoinWorkgroup/JoinDomain specified in the unattend
                        // file over what we may have already written.
                        //
                        if (StringIMatch (currentSection, S_PAGE_IDENTIFICATION)  && StringIMatch (stringKey, S_JOINDOMAIN)) {
                            WriteInfKey (currentSection, S_JOINWORKGROUP, TEXT(""));
                        }
                        else if (StringIMatch (currentSection, S_PAGE_IDENTIFICATION)  && StringIMatch (stringKey, S_JOINWORKGROUP)) {
                            WriteInfKey (currentSection, S_JOINDOMAIN, TEXT(""));
                        }
                    }
                    ELSE_DEBUGMSG((DBG_VERBOSE,"AnswerFile: Not merging restricted key %s",stringKey));

                } while (b && SetupFindNextLine (&ic, &ic));

                if (!b) {
                    LOG ((
                        LOG_ERROR,
                        "An error occured merging the section [%s] from %s. "
                        "Some settings from this section may have been lost.",
                        currentSection,
                        InputFile
                        ));
                    __leave;
                }
            }
        }

        result = TRUE;

    }
    __finally {
        PushError();

        if (hInf != INVALID_HANDLE_VALUE) {
            InfCloseInfFile (hInf);
        }

        if (pool) {
            PoolMemDestroyPool (pool);
        }

        PopError();
    }

    return result;
}


BOOL
MergeMigrationDllInf (
    IN PCTSTR InputFile
    )

/*++

Routine Description:

  MergeMigrationDllInf is responsible for merging information from a
  migration dll supplied answer file into the memdb based answer file being
  maintained. This is done by first ensuring that the answer file
  restrictions have been initialized and then merging in the data using those
  restrictions.

Arguments:

  InputFile - A String containing the name of the file to merge into the
              answer file being maintained.

Return Value:

  TRUE if the merge was successful, FALSE otherwise.

--*/


{
    static BOOL initialized = FALSE;



    if (!initialized) {
        INFCONTEXT context;
        TCHAR      section[MAX_TCHAR_PATH];
        TCHAR      key[MAX_TCHAR_PATH];

        //
        // Add the contents of the unattended constraints section to
        // MemDb.
        //

        //
        // Each line is of the form <section>=<pattern> where <section> need
        // not be unique and <pattern> is a section key pattern that may contain
        // wildcard characters.
        //
        if (SetupFindFirstLine (g_Win95UpgInf, MEMDB_CATEGORY_UNATTENDRESTRICTRIONS, NULL, &context)) {

            do {

                if (SetupGetStringField (&context, 0, section, MAX_TCHAR_PATH, NULL) &&
                    SetupGetStringField (&context, 1, key, MAX_TCHAR_PATH, NULL)) {
                    //
                    // Add to Memdb.
                    //
                    MemDbSetValueEx(
                        MEMDB_CATEGORY_UNATTENDRESTRICTRIONS,
                        section,
                        key,
                        NULL,
                        0,
                        NULL
                        );

                }
                ELSE_DEBUGMSG((DBG_WARNING,"BuildInf: SetupGetStringField failed."));

            } while (SetupFindNextLine (&context, &context));
        }
        ELSE_DEBUGMSG((DBG_WARNING,"BuildInf: No %s section in w95upg.inf.",MEMDB_CATEGORY_UNATTENDRESTRICTRIONS));
        initialized = TRUE;
    }


    //
    // At this point, all restrictions are accounted for. Merge the file with
    // the memory based structure.
    //
    return pDoMerge(InputFile,TRUE);

}
BOOL
MergeInf (
    IN PCTSTR InputFile
    )

/*++

Routine Description:

  MergeInf opens an INF file using the Setup APIs, enumerates all the
  sections and merges the strings in the INF file with what is in
  memory
  .
Arguments:

  InputFile  - The path to the INF file.  It is treated as an old-style
                 INF.

Return Value:

  TRUE if the file was read and merged successfully, or FALSE if an error
  occurred.  Call GetLastError to get a failure error code.

--*/

{

    return pDoMerge(InputFile,FALSE);

}



DWORD
pWriteInfKey (
    LPCTSTR Section,
    LPCTSTR Key,                    OPTIONAL
    LPCTSTR Value,                  OPTIONAL
    DWORD   ValueSectionId,
    BOOL    EnsureKeyIsUnique

    )

/*++

Routine Description:

  pWriteInfKey is responsible for adding an inf key to the memdb data being
  maintained for the answer file.

Arguments:

  Section           - A string containing the section to add the information
                      to.
  Key               - A string containing the key to add information under.
                      If not specified, then Value represents the complete
                      line text.
  Value             - A String containing the value to add under the
                      section/key. If not specified, Key will be removed.
  ValueSectionId    - A DWORD offset that is used to add multiple values to
                      the same key. 0 indicates no offset, and causes the old
                      key to be overwritten, if it exists or a new key to be
                      created, if it does not. pWriteInfKey returns this
                      offset when successful.
  EnsureKeyIsUnique - TRUE if the key should be unique in memory, FALSE
                      otherwise. This is used to create multiple keys in the
                      answer file under the same section with the same name.

Return Value:

   A valid offset if the call was successful, FALSE otherwise.

++*/

{

    BOOL            b;
    TCHAR           aKey[MEMDB_MAX];
    TCHAR           keySection[MEMDB_MAX];
    TCHAR           massagedSection[MEMDB_MAX];
    DWORD           testValue;
    TCHAR           valueId[20];
    TCHAR           sequence[20];
    static DWORD    idSeed  = 1;
    static DWORD    seqSeed = 1;
    DWORD           rSeed = 1;
    DWORD           sequenceValue;
    BOOL            keyFound;
    DWORD           valueOffset;
    DWORD           keyOffset;
    static DWORD    uniqueNumber = 1;
    TCHAR           uniqueKey[MEMDB_MAX];
    PTSTR           keyPtr = NULL;

    //
    // Guard against rouge parameters.
    //
    if (!Section || !*Section) {
        DEBUGMSG ((DBG_WHOOPS, "Missing Section or Key for SIF"));
        return 0;
    }

    if (!Key && !Value) {
        DEBUGMSG ((DBG_WHOOPS, "Missing Value or Key for SIF"));
        return 0;
    }

    if (Key && !*Key) {
        DEBUGMSG ((DBG_WHOOPS, "Empty key specified for SIF"));
        return 0;
    }

    //
    // ensure key/value do not have quotes.
    //
    if (Value && _tcschr (Value,TEXT('\"'))) {
        DEBUGMSG ((DBG_WHOOPS, "Quotes found in SIF value %s", Value));
        return 0;
    }

    if (Key && _tcschr (Key, TEXT('\"'))) {
        DEBUGMSG ((DBG_WHOOPS, "Quotes found in SIF key %s", Key));
        return 0;
    }

    if (g_AnswerFileAlreadyWritten) {
        DEBUGMSG ((DBG_WHOOPS, "Answer file has already been written to disk."));
        rSeed = 0;

    } else {
        //
        // Make sure Key is not NULL
        //

        if (!Key) {
            Key = BUILDINF_NULLKEY_PREFIX;
        }

        //
        // Massage the section in case it has any wacks in it.
        //
        StringCopy (massagedSection,Section);
        pHandleWacks(massagedSection,REPLACE_WACKS);

        //
        // Ensure the key is unique, if requested.
        //
        if (EnsureKeyIsUnique) {

            //
            // Add the prefix on..
            //
            wsprintf(uniqueKey,TEXT("%s%04X%s"),BUILDINF_UNIQUEKEY_PREFIX,ValueSectionId ? uniqueNumber - 1 : uniqueNumber,Key);

            if (!ValueSectionId) {
                uniqueNumber++;
            }
            keyPtr = uniqueKey;

        } else {

            keyPtr = (PTSTR) Key;
        }

        //
        // See if the key exists already.
        //
        wsprintf(keySection,S_ANSWERFILE_SECTIONMASK,massagedSection);
        MemDbBuildKey(aKey,keySection,keyPtr,NULL,NULL);
        keyFound = MemDbGetValue(aKey,&testValue);

        //
        // Prepare Id and Sequence strings, compute return Seed.
        //
        idSeed++;
        wsprintf(valueId,TEXT("%04x"),idSeed);

        if (keyFound) {
            sequenceValue = testValue;
        }
        else {
            sequenceValue = seqSeed++;
        }

        wsprintf(sequence,TEXT("%04x"),sequenceValue);

        //
        // Delete case
        //

        if (!Value) {
            MemDbBuildKey (aKey, MEMDB_CATEGORY_AF_SECTIONS, massagedSection, sequence, NULL);
            MemDbDeleteTree (aKey);
            return 0;
        }

        if (ValueSectionId && !keyFound) {
            LOG ((LOG_ERROR,"%u is not associated with %s.",testValue,aKey));
            return 0;
        }


        if (!ValueSectionId) {

            //
            //  This is not a continuation. Need to save the section and key into memdb.
            //

            if (keyFound) {

                //
                // Need to replace the key that already exists.
                //

                MemDbBuildKey(aKey,MEMDB_CATEGORY_AF_SECTIONS,massagedSection,sequence,NULL);
                MemDbDeleteTree(aKey);
            }

            //
            // Save away key.
            //
            b = MemDbSetValueEx(
                    keySection,
                    keyPtr,
                    NULL,
                    NULL,
                    sequenceValue,
                    &keyOffset
                    );

            if (!b) {
                DEBUGMSG((DBG_ERROR,"BuildInf: Unable to save key into MemDb."));
                rSeed = 0;
            }
            else {

                //
                // Save away section
                //
                b = MemDbSetValueEx(
                        MEMDB_CATEGORY_AF_SECTIONS,
                        massagedSection,
                        sequence,
                        NULL,
                        keyOffset,
                        NULL
                        );

                if (!b) {
                    DEBUGMSG((DBG_ERROR,"BuildInf: Unable to set value."));
                    rSeed = 0;
                }

            }
        }

        //
        // Add the value into the database.
        //
        b = MemDbSetValueEx(
                MEMDB_CATEGORY_AF_VALUES,
                Value,
                NULL,
                NULL,
                0,
                &valueOffset
                );

        if (!b) {
            DEBUGMSG((DBG_ERROR,"BuildInf: Unable to set value."));
            rSeed = 0;
        }
        else {

            b = MemDbSetValueEx(
                    MEMDB_CATEGORY_AF_SECTIONS,
                    massagedSection,
                    sequence,
                    valueId,
                    valueOffset,
                    NULL
                    );

            if (!b) {
                DEBUGMSG((DBG_ERROR,"BuildInf: Unable to set value."));
                rSeed = 0;
            }
        }
    }
    return rSeed;
}


/*++

Routine Description:

  WriteInfKeyEx and WriteInfKey are the external wrapper apis for
  pWriteInfKey. Each is used to add information to the memory based answer
  file being constructed. WriteInfKeyEx provides greateer control over how
  thiings are written to this file.

Arguments:

  Section           - A string containing the section to add the information
                      to.
  Key               - A string containing the key to add information under.
  Value             - A String containing the value to add under the
                      section/key. If not specified, Key will be removed.
  ValueSectionId    - A DWORD offset that is used to add multiple values to
                      the same key. 0 indicates no offset, and causes the old
                      key to be overwritten, if it exists or a new key to be
                      created, if it does not. pWriteInfKey returns this
                      offset when successful.
  EnsureKeyIsUnique - TRUE if the key should be unique in memory, FALSE
                      otherwise. This is used to create multiple keys in the
                      answer file under the same section with the same name.

Return Value:

  A valid offset, if the call was successful,  0 otherwise.

--*/



DWORD
WriteInfKeyEx (
    PCTSTR Section,
    PCTSTR Key,                 OPTIONAL
    PCTSTR Value,               OPTIONAL
    DWORD ValueSectionId,
    BOOL EnsureKeyIsUnique
    )
{
    return pWriteInfKey(Section,Key,Value,ValueSectionId,EnsureKeyIsUnique);
}

DWORD
WriteInfKey (
    IN PCTSTR Section,
    IN PCTSTR Key,              OPTIONAL
    IN PCTSTR Value             OPTIONAL
    )
{

    return pWriteInfKey(Section,Key,Value,0,FALSE);

}

#define S_WIN9XDEL_FILE TEXT("WIN9XDEL.TXT")
#define S_WIN9XMOV_FILE TEXT("WIN9XMOV.TXT")


BOOL
pWriteDelAndMoveFiles (
    VOID
    )

/*++

Routine Description:

  pWriteDelAndMoveFiles actually creates two files unrelated to the
  winnt.sif file. These files contain information on the files to be deleted
  during textmode and moved during textmode respectively. Because of the size
  of these sections, and due to certain answer file restrictions, these
  sections are no longer written into the winnt.sif file. They are processed
  seperately during textmode.


Arguments:

  none.

Return Value:

  TRUE if the files were created successfully, FALSE otherwise.

--*/

{
    MEMDB_ENUMW e;
    WCHAR SrcFile[MEMDB_MAX];
    WCHAR buffer[MEMDB_MAX];
    HANDLE file = INVALID_HANDLE_VALUE;
    PTSTR  fileString = NULL;
    PWSTR  unicodeString = NULL;
    DWORD  bytesWritten;
    ALL_FILEOPS_ENUMW OpEnum;
    UINT unused;
    DWORD Count;
    HASHTABLE fileTable = HtAllocW();
    BOOL result = FALSE;
    MOVELISTW moveList = NULL;
    POOLHANDLE moveListPool = NULL;

    __try {
        //
        // Special code for netcfg.exe tool. Of course, in the real project, g_TempDir will never be null..
        // (We would've exited long ago!!)
        //
#ifdef DEBUG
        if (!g_TempDir) {
            return TRUE;
        }
#endif

        moveListPool = PoolMemInitNamedPool ("Move List");
        if (!moveListPool) {
            __leave;
        }

        moveList = AllocateMoveListW (moveListPool);
        if (!moveList) {
            __leave;
        }


        fileString = JoinPaths(g_TempDir,WINNT32_D_WIN9XDEL_FILE);

        file = CreateFile (
                    fileString,
                    GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                    );

        DeclareTemporaryFile(fileString);

        if (file == INVALID_HANDLE_VALUE) {
            LOG ((LOG_ERROR,"Error creating file %s.", fileString));
            __leave;
        }

        //
        // Enumerate all TEXTMODE FileDel entries and add them to winnt.sif
        //
        if (EnumFirstFileOpW (&OpEnum, OPERATION_FILE_DELETE, NULL)) {

            do {

                //
                // For each file that should be deleted during textmode,
                // write it to the win9xdel.txt file.
                //

                HtAddStringW (fileTable, OpEnum.Path);

                Count++;
                if (!(Count % 128)) {
                    TickProgressBar();
                    DEBUGLOGTIME (("pWriteDelAndMoveFiles: FILE_DELETE enum 128 files"));
                }

                if (CANCELLED()) {
                    return TRUE;
                }

                //WriteFile (file, OpEnum.Path, ByteCountW (OpEnum.Path), &bytesWritten, NULL);
                //pWriteStrToFile(file, TEXT("\r\n"),TRUE);

            } while (EnumNextFileOpW (&OpEnum));
        }

        if (!HtWriteToFile (fileTable, file, WRITE_UNICODE_HEADER)) {
            LOG ((LOG_ERROR,"Unable to write to win9xdel.txt."));
            __leave;
        }

        //
        // Clean up resources.
        //
        CloseHandle(file);
        FreePathString(fileString);

        HtFree (fileTable);
        fileTable = NULL;

        //
        // Create WIN9XMOV.TXT file.
        //
        fileString = JoinPaths(g_TempDir,WINNT32_D_WIN9XMOV_FILE);

        file = CreateFile (
                    fileString,
                    GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                    );

        DeclareTemporaryFile(fileString);

        if (file == INVALID_HANDLE_VALUE) {
            LOG ((LOG_ERROR,"Error creating file %s.",fileString));
            __leave;
        }

        //
        // Add all the files to be moved
        //

        if (EnumFirstFileOpW (&OpEnum, OPERATION_FILE_MOVE|OPERATION_TEMP_PATH, NULL)) {

            do {

                //
                // only take into account the first destination of a file
                // (when OpEnum.PropertyNum == 0)
                // all other destinations are not relevant for textmode move
                //
                if (OpEnum.PropertyValid && OpEnum.PropertyNum == 0) {

                    InsertMoveIntoListW (
                        moveList,
                        OpEnum.Path,
                        OpEnum.Property
                        );

                    Count++;
                    if (!(Count % 256)) {
                        TickProgressBar();
                        DEBUGLOGTIME (("pWriteDelAndMoveFiles: FILE_MOVE|TEMP_PATH enum 256 files"));
                    }

                    if (CANCELLED()) {
                        return TRUE;
                    }
                }

            } while (EnumNextFileOpW (&OpEnum));
        }



        //
        // Enumerate all the SfTemp values and add them to the list of things to move.
        //

        if (MemDbGetValueExW (&e, MEMDB_CATEGORY_SF_TEMPW, NULL, NULL)) {

            do {

                if (MemDbBuildKeyFromOffsetW (e.dwValue, SrcFile, 1, NULL)) {

                    InsertMoveIntoListW (
                        moveList,
                        SrcFile,
                        e.szName
                        );

                    Count++;
                    if (!(Count % 128)) {
                        TickProgressBar();
                        DEBUGLOGTIME (("pWriteDelAndMoveFiles: MEMDB_CATEGORY_SF_TEMPW enum 128 files"));
                    }

                    if (CANCELLED()) {
                        return TRUE;
                    }

                }
                ELSE_DEBUGMSGW ((
                    DBG_WHOOPS,
                    "MemDbBuildKeyFromOffset: Cannot create key from offset %u of %s (2)",
                    e.dwValue,
                    e.szName
                    ));

            } while (MemDbEnumNextValueW (&e));
        }

        //
        // Enumerate all DirsCollision values and add them to the list of things to move.
        //

        if (MemDbGetValueExW (&e, MEMDB_CATEGORY_DIRS_COLLISIONW, NULL, NULL)) {

            do {
                if (EnumFirstFileOpW (&OpEnum, OPERATION_FILE_MOVE, e.szName)) {

                    InsertMoveIntoListW (
                        moveList,
                        e.szName,
                        OpEnum.Property
                        );

                    if (CANCELLED()) {
                        return TRUE;
                    }
                }
                //ELSE_DEBUGMSGW ((
                //    DBG_WHOOPS,
                //    "EnumFirstFileOpW: failed for FileSpec=%s",
                //    e.szName
                //    ));

            } while (MemDbEnumNextValueW (&e));
        }

        moveList = RemoveMoveListOverlapW (moveList);

        if (!OutputMoveListW (file, moveList, FALSE)) {
            LOG ((LOG_ERROR,"Unable to write to win9xmov.txt."));
            __leave;
        }

        CloseHandle(file);
        FreePathString(fileString);

        //
        // Finally, we need to write any 'absolutely make sure everything is deleted in this dir' dirs.
        // Textmode will blast away everything in the dir it finds. This *shouldn't* be needed, but
        // beta2 had a problem where there were some INFs left in %windir%\inf even after we had
        // supposedly enumerated all the files there and added them to the delete file.
        // As luck would have it, this was on a reviewer's machine...
        //

        //
        // Create W9XDDIR.TXT file.
        //
        fileString = JoinPaths(g_TempDir,WINNT32_D_W9XDDIR_FILE);

        file = CreateFile (
                    fileString,
                    GENERIC_WRITE,
                    0,
                    NULL,
                    CREATE_ALWAYS,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                    );


        DeclareTemporaryFile(fileString);


        if (file == INVALID_HANDLE_VALUE) {
            LOG ((LOG_ERROR,"Error creating file %s.",fileString));
            __leave;
        }

        WriteFile (file, "\xff\xfe", 2, &bytesWritten, NULL);

        //
        // Add any enumeration we want to do later. Right now, we only have the one dir to try.
        //
        FreePathString (fileString);
        fileString = JoinPaths (g_WinDir, TEXT("inf"));
        pWriteStrToFile (file, fileString, TRUE);           // TRUE == convert to unicode
        pWriteStrToFile (file, "\r\n", TRUE);

        if (MemDbGetValueExW (&e, MEMDB_CATEGORY_FULL_DIR_DELETESW, NULL, NULL)) {

            do {

                if (!WriteFile (file, e.szName, ByteCountW (e.szName), &unused, NULL)) {
                    LOG ((LOG_ERROR,"Unable to write to w9xddir.txt."));
                    __leave;
                }

                if (!WriteFile (file, L"\r\n", 4, &unused, NULL)) {
                    LOG ((LOG_ERROR,"Unable to write to w9xddir.txt."));
                    __leave;
                }

                if (CANCELLED()) {
                    return TRUE;
                }

            } while (MemDbEnumNextValueW (&e));
        }

        result = TRUE;

    }
    __finally {

        //
        // Free resources.
        //
        if (file != INVALID_HANDLE_VALUE) {
            CloseHandle(file);
        }

        FreePathString(fileString);

        HtFree (fileTable);

        PoolMemDestroyPool (moveListPool);
    }

    return result;
}


DWORD
CreateFileLists (
    IN DWORD Request
    )
{

    switch (Request) {

    case REQUEST_QUERYTICKS:
        if (REPORTONLY ()) {
            return 0;
        }
        else {
            return TICKS_CREATE_FILE_LISTS;
        }

    case REQUEST_RUN:

        ProgressBar_SetComponentById (MSG_PROCESSING_SYSTEM_FILES);
        pWriteDelAndMoveFiles ();

        ProgressBar_SetComponent (NULL);



        break;
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upg\winntsif\winntsif.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    winntsif.c

Abstract:

    winntsif.c is responsible for filling in the nt setup answer file with data from
    the win9xupg system being upgraded. This data is then used during unattended setup
    to control the installation of various portions of the winnt system.

    This is a rewrite and rationalization of the old unattend.c file.


Author:

    Marc R. Whitten (marcw) 16-Feb-1998

Revision History:

    ovidiut     14-Mar-2000     Added random admin password for GUI setup
    marcw       29-Aug-1999     ID mapping for NICs.
    marcw       08-Mar-1999     Migration dlls can handle section\keys.
    marcw       23-Sep-1998     DLC fix


--*/

#include "pch.h"

#define DBG_WINNTSIF "WinntSif"

/*++

Macro Expansion List Description:

  WINNTSIF_SECTIONS lists all of the sections in winnt.sif that will be populated by the
  winntsif processing code. The engine will enumerate each section in this list and then
  process the settings associated with that section.



Line Syntax:

   STRSECTION(SectionName,SettingsList)
   FUNSECTION(SectionFunction,SettingsList)

Arguments:

   SectionName - This is a string containing the name of the section that is processed.

   SectionFunction - This is an enumeration function that is called for sections that will
                     have multiple instances. This function returns a new section name each
                     time it is called, until there are no more instances to process.
                     At that time, this function returns NULL, ending the processing if the
                     associated section settings.

   SettingsList    - A list of settings associated with each function. Each of these settings
                     will be processed for the given section (or multiple sections in the case
                     of FUNSECTION lines..) See the description of the <X>_SECTION_SETTINGS
                     macro for more details on these settings.


Variables Generated From List:

   g_SectionList

--*/

/*++

Macro Expansion List Description:

  <X>_SECTION_SETTINGS lists the settings to be processed for the section X. Each section in the
  WINNTSIF_SECTIONS macro above contains a list of these settings..

Line Syntax:

   FUNDATA(CreationFunction,SettingName,DataFunction)
   STRDATA(CreationFunction,SettingName,DataString)
   REGDATA(CreationFunction,SettingName,RegKey,RegValue)


Arguments:

   CreationFunction - This is an optional boolean function which returns TRUE if the setting should
                      be written, FALSE if it should be skipped.

   SettingName      - A string containing the name of the setting being processed.

   DataFunction     - A Function which returns the string data to be written for the specified setting,
                      or NULL if nothing is to be written.

   DataString       - The actual string to write for the data of the setting.

   RegKey/RegValue  - The Key and value to use to retrieve the data to be written for the setting from
                      the registry.

Variables Generated From List:

   Used with WINNTSIF_SECTIONS to generate g_SectionList.


--*/



#define WINNTSIF_SECTIONS                                                                       \
    STRSECTION(WINNT_DATA,DATA_SECTION_SETTINGS)                                                \
    STRSECTION(S_UNATTENDED,UNATTENDED_SECTION_SETTINGS)                                        \
    STRSECTION(S_GUIUNATTENDED,GUIUNATTENDED_SECTION_SETTINGS)                                  \
    STRSECTION(S_USERDATA,USERDATA_SECTION_SETTINGS)                                            \
    STRSECTION(S_DISPLAY,DISPLAY_SECTION_SETTINGS)                                              \
    FUNSECTION(pNetAdapterSections,FUNDATA(NULL,S_INFID,pGetNetAdapterPnpId))                   \
    STRSECTION(S_NETWORKING,NETWORKING_SECTION_SETTINGS)                                        \
    STRSECTION(S_PAGE_IDENTIFICATION,IDENTIFICATION_SECTION_SETTINGS)                           \
    STRSECTION(S_PAGE_NETPROTOCOLS,NETPROTOCOLS_SECTION_SETTINGS)                               \
    STRSECTION(S_MS_NWIPX,FUNDATA(NULL,S_ADAPTERSECTIONS,pGetAdaptersWithIpxBindings))          \
    FUNSECTION(pIpxAdapterSections,IPX_ADAPTER_SECTION_SETTINGS)                                \
    FUNSECTION(pHomenetSection, HOMENET_SECTION_SETTINGS)                                       \
    STRSECTION(S_MS_TCPIP,TCPIP_SECTION_SETTINGS)                                               \
    FUNSECTION(pTcpAdapterSections,TCP_ADAPTER_SECTION_SETTINGS)                                \
    STRSECTION(S_PAGE_NETCLIENTS,NETCLIENTS_SECTION_SETTINGS)                                   \
    STRSECTION(S_SERVICESTARTTYPES,SERVICESTARTTYPES_SECTION_SETTINGS)                          \
    STRSECTION(S_PAGE_NETSERVICES,NETSERVICES_SECTION_SETTINGS)                                 \
    STRSECTION(S_NETOPTIONALCOMPONENTS,NETOPTIONALCOMPONENTS_SECTION_SETTINGS)                  \
    STRSECTION(S_MSRASCLI,STRDATA(pIsRasInstalled,S_PARAMSSECTION,S_PARAMSRASCLI))              \
    STRSECTION(S_PARAMSRASCLI,PARAMSRASCLI_SECTION_SETTINGS)                                    \
    FUNSECTION(pRasPortSections,RASPORT_SECTION_SETTINGS)                                       \
    STRSECTION(S_MS_NWCLIENT,NWCLIENT_SECTION_SETTINGS)                                         \
    FUNSECTION(pBindingSections,FUNDATA(NULL,NULL,NULL))                                        \
    STRSECTION(S_REGIONALSETTINGS,REGIONALSETTINGS_SECTION_SETTINGS)                            \

#if 0

// this was moved to winnt32 dll as part of Setup components update
    STRSECTION(WINNT_WIN95UPG_95_DIR_A,FUNDATA(NULL,WINNT_WIN95UPG_NTKEY_A,pGetReplacementDll)) \

#endif

//
// [Data]
//
#define DATA_SECTION_SETTINGS                                                                   \
    FUNDATA(NULL,WINNT_D_MIGTEMPDIR,pGetTempDir)                                                \
    FUNDATA(NULL,WINNT_D_WIN9XSIF,pGetWin9xSifDir)                                              \
    STRDATA(NULL,WINNT_U_UNATTENDMODE,WINNT_A_DEFAULTHIDE)                                      \
    FUNDATA(NULL,WINNT_D_INSTALLDIR,pGetWinDir)                                                 \
    FUNDATA(NULL,WINNT_D_WIN9XBOOTDRIVE,pGetWin9xBootDrive)                                     \
    FUNDATA(NULL,WINNT_D_GUICODEPAGEOVERRIDE,pGetGuiCodePage)                                   \
    FUNDATA(NULL,WINNT_D_BACKUP_LIST,pBackupFileList)                                           \
    FUNDATA(NULL,WINNT_D_ROLLBACK_MOVE,pUninstallMoveFileList)                                  \
    FUNDATA(NULL,WINNT_D_ROLLBACK_DELETE,pUninstallDelFileList)                                 \
    FUNDATA(NULL,WINNT_D_ROLLBACK_DELETE_DIR,pUninstallDelDirList)                              \
    FUNDATA(NULL,S_ROLLBACK_MK_DIRS,pUninstallMkDirList)                                        \

//
// [Unattended]
//
#define UNATTENDED_SECTION_SETTINGS                                                             \
    STRDATA(NULL,S_NOWAITAFTERTEXTMODE,S_ONE)                                                   \
    STRDATA(NULL,S_NOWAITAFTERGUIMODE,S_ONE)                                                    \
    STRDATA(NULL,S_CONFIRMHARDWARE,S_NO)                                                        \
    FUNDATA(NULL,S_KEYBOARDLAYOUT,pGetKeyboardLayout)                                           \
    FUNDATA(NULL,S_KEYBOARDHARDWARE,pGetKeyboardHardware)

//
// [GuiUnattended]
//
#define GUIUNATTENDED_SECTION_SETTINGS                                                          \
    FUNDATA(NULL,S_TIMEZONE,pGetTimeZone)                                                       \
    STRDATA(NULL,S_SERVERTYPE,S_STANDALONE)                                                     \
    FUNDATA(NULL,WINNT_US_ADMINPASS,pSetAdminPassword)


//
// [UserData]
//
#define USERDATA_SECTION_SETTINGS                                                               \
    FUNDATA(NULL,S_FULLNAME,pGetFullName)                                                       \
    REGDATA(NULL,S_ORGNAME,S_WINDOWS_CURRENTVERSION,S_REGISTEREDORGANIZATION)                   \
    FUNDATA(NULL,S_COMPUTERNAME,pGetComputerName)                                               \

//
// [Display]
//
#define DISPLAY_SECTION_SETTINGS                                                                \
    FUNDATA(NULL,S_BITSPERPEL,pGetBitsPerPixel)                                                 \
    FUNDATA(NULL,S_XRESOLUTION,pGetXResolution)                                                 \
    FUNDATA(NULL,S_YRESOLUTION,pGetYResolution)                                                 \
    FUNDATA(NULL,S_VREFRESH,pGetVerticalRefreshRate)                                            \

//
// [Networking]
//
#define NETWORKING_SECTION_SETTINGS                                                             \
    STRDATA(pIsNetworkingInstalled,S_PROCESSPAGESECTIONS,S_YES)                                 \
    STRDATA(pIsNetworkingInstalled,S_UPGRADEFROMPRODUCT,S_WINDOWS95)                            \
    FUNDATA(pIsNetworkingInstalled,S_BUILDNUMBER,pGetBuildNumber)

//
// [Identification]
//
#define IDENTIFICATION_SECTION_SETTINGS                                                         \
    FUNDATA(pIsNetworkingInstalled,S_JOINDOMAIN,pGetUpgradeDomainName)                          \
    FUNDATA(pIsNetworkingInstalled,S_JOINWORKGROUP,pGetUpgradeWorkgroupName)

//
// [NetProtocols]
//
#define NETPROTOCOLS_SECTION_SETTINGS                                                           \
    STRDATA(pIsNwIpxInstalled,S_MS_NWIPX,S_MS_NWIPX)                                            \
    STRDATA(pIsTcpIpInstalled,S_MS_TCPIP,S_MS_TCPIP)                                            \

//
// These protocols were removed from Whistler, don't migrate settings for them
//
//  STRDATA(pIsNetBeuiInstalled,S_MS_NETBEUI,S_MS_NETBEUI)                                      \
//  STRDATA(pIsMsDlcInstalled,S_MS_DLC,S_MS_DLC)                                                \

//
// [Adapter<x>.ipx]
//
#define IPX_ADAPTER_SECTION_SETTINGS                                                            \
    FUNDATA(NULL,S_SPECIFICTO,pSpecificTo)                                                      \
    FUNDATA(NULL,S_PKTTYPE,pGetIpxPacketType)                                                   \
    FUNDATA(NULL,S_NETWORKNUMBER,pGetIpxNetworkNumber)                                          \


//
// [MS_TCPIP]
//
#define TCPIP_SECTION_SETTINGS                                                                  \
    FUNDATA(pIsTcpIpInstalled,S_ADAPTERSECTIONS,pGetAdaptersWithTcpBindings)                    \
    FUNDATA(pIsTcpIpInstalled,S_DNS,pGetDnsStatus)                                              \
    REGDATA(pIsDnsEnabled,S_DNSHOST,S_MSTCP_KEY,S_HOSTNAMEVAL)                                  \
    FUNDATA(pIsDnsEnabled,S_DNSSUFFIXSEARCHORDER,pGetDnsSuffixSearchOrder)                      \
    REGDATA(pIsTcpIpInstalled,S_SCOPEID,S_MSTCP_KEY,S_SCOPEID)                                  \
    REGDATA(pIsTcpIpInstalled,S_IMPORTLMHOSTSFILE,S_MSTCP_KEY,S_LMHOSTS)                        \

//
// [Adapter<x>.tcpip]
//
#define TCP_ADAPTER_SECTION_SETTINGS                                                            \
    FUNDATA(NULL,S_SPECIFICTO,pSpecificTo)                                                      \
    FUNDATA(NULL,S_DHCP,pGetDhcpStatus)                                                         \
    STRDATA(NULL,S_NETBIOSOPTION,S_ONE)                                                         \
    FUNDATA(pHasStaticIpAddress,S_IPADDRESS,pGetIpAddress)                                      \
    FUNDATA(pHasStaticIpAddress,S_SUBNETMASK,pGetSubnetMask)                                    \
    FUNDATA(NULL,S_DEFAULTGATEWAY,pGetGateway)                                                  \
    FUNDATA(pIsDnsEnabled,S_DNSSERVERSEARCHORDER,pGetDnsServerSearchOrder)                      \
    REGDATA(pIsDnsEnabled,S_DNSDOMAIN,S_MSTCP_KEY,S_DOMAINVAL)                                  \
    FUNDATA(NULL,S_WINS,pGetWinsStatus)                                                         \
    FUNDATA(NULL,S_WINSSERVERLIST,pGetWinsServers)


#define HOMENET_SECTION_SETTINGS                                                                \
    FUNDATA(pExternalIsAdapter,S_EXTERNAL_ADAPTER, pIcsExternalAdapter)                         \
    FUNDATA(pExternalIsRasConn,S_EXTERNAL_CONNECTION_NAME, pIcsExternalConnectionName)          \
    FUNDATA(NULL, S_INTERNAL_IS_BRIDGE, pInternalIsBridge)                                      \
    FUNDATA(pHasInternalAdapter, S_INTERNAL_ADAPTER, pInternalAdapter)                          \
    FUNDATA(pHasBridge, S_BRIDGE, pBridge)                                                      \
    FUNDATA(NULL, S_DIAL_ON_DEMAND, pDialOnDemand)                                              \
    REGDATA(NULL, S_ENABLEICS, S_ICS_KEY, S_ENABLED)                                            \
    REGDATA(NULL, S_SHOW_TRAY_ICON, S_ICS_KEY, S_SHOW_TRAY_ICON)                                \
    STRDATA(NULL, S_ISW9XUPGRADE, S_YES)


//
// [NetClients]
//
#define NETCLIENTS_SECTION_SETTINGS                                                             \
    STRDATA(pIsWkstaInstalled,S_MS_NETCLIENT,S_MS_NETCLIENT)                                    \
    STRDATA(pIsNwClientInstalled,S_MS_NWCLIENT,S_MS_NWCLIENT)                                   \

//
// [ServiceStartTypes]
//
#define SERVICESTARTTYPES_SECTION_SETTINGS                                                      \
    STRDATA(pDisableBrowserService,S_BROWSER,TEXT("3"))                                         \


//
// [NetServices]
//
#define NETSERVICES_SECTION_SETTINGS                                                            \
    STRDATA(pInstallMsServer,S_MS_SERVER,S_MS_SERVER)                                           \
    STRDATA(pIsRasInstalled,S_MSRASCLI,S_MSRASCLI)

//
// [NetOptionalComponents]
//
#define NETOPTIONALCOMPONENTS_SECTION_SETTINGS                                                  \
    STRDATA(pIsSnmpInstalled,S_SNMP,S_ONE)                                                      \
    STRDATA(pIsUpnpInstalled,S_UPNP,S_ONE)

//
// [params.rascli]
//
#define PARAMSRASCLI_SECTION_SETTINGS                                                           \
    STRDATA(pIsRasInstalled,S_DIALOUTPROTOCOLS,S_ALL)                                           \
    FUNDATA(pIsRasInstalled,S_PORTSECTIONS,pGetRasPorts)

//
// [com<x>]
//
#define RASPORT_SECTION_SETTINGS                                                                \
    FUNDATA(NULL,S_PORTNAME,pRasPortName)                                                       \
    STRDATA(NULL,S_PORTUSAGE,S_CLIENT)

//
// [NwClient]
//
#define NWCLIENT_SECTION_SETTINGS                                                               \
    REGDATA(pIsNwClientInstalled,S_PREFERREDSERVER,S_AUTHAGENTREG,S_AUTHENTICATINGAGENT)        \
    REGDATA(pIsNwClientInstalled,S_DEFAULTCONTEXT,S_NWREDIRREG,S_DEFAULTNAMECONTEXT)            \
    REGDATA(pIsNwClientInstalled,S_DEFAULTTREE,S_NWREDIRREG,S_PREFERREDNDSTREE)                 \
    FUNDATA(pIsNwClientInstalled,S_LOGONSCRIPT,pGetScriptProcessingStatus)                      \


#define REGIONALSETTINGS_SECTION_SETTINGS                                                       \
    FUNDATA(NULL,S_LANGUAGEGROUP,pGetLanguageGroups)                                            \
    REGDATA(NULL,S_LANGUAGE,S_SYSTEMLOCALEREG,TEXT(""))                                         \



//
// typedefs for the various functions prototypes used by the winntsif code.
//
typedef BOOL    (* CREATION_FUNCTION)   (VOID);
typedef PCTSTR  (* DATA_FUNCTION)       (VOID);
typedef PCTSTR  (* SECTION_FUNCTION)    (VOID);

//
// The SETTING_TYPE enum contains all of the possible Types of settings which
// may occur in the macro expansion list above.
//
typedef enum {
    FUNCTION_SETTING = 1,
    STRING_SETTING,
    REGISTRY_SETTING,
    LAST_SETTING
} SETTING_TYPE;


//
// This structure wraps a key and a value inside a single structure. It is accessed
// within the union below.
//
typedef struct {
    PCTSTR  Key;
    PCTSTR  Value;
} REGKEYANDVALUE, *PREGKEYANDVALUE;

//
// SETTING contains the information to create a single setting within
// a winntsif file.
//
typedef struct {

    SETTING_TYPE      SettingType;
    CREATION_FUNCTION CreationFunction;
    PCTSTR            KeyName;



    //
    // The data depends on the SETTING_TYPE above.
    //
    union {
        REGKEYANDVALUE    Registry;
        DATA_FUNCTION     Function;
        PCTSTR            String;
    } Data;

} SETTING, *PSETTING;


//
// Section is the toplevel hierarchy used for the winntsif file.
// Each section contains a list of settings that will be processed and
// possibly written for that section.
//
#define MAX_SETTINGS 16
typedef struct {

    PTSTR              SectionString;
    SECTION_FUNCTION   SectionFunction;
    SETTING            SettingList[MAX_SETTINGS];

} SECTION, *PSECTION;

#define FUNDATA(create,key,datafunction)    {FUNCTION_SETTING,  (create),   (key),  {(PTSTR) (datafunction),    NULL}},
#define STRDATA(create,key,datastring)      {STRING_SETTING,    (create),   (key),  {(PTSTR) (datastring),      NULL}},
#define REGDATA(create,key,regkey,regvalue) {REGISTRY_SETTING,  (create),   (key),  {(regkey), (regvalue)}},

#define STRSECTION(section,list) {(section),NULL,{list /*,*/ {LAST_SETTING,NULL,NULL,{NULL,NULL}}}},
#define FUNSECTION(function,list) {NULL,(function),{list /*,*/ {LAST_SETTING,NULL,NULL,{NULL,NULL}}}},


typedef struct {

    PCTSTR Text;
    BOOL Installed;


} BINDINGPART, *PBINDINGPART;

#define NUM_PROTOCOLS 4
#define NUM_CLIENTS 2

typedef struct {

    BINDINGPART Clients[NUM_CLIENTS];
    BINDINGPART Protocols[NUM_PROTOCOLS];

} BINDINGINFO, *PBINDINGINFO;

BINDINGINFO g_BindingInfo =
    {{{S_MS_NETCLIENT, FALSE},{S_MS_NWCLIENT, FALSE}},{{S_MS_TCPIP, FALSE},{S_MS_NWIPX, FALSE},{S_MS_NETBEUI, FALSE}, {S_MS_DLC, FALSE}}};



TCHAR g_CurrentAdapter[MEMDB_MAX]; // During adapter/section enumeration, contains current adapter name.
TCHAR g_CurrentSection[MEMDB_MAX]; // During some section enums, contains current section name.
TCHAR g_TempBuffer[MEMDB_MAX]; // Contains the current value returned from pGetRegistryValue
MEMDB_ENUM g_TempEnum; // A global enumerator that may be used by various section functions.
HINF g_IntlInf;
INFSTRUCT g_InfStruct = INITINFSTRUCT_POOLHANDLE;
POOLHANDLE g_LocalePool;
HASHTABLE g_LocaleTable;

BOOL g_fIcsAdapterInPlace = FALSE;
BOOL g_fHasIcsExternalAdapter = FALSE;
TCHAR g_IcsAdapter[MEMDB_MAX] = {0};
TCHAR g_IcsExternalAdapter[MEMDB_MAX] = {0};
BOOL g_fIcsInternalIsBridge = FALSE;

#define S_REGIONALSETTINGS TEXT("RegionalSettings")

#define CLEARBUFFER() ZeroMemory(g_TempBuffer,MEMDB_MAX * sizeof (TCHAR));
//
// Helper and Miscellaneous functions..
//



/*++

Routine Description:

  pGetRegistryValue is a utility wrapper used for getting data out of the
  registry. Because winntsif processing requires frequent and very similar
  reads from the registry, this wrapper is modified to be a little friendlier
  to this type of processing than the normal functions in reg.h. This
  function reads the data from the registry, and packs it into a multisz. It
  is capable of handling REG_DWORD, REG_MULTI_SZ, and REG_SZ style registry
  data. The data is stored in g_TempBuffer as well as being passed back
  through the return value. If the specified Key/Value does not exist in the
  registry, or the function is unable to retrieve a value, NULL is returned.

Arguments:

  KeyString   - Contains the Key to be read from the registry.
  ValueString - Contains the Value to be read from the registry.

Return Value:

  A pointer to a multisz containing the data if it could be read from the
  registry, NULL otherwise.

--*/


PCTSTR
pGetRegistryValue (
    IN PCTSTR KeyString,
    IN PCTSTR ValueString
    )
{
    PCTSTR          rString  = NULL;
    HKEY            key      = NULL;
    PBYTE           data     = NULL;
    DWORD           type     = REG_NONE;
    LONG            rc       = ERROR_SUCCESS;
    PTSTR           end;

    MYASSERT(KeyString && ValueString);

    //
    // Open registry key.
    //
    key = OpenRegKeyStr(KeyString);

    if (!key) {
        DEBUGMSG((DBG_WINNTSIF, "Key %s does not exist.",KeyString));
        return NULL;
    }
    __try {
        //
        // Get type of data
        //
        rc = RegQueryValueExA (key, ValueString, NULL, &type, NULL, NULL);
        if (rc != ERROR_SUCCESS) {
            DEBUGMSG((DBG_WINNTSIF,"RegQueryValueEx failed for %s[%s]. Value may not exist.",KeyString,ValueString));
            SetLastError (rc);
            return NULL;
        }

        MYASSERT(type == REG_DWORD || type == REG_MULTI_SZ || type == REG_SZ);

        //
        // Get data and move it to a multistring
        //
        data = GetRegValueData (key, ValueString);

        if (!data) {
            DEBUGMSG((DBG_WHOOPS,"pGetRegistryValue: RegQueryValueEx succeeded, but GetRegValueData failed...Could be a problem."));
            return NULL;
        }

        CLEARBUFFER();


        switch  (type) {

        case REG_DWORD:
            wsprintf(g_TempBuffer,"%u", *(DWORD*) data);
            break;
        case REG_SZ:
            StringCopy(g_TempBuffer,(PCTSTR) data);
            //
            // some data is stored as REG_SZ, but is actually a comma separated multisz
            // append one more NULL to the end
            //
            end = GetEndOfString (g_TempBuffer) + 1;
            *end = 0;
            break;
        case REG_MULTI_SZ:

            end = (PTSTR) data;
            while (*end) {
                end = GetEndOfString (end) + 1;
            }
            memcpy(g_TempBuffer,data,(LONG)end - (LONG)data);
            break;
        default:
            LOG ((LOG_ERROR,"Unexpected registry type found while creating Setup answer file."));
            break;
        };

    } __finally {

        //
        // Clean up resources.
        //
        CloseRegKey(key);
        if (data) {
            MemFree(g_hHeap, 0, data);
        }
    }

    return g_TempBuffer;
}

BOOL
CALLBACK
pEnumLocalesFunc (
    IN PTSTR Locale
    )
{

    PTSTR group = NULL;
    PTSTR directory = NULL;


    //
    // Get the language group.
    //
    if (InfFindFirstLine (g_IntlInf, S_LOCALES, Locale, &g_InfStruct)) {

        group = InfGetStringField (&g_InfStruct, 3);

        if (group) {
            group = PoolMemDuplicateString (g_LocalePool, group);

        }
        ELSE_DEBUGMSG ((DBG_WARNING, "Unable to retrieve group data for locale %s.", Locale));
    }

    //
    // Get the language directory.
    //
    if (group && InfFindFirstLine (g_IntlInf, S_LANGUAGEGROUPS, group, &g_InfStruct)) {

        directory = InfGetStringField (&g_InfStruct, 2);
        if (directory) {
            directory = PoolMemDuplicateString (g_LocalePool, directory);
        }
    }

    //
    // Save the information into the locale hash table.
    //
    if (group) {

        HtAddStringAndData (g_LocaleTable, group, &directory);
    }

    return TRUE;
}

VOID
pBuildLanguageData (
    VOID
    )
{

    //
    // Allocate needed resources.
    //
    g_LocaleTable = HtAllocWithData (sizeof (PTSTR));
    g_LocalePool = PoolMemInitNamedPool (TEXT("Locale Pool"));


    //
    // Read data in from intl.inf. This is used to gather
    // the necessary information we need for each installed
    // locale.
    //
    g_IntlInf = InfOpenInfInAllSources (S_INTLINF);

    if (g_IntlInf != INVALID_HANDLE_VALUE) {

        EnumSystemLocales (pEnumLocalesFunc, LCID_INSTALLED);
        InfCloseInfFile (g_IntlInf);
    }

    InfCleanUpInfStruct (&g_InfStruct);

}

PTSTR
GetNeededLangDirs (
    VOID
    )
{

    UINT bytes = 0;
    PTSTR rDirs = NULL;
    HASHTABLE_ENUM e;
    GROWBUFFER buf = GROWBUF_INIT;
    PTSTR dir;
    //
    // Gather language data.
    //
    pBuildLanguageData ();
    if (EnumFirstHashTableString (&e, g_LocaleTable)) {
        do {

            if (e.ExtraData) {
                dir = *((PTSTR *) e.ExtraData);
            }
            else {
                dir = NULL;
            }

            //
            // Some language groups do not require an optional dir.
            //
            if (dir && *dir) {
                MultiSzAppend (&buf, dir);
            }

        } while (EnumNextHashTableString (&e));
    }

    if (buf.Buf) {
        bytes = SizeOfMultiSz (buf.Buf);
    }
    if (bytes) {
        rDirs = PoolMemGetMemory (g_LocalePool, bytes);
        CopyMemory (rDirs, buf.Buf, bytes);
    }

    FreeGrowBuffer (&buf);

    return rDirs;

}



/*++

Routine Description:

  This simple helper function determines wether a specific net component has
  bindings or not.

Arguments:

  NetComponent - Contains the Networking component to enumerate.

Return Value:

  TRUE if the specified Networking Component has bindings, FALSE
  otherwise.


--*/


BOOL
pDoesNetComponentHaveBindings (
    IN      PCTSTR NetComponent
    )
{
    PTSTR       keyString = NULL;
    REGKEY_ENUM e;


    keyString = JoinPaths(S_ENUM_NETWORK_KEY,NetComponent);

    if (!EnumFirstRegKeyStr (&e, keyString)) {
        FreePathString(keyString);
        return FALSE;
    }

    FreePathString(keyString);
    AbortRegKeyEnum (&e);

    return TRUE;
}


/*++

Routine Description:

  pGatherNetAdapterInfo is responsible for preprocessing the NetAdapter
  information in the registry in order to build up a tree of information
  about these adapters in memdb.  This tree contains information about each
  adapter, including its pnpid, its network bindings, and the nettrans keys
  for each of those bindings.

Arguments:

  None.

Return Value:

  None.

--*/


VOID
pGatherNetAdapterInfo (
    VOID
    )
{
    NETCARD_ENUM    eNetCard;
    REGVALUE_ENUM   eRegVal;
    UINT            curAdapter          = 1;
    UINT            offset              = 0;
    TCHAR           adapterString[30];
    PCTSTR          bindingsKey         = NULL;
    PCTSTR          networkKey          = NULL;
    PCTSTR          netTransKey         = NULL;
    PTSTR           p                   = NULL;
    HKEY            hKey;
    BOOL            fBoundToTCP         = FALSE;


    ZeroMemory(g_IcsAdapter, sizeof(g_IcsAdapter));
    //
    // Enumerate all net cards, we'll create
    // entries for all of the non-dialup PNP adapters
    // with the following proviso: If more than one net card is specified,
    //

    if (EnumFirstNetCard(&eNetCard)) {

        __try {

            do {

                fBoundToTCP = FALSE;
                //
                // Skip the Dial-Up Adapter.
                //
                if (StringIMatch(eNetCard.Description,S_DIALUP_ADAPTER_DESC)) {
                    continue;
                }

                //
                // Create the adapter section name for this adapter.
                //
                wsprintf(adapterString,TEXT("Adapter%u"),curAdapter);

                //
                // Next, we need to enumerate all of the bindings for this adapter
                // and create nettrans keys for each.
                //

                bindingsKey = JoinPaths(eNetCard.CurrentKey,S_BINDINGS);

                //
                // Open this key and enumerate the bindings underneath it.
                //
                if ((hKey = OpenRegKeyStr(bindingsKey)) != NULL) {
                    if (EnumFirstRegValue(&eRegVal,hKey)) {

                        do {

                            //
                            // For each protocol entry, build up the nettrans key.
                            //
                            networkKey = JoinPaths(S_NETWORK_BRANCH,eRegVal.ValueName);
                            netTransKey = JoinPaths(S_SERVICECLASS,pGetRegistryValue(networkKey,S_DRIVERVAL));

                            //
                            // Save this key into memdb.
                            //
                            MemDbSetValueEx(
                                MEMDB_CATEGORY_NETTRANSKEYS,
                                adapterString,
                                netTransKey,
                                NULL,
                                0,
                                &offset
                                );


                            //
                            // link it into the adapters section.
                            //

                            p = _tcschr(eRegVal.ValueName,TEXT('\\'));
                            if (p) {
                                *p = 0;
                            }

                            MemDbSetValueEx(
                                MEMDB_CATEGORY_NETADAPTERS,
                                adapterString,
                                S_BINDINGS,
                                eRegVal.ValueName,
                                offset,
                                NULL
                                );

                            if ((!fBoundToTCP) && 0 == lstrcmpi(eRegVal.ValueName, S_MSTCP))
                            {
                                fBoundToTCP = TRUE;
                            }

                             FreePathString(networkKey);
                             FreePathString(netTransKey);

                        } while (EnumNextRegValue(&eRegVal));
                    }

                    CloseRegKey(hKey);
                }

                //
                // Finally, store the pnpid for this card into memdb.
                //


                MemDbSetValueEx(
                    MEMDB_CATEGORY_NETADAPTERS,
                    adapterString,
                    MEMDB_FIELD_PNPID,
                    eNetCard.HardwareId && *eNetCard.HardwareId ? eNetCard.HardwareId : eNetCard.CompatibleIDs,
                    0,
                    NULL
                    );

                //store the driver key for this card into memdb
                MemDbSetValueEx(
                    MEMDB_CATEGORY_NETADAPTERS,
                    adapterString,
                    MEMDB_FIELD_DRIVER,
                    eNetCard.HardwareEnum.Driver,
                    0,
                    NULL
                    );

                if (fBoundToTCP && 0 == lstrcmp(eNetCard.CompatibleIDs, S_ICSHARE))
                {
                    //Save the ICSHARE adapter name for further use
                    lstrcpyn(g_IcsAdapter, adapterString, sizeof(g_IcsAdapter)/sizeof(g_IcsAdapter[0]));
                }

                FreePathString(bindingsKey);

                curAdapter++;

            } while (EnumNextNetCard(&eNetCard));

        } __except (EXCEPTION_EXECUTE_HANDLER) {

            EnumNetCardAbort(&eNetCard);
            LOG ((LOG_ERROR,"Caught exception while gathering data about network adapters."));
            return;
        }
    }
}



/*++

Routine Description:

  pEnumFirstAdapterByBinding and pEnumNextAdapterByBinding are memdb enumeration wrapperz
  that are used by several functions to enumerate based upon a certain protocol. This is
  necessary in order to build the per-adapter portions of the winnt.sif file.

Arguments:

  Enum    - A pointer to a valid MEMDB_ENUM structure.
  Binding - Contains the binding to enumerate upon.

Return Value:

  TRUE if an adapter was found with the specified binding, FALSE otherwise.

--*/


BOOL
pEnumFirstAdapterByBinding (
    IN      PMEMDB_ENUM Enum,
    IN      PCTSTR      Binding
    )
{

    BOOL    rBindingFound       = FALSE;
    TCHAR   key[MEMDB_MAX];
    UINT    unused;


    if (MemDbEnumItems(Enum,MEMDB_CATEGORY_NETADAPTERS)) {

        do {

            MemDbBuildKey(key,MEMDB_CATEGORY_NETADAPTERS,Enum -> szName,S_BINDINGS,Binding);
            rBindingFound = MemDbGetValue(key,&unused);

        } while(!rBindingFound && MemDbEnumNextValue(Enum));
    }

    return rBindingFound;
}


BOOL
pEnumNextAdapterByBinding (
    IN OUT      PMEMDB_ENUM Enum,
    IN          PCTSTR      Binding
    )
{

    BOOL    rBindingFound       = FALSE;
    TCHAR   key[MEMDB_MAX];
    UINT    unused;

    while(!rBindingFound && MemDbEnumNextValue(Enum)) {

        MemDbBuildKey(key,MEMDB_CATEGORY_NETADAPTERS,Enum -> szName,S_BINDINGS,Binding);
        rBindingFound = MemDbGetValue(key,&unused);

    }

    return rBindingFound;
}


/*++

Routine Description:

  pGetNetTransBinding returns the registry key to the Network Transport
  settings for a specified Adapter and Protocol.

Arguments:

  Adapter  - Contains the adapter to use to retrieve nettrans key information.
  Protocol - Contains the protocol to use to retrieve NetTrans Key
             information.

Return Value:

  The NetTrans Key if successful, NULL otherwise.

--*/


PCTSTR
pGetNetTransBinding(
    IN PCTSTR Adapter,
    IN PCTSTR Protocol
    )
{
    TCHAR  key[MEMDB_MAX];
    UINT   netTransOffset;

    MemDbBuildKey(key,MEMDB_CATEGORY_NETADAPTERS,Adapter,S_BINDINGS,Protocol);
    if (!MemDbGetValue(key,&netTransOffset)) {
        LOG ((LOG_ERROR,"Adapter %s does not have a binding to %s.",Adapter,Protocol));
        return NULL;
    }

    if (!MemDbBuildKeyFromOffset(netTransOffset,g_TempBuffer,2,NULL)) {
        DEBUGMSG((DBG_ERROR,"Error building net trans key..Adapter: %s Protocol: %s",Adapter,Protocol));
        return NULL;
    }

    return g_TempBuffer;

}



/*++

Routine Description:

  pListAdaptersWithBinding is used to create a multisz of adapter section
  names for adapters that have bindings to a specific networking component.
  Several winntsif sections require data in this form.

Arguments:

  Binding - The Binding to use as a filter in listing the adapter sections.
  Suffix  - an optional suffix which is attached to each adapter section
            name. This is useful for building sections such as: adapter1.ipx
            adapter2.ipx, etc etc.

Return Value:

  The list of adapters with the specified network component binding if any,
  NULL otherwise.

--*/


PCTSTR
pListAdaptersWithBinding (
    IN PCTSTR Binding,
    IN PCTSTR Suffix   OPTIONAL
    )
{

    PCTSTR rAdapterSections = NULL;
    PTSTR  string = g_TempBuffer;
    MEMDB_ENUM e;

    *string = 0;

    //
    // Enumerate all adapters, and create an entry for each adapter that has
    // IPX bindings.
    //

    if (pEnumFirstAdapterByBinding(&e,Binding)) {

        rAdapterSections = g_TempBuffer;

        do {

            //
            // Add this adapter into the multistring.
            //
            StringCopy(string,e.szName);
            if (Suffix) {
                StringCat(string,Suffix);
            }
            string = GetEndOfString(string) + 1;



        } while (pEnumNextAdapterByBinding(&e,Binding));

        ++string;
        *string = 0;

    }

    return rAdapterSections;
}



//
// Section Functions
//


/*++

Routine Description:

  Each Section Function is used to build n number of sections within the
  winntsif file. This is necessary for information which has multiple
  sections based upon some criteria. As an example, pNetAdapterSections
  returns a valid section for each adapter found on the system. When there
  are no more sections needed, these functions return NULL.

Arguments:

  None.

Return Value:

  A valid section name if one is necessary or NULL otherwise.

--*/



PCTSTR
pNetAdapterSections (
    VOID
    )
{

    static BOOL         firstTime           = TRUE;
    PCTSTR              rSection            = NULL;
    BOOL                moreNetAdapterInfo  = FALSE;


    //
    // The first time this function is called it causes all net adapter information
    // to be prescanned into memdb and starts an enumeration. Afterwards,
    // the function simply continues the enumeration.
    //

    if (firstTime) {

        firstTime = FALSE;

        //
        // The first thing we need to do is gather all of the necessary net card
        // information that will be needed during winntsif processing and store
        // it in a reasonable manner.
        //
        pGatherNetAdapterInfo();

        //
        // After pre-scanning all of the network adapter information into
        // memdb, we simply enumerate the adapters and return the section
        // names.
        //
        moreNetAdapterInfo = MemDbEnumItems(&g_TempEnum,MEMDB_CATEGORY_NETADAPTERS);
    }
    else {

        moreNetAdapterInfo = MemDbEnumNextValue(&g_TempEnum);
    }

    if (moreNetAdapterInfo) {

        StringCopy(g_CurrentAdapter,g_TempEnum.szName);
        rSection = g_CurrentAdapter;
        //
        // We have a minor hack here. The [NetAdapters] Section is a little unique
        // and doesn't fit our overall scheme. We secretly fill it in inside this
        // function.
        //
        WriteInfKey(S_PAGE_NETADAPTERS,g_TempEnum.szName,g_TempEnum.szName);

    }

    return rSection;
}


PCTSTR
pIpxAdapterSections (
    VOID
    )
{

    static       firstTime              = TRUE;
    PCTSTR       rSectionName           = NULL;
    BOOL         moreIpxAdapterSections;

    if (firstTime) {

        firstTime = FALSE;

        moreIpxAdapterSections = pEnumFirstAdapterByBinding(&g_TempEnum,S_NWLINK);
    }
    else {

        moreIpxAdapterSections = pEnumNextAdapterByBinding(&g_TempEnum,S_NWLINK);
    }


    if (moreIpxAdapterSections) {

        StringCopy(g_CurrentAdapter,g_TempEnum.szName);
        StringCopy(g_CurrentSection,g_TempEnum.szName);
        StringCat(g_CurrentSection,S_IPX_SUFFIX);
        rSectionName = g_CurrentSection;
    }


    return rSectionName;

}

PCTSTR
pTcpAdapterSections (
    VOID
    )
{

    static       firstTime              = TRUE;
    PCTSTR       rSectionName           = NULL;
    BOOL         moreTcpAdapterSections;

    g_fIcsAdapterInPlace = FALSE;

    if (firstTime) {

        firstTime = FALSE;

        moreTcpAdapterSections = pEnumFirstAdapterByBinding(&g_TempEnum,S_MSTCP);
    }
    else {

        moreTcpAdapterSections = pEnumNextAdapterByBinding(&g_TempEnum,S_MSTCP);
    }


    if (moreTcpAdapterSections) {

        StringCopy(g_CurrentAdapter,g_TempEnum.szName);
        StringCopy(g_CurrentSection,g_TempEnum.szName);
        StringCat(g_CurrentSection,S_TCPIP_SUFFIX);
        rSectionName = g_CurrentSection;

        //if ICS is installed, in Win9x, the external LAN adapter uses the TCP settings of
        //the virtual adapter -- ICSHARE. So when we save the TCP settings of this LAN
        //adapter, we should save the settings of ICSHARE adapter. That's why
        //we replace the g_CurrentAdapter with g_IcsAdapter
        if (g_fHasIcsExternalAdapter &&
            lstrcmp(g_CurrentAdapter, g_IcsExternalAdapter) == 0)
        {
            StringCopy(g_CurrentAdapter, g_IcsAdapter);
            g_fIcsAdapterInPlace = TRUE;
        }
    }


    return rSectionName;

}


PCTSTR
pRasPortSections (
    VOID
    )
{
    static BOOL         firstTime           = TRUE;
    static REGKEY_ENUM  e;
    static UINT         modemNum            = 1;
    BOOL                moreRasPortSections;
    PCTSTR              rSectionName        = NULL;



    if (firstTime) {
        firstTime = FALSE;
        moreRasPortSections = HwComp_DialUpAdapterFound() && EnumFirstRegKeyStr(&e,S_MODEMS);
    }
    else {

        moreRasPortSections = EnumNextRegKey(&e);

    }

    if (moreRasPortSections) {

        wsprintf(g_CurrentSection,TEXT("COM%u"),modemNum);
        modemNum++;
        rSectionName = g_CurrentSection;
    }

    return rSectionName;
}




VOID
pInitializeBindingInfo (
    HASHTABLE Table
    )
{
    MEMDB_ENUM e;
    UINT i;
    UINT j;
    TCHAR buffer[MEMDB_MAX];
    BOOL enabled=FALSE;

    //
    // This function will enumerate all possible binding paths on the machine and add them to
    // the provided string table. Later on, specifically enabled bindings will be removed.
    //
    if (MemDbEnumItems (&e, MEMDB_CATEGORY_NETADAPTERS)) {

        do {

            for (i = 0; i < NUM_CLIENTS; i++) {
                if (!g_BindingInfo.Clients[i].Installed) {
                    continue;
                }

                for (j = 0; j < NUM_PROTOCOLS; j++) {

                    if (g_BindingInfo.Protocols[j].Installed) {


                        //
                        // Add this client/protocl/adapter possibility to
                        // the hash table.
                        //
                        wsprintf (
                            buffer,
                            TEXT("%s,%s,%s"),
                            g_BindingInfo.Clients[i].Text,
                            g_BindingInfo.Protocols[j].Text,
                            e.szName
                            );


                        HtAddStringAndData (Table, buffer, &enabled);



                        DEBUGMSG ((DBG_VERBOSE, "DISABLED BINDING: %s", buffer));
                    }

                }
            }



            for (j = 0; j < NUM_PROTOCOLS; j++) {

                //
                // Add the protocol adapter mapping into the table.
                //
                if (g_BindingInfo.Protocols[j].Installed) {

                    wsprintf (buffer, TEXT("%s,%s"), g_BindingInfo.Protocols[j].Text, e.szName);
                    HtAddStringAndData (Table, buffer, &enabled);
                    DEBUGMSG ((DBG_VERBOSE, "DISABLED BINDING: %s", buffer));
                }
            }

        } while(MemDbEnumNextValue (&e));
    }
}


VOID
pResolveEnabledBindings (
    HASHTABLE Table
    )
{
    //
    // This function removes enabled binding paths from the hash table provided
    // (previously initialized with all of the binding possibilities that could
    //  exist on the machine..)
    //
    NETCARD_ENUM eCard;
    REGVALUE_ENUM eValues;
    REGVALUE_ENUM eProtocolValues;
    UINT curAdapter = 1;
    TCHAR adapterString[30];
    PTSTR bindingsPath = NULL;
    PTSTR protocolBindingsPath = NULL;
    PTSTR protocol = NULL;
    PTSTR client = NULL;
    HKEY key;
    HKEY protocolsKey;
    TCHAR buffer[MEMDB_MAX];
    HASHITEM index;
    BOOL enabled=TRUE;



    if (EnumFirstNetCard (&eCard)) {

        __try {

            do {

                //
                // Skip the Dial-Up Adapter.
                //
                if (StringIMatch (eCard.Description, S_DIALUP_ADAPTER_DESC)) {
                    continue;
                }

                //
                // Create the adapter section name for this adapter.
                //
                wsprintf (adapterString, TEXT("Adapter%u"), curAdapter);
                curAdapter++;
                bindingsPath = JoinPaths(eCard.CurrentKey,S_BINDINGS);

                key = OpenRegKeyStr (bindingsPath);
                FreePathString (bindingsPath);
                if (!key) {
                    continue;
                }

                if (EnumFirstRegValue (&eValues, key)) {
                    do {

                        protocol = NULL;

                        /*
                        if (IsPatternMatch (TEXT("NETBEUI*"), eValues.ValueName)) {
                            protocol = S_MS_NETBEUI;
                        } else if (IsPatternMatch (TEXT("MSDLC*"), eValues.ValueName)) {
                            protocol = S_MS_DLC;
                        }
                        */

                        if (IsPatternMatch (TEXT("NWLINK*"), eValues.ValueName)) {
                            protocol = S_MS_NWIPX;
                        }
                        else if (IsPatternMatch (TEXT("MSTCP*"), eValues.ValueName)) {
                            protocol = S_MS_TCPIP;

                        }

                        if (!protocol) {
                            continue;
                        }

                        //
                        // Enable protocol <-> adapter binding.
                        //

                        wsprintf (buffer, TEXT("%s,%s"),  protocol, adapterString);
                        index = HtFindString (Table, buffer);

                        if (index) {
                            HtSetStringData (Table, index, (PBYTE) &enabled);

                        }
                        DEBUGMSG ((DBG_VERBOSE, "ENABLED BINDING: %s", buffer));

                        //
                        // Search the bindings and enable protocol <-> client bindings
                        //

                        protocolBindingsPath = JoinPaths (S_NETWORK_BRANCH, eValues.ValueName);
                        bindingsPath = JoinPaths (protocolBindingsPath, S_BINDINGS);
                        FreePathString(protocolBindingsPath);

                        protocolsKey = OpenRegKeyStr (bindingsPath);
                        FreePathString (bindingsPath);

                        if (!protocolsKey) {
                            continue;
                        }

                        if (EnumFirstRegValue (&eProtocolValues, protocolsKey)) {

                            do {
                                client = NULL;


                                if (IsPatternMatch (TEXT("NWREDIR*"), eProtocolValues.ValueName)        ||
                                    IsPatternMatch (TEXT("NWLINK*"), eProtocolValues.ValueName)         ||
                                    IsPatternMatch (TEXT("NOVELLIPX32*"), eProtocolValues.ValueName)    ||
                                    IsPatternMatch (TEXT("IPXODI*"), eProtocolValues.ValueName)         ||
                                    IsPatternMatch (TEXT("NOVELL32*"), eProtocolValues.ValueName)) {
                                    client = S_MS_NWCLIENT;
                                }
                                else if (IsPatternMatch (TEXT("VREDIR*"), eProtocolValues.ValueName)) {
                                    client = S_MS_NETCLIENT;
                                }

                                if (client) {
                                    //
                                    // We can now remove a path from the bindings table -- we've got an
                                    // enabled one.
                                    //
                                    wsprintf (buffer, TEXT("%s,%s,%s"), client, protocol, adapterString);

                                    index = HtFindString (Table, buffer);
                                    if (index) {
                                        HtSetStringData (Table, index, (PBYTE) &enabled);
                                    }

                                    DEBUGMSG ((DBG_VERBOSE, "ENABLED BINDING: %s", buffer));
                                }

                            } while (EnumNextRegValue (&eProtocolValues));
                        }

                        CloseRegKey (protocolsKey);

                    } while (EnumNextRegValue (&eValues));
                }

                CloseRegKey (key);
            } while (EnumNextNetCard (&eCard));

        } __except (EXCEPTION_EXECUTE_HANDLER) {

            EnumNetCardAbort(&eCard);
            LOG ((LOG_ERROR,"Caught exception while gathering data about network adapters."));
            return;
        }
    }
}


BOOL
pSplitBindingPathIntoComponents (
    IN OUT PTSTR BindingPath,
    OUT PCTSTR * Client,
    OUT PCTSTR * Protocol,
    OUT PCTSTR * Adapter
    )
{
    PTSTR p;

    p = BindingPath;
    *Client = p;

    p = _tcschr (p, TEXT(','));
    MYASSERT (p);
    if (!p) {
        return FALSE;
    }

    *p = 0;
    p = _tcsinc (p);
    *Protocol = p;

    p = _tcschr (p, TEXT(','));

    if (!p) {

        //
        // Only Adapter and Protocol specified.
        //
        *Adapter = *Protocol;
        *Protocol = *Client;
        *Client = NULL;

    }
    else {

        //
        // Adapter/Protocol/Client specified.
        //
        *p = 0;
        p = _tcsinc (p);
        *Adapter = p;

    }

    return TRUE;

}


PCTSTR
pBindingSections (
    VOID
    )
{

    HASHTABLE disabledBindings;
    HASHTABLE_ENUM e;
    TCHAR bindingString[MEMDB_MAX];
    PTSTR client = NULL;
    PTSTR protocol = NULL;
    PTSTR adapter = NULL;
    DWORD keyVal = 0;

    disabledBindings = HtAllocWithData (sizeof(BOOL));


    if (!disabledBindings) {
        return NULL;
    }

    pInitializeBindingInfo (disabledBindings);
    pResolveEnabledBindings (disabledBindings);

    //
    // Simply enumerate the table and blast each disabled setting
    // to winnt.sif.
    //
    if (EnumFirstHashTableString (&e, disabledBindings)) {

        do {

            if (!*((PBOOL) e.ExtraData)) {

                StringCopy (bindingString, e.String);
                if (!pSplitBindingPathIntoComponents (bindingString, &client, &protocol, &adapter)) {
                    continue;
                }

                MYASSERT (protocol && adapter);

                //
                // Write full path..
                //
                keyVal = 0;
                if (client) {
                    keyVal = WriteInfKeyEx (S_NETBINDINGS, S_DISABLED, client, keyVal, TRUE);
                }

                keyVal = WriteInfKeyEx (S_NETBINDINGS, S_DISABLED, protocol, keyVal, TRUE);
                keyVal = WriteInfKeyEx (S_NETBINDINGS, S_DISABLED, adapter, keyVal, TRUE);

                DEBUGMSG ((DBG_VERBOSE, "DISABLED BINDING: %s", e.String));
            }

        } while (EnumNextHashTableString (&e));
    }

    HtFree (disabledBindings);

    //
    // All of the binding information is handled outside the normal winntsif proceessing. Therefore, we always return
    // NULL here (winntsif processing continues on...)
    //
    return NULL;
}


//
// Creation Functions
//

/*++

Routine Description:

  Each Creation function is responsible for determining wether a specific
  winntsif setting should be processed or
  not. The purpose of most of these functions is obvious.

    pIsNetworkingInstalled -
        returns TRUE if the machine has networking installed.

    pIsNetBeuiInstalled -
        TRUE if NETBEUI is installed on the machine.

    pIsMsDlcInstalled -
        TRUE if MSDLC or MSDLC32 is installed on the machine.

    pIsNwIpxInstalled -
        TRUE if the machine is running the IPX protocol.

    pIsTcpIpInstalled -
        TRUE if the machine is running the TCPIP protocol.

    pIsDnsEnabled -
        TRUE DNS support is enabled.

    pIsRasInstalled
        TRUE if the machine uses Remote Access.

    pIsWkstaInstalled
        TRUE if the Workstation Service is installed.

    pIsNwClientInstalled
        TRUE if the NWLINK is installed.

    pHasStaticIpAddress
        TRUE if the machine has a static IP address.


Arguments:

  None.

Return Value:

  TRUE if the winntsif engine should process the setting, FALSE otherwise.

--*/


BOOL
pIsNetworkingInstalled (
    VOID
    )
{
    static BOOL firstTime = TRUE;
    static BOOL rCreate   = FALSE;

    if (firstTime) {

        firstTime = FALSE;
        rCreate =
            HwComp_DialUpAdapterFound() ||
            MemDbGetEndpointValueEx(
                MEMDB_CATEGORY_NETADAPTERS,
                TEXT("Adapter1"),
                MEMDB_FIELD_PNPID,
                g_TempBuffer
                );
    }

    return rCreate;
}

BOOL
pInstallMsServer (
    VOID
    )
{

    if (MemDbGetEndpointValueEx(
            MEMDB_CATEGORY_NETADAPTERS,
            TEXT("Adapter1"),
            MEMDB_FIELD_PNPID,
            g_TempBuffer
            )) {

            return TRUE;
    }



    return FALSE;

}

BOOL
pIsNetBeuiInstalled (
    VOID
    )
{
    static BOOL rCreate = FALSE;
    static BOOL firstTime = TRUE;
    UINT i;

    if (firstTime) {
        rCreate = pIsNetworkingInstalled() && pDoesNetComponentHaveBindings(S_NETBEUI);
        if (rCreate) {
            //
            // Need to make sure tcp/ip is taken care of when processing bindings.
            //
            for (i=0;i<NUM_PROTOCOLS;i++) {
                if (StringIMatch (g_BindingInfo.Protocols[i].Text, S_MS_NETBEUI)) {
                    g_BindingInfo.Protocols[i].Installed = TRUE;
                    break;
                }
            }
        }

        firstTime = FALSE;
    }



    return rCreate;

}

#define S_IBMDLC TEXT("IBMDLC")
#define S_IBMDLC_REG TEXT("HKLM\\Enum\\Network\\IBMDLC")

BOOL
pIsMsDlcInstalled (
    VOID
    )
{

    static BOOL rCreate = FALSE;
    static BOOL firstTime = TRUE;
    UINT i;


    if (firstTime) {
        firstTime = FALSE;


        if (!pIsNetworkingInstalled()) {
            return FALSE;
        }

        //
        // Check to se if MS client is installed.
        //
        if (pDoesNetComponentHaveBindings(S_MSDLC) || pDoesNetComponentHaveBindings(S_MSDLC32)) {

            rCreate = TRUE;
        }

        //
        // Check to see if IBM DLC client is installed (and hasn't been handled by a migration dll..)
        // If so, we'll install the MS DLC client. IBM needs to write a migration dll to handle the
        // migration of their client. In the migration dll, they can handle this registry key, and
        // we will not install the protocol.
        //
        if (!rCreate && pDoesNetComponentHaveBindings(S_IBMDLC) && !Is95RegKeySuppressed (S_IBMDLC_REG)) {

            rCreate = TRUE;
        }


        if (rCreate) {

            for (i=0;i<NUM_PROTOCOLS;i++) {
                if (StringIMatch (g_BindingInfo.Protocols[i].Text, S_MS_DLC)) {
                    g_BindingInfo.Protocols[i].Installed = TRUE;
                    break;
                }
            }
        }
    }

    return rCreate;
}

BOOL
pIsNwIpxInstalled (
    VOID
    )
{
    static BOOL firstTime = TRUE;
    static BOOL rCreate = FALSE;
    UINT i;


    if (firstTime) {
        rCreate = pIsNetworkingInstalled() && pDoesNetComponentHaveBindings(S_NWLINK);
        if (rCreate) {
            //
            // Need to make sure tcp/ip is taken care of when processing bindings.
            //
            for (i=0;i<NUM_PROTOCOLS;i++) {
                if (StringIMatch (g_BindingInfo.Protocols[i].Text,S_MS_NWIPX)) {
                    g_BindingInfo.Protocols[i].Installed = TRUE;
                    break;
                }
            }
        }

        firstTime = FALSE;
    }


    return rCreate;

}

BOOL
pIsTcpIpInstalled (
    VOID
    )
{
    static BOOL firstTime = TRUE;
    static BOOL rCreate   = FALSE;
    UINT i;

    if (firstTime) {

        firstTime = FALSE;
        rCreate = pIsNetworkingInstalled() && pDoesNetComponentHaveBindings(S_MSTCP);

        //
        // Need to make sure tcp/ip is taken care of when processing bindings.
        //
        for (i=0;i<NUM_PROTOCOLS;i++) {
            if (StringIMatch (g_BindingInfo.Protocols[i].Text, S_MS_TCPIP)) {
                g_BindingInfo.Protocols[i].Installed = TRUE;
                break;
            }
        }
    }

    return rCreate;
}



BOOL
pIsDnsEnabled (
    VOID
    )
{
    return pGetRegistryValue (S_MSTCP_KEY, S_ENABLEDNS) && *g_TempBuffer == TEXT('1');
}

BOOL
pIsRasInstalled (
    VOID
    )
{
    return HwComp_DialUpAdapterFound();
}


BOOL
pIsSnmpInstalled (
    VOID
    )
{
    return pDoesNetComponentHaveBindings (S_SNMP);
}

BOOL
pIsUpnpInstalled (
    VOID
    )
{
    HKEY key;
    BOOL b = FALSE;

    key = OpenRegKey (HKEY_LOCAL_MACHINE, S_REGKEY_UPNP);
    if (key) {
        b = TRUE;
        CloseRegKey (key);
    }

    return b;
}

BOOL
pIsWkstaInstalled (
    VOID
    )
{
    static BOOL firstTime = TRUE;
    static BOOL rCreate   = FALSE;
    UINT i;

    if (firstTime) {

        firstTime = FALSE;
        rCreate = pDoesNetComponentHaveBindings(S_VREDIR);


        if (rCreate) {
            //
            // Need to make sure tcp/ip is taken care of when processing bindings.
            //
            for (i=0;i<NUM_CLIENTS;i++) {
                if (StringIMatch (g_BindingInfo.Clients[i].Text, S_MS_NETCLIENT)) {
                    g_BindingInfo.Clients[i].Installed = TRUE;
                    break;
                }
            }
        }
    }


    return rCreate;
}


BOOL
pDisableBrowserService (
    VOID
    )
{

    if (pIsWkstaInstalled () && !pDoesNetComponentHaveBindings (S_VSERVER)) {
        return TRUE;
    }

    return FALSE;
}

#define S_IPXODI TEXT("IPXODI")
#define S_IPXODI_REG TEXT("HKLM\\Enum\\Network\\IPXODI")
#define S_NOVELLIPX32 TEXT("NOVELLIPX32")
#define S_NOVELL32 TEXT("NOVELL32")




BOOL
pIsNwClientInstalled (
    VOID
    )
{
    static BOOL firstTime = TRUE;
    static BOOL rCreate   = FALSE;
    UINT i;

    if (firstTime) {

        firstTime = FALSE;
        rCreate = pDoesNetComponentHaveBindings(S_NWREDIR) ||
                  pDoesNetComponentHaveBindings(S_NOVELLIPX32) ||
                  pDoesNetComponentHaveBindings(S_NOVELL32) ||
                  (pDoesNetComponentHaveBindings(S_IPXODI) && !Is95RegKeySuppressed (S_IPXODI_REG));


        if (rCreate) {

            //
            // Need to make sure tcp/ip is taken care of when processing bindings.
            //
            for (i=0;i<NUM_CLIENTS;i++) {
                if (StringIMatch (g_BindingInfo.Clients[i].Text, S_MS_NWCLIENT)) {
                    g_BindingInfo.Clients[i].Installed = TRUE;
                    break;
                }
            }
        }
    }


    return rCreate;
}

BOOL
pHasStaticIpAddress (
    VOID
    )
{

    PCTSTR netTrans = NULL;
    netTrans = pGetNetTransBinding (g_CurrentAdapter, S_MSTCP);


    return netTrans != NULL &&
        pGetRegistryValue (netTrans, S_IPADDRVAL) != NULL &&
        !StringMatch (g_TempBuffer, TEXT("0.0.0.0"));

}
//
// Data Functions
//



/*++

Routine Description:

  pGetTempDir returns the temporary directory used by the win9xupg code.

Arguments:

  None.

Return Value:

  a multisz contaiining the win9xupg directory, or NULL if it could not be
  retrieved.

--*/


PCTSTR
pGetTempDir (
    VOID
    )
{


    //
    // Necessary for winntsif.exe tool.
    //
    if (!g_TempDir) {
        return NULL;
    }

    CLEARBUFFER();
    StringCopy(g_TempBuffer,g_TempDir);


    return g_TempBuffer;
}

/*++

Routine Description:

  pGetWin9xBootDrive returns the win9x boot drive letter used by the win9xupg code.

Arguments:

  None.

Return Value:

  a multisz contaiining the win9x boot drive letter, or NULL if it could not be
  retrieved.

--*/


PCTSTR
pGetWin9xBootDrive (
    VOID
    )
{
    CLEARBUFFER();
    wsprintf(g_TempBuffer,TEXT("%c:"),g_BootDriveLetter);

    return g_TempBuffer;
}



/*++

Routine Description:

  pGetGuiCodePage adds the code page override data for GUI mode to run in.

Arguments:

  None.

Return Value:

  a multisz contaiining the code page GUI mode should run in or NULL if it could not be
  retrieved or isn't needed.

--*/

PCTSTR
pGetGuiCodePage (
    VOID
    )
{

    HKEY key;
    PCTSTR systemCodePage;
    PCTSTR winntCodePage;
    INFSTRUCT is = INITINFSTRUCT_POOLHANDLE;
    PCTSTR rCodePage = NULL;
    TCHAR nlsFile[MAX_TCHAR_PATH];
    TCHAR nlsFileCompressed[MAX_TCHAR_PATH];
    PTSTR p;
    UINT i;
    BOOL cpExists = FALSE;



    key = OpenRegKeyStr (TEXT("HKLM\\System\\CurrentControlSet\\Control\\Nls\\CodePage"));
    if (!key) {
        return NULL;
    }

    __try {

        //
        // Get the ACP of the currently running system.
        //
        systemCodePage = GetRegValueString (key, TEXT("ACP"));
        if (!systemCodePage || InfFindFirstLine (g_Win95UpgInf, S_CODEPAGESTOIGNORE, systemCodePage, &is)) {

            //
            // Either the code page doesn't exist, or we intentionally skip it.
            //
            __leave;
        }

        //
        // Get the code page of our infs.
        //
        if (InfFindFirstLine (g_Win95UpgInf, S_VERSION, TEXT("LANGUAGE"), &is)) {

            winntCodePage = InfGetStringField (&is,1);

            if (!winntCodePage) {
                __leave;
            }
        }

        if (StringIMatch (winntCodePage, systemCodePage)) {

            //
            // Nothing to do if they are the same.
            //

            __leave;
        }

        if (!InfFindFirstLine (g_Win95UpgInf, S_ALLOWEDCODEPAGEOVERRIDES, winntCodePage, &is)) {

            //
            // We don't allow code page overrides from this winnt code page.
            //
            __leave;
        }


        //
        // See if this nls file exists in the source directories.
        //
        wsprintf(nlsFileCompressed, TEXT("c_%s.nl_"), systemCodePage);
        wsprintf(nlsFile, TEXT("c_%s.nls"), systemCodePage);

        for (i = 0; i < SOURCEDIRECTORYCOUNT(); i++) {

            p = JoinPaths (SOURCEDIRECTORY(i), nlsFileCompressed);
            if (DoesFileExist (p)) {
                cpExists = TRUE;
            }
            else {
                FreePathString (p);
                p = JoinPaths (SOURCEDIRECTORY(i), nlsFile);
                if (DoesFileExist (p)) {
                    cpExists = TRUE;
                }
            }


            FreePathString (p);
        }

        if (!cpExists) {
            wsprintf(nlsFile, TEXT("c_%s.nls"), systemCodePage);

            for (i = 0; i < SOURCEDIRECTORYCOUNT(); i++) {

                p = JoinPaths (SOURCEDIRECTORY(i), nlsFile);
                if (DoesFileExist (p)) {
                    cpExists = TRUE;
                }

                FreePathString (p);
            }
        }


        //
        // Codepage exists. We can and should override this for GUI mode.
        //
        if (cpExists) {

            CLEARBUFFER();
            StringCopy (g_TempBuffer, systemCodePage);
            rCodePage = g_TempBuffer;
            DEBUGMSG ((DBG_VERBOSE, "Overriding code page %s with %s during GUI mode.", winntCodePage, systemCodePage));

        }

    }
    __finally {

        if (systemCodePage) {
            MemFree (g_hHeap, 0, systemCodePage);
        }

        InfCleanUpInfStruct (&is);
        CloseRegKey (key);
    }


    return rCodePage;
}


/*++

Routine Description:

  pBackupImageList writes a path to winnt.sif listing the files to backup.

Arguments:

  None.

Return Value:

  a multisz containing the backup path, or NULL if it isn't needed.

--*/

PCTSTR
pBackupFileList (
    VOID
    )
{
    if (TRISTATE_NO == g_ConfigOptions.EnableBackup) {
        return NULL;
    }

    CLEARBUFFER();

    StringCopy (g_TempBuffer, g_TempDir);
    StringCopy (AppendWack (g_TempBuffer), TEXT("backup.txt"));

    return g_TempBuffer;
}


PCTSTR
pUninstallMoveFileList (
    VOID
    )
{
    if (!g_ConfigOptions.EnableBackup) {
        return NULL;
    }

    CLEARBUFFER();

    StringCopy (g_TempBuffer, g_TempDir);
    StringCopy (AppendWack (g_TempBuffer), S_UNINSTALL_TEMP_DIR TEXT("\\") S_ROLLBACK_MOVED_TXT);

    return g_TempBuffer;
}


PCTSTR
pUninstallDelDirList (
    VOID
    )
{
    if (!g_ConfigOptions.EnableBackup) {
        return NULL;
    }

    CLEARBUFFER();

    StringCopy (g_TempBuffer, g_TempDir);
    StringCopy (AppendWack (g_TempBuffer), S_UNINSTALL_TEMP_DIR TEXT("\\") S_ROLLBACK_DELDIRS_TXT);

    return g_TempBuffer;
}


PCTSTR
pUninstallDelFileList (
    VOID
    )
{
    if (!g_ConfigOptions.EnableBackup) {
        return NULL;
    }

    CLEARBUFFER();

    StringCopy (g_TempBuffer, g_TempDir);
    StringCopy (AppendWack (g_TempBuffer), S_UNINSTALL_TEMP_DIR TEXT("\\") S_ROLLBACK_DELFILES_TXT);

    return g_TempBuffer;
}


PCTSTR
pUninstallMkDirList (
    VOID
    )
{
    if (!g_ConfigOptions.EnableBackup) {
        return NULL;
    }

    CLEARBUFFER();

    StringCopy (g_TempBuffer, g_TempDir);
    StringCopy (AppendWack (g_TempBuffer), S_UNINSTALL_TEMP_DIR TEXT("\\") S_ROLLBACK_MKDIRS_TXT);

    return g_TempBuffer;
}


/*++

Routine Description:

  pGetWin9xSifDir returns the directory containing the filemove and filedel
  files.

Arguments:

  None.

Return Value:

  a multisz contaiining the win9xsifdir directory, or NULL if it could not be
  retrieved.

--*/

PCTSTR
pGetWin9xSifDir (
    VOID
    )
{

    //
    // Necessary for winntsif.exe tool.
    //
    if (!g_Win9xSifDir) {
        return NULL;
    }

    CLEARBUFFER();
    StringCopy(g_TempBuffer,g_Win9xSifDir);
    return g_TempBuffer;
}


/*++

Routine Description:

  pGetWinDir returns the windows directory of the machine being upgraded.

Arguments:

  None.

Return Value:

  a multisz contaiining the windows directory, or NULL if it could not be
  retrieved.

--*/

PCTSTR
pGetWinDir (
    VOID
    )
{

    //
    // Necessary for winntsif.exe tool.
    //
    if (!g_WinDir) {
        return NULL;
    }

    CLEARBUFFER();
    StringCopy(g_TempBuffer,g_WinDir);
    return g_TempBuffer;

}

#if 0
/*++

Routine Description:

  If the upgrade is running in unattended mode, this function returns "1",
  otherwise it returns "0". This is used to control wether GUI mode setup pauses
  at the final wizard screen or reboots automatically.

Arguments:

  None.

Return Value:

  a multisz contaiining the GUI mode pause state.

--*/
PCTSTR
pNoWaitAfterGuiMode (
    VOID
    )
{

    CLEARBUFFER();
    StringCopy(g_TempBuffer,UNATTENDED() ? S_ONE : S_ZERO);

    return g_TempBuffer;
}
#endif

/*++

Routine Description:

  pGetKeyboardLayout retrieves the keyboard layout to write to the winntsif file.
  This is done by retrieving the name of the layout being used by win9x and matching it
  against the keyboard layouts in txtsetup.sif.

Arguments:

  None.

Return Value:

  a multisz containing the keyboard layout, or NULL if it could not be
  retrieved.

--*/
PCTSTR
pGetKeyboardLayout (
    VOID
    )
{

    TCHAR       buffer[MAX_KEYBOARDLAYOUT];
    INFCONTEXT  ic;

    GetKeyboardLayoutName(buffer);

    //
    // Because some brilliant developer added ["Keyboard Layout"] instead of
    // just [Keyboard Layout], we cannot use GetPrivateProfileString.
    // We must use setup APIs.
    //

    if (SetupFindFirstLine (g_TxtSetupSif, S_QUOTEDKEYBOARDLAYOUT, buffer, &ic)) {
        if (SetupGetOemStringField (&ic, 1, g_TempBuffer, sizeof (g_TempBuffer), NULL)) {
            return g_TempBuffer;
        }
    }

    DEBUGMSG((DBG_WINNTSIF,"Keyboard layout %s not found in txtsetup.sif.",buffer));

    return NULL;
}
/*++

Routine Description:

  pGetKeyboardHardware retrives the keyboard hardware id of the machine running
  the upgrade.

Arguments:

  None.

Return Value:

  a multisz contaiining the win9xupg directory, or NULL if it could not be
  retrieved.

--*/

PCTSTR
pGetKeyboardHardware (
    VOID
    )
{
    CLEARBUFFER();

    if (GetLegacyKeyboardId (g_TempBuffer,sizeof(g_TempBuffer))) {
        return g_TempBuffer;
    }
    return NULL;
}

/*++

Routine Description:

  This rather laborious function retrieves the correct index to write to
  the winntsif file for the timezone being used on the machine. To do this,
  it is necessary to munge through several parts of the registry in order
  to find the correct string to match with and then match that string against
  the timezone mappings contained in win95upg.inf to come up with the actual
  index.

Arguments:

  None.

Return Value:

  a multisz containing the index to write to the winntsif file, or NULL if it
  could not be retrieved.

--*/
PCTSTR
pGetTimeZone (
    VOID
    )
{
    TIMEZONE_ENUM e;
    PCTSTR component = NULL;
    PCTSTR warning = NULL;
    PCTSTR args[1];

    if (EnumFirstTimeZone (&e, TZFLAG_USE_FORCED_MAPPINGS) || EnumFirstTimeZone(&e, TZFLAG_ENUM_ALL)) {

        if (e.MapCount != 1) {

            //
            // Ambigous timezone situation. Add an incompatibility message.
            //
            args[0] = e.CurTimeZone;

            component = GetStringResource (MSG_TIMEZONE_COMPONENT);

            if (*e.CurTimeZone) {
                warning = ParseMessageID (MSG_TIMEZONE_WARNING, args);
            }
            else {
                warning = GetStringResource (MSG_TIMEZONE_WARNING_UNKNOWN);
            }

            MYASSERT (component);
            MYASSERT (warning);

            MsgMgr_ObjectMsg_Add (TEXT("*TIMEZONE"), component, warning);
            FreeStringResource (component);
            FreeStringResource (warning);
        }

        CLEARBUFFER();
        StringCopy (g_TempBuffer, e.MapIndex);
        return g_TempBuffer;
    }
    else {
        LOG ((LOG_ERROR, "Unable to get timezone. User will have to enter timezone in GUI mode."));
    }

    return NULL;
}

/*++

Routine Description:

  pGetFullName returns the full name of the owner of the machine running
  the upgrade. This function first searches the registry and then, if that
  does not provide the needed information, calls GetUserName.

Arguments:

  None.

Return Value:

  a multisz containing the required data, or NULL if it could not be
  retrieved.

--*/

PCTSTR
pGetFullName (
    VOID
    )
{
    UINT size;
    INVALID_NAME_ENUM e;

    if (!pGetRegistryValue(S_WINDOWS_CURRENTVERSION,S_REGISTEREDOWNER)) {
        size = MEMDB_MAX;
        if (GetUserName (g_TempBuffer,&size)) {
            MYASSERT (g_TempBuffer[size - 1] == 0);
            g_TempBuffer[size] = 0;
        }
    }

    //
    // check if this name is:
    // 1. Empty - what do we do in this case?
    // 2. A reserved NT name: then we'll use the new name (user was informed about this)
    //
    if (*g_TempBuffer) {
        if (EnumFirstInvalidName (&e)) {
            do {
                if (StringIMatch (e.OriginalName, g_TempBuffer)) {
                    //
                    // the buffer is actually interpreted as a MULTISZ, so make sure
                    // it's terminated with 2 zeroes
                    //
                    if (SizeOfString (e.NewName) + sizeof (TCHAR) <= sizeof (g_TempBuffer)) {
                        //
                        // we surely have space for an extra 0
                        //
                        StringCopy (g_TempBuffer, e.NewName);
                        *(GetEndOfString (g_TempBuffer) + 1) = 0;
                        break;
                    }
                }
            } while (EnumNextInvalidName (&e));
        }
    }

    return g_TempBuffer;

}

/*++

Routine Description:

  pGetFullName returns the computer name of the machine running the
  upgrade.

Arguments:

  None.

Return Value:

  a multisz containing the required data, or NULL if it could not be
  retrieved.

--*/

PCTSTR
pGetComputerName (
    VOID
    )
{

    CLEARBUFFER();
    if (!GetUpgradeComputerName(g_TempBuffer)) {
        return NULL;
    }

    return g_TempBuffer;
}

/*++

Routine Description:

  pGetXResolution and pGetYResolution return the x and y resolution for
  the machine running the upgrade.

Arguments:

  None.

Return Value:

  a multisz containing the required data, or NULL if it could not be
  retrieved.

--*/

PCTSTR
pGetXResolution (
    VOID
    )
{
/*
    PTSTR s = NULL;

    if (!pGetRegistryValue(S_DISPLAYSETTINGS,S_RESOLUTION)) {
        LOG ((LOG_ERROR, "No Resolution settings."));
        return NULL;
    }

    s = _tcschr(g_TempBuffer,TEXT(','));
    if (s) {
        *s = 0;
        s++;
        *s = 0;
    }
*/
    wsprintf (g_TempBuffer, TEXT("%u%c"), GetSystemMetrics (SM_CXSCREEN), 0);
    return g_TempBuffer;
}


PCTSTR
pGetYResolution (
    VOID
    )
{
/*
    PTSTR s = NULL;

    if (!pGetRegistryValue(S_DISPLAYSETTINGS,S_RESOLUTION)) {
        LOG ((LOG_ERROR, "WinntSif: No Resolution settings."));
        return NULL;
    }

    s = _tcschr(g_TempBuffer,TEXT(','));
    if (s) {
        s++;
    }
    return s;
*/
    wsprintf (g_TempBuffer, TEXT("%u%c"), GetSystemMetrics (SM_CYSCREEN), 0);
    return g_TempBuffer;
}


PCTSTR
pGetBitsPerPixel (
    VOID
    )
{
    DEVMODE dm;

    if (!EnumDisplaySettings (NULL, ENUM_CURRENT_SETTINGS, &dm) ||
        !dm.dmBitsPerPel
        ) {
        return NULL;
    }

    wsprintf (g_TempBuffer, TEXT("%lu%c"), dm.dmBitsPerPel, 0);
    return g_TempBuffer;
}

PCTSTR
pGetVerticalRefreshRate (
    VOID
    )
{
    DEVMODE dm;

    if (!EnumDisplaySettings (NULL, ENUM_CURRENT_SETTINGS, &dm) ||
        !dm.dmDisplayFrequency
        ) {
        return NULL;
    }

    wsprintf (g_TempBuffer, TEXT("%lu%c"), dm.dmDisplayFrequency, 0);
    return g_TempBuffer;
}


/*++

Routine Description:

  Returns the PNP id for the current adapter being worked with.

Arguments:

  None.

Return Value:

  a multisz containing the required data, or NULL if it could not be
  retrieved.

--*/

PCTSTR
pGetNetAdapterPnpId (
    VOID
    )
{

    PCTSTR rPnpId = NULL;
    PTSTR p       = NULL;
    INFSTRUCT is = INITINFSTRUCT_POOLHANDLE;

    CLEARBUFFER();

    rPnpId = g_TempBuffer;

    if (!MemDbGetEndpointValueEx(
        MEMDB_CATEGORY_NETADAPTERS,
        g_CurrentAdapter,
        MEMDB_FIELD_PNPID,
        g_TempBuffer
        )) {

        *g_TempBuffer = TEXT('*');

    }
    else {
        p = _tcschr(g_TempBuffer,TEXT(','));
        if (p) {
            *p = 0;
            p++;
            *p = 0;
        }

        //
        // We may need to map this id.
        //
        if (InfFindFirstLine (g_Win95UpgInf, S_NICIDMAP, g_TempBuffer, &is)) {

            //
            // This pnp id needs to be mapped.
            //
            p = InfGetStringField (&is, 1);
            if (p) {
                CLEARBUFFER();
                StringCopy (g_TempBuffer, p);
            }
        }
    }


    return rPnpId;

}

/*++

Routine Description:

  pSpecificTo simply copies the current adapter into the the temporary
  buffer and returns it. This is necessary for the various adapter sections.

Arguments:

  None.

Return Value:

  a multisz containing the required data, or NULL if it could not be
  retrieved.

--*/

PCTSTR
pSpecificTo (
    VOID
    )
{
    CLEARBUFFER();
    //if this is ICS external adapter and we are saving tcpip settings, then the g_CurrentAdapter
    //actually contains name of the ICSHARE adapter intead of the real LAN adapter.
    //However, "SpecificTo" still needs to point to the real LAN adapter
    StringCopy(g_TempBuffer, (g_fIcsAdapterInPlace) ? g_IcsExternalAdapter : g_CurrentAdapter);

    return g_TempBuffer;
}



/*++

Routine Description:

  pGetBuildNumber simply packs the buildnumber into a string and passes
  it back.

Arguments:

  None.

Return Value:

  a multisz containing the required data, or NULL if it could not be
  retrieved.

--*/


PCTSTR
pGetBuildNumber (
    VOID
    )
{
    CLEARBUFFER();

    wsprintf(g_TempBuffer,"%u",BUILDNUMBER());

    return g_TempBuffer;
}

/*++

Routine Description:

  pGetUpgradeDomainName returns the upgrade domain name.

Arguments:

  None.

Return Value:

  a multisz containing the required data, or NULL if it could not be
  retrieved.

--*/


PCTSTR
pGetUpgradeDomainName (
    VOID
    )
{
    PCTSTR rDomainName = NULL;

    CLEARBUFFER();

    if (GetUpgradeDomainName(g_TempBuffer)) {

        rDomainName = g_TempBuffer;

        //
        // Need to save some state information for use in GUI mode.
        //
        MemDbSetValueEx (
            MEMDB_CATEGORY_STATE,
            MEMDB_ITEM_MSNP32,
            NULL,
            NULL,
            0,
            NULL
            );
    }

    //
    // If /#u:ForceWorkgroup is specified, force to workgroup
    //

    if (g_ConfigOptions.ForceWorkgroup) {
        return NULL;
    }

    return rDomainName;
}

/*++

Routine Description:

  pGetUpgradeWorkgroupName returns the upgrade domain name.

Arguments:

  None.

Return Value:

  a multisz containing the required data, or NULL if it could not be
  retrieved.

--*/


PCTSTR
pGetUpgradeWorkgroupName (
    VOID
    )
{
    PCTSTR rWorkGroupName = NULL;


    //
    // Don't write workgroup settings if domain settings already exist.
    //
    if (pGetUpgradeDomainName()) {
        return NULL;
    }

    CLEARBUFFER();

#ifdef PRERELEASE

    //
    // If /#U:STRESS was specified, hardcode ntdev.
    //
    if (g_Stress) {

        StringCopy(g_TempBuffer,TEXT("ntdev"));
        rWorkGroupName = g_TempBuffer;
    } else

#endif

    //
    // If /#u:ForceWorkgroup is specified, force to workgroup
    //
    if (!GetUpgradeWorkgroupName(g_TempBuffer) && !GetUpgradeDomainName(g_TempBuffer)) {

        PCTSTR Buf = GetStringResource (MSG_DEFAULT_WORKGROUP);
        MYASSERT(Buf);
        StringCopy (g_TempBuffer, Buf);
        FreeStringResource (Buf);
    }

    rWorkGroupName = g_TempBuffer;

    return rWorkGroupName;
}

/*++

Routine Description:

  pGetAdaptersWithIpxBindings and pGetAdaptersWithTcpBindings simply return a
  multisz list of adapter sections names for per-adapter sections of winnt.sif
  data for IPX and TCP settings respectively.

Arguments:

  None.

Return Value:

  a multisz containing the required data, or NULL if it could not be
  retrieved.

--*/


PCTSTR
pGetAdaptersWithIpxBindings (
    VOID
    )
{
    return pListAdaptersWithBinding(S_NWLINK,S_IPX_SUFFIX);
}

PCTSTR
pGetAdaptersWithTcpBindings (
    VOID
    )
{
    return pListAdaptersWithBinding(S_MSTCP,S_TCPIP_SUFFIX);
}

/*++

Routine Description:

  pGetIpxPacketType maps the frame type found in the win9x registry to the
  packet types that are possible in the winnt.sif file.

Arguments:

  None.

Return Value:

  a multisz containing the required data, or NULL if it could not be
  retrieved.

--*/

PCTSTR
pGetIpxPacketType (
    VOID
    )
{

    PCTSTR frameType = NULL;
    PCTSTR netTrans = NULL;

    CLEARBUFFER();

    netTrans = pGetNetTransBinding (g_CurrentAdapter, S_NWLINK);
    if (netTrans) {
        frameType = pGetRegistryValue(netTrans, S_FRAME_TYPE);
    }

    //
    // We must map the win9x frame type onto the compatible NT frame type.
    //
    if (frameType) {

        g_TempBuffer[1] = 0;

        switch(*frameType) {

        case TEXT('0'):
            *g_TempBuffer = TEXT('1'); // 802.3
            break;
        case TEXT('1'):
            *g_TempBuffer = TEXT('2'); // 802.2
            break;
        case TEXT('2'):
            *g_TempBuffer = TEXT('0'); // ETHERNET II
            break;
        case TEXT('3'):
            *g_TempBuffer = TEXT('3'); // ETHERNET SNAP
            break;
        default:
            //
            // If we find anything else, we'll just set it to AUTODETECT.
            //
            StringCopy(g_TempBuffer,TEXT("FF"));

            //
            // Lets log this to setupact.log.
            //
            LOG ((LOG_WARNING, (PCTSTR) MSG_AUTODETECT_FRAMETYPE));
        }
    }
    else {
        return NULL;
    }

    return g_TempBuffer;
}


PCTSTR
pGetIpxNetworkNumber (
    VOID
    )
{
    PCTSTR netTrans = NULL;
    CLEARBUFFER();

    netTrans = pGetNetTransBinding (g_CurrentAdapter, S_NWLINK);

    if (netTrans) {
        return pGetRegistryValue (netTrans, S_NETWORK_ID);
    }

    return NULL;
}


/*++

Routine Description:

  pGetDNSStatus returns "Yes" If DNS is enabled on the win9xupg machine,
  "No" otherwise.

Arguments:

  None.

Return Value:

  a multisz containing the required data, or NULL if it could not be
  retrieved.

--*/


PCTSTR
pGetDnsStatus (
    VOID
    )
{
    CLEARBUFFER();
    StringCopy(g_TempBuffer,pIsDnsEnabled() ? S_YES : S_NO);

    return g_TempBuffer;
}

/*++

Routine Description:

  pGetScriptProcessingStatus returns "Yes" if logon script processing is enabled,
  "No" otherwise.

Arguments:

  None.

Return Value:

  a multisz containing the required data, or NULL if it could not be
  retrieved.

--*/


PCTSTR
pGetScriptProcessingStatus (
    VOID
    )
{
    PBYTE p = NULL;
    HKEY  key;

    CLEARBUFFER();
    key = OpenRegKeyStr(S_NETWORKLOGON);

    if (key && key != INVALID_HANDLE_VALUE) {

        p = GetRegValueBinary(key,S_PROCESSLOGINSCRIPT);
        StringCopy(g_TempBuffer,p && *p == 0x01 ? S_YES : S_NO);
        CloseRegKey(key);

    }
    else {
        DEBUGMSG((DBG_WARNING,"pGetScriptProcessingStatus could not open key %s.",S_NETWORKLOGON));
        StringCopy(g_TempBuffer,S_NO);
    }

    if (p) {

        MemFree(g_hHeap,0,p);
    }

    return g_TempBuffer;
}

/*++

Routine Description:

  pGetIpAddress returns the IP Address of the win9xupg machine being upgraded,
  if it exists.

Arguments:

  None.

Return Value:

  a multisz containing the required data, or NULL if it could not be
  retrieved.

--*/


PCTSTR
pGetIpAddress (
    VOID
    )
{
    PTSTR p;
    PCTSTR netTrans;
    CLEARBUFFER();


    netTrans = pGetNetTransBinding (g_CurrentAdapter, S_MSTCP);

    if (!netTrans || !pGetRegistryValue(netTrans, S_IPADDRVAL)) {
        return NULL;
    }
    else {
        p = g_TempBuffer;
        while (p && *p) {
            p = _tcschr(p,TEXT(','));
            if (p) {
                *p = 0;
                p = _tcsinc(p);
            }
        }
    }

    return g_TempBuffer;

}

/*++

Routine Description:

  pGetDHCPStatus returns "Yes" if DHCP is enabled, "No" otherwise.

Arguments:

  None.

Return Value:

  a multisz containing the required data, or NULL if it could not be
  retrieved.

--*/


PCTSTR
pGetDhcpStatus (
    VOID
    )
{
    BOOL rStatus = !pHasStaticIpAddress();

    CLEARBUFFER();
    StringCopy(g_TempBuffer,rStatus ? S_YES : S_NO);

    return g_TempBuffer;
}

/*++

Routine Description:

  pGetSubnetMask returns the subnet mask in dotted decimal notation for the
  machine being upgraded.

Arguments:

  None.

Return Value:

  a multisz containing the required data, or NULL if it could not be
  retrieved.

--*/



PCTSTR
pGetSubnetMask (
    VOID
    )
{

    PTSTR p;
    PCTSTR netTrans =  NULL;
    CLEARBUFFER();

    netTrans = pGetNetTransBinding (g_CurrentAdapter, S_MSTCP);
    if (!netTrans || !pGetRegistryValue (netTrans, S_SUBNETVAL)) {
        return NULL;
    }
    else {
        p = g_TempBuffer;
        while (p && *p) {
            p = _tcschr(p,TEXT(','));
            if (p) {
                *p = 0;
                p = _tcsinc(p);
            }
        }
    }

    return g_TempBuffer;
}

/*++

Routine Description:

  pGetGateway returns the gateway(s) in dotted decimal notation for the
  machine being upgraded. If the machine doesn't have a static IP address,
  the Gateway settings are NOT migrated.

Arguments:

  None.

Return Value:

  a multisz containing the required data, or NULL if it could not be
  retrieved.

--*/


PCTSTR
pGetGateway (
    VOID
    )
{

    PTSTR p;
    PCTSTR netTrans = NULL;
    CLEARBUFFER();


    if (!pHasStaticIpAddress()) {
        return NULL;
    }

    netTrans = pGetNetTransBinding (g_CurrentAdapter, S_MSTCP);
    if (!netTrans || !pGetRegistryValue (netTrans, S_DEFGATEWAYVAL)) {
        return NULL;
    }
    else {
        p = g_TempBuffer;
        while (p && *p) {
            p = _tcschr(p,TEXT(','));
            if (p) {
                *p = 0;
                p = _tcsinc(p);
            }
        }
    }

    return g_TempBuffer;

}

PCTSTR
pGetDnsSuffixSearchOrder (
    VOID
    )
{
    PTSTR p;
    CLEARBUFFER();

    if (!pGetRegistryValue(S_MSTCP_KEY,S_SEARCHLIST)) {
        return NULL;
    }
    else {
        p = g_TempBuffer;
        while (p && *p) {
            p = _tcschr(p,TEXT(','));
            if (p) {
                *p = 0;
                p = _tcsinc(p);
            }
        }
    }

    return g_TempBuffer;
}


PCTSTR
pGetDnsServerSearchOrder (
    VOID
    )
{

    PTSTR p;
    CLEARBUFFER();


    if (!pGetRegistryValue(S_MSTCP_KEY,S_NAMESERVERVAL)) {
        return NULL;
    }
    else {
        p = g_TempBuffer;
        while (p && *p) {
            p = _tcschr(p,TEXT(','));
            if (p) {
                *p = 0;
                p = _tcsinc(p);
            }
        }
    }

    return g_TempBuffer;




}


/*++

Routine Description:

  pGetWinsStatus returns "Yes" if WINS servers are enabled, "No" otehrwise.

Arguments:

  None.

Return Value:

  a multisz containing the required data, or NULL if it could not be
  retrieved.

--*/


PCTSTR
pGetWinsStatus (
    VOID
    )
{
    PCTSTR status;
    PCTSTR netTrans = NULL;

    netTrans = pGetNetTransBinding (g_CurrentAdapter, S_MSTCP);

    if (!netTrans) {
        status = S_NO;
    }
    else {

        status =
            (!pGetRegistryValue (netTrans, S_NODEVAL) &&
             !pGetRegistryValue (S_MSTCP_KEY, S_NODEVAL))
             ? S_NO : S_YES;
    }

    CLEARBUFFER();
    StringCopy(g_TempBuffer,status);

    return g_TempBuffer;

}


/*++

Routine Description:

  pGetWinsServers returns the primary and secondary wins servers in dotted decimal
  notation for the machine being upgraded.

Arguments:

  None.

Return Value:

  a multisz containing the required data, or NULL if it could not be
  retrieved.

--*/


PCTSTR
pGetWinsServers (
    VOID
    )
{
    TCHAR winsServer2[MEMDB_MAX] = {""};
    TCHAR netTrans[MAX_PATH];
    PTSTR p;
    PCTSTR q;
    CLEARBUFFER ();

    q = pGetNetTransBinding (g_CurrentAdapter, S_MSTCP);
    if (!q) {
        return NULL;
    }

    StringCopy (netTrans, q);

    if (pGetRegistryValue (netTrans, S_NAMESERVER2VAL)) {
        StringCopy (winsServer2, g_TempBuffer);
    } else if (pGetRegistryValue (S_MSTCP_KEY, S_NAMESERVER2VAL)) {
        StringCopy (winsServer2, g_TempBuffer);
    }

    if (pGetRegistryValue (netTrans, S_NAMESERVER1VAL) ||
        pGetRegistryValue(S_MSTCP_KEY, S_NAMESERVER1VAL)) {

        p = GetEndOfString (g_TempBuffer) + 1;
        StringCopy (p, winsServer2);

        return g_TempBuffer;
    }


    return NULL;
}

/*++

Routine Description:

  pGetRasPorts returns a multisz containing all of the ras ports for the
  machine being upgraded.

Arguments:

  None.

Return Value:

  a multisz containing the required data, or NULL if it could not be
  retrieved.

--*/

PCTSTR
pGetRasPorts (
    VOID
    )
{
    REGKEY_ENUM e;
    PTSTR       p;
    UINT        modemNum = 1;

    CLEARBUFFER();

    if (EnumFirstRegKeyStr(&e,S_MODEMS)) {

        p = g_TempBuffer;
        do {

            wsprintf(p,TEXT("COM%u"),modemNum);
            modemNum++;
            p = GetEndOfString (p) + 1;

        } while (EnumNextRegKey(&e));
    }
    else {
        //
        // Apparently no modems.. Just return NULL.
        //
        return NULL;
    }

    return g_TempBuffer;
}

/*++

Routine Description:

  pRasPortName returns the current ras port name for the ras section
  currently being processed.

Arguments:

  None.

Return Value:

  a multisz containing the required data, or NULL if it could not be
  retrieved.

--*/


PCTSTR
pRasPortName (
    VOID
    )
{
    CLEARBUFFER();
    StringCopy(g_TempBuffer,g_CurrentSection);
    return g_TempBuffer;
}


/*++

Routine Description:

  pGetLanguageGroups returns the list of language groups to be installed
  during GUI mode setup. Note that any additional directories will have
  been communicated to Setup as optional directories earlier.

Arguments:

  None.

Return Value:

  a multisz containing the required data, or NULL if it could not be
  retrieved.

--*/


PCTSTR
pGetLanguageGroups (
    VOID
    )
{

    HASHTABLE_ENUM e;
    PTSTR p;

    if (!g_LocaleTable) {
        DEBUGMSG ((DBG_WARNING, "No information in Locale Hash Table."));
        return NULL;
    }

    CLEARBUFFER();
    p = g_TempBuffer;

    if (EnumFirstHashTableString (&e, g_LocaleTable)) {
        do {

            StringCopy (p, e.String);
            p = GetEndOfString (p) + 1;

        } while (EnumNextHashTableString (&e));
    }

    return g_TempBuffer;
}


#if 0

BOOL
pFileVersionLesser (
    IN      PCTSTR FileName,
    IN      DWORD FileVerMS,
    IN      DWORD FileVerLS
    )
{
    DWORD dwLength, dwTemp;
    UINT DataLength;
    PVOID lpData;
    VS_FIXEDFILEINFO *VsInfo;
    BOOL b = TRUE;

    if(dwLength = GetFileVersionInfoSize ((PTSTR)FileName, &dwTemp)) {
        lpData = PoolMemGetMemory (g_GlobalPool, dwLength);
        if(GetFileVersionInfo((PTSTR)FileName, 0, dwLength, lpData)) {
            if (VerQueryValue(lpData, TEXT("\\"), &VsInfo, &DataLength)) {
                b = VsInfo->dwFileVersionMS < FileVerMS ||
                    (VsInfo->dwFileVersionMS == FileVerMS &&
                     VsInfo->dwFileVersionLS <= FileVerLS);
            }
        }
        PoolMemReleaseMemory (g_GlobalPool, lpData);
    }
    return b;
}

BOOL
pNewerW95upgntOnCD (
    IN      PCTSTR ReplacementDll
    )
{
    DWORD dwLength, dwTemp;
    PVOID lpData = NULL;
    VS_FIXEDFILEINFO *VsInfo;
    UINT DataLength;
    DWORD result;
    UINT u;
    PCTSTR pathCDdllSource = NULL;
    PCTSTR pathCDdllTarget = NULL;
    DWORD FileVerMS;
    DWORD FileVerLS;
    BOOL b = TRUE;

    __try {

        for (u = 0; u < SOURCEDIRECTORYCOUNT(); u++) {
            pathCDdllSource = JoinPaths (SOURCEDIRECTORY(u), WINNT_WIN95UPG_NTKEY);
            if (DoesFileExist (pathCDdllSource)) {
                break;
            }
            FreePathString (pathCDdllSource);
            pathCDdllSource = NULL;
        }
        if (!pathCDdllSource) {
            __leave;
        }

        pathCDdllTarget = JoinPaths (g_TempDir, WINNT_WIN95UPG_NTKEY);
        SetFileAttributes (pathCDdllTarget, FILE_ATTRIBUTE_NORMAL);
        DeleteFile (pathCDdllTarget);

        result = SetupDecompressOrCopyFile (pathCDdllSource, pathCDdllTarget, 0);
        if (result != ERROR_SUCCESS) {
            LOG ((
                LOG_ERROR,
                "pGetW95UpgNTCDFileVersion: Unable to decompress %s",
                pathCDdllSource
                ));
            __leave;
        }

        if (dwLength = GetFileVersionInfoSize ((PTSTR)pathCDdllTarget, &dwTemp)) {
            lpData = PoolMemGetMemory (g_GlobalPool, dwLength);
            if (GetFileVersionInfo ((PTSTR)pathCDdllTarget, 0, dwLength, lpData)) {
                if (VerQueryValue (lpData, TEXT("\\"), &VsInfo, &DataLength)) {
                    b = pFileVersionLesser (
                            ReplacementDll,
                            VsInfo->dwFileVersionMS,
                            VsInfo->dwFileVersionLS
                            );
                }
            }
        }
    }
    __finally {
        if (lpData) {
            PoolMemReleaseMemory (g_GlobalPool, lpData);
        }
        if (pathCDdllSource) {
            FreePathString (pathCDdllSource);
        }
        if (pathCDdllTarget) {
            SetFileAttributes (pathCDdllTarget, FILE_ATTRIBUTE_NORMAL);
            DeleteFile (pathCDdllTarget);
            FreePathString (pathCDdllTarget);
        }
    }

    return b;
}

/*++

Routine Description:

  pGetReplacementDll is responsible for scanning the registry for an NT side
  win9x replacement dll and putting it into the answer file if found.

Arguments:

  None.

Return Value:

  a multisz containing the required data, or NULL if it could not be
  found.


--*/


PCTSTR
pGetReplacementDll (
    VOID
    )
{
    HKEY key = NULL;
    PTSTR val = NULL;
    BOOL b = FALSE;

    key = OpenRegKey (HKEY_LOCAL_MACHINE, WINNT_WIN95UPG_REPLACEMENT);

    if (!key) {
        return NULL;
    }

    __try {

        val = GetRegValueString (key, WINNT_WIN95UPG_NTKEY);
        if (!val) {
            __leave;
        }

        if (pNewerW95upgntOnCD (val)) {
            __leave;
        }

        CLEARBUFFER();
        StringCopy (g_TempBuffer, val);

        b = TRUE;

    } __finally {
        CloseRegKey (key);
        if (val) {
            MemFree (g_hHeap, 0, val);
        }
    }

    return b ? g_TempBuffer : NULL;
}

#endif


VOID
pGenerateRandomPassword (
    OUT     PTSTR Password
    )

/*++

Routine Description:

  pGenerateRandomPassword creates a password of upper-case, lower-case and
  numeric letters.  The password has a length between 8 and 14
  characters.

Arguments:

  Password - Receives the generated password

Return Value:

  none

--*/

{
    INT Length;
    TCHAR Offset;
    INT Limit;
    PTSTR p;

    //
    // Generate a random length based on the tick count
    //

    srand (GetTickCount());

    Length = (rand() % 6) + 8;

    p = Password;
    while (Length) {
        Limit = rand() % 3;
        Offset = TEXT(' ');

        if (Limit == 0) {
            Limit = 10;
            Offset = TEXT('0');
        } else if (Limit == 1) {
            Limit = 26;
            Offset = TEXT('a');
        } else if (Limit == 2) {
            Limit = 26;
            Offset = TEXT('A');
        }

        *p = Offset + (rand() % Limit);
        p++;

        Length--;
    }

    *p = 0;

    DEBUGMSG ((DBG_WINNTSIF, "Generated password: %s", Password));
}


PCTSTR
pSetAdminPassword (
    VOID
    )

/*++

Routine Description:

  pSetAdminPassword retrieves the AdminPassword as specified in the unattend file, if present.
  Otherwise it generates a random one.
  This information is stored in memdb to be available later.

Arguments:

  None.

Return Value:

  A pointer to the admin password.

--*/

{
    BOOL attribs = 0;
    TCHAR node[MEMDB_MAX];
    BOOL blank = FALSE;

    if (!g_UnattendScriptFile ||
        !*g_UnattendScriptFile ||
        !GetPrivateProfileString (
            S_GUIUNATTENDED,
            WINNT_US_ADMINPASS,
            TEXT(""),
            g_TempBuffer,
            MEMDB_MAX,
            *g_UnattendScriptFile
            )
        ) {

        if (g_PersonalSKU) {
            //
            // for Personal set an empty admin password
            //
            StringCopy (g_TempBuffer, TEXT("*"));
        } else {
            pGenerateRandomPassword (g_TempBuffer);
            attribs = PASSWORD_ATTR_RANDOM;
        }

    } else {
        if (GetPrivateProfileString (
                S_GUIUNATTENDED,
                WINNT_US_ENCRYPTEDADMINPASS,
                TEXT(""),
                node,
                MEMDB_MAX,
                *g_UnattendScriptFile
                )) {
            if (StringIMatch (node, S_YES) || StringIMatch (node, TEXT("1"))) {
                attribs = PASSWORD_ATTR_ENCRYPTED;
            }
        }
    }

    if (StringMatch (g_TempBuffer, TEXT("*"))) {
        blank = TRUE;
        *g_TempBuffer = 0;
    }
    MemDbBuildKey (node, MEMDB_CATEGORY_STATE, MEMDB_ITEM_ADMIN_PASSWORD, g_TempBuffer, NULL);
    MemDbSetValue (node, attribs);
    if (blank) {
        wsprintf (g_TempBuffer, TEXT("*%c"), 0);
    }

    return g_TempBuffer;
}


//ICS upgrade functions

/*++

Routine Description:

  pGetNetAdapterSectionNameBasedOnDriverID retrieves the net adapter name (for example, "Adapter1") based on the ID of
  the driver of this adapter. For example, "0001" is the ID for the driver under
  HKLM\System\CurrentControlSet\Services\Class\Net\0001.

Arguments:

  String of the driver ID

Return Value:

  A pointer to the adapter name

--*/
PCTSTR
pGetNetAdapterSectionNameBasedOnDriverID(
    PCTSTR pszDriverID
    )
{
    TCHAR szID[256];
    PCTSTR rAdapterSections = NULL;
    PTSTR  string = g_TempBuffer;
    PCSTR pReturn = NULL;
    MEMDB_ENUM e;


    //first cache the string for the driver ID
    lstrcpyn(szID, pszDriverID, sizeof(szID)/sizeof(szID[0]));

    *string = 0;

    //
    // Enumerate all adapters, and create an entry for each adapter that has
    // TCP bindings.
    //

    if (pEnumFirstAdapterByBinding(&e, S_MSTCP)) {

        do {

            //
            // check whether the driver ID of the card
            //

            MemDbGetEndpointValueEx(
                MEMDB_CATEGORY_NETADAPTERS,
                e.szName,
                MEMDB_FIELD_DRIVER,
                g_TempBuffer
                );

            string = _tcsstr(g_TempBuffer, S_NET_PREFIX);
            if (string)
            {
                string += TcharCount(S_NET_PREFIX);
                if (0 == StringICompare(string, szID))
                {
                    pReturn = e.szName;
                    break;
                }
            }

        } while (pEnumNextAdapterByBinding(&e,S_MSTCP));
    }

    return pReturn;
}

/*++

Routine Description:

  pHomenetSection is used to control whether the "ICSharing" section should show up in the
  answer file or not.

  If the ICS (Internet Connection Sharing) is installed, then we return "ICSharing" string for
  the first time of this call, otherwise always return NULL. In such way, we can ensure the
  "ICSharing" section will show up in the answer file ONLY when ICS is installed.

Arguments:

  None

Return Value:

  A pointer to "ICSharing" string if ICS is installed.
  Otherwise, return NULL.

--*/
PCTSTR
pHomenetSection(
    VOID
    )
{
    static BOOL firstTime = TRUE;

    PCTSTR pReturn = NULL;

    if (firstTime && NULL != pGetRegistryValue (S_ICS_KEY, S_EXTERNAL_ADAPTER))
    {
        firstTime = FALSE;
        StringCopy(g_CurrentSection, S_HOMENET);
        pReturn = g_CurrentSection;
    }

    return pReturn;
}

/*++

Routine Description:

  pExternalIsAdapter detects whether the External connection of ICS is a LAN connection

--*/
BOOL
pExternalIsAdapter(
    void
    )
{
    BOOL fRet = FALSE;
    if (NULL == pGetRegistryValue (S_ICS_KEY, S_EXTERNAL_ADAPTER))
    {
        return FALSE;
    }

    return (NULL != pGetNetAdapterSectionNameBasedOnDriverID(g_TempBuffer));

    return fRet;
}

/*++

Routine Description:

  pExternalIsRasConn detects whether the External connection of ICS is a RAS connection

--*/
BOOL
pExternalIsRasConn(
    void
    )
{
    if (NULL == pGetRegistryValue (S_ICS_KEY, S_EXTERNAL_ADAPTER))
    {
        return FALSE;
    }

    return NULL == pGetNetAdapterSectionNameBasedOnDriverID(g_TempBuffer);
}

/*++

Routine Description:

  pHasInternalAdapter detects whether the first Internal Adapter is specified for ICS

--*/
BOOL
pHasInternalAdapter(
    void
    )
{
    //To have the "InternalAdapter" key, two conditions have to be statisfy:
    //(1) there is "InternalAdapter"   AND
    //(2) this is the only internal adapter, i.e. internal is NOT bridge
    return (NULL != pGetRegistryValue (S_ICS_KEY, S_INTERNAL_ADAPTER) &&
            (!g_fIcsInternalIsBridge));
}

/*++

Routine Description:

  pHasBridge detects whether there are two ICS Internal Adapters. If so, we
  need to bridge those two adapter together

--*/
pHasBridge(
    void
    )
{
    return g_fIcsInternalIsBridge;
}

/*++

Routine Description:

  pIcsExternalAdapter retrieves the adapter name (for example, "Adapter1")
  for external ICS connection

--*/
PCTSTR
pIcsExternalAdapter (
    VOID
    )
{
    PCSTR pszAdapter;

    if (NULL == pGetRegistryValue(S_ICS_KEY, S_EXTERNAL_ADAPTER))
        return NULL;

    pszAdapter = pGetNetAdapterSectionNameBasedOnDriverID(g_TempBuffer);

    if (NULL == pszAdapter)
    {
        return NULL;
    }

    //ICSHARE adapter's TCP setting overwrite the TCP setting of the external adapter
    //We remember all the info here and will use it when saving the TCP setting of this adapter
    if (0 != lstrlen(g_IcsAdapter))
    {
        //this flag will be used to upgrade the TCP/IP settings of the ICSHARE adapter
        g_fHasIcsExternalAdapter = TRUE;
        lstrcpyn(g_IcsExternalAdapter,
                pszAdapter,
                sizeof(g_IcsExternalAdapter)/sizeof(g_IcsExternalAdapter[0]));
    }

    CLEARBUFFER();
    StringCopy(g_TempBuffer, pszAdapter);
    return g_TempBuffer;
}

/*++

Routine Description:

  pIcsExternalConnectionName retrieves the name (for example, "My Dial-up Connection")
  for external ICS RAS connection

--*/
PCSTR
pIcsExternalConnectionName (
    VOID
    )
{
    TCHAR szKey[MEMDB_MAX * 2]; // Contains the current value returned from pGetRegistryValue
    PCSTR pReturn = NULL;

    if (NULL == pGetRegistryValue(S_ICS_KEY, S_EXTERNAL_ADAPTER))
    {
        return NULL;
    }

    StringCopy(szKey, S_NET_DRIVER_KEY);
    StringCat(szKey, _T("\\"));
    StringCat(szKey, g_TempBuffer);

    //The "DriverDesc" value has to be "Dial-Up Adapter"
    if (NULL == pGetRegistryValue(szKey, S_DRIVERDESC) && 0 != StringCompare(g_TempBuffer, S_DIALUP_ADAPTER_DESC))
    {
        return NULL;
    }

    //the default ras connection should be the external one. The reg location of the connection name is at
    //HKCU\RemoteAccess\Default
    return pGetRegistryValue(S_REMOTEACCESS_KEY, S_RAS_DEFAULT);
}

/*++

Routine Description:

  pInternalIsBridge detects whether there are two ICS Internal Adapters. If so, we
  need to bridge those two adapter together

--*/
PCSTR
pInternalIsBridge(
    VOID
    )
{
    g_fIcsInternalIsBridge = (NULL != pGetRegistryValue (S_ICS_KEY, S_INTERNAL_ADAPTER) &&
                    NULL != pGetRegistryValue (S_ICS_KEY, S_INTERNAL_ADAPTER2));
    
    CLEARBUFFER();
    StringCopy(g_TempBuffer, (g_fIcsInternalIsBridge) ? S_YES : S_NO);

    return g_TempBuffer;
}

/*++

Routine Description:

  pInternalAdapter retrieves the adapter name (for example, "Adapter1") for first internal ICS connection
  NOTE: internal connections has to be LAN conncections

--*/
PCSTR
pInternalAdapter(
    VOID
    )
{
    PCSTR pszAdapter;

    if (NULL == pGetRegistryValue(S_ICS_KEY, S_INTERNAL_ADAPTER))
    {
        return NULL;
    }

    pszAdapter = pGetNetAdapterSectionNameBasedOnDriverID(g_TempBuffer);
    if (NULL == pszAdapter)
    {
        return NULL;
    }

    CLEARBUFFER();
    StringCopy(g_TempBuffer, pszAdapter);
    return g_TempBuffer;
}

/*++

Routine Description:

  pBridge retrieves name the two internal adapter names (for example, "Adapter2")

--*/
PCSTR
pBridge(
    VOID
    )
{

    TCHAR szBuff[MEMDB_MAX] = {0};
    TCHAR * psz = szBuff;
    PCSTR pszAdapter;

    if (NULL == pGetRegistryValue(S_ICS_KEY, S_INTERNAL_ADAPTER))
    {
        return NULL;
    }
    
    pszAdapter = pGetNetAdapterSectionNameBasedOnDriverID(g_TempBuffer);
    if (NULL == pszAdapter)
    {
        return NULL;
    }

    StringCopy(psz, pszAdapter);
    psz = GetEndOfString(szBuff) + 1;

    if (NULL == pGetRegistryValue(S_ICS_KEY, S_INTERNAL_ADAPTER2))
    {
        return NULL;
    }

    pszAdapter = pGetNetAdapterSectionNameBasedOnDriverID(g_TempBuffer);
    if (NULL == pszAdapter)
    {
        return NULL;
    }

    StringCopy(psz, pszAdapter);
    psz = GetEndOfString(psz) + 1;
    *psz = 0;

    CLEARBUFFER();
    memcpy(g_TempBuffer, szBuff, 
        sizeof(szBuff) < sizeof(g_TempBuffer) ? sizeof(szBuff) : sizeof(g_TempBuffer));
    
    return g_TempBuffer;
}

/*++

Routine Description:

  pDialOnDemand retrieves the dial-on-demand feature
  for ICS connection

--*/
PCSTR
pDialOnDemand(
    VOID
    )
{
    PCTSTR          KeyString = S_INET_SETTINGS;
    PCTSTR          ValueString = S_ENABLE_AUTODIAL;
    PCTSTR          rString  = NULL;
    HKEY            key      = NULL;
    PBYTE           data     = NULL;
    DWORD           type     = REG_NONE;
    DWORD           BufferSize = 0;
    LONG            rc       = ERROR_SUCCESS;
    PCTSTR          end;


    //
    //
    // Open registry key.
    //
    key = OpenRegKeyStr(KeyString);

    if (!key) {
        DEBUGMSG((DBG_WINNTSIF, "Key %s does not exist.",KeyString));
        return NULL;
    }

    //
    // Get type of data
    //
    rc = RegQueryValueExA (key, ValueString, NULL, &type, NULL, &BufferSize);
    if (rc != ERROR_SUCCESS) {
        DEBUGMSG((DBG_WINNTSIF,"RegQueryValueEx failed for %s[%s]. Value may not exist.",KeyString,ValueString));
        CloseRegKey(key);
        SetLastError (rc);
        return NULL;
    }

    if (0 == BufferSize ||
        (REG_DWORD != type && REG_BINARY != type))
    {
        DEBUGMSG((DBG_WINNTSIF,"EnableAutoDial is not a DWORD, nor a Binary."));
        CloseRegKey(key);
        return NULL;
    }

    if (REG_BINARY == type && sizeof(DWORD) != BufferSize)
    {
        DEBUGMSG((DBG_WINNTSIF,"EnableAutoDial is a binary, but the buffer size is not 4."));
        CloseRegKey(key);
        return NULL;
    }

    data = (PBYTE) MemAlloc (g_hHeap, 0, BufferSize);
    if (NULL == data)
    {
        DEBUGMSG((DBG_WINNTSIF,"Alloc failed. Out of memory."));
        CloseRegKey(key);
        return NULL;
    }

    rc = RegQueryValueExA (key, ValueString, NULL, NULL, data, &BufferSize);
    if (rc != ERROR_SUCCESS) {
        DEBUGMSG((DBG_WINNTSIF,"RegQueryValueEx failed for %s[%s]. Value may not exist.",KeyString,ValueString));
        MemFree(g_hHeap, 0, data);
        data = NULL;
        CloseRegKey(key);
        SetLastError (rc);
        return NULL;
    }


    CLEARBUFFER();

    wsprintf(g_TempBuffer,"%u",*((DWORD*) data));

    //
    // Clean up resources.
    //
    CloseRegKey(key);
    if (data) {
        MemFree(g_hHeap, 0, data);
        data = NULL;
    }


    return g_TempBuffer;
}


//
// Processing functions
//

//
// g_SectionList contains the list of all winntsif sections that will be enumerated and processed by BuildWinntSifFile.
//
SECTION g_SectionList[] = {WINNTSIF_SECTIONS /*,*/ {NULL,NULL,{{LAST_SETTING,NULL,NULL,{NULL,NULL}}}}};




/*++

Routine Description:

  pProcessSectionSettings is responsible for processing a single section
  worth of data. For this section, it will process all of the settings in the
  settinglist passed in.

Arguments:

  SectionName  - The name of the section being processed.
  SettingsList - a list of settings to be processed for this sections.

Return Value:



--*/


BOOL
pProcessSectionSettings (
    IN PCTSTR       SectionName,
    IN PSETTING     SettingsList
    )
{

    PSETTING            curSetting = SettingsList;
    PTSTR               data       = NULL;
    PTSTR               p;
    MULTISZ_ENUM        e;
    UINT                index      = 0;
    TCHAR               key[MEMDB_MAX];


    MYASSERT(curSetting);
    MYASSERT(SectionName);

    DEBUGMSG((DBG_WINNTSIF,"pProcessSectionSettings: Processing [%s] Section...",SectionName));

    //
    // The last setting in the list is a null setting with the type LAST_SETTING. We use this as the
    // break condition of our loop.
    //
    while (curSetting -> SettingType != LAST_SETTING) {

        if (!curSetting -> CreationFunction || curSetting -> CreationFunction()) {

            //
            // Any setting that gets to this point MUST have a  key name.
            // Since this data is static, we just assert this.
            //
            MYASSERT(curSetting  -> KeyName);

            //
            // We must still get the data for this particular setting. How we get that data is determined by
            // the SettingType of the current setting. If at the end, data is NULL, we will write nothing.
            //
            switch (curSetting -> SettingType) {

            case FUNCTION_SETTING:

                data = (PTSTR) curSetting -> Data.Function();
                break;

            case STRING_SETTING:

                StringCopy(g_TempBuffer,curSetting -> Data.String);
                p = GetEndOfString (g_TempBuffer) + 1;
                *p = 0;
                data = g_TempBuffer;
                break;

            case REGISTRY_SETTING:
                data = (PTSTR) pGetRegistryValue(curSetting -> Data.Registry.Key, curSetting -> Data.Registry.Value);
                break;

            default:
                DEBUGMSG((
                    DBG_WHOOPS,
                    "pProcessSectionSettings: Unexpected Setting Type for Section %s, Key %s. (Type: %u)",
                    SectionName,
                    curSetting -> KeyName,
                    curSetting -> SettingType
                    ));
                break;
            }

            //
            // If we found data, go ahead and create the setting. All data is stored in multi strings, typically only one string long.
            //
            if (data) {

                //
                // Make sure this isn't suppressed.
                //
                MemDbBuildKey (
                    key,
                    MEMDB_CATEGORY_SUPPRESS_ANSWER_FILE_SETTINGS,
                    SectionName,
                    curSetting->KeyName,
                    NULL
                    );


                if (MemDbGetPatternValue (key, NULL)) {

                    DEBUGMSG ((DBG_WINNTSIF, "Answer File Section is suppressed: [%s] %s", SectionName, curSetting->KeyName));
                }
                else {

                    DEBUGMSG((DBG_WINNTSIF,"Creating WinntSif Entry: Section: %s, Key: %s.",SectionName, curSetting -> KeyName));



                    if (EnumFirstMultiSz(&e,data)) {
                        index = 0;
                        do {

                            index = WriteInfKeyEx(SectionName, curSetting -> KeyName, e.CurrentString, index, FALSE);
                            DEBUGMSG_IF((
                                !index,
                                DBG_ERROR,
                                "pProcessSectionSettings: WriteInfKeyEx Failed. Section: %s Key: %s Value: %s",
                                SectionName,
                                curSetting -> KeyName,
                                e.CurrentString
                                ));
                            DEBUGMSG_IF((index,DBG_WINNTSIF,"Value: %s",e.CurrentString));

                        } while (EnumNextMultiSz(&e));
                    }
                }
            }
            ELSE_DEBUGMSG((DBG_WARNING,"pProcessSectionSettings: No data for Section %s, Key %s.",SectionName, curSetting -> KeyName));
        }

        curSetting++;
    }

    return TRUE;
}

/*++

Routine Description:

  BuildWinntSifFile is responsible for writing all of the necessary unattend
  settings to the winnt.sif file. The Win9xUpg code uses these unattended
  settings to control the behavior of text mode and GUI mode setup so that
  the settings gathered from win9x are incorporated into the new NT
  system.

The settings to be written are kept in the global list g_SettingL
  ist which is itself built from macro expansion lists. This function cycles
  through these settings, calculating wether each setting should be written
  and if so, with what data.

Arguments:

  None.

Return Value:

  TRUE if the function returned successfully, FALSE otherwise.

--*/


BOOL
pBuildWinntSifFile (
    VOID
    )
{
    BOOL            rSuccess    = TRUE;
    PSECTION        curSection  = g_SectionList;
    PCTSTR          sectionName = NULL;

    while (curSection -> SectionString || curSection -> SectionFunction) {


        sectionName = curSection -> SectionString ? curSection -> SectionString : curSection -> SectionFunction();

        while (sectionName) {

            if (!pProcessSectionSettings (sectionName,curSection -> SettingList)) {
                LOG ((LOG_ERROR,"Unable to process answer file settings for %s Section.",sectionName));
                rSuccess = FALSE;
            }

            //
            // If the section name was from a static string, we set the sectionName to NULL, exiting this loop.
            // If the section name was from a function, we call the function again. If there is another
            // section to build, it will return a new name, otherwise, it will return NULL.
            //
            sectionName = curSection -> SectionString ? NULL : curSection -> SectionFunction();
        }

        //
        // Go to the next setting.
        //
        curSection++;
    }
    return rSuccess;
}




DWORD
BuildWinntSifFile (
    DWORD Request
    )
{
    switch (Request) {
    case REQUEST_QUERYTICKS:
        return TICKS_BUILD_UNATTEND;
    case REQUEST_RUN:
        if (!pBuildWinntSifFile ()) {
            return GetLastError ();
        }
        else {
            return ERROR_SUCCESS;
        }
    default:
        DEBUGMSG ((DBG_ERROR, "Bad parameter in BuildWinntSif"));
    }
    return 0;
}


VOID
TerminateWinntSifBuilder (
    VOID
    )
{
    if (g_LocalePool) {
        HtFree (g_LocaleTable);
        PoolMemDestroyPool (g_LocalePool);

        g_LocaleTable = NULL;
        g_LocalePool = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\initnt\initnt.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

  initnt.c

Abstract:

  Code that performs initialization for the NT side of migration, and
  also implements workers that syssetup.dll calls.

Author:

  Jim Schmidt (jimschm) 01-Oct-1996

Revision History:

  jimschm   23-Sep-1998 New commonnt lib
  jimschm   31-Dec-1997 Moved here from w95upgnt\dll
  jimschm   21-Nov-1997 Updated for NEC98, some cleaned up and
                        code commenting

--*/

#include "pch.h"

#ifndef UNICODE
#error UNICODE required
#endif

//
// Local prototypes
//

BOOL pReadUserOptions (VOID);
VOID pReadStringMap (VOID);


// Things set by FirstInitRoutine
HANDLE g_hHeap;
HINSTANCE g_hInst;
TCHAR g_DllDir[MAX_TCHAR_PATH];
TCHAR g_WinDir[MAX_TCHAR_PATH];
TCHAR g_WinDrive[MAX_TCHAR_PATH];
TCHAR g_SystemDir[MAX_TCHAR_PATH];
TCHAR g_System32Dir[MAX_TCHAR_PATH];
TCHAR g_ProgramFiles[MAX_TCHAR_PATH];
TCHAR g_ProgramFilesCommon[MAX_TCHAR_PATH];
TCHAR g_Win95Name[MAX_TCHAR_PATH];        // holds Windows 95, Windows 98, etc...
PCTSTR g_AdministratorStr;
TCHAR g_Win9xBootDrivePath[] = TEXT("C:\\");

// Things set by SysSetupInit
HWND g_ParentWnd;
HWND g_ProgressBar;
HINF g_UnattendInf = INVALID_HANDLE_VALUE;
HINF g_WkstaMigInf = INVALID_HANDLE_VALUE;
HINF g_UserMigInf = INVALID_HANDLE_VALUE;
TCHAR g_TempDir[MAX_TCHAR_PATH];
TCHAR g_OurCopyOfSourceDir[MAX_TCHAR_PATH];
PCTSTR g_SourceDir;

POOLHANDLE g_UserOptionPool = NULL;
PCTSTR     g_MsgYes;
PCTSTR     g_MsgNo;
USEROPTIONS g_ConfigOptions;

PMAPSTRUCT g_StringMap;

//
// Initialization code
//


static int g_LibCount = 0;

typedef BOOL (WINAPI INITROUTINE_PROTOTYPE)(HINSTANCE, DWORD, LPVOID);
typedef INITROUTINE_PROTOTYPE * INITROUTINE;


//
// MigUtil_Entry *must* be first
//

#define LIBLIST                         \
    LIBRARY_NAME(MigUtil_Entry)         \
    LIBRARY_NAME(Win95Reg_Entry)        \
    LIBRARY_NAME(MemDb_Entry)           \
    LIBRARY_NAME(FileEnum_Entry)        \
    LIBRARY_NAME(CommonNt_Entry)        \
    LIBRARY_NAME(MigMain_Entry)         \
    LIBRARY_NAME(Merge_Entry)           \
    LIBRARY_NAME(RuleHlpr_Entry)        \
    LIBRARY_NAME(DosMigNt_Entry)        \
    LIBRARY_NAME(Ras_Entry)             \
    LIBRARY_NAME(Tapi_Entry)            \


#define LIBRARY_NAME(x) INITROUTINE_PROTOTYPE x;

LIBLIST

#undef LIBRARY_NAME

#define LIBRARY_NAME(x) x,



static INITROUTINE g_InitRoutine[] = {LIBLIST /*,*/ NULL};


//
// Buffer for persistent strings used for the life of the DLL
//

static PGROWBUFFER g_PersistentStrings;


//
// Implementation
//

BOOL
FirstInitRoutine (
    HINSTANCE hInstance
    )

/*++

Routine Description:

  FirstInitRoutine is the very first function called during the
  initialization of the DLL.  It sets up globals such as the heap
  pointer and instance handle.  This routine must be called before
  any library entry point is called.

Arguments:

  hInstance  - (OS-supplied) instance handle for the DLL

Return Value:

  Returns TRUE if the global variables could be initialized, or FALSE
  if an error occurred.

--*/

{
    PTSTR p;

    //
    // Get the process heap & instance handle
    //
    g_hHeap = HeapCreate (0, 0x20000, 0);
    if (!g_hHeap) {
        LOG ((LOG_ERROR, "Cannot create a private heap."));
        g_hHeap = GetProcessHeap();
    }

    g_hInst = hInstance;

    // No DLL_THREAD_ATTACH or DLL_THREAD_DETECH needed
    DisableThreadLibraryCalls (hInstance);

    // Init common controls
    InitCommonControls();

    // Get DLL path and strip directory
    GetModuleFileName (hInstance, g_DllDir, MAX_TCHAR_PATH);
    p = _tcsrchr (g_DllDir, TEXT('\\'));
    MYASSERT (p);
    *p = 0;

    // Set g_WinDir
    if (!GetWindowsDirectory (g_WinDir, sizeof (g_WinDir) / sizeof (g_WinDir[0]))) {
        return FALSE;
    }

    // Set g_WinDrive
    _tsplitpath (g_WinDir, g_WinDrive, NULL, NULL, NULL);

    // Set g_SystemDir
    wsprintf (g_SystemDir, TEXT("%s\\%s"), g_WinDir, TEXT("system"));

    // Set g_System32Dir
    GetSystemDirectory (g_System32Dir, sizeof (g_System32Dir) / sizeof (g_System32Dir[0]));

    return TRUE;
}


BOOL
InitLibs (
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    )

/*++

Routine Description:

  InitLibs calls all library entry points in the g_InitRoutine array.
  If an entry point fails, all libraries are unloaded in reverse order
  and InitLibs returns FALSE.

Arguments:

  hInstance  - (OS-supplied) instance handle for the DLL
  dwReason   - (OS-supplied) indicates attach or detatch from process or
               thread -- in this case always DLL_PROCESS_ATTACH
  lpReserved - (OS-supplied) unused

Return Value:

  Returns TRUE if all libraries successfully initialized, or FALSE if
  a library could not initialize.  If TRUE is returned, TerminateLibs
  must be called for the DLL_PROCESS_DETACH message.

--*/

{
    if(!pSetupInitializeUtils()) {
        return FALSE;
    }

    SET_RESETLOG();

    //
    // Init each LIB
    //

    for (g_LibCount = 0 ; g_InitRoutine[g_LibCount] ; g_LibCount++) {
        if (!g_InitRoutine[g_LibCount] (hInstance, dwReason, lpReserved)) {
            TerminateLibs (hInstance, DLL_PROCESS_DETACH, lpReserved);
            return FALSE;
        }
    }

    return TRUE;
}


BOOL
FinalInitRoutine (
    VOID
    )

/*++

Routine Description:

  FinalInitRoutine completes all initialization that requires completely
  initialized libraries.

Arguments:

  none

Return Value:

  TRUE if initialization completed successfully, or FALSE if an error occurred.

--*/

{
    PCTSTR TempStr;

    //
    // Load common message strings
    //

    g_PersistentStrings = CreateAllocTable();
    if (!g_PersistentStrings) {
        return FALSE;
    }

    // Get Administrator account name
    g_AdministratorStr = GetStringResourceEx (g_PersistentStrings, MSG_ADMINISTRATOR_ACCOUNT);
    if (!g_AdministratorStr) {
        g_AdministratorStr = S_EMPTY;
    }

    if(ISPC98()){
        //
        // Update the boot drive letter (set by migutil) to the system partition
        //
        g_BootDriveLetterW = g_BootDriveLetterA = (int)g_System32Dir[0];
        *((PSTR) g_BootDrivePathA) = g_BootDriveLetterA;
        *((PWSTR) g_BootDrivePathW) = g_BootDriveLetterW;
    }

    // Set Program Files directory
    TempStr = (PTSTR) GetStringResource (MSG_PROGRAM_FILES_DIR);
    MYASSERT (TempStr);

    StringCopy (g_ProgramFiles, TempStr);
    g_ProgramFiles [0] = g_WinDir [0];
    FreeStringResource (TempStr);

    StringCopy (g_ProgramFilesCommon, g_ProgramFiles);
    StringCat (g_ProgramFilesCommon, TEXT("\\"));
    StringCat (g_ProgramFilesCommon, S_COMMONDIR);

    return TRUE;
}


VOID
FirstCleanupRoutine (
    VOID
    )

/*++

Routine Description:

  FirstCleanupRoutine is called to perform any cleanup that requires
  libraries to still be loaded.

Arguments:

  none

Return Value:

  none

--*/

{
    TCHAR buffer[MEMDB_MAX];

    //
    // Terminate progress bar table
    //

    TerminateProcessingTable();

    //
    // If Win9x Side saved a LOGSAVETO location into memdb, then we need to save the
    // debugnt log to that location.
    //

    MemDbGetEndpointValueEx(MEMDB_CATEGORY_LOGSAVETO,NULL,NULL,buffer);
    AppendWack(buffer);
    StringCat(buffer,TEXT("debugnt.log"));
    CopyFile(TEXT("debugnt.log"),buffer,FALSE);

    //
    // Clean up persistent strings
    //

    if (g_PersistentStrings) {
        DestroyAllocTable (g_PersistentStrings);
    }
}


VOID
TerminateLibs (
    HINSTANCE hInstance,
    DWORD dwReason,
    LPVOID lpReserved
    )

/*++

Routine Description:

  TerminateLibs is called to unload all libraries in the reverse order
  that they were initialized.  Each entry point of successfully
  initialized library is called.

Arguments:

  hInstance  - (OS-supplied) instance handle for the DLL
  dwReason   - (OS-supplied) indicates attach or detatch from process or
               thread -- in this case always DLL_PROCESS_DETACH
  lpReserved - (OS-supplied) unused

Return Value:

  none

--*/

{
    INT i;

    for (i = g_LibCount - 1 ; i >= 0 ; i--) {
        g_InitRoutine[i] (hInstance, dwReason, lpReserved);
    }

    g_LibCount = 0;

    pSetupUninitializeUtils();
}


VOID
FinalCleanupRoutine (
    VOID
    )

/*++

Routine Description:

  FinalCleanupRoutine is after all library entry points have been
  called for cleanup.  This routine cleans up all resources that a
  library will not clean up.

Arguments:

  none

Return Value:

  none

--*/

{
    // Nothing to do now
}


BOOL
pGetInfVal (
    PCTSTR Section,
    PCTSTR Key,
    PTSTR Buffer,
    DWORD BufferSize
    )
{
    INFCONTEXT ic;

    if (!SetupFindFirstLine (g_UnattendInf, Section, Key, &ic))
        return FALSE;

    if (!SetupGetStringField (&ic, 1, Buffer, BufferSize, NULL))
        return FALSE;

    return TRUE;
}

typedef BOOL (OPTIONHANDLERFUN)(PTSTR, PVOID * Option, PTSTR Value);
typedef OPTIONHANDLERFUN * POPTIONHANDLERFUN;

BOOL pHandleBoolOption (PTSTR, PVOID *, PTSTR);
BOOL pHandleIntOption (PTSTR, PVOID *, PTSTR);
BOOL pHandleTriStateOption (PTSTR, PVOID *, PTSTR);
BOOL pHandleMultiSzOption (PTSTR, PVOID *, PTSTR);
BOOL pHandleStringOption (PTSTR, PVOID *, PTSTR);
BOOL pHandleSaveReportTo (PTSTR, PVOID *, PTSTR);
BOOL pHandleBoot16 (PTSTR, PVOID *, PTSTR);
BOOL pGetDefaultPassword (PTSTR, PVOID *, PTSTR);


typedef struct {

    PTSTR OptionName;
    PVOID Option;
    POPTIONHANDLERFUN DefaultHandler;
    POPTIONHANDLERFUN SpecialHandler;
    PVOID Default;

} OPTIONSTRUCT, *POPTIONSTRUCT;

#define INT_MAX_NUMBER_OF_DIGIT    11
PTSTR pGetIntStrForOption(INT Value)
{
    PTSTR strIntDefaultValue = AllocText(INT_MAX_NUMBER_OF_DIGIT + 1);
    if(strIntDefaultValue)
        _itot(Value, strIntDefaultValue, 10);
    return strIntDefaultValue;
}

#define BOOLOPTION(o,h,d) {TEXT(#o), &(g_ConfigOptions.##o), pHandleBoolOption, (h), (PVOID) (BOOL) (d) ? S_YES : S_NO},
#define INTOPTION(o,h,d) {TEXT(#o), &(g_ConfigOptions.##o), pHandleIntOption, (h), (PVOID)(d)},
#define TRISTATEOPTION(o,h,d) {TEXT(#o), &(g_ConfigOptions.##o), pHandleTriStateOption, (h), (PVOID)  (INT) (d == TRISTATE_AUTO)? S_AUTO: (d == TRISTATE_YES)? S_YES  : S_NO},
#define MULTISZOPTION(o,h,d) {TEXT(#o), &(g_ConfigOptions.##o), pHandleMultiSzOption, (h), (PVOID) (d)},
#define STRINGOPTION(o,h,d) {TEXT(#o), &(g_ConfigOptions.##o), pHandleStringOption, (h), (PVOID) (d)},

OPTIONSTRUCT g_OptionsList[] = {OPTION_LIST /*,*/ {NULL,NULL,NULL,NULL}};
PVOID g_OptionsTable = NULL;

#define HANDLEOPTION(Os,Value) {Os->SpecialHandler  ?   \
        Os->SpecialHandler (Os->OptionName,Os->Option,Value)       :   \
        Os->DefaultHandler (Os->OptionName,Os->Option,Value);          \
        }



POPTIONSTRUCT
pFindOption (
    PTSTR OptionName
    )
{

    POPTIONSTRUCT rOption = NULL;
    UINT rc;

    //
    // find the matching option struct for this, and
    // call the handler.
    //
    rc = pSetupStringTableLookUpStringEx (
        g_OptionsTable,
        OptionName,
        STRTAB_CASE_INSENSITIVE,
        (PBYTE) &rOption,
        sizeof (POPTIONSTRUCT)
        );

    DEBUGMSG_IF ((rc == -1, DBG_WARNING, "Unknown option found: %s", OptionName));

    return rOption;
}

VOID
pInitUserOptionsTable (
    VOID
    )
{
   POPTIONSTRUCT os;
   LONG rc;

   os = g_OptionsList;

   while (os->OptionName) {

        //
        // Add the option struct to a string table for quick retrieval.
        //
        rc = pSetupStringTableAddStringEx (
                        g_OptionsTable,
                        os->OptionName,
                        STRTAB_CASE_INSENSITIVE,
                        (PBYTE) &os,
                        sizeof (POPTIONSTRUCT)
                        );

        if (rc == -1) {

            LOG ((LOG_ERROR, "User Options: Can't add to string table"));
            break;
        }

        os++;
   }

}


BOOL
pHandleBoolOption (
    IN PTSTR Name,
    IN PVOID * OptionVar,
    IN PTSTR Value
    )
{
    BOOL rSuccess = TRUE;
    BOOL *option = (BOOL *) OptionVar;

    if (StringIMatch (Value, S_YES) ||
        StringIMatch (Value, S_ONE) ||
        StringIMatch (Value, TEXT("TRUE"))) {

        *option = TRUE;
    }
    else {

        *option = FALSE;
    }



    return rSuccess;
}

BOOL
pHandleIntOption (
    IN PTSTR Name,
    IN PVOID * OptionVar,
    IN PTSTR Value
    )
{
    BOOL rSuccess = TRUE;
    PINT option = (PINT) OptionVar;

    MYASSERT(Name && OptionVar);

    if (!Value) {
        Value = TEXT("0");
    }

    *option = _ttoi((PCTSTR)Value);

    return rSuccess;
}

BOOL
pHandleTriStateOption (
    IN PTSTR Name,
    IN PVOID * OptionVar,
    IN PTSTR Value
    )
{
    BOOL rSuccess = TRUE;
    PINT option = (PINT) OptionVar;

    MYASSERT(Name && OptionVar);

    if (!Value) {
        Value = S_AUTO;
    }

    if (StringIMatch (Value, S_YES)  ||
        StringIMatch (Value, S_ONE)  ||
        StringIMatch (Value, S_TRUE) ||
        StringIMatch (Value, S_REQUIRED)) {
        *option = TRISTATE_YES;
    }
    else {
        if(StringIMatch (Value, S_NO) ||
           StringIMatch (Value, S_STR_FALSE) ||
           StringIMatch (Value, S_ZERO)) {
            *option = TRISTATE_NO;
        }
        else {
            *option = TRISTATE_AUTO;
        }
    }

    return rSuccess;
}

BOOL
pHandleMultiSzOption (
    IN PTSTR Name,
    IN PVOID * OptionVar,
    IN PTSTR Value
    )
{

    BOOL rSuccess = TRUE;

    if (Value) {
        *OptionVar = PoolMemDuplicateMultiSz (g_UserOptionPool, Value);
    }
    ELSE_DEBUGMSG ((DBG_WHOOPS, "Multi-Sz config option has nul value"));

    return rSuccess;
}

BOOL
pHandleStringOption (
    IN PTSTR Name,
    IN PVOID * OptionVar,
    IN PTSTR Value
    )
{

    if (!Value) {
        *OptionVar = S_EMPTY;
    }
    else {
        *OptionVar = PoolMemDuplicateMultiSz (g_UserOptionPool, Value);
    }


    return TRUE;
}


BOOL
pHandleSaveReportTo (
    IN PTSTR Name,
    IN PVOID * OptionVar,
    IN PTSTR Value
    )
{

    return pHandleStringOption (Name, OptionVar, Value);
}

BOOL
pHandleBoot16 (
    IN PTSTR Name,
    IN PVOID * OptionVar,
    IN PTSTR Value
    )
{

    BOOL rSuccess = TRUE;
    PTSTR * option = (PTSTR *) OptionVar;

    if (!Value ||
        StringIMatch (Value, S_YES) ||
        StringIMatch (Value, S_TRUE) ||
        StringIMatch (Value, S_ONE)) {

        *option = S_YES;

        g_Boot16 = BOOT16_YES;
    }
    else if (Value &&
            (StringIMatch (Value, S_BOOT16_UNSPECIFIED) ||
             StringIMatch (Value, S_BOOT16_AUTOMATIC))) {


        *option = S_BOOT16_AUTOMATIC;

        g_Boot16 = BOOT16_AUTOMATIC;
    }
    else {

        g_Boot16 = BOOT16_NO;

        *option = S_NO;


    }

    return rSuccess;
}


BOOL
pGetDefaultPassword (
    IN PTSTR Name,
    IN PVOID * OptionVar,
    IN PTSTR Value
    )
{
    return pHandleStringOption (Name, OptionVar, Value);
}



BOOL
pReadUserOptions (
    VOID
    )
{

    PTSTR        curParameter;
    PTSTR        curValue;
    BOOL         rSuccess = TRUE;
    POPTIONSTRUCT os;

    INFSTRUCT is = INITINFSTRUCT_GROWBUFFER;

    ZeroMemory(&g_ConfigOptions,sizeof(USEROPTIONS));

    g_OptionsTable = pSetupStringTableInitializeEx (sizeof (POPTIONSTRUCT), 0);
    if (!g_OptionsTable) {
        LOG ((LOG_ERROR, "User Options: Unable to initialize string table."));
        return FALSE;
    }

    pInitUserOptionsTable ();


    if (InfFindFirstLine(g_UnattendInf,S_WIN9XUPGUSEROPTIONS,NULL,&is)) {

        //
        // There is at least one item. Loop through all user options, processing each.
        //
        do {

            //
            // Get the parameter and value from this line and pass it on.
            //
            curParameter = InfGetStringField  (&is, 0);

            if (curParameter) {
                curParameter = PoolMemDuplicateString (g_UserOptionPool, curParameter);
            }

            curValue     = InfGetMultiSzField (&is, 1);

            if (curValue) {
                curValue = PoolMemDuplicateMultiSz (g_UserOptionPool, curValue);
            }

            if (curParameter) {
                os = pFindOption (curParameter);
                if (os) {
                    HANDLEOPTION (os, curValue);
                }
            }
            else {
                //
                // If we couldn't get the current parameter, it is a serious enough error
                // to abort processing of the unattend file user options.
                //
                LOG ((LOG_ERROR,"An error occurred while attempting to read user options from the unattend file."));
                rSuccess = FALSE;
            }


        } while (rSuccess && InfFindNextLine(&is));
    }
    else {
        LOG ((LOG_ERROR,"No win9xupgrade section in unattend script file."));
    }

    InfCleanUpInfStruct (&is);


    if (g_ConfigOptions.DoLog) {
        SET_DOLOG();
    }

    pSetupStringTableDestroy (g_OptionsTable);


    return rSuccess;

}

BOOL
SysSetupInit (
    IN  HWND ProgressBar,
    IN  PCWSTR UnattendFile,
    IN  PCWSTR SourceDir
    )
{
    HINF hUnattendInf;
    BOOL b = FALSE;

    //
    // This routine is called after the DLL initialization routines
    // have completed.
    //

#ifdef PRERELEASE
    {
        TCHAR Buf[32];
        STARTUPINFO si;
        BOOL ProcessStarted;

        ZeroMemory (&si, sizeof (si));
        si.cb = sizeof (si);


        if (GetPrivateProfileString (
                    TEXT("Debug"),
                    TEXT("Debug"),
                    TEXT("0"),
                    Buf,
                    32,
                    ISPC98() ? TEXT("a:\\debug.inf") : TEXT("c:\\debug.inf")
                    )
            ) {
            if (_ttoi (Buf)) {
                ProcessStarted = WinExec ("cmd.exe", SW_SHOW) > 31;

                if (ProcessStarted) {
                    MessageBox (NULL, TEXT("Ready to debug."), TEXT("Debug"), MB_OK|MB_SETFOREGROUND);
                    //CloseHandle (pi.hProcess);
                } else {
                    DEBUGMSG ((DBG_ERROR, "Could not start cmd.exe, GLE=%u", GetLastError()));
                }
            }
        }
    }
#endif





    //
    // Open the answer file and keep it open until SysSetupTerminate is called
    //


    hUnattendInf = InfOpenInfFile (UnattendFile);
    if (hUnattendInf == INVALID_HANDLE_VALUE) {
        LOG ((LOG_ERROR, "InitNT: Cannot open %s", UnattendFile));
        return FALSE;
    }

    //
    // Create a pool for user options.
    //
    g_UserOptionPool = PoolMemInitNamedPool ("User Option Pool - NT Side");
    if (!g_UserOptionPool) {
        DEBUGMSG((DBG_ERROR,"Cannot initialize user option pool."));
        return FALSE;
    }

    //
    // Open wkstamig.inf for general use
    //

    g_WkstaMigInf = InfOpenInfFile (S_WKSTAMIG_INF);

    if (g_WkstaMigInf == INVALID_HANDLE_VALUE) {
        LOG ((LOG_ERROR, "InitNT: Unable to open %s", S_WKSTAMIG_INF));
        return FALSE;
    }

    //
    // Open usermig.inf for general use
    //

    g_UserMigInf = InfOpenInfFile (S_USERMIG_INF);

    if (g_UserMigInf == INVALID_HANDLE_VALUE) {
        LOG ((LOG_ERROR, "InitNT: Unable to open %s", S_USERMIG_INF));
        return FALSE;
    }

    //
    // Initialize our globals
    //

    g_UnattendInf = hUnattendInf;
    StringCopy (g_OurCopyOfSourceDir, SourceDir);
    g_SourceDir = g_OurCopyOfSourceDir;

    g_ParentWnd   = GetParent (ProgressBar);
    LogReInit (&g_ParentWnd, NULL);

    g_ProgressBar = ProgressBar;

    if (ISPC98()) {
        TCHAR win9xBootDrive[6];
        //
        // Get g_Win9xBootDrive from answer file's [Data] section
        //

        if (pGetInfVal (
                WINNT_DATA,
                WINNT_D_WIN9XBOOTDRIVE,
                win9xBootDrive,
                sizeof (win9xBootDrive) / sizeof (TCHAR)
                )) {
            g_Win9xBootDrivePath[0] = win9xBootDrive[0];
        } else {
            LOG ((LOG_ERROR, "InitNT: Cannot retrieve %s in [%s] of %s",
                      WINNT_DATA, WINNT_D_WIN9XBOOTDRIVE, UnattendFile));
        }
    }

    //
    // Get g_TempDir from answer file's [Data] section
    //

    if (!pGetInfVal (
            WINNT_DATA,
            WINNT_D_MIGTEMPDIR,
            g_TempDir,
            sizeof (g_TempDir) / sizeof (TCHAR)
            )) {
        LOG ((LOG_ERROR, "InitNT: Cannot retrieve %s in [%s] of %s",
                  WINNT_DATA, WINNT_D_MIGTEMPDIR, UnattendFile));
        goto cleanup;
    }

    //
    // Get user settings from command line
    //
    pReadUserOptions();

    //
    // Read [String Map] section and put pairs in the corresponding map
    //
    pReadStringMap ();

    // Done!
    b = TRUE;

cleanup:
    if (!b) {
        SysSetupTerminate();
    }

    return b;
}

VOID
SysSetupTerminate (
    VOID
    )
{
    //
    // Close the answer file
    //

    if (g_UnattendInf != INVALID_HANDLE_VALUE) {
        InfCloseInfFile (g_UnattendInf);
        g_UnattendInf = INVALID_HANDLE_VALUE;
    }

    //
    // Close wkstamig.inf
    //

    if (g_WkstaMigInf != INVALID_HANDLE_VALUE) {
        InfCloseInfFile (g_WkstaMigInf);
        g_WkstaMigInf = INVALID_HANDLE_VALUE;
    }

    if (g_UserMigInf != INVALID_HANDLE_VALUE) {
        InfCloseInfFile (g_UserMigInf);
        g_UserMigInf = INVALID_HANDLE_VALUE;
    }

    //
    // Clean up user option pool.
    //
    if (g_UserOptionPool) {
        PoolMemDestroyPool(g_UserOptionPool);
    }

    //
    // Set current directory to the root of C:
    //

    SetCurrentDirectory (g_BootDrivePath);

#ifdef PRERELEASE
    {
        TCHAR Buf[32];

        if (GetPrivateProfileString (
                    TEXT("Debug"),
                    TEXT("GuiModePause"),
                    TEXT("0"),
                    Buf,
                    32,
                    ISPC98() ? TEXT("a:\\debug.inf") : TEXT("c:\\debug.inf")
                    )
            ) {
            if (_ttoi (Buf)) {
                MessageBox (NULL, TEXT("Paused."), TEXT("Debug"), MB_OK|MB_SETFOREGROUND);
            }
        }
    }
#endif
}


BOOL
PerformMigration (
    IN  HWND Unused,
    IN  PCWSTR UnattendFile,
    IN  PCWSTR SourceDir            // i.e. f:\i386
    )
{
    BOOL rSuccess = TRUE;

    //
    // Initialize Migmain.
    //

    if (!MigMain_Init()) {
        LOG ((LOG_ERROR, "W95UpgNt_Migrate: MigMain_Init failed"));
        rSuccess = FALSE;
    }

    //
    // Do the migration!
    //

    else if (!MigMain_Migrate()) {

        LOG ((LOG_ERROR, "W95UpgNt_Migrate: MigMain_Migrate failed"));
        rSuccess = FALSE;
    }

    //
    // If we were unsuccessful anywhere along the way, Migration could be in big
    // trouble. Inform the user.
    //

    if (!rSuccess) {
        LOG ((LOG_ERROR, (PCSTR)MSG_MIGRATION_IS_TOAST, g_Win95Name));
    }
    ELSE_DEBUGMSG((DBG_VERBOSE, "W95UpgNt_Migrate: Successful completion..."));

    return rSuccess;
}


VOID
pReadStringMap (
    VOID
    )
{
    INFSTRUCT is = INITINFSTRUCT_POOLHANDLE;
    PTSTR Key, Value;
    INT SubstringMatch;
    PTSTR ExpKey, ExpValue;

    MYASSERT (g_WkstaMigInf);

    if (InfFindFirstLine (g_WkstaMigInf, S_STRINGMAP, NULL, &is)) {
        do {
            Key = InfGetStringField (&is, 0);
            if (!Key) {
                continue;
            }
            Value = InfGetStringField (&is, 1);
            if (!Value) {
                continue;
            }

            if (!InfGetIntField (&is, 2, &SubstringMatch)) {
                SubstringMatch = 0;
            }

            ExpKey = ExpandEnvironmentText (Key);
            ExpValue = ExpandEnvironmentText (Value);

            AddStringMappingPair (
                SubstringMatch ? g_SubStringMap : g_CompleteMatchMap,
                ExpKey,
                ExpValue
                );

            FreeText (ExpKey);
            FreeText (ExpValue);

        } while (InfFindNextLine (&is));
    }

    InfCleanUpInfStruct (&is);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\dll\dllentry.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

  dllentry.c

Abstract:

  Code that implements the external DLL routines that interface with
  SYSSETUP.DLL.

Author:

  Jim Schmidt (jimschm) 01-Oct-1996

Revision History:

  Jim Schmidt (jimschm) 31-Dec-1997  Moved most of the code to initnt.lib

  Jim Schmidt (jimschm) 21-Nov-1997  Updated for NEC98, some cleaned up and
                                     code commenting

--*/

#include "pch.h"

#ifndef UNICODE
#error UNICODE required
#endif

//
// Entry point for DLL
//

BOOL
WINAPI
DllMain (
    IN      HINSTANCE hInstance,
    IN      DWORD dwReason,
    IN      LPVOID lpReserved
    )

/*++

Routine Description:

  DllMain is the w95upgnt.dll entry point.  The OS calls it with
  dwReason set to either DLL_PROCESS_ATTACH or DLL_PROCESS_DETACH.
  The hInstance and lpReserved parameters are passed to all
  libraries used by the DLL.

Arguments:

  hInstance - Specifies the instance handle of the DLL (and not the parent EXE or DLL)

  dwReason - Specifies DLL_PROCESS_ATTACH or DLL_PROCESS_DETACH.  We specifically
             disable DLL_THREAD_ATTACH and DLL_THREAD_DETACH.

  lpReserved - Unused.

Return Value:

  DLL_PROCESS_ATTACH:
      TRUE if initialization completed successfully, or FALSE if an error
      occurred.  The DLL remains loaded only if TRUE is returned.

  DLL_PROCESS_DETACH:
      Always TRUE.

  other:
      unexpected, but always returns TRUE.

--*/

{
    switch (dwReason)  {

    case DLL_PROCESS_ATTACH:
        //
        // Initialize DLL globals
        //

        if (!FirstInitRoutine (hInstance)) {
            return FALSE;
        }

        //
        // Initialize all libraries
        //

        if (!InitLibs (hInstance, dwReason, lpReserved)) {
            return FALSE;
        }

        //
        // Final initialization
        //

        if (!FinalInitRoutine ()) {
            return FALSE;
        }

        break;

    case DLL_PROCESS_DETACH:
        //
        // Call the cleanup routine that requires library APIs
        //

        FirstCleanupRoutine();

        //
        // Clean up all libraries
        //

        TerminateLibs (hInstance, dwReason, lpReserved);

        //
        // Do any remaining clean up
        //

        FinalCleanupRoutine();

        break;
    }

    return TRUE;
}


BOOL
WINAPI
W95UpgNt_Migrate (
    IN  HWND ProgressBar,
    IN  PCWSTR UnattendFile,
    IN  PCWSTR SourceDir            // i.e. f:\i386
    )
{
    SendMessage (ProgressBar, PBM_SETPOS, 0, 0);

    if (!SysSetupInit (ProgressBar, UnattendFile, SourceDir)) {
        LOG ((LOG_ERROR, "W95UPGNT : Can't init globals"));
        return FALSE;
    }

    return PerformMigration (ProgressBar, UnattendFile, SourceDir);
}


BOOL
WINAPI
W95UpgNt_FileRemoval (
    VOID
    )
{
    // Close all files and make current directory the root of c:

    SysSetupTerminate();

    DEBUGMSG ((DBG_VERBOSE, "Win95 Migration: Removing temporary files"));

    return MigMain_Cleanup();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\commonnt\commonnt.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    commonnt.c

Abstract:

    Common functionality between various parts of GUI mode-side processing.
    The routines in this library are shared only by other LIBs in the
    w95upgnt tree.

Author:

    Jim Schmidt (jimschm) 18-Aug-1998

Revision History:

    Name (alias)            Date            Description

--*/

#include "pch.h"

#define DBG_DATAFILTER  "Data Filter"



BOOL
WINAPI
CommonNt_Entry (
    IN HINSTANCE Instance,
    IN DWORD Reason,
    IN PVOID lpv
    )

/*++

Routine Description:

  CommonNt_Entry is a DllMain-like init funciton, called by w95upgnt\dll.
  This function is called at process attach and detach.

Arguments:

  Instance - (OS-supplied) instance handle for the DLL
  Reason   - (OS-supplied) indicates attach or detatch from process or
             thread
  lpv      - unused

Return Value:

  Return value is always TRUE (indicating successful init).

--*/

{
    switch (Reason) {

    case DLL_PROCESS_ATTACH:
        // Nothing to do...
        break;


    case DLL_PROCESS_DETACH:
        // Nothing to do...
        break;
    }

    return TRUE;
}

typedef enum {
    STATE_NO_PATH,
    STATE_PATH_FOUND,
    STATE_IN_PATH,
    STATE_PATH_CHANGED,
    STATE_PATH_DELETED,
    STATE_LONG_PATH_CHANGED,
    STATE_SHORT_PATH_CHANGED,
    STATE_RETURN_PATH
} SCANSTATE;

BOOL
pIsPathSeparator (
    CHARTYPE ch
    )
{
    return ch == 0 ||
           ch == TEXT(',') ||
           ch == TEXT(';') ||
           _istspace (ch) != 0;
}

BOOL
pIsValidPathCharacter (
    CHARTYPE ch
    )
{
    if (_istalnum (ch)) {
        return TRUE;
    }

    if (ch == TEXT(',') ||
        ch == TEXT(';') ||
        ch == TEXT('\"') ||
        ch == TEXT('<') ||
        ch == TEXT('>') ||
        ch == TEXT('|') ||
        ch == TEXT('?') ||
        ch == TEXT('*')
        ) {
        return FALSE;
    }

    return TRUE;
}

CONVERTPATH_RC
pGetReplacementPath (
    IN      PCTSTR DataStart,
    IN      PCTSTR Pos,
    OUT     PCTSTR *OldStart,
    OUT     PCTSTR *OldEnd,
    OUT     PTSTR ReplacementStr
    )
{
    CONVERTPATH_RC rc = CONVERTPATH_NOT_REMAPPED;
    SCANSTATE State;
    BOOL DontIncrement;
    PCTSTR OrgStart = NULL;
    TCHAR PathBuffer[MAX_TCHAR_PATH + 2];
    TCHAR RenamedFile[MAX_TCHAR_PATH];
    PTSTR PathBufferRoot = NULL;
    PTSTR PathBufferPtr = NULL;
    CONVERTPATH_RC ConvertCode = 0;
    BOOL ShortPath = FALSE;
    BOOL QuotesOn = FALSE;
    BOOL Done = FALSE;
    BOOL OrgPathHasSepChar = FALSE;
    BOOL NeedQuotes = FALSE;
    BOOL PathSepChar;
    PCTSTR p;
    BOOL QuotesOnColumn = FALSE;
    PCTSTR LastPathPosition = NULL;

    State = STATE_NO_PATH;
    PathBuffer[0] = TEXT('\"');

    //
    // Scan string of Pos for command line
    //

    while (!Done) {

        DontIncrement = FALSE;

        switch (State) {

        case STATE_NO_PATH:
            if (Pos[0] == 0) {
                Done = TRUE;
                break;
            }

            if (Pos[1] == TEXT(':') && Pos[2] == TEXT('\\')) {

                if (_istalpha (Pos[0])) {
                    QuotesOn = FALSE;
                    State = STATE_PATH_FOUND;
                    DontIncrement = TRUE;
                }
            } else if (Pos[0] == TEXT('\"')) {
                if (_istalpha (Pos[1]) && Pos[2] == TEXT(':') && Pos[3] == TEXT('\\')) {
                    QuotesOn = TRUE;
                    State = STATE_PATH_FOUND;
                }
            }

            break;

        case STATE_PATH_FOUND:
            //
            // Initialize path attributes
            //
            QuotesOnColumn = QuotesOn;
            LastPathPosition = Pos;

            OrgStart = Pos;

            PathBufferRoot = &PathBuffer[1];
            PathBufferRoot[0] = Pos[0];
            PathBufferRoot[1] = Pos[1];

            PathBufferPtr = &PathBufferRoot[2];
            Pos = &Pos[2];

            ShortPath = FALSE;
            OrgPathHasSepChar = FALSE;

            State = STATE_IN_PATH;
            DontIncrement = TRUE;
            break;

        case STATE_IN_PATH:
            //
            // Is this a closing quote?  If so, look for replacement path
            // and fail entire string if it's not replaced.
            //

            if (Pos[0] == TEXT(':')) {
                //
                // bogus. This cannot be a path, it has two ':' characters
                //
                Pos = _tcsdec (LastPathPosition, Pos);
                if (Pos) {
                    Pos = _tcsdec (LastPathPosition, Pos);
                    if (Pos) {
                        if (Pos[0] == TEXT('\"')) {
                            Pos = NULL;
                        }
                    }
                }
                if (!Pos) {
                    Pos = LastPathPosition;
                    QuotesOn = QuotesOnColumn;
                }
                State = STATE_NO_PATH;
                break;
            }

            if (QuotesOn && *Pos == TEXT('\"')) {
                *PathBufferPtr = 0;

                ConvertCode = ConvertWin9xPath (PathBufferRoot);

                if (ConvertCode != CONVERTPATH_NOT_REMAPPED) {

                    State = STATE_PATH_CHANGED;
                    DontIncrement = TRUE;
                    break;

                }

                State = STATE_NO_PATH;
                break;
            }


            //
            // Is this a path separator?  If so, look in memdb for replacement path.
            //

            if (Pos[0] == L'\\') {
                PathSepChar = pIsPathSeparator ((CHARTYPE) _tcsnextc (Pos + 1));
            } else {
                PathSepChar = pIsPathSeparator ((CHARTYPE) _tcsnextc (Pos));
            }

            if (PathSepChar) {

                *PathBufferPtr = 0;

                ConvertCode = ConvertWin9xPath (PathBufferRoot);

                if (ConvertCode != CONVERTPATH_NOT_REMAPPED) {
                    State = STATE_PATH_CHANGED;
                    DontIncrement = TRUE;
                    break;
                }
            }

            //
            // Check for end of data
            //

            if (Pos[0] == 0) {
                Done = TRUE;
                break;
            }

            //
            // Copy path character to buffer, break if we exceed max path length
            //

            *PathBufferPtr = *Pos;
            PathBufferPtr = _tcsinc (PathBufferPtr);

            if (PathBufferPtr == PathBufferRoot + MAX_TCHAR_PATH) {
                Pos = OrgStart;
                State = STATE_NO_PATH;
                break;
            }

            //
            // Test for short path
            //

            if (*Pos == TEXT('~')) {
                ShortPath = TRUE;
            }

            OrgPathHasSepChar |= PathSepChar;

            break;

        case STATE_PATH_CHANGED:
            if (ConvertCode == CONVERTPATH_DELETED) {
                State = STATE_PATH_DELETED;
            } else if (ShortPath) {
                State = STATE_SHORT_PATH_CHANGED;
            } else {
                State = STATE_LONG_PATH_CHANGED;
            }

            //
            // If replacement has introduced a path separator, set the
            // NeedQuotes flag.  Quotes will later be added if the path
            // is only part of the complete string.
            //

            NeedQuotes = FALSE;

            if (!OrgPathHasSepChar) {

                for (p = PathBufferRoot ; *p ; p = _tcsinc (p)) {
                    if (pIsPathSeparator ((CHARTYPE) _tcsnextc (p))) {
                        NeedQuotes = TRUE;
                        break;
                    }
                }
            }

            DontIncrement = TRUE;
            break;

        case STATE_PATH_DELETED:
            State = STATE_RETURN_PATH;
            DontIncrement = TRUE;
            break;

        case STATE_SHORT_PATH_CHANGED:
            if (OurGetShortPathName (PathBufferRoot, RenamedFile, MAX_TCHAR_PATH)) {
                PathBufferRoot = RenamedFile;
            }

            State = STATE_RETURN_PATH;
            DontIncrement = TRUE;
            break;

        case STATE_LONG_PATH_CHANGED:

            if (!QuotesOn && NeedQuotes) {
                if (OrgStart != DataStart || Pos[0] != 0) {

                    PathBufferPtr = _tcschr (PathBufferRoot, 0);
                    PathBufferPtr[0] = TEXT('\"');
                    PathBufferPtr[1] = 0;
                    PathBufferRoot = PathBuffer;
                }
            }

            State = STATE_RETURN_PATH;
            DontIncrement = TRUE;
            break;

        case STATE_RETURN_PATH:
            rc = ConvertCode;
            StringCopy (ReplacementStr, PathBufferRoot);
            *OldStart = OrgStart;
            *OldEnd = Pos;
            Done = TRUE;
            break;
        }

        if (!DontIncrement) {
            Pos = _tcsinc (Pos);
        }
    }

    return rc;

}


BOOL
ConvertWin9xCmdLine (
    IN OUT  PTSTR CmdLine,              // MAX_CMDLINE buffer
    IN      PCTSTR ObjectForDbgMsg,     OPTIONAL
    OUT     PBOOL PointsToDeletedItem   OPTIONAL
    )
{
    TCHAR NewCmdLine[MAX_CMDLINE];
    TCHAR NewPathBuffer[MAX_TCHAR_PATH];
    PCTSTR CmdLineStart;
    PCTSTR ReplaceStart;
    PCTSTR ExtraParamsStart;
    CONVERTPATH_RC ConvertCode;
    PTSTR EndOfNewCmdLine;
    UINT End = 0;
    BOOL NewCmdLineFlag = FALSE;
    INT Bytes;

#ifdef DEBUG
    TCHAR OriginalCmdLine[MAX_CMDLINE];
    StringCopy (OriginalCmdLine, CmdLine);
#endif

    if (PointsToDeletedItem) {
        *PointsToDeletedItem = FALSE;
    }

    *NewCmdLine = 0;
    ExtraParamsStart = CmdLine;
    EndOfNewCmdLine = NewCmdLine;

    for(;;) {
        CmdLineStart = ExtraParamsStart;

        //
        // We must test for a command line argument that has quotes or
        // doesn't need quotes, and then test for an argument that needs
        // quotes but doesn't have them.
        //

        ConvertCode = pGetReplacementPath (
                        CmdLine,
                        CmdLineStart,
                        &ReplaceStart,
                        &ExtraParamsStart,
                        NewPathBuffer
                        );

        if (ConvertCode == CONVERTPATH_NOT_REMAPPED) {
            //
            // Rest of command line does not have changed files
            //

            break;
        }

        //
        // If a command line was found, we must replace the text between
        // ReplaceStart and ExtraParamsStart with NewPathBuffer. To do this,
        // we copy the unchanged portion (from CmdLineStart to ReplaceStart)
        // to the caller's buffer, and append the replacement text.  The
        // search continues, searching the rest of the command line specified
        // by ExtraParamsStart.
        //

        if (ConvertCode == CONVERTPATH_DELETED && PointsToDeletedItem) {
            *PointsToDeletedItem = TRUE;
        }

        if (ObjectForDbgMsg) {

            DEBUGMSG_IF ((
                ConvertCode == CONVERTPATH_DELETED,
                DBG_WARNING,
                "%s still points to the deleted Win9x file %s (command line: %s).",
                ObjectForDbgMsg,
                NewPathBuffer,
                OriginalCmdLine
                ));
        }

        //
        // Path has changed, so we replace the path in the command line.
        //

        End = ((PBYTE) EndOfNewCmdLine - (PBYTE) NewCmdLine) +
              ((PBYTE) ReplaceStart - (PBYTE) CmdLineStart) +
              SizeOfString (NewPathBuffer);

        if (End >  sizeof (NewCmdLine)) {
            LOG ((LOG_ERROR, "Converting CmdLine: Conversion caused buffer overrun - aborting"));
            return FALSE;
        }

        if (ReplaceStart > CmdLineStart) {
            StringCopyAB (EndOfNewCmdLine, CmdLineStart, ReplaceStart);
        }

        EndOfNewCmdLine = _tcsappend (EndOfNewCmdLine, NewPathBuffer);

        NewCmdLineFlag |= (ConvertCode == CONVERTPATH_REMAPPED);
    }

    if (NewCmdLineFlag) {
        //
        // We have changed the command line, so complete the processing.
        //

        if (ExtraParamsStart && *ExtraParamsStart) {
            End = (PBYTE) EndOfNewCmdLine - (PBYTE) NewCmdLine + SizeOfString (ExtraParamsStart);
            if (End > sizeof (NewCmdLine)) {
                LOG ((LOG_ERROR, "Converting CmdLine: Conversion caused buffer overrun -- aborting (2)"));
                return FALSE;
            }

            StringCopy (EndOfNewCmdLine, ExtraParamsStart);
        }

        //
        // End is the number of bytes in NewCmdLine
        //

        Bytes = (INT) End - sizeof(TCHAR);

    } else {
        //
        // No changes yet, initialize Bytes
        //

        Bytes = (INT) ByteCount (CmdLine);

    }

    //
    // In-place string conversion, first look for a complete match, and when
    // that fails, look for a partial match.
    //

    if (MappingSearchAndReplaceEx (
            g_CompleteMatchMap,
            NewCmdLineFlag ? NewCmdLine : CmdLine,
            NewCmdLine,
            Bytes,
            NULL,
            sizeof (NewCmdLine),
            STRMAP_COMPLETE_MATCH_ONLY,
            NULL,
            NULL
            )) {

        NewCmdLineFlag = TRUE;

    } else {

        NewCmdLineFlag |= MappingSearchAndReplaceEx (
                                g_SubStringMap,
                                NewCmdLineFlag ? NewCmdLine : CmdLine,
                                NewCmdLine,
                                Bytes,
                                NULL,
                                sizeof (NewCmdLine),
                                STRMAP_ANY_MATCH,
                                NULL,
                                NULL
                                );

    }

    if (NewCmdLineFlag) {
        DEBUGMSG ((
            DBG_DATAFILTER,
            "Command line %s was modified to %s",
            OriginalCmdLine,
            NewCmdLine
            ));

        StringCopy (CmdLine, NewCmdLine);
    }

    return NewCmdLineFlag;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\merge\mergep.h ===
#ifndef _MERGEP_H
#define _MERGEP_H

#define REGMERGE_TICK_THRESHOLD 125

BOOL
FilterObject (
    IN OUT  PDATAOBJECT SrcObPtr
    );

PBYTE
FilterRegValue (
    IN      PBYTE Data,
    IN      DWORD DataSize,
    IN      DWORD DataType,
    IN      PCTSTR KeyForDbgMsg,        OPTIONAL
    OUT     PDWORD NewDataSize
    );


BOOL
CopyHardwareProfiles (
    IN  HINF InfFile
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\merge\datafilt.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    datafilt.c

Abstract:

    Routines to filter registry values.

Author:

    Jim Schmidt (jimschm)   11-Mar-1997

Revision History:

    jimschm     23-Sep-1998 Debugging message fix
    jimschm     10-Sep-1998 Mapping mechanism
    jimschm     25-Mar-1998 Added FilterRegValue

--*/

#include "pch.h"
#include "mergep.h"

#define DBG_DATAFILTER  "Data Filter"


VOID
SpecialFileFixup (
    PTSTR Buffer
    )
{
    PTSTR p;

    // check for rundll32 with no .exe extension
    p = (PTSTR) _tcsistr (Buffer, TEXT("rundll32"));
    if (p) {
        // replace foo\rundll32 <args> with rundll32.exe <args>

        p = CharCountToPointer (p, 8);      // p = &p[8]
        if (_tcsnextc (p) != TEXT('.')) {
            // p points to start of arg list or a nul if no args
            MoveMemory (CharCountToPointer (Buffer, 12), p, SizeOfString (p));
            _tcsncpy (Buffer, TEXT("rundll32.exe"), 12);
        }
        return;
    }
}


VOID
AddQuotesIfNecessary (
    PTSTR File
    )
{
    if (_tcspbrk (File, TEXT(" ;,"))) {
        MoveMemory (File + 1, File, SizeOfString (File));
        *File = TEXT('\"');
        StringCat (File, TEXT("\""));
    }
}

BOOL
CanFileBeInRegistryData (
    IN      PCTSTR Data
    )
{
    //
    // Scan registry data for a colon or a dot
    //

    if (_tcspbrk (Data, TEXT(":.\\"))) {
        return TRUE;
    }

    return FALSE;
}


BOOL
FilterObject (
    IN OUT  PDATAOBJECT SrcObPtr
    )
{
    if (IsWin95Object (SrcObPtr) &&
        (SrcObPtr->Value.Size < MAX_TCHAR_PATH * sizeof (TCHAR)) &&
        (SrcObPtr->Value.Size > 4 * sizeof (TCHAR))  // must have drive letter
       ) {
        TCHAR Buffer[MAX_CMDLINE];

        switch (SrcObPtr->Type) {
        case REG_NONE:
            if (*((PCTSTR) (SrcObPtr->Value.Buffer + SrcObPtr->Value.Size - sizeof (TCHAR)))) {
                // don't process unless it is nul-terminated
                break;
            }
            // fall through
        case REG_SZ:
            // Require the data to contain a basic symbol that a path or file requires
            if (!CanFileBeInRegistryData ((PCTSTR) SrcObPtr->Value.Buffer)) {
                break;
            }

            _tcssafecpy (Buffer, (PCTSTR) SrcObPtr->Value.Buffer, MAX_CMDLINE);
            if (ConvertWin9xCmdLine (Buffer, DEBUGENCODER(SrcObPtr), NULL)) {
                // cmd line has changed
                ReplaceValue (SrcObPtr, (PBYTE) Buffer, SizeOfString (Buffer));
            }
            break;

        case REG_EXPAND_SZ:
            ExpandEnvironmentStrings ((PCTSTR) SrcObPtr->Value.Buffer, Buffer, sizeof (Buffer) / sizeof (TCHAR));

            // Require the data to contain a basic symbol that a path or file requires
            if (!CanFileBeInRegistryData ((PCTSTR) Buffer)) {
                break;
            }

            if (ConvertWin9xCmdLine (Buffer, DEBUGENCODER(SrcObPtr), NULL)) {
                // cmd line has changed
                DEBUGMSG ((DBG_VERBOSE, "%s was expanded from %s", Buffer, SrcObPtr->Value.Buffer));
                ReplaceValue (SrcObPtr, (PBYTE) Buffer, SizeOfString (Buffer));
            }
            break;
        }
    }

    return TRUE;
}


PBYTE
FilterRegValue (
    IN      PBYTE Data,
    IN      DWORD DataSize,
    IN      DWORD DataType,
    IN      PCTSTR KeyForDbgMsg,        OPTIONAL
    OUT     PDWORD NewDataSize
    )

/*++

Routine Description:

  FilterRegValue examines the specified registry data and updates any paths
  that have moved.

Arguments:

  Data     - Specifies a ReuseAlloc'd buffer containing the registry value data.
  DataSize - Specifies the size of the registry value data, as returned by
             the registry APIs.
  DataType - Specifies the type of the registry data, as specified by the
             registry APIs.

  KeyForDbgMsg - Specifies registry key, used only for debug messages

  NewDataSize - Receives the size of the data returned

Return Value:

  Returns Data if no changes were made, or a reallocated pointer if changes
  were made.  If NULL is returned, an error occurred.

--*/

{
    TCHAR Buffer[MAX_CMDLINE];
    PBYTE NewData = Data;
    DWORD Size;

    *NewDataSize = DataSize;

    switch (DataType) {
    case REG_NONE:
        if (*((PCTSTR) (Data + DataSize - sizeof (TCHAR)))) {
            // don't process unless it is nul-terminated
            break;
        }
        // fall through
    case REG_SZ:
        // Require the data to contain a basic symbol that a path or file requires
        if (!CanFileBeInRegistryData ((PCTSTR) Data)) {
            break;
        }

        _tcssafecpy (Buffer, (PCTSTR) Data, MAX_CMDLINE);
        if (ConvertWin9xCmdLine (Buffer, KeyForDbgMsg, NULL)) {
            // cmd line has changed
            Size = SizeOfString (Buffer);
            NewData = (PBYTE) ReuseAlloc (g_hHeap, Data, Size);

            if (NewData) {
                StringCopy ((PTSTR) NewData, Buffer);
                *NewDataSize = Size;
            } else {
                NewData = Data;
                DEBUGMSG ((DBG_ERROR, "FilterRegValue: ReuseAlloc failed"));
            }
        }
        break;

    case REG_EXPAND_SZ:
        ExpandEnvironmentStrings ((PCTSTR) Data, Buffer, sizeof (Buffer) / sizeof (TCHAR));

        // Require the data to contain a basic symbol that a path or file requires
        if (!CanFileBeInRegistryData ((PCTSTR) Buffer)) {
            break;
        }

        if (ConvertWin9xCmdLine (Buffer, KeyForDbgMsg, NULL)) {
            // cmd line has changed
            DEBUGMSG ((DBG_VERBOSE, "%s was expanded from %s", Buffer, Data));

            Size = SizeOfString (Buffer);
            NewData = (PBYTE) ReuseAlloc (g_hHeap, Data, Size);

            if (NewData) {
                StringCopy ((PTSTR) NewData, Buffer);
                *NewDataSize = Size;
            } else {
                NewData = Data;
                DEBUGMSG ((DBG_ERROR, "FilterRegValue: ReuseAlloc failed"));
            }
        }
        break;
    }

    return NewData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\merge\object.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    object.c

Abstract:

    Routines to manage an 'object' which currently can only be a registry
    key, value name, value, handle and root handle.

Author:

    Jim Schmidt (jimschm)  14-Feb-1997

Revision History:

    marcw 09-Mar-1999 Don't create empty keys that didn't exist in Win9x Registry.

--*/




#include "pch.h"
#include "mergep.h"

extern POOLHANDLE g_TempPool;
extern DWORD g_ProgressBarCounter;

BOOL AllocObjectVal (IN OUT PDATAOBJECT SrcObPtr, IN PBYTE Value, IN DWORD Size, IN DWORD AllocSize);
VOID FreeObjectVal (IN OUT PDATAOBJECT SrcObPtr);

#define NON_ROOT_KEY(Key)   ((Key) && ((UINT)(Key) < 0x7fffff00))


#ifdef DEBUG

static TCHAR g_DebugEncoding[MAX_ENCODED_RULE];

PCTSTR
DebugEncoder (
    PVOID ObPtr
    )
{
    CreateObjectString ((CPDATAOBJECT) ObPtr, g_DebugEncoding);
    return g_DebugEncoding;
}

#endif


PKEYPROPS
pCreateKeyPropsFromString (
    PCTSTR KeyString,
    BOOL Win95Flag
    )
{
    PKEYPROPS RegKey;

    RegKey = (PKEYPROPS) PoolMemGetAlignedMemory (
                                g_TempPool,
                                sizeof (KEYPROPS) + SizeOfString (KeyString)
                                );

    StringCopy (RegKey->KeyString, KeyString);
    RegKey->UseCount    = 1;
    RegKey->OpenCount   = 0;
    RegKey->OpenKey     = NULL;
    RegKey->Win95       = Win95Flag;

    return RegKey;
}


VOID
pFreeKeyProps (
    PKEYPROPS RegKey
    )
{
    RegKey->UseCount--;
    if (!RegKey->UseCount) {

        // Close the key if it is open
        if (NON_ROOT_KEY (RegKey->OpenKey)) {
            if (RegKey->Win95) {
                CloseRegKey95 (RegKey->OpenKey);
            } else {
                CloseRegKey (RegKey->OpenKey);
            }
        }

        // Free the KEYPROPS memory
        PoolMemReleaseMemory (g_TempPool, RegKey);
    }
}

VOID
pIncKeyPropUse (
    PKEYPROPS RegKey
    )
{
    RegKey->UseCount++;
    if (RegKey->OpenKey) {
        RegKey->OpenCount++;
    }
}

PKEYPROPS
pCreateDuplicateKeyProps (
    PKEYPROPS RegKey,
    BOOL Win95Flag
    )
{
    PKEYPROPS NewRegKey;

    NewRegKey = pCreateKeyPropsFromString (RegKey->KeyString, Win95Flag);
    pFreeKeyProps (RegKey);

    return NewRegKey;
}


HKEY
pGetWinNTKey (
    HKEY Key
    )
{
    if (Key == HKEY_ROOT) {
        return g_hKeyRootNT;
    }

    return Key;
}

HKEY
pGetWin95Key (
    HKEY Key
    )
{
    if (Key == HKEY_ROOT) {
        return g_hKeyRoot95;
    }

    return Key;
}


VOID
FixUpUserSpecifiedObject (
    PTSTR Object
    )
{
    PTSTR p;

    // Look for a space-open bracket pair
    p = _tcsrchr (Object, TEXT('['));
    if (p) {
        p = _tcsdec2 (Object, p);
        if (p && _tcsnextc (p) == TEXT(' ')) {
            // Found: turn space into wack
            _settchar (p, TEXT('\\'));
        }
    }
}


VOID
CreateObjectString (
    IN  CPDATAOBJECT InObPtr,
    OUT PTSTR Object
    )
{
    PTSTR p;

    *Object = 0;

    // Add HKR
    if (InObPtr->RootItem) {
        StringCopy (Object, GetRootStringFromOffset (InObPtr->RootItem));
    }

    // If no root, start with a wack when key is not relative
    else if (!(InObPtr->ObjectType & OT_REGISTRY_RELATIVE)) {
        if (InObPtr->KeyPtr) {
            StringCopy (Object, TEXT("\\"));
        }
    }

    // Add key
    if (InObPtr->KeyPtr) {
        if (*Object) {
            AppendWack (Object);
        }

        EncodeRuleChars (GetEndOfString (Object), InObPtr->KeyPtr->KeyString);
    }

    // Add tree
    if (InObPtr->ObjectType & OT_TREE) {
        if (*Object) {
            AppendWack (Object);
            StringCat (Object, TEXT("*"));
        }
    }

    // Add value name
    if (InObPtr->ValueName) {
        if (*Object) {
            AppendWack (Object);
        }

        p = _tcsappend (Object, TEXT("["));
        EncodeRuleChars (p, InObPtr->ValueName);
        StringCat (Object, TEXT("]"));
    }

    // Final product: HKR\Reg\Key\Path\*\[Root]
}


BOOL
GetRegistryKeyStrFromObject (
    IN  CPDATAOBJECT InObPtr,
    OUT PTSTR RegKey
    )
{
    *RegKey = 0;

    // Add HKR
    if (InObPtr->RootItem) {
        StringCopy (RegKey, GetRootStringFromOffset (InObPtr->RootItem));
    } else {
        return FALSE;
    }

    // Add key
    if (InObPtr->KeyPtr) {
        EncodeRuleChars (AppendWack (RegKey), InObPtr->KeyPtr->KeyString);
    } else {
        return FALSE;
    }

    // Final product: HKR\Reg\Key\Path
    return TRUE;
}

BOOL
TrackedCreateObjectStruct (
    IN  PCTSTR Object,
    OUT PDATAOBJECT OutObPtr,
    IN  BOOL Win95Flag /* , */
    ALLOCATION_TRACKING_DEF
    )
{
    PCTSTR EndOfKey = NULL;

    PCTSTR EndOfSpace;
    PCTSTR ValueName;
    PCTSTR ObjectStart;
    TCHAR DecodeBuf[MAX_ENCODED_RULE];
    DWORD Length;
    DWORD RelativeFlag = 0;
    BOOL TreeFlag = FALSE;
    CHARTYPE ch = 0;

    //
    // Init
    //

    ObjectStart = SkipSpace (Object);

    ZeroMemory (OutObPtr, sizeof (DATAOBJECT));
    if (!(*ObjectStart)) {
        DEBUGMSG ((DBG_WARNING, "CreateObjectStruct: Empty object"));
        return TRUE;
    }

    if (Win95Flag) {
        OutObPtr->ObjectType |= OT_WIN95;
    }

    //
    // Root
    //

    OutObPtr->RootItem = GetOffsetOfRootString (ObjectStart, &Length);
    if (OutObPtr->RootItem) {
        ObjectStart += Length;
        OutObPtr->ObjectType |= OT_REGISTRY;

        // If we have HKR\*, make ObjectStart point to \*
        if (_tcsnextc (ObjectStart) == TEXT('*')) {
            ObjectStart = _tcsdec2 (Object, ObjectStart);
            MYASSERT (ObjectStart);
        }

    }

    // If no root, starting with a wack means 'relative to the current root'
    else if (*ObjectStart == TEXT('\\')) {
        ObjectStart = _tcsinc (ObjectStart);
    }

    // If no root and key does not start with a wack, means 'relative to current key'
    else if (*ObjectStart != TEXT('[')) {
        RelativeFlag = OT_REGISTRY_RELATIVE;
    }

    //
    // Key
    //

    if (*ObjectStart) {
        // Extract key, but not tree or valuename syntax
        for (EndOfKey = ObjectStart ; *EndOfKey ; EndOfKey = _tcsinc (EndOfKey)) {
            ch = (CHARTYPE)_tcsnextc (EndOfKey);

            if (ch == TEXT('[') || ch == TEXT('*')) {
                //
                // EndOfKey points to start of value name or tree identifier
                //

                // Make it point to optional space before value, or
                // make it point to wack before asterisk of the tree identifier
                EndOfKey = _tcsdec2 (ObjectStart, EndOfKey);

                // Verify that tree identifier points to wack-asterisk, otherwise
                // return a syntax error
                if (ch == TEXT('*')) {
                    if (!EndOfKey || _tcsnextc (EndOfKey) != TEXT('\\')) {
                        DEBUGMSG ((DBG_WARNING, "CreateObjectStruct: %s is not a valid object", Object));
                        return FALSE;
                    }

                    // Put EndOfKey on last character of the key
                    // (one char before \* tree identifer)
                    EndOfKey = _tcsdec2 (ObjectStart, EndOfKey);
                }
                break;
            }
        }

        if (EndOfKey) {
            // EndOfKey points to the last character of the key, or the
            // nul terminating the key.  We need to trim trailing space.
            EndOfSpace = SkipSpaceR (ObjectStart, EndOfKey);

            // If EndOfSpace points to a wack, back it up one char (a key
            // that does not have a tree identifier can end in a wack)
            if (ch != TEXT('*')) {
                if (_tcsnextc (EndOfSpace) == TEXT('\\')) {
                    EndOfSpace = _tcsdec2 (ObjectStart, EndOfSpace);
                }
            }

            // Now make EndOfSpace point to the character after the end
            if (EndOfSpace) {   // always the case when we have a valid key
                EndOfSpace = _tcsinc (EndOfSpace);
            }

            // Now make EndOfKey point to the first character after the key
            // (which is either a nul, \*, \[valuename] or [valuename])
            if (*EndOfKey) {
                EndOfKey = _tcsinc (EndOfKey);
            }
        } else {
            // no key found
            EndOfSpace = NULL;
            EndOfKey = ObjectStart;
        }

        // Decode key if it actually exists
        if (ObjectStart < EndOfSpace) {
            DecodeRuleCharsAB (DecodeBuf, ObjectStart, EndOfSpace);
            SetRegistryKey (OutObPtr, DecodeBuf);
            OutObPtr->ObjectType |= RelativeFlag;
        } else {
            // if HKR\*, set an empty key
            if (_tcsnextc (ObjectStart) != '[' && ch == TEXT('*')) {
                SetRegistryKey (OutObPtr, TEXT(""));
            }
        }

        //
        // Tree identifier exists
        //
        if (ch == TEXT('*')) {
            OutObPtr->ObjectType |= OT_TREE;

            // EndOfKey points to \*, so move it past the identifier
            EndOfKey = _tcsinc (EndOfKey);
            EndOfKey = _tcsinc (EndOfKey);

            // If we are at a wack, skip past it.
            if (_tcsnextc (EndOfKey) == TEXT('\\')) {
                EndOfKey = _tcsinc (EndOfKey);
            }
        }

        if (EndOfKey) {
            ObjectStart = EndOfKey;
        }
    }

    //
    // Value name
    //

    if (*ObjectStart) {
        //
        // ObjectStart may point to optional space
        //

        ObjectStart = SkipSpace (ObjectStart);

        //
        // ObjectStart now points to nul, [valuename] or syntax error
        //

        if (_tcsnextc (ObjectStart) == TEXT('[')) {
            // Skip past optional spaces following bracket
            ValueName = SkipSpace (_tcsinc (ObjectStart));

            // Locate end of [valuename]
            EndOfKey = ValueName;
            while (TRUE) {
                if (!(*EndOfKey)) {
                    DEBUGMSG ((DBG_WARNING, "CreateObjectStruct: Value name is incomplete in %s", Object));
                    return FALSE;
                }

                ch = (CHARTYPE)_tcsnextc (EndOfKey);

                if (ch == TEXT(']')) {
                    // move to first space character before closing bracket,
                    // or leave it at the bracket if no space exists
                    EndOfKey = _tcsdec2 (ValueName, EndOfKey);
                    if (EndOfKey) {
                        EndOfKey = SkipSpaceR (ValueName, EndOfKey);
                        if (EndOfKey) {
                            EndOfKey = _tcsinc (EndOfKey);
                        }
                    } else {
                        EndOfKey = ValueName;
                    }

                    break;
                }

                EndOfKey = _tcsinc (EndOfKey);
            }

            // Now decode ValueName, which may be empty
            DecodeRuleCharsAB (DecodeBuf, ValueName, EndOfKey);
            SetRegistryValueName (OutObPtr, DecodeBuf);

            // Make ObjectStart point to nul
            ObjectStart = SkipSpace (_tcsinc (EndOfKey));
        }

        if (*ObjectStart) {
            DEBUGMSG ((DBG_WARNING, "CreateObjectStruct: %s does not have a valid value name", Object));
            return FALSE;
        }
    }

    //
    // The next line is normally disabled, and is enabled only when
    // tracking is needed.
    //

    //DebugRegisterAllocation (MERGE_OBJECT, OutObPtr, File, Line);
    return TRUE;
}


BOOL
CombineObjectStructs (
    IN OUT PDATAOBJECT DestObPtr,
    IN     CPDATAOBJECT SrcObPtr
    )
{
    if (!SrcObPtr->ObjectType) {
        DEBUGMSG ((DBG_WARNING, "CombineObjectStructs: Source is empty"));
        return TRUE;
    }

    // The values and handles are no longer valid
    FreeObjectVal (DestObPtr);
    CloseObject (DestObPtr);

    // Registry object merging
    if (DestObPtr->ObjectType & OT_REGISTRY || !DestObPtr->ObjectType) {
        if (SrcObPtr->ObjectType & OT_REGISTRY) {
            //
            // Verify objects are compatible
            //

            if ((SrcObPtr->ObjectType & OT_TREE) &&
                (DestObPtr->ValueName)
               ) {
                DEBUGMSG ((DBG_WHOOPS, "Cannot combine registry tree with valuename structs"));
                return FALSE;
            }

            if ((DestObPtr->ObjectType & OT_TREE) &&
                (SrcObPtr->ValueName)
               ) {
                DEBUGMSG ((DBG_WHOOPS, "Cannot combine registry tree with valuename structs"));
                return FALSE;
            }

            //
            // Make dest ob the same platform as src ob
            //

            SetPlatformType (DestObPtr, IsWin95Object (SrcObPtr));

            //
            // Copy source's value name, key, type and root to dest
            // (if they exist)
            //

            if (SrcObPtr->ValueName) {
                SetRegistryValueName (DestObPtr, SrcObPtr->ValueName);
            }

            if (SrcObPtr->KeyPtr) {
                if ((SrcObPtr->ObjectType & OT_REGISTRY_RELATIVE) &&
                    (DestObPtr->KeyPtr)
                   ) {
                    TCHAR CompleteKeyName[MAX_ENCODED_RULE];
                    PTSTR p;

                    // Src is only specifying a key name. Peel off
                    // last key name of dest and replace it with
                    // src.

                    StringCopy (CompleteKeyName, DestObPtr->KeyPtr->KeyString);
                    p = _tcsrchr (CompleteKeyName, TEXT('\\'));
                    if (!p) {
                        p = CompleteKeyName;
                    } else {
                        p = _tcsinc (p);
                    }

                    StringCopy (p, SrcObPtr->KeyPtr->KeyString);
                    SetRegistryKey (DestObPtr, CompleteKeyName);
                } else {
                    SetRegistryKey (DestObPtr, SrcObPtr->KeyPtr->KeyString);
                }
            }

            if (SrcObPtr->ObjectType & OT_REGISTRY_TYPE) {
                SetRegistryType (DestObPtr, SrcObPtr->Type);
            }

            if (SrcObPtr->RootItem) {
                DestObPtr->RootItem = SrcObPtr->RootItem;
            }

            return TRUE;
        }
        else {
            DEBUGMSG ((DBG_WHOOPS, "Cannot combine registry struct with other type of struct"));
        }
    }

    // Other type of object merging not supported
    DEBUGMSG ((DBG_WHOOPS, "Cannot combine unsupported or garbage objects"));
    return FALSE;
}


BOOL
TrackedDuplicateObjectStruct (
    OUT     PDATAOBJECT DestObPtr,
    IN      CPDATAOBJECT SrcObPtr /* , */
    ALLOCATION_TRACKING_DEF
    )
{
    ZeroMemory (DestObPtr, sizeof (DATAOBJECT));

    //
    // Create an object that has the same settings as the source,
    // but duplicate all strings.
    //

    if (SrcObPtr->ObjectType & OT_REGISTRY) {
        DestObPtr->ObjectType |= OT_REGISTRY;
    }

    if (SrcObPtr->KeyPtr) {
        DestObPtr->KeyPtr = SrcObPtr->KeyPtr;
        pIncKeyPropUse (DestObPtr->KeyPtr);
    }

    if (SrcObPtr->ValueName) {
        if (!SetRegistryValueName (DestObPtr, SrcObPtr->ValueName)) {
            LOG ((LOG_ERROR, "Error merging the registry (1)"));
            return FALSE;
        }
    }

    if (SrcObPtr->ObjectType & OT_VALUE) {
        if (!AllocObjectVal (
                DestObPtr,
                SrcObPtr->Value.Buffer,
                SrcObPtr->Value.Size,
                SrcObPtr->Value.AllocatedSize
                )) {
            LOG ((LOG_ERROR, "Error merging the registry (2)"));
            return FALSE;
        }
    }

    if (SrcObPtr->ObjectType & OT_REGISTRY_TYPE) {
        SetRegistryType (DestObPtr, SrcObPtr->Type);
    }

    DestObPtr->RootItem = SrcObPtr->RootItem;

    #define DUP_OBJECT_FLAGS (OT_TREE|OT_WIN95|OT_REGISTRY_RELATIVE)
    if (SrcObPtr->ObjectType & DUP_OBJECT_FLAGS) {
        DestObPtr->ObjectType |= (SrcObPtr->ObjectType & DUP_OBJECT_FLAGS);
    }

    if (SrcObPtr->ObjectType & OT_REGISTRY_ENUM_KEY) {
        DestObPtr->KeyEnum = SrcObPtr->KeyEnum;
        DestObPtr->ObjectType |= OT_REGISTRY_ENUM_KEY;
    }

    if (SrcObPtr->ObjectType & OT_REGISTRY_ENUM_VALUENAME) {
        DestObPtr->ValNameEnum = SrcObPtr->ValNameEnum;
        DestObPtr->ObjectType |= OT_REGISTRY_ENUM_VALUENAME;
    }

    if (SrcObPtr->ObjectType & OT_REGISTRY_CLASS) {
        if (!SetRegistryClass (DestObPtr, SrcObPtr->Class.Buffer, SrcObPtr->Class.Size)) {
            LOG ((LOG_ERROR, "Error merging the registry (3)"));
            return FALSE;
        }
    }

    //
    // The next line is normally disabled, and is enabled only when
    // tracking is needed.
    //

    //DebugRegisterAllocation (MERGE_OBJECT, DestObPtr, File, Line);
    return TRUE;
}


BOOL
AllocObjectVal (
    IN OUT  PDATAOBJECT SrcObPtr,
    IN      PBYTE Value,           OPTIONAL
    IN      DWORD Size,
    IN      DWORD AllocatedSize
    )
{
    SrcObPtr->Value.Buffer = PoolMemGetAlignedMemory (g_TempPool, AllocatedSize);
    if (!SrcObPtr->Value.Buffer) {
        DEBUGMSG ((DBG_WARNING, "AllocObjectVal failed to alloc memory"));
        return FALSE;
    }

    SrcObPtr->Value.AllocatedSize = AllocatedSize;
    SrcObPtr->Value.Size = Size;

    if (Value) {
        CopyMemory (SrcObPtr->Value.Buffer, Value, AllocatedSize);
    }

    SrcObPtr->ObjectType |= OT_VALUE;
    return TRUE;
}


VOID
FreeObjectVal (
    IN OUT  PDATAOBJECT SrcObPtr
    )
{
    if (SrcObPtr->ObjectType & OT_VALUE) {
        PoolMemReleaseMemory (g_TempPool, SrcObPtr->Value.Buffer);
        SrcObPtr->Value.Buffer = NULL;
        SrcObPtr->ObjectType &= ~OT_VALUE;
    }
}


VOID
CloseObject (
    IN OUT  PDATAOBJECT SrcObPtr
    )
{
    if (!(SrcObPtr->ObjectType & OT_OPEN)) {
        return;
    }

    MYASSERT (IsRegistryKeyOpen (SrcObPtr));


    SrcObPtr->KeyPtr->OpenCount -= 1;

    if (!SrcObPtr->KeyPtr->OpenCount) {

        if (NON_ROOT_KEY (SrcObPtr->KeyPtr->OpenKey)) {

            if (IsWin95Object (SrcObPtr)) {
                CloseRegKey95 (SrcObPtr->KeyPtr->OpenKey);
            } else {
                CloseRegKey (SrcObPtr->KeyPtr->OpenKey);
            }
        }

        SrcObPtr->KeyPtr->OpenKey = NULL;
    }

    SrcObPtr->ObjectType &= ~OT_OPEN;
}


VOID
FreeObjectStruct (
    IN OUT  PDATAOBJECT SrcObPtr
    )
{
    PushError();

    //
    // The next line is normally disabled, and is enabled only when
    // tracking is needed.
    //

    //DebugUnregisterAllocation (MERGE_OBJECT, SrcObPtr);

    FreeObjectVal (SrcObPtr);

    if (SrcObPtr->KeyPtr) {
        pFreeKeyProps (SrcObPtr->KeyPtr);
    }
    if (SrcObPtr->ParentKeyPtr) {
        pFreeKeyProps (SrcObPtr->ParentKeyPtr);
    }
    if (SrcObPtr->ValueName) {
        PoolMemReleaseMemory (g_TempPool, (PVOID) SrcObPtr->ValueName);
    }
    if (SrcObPtr->ObjectType & OT_REGISTRY_CLASS) {
        PoolMemReleaseMemory (g_TempPool, (PVOID) SrcObPtr->Class.Buffer);
    }

    ZeroMemory (SrcObPtr, sizeof (DATAOBJECT));
    PopError();
}

BOOL
CreateObject (
    IN OUT  PDATAOBJECT SrcObPtr
    )
{
    DWORD rc;
    DWORD DontCare;
    PTSTR ClassPtr;

    if (SrcObPtr->ObjectType & OT_OPEN) {
        return TRUE;
    }

    if (SrcObPtr->KeyPtr) {
        if (SrcObPtr->KeyPtr->OpenKey) {
            SrcObPtr->ObjectType |= OT_OPEN;
            SrcObPtr->KeyPtr->OpenCount++;
            return TRUE;
        }

        if (IsWin95Object (SrcObPtr)) {
            DEBUGMSG ((DBG_WHOOPS, "Cannot create Win95 registry objects (%s)", SrcObPtr->KeyPtr->KeyString));
            return FALSE;
        }

        if (!SrcObPtr->KeyPtr->KeyString[0]) {
            // This is the root of a hive
            return OpenObject (SrcObPtr);
        }

        if (SrcObPtr->ObjectType & OT_REGISTRY_CLASS) {
            ClassPtr = (PTSTR) SrcObPtr->Class.Buffer;
        } else {
            ClassPtr = TEXT("");
        }

        if (SrcObPtr->ParentKeyPtr && SrcObPtr->ParentKeyPtr->OpenKey && SrcObPtr->ChildKey) {
            rc = TrackedRegCreateKeyEx (
                    SrcObPtr->ParentKeyPtr->OpenKey,
                    SrcObPtr->ChildKey,
                    0, ClassPtr, 0,
                    KEY_ALL_ACCESS, NULL,
                    &SrcObPtr->KeyPtr->OpenKey,
                    &DontCare
                    );
        } else {
            rc = TrackedRegCreateKeyEx (
                    pGetWinNTKey (GetRootKeyFromOffset (SrcObPtr->RootItem)),
                    SrcObPtr->KeyPtr->KeyString,
                    0,
                    ClassPtr,
                    0,
                    KEY_ALL_ACCESS,
                    NULL,
                    &SrcObPtr->KeyPtr->OpenKey,
                    &DontCare
                    );
        }

        if (rc == ERROR_INVALID_PARAMETER) {
            //
            // Attempt was made to create a key directly under HKLM.  There is no
            // backing storage, so the RegCreateKeyEx call failed with this error.
            // We handle it gracefully...
            //

            DEBUGMSG ((DBG_WARNING, "CreateObject: Not possible to create %s on NT", SrcObPtr->KeyPtr->KeyString));
            SetLastError (ERROR_SUCCESS);
            return FALSE;
        }

        if (rc == ERROR_ACCESS_DENIED) {
            //
            // Attempt was made to create a key that has a strong ACL. We'll
            // just assume success in this case.
            //

            LOG ((
                LOG_INFORMATION,
                "Can't create %s because access was denied",
                SrcObPtr->KeyPtr->KeyString
                ));

            SetLastError (ERROR_SUCCESS);
            return FALSE;
        }

        if (rc != ERROR_SUCCESS) {
            SetLastError (rc);
            LOG ((LOG_ERROR, "Failed to create a registry key (%s)", SrcObPtr->KeyPtr->KeyString));
            return FALSE;
        }

        SrcObPtr->KeyPtr->OpenCount = 1;
        SrcObPtr->ObjectType |= OT_OPEN;
    }

    return TRUE;
}


BOOL
OpenObject (
    IN OUT  PDATAOBJECT SrcObPtr
    )
{
    DWORD rc = ERROR_SUCCESS;
    HKEY Parent;
#if CLASS_FIELD_ENABLED
    TCHAR ClassBuf[MAX_CLASS_SIZE];
    DWORD ClassBufSize = MAX_CLASS_SIZE;
#endif

    if (SrcObPtr->ObjectType & OT_OPEN) {
        return TRUE;
    }

    if (SrcObPtr->KeyPtr) {
        if (SrcObPtr->KeyPtr->OpenKey) {
            SrcObPtr->ObjectType |= OT_OPEN;
            SrcObPtr->KeyPtr->OpenCount++;
            return TRUE;
        }

        if (IsWin95Object (SrcObPtr)) {
            if (SrcObPtr->ParentKeyPtr && SrcObPtr->ParentKeyPtr->OpenKey && SrcObPtr->ChildKey) {
                rc = TrackedRegOpenKeyEx95 (
                         SrcObPtr->ParentKeyPtr->OpenKey,
                         SrcObPtr->ChildKey,
                         0,
                         KEY_READ,
                         &SrcObPtr->KeyPtr->OpenKey
                         );
            } else {
                Parent = pGetWin95Key (GetRootKeyFromOffset (SrcObPtr->RootItem));

                if (*SrcObPtr->KeyPtr->KeyString || NON_ROOT_KEY (Parent)) {
                    rc = TrackedRegOpenKeyEx95 (
                            Parent,
                            SrcObPtr->KeyPtr->KeyString,
                            0,
                            KEY_READ,
                            &SrcObPtr->KeyPtr->OpenKey
                            );
                } else {

                    SrcObPtr->KeyPtr->OpenKey = Parent;

                }
            }
        }
        else {
            if (SrcObPtr->ParentKeyPtr && SrcObPtr->ParentKeyPtr->OpenKey && SrcObPtr->ChildKey) {
                rc = TrackedRegOpenKeyEx (
                        SrcObPtr->ParentKeyPtr->OpenKey,
                        SrcObPtr->ChildKey,
                        0,
                        KEY_ALL_ACCESS,
                        &SrcObPtr->KeyPtr->OpenKey
                        );
            } else {
                Parent = pGetWinNTKey (GetRootKeyFromOffset (SrcObPtr->RootItem));

                if (*SrcObPtr->KeyPtr->KeyString || NON_ROOT_KEY (Parent)) {
                    rc = TrackedRegOpenKeyEx (
                            Parent,
                            SrcObPtr->KeyPtr->KeyString,
                            0,
                            KEY_ALL_ACCESS,
                            &SrcObPtr->KeyPtr->OpenKey
                            );
                } else {

                    SrcObPtr->KeyPtr->OpenKey = Parent;

                }
            }
        }

        if (rc != ERROR_SUCCESS) {
            SetLastError (rc);
            return FALSE;
        }

        SrcObPtr->ObjectType |= OT_OPEN;
        SrcObPtr->KeyPtr->OpenCount = 1;

#if CLASS_FIELD_ENABLED
        // Get the key's class
        if (IsWin95Object (SrcObPtr)) {
            rc = Win95RegQueryInfoKey (pGetWin95Key (SrcObPtr->RootKey),
                                       ClassBuf,
                                       &ClassBufSize,
                                       NULL,         // reserved
                                       NULL,         // sub key count
                                       NULL,         // max sub key len
                                       NULL,         // max class len
                                       NULL,         // values
                                       NULL,         // max value name len
                                       NULL,         // max value len
                                       NULL,         // security desc
                                       NULL          // last write time
                                       );
        } else {
            rc = WinNTRegQueryInfoKey (pGetWin95Key (SrcObPtr->RootKey),
                                       ClassBuf,
                                       &ClassBufSize,
                                       NULL,         // reserved
                                       NULL,         // sub key count

                                       NULL,         // max sub key len
                                       NULL,         // max class len
                                       NULL,         // values
                                       NULL,         // max value name len
                                       NULL,         // max value len
                                       NULL,         // security desc
                                       NULL          // last write time
                                       );
        }

        if (rc == ERROR_SUCCESS) {
            DEBUGMSG ((DBG_VERBOSE, "Class size is %u for %s\\%s", ClassBufSize,
                       GetRootStringFromOffset (SrcObPtr->RootItem), SrcObPtr->KeyPtr->KeyString));
            SetRegistryClass (SrcObPtr, ClassBuf, ClassBufSize);
        }
#endif
    }

    return TRUE;
}


VOID
pFixRegSzTermination (
    IN OUT  PDATAOBJECT SrcObPtr
    )
{
    BOOL addNul = FALSE;
    PTSTR end;
    PBYTE oldBuf;
    UINT oldSize;

    if (SrcObPtr->Type == REG_SZ || SrcObPtr->Type == REG_EXPAND_SZ) {

        if (SrcObPtr->Value.Size & 1) {
            //
            // Force type to REG_NONE because we assume all REG_SZ
            // and REG_EXPAND_SZ values are truncated.
            //

            SrcObPtr->Type = REG_NONE;
            DEBUGMSG ((
                DBG_WARNING,
                "Truncation occurred because of odd string size for %s",
                DebugEncoder (SrcObPtr)
                ));
        } else {

            //
            // Check if we need to append a nul.
            //

            addNul = FALSE;
            oldBuf = SrcObPtr->Value.Buffer;
            oldSize = SrcObPtr->Value.Size;

            if (oldSize < sizeof (TCHAR)) {
                addNul = TRUE;
            } else {
                end = (PTSTR) (oldBuf + oldSize - sizeof (TCHAR));
                addNul = (*end != 0);
            }

            if (addNul) {
                if (AllocObjectVal (SrcObPtr, NULL, oldSize, oldSize + sizeof (TCHAR))) {

                    CopyMemory (SrcObPtr->Value.Buffer, oldBuf, oldSize);
                    end = (PTSTR) (SrcObPtr->Value.Buffer + oldSize);
                    *end = 0;

                    PoolMemReleaseMemory (g_TempPool, oldBuf);
                } else {
                    SrcObPtr->Type = REG_NONE;
                }
            }
        }
    }
}


BOOL
ReadObject (
    IN OUT  PDATAOBJECT SrcObPtr
    )
{
    return ReadObjectEx (SrcObPtr, FALSE);
}

BOOL
ReadObjectEx (
    IN OUT  PDATAOBJECT SrcObPtr,
    IN      BOOL QueryOnly
    )
{
    DWORD rc;
    DWORD ReqSize;

    // Skip if value has already been read
    if (SrcObPtr->ObjectType & OT_VALUE) {
        return TRUE;
    }

    // If registry key and valuename, query Win95 registry
    if (IsObjectRegistryKeyAndVal (SrcObPtr)) {
        // Open key if necessary
        if (!OpenObject (SrcObPtr)) {
            DEBUGMSG ((DBG_VERBOSE, "ReadObject failed because OpenObject failed"));
            return FALSE;
        }

        // Get the value size
        if (IsWin95Object (SrcObPtr)) {
            ReqSize = 0;  // Temporary fix for win95reg
            rc = Win95RegQueryValueEx (SrcObPtr->KeyPtr->OpenKey,
                                       SrcObPtr->ValueName,
                                       NULL, &SrcObPtr->Type, NULL, &ReqSize);

        } else {
            rc = WinNTRegQueryValueEx (
                    SrcObPtr->KeyPtr->OpenKey,
                    SrcObPtr->ValueName,
                    NULL,
                    &SrcObPtr->Type,
                    NULL,
                    &ReqSize
                    );

            if (rc == ERROR_ACCESS_DENIED) {
                LOG ((
                    LOG_INFORMATION,
                    "Access denied for query of %s in %s",
                    SrcObPtr->ValueName,
                    SrcObPtr->KeyPtr->KeyString
                    ));
                ReqSize = 1;
                SrcObPtr->Type = REG_NONE;
            }
        }

        if (rc != ERROR_SUCCESS) {

            DEBUGMSG_IF ((rc != ERROR_FILE_NOT_FOUND, DBG_WARNING,
                         "ReadObject failed for %s (type: %x)",
                         DebugEncoder (SrcObPtr), SrcObPtr->ObjectType));

            DEBUGMSG_IF ((
                !QueryOnly && rc == ERROR_FILE_NOT_FOUND,
                DBG_WARNING,
                "Object %s not found",
                DebugEncoder (SrcObPtr)
                ));

            SetLastError (rc);
            return FALSE;
        }

        // Query only is used to see if the object exists
        if (QueryOnly) {
            return TRUE;
        }

        // Allocate a buffer for the value
        if (!AllocObjectVal (SrcObPtr, NULL, ReqSize, ReqSize)) {
            return FALSE;
        }

        // Get the the value
        if (IsWin95Object (SrcObPtr)) {
            rc = Win95RegQueryValueEx (SrcObPtr->KeyPtr->OpenKey,
                                       SrcObPtr->ValueName,
                                       NULL, &SrcObPtr->Type,
                                       SrcObPtr->Value.Buffer,
                                       &ReqSize);
        } else {
            rc = WinNTRegQueryValueEx (
                    SrcObPtr->KeyPtr->OpenKey,
                    SrcObPtr->ValueName,
                    NULL,
                    &SrcObPtr->Type,
                    SrcObPtr->Value.Buffer,
                    &ReqSize
                    );

            if (rc == ERROR_ACCESS_DENIED) {
                SrcObPtr->Type = REG_NONE;
                SrcObPtr->Value.Size = 0;
                rc = ERROR_SUCCESS;
            }
        }

        if (rc != ERROR_SUCCESS) {
            FreeObjectVal (SrcObPtr);
            SetLastError (rc);
            LOG ((LOG_ERROR, "Failed to read from the registry"));
            return FALSE;
        }

        // The SrcObPtr->Type field is accurate
        SrcObPtr->ObjectType |= OT_REGISTRY_TYPE;

        // Fix REG_SZ or REG_EXPAND_SZ
        pFixRegSzTermination (SrcObPtr);

        //
        // If necessary, convert the data
        //

        return FilterObject (SrcObPtr);
    }

    DEBUGMSG ((DBG_WHOOPS, "Read Object: Object type (%Xh) is not supported", SrcObPtr->ObjectType));
    return FALSE;
}


BOOL
WriteObject (
    IN     CPDATAOBJECT DestObPtr
    )
{
    DWORD rc;

    // If registry key, make sure it exists
    if ((DestObPtr->KeyPtr) &&
        !IsWin95Object (DestObPtr)
        ) {
        // Create or open key if necessary
        if (!CreateObject (DestObPtr)) {
            DEBUGMSG ((DBG_WARNING, "WriteObject: CreateObject failed for %s", DestObPtr->KeyPtr->KeyString));
            return FALSE;
        }

        // If no value name and no value, skip
        if (!(DestObPtr->ObjectType & OT_VALUE) && !(DestObPtr->ValueName)) {
            return TRUE;
        }

        // If no type, specify it as REG_NONE
        if (!IsRegistryTypeSpecified (DestObPtr)) {
            SetRegistryType (DestObPtr, REG_NONE);
        }

        // Write the value
        if (*DestObPtr->ValueName || NON_ROOT_KEY (DestObPtr->KeyPtr->OpenKey)) {
            rc = WinNTRegSetValueEx (
                    DestObPtr->KeyPtr->OpenKey,
                    DestObPtr->ValueName,
                    0,
                    DestObPtr->Type,
                    DestObPtr->Value.Buffer,
                    DestObPtr->Value.Size
                    );

            if (rc == ERROR_ACCESS_DENIED) {
                //
                // If access is denied, log & assume success
                //

                LOG ((
                    LOG_INFORMATION,
                    "Access denied; can't write registry value (%s [%s])",
                    DestObPtr->KeyPtr->KeyString,
                    DestObPtr->ValueName
                    ));
                rc = ERROR_SUCCESS;
            }

        } else {
            rc = ERROR_SUCCESS;
        }

        if (rc != ERROR_SUCCESS) {
            SetLastError (rc);
            LOG ((LOG_ERROR, "Failed to set a registry value (%s [%s])", DestObPtr->KeyPtr->KeyString, DestObPtr->ValueName));
            return FALSE;
        }

        return TRUE;
    }

    DEBUGMSG ((DBG_WHOOPS, "Write Object: Object type (%Xh) is not supported", DestObPtr->ObjectType));
    return FALSE;
}


FILTERRETURN
CopySingleObject (
    IN OUT  PDATAOBJECT SrcObPtr,
    IN OUT  PDATAOBJECT DestObPtr,
    IN      FILTERFUNCTION FilterFn,    OPTIONAL
    IN      PVOID FilterArg            OPTIONAL
    )
{
    FILTERRETURN fr = FILTER_RETURN_FAIL;
    DATAOBJECT TempOb;

    if (!ReadObject (SrcObPtr)) {
        if (GetLastError() == ERROR_FILE_NOT_FOUND) {
            fr = FILTER_RETURN_CONTINUE;
        }
        else {
            DEBUGMSG ((DBG_ERROR, "CopySingleObject: Cannot read object %s", DebugEncoder (SrcObPtr)));
        }

        return fr;
    }

    if (FilterFn) {
        fr = FilterFn (SrcObPtr, DestObPtr, FILTER_VALUE_COPY, FilterArg);
        if (fr != FILTER_RETURN_CONTINUE) {

            // handled means skip copy but don't stop enum
            if (fr == FILTER_RETURN_HANDLED) {
                fr = FILTER_RETURN_CONTINUE;
            }

            // Debug version tells us when a filter failed
            DEBUGMSG_IF ((fr == FILTER_RETURN_FAIL, DBG_VERBOSE, "CopySingleObject failed because filter function FILTER_VALUE_COPY failed"));

            return fr;
        }
    }

    //
    // Temporarily transfer SrcOb's value, value type and to DestOb
    //
    CopyMemory (&TempOb, DestObPtr, sizeof (DATAOBJECT));

    DestObPtr->ObjectType  |= SrcObPtr->ObjectType & (OT_VALUE|OT_REGISTRY_TYPE|OT_REGISTRY_CLASS);
    DestObPtr->Value.Buffer = SrcObPtr->Value.Buffer;
    DestObPtr->Value.Size   = SrcObPtr->Value.Size;
    DestObPtr->Class.Buffer = SrcObPtr->Class.Buffer;
    DestObPtr->Class.Size   = SrcObPtr->Class.Size;
    DestObPtr->Type         = SrcObPtr->Type;

    //
    // Write the dest ob
    //

    if (WriteObject (DestObPtr)) {
        fr = FILTER_RETURN_CONTINUE;
    } else {
        DEBUGMSG ((DBG_ERROR, "CopySingleObject: Cannot write object %s", DebugEncoder (DestObPtr)));
    }

    //
    // Restore the dest ob
    //

    CopyMemory (DestObPtr, &TempOb, sizeof (DATAOBJECT));

    return fr;
}


FILTERRETURN
NextSubObjectEnum (
    IN   PDATAOBJECT RootSrcObPtr,
    IN   PDATAOBJECT RootDestObPtr, OPTIONAL
    OUT  PDATAOBJECT SubSrcObPtr,
    OUT  PDATAOBJECT SubDestObPtr,
    IN   FILTERFUNCTION FilterFn,   OPTIONAL
    IN   PVOID FilterArg           OPTIONAL
    )
{
    DWORD rc;
    FILTERRETURN fr = FILTER_RETURN_FAIL;
    PTSTR NewKey;
    TCHAR KeyNameBuf[MAX_REGISTRY_KEY];
    DWORD KeyNameBufSize;
    TCHAR ClassBuf[MAX_CLASS_SIZE];
    DWORD ClassBufSize;
    FILETIME DontCare;
    BOOL CreatedSubOb = FALSE;

    if (IsObjectRegistryKeyOnly (RootSrcObPtr)) {
        do {
            MYASSERT (RootSrcObPtr->KeyPtr->OpenKey);
            KeyNameBufSize = MAX_REGISTRY_KEY;
            ClassBufSize = MAX_CLASS_SIZE;
            fr = FILTER_RETURN_FAIL;

            //
            // Enumerate the next sub object
            //

            if (IsWin95Object (RootSrcObPtr)) {
                rc = Win95RegEnumKey (
                        RootSrcObPtr->KeyPtr->OpenKey,
                        RootSrcObPtr->KeyEnum,
                        KeyNameBuf,
                        KeyNameBufSize
                        );

                ClassBufSize = 0;
            } else {
                rc = WinNTRegEnumKeyEx (
                        RootSrcObPtr->KeyPtr->OpenKey,
                        RootSrcObPtr->KeyEnum,
                        KeyNameBuf,
                        &KeyNameBufSize,
                        NULL,               // reserved
                        ClassBuf,
                        &ClassBufSize,
                        &DontCare           // last write time
                        );

                if (rc == ERROR_ACCESS_DENIED) {
                    LOG ((
                        LOG_INFORMATION,
                        "Access denied for enumeration of %s",
                        RootSrcObPtr->KeyPtr->KeyString
                        ));
                    rc = ERROR_NO_MORE_ITEMS;
                }

            }

            if (rc != ERROR_SUCCESS) {
                SetLastError (rc);
                if (rc == ERROR_NO_MORE_ITEMS) {
                    fr = FILTER_RETURN_DONE;
                }

                return fr;
            }

            //
            // Create sub source object
            //

            CreatedSubOb = TRUE;

            ZeroMemory (SubSrcObPtr, sizeof (DATAOBJECT));
            SubSrcObPtr->ObjectType = RootSrcObPtr->ObjectType & (OT_WIN95|OT_TREE);
            SubSrcObPtr->RootItem = RootSrcObPtr->RootItem;
            SubSrcObPtr->ParentKeyPtr = RootSrcObPtr->KeyPtr;
            pIncKeyPropUse (SubSrcObPtr->ParentKeyPtr);

            MYASSERT (KeyNameBuf && *KeyNameBuf);

            NewKey = JoinPaths (RootSrcObPtr->KeyPtr->KeyString, KeyNameBuf);
            SetRegistryKey (SubSrcObPtr, NewKey);
            FreePathString (NewKey);

            SubSrcObPtr->ChildKey = _tcsrchr (SubSrcObPtr->KeyPtr->KeyString, TEXT('\\'));
            if (SubSrcObPtr->ChildKey) {
                SubSrcObPtr->ChildKey = _tcsinc (SubSrcObPtr->ChildKey);
            } else {
                SubSrcObPtr->ChildKey = SubSrcObPtr->KeyPtr->KeyString;
            }

#if CLASS_FIELD_ENABLED
            SetRegistryClass (SubSrcObPtr, ClassBuf, ClassBufSize);
#endif

            //
            // Create sub dest object
            //

            ZeroMemory (SubDestObPtr, sizeof (DATAOBJECT));
            if (RootDestObPtr) {
                SubDestObPtr->ObjectType = RootDestObPtr->ObjectType & OT_TREE;
                SubDestObPtr->RootItem = RootDestObPtr->RootItem;
                SubDestObPtr->ParentKeyPtr = RootDestObPtr->KeyPtr;
                pIncKeyPropUse (SubDestObPtr->ParentKeyPtr);

                // let's convert KeyNameBuf if it's a path and the path changed
                ConvertWin9xCmdLine (KeyNameBuf, DEBUGENCODER(SubDestObPtr), NULL);

                NewKey = JoinPaths (RootDestObPtr->KeyPtr->KeyString, KeyNameBuf);
                SetRegistryKey (SubDestObPtr, NewKey);
                FreePathString (NewKey);

                SubDestObPtr->ChildKey = _tcsrchr (SubDestObPtr->KeyPtr->KeyString, TEXT('\\'));
                if (SubDestObPtr->ChildKey) {
                    SubDestObPtr->ChildKey = _tcsinc (SubDestObPtr->ChildKey);
                } else {
                    SubDestObPtr->ChildKey = SubDestObPtr->KeyPtr->KeyString;
                }

#if CLASS_FIELD_ENABLED
                SetRegistryClass (SubDestObPtr, ClassBuf, ClassBufSize);
#endif
            }

            if (FilterFn) {
                fr = FilterFn (
                        SubSrcObPtr,
                        RootDestObPtr ? SubDestObPtr : NULL,
                        FILTER_KEY_ENUM,
                        FilterArg
                        );

                if (fr == FILTER_RETURN_DELETED) {
                    CreatedSubOb = FALSE;
                    FreeObjectStruct (SubSrcObPtr);
                    FreeObjectStruct (SubDestObPtr);
                }

                // Debug version tells us when a filter fails
                DEBUGMSG_IF ((
                    fr == FILTER_RETURN_FAIL,
                    DBG_VERBOSE,
                    "NextSubObjectEnum failed because filter function FILTER_KEY_ENUM failed"
                    ));

            } else {
                fr = FILTER_RETURN_CONTINUE;
            }
        } while (fr == FILTER_RETURN_DELETED);

        RootSrcObPtr->KeyEnum += 1;
    }

    if (fr != FILTER_RETURN_CONTINUE && fr != FILTER_RETURN_HANDLED) {
        if (CreatedSubOb) {
            FreeObjectStruct (SubSrcObPtr);
            FreeObjectStruct (SubDestObPtr);
        }
    }

    return fr;
}


BOOL
BeginSubObjectEnum (
    IN   PDATAOBJECT RootSrcObPtr,
    IN   PDATAOBJECT RootDestObPtr, OPTIONAL
    OUT  PDATAOBJECT SubSrcObPtr,
    OUT  PDATAOBJECT SubDestObPtr,
    IN   FILTERFUNCTION FilterFn,   OPTIONAL
    IN   PVOID FilterArg           OPTIONAL
    )
{
    if (IsObjectRegistryKeyOnly (RootSrcObPtr)) {
        // Open key if necessary
        if (!OpenObject (RootSrcObPtr)) {
            if (GetLastError() == ERROR_FILE_NOT_FOUND) {
                return FILTER_RETURN_DONE;
            }
            DEBUGMSG ((DBG_WARNING, "BeginSubObjectEnum: Can't open %s", DebugEncoder (RootSrcObPtr)));
            return FILTER_RETURN_FAIL;
        }

        RootSrcObPtr->KeyEnum = 0;

        return NextSubObjectEnum (RootSrcObPtr, RootDestObPtr, SubSrcObPtr, SubDestObPtr, FilterFn, FilterArg);
    }

    // Other object types do not have sub objects
    DEBUGMSG ((DBG_WARNING, "BeginSubObjectEnum: Trying to enumerate unknown object"));
    return FILTER_RETURN_FAIL;
}


FILTERRETURN
NextValueNameEnum (
    IN      PDATAOBJECT RootSrcObPtr,
    IN      PDATAOBJECT RootDestObPtr,      OPTIONAL
    OUT     PDATAOBJECT ValSrcObPtr,
    OUT     PDATAOBJECT ValDestObPtr,
    IN      FILTERFUNCTION FilterFn,        OPTIONAL
    IN      PVOID FilterArg                OPTIONAL
    )
{
    DWORD rc;
    FILTERRETURN fr = FILTER_RETURN_FAIL;
    TCHAR ValNameBuf[MAX_REGISTRY_VALUE_NAME];
    DWORD ValNameBufSize = MAX_REGISTRY_VALUE_NAME;
    BOOL CreatedValOb = FALSE;

    if (IsObjectRegistryKeyOnly (RootSrcObPtr)) {
        MYASSERT (IsRegistryKeyOpen (RootSrcObPtr));

        if (IsWin95Object (RootSrcObPtr)) {
            rc = Win95RegEnumValue (
                    RootSrcObPtr->KeyPtr->OpenKey,
                    RootSrcObPtr->ValNameEnum,
                    ValNameBuf,
                    &ValNameBufSize,
                    NULL,               // reserved
                    NULL,               // type ptr
                    NULL,               // value data ptr
                    NULL                // value data size ptr
                    );
        } else {
            rc = WinNTRegEnumValue (
                    RootSrcObPtr->KeyPtr->OpenKey,
                    RootSrcObPtr->ValNameEnum,
                    ValNameBuf,
                    &ValNameBufSize,
                    NULL,               // reserved
                    NULL,               // type ptr
                    NULL,               // value data ptr
                    NULL                // value data size ptr
                    );

            if (rc == ERROR_ACCESS_DENIED) {
                LOG ((
                    LOG_INFORMATION,
                    "Access denied for enumeration of values in %s",
                    RootSrcObPtr->KeyPtr->KeyString
                    ));
                rc = ERROR_NO_MORE_ITEMS;
            }
        }

        if (rc != ERROR_SUCCESS) {
            SetLastError (rc);
            if (rc == ERROR_NO_MORE_ITEMS) {
                fr = FILTER_RETURN_DONE;
            } else {
                LOG ((LOG_ERROR, "Failed to enumerate a registry value"));
            }

            return fr;
        }

        //
        // Create src value object
        //

        CreatedValOb = TRUE;
        ZeroMemory (ValSrcObPtr, sizeof (DATAOBJECT));

        ValSrcObPtr->ObjectType = RootSrcObPtr->ObjectType & OT_WIN95;      // (OT_WIN95|OT_TREE) removed
        ValSrcObPtr->RootItem = RootSrcObPtr->RootItem;
        ValSrcObPtr->ParentKeyPtr = RootSrcObPtr->KeyPtr;
        pIncKeyPropUse (ValSrcObPtr->ParentKeyPtr);
        ValSrcObPtr->KeyPtr = RootSrcObPtr->KeyPtr;
        pIncKeyPropUse (ValSrcObPtr->KeyPtr);

        if (rc == ERROR_SUCCESS) {
            SetRegistryValueName (ValSrcObPtr, ValNameBuf);
        } else {
            SetRegistryValueName (ValSrcObPtr, TEXT(""));
        }

        //
        // Create dest value object
        //

        CreatedValOb = TRUE;
        ZeroMemory (ValDestObPtr, sizeof (DATAOBJECT));
        if (RootDestObPtr) {
            ValDestObPtr->RootItem = RootDestObPtr->RootItem;
            ValDestObPtr->ParentKeyPtr = RootDestObPtr->KeyPtr;
            pIncKeyPropUse (ValDestObPtr->ParentKeyPtr);
            ValDestObPtr->KeyPtr = RootDestObPtr->KeyPtr;
            pIncKeyPropUse (ValDestObPtr->KeyPtr);

            // let's convert ValNameBuf if it's a path and the path changed
            ConvertWin9xCmdLine (ValNameBuf, DEBUGENCODER(ValDestObPtr), NULL);

            if (rc == ERROR_SUCCESS) {
                SetRegistryValueName (ValDestObPtr, ValNameBuf);
            } else {
                SetRegistryValueName (ValDestObPtr, TEXT(""));
            }
        }

        if (FilterFn) {
            fr = FilterFn (
                    ValSrcObPtr,
                    RootDestObPtr ? ValDestObPtr : NULL,
                    FILTER_VALUENAME_ENUM,
                    FilterArg
                    );

            // Debug version tells us when a filter fails
            DEBUGMSG_IF ((fr == FILTER_RETURN_FAIL, DBG_VERBOSE, "NextValueNameEnum failed because filter function FILTER_VALUENAME_ENUM failed"));

        } else {
            fr = FILTER_RETURN_CONTINUE;
        }

        RootSrcObPtr->ValNameEnum += 1;
    }

    if (fr != FILTER_RETURN_CONTINUE && fr != FILTER_RETURN_HANDLED) {
        if (CreatedValOb) {
            FreeObjectStruct (ValSrcObPtr);
            FreeObjectStruct (ValDestObPtr);
        }
    }

    return fr;
}


FILTERRETURN
BeginValueNameEnum (
    IN      PDATAOBJECT RootSrcObPtr,
    IN      PDATAOBJECT RootDestObPtr,  OPTIONAL
    OUT     PDATAOBJECT ValSrcObPtr,
    OUT     PDATAOBJECT ValDestObPtr,
    IN      FILTERFUNCTION FilterFn,    OPTIONAL
    IN      PVOID FilterArg            OPTIONAL
    )
{
    if (IsObjectRegistryKeyOnly (RootSrcObPtr)) {
        // Open key if necessary
        if (!OpenObject (RootSrcObPtr)) {
            if (GetLastError() == ERROR_FILE_NOT_FOUND) {
                return FILTER_RETURN_DONE;
            }
            DEBUGMSG ((DBG_WARNING, "BeginValueNameEnum: Can't open %s", DebugEncoder (RootSrcObPtr)));
            return FILTER_RETURN_FAIL;
        }

        RootSrcObPtr->ValNameEnum = 0;

        return NextValueNameEnum (RootSrcObPtr, RootDestObPtr, ValSrcObPtr, ValDestObPtr, FilterFn, FilterArg);
    }

    // Other object types do not have sub objects
    DEBUGMSG ((DBG_WARNING, "BeginValueNameEnum: Trying to enumerate unknown object"));
    return FILTER_RETURN_FAIL;
}


FILTERRETURN
CopyObject (
    IN   PDATAOBJECT SrcObPtr,
    IN   CPDATAOBJECT DestObPtr,        OPTIONAL
    IN   FILTERFUNCTION FilterFn,       OPTIONAL
    IN   PVOID FilterArg                OPTIONAL
    )
{
    DATAOBJECT ChildOb, ChildDestOb;
    FILTERRETURN fr = FILTER_RETURN_FAIL;
    BOOL suppressKey = FALSE;

    //
    // Progress bar update
    //
    g_ProgressBarCounter++;
    if (g_ProgressBarCounter >= REGMERGE_TICK_THRESHOLD) {
        g_ProgressBarCounter = 0;
        TickProgressBar ();
    }

    //
    // Tree copy
    //
    if (SrcObPtr->ObjectType & OT_TREE) {
        if (DestObPtr) {
#ifdef DEBUG
            //
            // Verify destination does not specify value but does specify key
            //

            if (!IsObjectRegistryKeyOnly (DestObPtr)) {
                DEBUGMSG ((
                    DBG_WHOOPS,
                    "CopyObject: Destination invalid for copy %s tree",
                    DebugEncoder (SrcObPtr)
                    ));

                return FILTER_RETURN_FAIL;
            }
#endif

            // The source object cannot specify a registry value either
            MYASSERT (!(SrcObPtr->ValueName));

#ifndef VAR_PROGRESS_BAR
            //
            // Progress bar update
            //
            g_ProgressBarCounter++;
            if (g_ProgressBarCounter >= REGMERGE_TICK_THRESHOLD) {
                g_ProgressBarCounter = 0;
                TickProgressBarDelta (1);
            }
#endif
            //
            // Ask the filter if it wants to create the key unconditionally
            //

            if (FilterFn) {

                //
                // suppressKey should never be set if filterFn exists.
                //
                MYASSERT (!suppressKey)

                fr = FilterFn (SrcObPtr, DestObPtr, FILTER_CREATE_KEY, FilterArg);

                if (fr == FILTER_RETURN_FAIL || fr == FILTER_RETURN_DONE) {

                    // The done at the key create does not really mean end the whole copy!
                    if (fr == FILTER_RETURN_DONE) {
                        fr = FILTER_RETURN_CONTINUE;
                    }

                    return fr;
                }

            } else {

                //
                // Check to see if the win9x object actually exists. If not,
                // we'll pass on FILTER_RETURN_DONE. We don't want to get
                // empty keys created on nt where no keys existed on win9x.
                //

                if (!OpenObject (SrcObPtr)) {

                    suppressKey = TRUE;
                    fr = FILTER_RETURN_HANDLED;
                }
                else {

                    fr = FILTER_RETURN_CONTINUE;
                }
            }

            if (fr == FILTER_RETURN_CONTINUE) {

                if (!CreateObject (DestObPtr)) {

                    if (GetLastError() == ERROR_SUCCESS) {
                        //
                        // CreateObject failed but because the last error was
                        // ERROR_SUCCESS, we skip this registry node and continue
                        // processing as if the error didn't occur.
                        //

                        return FILTER_RETURN_CONTINUE;
                    }
                    else {

                        DEBUGMSG ((DBG_WARNING,
                                   "CopyObject: CreateObject failed to create %s",
                                   DebugEncoder (DestObPtr)
                                 ));
                        return FILTER_RETURN_FAIL;
                    }
                }

            }
        }

        //
        // Copy all values (call CopyObject recursively)
        //

        SrcObPtr->ObjectType &= ~(OT_TREE);

        if (FilterFn) {

            //
            // suppress key should never be set if there is a FilterFn.
            //
            MYASSERT (!suppressKey)

            fr = FilterFn (SrcObPtr, DestObPtr, FILTER_PROCESS_VALUES, FilterArg);

            // Debug version tells us that the filter failed
            DEBUGMSG_IF ((fr == FILTER_RETURN_FAIL, DBG_VERBOSE, "CopyObject failed because filter function FILTER_PROCESS_VALUES failed"));

            if (fr == FILTER_RETURN_FAIL || fr == FILTER_RETURN_DONE) {
                DEBUGMSG ((DBG_VERBOSE, "CopyObject is exiting"));
                SrcObPtr->ObjectType |= OT_TREE;
                return fr;
            }
        } else {
            fr = suppressKey ? FILTER_RETURN_HANDLED : FILTER_RETURN_CONTINUE;
        }

        //
        // Skip copy of key's values if FilterFn returned FILTER_RETURN_HANDLED
        //

        if (fr == FILTER_RETURN_CONTINUE) {
            fr = CopyObject (SrcObPtr, DestObPtr, FilterFn, FilterArg);

            SrcObPtr->ObjectType |= OT_TREE;
            if (fr != FILTER_RETURN_CONTINUE) {
                return fr;
            }
        } else {
            SrcObPtr->ObjectType |= OT_TREE;
        }

        //
        // Enumerate all child objects and process them recursively
        //

        fr = BeginSubObjectEnum (
                    SrcObPtr,
                    DestObPtr,
                    &ChildOb,
                    &ChildDestOb,
                    FilterFn,
                    FilterArg
                    );

        while (fr == FILTER_RETURN_CONTINUE || fr == FILTER_RETURN_HANDLED) {

            if (fr == FILTER_RETURN_CONTINUE) {
                fr = CopyObject (
                            &ChildOb,
                            DestObPtr ? &ChildDestOb : NULL,
                            FilterFn,
                            FilterArg
                            );
            } else {
                fr = FILTER_RETURN_CONTINUE;
            }

            FreeObjectStruct (&ChildOb);
            FreeObjectStruct (&ChildDestOb);

            if (fr != FILTER_RETURN_CONTINUE) {
                return fr;
            }

            fr = NextSubObjectEnum (
                        SrcObPtr,
                        DestObPtr,
                        &ChildOb,
                        &ChildDestOb,
                        FilterFn,
                        FilterArg
                        );
        }

        // The end of enum does not really mean end the copy!
        if (fr == FILTER_RETURN_DONE) {
            fr = FILTER_RETURN_CONTINUE;
        }

        DEBUGMSG_IF ((fr == FILTER_RETURN_FAIL, DBG_VERBOSE,
                     "CopyObject: Filter in subob enum failed"));
    }

    //
    // Copy all values of a key
    //

    else if (IsObjectRegistryKeyOnly (SrcObPtr)) {

#ifdef DEBUG
        if (DestObPtr) {
            //
            // Verify destination does not specify value but does specify key
            //

            if (!IsObjectRegistryKeyOnly (DestObPtr)) {
                DEBUGMSG ((
                    DBG_WHOOPS,
                    "CopyObject: Destination (%s) invalid for copy values in %s",
                    DebugEncoder (DestObPtr),
                    DebugEncoder (SrcObPtr)
                    ));

                return fr;
            }
        }
#endif

        //
        // Enumerate all values in the key
        //

        fr = BeginValueNameEnum (
                    SrcObPtr,
                    DestObPtr,
                    &ChildOb,
                    &ChildDestOb,
                    FilterFn,
                    FilterArg
                    );

        if (fr == FILTER_RETURN_DONE) {
            //
            // No values in this key.  Make sure DestObPtr is created.
            //

            if (DestObPtr && !suppressKey) {
                if (!CreateObject (DestObPtr)) {
                    DEBUGMSG ((DBG_WARNING, "CopyObject: Could not create %s (type %x)",
                              DebugEncoder (DestObPtr), DestObPtr->ObjectType));
                }
            }
        } else {
            //
            // For each value, call CopySingleObject
            //

            while (fr == FILTER_RETURN_CONTINUE || fr == FILTER_RETURN_HANDLED) {

                if (fr == FILTER_RETURN_CONTINUE && DestObPtr) {
                    fr = CopySingleObject (&ChildOb, &ChildDestOb, FilterFn, FilterArg);
                } else {
                    fr = FILTER_RETURN_CONTINUE;
                }

                FreeObjectStruct (&ChildOb);
                FreeObjectStruct (&ChildDestOb);

                if (fr != FILTER_RETURN_CONTINUE) {
                    DEBUGMSG ((DBG_VERBOSE, "CopyObject failed because CopySingleObject failed"));
                    return fr;
                }

                fr = NextValueNameEnum (
                            SrcObPtr,
                            DestObPtr,
                            &ChildOb,
                            &ChildDestOb,
                            FilterFn,
                            FilterArg
                            );
            }
        }

        // The end of enum does not really mean end the copy!
        if (fr == FILTER_RETURN_DONE) {
            fr = FILTER_RETURN_CONTINUE;
        }

        DEBUGMSG_IF ((fr == FILTER_RETURN_FAIL, DBG_VERBOSE,
                    "CopyObject: Filter in val enum failed"));
    }

    //
    // One value copy
    //

    else if (IsObjectRegistryKeyAndVal (SrcObPtr)) {

#ifdef DEBUG
        if (DestObPtr) {
            //
            // BUGBUG -- what is this used for?
            //

            if (!(DestObPtr->ValueName)) {
                if (!SetRegistryValueName (DestObPtr, SrcObPtr->ValueName)) {
                    DEBUGMSG ((DBG_VERBOSE, "CopyObject failed because SetRegistryValueName failed"));
                    return fr;
                }
            }
        }
#endif

        if (DestObPtr) {
            fr = CopySingleObject (SrcObPtr, DestObPtr, FilterFn, FilterArg);
        }

        DEBUGMSG_IF ((fr == FILTER_RETURN_FAIL, DBG_VERBOSE,
                     "CopyObject: Filter in CopySingleObject failed"));
    }

    //
    // Other object coping not supported
    //
    else {
        DEBUGMSG ((
            DBG_WHOOPS,
            "CopyObject: Don't know how to copy object %s",
            DebugEncoder (SrcObPtr)
            ));
    }

    return fr;
}


VOID
FreeRegistryKey (
    PDATAOBJECT p
    )
{
    if (p->KeyPtr && (p->ObjectType & OT_REGISTRY)) {
        pFreeKeyProps (p->KeyPtr);
        p->KeyPtr = NULL;
    }
}

VOID
FreeRegistryParentKey (
    PDATAOBJECT p
    )
{
    if (p->ParentKeyPtr && (p->ObjectType & OT_REGISTRY)) {
        pFreeKeyProps (p->ParentKeyPtr);
        p->ParentKeyPtr = NULL;
    }
}

BOOL
SetRegistryKey (
    PDATAOBJECT p,
    PCTSTR Key
    )
{
    FreeRegistryKey (p);

    p->KeyPtr = pCreateKeyPropsFromString (Key, IsWin95Object (p));
    if (!p->KeyPtr) {
        DEBUGMSG ((DBG_WARNING, "SetRegistryKey failed to create KEYPROPS struct"));
        return FALSE;
    }

    p->ObjectType |= OT_REGISTRY;
    return TRUE;
}


VOID
FreeRegistryValueName (
    PDATAOBJECT p
    )
{
    if (p->ValueName && p->ObjectType & OT_REGISTRY) {
        PoolMemReleaseMemory (g_TempPool, (PVOID) p->ValueName);
        p->ValueName = NULL;
    }
}


BOOL
SetRegistryValueName (
    PDATAOBJECT p,
    PCTSTR ValueName
    )
{
    FreeRegistryValueName (p);
    p->ValueName = PoolMemDuplicateString (g_TempPool, ValueName);
    if (!p->ValueName) {
        DEBUGMSG ((DBG_WARNING, "SetRegistryValueName failed to duplicate string"));
        return FALSE;
    }

    p->ObjectType |= OT_REGISTRY;

    return TRUE;
}


BOOL
SetRegistryClass (
    PDATAOBJECT p,
    PBYTE Class,
    DWORD ClassSize
    )
{
    FreeRegistryClass (p);

    p->Class.Buffer = PoolMemGetAlignedMemory (g_TempPool, ClassSize);
    if (p->Class.Buffer) {
        p->ObjectType |= OT_REGISTRY_CLASS|OT_REGISTRY;
        p->Class.Size = ClassSize;
        if (ClassSize) {
            CopyMemory (p->Class.Buffer, Class, ClassSize);
        }
    } else {
        p->ObjectType &= ~OT_REGISTRY_CLASS;
        DEBUGMSG ((DBG_WARNING, "SetRegistryClass failed to duplicate string"));
        return FALSE;
    }

    return TRUE;
}

VOID
FreeRegistryClass (
    PDATAOBJECT p
    )
{
    if (p->ObjectType & OT_REGISTRY_CLASS) {
        PoolMemReleaseMemory (g_TempPool, (PVOID) p->Class.Buffer);
        p->ObjectType &= ~OT_REGISTRY_CLASS;
    }
}

VOID
SetRegistryType (
    PDATAOBJECT p,
    DWORD Type
    )
{
    p->Type = Type;
    p->ObjectType |= OT_REGISTRY_TYPE|OT_REGISTRY;
}

BOOL
SetPlatformType (
    PDATAOBJECT p,
    BOOL Win95Type
    )
{
    if (Win95Type != IsWin95Object (p)) {
        //
        // We need to close the other platform valid handle. Otherwise
        // all subsequent operations will fail because we will try to
        // use an valid handle for a wrong platform.
        //
        CloseObject (p);

        // key type is changing to be the opposite platform,
        // so we have to create a duplicate key struct
        // (except for the platform being different)
        if (p->KeyPtr) {
            p->KeyPtr = pCreateDuplicateKeyProps (p->KeyPtr, Win95Type);
            if (!p->KeyPtr) {
                return FALSE;
            }
        }

        if (Win95Type) {
            p->ObjectType |= OT_WIN95;
        } else {
            p->ObjectType &= ~OT_WIN95;
        }

        FreeRegistryParentKey (p);
    }

    return TRUE;
}


BOOL
ReadWin95ObjectString (
    PCTSTR ObjectStr,
    PDATAOBJECT ObPtr
    )
{
    LONG rc = ERROR_INVALID_NAME;
    BOOL b = FALSE;

    if (!CreateObjectStruct (ObjectStr, ObPtr, WIN95OBJECT)) {
        rc = GetLastError();
        DEBUGMSG ((DBG_ERROR, "Read Win95 Object String: %s is invalid", ObjectStr));
        goto c0;
    }

    if (!ReadObject (ObPtr)) {
        rc = GetLastError();
        if (rc == ERROR_FILE_NOT_FOUND || rc == ERROR_BADKEY) {
            rc = ERROR_SUCCESS;
            DEBUGMSG ((DBG_WARNING, "ReadWin95ObjectString: %s does not exist", ObjectStr));
        }

        FreeObjectStruct (ObPtr);
    } else {
        b = TRUE;
    }

c0:
    if (!b) {
        SetLastError (rc);
    }

    return b;
}


BOOL
WriteWinNTObjectString (
    PCTSTR ObjectStr,
    CPDATAOBJECT SrcObPtr
    )
{
    DATAOBJECT DestOb, TempOb;
    BOOL b = FALSE;

    //
    // 1. Create TempOb from destination object string
    // 2. Copy SrcObPtr to DestOb
    // 3. Override DestOb with any setting in TempOb
    //

    if (!CreateObjectStruct (ObjectStr, &TempOb, WINNTOBJECT)) {
        DEBUGMSG ((DBG_ERROR, "WriteWinNTObjectString: %s struct cannot be created", ObjectStr));
        goto c0;
    }

    if (!DuplicateObjectStruct (&DestOb, SrcObPtr)) {
        goto c1;
    }

    if (!CombineObjectStructs (&DestOb, &TempOb)) {
        goto c2;
    }

    MYASSERT (!(DestOb.ObjectType & OT_VALUE));
    MYASSERT (SrcObPtr->ObjectType & OT_VALUE);

    if (SrcObPtr->ObjectType & OT_REGISTRY_TYPE) {
        DestOb.ObjectType |= OT_REGISTRY_TYPE;
        DestOb.Type = SrcObPtr->Type;
    }

    ReplaceValue (&DestOb, SrcObPtr->Value.Buffer, SrcObPtr->Value.Size);

    if (!WriteObject (&DestOb)) {
        DEBUGMSG ((DBG_ERROR, "WriteWinNTObjectString: %s cannot be written", ObjectStr));
        goto c2;
    }

    b = TRUE;

c2:
    FreeObjectStruct (&DestOb);


c1:
    FreeObjectStruct (&TempOb);

c0:
    return b;
}


BOOL
ReplaceValue (
    PDATAOBJECT ObPtr,
    PBYTE NewValue,
    DWORD Size
    )
{
    FreeObjectVal (ObPtr);
    if (!AllocObjectVal (ObPtr, NewValue, Size, Size)) {
        return FALSE;
    }

    // Fix REG_SZ or REG_EXPAND_SZ
    pFixRegSzTermination (ObPtr);

    return TRUE;
}


BOOL
GetDwordFromObject (
    CPDATAOBJECT ObPtr,
    PDWORD DwordPtr            OPTIONAL
    )
{
    DWORD d;

    if (DwordPtr) {
        *DwordPtr = 0;
    }

    if (!(ObPtr->ObjectType & OT_VALUE)) {
        if (!ReadObject (ObPtr)) {
            return FALSE;
        }
    }

    if (!(ObPtr->ObjectType & OT_REGISTRY_TYPE)) {
        return FALSE;
    }

    if (ObPtr->Type == REG_SZ) {

        d =  _tcstoul ((PCTSTR) ObPtr->Value.Buffer, NULL, 10);

    } else if (
            ObPtr->Type == REG_BINARY ||
            ObPtr->Type == REG_NONE ||
            ObPtr->Type == REG_DWORD
            ) {

        if (ObPtr->Value.Size != sizeof (DWORD)) {
            DEBUGMSG ((DBG_NAUSEA, "GetDwordFromObject: Value size is %u", ObPtr->Value.Size));
            return FALSE;
        }

        d = *((PDWORD) ObPtr->Value.Buffer);

    } else {
        return FALSE;
    }

    if (DwordPtr) {
        *DwordPtr = d;
    }

    return TRUE;
}


PCTSTR
GetStringFromObject (
    CPDATAOBJECT ObPtr
    )
{
    PTSTR result;
    PTSTR resultPtr;
    UINT i;

    if (!(ObPtr->ObjectType & OT_VALUE)) {
        if (!ReadObject (ObPtr)) {
            return NULL;
        }
    }

    if (!(ObPtr->ObjectType & OT_REGISTRY_TYPE)) {
        return NULL;
    }

    if (ObPtr->Type == REG_SZ) {
        result = AllocPathString (ObPtr->Value.Size);
        _tcssafecpy (result, (PCTSTR) ObPtr->Value.Buffer, ObPtr->Value.Size / sizeof (TCHAR));
    }
    else if (ObPtr->Type == REG_DWORD) {
        result = AllocPathString (11);
        wsprintf (result, TEXT("%lu"), *((PDWORD) ObPtr->Value.Buffer));
    }
    else if (ObPtr->Type == REG_BINARY) {
        result = AllocPathString (ObPtr->Value.Size?(ObPtr->Value.Size * 3):1);
        resultPtr = result;
        *resultPtr = 0;
        for (i = 0; i < ObPtr->Value.Size; i++) {
            wsprintf (resultPtr, TEXT("%02X"), ObPtr->Value.Buffer[i]);
            resultPtr = GetEndOfString (resultPtr);
            if (i < ObPtr->Value.Size - 1) {
                _tcscat (resultPtr, TEXT(" "));
                resultPtr = GetEndOfString (resultPtr);
            }
        }
    } else {
        return NULL;
    }

    return result;

}


FILTERRETURN
pDeleteDataObjectFilter (
    IN  CPDATAOBJECT   SrcObjectPtr,
    IN  CPDATAOBJECT   UnusedObPtr,        OPTIONAL
    IN  FILTERTYPE     FilterType,
    IN  PVOID         UnusedArg           OPTIONAL
    )
{
    if (FilterType == FILTER_KEY_ENUM) {
        DeleteDataObject (SrcObjectPtr);
        return FILTER_RETURN_DELETED;
    }
    return FILTER_RETURN_HANDLED;
}

BOOL
DeleteDataObject (
    IN   PDATAOBJECT ObjectPtr
    )
{
    FILTERRETURN fr;
    DWORD rc;

    ObjectPtr->ObjectType |= OT_TREE;

    fr = CopyObject (ObjectPtr, NULL, pDeleteDataObjectFilter, NULL);
    if (fr != FILTER_RETURN_FAIL) {
        //
        // Perform deletion
        //

        if (ObjectPtr->KeyPtr) {
            CloseObject (ObjectPtr);

            if (IsWin95Object (ObjectPtr)) {
                DEBUGMSG ((DBG_WHOOPS, "CreateObject: Cannot delete a Win95 object (%s)", DebugEncoder (ObjectPtr)));
                return FALSE;
            }

            if (ObjectPtr->ParentKeyPtr && ObjectPtr->ParentKeyPtr->OpenKey && ObjectPtr->ChildKey) {
                rc = WinNTRegDeleteKey (
                            ObjectPtr->ParentKeyPtr->OpenKey,
                            ObjectPtr->ChildKey
                            );

                if (rc == ERROR_ACCESS_DENIED) {
                    LOG ((
                        LOG_INFORMATION,
                        "Access denied trying to delete %s in %s",
                        ObjectPtr->ChildKey,
                        ObjectPtr->ParentKeyPtr->KeyString
                        ));
                    rc = ERROR_SUCCESS;
                }

            } else {
                rc = WinNTRegDeleteKey (
                            pGetWinNTKey (GetRootKeyFromOffset (ObjectPtr->RootItem)),
                            ObjectPtr->KeyPtr->KeyString
                            );

                if (rc == ERROR_ACCESS_DENIED) {
                    LOG ((
                        LOG_INFORMATION,
                        "Access denied trying to delete %s",
                        ObjectPtr->KeyPtr->KeyString
                        ));
                    rc = ERROR_SUCCESS;
                }
            }

            if (rc != ERROR_SUCCESS) {
                SetLastError (rc);
                LOG ((LOG_ERROR, "Failed to delete registry key"));
                return FALSE;
            }
        }
    }

    return fr != FILTER_RETURN_FAIL;
}


BOOL
RenameDataObject (
    IN      CPDATAOBJECT SrcObPtr,
    IN      CPDATAOBJECT DestObPtr
    )
{
    FILTERRETURN fr;

    //
    // Copy source to destination
    //

    fr = CopyObject (SrcObPtr, DestObPtr, NULL, NULL);
    if (fr == FILTER_RETURN_FAIL) {
        DEBUGMSG ((DBG_ERROR, "Rename Object: Could not copy source to destination"));
        return FALSE;
    }

    //
    // Delete source
    //

    if (!DeleteDataObject (SrcObPtr)) {
        DEBUGMSG ((DBG_ERROR, "Rename Object: Could not delete destination"));
        return FALSE;
    }

    return TRUE;
}

BOOL
DeleteDataObjectValue(
    IN      CPDATAOBJECT ObPtr
    )
{
    HKEY hKey;
    BOOL bResult;
    HKEY Parent;
    LONG rc;

    if(!ObPtr || !IsObjectRegistryKeyAndVal(ObPtr)){
        MYASSERT(FALSE);
        return FALSE;
    }

    Parent = pGetWinNTKey (GetRootKeyFromOffset (ObPtr->RootItem));
    if(NON_ROOT_KEY (Parent)){
        MYASSERT(FALSE);
        return FALSE;
    }

    if(ERROR_SUCCESS != TrackedRegOpenKeyEx(Parent, ObPtr->KeyPtr->KeyString, 0, KEY_ALL_ACCESS, &hKey)){
        MYASSERT(FALSE);
        return FALSE;
    }

    rc = WinNTRegDeleteValue(hKey, ObPtr->ValueName);
    bResult = (rc == ERROR_SUCCESS);

    if (rc == ERROR_ACCESS_DENIED) {
        LOG ((
            LOG_INFORMATION,
            "Access denied trying to delete %s in %s",
            ObPtr->KeyPtr->KeyString,
            ObPtr->ValueName
            ));
        bResult = TRUE;
    }

    CloseRegKey(hKey);

    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\merge\hkcr.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    hkcr.c

Abstract:

    Implements routines that merge various HKCR settings.  Macro expansion
    list defines a list of merge routines that are called for a particular
    key.  A context ID and a set of flags allow control over when a merge
    routine is called.

    The flag set controls the type of enumeration the merge routine wants
    to be notified with.  It can be any of three values:

        MERGE_FLAG_KEY      - Called for the root key itself
        MERGE_FLAG_VALUE    - Called for each value in the root key
        MERGE_FLAG_SUBKEY   - Called for each subkey in the root key

    Recursion of MergeRegistryNode is used to copy parts of the tree.
    The context ID is defined in merge.h, and is expandable.  It is used
    to specify a context when making recursive calls.

    The order of processing of the merge routines is specified in the
    macro expansion list.  The default behavior if no routine chooses to
    handle a key is to copy without overwrite.

Author:

    Jim Schmidt (jimschm)       24-Mar-1998

Revision History:

    jimschm   23-Sep-1998   Updated for new flag bit size
    jimschm   27-Apr-1998   Added DefaultIcon preservation

--*/

#include "pch.h"
#include "mergep.h"

extern DWORD g_ProgressBarCounter;

#define MERGE_FLAG_KEY          0x0001
#define MERGE_FLAG_SUBKEY       0x0002
#define MERGE_FLAG_VALUE        0x0004
#define MERGE_ALL_FLAGS         0xFFFFFFFF

#define MERGE_FLAG_SUBKEYS_AND_VALUES   (MERGE_FLAG_SUBKEY|MERGE_FLAG_VALUE)
#define MERGE_FLAG_ALL                  (MERGE_FLAG_KEY|MERGE_FLAG_SUBKEY|MERGE_FLAG_VALUE)
#define MERGE_FLAG_ALL_KEYS             (MERGE_FLAG_KEY|MERGE_FLAG_SUBKEY)

#define MULTI_CONTEXT           ANY_CONTEXT


/*++

Macro Expansion List Description:

  HKCR_FUNCTION_LIST lists functions that are called to process HKCR
  registry data.  The functions are called in the order specified by
  the macro expansion list, and when none of the functions process
  the data, the last filter, pLastMergeRoutine, performs a copy-no-
  overwrite merge.

  Processing occurs in the following stages:

  1. Functions are called for the key itself
  2. Functions are called for each of the key's values
  3. Functions are called for each of the key's subkeys

Line Syntax:

   DEFMAC(FilterFn, ContextId, Flags)

Arguments:

   FilterFn - Specifies the name of the function.  This function is
              automatically prototyped as:

                MERGE_RESULT
                FilterFn (
                    PMERGE_STATE State
                    );

              The filter function uses the State structure to determine
              the context surrounding the registry data (i.e., where is
              it, what its parent is, what kind of data, etc.).  The
              function returns one of the following:

              MERGE_LEAVE - Processing of the current key is terminated.
              MERGE_BREAK - Processing breaks out of the loop.  If the
                            loop is a value enumeration, then processing
                            continues with the values.  If the loop is
                            a subkey enumeration, processing ends for
                            the key.
              MERGE_CONTINUE - Processing continues to the next item in
                               the enumeration.
              MERGE_NOP - The function did not process the data
              MERGE_ERROR - An error occurred processing the data.  The
                            error stops processing of HKCR.

    ContextId - Specifies the context the function is called in.  Specify
                ANY_CONTEXT or MULTI_CONTEXT to always be called.  The
                ContextId is specified by the caller of MergeRegistryNode.

                NOTE: If MULTI_CONTEXT is used, the function must examine
                      the ContextId member of State and return MERGE_NOP
                      if the context is not correct.

                      Always place ANY_CONTEXT and MULTI_CONTEXT definitions
                      at the end of the HKCR_FUNCTION_LIST definition.

    Flags - Specifies one or more of the following:

              MERGE_FLAG_KEY - Called for the key, before enumeration
              MERGE_FLAG_SUBKEY - Called for each subkey of the key
              MERGE_FLAG_VALUE - Called for each value of the key

            or a combined macro:

              MERGE_FLAG_SUBKEYS_AND_VALUES - Called for each subkey and each value
              MERGE_FLAG_ALL                - Called for the key, then each subkey
                                              and each value

Variables Generated From List:

    g_MergeRoutines

--*/


#define HKCR_FUNCTION_LIST                                                          \
        DEFMAC(pDetectRootKeyType, ROOT_BASE, MERGE_FLAG_SUBKEY)                    \
        DEFMAC(pFileExtensionMerge, ROOT_BASE, MERGE_FLAG_SUBKEY)                   \
        DEFMAC(pCopyClassId, CLSID_BASE, MERGE_FLAG_SUBKEY)                         \
        DEFMAC(pCopyClassIdWorker, CLSID_COPY, MERGE_FLAG_ALL_KEYS)                 \
        DEFMAC(pInstanceSpecialCase, CLSID_INSTANCE_COPY, MERGE_FLAG_ALL_KEYS)      \
        DEFMAC(pCopyTypeLibOrInterface, MULTI_CONTEXT, MERGE_FLAG_SUBKEY)           \
        DEFMAC(pCopyTypeLibVersion, TYPELIB_VERSION_COPY, MERGE_FLAG_SUBKEY)        \
        DEFMAC(pDefaultIconExtraction, COPY_DEFAULT_ICON, MERGE_FLAG_ALL)           \
        DEFMAC(pCopyDefaultValue, COPY_DEFAULT_VALUE, MERGE_FLAG_KEY)               \
        DEFMAC(pKeyCopyMerge, KEY_COPY, MERGE_FLAG_VALUE)                           \
        \
        DEFMAC(pDetectDefaultIconKey, ANY_CONTEXT, MERGE_FLAG_SUBKEY)               \
        DEFMAC(pEnsureShellDefaultValue, TREE_COPY_NO_OVERWRITE, MERGE_FLAG_SUBKEY) \
        DEFMAC(pTreeCopyMerge, MULTI_CONTEXT, MERGE_FLAG_ALL)                       \
        \
        DEFMAC(pLastMergeRoutine, MULTI_CONTEXT, MERGE_FLAG_SUBKEY)


//
// Simplification macros
//

#define CopyAllValues(state)                MergeValuesOfKey(state,KEY_COPY)
#define CopyAllSubKeyValues(state)          MergeValuesOfSubKey(state,KEY_COPY)
#define CopyEntireSubKey(state)             MergeSubKeyNode(state,TREE_COPY)
#define CopyEntireSubKeyNoOverwrite(state)  MergeSubKeyNode(state,TREE_COPY_NO_OVERWRITE)

//
// Define macro expansion list types
//

typedef struct {
    HKEY Key95;
    HKEY KeyNt;
    HKEY SubKey95;
    HKEY SubKeyNt;
    BOOL CloseKey95;
    BOOL CloseKeyNt;
    PCTSTR SubKeyName;
    PCTSTR FullKeyName;
    PCTSTR FullSubKeyName;
    PCTSTR ValueName;
    PBYTE ValueData;
    DWORD ValueDataSize;
    DWORD ValueDataType;
    MERGE_CONTEXT Context;
    DWORD MergeFlag;
    BOOL LockValue;
} MERGE_STATE, *PMERGE_STATE;

typedef enum {
    MERGE_LEAVE,
    MERGE_BREAK,
    MERGE_CONTINUE,
    MERGE_NOP,
    MERGE_ERROR
} MERGE_RESULT;

typedef MERGE_RESULT (MERGE_ROUTINE_PROTOTYPE) (PMERGE_STATE State);
typedef MERGE_ROUTINE_PROTOTYPE * MERGE_ROUTINE;

typedef struct {
    MERGE_ROUTINE fn;
    MERGE_CONTEXT Context;
    DWORD Flags;
} MERGE_ROUTINE_ATTRIBS, *PMERGE_ROUTINE_ATTRIBS;

//
// Declare function prototypes
//

#define DEFMAC(fn,id,flags)    MERGE_ROUTINE_PROTOTYPE fn;

HKCR_FUNCTION_LIST

#undef DEFMAC

//
// Create g_MergeRoutines array
//

#define DEFMAC(fn,id,flags)    {fn,id,flags},

MERGE_ROUTINE_ATTRIBS g_MergeRoutines[] = {

    HKCR_FUNCTION_LIST /* , */
    {NULL, 0, 0}
};

#undef DEFMAC

//
// Local prototypes
//

MERGE_RESULT
pCallMergeRoutines (
    IN OUT  PMERGE_STATE State,
    IN      DWORD MergeFlag
    );

BOOL
pMakeSureNtKeyExists (
    IN      PMERGE_STATE State
    );

BOOL
pMakeSureNtSubKeyExists (
    IN      PMERGE_STATE State
    );

//
// Globals
//

PBYTE g_MergeBuf;
UINT g_MergeBufUseCount;


//
// Implementation
//

BOOL
MergeRegistryNodeEx (
    IN      PCTSTR RootKey,
    IN      HKEY RootKey95,             OPTIONAL
    IN      HKEY RootKeyNt,             OPTIONAL
    IN      MERGE_CONTEXT Context,
    IN      DWORD RestrictionFlags
    )

/*++

Routine Description:

  MergeRegistryNode calls functions for the specified RootKey, all of its
  values and all of its subkeys.  The merge functions can at runtime decide
  how to process a key, and typically call this function recursively.  All
  registry data is passed through the merge data filter, and keys or values
  marked as suppressed are not processed.

Arguments:

  RootKey - Specifies the root key string, starting with either HKLM or HKR.

  RootKey95 - Specifies the 95-side root key; reduces the number of key open
              calls

  RootKeyNt - Specifies the NT-side root key; reduces the number of key open
              calls

  Context - Specifies a root ID constant that corresponds to RootKey.  This
            constant is used by the merge routines to determine the
            processing context.

  RestrictionFlags - Specifies MERGE_FLAG mask to restrict processing.  The
                     caller can therefore limit the enumerations and processing
                     to only values, only subkeys, only the key, or a combination
                     of the three.

Return Value:

  TRUE if processing was successful, or FALSE if one of the merge functiosn
  returned an error.

--*/

{
    REGKEY_ENUM ek;
    REGVALUE_ENUM ev;
    MERGE_STATE State;
    MERGE_RESULT Result = MERGE_NOP;

    ZeroMemory (&State, sizeof (MERGE_STATE));

    //
    // Do not process if key is suppressed
    //
    if (Is95RegKeyTreeSuppressed (RootKey)) {
        return TRUE;
    }

    //
    // Init State
    //

    ZeroMemory (&State, sizeof (State));
    State.Context = Context;

    //
    // If the NT registry key is suppressed, then we want to do a tree copy, regardless
    // of wether there is an NT value or not.
    //
    if (Context == TREE_COPY_NO_OVERWRITE && IsNtRegKeyTreeSuppressed (RootKey)) {

        DEBUGMSG ((DBG_VERBOSE, "The NT Value for %s will be overwritten because it is marked for suppression.", RootKey));
        State.Context = TREE_COPY;
    }

    if (RootKey95) {
        State.Key95 = RootKey95;
    } else {
        State.Key95 = OpenRegKeyStr95 (RootKey);
        State.CloseKey95 = (State.Key95 != NULL);
    }

    if (!State.Key95) {
        DEBUGMSG ((DBG_VERBOSE, "Root %s does not exist", RootKey));
        return TRUE;
    }

    //
    // Progress bar update
    //

    g_ProgressBarCounter++;
    if (g_ProgressBarCounter >= REGMERGE_TICK_THRESHOLD) {
        g_ProgressBarCounter = 0;
        TickProgressBar();
    }

    __try {
        g_MergeBufUseCount++;
        if (g_MergeBufUseCount == MAX_REGISTRY_KEY) {
            DEBUGMSG ((DBG_WHOOPS, "Recursive merge depth indicates a loop problem, aborting!"));
            __leave;
        }

        if (RootKeyNt) {
            State.KeyNt = RootKeyNt;
        } else {
            State.KeyNt = OpenRegKeyStr (RootKey);
            State.CloseKeyNt = (State.KeyNt != NULL);
        }

        State.FullKeyName = RootKey;

        //
        // Key processing
        //

        if (!Is95RegKeySuppressed (RootKey)) {
            //
            // Loop through the key functions for the root key
            //

            if (RestrictionFlags & MERGE_FLAG_KEY) {
                Result = pCallMergeRoutines (&State, MERGE_FLAG_KEY);

                if (Result == MERGE_ERROR || Result == MERGE_LEAVE) {
                    __leave;
                }
            }

            //
            // Loop through the values, skipping those that are suppressed
            //

            if ((RestrictionFlags & MERGE_FLAG_VALUE) &&
                EnumFirstRegValue95 (&ev, State.Key95)
                ) {

                do {
                    if (Is95RegObjectSuppressed (State.FullKeyName, ev.ValueName)) {
                        continue;
                    }

                    State.ValueName = ev.ValueName;
                    State.ValueDataType = ev.Type;
                    State.ValueDataSize = ev.DataSize;

                    //
                    // Loop through the value functions
                    //

                    Result = pCallMergeRoutines (&State, MERGE_FLAG_VALUE);

                    if (Result == MERGE_ERROR ||
                        Result == MERGE_LEAVE ||
                        Result == MERGE_BREAK
                        ) {
                        break;
                    }

                } while (EnumNextRegValue95 (&ev));

                if (Result == MERGE_ERROR || Result == MERGE_LEAVE) {
                    __leave;
                }
            }

            State.ValueName = NULL;
            State.ValueDataType = 0;
            State.ValueDataSize = 0;
        }

        //
        // Subkey processing
        //

        if ((RestrictionFlags & MERGE_FLAG_SUBKEY) &&
            EnumFirstRegKey95 (&ek, State.Key95)
            ) {

            do {
                //
                // Prepare State, skip key if it is suppressed
                //

                State.SubKeyName = ek.SubKeyName;
                State.FullSubKeyName = JoinPaths (RootKey, ek.SubKeyName);

                if (Is95RegKeyTreeSuppressed (State.FullSubKeyName)) {
                    FreePathString (State.FullSubKeyName);
                    continue;
                }

                State.SubKey95 = OpenRegKey95 (ek.KeyHandle, ek.SubKeyName);
                if (State.KeyNt) {
                    State.SubKeyNt = OpenRegKey (State.KeyNt, ek.SubKeyName);
                } else {
                    State.SubKeyNt = NULL;
                }

                //
                // Loop through the subkey functions
                //

                Result = pCallMergeRoutines (&State, MERGE_FLAG_SUBKEY);

                //
                // Clean up
                //

                FreePathString (State.FullSubKeyName);
                if (State.SubKeyNt) {
                    CloseRegKey (State.SubKeyNt);
                }
                if (State.SubKey95) {
                    CloseRegKey95 (State.SubKey95);
                }

                if (Result == MERGE_ERROR ||
                    Result == MERGE_LEAVE ||
                    Result == MERGE_BREAK
                    ) {
                    break;
                }
            } while (EnumNextRegKey95 (&ek));

            if (Result == MERGE_ERROR || Result == MERGE_LEAVE) {
                __leave;
            }
        }
    }
    __finally {
        PushError();

        g_MergeBufUseCount--;
        if (!g_MergeBufUseCount && g_MergeBuf) {
            ReuseFree (g_hHeap, g_MergeBuf);
            g_MergeBuf = NULL;
        }

        if (State.CloseKey95) {
            CloseRegKey95 (State.Key95);
        }

        if (State.CloseKeyNt) {
            CloseRegKey (State.KeyNt);
        }

        PopError();
    }

    return Result != MERGE_ERROR;

}


BOOL
MergeRegistryNode (
    IN      PCTSTR RootKey,
    IN      MERGE_CONTEXT Context
    )
{
    return MergeRegistryNodeEx (RootKey, NULL, NULL, Context, MERGE_ALL_FLAGS);
}


BOOL
MergeKeyNode (
    IN      PMERGE_STATE State,
    IN      MERGE_CONTEXT Context
    )
{
    return MergeRegistryNodeEx (
                State->FullKeyName,
                State->Key95,
                State->KeyNt,
                Context,
                MERGE_ALL_FLAGS
                );
}


BOOL
MergeSubKeyNode (
    IN      PMERGE_STATE State,
    IN      MERGE_CONTEXT Context
    )
{
    return MergeRegistryNodeEx (
                State->FullSubKeyName,
                State->SubKey95,
                State->SubKeyNt,
                Context,
                MERGE_ALL_FLAGS
                );
}


BOOL
MergeValuesOfKey (
    IN      PMERGE_STATE State,
    IN      MERGE_CONTEXT Context
    )
{
    if (!pMakeSureNtKeyExists (State)) {
        DEBUGMSG ((DBG_ERROR, "Can't create %s to merge values", State->FullKeyName));
        return TRUE;        // eat error
    }

    return MergeRegistryNodeEx (
                State->FullKeyName,
                State->Key95,
                State->KeyNt,
                Context,
                MERGE_FLAG_VALUE
                );
}


BOOL
MergeValuesOfSubKey (
    IN      PMERGE_STATE State,
    IN      MERGE_CONTEXT Context
    )
{
    if (!pMakeSureNtSubKeyExists (State)) {
        DEBUGMSG ((DBG_ERROR, "Can't create %s to merge values", State->FullSubKeyName));
        return TRUE;        // eat error
    }

    return MergeRegistryNodeEx (
                State->FullSubKeyName,
                State->SubKey95,
                State->SubKeyNt,
                Context,
                MERGE_FLAG_VALUE
                );
}


MERGE_RESULT
pCallMergeRoutines (
    IN OUT  PMERGE_STATE State,
    IN      DWORD MergeFlag
    )
{
    INT i;
    MERGE_RESULT Result = MERGE_NOP;

    State->MergeFlag = MergeFlag;

    for (i = 0 ; g_MergeRoutines[i].fn ; i++) {
        if (g_MergeRoutines[i].Context != State->Context &&
            g_MergeRoutines[i].Context != ANY_CONTEXT
            ) {
            continue;
        }

        if (g_MergeRoutines[i].Flags & MergeFlag) {
            Result = g_MergeRoutines[i].fn (State);
            if (Result != MERGE_NOP) {
                break;
            }
        }
    }

    return Result;
}


BOOL
pFillStateWithValue (
    IN OUT  PMERGE_STATE State
    )

/*++

Routine Description:

  pFillStateWithValue queries the Win95 registry for the value specified in
  the inbound State struct.  Upon return, the ValueData member of State is
  set to the global buffer g_MergeBuf.  The value is passed through the merge
  data filter in datafilt.c.

  The caller must make a copy of the data if two or more values are to be
  processed at the same time.

Arguments:

  State - Specifies the registry key name and value, along with a key handle.
          Receives the value data.

Return Value:

  TRUE if the value was read, or FALSE if an error occurred.

--*/

{
    LONG rc;
    DWORD Size;

    if (!State->ValueName) {
        DEBUGMSG ((DBG_WHOOPS, "pFillStateWithValue: No value name"));
        return FALSE;
    }

    if (State->LockValue) {
        return TRUE;
    }

    //
    // Do not process if value is suppressed
    //

    if (Is95RegObjectSuppressed (State->FullKeyName, State->ValueName)) {
        return TRUE;
    }

    //
    // Get data from registry
    //

    rc = Win95RegQueryValueEx (
             State->Key95,
             State->ValueName,
             NULL,
             &State->ValueDataType,
             NULL,
             &State->ValueDataSize
             );

    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        LOG ((
            LOG_ERROR,
            "Win95Reg query size of %s [%s] failed",
            State->FullKeyName,
            State->ValueName
            ));
        return FALSE;
    }

    Size = State->ValueDataSize;
    g_MergeBuf = (PBYTE) ReuseAlloc (g_hHeap, g_MergeBuf, Size);
    if (!g_MergeBuf) {
        DEBUGMSG ((DBG_ERROR, "pFillStateWithValue: ReuseAlloc returned NULL"));
        return FALSE;
    }

    rc = Win95RegQueryValueEx (
             State->Key95,
             State->ValueName,
             NULL,
             NULL,
             g_MergeBuf,
             &Size
             );

    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        LOG ((
            LOG_ERROR,
            "Win95Reg query for %s [%s] failed",
            State->FullKeyName,
            State->ValueName
            ));
        return FALSE;
    }

    //
    // Convert data if necessary; g_MergeBuf is a ReUse buffer, so it's
    // address may change upon return.
    //

    State->ValueData = FilterRegValue (
                            g_MergeBuf,
                            Size,
                            State->ValueDataType,
                            State->FullKeyName,
                            &State->ValueDataSize
                            );

    if (State->ValueData) {
        if (g_MergeBuf != State->ValueData) {
            g_MergeBuf = State->ValueData;
        }
    }

    return State->ValueData != NULL;
}


BOOL
pMakeSureNtKeyExists (
    IN      PMERGE_STATE State
    )
{
    if (!State->KeyNt) {
        State->KeyNt = CreateRegKeyStr (State->FullKeyName);
        State->CloseKeyNt = (State->KeyNt != NULL);
    }

    return State->KeyNt != NULL;
}


BOOL
pMakeSureNtSubKeyExists (
    IN      PMERGE_STATE State
    )
{
    if (!State->SubKeyNt) {
        State->SubKeyNt = CreateRegKeyStr (State->FullSubKeyName);
    }

    return State->SubKeyNt != NULL;
}


BOOL
pCopy95ValueToNt (
    IN OUT  PMERGE_STATE State
    )
{
    LONG rc = ERROR_SUCCESS;

    if (pFillStateWithValue (State)) {

        pMakeSureNtKeyExists (State);

        rc = RegSetValueEx (
                 State->KeyNt,
                 State->ValueName,
                 0,
                 State->ValueDataType,
                 State->ValueData,
                 State->ValueDataSize
                 );

        if (rc != ERROR_SUCCESS) {
            SetLastError (rc);
            LOG ((
                LOG_ERROR,
                "Copy Win9x Value To Nt failed to set %s [%s]",
                State->FullKeyName,
                State->ValueName
                ));
        }
    }

    return rc = ERROR_SUCCESS;
}


MERGE_RESULT
pFileExtensionMerge (
    IN      PMERGE_STATE State
    )
{
    BOOL CloseNTKey = FALSE;
    BOOL Close95Key = FALSE;
    PCTSTR Value9x, ValueNt;
    TCHAR key [MEMDB_MAX];
    DWORD value;

    MYASSERT (State->FullKeyName);
    MYASSERT (State->FullSubKeyName);
    MYASSERT (State->SubKeyName);
    MYASSERT (State->SubKey95);
    MYASSERT (State->MergeFlag == MERGE_FLAG_SUBKEY);
    MYASSERT (State->Context == ROOT_BASE);

    //
    // Sub key name must have a dot
    //

    if (_tcsnextc (State->SubKeyName) != TEXT('.')) {
        return MERGE_NOP;
    }

    //
    // We look now to see if NT comes with this file extension.
    // If it does and the progID referenced by 9x file extension has
    // a loss of default command functionality, we let NT overwrite
    // the ProgId reference. We do this by suppressing the default
    // value of this file extension.
    //
    if (!State->SubKey95) {
        State->SubKey95 = OpenRegKeyStr95 (State->FullSubKeyName);
        Close95Key = (State->SubKey95 != NULL);
    }
    if (!State->SubKeyNt) {
        State->SubKeyNt = OpenRegKeyStr (State->FullSubKeyName);
        CloseNTKey = (State->SubKeyNt != NULL);
    }
    if (State->SubKey95 && State->SubKeyNt) {
        //
        // Let's see if we the NT default value is different than 9x one.
        //
        Value9x = GetRegValueString95 (State->SubKey95, TEXT(""));
        ValueNt = GetRegValueString (State->SubKeyNt, TEXT(""));

        if ((ValueNt && !Value9x) ||
            (!ValueNt && Value9x) ||
            (ValueNt && Value9x && (!StringIMatch (Value9x, ValueNt)))
            ) {
            MemDbBuildKey (key, MEMDB_CATEGORY_PROGIDS, Value9x?Value9x:State->SubKeyName, NULL, NULL);
            if (MemDbGetValue (key, &value) &&
                (value == PROGID_LOSTDEFAULT)
                ) {
                //
                // Now it's the time to suppress the default value for this file extension
                //
                MemDbBuildKey (key, MEMDB_CATEGORY_HKLM, TEXT("SOFTWARE\\Classes"), State->SubKeyName, NULL);
                if (!Suppress95RegSetting(key, TEXT(""))) {
                    DEBUGMSG((DBG_WARNING,"Could not suppress %s\\[] registry setting.", key));
                }
            }
        }

        if (Value9x) {
            MemFree (g_hHeap, 0, Value9x);
            Value9x = NULL;
        }

        if (ValueNt) {
            MemFree (g_hHeap, 0, ValueNt);
            ValueNt = NULL;
        }
    }
    if (Close95Key) {
        CloseRegKey95 (State->SubKey95);
        State->SubKey95 = NULL;
    }
    if (CloseNTKey) {
        CloseRegKey (State->SubKeyNt);
        State->SubKeyNt = NULL;
    }

    //
    // We copy all the extensions blindly
    //

    if (!CopyEntireSubKey (State)) {
        return MERGE_ERROR;
    }

    //
    // Return MERGE_CONTINUE so processing continues to next subkey
    //

    return MERGE_CONTINUE;
}


MERGE_RESULT
pDetectDefaultIconKey (
    IN      PMERGE_STATE State
    )
{
    MYASSERT (State->FullKeyName);
    MYASSERT (State->FullSubKeyName);
    MYASSERT (State->SubKeyName);
    MYASSERT (State->SubKey95);
    MYASSERT (State->MergeFlag == MERGE_FLAG_SUBKEY);

    if (StringIMatch (State->SubKeyName, TEXT("DefaultIcon"))) {
        if (!MergeSubKeyNode (State, COPY_DEFAULT_ICON)) {
            return MERGE_ERROR;
        }

        return MERGE_CONTINUE;
    }

    return MERGE_NOP;
}


MERGE_RESULT
pEnsureShellDefaultValue (
    IN      PMERGE_STATE State
    )
{

    PTSTR dataNt = NULL;
    PTSTR data9x = NULL;
    PTSTR p = NULL;

    MYASSERT (State->FullKeyName);
    MYASSERT (State->MergeFlag == MERGE_FLAG_SUBKEY);




    if (StringIMatch (State->SubKeyName, TEXT("Shell"))) {

        //
        // Get default values for both sides. We'll need this
        // to determine wether to do the merge or not.
        //
        pMakeSureNtSubKeyExists (State);

        data9x = (PTSTR) GetRegValueData95 (State->SubKey95, S_EMPTY);
        dataNt = (PTSTR) GetRegValueData (State->SubKeyNt, S_EMPTY);

        __try {

            if (data9x && *data9x && (!dataNt || !*dataNt)) {

                //
                // If we get here, we know there is some value set
                // in the win9x registry and no value set in the
                // nt registry.
                //
                p = JoinPaths (State->FullSubKeyName, data9x);
                if (!Is95RegKeyTreeSuppressed (p)) {

                    if (!MergeSubKeyNode (State, COPY_DEFAULT_VALUE)) {
                        return MERGE_ERROR;
                    }

                }

            }
        } __finally {

            if (p) {
                FreePathString (p);
            }

            if (dataNt) {
                MemFree (g_hHeap, 0, dataNt);
            }

            if (data9x) {
                MemFree (g_hHeap, 0, data9x);
            }
        }

    }

    return MERGE_NOP;
}


MERGE_RESULT
pDefaultIconExtraction (
    IN      PMERGE_STATE State
    )
{
    PCTSTR Data;
    TCHAR iconCmdLine[MAX_CMDLINE];
    PCTSTR LongPath = NULL;
    PCTSTR p;
    INT IconIndex;
    TCHAR IconIndexStr[32];
    TCHAR Node[MEMDB_MAX];
    DWORD Offset;
    DWORD Seq;
    LONG rc;
    BOOL Copied = FALSE;
    PCTSTR updatedPath;
    INT newSeq;

    MYASSERT (State->Context == COPY_DEFAULT_ICON);

    if (State->MergeFlag == MERGE_FLAG_KEY) {
        return MERGE_BREAK;
    }

    if (State->MergeFlag == MERGE_FLAG_SUBKEY) {
        //
        // Copy subkey (which is garbage)
        //

        if (!CopyEntireSubKey (State)) {
            return MERGE_ERROR;
        }

        return MERGE_CONTINUE;
    }

    //
    // Get the default command line
    //

    if (State->ValueDataSize > MAX_CMDLINE - sizeof (TCHAR)) {
        LOG ((LOG_ERROR, "Data too large in %s [%s]", State->FullKeyName, State->ValueName));
        return MERGE_CONTINUE;
    }

    Data = (PCTSTR) GetRegValueString95 (State->Key95, State->ValueName);

    if (Data) {
        //
        // Determine if command line has saved icon
        //

        ExtractArgZeroEx (Data, iconCmdLine, TEXT(","), TRUE);
        p = (PCTSTR) ((PBYTE) Data + ByteCount (iconCmdLine));
        while (*p == TEXT(' ')) {
            p++;
        }

        if (*p == TEXT(',')) {
            IconIndex = _ttoi (_tcsinc (p));

            LongPath = GetSourceFileLongName (iconCmdLine);

            wsprintf (IconIndexStr, TEXT("%i"), IconIndex);

            //
            // Test for a moved icon. If there is a moved icon, use it,
            // otherwise test for an extracted icon. If there is an
            // extracted icon, use it. Otherwise, leave DefaultIcon alone.
            //

            iconCmdLine[0] = 0;

            MemDbBuildKey (Node, MEMDB_CATEGORY_ICONS_MOVED, LongPath, IconIndexStr, NULL);

            if (MemDbGetValueAndFlags (Node, &Offset, &Seq)) {
                //
                // icon moved to a new binary
                //

                if (IconIndex < 0) {
                    newSeq = -((INT) Seq);
                } else {
                    newSeq = (INT) Seq;
                }

                MemDbBuildKeyFromOffset (Offset, Node, 1, NULL);
                updatedPath = GetPathStringOnNt (Node);
                wsprintf (iconCmdLine, TEXT("%s,%i"), updatedPath, newSeq);
                FreePathString (updatedPath);

            } else {

                Offset = INVALID_OFFSET;

                MemDbBuildKey (Node, MEMDB_CATEGORY_ICONS, LongPath, IconIndexStr, NULL);
                if (MemDbGetValueAndFlags (Node, NULL, &Seq)) {
                    //
                    // icon was extracted
                    //

                    wsprintf (iconCmdLine, TEXT("%s,%i"), g_IconBin, Seq);
                }
            }

            if (iconCmdLine[0]) {
                //
                // DefaultIcon has changed; write change now (full REG_SZ
                // value is in iconCmdLine)
                //

                if (!pMakeSureNtKeyExists (State)) {
                    LOG ((
                        LOG_ERROR,
                        "Unable to open %s",
                        State->FullKeyName
                        ));
                } else {

                    rc = RegSetValueEx (
                             State->KeyNt,
                             State->ValueName,
                             0,
                             REG_SZ,
                             (PBYTE) iconCmdLine,
                             SizeOfString (iconCmdLine)
                             );

                    if (rc != ERROR_SUCCESS) {
                        SetLastError (rc);
                        LOG ((
                            LOG_ERROR,
                            "Default Icon Extraction failed to set path for %s",
                            State->FullKeyName
                            ));
                    } else {
                        Copied = TRUE;

                        DEBUGMSG_IF ((
                            Offset == INVALID_OFFSET,
                            DBG_VERBOSE,
                            "DefaultIcon preserved for %s [%s]",
                            State->FullKeyName,
                            State->ValueName
                            ));

                        DEBUGMSG_IF ((
                            Offset != INVALID_OFFSET,
                            DBG_VERBOSE,
                            "DefaultIcon moved to new OS icon for %s [%s]",
                            State->FullKeyName,
                            State->ValueName
                            ));
                    }
                }
            }

            FreePathString (LongPath);
        }

        MemFree (g_hHeap, 0, Data);
    }

    if (!Copied) {
        pCopy95ValueToNt (State);
    }

    return MERGE_CONTINUE;
}


MERGE_RESULT
pTreeCopyMerge (
    IN      PMERGE_STATE State
    )
{
    REGVALUE_ENUM ev;

    if (State->Context != TREE_COPY && State->Context != TREE_COPY_NO_OVERWRITE) {
        return MERGE_NOP;
    }

    switch (State->MergeFlag) {

    case MERGE_FLAG_KEY:
        if (State->Context == TREE_COPY) {
            if (!pMakeSureNtKeyExists (State)) {
                LOG ((
                    LOG_ERROR,
                    "Unable to create %s",
                    State->FullKeyName
                    ));
            }
        } else {
            //
            // If no values in Win9x key, then it is OK to create the
            // value-less key now.  Otherwise, wait until MERGE_FLAG_VALUE
            // processing.
            //

            if (!EnumFirstRegValue95 (&ev, State->Key95)) {
                if (!pMakeSureNtKeyExists (State)) {
                    LOG ((
                        LOG_ERROR,
                        "Unable to create %s",
                        State->FullKeyName
                        ));
                }
            }
        }

        break;

    case MERGE_FLAG_VALUE:
        //
        // Copy values unconditionally, unless no overwrite is specified and
        // NT key exists.
        //

        if (State->Context == TREE_COPY_NO_OVERWRITE && State->KeyNt) {
            return MERGE_BREAK;
        }

        if (!MergeKeyNode (State, KEY_COPY)) {
            return MERGE_ERROR;
        }

        return MERGE_BREAK;     // MERGE_BREAK breaks out of value enumeration and enters
                                // subkey enumeration

    case MERGE_FLAG_SUBKEY:
        //
        // Continue copy recursively
        //

        if (!MergeSubKeyNode (State, State->Context)) {
            return MERGE_ERROR;
        }
        break;
    }

    return MERGE_CONTINUE;
}


MERGE_RESULT
pKeyCopyMerge (
    IN OUT  PMERGE_STATE State
    )
{
    MYASSERT (State->FullKeyName);
    MYASSERT (!State->FullSubKeyName);
    MYASSERT (!State->SubKeyName);
    MYASSERT (!State->SubKey95);
    MYASSERT (State->ValueName);
    MYASSERT (State->MergeFlag == MERGE_FLAG_VALUE);
    MYASSERT (State->Context == KEY_COPY);

    pCopy95ValueToNt (State);
    return MERGE_CONTINUE;
}


MERGE_RESULT
pCopyDefaultValue (
    IN      PMERGE_STATE State
    )
{
    PCSTR value1;
    PCSTR value2;
    PCWSTR value3;

    MYASSERT (State->FullKeyName);
    MYASSERT (!State->FullSubKeyName);
    MYASSERT (!State->SubKeyName);
    MYASSERT (!State->SubKey95);
    MYASSERT (!State->ValueName);
    MYASSERT (State->MergeFlag == MERGE_FLAG_KEY);
    MYASSERT (State->Context == COPY_DEFAULT_VALUE);

    State->ValueName = S_EMPTY;

#ifdef DEBUG
    //
    // Obtain NT value, if it exists, then compare against Win9x value.  If
    // different, dump debug output.
    //

    {
        PBYTE Data95, DataNt;

        Data95 = GetRegValueData95 (State->Key95, S_EMPTY);
        DataNt = GetRegValueData (State->KeyNt, S_EMPTY);

        if (Data95 && DataNt) {
            __try {
                if (memcmp (Data95, DataNt, ByteCount ((PTSTR) Data95))) {
                    DEBUGMSG ((
                        DBG_VERBOSE,
                        "Default value of %s changed from %s to %s",
                        State->FullKeyName,
                        DataNt,
                        Data95
                        ));
                }
            }
            __except (1) {
            }
        }

        if (Data95) {
            MemFree (g_hHeap, 0, Data95);
        }

        if (DataNt) {
            MemFree (g_hHeap, 0, DataNt);
        }
    }

#endif
    //
    // now let's get the value and convert it if necessary
    //

    if (pFillStateWithValue (State)) {

        if ((OurGetACP() == 932) &&
            ((State->ValueDataType == REG_SZ) ||
             (State->ValueDataType == REG_EXPAND_SZ)
            )) {
            //
            // apply the Katakana filter
            //
            value1 = ConvertWtoA ((PCWSTR) State->ValueData);
            value2 = ConvertSBtoDB (NULL, value1, NULL);
            value3 = ConvertAtoW (value2);
            g_MergeBuf = (PBYTE) ReuseAlloc (g_hHeap, g_MergeBuf, SizeOfStringW (value3));
            StringCopyW ((PWSTR)g_MergeBuf, value3);
            State->ValueData = g_MergeBuf;
            FreeConvertedStr (value3);
            FreePathStringA (value2);
            FreeConvertedStr (value1);
        }

        State->LockValue = TRUE;
        pCopy95ValueToNt (State);
        State->LockValue = FALSE;
    }

    State->ValueName = NULL;
    return MERGE_LEAVE;
}


MERGE_RESULT
pDetectRootKeyType (
    IN      PMERGE_STATE State
    )

/*++

Routine Description:

  pDetectRootKeyType identifies CLSID in the root of HKCR, and when found, the CLSID
  subkey is processed with the CLSID_BASE context.

Arguments:

  State - Specifies the enumeration state.

Return Value:

  MERGE_ERROR - An error occurred
  MERGE_CONTINUE - The subkey was processed
  MERGE_NOP - The subkey was not processed

--*/

{
    MYASSERT (State->FullKeyName);
    MYASSERT (State->FullSubKeyName);
    MYASSERT (State->SubKeyName);
    MYASSERT (State->SubKey95);
    MYASSERT (State->MergeFlag == MERGE_FLAG_SUBKEY);
    MYASSERT (State->Context == ROOT_BASE);

    if (StringIMatch (State->SubKeyName, TEXT("CLSID"))) {

        //
        // This is the CLSID key; copy with CLSID_BASE
        //

        if (!MergeSubKeyNode (State, CLSID_BASE)) {
            return MERGE_ERROR;
        }

        //
        // Copy the values (usually there are none)
        //

        if (!MergeRegistryNodeEx (
                State->FullKeyName,
                State->Key95,
                State->KeyNt,
                KEY_COPY,
                MERGE_FLAG_VALUE
                )) {
            return MERGE_ERROR;
        }

        return MERGE_CONTINUE;

    } else if (StringIMatch (State->SubKeyName, TEXT("TYPELIB"))) {

        //
        // Copy the TypeLib subkey (its values and all of its subkeys)
        //

        if (!MergeSubKeyNode (State, TYPELIB_BASE) ||
            !CopyAllSubKeyValues (State)
            ) {

            return MERGE_ERROR;

        }

        return MERGE_CONTINUE;

    } else if (StringIMatch (State->SubKeyName, TEXT("Interface"))) {

        //
        // Copy the Interface, then copy the values (usually none)
        //

        if (!MergeSubKeyNode (State, INTERFACE_BASE)) {
            return MERGE_ERROR;
        }

        if (!CopyAllSubKeyValues (State)) {
            return MERGE_ERROR;
        }

        return MERGE_CONTINUE;

    }

    return MERGE_NOP;
}


BOOL
pIsNtClsIdOverwritable (
    IN      HKEY Key
    )
{
    REGKEY_ENUM e;
    BOOL Overwritable = TRUE;
    HKEY InstanceSubKey;

    //
    // Enumerate the subkeys.  If there is a subkey that has a binary
    // implementation, then do not overwrite the key.
    //

    if (!Key) {
        return TRUE;
    }

    if (EnumFirstRegKey (&e, Key)) {
        do {

            if (StringIMatchCharCount (e.SubKeyName, TEXT("Inproc"), 6) ||
                StringIMatch (e.SubKeyName, TEXT("LocalServer")) ||
                StringIMatch (e.SubKeyName, TEXT("LocalServer32")) ||
                StringIMatch (e.SubKeyName, TEXT("ProxyStubClsid32"))
                ) {

                Overwritable = FALSE;
                break;

            }

            if (StringIMatch (e.SubKeyName, TEXT("Instance"))) {
                break;
            }

        } while (EnumNextRegKey (&e));
    }

    if (!Overwritable) {
        //
        // if we think a key is not overwritable, we have
        // to test for a subkey Instance.  If it exists, then we
        // consider the key overwritable.  This is for ActiveMovie,
        // and unfortunately it has the potential of breaking anyone
        // in NT who puts an Instance key in their CLSID.  Since
        // ActiveMovie plug-ins use this key, we're stuck.
        //
        // Fortunately, nobody in NT does this currently.
        //

        InstanceSubKey = OpenRegKey (Key, TEXT("Instance"));
        if (InstanceSubKey) {
            CloseRegKey (InstanceSubKey);
            Overwritable = TRUE;
        }

        return Overwritable;
    }

    return TRUE;
}


MERGE_RESULT
pCopyClassId (
    IN      PMERGE_STATE State
    )

/*++

Routine Description:

  pCopyClassId performs a copy of an HKCR\CLSID\* key.  It copies the entire
  key to NT if NT does not provide an equivalent setting.  In all cases, the
  friendly name is copied to NT, because it may have been modified on Win9x.
  However, we don't copy the default value when we are talking about a suppressed
  GUID and NT does not install this GUID.

  This function is called for all subkeys of CLSID.  The subkey name is either
  a GUID or garbage.

Arguments:

  State - Specifies the enumeration state, which is always a subkey of
          HKCR\CLSID in this case.

Return Value:

  MERGE_CONTINUE - Key was processed
  MERGE_ERROR - An error occurred

--*/

{
    TCHAR Node[MEMDB_MAX];
    TCHAR DefaultIconKey[MAX_REGISTRY_KEY];
    HKEY DefaultIcon95;
    BOOL Copied = FALSE;
    PTSTR defaultValue = NULL;

    MYASSERT (State->FullKeyName);
    MYASSERT (State->FullSubKeyName);
    MYASSERT (State->SubKeyName);
    MYASSERT (State->SubKey95);
    MYASSERT (State->MergeFlag == MERGE_FLAG_SUBKEY);
    MYASSERT (State->Context == CLSID_BASE);

    //
    // Skip if the GUID is suppressed
    //
    MemDbBuildKey (Node, MEMDB_CATEGORY_GUIDS, State->SubKeyName, NULL, NULL);
    if (!MemDbGetValue (Node, NULL)) {
        //
        // Copy entire Win9x setting if GUID does not exist on NT.
        // If GUID exists on NT, do not touch it.
        //

        if (pIsNtClsIdOverwritable (State->SubKeyNt)) {

            Copied = TRUE;

            if (!pMakeSureNtSubKeyExists (State)) {

                LOG ((LOG_ERROR, "Can't create %s", State->FullSubKeyName));

            } else {

                //
                // Copy the specific CLSID key from 95 to NT
                //

                if (!MergeSubKeyNode (State, CLSID_COPY)) {
                    return MERGE_ERROR;
                }
            }
        }
        ELSE_DEBUGMSG ((DBG_VERBOSE, "CLSID %s is not overwritable", State->SubKeyName));

    }
    if (!Copied) {

        if (State->SubKeyNt) {


            defaultValue = (PTSTR) GetRegValueData95 (State->SubKey95, S_EMPTY);
            if (defaultValue && *defaultValue) {
                //
                // If ClsId is suppressed but NT installs the GUID, we want to copy
                // the default value and the default icon for GUID.
                //
                // (This is the class friendly name.)
                //

                if (!MergeRegistryNodeEx (
                        State->FullSubKeyName,
                        State->SubKey95,
                        State->SubKeyNt,
                        COPY_DEFAULT_VALUE,
                        MERGE_FLAG_KEY
                        )) {
                    return MERGE_ERROR;
                }
            }

            if (defaultValue) {

                MemFree (g_hHeap, 0, defaultValue);

            }

            StringCopy (DefaultIconKey, State->FullSubKeyName);
            StringCopy (AppendWack (DefaultIconKey), TEXT("DefaultIcon"));

            DefaultIcon95 = OpenRegKeyStr95 (DefaultIconKey);
            if (DefaultIcon95) {
                CloseRegKey95 (DefaultIcon95);

                if (!MergeRegistryNode (DefaultIconKey, COPY_DEFAULT_ICON)) {
                    return MERGE_ERROR;
                }
            }
        }
    }

    return MERGE_CONTINUE;
}


MERGE_RESULT
pCopyClassIdWorker (
    IN      PMERGE_STATE State
    )


/*++

Routine Description:

  pCopyClassIdWorker handles one CLSID entry.  It processses all the values
  of the entry, and all subkeys.  This routine looks for the special cases of
  CLSID.  If none are found, the entire key is copied (unless NT provides the
  key).  If a special case is found, the root is changed for the special
  case.

  The key is HKCR\CLSID\<guid>.
  The subkey is HKCR\CLSID\<guid>\<subkey>

  We have already determined that <guid> is not suppressed.

Arguments:

  State - Specifies the enumeration state, which is the subkey of HKCR\CLSID,
          or the subkey of HKCR\CLSID\<guid>.

Return Value:

  MERGE_CONTINUE - Key was processed
  MERGE_ERROR - An error occurred

--*/

{
    MYASSERT (State->FullKeyName);
    MYASSERT (State->FullSubKeyName || State->MergeFlag == MERGE_FLAG_KEY);
    MYASSERT (State->SubKeyName || State->MergeFlag == MERGE_FLAG_KEY);
    MYASSERT (State->SubKey95 || State->MergeFlag == MERGE_FLAG_KEY);
    MYASSERT (State->Context == CLSID_COPY);

    switch (State->MergeFlag) {

    case MERGE_FLAG_KEY:
        //
        // For MERGE_FLAG_KEY, copy all the values
        //

        CopyAllValues (State);
        break;

    case MERGE_FLAG_SUBKEY:
        //
        // For MERGE_FLAG_SUBKEY, copy unless it needs a special-case merge
        //

        if (StringIMatch (State->SubKeyName, TEXT("Instance"))) {

            //
            // The subkey is Instance, perform a special-case merge
            //

            if (!MergeSubKeyNode (State, CLSID_INSTANCE_COPY)) {
                return MERGE_ERROR;
            }

        } else {

            //
            // Copy the key unconditionally
            //

            if (!CopyEntireSubKey (State)) {
                return MERGE_ERROR;
            }
        }
        break;

    default:
        DEBUGMSG ((DBG_WHOOPS, "Wasteful call to pCopyClassIdWorker"));
        break;
    }

    return MERGE_CONTINUE;
}


MERGE_RESULT
pInstanceSpecialCase (
    IN      PMERGE_STATE State
    )


/*++

Routine Description:

  pInstanceSpecialCase handles the Instance subkey of arbitrary GUIDs.  This
  is used by ActiveMovie to track third-party plug-ins.  This routine
  examines the format of Instance (specific to ActiveMove), and copies only
  parts of the key that are compatible with NT and not
  replaced.

  The Key refers to HKCR\CLSID\<guid>\Instance.

  The SubKey refers to HKCR\CLSID\<guid>\Instance\<sequencer>

  We have already determined that <guid> is not suppressed.

Arguments:

  State - Specifies the HKCR state.

Return Value:

  MERGE_CONTINUE - Key was processed
  MERGE_ERROR - An error occurred

--*/

{
    TCHAR Guid[MAX_GUID];
    TCHAR Node[MEMDB_MAX];
    LONG rc;
    DWORD Size;

    MYASSERT (State->FullKeyName);
    MYASSERT (State->FullSubKeyName || State->MergeFlag == MERGE_FLAG_KEY);
    MYASSERT (State->SubKeyName || State->MergeFlag == MERGE_FLAG_KEY);
    MYASSERT (State->SubKey95 || State->MergeFlag == MERGE_FLAG_KEY);
    MYASSERT (State->Context == CLSID_INSTANCE_COPY);

    switch (State->MergeFlag) {

    case MERGE_FLAG_KEY:
        //
        // Copy all values (normally there are none)
        //

        CopyAllValues (State);
        break;

    case MERGE_FLAG_SUBKEY:
        //
        // The subkey is a random enumerator (usually a GUID -- but it is not defined
        // to be so).  Look at the CLSID value of the subkey, then check the GUID
        // (the value data) against the suppress list.
        //

        //
        // Was that random enumerator installed by NT?  If so, ignore the Win9x
        // setting.
        //

        if (State->SubKeyNt) {
            break;
        }

        //
        // Get GUID and see if it is suppressed
        //

        Size = sizeof (Guid);

        rc = Win95RegQueryValueEx (
                 State->SubKey95,
                 TEXT("CLSID"),
                 NULL,
                 NULL,
                 (PBYTE) Guid,
                 &Size
                 );

        if (rc != ERROR_SUCCESS) {
            //
            // No CLSID value; copy entire subkey unaltered
            //

            if (!CopyEntireSubKey (State)) {
                return MERGE_ERROR;
            }
        }

        MemDbBuildKey (Node, MEMDB_CATEGORY_GUIDS, Guid, NULL, NULL);
        if (!MemDbGetValue (Node, NULL)) {
            //
            // GUID is not suppressed; copy entire subkey unaltered
            //

            if (!CopyEntireSubKey (State)) {
                return MERGE_ERROR;
            }
        }
        ELSE_DEBUGMSG ((DBG_VERBOSE, "Suppressing ActiveMovie Instance GUID: %s", Guid));
        break;

    default:
        DEBUGMSG ((DBG_WHOOPS, "Wasteful call to pInstanceSpecialCase"));
        break;
    }

    return MERGE_CONTINUE;
}


MERGE_RESULT
pCopyTypeLibOrInterface (
    IN      PMERGE_STATE State
    )

/*++

Routine Description:

  pCopyTypeLibOrInterface copies the COM type registration and COM interfaces.

Arguments:

  State - Specifies the enumeration state, which is always a subkey of
          HKCR\TypeLib in this case.

Return Value:

  MERGE_CONTINUE - Key was processed
  MERGE_ERROR - An error occurred

--*/

{
    TCHAR Node[MEMDB_MAX];

    MYASSERT (State->FullKeyName);
    MYASSERT (State->FullSubKeyName);
    MYASSERT (State->SubKeyName);
    MYASSERT (State->SubKey95);
    MYASSERT (State->MergeFlag == MERGE_FLAG_SUBKEY);

    if (State->Context != TYPELIB_BASE &&
        State->Context != INTERFACE_BASE
        ) {
        return MERGE_NOP;
    }

    //
    // Skip if the GUID is suppressed
    //

    MemDbBuildKey (Node, MEMDB_CATEGORY_GUIDS, State->SubKeyName, NULL, NULL);
    if (!MemDbGetValue (Node, NULL)) {
        if (State->Context == TYPELIB_BASE) {

            //
            // If this is a typelib entry, use additional typelib logic
            //

            if (!MergeSubKeyNode (State, TYPELIB_VERSION_COPY) ||
                !CopyAllSubKeyValues (State)
                ) {
                return MERGE_ERROR;
            }

        } else {

            //
            // For the Interface entries, copy entire Win9x setting if
            // GUID does not exist on NT. If GUID exists on NT, do not
            // touch it.
            //

            if (!State->SubKeyNt) {
                if (!CopyEntireSubKey (State)) {
                    return MERGE_ERROR;
                }
            }
        }
    }

    return MERGE_CONTINUE;
}


MERGE_RESULT
pCopyTypeLibVersion (
    IN      PMERGE_STATE State
    )

/*++

Routine Description:

  pCopyTypeLibVersion copies the type registration for a specific
  interface version.  It only copies if the particular version
  is not installed by NT.

  This function is called only for subkeys within a TypeLib\{GUID}
  key.

Arguments:

  State - Specifies the enumeration state, which is always a subkey of
          HKCR\TypeLib in this case.

Return Value:

  MERGE_CONTINUE - Key was processed
  MERGE_ERROR - An error occurred

--*/

{
    MYASSERT (State->FullKeyName);
    MYASSERT (State->MergeFlag == MERGE_FLAG_SUBKEY);
    MYASSERT (State->Context == TYPELIB_VERSION_COPY);
    MYASSERT (State->FullSubKeyName);
    MYASSERT (State->SubKeyName);
    MYASSERT (State->SubKey95);

    //
    // Skip if the sub key exists in NT, copy the entire thing otherwise
    //

    if (!State->SubKeyNt) {
        if (!CopyEntireSubKey (State)) {
            return MERGE_ERROR;
        }
    }

    return MERGE_CONTINUE;
}


MERGE_RESULT
pLastMergeRoutine (
    IN      PMERGE_STATE State
    )

/*++

Routine Description:

  pLastMergeRoutine performs a default copy with no overwrite for all keys
  left unhandled.  This routine first verifies the context is a base context
  (such as ROOT_BASE or CLSID_BASE), and if so, MergeRegistryNode is called
  recursively to perform the merge.

Arguments:

  State - Specifies the enumeration state

Return Value:

  MERGE_NOP - The subkey was not processed
  MERGE_ERROR - An error occurred
  MERGE_CONTINUE - The key was merged

--*/

{
    TCHAR DefaultIconKey[MAX_REGISTRY_KEY];
    HKEY DefaultIcon95;

    MYASSERT (State->FullKeyName);
    MYASSERT (State->FullSubKeyName);
    MYASSERT (State->SubKeyName);
    MYASSERT (State->SubKey95);
    MYASSERT (State->MergeFlag == MERGE_FLAG_SUBKEY);

    //
    // Process only base contexts
    //

    if (State->Context != ROOT_BASE &&
        State->Context != CLSID_BASE
        ) {
        return MERGE_NOP;
    }

    //
    // If we got here, nobody wants to handle the current key,
    // so let's copy it without overwriting NT keys.
    //

    if (!CopyEntireSubKeyNoOverwrite (State)) {
        return MERGE_ERROR;
    }

    //
    // Special case: If ROOT_BASE, and subkey has a DefaultIcon subkey,
    //               run the DefaultIcon processing.
    //

    if (State->Context == ROOT_BASE) {
        StringCopy (DefaultIconKey, State->FullSubKeyName);
        StringCopy (AppendWack (DefaultIconKey), TEXT("DefaultIcon"));

        DefaultIcon95 = OpenRegKeyStr95 (DefaultIconKey);
        if (DefaultIcon95) {
            CloseRegKey95 (DefaultIcon95);

            if (!MergeRegistryNode (DefaultIconKey, COPY_DEFAULT_ICON)) {
                return MERGE_ERROR;
            }
        }
    }

    return MERGE_CONTINUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\migmain\acctlist.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    acctlist.c

Abstract:

    This code builds a list of domains and queries each of them to
    locate an account.  It is different than LookupAccountName because
    it returns accounts for each match instead of just the first match.

Author:

    Jim Schmidt (jimschm) 26-Jun-1997

Revision History:

    ovidiut     14-Mar-2000 Added support for encrypted passwords
    jimschm     23-Sep-1998 UI changes
    jimschm     11-Jun-1998 User Profile Path now stored in account
                            list.  Added GetProfilePathForUser.
    jimschm     18-Mar-1998 Added support for random passwords and
                            auto-logon.
    jimschm     17-Feb-1998 Updated share security for NT 5 changes
    marcw       10-Dec-1997 Added unattended local account password
                            support.

--*/

#include "pch.h"
#include "migmainp.h"
#include "security.h"

#define DBG_ACCOUNTS    "AcctList"

POOLHANDLE g_UserPool;
PVOID g_UserTable;

typedef struct {
    PCWSTR Domain;
    PSID Sid;
    PCWSTR ProfilePath;
} USERDETAILS, *PUSERDETAILS;

BOOL g_DomainProblem;

BOOL g_RandomPassword = FALSE;

BOOL
pAddUser (
    IN      PCWSTR User,
    IN      PCWSTR Domain
    );

BOOL
pAddLocalGroup (
    IN      PCWSTR Group
    );

BOOL
pAddDomainGroup (
    IN      PCWSTR Group
    );

VOID
pGenerateRandomPassword (
    OUT     PTSTR Password
    );

VOID
pResolveUserDomains (
    VOID
    );

BOOL
pMakeSureAccountsAreValid (
    VOID
    );

BOOL
pWasWin9xOnTheNet (
    VOID
    );

VOID
FindAccountInit (
    VOID
    )

/*++

Routine Description:

    Initialization routine for account management routines, initialized
    when the migration module begins and terminated when the migration
    module ends.

Arguments:

    none

Return value:

    none

--*/

{
    g_UserPool = PoolMemInitNamedPool ("User Accounts");
    g_UserTable = pSetupStringTableInitializeEx (sizeof (USERDETAILS), 0);
}


VOID
FindAccountTerminate (
    VOID
    )

/*++

Routine Description:

    Termination routine for the account management routines, called when
    migmain's entry point is called for cleanup.

Arguments:

    none

Return value:

    none

--*/

{
    PushError();

    //
    // Free user list
    //

    PoolMemDestroyPool (g_UserPool);
    pSetupStringTableDestroy (g_UserTable);

    //
    // Restore error value
    //

    PopError();
}


BOOL
SearchDomainsForUserAccounts (
    VOID
    )

/*++

Routine Description:

    Routine to resolve all account names into fully qualified
    domain names with SIDs, and user profile paths.

    The account names come from the Autosearch and KnownDomain
    categories in memdb.  They are validated and placed in a
    string table called the user list.  Functions in this source
    file access the user list.

Arguments:

    none

Return value:

    TRUE if the account list was resolved, or FALSE if a failure
    occurs.  In the failure case, the account list may not be
    accurate, but the installer is informed when network problems
    occur, and the installer also has several chances to correct
    the problem.

--*/

{
    MEMDB_ENUM e;
    PTSTR p, UserName;
    TCHAR DomainName[MAX_SERVER_NAME];
    BOOL FallbackToLocal = FALSE;
    BOOL LocalizeWarning = FALSE;
    BOOL b = FALSE;
    INFCONTEXT ic;
    TCHAR Buffer[256];

    __try {

        //
        // Put the Administrator password in the list
        //

        if (MemDbGetValueEx (&e, MEMDB_CATEGORY_STATE, MEMDB_ITEM_ADMIN_PASSWORD, NULL)) {
            MemDbSetValueEx (
                MEMDB_CATEGORY_USERPASSWORD,
                g_AdministratorStr,
                e.szName,
                NULL,
                e.dwValue,
                NULL
                );
        } else {
            MYASSERT (FALSE);
        }

        //
        // Create the status dialog (initially hidden)
        //

        CreateStatusPopup();

        //
        // Prepare the account list
        //

        InitAccountList();

        //
        // Get all trusted domains
        //

        if (!BuildDomainList()) {
            FallbackToLocal = TRUE;
        }

        //
        // Put all users who need autosearch to resolve their domain names
        // in the unknown domain.
        //

        if (MemDbEnumItems (&e, MEMDB_CATEGORY_AUTOSEARCH)) {
            do {
                if (FallbackToLocal) {
                    if (!pAddUser (e.szName, NULL)) {
                        LOG ((
                            LOG_ERROR,
                            "Can't create local account for %s, this user can't be processed.",
                            e.szName
                            ));
                    }
                } else {
                    AddUserToDomainList (e.szName, S_UNKNOWN_DOMAIN);
                }
            } while (MemDbEnumNextValue (&e));
        }

        //
        // Put all users whos domain is known in the appropriate domain.  If
        // the add fails, the domain does not exist and the account must be
        // added to the autosearch (causing a silent repair if possible).
        //

        if (MemDbGetValueEx (&e, MEMDB_CATEGORY_KNOWNDOMAIN, NULL, NULL)) {
            do {
                StringCopy (DomainName, e.szName);
                p = _tcschr (DomainName, TEXT('\\'));
                if (!p) {
                    DEBUGMSG ((
                        DBG_WHOOPS,
                        "Unexpected string in %s: %s",
                        MEMDB_CATEGORY_KNOWNDOMAIN,
                        e.szName
                        ));

                    continue;
                }

                UserName = _tcsinc (p);
                *p = 0;

                //
                // Verify that this isn't some irrelavent user
                //

                if (!GetUserDatLocation (UserName, NULL)) {

                    DEBUGMSG ((
                        DBG_WARNING,
                        "Ignoring irrelavent user specified in UserDomain of unattend.txt: %s",
                        e.szName
                        ));

                    continue;
                }

                if (p == DomainName || FallbackToLocal) {
                    //
                    // This user has a local account
                    //

                    if (!pAddUser (UserName, NULL)) {
                        LOG ((
                            LOG_ERROR,
                            "Can't create local account for %s, this user can't be processed. (2)",
                            e.szName
                            ));
                    }

                } else {
                    //
                    // This user's domain name needs verification
                    //

                    if (!AddUserToDomainList (UserName, DomainName)) {
                        AddUserToDomainList (UserName, S_UNKNOWN_DOMAIN);
                    }
                }
            } while (MemDbEnumNextValue (&e));
        }

        //
        // Now resolve all the domain names
        //

        if (!FallbackToLocal) {
            do {
                g_DomainProblem = FALSE;
                pResolveUserDomains();

                PrepareForRetry();

            } while (pMakeSureAccountsAreValid());
        }

        //
        // If we had no choice but to make some accounts local,
        // put a message in the PSS log.
        //

        if (FallbackToLocal) {
            if (pWasWin9xOnTheNet() && !g_ConfigOptions.UseLocalAccountOnError) {
                LOG ((LOG_WARNING, (PCSTR)MSG_ALL_USERS_ARE_LOCAL, g_ComputerName));
            }
        }

        //
        // Make sure Administrator is in the account list
        //

        if (!GetSidForUser (g_AdministratorStr)) {
            if (!pAddUser (g_AdministratorStr, NULL)) {
                LOG ((LOG_ERROR, "Account name mismatch: %s", g_AdministratorStr));
                LocalizeWarning = TRUE;
            }
        }

        //
        // Add local "Everyone" for network account case
        //

        if (!pAddLocalGroup (g_EveryoneStr)) {
            LOG ((LOG_ERROR, "Account name mismatch: %s", g_EveryoneStr));
            LocalizeWarning = TRUE;
            __leave;
        }

        //
        // Add Administrators group
        //

        if (!pAddLocalGroup (g_AdministratorsGroupStr)) {
            LOG ((LOG_ERROR, "Account name mismatch: %s", g_AdministratorsGroupStr));
            LocalizeWarning = TRUE;
            __leave;
        }

        //
        // Add domain users group if domain is enabled, or add "none" group otherwise
        //

        if (!FallbackToLocal) {
            if (!pAddDomainGroup (g_DomainUsersGroupStr)) {
                DEBUGMSG ((DBG_WARNING, "Domain enabled but GetPrimaryDomainName failed"));
            }
        } else {
            if (!pAddLocalGroup (g_NoneGroupStr)) {
                LOG ((LOG_ERROR, "Account name mismatch: %s", g_NoneGroupStr));
                LocalizeWarning = TRUE;
                __leave;
            }
        }

        //
        // All user accounts and SIDs now exist in a user table, so we do not
        // need the account list anymore.
        //

        TerminateAccountList();
        DestroyStatusPopup();

        b = TRUE;
    }
    __finally {

#ifdef PRERELEASE
        if (LocalizeWarning) {
            LOG ((
                LOG_ERROR,
                "Account name mismatches are usually caused by improper localization.  "
                    "Make sure w95upgnt.dll account names match the LSA database."
                ));
        }
#endif

    }

    return b;
}


VOID
AutoStartProcessing (
    VOID
    )

/*++

Routine Description:

  AutoStartProcessing fills in the winlogon key's auto-admin logon, and sets
  migpwd.exe in Run.

  If necessary, Winlogon will prompt the user for their password.  As a backup,
  a RunOnce and Run entry is made.  (If some bug caused winlogon not to run
  this app, then it would be impossible to log on.)

  If an administrator password was already set via the AdminPassword line in
  [GUIUnattended], then the migpwd.exe entry is not used.

Arguments:

  None.

Return Value:

  None.

--*/

{
    HKEY WinlogonKey;
    HKEY RunKey;
    TCHAR Buf[32];
    PCTSTR MigPwdPath;
    BOOL AutoLogonOk = TRUE;
    LONG rc;
    MEMDB_ENUM e;
    DWORD One = 1;

    //
    // Enable auto-logon if random password was used
    //

    if (!MemDbGetValueEx (&e, MEMDB_CATEGORY_STATE, MEMDB_ITEM_ADMIN_PASSWORD, NULL)) {
        MYASSERT (FALSE);
        e.dwValue = PASSWORD_ATTR_RANDOM;
        e.szName[0] = 0;
        ClearAdminPassword();
    }

    MigPwdPath = JoinPaths (g_System32Dir, S_MIGPWD_EXE);

    //if ((e.dwValue & PASSWORD_ATTR_RANDOM) == PASSWORD_ATTR_RANDOM || g_RandomPassword) {

    //
    // Set AutoAdminLogon, DefaultUser, DefaultUserDomain and DefaultPassword
    //

    WinlogonKey = OpenRegKeyStr (S_WINLOGON_REGKEY);
    if (WinlogonKey) {
        rc = RegSetValueEx (
                WinlogonKey,
                S_DEFAULT_USER_NAME_VALUE,
                0,
                REG_SZ,
                (PBYTE) g_AdministratorStr,
                SizeOfString (g_AdministratorStr)
                );

        if (rc != ERROR_SUCCESS) {
            DEBUGMSG ((DBG_WHOOPS, "Can't set default user name"));
            AutoLogonOk = FALSE;
        }

        rc = RegSetValueEx (
                WinlogonKey,
                S_DEFAULT_DOMAIN_NAME_VALUE,
                0,
                REG_SZ,
                (PBYTE) g_ComputerName,
                SizeOfString (g_ComputerName)
                );

        if (rc != ERROR_SUCCESS) {
            DEBUGMSG ((DBG_WHOOPS, "Can't set default domain name"));
            AutoLogonOk = FALSE;
        }

        rc = RegSetValueEx (
                WinlogonKey,
                S_DEFAULT_PASSWORD_VALUE,
                0,
                REG_SZ,
                (PBYTE) e.szName,
                SizeOfString (e.szName)
                );

        if (rc != ERROR_SUCCESS) {
            DEBUGMSG ((DBG_WHOOPS, "Can't set administrator password"));
            AutoLogonOk = FALSE;
        }

        wsprintf (Buf, TEXT("%u"), 1);

        rc = RegSetValueEx (
                WinlogonKey,
                S_AUTOADMIN_LOGON_VALUE,
                0,
                REG_SZ,
                (PBYTE) Buf,
                SizeOfString (Buf)
                );

        if (rc != ERROR_SUCCESS) {
            DEBUGMSG ((DBG_WHOOPS, "Can't turn on auto logon"));
            AutoLogonOk = FALSE;
        }

        rc = RegSetValueEx (
                WinlogonKey,
                TEXT("SetWin9xUpgradePasswords"),
                0,
                REG_DWORD,
                (PBYTE) &One,
                sizeof (One)
                );

        if (rc != ERROR_SUCCESS) {
            DEBUGMSG ((DBG_WHOOPS, "Can't enable boot-time password prompt"));
        }

        CloseRegKey (WinlogonKey);

    } else {
        DEBUGMSG ((DBG_WHOOPS, "Can't open winlogon key"));
        AutoLogonOk = FALSE;
    }

    //
    // Add migpwd.exe to Run.
    //

    RunKey = OpenRegKeyStr (S_RUN_KEY);

    if (RunKey) {
        rc = RegSetValueEx (
                RunKey,
                S_MIGPWD,
                0,
                REG_SZ,
                (PBYTE) MigPwdPath,
                SizeOfString (MigPwdPath)
                );

        if (rc != ERROR_SUCCESS) {
            DEBUGMSG ((DBG_WHOOPS, "Can't set Run key value"));
            AutoLogonOk = FALSE;
        }

        CloseRegKey (RunKey);

    } else {
        DEBUGMSG ((DBG_WHOOPS, "Can't open Run key"));
        AutoLogonOk = FALSE;
    }

    RunKey = OpenRegKeyStr (S_RUNONCE_KEY);

    if (RunKey) {
        rc = RegSetValueEx (
                RunKey,
                S_MIGPWD,
                0,
                REG_SZ,
                (PBYTE) MigPwdPath,
                SizeOfString (MigPwdPath)
                );

        if (rc != ERROR_SUCCESS) {
            DEBUGMSG ((DBG_WHOOPS, "Can't set RunOnce key value"));
            AutoLogonOk = FALSE;
        }

        CloseRegKey (RunKey);

    } else {
        DEBUGMSG ((DBG_WHOOPS, "Can't open RunOnce key"));
        AutoLogonOk = FALSE;
    }

#if 0
    } else {
        DEBUGMSG ((DBG_ACCOUNTS, "Deleting %s because it is not needed", MigPwdPath));
        DeleteFile (MigPwdPath);
    }
#endif

    if (!AutoLogonOk) {
        LOG ((
            LOG_ACCOUNTS,
            "An error occurred preparing autologon.  There will be password problems."
            ));

        //
        // Set the Admin password to blank
        //

        ClearAdminPassword();
    }

    FreePathString (MigPwdPath);

}


VOID
pResolveUserDomains (
    VOID
    )

/*++

Routine Description:

    This private function searches the network for all users with unknown
    domains as well as users with manually entered domains.  It resolves
    as many users as it can, and if no network problems occur, all users
    are resolved.

Arguments:

    none

Return value:

    none

--*/

{
    ACCT_ENUM KnownDomain, UnknownDomain;
    ACCT_ENUM UserEnum;
    BOOL UnknownFlag, KnownFlag;
    PCWSTR Domain;
    UINT TotalDomains;
    UINT CurrentDomain;
    PCTSTR Message;
    PCTSTR ArgArray[3];
    BOOL FlashSuppress = TRUE;

    //
    // Determine if there are any users who do not have domains
    //

    UnknownFlag = FindDomainInList (&UnknownDomain, S_UNKNOWN_DOMAIN);
    if (UnknownFlag && !CountUsersInDomain (&UnknownDomain)) {
        UnknownFlag = FALSE;
    }

    //
    // Count the number of domains
    //

    Domain = ListFirstDomain (&KnownDomain);
    TotalDomains = 0;

    while (Domain) {
        //
        // We will query a domain when:
        //
        // - it is trusted
        // - there is one or more users who we think is in the domain
        // - or, there is one or more users which we don't know the domain
        //

        if (IsTrustedDomain (&KnownDomain)) {
            if (UnknownFlag) {
                TotalDomains++;
            } else if (CountUsersInDomain (&KnownDomain)) {
                TotalDomains++;
            }
        }

        Domain = ListNextDomain (&KnownDomain);
    }


    //
    // Enumerate each trusted domain
    //

    Domain = ListFirstDomain (&KnownDomain);
    CurrentDomain = 0;

    if (TotalDomains <= 4) {
        //
        // No status on small nets
        //

        HideStatusPopup (INFINITE);
        FlashSuppress = FALSE;
    }

    while (Domain) {
        if (IsTrustedDomain (&KnownDomain)) {
            //
            // Determine if there are any users for the current domain
            //

            KnownFlag = CountUsersInDomain (&KnownDomain) != 0;

            //
            // Process only if this domain needs to be queried -- either
            // domain is unknown, or it is known but unverified.
            //

            if (UnknownFlag || KnownFlag) {

                //
                // Update the status window
                //

                CurrentDomain++;

                ArgArray[0] = Domain;
                ArgArray[1] = (PCTSTR) CurrentDomain;
                ArgArray[2] = (PCTSTR) TotalDomains;

                Message = ParseMessageID (MSG_DOMAIN_STATUS_POPUP, ArgArray);
                UpdateStatusPopup (Message);
                FreeStringResource (Message);

                if (FlashSuppress) {
                    if (IsStatusPopupVisible()) {
                        FlashSuppress = FALSE;
                    } else if ((TotalDomains - CurrentDomain) <= 3) {
                        //
                        // Not much left, we better suspend the status dialog
                        //

                        HideStatusPopup (INFINITE);
                        FlashSuppress = FALSE;
                    }
                }

                //
                // Enumerate all users with unknown domains and look for them
                // in this domain, unless user wants to abort search.
                //

                if (g_RetryCount != DOMAIN_RETRY_ABORT) {
                    if (ListFirstUserInDomain (&UnknownDomain, &UserEnum)) {
                        do {
                            if (QueryDomainForUser (&KnownDomain, &UserEnum)) {
                                UserMayBeInDomain (&UserEnum, &KnownDomain);
                            }
                            if (g_RetryCount == DOMAIN_RETRY_ABORT) {
                                break;
                            }
                        } while (ListNextUserInDomain (&UserEnum));
                    }
                }

                //
                // Enumerate all users that are supposed to be in this domain,
                // unless user wants to abort search.
                //

                if (ListFirstUserInDomain (&KnownDomain, &UserEnum)) {
                    do {
                        if (g_RetryCount == DOMAIN_RETRY_ABORT ||
                            !QueryDomainForUser (&KnownDomain, &UserEnum)) {
                            //
                            // User was not found!  Put them in the "failed" domain
                            //

                            MoveUserToNewDomain (&UserEnum, S_FAILED_DOMAIN);
                        }
                    } while (ListNextUserInDomain (&UserEnum));
                }
            }
        }

        Domain = ListNextDomain (&KnownDomain);
    }
}


VOID
pAddUserToRegistryList (
    PCTSTR User,
    BOOL DomainFixList
    )
{
    HKEY Key;
    PCTSTR KeyStr;

    KeyStr = DomainFixList ? S_WINLOGON_USER_LIST_KEY : S_USER_LIST_KEY;

    Key = CreateRegKeyStr (KeyStr);

    if (Key) {
        RegSetValueEx (
            Key,
            User,
            0,
            REG_SZ,
            (PBYTE) S_EMPTY,
            sizeof (TCHAR)
            );

        CloseRegKey (Key);
    }
    ELSE_DEBUGMSG ((DBG_WHOOPS, "Can't create %s", KeyStr));
}


BOOL
pAddUser (
    IN      PCWSTR User,
    IN      PCWSTR Domain           OPTIONAL
    )

/*++

Routine Description:

    Adds a user and domain to our user list.  It obtains the SID for the user
    and saves the user name, domain and SID in a string table.  The profile
    path for the user is obtained via a call to CreateUserProfile (in userenv.dll).

    This function also maintains g_RandomPassword - a flag that is set to TRUE
    if a random password is used.

Arguments:

    User - Specifies fixed user name

    Domain - Specifies domain where user account exists, NULL for local machine

Return value:

    TRUE if no errors occur, or FALSE if an unexpected problem occurs and the
    user cannot be added.

--*/

{
    BOOL DupDomain = TRUE;
    USERDETAILS UserDetails;
    ACCOUNTPROPERTIES Account;
    DWORD rc;
    GROWBUFFER SidBuf = GROWBUF_INIT;
    TCHAR UserProfilePath[MAX_TCHAR_PATH];
    BOOL CreateAccountFlag;
    MEMDB_ENUM e;
    DWORD attribs = PASSWORD_ATTR_DEFAULT;
    TCHAR pattern[MEMDB_MAX];
    TCHAR randomPwd[16];
    TCHAR copyPwd[MEMDB_MAX];
    PCTSTR ArgList[1];
    PCTSTR autoLogon;
    PCTSTR autoLogonUserName;
    PCTSTR autoLogonDomainName;
    HKEY WinlogonKey;

    CreateAccountFlag = MemDbGetValueEx (
                            &e,
                            MEMDB_CATEGORY_USER_DAT_LOC,
                            User,
                            NULL
                            );

    ZeroMemory (&UserDetails, sizeof (UserDetails));

    //
    // Make sure the administrator account is created
    //
    if (CreateAccountFlag || StringIMatch (User, g_AdministratorStr)) {
        //
        // If a local account, create it
        //

        if (!Domain) {
            Account.User = User;
            Account.FullName = User;
            ArgList[0] = g_Win95Name;
            Account.AdminComment = ParseMessageID (MSG_MIGRATED_ACCOUNT_DESCRIPTION, ArgList);
            Account.EncryptedPassword = NULL;

            //
            // Set password. If installer specified a password for this user via an unattend
            // setting, we'll use that. Otherwise, if they have specified a default
            // password, we'll use that. Finally, if neither of those settings were
            // specified, we'll use a random password.
            //

            MemDbBuildKey (pattern, MEMDB_CATEGORY_USERPASSWORD, User, TEXT("*"), NULL);
            if (MemDbEnumFirstValue (
                    &e,
                    pattern,
                    MEMDB_ALL_SUBLEVELS,
                    MEMDB_ENDPOINTS_ONLY
                    )) {

                StackStringCopy (copyPwd, e.szName);
                attribs = e.dwValue;
                if (attribs & PASSWORD_ATTR_ENCRYPTED) {
                    //
                    // cannot use this hashed pwd to create the account
                    // create a random one that will be replaced
                    // using OWF hashing functions
                    //
                    pGenerateRandomPassword (randomPwd);
                    Account.Password = randomPwd;
                    Account.EncryptedPassword = copyPwd;
                    DEBUGMSG ((
                        DBG_ACCOUNTS,
                        "Per-user encrypted password specified for %s: %s",
                        Account.User,
                        Account.EncryptedPassword
                        ));
                } else {
                    Account.Password = copyPwd;
                    DEBUGMSG ((
                        DBG_ACCOUNTS,
                        "Per-user password specified for %s: %s",
                        Account.User,
                        Account.Password
                        ));
                }

            } else {
                if (g_ConfigOptions.DefaultPassword && !StringMatch (g_ConfigOptions.DefaultPassword, TEXT("*"))) {
                    if (g_ConfigOptions.EncryptedUserPasswords) {
                        pGenerateRandomPassword (randomPwd);
                        Account.Password = randomPwd;
                        Account.EncryptedPassword = g_ConfigOptions.DefaultPassword;
                        DEBUGMSG ((
                            DBG_ACCOUNTS,
                            "Default encrypted password specified for %s: %s",
                            Account.User,
                            Account.EncryptedPassword
                            ));
                    } else {
                        Account.Password = g_ConfigOptions.DefaultPassword;
                        DEBUGMSG ((
                            DBG_ACCOUNTS,
                            "Default password specified for %s: %s",
                            Account.User,
                            Account.Password
                            ));
                    }
                } else {
                    MemDbBuildKey (pattern, MEMDB_CATEGORY_USERPASSWORD, S_DEFAULTUSER, TEXT("*"), NULL);
                    if (MemDbEnumFirstValue (
                            &e,
                            pattern,
                            MEMDB_ALL_SUBLEVELS,
                            MEMDB_ENDPOINTS_ONLY
                            )) {

                        //
                        // check for the placeholder
                        //
                        if (StringMatch (e.szName, TEXT("*"))) {
                            e.szName[0] = 0;
                        }

                        StackStringCopy (copyPwd, e.szName);
                        attribs = e.dwValue;
                        if (attribs & PASSWORD_ATTR_ENCRYPTED) {
                            //
                            // cannot use this hashed pwd to create the account
                            // create a random one that will be replaced
                            // using OWF hashing functions
                            //
                            pGenerateRandomPassword (randomPwd);
                            Account.Password = randomPwd;
                            Account.EncryptedPassword = copyPwd;
                            DEBUGMSG ((
                                DBG_ACCOUNTS,
                                "Default encrypted password specified for %s: %s",
                                Account.User,
                                Account.EncryptedPassword
                                ));
                        } else {
                            Account.Password = copyPwd;
                            DEBUGMSG ((
                                DBG_ACCOUNTS,
                                "Per-user password specified for %s: %s",
                                Account.User,
                                Account.Password
                                ));
                        }

                    } else {

                        pGenerateRandomPassword (randomPwd);
                        Account.Password = randomPwd;
                        LOG ((LOG_ACCOUNTS, "Random password for %s is %s", Account.User, Account.Password));

                        g_RandomPassword = TRUE;
                        attribs = PASSWORD_ATTR_RANDOM;
                        pAddUserToRegistryList (Account.User, FALSE);
                    }
                }
            }
            Account.PasswordAttribs = attribs;

            //
            // put this user in the domain fix list if necessary
            //

            if (StringIMatch (User, g_AdministratorStr)) {
                if (!MemDbGetValueEx (&e, MEMDB_CATEGORY_STATE, MEMDB_ITEM_ADMIN_PASSWORD, NULL)) {
                    MYASSERT (FALSE);
                    e.dwValue = PASSWORD_ATTR_RANDOM;
                }
                if (e.dwValue & PASSWORD_ATTR_RANDOM) {
                    //
                    // change the password for admin, too, because it was randomly generated
                    //
                    pAddUserToRegistryList (g_AdministratorStr, FALSE);
                }
                //
                // don't change admin password now if the account is already created
                //
                Account.PasswordAttribs |= PASSWORD_ATTR_DONT_CHANGE_IF_EXIST;
            } else if (pWasWin9xOnTheNet()) {
                pAddUserToRegistryList (Account.User, TRUE);
            }

            //
            // Now create the local account
            //

            rc = CreateLocalAccount (&Account, NULL);

            FreeStringResource (Account.AdminComment);

            if (rc != ERROR_SUCCESS) {
                if (rc != ERROR_PASSWORD_RESTRICTION && rc != ERROR_INVALID_PARAMETER) {
                    //
                    // account could not be created
                    //
                    SetLastError (rc);
                    LOG ((LOG_ERROR, (PCSTR)MSG_CREATE_ACCOUNT_FAILED, User));

                    return FALSE;
                }
                //
                // this user's password must be re-set
                //
                pAddUserToRegistryList (Account.User, FALSE);

            } else if (!(Account.PasswordAttribs & (PASSWORD_ATTR_RANDOM | PASSWORD_ATTR_ENCRYPTED))) {

                //
                // The account was created. If AutoAdminLogon is enabled,
                // make sure the DefaultPassword value matches the password
                // we set for DefaultUserName
                //
                WinlogonKey = OpenRegKeyStr (S_WINLOGON_REGKEY);
                if (WinlogonKey) {

                    autoLogon = GetRegValueString (WinlogonKey, S_AUTOADMIN_LOGON_VALUE);
                    if (autoLogon) {
                        if (_ttoi (autoLogon)) {
                            //
                            // make sure the autologon account is local
                            //
                            autoLogonDomainName = GetRegValueString (WinlogonKey, S_DEFAULT_DOMAIN_NAME_VALUE);
                            if (autoLogonDomainName) {
                                if (StringIMatch (autoLogonDomainName, g_ComputerName)) {
                                    autoLogonUserName = GetRegValueString (WinlogonKey, S_DEFAULT_USER_NAME_VALUE);
                                    if (autoLogonUserName) {
                                        if (StringIMatch (autoLogonUserName, Account.User)) {

                                            rc = RegSetValueEx (
                                                    WinlogonKey,
                                                    S_DEFAULT_PASSWORD_VALUE,
                                                    0,
                                                    REG_SZ,
                                                    (PBYTE) Account.Password,
                                                    SizeOfString (Account.Password)
                                                    );

                                            if (rc != ERROR_SUCCESS) {
                                                LOG ((LOG_WARNING, "Unable to set %s\\%s (%u), AutoLogon might fail", S_WINLOGON_REGKEY, S_DEFAULT_PASSWORD_VALUE, rc));
                                            }


                                        }
                                        MemFree (g_hHeap, 0, autoLogonUserName);
                                    }
                                }
                                MemFree (g_hHeap, 0, autoLogonDomainName);
                            }
                        }
                        MemFree (g_hHeap, 0, autoLogon);
                    }

                    CloseRegKey (WinlogonKey);
                }
            }

            DupDomain = FALSE;

        }
    } else {

        DupDomain = FALSE;

    }

    if (DupDomain) {
        UserDetails.Domain = PoolMemDuplicateString (g_UserPool, Domain);
    }

    //
    // Get SID, looping until it's valid
    //

    do {
        if (GetUserSid (User, Domain, &SidBuf)) {
            //
            // User SID was found, so we copy it to our pool and throw away the
            // grow buffer.
            //

            UserDetails.Sid = (PSID) PoolMemGetMemory (g_UserPool, SidBuf.End);
            CopyMemory (UserDetails.Sid, SidBuf.Buf, SidBuf.End);
            FreeGrowBuffer (&SidBuf);
        }
        else {
            //
            // User SID was not found.  We ask the user if they wish to retry.
            //

            PCWSTR ArgArray[1];

            ArgArray[0] = User;

            if (!RetryMessageBox (MSG_SID_RETRY, ArgArray)) {

                if (!Domain) {
                    LOG ((LOG_ERROR, (PCSTR)MSG_SID_LOOKUP_FAILED, User));
                    return FALSE;
                } else {
                    LOG ((LOG_ERROR, "Can't get SID for %s on %s, going to local account", User, Domain));
                    return pAddUser (User, NULL);
                }
            }
        }
    } while (!UserDetails.Sid);

    if (CreateAccountFlag) {
        //
        // Get the user profile path
        //

        if (!CreateUserProfile (UserDetails.Sid, User, NULL, UserProfilePath, MAX_TCHAR_PATH)) {

            LOG ((LOG_ERROR, (PCSTR)MSG_PROFILE_LOOKUP_FAILED, User));

            return FALSE;
        }

        UserDetails.ProfilePath = PoolMemDuplicateString (g_UserPool, UserProfilePath);
        DEBUGMSG ((DBG_ACCOUNTS, "User %s has profile path %s", User, UserProfilePath));
    }

    //
    // Save user details in string table
    //

    pSetupStringTableAddStringEx (
        g_UserTable,
        (PWSTR) User,
        STRTAB_CASE_INSENSITIVE,
        (PBYTE) &UserDetails,
        sizeof (USERDETAILS)
        );

    DEBUGMSG_IF ((Domain != NULL, DBG_ACCOUNTS, "%s\\%s added to user list", Domain, User));
    DEBUGMSG_IF ((Domain == NULL, DBG_ACCOUNTS, "%s added to user list", User));

    return TRUE;
}


BOOL
pAddLocalGroup (
    IN      PCWSTR Group
    )

/*++

Routine Description:

    Adds a local group to the array of users.  This function allows local accounts
    to be added to the user list.

Arguments:

    Group - Specifies the name of the local group to add to the list

Return value:

    TRUE if add was successful

--*/

{
    USERDETAILS UserDetails;
    GROWBUFFER SidBuf = GROWBUF_INIT;

    UserDetails.Domain = NULL;
    UserDetails.Sid = NULL;

    if (GetUserSid (Group, NULL, &SidBuf)) {
        //
        // User SID was found, so we copy it to our pool and throw away the
        // grow buffer.
        //

        UserDetails.Sid = (PSID) PoolMemGetMemory (g_UserPool, SidBuf.End);
        CopyMemory (UserDetails.Sid, SidBuf.Buf, SidBuf.End);
        FreeGrowBuffer (&SidBuf);
    } else {
        LOG ((LOG_ERROR, "%s is not a local group", Group));
        return FALSE;
    }

    pSetupStringTableAddStringEx (
        g_UserTable,
        (PWSTR) Group,
        STRTAB_CASE_INSENSITIVE,
        (PBYTE) &UserDetails,
        sizeof (USERDETAILS)
        );

    DEBUGMSG ((DBG_ACCOUNTS, "%s added to user list", Group));

    return TRUE;
}


BOOL
pAddDomainGroup (
    IN      PCWSTR Group
    )

/*++

Routine Description:

    Adds a domain group to the array of users.  This function is used to
    add network domain groups to the user list.

Arguments:

    Group - Specifies the name of the domain group to add to the list

Return value:

    TRUE if add was successful

--*/

{
    TCHAR DomainName[MAX_SERVER_NAME];
    BYTE SidBuffer[MAX_SID_SIZE];
    USERDETAILS UserDetails;
    GROWBUFFER SidBuf = GROWBUF_INIT;

    if (!GetPrimaryDomainName (DomainName)) {
        DEBUGMSG ((DBG_WARNING, "Can't get primary domain name"));
        return FALSE;
    }

    if (!GetPrimaryDomainSid (SidBuffer, sizeof (SidBuffer))) {
        LOG ((LOG_ERROR, "Can't get primary domain SID of %s", DomainName));
        return FALSE;
    }

    UserDetails.Domain = DomainName;
    UserDetails.Sid = (PSID) SidBuffer;

    if (GetUserSid (Group, DomainName, &SidBuf)) {
        //
        // User SID was found, so we copy it to our pool and throw away the
        // grow buffer.
        //

        UserDetails.Sid = (PSID) PoolMemGetMemory (g_UserPool, SidBuf.End);
        CopyMemory (UserDetails.Sid, SidBuf.Buf, SidBuf.End);
        FreeGrowBuffer (&SidBuf);
    } else {
        DEBUGMSG ((DBG_WARNING, "Can't get SID of %s in %s", Group, DomainName));
        FreeGrowBuffer (&SidBuf);
        return FALSE;
    }

    pSetupStringTableAddStringEx (
        g_UserTable,
        (PWSTR) Group,
        STRTAB_CASE_INSENSITIVE,
        (PBYTE) &UserDetails,
        sizeof (USERDETAILS)
        );

    DEBUGMSG ((DBG_ACCOUNTS, "%s\\%s added to user list", DomainName, Group));

    return TRUE;
}


VOID
pResolveMultipleDomains (
    VOID
    )

/*++

Routine Description:

    Perpares an array of users and presents a dialog allowing the installer
    to choose an action for each user.  A user may be a local user, multiple domains
    may be resolved, or the installer may choose to retry the account search.

    The account list is updated based on the installer's choices.

Arguments:

    none

Return value:

    none

--*/

{
    GROWBUFFER UserList = GROWBUF_INIT;
    POOLHANDLE UserListData = NULL;
    ACCT_ENUM UserEnum;
    DWORD PossibleDomains;
    PRESOLVE_ACCOUNTS_ARRAY Array = NULL;
    PCTSTR User;
    PCTSTR Domain;
    PCTSTR *DomainList;

    __try {

        UserListData = PoolMemInitNamedPool ("UserListData");

        //
        // Create list of user accounts and allow the installer to decide weather
        // to retry the search, use a local account, or choose a domain when
        // multiple choices exist.
        //

        if (FindDomainInList (&UserEnum, S_UNKNOWN_DOMAIN)) {
            User = ListFirstUserInDomain (&UserEnum, &UserEnum);
            while (User) {
                PossibleDomains = CountPossibleDomains (&UserEnum);

                Array = (PRESOLVE_ACCOUNTS_ARRAY) GrowBuffer (
                                                        &UserList,
                                                        sizeof (RESOLVE_ACCOUNTS_ARRAY)
                                                        );
                ZeroMemory (Array, sizeof (RESOLVE_ACCOUNTS_ARRAY));

                Array->UserName = PoolMemDuplicateString (UserListData, User);

                Array->DomainArray = (PCTSTR *) PoolMemGetAlignedMemory (
                                                    UserListData,
                                                    (PossibleDomains + 1) * sizeof (PCTSTR)
                                                    );

                DomainList = Array->DomainArray;

                Domain = ListFirstPossibleDomain (&UserEnum, &UserEnum);
                while (Domain) {
                    *DomainList = PoolMemDuplicateString (UserListData, Domain);
                    DomainList++;

                    Domain = ListNextPossibleDomain (&UserEnum);
                }

                *DomainList = NULL;

                //
                // If UseLocalAccountOnError config option is TRUE, we set OutboundDomain
                // to NULL, ensuring a Local Account.
                //
                if (g_ConfigOptions.UseLocalAccountOnError) {
                    Array->OutboundDomain = NULL;
                    Array->RetryFlag = FALSE;
                }
                else {
                    Array->OutboundDomain = *Array->DomainArray;
                    Array->RetryFlag = TRUE;
                }

                User = ListNextUserInDomain (&UserEnum);
            }
        }

        if (!Array) {
            //
            // No unresolved users
            //

            return;
        }


        //
        // If UseLocalAccountOnError is specified, we've already set all unresolved accounts to
        // Local account and we aren't going to throw up any UI. Otherwise, we'll give the user
        // the resolve UI.
        //
        if (!g_ConfigOptions.UseLocalAccountOnError) {

            Array = (PRESOLVE_ACCOUNTS_ARRAY) GrowBuffer (
                &UserList,
                sizeof (RESOLVE_ACCOUNTS_ARRAY)
                );

            ZeroMemory (Array, sizeof (RESOLVE_ACCOUNTS_ARRAY));

            ResolveAccounts ((PRESOLVE_ACCOUNTS_ARRAY) UserList.Buf);
        }

        //
        // Now process the installer's changes to the user list
        //

        Array = (PRESOLVE_ACCOUNTS_ARRAY) UserList.Buf;
        FindDomainInList (&UserEnum, S_UNKNOWN_DOMAIN);

        while (Array->UserName) {
            if (!FindUserInDomain (&UserEnum, &UserEnum, Array->UserName)) {
                DEBUGMSG ((DBG_WHOOPS, "Could not find user name %s in array!", Array->UserName));
            }
            else if (!Array->RetryFlag) {
                //
                // The installer chose either to make the account local, or to
                // use one of the several possible domains.
                //

                pAddUser (Array->UserName, Array->OutboundDomain);
                DeleteUserFromDomainList (&UserEnum);
            } else {
                ClearPossibleDomains (&UserEnum);
            }

            Array++;
        }
    }
    __finally {
        FreeGrowBuffer (&UserList);
        PoolMemDestroyPool (UserListData);
    }
}


BOOL
pMakeSureAccountsAreValid (
    VOID
    )

/*++

Routine Description:

    Scans the domain lists and adds all valid users to our user list.  Any
    invalid users are put back in the unknown domain.

Arguments:

    none

Return value:

    TRUE if unresolved users exist (meaning the installer wants to retry
    searching), or FALSE if all domains for each user has been resolved.

--*/

{
    ACCT_ENUM UserEnum;
    INT PossibleDomains;
    PCWSTR Domain;
    PCWSTR User;
    BOOL b;

    //
    // Scan the unknown list for matches where one domain was found
    //

    if (FindDomainInList (&UserEnum, S_UNKNOWN_DOMAIN)) {
        User = ListFirstUserInDomain (&UserEnum, &UserEnum);
        while (User) {
            PossibleDomains = CountPossibleDomains (&UserEnum);

            if (PossibleDomains == 1 && !g_DomainProblem) {
                Domain = ListFirstPossibleDomain (&UserEnum, &UserEnum);

                pAddUser (User, Domain);
                DeleteUserFromDomainList (&UserEnum);
            }

            User = ListNextUserInDomain (&UserEnum);
        }
    }

    //
    // Add all correct known accounts to our user list
    //

    Domain = ListFirstDomain (&UserEnum);
    while (Domain) {
        if (!IsTrustedDomain (&UserEnum)) {
            Domain = ListNextDomain (&UserEnum);
            continue;
        }

        User = ListFirstUserInDomain (&UserEnum, &UserEnum);
        while (User) {
            pAddUser (User, Domain);
            DeleteUserFromDomainList (&UserEnum);
            User = ListNextUserInDomain (&UserEnum);
        }

        Domain = ListNextDomain (&UserEnum);
    }

    //
    // Move the failed list to the unknown list
    //

    if (FindDomainInList (&UserEnum, S_FAILED_DOMAIN)) {

        User = ListFirstUserInDomain (&UserEnum, &UserEnum);

        while (User) {

            if (g_ConfigOptions.UseLocalAccountOnError) {
                pAddUser (User, NULL);
                DeleteUserFromDomainList (&UserEnum);
            } else {
                MoveUserToNewDomain (&UserEnum, S_UNKNOWN_DOMAIN);
            }

            User = ListNextUserInDomain (&UserEnum);
        }
    }

    //
    // Provide UI for remaining unknowns, allowing manual decision
    // weather to make account local, or to decide between multiple
    // domain matches.
    //

    HideStatusPopup (INFINITE);
    pResolveMultipleDomains();

    //
    // Return TRUE if the unknown domain is not empty
    //

    b = FindDomainInList (&UserEnum, S_UNKNOWN_DOMAIN);
    if (b) {
        b = CountUsersInDomain (&UserEnum) != 0;

        if (b) {
            HideStatusPopup (STATUS_DELAY);
        }
    }

    return b;
}


BOOL
pGetUserDetails (
    IN      PCWSTR User,
    OUT     PUSERDETAILS DetailsPtr
    )

/*++

Routine Description:

    A common routine that locates the USERDETAILS structure for a
    given user.

Arguments:

    User - Specifies fixed user name

    DetailsPtr - Receives the structure for the user

Return value:

    TRUE if the user details were found, or FALSE if the user does
    not exist.

--*/

{
    return (-1 != pSetupStringTableLookUpStringEx (
                    g_UserTable,
                    (PWSTR) User,
                    STRTAB_CASE_INSENSITIVE,
                    (PBYTE) DetailsPtr,
                    sizeof(USERDETAILS)
                    ));
}


PCWSTR
GetDomainForUser (
    IN      PCWSTR User
    )

/*++

Routine Description:

    Given a user name, this function returns a pointer to the domain name
    maintained in the user list for the specified user.

    Since Windows 95 does not support multiple domains for a single user,
    the user list doesn't either.

Arguments:

    User - Specifies fixed user name

Return value:

    A pointer to the domain name for the user, or NULL if the user was not
    found.

--*/

{
    USERDETAILS Details;

    if (pGetUserDetails (User, &Details)) {
        return Details.Domain;
    }

    return NULL;
}


PSID
GetSidForUser (
    PCWSTR User
    )

/*++

Routine Description:

    Given a user name, this function returns a pointer to the SID maintained
    in the user list for the specified user.

Arguments:

    User - Specifies fixed user name

Return value:

    A pointer to the SID for the user, or NULL if the user was not found.

--*/

{
    USERDETAILS Details;

    if (pGetUserDetails (User, &Details)) {
        return Details.Sid;
    }

    return NULL;
}


PCWSTR
GetProfilePathForUser (
    IN      PCWSTR User
    )

/*++

Routine Description:

    Given a user name, this function returns a pointer to the user's
    profile, maintained in the user list for the specified user.

Arguments:

    User - Specifies fixed user name

Return value:

    A pointer to the user's profile path, or NULL if the specified user
    was not in the list.

--*/

{
    USERDETAILS Details;

    if (pGetUserDetails (User, &Details)) {
        return Details.ProfilePath;
    }

    return NULL;
}


BOOL
pWasWin9xOnTheNet (
    VOID
    )

/*++

Routine Description:

    Queries memdb to determine if the machine had the MS Networking Client
    installed.

Arguments:

    none

Return value:

    TRUE if the Win9x configuration had MSNP32 installed, FALSE if not.

--*/

{
    TCHAR Node[MEMDB_MAX];

    MemDbBuildKey (Node, MEMDB_CATEGORY_STATE, MEMDB_ITEM_MSNP32, NULL, NULL);
    return MemDbGetValue (Node, NULL);
}


VOID
pGenerateRandomPassword (
    OUT     PTSTR Password
    )

/*++

Routine Description:

  pGenerateRandomPassword creates a password of upper-case, lower-case and
  numeric letters.  The password has a length between 8 and 14
  characters.

Arguments:

  Password - Receives the generated password

Return Value:

  none

--*/

{
    INT Length;
    TCHAR Offset;
    INT Limit;
    PTSTR p;

    //
    // Generate a random length based on the tick count
    //

    srand (GetTickCount());

    Length = (rand() % 6) + 8;

    p = Password;
    while (Length) {
        Limit = rand() % 3;
        Offset = TEXT(' ');

        if (Limit == 0) {
            Limit = 10;
            Offset = TEXT('0');
        } else if (Limit == 1) {
            Limit = 26;
            Offset = TEXT('a');
        } else if (Limit == 2) {
            Limit = 26;
            Offset = TEXT('A');
        }

        *p = Offset + (rand() % Limit);
        p++;

        Length--;
    }

    *p = 0;

    DEBUGMSG ((DBG_ACCOUNTS, "Generated password: %s", Password));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\merge\hwprof.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    hwprof.c

Abstract:

    Hardware profile merge code

Author:

    Jim Schmidt (jimschm) 29-May-1997

Revision History:


--*/

#include "pch.h"
#include "mergep.h"

HASHTABLE g_SoftwareDefaultListHash = NULL;

typedef struct _HARDWARE_PROFILE {
    DWORD NumberOnWin9x;
} HARDWARE_PROFILE, *PHARDWARE_PROFILE;

GROWLIST g_HardwareProfileList = GROWLIST_INIT;

BOOL
pCreateDefaultKey (
    LPCTSTR BaseRegStr
    );

BOOL
pCopyHwProfileProperties (
    IN      DWORD ProfileSrcId, 
    IN      DWORD ProfileDestId
    );

FILTERRETURN
pHwProfileEnumFilter (
    IN  CPDATAOBJECT   SrcObjectPtr,
    IN  CPDATAOBJECT   Unused,             OPTIONAL
    IN  FILTERTYPE     FilterType,
    IN  LPVOID         FilterArg           OPTIONAL
    );

BOOL
pCopyHwProfileConfigData (
    IN      DWORD ProfileSrcId, 
    IN      DWORD ProfileDestId
    );

VOID 
pDeleteProfilesConfigValues(
    IN      DWORD ConfigNumber
    );

BOOL
pDeleteDefaultKey (
    IN      LPCTSTR BaseRegStr
    );

DWORD 
pGetCurrentConfig (
    VOID
    );

BOOL
pCopyCurrentConfig (
    VOID
    );

VOID 
pProcessSoftwareDefaultList(
    IN  HINF    InfFile, 
    IN  PCTSTR  Section
    );

VOID 
pFreeSoftwareDefaultList(
    VOID
    );

VOID 
pMigrateHardwareProfiles(
    VOID
    );

BOOL
CopyHardwareProfiles (
    IN  HINF InfFile
    )
{
    BOOL b;
    DATAOBJECT Win9xOb;

    //
    // Move current hardware profile into Default key
    //

    if (!pCreateDefaultKey (S_IDCONFIGDB_HW_KEY)) {
        LOG ((LOG_ERROR, "Unable to complete CopyHardwareProfiles"));
        return FALSE;
    }

    if (!pCreateDefaultKey (S_NT_CONFIG_KEY)) {
        LOG ((LOG_ERROR, "Unable to complete CopyHardwareProfiles (2)"));
        return FALSE;
    }

    //
    // Enumerate all Win9x hardware profiles and copy each one
    //

    pProcessSoftwareDefaultList(InfFile, S_MERGE_WIN9X_SUPPRESS_SFT_D);

    b = CreateObjectStruct (S_9X_CONFIG_KEY S_TREE, &Win9xOb, WIN95OBJECT);
    MYASSERT(b);

    b = FILTER_RETURN_FAIL != CopyObject (&Win9xOb, 
                                          NULL, 
                                          pHwProfileEnumFilter, 
                                          (PVOID)pGetCurrentConfig());

    pFreeSoftwareDefaultList();

    pMigrateHardwareProfiles();

    //
    // Clean up Default key
    //

    pDeleteDefaultKey (S_IDCONFIGDB_HW_KEY);
    pDeleteDefaultKey (S_NT_CONFIG_KEY);

    //
    // Set the current config value
    //
    // b = pCopyCurrentConfig();

    FreeObjectStruct (&Win9xOb);

    return b;
}


FILTERRETURN
pHwProfileSuppressFilter (
    IN  CPDATAOBJECT   SrcObjectPtr,
    IN  CPDATAOBJECT   DestObjectPtr,      OPTIONAL
    IN  FILTERTYPE     FilterType,
    IN  LPVOID         UnusedArg           OPTIONAL
    )
{
    TCHAR ObStr[MAX_ENCODED_RULE];
    LPTSTR p;
    TCHAR Node[MEMDB_MAX];

    if (FilterType == FILTER_CREATE_KEY) {
        // Create empty key is unnecessary
        return FILTER_RETURN_HANDLED;
    }

    else if (FilterType == FILTER_KEY_ENUM ||
             FilterType == FILTER_PROCESS_VALUES ||
             FilterType == FILTER_VALUENAME_ENUM
             ) {
        // Make p point to HKLM\Config\0001\...
        CreateObjectString (SrcObjectPtr, ObStr);
        p = ObStr;

        // Make p point to \Config\0001\subkey
        p = _tcschr (p, TEXT('\\'));
        if (p) {
            // Make p point to \0001\subkey
            p = _tcschr (_tcsinc (p), TEXT('\\'));
            if (p) {
                // Make p point to \subkey
                p = _tcschr (_tcsinc (p), TEXT('\\'));
                if (p) {
                    // Make p point to subkey
                    p = _tcsinc (p);
                } else {
                    p = S_EMPTY;
                }
            }
        }

        if (!p) {
            DEBUGMSG ((
                DBG_WHOOPS,
                "pHwProfileSuppressFilter: Not a hardware profile key: %s",
                ObStr
                ));

            return FILTER_RETURN_FAIL;
        }

        //
        // If an entry exists in memdb's HKCC category, we have a
        // suppression match
        //

        wsprintf (Node, TEXT("HKCC\\%s"), p);
        if (MemDbGetValue (Node, NULL)) {
            return FILTER_RETURN_HANDLED;
        }
    }

    return FILTER_RETURN_CONTINUE;
}

VOID 
pProcessSoftwareDefaultList(
    IN  HINF    InfFile, 
    IN  PCTSTR  Section
    )
{
    INFCONTEXT ic;
    TCHAR SrcObjectStr[MAX_ENCODED_RULE];

    g_SoftwareDefaultListHash = HtAllocW();

    if(!g_SoftwareDefaultListHash){
        LOG ((LOG_ERROR, "pProcessSoftwareDefaultList: Can't create hash table"));
        return;
    }

    if(SetupFindFirstLine (InfFile, Section, NULL, &ic)){
        do{
            if(SetupGetStringField (&ic, 1, SrcObjectStr, MAX_ENCODED_RULE, NULL)){
                FixUpUserSpecifiedObject(SrcObjectStr);
                HtAddString(g_SoftwareDefaultListHash, SrcObjectStr);
            }
            else{
                LOG ((LOG_ERROR, "pProcessSoftwareDefaultList: syntax error in line %u of section %s in wkstamig.inf", 
                     ic.Line, Section));
            }
        } while (SetupFindNextLine (&ic, &ic));
    }
    else{
        DEBUGMSG ((DBG_VERBOSE, "pProcessSoftwareDefaultList: Section %s can't be found", Section));
    }
}

VOID 
pFreeSoftwareDefaultList(
    VOID
    )
{
    INFCONTEXT ic;
    TCHAR SrcObjectStr[MAX_ENCODED_RULE];

    if(g_SoftwareDefaultListHash){
        HtFree(g_SoftwareDefaultListHash);
        g_SoftwareDefaultListHash = NULL;
    }
}

FILTERRETURN
pHwSoftwareDefaultDetectFilter (
    IN  CPDATAOBJECT   SrcObjectPtr,
    IN  CPDATAOBJECT   DestObjectPtr,      OPTIONAL
    IN  FILTERTYPE     FilterType,
    IN  LPVOID         Arg
    )
{
    TCHAR ObStr[MAX_ENCODED_RULE];
    LPTSTR p;
    TCHAR Node[MEMDB_MAX];
    BOOL * notDefault;

    if(!Arg){
        MYASSERT(FALSE);
        return FILTER_RETURN_FAIL;
    }

    notDefault = Arg;


    if (FilterType == FILTER_VALUENAME_ENUM){
        // Make p point to HKLM\Config\0001\...
        CreateObjectString (SrcObjectPtr, ObStr);
        p = ObStr;

        // Make p point to \Config\0001\Software\subkey
        p = _tcschr (p, TEXT('\\'));
        if (p) {
            // Make p point to \0001\Software\subkey
            p = _tcschr (_tcsinc (p), TEXT('\\'));
            if (p) {
                // Make p point to \Software\subkey
                p = _tcschr (_tcsinc (p), TEXT('\\'));
                if (p) {
                    // Make p point to \subkey
                    p = _tcschr (_tcsinc (p), TEXT('\\'));
                    if (p) {
                        // Make p point to subkey
                        p = _tcsinc (p);
                    } else {
                        p = S_EMPTY;
                    }
                }
            }
        }

        if (!p) {
            DEBUGMSG ((
                DBG_ERROR,
                "pHwSoftwareDefaultDetectFilter: Not a hardware profile key: %s",
                ObStr
                ));

            return FILTER_RETURN_FAIL;
        }

        //
        // If an entry exists in memdb's HKCC category, we have a
        // suppression match
        //

        wsprintf (Node, TEXT("HKCC\\Software\\%s"), p);
        if(MemDbGetValue(Node, NULL)) {
            return FILTER_RETURN_CONTINUE;
        }
        
        wsprintf (Node, TEXT("HKCCS\\%s"), p);
        if(HtFindString(g_SoftwareDefaultListHash, Node)){
            return FILTER_RETURN_CONTINUE;
        }

        DEBUGMSG((DBG_VERBOSE, "pHwSoftwareDefaultDetectFilter(%s): not-default profile", Node));
        *notDefault = TRUE;

        return FILTER_RETURN_FAIL;
    }
    
    return FILTER_RETURN_CONTINUE;
}

BOOL 
pIsSoftwareBranchDefault(
    IN  DWORD ConfigNumber
    )
{
    BOOL b;
    DATAOBJECT Win9xOb;
    TCHAR keyName[MAX_TCHAR_PATH];
    BOOL notDefault;

    wsprintf(keyName, S_9X_CONFIG_MASK S_SOFTWARE S_TREE, ConfigNumber);

    b = CreateObjectStruct(keyName, &Win9xOb, WIN95OBJECT);
    MYASSERT(b);

    if(!b){
        return TRUE;
    }

    notDefault = FALSE;
    CopyObject(&Win9xOb, 
               NULL, 
               pHwSoftwareDefaultDetectFilter, 
               (PVOID)&notDefault);

    FreeObjectStruct(&Win9xOb);

    return !notDefault;
}

FILTERRETURN
pHwProfileEnumFilter (
    IN  CPDATAOBJECT   SrcObjectPtr,
    IN  CPDATAOBJECT   Unused,             OPTIONAL
    IN  FILTERTYPE     FilterType,
    IN  LPVOID         FilterArg           OPTIONAL
    )
{
    LPCTSTR p;
    DWORD   CurrentConfig = (DWORD)FilterArg;
    HARDWARE_PROFILE hardwareProfile;

    MYASSERT(CurrentConfig);

    if (FilterType == FILTER_KEY_ENUM) {
        // Make p point to 0001\Subkey
        p = _tcschr (SrcObjectPtr->KeyPtr->KeyString, TEXT('\\'));
        if (!p) {
            // Object string is premature -- keep enumerating
            return FILTER_RETURN_CONTINUE;
        } else {
            p = _tcsinc (p);
        }

        // Get current configuration number
        hardwareProfile.NumberOnWin9x = _ttoi (p);

        MYASSERT(hardwareProfile.NumberOnWin9x);

        if(hardwareProfile.NumberOnWin9x == CurrentConfig){
            if(GrowListGetSize(&g_HardwareProfileList)){
                GrowListInsert(&g_HardwareProfileList, 0, (PBYTE)&hardwareProfile, sizeof(hardwareProfile));
            }
            else{
                GrowListAppend(&g_HardwareProfileList, (PBYTE)&hardwareProfile, sizeof(hardwareProfile));
            }
        }
        else if(!pIsSoftwareBranchDefault(hardwareProfile.NumberOnWin9x)){
            GrowListAppend(&g_HardwareProfileList, (PBYTE)&hardwareProfile, sizeof(hardwareProfile));
        }
    }
    
    return FILTER_RETURN_HANDLED;
}






    /*
         The current hardware profile is used as the "default" hardware
          profile. The Windows NT key Hardware Profiles\0001 is renamed
          to Hardware Profiles\Default for temporary use.
         The Windows NT defaults are used as the base of all upgraded profiles.
          For each hardware profile on Windows 9x, a Hardware Profiles\<n> key
          is created, where <n> is the numeric identifier of the Windows 9x
          hardware profile.  All values and subkeys of Hardware Profiles\Default
          are copied to this new key.
         The Windows 9x settings are copied to NT.  For each hardware profile
          on Windows 9x, the entire registry tree in Config\<n> is copied to
          Hardware Profiles\<n>, where <n> is the four-digit hardware profile
          numeric identifier.
         The default settings are deleted.  Setup removes the Hardware
          Profiles\Default key.
    */


BOOL
pCreateDefaultKey (
    LPCTSTR BaseRegStr
    )
{
    DATAOBJECT SrcOb, DestOb;
    TCHAR SrcObStr[MAX_ENCODED_RULE];
    TCHAR DestObStr[MAX_ENCODED_RULE];
    BOOL b;

    wsprintf (SrcObStr, TEXT("%s\\%s\\*") , BaseRegStr, S_HW_ID_0001);
    b = CreateObjectStruct (SrcObStr, &SrcOb, WINNTOBJECT);
    MYASSERT(b);

    wsprintf (DestObStr, TEXT("%s\\%s\\*"), BaseRegStr, S_HW_DEFAULT);
    b = CreateObjectStruct (DestObStr, &DestOb, WINNTOBJECT);
    MYASSERT(b);

    b = RenameDataObject (&SrcOb, &DestOb);

    FreeObjectStruct (&SrcOb);
    FreeObjectStruct (&DestOb);

    if (!b) {
        LOG ((LOG_ERROR, "CreateDefaultKey: Could not rename %s to %s", SrcObStr, DestObStr));
    }

    return b;
}

VOID 
pDeleteProfilesConfigValues(
    IN      DWORD ConfigNumber
    )
{
    DATAOBJECT Object;
    TCHAR ObStr[MAX_ENCODED_RULE];
    BOOL bResult;
    UINT i;
    static PCTSTR ObjectsValue[] =  {
                                        TEXT("Aliasable"), 
                                        TEXT("Cloned"), 
                                        TEXT("HwProfileGuid")
                                    };

    for(i = 0; i < ARRAYSIZE(ObjectsValue); i++){
        wsprintf (ObStr, S_NT_HW_ID_MASK TEXT("\\[%s]"), ConfigNumber, ObjectsValue[i]);
        
        bResult = CreateObjectStruct (ObStr, &Object, WINNTOBJECT);
        if(!bResult){
            MYASSERT(FALSE);
            continue;
        }
        
        bResult = DeleteDataObjectValue (&Object);
        MYASSERT(bResult);
        
        FreeObjectStruct (&Object);
    }
    
    return;
}

BOOL
pDeleteDefaultKey (
    IN      LPCTSTR BaseRegStr
    )
{
    DATAOBJECT Object;
    TCHAR ObStr[MAX_ENCODED_RULE];
    BOOL b;

    wsprintf (ObStr, TEXT("%s\\%s\\*"), BaseRegStr, S_HW_DEFAULT);
    b = CreateObjectStruct (ObStr, &Object, WINNTOBJECT);
    MYASSERT(b);

    b = DeleteDataObject (&Object);

    FreeObjectStruct (&Object);

    if (!b) {
        LOG ((LOG_ERROR, "CreateDefaultKey: Could not delete %s", ObStr));
    }

    return b;
}


BOOL
pCopyHwProfileConfigData (
    IN      DWORD ProfileSrcId, 
    IN      DWORD ProfileDestId
    )
{
    DATAOBJECT DefaultOb, SrcConfigOb, DestOb;
    BOOL b;
    TCHAR Buf[MAX_TCHAR_PATH];

    ZeroMemory (&DefaultOb, sizeof (DefaultOb));
    ZeroMemory (&SrcConfigOb, sizeof (SrcConfigOb));
    ZeroMemory (&DestOb, sizeof (DestOb));

    //
    // DefaultOb struct points to the default NT hardware profile
    // configuration (i.e. HKLM\System\CCS\Hardware Profiles\Default)
    //

    b = CreateObjectStruct (S_NT_DEFAULT_HW_KEY S_TREE, &DefaultOb, WINNTOBJECT);
    MYASSERT(b);

    //
    // SrcConfigOb struct points to the reg key holding the Win9x
    // configuration settings (i.e. HKLM\Config\<ProfileId>)
    //

    wsprintf (Buf, S_9X_CONFIG_MASK S_TREE, ProfileSrcId);
    b = b && CreateObjectStruct (Buf, &SrcConfigOb, WIN95OBJECT);
    MYASSERT(b);

    //
    // DestOb struct points to the reg key to receive combined WinNT
    // and Win9x settings (i.e. HKLM\System\CCS\Hardware Profiles\<n>)
    //

    wsprintf (Buf, S_NT_CONFIG_MASK S_TREE, ProfileDestId);
    b = b && CreateObjectStruct (Buf, &DestOb, WINNTOBJECT);
    MYASSERT(b);

    //
    // Copy defaults to new profile, then copy Win9x settings as well
    //

    if (b) {
        b = FILTER_RETURN_FAIL != CopyObject (&DefaultOb, &DestOb, NULL, NULL);
        if (!b) {
            LOG ((LOG_ERROR, "pCopyHwProfileConfigData: Unable to copy defaults"));
        }
    }
    if (b) {
        b = FILTER_RETURN_FAIL != CopyObject (&SrcConfigOb, &DestOb,
                                              pHwProfileSuppressFilter, NULL);
        if (!b) {
            LOG ((LOG_ERROR, "Copy Hardware Profile: Unable to copy Win9x settings"));
        }
    }

    //
    // Cleanup
    //

    FreeObjectStruct (&DefaultOb);
    FreeObjectStruct (&SrcConfigOb);
    FreeObjectStruct (&DestOb);

    return b;
}

BOOL
pCopyHwProfileProperties (
    IN      DWORD ProfileSrcId, 
    IN      DWORD ProfileDestId
    )
{
    DATAOBJECT DefaultOb, NameOb, DestOb;
    BOOL b;
    TCHAR Buf[MAX_TCHAR_PATH];

    ZeroMemory (&DefaultOb, sizeof (DefaultOb));
    ZeroMemory (&NameOb, sizeof (NameOb));
    ZeroMemory (&DestOb, sizeof (DestOb));

    //
    // DefaultOb struct points to the default NT hardware profile
    // properties
    //

    b = CreateObjectStruct (S_NT_DEFAULT_HW_ID_KEY S_TREE, &DefaultOb, WINNTOBJECT);
    MYASSERT(b);

    //
    // NameOb struct points to the reg key holding FriendlyName<n>
    // (i.e. HKLM\System\CCS\Control\IDConfigDB)
    //

    b = b && CreateObjectStruct (S_BASE_IDCONFIGDB_KEY, &NameOb, WIN95OBJECT);
    MYASSERT(b);

    //
    // DestOb struct points to the reg key to receive FriendlyName
    // and PreferenceOrder (i.e. HKLM\System\CCS\Control\IDConfigDB\Hardware
    // Profiles\<ProfileId>)
    //

    wsprintf (Buf, S_NT_HW_ID_MASK S_TREE, ProfileDestId);
    b = b && CreateObjectStruct (Buf, &DestOb, WINNTOBJECT);
    MYASSERT(b);

    //
    // Copy default settings to dest object
    //

    if (b) {
        b = FILTER_RETURN_FAIL != CopyObject (&DefaultOb, &DestOb, NULL, NULL);
        if (!b) {
            LOG ((LOG_ERROR, "Object copy failed"));
        }
        DEBUGMSG_IF ((!b, DBG_ERROR, "pCopyHwProfileProperties: Cannot copy, source=%s", DebugEncoder (&DefaultOb)));
        DEBUGMSG_IF ((!b, DBG_ERROR, "pCopyHwProfileProperties: Cannot copy, dest=%s", DebugEncoder (&DestOb)));
    }

    //
    // Copy FriendlyName and PreferenceOrder values to dest object
    //

    // Obtain FriendlyName<n>
    if (b) {
        wsprintf (Buf, S_FRIENDLYNAME_SPRINTF, ProfileSrcId);
        SetRegistryValueName (&NameOb, Buf);

        b = ReadObject (&NameOb);
        if (!b) {
            LOG ((LOG_ERROR, "Copy Hardware Profile Properties: Cannot obtain friendly name"));
        }
    }

    // Copy data to dest object struct
    if (b) {
        SetRegistryType (&DestOb, REG_SZ);
        b = ReplaceValue (&DestOb, NameOb.Value.Buffer, NameOb.Value.Size);
        if (!b) {
            LOG ((LOG_ERROR, "Copy Hardware Profile Properites: Cannot replace value data"));
        }
    }

    // Write dest object
    if (b) {
        SetRegistryValueName (&DestOb, S_FRIENDLYNAME);
        b = WriteObject (&DestOb);
        if (!b) {
            LOG ((LOG_ERROR, "Copy Hardware Profile Properties: Cannot write object"));
        }
        DEBUGMSG_IF ((!b, DBG_ERROR, "pCopyHwProfileProperties: Cannot write %s", DebugEncoder (&DestOb)));
    }

    // Set preference order in dest object struct
    if (b) {
        SetRegistryType (&DestOb, REG_DWORD);
        ProfileDestId--;
        b = ReplaceValue (&DestOb, (LPBYTE) &ProfileDestId, sizeof(ProfileDestId));
        if (!b) {
            LOG ((LOG_ERROR, "Copy Hardware Profile Properties: Cannot set preference order value data"));
        }
        DEBUGMSG_IF ((!b, DBG_ERROR, "pCopyHwProfileProperties: Cannot set preference order value data"));
    }

    // Write dest object
    if (b) {
        SetRegistryValueName (&DestOb, S_PREFERENCEORDER);
        b = WriteObject (&DestOb);
        if (!b) {
            LOG ((LOG_ERROR, "Copy Hardware Profile Properties: Cannot write object"));
        }
        DEBUGMSG_IF ((!b, DBG_ERROR, "pCopyHwProfileProperties: Cannot write %s", DebugEncoder (&DestOb)));
    }

    //
    // Cleanup
    //

    FreeObjectStruct (&DefaultOb);
    FreeObjectStruct (&NameOb);
    FreeObjectStruct (&DestOb);

    return b;
}


DWORD 
pGetCurrentConfig (
    VOID
    )
{
    DATAOBJECT SrcOb;
    BOOL b;
    DWORD dwCurrentConfig = 1;

    b = CreateObjectStruct (S_CURRENT_CONFIG, &SrcOb, WIN95OBJECT);
    MYASSERT(b);
    
    if (ReadObject (&SrcOb)) {
        if (IsRegistryTypeSpecified (&SrcOb) && SrcOb.Type == REG_SZ) {
            //
            // Set destination's object to a REG_DWORD equivalent of
            // the Win9x REG_SZ setting
            //

            dwCurrentConfig = _ttoi ((LPCTSTR) SrcOb.Value.Buffer);
            if(!dwCurrentConfig){
                dwCurrentConfig = 1;
                MYASSERT(FALSE);
            }
            DEBUGMSG ((DBG_VERBOSE, "pGetCurrentConfig: %d", dwCurrentConfig));
        }
        else {
            LOG ((
                LOG_ERROR,
                "Get Current Config: Read unexpected data type from registry in object"
                ));
            DEBUGMSG ((
                DBG_ERROR,
                "pGetCurrentConfig: Read unexpected data type from registry in %s",
                DebugEncoder (&SrcOb)
                ));
        }
    }
    else {
        LOG ((
            LOG_ERROR,
            "Get Current Config: Could not read object"
            ));
        DEBUGMSG ((
            DBG_ERROR,
            "pGetCurrentConfig: Could not read %s",
            DebugEncoder (&SrcOb)
            ));
    }

    FreeObjectStruct (&SrcOb);

    return dwCurrentConfig;
}

BOOL
pCopyCurrentConfig (
    VOID
    )
{
    DATAOBJECT SrcOb, DestOb;
    BOOL b;
    DWORD d;

    b = CreateObjectStruct (S_CURRENT_CONFIG, &SrcOb, WIN95OBJECT);
    MYASSERT(b);

    b = CreateObjectStruct (S_CURRENT_CONFIG, &DestOb, WINNTOBJECT);
    MYASSERT(b);

    b = ReadObject (&SrcOb);
    if (b) {
        if (IsRegistryTypeSpecified (&SrcOb) && SrcOb.Type == REG_SZ) {
            //
            // Set destination's object to a REG_DWORD equivalent of
            // the Win9x REG_SZ setting
            //

            d = _ttoi ((LPCTSTR) SrcOb.Value.Buffer);
            b = ReplaceValue (&DestOb, (LPBYTE) &d, sizeof(d));

            if (b) {
                SetRegistryType (&DestOb, REG_DWORD);
                b = WriteObject (&DestOb);
                if (!b) {
                    LOG ((
                        LOG_ERROR,
                        "Copy Current Config: Could not write object"
                        ));
                }
                DEBUGMSG_IF ((
                    !b,
                    DBG_ERROR,
                    "pCopyCurrentConfig: Could not write %s",
                    DebugEncoder (&DestOb)
                    ));
            }
            else {
                LOG ((LOG_ERROR, "Copy Current Config: Unable to replace value"));
                DEBUGMSG ((DBG_ERROR, "pCopyCurrentConfig: Unable to replace value"));
            }
        }
        else {
            LOG ((
                LOG_ERROR,
                "Copy Current Config: Read unexpected data type from registry in object"
                ));
            DEBUGMSG ((
                DBG_ERROR,
                "pCopyCurrentConfig: Read unexpected data type from registry in %s",
                DebugEncoder (&SrcOb)
                ));
        }
    }
    else {
        LOG ((
            LOG_ERROR,
            "Copy Current Config: Could not read object"
            ));
        DEBUGMSG ((
            DBG_ERROR,
            "pCopyCurrentConfig: Could not read %s",
            DebugEncoder (&SrcOb)
            ));
    }

    FreeObjectStruct (&SrcOb);
    FreeObjectStruct (&DestOb);

    return b;
}

VOID 
pMigrateHardwareProfiles(
    VOID
    )
{
    PHARDWARE_PROFILE hardwareProfile;
    UINT destHWProfileNumber;
    UINT itemCount;

    BOOL b;

    for(destHWProfileNumber = 1, itemCount = GrowListGetSize(&g_HardwareProfileList); 
        destHWProfileNumber <= itemCount; 
        destHWProfileNumber++){
        hardwareProfile = (PHARDWARE_PROFILE)GrowListGetItem(&g_HardwareProfileList, destHWProfileNumber - 1);

        MYASSERT(hardwareProfile);

        //
        // Process hardware profile ID entry
        //

        b = pCopyHwProfileProperties(hardwareProfile->NumberOnWin9x, destHWProfileNumber);
        if (!b) {
            LOG ((LOG_ERROR, "Unable to continue processing hardware profile %04u->%04u", hardwareProfile->NumberOnWin9x, destHWProfileNumber));
        }

        //
        // Process hardware profile configuration entries
        //

        if (b) {
            b = pCopyHwProfileConfigData(hardwareProfile->NumberOnWin9x, destHWProfileNumber);
            if (!b) {
                LOG ((LOG_ERROR, "Unable to complete processing hardware profile %04u->%04u", hardwareProfile->NumberOnWin9x, destHWProfileNumber));
            }
        }

        if(1 != destHWProfileNumber){
            pDeleteProfilesConfigValues(destHWProfileNumber);
        }
    }
    
    FreeGrowList(&g_HardwareProfileList);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\migmain\brfcase.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    brfcase.c

Abstract:

    This module implements the conversion of paths inside a Windows Briefcase Database
    as a result of files/directories relocation after an upgrade.

Author:

    Ovidiu Temereanca (ovidiut) 24-Jun-1999

Environment:

    GUI mode Setup.

Revision History:

    24-Jun-1999     ovidiut Creation and initial implementation.

--*/


#include "pch.h"
#include "brfcasep.h"

//
// globals
//
POOLHANDLE g_BrfcasePool = NULL;


/* Constants
 ************/

/* database file attributes */

#define DB_FILE_ATTR                (FILE_ATTRIBUTE_HIDDEN)

/* database cache lengths */

#define DEFAULT_DATABASE_CACHE_LEN  (32)
#define MAX_DATABASE_CACHE_LEN      (32 * 1024)

/* string table allocation constants */

#define NUM_NAME_HASH_BUCKETS       (67)


/* Types
 ********/

/* briefcase database description */

typedef struct _brfcasedb
{
   /*
    * handle to path of folder of open database (stored in briefcase path list)
    */

   HPATH hpathDBFolder;

   /* name of database file */

   LPTSTR pszDBName;

   /* handle to open cached database file */

   HCACHEDFILE hcfDB;

   /*
    * handle to path of folder that database was last saved in (stored in
    * briefcase's path list), only valid during OpenBriefcase() and
    * SaveBriefcase()
    */

   HPATH hpathLastSavedDBFolder;
}
BRFCASEDB;
DECLARE_STANDARD_TYPES(BRFCASEDB);

/*
 * briefcase flags
 *
 * N.b., the private BR_ flags must not collide with the public OB_ flags!
 */

typedef enum _brfcaseflags
{
   /* The briefcase database has been opened. */

   BR_FL_DATABASE_OPENED      = 0x00010000,

   /* flag combinations */

   ALL_BR_FLAGS               = (BR_FL_DATABASE_OPENED
                                ),

   ALL_BRFCASE_FLAGS          = (ALL_OB_FLAGS |
                                 ALL_BR_FLAGS)
}
BRFCASEFLAGS;

/* briefcase structure */

typedef struct _brfcase
{
   /* flags */

   DWORD dwFlags;

   /* handle to name string table */

   HSTRINGTABLE hstNames;

   /* handle to list of paths */

   HPATHLIST hpathlist;

   /* handle to array of pointers to twin families */

   HPTRARRAY hpaTwinFamilies;

   /* handle to array of pointers to folder pairs */

   HPTRARRAY hpaFolderPairs;

   /*
    * handle to parent window, only valid if OB_FL_ALLOW_UI is set in dwFlags
    * field
    */

   HWND hwndOwner;

   /* database description */

   BRFCASEDB bcdb;
}
BRFCASE;
DECLARE_STANDARD_TYPES(BRFCASE);

/* database briefcase structure */

typedef struct _dbbrfcase
{
   /* old handle to folder that database was saved in */

   HPATH hpathLastSavedDBFolder;
}
DBBRFCASE;
DECLARE_STANDARD_TYPES(DBBRFCASE);


/* database cache size */

DWORD MdwcbMaxDatabaseCacheLen = MAX_DATABASE_CACHE_LEN;

TWINRESULT OpenBriefcaseDatabase(PBRFCASE, LPCTSTR);
TWINRESULT CloseBriefcaseDatabase(PBRFCASEDB);
BOOL CreateBriefcase(PBRFCASE *, DWORD, HWND);
TWINRESULT DestroyBriefcase(PBRFCASE);
TWINRESULT MyWriteDatabase(PBRFCASE);
TWINRESULT MyReadDatabase(PBRFCASE, DWORD);


void CopyFileStampFromFindData(PCWIN32_FIND_DATA pcwfdSrc,
                                           PFILESTAMP pfsDest)
{
   ASSERT(IS_VALID_READ_PTR(pcwfdSrc, CWIN32_FIND_DATA));

   pfsDest->dwcbHighLength = pcwfdSrc->nFileSizeHigh;
   pfsDest->dwcbLowLength = pcwfdSrc->nFileSizeLow;

   /* Convert to local time and save that too */

   if ( !FileTimeToLocalFileTime(&pcwfdSrc->ftLastWriteTime, &pfsDest->ftModLocal) )
   {
      /* Just copy the time if FileTimeToLocalFileTime failed */

      pfsDest->ftModLocal = pcwfdSrc->ftLastWriteTime;
   }
   pfsDest->ftMod = pcwfdSrc->ftLastWriteTime;
   pfsDest->fscond = FS_COND_EXISTS;
}


void MyGetFileStamp(LPCTSTR pcszFile, PFILESTAMP pfs)
{
   WIN32_FIND_DATA wfd;
   HANDLE hff;

   ASSERT(IS_VALID_STRING_PTR(pcszFile, CSTR));

   ZeroMemory(pfs, sizeof(*pfs));

   hff = FindFirstFile(pcszFile, &wfd);

   if (hff != INVALID_HANDLE_VALUE)
   {
      if (! IS_ATTR_DIR(wfd.dwFileAttributes))
         CopyFileStampFromFindData(&wfd, pfs);
      else
         pfs->fscond = FS_COND_EXISTS;

      EVAL(FindClose(hff));
   }
   else
      pfs->fscond = FS_COND_DOES_NOT_EXIST;
}


TWINRESULT OpenBriefcaseDatabase(PBRFCASE pbr, LPCTSTR pcszPath)
{
   TWINRESULT tr;
   TCHAR rgchCanonicalPath[MAX_SEPARATED_PATH_LEN];
   DWORD dwOutFlags;
   TCHAR rgchNetResource[MAX_PATH_LEN];
   LPTSTR pszRootPathSuffix;

   ASSERT(IS_VALID_STRUCT_PTR(pbr, CBRFCASE));
   ASSERT(IS_VALID_STRING_PTR(pcszPath, CSTR));

   if (GetCanonicalPathInfo(pcszPath, rgchCanonicalPath, &dwOutFlags,
                            rgchNetResource, &pszRootPathSuffix))
   {
      LPTSTR pszDBName;

      pszDBName = (LPTSTR)ExtractFileName(pszRootPathSuffix);

      ASSERT(IS_SLASH(*(pszDBName - 1)));

      if (StringCopy2(pszDBName, &(pbr->bcdb.pszDBName)))
      {
         if (pszDBName == pszRootPathSuffix)
         {
            /* Database in root. */

            *pszDBName = TEXT('\0');

            ASSERT(IsRootPath(rgchCanonicalPath));
         }
         else
         {
            ASSERT(pszDBName > pszRootPathSuffix);
            *(pszDBName - 1) = TEXT('\0');
         }

         tr = TranslatePATHRESULTToTWINRESULT(
                  AddPath(pbr->hpathlist, rgchCanonicalPath,
                          &(pbr->bcdb.hpathDBFolder)));

         if (tr == TR_SUCCESS)
         {
            if (IsPathVolumeAvailable(pbr->bcdb.hpathDBFolder))
            {
               TCHAR rgchDBPath[MAX_PATH_LEN];
               CACHEDFILE cfDB;

               GetPathString(pbr->bcdb.hpathDBFolder, rgchDBPath);
               CatPath(rgchDBPath, pbr->bcdb.pszDBName);

               /* Assume sequential reads and writes. */

               /* Share read access, but not write access. */

               cfDB.pcszPath = rgchDBPath;
               cfDB.dwOpenMode = (GENERIC_READ | GENERIC_WRITE);
               cfDB.dwSharingMode = FILE_SHARE_READ;
               cfDB.psa = NULL;
               cfDB.dwCreateMode = OPEN_ALWAYS;
               cfDB.dwAttrsAndFlags = (DB_FILE_ATTR | FILE_FLAG_SEQUENTIAL_SCAN);
               cfDB.hTemplateFile = NULL;
               cfDB.dwcbDefaultCacheSize = DEFAULT_DATABASE_CACHE_LEN;

               tr = TranslateFCRESULTToTWINRESULT(
                     CreateCachedFile(&cfDB, &(pbr->bcdb.hcfDB)));

               if (tr == TR_SUCCESS)
               {
                  pbr->bcdb.hpathLastSavedDBFolder = NULL;

                  ASSERT(IS_FLAG_CLEAR(pbr->dwFlags, BR_FL_DATABASE_OPENED));
                  SET_FLAG(pbr->dwFlags, BR_FL_DATABASE_OPENED);
               }
               else
               {
                  DeletePath(pbr->bcdb.hpathDBFolder);
OPENBRIEFCASEDATABASE_BAIL:
                  FreeMemory(pbr->bcdb.pszDBName);
               }
            }
            else
            {
               tr = TR_UNAVAILABLE_VOLUME;
               goto OPENBRIEFCASEDATABASE_BAIL;
            }
         }
      }
      else
         tr = TR_OUT_OF_MEMORY;
   }
   else
      tr = TWINRESULTFromLastError(TR_INVALID_PARAMETER);

   return(tr);
}


TWINRESULT CloseBriefcaseDatabase(PBRFCASEDB pbcdb)
{
   TWINRESULT tr;
   TCHAR rgchDBPath[MAX_PATH_LEN];
   FILESTAMP fsDB;

   tr = CloseCachedFile(pbcdb->hcfDB) ? TR_SUCCESS : TR_BRIEFCASE_WRITE_FAILED;

   if (tr == TR_SUCCESS)
      TRACE_OUT((TEXT("CloseBriefcaseDatabase(): Closed cached briefcase database file %s\\%s."),
                 DebugGetPathString(pbcdb->hpathDBFolder),
                 pbcdb->pszDBName));
   else
      WARNING_OUT((TEXT("CloseBriefcaseDatabase(): Failed to close cached briefcase database file %s\\%s."),
                   DebugGetPathString(pbcdb->hpathDBFolder),
                   pbcdb->pszDBName));

   /* Try not to leave a 0-length database laying around. */

   GetPathString(pbcdb->hpathDBFolder, rgchDBPath);
   CatPath(rgchDBPath, pbcdb->pszDBName);

   MyGetFileStamp(rgchDBPath, &fsDB);

   if (fsDB.fscond == FS_COND_EXISTS &&
       (! fsDB.dwcbLowLength && ! fsDB.dwcbHighLength))
   {
      if (DeleteFile(rgchDBPath))
         WARNING_OUT((TEXT("CloseBriefcaseDatabase(): Deleted 0 length database %s\\%s."),
                      DebugGetPathString(pbcdb->hpathDBFolder),
                      pbcdb->pszDBName));
   }

   FreeMemory(pbcdb->pszDBName);
   DeletePath(pbcdb->hpathDBFolder);

   return(tr);
}


BOOL CreateBriefcase(PBRFCASE *ppbr, DWORD dwInFlags,
                                  HWND hwndOwner)
{
   BOOL bResult = FALSE;

   ASSERT(IS_VALID_WRITE_PTR(ppbr, PBRFCASE));
   ASSERT(FLAGS_ARE_VALID(dwInFlags, ALL_BRFCASE_FLAGS));
   ASSERT(IS_FLAG_CLEAR(dwInFlags, OB_FL_ALLOW_UI) ||
          IS_VALID_HANDLE(hwndOwner, WND));

   if (AllocateMemory(sizeof(**ppbr), ppbr))
   {
      DWORD dwCPLFlags;

      dwCPLFlags = (RLI_IFL_CONNECT |
                    RLI_IFL_UPDATE |
                    RLI_IFL_LOCAL_SEARCH);

      if (IS_FLAG_SET(dwInFlags, OB_FL_ALLOW_UI))
         SET_FLAG(dwCPLFlags, RLI_IFL_ALLOW_UI);

      if (CreatePathList(dwCPLFlags, hwndOwner, &((*ppbr)->hpathlist)))
      {
         NEWSTRINGTABLE nszt;

         nszt.hbc = NUM_NAME_HASH_BUCKETS;

         if (CreateStringTable(&nszt, &((*ppbr)->hstNames)))
         {
            if (CreateTwinFamilyPtrArray(&((*ppbr)->hpaTwinFamilies)))
            {
               if (CreateFolderPairPtrArray(&((*ppbr)->hpaFolderPairs)))
               {
                  if (TRUE)
                  {
                     (*ppbr)->dwFlags = dwInFlags;
                     (*ppbr)->hwndOwner = hwndOwner;

                     bResult = TRUE;
                  }
                  else
                  {
CREATEBRIEFCASE_BAIL1:
                     DestroyTwinFamilyPtrArray((*ppbr)->hpaTwinFamilies);
CREATEBRIEFCASE_BAIL2:
                     DestroyStringTable((*ppbr)->hstNames);
CREATEBRIEFCASE_BAIL3:
                     DestroyPathList((*ppbr)->hpathlist);
CREATEBRIEFCASE_BAIL4:
                     FreeMemory((*ppbr));
                  }
               }
               else
                  goto CREATEBRIEFCASE_BAIL1;
            }
            else
               goto CREATEBRIEFCASE_BAIL2;
         }
         else
            goto CREATEBRIEFCASE_BAIL3;
      }
      else
         goto CREATEBRIEFCASE_BAIL4;
   }

   ASSERT(! bResult ||
          IS_VALID_STRUCT_PTR(*ppbr, CBRFCASE));

   return(bResult);
}


TWINRESULT DestroyBriefcase(PBRFCASE pbr)
{
   TWINRESULT tr;

   ASSERT(IS_VALID_STRUCT_PTR(pbr, CBRFCASE));

   if (IS_FLAG_SET(pbr->dwFlags, BR_FL_DATABASE_OPENED))
      tr = CloseBriefcaseDatabase(&(pbr->bcdb));
   else
      tr = TR_SUCCESS;
   //
   // don't free any memory here; this is not done properly if some strings were
   // replaced with longer ones
   //

#if 0
   DestroyFolderPairPtrArray(pbr->hpaFolderPairs);

   DestroyTwinFamilyPtrArray(pbr->hpaTwinFamilies);

   ASSERT(! GetStringCount(pbr->hstNames));
   DestroyStringTable(pbr->hstNames);

   ASSERT(! GetPathCount(pbr->hpathlist));
   DestroyPathList(pbr->hpathlist);

   FreeMemory(pbr);
#endif

   return(tr);
}


TWINRESULT MyWriteDatabase(PBRFCASE pbr)
{
   TWINRESULT tr;

   ASSERT(IS_VALID_STRUCT_PTR(pbr, CBRFCASE));

   ASSERT(IS_FLAG_SET(pbr->dwFlags, BR_FL_DATABASE_OPENED));

   {
      /* Grow the database cache in preparation for writing. */

      ASSERT(MdwcbMaxDatabaseCacheLen > 0);

      if (SetCachedFileCacheSize(pbr->bcdb.hcfDB, MdwcbMaxDatabaseCacheLen)
          != FCR_SUCCESS)
         WARNING_OUT((TEXT("MyWriteDatabase(): Unable to grow database cache to %lu bytes.  Using default database write cache of %lu bytes."),
                      MdwcbMaxDatabaseCacheLen,
                      (DWORD)DEFAULT_DATABASE_CACHE_LEN));

      /* Write the database. */

      tr = WriteTwinDatabase(pbr->bcdb.hcfDB, (HBRFCASE)pbr);

      if (tr == TR_SUCCESS)
      {
         if (CommitCachedFile(pbr->bcdb.hcfDB))
         {
            /* Shrink the database cache back down to its default size. */

            EVAL(SetCachedFileCacheSize(pbr->bcdb.hcfDB,
                                        DEFAULT_DATABASE_CACHE_LEN)
                 == FCR_SUCCESS);

            TRACE_OUT((TEXT("MyWriteDatabase(): Wrote database %s\\%s."),
                       DebugGetPathString(pbr->bcdb.hpathDBFolder),
                       pbr->bcdb.pszDBName));
         }
         else
            tr = TR_BRIEFCASE_WRITE_FAILED;
      }
   }

   return(tr);
}


TWINRESULT MyReadDatabase(PBRFCASE pbr, DWORD dwInFlags)
{
   TWINRESULT tr;

   ASSERT(IS_VALID_STRUCT_PTR(pbr, CBRFCASE));
   ASSERT(FLAGS_ARE_VALID(dwInFlags, ALL_OB_FLAGS));

   {
      DWORD dwcbDatabaseSize;

      /* Is there an exising database to read? */

      dwcbDatabaseSize = GetCachedFileSize(pbr->bcdb.hcfDB);

      if (dwcbDatabaseSize > 0)
      {
         DWORD dwcbMaxCacheSize;

         /* Yes.  Grow the database cache in preparation for reading. */

         /*
          * Use file length instead of MdwcbMaxDatabaseCacheLen if file length
          * is smaller.
          */

         ASSERT(MdwcbMaxDatabaseCacheLen > 0);

         if (dwcbDatabaseSize < MdwcbMaxDatabaseCacheLen)
         {
            dwcbMaxCacheSize = dwcbDatabaseSize;

            WARNING_OUT((TEXT("MyReadDatabase(): Using file size %lu bytes as read cache size for database %s\\%s."),
                         dwcbDatabaseSize,
                         DebugGetPathString(pbr->bcdb.hpathDBFolder),
                         pbr->bcdb.pszDBName));
         }
         else
            dwcbMaxCacheSize = MdwcbMaxDatabaseCacheLen;

         if (TranslateFCRESULTToTWINRESULT(SetCachedFileCacheSize(
                                                            pbr->bcdb.hcfDB,
                                                            dwcbMaxCacheSize))
             != TR_SUCCESS)
            WARNING_OUT((TEXT("MyReadDatabase(): Unable to grow database cache to %lu bytes.  Using default database read cache of %lu bytes."),
                         dwcbMaxCacheSize,
                         (DWORD)DEFAULT_DATABASE_CACHE_LEN));

         tr = ReadTwinDatabase((HBRFCASE)pbr, pbr->bcdb.hcfDB);

         if (tr == TR_SUCCESS)
         {
            ASSERT(! pbr->bcdb.hpathLastSavedDBFolder ||
                   IS_VALID_HANDLE(pbr->bcdb.hpathLastSavedDBFolder, PATH));

            if (pbr->bcdb.hpathLastSavedDBFolder)
            {
               DeletePath(pbr->bcdb.hpathLastSavedDBFolder);
               pbr->bcdb.hpathLastSavedDBFolder = NULL;
            }

            if (tr == TR_SUCCESS)
               TRACE_OUT((TEXT("MyReadDatabase(): Read database %s\\%s."),
                          DebugGetPathString(pbr->bcdb.hpathDBFolder),
                          pbr->bcdb.pszDBName));
         }

         /* Shrink the database cache back down to its default size. */

         EVAL(TranslateFCRESULTToTWINRESULT(SetCachedFileCacheSize(
                                                   pbr->bcdb.hcfDB,
                                                   DEFAULT_DATABASE_CACHE_LEN))
              == TR_SUCCESS);
      }
      else
      {
         tr = TR_SUCCESS;

         WARNING_OUT((TEXT("MyReadDatabase(): Database %s\\%s not found."),
                      DebugGetPathString(pbr->bcdb.hpathDBFolder),
                      pbr->bcdb.pszDBName));
      }
   }

   return(tr);
}


HSTRINGTABLE GetBriefcaseNameStringTable(HBRFCASE hbr)
{
   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));

   return(((PCBRFCASE)hbr)->hstNames);
}


HPTRARRAY GetBriefcaseTwinFamilyPtrArray(HBRFCASE hbr)
{
   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));

   return(((PCBRFCASE)hbr)->hpaTwinFamilies);
}


HPTRARRAY GetBriefcaseFolderPairPtrArray(HBRFCASE hbr)
{
   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));

   return(((PCBRFCASE)hbr)->hpaFolderPairs);
}


HPATHLIST GetBriefcasePathList(HBRFCASE hbr)
{
   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));

   return(((PCBRFCASE)hbr)->hpathlist);
}


TWINRESULT WriteBriefcaseInfo(HCACHEDFILE hcf, HBRFCASE hbr)
{
   TWINRESULT tr;
   DBBRFCASE dbbr;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));

   /* Set up briefcase database structure. */

   ASSERT(IS_VALID_HANDLE(((PCBRFCASE)hbr)->bcdb.hpathLastSavedDBFolder, PATH));

   dbbr.hpathLastSavedDBFolder = ((PCBRFCASE)hbr)->bcdb.hpathLastSavedDBFolder;

   /* Save briefcase database structure. */

   if (WriteToCachedFile(hcf, (PCVOID)&dbbr, sizeof(dbbr), NULL))
   {
      tr = TR_SUCCESS;

      TRACE_OUT((TEXT("WriteBriefcaseInfo(): Wrote last saved database folder %s."),
                 DebugGetPathString(dbbr.hpathLastSavedDBFolder)));
   }
   else
      tr = TR_BRIEFCASE_WRITE_FAILED;

   return(tr);
}


TWINRESULT ReadBriefcaseInfo(HCACHEDFILE hcf, HBRFCASE hbr,
                                    HHANDLETRANS hhtFolderTrans)
{
   TWINRESULT tr;
   DBBRFCASE dbbr;
   DWORD dwcbRead;
   HPATH hpath;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
   ASSERT(IS_VALID_HANDLE(hhtFolderTrans, HANDLETRANS));

   /* Read briefcase database structure. */

   if ((ReadFromCachedFile(hcf, &dbbr, sizeof(dbbr), &dwcbRead) &&
        dwcbRead == sizeof(dbbr)) &&
       TranslateHandle(hhtFolderTrans, (HGENERIC)(dbbr.hpathLastSavedDBFolder),
                       (PHGENERIC)&hpath))
   {
      HPATH hpathLastSavedDBFolder;

      /*
       * Bump last saved database folder path's lock count in the briefcase's
       * path list.
       */

      if (CopyPath(hpath, ((PCBRFCASE)hbr)->hpathlist, &hpathLastSavedDBFolder))
      {
         ((PBRFCASE)hbr)->bcdb.hpathLastSavedDBFolder = hpathLastSavedDBFolder;

         tr = TR_SUCCESS;

         TRACE_OUT((TEXT("ReadBriefcaseInfo(): Read last saved database folder %s."),
                    DebugGetPathString(((PBRFCASE)hbr)->bcdb.hpathLastSavedDBFolder)));
      }
      else
         tr = TR_OUT_OF_MEMORY;
   }
   else
      tr = TR_CORRUPT_BRIEFCASE;

   return(tr);
}


/******************************************************************************

@api TWINRESULT | OpenBriefcase | Opens an existing briefcase database, or
creates a new briefcase.

@parm PCSTR | pcszPath | A pointer to a path string indicating the briefcase
database to be opened or created.  This parameter is ignored unless the
OB_FL_OPEN_DATABASE flag is set in dwFlags.

@parm DWORD | dwInFlags | A bit mask of flags.  This parameter may be any
combination of the following values:
   OB_FL_OPEN_DATABASE - Open the briefcase database specified by pcszPath.
   OB_FL_TRANSLATE_DB_FOLDER - Translate the folder where the briefcase
   database was last saved to the folder where the briefcase database was
   opened.
   OB_FL_ALLOW_UI - Allow interaction with the user during briefcase
   operations.

@parm HWND | hwndOwner | A handle to the parent window to be used when
requesting user interaction.  This parameter is ignored if the OB_FL_ALLOW_UI
flag is clear.

@parm PHBRFCASE | phbr | A pointer to an HBRFCASE to be filled in with a
handle to the open briefcase.  *phbr is only valid if TR_SUCCESS is returned.

@rdesc If the briefcase was opened or created successfully, TR_SUCCESS is
returned, and *phbr contains a handle to the open briefcase.  Otherwise, the
briefcase was not opened or created successfully, the return value indicates
the error that occurred, and *phbr is undefined.

@comm If the OB_FL_OPEN_DATABASE flag is set in dwFlags, the database specified
by pcszPath is associated with the briefcase.  If the database specified does
not exist, the database is created.<nl>
If the OB_FL_OPEN_DATABASE flag is clear in dwFlags, no persistent database is
associated with the briefcase.  SaveBriefcase() will fail if called on a
briefcase with no associated database.<nl>
Once the caller is finished with the briefcase handle returned by
OpenBriefcase(), CloseBriefcase() should be called to release the briefcase.
SaveBriefcase() may be called before CloseBriefcase() to save the current
contents of the briefcase.

******************************************************************************/

TWINRESULT WINAPI OpenBriefcase(LPCTSTR pcszPath, DWORD dwInFlags,
                                           HWND hwndOwner, PHBRFCASE phbr)
{
   TWINRESULT tr;

  /* Verify parameters. */

  if (FLAGS_ARE_VALID(dwInFlags, ALL_OB_FLAGS))
  {
     PBRFCASE pbr;

     if (CreateBriefcase(&pbr, dwInFlags, hwndOwner))
     {
        if (IS_FLAG_SET(dwInFlags, OB_FL_OPEN_DATABASE))
        {
           tr = OpenBriefcaseDatabase(pbr, pcszPath);

           if (tr == TR_SUCCESS)
           {
              tr = MyReadDatabase(pbr, dwInFlags);

              if (tr == TR_SUCCESS)
              {
                 *phbr = (HBRFCASE)pbr;
              }
              else
              {
OPENBRIEFCASE_BAIL:
                 EVAL(DestroyBriefcase(pbr) == TR_SUCCESS);
              }
           }
           else
              goto OPENBRIEFCASE_BAIL;
        }
        else
        {
           *phbr = (HBRFCASE)pbr;
           tr = TR_SUCCESS;

           TRACE_OUT((TEXT("OpenBriefcase(): Opened briefcase %#lx with no associated database, by request."),
                      *phbr));
        }
     }
     else
        tr = TR_OUT_OF_MEMORY;
  }
  else
     tr = TR_INVALID_PARAMETER;

   return(tr);
}


/******************************************************************************

@api TWINRESULT | SaveBriefcase | Saves the contents of an open briefcase to a
briefcase database.

@parm HBRFCASE | hbr | A handle to the briefcase to be saved.  This handle may
be obtained by calling OpenBriefcase() with a briefcase database path and with
the OB_FL_OPEN_DATABASE flag set.  SaveBriefcase() will return
TR_INVALID_PARAMETER if called on a briefcase with no associated briefcase
database.

@rdesc If the contents of the briefcase was saved to the briefcase database
successfully, TR_SUCCESS is returned.  Otherwise, the contents of the briefcase
was not saved to the briefcase database successfully, and the return value
indicates the error that occurred.

******************************************************************************/

TWINRESULT WINAPI SaveBriefcase(HBRFCASE hbr)
{
   TWINRESULT tr;

  /* Verify parameters. */

  if (IS_FLAG_SET(((PBRFCASE)hbr)->dwFlags, BR_FL_DATABASE_OPENED))
  {
     ((PBRFCASE)hbr)->bcdb.hpathLastSavedDBFolder = ((PCBRFCASE)hbr)->bcdb.hpathDBFolder;

     tr = MyWriteDatabase((PBRFCASE)hbr);

     ((PBRFCASE)hbr)->bcdb.hpathLastSavedDBFolder = NULL;
  }
  else
     tr = TR_INVALID_PARAMETER;

   return(tr);
}


/******************************************************************************

@api TWINRESULT | CloseBriefcase | Closes an open briefcase.

@parm HBRFCASE | hbr | A handle to the briefcase to be closed.  This handle may
be obtained by calling OpenBriefcase().

@rdesc If the briefcase was closed successfully, TR_SUCCESS is returned.
Otherwise, the briefcase was not closed successfully, and the return value
indicates the error that occurred.

******************************************************************************/

TWINRESULT WINAPI CloseBriefcase(HBRFCASE hbr)
{
   TWINRESULT tr;

  /* Verify parameters. */

  if (IS_VALID_HANDLE(hbr, BRFCASE))
  {
     tr = DestroyBriefcase((PBRFCASE)hbr);
  }
  else
     tr = TR_INVALID_PARAMETER;

   return(tr);
}


void CatPath(LPTSTR pszPath, LPCTSTR pcszSubPath)
{
   LPTSTR pcsz;
   LPTSTR pcszLast;

   ASSERT(IS_VALID_STRING_PTR(pszPath, STR));
   ASSERT(IS_VALID_STRING_PTR(pcszSubPath, CSTR));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszPath, STR, MAX_PATH_LEN - lstrlen(pszPath)));

   /* Find last character in path string. */

   for (pcsz = pcszLast = pszPath; *pcsz; pcsz = CharNext(pcsz))
      pcszLast = pcsz;

   if (IS_SLASH(*pcszLast) && IS_SLASH(*pcszSubPath))
      pcszSubPath++;
   else if (! IS_SLASH(*pcszLast) && ! IS_SLASH(*pcszSubPath))
   {
      if (*pcszLast && *pcszLast != COLON && *pcszSubPath)
         *pcsz++ = TEXT('\\');
   }

   MyLStrCpyN(pcsz, pcszSubPath, MAX_PATH_LEN - (int)(pcsz - pszPath));

   ASSERT(IS_VALID_STRING_PTR(pszPath, STR));
}


COMPARISONRESULT MapIntToComparisonResult(int nResult)
{
   COMPARISONRESULT cr;

   /* Any integer is valid input. */

   if (nResult < 0)
      cr = CR_FIRST_SMALLER;
   else if (nResult > 0)
      cr = CR_FIRST_LARGER;
   else
      cr = CR_EQUAL;

   return(cr);
}


/*
** MyLStrCpyN()
**
** Like lstrcpy(), but the copy is limited to ucb bytes.  The destination
** string is always null-terminated.
**
** Arguments:     pszDest - pointer to destination buffer
**                pcszSrc - pointer to source string
**                ncb - maximum number of bytes to copy, including null
**                      terminator
**
** Returns:       void
**
** Side Effects:  none
**
** N.b., this function behaves quite differently than strncpy()!  It does not
** pad out the destination buffer with null characters, and it always null
** terminates the destination string.
*/
void MyLStrCpyN(LPTSTR pszDest, LPCTSTR pcszSrc, int ncch)
{
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszDest, STR, ncch * sizeof(TCHAR)));
   ASSERT(IS_VALID_STRING_PTR(pcszSrc, CSTR));
   ASSERT(ncch > 0);

   while (ncch > 1)
   {
      ncch--;

      *pszDest = *pcszSrc;

      if (*pcszSrc)
      {
         pszDest++;
         pcszSrc++;
      }
      else
         break;
   }

   if (ncch == 1)
      *pszDest = TEXT('\0');

   ASSERT(IS_VALID_STRING_PTR(pszDest, STR));
   ASSERT(lstrlen(pszDest) < ncch);
   ASSERT(lstrlen(pszDest) <= lstrlen(pcszSrc));
}


BOOL StringCopy2(LPCTSTR pcszSrc, LPTSTR *ppszCopy)
{
   BOOL bResult;

   ASSERT(IS_VALID_STRING_PTR(pcszSrc, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(ppszCopy, LPTSTR));

   /* (+ 1) for null terminator. */

   bResult = AllocateMemory((lstrlen(pcszSrc) + 1) * sizeof(TCHAR), ppszCopy);

   if (bResult)
      lstrcpy(*ppszCopy, pcszSrc);

   ASSERT(! bResult ||
          IS_VALID_STRING_PTR(*ppszCopy, STR));

   return(bResult);
}


COMPARISONRESULT ComparePathStrings(LPCTSTR pcszFirst, LPCTSTR pcszSecond)
{
   ASSERT(IS_VALID_STRING_PTR(pcszFirst, CSTR));
   ASSERT(IS_VALID_STRING_PTR(pcszSecond, CSTR));

   return(MapIntToComparisonResult(lstrcmpi(pcszFirst, pcszSecond)));
}


#ifdef DEBUG

BOOL IsRootPath(LPCTSTR pcszFullPath)
{
   TCHAR rgchCanonicalPath[MAX_PATH_LEN];
   DWORD dwOutFlags;
   TCHAR rgchNetResource[MAX_PATH_LEN];
   LPTSTR pszRootPathSuffix;

   ASSERT(IsFullPath(pcszFullPath));

   return(GetCanonicalPathInfo(pcszFullPath, rgchCanonicalPath, &dwOutFlags,
                               rgchNetResource, &pszRootPathSuffix) &&
          ! *pszRootPathSuffix);
}


BOOL IsTrailingSlashCanonicalized(LPCTSTR pcszFullPath)
{
   BOOL bResult;
   BOOL bSlashLast;
   LPCTSTR pcszLastPathChar;

   ASSERT(IsFullPath(pcszFullPath));

   /* Make sure that the path only ends in a slash for root paths. */

   pcszLastPathChar = CharPrev(pcszFullPath, pcszFullPath + lstrlen(pcszFullPath));

   ASSERT(pcszLastPathChar >= pcszFullPath);

   bSlashLast = IS_SLASH(*pcszLastPathChar);

   /* Is this a root path? */

   if (IsRootPath(pcszFullPath))
      bResult = bSlashLast;
   else
      bResult = ! bSlashLast;

   return(bResult);
}


BOOL IsFullPath(LPCTSTR pcszPath)
{
   BOOL bResult = FALSE;
   TCHAR rgchFullPath[MAX_PATH_LEN];

   if (IS_VALID_STRING_PTR(pcszPath, CSTR) &&
       EVAL(lstrlen(pcszPath) < MAX_PATH_LEN))
   {
      DWORD dwPathLen;
      LPTSTR pszFileName;

      dwPathLen = GetFullPathName(pcszPath, ARRAYSIZE(rgchFullPath), rgchFullPath,
                                  &pszFileName);

      if (EVAL(dwPathLen > 0) &&
          EVAL(dwPathLen < ARRAYSIZE(rgchFullPath)))
         bResult = EVAL(ComparePathStrings(pcszPath, rgchFullPath) == CR_EQUAL);
   }

   return(bResult);
}


BOOL IsCanonicalPath(LPCTSTR pcszPath)
{
   return(EVAL(IsFullPath(pcszPath)) &&
          EVAL(IsTrailingSlashCanonicalized(pcszPath)));

}


#endif   /* DEBUG */


/* Constants
 ************/

/* database header magic id string */

#define MAGIC_HEADER             "DDSH\x02\x05\x01\x14"

/* length of MAGIC_HEADER (no null terminator) */

#define MAGIC_HEADER_LEN         (8)

/* Types
 ********/

typedef struct _dbheader
{
   BYTE rgbyteMagic[MAGIC_HEADER_LEN];
   DWORD dwcbHeaderLen;
   DWORD dwMajorVer;
   DWORD dwMinorVer;
}
DBHEADER;
DECLARE_STANDARD_TYPES(DBHEADER);


TWINRESULT WriteDBHeader(HCACHEDFILE, PDBHEADER);
TWINRESULT ReadDBHeader(HCACHEDFILE, PDBHEADER);
TWINRESULT CheckDBHeader(PCDBHEADER);
TWINRESULT WriteTwinInfo(HCACHEDFILE, HBRFCASE);
TWINRESULT ReadTwinInfo(HCACHEDFILE, HBRFCASE, PCDBVERSION);


TWINRESULT WriteDBHeader(HCACHEDFILE hcf, PDBHEADER pdbh)
{
   TWINRESULT tr;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_STRUCT_PTR(pdbh, CDBHEADER));

   if (WriteToCachedFile(hcf, (PCVOID)pdbh, sizeof(*pdbh), NULL))
      tr = TR_SUCCESS;
   else
      tr = TR_BRIEFCASE_WRITE_FAILED;

   return(tr);
}


TWINRESULT ReadDBHeader(HCACHEDFILE hcf, PDBHEADER pdbh)
{
   TWINRESULT tr;
   DWORD dwcbRead;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_WRITE_PTR(pdbh, DBHEADER));

   if (ReadFromCachedFile(hcf, pdbh, sizeof(*pdbh), &dwcbRead) &&
       dwcbRead == sizeof(*pdbh))
      tr = CheckDBHeader(pdbh);
   else
      tr = TR_CORRUPT_BRIEFCASE;

   return(tr);
}


TWINRESULT CheckDBHeader(PCDBHEADER pcdbh)
{
   TWINRESULT tr = TR_CORRUPT_BRIEFCASE;

   ASSERT(IS_VALID_READ_PTR(pcdbh, CDBHEADER));

   if (MyMemComp(pcdbh->rgbyteMagic, MAGIC_HEADER, MAGIC_HEADER_LEN) == CR_EQUAL)
   {
      /* Treat older databases as corrupt.  Support M8 databases. */

      if (pcdbh->dwMajorVer == HEADER_MAJOR_VER &&
          (pcdbh->dwMinorVer == HEADER_MINOR_VER || pcdbh->dwMinorVer == HEADER_M8_MINOR_VER))
      {
         if (pcdbh->dwcbHeaderLen == sizeof(*pcdbh))
            tr = TR_SUCCESS;
      }
      else if (pcdbh->dwMajorVer > HEADER_MAJOR_VER ||
               (pcdbh->dwMajorVer == HEADER_MAJOR_VER &&
                pcdbh->dwMinorVer > HEADER_MINOR_VER))
      {
         tr = TR_NEWER_BRIEFCASE;

         WARNING_OUT((TEXT("CheckDBHeader(): Newer database version %lu.%lu."),
                      pcdbh->dwMajorVer,
                      pcdbh->dwMinorVer));
      }
      else
      {
         tr = TR_CORRUPT_BRIEFCASE;

         WARNING_OUT((TEXT("CheckDBHeader(): Treating old database version %lu.%lu as corrupt.  Current database version is %lu.%lu."),
                      pcdbh->dwMajorVer,
                      pcdbh->dwMinorVer,
                      (DWORD)HEADER_MAJOR_VER,
                      (DWORD)HEADER_MINOR_VER));
      }
   }

   return(tr);
}


TWINRESULT WriteTwinInfo(HCACHEDFILE hcf, HBRFCASE hbr)
{
   TWINRESULT tr = TR_BRIEFCASE_WRITE_FAILED;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));

   tr = WritePathList(hcf, GetBriefcasePathList(hbr));

   if (tr == TR_SUCCESS)
   {
      tr = WriteBriefcaseInfo(hcf, hbr);

      if (tr == TR_SUCCESS)
      {
         tr = WriteStringTable(hcf, GetBriefcaseNameStringTable(hbr));

         if (tr == TR_SUCCESS)
         {
            tr = WriteTwinFamilies(hcf, GetBriefcaseTwinFamilyPtrArray(hbr));

            if (tr == TR_SUCCESS)
               tr = WriteFolderPairList(hcf, GetBriefcaseFolderPairPtrArray(hbr));
         }
      }
   }

   return(tr);
}


TWINRESULT ReadTwinInfo(HCACHEDFILE hcf, HBRFCASE hbr,
                                     PCDBVERSION pcdbver)
{
   TWINRESULT tr;
   HHANDLETRANS hhtPathTrans;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_READ_PTR(pcdbver, DBVERSION));
   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));

   tr = ReadPathList(hcf, GetBriefcasePathList(hbr), &hhtPathTrans);

   if (tr == TR_SUCCESS)
   {
      tr = ReadBriefcaseInfo(hcf, hbr, hhtPathTrans);

      if (tr == TR_SUCCESS)
      {
         HHANDLETRANS hhtNameTrans;

         tr = ReadStringTable(hcf, GetBriefcaseNameStringTable(hbr), &hhtNameTrans);

         if (tr == TR_SUCCESS)
         {
            tr = ReadTwinFamilies(hcf, hbr, pcdbver, hhtPathTrans, hhtNameTrans);

            if (tr == TR_SUCCESS)
               tr = ReadFolderPairList(hcf, hbr, hhtPathTrans, hhtNameTrans);

            DestroyHandleTranslator(hhtNameTrans);
         }
      }

      DestroyHandleTranslator(hhtPathTrans);
   }

   return(tr);
}


TWINRESULT WriteTwinDatabase(HCACHEDFILE hcf, HBRFCASE hbr)
{
   TWINRESULT tr;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));

   if (! SeekInCachedFile(hcf, 0, FILE_BEGIN))
   {
      DBHEADER dbh;

      /* Set up database header. */

      CopyMemory(dbh.rgbyteMagic, MAGIC_HEADER, MAGIC_HEADER_LEN);
      dbh.dwcbHeaderLen = sizeof(dbh);
      dbh.dwMajorVer = HEADER_MAJOR_VER;
      dbh.dwMinorVer = HEADER_MINOR_VER;

      tr = WriteDBHeader(hcf, &dbh);

      if (tr == TR_SUCCESS)
      {
         TRACE_OUT((TEXT("WriteTwinDatabase(): Wrote database header version %lu.%lu."),
                    dbh.dwMajorVer,
                    dbh.dwMinorVer));

         tr = WriteTwinInfo(hcf, hbr);

         if (tr == TR_SUCCESS && ! SetEndOfCachedFile(hcf))
            tr = TR_BRIEFCASE_WRITE_FAILED;
      }
   }
   else
      tr = TR_BRIEFCASE_WRITE_FAILED;

   return(tr);
}


TWINRESULT ReadTwinDatabase(HBRFCASE hbr, HCACHEDFILE hcf)
{
   TWINRESULT tr;

   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));

   if (! SeekInCachedFile(hcf, 0, FILE_BEGIN))
   {
      DBHEADER dbh;

      tr = ReadDBHeader(hcf, &dbh);

      if (tr == TR_SUCCESS)
      {
         TRACE_OUT((TEXT("ReadTwinDatabase(): Read database header version %lu.%lu."),
                    dbh.dwMajorVer,
                    dbh.dwMinorVer));

         tr = ReadTwinInfo(hcf, hbr, (PCDBVERSION)&dbh.dwMajorVer);

         if (tr == TR_SUCCESS)
            ASSERT(GetCachedFilePointerPosition(hcf) == GetCachedFileSize(hcf));
      }
   }
   else
      tr = TR_BRIEFCASE_READ_FAILED;

   return(tr);
}


TWINRESULT WriteDBSegmentHeader(HCACHEDFILE hcf,
                                       LONG lcbDBSegmentHeaderOffset,
                                       PCVOID pcvSegmentHeader,
                                       UINT ucbSegmentHeaderLen)
{
   TWINRESULT tr;
   DWORD dwcbStartOffset;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(lcbDBSegmentHeaderOffset >= 0);
   ASSERT(ucbSegmentHeaderLen > 0);
   ASSERT(IS_VALID_READ_BUFFER_PTR(pcvSegmentHeader, BYTE, ucbSegmentHeaderLen));

   dwcbStartOffset = GetCachedFilePointerPosition(hcf);

   if (dwcbStartOffset != INVALID_SEEK_POSITION &&
       SeekInCachedFile(hcf, lcbDBSegmentHeaderOffset, SEEK_SET) != INVALID_SEEK_POSITION &&
       WriteToCachedFile(hcf, pcvSegmentHeader, ucbSegmentHeaderLen, NULL) &&
       SeekInCachedFile(hcf, dwcbStartOffset, SEEK_SET) != INVALID_SEEK_POSITION)
      tr = TR_SUCCESS;
   else
      tr = TR_BRIEFCASE_WRITE_FAILED;

   return(tr);
}


TWINRESULT TranslateFCRESULTToTWINRESULT(FCRESULT fcr)
{
   TWINRESULT tr;

   switch (fcr)
   {
      case FCR_SUCCESS:
         tr = TR_SUCCESS;
         break;

      case FCR_OUT_OF_MEMORY:
         tr = TR_OUT_OF_MEMORY;
         break;

      case FCR_OPEN_FAILED:
         tr = TR_BRIEFCASE_OPEN_FAILED;
         break;

      case FCR_CREATE_FAILED:
         tr = TR_BRIEFCASE_OPEN_FAILED;
         break;

      case FCR_WRITE_FAILED:
         tr = TR_BRIEFCASE_WRITE_FAILED;
         break;

      default:
         ASSERT(fcr == FCR_FILE_LOCKED);
         tr = TR_BRIEFCASE_LOCKED;
         break;
   }

   return(tr);
}


/* Constants
 ************/

/* last resort default minimum cache size */

#define DEFAULT_MIN_CACHE_SIZE      (32)


/* Types
 ********/

/* cached file description structure */

typedef struct _icachedfile
{
   /* current position of file pointer in file */

   DWORD dwcbCurFilePosition;

   /* file handle of cached file */

   HANDLE hfile;

   /* file open mode */

   DWORD dwOpenMode;

   /* size of cache in bytes */

   DWORD dwcbCacheSize;

   /* pointer to base of cache */

   PBYTE pbyteCache;

   /* size of default cache in bytes */

   DWORD dwcbDefaultCacheSize;

   /* default cache */

   PBYTE pbyteDefaultCache;

   /* length of file (including data written to cache) */

   DWORD dwcbFileLen;

   /* offset of start of cache in file */

   DWORD dwcbFileOffsetOfCache;

   /* number of valid bytes in cache, starting at beginning of cache */

   DWORD dwcbValid;

   /* number of uncommitted bytes in cache, starting at beginning of cache */

   DWORD dwcbUncommitted;

   /* path of cached file */

   LPTSTR pszPath;
}
ICACHEDFILE;
DECLARE_STANDARD_TYPES(ICACHEDFILE);


FCRESULT SetUpCachedFile(PCCACHEDFILE, PHCACHEDFILE);

void BreakDownCachedFile(PICACHEDFILE);
void ResetCacheToEmpty(PICACHEDFILE);
DWORD ReadFromCache(PICACHEDFILE, PVOID, DWORD);
DWORD GetValidReadData(PICACHEDFILE, PBYTE *);
BOOL FillCache(PICACHEDFILE, PDWORD);
DWORD WriteToCache(PICACHEDFILE, PCVOID, DWORD);
DWORD GetAvailableWriteSpace(PICACHEDFILE, PBYTE *);
BOOL CommitCache(PICACHEDFILE);


FCRESULT SetUpCachedFile(PCCACHEDFILE pccf, PHCACHEDFILE phcf)
{
   FCRESULT fcr;
   HANDLE hfNew;

   ASSERT(IS_VALID_STRUCT_PTR(pccf, CCACHEDFILE));
   ASSERT(IS_VALID_WRITE_PTR(phcf, HCACHEDFILE));

   /* Open the file with the requested open and sharing flags. */

   hfNew = CreateFile(pccf->pcszPath, pccf->dwOpenMode, pccf->dwSharingMode,
                      pccf->psa, pccf->dwCreateMode, pccf->dwAttrsAndFlags,
                      pccf->hTemplateFile);

   if (hfNew != INVALID_HANDLE_VALUE)
   {

      PICACHEDFILE picf;

      fcr = FCR_OUT_OF_MEMORY;

      /* Try to allocate a new cached file structure. */

      if (AllocateMemory(sizeof(*picf), &picf))
      {
         DWORD dwcbDefaultCacheSize;

         /* Allocate the default cache for the cached file. */

         if (pccf->dwcbDefaultCacheSize > 0)
            dwcbDefaultCacheSize = pccf->dwcbDefaultCacheSize;
         else
         {
            dwcbDefaultCacheSize = DEFAULT_MIN_CACHE_SIZE;

            WARNING_OUT((TEXT("SetUpCachedFile(): Using minimum cache size of %lu instead of %lu."),
                         dwcbDefaultCacheSize,
                         pccf->dwcbDefaultCacheSize));
         }

         if (AllocateMemory(dwcbDefaultCacheSize, &(picf->pbyteDefaultCache)))
         {
            if (StringCopy2(pccf->pcszPath, &(picf->pszPath)))
            {
               DWORD dwcbFileLenHigh;

               picf->dwcbFileLen = GetFileSize(hfNew, &dwcbFileLenHigh);

               if (picf->dwcbFileLen != INVALID_FILE_SIZE && ! dwcbFileLenHigh)
               {
                  /* Success!  Fill in cached file structure fields. */

                  picf->hfile = hfNew;
                  picf->dwcbCurFilePosition = 0;
                  picf->dwcbCacheSize = dwcbDefaultCacheSize;
                  picf->pbyteCache = picf->pbyteDefaultCache;
                  picf->dwcbDefaultCacheSize = dwcbDefaultCacheSize;
                  picf->dwOpenMode = pccf->dwOpenMode;

                  ResetCacheToEmpty(picf);

                  *phcf = (HCACHEDFILE)picf;
                  fcr = FCR_SUCCESS;

                  ASSERT(IS_VALID_HANDLE(*phcf, CACHEDFILE));

                  TRACE_OUT((TEXT("SetUpCachedFile(): Created %lu byte default cache for file %s."),
                             picf->dwcbCacheSize,
                             picf->pszPath));
               }
               else
               {
                  fcr = FCR_OPEN_FAILED;

SETUPCACHEDFILE_BAIL1:
                  FreeMemory(picf->pbyteDefaultCache);
SETUPCACHEDFILE_BAIL2:
                  FreeMemory(picf);
SETUPCACHEDFILE_BAIL3:
                  /*
                   * Failing to close the file properly is not a failure
                   * condition here.
                   */
                  CloseHandle(hfNew);
               }
            }
            else
               goto SETUPCACHEDFILE_BAIL1;
         }
         else
            goto SETUPCACHEDFILE_BAIL2;
      }
      else
         goto SETUPCACHEDFILE_BAIL3;
   }
   else
   {
      switch (GetLastError())
      {
         /* Returned when file opened by local machine. */
         case ERROR_SHARING_VIOLATION:
            fcr = FCR_FILE_LOCKED;
            break;

         default:
            fcr = FCR_OPEN_FAILED;
            break;
      }
   }

   return(fcr);
}


void BreakDownCachedFile(PICACHEDFILE picf)
{
   ASSERT(IS_VALID_STRUCT_PTR(picf, CICACHEDFILE));

   /* Are we using the default cache? */

   if (picf->pbyteCache != picf->pbyteDefaultCache)
      /* No.  Free the cache. */
      FreeMemory(picf->pbyteCache);

   /* Free the default cache. */

   FreeMemory(picf->pbyteDefaultCache);

   TRACE_OUT((TEXT("BreakDownCachedFile(): Destroyed cache for file %s."),
              picf->pszPath));

   FreeMemory(picf->pszPath);
   FreeMemory(picf);
}


void ResetCacheToEmpty(PICACHEDFILE picf)
{
   /*
    * Don't fully validate *picf here since we may be called by
    * SetUpCachedFile() before *picf has been set up.
    */

   ASSERT(IS_VALID_WRITE_PTR(picf, ICACHEDFILE));

   picf->dwcbFileOffsetOfCache = picf->dwcbCurFilePosition;
   picf->dwcbValid = 0;
   picf->dwcbUncommitted = 0;
}


DWORD ReadFromCache(PICACHEDFILE picf, PVOID hpbyteBuffer, DWORD dwcb)
{
   DWORD dwcbRead;
   PBYTE pbyteStart;
   DWORD dwcbValid;

   ASSERT(IS_VALID_STRUCT_PTR(picf, CICACHEDFILE));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(hpbyteBuffer, BYTE, (UINT)dwcb));

   ASSERT(IS_FLAG_SET(picf->dwOpenMode, GENERIC_READ));
   ASSERT(dwcb > 0);

   /* Is there any valid data that can be read from the cache? */

   dwcbValid = GetValidReadData(picf, &pbyteStart);

   if (dwcbValid > 0)
   {
      /* Yes.  Copy it into the buffer. */

      dwcbRead = min(dwcbValid, dwcb);

      CopyMemory(hpbyteBuffer, pbyteStart, dwcbRead);

      picf->dwcbCurFilePosition += dwcbRead;
   }
   else
      dwcbRead = 0;

   return(dwcbRead);
}


DWORD GetValidReadData(PICACHEDFILE picf, PBYTE *ppbyteStart)
{
   DWORD dwcbValid;

   ASSERT(IS_VALID_STRUCT_PTR(picf, CICACHEDFILE));
   ASSERT(IS_VALID_WRITE_PTR(ppbyteStart, PBYTE *));

   ASSERT(IS_FLAG_SET(picf->dwOpenMode, GENERIC_READ));

   /* Is there any valid read data in the cache? */

   /* The current file position must be inside the valid data in the cache. */

   /* Watch out for overflow. */

   ASSERT(picf->dwcbFileOffsetOfCache <= DWORD_MAX - picf->dwcbValid);

   if (picf->dwcbCurFilePosition >= picf->dwcbFileOffsetOfCache &&
       picf->dwcbCurFilePosition < picf->dwcbFileOffsetOfCache + picf->dwcbValid)
   {
      DWORD dwcbStartBias;

      /* Yes. */

      dwcbStartBias = picf->dwcbCurFilePosition - picf->dwcbFileOffsetOfCache;

      *ppbyteStart = picf->pbyteCache + dwcbStartBias;

      /* The second clause above protects against underflow here. */

      dwcbValid = picf->dwcbValid - dwcbStartBias;
   }
   else
      /* No. */
      dwcbValid = 0;

   return(dwcbValid);
}


BOOL FillCache(PICACHEDFILE picf, PDWORD pdwcbNewData)
{
   BOOL bResult = FALSE;

   ASSERT(IS_VALID_STRUCT_PTR(picf, CICACHEDFILE));
   ASSERT(IS_VALID_WRITE_PTR(pdwcbNewData, DWORD));

   ASSERT(IS_FLAG_SET(picf->dwOpenMode, GENERIC_READ));

   if (CommitCache(picf))
   {
      DWORD dwcbOffset;

      ResetCacheToEmpty(picf);

      /* Seek to start position. */

      dwcbOffset = SetFilePointer(picf->hfile, picf->dwcbCurFilePosition, NULL, FILE_BEGIN);

      if (dwcbOffset != INVALID_SEEK_POSITION)
      {
         DWORD dwcbRead;

         ASSERT(dwcbOffset == picf->dwcbCurFilePosition);

         /* Fill cache from file. */

         if (ReadFile(picf->hfile, picf->pbyteCache, picf->dwcbCacheSize, &dwcbRead, NULL))
         {
            picf->dwcbValid = dwcbRead;

            *pdwcbNewData = dwcbRead;
            bResult = TRUE;

            TRACE_OUT((TEXT("FillCache(): Read %lu bytes into cache starting at offset %lu in file %s."),
                       dwcbRead,
                       dwcbOffset,
                       picf->pszPath));
         }
      }
   }

   return(bResult);
}


DWORD WriteToCache(PICACHEDFILE picf, PCVOID hpbyteBuffer, DWORD dwcb)
{
   DWORD dwcbAvailable;
   PBYTE pbyteStart;
   DWORD dwcbWritten;
   DWORD dwcbNewUncommitted;

   ASSERT(IS_VALID_STRUCT_PTR(picf, CICACHEDFILE));
   ASSERT(IS_VALID_READ_BUFFER_PTR(hpbyteBuffer, BYTE, (UINT)dwcb));

   ASSERT(IS_FLAG_SET(picf->dwOpenMode, GENERIC_WRITE));
   ASSERT(dwcb > 0);

   /* Is there any room left to write data into the cache? */

   dwcbAvailable = GetAvailableWriteSpace(picf, &pbyteStart);

   /* Yes.  Determine how much to copy into cache. */

   dwcbWritten = min(dwcbAvailable, dwcb);

   /* Can we write anything into the cache? */

   if (dwcbWritten > 0)
   {
      /* Yes.  Write it. */

      CopyMemory(pbyteStart, hpbyteBuffer, dwcbWritten);

      /* Watch out for overflow. */

      ASSERT(picf->dwcbCurFilePosition <= DWORD_MAX - dwcbWritten);

      picf->dwcbCurFilePosition += dwcbWritten;

      /* Watch out for underflow. */

      ASSERT(picf->dwcbCurFilePosition >= picf->dwcbFileOffsetOfCache);

      dwcbNewUncommitted = picf->dwcbCurFilePosition - picf->dwcbFileOffsetOfCache;

      if (picf->dwcbUncommitted < dwcbNewUncommitted)
         picf->dwcbUncommitted = dwcbNewUncommitted;

      if (picf->dwcbValid < dwcbNewUncommitted)
      {
         DWORD dwcbNewFileLen;

         picf->dwcbValid = dwcbNewUncommitted;

         /* Watch out for overflow. */

         ASSERT(picf->dwcbFileOffsetOfCache <= DWORD_MAX - dwcbNewUncommitted);

         dwcbNewFileLen = picf->dwcbFileOffsetOfCache + dwcbNewUncommitted;

         if (picf->dwcbFileLen < dwcbNewFileLen)
            picf->dwcbFileLen = dwcbNewFileLen;
      }
   }

   return(dwcbWritten);
}


DWORD GetAvailableWriteSpace(PICACHEDFILE picf, PBYTE *ppbyteStart)
{
   DWORD dwcbAvailable;

   ASSERT(IS_VALID_STRUCT_PTR(picf, CICACHEDFILE));
   ASSERT(IS_VALID_WRITE_PTR(ppbyteStart, PBYTE *));

   ASSERT(IS_FLAG_SET(picf->dwOpenMode, GENERIC_WRITE));

   /* Is there room to write data in the cache? */

   /*
    * The current file position must be inside or just after the end of the
    * valid data in the cache, or at the front of the cache when there is no
    * valid data in the cache.
    */

   /* Watch out for overflow. */

   ASSERT(picf->dwcbFileOffsetOfCache <= DWORD_MAX - picf->dwcbValid);

   if (picf->dwcbCurFilePosition >= picf->dwcbFileOffsetOfCache &&
       picf->dwcbCurFilePosition <= picf->dwcbFileOffsetOfCache + picf->dwcbValid)
   {
      DWORD dwcbStartBias;

      /* Yes. */

      dwcbStartBias = picf->dwcbCurFilePosition - picf->dwcbFileOffsetOfCache;

      *ppbyteStart = picf->pbyteCache + dwcbStartBias;

      /* Watch out for underflow. */

      ASSERT(picf->dwcbCacheSize >= dwcbStartBias);

      dwcbAvailable = picf->dwcbCacheSize - dwcbStartBias;
   }
   else
      /* No. */
      dwcbAvailable = 0;

   return(dwcbAvailable);
}


BOOL CommitCache(PICACHEDFILE picf)
{
   BOOL bResult;

   ASSERT(IS_VALID_STRUCT_PTR(picf, CICACHEDFILE));

   /* Any data to commit? */

   if (IS_FLAG_SET(picf->dwOpenMode, GENERIC_WRITE) &&
       picf->dwcbUncommitted > 0)
   {
      DWORD dwcbOffset;

      /* Yes.  Seek to start position of cache in file. */

      bResult = FALSE;

      dwcbOffset = SetFilePointer(picf->hfile, picf->dwcbFileOffsetOfCache, NULL, FILE_BEGIN);

      if (dwcbOffset != INVALID_SEEK_POSITION)
      {
         DWORD dwcbWritten;

         ASSERT(dwcbOffset == picf->dwcbFileOffsetOfCache);

         /* Write to file from cache. */

         if (WriteFile(picf->hfile, picf->pbyteCache, picf->dwcbUncommitted, &dwcbWritten, NULL) &&
             dwcbWritten == picf->dwcbUncommitted)
         {
            TRACE_OUT((TEXT("CommitCache(): Committed %lu uncommitted bytes starting at offset %lu in file %s."),
                       dwcbWritten,
                       dwcbOffset,
                       picf->pszPath));

            bResult = TRUE;
         }
      }
   }
   else
      bResult = TRUE;

   return(bResult);
}


FCRESULT CreateCachedFile(PCCACHEDFILE pccf, PHCACHEDFILE phcf)
{
   ASSERT(IS_VALID_STRUCT_PTR(pccf, CCACHEDFILE));
   ASSERT(IS_VALID_WRITE_PTR(phcf, HCACHEDFILE));

   return(SetUpCachedFile(pccf, phcf));
}


FCRESULT SetCachedFileCacheSize(HCACHEDFILE hcf, DWORD dwcbNewCacheSize)
{
   FCRESULT fcr;

   /* dwcbNewCacheSize may be any value here. */

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));

   /* Use default cache size instead of 0. */

   if (! dwcbNewCacheSize)
   {
      ASSERT(((PICACHEDFILE)hcf)->dwcbDefaultCacheSize > 0);

      dwcbNewCacheSize = ((PICACHEDFILE)hcf)->dwcbDefaultCacheSize;
   }

   /* Is the cache size changing? */

   if (dwcbNewCacheSize == ((PICACHEDFILE)hcf)->dwcbCacheSize)
      /* No.  Whine about it. */
      WARNING_OUT((TEXT("SetCachedFileCacheSize(): Cache size is already %lu bytes."),
                   dwcbNewCacheSize));

   /* Commit the cache so we can change its size. */

   if (CommitCache((PICACHEDFILE)hcf))
   {
      PBYTE pbyteNewCache;

      /* Throw away cached data. */

      ResetCacheToEmpty((PICACHEDFILE)hcf);

      /* Do we need to allocate a new cache? */

      if (dwcbNewCacheSize <= ((PICACHEDFILE)hcf)->dwcbDefaultCacheSize)
      {
         /* No. */

         pbyteNewCache = ((PICACHEDFILE)hcf)->pbyteDefaultCache;

         fcr = FCR_SUCCESS;

         TRACE_OUT((TEXT("SetCachedFileCacheSize(): Using %lu bytes of %lu bytes allocated to default cache."),
                    dwcbNewCacheSize,
                    ((PICACHEDFILE)hcf)->dwcbDefaultCacheSize));
      }
      else
      {
         /* Yes. */

         if (AllocateMemory(dwcbNewCacheSize, &pbyteNewCache))
         {
            fcr = FCR_SUCCESS;

            TRACE_OUT((TEXT("SetCachedFileCacheSize(): Allocated %lu bytes for new cache."),
                       dwcbNewCacheSize));
         }
         else
            fcr = FCR_OUT_OF_MEMORY;
      }

      if (fcr == FCR_SUCCESS)
      {
         /* Do we need to free the old cache? */

         if (((PICACHEDFILE)hcf)->pbyteCache != ((PICACHEDFILE)hcf)->pbyteDefaultCache)
         {
            /* Yes. */

            ASSERT(((PICACHEDFILE)hcf)->dwcbCacheSize > ((PICACHEDFILE)hcf)->dwcbDefaultCacheSize);

            FreeMemory(((PICACHEDFILE)hcf)->pbyteCache);
         }

         /* Use new cache. */

         ((PICACHEDFILE)hcf)->pbyteCache = pbyteNewCache;
         ((PICACHEDFILE)hcf)->dwcbCacheSize = dwcbNewCacheSize;
      }
   }
   else
      fcr = FCR_WRITE_FAILED;

   return(fcr);
}


DWORD SeekInCachedFile(HCACHEDFILE hcf, DWORD dwcbSeek, DWORD uOrigin)
{
   DWORD dwcbResult;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(uOrigin == FILE_BEGIN || uOrigin == FILE_CURRENT || uOrigin == FILE_END);

   {
      BOOL bValidTarget = TRUE;
      DWORD dwcbWorkingOffset = 0;

      /* Determine seek base. */

      switch (uOrigin)
      {
         case SEEK_CUR:
            dwcbWorkingOffset = ((PICACHEDFILE)hcf)->dwcbCurFilePosition;
            break;

         case SEEK_SET:
            break;

         case SEEK_END:
            dwcbWorkingOffset = ((PICACHEDFILE)hcf)->dwcbFileLen;
            break;

         default:
            bValidTarget = FALSE;
            break;
      }

      if (bValidTarget)
      {
         /* Add bias. */

         /* Watch out for overflow. */

         ASSERT(dwcbWorkingOffset <= DWORD_MAX - dwcbSeek);

         dwcbWorkingOffset += dwcbSeek;

         ((PICACHEDFILE)hcf)->dwcbCurFilePosition = dwcbWorkingOffset;
         dwcbResult = dwcbWorkingOffset;
      }
      else
         dwcbResult = INVALID_SEEK_POSITION;
   }

   return(dwcbResult);
}


BOOL SetEndOfCachedFile(HCACHEDFILE hcf)
{
   BOOL bResult;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));

   bResult = CommitCache((PICACHEDFILE)hcf);

   if (bResult)
   {
      bResult = (SetFilePointer(((PICACHEDFILE)hcf)->hfile,
                                ((PICACHEDFILE)hcf)->dwcbCurFilePosition, NULL,
                                FILE_BEGIN) ==
                 ((PICACHEDFILE)hcf)->dwcbCurFilePosition);

      if (bResult)
      {
         bResult = SetEndOfFile(((PICACHEDFILE)hcf)->hfile);

         if (bResult)
         {
            ResetCacheToEmpty((PICACHEDFILE)hcf);

            ((PICACHEDFILE)hcf)->dwcbFileLen = ((PICACHEDFILE)hcf)->dwcbCurFilePosition;

#ifdef DEBUG

            {
               DWORD dwcbFileSizeHigh;
               DWORD dwcbFileSizeLow;

               dwcbFileSizeLow = GetFileSize(((PICACHEDFILE)hcf)->hfile, &dwcbFileSizeHigh);

               ASSERT(! dwcbFileSizeHigh);
               ASSERT(((PICACHEDFILE)hcf)->dwcbFileLen == dwcbFileSizeLow);
               ASSERT(((PICACHEDFILE)hcf)->dwcbCurFilePosition == dwcbFileSizeLow);
            }

#endif

         }
      }
   }

   return(bResult);
}


DWORD GetCachedFilePointerPosition(HCACHEDFILE hcf)
{
   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));

   return(((PICACHEDFILE)hcf)->dwcbCurFilePosition);
}


DWORD GetCachedFileSize(HCACHEDFILE hcf)
{
   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));

   return(((PICACHEDFILE)hcf)->dwcbFileLen);
}


BOOL ReadFromCachedFile(HCACHEDFILE hcf, PVOID hpbyteBuffer, DWORD dwcb,
                               PDWORD pdwcbRead)
{
   BOOL bResult;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(hpbyteBuffer, BYTE, (UINT)dwcb));
   ASSERT(! pdwcbRead || IS_VALID_WRITE_PTR(pdwcbRead, DWORD));

   *pdwcbRead = 0;

   /*
    * Make sure that the cached file has been set up for read access before
    * allowing a read.
    */

   if (IS_FLAG_SET(((PICACHEDFILE)hcf)->dwOpenMode, GENERIC_READ))
   {
      DWORD dwcbToRead = dwcb;

      /* Read requested data. */

      bResult = TRUE;

      while (dwcbToRead > 0)
      {
         DWORD dwcbRead;

         dwcbRead = ReadFromCache((PICACHEDFILE)hcf, hpbyteBuffer, dwcbToRead);

         /* Watch out for underflow. */

         ASSERT(dwcbRead <= dwcbToRead);

         dwcbToRead -= dwcbRead;

         if (dwcbToRead > 0)
         {
            DWORD dwcbNewData;

            if (FillCache((PICACHEDFILE)hcf, &dwcbNewData))
            {
               hpbyteBuffer = (PBYTE)hpbyteBuffer + dwcbRead;

               if (! dwcbNewData)
                  break;
            }
            else
            {
               bResult = FALSE;
               break;
            }
         }
      }

      /* Watch out for underflow. */

      ASSERT(dwcb >= dwcbToRead);

      if (bResult && pdwcbRead)
         *pdwcbRead = dwcb - dwcbToRead;
   }
   else
      bResult = FALSE;

   ASSERT(! pdwcbRead ||
          ((bResult && *pdwcbRead <= dwcb) ||
           (! bResult && ! *pdwcbRead)));

   return(bResult);
}


BOOL WriteToCachedFile(HCACHEDFILE hcf, PCVOID hpbyteBuffer, DWORD dwcb,
                              PDWORD pdwcbWritten)
{
   BOOL bResult;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_READ_BUFFER_PTR(hpbyteBuffer, BYTE, (UINT)dwcb));

   ASSERT(dwcb > 0);

   /*
    * Make sure that the cached file has been set up for write access before
    * allowing a write.
    */

   if (IS_FLAG_SET(((PICACHEDFILE)hcf)->dwOpenMode, GENERIC_WRITE))
   {
      DWORD dwcbToWrite = dwcb;

      /* Write requested data. */

      bResult = TRUE;

      while (dwcbToWrite > 0)
      {
         DWORD dwcbWritten;

         dwcbWritten = WriteToCache((PICACHEDFILE)hcf, hpbyteBuffer, dwcbToWrite);

         /* Watch out for underflow. */

         ASSERT(dwcbWritten <= dwcbToWrite);

         dwcbToWrite -= dwcbWritten;

         if (dwcbToWrite > 0)
         {
            if (CommitCache((PICACHEDFILE)hcf))
            {
               ResetCacheToEmpty((PICACHEDFILE)hcf);

               hpbyteBuffer = (PCBYTE)hpbyteBuffer + dwcbWritten;
            }
            else
            {
               bResult = FALSE;

               break;
            }
         }
      }

      ASSERT(dwcb >= dwcbToWrite);

      if (pdwcbWritten)
      {
         if (bResult)
         {
            ASSERT(! dwcbToWrite);

            *pdwcbWritten = dwcb;
         }
         else
            *pdwcbWritten = 0;
      }
   }
   else
      bResult = FALSE;

   ASSERT(! pdwcbWritten ||
          ((bResult && *pdwcbWritten == dwcb) ||
           (! bResult && ! *pdwcbWritten)));

   return(bResult);
}


BOOL CommitCachedFile(HCACHEDFILE hcf)
{
   BOOL bResult;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));

   /*
    * Make sure that the cached file has been set up for write access before
    * allowing a commit.
    */

   if (IS_FLAG_SET(((PICACHEDFILE)hcf)->dwOpenMode, GENERIC_WRITE))
      bResult = CommitCache((PICACHEDFILE)hcf);
   else
      bResult = FALSE;

   return(bResult);
}


HANDLE GetFileHandle(HCACHEDFILE hcf)
{
   HANDLE hfResult;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));

   hfResult = ((PCICACHEDFILE)hcf)->hfile;

   return(hfResult);
}


BOOL CloseCachedFile(HCACHEDFILE hcf)
{
   BOOL bResult;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));

   {
      BOOL bCommit;
      BOOL bClose;

      bCommit = CommitCache((PICACHEDFILE)hcf);

      bClose = CloseHandle(((PCICACHEDFILE)hcf)->hfile);

      BreakDownCachedFile((PICACHEDFILE)hcf);

      bResult = bCommit && bClose;
   }

   return(bResult);
}


/* Constants
 ************/

/* pointer array allocation constants */

#define NUM_START_FOLDER_TWIN_PTRS     (16)
#define NUM_FOLDER_TWIN_PTRS_TO_ADD    (16)


/* Types
 ********/

/* internal new folder twin description */

typedef struct _inewfoldertwin
{
   HPATH hpathFirst;
   HPATH hpathSecond;
   HSTRING hsName;
   DWORD dwAttributes;
   HBRFCASE hbr;
   DWORD dwFlags;
}
INEWFOLDERTWIN;
DECLARE_STANDARD_TYPES(INEWFOLDERTWIN);

/* database folder twin list header */

typedef struct _dbfoldertwinlistheader
{
   LONG lcFolderPairs;
}
DBFOLDERTWINLISTHEADER;
DECLARE_STANDARD_TYPES(DBFOLDERTWINLISTHEADER);

/* database folder twin structure */

typedef struct _dbfoldertwin
{
   /* shared stub flags */

   DWORD dwStubFlags;

   /* old handle to first folder path */

   HPATH hpath1;

   /* old handle to second folder path */

   HPATH hpath2;

   /* old handle to name string */

   HSTRING hsName;

   /* attributes to match */

   DWORD dwAttributes;
}
DBFOLDERTWIN;
DECLARE_STANDARD_TYPES(DBFOLDERTWIN);


TWINRESULT TwinFolders(PCINEWFOLDERTWIN, PFOLDERPAIR *);
BOOL CreateFolderPair(PCINEWFOLDERTWIN, PFOLDERPAIR *);
BOOL CreateHalfOfFolderPair(HPATH, HBRFCASE, PFOLDERPAIR *);
void DestroyHalfOfFolderPair(PFOLDERPAIR);
BOOL CreateSharedFolderPairData(PCINEWFOLDERTWIN, PFOLDERPAIRDATA *);
void DestroySharedFolderPairData(PFOLDERPAIRDATA);
COMPARISONRESULT FolderPairSortCmp(PCVOID, PCVOID);
COMPARISONRESULT FolderPairSearchCmp(PCVOID, PCVOID);
BOOL RemoveSourceFolderTwin(POBJECTTWIN, PVOID);
void UnlinkHalfOfFolderPair(PFOLDERPAIR);
BOOL FolderTwinIntersectsFolder(PCFOLDERPAIR, HPATH);
TWINRESULT CreateListOfFolderTwins(HBRFCASE, ARRAYINDEX, HPATH, PFOLDERTWIN *, PARRAYINDEX);
void DestroyListOfFolderTwins(PFOLDERTWIN);
TWINRESULT AddFolderTwinToList(PFOLDERPAIR, PFOLDERTWIN, PFOLDERTWIN *);
TWINRESULT WriteFolderPair(HCACHEDFILE, PFOLDERPAIR);
TWINRESULT ReadFolderPair(HCACHEDFILE, HBRFCASE, HHANDLETRANS, HHANDLETRANS);


/* Macros
 *********/

/* name component macros used by NameComponentsIntersect() */

#define COMPONENT_CHARS_MATCH(ch1, ch2)   (CharLower((PTSTR)(DWORD)ch1) == CharLower((PTSTR)(DWORD)ch2) || (ch1) == QMARK || (ch2) == QMARK)

#define IS_COMPONENT_TERMINATOR(ch)       (! (ch) || (ch) == PERIOD || (ch) == ASTERISK)




BOOL NameComponentsIntersect(LPCTSTR pcszComponent1,
                                          LPCTSTR pcszComponent2)
{
   BOOL bIntersect;

   ASSERT(IS_VALID_STRING_PTR(pcszComponent1, CSTR));
   ASSERT(IS_VALID_STRING_PTR(pcszComponent2, CSTR));

   while (! IS_COMPONENT_TERMINATOR(*pcszComponent1) && ! IS_COMPONENT_TERMINATOR(*pcszComponent2) &&
          COMPONENT_CHARS_MATCH(*pcszComponent1, *pcszComponent2))
   {
      pcszComponent1 = CharNext(pcszComponent1);
      pcszComponent2 = CharNext(pcszComponent2);
   }

   if (*pcszComponent1 == ASTERISK ||
       *pcszComponent2 == ASTERISK ||
       *pcszComponent1 == *pcszComponent2)
      bIntersect = TRUE;
   else
   {
      LPCTSTR pcszTrailer;

      if (! *pcszComponent1 || *pcszComponent1 == PERIOD)
         pcszTrailer = pcszComponent2;
      else
         pcszTrailer = pcszComponent1;

      while (*pcszTrailer == QMARK)
         pcszTrailer++;

      if (IS_COMPONENT_TERMINATOR(*pcszTrailer))
         bIntersect = TRUE;
      else
         bIntersect = FALSE;
   }

   return(bIntersect);
}


BOOL NamesIntersect(LPCTSTR pcszName1, LPCTSTR pcszName2)
{
   BOOL bIntersect = FALSE;

   ASSERT(IS_VALID_STRING_PTR(pcszName1, CSTR));
   ASSERT(IS_VALID_STRING_PTR(pcszName2, CSTR));

   if (NameComponentsIntersect(pcszName1, pcszName2))
   {
      LPCTSTR pcszExt1;
      LPCTSTR pcszExt2;

      /* Get extensions, skipping leading periods. */

      pcszExt1 = ExtractExtension(pcszName1);
      if (*pcszExt1 == PERIOD)
         pcszExt1 = CharNext(pcszExt1);

      pcszExt2 = ExtractExtension(pcszName2);
      if (*pcszExt2 == PERIOD)
         pcszExt2 = CharNext(pcszExt2);

      bIntersect = NameComponentsIntersect(pcszExt1, pcszExt2);
   }

   return(bIntersect);
}


void ClearFlagInArrayOfStubs(HPTRARRAY hpa, DWORD dwClearFlags)
{
   ARRAYINDEX aicPtrs;
   ARRAYINDEX ai;

   ASSERT(IS_VALID_HANDLE(hpa, PTRARRAY));
   ASSERT(FLAGS_ARE_VALID(dwClearFlags, ALL_STUB_FLAGS));

   aicPtrs = GetPtrCount(hpa);

   for (ai = 0; ai < aicPtrs; ai++)
      ClearStubFlag(GetPtr(hpa, ai), dwClearFlags);
}


/*
** CreateFolderPair()
**
** Creates a new folder pair, and adds them to a briefcase's list of folder
** pairs.
**
** Arguments:     pcinft - pointer to INEWFOLDERTWIN describing folder pair to
**                         create
**                ppfp - pointer to PFOLDERPAIR to be filled in with pointer to
**                       half of new folder pair representing
**                       pcnft->pcszFolder1
**
** Returns:
**
** Side Effects:  Adds the new folder pair to the global array of folder pairs.
**
** N.b., this function does not first check to see if the folder pair already
** exists in the global list of folder pairs.
*/
BOOL CreateFolderPair(PCINEWFOLDERTWIN pcinft, PFOLDERPAIR *ppfp)
{
   BOOL bResult = FALSE;
   PFOLDERPAIRDATA pfpd;

   ASSERT(IS_VALID_STRUCT_PTR(pcinft, CINEWFOLDERTWIN));
   ASSERT(IS_VALID_WRITE_PTR(ppfp, PFOLDERPAIR));

   /* Try to create the shared folder data structure. */

   if (CreateSharedFolderPairData(pcinft, &pfpd))
   {
      PFOLDERPAIR pfpNew1;
      BOOL bPtr1Loose = TRUE;

      if (CreateHalfOfFolderPair(pcinft->hpathFirst, pcinft->hbr, &pfpNew1))
      {
         PFOLDERPAIR pfpNew2;

         if (CreateHalfOfFolderPair(pcinft->hpathSecond, pcinft->hbr,
                                    &pfpNew2))
         {
            HPTRARRAY hpaFolderPairs;
            ARRAYINDEX ai1;

            /* Combine the two folder pair halves. */

            pfpNew1->pfpd = pfpd;
            pfpNew1->pfpOther = pfpNew2;

            pfpNew2->pfpd = pfpd;
            pfpNew2->pfpOther = pfpNew1;

            /* Set flags. */

            if (IS_FLAG_SET(pcinft->dwFlags, NFT_FL_SUBTREE))
            {
               SetStubFlag(&(pfpNew1->stub), STUB_FL_SUBTREE);
               SetStubFlag(&(pfpNew2->stub), STUB_FL_SUBTREE);
            }

            /*
             * Try to add the two folder pairs to the global list of folder
             * pairs.
             */

            hpaFolderPairs = GetBriefcaseFolderPairPtrArray(pcinft->hbr);

            if (AddPtr(hpaFolderPairs, FolderPairSortCmp, pfpNew1, &ai1))
            {
               ARRAYINDEX ai2;

               bPtr1Loose = FALSE;

               if (AddPtr(hpaFolderPairs, FolderPairSortCmp, pfpNew2, &ai2))
               {
                  ASSERT(IS_VALID_STRUCT_PTR(pfpNew1, CFOLDERPAIR));
                  ASSERT(IS_VALID_STRUCT_PTR(pfpNew2, CFOLDERPAIR));

                  if (ApplyNewFolderTwinsToTwinFamilies(pfpNew1))
                  {
                     *ppfp = pfpNew1;
                     bResult = TRUE;
                  }
                  else
                  {
                     DeletePtr(hpaFolderPairs, ai2);

CREATEFOLDERPAIR_BAIL1:
                     DeletePtr(hpaFolderPairs, ai1);

CREATEFOLDERPAIR_BAIL2:
                     /*
                      * Don't try to remove pfpNew2 from the global list of
                      * folder pairs here since it was never added
                      * successfully.
                      */
                     DestroyHalfOfFolderPair(pfpNew2);

CREATEFOLDERPAIR_BAIL3:
                     /*
                      * Don't try to remove pfpNew1 from the global list of
                      * folder pairs here since it was never added
                      * successfully.
                      */
                     DestroyHalfOfFolderPair(pfpNew1);

CREATEFOLDERPAIR_BAIL4:
                     DestroySharedFolderPairData(pfpd);
                  }
               }
               else
                  goto CREATEFOLDERPAIR_BAIL1;
            }
            else
               goto CREATEFOLDERPAIR_BAIL2;
         }
         else
            goto CREATEFOLDERPAIR_BAIL3;
      }
      else
         goto CREATEFOLDERPAIR_BAIL4;
   }

   return(bResult);
}


BOOL CreateHalfOfFolderPair(HPATH hpathFolder, HBRFCASE hbr,
                                    PFOLDERPAIR *ppfp)
{
   BOOL bResult = FALSE;
   PFOLDERPAIR pfpNew;

   ASSERT(IS_VALID_HANDLE(hpathFolder, PATH));
   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
   ASSERT(IS_VALID_WRITE_PTR(ppfp, PFOLDERPAIR));

   /* Try to create a new FOLDERPAIR structure. */

   if (AllocateMemory(sizeof(*pfpNew), &pfpNew))
   {
      /* Try to add the folder string to the folder string table. */

      if (CopyPath(hpathFolder, GetBriefcasePathList(hbr), &(pfpNew->hpath)))
      {
         /* Fill in the fields of the new FOLDERPAIR structure. */

         InitStub(&(pfpNew->stub), ST_FOLDERPAIR);

         *ppfp = pfpNew;
         bResult = TRUE;
      }
      else
         FreeMemory(pfpNew);
   }

   return(bResult);
}


void DestroyHalfOfFolderPair(PFOLDERPAIR pfp)
{
   ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));

   TRACE_OUT((TEXT("DestroyHalfOfFolderPair(): Destroying folder twin %s."),
              DebugGetPathString(pfp->hpath)));

   /* Has the other half of this folder pair already been destroyed? */

   if (IsStubFlagClear(&(pfp->stub), STUB_FL_BEING_DELETED))
      /* No.  Indicate that this half has already been deleted. */
      SetStubFlag(&(pfp->pfpOther->stub), STUB_FL_BEING_DELETED);

   /* Destroy FOLDERPAIR fields. */

   DeletePath(pfp->hpath);
   FreeMemory(pfp);
}


BOOL CreateSharedFolderPairData(PCINEWFOLDERTWIN pcinft,
                                        PFOLDERPAIRDATA *ppfpd)
{
   PFOLDERPAIRDATA pfpd;

   ASSERT(IS_VALID_STRUCT_PTR(pcinft, CINEWFOLDERTWIN));
   ASSERT(IS_VALID_WRITE_PTR(ppfpd, PFOLDERPAIRDATA));

   /* Try to allocate a new shared folder pair data data structure. */

   *ppfpd = NULL;

   if (AllocateMemory(sizeof(*pfpd), &pfpd))
   {
      /* Fill in the FOLDERPAIRDATA structure fields. */

      LockString(pcinft->hsName);
      pfpd->hsName = pcinft->hsName;

      pfpd->dwAttributes = pcinft->dwAttributes;
      pfpd->hbr = pcinft->hbr;

      ASSERT(! IS_ATTR_DIR(pfpd->dwAttributes));

      CLEAR_FLAG(pfpd->dwAttributes, FILE_ATTRIBUTE_DIRECTORY);

      *ppfpd = pfpd;

      ASSERT(IS_VALID_STRUCT_PTR(*ppfpd, CFOLDERPAIRDATA));
   }

   return(*ppfpd != NULL);
}


void DestroySharedFolderPairData(PFOLDERPAIRDATA pfpd)
{
   ASSERT(IS_VALID_STRUCT_PTR(pfpd, CFOLDERPAIRDATA));

   /* Destroy FOLDERPAIRDATA fields. */

   DeleteString(pfpd->hsName);
   FreeMemory(pfpd);
}


/*
** FolderPairSortCmp()
**
** Pointer comparison function used to sort the global array of folder pairs.
**
** Arguments:     pcfp1 - pointer to FOLDERPAIR describing first folder pair
**                pcfp2 - pointer to FOLDERPAIR describing second folder pair
**
** Returns:
**
** Side Effects:  none
**
** Folder pairs are sorted by:
**    1) path
**    2) pointer value
*/
COMPARISONRESULT FolderPairSortCmp(PCVOID pcfp1, PCVOID pcfp2)
{
   COMPARISONRESULT cr;

   ASSERT(IS_VALID_STRUCT_PTR(pcfp1, CFOLDERPAIR));
   ASSERT(IS_VALID_STRUCT_PTR(pcfp2, CFOLDERPAIR));

   cr = ComparePaths(((PCFOLDERPAIR)pcfp1)->hpath,
                     ((PCFOLDERPAIR)pcfp2)->hpath);

   if (cr == CR_EQUAL)
      cr = ComparePointers(pcfp1, pcfp2);

   return(cr);
}


/*
** FolderPairSearchCmp()
**
** Pointer comparison function used to search the global array of folder pairs
** for the first folder pair for a given folder.
**
** Arguments:     hpath - folder pair to search for
**                pcfp - pointer to FOLDERPAIR to examine
**
** Returns:
**
** Side Effects:  none
**
** Folder pairs are searched by:
**    1) path
*/
COMPARISONRESULT FolderPairSearchCmp(PCVOID hpath, PCVOID pcfp)
{
   ASSERT(IS_VALID_HANDLE((HPATH)hpath, PATH));
   ASSERT(IS_VALID_STRUCT_PTR(pcfp, CFOLDERPAIR));

   return(ComparePaths((HPATH)hpath, ((PCFOLDERPAIR)pcfp)->hpath));
}


BOOL RemoveSourceFolderTwin(POBJECTTWIN pot, PVOID pv)
{
   ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));
   ASSERT(! pv);

   if (EVAL(pot->ulcSrcFolderTwins > 0))
      pot->ulcSrcFolderTwins--;

   /*
    * If there are no more source folder twins for this object twin, and this
    * object twin is not a separate "orphan" object twin, wipe it out.
    */

   if (! pot->ulcSrcFolderTwins &&
       IsStubFlagClear(&(pot->stub), STUB_FL_FROM_OBJECT_TWIN))
      EVAL(DestroyStub(&(pot->stub)) == TR_SUCCESS);

   return(TRUE);
}


/*
** UnlinkHalfOfFolderPair()
**
** Unlinks one half of a pair of folder twins.
**
** Arguments:     pfp - pointer to folder pair half to unlink
**
** Returns:       void
**
** Side Effects:  Removes a source folder twin from each of the object twin's
**                in the folder pair's list of generated object twins.  May
**                cause object twins and twin families to be destroyed.
*/
void UnlinkHalfOfFolderPair(PFOLDERPAIR pfp)
{
   HPTRARRAY hpaFolderPairs;
   ARRAYINDEX aiUnlink;

   ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));

   TRACE_OUT((TEXT("UnlinkHalfOfFolderPair(): Unlinking folder twin %s."),
              DebugGetPathString(pfp->hpath)));

   /* Search for the folder pair to be unlinked. */

   hpaFolderPairs = GetBriefcaseFolderPairPtrArray(pfp->pfpd->hbr);

   if (EVAL(SearchSortedArray(hpaFolderPairs, &FolderPairSortCmp, pfp,
                              &aiUnlink)))
   {
      /* Unlink folder pair. */

      ASSERT(GetPtr(hpaFolderPairs, aiUnlink) == pfp);

      DeletePtr(hpaFolderPairs, aiUnlink);

      /*
       * Don't mark folder pair stub unlinked here.  Let caller do that after
       * both folder pair halves have been unlinked.
       */

      /* Remove a source folder twin from all generated object twins. */

      EVAL(EnumGeneratedObjectTwins(pfp, &RemoveSourceFolderTwin, NULL));
   }
}


BOOL FolderTwinIntersectsFolder(PCFOLDERPAIR pcfp, HPATH hpathFolder)
{
   BOOL bResult;

   ASSERT(IS_VALID_STRUCT_PTR(pcfp, CFOLDERPAIR));
   ASSERT(IS_VALID_HANDLE(hpathFolder, PATH));

   if (IsStubFlagSet(&(pcfp->stub), STUB_FL_SUBTREE))
      bResult = IsPathPrefix(hpathFolder, pcfp->hpath);
   else
      bResult = (ComparePaths(hpathFolder, pcfp->hpath) == CR_EQUAL);

   return(bResult);
}


/*
** CreateListOfFolderTwins()
**
** Creates a list of folder twins from a block of folder pairs.
**
** Arguments:     aiFirst - index of first folder pair in the array of folder
**                          pairs
**                hpathFolder - folder that list of folder twins is to be
**                              created for
**                ppftHead - pointer to PFOLDERTWIN to be filled in with
**                           pointer to first folder twin in new list
**                paic - pointer to ARRAYINDEX to be filled in with number of
**                       folder twins in new list
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
TWINRESULT CreateListOfFolderTwins(HBRFCASE hbr, ARRAYINDEX aiFirst,
                                           HPATH hpathFolder,
                                           PFOLDERTWIN *ppftHead,
                                           PARRAYINDEX paic)
{
   TWINRESULT tr;
   PFOLDERPAIR pfp;
   HPATH hpath;
   ARRAYINDEX aicPtrs;
   ARRAYINDEX ai;
   PFOLDERTWIN pftHead;
   HPTRARRAY hpaFolderTwins;

   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
   ASSERT(IS_VALID_HANDLE(hpathFolder, PATH));
   ASSERT(IS_VALID_WRITE_PTR(ppftHead, PFOLDERTWIN));
   ASSERT(IS_VALID_WRITE_PTR(paic, ARRAYINDEX));

   /*
    * Get the handle to the common folder that the list of folder twins is
    * being prepared for.
    */

   hpaFolderTwins = GetBriefcaseFolderPairPtrArray(hbr);

   pfp = GetPtr(hpaFolderTwins, aiFirst);

   hpath = pfp->hpath;

   /*
    * Add the other half of each matching folder pair to the folder twin list
    * as a folder twin.
    */

   aicPtrs = GetPtrCount(hpaFolderTwins);
   ASSERT(aicPtrs > 0);
   ASSERT(! (aicPtrs % 2));
   ASSERT(aiFirst >= 0);
   ASSERT(aiFirst < aicPtrs);

   /* Start with an empty list of folder twins. */

   pftHead = NULL;

   /*
    * A pointer to the first folder pair is already in pfp, but we'll look it
    * up again.
    */

   TRACE_OUT((TEXT("CreateListOfFolderTwins(): Creating list of folder twins of folder %s."),
              DebugGetPathString(hpath)));

   tr = TR_SUCCESS;

   for (ai = aiFirst; ai < aicPtrs && tr == TR_SUCCESS; ai++)
   {
      pfp = GetPtr(hpaFolderTwins, ai);

      if (ComparePaths(pfp->hpath, hpathFolder) == CR_EQUAL)
         tr = AddFolderTwinToList(pfp, pftHead, &pftHead);
      else
         break;
   }

   TRACE_OUT((TEXT("CreateListOfFolderTwins(): Finished creating list of folder twins of folder %s."),
              DebugGetPathString(hpath)));

   if (tr == TR_SUCCESS)
   {
      /* Success!  Fill in the result parameters. */

      *ppftHead = pftHead;
      *paic = ai - aiFirst;
   }
   else
      /* Free any folder twins that have been added to the list. */
      DestroyListOfFolderTwins(pftHead);

   return(tr);
}


/*
** DestroyListOfFolderTwins()
**
** Wipes out the folder twins in a folder twin list.
**
** Arguments:     pftHead - pointer to first folder twin in list
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
void DestroyListOfFolderTwins(PFOLDERTWIN pftHead)
{
   while (pftHead)
   {
      PFOLDERTWIN pftOldHead;

      ASSERT(IS_VALID_STRUCT_PTR(pftHead, CFOLDERTWIN));

      UnlockStub(&(((PFOLDERPAIR)(pftHead->hftSrc))->stub));
      UnlockStub(&(((PFOLDERPAIR)(pftHead->hftOther))->stub));

      pftOldHead = pftHead;
      pftHead = (PFOLDERTWIN)(pftHead->pcftNext);

      FreeMemory((LPTSTR)(pftOldHead->pcszSrcFolder));
      FreeMemory((LPTSTR)(pftOldHead->pcszOtherFolder));

      FreeMemory(pftOldHead);
   }
}


/*
** AddFolderTwinToList()
**
** Adds a folder twin to a list of folder twins.
**
** Arguments:     pfpSrc - pointer to source folder pair to be added
**                pftHead - pointer to head of folder twin list, may be NULL
**                ppft - pointer to PFOLDERTWIN to be filled in with pointer
**                         to new folder twin, ppft may be &pftHead
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
TWINRESULT AddFolderTwinToList(PFOLDERPAIR pfpSrc,
                                            PFOLDERTWIN pftHead,
                                            PFOLDERTWIN *ppft)
{
   TWINRESULT tr = TR_OUT_OF_MEMORY;
   PFOLDERTWIN pftNew;

   ASSERT(IS_VALID_STRUCT_PTR(pfpSrc, CFOLDERPAIR));
   ASSERT(! pftHead || IS_VALID_STRUCT_PTR(pftHead, CFOLDERTWIN));
   ASSERT(IS_VALID_WRITE_PTR(ppft, PFOLDERTWIN));

   /* Try to create a new FOLDERTWIN structure. */

   if (AllocateMemory(sizeof(*pftNew), &pftNew))
   {
      LPTSTR pszFirstFolder;

      if (AllocatePathString(pfpSrc->hpath, &pszFirstFolder))
      {
         LPTSTR pszSecondFolder;

         if (AllocatePathString(pfpSrc->pfpOther->hpath, &pszSecondFolder))
         {
            /* Fill in FOLDERTWIN structure fields. */

            pftNew->pcftNext = pftHead;
            pftNew->hftSrc = (HFOLDERTWIN)pfpSrc;
            pftNew->hvidSrc = (HVOLUMEID)(pfpSrc->hpath);
            pftNew->pcszSrcFolder = pszFirstFolder;
            pftNew->hftOther = (HFOLDERTWIN)(pfpSrc->pfpOther);
            pftNew->hvidOther = (HVOLUMEID)(pfpSrc->pfpOther->hpath);
            pftNew->pcszOtherFolder = pszSecondFolder;
            pftNew->pcszName = GetBfcString(pfpSrc->pfpd->hsName);

            pftNew->dwFlags = 0;

            if (IsStubFlagSet(&(pfpSrc->stub), STUB_FL_SUBTREE))
               pftNew->dwFlags = FT_FL_SUBTREE;

            LockStub(&(pfpSrc->stub));
            LockStub(&(pfpSrc->pfpOther->stub));

            *ppft = pftNew;
            tr = TR_SUCCESS;

            TRACE_OUT((TEXT("AddFolderTwinToList(): Added folder twin %s of folder %s matching objects %s."),
                       pftNew->pcszSrcFolder,
                       pftNew->pcszOtherFolder,
                       pftNew->pcszName));
         }
         else
         {
            FreeMemory(pszFirstFolder);
ADDFOLDERTWINTOLIST_BAIL:
            FreeMemory(pftNew);
         }
      }
      else
         goto ADDFOLDERTWINTOLIST_BAIL;
   }

   ASSERT(tr != TR_SUCCESS ||
          IS_VALID_STRUCT_PTR(*ppft, CFOLDERTWIN));

   return(tr);
}


TWINRESULT WriteFolderPair(HCACHEDFILE hcf, PFOLDERPAIR pfp)
{
   TWINRESULT tr;
   DBFOLDERTWIN dbft;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));

   /* Set up folder pair database structure. */

   dbft.dwStubFlags = (pfp->stub.dwFlags & DB_STUB_FLAGS_MASK);
   dbft.hpath1 = pfp->hpath;
   dbft.hpath2 = pfp->pfpOther->hpath;
   dbft.hsName = pfp->pfpd->hsName;
   dbft.dwAttributes = pfp->pfpd->dwAttributes;

   /* Save folder pair database structure. */

   if (WriteToCachedFile(hcf, (PCVOID)&dbft, sizeof(dbft), NULL))
      tr = TR_SUCCESS;
   else
      tr = TR_BRIEFCASE_WRITE_FAILED;

   return(tr);
}


TWINRESULT ReadFolderPair(HCACHEDFILE hcf, HBRFCASE hbr,
                                  HHANDLETRANS hhtFolderTrans,
                                  HHANDLETRANS hhtNameTrans)
{
   TWINRESULT tr = TR_CORRUPT_BRIEFCASE;
   DBFOLDERTWIN dbft;
   DWORD dwcbRead;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
   ASSERT(IS_VALID_HANDLE(hhtFolderTrans, HANDLETRANS));
   ASSERT(IS_VALID_HANDLE(hhtNameTrans, HANDLETRANS));

   if (ReadFromCachedFile(hcf, &dbft, sizeof(dbft), &dwcbRead) &&
       dwcbRead == sizeof(dbft))
   {
      INEWFOLDERTWIN inft;

      if (TranslateHandle(hhtFolderTrans, (HGENERIC)(dbft.hpath1), (PHGENERIC)&(inft.hpathFirst)))
      {
         if (TranslateHandle(hhtFolderTrans, (HGENERIC)(dbft.hpath2), (PHGENERIC)&(inft.hpathSecond)))
         {
            if (TranslateHandle(hhtNameTrans, (HGENERIC)(dbft.hsName), (PHGENERIC)&(inft.hsName)))
            {
               PFOLDERPAIR pfp;

               inft.dwAttributes = dbft.dwAttributes;
               inft.hbr = hbr;

               if (IS_FLAG_SET(dbft.dwStubFlags, STUB_FL_SUBTREE))
                  inft.dwFlags = NFT_FL_SUBTREE;
               else
                  inft.dwFlags = 0;

               if (CreateFolderPair(&inft, &pfp))
                  tr = TR_SUCCESS;
               else
                  tr = TR_OUT_OF_MEMORY;
            }
         }
      }
   }

   return(tr);
}


BOOL CreateFolderPairPtrArray(PHPTRARRAY phpa)
{
   NEWPTRARRAY npa;

   ASSERT(IS_VALID_WRITE_PTR(phpa, HPTRARRAY));

   /* Try to create a folder pair pointer array. */

   npa.aicInitialPtrs = NUM_START_FOLDER_TWIN_PTRS;
   npa.aicAllocGranularity = NUM_FOLDER_TWIN_PTRS_TO_ADD;
   npa.dwFlags = NPA_FL_SORTED_ADD;

   return(CreatePtrArray(&npa, phpa));
}


void DestroyFolderPairPtrArray(HPTRARRAY hpa)
{
   ARRAYINDEX aicPtrs;
   ARRAYINDEX ai;

   ASSERT(IS_VALID_HANDLE(hpa, PTRARRAY));

   /* Free all folder pairs in pointer array. */

   aicPtrs = GetPtrCount(hpa);
   ASSERT(! (aicPtrs % 2));

   for (ai = 0; ai < aicPtrs; ai++)
   {
      PFOLDERPAIR pfp;
      PFOLDERPAIR pfpOther;
      PFOLDERPAIRDATA pfpd;
      BOOL bDeleteFolderPairData;

      pfp = GetPtr(hpa, ai);

      ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));

      /* Copy fields needed after folder pair half's demise. */

      pfpOther = pfp->pfpOther;
      pfpd = pfp->pfpd;
      bDeleteFolderPairData = IsStubFlagSet(&(pfp->stub), STUB_FL_BEING_DELETED);

      DestroyHalfOfFolderPair(pfp);

      /* Has the other half of this folder pair already been destroyed? */

      if (bDeleteFolderPairData)
         /* Yes.  Destroy the pair's shared data. */
         DestroySharedFolderPairData(pfpd);
   }

   /* Now wipe out the pointer array. */

   DestroyPtrArray(hpa);
}


void LockFolderPair(PFOLDERPAIR pfp)
{
   ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));

   ASSERT(IsStubFlagClear(&(pfp->stub), STUB_FL_UNLINKED));
   ASSERT(IsStubFlagClear(&(pfp->pfpOther->stub), STUB_FL_UNLINKED));

   ASSERT(pfp->stub.ulcLock < ULONG_MAX);
   pfp->stub.ulcLock++;

   ASSERT(pfp->pfpOther->stub.ulcLock < ULONG_MAX);
   pfp->pfpOther->stub.ulcLock++;
}


void UnlockFolderPair(PFOLDERPAIR pfp)
{
   ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));

   if (EVAL(pfp->stub.ulcLock > 0))
      pfp->stub.ulcLock--;

   if (EVAL(pfp->pfpOther->stub.ulcLock > 0))
      pfp->pfpOther->stub.ulcLock--;

   if (! pfp->stub.ulcLock &&
       IsStubFlagSet(&(pfp->stub), STUB_FL_UNLINKED))
   {
      ASSERT(! pfp->pfpOther->stub.ulcLock);
      ASSERT(IsStubFlagSet(&(pfp->pfpOther->stub), STUB_FL_UNLINKED));

      DestroyFolderPair(pfp);
   }
}


/*
** UnlinkFolderPair()
**
** Unlinks a folder pair.
**
** Arguments:     pfp - pointer to folder pair to be unlinked
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
TWINRESULT UnlinkFolderPair(PFOLDERPAIR pfp)
{
   ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));

   ASSERT(IsStubFlagClear(&(pfp->stub), STUB_FL_UNLINKED));
   ASSERT(IsStubFlagClear(&(pfp->pfpOther->stub), STUB_FL_UNLINKED));

   /* Unlink both halves of the folder pair. */

   UnlinkHalfOfFolderPair(pfp);
   UnlinkHalfOfFolderPair(pfp->pfpOther);

   SetStubFlag(&(pfp->stub), STUB_FL_UNLINKED);
   SetStubFlag(&(pfp->pfpOther->stub), STUB_FL_UNLINKED);

   return(TR_SUCCESS);
}


/*
** DestroyFolderPair()
**
** Destroys a folder pair.
**
** Arguments:     pfp - pointer to folder pair to destroy
**
** Returns:       void
**
** Side Effects:  none
*/
void DestroyFolderPair(PFOLDERPAIR pfp)
{
   PFOLDERPAIRDATA pfpd;

   ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));

   /* Destroy both FOLDERPAIR halves, and shared data. */

   pfpd = pfp->pfpd;

   DestroyHalfOfFolderPair(pfp->pfpOther);
   DestroyHalfOfFolderPair(pfp);

   DestroySharedFolderPairData(pfpd);
}



/*
** ApplyNewObjectTwinsToFolderTwins()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  Adds new spin-off object twins to hlistNewObjectTwins as they
**                are created.
**
** N.b., new object twins may have been added to hlistNewObjectTwins even if
** FALSE is returned.  Clean-up of these new object twins in case of failure is
** the caller's responsibility.
**
*/
BOOL ApplyNewObjectTwinsToFolderTwins(HLIST hlistNewObjectTwins)
{
   BOOL bResult = TRUE;
   BOOL bContinue;
   HNODE hnode;

   ASSERT(IS_VALID_HANDLE(hlistNewObjectTwins, LIST));

   /*
    * Don't use WalkList() here because we want to insert new nodes in
    * hlistNewObjectTwins after the current node.
    */

   for (bContinue = GetFirstNode(hlistNewObjectTwins, &hnode);
        bContinue && bResult;
        bContinue = GetNextNode(hnode, &hnode))
   {
      POBJECTTWIN pot;
      HPATHLIST hpl;
      HPTRARRAY hpaFolderPairs;
      ARRAYINDEX aicPtrs;
      ARRAYINDEX ai;

      pot = GetNodeData(hnode);

      ASSERT(! pot->ulcSrcFolderTwins);

      TRACE_OUT((TEXT("ApplyNewObjectTwinsToFolderTwins(): Applying new object twin %s\\%s."),
                 DebugGetPathString(pot->hpath),
                 GetBfcString(pot->ptfParent->hsName)));

      /*
       * Assume that hpl, hpaFolderPairs, and aicPtrs don't change during this
       * loop.  Calculate them outside the loop.
       */

      hpl = GetBriefcasePathList(pot->ptfParent->hbr);
      hpaFolderPairs = GetBriefcaseFolderPairPtrArray(pot->ptfParent->hbr);

      aicPtrs = GetPtrCount(hpaFolderPairs);
      ASSERT(! (aicPtrs % 2));

      for (ai = 0; ai < aicPtrs; ai++)
      {
         PFOLDERPAIR pfp;

         pfp = GetPtr(hpaFolderPairs, ai);

         if (FolderTwinGeneratesObjectTwin(pfp, pot->hpath,
                                           GetBfcString(pot->ptfParent->hsName)))
         {
            HPATH hpathMatchingFolder;
            HNODE hnodeUnused;

            ASSERT(pot->ulcSrcFolderTwins < ULONG_MAX);
            pot->ulcSrcFolderTwins++;

            /*
             * Append the generated object twin's subpath to the matching
             * folder twin's base path for subtree twins.
             */

            if (BuildPathForMatchingObjectTwin(pfp, pot, hpl,
                                               &hpathMatchingFolder))
            {
               /*
                * We don't want to collapse any twin families if the matching
                * object twin is found in a different twin family.  This will
                * be done by ApplyNewFolderTwinsToTwinFamilies() for spin-off
                * object twins generated by new folder twins.
                *
                * Spin-off object twins created by new object twins never
                * require collapsing twin families.  For a spin-off object twin
                * generated by a new object twin to collapse twin families,
                * there would have to have been separate twin families
                * connected by a folder twin.  But if those twin families were
                * already connected by a folder twin, they would not be
                * separate because they would already have been collapsed by
                * ApplyNewFolderTwinsToTwinFamilies() when the connecting
                * folder twin was added.
                */

               if (! FindObjectTwin(pot->ptfParent->hbr, hpathMatchingFolder,
                                    GetBfcString(pot->ptfParent->hsName),
                                    &hnodeUnused))
               {
                  POBJECTTWIN potNew;

                  /*
                   * CreateObjectTwin() ASSERT()s that an object twin for
                   * hpathMatchingFolder is not found, so we don't need to do
                   * that here.
                   */

                  if (CreateObjectTwin(pot->ptfParent, hpathMatchingFolder,
                                       &potNew))
                  {
                     /*
                      * Add the new object twin to hlistNewObjectTwins after
                      * the new object twin currently being processed to make
                      * certain that it gets processed in the outside loop
                      * through hlistNewObjectTwins.
                      */

                     if (! InsertNodeAfter(hnode, NULL, potNew, &hnodeUnused))
                     {
                        DestroyStub(&(potNew->stub));
                        bResult = FALSE;
                        break;
                     }
                  }
               }

               DeletePath(hpathMatchingFolder);
            }
            else
            {
               bResult = FALSE;
               break;
            }
         }
      }
   }

   return(bResult);
}


/*
** BuildPathForMatchingObjectTwin()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  Path is added to object twin's briefcase's path list.
*/
BOOL BuildPathForMatchingObjectTwin(PCFOLDERPAIR pcfp,
                                                PCOBJECTTWIN pcot,
                                                HPATHLIST hpl, PHPATH phpath)
{
   BOOL bResult;

   ASSERT(IS_VALID_STRUCT_PTR(pcfp, CFOLDERPAIR));
   ASSERT(IS_VALID_STRUCT_PTR(pcot, COBJECTTWIN));
   ASSERT(IS_VALID_HANDLE(hpl, PATHLIST));
   ASSERT(IS_VALID_WRITE_PTR(phpath, HPATH));

   ASSERT(FolderTwinGeneratesObjectTwin(pcfp, pcot->hpath, GetBfcString(pcot->ptfParent->hsName)));

   /* Is the generating folder twin a subtree twin? */

   if (IsStubFlagSet(&(pcfp->stub), STUB_FL_SUBTREE))
   {
      TCHAR rgchPathSuffix[MAX_PATH_LEN];
      LPCTSTR pcszSubPath;

      /*
       * Yes.  Append the object twin's subpath to the subtree twin's base
       * path.
       */

      pcszSubPath = FindChildPathSuffix(pcfp->hpath, pcot->hpath,
                                        rgchPathSuffix);

      bResult = AddChildPath(hpl, pcfp->pfpOther->hpath, pcszSubPath, phpath);
   }
   else
      /* No.  Just use the matching folder twin's folder. */
      bResult = CopyPath(pcfp->pfpOther->hpath, hpl, phpath);

   return(bResult);
}


/*
** EnumGeneratedObjectTwins()
**
**
**
** Arguments:
**
** Returns:       FALSE if callback aborted.  TRUE if not.
**
** Side Effects:  none
*/
BOOL EnumGeneratedObjectTwins(PCFOLDERPAIR pcfp,
                                     ENUMGENERATEDOBJECTTWINSPROC egotp,
                                     PVOID pvRefData)
{
   BOOL bResult = TRUE;
   HPTRARRAY hpaTwinFamilies;
   ARRAYINDEX aicPtrs;
   ARRAYINDEX ai;

   /* pvRefData may be any value. */

   ASSERT(IS_VALID_STRUCT_PTR(pcfp, CFOLDERPAIR));
   ASSERT(IS_VALID_CODE_PTR(egotp, ENUMGENERATEDOBJECTTWINPROC));

   /*
    * Walk the array of twin families, looking for twin families whose names
    * intersect the given folder twin's name specification.
    */

   hpaTwinFamilies = GetBriefcaseTwinFamilyPtrArray(pcfp->pfpd->hbr);

   aicPtrs = GetPtrCount(hpaTwinFamilies);
   ai = 0;

   while (ai < aicPtrs)
   {
      PTWINFAMILY ptf;
      LPCTSTR pcszName;

      ptf = GetPtr(hpaTwinFamilies, ai);

      ASSERT(IS_VALID_STRUCT_PTR(ptf, CTWINFAMILY));
      ASSERT(IsStubFlagClear(&(ptf->stub), STUB_FL_UNLINKED));

      /*
       * Does the twin family's name match the folder twin's name
       * specification?
       */

      pcszName = GetBfcString(ptf->hsName);

      if (IsFolderObjectTwinName(pcszName) ||
          NamesIntersect(pcszName, GetBfcString(pcfp->pfpd->hsName)))
      {
         BOOL bContinue;
         HNODE hnodePrev;

         /* Yes.  Look for a matching folder. */

         /* Lock the twin family so it isn't deleted out from under us. */

         LockStub(&(ptf->stub));

         /*
          * Walk each twin family's list of object twins looking for object
          * twins in the given folder twin's subtree.
          */

         bContinue = GetFirstNode(ptf->hlistObjectTwins, &hnodePrev);

         while (bContinue)
         {
            HNODE hnodeNext;
            POBJECTTWIN pot;

            bContinue = GetNextNode(hnodePrev, &hnodeNext);

            pot = (POBJECTTWIN)GetNodeData(hnodePrev);

            ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));

            if (FolderTwinIntersectsFolder(pcfp, pot->hpath))
            {
               /*
                * A given object twin should only be generated by one of the
                * folder twins in a pair of folder twins.
                */

               ASSERT(! FolderTwinGeneratesObjectTwin(pcfp->pfpOther, pot->hpath, GetBfcString(pot->ptfParent->hsName)));

               bResult = (*egotp)(pot, pvRefData);

               if (! bResult)
                  break;
            }

            hnodePrev = hnodeNext;
         }

         /* Was the twin family unlinked? */

         if (IsStubFlagClear(&(ptf->stub), STUB_FL_UNLINKED))
            /* No. */
            ai++;
         else
         {
            /* Yes. */

            aicPtrs--;
            ASSERT(aicPtrs == GetPtrCount(hpaTwinFamilies));

            TRACE_OUT((TEXT("EnumGeneratedObjectTwins(): Twin family for object %s unlinked by callback."),
                       GetBfcString(ptf->hsName)));
         }

         UnlockStub(&(ptf->stub));

         if (! bResult)
            break;
      }
      else
         /* No.  Skip it. */
         ai++;
   }

   return(bResult);
}


/*
** EnumGeneratingFolderTwins()
**
**
**
** Arguments:
**
** Returns:       FALSE if callback aborted.  TRUE if not.
**
** Side Effects:  none
**
** N.b., if the egftp callback removes a pair of folder twins, it must remove
** the pair from the first folder twin encountered.  If it removes the pair of
** folder twins from the second folder twin encountered, a folder twin will be
** skipped.
*/
BOOL EnumGeneratingFolderTwins(PCOBJECTTWIN pcot,
                                           ENUMGENERATINGFOLDERTWINSPROC egftp,
                                           PVOID pvRefData,
                                           PULONG pulcGeneratingFolderTwins)
{
   BOOL bResult = TRUE;
   HPTRARRAY hpaFolderPairs;
   ARRAYINDEX aicPtrs;
   ARRAYINDEX ai;

   /* pvRefData may be any value. */

   ASSERT(IS_VALID_STRUCT_PTR(pcot, COBJECTTWIN));
   ASSERT(IS_VALID_CODE_PTR(egftp, ENUMGENERATINGFOLDERTWINSPROC));
   ASSERT(IS_VALID_WRITE_PTR(pulcGeneratingFolderTwins, ULONG));

   *pulcGeneratingFolderTwins = 0;

   hpaFolderPairs = GetBriefcaseFolderPairPtrArray(pcot->ptfParent->hbr);

   aicPtrs = GetPtrCount(hpaFolderPairs);
   ASSERT(! (aicPtrs % 2));

   ai = 0;

   while (ai < aicPtrs)
   {
      PFOLDERPAIR pfp;

      pfp = GetPtr(hpaFolderPairs, ai);

      if (FolderTwinGeneratesObjectTwin(pfp, pcot->hpath,
                                        GetBfcString(pcot->ptfParent->hsName)))
      {
         ASSERT(! FolderTwinGeneratesObjectTwin(pfp->pfpOther, pcot->hpath, GetBfcString(pcot->ptfParent->hsName)));

         ASSERT(*pulcGeneratingFolderTwins < ULONG_MAX);
         (*pulcGeneratingFolderTwins)++;

         /*
          * Lock the pair of folder twins so they don't get deleted out from
          * under us.
          */

         LockStub(&(pfp->stub));

         bResult = (*egftp)(pfp, pvRefData);

         if (IsStubFlagSet(&(pfp->stub), STUB_FL_UNLINKED))
         {
            WARNING_OUT((TEXT("EnumGeneratingFolderTwins(): Folder twin pair unlinked during callback.")));

            aicPtrs -= 2;
            ASSERT(! (aicPtrs % 2));
            ASSERT(aicPtrs == GetPtrCount(hpaFolderPairs));
         }
         else
            ai++;

         UnlockStub(&(pfp->stub));

         if (! bResult)
            break;
      }
      else
         ai++;
   }

   return(bResult);
}


/*
** FolderTwinGeneratesObjectTwin()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
**
** A folder twin or subtree twin is said to generate an object twin when the
** following conditions are met:
**
** 1) The folder twin or subtree twin is on the same volume as the object twin.
**
** 2) The name of the object twin (literal) intersects the objects matched by
**    the folder twin or subtree twin (literal or wildcard).
**
** 3) The folder twin's folder exactly matches the object twin's folder, or the
**    subtree twin's root folder is a path prefix of the object twin's folder.
*/
BOOL FolderTwinGeneratesObjectTwin(PCFOLDERPAIR pcfp,
                                               HPATH hpathFolder,
                                               LPCTSTR pcszName)
{
   ASSERT(IS_VALID_STRUCT_PTR(pcfp, CFOLDERPAIR));
   ASSERT(IS_VALID_HANDLE(hpathFolder, PATH));
   ASSERT(IS_VALID_STRING_PTR(pcszName, CSTR));

   return(FolderTwinIntersectsFolder(pcfp, hpathFolder) &&
          (IsFolderObjectTwinName(pcszName) ||
           NamesIntersect(pcszName, GetBfcString(pcfp->pfpd->hsName))));
}


TWINRESULT WriteFolderPairList(HCACHEDFILE hcf,
                                      HPTRARRAY hpaFolderPairs)
{
   TWINRESULT tr = TR_BRIEFCASE_WRITE_FAILED;
   DWORD dwcbDBFolderTwinListHeaderOffset;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_HANDLE(hpaFolderPairs, PTRARRAY));

   /* Save initial file position. */

   dwcbDBFolderTwinListHeaderOffset = GetCachedFilePointerPosition(hcf);

   if (dwcbDBFolderTwinListHeaderOffset != INVALID_SEEK_POSITION)
   {
      DBFOLDERTWINLISTHEADER dbftlh;

      /* Leave space for folder twin data header. */

      ZeroMemory(&dbftlh, sizeof(dbftlh));

      if (WriteToCachedFile(hcf, (PCVOID)&dbftlh, sizeof(dbftlh), NULL))
      {
         ARRAYINDEX aicPtrs;
         ARRAYINDEX ai;

         tr = TR_SUCCESS;

         /* Mark all folder pairs unused. */

         ClearFlagInArrayOfStubs(hpaFolderPairs, STUB_FL_USED);

         aicPtrs = GetPtrCount(hpaFolderPairs);
         ASSERT(! (aicPtrs % 2));

         /* Write all folder pairs. */

         for (ai = 0; ai < aicPtrs; ai++)
         {
            PFOLDERPAIR pfp;

            pfp = GetPtr(hpaFolderPairs, ai);

            ASSERT(IS_VALID_STRUCT_PTR(pfp, CFOLDERPAIR));

            if (IsStubFlagClear(&(pfp->stub), STUB_FL_USED))
            {
               ASSERT(IsStubFlagClear(&(pfp->pfpOther->stub), STUB_FL_USED));

               tr = WriteFolderPair(hcf, pfp);

               if (tr == TR_SUCCESS)
               {
                  SetStubFlag(&(pfp->stub), STUB_FL_USED);
                  SetStubFlag(&(pfp->pfpOther->stub), STUB_FL_USED);
               }
               else
                  break;
            }
         }

         /* Save folder twin data header. */

         if (tr == TR_SUCCESS)
         {
            ASSERT(! (aicPtrs % 2));

            dbftlh.lcFolderPairs = aicPtrs / 2;

            tr = WriteDBSegmentHeader(hcf, dwcbDBFolderTwinListHeaderOffset,
                                      &dbftlh, sizeof(dbftlh));

            if (tr == TR_SUCCESS)
               TRACE_OUT((TEXT("WriteFolderPairList(): Wrote %ld folder pairs."),
                          dbftlh.lcFolderPairs));
         }
      }
   }

   return(tr);
}


TWINRESULT ReadFolderPairList(HCACHEDFILE hcf, HBRFCASE hbr,
                                     HHANDLETRANS hhtFolderTrans,
                                     HHANDLETRANS hhtNameTrans)
{
   TWINRESULT tr;
   DBFOLDERTWINLISTHEADER dbftlh;
   DWORD dwcbRead;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
   ASSERT(IS_VALID_HANDLE(hhtFolderTrans, HANDLETRANS));
   ASSERT(IS_VALID_HANDLE(hhtNameTrans, HANDLETRANS));

   if (ReadFromCachedFile(hcf, &dbftlh, sizeof(dbftlh), &dwcbRead) &&
       dwcbRead == sizeof(dbftlh))
   {
      LONG l;

      tr = TR_SUCCESS;

      TRACE_OUT((TEXT("ReadFolderPairList(): Reading %ld folder pairs."),
                 dbftlh.lcFolderPairs));

      for (l = 0; l < dbftlh.lcFolderPairs && tr == TR_SUCCESS; l++)
         tr = ReadFolderPair(hcf, hbr, hhtFolderTrans, hhtNameTrans);

      ASSERT(tr != TR_SUCCESS || AreFolderPairsValid(GetBriefcaseFolderPairPtrArray(hbr)));
   }
   else
      tr = TR_CORRUPT_BRIEFCASE;

   return(tr);
}


/* Macros
 *********/

#define HT_ARRAY_ELEMENT(pht, ai)   ((((PHANDLETRANS)(hht))->hpHandlePairs)[(ai)])


/* Types
 ********/

/* handle translation unit */

typedef struct _handlepair
{
   HGENERIC hgenOld;
   HGENERIC hgenNew;
}
HANDLEPAIR;
DECLARE_STANDARD_TYPES(HANDLEPAIR);

/* handle translation structure */

typedef struct _handletrans
{
   /* pointer to array of handle translation units */

   HANDLEPAIR *hpHandlePairs;

   /* number of handle pairs in array */

   LONG lcTotalHandlePairs;

   /* number of used handle pairs in array */

   LONG lcUsedHandlePairs;
}
HANDLETRANS;
DECLARE_STANDARD_TYPES(HANDLETRANS);


COMPARISONRESULT CompareHandlePairs(PCVOID pchp1, PCVOID pchp2)
{
   COMPARISONRESULT cr;

   ASSERT(IS_VALID_STRUCT_PTR(pchp1, CHANDLEPAIR));
   ASSERT(IS_VALID_STRUCT_PTR(pchp2, CHANDLEPAIR));

   if (((PHANDLEPAIR)pchp1)->hgenOld < ((PHANDLEPAIR)pchp2)->hgenOld)
      cr = CR_FIRST_SMALLER;
   else if (((PHANDLEPAIR)pchp1)->hgenOld > ((PHANDLEPAIR)pchp2)->hgenOld)
      cr = CR_FIRST_LARGER;
   else
      cr = CR_EQUAL;

   return(cr);
}


BOOL CreateHandleTranslator(LONG lcHandles, PHHANDLETRANS phht)
{
   PHANDLEPAIR hpHandlePairs;

   ASSERT(IS_VALID_WRITE_PTR(phht, HHANDLETRANS));

   *phht = NULL;

   if (AllocateMemory(sizeof(HANDLEPAIR) * lcHandles, &hpHandlePairs))
   {
      PHANDLETRANS phtNew;

      if (AllocateMemory(sizeof(*phtNew), &phtNew))
      {
         /* Success!  Fill in HANDLETRANS fields. */

         phtNew->hpHandlePairs = hpHandlePairs;
         phtNew->lcTotalHandlePairs = lcHandles;
         phtNew->lcUsedHandlePairs = 0;

         *phht = (HHANDLETRANS)phtNew;

         ASSERT(IS_VALID_HANDLE(*phht, HANDLETRANS));
      }
      else
         FreeMemory(hpHandlePairs);
   }

   return(*phht != NULL);
}


void DestroyHandleTranslator(HHANDLETRANS hht)
{
   ASSERT(IS_VALID_HANDLE(hht, HANDLETRANS));

   ASSERT(((PHANDLETRANS)hht)->hpHandlePairs);

   FreeMemory(((PHANDLETRANS)hht)->hpHandlePairs);

   FreeMemory((PHANDLETRANS)hht);
}


BOOL AddHandleToHandleTranslator(HHANDLETRANS hht,
                                               HGENERIC hgenOld,
                                               HGENERIC hgenNew)
{
   BOOL bRet;

   ASSERT(IS_VALID_HANDLE(hht, HANDLETRANS));

   if (((PHANDLETRANS)hht)->lcUsedHandlePairs < ((PHANDLETRANS)hht)->lcTotalHandlePairs)
   {
      HT_ARRAY_ELEMENT((PHANDLETRANS)hht, ((PHANDLETRANS)hht)->lcUsedHandlePairs).hgenOld = hgenOld;
      HT_ARRAY_ELEMENT((PHANDLETRANS)hht, ((PHANDLETRANS)hht)->lcUsedHandlePairs).hgenNew = hgenNew;

      ((PHANDLETRANS)hht)->lcUsedHandlePairs++;

      bRet = TRUE;
   }
   else
      bRet = FALSE;

   return(bRet);
}


void PrepareForHandleTranslation(HHANDLETRANS hht)
{
   HANDLEPAIR hpTemp;

   ASSERT(IS_VALID_HANDLE(hht, HANDLETRANS));

   HeapSort(((PHANDLETRANS)hht)->hpHandlePairs,
            ((PHANDLETRANS)hht)->lcUsedHandlePairs,
            sizeof((((PHANDLETRANS)hht)->hpHandlePairs)[0]),
            &CompareHandlePairs,
            &hpTemp);
}


BOOL TranslateHandle(HHANDLETRANS hht, HGENERIC hgenOld,
                                   PHGENERIC phgenNew)
{
   BOOL bFound;
   HANDLEPAIR hpTemp;
   LONG liTarget;

   ASSERT(IS_VALID_HANDLE(hht, HANDLETRANS));
   ASSERT(IS_VALID_WRITE_PTR(phgenNew, HGENERIC));

   hpTemp.hgenOld = hgenOld;

   bFound = BinarySearch(((PHANDLETRANS)hht)->hpHandlePairs,
                         ((PHANDLETRANS)hht)->lcUsedHandlePairs,
                         sizeof((((PHANDLETRANS)hht)->hpHandlePairs)[0]),
                         &CompareHandlePairs,
                         &hpTemp,
                         &liTarget);

   if (bFound)
   {
      ASSERT(liTarget < ((PHANDLETRANS)hht)->lcUsedHandlePairs);

      *phgenNew = HT_ARRAY_ELEMENT((PHANDLETRANS)hht, liTarget).hgenNew;
   }

   return(bFound);
}


/* Macros
 *********/

/* Add nodes to list in sorted order? */

#define ADD_NODES_IN_SORTED_ORDER(plist)  IS_FLAG_SET((plist)->dwFlags, LIST_FL_SORTED_ADD)


/* Types
 ********/

/* list node types */

typedef struct _node
{
   struct _node *pnodeNext;      /* next node in list */
   struct _node *pnodePrev;      /* previous node in list */
   PCVOID pcv;                   /* node data */
}
NODE;
DECLARE_STANDARD_TYPES(NODE);

/* list flags */

typedef enum _listflags
{
   /* Insert nodes in sorted order. */

   LIST_FL_SORTED_ADD      = 0x0001,

   /* flag combinations */

   ALL_LIST_FLAGS          = LIST_FL_SORTED_ADD
}
LISTFLAGS;

/*
 * A LIST is just a special node at the head of a list.  N.b., the _node
 * structure MUST appear first in the _list structure because a pointer to a
 * list is sometimes used as a pointer to a node.
 */

typedef struct _list
{
   NODE node;

   DWORD dwFlags;
}
LIST;
DECLARE_STANDARD_TYPES(LIST);

/* SearchForNode() return codes */

typedef enum _addnodeaction
{
   ANA_FOUND,
   ANA_INSERT_BEFORE_NODE,
   ANA_INSERT_AFTER_NODE,
   ANA_INSERT_AT_HEAD
}
ADDNODEACTION;
DECLARE_STANDARD_TYPES(ADDNODEACTION);


/* Module Prototypes
 ********************/

ADDNODEACTION SearchForNode(HLIST, COMPARESORTEDNODESPROC, PCVOID, PHNODE);
BOOL IsListInSortedOrder(PCLIST, COMPARESORTEDNODESPROC);


ADDNODEACTION SearchForNode(HLIST hlist,
                            COMPARESORTEDNODESPROC csnp,
                            PCVOID pcv,
                            PHNODE phnode)
{
   ADDNODEACTION ana;
   ULONG ulcNodes;

   /* pcv may be any value */

   ASSERT(IS_VALID_HANDLE(hlist, LIST));
   ASSERT(IS_VALID_CODE_PTR(csnp, COMPARESORTEDNODESPROC));
   ASSERT(IS_VALID_WRITE_PTR(phnode, HNODE));

   ASSERT(ADD_NODES_IN_SORTED_ORDER((PCLIST)hlist));
   ASSERT(IsListInSortedOrder((PCLIST)hlist, csnp));

   /* Yes.  Are there any nodes in this list? */

   ulcNodes = GetNodeCount(hlist);

   ASSERT(ulcNodes < LONG_MAX);

   if (ulcNodes > 0)
   {
      LONG lLow = 0;
      LONG lMiddle = 0;
      LONG lHigh = ulcNodes - 1;
      LONG lCurrent = 0;
      int nCmpResult = 0;

      /* Yes.  Search for target. */

      EVAL(GetFirstNode(hlist, phnode));

      while (lLow <= lHigh)
      {
         lMiddle = (lLow + lHigh) / 2;

         /* Which way should we seek in the list to get the lMiddle node? */

         if (lCurrent < lMiddle)
         {
            /* Forward from the current node. */

            while (lCurrent < lMiddle)
            {
               EVAL(GetNextNode(*phnode, phnode));
               lCurrent++;
            }
         }
         else if (lCurrent > lMiddle)
         {
            /* Backward from the current node. */

            while (lCurrent > lMiddle)
            {
               EVAL(GetPrevNode(*phnode, phnode));
               lCurrent--;
            }
         }

         nCmpResult = (*csnp)(pcv, GetNodeData(*phnode));

         if (nCmpResult < 0)
            lHigh = lMiddle - 1;
         else if (nCmpResult > 0)
            lLow = lMiddle + 1;
         else
            /* Found a match at *phnode. */
            break;
      }

      /*
       * If (nCmpResult >  0), insert after *phnode.
       *
       * If (nCmpResult <  0), insert before *phnode.
       *
       * If (nCmpResult == 0), string found at *phnode.
       */

      if (nCmpResult > 0)
         ana = ANA_INSERT_AFTER_NODE;
      else if (nCmpResult < 0)
         ana = ANA_INSERT_BEFORE_NODE;
      else
         ana = ANA_FOUND;
   }
   else
   {
      /* No.  Insert the target as the only node in the list. */

      *phnode = NULL;
      ana = ANA_INSERT_AT_HEAD;
   }

   return(ana);
}


BOOL IsListInSortedOrder(PCLIST pclist, COMPARESORTEDNODESPROC csnp)
{
   BOOL bResult = TRUE;
   PNODE pnode;

   /* Don't validate pclist here. */

   ASSERT(ADD_NODES_IN_SORTED_ORDER(pclist));
   ASSERT(IS_VALID_CODE_PTR(csnp, COMPARESORTEDNODESPROC));

   pnode = pclist->node.pnodeNext;

   while (pnode)
   {
      PNODE pnodeNext;

      pnodeNext = pnode->pnodeNext;

      if (pnodeNext)
      {
         if ( (*csnp)(pnode->pcv, pnodeNext->pcv) == CR_FIRST_LARGER)
         {
            bResult = FALSE;
            ERROR_OUT((TEXT("IsListInSortedOrder(): Node [%ld] %#lx > following node [%ld] %#lx."),
                       pnode,
                       pnode->pcv,
                       pnodeNext,
                       pnodeNext->pcv));
            break;
         }

         pnode = pnodeNext;
      }
      else
         break;
   }

   return(bResult);
}


/*
** CreateList()
**
** Creates a new list.
**
** Arguments:     void
**
** Returns:       Handle to new list, or NULL if unsuccessful.
**
** Side Effects:  none
*/
BOOL CreateList(PCNEWLIST pcnl, PHLIST phlist)
{
   PLIST plist;

   ASSERT(IS_VALID_STRUCT_PTR(pcnl, CNEWLIST));
   ASSERT(IS_VALID_WRITE_PTR(phlist, HLIST));

   /* Try to allocate new list structure. */

   *phlist = NULL;

   if (AllocateMemory(sizeof(*plist), &plist))
   {
      /* List allocated successfully.  Initialize list fields. */

      plist->node.pnodeNext = NULL;
      plist->node.pnodePrev = NULL;
      plist->node.pcv = NULL;

      plist->dwFlags = 0;

      if (IS_FLAG_SET(pcnl->dwFlags, NL_FL_SORTED_ADD))
      {
         SET_FLAG(plist->dwFlags, LIST_FL_SORTED_ADD);
      }

      *phlist = (HLIST)plist;

      ASSERT(IS_VALID_HANDLE(*phlist, LIST));
   }

   return(*phlist != NULL);
}


/*
** DestroyList()
**
** Deletes a list.
**
** Arguments:     hlist - handle to list to be deleted
**
** Returns:       void
**
** Side Effects:  none
*/
void DestroyList(HLIST hlist)
{
   ASSERT(IS_VALID_HANDLE(hlist, LIST));

   DeleteAllNodes(hlist);

   /* Delete list. */

   FreeMemory((PLIST)hlist);
}


BOOL AddNode(HLIST hlist, COMPARESORTEDNODESPROC csnp, PCVOID pcv, PHNODE phnode)
{
   BOOL bResult;

   ASSERT(IS_VALID_HANDLE(hlist, LIST));

   if (ADD_NODES_IN_SORTED_ORDER((PCLIST)hlist))
   {
      ADDNODEACTION ana;

      ana = SearchForNode(hlist, csnp, pcv, phnode);

      ASSERT(ana != ANA_FOUND);

      switch (ana)
      {
         case ANA_INSERT_BEFORE_NODE:
            bResult = InsertNodeBefore(*phnode, csnp, pcv, phnode);
            break;

         case ANA_INSERT_AFTER_NODE:
            bResult = InsertNodeAfter(*phnode, csnp, pcv, phnode);
            break;

         default:
            ASSERT(ana == ANA_INSERT_AT_HEAD);
            bResult = InsertNodeAtFront(hlist, csnp, pcv, phnode);
            break;
      }
   }
   else
      bResult = InsertNodeAtFront(hlist, csnp, pcv, phnode);

   ASSERT(! bResult ||
          IS_VALID_HANDLE(*phnode, NODE));

   return(bResult);
}


/*
** InsertNodeAtFront()
**
** Inserts a node at the front of a list.
**
** Arguments:     hlist - handle to list that node is to be inserted at head of
**                pcv - data to be stored in node
**
** Returns:       Handle to new node, or NULL if unsuccessful.
**
** Side Effects:  none
*/
BOOL InsertNodeAtFront(HLIST hlist, COMPARESORTEDNODESPROC csnp, PCVOID pcv, PHNODE phnode)
{
   BOOL bResult;
   PNODE pnode;

   ASSERT(IS_VALID_HANDLE(hlist, LIST));
   ASSERT(IS_VALID_WRITE_PTR(phnode, HNODE));

#ifdef DEBUG

   /* Make sure the correct index was given for insertion. */

   if (ADD_NODES_IN_SORTED_ORDER((PCLIST)hlist))
   {
      HNODE hnodeNew;
      ADDNODEACTION anaNew;

      anaNew = SearchForNode(hlist, csnp, pcv, &hnodeNew);

      ASSERT(anaNew != ANA_FOUND);
      ASSERT(anaNew == ANA_INSERT_AT_HEAD ||
             (anaNew == ANA_INSERT_BEFORE_NODE &&
              hnodeNew == (HNODE)(((PCLIST)hlist)->node.pnodeNext)));
   }

#endif

   bResult = AllocateMemory(sizeof(*pnode), &pnode);

   if (bResult)
   {
      /* Add new node to front of list. */

      pnode->pnodePrev = (PNODE)hlist;
      pnode->pnodeNext = ((PLIST)hlist)->node.pnodeNext;
      pnode->pcv = pcv;

      ((PLIST)hlist)->node.pnodeNext = pnode;

      /* Any more nodes in list? */

      if (pnode->pnodeNext)
         pnode->pnodeNext->pnodePrev = pnode;

      *phnode = (HNODE)pnode;
   }

   ASSERT(! bResult ||
          IS_VALID_HANDLE(*phnode, NODE));

   return(bResult);
}


/*
** InsertNodeBefore()
**
** Inserts a new node in a list before a given node.
**
** Arguments:     hnode - handle to node that new node is to be inserted before
**                pcv - data to be stored in node
**
** Returns:       Handle to new node, or NULL if unsuccessful.
**
** Side Effects:  none
*/
BOOL InsertNodeBefore(HNODE hnode, COMPARESORTEDNODESPROC csnp, PCVOID pcv, PHNODE phnode)
{
   BOOL bResult;
   PNODE pnode;

   ASSERT(IS_VALID_HANDLE(hnode, NODE));
   ASSERT(IS_VALID_WRITE_PTR(phnode, HNODE));

#ifdef DEBUG

   {
      HLIST hlistParent;

      /* Make sure the correct index was given for insertion. */

      hlistParent = GetList(hnode);

      if (ADD_NODES_IN_SORTED_ORDER((PCLIST)hlistParent))
      {
         HNODE hnodeNew;
         ADDNODEACTION anaNew;

         anaNew = SearchForNode(hlistParent, csnp, pcv, &hnodeNew);

         ASSERT(anaNew != ANA_FOUND);
         ASSERT((anaNew == ANA_INSERT_BEFORE_NODE &&
                 hnodeNew == hnode) ||
                (anaNew == ANA_INSERT_AFTER_NODE &&
                 hnodeNew == (HNODE)(((PCNODE)hnode)->pnodePrev)) ||
                (anaNew == ANA_INSERT_AT_HEAD &&
                 hnode == (HNODE)(((PCLIST)hlistParent)->node.pnodeNext)));
      }
   }

#endif

   bResult = AllocateMemory(sizeof(*pnode), &pnode);

   if (bResult)
   {
      /* Insert new node before given node. */

      pnode->pnodePrev = ((PNODE)hnode)->pnodePrev;
      pnode->pnodeNext = (PNODE)hnode;
      pnode->pcv = pcv;

      ((PNODE)hnode)->pnodePrev->pnodeNext = pnode;

      ((PNODE)hnode)->pnodePrev = pnode;

      *phnode = (HNODE)pnode;
   }

   ASSERT(! bResult ||
          IS_VALID_HANDLE(*phnode, NODE));

   return(bResult);
}


/*
** InsertNodeAfter()
**
** Inserts a new node in a list after a given node.
**
** Arguments:     hnode - handle to node that new node is to be inserted after
**                pcv - data to be stored in node
**
** Returns:       Handle to new node, or NULL if unsuccessful.
**
** Side Effects:  none
*/
BOOL InsertNodeAfter(HNODE hnode, COMPARESORTEDNODESPROC csnp, PCVOID pcv, PHNODE phnode)
{
   BOOL bResult;
   PNODE pnode;

   ASSERT(IS_VALID_HANDLE(hnode, NODE));
   ASSERT(IS_VALID_WRITE_PTR(phnode, HNODE));

#ifdef DEBUG

   /* Make sure the correct index was given for insertion. */

   {
      HLIST hlistParent;

      /* Make sure the correct index was given for insertion. */

      hlistParent = GetList(hnode);

      if (ADD_NODES_IN_SORTED_ORDER((PCLIST)hlistParent))
      {
         HNODE hnodeNew;
         ADDNODEACTION anaNew;

         anaNew = SearchForNode(hlistParent, csnp, pcv, &hnodeNew);

         ASSERT(anaNew != ANA_FOUND);
         ASSERT((anaNew == ANA_INSERT_AFTER_NODE &&
                 hnodeNew == hnode) ||
                (anaNew == ANA_INSERT_BEFORE_NODE &&
                 hnodeNew == (HNODE)(((PCNODE)hnode)->pnodeNext)));
      }
   }

#endif

   bResult = AllocateMemory(sizeof(*pnode), &pnode);

   if (bResult)
   {
      /* Insert new node after given node. */

      pnode->pnodePrev = (PNODE)hnode;
      pnode->pnodeNext = ((PNODE)hnode)->pnodeNext;
      pnode->pcv = pcv;

      /* Are we inserting after the tail of the list? */

      if (((PNODE)hnode)->pnodeNext)
         /* No. */
         ((PNODE)hnode)->pnodeNext->pnodePrev = pnode;

      ((PNODE)hnode)->pnodeNext = pnode;

      *phnode = (HNODE)pnode;
   }

   ASSERT(! bResult ||
          IS_VALID_HANDLE(*phnode, NODE));

   return(bResult);
}


/*
** DeleteNode()
**
** Removes a node from a list.
**
** Arguments:     hnode - handle to node to be removed
**
** Returns:       void
**
** Side Effects:  none
*/
void DeleteNode(HNODE hnode)
{
   ASSERT(IS_VALID_HANDLE(hnode, NODE));

   /*
    * There is always a previous node for normal list nodes.  Even the head
    * list node is preceded by the list's leading LIST node.
    */

   ((PNODE)hnode)->pnodePrev->pnodeNext = ((PNODE)hnode)->pnodeNext;

   /* Any more nodes in list? */

   if (((PNODE)hnode)->pnodeNext)
      ((PNODE)hnode)->pnodeNext->pnodePrev = ((PNODE)hnode)->pnodePrev;

   FreeMemory((PNODE)hnode);
}


void DeleteAllNodes(HLIST hlist)
{
   PNODE pnodePrev;
   PNODE pnode;

   ASSERT(IS_VALID_HANDLE(hlist, LIST));

   /* Walk list, starting with first node after head, deleting each node. */

   pnodePrev = ((PLIST)hlist)->node.pnodeNext;

   /*
    * Deleting the tail node in the loop forces us to add an extra
    * comparison to the body of the loop.  Trade speed for size here.
    */

   while (pnodePrev)
   {
      pnode = pnodePrev->pnodeNext;

      FreeMemory(pnodePrev);

      pnodePrev = pnode;

      if (pnode)
         pnode = pnode->pnodeNext;
   }

   ((PLIST)hlist)->node.pnodeNext = NULL;
}


/*
** GetNodeData()
**
** Gets the data stored in a node.
**
** Arguments:     hnode - handle to node whose data is to be returned
**
** Returns:       Pointer to node's data.
**
** Side Effects:  none
*/
PVOID GetNodeData(HNODE hnode)
{
   ASSERT(IS_VALID_HANDLE(hnode, NODE));

   return((PVOID)(((PNODE)hnode)->pcv));
}


/*
** SetNodeData()
**
** Sets the data stored in a node.
**
** Arguments:     hnode - handle to node whose data is to be set
**                pcv - node data
**
** Returns:       void
**
** Side Effects:  none
*/
void SetNodeData(HNODE hnode, PCVOID pcv)
{
   ASSERT(IS_VALID_HANDLE(hnode, NODE));

   ((PNODE)hnode)->pcv = pcv;
}


/*
** GetNodeCount()
**
** Counts the number of nodes in a list.
**
** Arguments:     hlist - handle to list whose nodes are to be counted
**
** Returns:       Number of nodes in list.
**
** Side Effects:  none
**
** N.b., this is an O(n) operation since we don't explicitly keep track of the
** number of nodes in a list.
*/
ULONG GetNodeCount(HLIST hlist)
{
   PNODE pnode;
   ULONG ulcNodes;

   ASSERT(IS_VALID_HANDLE(hlist, LIST));

   ulcNodes = 0;

   for (pnode = ((PLIST)hlist)->node.pnodeNext;
        pnode;
        pnode = pnode->pnodeNext)
   {
      ASSERT(ulcNodes < ULONG_MAX);
      ulcNodes++;
   }

   return(ulcNodes);
}


/*
** IsListEmpty()
**
** Determines whether or not a list is empty.
**
** Arguments:     hlist - handle to list to be checked
**
** Returns:       TRUE if list is empty, or FALSE if not.
**
** Side Effects:  none
*/
BOOL IsListEmpty(HLIST hlist)
{
   ASSERT(IS_VALID_HANDLE(hlist, LIST));

   return(((PLIST)hlist)->node.pnodeNext == NULL);
}


/*
** GetFirstNode()
**
** Gets the head node in a list.
**
** Arguments:     hlist - handle to list whose head node is to be retrieved
**
** Returns:       Handle to head list node, or NULL if list is empty.
**
** Side Effects:  none
*/
BOOL GetFirstNode(HLIST hlist, PHNODE phnode)
{
   ASSERT(IS_VALID_HANDLE(hlist, LIST));
   ASSERT(IS_VALID_WRITE_PTR(phnode, HNODE));

   *phnode = (HNODE)(((PLIST)hlist)->node.pnodeNext);

   ASSERT(! *phnode || IS_VALID_HANDLE(*phnode, NODE));

   return(*phnode != NULL);
}


/*
** GetNextNode()
**
** Gets the next node in a list.
**
** Arguments:     hnode - handle to current node
**                phnode - pointer to HNODE to be filled in with handle to next
**                         node in list, *phnode is only valid if GetNextNode()
**                         returns TRUE
**
** Returns:       TRUE if there is another node in the list, or FALSE if there
**                are no more nodes in the list.
**
** Side Effects:  none
*/
BOOL GetNextNode(HNODE hnode, PHNODE phnode)
{
   ASSERT(IS_VALID_HANDLE(hnode, NODE));
   ASSERT(IS_VALID_WRITE_PTR(phnode, HNODE));

   *phnode = (HNODE)(((PNODE)hnode)->pnodeNext);

   ASSERT(! *phnode || IS_VALID_HANDLE(*phnode, NODE));

   return(*phnode != NULL);
}


/*
** GetPrevNode()
**
** Gets the previous node in a list.
**
** Arguments:     hnode - handle to current node
**
** Returns:       Handle to previous node in list, or NULL if there are no
**                previous nodes in the list.
**
** Side Effects:  none
*/
BOOL GetPrevNode(HNODE hnode, PHNODE phnode)
{
   ASSERT(IS_VALID_HANDLE(hnode, NODE));
   ASSERT(IS_VALID_WRITE_PTR(phnode, HNODE));

   /* Is this the first node in the list? */

   if (((PNODE)hnode)->pnodePrev->pnodePrev)
   {
      *phnode = (HNODE)(((PNODE)hnode)->pnodePrev);
      ASSERT(IS_VALID_HANDLE(*phnode, NODE));
   }
   else
      *phnode = NULL;

   return(*phnode != NULL);
}


/*
** AppendList()
**
** Appends one list on to another, leaving the source list empty.
**
** Arguments:     hlistDest - handle to destination list to append to
**                hlistSrc - handle to source list to truncate
**
** Returns:       void
**
** Side Effects:  none
**
** N.b., all HNODEs from both lists remain valid.
*/
void AppendList(HLIST hlistDest, HLIST hlistSrc)
{
   PNODE pnode;

   ASSERT(IS_VALID_HANDLE(hlistDest, LIST));
   ASSERT(IS_VALID_HANDLE(hlistSrc, LIST));

   if (hlistSrc != hlistDest)
   {
      /* Find last node in destination list to append to. */

      /*
       * N.b., start with the actual LIST node here, not the first node in the
       * list, in case the list is empty.
       */

      for (pnode = &((PLIST)hlistDest)->node;
           pnode->pnodeNext;
           pnode = pnode->pnodeNext)
         ;

      /* Append the source list to the last node in the destination list. */

      pnode->pnodeNext = ((PLIST)hlistSrc)->node.pnodeNext;

      if (pnode->pnodeNext)
         pnode->pnodeNext->pnodePrev = pnode;

      ((PLIST)hlistSrc)->node.pnodeNext = NULL;
   }
   else
      WARNING_OUT((TEXT("AppendList(): Source list same as destination list (%#lx)."),
                   hlistDest));
}


BOOL SearchSortedList(HLIST hlist, COMPARESORTEDNODESPROC csnp,
                                  PCVOID pcv, PHNODE phnode)
{
   BOOL bResult;

   /* pcv may be any value */

   ASSERT(IS_VALID_HANDLE(hlist, LIST));
   ASSERT(IS_VALID_CODE_PTR(csnp, COMPARESORTEDNODESPROC));
   ASSERT(IS_VALID_WRITE_PTR(phnode, HNODE));

   ASSERT(ADD_NODES_IN_SORTED_ORDER((PCLIST)hlist));

   bResult = (SearchForNode(hlist, csnp, pcv, phnode) == ANA_FOUND);

   ASSERT(! bResult ||
          IS_VALID_HANDLE(*phnode, NODE));

   return(bResult);
}


BOOL SearchUnsortedList(HLIST hlist, COMPAREUNSORTEDNODESPROC cunp,
                                    PCVOID pcv, PHNODE phn)
{
   PNODE pnode;

   ASSERT(IS_VALID_HANDLE(hlist, LIST));
   ASSERT(IS_VALID_CODE_PTR(cunp, COMPAREUNSORTEDNODESPROC));
   ASSERT(IS_VALID_WRITE_PTR(phn, HNODE));

   *phn = NULL;

   for (pnode = ((PLIST)hlist)->node.pnodeNext;
        pnode;
        pnode = pnode->pnodeNext)
   {
      if ((*cunp)(pcv, pnode->pcv) == CR_EQUAL)
      {
         *phn = (HNODE)pnode;
         break;
      }
   }

   return(*phn != NULL);
}


/*
** WalkList()
**
** Walks a list, calling a callback function with each list node's data and
** caller supplied data.
**
** Arguments:     hlist - handle to list to be searched
**                wlp - callback function to be called with each list node's
**                      data, called as:
**
**                         bContinue = (*wlwdp)(pv, pvRefData);
**
**                      wlp should return TRUE to continue the walk, or FALSE
**                      to halt the walk
**                pvRefData - data to pass to callback function
**
** Returns:       FALSE if callback function aborted the walk.  TRUE if the
**                walk completed.
**
** N.b., the callback function is allowed to delete the node it is passed.
**
** Side Effects:  none
*/
BOOL WalkList(HLIST hlist, WALKLIST wlp, PVOID pvRefData)
{
   BOOL bResult = TRUE;
   PNODE pnode;

   ASSERT(IS_VALID_HANDLE(hlist, LIST));
   ASSERT(IS_VALID_CODE_PTR(wlp, WALKLISTPROC));

   pnode = ((PLIST)hlist)->node.pnodeNext;

   while (pnode)
   {
      PNODE pnodeNext;

      pnodeNext = pnode->pnodeNext;

      if ((*wlp)((PVOID)(pnode->pcv), pvRefData))
         pnode = pnodeNext;
      else
      {
         bResult = FALSE;
         break;
      }
   }

   return(bResult);
}

#ifdef DEBUG

HLIST GetList(HNODE hnode)
{
   PCNODE pcnode;

   ASSERT(IS_VALID_HANDLE(hnode, NODE));

   ASSERT(((PCNODE)hnode)->pnodePrev);

   for (pcnode = (PCNODE)hnode; pcnode->pnodePrev; pcnode = pcnode->pnodePrev)
      ;

   return((HLIST)pcnode);
}

#endif


/* Macros
 *********/


COMPARISONRESULT MyMemComp(PCVOID pcv1, PCVOID pcv2, DWORD dwcbSize)
{
   int nResult = 0;
   PCBYTE pcbyte1 = pcv1;
   PCBYTE pcbyte2 = pcv2;

   ASSERT(IS_VALID_READ_BUFFER_PTR(pcv1, BYTE, (UINT)dwcbSize));
   ASSERT(IS_VALID_READ_BUFFER_PTR(pcv2, BYTE, (UINT)dwcbSize));

   while (dwcbSize > 0 &&
          ! (nResult = *pcbyte1 - *pcbyte2))
   {
      pcbyte1++;
      pcbyte2++;
      dwcbSize--;
   }

   return(MapIntToComparisonResult(nResult));
}


BOOL AllocateMemory(DWORD dwcbSize, PVOID *ppvNew)
{
    *ppvNew = PoolMemGetAlignedMemory (g_BrfcasePool, dwcbSize);
    return(*ppvNew != NULL);
}


void FreeMemory(PVOID pvOld)
{
    PoolMemReleaseMemory (g_BrfcasePool, pvOld);
}


BOOL ReallocateMemory(PVOID pvOld, DWORD dwcbOldSize, DWORD dwcbNewSize, PVOID *ppvNew)
{
    if (AllocateMemory (dwcbNewSize, ppvNew)) {
        CopyMemory (*ppvNew, pvOld, dwcbOldSize);
    }
    return(*ppvNew != NULL);
}


/* Constants
 ************/

/* PATHLIST PTRARRAY allocation parameters */

#define NUM_START_PATHS          (32)
#define NUM_PATHS_TO_ADD         (32)

/* PATHLIST string table allocation parameters */

#define NUM_PATH_HASH_BUCKETS    (67)


/* Types
 ********/

/* path list */

typedef struct _pathlist
{
   /* array of pointers to PATHs */

   HPTRARRAY hpa;

   /* list of volumes */

   HVOLUMELIST hvl;

   /* table of path suffix strings */

   HSTRINGTABLE hst;
}
PATHLIST;
DECLARE_STANDARD_TYPES(PATHLIST);

/* path structure */

typedef struct _path
{
   /* reference count */

   ULONG ulcLock;

   /* handle to parent volume */

   HVOLUME hvol;

   /* handle to path suffix string */

   HSTRING hsPathSuffix;

   /* pointer to PATH's parent PATHLIST */

   PPATHLIST pplParent;
}
PATH;
DECLARE_STANDARD_TYPES(PATH);

/* PATH search structure used by PathSearchCmp() */

typedef struct _pathsearchinfo
{
   HVOLUME hvol;

   LPCTSTR pcszPathSuffix;
}
PATHSEARCHINFO;
DECLARE_STANDARD_TYPES(PATHSEARCHINFO);

/* database path list header */

typedef struct _dbpathlistheader
{
   /* number of paths in list */

   LONG lcPaths;
}
DBPATHLISTHEADER;
DECLARE_STANDARD_TYPES(DBPATHLISTHEADER);

/* database path structure */

typedef struct _dbpath
{
   /* old handle to path */

   HPATH hpath;

   /* old handle to parent volume */

   HVOLUME hvol;

   /* old handle to path suffix string */

   HSTRING hsPathSuffix;
}
DBPATH;
DECLARE_STANDARD_TYPES(DBPATH);


/* Module Prototypes
 ********************/

COMPARISONRESULT PathSortCmp(PCVOID, PCVOID);
COMPARISONRESULT PathSearchCmp(PCVOID, PCVOID);
BOOL UnifyPath(PPATHLIST, HVOLUME, LPCTSTR, PPATH *);
BOOL CreatePath(PPATHLIST, HVOLUME, LPCTSTR, PPATH *);
void DestroyPath(PPATH);
void UnlinkPath(PCPATH);
void LockPath(PPATH);
BOOL UnlockPath(PPATH);
PATHRESULT TranslateVOLUMERESULTToPATHRESULT(VOLUMERESULT);
TWINRESULT WritePath(HCACHEDFILE, PPATH);
TWINRESULT ReadPath(HCACHEDFILE, PPATHLIST, HHANDLETRANS, HHANDLETRANS, HHANDLETRANS);


/*
** PathSortCmp()
**
** Pointer comparison function used to sort the module array of paths.
**
** Arguments:     pcpath1 - pointer to first path
**                pcpath2 - pointer to second path
**
** Returns:
**
** Side Effects:  none
**
** The internal paths are sorted by:
**    1) volume
**    2) path suffix
**    3) pointer value
*/
COMPARISONRESULT PathSortCmp(PCVOID pcpath1, PCVOID pcpath2)
{
   COMPARISONRESULT cr;

   ASSERT(IS_VALID_STRUCT_PTR(pcpath1, CPATH));
   ASSERT(IS_VALID_STRUCT_PTR(pcpath2, CPATH));

   cr = CompareVolumes(((PCPATH)pcpath1)->hvol,
                       ((PCPATH)pcpath2)->hvol);

   if (cr == CR_EQUAL)
   {
      cr = ComparePathStringsByHandle(((PCPATH)pcpath1)->hsPathSuffix,
                                      ((PCPATH)pcpath2)->hsPathSuffix);

      if (cr == CR_EQUAL)
         cr = ComparePointers(pcpath1, pcpath2);
   }

   return(cr);
}


/*
** PathSearchCmp()
**
** Pointer comparison function used to search for a path.
**
** Arguments:     pcpathsi - pointer to PATHSEARCHINFO describing path to
**                           search for
**                pcpath - pointer to path to examine
**
** Returns:
**
** Side Effects:  none
**
** The internal paths are searched by:
**    1) volume
**    2) path suffix string
*/
COMPARISONRESULT PathSearchCmp(PCVOID pcpathsi, PCVOID pcpath)
{
   COMPARISONRESULT cr;

   ASSERT(IS_VALID_STRUCT_PTR(pcpath, CPATH));

   cr = CompareVolumes(((PCPATHSEARCHINFO)pcpathsi)->hvol,
                       ((PCPATH)pcpath)->hvol);

   if (cr == CR_EQUAL)
      cr = ComparePathStrings(((PCPATHSEARCHINFO)pcpathsi)->pcszPathSuffix,
                              GetBfcString(((PCPATH)pcpath)->hsPathSuffix));

   return(cr);
}


BOOL UnifyPath(PPATHLIST ppl, HVOLUME hvol, LPCTSTR pcszPathSuffix,
                            PPATH *pppath)
{
   BOOL bResult = FALSE;

   ASSERT(IS_VALID_STRUCT_PTR(ppl, CPATHLIST));
   ASSERT(IS_VALID_HANDLE(hvol, VOLUME));
   ASSERT(IsValidPathSuffix(pcszPathSuffix));
   ASSERT(IS_VALID_WRITE_PTR(pppath, PPATH));

   /* Allocate space for PATH structure. */

   if (AllocateMemory(sizeof(**pppath), pppath))
   {
      if (CopyVolume(hvol, ppl->hvl, &((*pppath)->hvol)))
      {
         if (AddString(pcszPathSuffix, ppl->hst, GetHashBucketIndex, &((*pppath)->hsPathSuffix)))
         {
            ARRAYINDEX aiUnused;

            /* Initialize remaining PATH fields. */

            (*pppath)->ulcLock = 0;
            (*pppath)->pplParent = ppl;

            /* Add new PATH to array. */

            if (AddPtr(ppl->hpa, PathSortCmp, *pppath, &aiUnused))
               bResult = TRUE;
            else
            {
               DeleteString((*pppath)->hsPathSuffix);
UNIFYPATH_BAIL1:
               DeleteVolume((*pppath)->hvol);
UNIFYPATH_BAIL2:
               FreeMemory(*pppath);
            }
         }
         else
            goto UNIFYPATH_BAIL1;
      }
      else
         goto UNIFYPATH_BAIL2;
   }

   ASSERT(! bResult ||
          IS_VALID_STRUCT_PTR(*pppath, CPATH));

   return(bResult);
}


BOOL CreatePath(PPATHLIST ppl, HVOLUME hvol, LPCTSTR pcszPathSuffix,
                             PPATH *pppath)
{
   BOOL bResult;
   ARRAYINDEX aiFound;
   PATHSEARCHINFO pathsi;

   ASSERT(IS_VALID_STRUCT_PTR(ppl, CPATHLIST));
   ASSERT(IS_VALID_HANDLE(hvol, VOLUME));
   ASSERT(IsValidPathSuffix(pcszPathSuffix));
   ASSERT(IS_VALID_WRITE_PTR(pppath, CPATH));

   /* Does a path for the given volume and path suffix already exist? */

   pathsi.hvol = hvol;
   pathsi.pcszPathSuffix = pcszPathSuffix;

   bResult = SearchSortedArray(ppl->hpa, &PathSearchCmp, &pathsi, &aiFound);

   if (bResult)
      /* Yes.  Return it. */
      *pppath = GetPtr(ppl->hpa, aiFound);
   else
      bResult = UnifyPath(ppl, hvol, pcszPathSuffix, pppath);

   if (bResult)
      LockPath(*pppath);

   ASSERT(! bResult ||
          IS_VALID_STRUCT_PTR(*pppath, CPATH));

   return(bResult);
}


void DestroyPath(PPATH ppath)
{
   ASSERT(IS_VALID_STRUCT_PTR(ppath, CPATH));

   DeleteVolume(ppath->hvol);
   DeleteString(ppath->hsPathSuffix);
   FreeMemory(ppath);
}


void UnlinkPath(PCPATH pcpath)
{
   HPTRARRAY hpa;
   ARRAYINDEX aiFound;

   ASSERT(IS_VALID_STRUCT_PTR(pcpath, CPATH));

   hpa = pcpath->pplParent->hpa;

   if (EVAL(SearchSortedArray(hpa, &PathSortCmp, pcpath, &aiFound)))
   {
      ASSERT(GetPtr(hpa, aiFound) == pcpath);

      DeletePtr(hpa, aiFound);
   }
}


void LockPath(PPATH ppath)
{
   ASSERT(IS_VALID_STRUCT_PTR(ppath, CPATH));

   ASSERT(ppath->ulcLock < ULONG_MAX);
   ppath->ulcLock++;
}


BOOL UnlockPath(PPATH ppath)
{
   ASSERT(IS_VALID_STRUCT_PTR(ppath, CPATH));

   if (EVAL(ppath->ulcLock > 0))
      ppath->ulcLock--;

   return(ppath->ulcLock > 0);
}


PATHRESULT TranslateVOLUMERESULTToPATHRESULT(VOLUMERESULT vr)
{
   PATHRESULT pr;

   switch (vr)
   {
      case VR_SUCCESS:
         pr = PR_SUCCESS;
         break;

      case VR_UNAVAILABLE_VOLUME:
         pr = PR_UNAVAILABLE_VOLUME;
         break;

      case VR_OUT_OF_MEMORY:
         pr = PR_OUT_OF_MEMORY;
         break;

      default:
         ASSERT(vr == VR_INVALID_PATH);
         pr = PR_INVALID_PATH;
         break;
   }

   return(pr);
}


TWINRESULT WritePath(HCACHEDFILE hcf, PPATH ppath)
{
   TWINRESULT tr;
   DBPATH dbpath;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_STRUCT_PTR(ppath, CPATH));

   /* Write database path. */

   dbpath.hpath = (HPATH)ppath;
   dbpath.hvol = ppath->hvol;
   dbpath.hsPathSuffix = ppath->hsPathSuffix;

   if (WriteToCachedFile(hcf, (PCVOID)&dbpath, sizeof(dbpath), NULL))
      tr = TR_SUCCESS;
   else
      tr = TR_BRIEFCASE_WRITE_FAILED;

   return(tr);
}


TWINRESULT ReadPath(HCACHEDFILE hcf, PPATHLIST ppl,
                                 HHANDLETRANS hhtVolumes,
                                 HHANDLETRANS hhtStrings,
                                 HHANDLETRANS hhtPaths)
{
   TWINRESULT tr;
   DBPATH dbpath;
   DWORD dwcbRead;
   HVOLUME hvol;
   HSTRING hsPathSuffix;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_STRUCT_PTR(ppl, CPATHLIST));
   ASSERT(IS_VALID_HANDLE(hhtVolumes, HANDLETRANS));
   ASSERT(IS_VALID_HANDLE(hhtStrings, HANDLETRANS));
   ASSERT(IS_VALID_HANDLE(hhtPaths, HANDLETRANS));

   if (ReadFromCachedFile(hcf, &dbpath, sizeof(dbpath), &dwcbRead) &&
       dwcbRead == sizeof(dbpath) &&
       TranslateHandle(hhtVolumes, (HGENERIC)(dbpath.hvol), (PHGENERIC)&hvol) &&
       TranslateHandle(hhtStrings, (HGENERIC)(dbpath.hsPathSuffix), (PHGENERIC)&hsPathSuffix))
   {
      PPATH ppath;

      if (CreatePath(ppl, hvol, GetBfcString(hsPathSuffix), &ppath))
      {
         /*
          * To leave read paths with 0 initial lock count, we must undo
          * the LockPath() performed by CreatePath().
          */

         UnlockPath(ppath);

         if (AddHandleToHandleTranslator(hhtPaths,
                                         (HGENERIC)(dbpath.hpath),
                                         (HGENERIC)ppath))
            tr = TR_SUCCESS;
         else
         {
            UnlinkPath(ppath);
            DestroyPath(ppath);

            tr = TR_OUT_OF_MEMORY;
         }
      }
      else
         tr = TR_OUT_OF_MEMORY;
   }
   else
      tr = TR_CORRUPT_BRIEFCASE;

   return(tr);
}


BOOL CreatePathList(DWORD dwFlags, HWND hwndOwner, PHPATHLIST phpl)
{
   BOOL bResult = FALSE;
   PPATHLIST ppl;

   ASSERT(FLAGS_ARE_VALID(dwFlags, ALL_RLI_IFLAGS));
   ASSERT(IS_FLAG_CLEAR(dwFlags, RLI_IFL_ALLOW_UI) ||
          IS_VALID_HANDLE(hwndOwner, WND));
   ASSERT(IS_VALID_WRITE_PTR(phpl, HPATHLIST));

   if (AllocateMemory(sizeof(*ppl), &ppl))
   {
      NEWPTRARRAY npa;

      /* Create pointer array of paths. */

      npa.aicInitialPtrs = NUM_START_PATHS;
      npa.aicAllocGranularity = NUM_PATHS_TO_ADD;
      npa.dwFlags = NPA_FL_SORTED_ADD;

      if (CreatePtrArray(&npa, &(ppl->hpa)))
      {
         if (CreateVolumeList(dwFlags, hwndOwner, &(ppl->hvl)))
         {
            NEWSTRINGTABLE nszt;

            /* Create string table for path suffix strings. */

            nszt.hbc = NUM_PATH_HASH_BUCKETS;

            if (CreateStringTable(&nszt, &(ppl->hst)))
            {
               *phpl = (HPATHLIST)ppl;
               bResult = TRUE;
            }
            else
            {
               DestroyVolumeList(ppl->hvl);
CREATEPATHLIST_BAIL1:
               DestroyPtrArray(ppl->hpa);
CREATEPATHLIST_BAIL2:
               FreeMemory(ppl);
            }
         }
         else
            goto CREATEPATHLIST_BAIL1;
      }
      else
         goto CREATEPATHLIST_BAIL2;
   }

   ASSERT(! bResult ||
          IS_VALID_HANDLE(*phpl, PATHLIST));

   return(bResult);
}


void DestroyPathList(HPATHLIST hpl)
{
   ARRAYINDEX aicPtrs;
   ARRAYINDEX ai;

   ASSERT(IS_VALID_HANDLE(hpl, PATHLIST));

   /* First free all paths in array. */

   aicPtrs = GetPtrCount(((PCPATHLIST)hpl)->hpa);

   for (ai = 0; ai < aicPtrs; ai++)
      DestroyPath(GetPtr(((PCPATHLIST)hpl)->hpa, ai));

   /* Now wipe out the array. */

   DestroyPtrArray(((PCPATHLIST)hpl)->hpa);

   ASSERT(! GetVolumeCount(((PCPATHLIST)hpl)->hvl));
   DestroyVolumeList(((PCPATHLIST)hpl)->hvl);

   ASSERT(! GetStringCount(((PCPATHLIST)hpl)->hst));
   DestroyStringTable(((PCPATHLIST)hpl)->hst);

   FreeMemory((PPATHLIST)hpl);
}


void InvalidatePathListInfo(HPATHLIST hpl)
{
   InvalidateVolumeListInfo(((PCPATHLIST)hpl)->hvl);
}


void ClearPathListInfo(HPATHLIST hpl)
{
   ClearVolumeListInfo(((PCPATHLIST)hpl)->hvl);
}


PATHRESULT AddPath(HPATHLIST hpl, LPCTSTR pcszPath, PHPATH phpath)
{
   PATHRESULT pr;
   HVOLUME hvol;
   TCHAR rgchPathSuffix[MAX_PATH_LEN];
   LPCTSTR     pszPath;
   WCHAR szUnicode[MAX_PATH];

   ASSERT(IS_VALID_HANDLE(hpl, PATHLIST));
   ASSERT(IS_VALID_STRING_PTR(pcszPath, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(phpath, HPATH));

   // On NT, we want to convert a unicode string to an ANSI shortened path for
   // the sake of interop

   {
        CHAR szAnsi[MAX_PATH];
        szUnicode[0] = L'\0';

        WideCharToMultiByte( OurGetACP(), 0, pcszPath, -1, szAnsi, ARRAYSIZE(szAnsi), NULL, NULL);
        MultiByteToWideChar( OurGetACP(), 0, szAnsi,   -1, szUnicode, ARRAYSIZE(szUnicode));
        if (lstrcmp(szUnicode, pcszPath))
        {
            // Cannot convert losslessly from Unicode -> Ansi, so get the short path

            lstrcpy(szUnicode, pcszPath);
            SheShortenPath(szUnicode, TRUE);
            pszPath = szUnicode;
        }
        else
        {
            // It will convert OK, so just use the original

            pszPath = pcszPath;
        }
   }

   pr = TranslateVOLUMERESULTToPATHRESULT(
            AddVolume(((PCPATHLIST)hpl)->hvl, pszPath, &hvol, rgchPathSuffix));

   if (pr == PR_SUCCESS)
   {
      PPATH ppath;

      if (CreatePath((PPATHLIST)hpl, hvol, rgchPathSuffix, &ppath))
         *phpath = (HPATH)ppath;
      else
         pr = PR_OUT_OF_MEMORY;

      DeleteVolume(hvol);
   }

   ASSERT(pr != PR_SUCCESS ||
          IS_VALID_HANDLE(*phpath, PATH));

   return(pr);
}


BOOL AddChildPath(HPATHLIST hpl, HPATH hpathParent,
                              LPCTSTR pcszSubPath, PHPATH phpathChild)
{
   BOOL bResult;
   TCHAR rgchChildPathSuffix[MAX_PATH_LEN];
   LPCTSTR pcszPathSuffix;
   LPTSTR pszPathSuffixEnd;
   PPATH ppathChild;

   ASSERT(IS_VALID_HANDLE(hpl, PATHLIST));
   ASSERT(IS_VALID_HANDLE(hpathParent, PATH));
   ASSERT(IS_VALID_STRING_PTR(pcszSubPath, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(phpathChild, HPATH));

   ComposePath(rgchChildPathSuffix,
               GetBfcString(((PCPATH)hpathParent)->hsPathSuffix),
               pcszSubPath);

   pcszPathSuffix = rgchChildPathSuffix;

   if (IS_SLASH(*pcszPathSuffix))
      pcszPathSuffix++;

   pszPathSuffixEnd = CharPrev(pcszPathSuffix,
                               pcszPathSuffix + lstrlen(pcszPathSuffix));

   if (IS_SLASH(*pszPathSuffixEnd))
      *pszPathSuffixEnd = TEXT('\0');

   ASSERT(IsValidPathSuffix(pcszPathSuffix));

   bResult = CreatePath((PPATHLIST)hpl, ((PCPATH)hpathParent)->hvol,
                        pcszPathSuffix, &ppathChild);

   if (bResult)
      *phpathChild = (HPATH)ppathChild;

   ASSERT(! bResult ||
          IS_VALID_HANDLE(*phpathChild, PATH));

   return(bResult);
}


void DeletePath(HPATH hpath)
{
   ASSERT(IS_VALID_HANDLE(hpath, PATH));

   if (! UnlockPath((PPATH)hpath))
   {
      UnlinkPath((PPATH)hpath);
      DestroyPath((PPATH)hpath);
   }
}


BOOL CopyPath(HPATH hpathSrc, HPATHLIST hplDest, PHPATH phpathCopy)
{
   BOOL bResult;
   PPATH ppath;

   ASSERT(IS_VALID_HANDLE(hpathSrc, PATH));
   ASSERT(IS_VALID_HANDLE(hplDest, PATHLIST));
   ASSERT(IS_VALID_WRITE_PTR(phpathCopy, HPATH));

   /* Is the destination path list the source path's path list? */

   if (((PCPATH)hpathSrc)->pplParent == (PCPATHLIST)hplDest)
   {
      /* Yes.  Use the source path. */

      LockPath((PPATH)hpathSrc);
      ppath = (PPATH)hpathSrc;
      bResult = TRUE;
   }
   else
      bResult = CreatePath((PPATHLIST)hplDest, ((PCPATH)hpathSrc)->hvol,
                           GetBfcString(((PCPATH)hpathSrc)->hsPathSuffix),
                           &ppath);

   if (bResult)
      *phpathCopy = (HPATH)ppath;

   ASSERT(! bResult ||
          IS_VALID_HANDLE(*phpathCopy, PATH));

   return(bResult);
}


void GetPathString(HPATH hpath, LPTSTR pszPathBuf)
{
   ASSERT(IS_VALID_HANDLE(hpath, PATH));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszPathBuf, STR, MAX_PATH_LEN));

   GetPathRootString(hpath, pszPathBuf);
   CatPath(pszPathBuf, GetBfcString(((PPATH)hpath)->hsPathSuffix));

   ASSERT(IsCanonicalPath(pszPathBuf));
}


void GetPathRootString(HPATH hpath, LPTSTR pszPathRootBuf)
{
   ASSERT(IS_VALID_HANDLE(hpath, PATH));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszPathRootBuf, STR, MAX_PATH_LEN));

   GetVolumeRootPath(((PPATH)hpath)->hvol, pszPathRootBuf);

   ASSERT(IsCanonicalPath(pszPathRootBuf));
}


void GetPathSuffixString(HPATH hpath, LPTSTR pszPathSuffixBuf)
{
   ASSERT(IS_VALID_HANDLE(hpath, PATH));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszPathSuffixBuf, STR, MAX_PATH_LEN));

   ASSERT(lstrlen(GetBfcString(((PPATH)hpath)->hsPathSuffix)) < MAX_PATH_LEN);
   MyLStrCpyN(pszPathSuffixBuf, GetBfcString(((PPATH)hpath)->hsPathSuffix), MAX_PATH_LEN);

   ASSERT(IsValidPathSuffix(pszPathSuffixBuf));
}


BOOL AllocatePathString(HPATH hpath, LPTSTR *ppszPath)
{
   TCHAR rgchPath[MAX_PATH_LEN];

   ASSERT(IS_VALID_HANDLE(hpath, PATH));
   ASSERT(IS_VALID_WRITE_PTR(ppszPath, LPTSTR));

   GetPathString(hpath, rgchPath);

   return(StringCopy2(rgchPath, ppszPath));
}


ULONG GetPathCount(HPATHLIST hpl)
{
   ASSERT(IS_VALID_HANDLE(hpl, PATHLIST));

   return(GetPtrCount(((PCPATHLIST)hpl)->hpa));
}


BOOL IsPathVolumeAvailable(HPATH hpath)
{
   ASSERT(IS_VALID_HANDLE(hpath, PATH));

   return(IsVolumeAvailable(((PCPATH)hpath)->hvol));
}


HVOLUMEID GetPathVolumeID(HPATH hpath)
{
   ASSERT(IS_VALID_HANDLE(hpath, PATH));

   return((HVOLUMEID)hpath);
}


/*
** MyIsPathOnVolume()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
**
** MyIsPathOnVolume() will fail for a new root path alias for a volume.  E.g.,
** if the same net resource is connected to both X: and Y:, MyIsPathOnVolume()
** will only return TRUE for the drive root path that the net resource was
** connected to through the given HVOLUME.
*/
BOOL MyIsPathOnVolume(LPCTSTR pcszPath, HPATH hpath)
{
   BOOL bResult;
   TCHAR rgchVolumeRootPath[MAX_PATH_LEN];

   ASSERT(IsFullPath(pcszPath));
   ASSERT(IS_VALID_HANDLE(hpath, PATH));

   if (IsVolumeAvailable(((PPATH)hpath)->hvol))
   {
      GetVolumeRootPath(((PPATH)hpath)->hvol, rgchVolumeRootPath);

      bResult = (MyLStrCmpNI(pcszPath, rgchVolumeRootPath,
                             lstrlen(rgchVolumeRootPath))
                 == CR_EQUAL);
   }
   else
   {
      TRACE_OUT((TEXT("MyIsPathOnVolume(): Failing on unavailable volume %s."),
                 DebugGetVolumeRootPath(((PPATH)hpath)->hvol, rgchVolumeRootPath)));

      bResult = FALSE;
   }

   return(bResult);
}


/*
** ComparePaths()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
**
** PATHs are compared by:
**    1) volume
**    2) path suffix
*/
COMPARISONRESULT ComparePaths(HPATH hpath1, HPATH hpath2)
{
   COMPARISONRESULT cr;

   ASSERT(IS_VALID_HANDLE(hpath1, PATH));
   ASSERT(IS_VALID_HANDLE(hpath2, PATH));

   /* This comparison works across path lists. */

   cr = ComparePathVolumes(hpath1, hpath2);

   if (cr == CR_EQUAL)
      cr = ComparePathStringsByHandle(((PCPATH)hpath1)->hsPathSuffix,
                                      ((PCPATH)hpath2)->hsPathSuffix);

   return(cr);
}


COMPARISONRESULT ComparePathVolumes(HPATH hpath1, HPATH hpath2)
{
   ASSERT(IS_VALID_HANDLE(hpath1, PATH));
   ASSERT(IS_VALID_HANDLE(hpath2, PATH));

   return(CompareVolumes(((PCPATH)hpath1)->hvol, ((PCPATH)hpath2)->hvol));
}


/*
** IsPathPrefix()
**
** Determines whether or not one path is a prefix of another.
**
** Arguments:     hpathChild - whole path (longer or same length)
**                hpathParent - prefix path to test (shorter or same length)
**
** Returns:       TRUE if the second path is a prefix of the first path.  FALSE
**                if not.
**
** Side Effects:  none
**
** Read 'IsPathPrefix(A, B)' as 'Is A in B's subtree?'.
*/
BOOL IsPathPrefix(HPATH hpathChild, HPATH hpathParent)
{
   BOOL bResult;

   ASSERT(IS_VALID_HANDLE(hpathParent, PATH));
   ASSERT(IS_VALID_HANDLE(hpathChild, PATH));

   if (ComparePathVolumes(hpathParent, hpathChild) == CR_EQUAL)
   {
      TCHAR rgchParentSuffix[MAX_PATH_LEN];
      TCHAR rgchChildSuffix[MAX_PATH_LEN];
      int nParentSuffixLen;
      int nChildSuffixLen;

      /* Ignore path roots when comparing path strings. */

      GetPathSuffixString(hpathParent, rgchParentSuffix);
      GetPathSuffixString(hpathChild, rgchChildSuffix);

      /* Only root paths should have no path suffix off the root. */

      nParentSuffixLen = lstrlen(rgchParentSuffix);
      nChildSuffixLen = lstrlen(rgchChildSuffix);

      /*
       * The parent path is a path prefix of the child path iff:
       *    1) The parent's path suffix string is shorter than or the same
       *       length as the child's path suffix string.
       *    2) The two path suffix strings match through the length of the
       *       parent's path suffix string.
       *    3) The prefix of the child's path suffix string is followed
       *       immediately by a null terminator or a path separator.
       */

      bResult = (nChildSuffixLen >= nParentSuffixLen &&
                 MyLStrCmpNI(rgchParentSuffix, rgchChildSuffix,
                             nParentSuffixLen) == CR_EQUAL &&
                 (nChildSuffixLen == nParentSuffixLen ||          /* same paths */
                  ! nParentSuffixLen ||                           /* root parent */
                  IS_SLASH(rgchChildSuffix[nParentSuffixLen])));  /* non-root parent */
   }
   else
      bResult = FALSE;

   return(bResult);
}


/*
** SubtreesIntersect()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
**
** N.b., two subtrees cannot both intersect a third subtree unless they
** intersect each other.
*/
BOOL SubtreesIntersect(HPATH hpath1, HPATH hpath2)
{
   ASSERT(IS_VALID_HANDLE(hpath1, PATH));
   ASSERT(IS_VALID_HANDLE(hpath2, PATH));

   return(IsPathPrefix(hpath1, hpath2) ||
          IsPathPrefix(hpath2, hpath1));
}


/*
** FindEndOfRootSpec()
**
** Finds the end of the root specification in a path string.
**
** Arguments:     pcszPath - path to examine for root specification
**                hpath - handle to PATH that path string was generated from
**
** Returns:       pointer to first character after end of root specification
**
** Side Effects:  none
**
*/
LPTSTR FindEndOfRootSpec(LPCTSTR pcszFullPath, HPATH hpath)
{
   LPCTSTR pcsz;
   UINT ucchPathLen;
   UINT ucchSuffixLen;

   ASSERT(IsCanonicalPath(pcszFullPath));
   ASSERT(IS_VALID_HANDLE(hpath, PATH));

   ucchPathLen = lstrlen(pcszFullPath);
   ucchSuffixLen = lstrlen(GetBfcString(((PCPATH)hpath)->hsPathSuffix));

   pcsz = pcszFullPath + ucchPathLen;

   if (ucchPathLen > ucchSuffixLen)
      pcsz -= ucchSuffixLen;
   else
      /* Assume path is root path. */
      ERROR_OUT((TEXT("FindEndOfRootSpec(): Path suffix %s is longer than full path %s."),
                 GetBfcString(((PCPATH)hpath)->hsPathSuffix),
                 pcszFullPath));

   ASSERT(IsValidPathSuffix(pcsz));

   return((LPTSTR)pcsz);
}


LPTSTR FindChildPathSuffix(HPATH hpathParent, HPATH hpathChild,
                                     LPTSTR pszChildSuffixBuf)
{
   LPCTSTR pcszChildSuffix;
   TCHAR rgchParentSuffix[MAX_PATH_LEN];

   ASSERT(IS_VALID_HANDLE(hpathParent, PATH));
   ASSERT(IS_VALID_HANDLE(hpathChild, PATH));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszChildSuffixBuf, STR, MAX_PATH_LEN));

   ASSERT(IsPathPrefix(hpathChild, hpathParent));

   GetPathSuffixString(hpathParent, rgchParentSuffix);
   GetPathSuffixString(hpathChild, pszChildSuffixBuf);

   ASSERT(lstrlen(rgchParentSuffix) <= lstrlen(pszChildSuffixBuf));
   pcszChildSuffix = pszChildSuffixBuf + lstrlen(rgchParentSuffix);

   if (IS_SLASH(*pcszChildSuffix))
      pcszChildSuffix++;

   ASSERT(IsValidPathSuffix(pcszChildSuffix));

   return((LPTSTR)pcszChildSuffix);
}


COMPARISONRESULT ComparePointers(PCVOID pcv1, PCVOID pcv2)
{
   COMPARISONRESULT cr;

   /* pcv1 and pcv2 may be any value. */

   if (pcv1 < pcv2)
      cr = CR_FIRST_SMALLER;
   else if (pcv1 > pcv2)
      cr = CR_FIRST_LARGER;
   else
      cr = CR_EQUAL;

   return(cr);
}


TWINRESULT TWINRESULTFromLastError(TWINRESULT tr)
{
   switch (GetLastError())
   {
      case ERROR_OUTOFMEMORY:
         tr = TR_OUT_OF_MEMORY;
         break;

      default:
         break;
   }

   return(tr);
}


TWINRESULT WritePathList(HCACHEDFILE hcf, HPATHLIST hpl)
{
   TWINRESULT tr;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_HANDLE(hpl, PATHLIST));

   tr = WriteVolumeList(hcf, ((PCPATHLIST)hpl)->hvl);

   if (tr == TR_SUCCESS)
   {
      tr = WriteStringTable(hcf, ((PCPATHLIST)hpl)->hst);

      if (tr == TR_SUCCESS)
      {
         DWORD dwcbDBPathListHeaderOffset;

         tr = TR_BRIEFCASE_WRITE_FAILED;

         /* Save initial file position. */

         dwcbDBPathListHeaderOffset = GetCachedFilePointerPosition(hcf);

         if (dwcbDBPathListHeaderOffset != INVALID_SEEK_POSITION)
         {
            DBPATHLISTHEADER dbplh;

            /* Leave space for path list header. */

            ZeroMemory(&dbplh, sizeof(dbplh));

            if (WriteToCachedFile(hcf, (PCVOID)&dbplh, sizeof(dbplh), NULL))
            {
               ARRAYINDEX aicPtrs;
               ARRAYINDEX ai;
               LONG lcPaths = 0;

               tr = TR_SUCCESS;

               aicPtrs = GetPtrCount(((PCPATHLIST)hpl)->hpa);

               /* Write all paths. */

               for (ai = 0; ai < aicPtrs; ai++)
               {
                  PPATH ppath;

                  ppath = GetPtr(((PCPATHLIST)hpl)->hpa, ai);

                  /*
                   * As a sanity check, don't save any path with a lock count
                   * of 0.  A 0 lock count implies that the path has not been
                   * referenced since it was restored from the database, or
                   * something is broken.
                   */

                  if (ppath->ulcLock > 0)
                  {
                     tr = WritePath(hcf, ppath);

                     if (tr == TR_SUCCESS)
                     {
                        ASSERT(lcPaths < LONG_MAX);
                        lcPaths++;
                     }
                     else
                        break;
                  }
                  else
                     ERROR_OUT((TEXT("WritePathList(): PATH for path %s has 0 lock count and will not be written."),
                                DebugGetPathString((HPATH)ppath)));
               }

               /* Save path list header. */

               if (tr == TR_SUCCESS)
               {
                  dbplh.lcPaths = lcPaths;

                  tr = WriteDBSegmentHeader(hcf, dwcbDBPathListHeaderOffset, &dbplh,
                                            sizeof(dbplh));

                  TRACE_OUT((TEXT("WritePathList(): Wrote %ld paths."),
                             dbplh.lcPaths));
               }
            }
         }
      }
   }

   return(tr);
}


TWINRESULT ReadPathList(HCACHEDFILE hcf, HPATHLIST hpl,
                                    PHHANDLETRANS phht)
{
   TWINRESULT tr;
   HHANDLETRANS hhtVolumes;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_HANDLE(hpl, PATHLIST));
   ASSERT(IS_VALID_WRITE_PTR(phht, HHANDLETRANS));

   tr = ReadVolumeList(hcf, ((PCPATHLIST)hpl)->hvl, &hhtVolumes);

   if (tr == TR_SUCCESS)
   {
      HHANDLETRANS hhtStrings;

      tr = ReadStringTable(hcf, ((PCPATHLIST)hpl)->hst, &hhtStrings);

      if (tr == TR_SUCCESS)
      {
         DBPATHLISTHEADER dbplh;
         DWORD dwcbRead;

         tr = TR_CORRUPT_BRIEFCASE;

         if (ReadFromCachedFile(hcf, &dbplh, sizeof(dbplh), &dwcbRead) &&
             dwcbRead == sizeof(dbplh))
         {
            HHANDLETRANS hht;

            if (CreateHandleTranslator(dbplh.lcPaths, &hht))
            {
               LONG l;

               tr = TR_SUCCESS;

               TRACE_OUT((TEXT("ReadPathList(): Reading %ld paths."),
                          dbplh.lcPaths));

               for (l = 0; l < dbplh.lcPaths; l++)
               {
                  tr = ReadPath(hcf, (PPATHLIST)hpl, hhtVolumes, hhtStrings,
                                hht);

                  if (tr != TR_SUCCESS)
                     break;
               }

               if (tr == TR_SUCCESS)
               {
                  PrepareForHandleTranslation(hht);
                  *phht = hht;

                  ASSERT(IS_VALID_HANDLE(hpl, PATHLIST));
                  ASSERT(IS_VALID_HANDLE(*phht, HANDLETRANS));
               }
               else
                  DestroyHandleTranslator(hht);
            }
            else
               tr = TR_OUT_OF_MEMORY;
         }

         DestroyHandleTranslator(hhtStrings);
      }

      DestroyHandleTranslator(hhtVolumes);
   }

   return(tr);
}


/* Macros
 *********/

/* extract array element */
#define ARRAY_ELEMENT(ppa, ai)            (((ppa)->ppcvArray)[(ai)])

/* Add pointers to array in sorted order? */

#define ADD_PTRS_IN_SORTED_ORDER(ppa)     IS_FLAG_SET((ppa)->dwFlags, PA_FL_SORTED_ADD)


/* Types
 ********/

/* pointer array flags */

typedef enum _ptrarrayflags
{
   /* Insert elements in sorted order. */

   PA_FL_SORTED_ADD        = 0x0001,

   /* flag combinations */

   ALL_PA_FLAGS            = PA_FL_SORTED_ADD
}
PTRARRAYFLAGS;

/* pointer array structure */

/*
 * Free elements in the ppcvArray[] array lie between indexes (aicPtrsUsed)
 * and (aiLast), inclusive.
 */

typedef struct _ptrarray
{
   /* elements to grow array by after it fills up */

   ARRAYINDEX aicPtrsToGrowBy;

   /* array flags */

   DWORD dwFlags;

   /* pointer to base of array */

   PCVOID *ppcvArray;

   /* index of last element allocated in array */

   ARRAYINDEX aicPtrsAllocated;

   /*
    * (We keep a count of the number of elements used instead of the index of
    * the last element used so that this value is 0 for an empty array, and not
    * some non-zero sentinel value.)
    */

   /* number of elements used in array */

   ARRAYINDEX aicPtrsUsed;
}
PTRARRAY;
DECLARE_STANDARD_TYPES(PTRARRAY);


/* Module Prototypes
 ********************/

BOOL AddAFreePtrToEnd(PPTRARRAY);
void PtrHeapSwap(PPTRARRAY, ARRAYINDEX, ARRAYINDEX);
void PtrHeapSift(PPTRARRAY, ARRAYINDEX, ARRAYINDEX, COMPARESORTEDPTRSPROC);


/*
** AddAFreePtrToEnd()
**
** Adds a free element to the end of an array.
**
** Arguments:     pa - pointer to array
**
** Returns:       TRUE if successful, or FALSE if not.
**
** Side Effects:  May grow the array.
*/
BOOL AddAFreePtrToEnd(PPTRARRAY pa)
{
   BOOL bResult;

   ASSERT(IS_VALID_STRUCT_PTR(pa, CPTRARRAY));

   /* Are there any free elements in the array? */

   if (pa->aicPtrsUsed < pa->aicPtrsAllocated)
      /* Yes.  Return the next free pointer. */
      bResult = TRUE;
   else
   {
      ARRAYINDEX aicNewPtrs = pa->aicPtrsAllocated + pa->aicPtrsToGrowBy;
      PCVOID *ppcvArray;

      bResult = FALSE;

      /* Try to grow the array. */

      /* Blow off unlikely overflow conditions as ASSERT()s. */

      ASSERT(pa->aicPtrsAllocated <= ARRAYINDEX_MAX + 1);
      ASSERT(ARRAYINDEX_MAX + 1 - pa->aicPtrsToGrowBy >= pa->aicPtrsAllocated);

      /* Try to grow the array. */

      if (ReallocateMemory(
            (PVOID)(pa->ppcvArray),
            pa->aicPtrsAllocated * sizeof(*ppcvArray),
            aicNewPtrs * sizeof(*ppcvArray),
            (PVOID *)(&ppcvArray)
            ))
      {
         /*
          * Array reallocated successfully.  Set up PTRARRAY fields, and return
          * the first free index.
          */

         pa->ppcvArray = ppcvArray;
         pa->aicPtrsAllocated = aicNewPtrs;

         bResult = TRUE;
      }
   }

   return(bResult);
}


/*
** PtrHeapSwap()
**
** Swaps two elements in an array.
**
** Arguments:     pa - pointer to array
**                aiFirst - index of first element
**                aiSecond - index of second element
**
** Returns:       void
**
** Side Effects:  none
*/
void PtrHeapSwap(PPTRARRAY pa, ARRAYINDEX ai1, ARRAYINDEX ai2)
{
   PCVOID pcvTemp;

   ASSERT(IS_VALID_STRUCT_PTR(pa, CPTRARRAY));
   ASSERT(ai1 >= 0);
   ASSERT(ai1 < pa->aicPtrsUsed);
   ASSERT(ai2 >= 0);
   ASSERT(ai2 < pa->aicPtrsUsed);

   pcvTemp = ARRAY_ELEMENT(pa, ai1);
   ARRAY_ELEMENT(pa, ai1) = ARRAY_ELEMENT(pa, ai2);
   ARRAY_ELEMENT(pa, ai2) = pcvTemp;
}


/*
** PtrHeapSift()
**
** Sifts an element down in an array until the partially ordered tree property
** is retored.
**
** Arguments:     pa - pointer to array
**                aiFirst - index of element to sift down
**                aiLast - index of last element in subtree
**                cspp - element comparison callback function to be called to
**                      compare elements
**
** Returns:       void
**
** Side Effects:  none
*/
void PtrHeapSift(PPTRARRAY pa, ARRAYINDEX aiFirst, ARRAYINDEX aiLast,
                         COMPARESORTEDPTRSPROC cspp)
{
   ARRAYINDEX ai;
   PCVOID pcvTemp;

   ASSERT(IS_VALID_STRUCT_PTR(pa, CPTRARRAY));
   ASSERT(IS_VALID_CODE_PTR(cspp, COMPARESORTEDPTRSPROC));

   ASSERT(aiFirst >= 0);
   ASSERT(aiFirst < pa->aicPtrsUsed);
   ASSERT(aiLast >= 0);
   ASSERT(aiLast < pa->aicPtrsUsed);

   ai = aiFirst * 2;

   pcvTemp = ARRAY_ELEMENT(pa, aiFirst);

   while (ai <= aiLast)
   {
      if (ai < aiLast &&
          (*cspp)(ARRAY_ELEMENT(pa, ai), ARRAY_ELEMENT(pa, ai + 1)) == CR_FIRST_SMALLER)
         ai++;

      if ((*cspp)(pcvTemp, ARRAY_ELEMENT(pa, ai)) != CR_FIRST_SMALLER)
         break;

      ARRAY_ELEMENT(pa, aiFirst) = ARRAY_ELEMENT(pa, ai);

      aiFirst = ai;

      ai *= 2;
   }

   ARRAY_ELEMENT(pa, aiFirst) = pcvTemp;
}


/*
** CreatePtrArray()
**
** Creates a pointer array.
**
** Arguments:     pcna - pointer to NEWPTRARRAY describing the array to be
**                        created
**
** Returns:       Handle to the new array if successful, or NULL if
**                unsuccessful.
**
** Side Effects:  none
*/
BOOL CreatePtrArray(PCNEWPTRARRAY pcna, PHPTRARRAY phpa)
{
   PCVOID *ppcvArray;

   ASSERT(IS_VALID_STRUCT_PTR(pcna, CNEWPTRARRAY));
   ASSERT(IS_VALID_WRITE_PTR(phpa, HPTRARRAY));

   /* Try to allocate the initial array. */

   *phpa = NULL;

   if (AllocateMemory(pcna->aicInitialPtrs * sizeof(*ppcvArray), (PVOID *)(&ppcvArray)))
   {
      PPTRARRAY pa;

      /* Try to allocate PTRARRAY structure. */

      if (AllocateMemory(sizeof(*pa), &pa))
      {
         /* Initialize PTRARRAY fields. */

         pa->aicPtrsToGrowBy = pcna->aicAllocGranularity;
         pa->ppcvArray = ppcvArray;
         pa->aicPtrsAllocated = pcna->aicInitialPtrs;
         pa->aicPtrsUsed = 0;

         /* Set flags. */

         if (IS_FLAG_SET(pcna->dwFlags, NPA_FL_SORTED_ADD))
            pa->dwFlags = PA_FL_SORTED_ADD;
         else
            pa->dwFlags = 0;

         *phpa = (HPTRARRAY)pa;

         ASSERT(IS_VALID_HANDLE(*phpa, PTRARRAY));
      }
      else
         /* Unlock and free array (ignoring return values). */
         FreeMemory((PVOID)(ppcvArray));
   }

   return(*phpa != NULL);
}


void DestroyPtrArray(HPTRARRAY hpa)
{
   ASSERT(IS_VALID_HANDLE(hpa, PTRARRAY));

   /* Free the array. */

   ASSERT(((PCPTRARRAY)hpa)->ppcvArray);

   FreeMemory((PVOID)(((PCPTRARRAY)hpa)->ppcvArray));

   /* Free PTRARRAY structure. */

   FreeMemory((PPTRARRAY)hpa);
}


/*
** InsertPtr()
**
** Adds an element to an array at a given index.
**
** Arguments:     hpa - handle to array that element is to be added to
**                aiInsert - index where new element is to be inserted
**                pcvNew - pointer to element to add to array
**
** Returns:       TRUE if the element was inserted successfully, or FALSE if
**                not.
**
** Side Effects:  The array may be grown.
**
** N.b., for an array marked PA_FL_SORTED_ADD, this index should only be
** retrieved using SearchSortedArray(), or the sorted order will be destroyed.
*/
BOOL InsertPtr(HPTRARRAY hpa, COMPARESORTEDPTRSPROC cspp, ARRAYINDEX aiInsert, PCVOID pcvNew)
{
   BOOL bResult;

   ASSERT(IS_VALID_HANDLE(hpa, PTRARRAY));
   ASSERT(aiInsert >= 0);
   ASSERT(aiInsert <= ((PCPTRARRAY)hpa)->aicPtrsUsed);

#ifdef DEBUG

   /* Make sure the correct index was given for insertion. */

   if (ADD_PTRS_IN_SORTED_ORDER((PCPTRARRAY)hpa))
   {
      ARRAYINDEX aiNew;

      EVAL(! SearchSortedArray(hpa, cspp, pcvNew, &aiNew));

      ASSERT(aiInsert == aiNew);
   }

#endif

   /* Get a free element in the array. */

   bResult = AddAFreePtrToEnd((PPTRARRAY)hpa);

   if (bResult)
   {
      ASSERT(((PCPTRARRAY)hpa)->aicPtrsUsed < ARRAYINDEX_MAX);

      /* Open a slot for the new element. */

      MoveMemory((PVOID)& ARRAY_ELEMENT((PPTRARRAY)hpa, aiInsert + 1),
                 & ARRAY_ELEMENT((PPTRARRAY)hpa, aiInsert),
                 (((PCPTRARRAY)hpa)->aicPtrsUsed - aiInsert) * sizeof(ARRAY_ELEMENT((PCPTRARRAY)hpa, 0)));

      /* Put the new element in the open slot. */

      ARRAY_ELEMENT((PPTRARRAY)hpa, aiInsert) = pcvNew;

      ((PPTRARRAY)hpa)->aicPtrsUsed++;
   }

   return(bResult);
}


/*
** AddPtr()
**
** Adds an element to an array, in sorted order if so specified at
** CreatePtrArray() time.
**
** Arguments:     hpa - handle to array that element is to be added to
**                pcvNew - pointer to element to be added to array
**                pai - pointer to ARRAYINDEX to be filled in with index of
**                      new element, may be NULL
**
** Returns:       TWINRESULT
**
** Side Effects:  The array may be grown.
*/
BOOL AddPtr(HPTRARRAY hpa, COMPARESORTEDPTRSPROC cspp, PCVOID pcvNew, PARRAYINDEX pai)
{
   BOOL bResult;
   ARRAYINDEX aiNew;

   ASSERT(IS_VALID_HANDLE(hpa, PTRARRAY));
   ASSERT(! pai || IS_VALID_WRITE_PTR(pai, ARRAYINDEX));

   /* Find out where the new element should go. */

   if (ADD_PTRS_IN_SORTED_ORDER((PCPTRARRAY)hpa))
      EVAL(! SearchSortedArray(hpa, cspp, pcvNew, &aiNew));
   else
      aiNew = ((PCPTRARRAY)hpa)->aicPtrsUsed;

   bResult = InsertPtr(hpa, cspp, aiNew, pcvNew);

   if (bResult && pai)
      *pai = aiNew;

   return(bResult);
}


/*
** DeletePtr()
**
** Removes an element from an element array.
**
** Arguments:     ha - handle to array
**                aiDelete - index of element to be deleted
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
void DeletePtr(HPTRARRAY hpa, ARRAYINDEX aiDelete)
{
   ASSERT(IS_VALID_HANDLE(hpa, PTRARRAY));
   ASSERT(aiDelete >= 0);
   ASSERT(aiDelete < ((PCPTRARRAY)hpa)->aicPtrsUsed);

   /*
    * Compact the element array by moving down all elements past the one being
    * deleted.
    */

   MoveMemory((PVOID)& ARRAY_ELEMENT((PPTRARRAY)hpa, aiDelete),
              & ARRAY_ELEMENT((PPTRARRAY)hpa, aiDelete + 1),
              (((PCPTRARRAY)hpa)->aicPtrsUsed - aiDelete - 1) * sizeof(ARRAY_ELEMENT((PCPTRARRAY)hpa, 0)));

   /* One less element used. */

   ((PPTRARRAY)hpa)->aicPtrsUsed--;
}


void DeleteAllPtrs(HPTRARRAY hpa)
{
   ASSERT(IS_VALID_HANDLE(hpa, PTRARRAY));

   ((PPTRARRAY)hpa)->aicPtrsUsed = 0;
}


/*
** GetPtrCount()
**
** Retrieves the number of elements in an element array.
**
** Arguments:     hpa - handle to array
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
ARRAYINDEX GetPtrCount(HPTRARRAY hpa)
{
   ASSERT(IS_VALID_HANDLE(hpa, PTRARRAY));

   return(((PCPTRARRAY)hpa)->aicPtrsUsed);
}


/*
** GetPtr()
**
** Retrieves an element from an array.
**
** Arguments:     hpa - handle to array
**                ai - index of element to be retrieved
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
PVOID GetPtr(HPTRARRAY hpa, ARRAYINDEX ai)
{
   ASSERT(IS_VALID_HANDLE(hpa, PTRARRAY));
   ASSERT(ai >= 0);
   ASSERT(ai < ((PCPTRARRAY)hpa)->aicPtrsUsed);

   return((PVOID)ARRAY_ELEMENT((PCPTRARRAY)hpa, ai));
}


/*
** SortPtrArray()
**
** Sorts an array.
**
** Arguments:     hpa - handle to element list to be sorted
**                cspp - pointer comparison callback function
**
** Returns:       void
**
** Side Effects:  none
**
** Uses heap sort.
*/
void SortPtrArray(HPTRARRAY hpa, COMPARESORTEDPTRSPROC cspp)
{
   ASSERT(IS_VALID_HANDLE(hpa, PTRARRAY));

   /* Are there any elements to sort (2 or more)? */

   if (((PCPTRARRAY)hpa)->aicPtrsUsed > 1)
   {
      ARRAYINDEX ai;
      ARRAYINDEX aiLastUsed = ((PCPTRARRAY)hpa)->aicPtrsUsed - 1;

      /* Yes.  Create partially ordered tree. */

      for (ai = aiLastUsed / 2; ai >= 0; ai--)
         PtrHeapSift((PPTRARRAY)hpa, ai, aiLastUsed, cspp);

      for (ai = aiLastUsed; ai >= 1; ai--)
      {
         /* Remove minimum from front of heap. */

         PtrHeapSwap((PPTRARRAY)hpa, 0, ai);

         /* Reestablish partially ordered tree. */

         PtrHeapSift((PPTRARRAY)hpa, 0, ai - 1, cspp);
      }
   }

   ASSERT(IsPtrArrayInSortedOrder((PCPTRARRAY)hpa, cspp));
}


/*
** SearchSortedArray()
**
** Searches an array for a target element using binary search.  If several
** adjacent elements match the target element, the index of the first matching
** element is returned.
**
** Arguments:     hpa - handle to array to be searched
**                cspp - element comparison callback function to be called to
**                      compare the target element with an element from the
**                      array, the callback function is called as:
**
**                         (*cspp)(pcvTarget, pcvPtrFromList)
**
**                pcvTarget - pointer to target element to search for
**                pbFound - pointer to BOOL to be filled in with TRUE if the
**                          target element is found, or FALSE if not
**                paiTarget - pointer to ARRAYINDEX to be filled in with the
**                            index of the first element matching the target
**                            element if found, otherwise filled in with the
**                            index where the target element should be
**                            inserted
**
** Returns:       TRUE if target element is found.  FALSE if not.
**
** Side Effects:  none
**
** We use a private version of SearchSortedArray() instead of the CRT bsearch()
** function since we want it to return the insertion index of the target
** element if the target element is not found.
*/
BOOL SearchSortedArray(HPTRARRAY hpa, COMPARESORTEDPTRSPROC cspp,
                                   PCVOID pcvTarget, PARRAYINDEX paiTarget)
{
   BOOL bFound;

   ASSERT(IS_VALID_HANDLE(hpa, PTRARRAY));
   ASSERT(IS_VALID_CODE_PTR(cspp, COMPARESORTEDPTRSPROC));
   ASSERT(IS_VALID_WRITE_PTR(paiTarget, ARRAYINDEX));

   ASSERT(ADD_PTRS_IN_SORTED_ORDER((PCPTRARRAY)hpa));
#if 0
   ASSERT(IsPtrArrayInSortedOrder((PCPTRARRAY)hpa, ((PCPTRARRAY)hpa)->cspp));
#endif

   bFound = FALSE;

   /* Are there any elements to search through? */

   if (((PCPTRARRAY)hpa)->aicPtrsUsed > 0)
   {
      ARRAYINDEX aiLow = 0;
      ARRAYINDEX aiMiddle = 0;
      ARRAYINDEX aiHigh = ((PCPTRARRAY)hpa)->aicPtrsUsed - 1;
      COMPARISONRESULT cr = CR_EQUAL;

      /* Yes.  Search for the target element. */

      /*
       * At the end of the penultimate iteration of this loop:
       *
       * aiLow == aiMiddle == aiHigh.
       */

      ASSERT(aiHigh <= ARRAYINDEX_MAX);

      while (aiLow <= aiHigh)
      {
         aiMiddle = (aiLow + aiHigh) / 2;

         cr = (*cspp)(pcvTarget, ARRAY_ELEMENT((PCPTRARRAY)hpa, aiMiddle));

         if (cr == CR_FIRST_SMALLER)
            aiHigh = aiMiddle - 1;
         else if (cr == CR_FIRST_LARGER)
            aiLow = aiMiddle + 1;
         else
         {
            /*
             * Found a match at index aiMiddle.  Search back for first match.
             */

            bFound = TRUE;

            while (aiMiddle > 0)
            {
               if ((*cspp)(pcvTarget, ARRAY_ELEMENT((PCPTRARRAY)hpa, aiMiddle - 1)) != CR_EQUAL)
                  break;
               else
                  aiMiddle--;
            }

            break;
         }
      }

      /*
       * Return the index of the target if found, or the index where the target
       * should be inserted if not found.
       */

      /*
       * If (cr == CR_FIRST_LARGER), the insertion index is aiLow.
       *
       * If (cr == CR_FIRST_SMALLER), the insertion index is aiMiddle.
       *
       * If (cr == CR_EQUAL), the insertion index is aiMiddle.
       */

      if (cr == CR_FIRST_LARGER)
         *paiTarget = aiLow;
      else
         *paiTarget = aiMiddle;
   }
   else
      /*
       * No.  The target element cannot be found in an empty array.  It should
       * be inserted as the first element.
       */
      *paiTarget = 0;

   ASSERT(*paiTarget <= ((PCPTRARRAY)hpa)->aicPtrsUsed);

   return(bFound);
}


/*
** LinearSearchArray()
**
** Searches an array for a target element using binary search.  If several
** adjacent elements match the target element, the index of the first matching
** element is returned.
**
** Arguments:     hpa - handle to array to be searched
**                cupp - element comparison callback function to be called to
**                       compare the target element with an element from the
**                       array, the callback function is called as:
**
**                         (*cupp)(pvTarget, pvPtrFromList)
**
**                      the callback function should return a value based upon
**                      the result of the element comparison as follows:
**
**                         FALSE, pvTarget == pvPtrFromList
**                         TRUE,  pvTarget != pvPtrFromList
**
**                pvTarget - far element to target element to search for
**                paiTarget - far element to ARRAYINDEX to be filled in with
**                            the index of the first matching element if
**                            found, otherwise filled in with index where
**                            element should be inserted
**
** Returns:       TRUE if target element is found.  FALSE if not.
**
** Side Effects:  none
**
** We use a private version of LinearSearchForPtr() instead of the CRT _lfind()
** function since we want it to return the insertion index of the target
** element if the target element is not found.
**
** If the target element is not found the insertion index returned is the first
** element after the last used element in the array.
*/
BOOL LinearSearchArray(HPTRARRAY hpa, COMPAREUNSORTEDPTRSPROC cupp,
                                   PCVOID pcvTarget, PARRAYINDEX paiTarget)
{
   BOOL bFound;
   ARRAYINDEX ai;

   ASSERT(IS_VALID_HANDLE(hpa, PTRARRAY) &&
          (! cupp || IS_VALID_CODE_PTR(cupp, COMPPTRSPROC)) &&
          IS_VALID_WRITE_PTR(paiTarget, ARRAYINDEX));

   bFound = FALSE;

   for (ai = 0; ai < ((PCPTRARRAY)hpa)->aicPtrsUsed; ai++)
   {
      if (! (*cupp)(pcvTarget, ARRAY_ELEMENT((PCPTRARRAY)hpa, ai)))
      {
         bFound = TRUE;
         break;
      }
   }

   if (bFound)
      *paiTarget = ai;

   return(bFound);
}


/* Macros
 *********/

#define ARRAY_ELEMENT_SIZE(hpa, ai, es)     (((PBYTE)hpa)[(ai) * (es)])


/* Module Prototypes
 ********************/

void HeapSwap(PVOID, LONG, LONG, size_t, PVOID);
void HeapSift(PVOID, LONG, LONG, size_t, COMPARESORTEDELEMSPROC, PVOID);


/*
** HeapSwap()
**
** Swaps two elements of an array.
**
** Arguments:     pvArray - pointer to array
**                li1 - index of first element
**                li2 - index of second element
**                stElemSize - length of element in bytes
**                pvTemp - pointer to temporary buffer of at least stElemSize
**                          bytes used for swapping
**
** Returns:       void
**
** Side Effects:  none
*/
void HeapSwap(PVOID pvArray, LONG li1, LONG li2,
                           size_t stElemSize, PVOID pvTemp)
{
   ASSERT(li1 >= 0);
   ASSERT(li2 >= 0);
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pvArray, VOID, (max(li1, li2) + 1) * stElemSize));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pvTemp, VOID, stElemSize));

   CopyMemory(pvTemp, & ARRAY_ELEMENT_SIZE(pvArray, li1, stElemSize), stElemSize);
   CopyMemory(& ARRAY_ELEMENT_SIZE(pvArray, li1, stElemSize), & ARRAY_ELEMENT_SIZE(pvArray, li2, stElemSize), stElemSize);
   CopyMemory(& ARRAY_ELEMENT_SIZE(pvArray, li2, stElemSize), pvTemp, stElemSize);
}


/*
** HeapSift()
**
** Sifts an element down in an array until the partially ordered tree property
** is restored.
**
** Arguments:     hppTable - pointer to array
**                liFirst - index of first element to sift down
**                liLast - index of last element in subtree
**                cep - pointer comparison callback function to be called to
**                      compare elements
**
** Returns:       void
**
** Side Effects:  none
*/
void HeapSift(PVOID pvArray, LONG liFirst, LONG liLast,
                           size_t stElemSize, COMPARESORTEDELEMSPROC cep, PVOID pvTemp)
{
   LONG li;

   ASSERT(liFirst >= 0);
   ASSERT(liLast >= 0);
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pvArray, VOID, (max(liFirst, liLast) + 1) * stElemSize));
   ASSERT(IS_VALID_CODE_PTR(cep, COMPARESORTEDELEMSPROC));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pvTemp, VOID, stElemSize));

   li = liFirst * 2;

   CopyMemory(pvTemp, & ARRAY_ELEMENT_SIZE(pvArray, liFirst, stElemSize), stElemSize);

   while (li <= liLast)
   {
      if (li < liLast &&
          (*cep)(& ARRAY_ELEMENT_SIZE(pvArray, li, stElemSize), & ARRAY_ELEMENT_SIZE(pvArray, li + 1, stElemSize)) == CR_FIRST_SMALLER)
         li++;

      if ((*cep)(pvTemp, & ARRAY_ELEMENT_SIZE(pvArray, li, stElemSize)) != CR_FIRST_SMALLER)
         break;

      CopyMemory(& ARRAY_ELEMENT_SIZE(pvArray, liFirst, stElemSize), & ARRAY_ELEMENT_SIZE(pvArray, li, stElemSize), stElemSize);

      liFirst = li;

      li *= 2;
   }

   CopyMemory(& ARRAY_ELEMENT_SIZE(pvArray, liFirst, stElemSize), pvTemp, stElemSize);
}


#ifdef DEBUG

/*
** InSortedOrder()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
BOOL InSortedOrder(PVOID pvArray, LONG lcElements,
                                size_t stElemSize, COMPARESORTEDELEMSPROC cep)
{
   BOOL bResult = TRUE;

   ASSERT(lcElements >= 0);
   ASSERT(IS_VALID_READ_BUFFER_PTR(pvArray, VOID, lcElements * stElemSize));
   ASSERT(IS_VALID_CODE_PTR(cep, COMPARESORTEDELEMSPROC));

   if (lcElements > 1)
   {
      LONG li;

      for (li = 0; li < lcElements - 1; li++)
      {
         if ((*cep)(& ARRAY_ELEMENT_SIZE(pvArray, li, stElemSize),
                    & ARRAY_ELEMENT_SIZE(pvArray, li + 1, stElemSize))
             == CR_FIRST_LARGER)
         {
            bResult = FALSE;
            ERROR_OUT((TEXT("InSortedOrder(): Element [%ld] %#lx > following element [%ld] %#lx."),
                       li,
                       & ARRAY_ELEMENT_SIZE(pvArray, li, stElemSize),
                       li + 1,
                       & ARRAY_ELEMENT_SIZE(pvArray, li + 1, stElemSize)));
            break;
         }
      }
   }

   return(bResult);
}

#endif


/*
** HeapSort()
**
** Sorts an array.  Thanks to Rob's Dad for the cool heap sort algorithm.
**
** Arguments:     pvArray - pointer to base of array
**                lcElements - number of elements in array
**                stElemSize - length of element in bytes
**                cep - element comparison callback function
**                pvTemp - pointer to temporary buffer of at least stElemSize
**                          bytes used for swapping
**
** Returns:       void
**
** Side Effects:  none
*/
void HeapSort(PVOID pvArray, LONG lcElements, size_t stElemSize,
                          COMPARESORTEDELEMSPROC cep, PVOID pvTemp)
{
   ASSERT(lcElements >= 0);
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pvArray, VOID, lcElements * stElemSize));
   ASSERT(IS_VALID_CODE_PTR(cep, COMPARESORTEDELEMSPROC));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pvTemp, VOID, stElemSize));

   /* Are there any elements to sort (2 or more)? */

   if (lcElements > 1)
   {
      LONG li;
      LONG liLastUsed = lcElements - 1;

      /* Yes.  Create partially ordered tree. */

      for (li = liLastUsed / 2; li >= 0; li--)
         HeapSift(pvArray, li, liLastUsed, stElemSize, cep, pvTemp);

      for (li = liLastUsed; li >= 1; li--)
      {
         /* Remove minimum from front of heap. */

         HeapSwap(pvArray, 0, li, stElemSize, pvTemp);

         /* Reestablish partially ordered tree. */

         HeapSift(pvArray, 0, li - 1, stElemSize, cep, pvTemp);
      }
   }

   ASSERT(InSortedOrder(pvArray, lcElements, stElemSize, cep));
}


/*
** BinarySearch()
**
** Searches an array for a given element.
**
** Arguments:     pvArray - pointer to base of array
**                lcElements - number of elements in array
**                stElemSize - length of element in bytes
**                cep - element comparison callback function
**                pvTarget - pointer to target element to search for
**                pliTarget - pointer to LONG to be filled in with index of
**                             target element if found
**
** Returns:       TRUE if target element found, or FALSE if not.
**
** Side Effects:  none
*/
BOOL BinarySearch(PVOID pvArray, LONG lcElements,
                              size_t stElemSize, COMPARESORTEDELEMSPROC cep,
                              PCVOID pcvTarget, PLONG pliTarget)
{
   BOOL bFound = FALSE;

   ASSERT(lcElements >= 0);
   ASSERT(IS_VALID_READ_BUFFER_PTR(pvArray, VOID, lcElements * stElemSize));
   ASSERT(IS_VALID_CODE_PTR(cep, COMPARESORTEDELEMSPROC));
   ASSERT(IS_VALID_READ_BUFFER_PTR(pcvTarget, VOID, stElemSize));
   ASSERT(IS_VALID_WRITE_PTR(pliTarget, LONG));

   /* Are there any elements to search through? */

   if (lcElements > 0)
   {
      LONG liLow = 0;
      LONG liMiddle = 0;
      LONG liHigh = lcElements - 1;
      COMPARISONRESULT cr = CR_EQUAL;

      /* Yes.  Search for the target element. */

      /*
       * At the end of the penultimate iteration of this loop:
       *
       * liLow == liMiddle == liHigh.
       */

      while (liLow <= liHigh)
      {
         liMiddle = (liLow + liHigh) / 2;

         cr = (*cep)(pcvTarget, & ARRAY_ELEMENT_SIZE(pvArray, liMiddle, stElemSize));

         if (cr == CR_FIRST_SMALLER)
            liHigh = liMiddle - 1;
         else if (cr == CR_FIRST_LARGER)
            liLow = liMiddle + 1;
         else
         {
            *pliTarget = liMiddle;
            bFound = TRUE;
            break;
         }
      }
   }

   return(bFound);
}


/* Types
 ********/

/* string table */

typedef struct _stringtable
{
   /* number of hash buckets in string table */

   HASHBUCKETCOUNT hbc;

   /* pointer to array of hash buckets (HLISTs) */

   PHLIST phlistHashBuckets;
}
STRINGTABLE;
DECLARE_STANDARD_TYPES(STRINGTABLE);

/* string heap structure */

typedef struct _string
{
   /* lock count of string */

   ULONG ulcLock;

   /* actual string */

   TCHAR string[1];
}
BFCSTRING;
DECLARE_STANDARD_TYPES(BFCSTRING);

/* string table database structure header */

typedef struct _stringtabledbheader
{
   /*
    * length of longest string in string table, not including null terminator
    */

   DWORD dwcbMaxStringLen;

   /* number of strings in string table */

   LONG lcStrings;
}
STRINGTABLEDBHEADER;
DECLARE_STANDARD_TYPES(STRINGTABLEDBHEADER);

/* database string header */

typedef struct _dbstringheader
{
   /* old handle to this string */

   HSTRING hsOld;
}
DBSTRINGHEADER;
DECLARE_STANDARD_TYPES(DBSTRINGHEADER);


/* Module Prototypes
 ********************/

COMPARISONRESULT StringSearchCmp(PCVOID, PCVOID);
COMPARISONRESULT StringSortCmp(PCVOID, PCVOID);
BOOL UnlockString(PBFCSTRING);
BOOL FreeStringWalker(PVOID, PVOID);
void FreeHashBucket(HLIST);
TWINRESULT WriteHashBucket(HCACHEDFILE, HLIST, PLONG, PDWORD);
TWINRESULT WriteString(HCACHEDFILE, HNODE, PBFCSTRING, PDWORD);
TWINRESULT ReadString(HCACHEDFILE, HSTRINGTABLE, HHANDLETRANS, LPTSTR, DWORD);
TWINRESULT SlowReadString(HCACHEDFILE, LPTSTR, DWORD);


/*
** StringSearchCmp()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
COMPARISONRESULT StringSearchCmp(PCVOID pcszPath, PCVOID pcstring)
{
   ASSERT(IS_VALID_STRING_PTR(pcszPath, CSTR));
   ASSERT(IS_VALID_STRUCT_PTR(pcstring, PCBFCSTRING));

   return(MapIntToComparisonResult(lstrcmp((LPCTSTR)pcszPath,
                                           (LPCTSTR)&(((PCBFCSTRING)pcstring)->string))));
}


COMPARISONRESULT StringSortCmp(PCVOID pcstring1, PCVOID pcstring2)
{
   ASSERT(IS_VALID_STRUCT_PTR(pcstring1, PCBFCSTRING));
   ASSERT(IS_VALID_STRUCT_PTR(pcstring2, PCBFCSTRING));

   return(MapIntToComparisonResult(lstrcmp((LPCTSTR)&(((PCBFCSTRING)pcstring1)->string),
                                           (LPCTSTR)&(((PCBFCSTRING)pcstring2)->string))));
}


BOOL UnlockString(PBFCSTRING pstring)
{
   ASSERT(IS_VALID_STRUCT_PTR(pstring, PCBFCSTRING));

   /* Is the lock count going to underflow? */

   if (EVAL(pstring->ulcLock > 0))
      pstring->ulcLock--;

   return(pstring->ulcLock > 0);
}


BOOL FreeStringWalker(PVOID pstring, PVOID pvUnused)
{
   ASSERT(IS_VALID_STRUCT_PTR(pstring, PCBFCSTRING));
   ASSERT(! pvUnused);

   FreeMemory(pstring);

   return(TRUE);
}


/*
** FreeHashBucket()
**
** Frees the strings in a hash bucket, and the hash bucket's string list.
**
** Arguments:     hlistHashBucket - handle to hash bucket's list of strings
**
** Returns:       void
**
** Side Effects:  none
**
** N.b., this function ignores the lock counts of the strings in the hash
** bucket.  All strings in the hash bucket are freed.
*/
void FreeHashBucket(HLIST hlistHashBucket)
{
   ASSERT(! hlistHashBucket || IS_VALID_HANDLE(hlistHashBucket, LIST));

   /* Are there any strings in this hash bucket to delete? */

   if (hlistHashBucket)
   {
      /* Yes.  Delete all strings in list. */

      EVAL(WalkList(hlistHashBucket, &FreeStringWalker, NULL));

      /* Delete hash bucket string list. */

      DestroyList(hlistHashBucket);
   }
}


/*
** MyGetStringLen()
**
** Retrieves the length of a string in a string table.
**
** Arguments:     pcstring - pointer to string whose length is to be
**                            determined
**
** Returns:       Length of string in bytes, not including null terminator.
**
** Side Effects:  none
*/
int MyGetStringLen(PCBFCSTRING pcstring)
{
   ASSERT(IS_VALID_STRUCT_PTR(pcstring, PCBFCSTRING));

   return(lstrlen(pcstring->string) * sizeof(TCHAR));
}


TWINRESULT WriteHashBucket(HCACHEDFILE hcf,
                                           HLIST hlistHashBucket,
                                           PLONG plcStrings,
                                           PDWORD pdwcbMaxStringLen)
{
   TWINRESULT tr = TR_SUCCESS;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(! hlistHashBucket || IS_VALID_HANDLE(hlistHashBucket, LIST));
   ASSERT(IS_VALID_WRITE_PTR(plcStrings, LONG));
   ASSERT(IS_VALID_WRITE_PTR(pdwcbMaxStringLen, DWORD));

   /* Any strings in this hash bucket? */

   *plcStrings = 0;
   *pdwcbMaxStringLen = 0;

   if (hlistHashBucket)
   {
      BOOL bContinue;
      HNODE hnode;

      /* Yes.  Walk hash bucket, saving each string. */

      for (bContinue = GetFirstNode(hlistHashBucket, &hnode);
           bContinue;
           bContinue = GetNextNode(hnode, &hnode))
      {
         PBFCSTRING pstring;

         pstring = (PBFCSTRING)GetNodeData(hnode);

         ASSERT(IS_VALID_STRUCT_PTR(pstring, PCBFCSTRING));

         /*
          * As a sanity check, don't save any string with a lock count of 0.  A
          * 0 lock count implies that the string has not been referenced since
          * it was restored from the database, or something is broken.
          */

         if (pstring->ulcLock > 0)
         {
            DWORD dwcbStringLen;

            tr = WriteString(hcf, hnode, pstring, &dwcbStringLen);

            if (tr == TR_SUCCESS)
            {
               if (dwcbStringLen > *pdwcbMaxStringLen)
                  *pdwcbMaxStringLen = dwcbStringLen;

               ASSERT(*plcStrings < LONG_MAX);
               (*plcStrings)++;
            }
            else
               break;
         }
         else
            ERROR_OUT((TEXT("WriteHashBucket(): String \"%s\" has 0 lock count and will not be saved."),
                       pstring->string));
      }
   }

   return(tr);
}


TWINRESULT WriteString(HCACHEDFILE hcf, HNODE hnodeOld,
                                    PBFCSTRING pstring, PDWORD pdwcbStringLen)
{
   TWINRESULT tr = TR_BRIEFCASE_WRITE_FAILED;
   DBSTRINGHEADER dbsh;

   /* (+ 1) for null terminator. */

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_HANDLE(hnodeOld, NODE));
   ASSERT(IS_VALID_STRUCT_PTR(pstring, PCBFCSTRING));
   ASSERT(IS_VALID_READ_BUFFER_PTR(pstring, BFCSTRING, sizeof(BFCSTRING) + MyGetStringLen(pstring) + sizeof(TCHAR) - sizeof(pstring->string)));
   ASSERT(IS_VALID_WRITE_PTR(pdwcbStringLen, DWORD));

   /* Create string header. */

   dbsh.hsOld = (HSTRING)hnodeOld;

   /* Save string header and string. */

   if (WriteToCachedFile(hcf, (PCVOID)&dbsh, sizeof(dbsh), NULL))
   {
      LPSTR pszAnsi;

      /* (+ 1) for null terminator. */

      *pdwcbStringLen = MyGetStringLen(pstring) + SIZEOF(TCHAR);

      // If its unicode, convert the string to ansi before writing it out

      {
          pszAnsi = LocalAlloc(LPTR, *pdwcbStringLen);
          if (NULL == pszAnsi)
          {
            return tr;
          }
          WideCharToMultiByte( OurGetACP(), 0, pstring->string, -1, pszAnsi, *pdwcbStringLen, NULL, NULL);

          // We should always have a string at this point that can be converted losslessly

          #ifdef DEBUG
          {
                WCHAR szUnicode[MAX_PATH*2];
                MultiByteToWideChar( OurGetACP(), 0, pszAnsi, -1, szUnicode, ARRAYSIZE(szUnicode));
                ASSERT(0 == lstrcmp(szUnicode, pstring->string));
          }
          #endif

          if (WriteToCachedFile(hcf, (PCVOID) pszAnsi, lstrlenA(pszAnsi) + 1, NULL))
            tr = TR_SUCCESS;

          LocalFree(pszAnsi);
     }

   }

   return(tr);
}


TWINRESULT ReadString(HCACHEDFILE hcf, HSTRINGTABLE hst,
                                      HHANDLETRANS hht, LPTSTR pszStringBuf,
                                      DWORD dwcbStringBufLen)
{
   TWINRESULT tr;
   DBSTRINGHEADER dbsh;
   DWORD dwcbRead;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_HANDLE(hst, STRINGTABLE));
   ASSERT(IS_VALID_HANDLE(hht, HANDLETRANS));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszStringBuf, STR, (UINT)dwcbStringBufLen));

   if (ReadFromCachedFile(hcf, &dbsh, sizeof(dbsh), &dwcbRead) &&
       dwcbRead == sizeof(dbsh))
   {
      tr = SlowReadString(hcf, pszStringBuf, dwcbStringBufLen);

      if (tr == TR_SUCCESS)
      {
         HSTRING hsNew;

         if (AddString(pszStringBuf, hst, GetHashBucketIndex, &hsNew))
         {
            /*
             * We must undo the LockString() performed by AddString() to
             * maintain the correct string lock count.  N.b., the lock count of
             * a string may be > 0 even after unlocking since the client may
             * already have added the string to the given string table.
             */

            UnlockString((PBFCSTRING)GetNodeData((HNODE)hsNew));

            if (! AddHandleToHandleTranslator(hht, (HGENERIC)(dbsh.hsOld), (HGENERIC)hsNew))
            {
               DeleteNode((HNODE)hsNew);

               tr = TR_CORRUPT_BRIEFCASE;
            }
         }
         else
            tr = TR_OUT_OF_MEMORY;
      }
   }
   else
      tr = TR_CORRUPT_BRIEFCASE;

   return(tr);
}


TWINRESULT SlowReadString(HCACHEDFILE hcf, LPTSTR pszStringBuf,
                                          DWORD dwcbStringBufLen)
{
   TWINRESULT tr = TR_CORRUPT_BRIEFCASE;
   LPTSTR pszStringBufEnd;
   DWORD dwcbRead;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszStringBuf, STR, (UINT)dwcbStringBufLen));

   pszStringBufEnd = pszStringBuf + dwcbStringBufLen;

   // The database strings are always written ANSI, so if we are running unicode,
   // we need to convert as we go

   {
        LPSTR pszAnsiEnd;
        LPSTR pszAnsiStart;
        LPSTR pszAnsi = LocalAlloc(LPTR, dwcbStringBufLen);
        pszAnsiStart  = pszAnsi;
        pszAnsiEnd    = pszAnsi + dwcbStringBufLen;

        if (NULL == pszAnsi)
        {
            return tr;
        }

        while (pszAnsi < pszAnsiEnd &&
              ReadFromCachedFile(hcf, pszAnsi, sizeof(*pszAnsi), &dwcbRead) &&
              dwcbRead == sizeof(*pszAnsi))
        {
            if (*pszAnsi)
                pszAnsi++;
            else
            {
                tr = TR_SUCCESS;
                break;
            }
        }

       if (tr == TR_SUCCESS)
       {
            MultiByteToWideChar( OurGetACP(), 0, pszAnsiStart, -1, pszStringBuf, dwcbStringBufLen / sizeof(TCHAR));
       }

       LocalFree(pszAnsiStart);
    }

   return(tr);
}


/*
** CreateStringTable()
**
** Creates a new string table.
**
** Arguments:     pcnszt - pointer to NEWSTRINGTABLE descibing string table to
**                          be created
**
** Returns:       Handle to new string table if successful, or NULL if
**                unsuccessful.
**
** Side Effects:  none
*/
BOOL CreateStringTable(PCNEWSTRINGTABLE pcnszt,
                                     PHSTRINGTABLE phst)
{
   PSTRINGTABLE pst;

   ASSERT(IS_VALID_STRUCT_PTR(pcnszt, CNEWSTRINGTABLE));
   ASSERT(IS_VALID_WRITE_PTR(phst, HSTRINGTABLE));

   /* Try to allocate new string table structure. */

   *phst = NULL;

   if (AllocateMemory(sizeof(*pst), &pst))
   {
      PHLIST phlistHashBuckets;

      /* Try to allocate hash bucket array. */

      if (AllocateMemory(pcnszt->hbc * sizeof(*phlistHashBuckets), (PVOID *)(&phlistHashBuckets)))
      {
         HASHBUCKETCOUNT bc;

         /* Successs!  Initialize STRINGTABLE fields. */

         pst->phlistHashBuckets = phlistHashBuckets;
         pst->hbc = pcnszt->hbc;

         /* Initialize all hash buckets to NULL. */

         for (bc = 0; bc < pcnszt->hbc; bc++)
            phlistHashBuckets[bc] = NULL;

         *phst = (HSTRINGTABLE)pst;

         ASSERT(IS_VALID_HANDLE(*phst, STRINGTABLE));
      }
      else
         /* Free string table structure. */
         FreeMemory(pst);
   }

   return(*phst != NULL);
}


void DestroyStringTable(HSTRINGTABLE hst)
{
   HASHBUCKETCOUNT bc;

   ASSERT(IS_VALID_HANDLE(hst, STRINGTABLE));

   /* Traverse array of hash bucket heads, freeing hash bucket strings. */

   for (bc = 0; bc < ((PSTRINGTABLE)hst)->hbc; bc++)
      FreeHashBucket(((PSTRINGTABLE)hst)->phlistHashBuckets[bc]);

   /* Free array of hash buckets. */

   FreeMemory(((PSTRINGTABLE)hst)->phlistHashBuckets);

   /* Free string table structure. */

   FreeMemory((PSTRINGTABLE)hst);
}


/*
** AddString()
**
** Adds a string to a string table.
**
** Arguments:     pcsz - pointer to string to be added
**                hst - handle to string table that string is to be added to
**
** Returns:       Handle to new string if successful, or NULL if unsuccessful.
**
** Side Effects:  none
*/
BOOL AddString(LPCTSTR pcsz, HSTRINGTABLE hst,
                           STRINGTABLEHASHFUNC pfnHashFunc, PHSTRING phs)
{
   BOOL bResult;
   HASHBUCKETCOUNT hbcNew;
   BOOL bFound;
   HNODE hnode;
   PHLIST phlistHashBucket;

   ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));
   ASSERT(IS_VALID_HANDLE(hst, STRINGTABLE));
   ASSERT(IS_VALID_CODE_PTR(pfnHashFunc, STRINGTABLEHASHFUNC));
   ASSERT(IS_VALID_WRITE_PTR(phs, HSTRING));

   /* Find appropriate hash bucket. */

   hbcNew = pfnHashFunc(pcsz, ((PSTRINGTABLE)hst)->hbc);

   ASSERT(hbcNew < ((PSTRINGTABLE)hst)->hbc);

   phlistHashBucket = &(((PSTRINGTABLE)hst)->phlistHashBuckets[hbcNew]);

   if (*phlistHashBucket)
   {
      /* Search the hash bucket for the string. */

      bFound = SearchSortedList(*phlistHashBucket, &StringSearchCmp, pcsz,
                                &hnode);
      bResult = TRUE;
   }
   else
   {
      NEWLIST nl;

      /* Create a string list for this hash bucket. */

      bFound = FALSE;

      nl.dwFlags = NL_FL_SORTED_ADD;

      bResult = CreateList(&nl, phlistHashBucket);
   }

   /* Do we have a hash bucket for the string? */

   if (bResult)
   {
      /* Yes.  Is the string already in the hash bucket? */

      if (bFound)
      {
         /* Yes. */

         LockString((HSTRING)hnode);
         *phs = (HSTRING)hnode;
      }
      else
      {
         /* No.  Create it. */

         PBFCSTRING pstringNew;

         /* (+ 1) for null terminator. */

         bResult = AllocateMemory(sizeof(*pstringNew) - sizeof(pstringNew->string)
                                  + (lstrlen(pcsz) + 1) * sizeof(TCHAR), &pstringNew);

         if (bResult)
         {
            HNODE hnodeNew;

            /* Set up BFCSTRING fields. */

            pstringNew->ulcLock = 1;
            lstrcpy(pstringNew->string, pcsz);

            /* What's up with this string, Doc? */

            bResult = AddNode(*phlistHashBucket, StringSortCmp, pstringNew, &hnodeNew);

            /* Was the new string added to the hash bucket successfully? */

            if (bResult)
               /* Yes. */
               *phs = (HSTRING)hnodeNew;
            else
               /* No. */
               FreeMemory(pstringNew);
         }
      }
   }

   ASSERT(! bResult ||
          IS_VALID_HANDLE(*phs, BFCSTRING));

   return(bResult);
}


/*
** DeleteString()
**
** Decrements a string's lock count.  If the lock count goes to 0, the string
** is deleted from its string table.
**
** Arguments:     hs - handle to the string to be deleted
**
** Returns:       void
**
** Side Effects:  none
*/
void DeleteString(HSTRING hs)
{
   PBFCSTRING pstring;

   ASSERT(IS_VALID_HANDLE(hs, BFCSTRING));

   pstring = (PBFCSTRING)GetNodeData((HNODE)hs);

   /* Delete string completely? */

   if (! UnlockString(pstring))
   {
      /* Yes.  Remove the string node from the hash bucket's list. */

      DeleteNode((HNODE)hs);

      FreeMemory(pstring);
   }
}


/*
** LockString()
**
** Increments a string's lock count.
**
** Arguments:     hs - handle to string whose lock count is to be incremented
**
** Returns:       void
**
** Side Effects:  none
*/
void LockString(HSTRING hs)
{
   PBFCSTRING pstring;

   ASSERT(IS_VALID_HANDLE(hs, BFCSTRING));

   /* Increment lock count. */

   pstring = (PBFCSTRING)GetNodeData((HNODE)hs);

   ASSERT(pstring->ulcLock < ULONG_MAX);
   pstring->ulcLock++;
}


COMPARISONRESULT CompareStringsI(HSTRING hs1, HSTRING hs2)
{
   ASSERT(IS_VALID_HANDLE(hs1, BFCSTRING));
   ASSERT(IS_VALID_HANDLE(hs2, BFCSTRING));

   /* This comparison works across string tables. */

   return(MapIntToComparisonResult(lstrcmpi(((PCBFCSTRING)GetNodeData((HNODE)hs1))->string,
                                            ((PCBFCSTRING)GetNodeData((HNODE)hs2))->string)));
}


/*
** GetBfcString()
**
** Retrieves a pointer to a string in a string table.
**
** Arguments:     hs - handle to the string to be retrieved
**
** Returns:       Pointer to string.
**
** Side Effects:  none
*/
LPCTSTR GetBfcString(HSTRING hs)
{
   PBFCSTRING pstring;

   ASSERT(IS_VALID_HANDLE(hs, BFCSTRING));

   pstring = (PBFCSTRING)GetNodeData((HNODE)hs);

   return((LPCTSTR)&(pstring->string));
}


TWINRESULT WriteStringTable(HCACHEDFILE hcf, HSTRINGTABLE hst)
{
   TWINRESULT tr = TR_BRIEFCASE_WRITE_FAILED;
   DWORD dwcbStringTableDBHeaderOffset;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_HANDLE(hst, STRINGTABLE));

   /* Save initial file poisition. */

   dwcbStringTableDBHeaderOffset = GetCachedFilePointerPosition(hcf);

   if (dwcbStringTableDBHeaderOffset != INVALID_SEEK_POSITION)
   {
      STRINGTABLEDBHEADER stdbh;

      /* Leave space for the string table header. */

      ZeroMemory(&stdbh, sizeof(stdbh));

      if (WriteToCachedFile(hcf, (PCVOID)&stdbh, sizeof(stdbh), NULL))
      {
         HASHBUCKETCOUNT hbc;

         /* Save strings in each hash bucket. */

         stdbh.dwcbMaxStringLen = 0;
         stdbh.lcStrings = 0;

         tr = TR_SUCCESS;

         for (hbc = 0; hbc < ((PSTRINGTABLE)hst)->hbc; hbc++)
         {
            LONG lcStringsInHashBucket;
            DWORD dwcbStringLen;

            tr = WriteHashBucket(hcf,
                              (((PSTRINGTABLE)hst)->phlistHashBuckets)[hbc],
                              &lcStringsInHashBucket, &dwcbStringLen);

            if (tr == TR_SUCCESS)
            {
               /* Watch out for overflow. */

               ASSERT(stdbh.lcStrings <= LONG_MAX - lcStringsInHashBucket);

               stdbh.lcStrings += lcStringsInHashBucket;

               if (dwcbStringLen > stdbh.dwcbMaxStringLen)
                  stdbh.dwcbMaxStringLen = dwcbStringLen;
            }
            else
               break;
         }

         if (tr == TR_SUCCESS)
         {
            /* Save string table header. */

            // The on-disk dwCBMaxString len always refers to ANSI chars,
            // whereas in memory it is for the TCHAR type, we adjust it
            // around the save

            stdbh.dwcbMaxStringLen /= sizeof(TCHAR);

            tr = WriteDBSegmentHeader(hcf, dwcbStringTableDBHeaderOffset,
                                      &stdbh, sizeof(stdbh));

            stdbh.dwcbMaxStringLen *= sizeof(TCHAR);

            TRACE_OUT((TEXT("WriteStringTable(): Wrote %ld strings."),
                       stdbh.lcStrings));
         }
      }
   }

   return(tr);
}


TWINRESULT ReadStringTable(HCACHEDFILE hcf, HSTRINGTABLE hst,
                                         PHHANDLETRANS phhtTrans)
{
   TWINRESULT tr;
   STRINGTABLEDBHEADER stdbh;
   DWORD dwcbRead;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_HANDLE(hst, STRINGTABLE));
   ASSERT(IS_VALID_WRITE_PTR(phhtTrans, HHANDLETRANS));

   if (ReadFromCachedFile(hcf, &stdbh, sizeof(stdbh), &dwcbRead) &&
       dwcbRead == sizeof(stdbh))
   {
      LPTSTR pszStringBuf;

      // The string header will have the ANSI cb max, whereas inmemory
      // we need the cb max based on the current character size

      stdbh.dwcbMaxStringLen *= sizeof(TCHAR);

      if (AllocateMemory(stdbh.dwcbMaxStringLen, &pszStringBuf))
      {
         HHANDLETRANS hht;

         if (CreateHandleTranslator(stdbh.lcStrings, &hht))
         {
            LONG lcStrings;

            tr = TR_SUCCESS;

            TRACE_OUT((TEXT("ReadStringTable(): Reading %ld strings, maximum length %lu."),
                       stdbh.lcStrings,
                       stdbh.dwcbMaxStringLen));

            for (lcStrings = 0;
                 lcStrings < stdbh.lcStrings && tr == TR_SUCCESS;
                 lcStrings++)
               tr = ReadString(hcf, hst, hht, pszStringBuf, stdbh.dwcbMaxStringLen);

            if (tr == TR_SUCCESS)
            {
               PrepareForHandleTranslation(hht);
               *phhtTrans = hht;

               ASSERT(IS_VALID_HANDLE(hst, STRINGTABLE));
               ASSERT(IS_VALID_HANDLE(*phhtTrans, HANDLETRANS));
            }
            else
               DestroyHandleTranslator(hht);
         }
         else
            tr = TR_OUT_OF_MEMORY;

         FreeMemory(pszStringBuf);
      }
      else
         tr = TR_OUT_OF_MEMORY;
   }
   else
      tr = TR_CORRUPT_BRIEFCASE;

   return(tr);
}


#ifdef DEBUG

ULONG GetStringCount(HSTRINGTABLE hst)
{
   ULONG ulcStrings = 0;
   HASHBUCKETCOUNT hbc;

   ASSERT(IS_VALID_HANDLE(hst, STRINGTABLE));

   for (hbc = 0; hbc < ((PCSTRINGTABLE)hst)->hbc; hbc++)
   {
      HLIST hlistHashBucket;

      hlistHashBucket = (((PCSTRINGTABLE)hst)->phlistHashBuckets)[hbc];

      if (hlistHashBucket)
      {
         ASSERT(ulcStrings <= ULONG_MAX - GetNodeCount(hlistHashBucket));
         ulcStrings += GetNodeCount(hlistHashBucket);
      }
   }

   return(ulcStrings);
}

#endif


/* Macros
 *********/

/* get a pointer to the stub type descriptor for a STUB */

#define GetStubTypeDescriptor(pcs)     (&(Mrgcstd[pcs->st]))


/* Types
 ********/

/* stub functions */

typedef TWINRESULT (*UNLINKSTUBPROC)(PSTUB);
typedef void (*DESTROYSTUBPROC)(PSTUB);
typedef void (*LOCKSTUBPROC)(PSTUB);
typedef void (*UNLOCKSTUBPROC)(PSTUB);

/* stub type descriptor */

typedef struct _stubtypedescriptor
{
   UNLINKSTUBPROC UnlinkStub;

   DESTROYSTUBPROC DestroyStub;

   LOCKSTUBPROC LockStub;

   UNLOCKSTUBPROC UnlockStub;
}
STUBTYPEDESCRIPTOR;
DECLARE_STANDARD_TYPES(STUBTYPEDESCRIPTOR);


/* Module Prototypes
 ********************/

void LockSingleStub(PSTUB);
void UnlockSingleStub(PSTUB);

#ifdef DEBUG

LPCTSTR GetStubName(PCSTUB);

#endif


/* Module Variables
 *******************/

/* stub type descriptors */

/* Cast off compiler complaints about pointer argument mismatch. */

CONST STUBTYPEDESCRIPTOR Mrgcstd[] =
{
   /* object twin STUB descriptor */

   {
      (UNLINKSTUBPROC)UnlinkObjectTwin,
      (DESTROYSTUBPROC)DestroyObjectTwin,
      LockSingleStub,
      UnlockSingleStub
   },

   /* twin family STUB descriptor */

   {
      (UNLINKSTUBPROC)UnlinkTwinFamily,
      (DESTROYSTUBPROC)DestroyTwinFamily,
      LockSingleStub,
      UnlockSingleStub
   },

   /* folder pair STUB descriptor */

   {
      (UNLINKSTUBPROC)UnlinkFolderPair,
      (DESTROYSTUBPROC)DestroyFolderPair,
      (LOCKSTUBPROC)LockFolderPair,
      (UNLOCKSTUBPROC)UnlockFolderPair
   }
};


void LockSingleStub(PSTUB ps)
{
   ASSERT(IS_VALID_STRUCT_PTR(ps, CSTUB));

   ASSERT(IsStubFlagClear(ps, STUB_FL_UNLINKED));

   ASSERT(ps->ulcLock < ULONG_MAX);
   ps->ulcLock++;
}


void UnlockSingleStub(PSTUB ps)
{
   ASSERT(IS_VALID_STRUCT_PTR(ps, CSTUB));

   if (EVAL(ps->ulcLock > 0))
   {
      ps->ulcLock--;

      if (! ps->ulcLock &&
          IsStubFlagSet(ps, STUB_FL_UNLINKED))
         DestroyStub(ps);
   }
}


#ifdef DEBUG

LPCTSTR GetStubName(PCSTUB pcs)
{
   LPCTSTR pcszStubName;

   ASSERT(IS_VALID_STRUCT_PTR(pcs, CSTUB));

   switch (pcs->st)
   {
      case ST_OBJECTTWIN:
         pcszStubName = TEXT("object twin");
         break;

      case ST_TWINFAMILY:
         pcszStubName = TEXT("twin family");
         break;

      case ST_FOLDERPAIR:
         pcszStubName = TEXT("folder twin");
         break;

      default:
         ERROR_OUT((TEXT("GetStubName() called on unrecognized stub type %d."),
                    pcs->st));
         pcszStubName = TEXT("UNKNOWN");
         break;
   }

   ASSERT(IS_VALID_STRING_PTR(pcszStubName, CSTR));

   return(pcszStubName);
}

#endif


/*
** InitStub()
**
** Initializes a stub.
**
** Arguments:     ps - pointer to stub to be initialized
**                st - type of stub
**
** Returns:       void
**
** Side Effects:  none
*/
void InitStub(PSTUB ps, STUBTYPE st)
{
   ASSERT(IS_VALID_WRITE_PTR(ps, STUB));

   ps->st = st;
   ps->ulcLock = 0;
   ps->dwFlags = 0;

   ASSERT(IS_VALID_STRUCT_PTR(ps, CSTUB));
}


/*
** DestroyStub()
**
** Destroys a stub.
**
** Arguments:     ps - pointer to stub to be destroyed
**
** Returns:       TWINRESULT
**
** Side Effects:  Depends upon stub type.
*/
TWINRESULT DestroyStub(PSTUB ps)
{
   TWINRESULT tr;
   PCSTUBTYPEDESCRIPTOR pcstd;

   ASSERT(IS_VALID_STRUCT_PTR(ps, CSTUB));

#ifdef DEBUG

   if (IsStubFlagSet(ps, STUB_FL_UNLINKED) &&
       ps->ulcLock > 0)
      WARNING_OUT((TEXT("DestroyStub() called on unlinked locked %s stub %#lx."),
                   GetStubName(ps),
                   ps));

#endif

   pcstd = GetStubTypeDescriptor(ps);

   /* Is the stub already unlinked? */

   if (IsStubFlagSet(ps, STUB_FL_UNLINKED))
      /* Yes. */
      tr = TR_SUCCESS;
   else
      /* No.  Unlink it. */
      tr = (*(pcstd->UnlinkStub))(ps);

   /* Is the stub still locked? */

   if (tr == TR_SUCCESS && ! ps->ulcLock)
      /* No.  Wipe it out. */
      (*(pcstd->DestroyStub))(ps);

   return(tr);
}


void LockStub(PSTUB ps)
{
   ASSERT(IS_VALID_STRUCT_PTR(ps, CSTUB));

   (*(GetStubTypeDescriptor(ps)->LockStub))(ps);
}


/*
** UnlockStub()
**
** Unlocks a stub.  Carries out any pending deletion on the stub.
**
** Arguments:     ps - pointer to stub to be unlocked
**
** Returns:       void
**
** Side Effects:  If the stub is unlinked and the lock count decreases to 0
**                after unlocking, the stub is deleted.
*/
void UnlockStub(PSTUB ps)
{
   ASSERT(IS_VALID_STRUCT_PTR(ps, CSTUB));

   (*(GetStubTypeDescriptor(ps)->UnlockStub))(ps);
}


DWORD GetStubFlags(PCSTUB pcs)
{
   ASSERT(IS_VALID_STRUCT_PTR(pcs, CSTUB));

   return(pcs->dwFlags);
}


/*
** SetStubFlag()
**
** Sets given flag in a stub.  Other flags in stub are not affected.
**
** Arguments:     ps - pointer to stub whose flags are to be set
**
** Returns:       void
**
** Side Effects:  none
*/
void SetStubFlag(PSTUB ps, DWORD dwFlags)
{
   ASSERT(IS_VALID_STRUCT_PTR(ps, CSTUB));
   ASSERT(FLAGS_ARE_VALID(dwFlags, ALL_STUB_FLAGS));

   SET_FLAG(ps->dwFlags, dwFlags);
}


/*
** ClearStubFlag()
**
** Clears given flag in a stub.  Other flags in stub are not affected.
**
** Arguments:     ps - pointer to stub whose flags are to be set
**
** Returns:       void
**
** Side Effects:  none
*/
void ClearStubFlag(PSTUB ps, DWORD dwFlags)
{
   ASSERT(IS_VALID_STRUCT_PTR(ps, CSTUB));
   ASSERT(FLAGS_ARE_VALID(dwFlags, ALL_STUB_FLAGS));

   CLEAR_FLAG(ps->dwFlags, dwFlags);
}


BOOL IsStubFlagSet(PCSTUB pcs, DWORD dwFlags)
{
   ASSERT(IS_VALID_STRUCT_PTR(pcs, CSTUB));
   ASSERT(FLAGS_ARE_VALID(dwFlags, ALL_STUB_FLAGS));

   return(IS_FLAG_SET(pcs->dwFlags, dwFlags));
}


BOOL IsStubFlagClear(PCSTUB pcs, DWORD dwFlags)
{
   ASSERT(IS_VALID_STRUCT_PTR(pcs, CSTUB));
   ASSERT(FLAGS_ARE_VALID(dwFlags, ALL_STUB_FLAGS));

   return(IS_FLAG_CLEAR(pcs->dwFlags, dwFlags));
}


/* Constants
 ************/

/* twin family pointer array allocation constants */

#define NUM_START_TWIN_FAMILY_PTRS        (16)
#define NUM_TWIN_FAMILY_PTRS_TO_ADD       (16)


/* Types
 ********/

/* twin families database structure header */

typedef struct _twinfamiliesdbheader
{
   /* number of twin families */

   LONG lcTwinFamilies;
}
TWINFAMILIESDBHEADER;
DECLARE_STANDARD_TYPES(TWINFAMILIESDBHEADER);

/* individual twin family database structure header */

typedef struct _twinfamilydbheader
{
   /* stub flags */

   DWORD dwStubFlags;

   /* old string handle of name */

   HSTRING hsName;

   /* number of object twins in family */

   LONG lcObjectTwins;
}
TWINFAMILYDBHEADER;
DECLARE_STANDARD_TYPES(TWINFAMILYDBHEADER);

/* object twin database structure */

typedef struct _dbobjecttwin
{
   /* stub flags */

   DWORD dwStubFlags;

   /* old handle to folder string */

   HPATH hpath;

   /* time stamp at last reconciliation */

   FILESTAMP fsLastRec;
}
DBOBJECTTWIN;
DECLARE_STANDARD_TYPES(DBOBJECTTWIN);

/* GenerateSpinOffObjectTwin() callback structure */

typedef struct _spinoffobjecttwininfo
{
   PCFOLDERPAIR pcfp;

   HLIST hlistNewObjectTwins;
}
SPINOFFOBJECTTWININFO;
DECLARE_STANDARD_TYPES(SPINOFFOBJECTTWININFO);

typedef void (CALLBACK *COPYOBJECTTWINPROC)(POBJECTTWIN, PCDBOBJECTTWIN);


/* Module Prototypes
 ********************/

TWINRESULT TwinJustTheseTwoObjects(HBRFCASE, HPATH, HPATH, LPCTSTR, POBJECTTWIN *, POBJECTTWIN *, HLIST);
BOOL CreateTwinFamily(HBRFCASE, LPCTSTR, PTWINFAMILY *);
void CollapseTwinFamilies(PTWINFAMILY, PTWINFAMILY);
BOOL GenerateSpinOffObjectTwin(PVOID, PVOID);
BOOL BuildBradyBunch(PVOID, PVOID);
BOOL CreateObjectTwinAndAddToList(PTWINFAMILY, HPATH, HLIST, POBJECTTWIN *, PHNODE);
BOOL CreateListOfGeneratedObjectTwins(PCFOLDERPAIR, PHLIST);
COMPARISONRESULT TwinFamilySortCmp(PCVOID, PCVOID);
COMPARISONRESULT TwinFamilySearchCmp(PCVOID, PCVOID);
BOOL ObjectTwinSearchCmp(PCVOID, PCVOID);
TWINRESULT WriteTwinFamily(HCACHEDFILE, PCTWINFAMILY);
TWINRESULT WriteObjectTwin(HCACHEDFILE, PCOBJECTTWIN);
TWINRESULT ReadTwinFamily(HCACHEDFILE, HBRFCASE, PCDBVERSION, HHANDLETRANS, HHANDLETRANS);
TWINRESULT ReadObjectTwin(HCACHEDFILE, PCDBVERSION, PTWINFAMILY, HHANDLETRANS);
void CopyTwinFamilyInfo(PTWINFAMILY, PCTWINFAMILYDBHEADER);
void CopyObjectTwinInfo(POBJECTTWIN, PCDBOBJECTTWIN);
void CopyM8ObjectTwinInfo(POBJECTTWIN, PCDBOBJECTTWIN);
BOOL DestroyObjectTwinStubWalker(PVOID, PVOID);
BOOL MarkObjectTwinNeverReconciledWalker(PVOID, PVOID);
BOOL LookForSrcFolderTwinsWalker(PVOID, PVOID);
BOOL IncrementSrcFolderTwinsWalker(PVOID, PVOID);
BOOL ClearSrcFolderTwinsWalker(PVOID, PVOID);
BOOL SetTwinFamilyWalker(PVOID, PVOID);
BOOL InsertNodeAtFrontWalker(POBJECTTWIN, PVOID);


BOOL IsReconciledFileStamp(PCFILESTAMP pcfs)
{
   ASSERT(IS_VALID_STRUCT_PTR(pcfs, CFILESTAMP));

   return(pcfs->fscond != FS_COND_UNAVAILABLE);
}


TWINRESULT TwinJustTheseTwoObjects(HBRFCASE hbr, HPATH hpathFolder1,
                                           HPATH hpathFolder2, LPCTSTR pcszName,
                                           POBJECTTWIN *ppot1,
                                           POBJECTTWIN *ppot2,
                                           HLIST hlistNewObjectTwins)
{
   TWINRESULT tr = TR_OUT_OF_MEMORY;
   HNODE hnodeSearch;
   BOOL bFound1;
   BOOL bFound2;

   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
   ASSERT(IS_VALID_HANDLE(hpathFolder1, PATH));
   ASSERT(IS_VALID_HANDLE(hpathFolder2, PATH));
   ASSERT(IS_VALID_STRING_PTR(pcszName, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(ppot1, POBJECTTWIN));
   ASSERT(IS_VALID_WRITE_PTR(ppot2, POBJECTTWIN));
   ASSERT(IS_VALID_HANDLE(hlistNewObjectTwins, LIST));

   /* Determine twin families of existing object twins. */

   bFound1 = FindObjectTwin(hbr, hpathFolder1, pcszName, &hnodeSearch);

   if (bFound1)
      *ppot1 = (POBJECTTWIN)GetNodeData(hnodeSearch);

   bFound2 = FindObjectTwin(hbr, hpathFolder2, pcszName, &hnodeSearch);

   if (bFound2)
      *ppot2 = (POBJECTTWIN)GetNodeData(hnodeSearch);

   /* Take action based upon existence of two object twins. */

   if (! bFound1 && ! bFound2)
   {
      PTWINFAMILY ptfNew;

      /* Neither object is already present.  Create a new twin family. */

      if (CreateTwinFamily(hbr, pcszName, &ptfNew))
      {
         HNODE hnodeNew1;

         if (CreateObjectTwinAndAddToList(ptfNew, hpathFolder1,
                                          hlistNewObjectTwins, ppot1,
                                          &hnodeNew1))
         {
            HNODE hnodeNew2;

            if (CreateObjectTwinAndAddToList(ptfNew, hpathFolder2,
                                             hlistNewObjectTwins, ppot2,
                                             &hnodeNew2))
            {
               TRACE_OUT((TEXT("TwinJustTheseTwoObjects(): Created a twin family for object %s in folders %s and %s."),
                          pcszName,
                          DebugGetPathString(hpathFolder1),
                          DebugGetPathString(hpathFolder2)));

               ASSERT(IsStubFlagClear(&(ptfNew->stub), STUB_FL_DELETION_PENDING));

               tr = TR_SUCCESS;
            }
            else
            {
               DeleteNode(hnodeNew1);
               DestroyStub(&((*ppot1)->stub));
TWINJUSTTHESETWOOBJECTS_BAIL:
               DestroyStub(&(ptfNew->stub));
            }
         }
         else
            goto TWINJUSTTHESETWOOBJECTS_BAIL;
      }
   }
   else if (bFound1 && bFound2)
   {
      /*
       * Both objects are already present.  Are they members of the same twin
       * family?
       */

      if ((*ppot1)->ptfParent == (*ppot2)->ptfParent)
      {
         /* Yes, same twin family.  Complain that these twins already exist. */

         TRACE_OUT((TEXT("TwinJustTheseTwoObjects(): Object %s is already twinned in folders %s and %s."),
                    pcszName,
                    DebugGetPathString(hpathFolder1),
                    DebugGetPathString(hpathFolder2)));

         tr = TR_DUPLICATE_TWIN;
      }
      else
      {
         /*
          * No, different twin families.  Collapse the two families.
          *
          * "That's the way they became the Brady bunch..."
          *
          * *ppot1 and *ppot2 remain valid across this call.
          */

         TRACE_OUT((TEXT("TwinJustTheseTwoObjects(): Collapsing separate twin families for object %s in folders %s and %s."),
                    pcszName,
                    DebugGetPathString(hpathFolder1),
                    DebugGetPathString(hpathFolder2)));

         CollapseTwinFamilies((*ppot1)->ptfParent, (*ppot2)->ptfParent);

         tr = TR_SUCCESS;
      }
   }
   else
   {
      PTWINFAMILY ptfParent;
      HNODE hnodeUnused;

      /*
       * Only one of the two objects is present.  Add the new object twin
       * to the existing object twin's family.
       */

      if (bFound1)
      {
         /* First object is already a twin. */

         ptfParent = (*ppot1)->ptfParent;

         if (CreateObjectTwinAndAddToList(ptfParent, hpathFolder2,
                                          hlistNewObjectTwins, ppot2,
                                          &hnodeUnused))
         {
            TRACE_OUT((TEXT("TwinJustTheseTwoObjects(): Adding twin of object %s\\%s to existing twin family including %s\\%s."),
                       DebugGetPathString(hpathFolder2),
                       pcszName,
                       DebugGetPathString(hpathFolder1),
                       pcszName));

            tr = TR_SUCCESS;
         }
      }
      else
      {
         /* Second object is already a twin. */

         ptfParent = (*ppot2)->ptfParent;

         if (CreateObjectTwinAndAddToList(ptfParent, hpathFolder1,
                                          hlistNewObjectTwins, ppot1,
                                          &hnodeUnused))
         {
            TRACE_OUT((TEXT("TwinJustTheseTwoObjects(): Adding twin of object %s\\%s to existing twin family including %s\\%s."),
                       DebugGetPathString(hpathFolder1),
                       pcszName,
                       DebugGetPathString(hpathFolder2),
                       pcszName));

            tr = TR_SUCCESS;
         }
      }
   }

   ASSERT((tr != TR_SUCCESS && tr != TR_DUPLICATE_TWIN) ||
          IS_VALID_STRUCT_PTR(*ppot1, COBJECTTWIN) && IS_VALID_STRUCT_PTR(*ppot2, COBJECTTWIN));

   return(tr);
}


BOOL CreateTwinFamily(HBRFCASE hbr, LPCTSTR pcszName, PTWINFAMILY *pptf)
{
   BOOL bResult = FALSE;
   PTWINFAMILY ptfNew;

   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
   ASSERT(IS_VALID_STRING_PTR(pcszName, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(pptf, PTWINFAMILY));

   /* Try to create a new TWINFAMILY structure. */

   if (AllocateMemory(sizeof(*ptfNew), &ptfNew))
   {
      NEWLIST nl;
      HLIST hlistObjectTwins;

      /* Create a list of object twins for the new twin family. */

      nl.dwFlags = 0;

      if (CreateList(&nl, &hlistObjectTwins))
      {
         HSTRING hsName;

         /* Add the object name to the name string table. */

         if (AddString(pcszName, GetBriefcaseNameStringTable(hbr),
            GetHashBucketIndex, &hsName))
         {
            ARRAYINDEX aiUnused;

            /* Fill in TWINFAMILY fields. */

            InitStub(&(ptfNew->stub), ST_TWINFAMILY);

            ptfNew->hsName = hsName;
            ptfNew->hlistObjectTwins = hlistObjectTwins;
            ptfNew->hbr = hbr;

            MarkTwinFamilyNeverReconciled(ptfNew);

            /* Add the twin family to the briefcase's list of twin families. */

            if (AddPtr(GetBriefcaseTwinFamilyPtrArray(hbr), TwinFamilySortCmp, ptfNew, &aiUnused))
            {
               *pptf = ptfNew;
               bResult = TRUE;

               ASSERT(IS_VALID_STRUCT_PTR(*pptf, CTWINFAMILY));
            }
            else
            {
               DeleteString(hsName);
CREATETWINFAMILY_BAIL1:
               DestroyList(hlistObjectTwins);
CREATETWINFAMILY_BAIL2:
               FreeMemory(ptfNew);
            }
         }
         else
            goto CREATETWINFAMILY_BAIL1;
      }
      else
         goto CREATETWINFAMILY_BAIL2;
   }

   return(bResult);
}


/*
** CollapseTwinFamilies()
**
** Collapses two twin families into one.  N.b., this function should only be
** called on two twin families with the same object name!
**
** Arguments:     ptf1 - pointer to destination twin family
**                ptf2 - pointer to source twin family
**
** Returns:       void
**
** Side Effects:  Twin family *ptf2 is destroyed.
*/
void CollapseTwinFamilies(PTWINFAMILY ptf1, PTWINFAMILY ptf2)
{
   ASSERT(IS_VALID_STRUCT_PTR(ptf1, CTWINFAMILY));
   ASSERT(IS_VALID_STRUCT_PTR(ptf2, CTWINFAMILY));

   ASSERT(CompareNameStringsByHandle(ptf1->hsName, ptf2->hsName) == CR_EQUAL);

   /* Use the first twin family as the collapsed twin family. */

   /*
    * Change the parent twin family of the object twins in the second twin
    * family to the first twin family.
    */

   EVAL(WalkList(ptf2->hlistObjectTwins, &SetTwinFamilyWalker, ptf1));

   /* Append object list from second twin family on to first. */

   AppendList(ptf1->hlistObjectTwins, ptf2->hlistObjectTwins);

   MarkTwinFamilyNeverReconciled(ptf1);

   /* Wipe out the old twin family. */

   DestroyStub(&(ptf2->stub));

   ASSERT(IS_VALID_STRUCT_PTR(ptf1, CTWINFAMILY));
}


BOOL GenerateSpinOffObjectTwin(PVOID pot, PVOID pcsooti)
{
   BOOL bResult;
   HPATH hpathMatchingFolder;
   HNODE hnodeUnused;

   ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));
   ASSERT(IS_VALID_STRUCT_PTR(pcsooti, CSPINOFFOBJECTTWININFO));

   /*
    * Append the generated object twin's subpath to the matching folder twin's
    * base path for subtree twins.
    */

   if (BuildPathForMatchingObjectTwin(
                     ((PCSPINOFFOBJECTTWININFO)pcsooti)->pcfp, pot,
                     GetBriefcasePathList(((POBJECTTWIN)pot)->ptfParent->hbr),
                     &hpathMatchingFolder))
   {
      /*
       * Does this generated object twin's twin family already contain an
       * object twin generated by the other half of the pair of folder twins?
       */

      if (! SearchUnsortedList(((POBJECTTWIN)pot)->ptfParent->hlistObjectTwins,
                               &ObjectTwinSearchCmp, hpathMatchingFolder,
                               &hnodeUnused))
      {
         /*
          * No.  Does the other object twin already exist in a different twin
          * family?
          */

         if (FindObjectTwin(((POBJECTTWIN)pot)->ptfParent->hbr,
                            hpathMatchingFolder,
                            GetBfcString(((POBJECTTWIN)pot)->ptfParent->hsName),
                            &hnodeUnused))
         {
            /* Yes. */

            ASSERT(((PCOBJECTTWIN)GetNodeData(hnodeUnused))->ptfParent != ((POBJECTTWIN)pot)->ptfParent);

            bResult = TRUE;
         }
         else
         {
            POBJECTTWIN potNew;

            /*
             * No.  Create a new object twin, and add it to the bookkeeping
             * list of new object twins.
             */

            bResult = CreateObjectTwinAndAddToList(
                     ((POBJECTTWIN)pot)->ptfParent, hpathMatchingFolder,
                     ((PCSPINOFFOBJECTTWININFO)pcsooti)->hlistNewObjectTwins,
                     &potNew, &hnodeUnused);
         }
      }
      else
         bResult = TRUE;

      DeletePath(hpathMatchingFolder);
   }
   else
      bResult = FALSE;

   return(bResult);
}


BOOL BuildBradyBunch(PVOID pot, PVOID pcfp)
{
   BOOL bResult;
   HPATH hpathMatchingFolder;
   HNODE hnodeOther;

   ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));
   ASSERT(IS_VALID_STRUCT_PTR(pcfp, CFOLDERPAIR));

   /*
    * Append the generated object twin's subpath to the matching folder twin's
    * base path for subtree twins.
    */

   bResult = BuildPathForMatchingObjectTwin(
                     pcfp, pot,
                     GetBriefcasePathList(((POBJECTTWIN)pot)->ptfParent->hbr),
                     &hpathMatchingFolder);

   if (bResult)
   {
      /*
       * Does this generated object twin's twin family already contain an object
       * twin generated by the other half of the pair of folder twins?
       */

      if (! SearchUnsortedList(((POBJECTTWIN)pot)->ptfParent->hlistObjectTwins,
                               &ObjectTwinSearchCmp, hpathMatchingFolder,
                               &hnodeOther))
      {
         /*
          * The other object twin should already exist in a different twin family.
          */

         if (EVAL(FindObjectTwin(((POBJECTTWIN)pot)->ptfParent->hbr,
                                 hpathMatchingFolder,
                                 GetBfcString(((POBJECTTWIN)pot)->ptfParent->hsName),
                                 &hnodeOther)))
         {
            PCOBJECTTWIN pcotOther;

            pcotOther = (PCOBJECTTWIN)GetNodeData(hnodeOther);

            if (EVAL(pcotOther->ptfParent != ((POBJECTTWIN)pot)->ptfParent))
            {
               /* It does.  Crush them. */

               CollapseTwinFamilies(((POBJECTTWIN)pot)->ptfParent,
                                    pcotOther->ptfParent);

               TRACE_OUT((TEXT("BuildBradyBunch(): Collapsed separate twin families for object %s\\%s and %s\\%s."),
                          DebugGetPathString(((POBJECTTWIN)pot)->hpath),
                          GetBfcString(((POBJECTTWIN)pot)->ptfParent->hsName),
                          DebugGetPathString(pcotOther->hpath),
                          GetBfcString(pcotOther->ptfParent->hsName)));
            }
         }
      }

      DeletePath(hpathMatchingFolder);
   }

   return(bResult);
}


BOOL CreateObjectTwinAndAddToList(PTWINFAMILY ptf, HPATH hpathFolder,
                                          HLIST hlistObjectTwins,
                                          POBJECTTWIN *ppot, PHNODE phnode)
{
   BOOL bResult = FALSE;

   ASSERT(IS_VALID_STRUCT_PTR(ptf, CTWINFAMILY));
   ASSERT(IS_VALID_HANDLE(hpathFolder, PATH));
   ASSERT(IS_VALID_HANDLE(hlistObjectTwins, LIST));
   ASSERT(IS_VALID_WRITE_PTR(ppot, POBJECTTWIN));
   ASSERT(IS_VALID_WRITE_PTR(phnode, HNODE));

   if (CreateObjectTwin(ptf, hpathFolder, ppot))
   {
      if (InsertNodeAtFront(hlistObjectTwins, NULL, *ppot, phnode))
         bResult = TRUE;
      else
         DestroyStub(&((*ppot)->stub));
   }

   return(bResult);
}


BOOL CreateListOfGeneratedObjectTwins(PCFOLDERPAIR pcfp,
                                             PHLIST phlistGeneratedObjectTwins)
{
   NEWLIST nl;
   BOOL bResult = FALSE;

   ASSERT(IS_VALID_STRUCT_PTR(pcfp, CFOLDERPAIR));
   ASSERT(IS_VALID_WRITE_PTR(phlistGeneratedObjectTwins, HLIST));

   nl.dwFlags = 0;

   if (CreateList(&nl, phlistGeneratedObjectTwins))
   {
      if (EnumGeneratedObjectTwins(pcfp, &InsertNodeAtFrontWalker, *phlistGeneratedObjectTwins))
         bResult = TRUE;
      else
         DestroyList(*phlistGeneratedObjectTwins);
   }

   return(bResult);
}


/*
** TwinFamilySortCmp()
**
** Pointer comparison function used to sort the global array of twin families.
**
** Arguments:     pctf1 - pointer to TWINFAMILY describing first twin family
**                pctf2 - pointer to TWINFAMILY describing second twin family
**
** Returns:
**
** Side Effects:  none
**
** Twin families are sorted by:
**    1) name string
**    2) pointer value
*/
COMPARISONRESULT TwinFamilySortCmp(PCVOID pctf1, PCVOID pctf2)
{
   COMPARISONRESULT cr;

   ASSERT(IS_VALID_STRUCT_PTR(pctf1, CTWINFAMILY));
   ASSERT(IS_VALID_STRUCT_PTR(pctf2, CTWINFAMILY));

   cr = CompareNameStringsByHandle(((PCTWINFAMILY)pctf1)->hsName, ((PCTWINFAMILY)pctf2)->hsName);

   if (cr == CR_EQUAL)
      /* Same name strings.  Now sort by pointer value. */
      cr = ComparePointers(pctf1, pctf2);

   return(cr);
}


/*
** TwinFamilySearchCmp()
**
** Pointer comparison function used to search the global array of twin families
** for the first twin family for a given name.
**
** Arguments:     pcszName - name string to search for
**                pctf - pointer to TWINFAMILY to examine
**
** Returns:
**
** Side Effects:  none
**
** Twin families are searched by:
**    1) name string
*/
COMPARISONRESULT TwinFamilySearchCmp(PCVOID pcszName, PCVOID pctf)
{
   ASSERT(IS_VALID_STRING_PTR(pcszName, CSTR));
   ASSERT(IS_VALID_STRUCT_PTR(pctf, CTWINFAMILY));

   return(CompareNameStrings(pcszName, GetBfcString(((PCTWINFAMILY)pctf)->hsName)));
}


BOOL ObjectTwinSearchCmp(PCVOID hpath, PCVOID pcot)
{
   ASSERT(IS_VALID_HANDLE((HPATH)hpath, PATH));
   ASSERT(IS_VALID_STRUCT_PTR(pcot, COBJECTTWIN));

   return(ComparePaths((HPATH)hpath, ((PCOBJECTTWIN)pcot)->hpath));
}


TWINRESULT WriteTwinFamily(HCACHEDFILE hcf, PCTWINFAMILY pctf)
{
   TWINRESULT tr = TR_BRIEFCASE_WRITE_FAILED;
   DWORD dwcbTwinFamilyDBHeaderOffset;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_STRUCT_PTR(pctf, CTWINFAMILY));

   /* Save initial file poisition. */

   dwcbTwinFamilyDBHeaderOffset = GetCachedFilePointerPosition(hcf);

   if (dwcbTwinFamilyDBHeaderOffset != INVALID_SEEK_POSITION)
   {
      TWINFAMILYDBHEADER tfdbh;

      /* Leave space for the twin family's header. */

      ZeroMemory(&tfdbh, sizeof(tfdbh));

      if (WriteToCachedFile(hcf, (PCVOID)&tfdbh, sizeof(tfdbh), NULL))
      {
         BOOL bContinue;
         HNODE hnode;
         LONG lcObjectTwins = 0;

         /* Save twin family's object twins. */

         ASSERT(GetNodeCount(pctf->hlistObjectTwins) >= 2);

         tr = TR_SUCCESS;

         for (bContinue = GetFirstNode(pctf->hlistObjectTwins, &hnode);
              bContinue;
              bContinue = GetNextNode(hnode, &hnode))
         {
            POBJECTTWIN pot;

            pot = (POBJECTTWIN)GetNodeData(hnode);

            tr = WriteObjectTwin(hcf, pot);

            if (tr == TR_SUCCESS)
            {
               ASSERT(lcObjectTwins < LONG_MAX);
               lcObjectTwins++;
            }
            else
               break;
         }

         /* Save twin family's database header. */

         if (tr == TR_SUCCESS)
         {
            ASSERT(lcObjectTwins >= 2);

            tfdbh.dwStubFlags = (pctf->stub.dwFlags & DB_STUB_FLAGS_MASK);
            tfdbh.hsName = pctf->hsName;
            tfdbh.lcObjectTwins = lcObjectTwins;

            tr = WriteDBSegmentHeader(hcf, dwcbTwinFamilyDBHeaderOffset, &tfdbh, sizeof(tfdbh));
         }
      }
   }

   return(tr);
}


TWINRESULT WriteObjectTwin(HCACHEDFILE hcf, PCOBJECTTWIN pcot)
{
   TWINRESULT tr;
   DBOBJECTTWIN dbot;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_STRUCT_PTR(pcot, COBJECTTWIN));

   /* Set up object twin database structure. */

   dbot.dwStubFlags = (pcot->stub.dwFlags & DB_STUB_FLAGS_MASK);
   dbot.hpath = pcot->hpath;
   dbot.hpath = pcot->hpath;
   dbot.fsLastRec = pcot->fsLastRec;

   /* Save object twin database structure. */

   if (WriteToCachedFile(hcf, (PCVOID)&dbot, sizeof(dbot), NULL))
      tr = TR_SUCCESS;
   else
      tr = TR_BRIEFCASE_WRITE_FAILED;

   return(tr);
}


TWINRESULT ReadTwinFamily(HCACHEDFILE hcf, HBRFCASE hbr,
                                  PCDBVERSION pcdbver,
                                  HHANDLETRANS hhtFolderTrans,
                                  HHANDLETRANS hhtNameTrans)
{
   TWINRESULT tr = TR_CORRUPT_BRIEFCASE;
   TWINFAMILYDBHEADER tfdbh;
   DWORD dwcbRead;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
   ASSERT(IS_VALID_READ_PTR(pcdbver, DBVERSION));
   ASSERT(IS_VALID_HANDLE(hhtFolderTrans, HANDLETRANS));
   ASSERT(IS_VALID_HANDLE(hhtNameTrans, HANDLETRANS));

   if (ReadFromCachedFile(hcf, &tfdbh, sizeof(tfdbh), &dwcbRead) &&
       dwcbRead == sizeof(tfdbh))
   {
      if (tfdbh.lcObjectTwins >= 2)
      {
         HSTRING hsName;

         if (TranslateHandle(hhtNameTrans, (HGENERIC)(tfdbh.hsName), (PHGENERIC)&hsName))
         {
            PTWINFAMILY ptfParent;

            if (CreateTwinFamily(hbr, GetBfcString(hsName), &ptfParent))
            {
               LONG l;

               CopyTwinFamilyInfo(ptfParent, &tfdbh);

               tr = TR_SUCCESS;

               for (l = tfdbh.lcObjectTwins;
                    l > 0 && tr == TR_SUCCESS;
                    l--)
                  tr = ReadObjectTwin(hcf, pcdbver, ptfParent, hhtFolderTrans);

               if (tr != TR_SUCCESS)
                  DestroyStub(&(ptfParent->stub));
            }
            else
               tr = TR_OUT_OF_MEMORY;
         }
      }
   }

   return(tr);
}


TWINRESULT ReadObjectTwin(HCACHEDFILE hcf,
                                  PCDBVERSION pcdbver,
                                  PTWINFAMILY ptfParent,
                                  HHANDLETRANS hhtFolderTrans)
{
   TWINRESULT tr;
   DBOBJECTTWIN dbot;
   DWORD dwcbRead;
   HPATH hpath;
   DWORD dwcbSize;
   COPYOBJECTTWINPROC pfnCopy;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_READ_PTR(pcdbver, DBVERSION));
   ASSERT(IS_VALID_STRUCT_PTR(ptfParent, CTWINFAMILY));
   ASSERT(IS_VALID_HANDLE(hhtFolderTrans, HANDLETRANS));

   if (HEADER_M8_MINOR_VER == pcdbver->dwMinorVer)
   {
      /* The M8 database does not have the ftModLocal in the FILESTAMP
      ** structure.
      */

      dwcbSize = sizeof(dbot) - sizeof(FILETIME);
      pfnCopy = CopyM8ObjectTwinInfo;
   }
   else
   {
      ASSERT(HEADER_MINOR_VER == pcdbver->dwMinorVer);
      dwcbSize = sizeof(dbot);
      pfnCopy = CopyObjectTwinInfo;
   }

   if ((ReadFromCachedFile(hcf, &dbot, dwcbSize, &dwcbRead) &&
        dwcbRead == dwcbSize) &&
       TranslateHandle(hhtFolderTrans, (HGENERIC)(dbot.hpath), (PHGENERIC)&hpath))
   {
      POBJECTTWIN pot;

      /* Create the new object twin and add it to the twin family. */

      if (CreateObjectTwin(ptfParent, hpath, &pot))
      {
          pfnCopy(pot, &dbot);

          tr = TR_SUCCESS;
      }
      else
         tr = TR_OUT_OF_MEMORY;
   }
   else
      tr = TR_CORRUPT_BRIEFCASE;

   return(tr);
}


void CopyTwinFamilyInfo(PTWINFAMILY ptf,
                                PCTWINFAMILYDBHEADER pctfdbh)
{
   ASSERT(IS_VALID_WRITE_PTR(ptf, TWINFAMILY));
   ASSERT(IS_VALID_READ_PTR(pctfdbh, CTWINFAMILYDBHEADER));

   ptf->stub.dwFlags = pctfdbh->dwStubFlags;
}


void CopyObjectTwinInfo(POBJECTTWIN pot, PCDBOBJECTTWIN pcdbot)
{
   ASSERT(IS_VALID_WRITE_PTR(pot, OBJECTTWIN));
   ASSERT(IS_VALID_READ_PTR(pcdbot, CDBOBJECTTWIN));

   pot->stub.dwFlags = pcdbot->dwStubFlags;
   pot->fsLastRec = pcdbot->fsLastRec;
}


void CopyM8ObjectTwinInfo(POBJECTTWIN pot, PCDBOBJECTTWIN pcdbot)
{
   ASSERT(IS_VALID_WRITE_PTR(pot, OBJECTTWIN));
   ASSERT(IS_VALID_READ_PTR(pcdbot, CDBOBJECTTWIN));

   pot->stub.dwFlags = pcdbot->dwStubFlags;
   pot->fsLastRec = pcdbot->fsLastRec;

   /* The pot->fsLastRec.ftModLocal field is invalid, so fill it in */

   if ( !FileTimeToLocalFileTime(&pot->fsLastRec.ftMod, &pot->fsLastRec.ftModLocal) )
   {
      /* Just copy the time if FileTimeToLocalFileTime failed */

      pot->fsLastRec.ftModLocal = pot->fsLastRec.ftMod;
   }
}


BOOL DestroyObjectTwinStubWalker(PVOID pot, PVOID pvUnused)
{
   ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));
   ASSERT(! pvUnused);

   /*
    * Set ulcSrcFolderTwins to 0 so UnlinkObjectTwin() succeeds.
    * DestroyStub() will unlink and destroy any new twin family created.
    */

   ((POBJECTTWIN)pot)->ulcSrcFolderTwins = 0;
   DestroyStub(&(((POBJECTTWIN)pot)->stub));

   return(TRUE);
}


BOOL MarkObjectTwinNeverReconciledWalker(PVOID pot, PVOID pvUnused)
{
   ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));
   ASSERT(! pvUnused);

   MarkObjectTwinNeverReconciled(pot);

   return(TRUE);
}


BOOL LookForSrcFolderTwinsWalker(PVOID pot, PVOID pvUnused)
{
   ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));
   ASSERT(! pvUnused);

   return(! ((POBJECTTWIN)pot)->ulcSrcFolderTwins);
}


BOOL IncrementSrcFolderTwinsWalker(PVOID pot, PVOID pvUnused)
{
   ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));
   ASSERT(! pvUnused);

   ASSERT(((POBJECTTWIN)pot)->ulcSrcFolderTwins < ULONG_MAX);
   ((POBJECTTWIN)pot)->ulcSrcFolderTwins++;

   return(TRUE);
}


BOOL ClearSrcFolderTwinsWalker(PVOID pot, PVOID pvUnused)
{
   ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));
   ASSERT(! pvUnused);

   ((POBJECTTWIN)pot)->ulcSrcFolderTwins = 0;

   return(TRUE);
}


BOOL SetTwinFamilyWalker(PVOID pot, PVOID ptfParent)
{
   ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));
   ASSERT(IS_VALID_STRUCT_PTR(ptfParent, CTWINFAMILY));

   ((POBJECTTWIN)pot)->ptfParent = ptfParent;

   return(TRUE);
}


BOOL InsertNodeAtFrontWalker(POBJECTTWIN pot, PVOID hlist)
{
   HNODE hnodeUnused;

   ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));
   ASSERT(IS_VALID_HANDLE(hlist, LIST));

   return(InsertNodeAtFront(hlist, NULL, pot, &hnodeUnused));
}


COMPARISONRESULT CompareNameStrings(LPCTSTR pcszFirst, LPCTSTR pcszSecond)
{
   ASSERT(IS_VALID_STRING_PTR(pcszFirst, CSTR));
   ASSERT(IS_VALID_STRING_PTR(pcszSecond, CSTR));

   return(MapIntToComparisonResult(lstrcmpi(pcszFirst, pcszSecond)));
}


COMPARISONRESULT CompareNameStringsByHandle(HSTRING hsFirst,
                                                        HSTRING hsSecond)
{
   ASSERT(IS_VALID_HANDLE(hsFirst, BFCSTRING));
   ASSERT(IS_VALID_HANDLE(hsSecond, BFCSTRING));

   return(CompareStringsI(hsFirst, hsSecond));
}


TWINRESULT TranslatePATHRESULTToTWINRESULT(PATHRESULT pr)
{
   TWINRESULT tr;

   switch (pr)
   {
      case PR_SUCCESS:
         tr = TR_SUCCESS;
         break;

      case PR_UNAVAILABLE_VOLUME:
         tr = TR_UNAVAILABLE_VOLUME;
         break;

      case PR_OUT_OF_MEMORY:
         tr = TR_OUT_OF_MEMORY;
         break;

      default:
         ASSERT(pr == PR_INVALID_PATH);
         tr = TR_INVALID_PARAMETER;
         break;
   }

   return(tr);
}


BOOL CreateTwinFamilyPtrArray(PHPTRARRAY phpa)
{
   NEWPTRARRAY npa;

   ASSERT(IS_VALID_WRITE_PTR(phpa, HPTRARRAY));

   /* Try to create a twin family pointer array. */

   npa.aicInitialPtrs = NUM_START_TWIN_FAMILY_PTRS;
   npa.aicAllocGranularity = NUM_TWIN_FAMILY_PTRS_TO_ADD;
   npa.dwFlags = NPA_FL_SORTED_ADD;

   return(CreatePtrArray(&npa, phpa));
}


void DestroyTwinFamilyPtrArray(HPTRARRAY hpa)
{
   ARRAYINDEX aicPtrs;
   ARRAYINDEX ai;

   ASSERT(IS_VALID_HANDLE(hpa, PTRARRAY));

   /* First free all twin families in pointer array. */

   aicPtrs = GetPtrCount(hpa);

   for (ai = 0; ai < aicPtrs; ai++)
      DestroyTwinFamily(GetPtr(hpa, ai));

   /* Now wipe out the pointer array. */

   DestroyPtrArray(hpa);
}


HBRFCASE GetTwinBriefcase(HTWIN htwin)
{
   HBRFCASE hbr;

   ASSERT(IS_VALID_HANDLE(htwin, TWIN));

   switch (((PSTUB)htwin)->st)
   {
      case ST_OBJECTTWIN:
         hbr = ((PCOBJECTTWIN)htwin)->ptfParent->hbr;
         break;

      case ST_TWINFAMILY:
         hbr = ((PCTWINFAMILY)htwin)->hbr;
         break;

      case ST_FOLDERPAIR:
         hbr = ((PCFOLDERPAIR)htwin)->pfpd->hbr;
         break;

      default:
         ERROR_OUT((TEXT("GetTwinBriefcase() called on unrecognized stub type %d."),
                    ((PSTUB)htwin)->st));
         hbr = NULL;
         break;
   }

   return(hbr);
}


BOOL FindObjectTwinInList(HLIST hlist, HPATH hpath, PHNODE phnode)
{
   ASSERT(IS_VALID_HANDLE(hlist, LIST));
   ASSERT(IS_VALID_HANDLE(hpath, PATH));
   ASSERT(IS_VALID_WRITE_PTR(phnode, HNODE));

   return(SearchUnsortedList(hlist, &ObjectTwinSearchCmp, hpath, phnode));
}


/*
** EnumTwins()
**
** Enumerates folder twins and twin families in a briefcase.
**
** Arguments:
**
** Returns:       TRUE if halted.  FALSE if not.
**
** Side Effects:  none
*/
BOOL EnumTwins(HBRFCASE hbr, ENUMTWINSPROC etp, LPARAM lpData,
                           PHTWIN phtwinStop)
{
   HPTRARRAY hpa;
   ARRAYINDEX aicPtrs;
   ARRAYINDEX ai;

   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
   ASSERT(IS_VALID_CODE_PTR(etp, ENUMTWINSPROC));
   ASSERT(IS_VALID_WRITE_PTR(phtwinStop, HTWIN));

   /* Enumerate folder pairs. */

   *phtwinStop = NULL;

   hpa = GetBriefcaseFolderPairPtrArray(hbr);

   aicPtrs = GetPtrCount(hpa);

   for (ai = 0; ai < aicPtrs; ai++)
   {
      PCFOLDERPAIR pcfp;

      pcfp = GetPtr(hpa, ai);

      ASSERT(IS_VALID_STRUCT_PTR(pcfp, CFOLDERPAIR));

      if (! (*etp)((HTWIN)pcfp, lpData))
      {
         *phtwinStop = (HTWIN)pcfp;
         break;
      }
   }

   if (! *phtwinStop)
   {
      /* Enumerate twin families. */

      hpa = GetBriefcaseTwinFamilyPtrArray(hbr);

      aicPtrs = GetPtrCount(hpa);

      for (ai = 0; ai < aicPtrs; ai++)
      {
         PCTWINFAMILY pctf;

         pctf = GetPtr(hpa, ai);

         ASSERT(IS_VALID_STRUCT_PTR(pctf, CTWINFAMILY));

         if (! (*etp)((HTWIN)pctf, lpData))
         {
            *phtwinStop = (HTWIN)pctf;
            break;
         }
      }
   }

   return(*phtwinStop != NULL);
}


/*
** FindObjectTwin()
**
** Looks for a twin family containing a specified object twin.
**
** Arguments:     hpathFolder - folder containing object
**                pcszName - name of object
**
** Returns:       Handle to list node containing pointer to object twin if
**                found, or NULL if not found.
**
** Side Effects:  none
*/
BOOL FindObjectTwin(HBRFCASE hbr, HPATH hpathFolder,
                                LPCTSTR pcszName, PHNODE phnode)
{
   BOOL bFound = FALSE;
   HPTRARRAY hpaTwinFamilies;
   ARRAYINDEX aiFirst;

   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
   ASSERT(IS_VALID_HANDLE(hpathFolder, PATH));
   ASSERT(IS_VALID_STRING_PTR(pcszName, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(phnode, HNODE));

   /* Search for a matching twin family. */

   *phnode = NULL;

   hpaTwinFamilies = GetBriefcaseTwinFamilyPtrArray(hbr);

   if (SearchSortedArray(hpaTwinFamilies, &TwinFamilySearchCmp, pcszName,
                         &aiFirst))
   {
      ARRAYINDEX aicPtrs;
      ARRAYINDEX ai;
      PTWINFAMILY ptf;

      /*
       * aiFirst holds the index of the first twin family with a common object
       * name matching pcszName.
       */

      /*
       * Now search each of these twin families for a folder matching
       * pcszFolder.
       */

      aicPtrs = GetPtrCount(hpaTwinFamilies);

      ASSERT(aicPtrs > 0);
      ASSERT(aiFirst >= 0);
      ASSERT(aiFirst < aicPtrs);

      for (ai = aiFirst; ai < aicPtrs; ai++)
      {
         ptf = GetPtr(hpaTwinFamilies, ai);

         ASSERT(IS_VALID_STRUCT_PTR(ptf, CTWINFAMILY));

         /* Is this a twin family of objects of the given name? */

         if (CompareNameStrings(GetBfcString(ptf->hsName), pcszName) == CR_EQUAL)
         {
            bFound = SearchUnsortedList(ptf->hlistObjectTwins,
                                        &ObjectTwinSearchCmp, hpathFolder,
                                        phnode);

            if (bFound)
               break;
         }
         else
            /* No.  Stop searching. */
            break;
      }
   }

   return(bFound);
}


/*
** CreateObjectTwin()
**
** Creates a new object twin, and adds it to a twin family.
**
** Arguments:     ptf - pointer to parent twin family
**                hpathFolder - folder of new object twin
**
** Returns:       Pointer to new object twin if successful, or NULL if
**                unsuccessful.
**
** Side Effects:  none
**
** N.b., this function does not first check to see if the object twin already
** exists in the family.
*/
BOOL CreateObjectTwin(PTWINFAMILY ptf, HPATH hpathFolder,
                             POBJECTTWIN *ppot)
{
   BOOL bResult = FALSE;
   POBJECTTWIN potNew;

   ASSERT(IS_VALID_STRUCT_PTR(ptf, CTWINFAMILY));
   ASSERT(IS_VALID_HANDLE(hpathFolder, PATH));
   ASSERT(IS_VALID_WRITE_PTR(ppot, POBJECTTWIN));

   /* Create a new OBJECTTWIN structure. */

   if (AllocateMemory(sizeof(*potNew), &potNew))
   {
      if (CopyPath(hpathFolder, GetBriefcasePathList(ptf->hbr), &(potNew->hpath)))
      {
         HNODE hnodeUnused;

         /* Fill in new OBJECTTWIN fields. */

         InitStub(&(potNew->stub), ST_OBJECTTWIN);

         potNew->ptfParent = ptf;
         potNew->ulcSrcFolderTwins = 0;

         MarkObjectTwinNeverReconciled(potNew);

         /* Add the object twin to the twin family's list of object twins. */

         if (InsertNodeAtFront(ptf->hlistObjectTwins, NULL, potNew, &hnodeUnused))
         {
            *ppot = potNew;
            bResult = TRUE;

            ASSERT(IS_VALID_STRUCT_PTR(*ppot, COBJECTTWIN));
         }
         else
         {
            DeletePath(potNew->hpath);
CREATEOBJECTTWIN_BAIL:
            FreeMemory(potNew);
         }
      }
      else
         goto CREATEOBJECTTWIN_BAIL;
   }

   return(bResult);
}


/*
** UnlinkObjectTwin()
**
** Unlinks an object twin.
**
** Arguments:     pot - pointer to object twin to unlink
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
TWINRESULT UnlinkObjectTwin(POBJECTTWIN pot)
{
   TWINRESULT tr;

   ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));

   ASSERT(IsStubFlagClear(&(pot->stub), STUB_FL_UNLINKED));

   TRACE_OUT((TEXT("UnlinkObjectTwin(): Unlinking object twin for folder %s."),
              DebugGetPathString(pot->hpath)));

   /* Is the object twin's twin family being deleted? */

   if (IsStubFlagSet(&(pot->ptfParent->stub), STUB_FL_BEING_DELETED))
      /* Yes.  No need to unlink the object twin. */
      tr = TR_SUCCESS;
   else
   {
      /* Are there any folder twin sources left for this object twin? */

      if (! pot->ulcSrcFolderTwins)
      {
         HNODE hnode;

         /*
          * Search the object twin's parent's list of object twins for the
          * object twin to be unlinked.
          */

         if (EVAL(FindObjectTwinInList(pot->ptfParent->hlistObjectTwins, pot->hpath, &hnode)) &&
             EVAL(GetNodeData(hnode) == pot))
         {
            ULONG ulcRemainingObjectTwins;

            /* Unlink the object twin. */

            DeleteNode(hnode);

            SetStubFlag(&(pot->stub), STUB_FL_UNLINKED);

            /*
             * If we have just unlinked the second last object twin in a twin
             * family, destroy the twin family.
             */

            ulcRemainingObjectTwins = GetNodeCount(pot->ptfParent->hlistObjectTwins);

            if (ulcRemainingObjectTwins < 2)
            {

               /* It's the end of the family line. */

               tr = DestroyStub(&(pot->ptfParent->stub));

               if (ulcRemainingObjectTwins == 1 &&
                   tr == TR_HAS_FOLDER_TWIN_SRC)
                  tr = TR_SUCCESS;
            }
            else
               tr = TR_SUCCESS;
         }
         else
            tr = TR_INVALID_PARAMETER;

         ASSERT(tr == TR_SUCCESS);
      }
      else
         tr = TR_HAS_FOLDER_TWIN_SRC;
   }

   return(tr);
}


/*
** DestroyObjectTwin()
**
** Destroys an object twin.
**
** Arguments:     pot - pointer to object twin to destroy
**
** Returns:       void
**
** Side Effects:  none
*/
void DestroyObjectTwin(POBJECTTWIN pot)
{
   ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));

   TRACE_OUT((TEXT("DestroyObjectTwin(): Destroying object twin for folder %s."),
              DebugGetPathString(pot->hpath)));

   DeletePath(pot->hpath);
   FreeMemory(pot);
}


/*
** UnlinkTwinFamily()
**
** Unlinks a twin family.
**
** Arguments:     ptf - pointer to twin family to unlink
**
** Returns:       TWINRESULT
**
** Side Effects:  none
*/
TWINRESULT UnlinkTwinFamily(PTWINFAMILY ptf)
{
   TWINRESULT tr;

   ASSERT(IS_VALID_STRUCT_PTR(ptf, CTWINFAMILY));

   ASSERT(IsStubFlagClear(&(ptf->stub), STUB_FL_UNLINKED));
   ASSERT(IsStubFlagClear(&(ptf->stub), STUB_FL_BEING_DELETED));

   /*
    * A twin family containing object twins generated by folder twins may not
    * be deleted, since those object twins may not be directly deleted.
    */

   if (WalkList(ptf->hlistObjectTwins, &LookForSrcFolderTwinsWalker, NULL))
   {
      HPTRARRAY hpaTwinFamilies;
      ARRAYINDEX aiUnlink;

      TRACE_OUT((TEXT("UnlinkTwinFamily(): Unlinking twin family for object %s."),
                 GetBfcString(ptf->hsName)));

      /* Search for the twin family to be unlinked. */

      hpaTwinFamilies = GetBriefcaseTwinFamilyPtrArray(ptf->hbr);

      if (EVAL(SearchSortedArray(hpaTwinFamilies, &TwinFamilySortCmp, ptf,
                                 &aiUnlink)))
      {
         /* Unlink the twin family. */

         ASSERT(GetPtr(hpaTwinFamilies, aiUnlink) == ptf);

         DeletePtr(hpaTwinFamilies, aiUnlink);

         SetStubFlag(&(ptf->stub), STUB_FL_UNLINKED);
      }

      tr = TR_SUCCESS;
   }
   else
      tr = TR_HAS_FOLDER_TWIN_SRC;

   return(tr);
}


/*
** DestroyTwinFamily()
**
** Destroys a twin family.
**
** Arguments:     ptf - pointer to twin family to destroy
**
** Returns:       void
**
** Side Effects:  none
*/
void DestroyTwinFamily(PTWINFAMILY ptf)
{
   ASSERT(IS_VALID_STRUCT_PTR(ptf, CTWINFAMILY));

   ASSERT(IsStubFlagClear(&(ptf->stub), STUB_FL_BEING_DELETED));

   TRACE_OUT((TEXT("DestroyTwinFamily(): Destroying twin family for object %s."),
              GetBfcString(ptf->hsName)));

   SetStubFlag(&(ptf->stub), STUB_FL_BEING_DELETED);

   /*
    * Destroy the object twins in the family one by one.  Be careful not to use
    * an object twin after it has been destroyed.
    */

   EVAL(WalkList(ptf->hlistObjectTwins, &DestroyObjectTwinStubWalker, NULL));

   /* Destroy TWINFAMILY fields. */

   DestroyList(ptf->hlistObjectTwins);
   DeleteString(ptf->hsName);
   FreeMemory(ptf);
}


/*
** MarkTwinFamilyNeverReconciled()
**
** Marks a twin family as never reconciled.
**
** Arguments:     ptf - pointer to twin family to be marked never reconciled
**
** Returns:       void
**
** Side Effects:  Clears the twin family's last reconciliation time stamp.
**                Marks all the object twins in the family never reconciled.
*/
void MarkTwinFamilyNeverReconciled(PTWINFAMILY ptf)
{
   /*
    * If we're being called from CreateTwinFamily(), the fields we're about to
    * set may currently be invalid.  Don't fully verify the TWINFAMILY
    * structure.
    */

   ASSERT(IS_VALID_WRITE_PTR(ptf, TWINFAMILY));

   /* Mark all object twins in twin family as never reconciled. */

   EVAL(WalkList(ptf->hlistObjectTwins, MarkObjectTwinNeverReconciledWalker, NULL));
}


void MarkObjectTwinNeverReconciled(PVOID pot)
{
   /*
    * If we're being called from CreateObjectTwin(), the fields we're about to
    * set may currently be invalid.  Don't fully verify the OBJECTTWIN
    * structure.
    */

   ASSERT(IS_VALID_WRITE_PTR((PCOBJECTTWIN)pot, COBJECTTWIN));

   ASSERT(IsStubFlagClear(&(((PCOBJECTTWIN)pot)->stub), STUB_FL_NOT_RECONCILED));

   ZeroMemory(&(((POBJECTTWIN)pot)->fsLastRec),
              sizeof(((POBJECTTWIN)pot)->fsLastRec));

   ((POBJECTTWIN)pot)->fsLastRec.fscond = FS_COND_UNAVAILABLE;
}


void MarkTwinFamilyDeletionPending(PTWINFAMILY ptf)
{
   ASSERT(IS_VALID_STRUCT_PTR(ptf, CTWINFAMILY));

   if (IsStubFlagClear(&(ptf->stub), STUB_FL_DELETION_PENDING))
      TRACE_OUT((TEXT("MarkTwinFamilyDeletionPending(): Deletion now pending for twin family for %s."),
                 GetBfcString(ptf->hsName)));

   SetStubFlag(&(ptf->stub), STUB_FL_DELETION_PENDING);
}


void UnmarkTwinFamilyDeletionPending(PTWINFAMILY ptf)
{
   BOOL bContinue;
   HNODE hnode;

   ASSERT(IS_VALID_STRUCT_PTR(ptf, CTWINFAMILY));

   if (IsStubFlagSet(&(ptf->stub), STUB_FL_DELETION_PENDING))
   {
      for (bContinue = GetFirstNode(ptf->hlistObjectTwins, &hnode);
           bContinue;
           bContinue = GetNextNode(hnode, &hnode))
      {
         POBJECTTWIN pot;

         pot = GetNodeData(hnode);

         ClearStubFlag(&(pot->stub), STUB_FL_KEEP);
      }

      ClearStubFlag(&(ptf->stub), STUB_FL_DELETION_PENDING);

      TRACE_OUT((TEXT("UnmarkTwinFamilyDeletionPending(): Deletion no longer pending for twin family for %s."),
                 GetBfcString(ptf->hsName)));
   }
}


BOOL IsTwinFamilyDeletionPending(PCTWINFAMILY pctf)
{
   ASSERT(IS_VALID_STRUCT_PTR(pctf, CTWINFAMILY));

   return(IsStubFlagSet(&(pctf->stub), STUB_FL_DELETION_PENDING));
}


void ClearTwinFamilySrcFolderTwinCount(PTWINFAMILY ptf)
{
   ASSERT(IS_VALID_STRUCT_PTR(ptf, CTWINFAMILY));

   EVAL(WalkList(ptf->hlistObjectTwins, &ClearSrcFolderTwinsWalker, NULL));
}


BOOL EnumObjectTwins(HBRFCASE hbr,
                                 ENUMGENERATEDOBJECTTWINSPROC egotp,
                                 PVOID pvRefData)
{
   BOOL bResult = TRUE;
   HPTRARRAY hpaTwinFamilies;
   ARRAYINDEX aicPtrs;
   ARRAYINDEX ai;

   /* pvRefData may be any value. */

   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
   ASSERT(IS_VALID_CODE_PTR(egotp, ENUMGENERATEDOBJECTTWINPROC));

   /* Walk the array of twin families. */

   hpaTwinFamilies = GetBriefcaseTwinFamilyPtrArray(hbr);

   aicPtrs = GetPtrCount(hpaTwinFamilies);
   ai = 0;

   while (ai < aicPtrs)
   {
      PTWINFAMILY ptf;
      BOOL bContinue;
      HNODE hnodePrev;

      ptf = GetPtr(hpaTwinFamilies, ai);

      ASSERT(IS_VALID_STRUCT_PTR(ptf, CTWINFAMILY));
      ASSERT(IsStubFlagClear(&(ptf->stub), STUB_FL_UNLINKED));

      /* Lock the twin family so it isn't deleted out from under us. */

      LockStub(&(ptf->stub));

      /*
       * Walk each twin family's list of object twins, calling the callback
       * function with each object twin.
       */

      bContinue = GetFirstNode(ptf->hlistObjectTwins, &hnodePrev);

      while (bContinue)
      {
         HNODE hnodeNext;
         POBJECTTWIN pot;

         bContinue = GetNextNode(hnodePrev, &hnodeNext);

         pot = (POBJECTTWIN)GetNodeData(hnodePrev);

         ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));

         bResult = (*egotp)(pot, pvRefData);

         if (! bResult)
            break;

         hnodePrev = hnodeNext;
      }

      /* Was the twin family unlinked? */

      if (IsStubFlagClear(&(ptf->stub), STUB_FL_UNLINKED))
         /* No. */
         ai++;
      else
      {
         /* Yes. */
         aicPtrs--;
         ASSERT(aicPtrs == GetPtrCount(hpaTwinFamilies));
         TRACE_OUT((TEXT("EnumObjectTwins(): Twin family for object %s unlinked by callback."),
                    GetBfcString(ptf->hsName)));
      }

      UnlockStub(&(ptf->stub));

      if (! bResult)
         break;
   }

   return(bResult);
}


/*
** ApplyNewFolderTwinsToTwinFamilies()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
**
** If FALSE is returned, the array of twin families is in the same state it was
** in before ApplyNewFolderTwinsToTwinFamilies() was called.  No clean-up is
** required by the caller in case of failure.
**
** This function collapses a pair of separate twin families when an object twin
** in one twin family intersects one of the folder twins in the pair of new
** folder twins and an object twin in the other twin family intersects the
** other folder twin in the pair of new folder twins.
**
** This function generates a spinoff object twin when an existing object twin
** intersects one of the folder twins in the pair of new folder twins, and no
** corresponding object twin for the other folder twin in the pair of new
** folder twins exists in the briefcase.  The spinoff object twin is added to
** the generating object twin's twin family.  A spinoff object twins cannot
** cause any existing pairs of twin families to be collapsed because the
** spinoff object twin did not previously exist in a twin family.
**
*/
BOOL ApplyNewFolderTwinsToTwinFamilies(PCFOLDERPAIR pcfp)
{
   BOOL bResult = FALSE;
   HLIST hlistGeneratedObjectTwins;

   ASSERT(IS_VALID_STRUCT_PTR(pcfp, CFOLDERPAIR));

   /*
    * Create lists to contain existing object twins generated by both folder
    * twins.
    */

   if (CreateListOfGeneratedObjectTwins(pcfp, &hlistGeneratedObjectTwins))
   {
      HLIST hlistOtherGeneratedObjectTwins;

      if (CreateListOfGeneratedObjectTwins(pcfp->pfpOther,
                                           &hlistOtherGeneratedObjectTwins))
      {
         NEWLIST nl;
         HLIST hlistNewObjectTwins;

         /* Create list to contain spin-off object twins. */

         nl.dwFlags = 0;

         if (CreateList(&nl, &hlistNewObjectTwins))
         {
            SPINOFFOBJECTTWININFO sooti;

            /*
             * Generate list of new object twins generated by new folder twins
             * to seed ApplyNewObjectTwinToFolderTwins().
             */

            sooti.pcfp = pcfp;
            sooti.hlistNewObjectTwins = hlistNewObjectTwins;

            if (WalkList(hlistGeneratedObjectTwins, &GenerateSpinOffObjectTwin,
                         &sooti))
            {
               sooti.pcfp = pcfp->pfpOther;
               ASSERT(sooti.hlistNewObjectTwins == hlistNewObjectTwins);

               if (WalkList(hlistOtherGeneratedObjectTwins,
                            &GenerateSpinOffObjectTwin, &sooti))
               {
                  /*
                   * ApplyNewObjectTwinsToFolderTwins() sets ulcSrcFolderTwins
                   * for all object twins in hlistNewObjectTwins.
                   */

                  if (ApplyNewObjectTwinsToFolderTwins(hlistNewObjectTwins))
                  {
                     /*
                      * Collapse separate twin families joined by new folder
                      * twin.
                      */

                     EVAL(WalkList(hlistGeneratedObjectTwins, &BuildBradyBunch,
                                   (PVOID)pcfp));

                     /*
                      * We don't need to call BuildBradyBunch() for
                      * pcfp->pfpOther and hlistOtherGeneratedObjectTwins since
                      * one twin family from each collapsed pair of twin
                      * families must come from each list of generated object
                      * twins.
                      */

                     /*
                      * Increment source folder twin count for all pre-existing
                      * object twins generated by the new folder twins.
                      */

                     EVAL(WalkList(hlistGeneratedObjectTwins,
                                   &IncrementSrcFolderTwinsWalker, NULL));
                     EVAL(WalkList(hlistOtherGeneratedObjectTwins,
                                   &IncrementSrcFolderTwinsWalker, NULL));

                     bResult = TRUE;
                  }
               }
            }

            /* Wipe out any new object twins on failure. */

            if (! bResult)
               EVAL(WalkList(hlistNewObjectTwins, &DestroyObjectTwinStubWalker,
                             NULL));

            DestroyList(hlistNewObjectTwins);
         }

         DestroyList(hlistOtherGeneratedObjectTwins);
      }

      DestroyList(hlistGeneratedObjectTwins);
   }

   return(bResult);
}


TWINRESULT TransplantObjectTwin(POBJECTTWIN pot,
                                            HPATH hpathOldFolder,
                                            HPATH hpathNewFolder)
{
   TWINRESULT tr;

   ASSERT(IS_VALID_STRUCT_PTR(pot, COBJECTTWIN));
   ASSERT(IS_VALID_HANDLE(hpathOldFolder, PATH));
   ASSERT(IS_VALID_HANDLE(hpathNewFolder, PATH));

   /* Is this object twin rooted in the renamed folder's subtree? */

   if (IsPathPrefix(pot->hpath, hpathOldFolder))
   {
      TCHAR rgchPathSuffix[MAX_PATH_LEN];
      LPCTSTR pcszSubPath;
      HPATH hpathNew;

      /* Yes.  Change the object twin's root. */

      pcszSubPath = FindChildPathSuffix(hpathOldFolder, pot->hpath,
                                        rgchPathSuffix);

      if (AddChildPath(GetBriefcasePathList(pot->ptfParent->hbr),
                       hpathNewFolder, pcszSubPath, &hpathNew))
      {
         TRACE_OUT((TEXT("TransplantObjectTwin(): Transplanted object twin %s\\%s to %s\\%s."),
                    DebugGetPathString(pot->hpath),
                    GetBfcString(pot->ptfParent->hsName),
                    DebugGetPathString(hpathNew),
                    GetBfcString(pot->ptfParent->hsName)));

         DeletePath(pot->hpath);
         pot->hpath = hpathNew;

         tr = TR_SUCCESS;
      }
      else
         tr = TR_OUT_OF_MEMORY;
   }
   else
      tr = TR_SUCCESS;

   return(tr);
}


BOOL IsFolderObjectTwinName(LPCTSTR pcszName)
{
   ASSERT(IS_VALID_STRING_PTR(pcszName, CSTR));

   return(! *pcszName);
}


TWINRESULT WriteTwinFamilies(HCACHEDFILE hcf, HPTRARRAY hpaTwinFamilies)
{
   TWINRESULT tr = TR_BRIEFCASE_WRITE_FAILED;
   DWORD dwcbTwinFamiliesDBHeaderOffset;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_HANDLE(hpaTwinFamilies, PTRARRAY));

   /* Save initial file poisition. */

   dwcbTwinFamiliesDBHeaderOffset = GetCachedFilePointerPosition(hcf);

   if (dwcbTwinFamiliesDBHeaderOffset != INVALID_SEEK_POSITION)
   {
      TWINFAMILIESDBHEADER tfdbh;

      /* Leave space for the twin families' header. */

      ZeroMemory(&tfdbh, sizeof(tfdbh));

      if (WriteToCachedFile(hcf, (PCVOID)&tfdbh, sizeof(tfdbh), NULL))
      {
         ARRAYINDEX aicPtrs;
         ARRAYINDEX ai;

         tr = TR_SUCCESS;

         aicPtrs = GetPtrCount(hpaTwinFamilies);

         for (ai = 0;
              ai < aicPtrs && tr == TR_SUCCESS;
              ai++)
            tr = WriteTwinFamily(hcf, GetPtr(hpaTwinFamilies, ai));

         if (tr == TR_SUCCESS)
         {
            /* Save twin families' header. */

            tfdbh.lcTwinFamilies = aicPtrs;

            tr = WriteDBSegmentHeader(hcf, dwcbTwinFamiliesDBHeaderOffset,
                                      &tfdbh, sizeof(tfdbh));

            if (tr == TR_SUCCESS)
               TRACE_OUT((TEXT("WriteTwinFamilies(): Wrote %ld twin families."),
                          tfdbh.lcTwinFamilies));
         }
      }
   }

   return(tr);
}


TWINRESULT ReadTwinFamilies(HCACHEDFILE hcf, HBRFCASE hbr,
                                   PCDBVERSION pcdbver,
                                   HHANDLETRANS hhtFolderTrans,
                                   HHANDLETRANS hhtNameTrans)
{
   TWINRESULT tr;
   TWINFAMILIESDBHEADER tfdbh;
   DWORD dwcbRead;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_HANDLE(hbr, BRFCASE));
   ASSERT(IS_VALID_READ_PTR(pcdbver, DBVERSION));
   ASSERT(IS_VALID_HANDLE(hhtFolderTrans, HANDLETRANS));
   ASSERT(IS_VALID_HANDLE(hhtNameTrans, HANDLETRANS));

   if (ReadFromCachedFile(hcf, &tfdbh, sizeof(tfdbh), &dwcbRead) &&
       dwcbRead == sizeof(tfdbh))
   {
      LONG l;

      tr = TR_SUCCESS;

      TRACE_OUT((TEXT("ReadTwinFamilies(): Reading %ld twin families."),
                 tfdbh.lcTwinFamilies));

      for (l = 0;
           l < tfdbh.lcTwinFamilies && tr == TR_SUCCESS;
           l++)
         tr = ReadTwinFamily(hcf, hbr, pcdbver, hhtFolderTrans, hhtNameTrans);
   }
   else
      tr = TR_CORRUPT_BRIEFCASE;

   return(tr);
}


COMPARISONRESULT ComparePathStringsByHandle(HSTRING hsFirst,
                                                        HSTRING hsSecond)
{
   ASSERT(IS_VALID_HANDLE(hsFirst, BFCSTRING));
   ASSERT(IS_VALID_HANDLE(hsSecond, BFCSTRING));

   return(CompareStringsI(hsFirst, hsSecond));
}


COMPARISONRESULT MyLStrCmpNI(LPCTSTR pcsz1, LPCTSTR pcsz2, int ncbLen)
{
   int n = 0;

   ASSERT(IS_VALID_STRING_PTR(pcsz1, CSTR));
   ASSERT(IS_VALID_STRING_PTR(pcsz2, CSTR));
   ASSERT(ncbLen >= 0);

   while (ncbLen > 0 &&
          ! (n = PtrToUlong(CharLower((LPTSTR)(ULONG)*pcsz1))
               - PtrToUlong(CharLower((LPTSTR)(ULONG)*pcsz2))) &&
          *pcsz1)
   {
      pcsz1++;
      pcsz2++;
      ncbLen--;
   }

   return(MapIntToComparisonResult(n));
}


/*
** ComposePath()
**
** Composes a path string given a folder and a filename.
**
** Arguments:     pszBuffer - path string that is created
**                pcszFolder - path string of the folder
**                pcszName - path to append
**
** Returns:       void
**
** Side Effects:  none
**
** N.b., truncates path to MAX_PATH_LEN bytes in length.
*/
void ComposePath(LPTSTR pszBuffer, LPCTSTR pcszFolder, LPCTSTR pcszName)
{
   ASSERT(IS_VALID_STRING_PTR(pszBuffer, STR));
   ASSERT(IS_VALID_STRING_PTR(pcszFolder, CSTR));
   ASSERT(IS_VALID_STRING_PTR(pcszName, CSTR));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszBuffer, STR, MAX_PATH_LEN));

   MyLStrCpyN(pszBuffer, pcszFolder, MAX_PATH_LEN);

   CatPath(pszBuffer, pcszName);

   ASSERT(IS_VALID_STRING_PTR(pszBuffer, STR));
}


/*
** ExtractFileName()
**
** Extracts the file name from a path name.
**
** Arguments:     pcszPathName - path string from which to extract file name
**
** Returns:       Pointer to file name in path string.
**
** Side Effects:  none
*/
LPCTSTR ExtractFileName(LPCTSTR pcszPathName)
{
   LPCTSTR pcszLastComponent;
   LPCTSTR pcsz;

   ASSERT(IS_VALID_STRING_PTR(pcszPathName, CSTR));

   for (pcszLastComponent = pcsz = pcszPathName;
        *pcsz;
        pcsz = CharNext(pcsz))
   {
      if (IS_SLASH(*pcsz) || *pcsz == COLON)
         pcszLastComponent = CharNext(pcsz);
   }

   ASSERT(IS_VALID_STRING_PTR(pcszLastComponent, CSTR));

   return(pcszLastComponent);
}


/*
** ExtractExtension()
**
** Extracts the extension from a file.
**
** Arguments:     pcszName - name whose extension is to be extracted
**
** Returns:       If the name contains an extension, a pointer to the period at
**                the beginning of the extension is returned.  If the name has
**                no extension, a pointer to the name's null terminator is
**                returned.
**
** Side Effects:  none
*/
LPCTSTR ExtractExtension(LPCTSTR pcszName)
{
   LPCTSTR pcszLastPeriod;

   ASSERT(IS_VALID_STRING_PTR(pcszName, CSTR));

   /* Make sure we have an isolated file name. */

   pcszName = ExtractFileName(pcszName);

   pcszLastPeriod = NULL;

   while (*pcszName)
   {
      if (*pcszName == PERIOD)
         pcszLastPeriod = pcszName;

      pcszName = CharNext(pcszName);
   }

   if (! pcszLastPeriod)
   {
      /* Point at null terminator. */

      pcszLastPeriod = pcszName;
      ASSERT(! *pcszLastPeriod);
   }
   else
      /* Point at period at beginning of extension. */
      ASSERT(*pcszLastPeriod == PERIOD);

   ASSERT(IS_VALID_STRING_PTR(pcszLastPeriod, CSTR));

   return(pcszLastPeriod);
}


/*
** GetHashBucketIndex()
**
** Calculates the hash bucket index for a string.
**
** Arguments:     pcsz - pointer to string whose hash bucket index is to be
**                        calculated
**                hbc - number of hash buckets in string table
**
** Returns:       Hash bucket index for string.
**
** Side Effects:  none
**
** The hashing function used is the sum of the byte values in the string modulo
** the number of buckets in the hash table.
*/
HASHBUCKETCOUNT GetHashBucketIndex(LPCTSTR pcsz, HASHBUCKETCOUNT hbc)
{
   ULONG ulSum;

   ASSERT(IS_VALID_STRING_PTR(pcsz, CSTR));
   ASSERT(hbc > 0);

   /* Don't worry about overflow here. */

   for (ulSum = 0; *pcsz; pcsz++)
      ulSum += *pcsz;

   return((HASHBUCKETCOUNT)(ulSum % hbc));
}


/*
** CopyLinkInfo()
**
** Copies LinkInfo into local memory.
**
** Arguments:     pcliSrc - source LinkInfo
**                ppliDest - pointer to PLINKINFO to be filled in with pointer
**                           to local copy
**
** Returns:       TRUE if successful.  FALSE if not.
**
** Side Effects:  none
*/
BOOL CopyLinkInfo(PCLINKINFO pcliSrc, PLINKINFO *ppliDest)
{
   BOOL bResult;
   DWORD dwcbSize;

   ASSERT(IS_VALID_STRUCT_PTR(pcliSrc, CLINKINFO));
   ASSERT(IS_VALID_WRITE_PTR(ppliDest, PLINKINFO));

   dwcbSize = *(PDWORD)pcliSrc;

   bResult = AllocateMemory(dwcbSize, ppliDest);

   if (bResult)
      CopyMemory(*ppliDest, pcliSrc, dwcbSize);

   ASSERT(! bResult ||
          IS_VALID_STRUCT_PTR(*ppliDest, CLINKINFO));

   return(bResult);
}


/* Constants
 ************/

/* VOLUMELIST PTRARRAY allocation parameters */

#define NUM_START_VOLUMES        (16)
#define NUM_VOLUMES_TO_ADD       (16)

/* VOLUMELIST string table allocation parameters */

#define NUM_VOLUME_HASH_BUCKETS  (31)


/* Types
 ********/

/* volume list */

typedef struct _volumelist
{
   /* array of pointers to VOLUMEs */

   HPTRARRAY hpa;

   /* table of volume root path strings */

   HSTRINGTABLE hst;

   /* flags from RESOLVELINKINFOINFLAGS */

   DWORD dwFlags;

   /*
    * handle to parent window, only valid if RLI_IFL_ALLOW_UI is set in dwFlags
    * field
    */

   HWND hwndOwner;
}
VOLUMELIST;
DECLARE_STANDARD_TYPES(VOLUMELIST);

/* VOLUME flags */

typedef enum _volumeflags
{
   /* The volume root path string indicated by hsRootPath is valid. */

   VOLUME_FL_ROOT_PATH_VALID  = 0x0001,

   /*
    * The net resource should be disconnected by calling DisconnectLinkInfo()
    * when finished.
    */

   VOLUME_FL_DISCONNECT       = 0x0002,

   /* Any cached volume information should be verified before use. */

   VOLUME_FL_VERIFY_VOLUME    = 0x0004,

   /* flag combinations */

   ALL_VOLUME_FLAGS           = (VOLUME_FL_ROOT_PATH_VALID |
                                 VOLUME_FL_DISCONNECT |
                                 VOLUME_FL_VERIFY_VOLUME)
}
VOLUMEFLAGS;

/* VOLUME states */

typedef enum _volumestate
{
   VS_UNKNOWN,

   VS_AVAILABLE,

   VS_UNAVAILABLE
}
VOLUMESTATE;
DECLARE_STANDARD_TYPES(VOLUMESTATE);

/* volume structure */

typedef struct _volume
{
   /* reference count */

   ULONG ulcLock;

   /* bit mask of flags from VOLUMEFLAGS */

   DWORD dwFlags;

   /* volume state */

   VOLUMESTATE vs;

   /* pointer to LinkInfo structure indentifying volume */

   PLINKINFO pli;

   /*
    * handle to volume root path string, only valid if
    * VOLUME_FL_ROOT_PATH_VALID is set in dwFlags field
    */

   HSTRING hsRootPath;

   /* pointer to parent volume list */

   PVOLUMELIST pvlParent;
}
VOLUME;
DECLARE_STANDARD_TYPES(VOLUME);

/* database volume list header */

typedef struct _dbvolumelistheader
{
   /* number of volumes in list */

   LONG lcVolumes;

   /* length of longest LinkInfo structure in volume list in bytes */

   UINT ucbMaxLinkInfoLen;
}
DBVOLUMELISTHEADER;
DECLARE_STANDARD_TYPES(DBVOLUMELISTHEADER);

/* database volume structure */

typedef struct _dbvolume
{
   /* old handle to volume */

   HVOLUME hvol;

   /* old LinkInfo structure follows */

   /* first DWORD of LinkInfo structure is total size in bytes */
}
DBVOLUME;
DECLARE_STANDARD_TYPES(DBVOLUME);


/* Module Prototypes
 ********************/

COMPARISONRESULT VolumeSortCmp(PCVOID, PCVOID);
COMPARISONRESULT VolumeSearchCmp(PCVOID, PCVOID);
BOOL SearchForVolumeByRootPathCmp(PCVOID, PCVOID);
BOOL UnifyVolume(PVOLUMELIST, PLINKINFO, PVOLUME *);
BOOL CreateVolume(PVOLUMELIST, PLINKINFO, PVOLUME *);
void UnlinkVolume(PCVOLUME);
BOOL DisconnectVolume(PVOLUME);
void DestroyVolume(PVOLUME);
void LockVolume(PVOLUME);
BOOL UnlockVolume(PVOLUME);
void InvalidateVolumeInfo(PVOLUME);
void ClearVolumeInfo(PVOLUME);
void GetUnavailableVolumeRootPath(PCLINKINFO, LPTSTR);
BOOL VerifyAvailableVolume(PVOLUME);
void ExpensiveResolveVolumeRootPath(PVOLUME, LPTSTR);
void ResolveVolumeRootPath(PVOLUME, LPTSTR);
VOLUMERESULT VOLUMERESULTFromLastError(VOLUMERESULT);
TWINRESULT WriteVolume(HCACHEDFILE, PVOLUME);
TWINRESULT ReadVolume(HCACHEDFILE, PVOLUMELIST, PLINKINFO, UINT, HHANDLETRANS);

/*
** VolumeSortCmp()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
**
** Volumes are sorted by:
**    1) LinkInfo volume
**    2) pointer
*/
COMPARISONRESULT VolumeSortCmp(PCVOID pcvol1, PCVOID pcvol2)
{
   COMPARISONRESULT cr;

   ASSERT(IS_VALID_STRUCT_PTR(pcvol1, CVOLUME));
   ASSERT(IS_VALID_STRUCT_PTR(pcvol2, CVOLUME));

   cr = CompareLinkInfoVolumes(((PCVOLUME)pcvol1)->pli,
                               ((PCVOLUME)pcvol2)->pli);

   if (cr == CR_EQUAL)
      cr = ComparePointers(pcvol1, pcvol1);

   return(cr);
}


/*
** VolumeSearchCmp()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
**
** Volumes are searched by:
**    1) LinkInfo volume
*/
COMPARISONRESULT VolumeSearchCmp(PCVOID pcli, PCVOID pcvol)
{
   ASSERT(IS_VALID_STRUCT_PTR(pcli, CLINKINFO));
   ASSERT(IS_VALID_STRUCT_PTR(pcvol, CVOLUME));

   return(CompareLinkInfoVolumes(pcli, ((PCVOLUME)pcvol)->pli));
}


/*
** SearchForVolumeByRootPathCmp()
**
**
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
**
** Volumes are searched by:
**    1) available volume root path
*/
BOOL SearchForVolumeByRootPathCmp(PCVOID pcszFullPath,
                                               PCVOID pcvol)
{
   BOOL bDifferent;

   ASSERT(IsFullPath(pcszFullPath));
   ASSERT(IS_VALID_STRUCT_PTR(pcvol, CVOLUME));

   if (((PCVOLUME)pcvol)->vs == VS_AVAILABLE &&
       IS_FLAG_SET(((PCVOLUME)pcvol)->dwFlags, VOLUME_FL_ROOT_PATH_VALID))
   {
      LPCTSTR pcszVolumeRootPath;

      pcszVolumeRootPath = GetBfcString(((PCVOLUME)pcvol)->hsRootPath);

      bDifferent = MyLStrCmpNI(pcszFullPath, pcszVolumeRootPath,
                               lstrlen(pcszVolumeRootPath));
   }
   else
      bDifferent = TRUE;

   return(bDifferent);
}


BOOL UnifyVolume(PVOLUMELIST pvl, PLINKINFO pliRoot,
                              PVOLUME *ppvol)
{
   BOOL bResult = FALSE;

   ASSERT(IS_VALID_STRUCT_PTR(pvl, CVOLUMELIST));
   ASSERT(IS_VALID_STRUCT_PTR(pliRoot, CLINKINFO));
   ASSERT(IS_VALID_WRITE_PTR(ppvol, PVOLUME));

   if (AllocateMemory(sizeof(**ppvol), ppvol))
   {
      if (CopyLinkInfo(pliRoot, &((*ppvol)->pli)))
      {
         ARRAYINDEX aiUnused;

         (*ppvol)->ulcLock = 0;
         (*ppvol)->dwFlags = 0;
         (*ppvol)->vs = VS_UNKNOWN;
         (*ppvol)->hsRootPath = NULL;
         (*ppvol)->pvlParent = pvl;

         if (AddPtr(pvl->hpa, VolumeSortCmp, *ppvol, &aiUnused))
            bResult = TRUE;
         else
         {
            FreeMemory((*ppvol)->pli);
UNIFYVOLUME_BAIL:
            FreeMemory(*ppvol);
         }
      }
      else
         goto UNIFYVOLUME_BAIL;
   }

   ASSERT(! bResult ||
          IS_VALID_STRUCT_PTR(*ppvol, CVOLUME));

   return(bResult);
}


BOOL CreateVolume(PVOLUMELIST pvl, PLINKINFO pliRoot,
                               PVOLUME *ppvol)
{
   BOOL bResult;
   PVOLUME pvol;
   ARRAYINDEX aiFound;

   ASSERT(IS_VALID_STRUCT_PTR(pvl, CVOLUMELIST));
   ASSERT(IS_VALID_STRUCT_PTR(pliRoot, CLINKINFO));
   ASSERT(IS_VALID_WRITE_PTR(ppvol, PVOLUME));

   /* Does a volume for the given root path already exist? */

   if (SearchSortedArray(pvl->hpa, &VolumeSearchCmp, pliRoot, &aiFound))
   {
      pvol = GetPtr(pvl->hpa, aiFound);
      bResult = TRUE;
   }
   else
      bResult = UnifyVolume(pvl, pliRoot, &pvol);

   if (bResult)
   {
      LockVolume(pvol);
      *ppvol = pvol;
   }

   ASSERT(! bResult ||
          IS_VALID_STRUCT_PTR(*ppvol, CVOLUME));

   return(bResult);
}


void UnlinkVolume(PCVOLUME pcvol)
{
   HPTRARRAY hpa;
   ARRAYINDEX aiFound;

   ASSERT(IS_VALID_STRUCT_PTR(pcvol, CVOLUME));

   hpa = pcvol->pvlParent->hpa;

   if (EVAL(SearchSortedArray(hpa, &VolumeSortCmp, pcvol, &aiFound)))
   {
      ASSERT(GetPtr(hpa, aiFound) == pcvol);

      DeletePtr(hpa, aiFound);
   }
}


BOOL DisconnectVolume(PVOLUME pvol)
{
   BOOL bResult;

   ASSERT(IS_VALID_STRUCT_PTR(pvol, CVOLUME));

   if (IS_FLAG_SET(pvol->dwFlags, VOLUME_FL_DISCONNECT))
   {
      bResult = DisconnectLinkInfo(pvol->pli);

      CLEAR_FLAG(pvol->dwFlags, VOLUME_FL_DISCONNECT);
   }
   else
      bResult = TRUE;

   return(bResult);
}


void DestroyVolume(PVOLUME pvol)
{
   ASSERT(IS_VALID_STRUCT_PTR(pvol, CVOLUME));

   ClearVolumeInfo(pvol);

   FreeMemory(pvol->pli);
   FreeMemory(pvol);
}


void LockVolume(PVOLUME pvol)
{
   ASSERT(IS_VALID_STRUCT_PTR(pvol, CVOLUME));

   ASSERT(pvol->ulcLock < ULONG_MAX);
   pvol->ulcLock++;
}


BOOL UnlockVolume(PVOLUME pvol)
{
   ASSERT(IS_VALID_STRUCT_PTR(pvol, CVOLUME));

   if (EVAL(pvol->ulcLock > 0))
      pvol->ulcLock--;

   return(pvol->ulcLock > 0);
}


void InvalidateVolumeInfo(PVOLUME pvol)
{
   ASSERT(IS_VALID_STRUCT_PTR(pvol, CVOLUME));

   SET_FLAG(pvol->dwFlags, VOLUME_FL_VERIFY_VOLUME);

   ASSERT(IS_VALID_STRUCT_PTR(pvol, CVOLUME));
}


void ClearVolumeInfo(PVOLUME pvol)
{
   ASSERT(IS_VALID_STRUCT_PTR(pvol, CVOLUME));

   DisconnectVolume(pvol);

   if (IS_FLAG_SET(pvol->dwFlags, VOLUME_FL_ROOT_PATH_VALID))
   {
      DeleteString(pvol->hsRootPath);

      CLEAR_FLAG(pvol->dwFlags, VOLUME_FL_ROOT_PATH_VALID);
   }

   CLEAR_FLAG(pvol->dwFlags, VOLUME_FL_VERIFY_VOLUME);

   pvol->vs = VS_UNKNOWN;

   ASSERT(IS_VALID_STRUCT_PTR(pvol, CVOLUME));
}


void GetUnavailableVolumeRootPath(PCLINKINFO pcli,
                                               LPTSTR pszRootPathBuf)
{
    LPCSTR pcszLinkInfoData;
    TCHAR szTmp[MAX_PATH] = TEXT("");

   ASSERT(IS_VALID_STRUCT_PTR(pcli, CLINKINFO));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszRootPathBuf, STR, MAX_PATH_LEN));

   /*
    * Try unavailable volume root paths in the following order:
    *    1) last redirected device
    *    2) net resource name
    *    3) local path           ...and take the _last_ good one!
    */

   if (GetLinkInfoData(pcli, LIDT_REDIRECTED_DEVICE, &pcszLinkInfoData) ||
       GetLinkInfoData(pcli, LIDT_NET_RESOURCE, &pcszLinkInfoData) ||
       GetLinkInfoData(pcli, LIDT_LOCAL_BASE_PATH, &pcszLinkInfoData))
   {
      ASSERT(lstrlenA(pcszLinkInfoData) < MAX_PATH_LEN);

      MultiByteToWideChar( OurGetACP(), 0, pcszLinkInfoData, -1, szTmp, MAX_PATH);
      ComposePath(pszRootPathBuf, szTmp, TEXT("\\"));
   }
   else
   {
      pszRootPathBuf[0] = TEXT('\0');

      ERROR_OUT((TEXT("GetUnavailableVolumeRootPath(): Net resource name and local base path unavailable.  Using empty string as unavailable root path.")));
   }

   ASSERT(IsRootPath(pszRootPathBuf) &&
          EVAL(lstrlen(pszRootPathBuf) < MAX_PATH_LEN));
}


BOOL VerifyAvailableVolume(PVOLUME pvol)
{
   BOOL bResult = FALSE;
   PLINKINFO pli;

   ASSERT(IS_VALID_STRUCT_PTR(pvol, CVOLUME));

   ASSERT(pvol->vs == VS_AVAILABLE);
   ASSERT(IS_FLAG_SET(pvol->dwFlags, VOLUME_FL_ROOT_PATH_VALID));

   WARNING_OUT((TEXT("VerifyAvailableVolume(): Calling CreateLinkInfo() to verify volume on %s."),
                GetBfcString(pvol->hsRootPath)));

   if (CreateLinkInfo(GetBfcString(pvol->hsRootPath), &pli))
   {
      bResult = (CompareLinkInfoReferents(pvol->pli, pli) == CR_EQUAL);

      DestroyLinkInfo(pli);

      if (bResult)
         TRACE_OUT((TEXT("VerifyAvailableVolume(): Volume %s has not changed."),
                    GetBfcString(pvol->hsRootPath)));
      else
         WARNING_OUT((TEXT("VerifyAvailableVolume(): Volume %s has changed."),
                      GetBfcString(pvol->hsRootPath)));
   }
   else
      WARNING_OUT((TEXT("VerifyAvailableVolume(): CreateLinkInfo() failed for %s."),
                   GetBfcString(pvol->hsRootPath)));

   return(bResult);
}


void ExpensiveResolveVolumeRootPath(PVOLUME pvol, LPTSTR pszVolumeRootPathBuf)
{
   BOOL bResult;
   DWORD dwOutFlags;
   PLINKINFO pliUpdated;
   HSTRING hsRootPath;

   ASSERT(IS_VALID_STRUCT_PTR(pvol, CVOLUME));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszVolumeRootPathBuf, STR, MAX_PATH_LEN));

   if (pvol->vs == VS_UNKNOWN ||
       pvol->vs == VS_AVAILABLE)
   {
      /*
       * Only request a connection if connections are still permitted in this
       * volume list.
       */

      WARNING_OUT((TEXT("ExpensiveResolveVolumeRootPath(): Calling ResolveLinkInfo() to determine volume availability and root path.")));

      bResult = ResolveLinkInfo(pvol->pli, pszVolumeRootPathBuf,
                                pvol->pvlParent->dwFlags,
                                pvol->pvlParent->hwndOwner, &dwOutFlags,
                                &pliUpdated);

      if (bResult)
      {
         pvol->vs = VS_AVAILABLE;

         if (IS_FLAG_SET(dwOutFlags, RLI_OFL_UPDATED))
         {
            PLINKINFO pliUpdatedCopy;

            ASSERT(IS_FLAG_SET(pvol->pvlParent->dwFlags, RLI_IFL_UPDATE));

            if (CopyLinkInfo(pliUpdated, &pliUpdatedCopy))
            {
               FreeMemory(pvol->pli);
               pvol->pli = pliUpdatedCopy;
            }

            DestroyLinkInfo(pliUpdated);

            WARNING_OUT((TEXT("ExpensiveResolveVolumeRootPath(): Updating LinkInfo for volume %s."),
                         pszVolumeRootPathBuf));
         }

         if (IS_FLAG_SET(dwOutFlags, RLI_OFL_DISCONNECT))
         {
            SET_FLAG(pvol->dwFlags, VOLUME_FL_DISCONNECT);

            WARNING_OUT((TEXT("ExpensiveResolveVolumeRootPath(): Volume %s must be disconnected when finished."),
                         pszVolumeRootPathBuf));
         }

         TRACE_OUT((TEXT("ExpensiveResolveVolumeRootPath(): Volume %s is available."),
                    pszVolumeRootPathBuf));
      }
      else
         ASSERT(GetLastError() != ERROR_INVALID_PARAMETER);
   }
   else
   {
      ASSERT(pvol->vs == VS_UNAVAILABLE);
      bResult = FALSE;
   }

   if (! bResult)
   {
      pvol->vs = VS_UNAVAILABLE;

      if (GetLastError() == ERROR_CANCELLED)
      {
         ASSERT(IS_FLAG_SET(pvol->pvlParent->dwFlags, RLI_IFL_CONNECT));

         CLEAR_FLAG(pvol->pvlParent->dwFlags, RLI_IFL_CONNECT);

         WARNING_OUT((TEXT("ExpensiveResolveVolumeRootPath(): Connection attempt cancelled.  No subsequent connections will be attempted.")));
      }

      GetUnavailableVolumeRootPath(pvol->pli, pszVolumeRootPathBuf);

      WARNING_OUT((TEXT("ExpensiveResolveVolumeRootPath(): Using %s as unavailable volume root path."),
                   pszVolumeRootPathBuf));
   }

   /* Add volume root path string to volume list's string table. */

   if (IS_FLAG_SET(pvol->dwFlags, VOLUME_FL_ROOT_PATH_VALID))
   {
      CLEAR_FLAG(pvol->dwFlags, VOLUME_FL_ROOT_PATH_VALID);
      DeleteString(pvol->hsRootPath);
   }

   if (AddString(pszVolumeRootPathBuf, pvol->pvlParent->hst, GetHashBucketIndex, &hsRootPath))
   {
      SET_FLAG(pvol->dwFlags, VOLUME_FL_ROOT_PATH_VALID);
      pvol->hsRootPath = hsRootPath;
   }
   else
      WARNING_OUT((TEXT("ExpensiveResolveVolumeRootPath(): Unable to save %s as volume root path."),
                   pszVolumeRootPathBuf));
}


void ResolveVolumeRootPath(PVOLUME pvol,
                                        LPTSTR pszVolumeRootPathBuf)
{
   ASSERT(IS_VALID_STRUCT_PTR(pvol, CVOLUME));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszVolumeRootPathBuf, STR, MAX_PATH_LEN));

   /* Do we have a cached volume root path to use? */

   if (IS_FLAG_SET(pvol->dwFlags, VOLUME_FL_ROOT_PATH_VALID) &&
       (IS_FLAG_CLEAR(pvol->dwFlags, VOLUME_FL_VERIFY_VOLUME) ||
        (pvol->vs == VS_AVAILABLE &&
         VerifyAvailableVolume(pvol))))
   {
      /* Yes. */

      MyLStrCpyN(pszVolumeRootPathBuf, GetBfcString(pvol->hsRootPath), MAX_PATH_LEN);
      ASSERT(lstrlen(pszVolumeRootPathBuf) < MAX_PATH_LEN);

      ASSERT(pvol->vs != VS_UNKNOWN);
   }
   else
      /* No.  Welcome in I/O City. */
      ExpensiveResolveVolumeRootPath(pvol, pszVolumeRootPathBuf);

   CLEAR_FLAG(pvol->dwFlags, VOLUME_FL_VERIFY_VOLUME);

   ASSERT(IS_VALID_STRUCT_PTR(pvol, CVOLUME));
}


VOLUMERESULT VOLUMERESULTFromLastError(VOLUMERESULT vr)
{
   switch (GetLastError())
   {
      case ERROR_OUTOFMEMORY:
         vr = VR_OUT_OF_MEMORY;
         break;

      case ERROR_BAD_PATHNAME:
         vr = VR_INVALID_PATH;
         break;

      default:
         break;
   }

   return(vr);
}


TWINRESULT WriteVolume(HCACHEDFILE hcf, PVOLUME pvol)
{
   TWINRESULT tr;
   DBVOLUME dbvol;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_STRUCT_PTR(pvol, CVOLUME));

   /* Write database volume followed by LinkInfo structure. */

   dbvol.hvol = (HVOLUME)pvol;

   if (WriteToCachedFile(hcf, (PCVOID)&dbvol, sizeof(dbvol), NULL) &&
       WriteToCachedFile(hcf, pvol->pli, *(PDWORD)(pvol->pli), NULL))
      tr = TR_SUCCESS;
   else
      tr = TR_BRIEFCASE_WRITE_FAILED;

   return(tr);
}


TWINRESULT ReadVolume(HCACHEDFILE hcf, PVOLUMELIST pvl,
                                   PLINKINFO pliBuf, UINT ucbLinkInfoBufLen,
                                   HHANDLETRANS hhtVolumes)
{
   TWINRESULT tr = TR_CORRUPT_BRIEFCASE;
   DBVOLUME dbvol;
   DWORD dwcbRead;
   UINT ucbLinkInfoLen;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_STRUCT_PTR(pvl, CVOLUMELIST));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pliBuf, LINKINFO, ucbLinkInfoBufLen));
   ASSERT(IS_VALID_HANDLE(hhtVolumes, HANDLETRANS));

   if (ReadFromCachedFile(hcf, &dbvol, sizeof(dbvol), &dwcbRead) &&
       dwcbRead == sizeof(dbvol) &&
       ReadFromCachedFile(hcf, &ucbLinkInfoLen, sizeof(ucbLinkInfoLen), &dwcbRead) &&
       dwcbRead == sizeof(ucbLinkInfoLen) &&
       ucbLinkInfoLen <= ucbLinkInfoBufLen)
   {
      /* Read the remainder of the LinkInfo structure into memory. */

      DWORD dwcbRemainder;

      pliBuf->ucbSize = ucbLinkInfoLen;
      dwcbRemainder = ucbLinkInfoLen - sizeof(ucbLinkInfoLen);

      if (ReadFromCachedFile(hcf, (PBYTE)pliBuf + sizeof(ucbLinkInfoLen),
                             dwcbRemainder, &dwcbRead) &&
          dwcbRead == dwcbRemainder &&
          IsValidLinkInfo(pliBuf))
      {
         PVOLUME pvol;

         if (CreateVolume(pvl, pliBuf, &pvol))
         {
            /*
             * To leave read volumes with 0 initial lock count, we must undo
             * the LockVolume() performed by CreateVolume().
             */

            UnlockVolume(pvol);

            if (AddHandleToHandleTranslator(hhtVolumes,
                                            (HGENERIC)(dbvol.hvol),
                                            (HGENERIC)pvol))
               tr = TR_SUCCESS;
            else
            {
               UnlinkVolume(pvol);
               DestroyVolume(pvol);

               tr = TR_OUT_OF_MEMORY;
            }
         }
         else
            tr = TR_OUT_OF_MEMORY;
      }
   }

   return(tr);
}


BOOL CreateVolumeList(DWORD dwFlags, HWND hwndOwner,
                                  PHVOLUMELIST phvl)
{
   BOOL bResult = FALSE;
   PVOLUMELIST pvl;

   ASSERT(FLAGS_ARE_VALID(dwFlags, ALL_RLI_IFLAGS));
   ASSERT(IS_FLAG_CLEAR(dwFlags, RLI_IFL_ALLOW_UI) ||
          IS_VALID_HANDLE(hwndOwner, WND));
   ASSERT(IS_VALID_WRITE_PTR(phvl, HVOLUMELIST));

   if (AllocateMemory(sizeof(*pvl), &pvl))
   {
      NEWSTRINGTABLE nszt;

      /* Create string table for volume root path strngs. */

      nszt.hbc = NUM_VOLUME_HASH_BUCKETS;

      if (CreateStringTable(&nszt, &(pvl->hst)))
      {
         NEWPTRARRAY npa;

         /* Create pointer array of volumes. */

         npa.aicInitialPtrs = NUM_START_VOLUMES;
         npa.aicAllocGranularity = NUM_VOLUMES_TO_ADD;
         npa.dwFlags = NPA_FL_SORTED_ADD;

         if (CreatePtrArray(&npa, &(pvl->hpa)))
         {
            pvl->dwFlags = dwFlags;
            pvl->hwndOwner = hwndOwner;

            *phvl = (HVOLUMELIST)pvl;
            bResult = TRUE;
         }
         else
         {
            DestroyStringTable(pvl->hst);
CREATEVOLUMELIST_BAIL:
            FreeMemory(pvl);
         }
      }
      else
         goto CREATEVOLUMELIST_BAIL;
   }

   ASSERT(! bResult ||
          IS_VALID_HANDLE(*phvl, VOLUMELIST));

   return(bResult);
}


void DestroyVolumeList(HVOLUMELIST hvl)
{
   ARRAYINDEX aicPtrs;
   ARRAYINDEX ai;

   ASSERT(IS_VALID_HANDLE(hvl, VOLUMELIST));

   /* First free all volumes in array. */

   aicPtrs = GetPtrCount(((PCVOLUMELIST)hvl)->hpa);

   for (ai = 0; ai < aicPtrs; ai++)
      DestroyVolume(GetPtr(((PCVOLUMELIST)hvl)->hpa, ai));

   /* Now wipe out the array. */

   DestroyPtrArray(((PCVOLUMELIST)hvl)->hpa);

   ASSERT(! GetStringCount(((PCVOLUMELIST)hvl)->hst));
   DestroyStringTable(((PCVOLUMELIST)hvl)->hst);

   FreeMemory((PVOLUMELIST)hvl);
}


void InvalidateVolumeListInfo(HVOLUMELIST hvl)
{
   ARRAYINDEX aicPtrs;
   ARRAYINDEX ai;

   ASSERT(IS_VALID_HANDLE(hvl, VOLUMELIST));

   aicPtrs = GetPtrCount(((PCVOLUMELIST)hvl)->hpa);

   for (ai = 0; ai < aicPtrs; ai++)
      InvalidateVolumeInfo(GetPtr(((PCVOLUMELIST)hvl)->hpa, ai));

   WARNING_OUT((TEXT("InvalidateVolumeListInfo(): Volume cache invalidated.")));
}


void ClearVolumeListInfo(HVOLUMELIST hvl)
{
   ARRAYINDEX aicPtrs;
   ARRAYINDEX ai;

   ASSERT(IS_VALID_HANDLE(hvl, VOLUMELIST));

   aicPtrs = GetPtrCount(((PCVOLUMELIST)hvl)->hpa);

   for (ai = 0; ai < aicPtrs; ai++)
      ClearVolumeInfo(GetPtr(((PCVOLUMELIST)hvl)->hpa, ai));

   WARNING_OUT((TEXT("ClearVolumeListInfo(): Volume cache cleared.")));
}


VOLUMERESULT AddVolume(HVOLUMELIST hvl, LPCTSTR pcszPath,
                                   PHVOLUME phvol, LPTSTR pszPathSuffixBuf)
{
   VOLUMERESULT vr;
   TCHAR rgchPath[MAX_PATH_LEN];
   LPTSTR pszFileName;
   DWORD dwPathLen;

   ASSERT(IS_VALID_HANDLE(hvl, VOLUMELIST));
   ASSERT(IS_VALID_STRING_PTR(pcszPath, CSTR));
   ASSERT(IS_VALID_WRITE_PTR(phvol, HVOLUME));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszPathSuffixBuf, STR, MAX_PATH_LEN));

   dwPathLen = GetFullPathName(pcszPath, ARRAYSIZE(rgchPath), rgchPath,
                               &pszFileName);

   if (dwPathLen > 0 && dwPathLen < ARRAYSIZE(rgchPath))
   {
      ARRAYINDEX aiFound;

      /* Does a volume for this root path already exist? */

      if (LinearSearchArray(((PVOLUMELIST)hvl)->hpa,
                            &SearchForVolumeByRootPathCmp, rgchPath,
                            &aiFound))
      {
         PVOLUME pvol;
         LPCTSTR pcszVolumeRootPath;

         /* Yes. */

         pvol = GetPtr(((PVOLUMELIST)hvl)->hpa, aiFound);

         LockVolume(pvol);

         ASSERT(pvol->vs == VS_AVAILABLE &&
                IS_FLAG_SET(pvol->dwFlags, VOLUME_FL_ROOT_PATH_VALID));

         pcszVolumeRootPath = GetBfcString(pvol->hsRootPath);

         ASSERT(lstrlen(pcszVolumeRootPath) <= lstrlen(rgchPath));

         lstrcpy(pszPathSuffixBuf, rgchPath + lstrlen(pcszVolumeRootPath));

         *phvol = (HVOLUME)pvol;
         vr = VR_SUCCESS;
      }
      else
      {
         DWORD dwOutFlags;
         TCHAR rgchNetResource[MAX_PATH_LEN];
         LPTSTR pszRootPathSuffix;

         /* No.  Create a new volume. */

         if (GetCanonicalPathInfo(pcszPath, rgchPath, &dwOutFlags,
                                  rgchNetResource, &pszRootPathSuffix))
         {
            PLINKINFO pli;

            lstrcpy(pszPathSuffixBuf, pszRootPathSuffix);
            *pszRootPathSuffix = TEXT('\0');

            WARNING_OUT((TEXT("AddVolume(): Creating LinkInfo for root path %s."),
                         rgchPath));

            if (CreateLinkInfo(rgchPath, &pli))
            {
               PVOLUME pvol;

               if (CreateVolume((PVOLUMELIST)hvl, pli, &pvol))
               {
                  TCHAR rgchUnusedVolumeRootPath[MAX_PATH_LEN];

                  ResolveVolumeRootPath(pvol, rgchUnusedVolumeRootPath);

                  *phvol = (HVOLUME)pvol;
                  vr = VR_SUCCESS;
               }
               else
                  vr = VR_OUT_OF_MEMORY;

               DestroyLinkInfo(pli);
            }
            else
               /*
                * Differentiate between VR_UNAVAILABLE_VOLUME and
                * VR_OUT_OF_MEMORY.
                */
               vr = VOLUMERESULTFromLastError(VR_UNAVAILABLE_VOLUME);
         }
         else
            vr = VOLUMERESULTFromLastError(VR_INVALID_PATH);
      }
   }
   else
   {
      ASSERT(! dwPathLen);

      vr = VOLUMERESULTFromLastError(VR_INVALID_PATH);
   }

   ASSERT(vr != VR_SUCCESS ||
          (IS_VALID_HANDLE(*phvol, VOLUME) &&
           EVAL(IsValidPathSuffix(pszPathSuffixBuf))));

   return(vr);
}


void DeleteVolume(HVOLUME hvol)
{
   ASSERT(IS_VALID_HANDLE(hvol, VOLUME));

   if (! UnlockVolume((PVOLUME)hvol))
   {
      UnlinkVolume((PVOLUME)hvol);
      DestroyVolume((PVOLUME)hvol);
   }
}


COMPARISONRESULT CompareVolumes(HVOLUME hvolFirst,
                                            HVOLUME hvolSecond)
{
   ASSERT(IS_VALID_HANDLE(hvolFirst, VOLUME));
   ASSERT(IS_VALID_HANDLE(hvolSecond, VOLUME));

   /* This comparison works across volume lists. */

   return(CompareLinkInfoVolumes(((PCVOLUME)hvolFirst)->pli,
                                 ((PCVOLUME)hvolSecond)->pli));
}


BOOL CopyVolume(HVOLUME hvolSrc, HVOLUMELIST hvlDest,
                            PHVOLUME phvolCopy)
{
   BOOL bResult;
   PVOLUME pvol;

   ASSERT(IS_VALID_HANDLE(hvolSrc, VOLUME));
   ASSERT(IS_VALID_HANDLE(hvlDest, VOLUMELIST));
   ASSERT(IS_VALID_WRITE_PTR(phvolCopy, HVOLUME));

   /* Is the destination volume list the source volume's volume list? */

   if (((PCVOLUME)hvolSrc)->pvlParent == (PCVOLUMELIST)hvlDest)
   {
      /* Yes.  Use the source volume. */

      LockVolume((PVOLUME)hvolSrc);
      pvol = (PVOLUME)hvolSrc;
      bResult = TRUE;
   }
   else
      bResult = CreateVolume((PVOLUMELIST)hvlDest, ((PCVOLUME)hvolSrc)->pli,
                             &pvol);

   if (bResult)
      *phvolCopy = (HVOLUME)pvol;

   ASSERT(! bResult ||
          IS_VALID_HANDLE(*phvolCopy, VOLUME));

   return(bResult);
}


BOOL IsVolumeAvailable(HVOLUME hvol)
{
   TCHAR rgchUnusedVolumeRootPath[MAX_PATH_LEN];

   ASSERT(IS_VALID_HANDLE(hvol, VOLUME));

   ResolveVolumeRootPath((PVOLUME)hvol, rgchUnusedVolumeRootPath);

   ASSERT(IsValidVOLUMESTATE(((PCVOLUME)hvol)->vs) &&
          ((PCVOLUME)hvol)->vs != VS_UNKNOWN);

   return(((PCVOLUME)hvol)->vs == VS_AVAILABLE);
}


void GetVolumeRootPath(HVOLUME hvol, LPTSTR pszRootPathBuf)
{
   ASSERT(IS_VALID_HANDLE(hvol, VOLUME));
   ASSERT(IS_VALID_WRITE_BUFFER_PTR(pszRootPathBuf, STR, MAX_PATH_LEN));

   ResolveVolumeRootPath((PVOLUME)hvol, pszRootPathBuf);

   ASSERT(IsRootPath(pszRootPathBuf));
}


ULONG GetVolumeCount(HVOLUMELIST hvl)
{
   ASSERT(IS_VALID_HANDLE(hvl, VOLUMELIST));

   return(GetPtrCount(((PCVOLUMELIST)hvl)->hpa));
}


void DescribeVolume(HVOLUME hvol, PVOLUMEDESC pvoldesc)
{
   PCVOID pcv;

   ASSERT(IS_VALID_HANDLE(hvol, VOLUME));

   ASSERT(pvoldesc->ulSize == sizeof(*pvoldesc));

   pvoldesc->dwFlags = 0;

   if (GetLinkInfoData(((PCVOLUME)hvol)->pli, LIDT_VOLUME_SERIAL_NUMBER, &pcv))
   {
      pvoldesc->dwSerialNumber = *(PCDWORD)pcv;
      SET_FLAG(pvoldesc->dwFlags, VD_FL_SERIAL_NUMBER_VALID);
   }
   else
      pvoldesc->dwSerialNumber = 0;

   if (GetLinkInfoData(((PCVOLUME)hvol)->pli, LIDT_VOLUME_LABELW, &pcv) && pcv)
   {
      lstrcpy(pvoldesc->rgchVolumeLabel, pcv);
      SET_FLAG(pvoldesc->dwFlags, VD_FL_VOLUME_LABEL_VALID);
   }
   else if (GetLinkInfoData(((PCVOLUME)hvol)->pli, LIDT_VOLUME_LABEL, &pcv) && pcv)
   {
      MultiByteToWideChar( OurGetACP(), 0, pcv, -1, pvoldesc->rgchVolumeLabel, MAX_PATH);
      SET_FLAG(pvoldesc->dwFlags, VD_FL_VOLUME_LABEL_VALID);
   }
   else
   {
      pvoldesc->rgchVolumeLabel[0] = TEXT('\0');
   }

   if (GetLinkInfoData(((PCVOLUME)hvol)->pli, LIDT_NET_RESOURCEW, &pcv) && pcv)
   {
        lstrcpy(pvoldesc->rgchNetResource, pcv);
        SET_FLAG(pvoldesc->dwFlags, VD_FL_NET_RESOURCE_VALID);
   }
   else if (GetLinkInfoData(((PCVOLUME)hvol)->pli, LIDT_NET_RESOURCE, &pcv) && pcv)
   {
        MultiByteToWideChar( OurGetACP(), 0, pcv, -1, pvoldesc->rgchNetResource, MAX_PATH);
        SET_FLAG(pvoldesc->dwFlags, VD_FL_NET_RESOURCE_VALID);
   }
   else
      pvoldesc->rgchNetResource[0] = TEXT('\0');

   ASSERT(IS_VALID_STRUCT_PTR(pvoldesc, CVOLUMEDESC));
}


TWINRESULT WriteVolumeList(HCACHEDFILE hcf, HVOLUMELIST hvl)
{
   TWINRESULT tr = TR_BRIEFCASE_WRITE_FAILED;
   DWORD dwcbDBVolumeListHeaderOffset;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_HANDLE(hvl, VOLUMELIST));

   /* Save initial file position. */

   dwcbDBVolumeListHeaderOffset = GetCachedFilePointerPosition(hcf);

   if (dwcbDBVolumeListHeaderOffset != INVALID_SEEK_POSITION)
   {
      DBVOLUMELISTHEADER dbvlh;

      /* Leave space for volume list header. */

      ZeroMemory(&dbvlh, sizeof(dbvlh));

      if (WriteToCachedFile(hcf, (PCVOID)&dbvlh, sizeof(dbvlh), NULL))
      {
         ARRAYINDEX aicPtrs;
         ARRAYINDEX ai;
         UINT ucbMaxLinkInfoLen = 0;
         LONG lcVolumes = 0;

         tr = TR_SUCCESS;

         aicPtrs = GetPtrCount(((PCVOLUMELIST)hvl)->hpa);

         /* Write all volumes. */

         for (ai = 0; ai < aicPtrs; ai++)
         {
            PVOLUME pvol;

            pvol = GetPtr(((PCVOLUMELIST)hvl)->hpa, ai);

            /*
             * As a sanity check, don't save any volume with a lock count of 0.
             * A 0 lock count implies that the volume has not been referenced
             * since it was restored from the database, or something is broken.
             */

            if (pvol->ulcLock > 0)
            {
               tr = WriteVolume(hcf, pvol);

               if (tr == TR_SUCCESS)
               {
                  ASSERT(lcVolumes < LONG_MAX);
                  lcVolumes++;

                  if (pvol->pli->ucbSize > ucbMaxLinkInfoLen)
                     ucbMaxLinkInfoLen = pvol->pli->ucbSize;
               }
               else
                  break;
            }
            else
               ERROR_OUT((TEXT("WriteVolumeList(): VOLUME has 0 lock count and will not be written.")));
         }

         /* Save volume list header. */

         if (tr == TR_SUCCESS)
         {
            dbvlh.lcVolumes = lcVolumes;
            dbvlh.ucbMaxLinkInfoLen = ucbMaxLinkInfoLen;

            tr = WriteDBSegmentHeader(hcf, dwcbDBVolumeListHeaderOffset,
                                      &dbvlh, sizeof(dbvlh));

            TRACE_OUT((TEXT("WriteVolumeList(): Wrote %ld volumes; maximum LinkInfo length %u bytes."),
                       dbvlh.lcVolumes,
                       dbvlh.ucbMaxLinkInfoLen));
         }
      }
   }

   return(tr);
}


TWINRESULT ReadVolumeList(HCACHEDFILE hcf, HVOLUMELIST hvl,
                                      PHHANDLETRANS phht)
{
   TWINRESULT tr;
   DBVOLUMELISTHEADER dbvlh;
   DWORD dwcbRead;

   ASSERT(IS_VALID_HANDLE(hcf, CACHEDFILE));
   ASSERT(IS_VALID_HANDLE(hvl, VOLUMELIST));
   ASSERT(IS_VALID_WRITE_PTR(phht, HHANDLETRANS));

   if (ReadFromCachedFile(hcf, &dbvlh, sizeof(dbvlh), &dwcbRead) &&
       dwcbRead == sizeof(dbvlh))
   {
      HHANDLETRANS hht;

      tr = TR_OUT_OF_MEMORY;

      if (CreateHandleTranslator(dbvlh.lcVolumes, &hht))
      {
         PLINKINFO pliBuf;

         if (AllocateMemory(dbvlh.ucbMaxLinkInfoLen, &pliBuf))
         {
            LONG l;

            tr = TR_SUCCESS;

            TRACE_OUT((TEXT("ReadPathList(): Reading %ld volumes; maximum LinkInfo length %u bytes."),
                       dbvlh.lcVolumes,
                       dbvlh.ucbMaxLinkInfoLen));

            for (l = 0; l < dbvlh.lcVolumes; l++)
            {
               tr = ReadVolume(hcf, (PVOLUMELIST)hvl, pliBuf,
                               dbvlh.ucbMaxLinkInfoLen, hht);

               if (tr != TR_SUCCESS)
                  break;
            }

            if (tr == TR_SUCCESS)
            {
               PrepareForHandleTranslation(hht);
               *phht = hht;

               ASSERT(IS_VALID_HANDLE(hvl, VOLUMELIST));
               ASSERT(IS_VALID_HANDLE(*phht, HANDLETRANS));
            }
            else
               DestroyHandleTranslator(hht);

            FreeMemory(pliBuf);
         }
      }
   }
   else
      tr = TR_CORRUPT_BRIEFCASE;

   ASSERT(tr != TR_SUCCESS ||
          (IS_VALID_HANDLE(hvl, VOLUMELIST) &&
           IS_VALID_HANDLE(*phht, HANDLETRANS)));

   return(tr);
}


BOOL
EnumFirstBrfcasePath (
    IN      HBRFCASE Brfcase,
    OUT     PBRFPATH_ENUM e
    )
{
    e->PathList = GetBriefcasePathList(Brfcase);
    e->Max = GetPtrCount(((PCPATHLIST)e->PathList)->hpa);
    e->Index = 0;
    return EnumNextBrfcasePath (e);
}


BOOL
EnumNextBrfcasePath (
    IN OUT  PBRFPATH_ENUM e
    )
{
    if (e->Index >= e->Max) {
        return FALSE;
    }

    e->Path = GetPtr(((PCPATHLIST)e->PathList)->hpa, e->Index);
    GetPathString (e->Path, e->PathString);
    e->Index++;
    return TRUE;
}


BOOL
ReplaceBrfcasePath (
    IN      PBRFPATH_ENUM PathEnum,
    IN      PCTSTR NewPath
    )
{
    HSTRING hsNew;
    PCTSTR PathSuffix;
    PPATH Path;
    PCPATHLIST PathList;

    MYASSERT (NewPath[1] == TEXT(':') && NewPath[2] == TEXT('\\'));

    PathSuffix = NewPath + 3;
    Path = (PPATH)PathEnum->Path;

    if (CharCount (NewPath) <= CharCount (PathEnum->PathString)) {
        //
        // just copy over
        //
        StringCopy ((PTSTR)GetBfcString (Path->hsPathSuffix), PathSuffix);

    } else {
        PathList = (PCPATHLIST)PathEnum->PathList;
        if (!AddString (PathSuffix, PathList->hst, GetHashBucketIndex, &hsNew)) {
            return FALSE;
        }
        DeleteString (Path->hsPathSuffix);
        Path->hsPathSuffix = hsNew;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\merge\merge.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    merge.c

Abstract:

    Registry merge code

Author:

    Jim Schmidt (jimschm) 17-Feb-1997

Revision History:

    jimschm     23-Sep-1998 String mapping mechanism
    jimschm     24-Mar-1998 Added more complex hkcr processing

--*/

#include "pch.h"
#include "mergep.h"

static PCTSTR g_InfFileName;

BOOL g_ProcessRenameTable = FALSE;
DWORD g_ProgressBarCounter;
HKEY g_DuHandle;

BOOL
pForceCopy (
    HINF InfFile
    );

BOOL
pForceCopyFromMemDb (
    VOID
    );

BOOL
pCreateRenameTable (
    IN  HINF InfFile,
    OUT PVOID *RenameTablePtr
    );

BOOL
pProcessRenameTable (
    IN PVOID RenameTable
    );

BOOL
pSpecialConversion (
    IN  HINF InfFile,
    IN  PCTSTR User,
    IN  PVOID RenameTable
    );

BOOL
pProcessSuppressList (
    IN  HINF InfFile,
    IN  PCTSTR SectionName
    );

BOOL
pProcessHardwareSuppressList (
    IN  HINF InfFile
    );

BOOL
pSuppressNTDefaults (
    IN  HINF InfFile,
    IN  PCTSTR SectionName
    );

BOOL
pDontCombineWithDefaults (
    IN  HINF InfFile,
    IN  PCTSTR SectionName
    );

BOOL
pForceNTDefaults (
    IN  HINF InfFile,
    IN  PCTSTR SectionName
    );

BOOL
pForceNTDefaultsHack (
    IN  HINF InfFile,
    IN  PCTSTR SectionName
    );

BOOL
pMergeWin95WithUser (
    IN  PVOID RenameTable
    );

BOOL
pSpecialConversionNT (
    IN  HINF InfFile,
    IN  PCTSTR User,
    IN  BOOL PerUser
    );

BOOL
pMergeNTDefaultsWithUser (
    IN  HINF InfFile
    );

BOOL
pCopyWin95ToSystem (
    VOID
    );

BOOL
pMergeWin95WithSystem (
    VOID
    );

BOOL
pDeleteAfterMigration (
    IN HINF InfFile
    );

FILTERRETURN
SuppressFilter95 (
    IN      CPDATAOBJECT SrcObjectPtr,
    IN      CPDATAOBJECT DestObjectPtr,     OPTIONAL
    IN      FILTERTYPE FilterType,
    IN      PVOID DontCare
    );

//
// Globals
//

POOLHANDLE g_TempPool;
POOLHANDLE g_RenamePool;
PMAPSTRUCT g_CompleteMatchMap;
PMAPSTRUCT g_SubStringMap;

BOOL
WINAPI
Merge_Entry (
    IN HINSTANCE hinstDLL,
    IN DWORD dwReason,
    IN PVOID lpv
    )

/*++

Routine Description:

  DllMain is called after the C runtime is initialized, and its purpose
  is to initialize the globals for this process.

Arguments:

  hinstDLL  - (OS-supplied) Instance handle for the DLL
  dwReason  - (OS-supplied) Type of initialization or termination
  lpv       - (OS-supplied) Unused

Return Value:

  TRUE because DLL always initializes properly.

--*/

{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        if(!pSetupInitializeUtils()) {
            return FALSE;
        }
        g_CompleteMatchMap = CreateStringMapping();
        g_SubStringMap = CreateStringMapping();
        break;


    case DLL_PROCESS_DETACH:
        DestroyStringMapping (g_CompleteMatchMap);
        DestroyStringMapping (g_SubStringMap);
        pSetupUninitializeUtils();
        break;
    }

    return TRUE;
}



BOOL
MergeRegistry (
    IN  PCTSTR FileName,
    IN  PCTSTR User
    )
{
    HINF hInf;                      // handle to the INF being processed
    BOOL b = FALSE;                 // Return value
    PVOID RenameTable = NULL;
    BOOL LogonAccount = FALSE;
    BOOL DefaultUserAccount = FALSE;

    g_ProgressBarCounter = 0;

    //
    // Open the INF
    //

    g_InfFileName = FileName;
    hInf = InfOpenInfFile (FileName);

    if (hInf == INVALID_HANDLE_VALUE) {
        LOG ((LOG_ERROR, "MergeRegistry: SetupOpenInfFile failed for %s", FileName));
        return FALSE;
    }

    g_TempPool = PoolMemInitNamedPool ("Merge: temp pool");
    g_RenamePool = PoolMemInitNamedPool ("Merge: Rename pool");

    if (!g_TempPool || !g_RenamePool) {
        DEBUGMSG ((DBG_ERROR, "MergeRegistry: Can't init pool"));
        goto c0;
    }

    PoolMemSetMinimumGrowthSize (g_TempPool, 16384);

    if (User) {
        SetCurrentUserW (g_FixedUserName);
    }

    //
    // Perform forced copy of Win95 registry, build rename table,
    // execute registry value conversions, convert types, and mark
    // specified keys as suppressed.
    //

    if (!pForceCopy (hInf)) {
        goto c0;
    }

    if (!User) {
        if (!pForceCopyFromMemDb ()) {
            goto c0;
        }
    }

    if (!pCreateRenameTable (hInf, &RenameTable)) {
        goto c0;
    }

    //
    // Identify the logon account or default user account
    //

    if (User) {
        if (*User == 0 || StringIMatch (User, S_DOT_DEFAULT)) {

            DEBUGMSG ((DBG_NAUSEA, "The logon user account is indicated by user name '%s'", User));
            LogonAccount = TRUE;

        } else if (StringIMatch (User, S_DEFAULT_USER)) {

            DEBUGMSG ((DBG_NAUSEA, "The default user account template is indicated by user name '%s'", User));
            DefaultUserAccount = TRUE;
        }
    }

    //
    // Prepare flags for registry merging
    //

    if (!pProcessSuppressList (hInf, S_MERGE_WIN9X_SUPPRESS)) {
        goto c0;
    }

    if (User) {
        //
        // These functions read usermig.inf and set flags
        // for the keys, key trees or values, as specified in
        // the INF.
        //

        if (!pSuppressNTDefaults (hInf, S_MERGE_WINNT_SUPPRESS)) {
            goto c0;
        }

        if (!pDontCombineWithDefaults (hInf, S_MERGE_DONT_COMBINE_WITH_DEFAULT)) {
            goto c0;
        }

        if (!pForceNTDefaults (hInf, S_MERGE_FORCE_NT_DEFAULTS)) {
            goto c0;
        }

        if (LogonAccount) {
            if (!pProcessSuppressList (hInf, S_MERGE_WIN9X_SUPPRESS_LU)) {
                goto c0;
            }
        }

        if (DefaultUserAccount) {
            if (!pProcessSuppressList (hInf, S_MERGE_WIN9X_SUPPRESS_DU)) {
                goto c0;
            }
        }

        g_DuHandle = OpenRegKeyStr (L"hklm\\" S_MAPPED_DEFAULT_USER_KEY);

    } else {
        if (!pForceNTDefaults (hInf, S_MERGE_FORCE_NT_DEFAULTS)) {
            goto c0;
        }

        if (!pProcessHardwareSuppressList (hInf)) {
            goto c0;
        }
    }

    if (!pSpecialConversion (hInf, User, RenameTable)) {
        goto c0;
    }

    //
    // Perform merge
    //

    if (User) {
        // User merge
        if (!pMergeWin95WithUser (RenameTable)) {
            goto c0;
        }

        if (!pSpecialConversionNT (hInf, User, TRUE)) {
            goto c0;
        }

        if (!LogonAccount && !DefaultUserAccount) {
            // Non-default user, not logon prompt account
            if (!pMergeNTDefaultsWithUser (hInf)) {
                goto c0;
            }
        }
    }
    else {
        // Workstation merge
        if (!pCopyWin95ToSystem()) {
            goto c0;
        }

        if (!pForceNTDefaultsHack (hInf, S_MERGE_FORCE_NT_DEFAULTS)) {
            goto c0;
        }

        if (!pMergeWin95WithSystem()) {
            goto c0;
        }

        if (!CopyHardwareProfiles (hInf)) {
            goto c0;
        }
        TickProgressBar ();

        if (!pSpecialConversionNT (hInf, NULL, FALSE)) {
            goto c0;
        }
        TickProgressBar ();
    }

    g_ProcessRenameTable = TRUE;

    b = pProcessRenameTable (RenameTable);
    TickProgressBar ();

    g_ProcessRenameTable = FALSE;

    //
    // Once we are done with the complete registry merge, process the special section
    // [Delete After Migration]
    //

    if (!pDeleteAfterMigration (hInf)) {
        LOG((LOG_ERROR,"Registry Merge: Delete After Migration failed."));
        goto c0;
    }

c0:
    if (RenameTable) {
        pSetupStringTableDestroy (RenameTable);
    }

    if (User) {
        SetCurrentUserW (NULL);
    }

    if (g_TempPool) {
        PoolMemDestroyPool (g_TempPool);
    }
    if (g_RenamePool) {
        PoolMemDestroyPool (g_RenamePool);
    }

    if (g_DuHandle) {
        CloseRegKey (g_DuHandle);
        g_DuHandle = NULL;
    }

    InfCloseInfFile (hInf);

    return b;
}


PTSTR
pGetStringFromObjectData (
    IN  CPDATAOBJECT ObPtr
    )
{
    PTSTR p;
    PTSTR end;

    //
    // Value type has to be a registry object
    //

    if (!DoesObjectHaveValue (ObPtr) ||
        !IsRegistryTypeSpecified (ObPtr)
        ) {
        return NULL;
    }

    if (ObPtr->Type == REG_DWORD) {
        return NULL;
    }

    if (ObPtr->Value.Size & 1) {
        return NULL;
    }

    p = (PTSTR) ObPtr->Value.Buffer;
    end = (PTSTR) ((PBYTE) p + ObPtr->Value.Size);

    if ((end - p) >= MAX_PATH) {
        return NULL;
    }

    if (ObPtr->Type == REG_SZ || ObPtr->Type == REG_EXPAND_SZ) {
        return p;
    }

    //
    // For REG_NONE and REG_BINARY, give it a try by looking for a terminated string
    //

    if (*(end - 1)) {
        return NULL;
    }

    return p;
}


BOOL
SetObjectStringFlag (
    IN  PCTSTR ObjectStr,
    IN  DWORD   Flag,
    IN  DWORD   RemoveFlag
    )
{
    DWORD Val;

    if (!MemDbGetValue (ObjectStr, &Val)) {
        Val = 0;
    }

    if (Val & RemoveFlag) {
        if (Val & RemoveFlag & (~Flag)) {
            DEBUGMSG ((DBG_WARNING, "SetObjectStringFlag: Removing flag %x from val %x in %s",
                       Val & RemoveFlag, Val, ObjectStr));
            Val = Val & (~RemoveFlag);
        }
    }

    Val |= Flag;
    return MemDbSetValue (ObjectStr, Val);
}


BOOL
SetObjectStructFlag (
    IN  CPDATAOBJECT ObPtr,
    DWORD Flag,
    DWORD RemoveFlag
    )
{
    TCHAR EncodedObject[MAX_ENCODED_RULE];

    CreateObjectString (ObPtr, EncodedObject);
    return SetObjectStringFlag (EncodedObject, Flag, RemoveFlag);
}


BOOL
CreateRenamedObjectStruct (
    IN      PVOID RenameTable,
    IN      PDATAOBJECT InObPtr,
    OUT     PDATAOBJECT OutObPtr
    )

// returns TRUE when OutObPtr is different than InObPtr

{
    LONG rc;
    PCTSTR NewPtr;
    PTSTR p;
    PCTSTR Tail;
    PCTSTR RealValueName;
    TCHAR EncodedObject[MAX_ENCODED_RULE];
    TCHAR CopyOfEncodedObject[MAX_ENCODED_RULE];
    PTSTR NewEncodedObject;
    BOOL b = FALSE;

    ZeroMemory (OutObPtr, sizeof (DATAOBJECT));

    if (InObPtr->KeyPtr) {
        // Look for HKR\sub\key
        InObPtr->ObjectType &= ~(OT_TREE);
        RealValueName = InObPtr->ValueName;
        InObPtr->ValueName = NULL;

        CreateObjectString (InObPtr, EncodedObject);
        StringCopy (CopyOfEncodedObject, EncodedObject);

        InObPtr->ValueName = RealValueName;

        rc = pSetupStringTableLookUpStringEx (RenameTable,
                                        EncodedObject,
                                        STRTAB_CASE_INSENSITIVE,
                                        (PBYTE) &NewPtr,
                                        sizeof (NewPtr)
                                        );
        if (rc != -1) {
            CreateObjectStruct (NewPtr, OutObPtr, WINNTOBJECT);
            b = TRUE;
        } else if (*EncodedObject) {
            // Look for HKR\sub\key\*, HKR\sub\* and HKR\*
            p = GetEndOfString (EncodedObject);
            do {
                StringCopy (p, TEXT("\\*"));

                rc = pSetupStringTableLookUpStringEx (RenameTable,
                                                EncodedObject,
                                                STRTAB_CASE_INSENSITIVE,
                                                (PBYTE) &NewPtr,
                                                sizeof (NewPtr)
                                                );
                if (rc != -1) {
                    Tail = CopyOfEncodedObject + (p - EncodedObject);
                    NewEncodedObject = JoinPaths (NewPtr, Tail);
                    CreateObjectStruct (NewEncodedObject, OutObPtr, WINNTOBJECT);
                    FreePathString (NewEncodedObject);
                    b = TRUE;
                    break;
                }

                do {
                    // _tcsdec is fixed in strings.h
                    p = _tcsdec2 (EncodedObject, p);
                } while (p && _tcsnextc (p) != TEXT('\\'));
            } while (p);
        }
    }

    if (InObPtr->ValueName) {
        if (InObPtr->KeyPtr) {
            // Look for HKR\sub\key\[value]
            CreateObjectString (InObPtr, EncodedObject);

            rc = pSetupStringTableLookUpStringEx (RenameTable,
                                            EncodedObject,
                                            STRTAB_CASE_INSENSITIVE,
                                            (PBYTE) &NewPtr,
                                            sizeof (NewPtr)
                                            );
            if (rc != -1) {
                CreateObjectStruct (NewPtr, OutObPtr, WINNTOBJECT);
                b = TRUE;
            }
        }
    }

    if (!b) {
        // If rename not found, copy in object to out object
        CopyMemory (OutObPtr, InObPtr, sizeof (DATAOBJECT));
    }

    return b;
}


BOOL
CreateRenamedObjectString (
    IN      PVOID RenameTable,
    IN      PCTSTR InObStr,
    OUT     PTSTR OutObStr
    )
{
    DATAOBJECT InObject, OutObject;
    BOOL b;

    if (!CreateObjectStruct (InObStr, &InObject, WIN95OBJECT)) {
        return FALSE;
    }

    b = CreateRenamedObjectStruct (RenameTable, &InObject, &OutObject);

    CreateObjectString (&OutObject, OutObStr);

    FreeObjectStruct (&InObject);
    if (b) {
        FreeObjectStruct (&OutObject);
    }

    return b;
}


BOOL
pForceCopy (
    HINF InfFile
    )
{
    INFCONTEXT ic;
    TCHAR SrcObjectStr[MAX_ENCODED_RULE];
    TCHAR DestObjectStr[MAX_ENCODED_RULE];
    DATAOBJECT SrcObject, DestObject, DupObject;
    BOOL b = TRUE;
    FILTERRETURN fr;

    //
    // Look in INF for [ForceCopy] section
    //

    if (SetupFindFirstLine (InfFile, S_MERGE_FORCECOPY, NULL, &ic)) {
        //
        // For each line in this section, get the encoded object in
        // field 0 (the source) and copy it to the encoded object in
        // field 1 (the destination).
        //
        do {
            *DestObjectStr = 0;
            if (SetupGetStringField (&ic, 0, SrcObjectStr, MAX_ENCODED_RULE, NULL) &&
                SetupGetStringField (&ic, 1, DestObjectStr, MAX_ENCODED_RULE, NULL)
                ) {
                if (!(*DestObjectStr)) {
                    StringCopy (DestObjectStr, SrcObjectStr);
                }

                if (!CreateObjectStruct (SrcObjectStr, &SrcObject, WIN95OBJECT)) {
                    DEBUGMSG ((DBG_WARNING, "pForceCopy: Source object invalid (Section line %u of %s)",
                              ic.Line, g_InfFileName));
                    continue;
                }

                if (!CreateObjectStruct (DestObjectStr, &DestObject, WINNTOBJECT)) {
                    DEBUGMSG ((DBG_WARNING, "pForceCopy: Destination object invalid (Section line %u of %s)",
                              ic.Line, g_InfFileName));
                    FreeObjectStruct (&SrcObject);
                    continue;
                }

                if (b = DuplicateObjectStruct (&DupObject, &SrcObject)) {
                    if (b = CombineObjectStructs (&DupObject, &DestObject)) {
                        //
                        // Copy source to dest
                        //

                        fr = CopyObject (&SrcObject, &DupObject, NULL, NULL);
                        if (fr == FILTER_RETURN_FAIL) {
                            LOG ((LOG_ERROR, "Force Copy: CopyObject failed for %s=%s in %s", SrcObjectStr, DestObjectStr, g_InfFileName));
                            b = FALSE;
                        }
                    }

                    FreeObjectStruct (&DupObject);
                }

                FreeObjectStruct (&SrcObject);
                FreeObjectStruct (&DestObject);
            } else {
                LOG ((LOG_ERROR, "Force Copy: syntax error in line %u of section %s in %s",
                          ic.Line, S_MERGE_FORCECOPY, g_InfFileName));
            }

            TickProgressBar ();

        } while (b && SetupFindNextLine (&ic, &ic));
    }

    return TRUE;
}

BOOL
pForceCopyFromMemDb (
    VOID
    )
{
    MEMDB_ENUM e;
    TCHAR key [MEMDB_MAX];
    TCHAR SrcObjectStr[MAX_ENCODED_RULE];
    TCHAR DestObjectStr[MAX_ENCODED_RULE];
    DATAOBJECT SrcObject, DestObject, DupObject;
    BOOL b = TRUE;
    FILTERRETURN fr;

    //
    // Look in MemDb for ForceCopy tree
    //
    MemDbBuildKey (key, MEMDB_CATEGORY_FORCECOPY, TEXT("*"), NULL, NULL);
    if (MemDbEnumFirstValue (&e, key, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
        //
        // For each key here the offset points to the destination
        //
        do {
            if (e.dwValue != 0) {
                StringCopy (SrcObjectStr, e.szName);

                if (MemDbBuildKeyFromOffset (e.dwValue, DestObjectStr, 1, NULL)) {

                    if (!(*DestObjectStr)) {
                        StringCopy (DestObjectStr, SrcObjectStr);
                    }

                    if (!CreateObjectStruct (SrcObjectStr, &SrcObject, WIN95OBJECT)) {
                        DEBUGMSG ((DBG_WARNING, "pForceCopyFromMemDb: Source object invalid %s",
                                  SrcObjectStr));
                        continue;
                    }

                    if (!CreateObjectStruct (DestObjectStr, &DestObject, WINNTOBJECT)) {
                        DEBUGMSG ((DBG_WARNING, "pForceCopyFromMemDb: Destination object invalid %s",
                                  DestObjectStr));
                        FreeObjectStruct (&SrcObject);
                        continue;
                    }

                    if (b = DuplicateObjectStruct (&DupObject, &SrcObject)) {
                        if (b = CombineObjectStructs (&DupObject, &DestObject)) {
                            //
                            // Copy source to dest
                            //

                            fr = CopyObject (&SrcObject, &DupObject, NULL, NULL);
                            if (fr == FILTER_RETURN_FAIL) {
                                LOG ((LOG_ERROR, "Force Copy from MemDb: CopyObject failed for %s=%s", SrcObjectStr, DestObjectStr));
                                b = FALSE;
                            }
                        }

                        FreeObjectStruct (&DupObject);
                    }

                    FreeObjectStruct (&SrcObject);
                    FreeObjectStruct (&DestObject);
                }
            }
            TickProgressBar ();

        } while (b && MemDbEnumNextValue (&e));
    }

    return TRUE;
}


#define S_MERGE_DELETEAFTERMIGRATION TEXT("Delete After Migration")

BOOL
pDeleteAfterMigration (
    IN HINF InfFile
    )
{
    BOOL rSuccess = TRUE;
    TCHAR objectString[MAX_ENCODED_RULE];
    DATAOBJECT object;
    INFCONTEXT ic;
    HKEY key;

    //
    // Look in INF for [DeleteAfterMigration] section
    //

    if (SetupFindFirstLine (InfFile, S_MERGE_DELETEAFTERMIGRATION, NULL, &ic)) {

        //
        // For each line in this section, get the encoded object in
        // field 0 and delete it from the registry.
        //

        do {

            if (SetupGetStringField(&ic,0,objectString,MAX_ENCODED_RULE,NULL)) {

                FixUpUserSpecifiedObject(objectString);

                if (!CreateObjectStruct(objectString,&object,WINNTOBJECT)) {
                    LOG((
                        LOG_ERROR,
                        "Delete After Migration: ObjectString invalid. (Section line %u of %s)",
                        ic.Line,
                        g_InfFileName
                        ));

                    continue;
                }

                //
                // We have a good object. Delete it!
                //

                if (object.ValueName) {

                    //
                    // Value is specified. Delete it.
                    //
                    if (!RegDeleteValue(object.KeyPtr->OpenKey,object.ValueName)) {
                        DEBUGMSG((DBG_WARNING,"pDeleteAfterMigration: RegDeleteValue failed for %s [%s]",
                            object.KeyPtr->KeyString,
                            object.ValueName ? object.ValueName : TEXT("<DEFAULT>")
                            ));
                    }
                }
                else {

                    key = GetRootKeyFromOffset (object.RootItem);
                    pSetupRegistryDelnode (key == HKEY_ROOT ? g_hKeyRootNT : key, object.KeyPtr->KeyString);

                }


                //
                // Free our resources.
                //
                FreeObjectStruct(&object);
            }

        } while (SetupFindNextLine(&ic,&ic));
     }

    return rSuccess;
}


BOOL
pCreateRenameTable (
    IN  HINF InfFile,
    OUT PVOID *RenameTablePtr
    )
{
    INFCONTEXT ic;
    TCHAR SrcObjectStr[MAX_ENCODED_RULE];
    TCHAR DestObjectStr[MAX_ENCODED_RULE];
    LONG rc;
    DATAOBJECT OrgOb;
    DATAOBJECT NewOb;
    PCTSTR DestStr;

    //
    // Look in INF for [Rename] section
    //

    if (SetupFindFirstLine (InfFile, S_MERGE_RENAME, NULL, &ic)) {
        //
        // Create string table
        //
        *RenameTablePtr = pSetupStringTableInitializeEx (sizeof (PCTSTR), 0);
        if (!(*RenameTablePtr)) {
            LOG ((LOG_ERROR, "Create Rename Table: Cannot allocate a string table"));
            return FALSE;
        }

        do {
            if (SetupGetStringField (&ic, 0, SrcObjectStr, MAX_ENCODED_RULE, NULL) &&
                SetupGetStringField (&ic, 1, DestObjectStr, MAX_ENCODED_RULE, NULL)
                ) {
                // Ignore bad lines

                FixUpUserSpecifiedObject (SrcObjectStr);
                FixUpUserSpecifiedObject (DestObjectStr);

                if (!CreateObjectStruct (SrcObjectStr, &OrgOb, WIN95OBJECT)) {
                    DEBUGMSG ((DBG_WARNING, "pCreateRenameTable: Source object invalid (Section line %u of %s)",
                              ic.Line, g_InfFileName));
                    continue;
                }

                if (!CreateObjectStruct (DestObjectStr, &NewOb, WINNTOBJECT)) {
                    FreeObjectStruct (&OrgOb);
                    DEBUGMSG ((DBG_WARNING, "pCreateRenameTable: Dest object invalid (Section line %u of %s)",
                              ic.Line, g_InfFileName));
                    continue;
                }

                //
                // Convert DestObjectStr into complete object string
                //

                if (!CombineObjectStructs (&OrgOb, &NewOb)) {
                    FreeObjectStruct (&NewOb);
                    FreeObjectStruct (&OrgOb);

                    DEBUGMSG ((DBG_WARNING, "pCreateRenameTable: Can't perform the rename (Section line %u in %s)",
                              ic.Line, g_InfFileName));
                    continue;
                }

                // Disable tree for destination object
                OrgOb.ObjectType &= ~OT_TREE;

                CreateObjectString (&OrgOb, DestObjectStr);
                FreeObjectStruct (&NewOb);
                FreeObjectStruct (&OrgOb);

                DestStr = PoolMemDuplicateString (g_RenamePool, DestObjectStr);
                if (!DestStr) {
                    break;
                }

                rc = pSetupStringTableAddStringEx (
                            *RenameTablePtr,
                            (PTSTR) SrcObjectStr,
                            STRTAB_CASE_INSENSITIVE,
                            (PBYTE) &DestStr,
                            sizeof (PCTSTR)
                            );

                if (rc == -1) {
                    SetLastError (rc);
                    LOG ((LOG_ERROR, "Create Rename Table: Cannot add string to string table"));
                    break;
                }

                SetObjectStringFlag (SrcObjectStr, REGMERGE_95_RENAME, REGMERGE_95_RENAME);
                SetObjectStringFlag (DestStr, REGMERGE_NT_SUPPRESS, REGMERGE_NT_MASK);
            } else {
                LOG ((LOG_ERROR, "Create Rename Table: syntax error in line %u of section %s in %s",
                          ic.Line, S_MERGE_RENAME, g_InfFileName));
            }

            TickProgressBar ();

        } while (SetupFindNextLine (&ic, &ic));
    } else {
        return FALSE;
    }

    return TRUE;
}

BOOL
CopyRenameTableEntry (
    PVOID   StringTable,
    LONG    StringID,
    PCTSTR  SrcObjectStr,
    PVOID   ExtraData,
    UINT    ExtraDataSize,
    LPARAM  lParam
    )
{
    PCTSTR DestObjectStr = *((PCTSTR *) ExtraData);
    DATAOBJECT SrcOb, DestOb;
    FILTERRETURN fr = FILTER_RETURN_FAIL;
    DWORD Val;

    // See if src has been processed
    if (MemDbGetValue (SrcObjectStr, &Val) && (Val & REGMERGE_95_RENAME_SUPPRESS)) {
        return TRUE;
    }

    // If not, copy Win95 src to WinNT dest
    if (CreateObjectStruct (SrcObjectStr, &SrcOb, WIN95OBJECT)) {
        if (CreateObjectStruct (DestObjectStr, &DestOb, WINNTOBJECT)) {
            fr = CopyObject (&SrcOb, &DestOb, SuppressFilter95, NULL);
            FreeObjectStruct (&DestOb);
        }
        FreeObjectStruct (&SrcOb);
    }

    return fr != FILTER_RETURN_FAIL;
}

BOOL
pProcessRenameTable (
    IN PVOID RenameTable
    )
{
    PCTSTR DataBuf;

    return pSetupStringTableEnum (RenameTable, (PVOID) &DataBuf, sizeof (DataBuf), CopyRenameTableEntry, 0);
}



BOOL
pSpecialConversion (
    IN  HINF InfFile,
    IN  PCTSTR User,
    IN  PVOID RenameTable
    )
{
    INFCONTEXT ic;
    TCHAR FunctionStr[MAX_ENCODED_RULE];
    TCHAR SrcObjectStr[MAX_ENCODED_RULE];
    TCHAR RenamedObjectStr[MAX_ENCODED_RULE];
    PROCESSINGFN Fn;
    PVOID Arg;

    //
    // Look in INF for [SpecialConversion] section
    //

    if (SetupFindFirstLine (InfFile, S_MERGE_WIN9X_CONVERSION, NULL, &ic)) {
        //
        // For each line, get the function and the source object, then call
        // the function.
        //

        do {
            if (SetupGetStringField (&ic, 0, FunctionStr, MAX_ENCODED_RULE, NULL) &&
                SetupGetStringField (&ic, 1, SrcObjectStr, MAX_ENCODED_RULE, NULL)
                ) {
                FixUpUserSpecifiedObject (SrcObjectStr);

                Fn = RuleHlpr_GetFunctionAddr (FunctionStr, &Arg);
                if (!Fn) {
                    LOG ((LOG_ERROR, "Special Conversion: Invalid function %s in %s", FunctionStr, g_InfFileName));
                    continue;
                }

                CreateRenamedObjectString (RenameTable, SrcObjectStr, RenamedObjectStr);

                if (!Fn (SrcObjectStr, RenamedObjectStr, User, Arg)) {
                    if (GetLastError () == ERROR_SUCCESS) {
                        continue;
                    }

                    LOG ((LOG_ERROR, "Processing of Special Conversion was aborted because %s failed.", FunctionStr));
                    break;
                }

                SetObjectStringFlag (
                    SrcObjectStr,
                    REGMERGE_95_SUPPRESS|REGMERGE_95_RENAME_SUPPRESS,
                    REGMERGE_95_SUPPRESS|REGMERGE_95_RENAME_SUPPRESS
                    );

                SetObjectStringFlag (RenamedObjectStr, REGMERGE_NT_SUPPRESS, REGMERGE_NT_MASK);

            } else {
                LOG ((LOG_ERROR, "Special Conversion: syntax error in line %u of section %s in %s",
                          ic.Line, S_MERGE_WIN9X_CONVERSION, g_InfFileName));
            }

            TickProgressBar ();

        } while (SetupFindNextLine (&ic, &ic));
    }

    return TRUE;
}


BOOL
SetFlagsForObject (
    IN  HINF InfFile,
    IN  PCTSTR Section,
    IN  DWORD Flag,
    IN  DWORD RemoveFlag
    )
{
    INFCONTEXT ic;
    TCHAR SrcObjectStr[MAX_ENCODED_RULE];

    //
    // Look in INF for section
    //

    if (SetupFindFirstLine (InfFile, Section, NULL, &ic)) {
        //
        // For each line, get the object and mark it as suppressed.
        //

        do {
            if (SetupGetStringField (&ic, 1, SrcObjectStr, MAX_ENCODED_RULE, NULL)
                ) {
                FixUpUserSpecifiedObject (SrcObjectStr);
                SetObjectStringFlag (SrcObjectStr, Flag, RemoveFlag);
            } else {
                LOG ((LOG_ERROR, "Set Flags For Object: syntax error in line %u of section %s in %s",
                          ic.Line, Section, g_InfFileName));
            }
            TickProgressBar ();
        } while (SetupFindNextLine (&ic, &ic));
    } else {
        DEBUGMSG ((DBG_VERBOSE, "SetFlagsForObject: Section %s can't be found", Section));
    }

    return TRUE;
}

BOOL
pProcessSuppressList (
    IN  HINF InfFile,
    IN  PCTSTR SectionName
    )
{
    return SetFlagsForObject (
                InfFile,
                SectionName,
                REGMERGE_95_SUPPRESS,
                REGMERGE_95_SUPPRESS
                );
}


BOOL
pProcessHardwareSuppressList (
    IN  HINF InfFile
    )
{
    return SetFlagsForObject (InfFile, S_MERGE_WIN9X_SUPPRESS_HW, REGMERGE_95_SUPPRESS, REGMERGE_95_SUPPRESS);
}


BOOL
pSuppressNTDefaults (
    IN  HINF InfFile,
    IN  PCTSTR SectionName
    )
{
    //
    // The objects listed in Suppress WinNT Settings are enumerated,
    // and they are blocked from being transferred from the NT default
    // user to the new user.
    //

    return SetFlagsForObject (
                InfFile,
                SectionName,
                REGMERGE_NT_SUPPRESS,
                REGMERGE_NT_SUPPRESS
                );
}

BOOL
pDontCombineWithDefaults (
    IN  HINF InfFile,
    IN  PCTSTR SectionName
    )
{
    //
    // The objects listed in Merge WinNT with Win9x are enumerated,
    // and they are blocked from being transferred from the NT default
    // user to the new user.  In addition, they are put in a list
    // to be processed at the end of user registry migration.  This
    // last step uses CombineFilter to make sure the NT values do
    // not overwrite the 9x values.
    //

    return SetFlagsForObject (
                InfFile,
                SectionName,
                REGMERGE_NT_IGNORE_DEFAULTS,
                REGMERGE_NT_IGNORE_DEFAULTS
                );
}

BOOL
pForceNTDefaults (
    IN  HINF InfFile,
    IN  PCTSTR SectionName
    )
{
    //
    // The objects listed in Force WinNT Settings are enumerated,
    // and they are blocked from being processed during the general
    // 9x to NT copy.  In addition, they are put in a list to be
    // processed at the end of user registry migration.  This last
    // step forces the entire key to be copied from the default
    // user to the new user, overwriting any previously migrated
    // settings.
    //
    // It is important to note that the special conversion functions
    // are not suppressed here, but the converted settings may be
    // overwritten.
    //

    return SetFlagsForObject (
                InfFile,
                SectionName,
                REGMERGE_NT_PRIORITY_NT|REGMERGE_95_SUPPRESS,
                REGMERGE_NT_PRIORITY_NT|REGMERGE_95_SUPPRESS
                );
}

BOOL
pForceNTDefaultsHack (
    IN  HINF InfFile,
    IN  PCTSTR SectionName
    )
{
    //
    // Take away the REGMERGE_95_SUPPRESS flag now, because the general
    // 9x merge has completed, but we get confused between an actual
    // suppress and a suppress done for the priority-nt case.
    //

    return SetFlagsForObject (
                InfFile,
                SectionName,
                REGMERGE_NT_PRIORITY_NT,
                REGMERGE_NT_PRIORITY_NT|REGMERGE_95_SUPPRESS
                );
}


FILTERRETURN
SuppressFilter95 (
    IN      CPDATAOBJECT SrcObjectPtr,
    IN      CPDATAOBJECT DestObjectPtr,     OPTIONAL
    IN      FILTERTYPE FilterType,
    IN      PVOID DontCare
    )
{
    TCHAR ObStr[MAX_ENCODED_RULE];
    DWORD Val;
    PTSTR p, q, r;
    TCHAR Node[MEMDB_MAX];

    if (FilterType == FILTER_CREATE_KEY) {
        //
        // Check if this tree is suppressed
        //

        MYASSERT (SrcObjectPtr->ObjectType & OT_TREE);
        MYASSERT (SrcObjectPtr->KeyPtr);
        MYASSERT (!(SrcObjectPtr->ValueName));

        // Query setting for HKR\Sub\Key\*
        CreateObjectString (SrcObjectPtr, ObStr);
        if (MemDbGetValue (ObStr, &Val)) {
            if (Val & REGMERGE_95_SUPPRESS) {
                return FILTER_RETURN_DONE;
            }

            if (!g_ProcessRenameTable && (Val & REGMERGE_95_RENAME)) {
                return FILTER_RETURN_DONE;
            }
        }

        // If key is a GUID and GUID is suppressed, suppress the tree
        p = (PTSTR) SrcObjectPtr->ChildKey;
        if (p && _tcsnextc (p) == TEXT('{')) {
            // Look for matching curly brace
            q = _tcschr (p, TEXT('}'));
            if (q) {
                q = _tcsinc (q);

                // Create GUIDS\{a-b-c-d-e}
                *Node = 0;
                r = _tcsappend (Node, MEMDB_CATEGORY_GUIDS);
                r = _tcsappend (r, TEXT("\\"));
                StringCopyAB (r, p, q);

                // Look for match
                if (MemDbGetValue (Node, NULL)) {
                    DEBUGMSG ((DBG_VERBOSE, "Suppressed %s found in %s", Node, ObStr));
                    return FILTER_RETURN_DONE;
                }
            }
        }
    }

    else if (FilterType == FILTER_PROCESS_VALUES) {
        //
        // Check if this node is suppressed
        //

        MYASSERT (!(SrcObjectPtr->ObjectType & OT_TREE));
        MYASSERT (SrcObjectPtr->KeyPtr);
        MYASSERT (!(SrcObjectPtr->ValueName));
        CreateObjectString (SrcObjectPtr, ObStr);

        // Query setting for HKR\Sub\Key
        if (!MemDbGetValue (ObStr, &Val)) {
            Val = 0;
        }

        if (Val & REGMERGE_95_SUPPRESS) {
            return FILTER_RETURN_HANDLED;
        }

        if (!g_ProcessRenameTable && (Val & REGMERGE_95_RENAME)) {
            return FILTER_RETURN_HANDLED;
        }

    }

    else if (FilterType == FILTER_VALUENAME_ENUM) {
        //
        // Check if this value is suppressed
        //

        MYASSERT (!(SrcObjectPtr->ObjectType & OT_TREE));
        MYASSERT (SrcObjectPtr->KeyPtr);
        MYASSERT (SrcObjectPtr->ValueName);
        CreateObjectString (SrcObjectPtr, ObStr);

        // If value name is a GUID and GUID is suppressed, suppress the value
        p = (PTSTR) SrcObjectPtr->ValueName;
        if (_tcsnextc (p) == TEXT('{')) {
            MemDbBuildKey (Node, MEMDB_CATEGORY_GUIDS, NULL, NULL, p);
            if (MemDbGetValue (Node, NULL)) {
                return FILTER_RETURN_HANDLED;
            }
        }

        if (!MemDbGetValue (ObStr, &Val)) {
            Val = 0;
        }

        if (Val & REGMERGE_95_SUPPRESS) {
            return FILTER_RETURN_HANDLED;
        }

        if (!g_ProcessRenameTable && (Val & REGMERGE_95_RENAME)) {
            return FILTER_RETURN_HANDLED;
        }

    }

    else if (FilterType == FILTER_VALUE_COPY) {
        //
        // Don't copy if value has a suppressed GUID
        //

        p = pGetStringFromObjectData (SrcObjectPtr);

        if (p && _tcsnextc (p) == TEXT('{')) {
            MemDbBuildKey (Node, MEMDB_CATEGORY_GUIDS, NULL, NULL, p);
            if (MemDbGetValue (Node, NULL)) {
                return FILTER_RETURN_HANDLED;
            }
        }
    }

    return FILTER_RETURN_CONTINUE;
}


FILTERRETURN
SuppressFilterNT (
    IN      CPDATAOBJECT SrcObjectPtr,
    IN      CPDATAOBJECT DestObjectPtr,         OPTIONAL
    IN      FILTERTYPE FilterType,
    IN      PVOID DontCare
    )
{
    TCHAR ObStr[MAX_ENCODED_RULE];
    DWORD Val;
    PTSTR p;

    if (FilterType == FILTER_CREATE_KEY) {
        //
        // Check if this tree is suppressed
        //

        MYASSERT (DestObjectPtr->ObjectType & OT_TREE);
        MYASSERT (DestObjectPtr->KeyPtr);
        MYASSERT (!(DestObjectPtr->ValueName));
        CreateObjectString (DestObjectPtr, ObStr);

        if (MemDbGetValue (ObStr, &Val) && (Val & REGMERGE_NT_MASK)) {
            return FILTER_RETURN_DONE;
        }
    }


    else if (FilterType == FILTER_PROCESS_VALUES) {
        DATAOBJECT CopyOfDestOb;
        DWORD rc;
        DWORD ValueCount;

        //
        // Does destination already exist?
        //

        CopyMemory (&CopyOfDestOb, DestObjectPtr, sizeof (DATAOBJECT));
        if (OpenObject (&CopyOfDestOb)) {
            //
            // Does it have values?
            //

            MYASSERT (!IsWin95Object (&CopyOfDestOb));

            rc = RegQueryInfoKey (
                    CopyOfDestOb.KeyPtr->OpenKey,
                    NULL,                           // class
                    NULL,                           // class size
                    NULL,                           // reserved
                    NULL,                           // subkey count
                    NULL,                           // max subkey length
                    NULL,                           // max class length
                    &ValueCount,
                    NULL,                           // max value name size
                    NULL,                           // max value size
                    NULL,                           // security
                    NULL                            // last changed time
                    );

            if (rc == ERROR_SUCCESS && ValueCount > 0) {
                CloseObject (&CopyOfDestOb);
                return FILTER_RETURN_HANDLED;
            }
        }


        //
        // Check if this node is suppressed
        //

        MYASSERT (DestObjectPtr->ObjectType & OT_TREE);
        MYASSERT (DestObjectPtr->KeyPtr);
        MYASSERT (!(DestObjectPtr->ValueName));

        CreateObjectString (DestObjectPtr, ObStr);
        p = _tcsrchr (ObStr, TEXT('\\'));
        if (p) {
            *p = 0;
        }


        if (MemDbGetValue (ObStr, &Val) && (Val & REGMERGE_NT_MASK)) {
            return FILTER_RETURN_HANDLED;
        }
    }

    else if (FilterType == FILTER_VALUENAME_ENUM) {
        //
        // Check if this value is suppressed
        //

        MYASSERT (!(DestObjectPtr->ObjectType & OT_TREE));
        MYASSERT (DestObjectPtr->KeyPtr);
        MYASSERT (DestObjectPtr->ValueName);
        CreateObjectString (DestObjectPtr, ObStr);

        if (MemDbGetValue (ObStr, &Val) && (Val & REGMERGE_NT_MASK)) {
            return FILTER_RETURN_HANDLED;
        }
    }

    return FILTER_RETURN_CONTINUE;
}


FILTERRETURN
CombineFilter (
    IN      CPDATAOBJECT SrcObjectPtr,
    IN      CPDATAOBJECT DestObjectPtr,         OPTIONAL
    IN      FILTERTYPE FilterType,
    IN      PVOID DontCare
    )
{
    BOOL b;

    if (FilterType == FILTER_VALUE_COPY) {
        //
        // Check if destination already exists in the registry
        //

        MYASSERT (!(SrcObjectPtr->ObjectType & OT_TREE));
        MYASSERT (SrcObjectPtr->KeyPtr);
        MYASSERT (SrcObjectPtr->ValueName);
        MYASSERT (!(DestObjectPtr->ObjectType & OT_TREE));
        MYASSERT (DestObjectPtr->KeyPtr);
        MYASSERT (DestObjectPtr->ValueName);

        b = CheckIfNtKeyExists (DestObjectPtr);

        if (b) {
            return FILTER_RETURN_HANDLED;
        } else if (GetLastError() != ERROR_SUCCESS) {
            return FILTER_RETURN_FAIL;
        }
    }

    return FILTER_RETURN_CONTINUE;
}


FILTERRETURN
pSuppressDefaultUserFilter (
    IN      CPDATAOBJECT SrcObjectPtr,
    IN      CPDATAOBJECT DestObjectPtr,         OPTIONAL
    IN      FILTERTYPE FilterType,
    IN      PVOID DontCare
    )
{
    TCHAR ObStr[MAX_ENCODED_RULE];
    DWORD Val;
    PTSTR p;

    if (FilterType == FILTER_CREATE_KEY) {
        //
        // Check if this tree is suppressed
        //

        MYASSERT (DestObjectPtr->ObjectType & OT_TREE);
        MYASSERT (DestObjectPtr->KeyPtr);
        MYASSERT (!(DestObjectPtr->ValueName));



        CreateObjectString (DestObjectPtr, ObStr);

        if (MemDbGetValue (ObStr, &Val) && (Val & REGMERGE_NT_IGNORE_DEFAULTS)) {
            return FILTER_RETURN_DONE;
        }
    }

    else if (FilterType == FILTER_PROCESS_VALUES) {
        //
        // Check if this node is suppressed
        //

        MYASSERT (DestObjectPtr->ObjectType & OT_TREE);
        MYASSERT (DestObjectPtr->KeyPtr);
        MYASSERT (!(DestObjectPtr->ValueName));

        CreateObjectString (DestObjectPtr, ObStr);
        p = _tcsrchr (ObStr, TEXT('\\'));
        if (p) {
            *p = 0;
        }


        if (MemDbGetValue (ObStr, &Val) && (Val & REGMERGE_NT_IGNORE_DEFAULTS)) {
            return FILTER_RETURN_HANDLED;
        }

    }

    else if (FilterType == FILTER_VALUENAME_ENUM) {
        //
        // Check if this value is suppressed
        //

        MYASSERT (!(DestObjectPtr->ObjectType & OT_TREE));
        MYASSERT (DestObjectPtr->KeyPtr);
        MYASSERT (DestObjectPtr->ValueName);



        CreateObjectString (DestObjectPtr, ObStr);

        if (MemDbGetValue (ObStr, &Val) && (Val & REGMERGE_NT_IGNORE_DEFAULTS)) {
            return FILTER_RETURN_HANDLED;
        }
    }

    return CombineFilter (SrcObjectPtr, DestObjectPtr, FilterType, DontCare);
}


FILTERRETURN
CopyNoOverwriteFilter (
    IN      CPDATAOBJECT SrcObjectPtr,
    IN      CPDATAOBJECT DestObjectPtr,         OPTIONAL
    IN      FILTERTYPE FilterType,
    IN      PVOID DontCare
    )
{
    FILTERRETURN fr;

    fr = SuppressFilter95 (SrcObjectPtr, DestObjectPtr, FilterType, DontCare);
    if (fr != FILTER_RETURN_CONTINUE) {
        return fr;
    }

    return CombineFilter (SrcObjectPtr, DestObjectPtr, FilterType, DontCare);
}


BOOL
pMergeWin95WithUser (
    IN  PVOID RenameTable
    )
{
    DATAOBJECT SrcOb, DestOb;
    BOOL b;
    FILTERRETURN fr;

    //
    // Copy unsuppressed Win95 keys to NT user hive
    //

    b = CreateObjectStruct (TEXT("HKR\\*"), &SrcOb, WIN95OBJECT);
    MYASSERT (b);

    b = CreateObjectStruct (TEXT("HKR\\*"), &DestOb, WINNTOBJECT);
    MYASSERT (b);

    fr = CopyObject (&SrcOb, &DestOb, SuppressFilter95, NULL);

    FreeObjectStruct (&SrcOb);
    FreeObjectStruct (&DestOb);

    if (fr == FILTER_RETURN_FAIL) {
        LOG ((LOG_ERROR, "Merge Win95 With User: CopyObject failed"));
        return FALSE;
    }

    return TRUE;
}

VOID
RegistryCombineWorker (
    DWORD Flag,
    FILTERFUNCTION FilterFn,
    PCTSTR MemDbRoot,
    PCTSTR SrcRoot,
    DWORD SrcObjectType
    )
{
    MEMDB_ENUM e;
    TCHAR SrcRegKey[MEMDB_MAX];
    TCHAR DestRegKey[MEMDB_MAX];
    PTSTR SrcPtr, DestPtr;
    DATAOBJECT SrcOb, DestOb;
    FILTERRETURN fr;
    TCHAR Pattern[32];

    wsprintf (Pattern, TEXT("%s\\*"), MemDbRoot);

    //
    // Enumerate all keys in memdb and call CopyObject for them
    //

    *SrcRegKey = 0;
    *DestRegKey = 0;

    SrcPtr = _tcsappend (SrcRegKey, SrcRoot);
    SrcPtr = _tcsappend (SrcPtr, TEXT("\\"));

    DestPtr = _tcsappend (DestRegKey, MemDbRoot);
    DestPtr = _tcsappend (DestPtr, TEXT("\\"));

    if (MemDbEnumFirstValue (
            &e,
            Pattern,
            MEMDB_ALL_SUBLEVELS,
            MEMDB_ENDPOINTS_ONLY
            )) {

        do {
            if ((e.dwValue & REGMERGE_NT_MASK) & Flag) {
                StringCopy (SrcPtr, e.szName);
                StringCopy (DestPtr, e.szName);

                if (!CreateObjectStruct (SrcRegKey, &SrcOb, SrcObjectType)) {
                    LOG ((LOG_ERROR, "Merge NT Defaults With User: Can't create object for %s", SrcRegKey));
                    continue;
                }

                if (!CreateObjectStruct (DestRegKey, &DestOb, WINNTOBJECT)) {
                    FreeObjectStruct (&SrcOb);
                    LOG ((LOG_ERROR, "Merge NT Defaults With User: Can't create object for %s", SrcRegKey));
                    continue;
                }

                fr = CopyObject (&SrcOb, &DestOb, FilterFn, NULL);
                if (fr == FILTER_RETURN_FAIL) {
                    LOG ((LOG_ERROR, "Merge NT Defaults With User: Can't copy %s to %s", SrcRegKey, DestRegKey));
                }

                FreeObjectStruct (&SrcOb);
                FreeObjectStruct (&DestOb);
            }

            TickProgressBar ();

        } while (MemDbEnumNextValue (&e));
    }
}


BOOL
pMergeNTDefaultsWithUser (
    HINF hInf
    )
{
    DATAOBJECT SrcOb, DestOb;
    FILTERRETURN fr;
    BOOL b;

    //
    // Copy unsuppressed NT defaults to NT user hive
    //

    b = CreateObjectStruct (
            TEXT("HKLM\\") S_MAPPED_DEFAULT_USER_KEY TEXT("\\*"),
            &SrcOb,
            WINNTOBJECT
            );

    MYASSERT (b);

    b = CreateObjectStruct (TEXT("HKR\\*"), &DestOb, WINNTOBJECT);
    MYASSERT (b);

    __try {
        b = FALSE;

        fr = CopyObject (&SrcOb, &DestOb, SuppressFilterNT, NULL);

        if (fr == FILTER_RETURN_FAIL) {
            LOG ((LOG_ERROR, "Merge NT Defaults With User: CopyObject failed"));
            __leave;
        }

        //
        // Copy forced NT defaults to NT user hive, then copy all NT defaults
        // that need to be combined with Win95 settings.
        //

        RegistryCombineWorker (
            REGMERGE_NT_PRIORITY_NT,
            NULL,
            TEXT("HKR"),
            TEXT("HKLM\\") S_MAPPED_DEFAULT_USER_KEY,
            WINNTOBJECT
            );

        fr = CopyObject (&SrcOb, &DestOb, pSuppressDefaultUserFilter, NULL);

        if (fr == FILTER_RETURN_FAIL) {
            LOG ((LOG_ERROR, "Combine NT Defaults With User: CopyObject failed"));
            __leave;
        }

        b = TRUE;
    }

    __finally {
        FreeObjectStruct (&SrcOb);
        FreeObjectStruct (&DestOb);
    }

    return b;
}


BOOL
pCopyWin9xValuesNotInNt (
    HINF hInf
    )
{
    DATAOBJECT SrcOb, DestOb;
    FILTERRETURN fr;
    BOOL b;

    //
    // Copy Win9x values that NT does not have
    //

    b = CreateObjectStruct (
            TEXT("HKLM\\*"),
            &SrcOb,
            WIN95OBJECT
            );

    MYASSERT (b);

    b = CreateObjectStruct (TEXT("HKR\\*"), &DestOb, WINNTOBJECT);
    MYASSERT (b);

    __try {
        b = FALSE;

        fr = CopyObject (&SrcOb, &DestOb, SuppressFilterNT, NULL);

        if (fr == FILTER_RETURN_FAIL) {
            LOG ((LOG_ERROR, "Merge NT Defaults With User: CopyObject failed"));
            __leave;
        }

        //
        // Copy forced NT defaults to NT user hive, then copy all NT defaults
        // that need to be combined with Win95 settings.
        //

        RegistryCombineWorker (
            REGMERGE_NT_PRIORITY_NT,
            NULL,
            TEXT("HKR"),
            TEXT("HKLM\\") S_MAPPED_DEFAULT_USER_KEY,
            WINNTOBJECT
            );

        fr = CopyObject (&SrcOb, &DestOb, pSuppressDefaultUserFilter, NULL);

        if (fr == FILTER_RETURN_FAIL) {
            LOG ((LOG_ERROR, "Combine NT Defaults With User: CopyObject failed"));
            __leave;
        }

        b = TRUE;
    }

    __finally {
        FreeObjectStruct (&SrcOb);
        FreeObjectStruct (&DestOb);
    }

    return b;
}


BOOL
pMergeWin95WithSystem (
    VOID
    )

/*++

Routine Description:

  pMergeWin95WithSystem copies the Win95 registry to NT, skipping values
  that already exist on NT.

Arguments:

  none

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    RegistryCombineWorker (
        REGMERGE_NT_PRIORITY_NT,
        CopyNoOverwriteFilter,
        TEXT("HKLM"),               // memdb root and dest root
        TEXT("HKLM"),               // source root
        WIN95OBJECT
        );

    return TRUE;
}


BOOL
pCopyWin95ToSystem (
    VOID
    )

/*++

Routine Description:

  pCopyWin95ToSystem copies all Win95 settings to NT, unless the setting
  is supressed.  This achieves a copy with overwrite capability.

Arguments:

  none

Return Value:

  TRUE if success, FALSE if failure.

--*/

{
    DATAOBJECT SrcOb, DestOb;
    BOOL b;
    FILTERRETURN fr;

    b = CreateObjectStruct (TEXT("HKLM\\*"), &SrcOb, WIN95OBJECT);
    MYASSERT (b);

    b = CreateObjectStruct (TEXT("HKLM\\*"), &DestOb, WINNTOBJECT);
    MYASSERT (b);

    fr = CopyObject (&SrcOb, &DestOb, SuppressFilter95, NULL);

    FreeObjectStruct (&SrcOb);
    FreeObjectStruct (&DestOb);

    if (fr == FILTER_RETURN_FAIL) {
        LOG ((LOG_ERROR, "Copy Win95 To System: CopyObject failed"));
        return FALSE;
    }

    return TRUE;
}


BOOL
pSpecialConversionNT (
    IN  HINF InfFile,
    IN  PCTSTR User,
    IN  BOOL PerUser
    )
{
    INFCONTEXT ic;
    DATAOBJECT SrcOb, DestOb;
    TCHAR FunctionStr[MAX_ENCODED_RULE];
    TCHAR SrcObjectStr[MAX_ENCODED_RULE];
    TCHAR DestObjectStr[MAX_ENCODED_RULE];
    PROCESSINGFN Fn;
    PVOID Arg;

    //
    // Look in INF for [SpecialConversionNT] section
    //

    if (SetupFindFirstLine (InfFile, S_MERGE_WINNT_CONVERSION, NULL, &ic)) {
        //
        // For each line, get the function and the source object, then call
        // the function.
        //

        do {
            if (SetupGetStringField (&ic, 0, FunctionStr, MAX_ENCODED_RULE, NULL) &&
                SetupGetStringField (&ic, 1, DestObjectStr, MAX_ENCODED_RULE, NULL)
                ) {
                FixUpUserSpecifiedObject (DestObjectStr);

                Fn = RuleHlpr_GetFunctionAddr (FunctionStr, &Arg);

                if (!Fn) {
                    LOG ((LOG_ERROR, "Special Conversion: Invalid function %s in %s", FunctionStr, g_InfFileName));
                    continue;
                }

                if (PerUser) {
                    //
                    // Make source off of HKLM\MappedDefaultUser
                    //

                    if (!CreateObjectStruct (DestObjectStr, &SrcOb, WINNTOBJECT)) {
                        continue;
                    }

                    if (!(SrcOb.RootItem)) {
                        LOG ((LOG_ERROR, "Special Conversion NT: Invalid function object %s", DestObjectStr));
                        FreeObjectStruct (&SrcOb);
                        continue;
                    }

                    CreateObjectStruct (TEXT("HKLM"), &DestOb, WINNTOBJECT);
                    CombineObjectStructs (&SrcOb, &DestOb);

                    StringCopy (SrcObjectStr, S_MAPPED_DEFAULT_USER_KEY TEXT("\\"));
                    CreateObjectString (&SrcOb, GetEndOfString (SrcObjectStr));

                    FreeObjectStruct (&DestOb);
                    FreeObjectStruct (&SrcOb);

                } else {

                    if (!CreateObjectStruct (DestObjectStr, &SrcOb, WINNTOBJECT)) {
                        continue;
                    }

                    if (!(SrcOb.RootItem)) {
                        LOG ((LOG_ERROR, "Special Conversion NT: Invalid function object %s", DestObjectStr));
                        FreeObjectStruct (&SrcOb);
                        continue;
                    }


                    CreateObjectString (&SrcOb, SrcObjectStr);
                    FreeObjectStruct (&SrcOb);

                }

                if (!Fn (SrcObjectStr, PerUser ? DestObjectStr : SrcObjectStr, User, Arg)) {
                    if (GetLastError () == ERROR_SUCCESS) {
                        continue;
                    }

                    LOG ((LOG_ERROR, "Processing of Special Conversion was aborted because %s failed.", FunctionStr));
                    break;
                }

                SetObjectStringFlag (SrcObjectStr, REGMERGE_NT_SUPPRESS, REGMERGE_NT_MASK);
            } else {
                LOG ((LOG_ERROR, "Special Conversion NT: syntax error in line %u of section %s in %s",
                          ic.Line, S_MERGE_WINNT_CONVERSION, g_InfFileName));
            }

            TickProgressBar ();

        } while (SetupFindNextLine (&ic, &ic));
    }

    return TRUE;
}



BOOL
SuppressWin95Object (
    IN  PCTSTR ObjectStr
    )
{
    return SetObjectStringFlag (ObjectStr, REGMERGE_95_SUPPRESS, REGMERGE_95_SUPPRESS);
}



BOOL
CheckIfNtKeyExists (
    IN      CPDATAOBJECT SrcObjectPtr
    )

/*++

Routine Description:

  CheckIfNtKeyExists takes a 9x object and tests to see if the same NT
  setting exists.  The 9x object must have a key and value name.

Arguments:

  SrcObjectPtr - Specifies the 9x object to test.

Return Value:

  TRUE if the object exists in NT, FALSE if it doesn't or if an error occurs.
  GetLastError indicates the error (if any).

--*/

{
    DATAOBJECT NtObject;
    BOOL b;
    PCSTR value1;
    PCSTR value2;
    PCWSTR value3;
    PCWSTR oldValueName;
    HKEY oldRoot;

    if (!DuplicateObjectStruct (&NtObject, SrcObjectPtr)) {
        LOG ((LOG_ERROR, "Combine Filter: destination is invalid"));
        return FALSE;
    }

    SetPlatformType (&NtObject, FALSE);

    b = OpenObject (&NtObject);

    if (!b && g_DuHandle) {

        oldRoot = GetRegRoot();
        SetRegRoot (g_DuHandle);

        b = OpenObject (&NtObject);

        SetRegRoot (oldRoot);
    }

    if (b) {
        b = ReadObject (&NtObject);

        if (!b) {
            if (OurGetACP() == 932) {
                //
                // Katakana special case
                //
                oldValueName = NtObject.ValueName;
                value1 = ConvertWtoA (NtObject.ValueName);
                value2 = ConvertSBtoDB (NULL, value1, NULL);
                value3 = ConvertAtoW (value2);
                NtObject.ValueName = value3;
                FreeObjectVal (&NtObject);
                b = ReadObject (&NtObject);
                FreeConvertedStr (value3);
                FreePathStringA (value2);
                FreeConvertedStr (value1);
                NtObject.ValueName = oldValueName;
            }
        }
    }

    FreeObjectStruct (&NtObject);
    SetLastError (ERROR_SUCCESS);

    return b;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\migmain\brfcasep.h ===
/*
 * stock.h - Stock header file.
 */


/* Constants
 ************/

#define INVALID_SEEK_POSITION    (0xffffffff)

#define EMPTY_STRING             TEXT("")
#define SLASH_SLASH              TEXT("\\\\")

#define EQUAL                    TEXT('=')
#define SPACE                    TEXT(' ')
#define TAB                      TEXT('\t')
#define COLON                    TEXT(':')
#define COMMA                    TEXT(',')
#define PERIOD                   TEXT('.')
#define SLASH                    TEXT('\\')
#define BACKSLASH                TEXT('/')
#define ASTERISK                 TEXT('*')
#define QMARK                    TEXT('?')

/* limits */

#define WORD_MAX                 USHRT_MAX
#define DWORD_MAX                ULONG_MAX
#define SIZE_T_MAX               DWORD_MAX
#define PTR_MAX                  ((PCVOID)MAXULONG_PTR)

/* file system constants */

#define MAX_PATH_LEN             MAX_PATH
#define MAX_NAME_LEN             MAX_PATH
#define MAX_FOLDER_DEPTH         (MAX_PATH / 2)
#define DRIVE_ROOT_PATH_LEN      (4)

/* size macros */

#define SIZEOF(a)       sizeof(a)

/* invalid thread ID */

#define INVALID_THREAD_ID        (0xffffffff)

/* file-related flag combinations */

#define ALL_FILE_ACCESS_FLAGS          (GENERIC_READ |\
                                        GENERIC_WRITE)

#define ALL_FILE_SHARING_FLAGS         (FILE_SHARE_READ |\
                                        FILE_SHARE_WRITE)

#define ALL_FILE_ATTRIBUTES            (FILE_ATTRIBUTE_READONLY |\
                                        FILE_ATTRIBUTE_HIDDEN |\
                                        FILE_ATTRIBUTE_SYSTEM |\
                                        FILE_ATTRIBUTE_DIRECTORY |\
                                        FILE_ATTRIBUTE_ARCHIVE |\
                                        FILE_ATTRIBUTE_NORMAL |\
                                        FILE_ATTRIBUTE_TEMPORARY)

#define ALL_FILE_FLAGS                 (FILE_FLAG_WRITE_THROUGH |\
                                        FILE_FLAG_OVERLAPPED |\
                                        FILE_FLAG_NO_BUFFERING |\
                                        FILE_FLAG_RANDOM_ACCESS |\
                                        FILE_FLAG_SEQUENTIAL_SCAN |\
                                        FILE_FLAG_DELETE_ON_CLOSE |\
                                        FILE_FLAG_BACKUP_SEMANTICS |\
                                        FILE_FLAG_POSIX_SEMANTICS)

#define ALL_FILE_ATTRIBUTES_AND_FLAGS  (ALL_FILE_ATTRIBUTES |\
                                        ALL_FILE_FLAGS)


/* Macros
 *********/

#ifndef DECLARE_STANDARD_TYPES

/*
 * For a type "FOO", define the standard derived types PFOO, CFOO, and PCFOO.
 */

#define DECLARE_STANDARD_TYPES(type)      typedef type *P##type; \
                                          typedef const type C##type; \
                                          typedef const type *PC##type;

#endif

/* character manipulation */

#define IS_SLASH(ch)                      ((ch) == SLASH || (ch) == BACKSLASH)

/* bit flag manipulation */

#define SET_FLAG(dwAllFlags, dwFlag)      ((dwAllFlags) |= (dwFlag))
#define CLEAR_FLAG(dwAllFlags, dwFlag)    ((dwAllFlags) &= (~dwFlag))

#define IS_FLAG_SET(dwAllFlags, dwFlag)   ((BOOL)((dwAllFlags) & (dwFlag)))
#define IS_FLAG_CLEAR(dwAllFlags, dwFlag) (! (IS_FLAG_SET(dwAllFlags, dwFlag)))

/* array element count */

#define ARRAY_ELEMENTS(rg)                (sizeof(rg) / sizeof((rg)[0]))

/* file attribute manipulation */

#define IS_ATTR_DIR(attr)                 (IS_FLAG_SET((attr), FILE_ATTRIBUTE_DIRECTORY))
#define IS_ATTR_VOLUME(attr)              (IS_FLAG_SET((attr), FILE_ATTRIBUTE_VOLUME))


/* Types
 ********/

typedef const void *PCVOID;
typedef const INT CINT;
typedef const INT *PCINT;
typedef const UINT CUINT;
typedef const UINT *PCUINT;
typedef const BYTE CBYTE;
typedef const BYTE *PCBYTE;
typedef const WORD CWORD;
typedef const WORD *PCWORD;
typedef const DWORD CDWORD;
typedef const DWORD *PCDWORD;
typedef const CRITICAL_SECTION CCRITICAL_SECTION;
typedef const CRITICAL_SECTION *PCCRITICAL_SECTION;
typedef const FILETIME CFILETIME;
typedef const FILETIME *PCFILETIME;
typedef const SECURITY_ATTRIBUTES CSECURITY_ATTRIBUTES;
typedef const SECURITY_ATTRIBUTES *PCSECURITY_ATTRIBUTES;
typedef const WIN32_FIND_DATA CWIN32_FIND_DATA;
typedef const WIN32_FIND_DATA *PCWIN32_FIND_DATA;

DECLARE_STANDARD_TYPES(HICON);
DECLARE_STANDARD_TYPES(NMHDR);

#ifndef _COMPARISONRESULT_DEFINED_

/* comparison result */

typedef enum _comparisonresult
{
   CR_FIRST_SMALLER = -1,
   CR_EQUAL = 0,
   CR_FIRST_LARGER = +1
}
COMPARISONRESULT;
DECLARE_STANDARD_TYPES(COMPARISONRESULT);

#define _COMPARISONRESULT_DEFINED_

#endif

/*
 * debug.h - Debug macros and their retail translations.
 */


/* Macros
 *********/

/* debug output macros */

/*
 * Do not call SPEW_OUT directly.  Instead, call TRACE_OUT, WARNING_OUT,
 * ERROR_OUT, or FATAL_OUT.
 */

/*
 * call like printf(), but with an extra pair of parentheses:
 *
 * ERROR_OUT(("'%s' too big by %d bytes.", pszName, nExtra));
 */

#ifdef DEBUG

#define SPEW_OUT(args) 0

#define PLAIN_TRACE_OUT(args) 0

#define TRACE_OUT(args) 0

#define WARNING_OUT(args) 0

#define ERROR_OUT(args) 0

#define FATAL_OUT(args) 0

#else

#define PLAIN_TRACE_OUT(args)
#define TRACE_OUT(args)
#define WARNING_OUT(args)
#define ERROR_OUT(args)
#define FATAL_OUT(args)

#endif

/* parameter validation macros */

/*
 * call as:
 *
 * bPTwinOK = IS_VALID_READ_PTR(ptwin, CTWIN);
 *
 * bHTwinOK = IS_VALID_HANDLE(htwin, TWIN);
 */

#ifdef DEBUG

#define IS_VALID_READ_PTR(ptr, type) \
   (IsBadReadPtr((ptr), sizeof(type)) ? \
    (ERROR_OUT((TEXT("invalid %s read pointer - %#08lx"), (LPCTSTR)TEXT("P")TEXT(#type), (ptr))), FALSE) : \
    TRUE)

#define IS_VALID_WRITE_PTR(ptr, type) \
   (IsBadWritePtr((PVOID)(ptr), sizeof(type)) ? \
    (ERROR_OUT((TEXT("invalid %s write pointer - %#08lx"), (LPCTSTR)TEXT("P")TEXT(#type), (ptr))), FALSE) : \
    TRUE)

#define IS_VALID_STRING_PTRA(ptr, type) \
   (IsBadStringPtrA((ptr), (UINT)-1) ? \
    (ERROR_OUT((TEXT("invalid %s pointer - %#08lx"), (LPCTSTR)TEXT("P")TEXT(#type), (ptr))), FALSE) : \
    TRUE)

#define IS_VALID_STRING_PTRW(ptr, type) \
   (IsBadStringPtrW((ptr), (UINT)-1) ? \
    (ERROR_OUT((TEXT("invalid %s pointer - %#08lx"), (LPCTSTR)TEXT("P")TEXT(#type), (ptr))), FALSE) : \
    TRUE)

#ifdef UNICODE
#define IS_VALID_STRING_PTR(ptr, type) IS_VALID_STRING_PTRW(ptr, type)
#else
#define IS_VALID_STRING_PTR(ptr, type) IS_VALID_STRING_PTRA(ptr, type)
#endif

#define IS_VALID_CODE_PTR(ptr, type) \
   (IsBadCodePtr((PROC)(ptr)) ? \
    (ERROR_OUT((TEXT("invalid %s code pointer - %#08lx"), (LPCTSTR)TEXT(#type), (ptr))), FALSE) : \
    TRUE)

#define IS_VALID_READ_BUFFER_PTR(ptr, type, len) \
   (IsBadReadPtr((ptr), len) ? \
    (ERROR_OUT((TEXT("invalid %s read pointer - %#08lx"), (LPCTSTR)TEXT("P")TEXT(#type), (ptr))), FALSE) : \
    TRUE)

#define IS_VALID_WRITE_BUFFER_PTR(ptr, type, len) \
   (IsBadWritePtr((ptr), len) ? \
    (ERROR_OUT((TEXT("invalid %s write pointer - %#08lx"), (LPCTSTR)TEXT("P")TEXT(#type), (ptr))), FALSE) : \
    TRUE)

#define FLAGS_ARE_VALID(dwFlags, dwAllFlags) \
   (((dwFlags) & (~(dwAllFlags))) ? \
    (ERROR_OUT((TEXT("invalid flags set - %#08lx"), ((dwFlags) & (~(dwAllFlags))))), FALSE) : \
    TRUE)

#else

#define IS_VALID_READ_PTR(ptr, type) \
   (! IsBadReadPtr((ptr), sizeof(type)))

#define IS_VALID_WRITE_PTR(ptr, type) \
   (! IsBadWritePtr((PVOID)(ptr), sizeof(type)))

#define IS_VALID_STRING_PTR(ptr, type) \
   (! IsBadStringPtr((ptr), (UINT)-1))

#define IS_VALID_CODE_PTR(ptr, type) \
   (! IsBadCodePtr((PROC)(ptr)))

#define IS_VALID_READ_BUFFER_PTR(ptr, type, len) \
   (! IsBadReadPtr((ptr), len))

#define IS_VALID_WRITE_BUFFER_PTR(ptr, type, len) \
   (! IsBadWritePtr((ptr), len))

#define FLAGS_ARE_VALID(dwFlags, dwAllFlags) \
   (((dwFlags) & (~(dwAllFlags))) ? FALSE : TRUE)

#endif

/* handle validation macros */

#define IS_VALID_HANDLE(hnd, type) TRUE

/* structure validation macros */

#ifdef DEBUG

#define IS_VALID_STRUCT_PTR(ptr, type) TRUE

#endif


/* debug assertion macro */

/*
 * ASSERT() may only be used as a statement, not as an expression.
 *
 * call as:
 *
 * ASSERT(pszRest);
 */
/*
#ifdef DEBUG

#define ASSERT(exp) \
   if (exp) \
      ; \
   else \
      MessageBox(NULL, TEXT("assertion failed"), TEXT("TEST"), MB_OK)

#else
*/
#define ASSERT(exp)
/*
#endif
*/
/* debug evaluation macro */

/*
 * EVAL() may be used as an expression.
 *
 * call as:
 *
 * if (EVAL(pszFoo))
 *    bResult = TRUE;
 */

#ifdef DEBUG

#define EVAL(exp) \
   ((exp) || (ERROR_OUT((TEXT("evaluation failed '%s'"), (LPCTSTR)TEXT(#exp))), 0))

#else

#define EVAL(exp) \
   (exp)

#endif

/* debug break */

#ifndef DEBUG

#define DebugBreak()

#endif

/* debug exported function entry */

#define DebugEntry(szFunctionName)

/* debug exported function exit */

#define DebugExitVOID(szFunctionName)
#define DebugExit(szFunctionName, szResult)
#define DebugExitINT(szFunctionName, n)
#define DebugExitULONG(szFunctionName, ul)
#define DebugExitBOOL(szFunctionName, bool)
#define DebugExitHRESULT(szFunctionName, hr)
#define DebugExitCOMPARISONRESULT(szFunctionName, cr)
#define DebugExitTWINRESULT(szFunctionName, tr)
#define DebugExitRECRESULT(szFunctionName, rr)


/* Types
 ********/

/* GdwSpewFlags flags */

typedef enum _spewflags
{
   SPEW_FL_SPEW_PREFIX     = 0x0001,

   SPEW_FL_SPEW_LOCATION   = 0x0002,

   ALL_SPEW_FLAGS          = (SPEW_FL_SPEW_PREFIX |
                              SPEW_FL_SPEW_LOCATION)
}
SPEWFLAGS;

/* GuSpewSev values */

typedef enum _spewsev
{
   SPEW_TRACE              = 1,

   SPEW_WARNING            = 2,

   SPEW_ERROR              = 3,

   SPEW_FATAL              = 4
}
SPEWSEV;


/* Prototypes
 *************/

/* debug.c */

#ifdef DEBUG

extern BOOL SetDebugModuleIniSwitches(void);
extern BOOL InitDebugModule(void);
extern void ExitDebugModule(void);
extern void StackEnter(void);
extern void StackLeave(void);
extern ULONG GetStackDepth(void);
extern void __cdecl SpewOut(LPCTSTR pcszFormat, ...);

#endif


/* Global Variables
 *******************/

#ifdef DEBUG

/* debug.c */

extern DWORD GdwSpewFlags;
extern UINT GuSpewSev;
extern UINT GuSpewLine;
extern LPCTSTR GpcszSpewFile;

/* defined by client */

extern LPCTSTR GpcszSpewModule;

#endif

/* Prototypes
 *************/

/* memmgr.c */

extern COMPARISONRESULT MyMemComp(PCVOID, PCVOID, DWORD);
extern BOOL AllocateMemory(DWORD, PVOID *);
extern void FreeMemory(PVOID);
extern BOOL ReallocateMemory(PVOID, DWORD, DWORD, PVOID *);

/*
 * ptrarray.h - Pointer array ADT description.
 */


/* Constants
 ************/

/*
 * ARRAYINDEX_MAX is set such that (ARRAYINDEX_MAX + 1) does not overflow an
 * ARRAYINDEX.  This guarantee allows GetPtrCount() to return a count of
 * pointers as an ARRAYINDEX.
 */

#define ARRAYINDEX_MAX           (LONG_MAX - 1)


/* Types
 ********/

/* handles */

DECLARE_HANDLE(HPTRARRAY);
DECLARE_STANDARD_TYPES(HPTRARRAY);

/* array index */

typedef LONG ARRAYINDEX;
DECLARE_STANDARD_TYPES(ARRAYINDEX);

/*
 * pointer comparison callback function
 *
 * In sorting functions, both pointers are pointer array elements.  In
 * searching functions, the first pointer is reference data and the second
 * pointer is a pointer array element.
 */

typedef COMPARISONRESULT (*COMPARESORTEDPTRSPROC)(PCVOID, PCVOID);

/*
 * pointer comparison callback function
 *
 * In searching functions, the first pointer is reference data and the second
 * pointer is a pointer array element.
 */

typedef BOOL (*COMPAREUNSORTEDPTRSPROC)(PCVOID, PCVOID);

/* new pointer array flags */

typedef enum _newptrarrayflags
{
   /* Insert elements in sorted order. */

   NPA_FL_SORTED_ADD       = 0x0001,

   /* flag combinations */

   ALL_NPA_FLAGS           = NPA_FL_SORTED_ADD
}
NEWPTRARRAYFLAGS;

/* new pointer array description */

typedef struct _newptrarray
{
   DWORD dwFlags;

   ARRAYINDEX aicInitialPtrs;

   ARRAYINDEX aicAllocGranularity;
}
NEWPTRARRAY;
DECLARE_STANDARD_TYPES(NEWPTRARRAY);


/* Prototypes
 *************/

/* ptrarray.c */

extern BOOL CreatePtrArray(PCNEWPTRARRAY, PHPTRARRAY);
extern void DestroyPtrArray(HPTRARRAY);
extern BOOL InsertPtr(HPTRARRAY, COMPARESORTEDPTRSPROC, ARRAYINDEX, PCVOID);
extern BOOL AddPtr(HPTRARRAY, COMPARESORTEDPTRSPROC, PCVOID, PARRAYINDEX);
extern void DeletePtr(HPTRARRAY, ARRAYINDEX);
extern void DeleteAllPtrs(HPTRARRAY);
extern ARRAYINDEX GetPtrCount(HPTRARRAY);
extern PVOID GetPtr(HPTRARRAY, ARRAYINDEX);
extern void SortPtrArray(HPTRARRAY, COMPARESORTEDPTRSPROC);
extern BOOL SearchSortedArray(HPTRARRAY, COMPARESORTEDPTRSPROC, PCVOID, PARRAYINDEX);
extern BOOL LinearSearchArray(HPTRARRAY, COMPAREUNSORTEDPTRSPROC, PCVOID, PARRAYINDEX);

extern BOOL IsValidHPTRARRAY(HPTRARRAY);


extern BOOL IsValidHGLOBAL(HGLOBAL);


/*
 * list.h - List ADT description.
 */


/* Types
 ********/

/* handles */

DECLARE_HANDLE(HLIST);
DECLARE_STANDARD_TYPES(HLIST);

DECLARE_HANDLE(HNODE);
DECLARE_STANDARD_TYPES(HNODE);

/*
 * sorted list node comparison callback function
 *
 * The first pointer is reference data and the second pointer is a list node
 * data element.
 */

typedef COMPARISONRESULT (*COMPARESORTEDNODESPROC)(PCVOID, PCVOID);

/*
 * unsorted list node comparison callback function
 *
 * The first pointer is reference data and the second pointer is a list node
 * data element.
 */

typedef BOOL (*COMPAREUNSORTEDNODESPROC)(PCVOID, PCVOID);

/*
 * WalkList() callback function - called as:
 *
 *    bContinue = WalkList(pvNodeData, pvRefData);
 */

typedef BOOL (*WALKLIST)(PVOID, PVOID);

/* new list flags */

typedef enum _newlistflags
{
   /* Insert nodes in sorted order. */

   NL_FL_SORTED_ADD        = 0x0001,

   /* flag combinations */

   ALL_NL_FLAGS            = NL_FL_SORTED_ADD
}
NEWLISTFLAGS;

/* new list description */

typedef struct _newlist
{
   DWORD dwFlags;
}
NEWLIST;
DECLARE_STANDARD_TYPES(NEWLIST);


/* Prototypes
 *************/

/* list.c */

extern BOOL CreateList(PCNEWLIST, PHLIST);
extern void DestroyList(HLIST);
extern BOOL AddNode(HLIST, COMPARESORTEDNODESPROC, PCVOID, PHNODE);
extern BOOL InsertNodeAtFront(HLIST, COMPARESORTEDNODESPROC, PCVOID, PHNODE);
extern BOOL InsertNodeBefore(HNODE, COMPARESORTEDNODESPROC, PCVOID, PHNODE);
extern BOOL InsertNodeAfter(HNODE, COMPARESORTEDNODESPROC, PCVOID, PHNODE);
extern void DeleteNode(HNODE);
extern void DeleteAllNodes(HLIST);
extern PVOID GetNodeData(HNODE);
extern void SetNodeData(HNODE, PCVOID);
extern ULONG GetNodeCount(HLIST);
extern BOOL IsListEmpty(HLIST);
extern BOOL GetFirstNode(HLIST, PHNODE);
extern BOOL GetNextNode(HNODE, PHNODE);
extern BOOL GetPrevNode(HNODE, PHNODE);
extern void AppendList(HLIST, HLIST);
extern BOOL SearchSortedList(HLIST, COMPARESORTEDNODESPROC, PCVOID, PHNODE);
extern BOOL SearchUnsortedList(HLIST, COMPAREUNSORTEDNODESPROC, PCVOID, PHNODE);
extern BOOL WalkList(HLIST, WALKLIST, PVOID);

#ifdef DEBUG
HLIST GetList(HNODE);
#endif

/*
 * hndtrans.h - Handle translation description.
 */


/* Types
 ********/

/* handles */

DECLARE_HANDLE(HHANDLETRANS);
DECLARE_STANDARD_TYPES(HHANDLETRANS);

DECLARE_HANDLE(HGENERIC);
DECLARE_STANDARD_TYPES(HGENERIC);


/* Prototypes
 *************/

/* hndtrans.c */

extern BOOL CreateHandleTranslator(LONG, PHHANDLETRANS);
extern void DestroyHandleTranslator(HHANDLETRANS);
extern BOOL AddHandleToHandleTranslator(HHANDLETRANS, HGENERIC, HGENERIC);
extern void PrepareForHandleTranslation(HHANDLETRANS);
extern BOOL TranslateHandle(HHANDLETRANS, HGENERIC, PHGENERIC);

#ifdef DEBUG

extern BOOL IsValidHHANDLETRANS(HHANDLETRANS);

#endif


/*
 * string.h - String table ADT description.
 */


/* Types
 ********/

/* handles */

DECLARE_HANDLE(HSTRING);
DECLARE_STANDARD_TYPES(HSTRING);
DECLARE_HANDLE(HSTRINGTABLE);
DECLARE_STANDARD_TYPES(HSTRINGTABLE);

/* count of hash buckets in a string table */

typedef UINT HASHBUCKETCOUNT;
DECLARE_STANDARD_TYPES(HASHBUCKETCOUNT);

/* string table hash function */

typedef HASHBUCKETCOUNT (*STRINGTABLEHASHFUNC)(LPCTSTR, HASHBUCKETCOUNT);

/* new string table */

typedef struct _newstringtable
{
   HASHBUCKETCOUNT hbc;
}
NEWSTRINGTABLE;
DECLARE_STANDARD_TYPES(NEWSTRINGTABLE);


/* Prototypes
 *************/

/* string.c */

extern BOOL CreateStringTable(PCNEWSTRINGTABLE, PHSTRINGTABLE);
extern void DestroyStringTable(HSTRINGTABLE);
extern BOOL AddString(LPCTSTR pcsz, HSTRINGTABLE hst, STRINGTABLEHASHFUNC pfnHashFunc, PHSTRING phs);
extern void DeleteString(HSTRING);
extern void LockString(HSTRING);
extern COMPARISONRESULT CompareStringsI(HSTRING, HSTRING);
extern LPCTSTR GetBfcString(HSTRING);

extern BOOL IsValidHSTRING(HSTRING);
extern BOOL IsValidHSTRINGTABLE(HSTRINGTABLE);

#ifdef DEBUG

extern ULONG GetStringCount(HSTRINGTABLE);

#endif

/*
 * comc.h - Shared routines description.
 */


/* Prototypes
 *************/

/* comc.c */

extern void CatPath(LPTSTR, LPCTSTR);
extern COMPARISONRESULT MapIntToComparisonResult(int);
extern void MyLStrCpyN(LPTSTR, LPCTSTR, int);

#ifdef DEBUG

extern BOOL IsStringContained(LPCTSTR, LPCTSTR);

#endif   /* DEBUG */

#if defined(_SYNCENG_) || defined(_LINKINFO_)

extern void DeleteLastPathElement(LPTSTR);
extern LONG GetDefaultRegKeyValue(HKEY, LPCTSTR, LPTSTR, PDWORD);
extern BOOL StringCopy2(LPCTSTR, LPTSTR *);
extern void CopyRootPath(LPCTSTR, LPTSTR);
extern COMPARISONRESULT ComparePathStrings(LPCTSTR, LPCTSTR);
extern BOOL MyStrChr(LPCTSTR, TCHAR, LPCTSTR *);
extern BOOL PathExists(LPCTSTR);
extern BOOL IsDrivePath(LPCTSTR);

extern BOOL IsValidDriveType(UINT);
extern BOOL IsValidPathSuffix(LPCTSTR);

#ifdef DEBUG

extern BOOL IsRootPath(LPCTSTR);
extern BOOL IsTrailingSlashCanonicalized(LPCTSTR);
extern BOOL IsFullPath(LPCTSTR);
extern BOOL IsCanonicalPath(LPCTSTR);
extern BOOL IsValidCOMPARISONRESULT(COMPARISONRESULT);

#endif   /* DEBUG */

#endif   /* _SYNCENG_ || _LINKINFO_ */

/*
 * util.h - Miscellaneous utility functions module description.
 */


/* Constants
 ************/

/* maximum length of buffer required by SeparatePath() */

#define MAX_SEPARATED_PATH_LEN            (MAX_PATH_LEN + 1)

/* events for NotifyShell */

typedef enum _notifyshellevent
{
   NSE_CREATE_ITEM,
   NSE_DELETE_ITEM,
   NSE_CREATE_FOLDER,
   NSE_DELETE_FOLDER,
   NSE_UPDATE_ITEM,
   NSE_UPDATE_FOLDER
}
NOTIFYSHELLEVENT;
DECLARE_STANDARD_TYPES(NOTIFYSHELLEVENT);


/* Prototypes
 *************/

/* util.c */

extern void NotifyShell(LPCTSTR, NOTIFYSHELLEVENT);
extern COMPARISONRESULT ComparePathStringsByHandle(HSTRING, HSTRING);
extern COMPARISONRESULT MyLStrCmpNI(LPCTSTR, LPCTSTR, int);
extern void ComposePath(LPTSTR, LPCTSTR, LPCTSTR);
extern LPCTSTR ExtractFileName(LPCTSTR);
extern LPCTSTR ExtractExtension(LPCTSTR);
extern HASHBUCKETCOUNT GetHashBucketIndex(LPCTSTR, HASHBUCKETCOUNT);
extern COMPARISONRESULT MyCompareStrings(LPCTSTR, LPCTSTR, BOOL);
extern BOOL RegKeyExists(HKEY, LPCTSTR);
extern BOOL CopyLinkInfo(PCLINKINFO, PLINKINFO *);


extern BOOL IsValidPCLINKINFO(PCLINKINFO);


/*
 * path.h - Path ADT module description.
 */


/* Types
 ********/

/* handles */

DECLARE_HANDLE(HPATHLIST);
DECLARE_STANDARD_TYPES(HPATHLIST);

DECLARE_HANDLE(HPATH);
DECLARE_STANDARD_TYPES(HPATH);

/* path results returned by AddPath() */

typedef enum _pathresult
{
   PR_SUCCESS,

   PR_UNAVAILABLE_VOLUME,

   PR_OUT_OF_MEMORY,

   PR_INVALID_PATH
}
PATHRESULT;
DECLARE_STANDARD_TYPES(PATHRESULT);


/* Prototypes
 *************/

/* path.c */

extern BOOL CreatePathList(DWORD, HWND, PHPATHLIST);
extern void DestroyPathList(HPATHLIST);
extern void InvalidatePathListInfo(HPATHLIST);
extern void ClearPathListInfo(HPATHLIST);
extern PATHRESULT AddPath(HPATHLIST, LPCTSTR, PHPATH);
extern BOOL AddChildPath(HPATHLIST, HPATH, LPCTSTR, PHPATH);
extern void DeletePath(HPATH);
extern BOOL CopyPath(HPATH, HPATHLIST, PHPATH);
extern void GetPathString(HPATH, LPTSTR);
extern void GetPathRootString(HPATH, LPTSTR);
extern void GetPathSuffixString(HPATH, LPTSTR);
extern BOOL AllocatePathString(HPATH, LPTSTR *);

#ifdef DEBUG

extern LPCTSTR DebugGetPathString(HPATH);
extern ULONG GetPathCount(HPATHLIST);

#endif

extern BOOL IsPathVolumeAvailable(HPATH);
extern HVOLUMEID GetPathVolumeID(HPATH);
extern BOOL MyIsPathOnVolume(LPCTSTR, HPATH);
extern COMPARISONRESULT ComparePaths(HPATH, HPATH);
extern COMPARISONRESULT ComparePathVolumes(HPATH, HPATH);
extern BOOL IsPathPrefix(HPATH, HPATH);
extern BOOL SubtreesIntersect(HPATH, HPATH);
extern LPTSTR FindEndOfRootSpec(LPCTSTR, HPATH);
extern COMPARISONRESULT ComparePointers(PCVOID, PCVOID);
extern LPTSTR FindChildPathSuffix(HPATH, HPATH, LPTSTR);
extern TWINRESULT TWINRESULTFromLastError(TWINRESULT);
extern BOOL IsValidHPATH(HPATH);
extern BOOL IsValidHVOLUMEID(HVOLUMEID);

extern BOOL IsValidHPATHLIST(HPATHLIST);


/*
 * fcache.h - File cache ADT description.
 */


/* Types
 ********/

/* return code */

typedef enum _fcresult
{
   FCR_SUCCESS,
   FCR_OUT_OF_MEMORY,
   FCR_OPEN_FAILED,
   FCR_CREATE_FAILED,
   FCR_WRITE_FAILED,
   FCR_FILE_LOCKED
}
FCRESULT;
DECLARE_STANDARD_TYPES(FCRESULT);

/* handles */

#ifdef NOFCACHE
typedef HANDLE HCACHEDFILE;
#else
DECLARE_HANDLE(HCACHEDFILE);
#endif
DECLARE_STANDARD_TYPES(HCACHEDFILE);

/* cached file description */

typedef struct _cachedfile
{
   LPCTSTR pcszPath;

   DWORD dwcbDefaultCacheSize;

   DWORD dwOpenMode;

   DWORD dwSharingMode;

   PSECURITY_ATTRIBUTES psa;

   DWORD dwCreateMode;

   DWORD dwAttrsAndFlags;

   HANDLE hTemplateFile;
}
CACHEDFILE;
DECLARE_STANDARD_TYPES(CACHEDFILE);


/* Prototypes
 *************/

/* fcache.c */

extern FCRESULT CreateCachedFile(PCCACHEDFILE, PHCACHEDFILE);
extern FCRESULT SetCachedFileCacheSize(HCACHEDFILE, DWORD);
extern DWORD SeekInCachedFile(HCACHEDFILE, DWORD, DWORD);
extern BOOL SetEndOfCachedFile(HCACHEDFILE);
extern DWORD GetCachedFilePointerPosition(HCACHEDFILE);
extern DWORD GetCachedFileSize(HCACHEDFILE);
extern BOOL ReadFromCachedFile(HCACHEDFILE, PVOID, DWORD, PDWORD);
extern BOOL WriteToCachedFile(HCACHEDFILE, PCVOID, DWORD, PDWORD);
extern BOOL CommitCachedFile(HCACHEDFILE);
extern HANDLE GetFileHandle(HCACHEDFILE);
extern BOOL CloseCachedFile(HCACHEDFILE);
extern HANDLE GetFileHandle(HCACHEDFILE);

extern BOOL IsValidHCACHEDFILE(HCACHEDFILE);

/*
 * brfcase.h - Briefcase ADT description.
 */


/* Prototypes
 *************/

/* brfcase.c */

#define BeginExclusiveBriefcaseAccess() TRUE
#define EndExclusiveBriefcaseAccess()

extern BOOL SetBriefcaseModuleIniSwitches(void);
extern BOOL InitBriefcaseModule(void);
extern void ExitBriefcaseModule(void);
extern HSTRINGTABLE GetBriefcaseNameStringTable(HBRFCASE);
extern HPTRARRAY GetBriefcaseTwinFamilyPtrArray(HBRFCASE);
extern HPTRARRAY GetBriefcaseFolderPairPtrArray(HBRFCASE);
extern HPATHLIST GetBriefcasePathList(HBRFCASE);

#ifdef DEBUG

extern BOOL BriefcaseAccessIsExclusive(void);

#endif

extern BOOL IsValidHBRFCASE(HBRFCASE);

/*
 * twin.h - Twin ADT description.
 */


/* Types
 ********/

/*
 * EnumTwins() callback function - called as:
 *
 *    bContinue = EnumTwinsProc(htwin, pData);
 */

typedef BOOL (*ENUMTWINSPROC)(HTWIN, LPARAM);


/* Prototypes
 *************/

/* twin.c */

extern COMPARISONRESULT CompareNameStrings(LPCTSTR, LPCTSTR);
extern COMPARISONRESULT CompareNameStringsByHandle(HSTRING, HSTRING);
extern TWINRESULT TranslatePATHRESULTToTWINRESULT(PATHRESULT);
extern BOOL CreateTwinFamilyPtrArray(PHPTRARRAY);
extern void DestroyTwinFamilyPtrArray(HPTRARRAY);
extern HBRFCASE GetTwinBriefcase(HTWIN);
extern BOOL FindObjectTwinInList(HLIST, HPATH, PHNODE);
extern BOOL EnumTwins(HBRFCASE, ENUMTWINSPROC, LPARAM, PHTWIN);
extern BOOL IsValidHTWIN(HTWIN);
extern BOOL IsValidHTWINFAMILY(HTWINFAMILY);
extern BOOL IsValidHOBJECTTWIN(HOBJECTTWIN);


/*
 * foldtwin.h - Folder twin ADT description.
 */


/* Prototypes
 *************/

/* foldtwin.c */

extern BOOL CreateFolderPairPtrArray(PHPTRARRAY);
extern void DestroyFolderPairPtrArray(HPTRARRAY);
extern TWINRESULT MyTranslateFolder(HBRFCASE, HPATH, HPATH);
extern BOOL IsValidHFOLDERTWIN(HFOLDERTWIN);

/*
 * db.c - Twin database module description.
 */


/* Types
 ********/

/* database header version numbers */

#define HEADER_MAJOR_VER         (0x0001)
#define HEADER_MINOR_VER         (0x0005)

/* old (but supported) version numbers */

#define HEADER_M8_MINOR_VER      (0x0004)


typedef struct _dbversion
{
    DWORD dwMajorVer;
    DWORD dwMinorVer;
}
DBVERSION;
DECLARE_STANDARD_TYPES(DBVERSION);


/* Prototypes
 *************/

/* db.c */

extern TWINRESULT WriteTwinDatabase(HCACHEDFILE, HBRFCASE);
extern TWINRESULT ReadTwinDatabase(HBRFCASE, HCACHEDFILE);
extern TWINRESULT WriteDBSegmentHeader(HCACHEDFILE, LONG, PCVOID, UINT);
extern TWINRESULT TranslateFCRESULTToTWINRESULT(FCRESULT);

/* path.c */

extern TWINRESULT WritePathList(HCACHEDFILE, HPATHLIST);
extern TWINRESULT ReadPathList(HCACHEDFILE, HPATHLIST, PHHANDLETRANS);

/* brfcase.c */

extern TWINRESULT WriteBriefcaseInfo(HCACHEDFILE, HBRFCASE);
extern TWINRESULT ReadBriefcaseInfo(HCACHEDFILE, HBRFCASE, HHANDLETRANS);

/* string.c */

extern TWINRESULT WriteStringTable(HCACHEDFILE, HSTRINGTABLE);
extern TWINRESULT ReadStringTable(HCACHEDFILE, HSTRINGTABLE, PHHANDLETRANS);

/* twin.c */

extern TWINRESULT WriteTwinFamilies(HCACHEDFILE, HPTRARRAY);
extern TWINRESULT ReadTwinFamilies(HCACHEDFILE, HBRFCASE, PCDBVERSION, HHANDLETRANS, HHANDLETRANS);

/* foldtwin.c */

extern TWINRESULT WriteFolderPairList(HCACHEDFILE, HPTRARRAY);
extern TWINRESULT ReadFolderPairList(HCACHEDFILE, HBRFCASE, HHANDLETRANS, HHANDLETRANS);

/*
 * stub.h - Stub ADT description.
 */


/* Types
 ********/

/* stub types */

typedef enum _stubtype
{
   ST_OBJECTTWIN,

   ST_TWINFAMILY,

   ST_FOLDERPAIR
}
STUBTYPE;
DECLARE_STANDARD_TYPES(STUBTYPE);

/* stub flags */

typedef enum _stubflags
{
   /* This stub was marked for deletion while it was locked. */

   STUB_FL_UNLINKED           = 0x0001,

   /* This stub has already been used for some operation. */

   STUB_FL_USED               = 0x0002,

   /*
    * The file stamp of this object twin stub is valid.  (Only used for object
    * twins to cache file stamp from folder twin expansion for RECNODE
    * creation.)
    */

   STUB_FL_FILE_STAMP_VALID   = 0x0004,

   /*
    * This twin family stub or folder twin stub is in the process of being
    * deleted.  (Only used for twin families and folder twins.)
    */

   STUB_FL_BEING_DELETED      = 0x0008,

   /*
    * This folder twin stub is in the process of being translated.  (Only used
    * for folder twins.)
    */

   STUB_FL_BEING_TRANSLATED   = 0x0010,

   /*
    * This object twin stub was explicitly added a an object twin through
    * AddObjectTwin().  (Only used for object twins.)
    */

   STUB_FL_FROM_OBJECT_TWIN   = 0x0100,

   /*
    * This object twin stub was not reconciled the last time its twin family
    * was reconciled, and some members of the twin family were known to have
    * changed.  (Only used for object twins.)
    */

   STUB_FL_NOT_RECONCILED     = 0x0200,

   /*
    * The subtree of the root folder of this folder twin stub is to be included
    * in reconciliation.  (Only used for folder twins.)
    */

   STUB_FL_SUBTREE            = 0x0400,

   /*
    * The object twins in this twin family are pending deletion because an
    * object twin was deleted, and no object twins have changed since that
    * object twins was deleted.  This folder twin is pending deletion because
    * its folder root is last known deleted.  (Only used for twin families and
    * folder twins.)
    */

   STUB_FL_DELETION_PENDING   = 0x0800,

   /*
    * The client indicated that this object twin should not be deleted.  (Only
    * used for object twins.)
    */

   STUB_FL_KEEP               = 0x1000,

   /* stub flag combinations */

   ALL_STUB_FLAGS             = (STUB_FL_UNLINKED |
                                 STUB_FL_USED |
                                 STUB_FL_FILE_STAMP_VALID |
                                 STUB_FL_BEING_DELETED |
                                 STUB_FL_BEING_TRANSLATED |
                                 STUB_FL_FROM_OBJECT_TWIN |
                                 STUB_FL_NOT_RECONCILED |
                                 STUB_FL_SUBTREE |
                                 STUB_FL_DELETION_PENDING |
                                 STUB_FL_KEEP),

   ALL_OBJECT_TWIN_FLAGS      = (STUB_FL_UNLINKED |
                                 STUB_FL_USED |
                                 STUB_FL_FILE_STAMP_VALID |
                                 STUB_FL_NOT_RECONCILED |
                                 STUB_FL_FROM_OBJECT_TWIN |
                                 STUB_FL_KEEP),

   ALL_TWIN_FAMILY_FLAGS      = (STUB_FL_UNLINKED |
                                 STUB_FL_USED |
                                 STUB_FL_BEING_DELETED |
                                 STUB_FL_DELETION_PENDING),

   ALL_FOLDER_TWIN_FLAGS      = (STUB_FL_UNLINKED |
                                 STUB_FL_USED |
                                 STUB_FL_BEING_DELETED |
                                 STUB_FL_BEING_TRANSLATED |
                                 STUB_FL_SUBTREE |
                                 STUB_FL_DELETION_PENDING),

   /* bit mask used to save stub flags in briefcase database */

   DB_STUB_FLAGS_MASK         = 0xff00
}
STUBFLAGS;

/*
 * common stub - These fields must appear at the start of TWINFAMILY,
 * OBJECTTWIN, and FOLDERPAIR in the same order.
 */

typedef struct _stub
{
   /* structure tag */

   STUBTYPE st;

   /* lock count */

   ULONG ulcLock;

   /* flags */

   DWORD dwFlags;
}
STUB;
DECLARE_STANDARD_TYPES(STUB);

/* object twin family */

typedef struct _twinfamily
{
   /* common stub */

   STUB stub;

   /* handle to name string */

   HSTRING hsName;

   /* handle to list of object twins */

   HLIST hlistObjectTwins;

   /* handle to parent briefcase */

   HBRFCASE hbr;
}
TWINFAMILY;
DECLARE_STANDARD_TYPES(TWINFAMILY);

/* object twin */

typedef struct _objecttwin
{
   /* common stub */

   STUB stub;

   /* handle to folder path */

   HPATH hpath;

   /* file stamp at last reconciliation time */

   FILESTAMP fsLastRec;

   /* pointer to parent twin family */

   PTWINFAMILY ptfParent;

   /* source folder twins count */

   ULONG ulcSrcFolderTwins;

   /*
    * current file stamp, only valid if STUB_FL_FILE_STAMP_VALID is set in
    * stub's flags
    */

   FILESTAMP fsCurrent;
}
OBJECTTWIN;
DECLARE_STANDARD_TYPES(OBJECTTWIN);

/* folder pair data */

typedef struct _folderpairdata
{
   /* handle to name of included objects - may contain wildcards */

   HSTRING hsName;

   /* attributes to match */

   DWORD dwAttributes;

   /* handle to parent briefcase */

   HBRFCASE hbr;
}
FOLDERPAIRDATA;
DECLARE_STANDARD_TYPES(FOLDERPAIRDATA);

/* folder pair */

typedef struct _folderpair
{
   /* common stub */

   STUB stub;

   /* handle to folder path */

   HPATH hpath;

   /* pointer to folder pair data */

   PFOLDERPAIRDATA pfpd;

   /* pointer to other half of folder pair */

   struct _folderpair *pfpOther;
}
FOLDERPAIR;
DECLARE_STANDARD_TYPES(FOLDERPAIR);

/*
 * EnumGeneratedObjectTwins() callback function
 *
 * Called as:
 *
 * bContinue = EnumGeneratedObjectTwinsProc(pot, pvRefData);
 */

typedef BOOL (*ENUMGENERATEDOBJECTTWINSPROC)(POBJECTTWIN, PVOID);

/*
 * EnumGeneratingFolderTwins() callback function
 *
 * Called as:
 *
 * bContinue = EnumGeneratingFolderTwinsProc(pfp, pvRefData);
 */

typedef BOOL (*ENUMGENERATINGFOLDERTWINSPROC)(PFOLDERPAIR, PVOID);


/* Prototypes
 *************/

/* stub.c */

extern void InitStub(PSTUB, STUBTYPE);
extern TWINRESULT DestroyStub(PSTUB);
extern void LockStub(PSTUB);
extern void UnlockStub(PSTUB);
extern DWORD GetStubFlags(PCSTUB);
extern void SetStubFlag(PSTUB, DWORD);
extern void ClearStubFlag(PSTUB, DWORD);
extern BOOL IsStubFlagSet(PCSTUB, DWORD);
extern BOOL IsStubFlagClear(PCSTUB, DWORD);

extern BOOL IsValidPCSTUB(PCSTUB);

/* twin.c */

extern BOOL FindObjectTwin(HBRFCASE, HPATH, LPCTSTR, PHNODE);
extern BOOL CreateObjectTwin(PTWINFAMILY, HPATH, POBJECTTWIN *);
extern TWINRESULT UnlinkObjectTwin(POBJECTTWIN);
extern void DestroyObjectTwin(POBJECTTWIN);
extern TWINRESULT UnlinkTwinFamily(PTWINFAMILY);
extern void MarkTwinFamilyNeverReconciled(PTWINFAMILY);
extern void MarkObjectTwinNeverReconciled(PVOID);
extern void DestroyTwinFamily(PTWINFAMILY);
extern void MarkTwinFamilyDeletionPending(PTWINFAMILY);
extern void UnmarkTwinFamilyDeletionPending(PTWINFAMILY);
extern BOOL IsTwinFamilyDeletionPending(PCTWINFAMILY);
extern void ClearTwinFamilySrcFolderTwinCount(PTWINFAMILY);
extern BOOL EnumObjectTwins(HBRFCASE, ENUMGENERATEDOBJECTTWINSPROC, PVOID);
extern BOOL ApplyNewFolderTwinsToTwinFamilies(PCFOLDERPAIR);
extern TWINRESULT TransplantObjectTwin(POBJECTTWIN, HPATH, HPATH);
extern BOOL IsFolderObjectTwinName(LPCTSTR);


extern BOOL IsValidPCTWINFAMILY(PCTWINFAMILY);
extern BOOL IsValidPCOBJECTTWIN(PCOBJECTTWIN);


/* foldtwin.c */

extern void LockFolderPair(PFOLDERPAIR);
extern void UnlockFolderPair(PFOLDERPAIR);
extern TWINRESULT UnlinkFolderPair(PFOLDERPAIR);
extern void DestroyFolderPair(PFOLDERPAIR);
extern BOOL ApplyNewObjectTwinsToFolderTwins(HLIST);
extern BOOL BuildPathForMatchingObjectTwin(PCFOLDERPAIR, PCOBJECTTWIN, HPATHLIST, PHPATH);
extern BOOL EnumGeneratedObjectTwins(PCFOLDERPAIR, ENUMGENERATEDOBJECTTWINSPROC, PVOID);
extern BOOL EnumGeneratingFolderTwins(PCOBJECTTWIN, ENUMGENERATINGFOLDERTWINSPROC, PVOID, PULONG);
extern BOOL FolderTwinGeneratesObjectTwin(PCFOLDERPAIR, HPATH, LPCTSTR);

extern BOOL IsValidPCFOLDERPAIR(PCFOLDERPAIR);

extern void RemoveObjectTwinFromAllFolderPairs(POBJECTTWIN);

/* expandft.c */

extern BOOL ClearStubFlagWrapper(PSTUB, PVOID);
extern BOOL SetStubFlagWrapper(PSTUB, PVOID);
extern TWINRESULT ExpandIntersectingFolderTwins(PFOLDERPAIR, CREATERECLISTPROC, LPARAM);
extern TWINRESULT TryToGenerateObjectTwin(HBRFCASE, HPATH, LPCTSTR, PBOOL, POBJECTTWIN *);

/*
 * volume.h - Volume ADT module description.
 */


/* Types
 ********/

/* handles */

DECLARE_HANDLE(HVOLUMELIST);
DECLARE_STANDARD_TYPES(HVOLUMELIST);

DECLARE_HANDLE(HVOLUME);
DECLARE_STANDARD_TYPES(HVOLUME);

/* volume results returned by AddVolume() */

typedef enum _volumeresult
{
   VR_SUCCESS,

   VR_UNAVAILABLE_VOLUME,

   VR_OUT_OF_MEMORY,

   VR_INVALID_PATH
}
VOLUMERESULT;
DECLARE_STANDARD_TYPES(VOLUMERESULT);


/* Prototypes
 *************/

/* volume.c */

extern BOOL CreateVolumeList(DWORD, HWND, PHVOLUMELIST);
extern void DestroyVolumeList(HVOLUMELIST);
extern void InvalidateVolumeListInfo(HVOLUMELIST);
void ClearVolumeListInfo(HVOLUMELIST);
extern VOLUMERESULT AddVolume(HVOLUMELIST, LPCTSTR, PHVOLUME, LPTSTR);
extern void DeleteVolume(HVOLUME);
extern COMPARISONRESULT CompareVolumes(HVOLUME, HVOLUME);
extern BOOL CopyVolume(HVOLUME, HVOLUMELIST, PHVOLUME);
extern BOOL IsVolumeAvailable(HVOLUME);
extern void GetVolumeRootPath(HVOLUME, LPTSTR);

#ifdef DEBUG

extern LPTSTR DebugGetVolumeRootPath(HVOLUME, LPTSTR);
extern ULONG GetVolumeCount(HVOLUMELIST);

#endif

extern void DescribeVolume(HVOLUME, PVOLUMEDESC);
extern TWINRESULT WriteVolumeList(HCACHEDFILE, HVOLUMELIST);
extern TWINRESULT ReadVolumeList(HCACHEDFILE, HVOLUMELIST, PHHANDLETRANS);
extern BOOL IsValidHVOLUME(HVOLUME);


extern BOOL IsValidHVOLUMELIST(HVOLUMELIST);


/*
 * sortsrch.c - Generic array sorting and searching description.
 */


/* Types
 ********/

/* array element comparison callback function */

typedef COMPARISONRESULT (*COMPARESORTEDELEMSPROC)(PCVOID, PCVOID);


/* Prototypes
 *************/

/* sortsrch.c */

extern void HeapSort(PVOID, LONG, size_t, COMPARESORTEDELEMSPROC, PVOID);
extern BOOL BinarySearch(PVOID, LONG, size_t, COMPARESORTEDELEMSPROC, PCVOID, PLONG);

#define WINSHELLAPI       DECLSPEC_IMPORT

WINSHELLAPI BOOL SheShortenPathA(LPSTR pPath, BOOL bShorten);
WINSHELLAPI BOOL SheShortenPathW(LPWSTR pPath, BOOL bShorten);
#ifdef UNICODE
#define SheShortenPath  SheShortenPathW
#else
#define SheShortenPath  SheShortenPathA
#endif // !UNICODE

typedef struct {
    HPATHLIST   PathList;
    HPATH       Path;
    TCHAR       PathString[MAX_PATH];
    ULONG       Max;
    ULONG       Index;
} BRFPATH_ENUM, *PBRFPATH_ENUM;

extern POOLHANDLE g_BrfcasePool;


BOOL
EnumFirstBrfcasePath (
    IN      HBRFCASE Brfcase,
    OUT     PBRFPATH_ENUM e
    );

BOOL
EnumNextBrfcasePath (
    IN OUT  PBRFPATH_ENUM e
    );

BOOL
ReplaceBrfcasePath (
    IN      PBRFPATH_ENUM PathEnum,
    IN      PCTSTR NewPath
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\migmain\filemig.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    filemig.c

Abstract:

    Contains utility functions to migrate file system settings.

Author:

    Jim Schmidt (jimschm) 12-Jul-1996

Revision History:

    jimschm     08-Jul-1999 Added FileSearchAndReplace
    jimschm     23-Sep-1998 Changed for new shell.c & progress.c
    calinn      29-Jan-1998 Fixed DoFileDel messages
    jimschm     21-Nov-1997 PC-98 changes
    jimschm     14-Nov-1997 FileCopy now makes the dest dir if it doesn't
                            exist
    jimschm     18-Jul-1997 Now supports FileCopy and FileDel changes
    mikeco      09-Apr-1997 Mods to MoveProfileDir
    jimschm     18-Dec-1996 Extracted code from miginf
    jimschm     23-Oct-1996 Joined ProcessUserInfs and ApplyChanges
    mikeco      04-Dec-1996 Enumerate/modify PIF and LNK files
    jimschm     02-Oct-1996 Added default user migration

--*/

#include "pch.h"
#include "migmainp.h"
#include "persist.h"
#include "uninstall.h"

#ifndef UNICODE
#error UNICODE reqired
#endif

#define DBG_FILEMIG     "FileMig"
#define BACKUP_FILE_NUMBER  2
#define BOOT_FILES_ADDITIONAL_PADDING   (1<<20)
#define UNDO_FILES_ADDITIONAL_PADDING   (1<<20)
#define MAX_INT_CHAR 11

PERSISTENCE_IMPLEMENTATION(DRIVE_LAYOUT_INFORMATION_EX_PERSISTENCE);
PERSISTENCE_IMPLEMENTATION(DISKINFO_PERSISTENCE);
PERSISTENCE_IMPLEMENTATION(DRIVEINFO_PERSISTENCE);
PERSISTENCE_IMPLEMENTATION(FILEINTEGRITYINFO_PERSISTENCE);
PERSISTENCE_IMPLEMENTATION(BACKUPIMAGEINFO_PERSISTENCE);

GROWLIST g_StartMenuItemsForCleanUpCommon = GROWLIST_INIT;
GROWLIST g_StartMenuItemsForCleanUpPrivate = GROWLIST_INIT;


BOOL
OurMoveFileExA (
    IN      PCSTR ExistingFile,
    IN      PCSTR DestinationFile,
    IN      DWORD Flags
    )
{
    PCWSTR unicodeExistingFile;
    PCWSTR unicodeDestinationFile;
    BOOL b;

    unicodeExistingFile = ConvertAtoW (ExistingFile);
    unicodeDestinationFile = ConvertAtoW (DestinationFile);

    b = OurMoveFileExW (unicodeExistingFile, unicodeDestinationFile, Flags);

    FreeConvertedStr (unicodeExistingFile);
    FreeConvertedStr (unicodeDestinationFile);

    return b;
}


BOOL
OurMoveFileExW (
    IN      PCWSTR ExistingFile,
    IN      PCWSTR DestinationFile,
    IN      DWORD Flags
    )
{
    PCWSTR longExistingFile;
    PCWSTR longDestinationFile;
    BOOL b;

    longExistingFile = JoinPathsW (L"\\\\?", ExistingFile);
    longDestinationFile = JoinPathsW (L"\\\\?", DestinationFile);

    MakeSurePathExists (longDestinationFile, FALSE);

    DEBUGMSG ((DBG_VERBOSE, "Trying to move %s to %s", longExistingFile, longDestinationFile));
    b = MoveFileExW (longExistingFile, longDestinationFile, Flags);

    FreePathStringW (longExistingFile);
    FreePathStringW (longDestinationFile);

    return b;
}


BOOL
OurCopyFileW (
    IN      PCWSTR ExistingFile,
    IN      PCWSTR DestinationFile
    )
{
    PCWSTR longExistingFile;
    PCWSTR longDestinationFile;
    BOOL b;

    longExistingFile = JoinPathsW (L"\\\\?", ExistingFile);
    longDestinationFile = JoinPathsW (L"\\\\?", DestinationFile);

    DEBUGMSG ((DBG_VERBOSE, "Trying to copy %s to %s", longExistingFile, longDestinationFile));

    MakeSurePathExists (longDestinationFile, FALSE);
    b = CopyFileW (longExistingFile, longDestinationFile, FALSE);

    FreePathStringW (longExistingFile);
    FreePathStringW (longDestinationFile);

    return b;
}


BOOL
pFileSearchAndReplaceWorker (
    IN      PBYTE MapStart,
    IN      PBYTE MapEnd,
    IN      HANDLE OutFile,
    IN      PTOKENSET TokenSet
    );


BOOL
pCopyFileWithVersionCheck (
    IN      PCTSTR Src,
    IN      PCTSTR Dest
    )
{
    DWORD Attributes;
    DWORD rc;

    Attributes = GetLongPathAttributes (Src);
    if (Attributes == INVALID_ATTRIBUTES) {
        SetLastError (ERROR_FILE_NOT_FOUND);
        LOG ((LOG_ERROR, "Copy File With Version Check: File not found: %s", Src));
        return FALSE;
    }

    MakeSureLongPathExists (Dest, FALSE);       // FALSE == not path only

    SetLongPathAttributes (Dest, FILE_ATTRIBUTE_NORMAL);
    rc = SetupDecompressOrCopyFile (
             Src,
             Dest,
             FILE_COMPRESSION_NONE
             );

    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        LOG ((LOG_ERROR, "Cannot copy %s to %s", Src, Dest));
        return FALSE;
    }

    SetLongPathAttributes (Dest, Attributes);
    return TRUE;
}


BOOL
pCopyTempRelocToDest (
    VOID
    )

/*++

Routine Description:

  pCopyTempRelocToDest enumerates the DirAttribs category and establishes
  a path for each directory listed.  It then enumerates the RelocTemp
  category and copies each file to its one or more destinations.

Arguments:

  none

Return Value:

  TRUE if copy succeeded, or FALSE if an error occurred.
  Call GetLastError() for error code.

--*/

{
    FILEOP_ENUM eOp;
    FILEOP_PROP_ENUM eOpProp;
    TCHAR srcPath [MEMDB_MAX];
    PCTSTR extPtr;

    if (EnumFirstPathInOperation (&eOp, OPERATION_TEMP_PATH)) {
        do {
            srcPath [0] = 0;

            if (EnumFirstFileOpProperty (&eOpProp, eOp.Sequencer, OPERATION_TEMP_PATH)) {
                do {
                    if (srcPath [0]) {
                        //
                        // if the dest file is an INI file,
                        // don't copy it;
                        // the merging mechanism will combine them later
                        //
                        extPtr = GetFileExtensionFromPath (eOpProp.Property);
                        if (extPtr && StringIMatch (extPtr, TEXT("INI"))) {
                            continue;
                        }

                        MakeSureLongPathExists (eOpProp.Property, FALSE);
                        if (!pCopyFileWithVersionCheck (srcPath, eOpProp.Property)) {
                            //
                            // don't stop here; continue with remaining files
                            //
                            break;
                        }
                    } else {
                        StringCopy (srcPath, eOpProp.Property);
                    }
                } while (EnumNextFileOpProperty (&eOpProp));
            }
        } while (EnumNextPathInOperation (&eOp));
    }

    return TRUE;
}

DWORD
DoCopyFile (
    DWORD Request
    )

/*++

Routine Description:

  DoCopyFile performs a file copy for each file listed in the
  file copy operation.

Arguments:

  Request - Specifies REQUEST_QUERYTICKS if a tick estimate is needed,
            or REQUEST_RUN if processing should be preformed.

Return Value:

  Tick count (REQUEST_QUERYTICKS), or Win32 status code (REQUEST_RUN).

--*/

{
    FILEOP_ENUM OpEnum;
    TCHAR DestPath[MAX_TCHAR_PATH];

    if (Request == REQUEST_QUERYTICKS) {
        return TICKS_COPYFILE;
    }

    //
    // Perform rest of temporary file relocation
    //
    pCopyTempRelocToDest();

    //
    // Copy files into directories
    //

    if (EnumFirstPathInOperation (&OpEnum, OPERATION_FILE_COPY)) {
        do {
            //
            // Get dest
            //

            if (GetPathProperty (OpEnum.Path, OPERATION_FILE_COPY, 0, DestPath)) {
                MakeSureLongPathExists (DestPath, FALSE);
                pCopyFileWithVersionCheck (OpEnum.Path, DestPath);
            }
        } while (EnumNextPathInOperation (&OpEnum));
    }

    TickProgressBarDelta (TICKS_COPYFILE);

    return ERROR_SUCCESS;
}

PCTSTR g_LnkStubDataFile = NULL;
HANDLE g_LnkStubDataHandle = INVALID_HANDLE_VALUE;
BOOL g_LnkStubBadData = FALSE;

VOID
pInitLnkStubData (
    VOID
    )
{
    INT maxSequencer;
    DWORD offset = 0;
    DWORD bytesWritten;

    MemDbGetValue (MEMDB_CATEGORY_LINKSTUB_MAXSEQUENCE, &maxSequencer);

    g_LnkStubDataFile = JoinPaths (g_WinDir, S_LNKSTUB_DAT);

    g_LnkStubDataHandle = CreateFile (
                            g_LnkStubDataFile,
                            GENERIC_READ|GENERIC_WRITE,
                            0,
                            NULL,
                            CREATE_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL
                            );
    if (g_LnkStubDataHandle != INVALID_HANDLE_VALUE) {

        // let's write empty data for all possible sequencers
        // there is a DWORD entry for each sequencer (1 based)
        while (maxSequencer) {
            if (!WriteFile (
                    g_LnkStubDataHandle,
                    &offset,
                    sizeof (DWORD),
                    &bytesWritten,
                    NULL
                    )) {
                g_LnkStubBadData = TRUE;
                return;
            }
            maxSequencer--;
        }
    } else {
        g_LnkStubBadData = TRUE;
    }
}

VOID
pDoneLnkStubData (
    VOID
    )
{
    CloseHandle (g_LnkStubDataHandle);
    g_LnkStubDataHandle = INVALID_HANDLE_VALUE;

    if (g_LnkStubBadData) {
        DeleteFile (g_LnkStubDataFile);
    }

    FreePathString (g_LnkStubDataFile);
    g_LnkStubDataFile = NULL;
}

VOID
pWriteLnkStubData (
    IN      PCTSTR NewLinkPath,
    IN      PCTSTR NewTarget,
    IN      PCTSTR NewArgs,
    IN      PCTSTR NewWorkDir,
    IN      PCTSTR NewIconPath,
    IN      INT NewIconNr,
    IN      INT ShowMode,
    IN      INT Sequencer,
    IN      DWORD Announcement,
    IN      DWORD Availability,
    IN      PGROWBUFFER ReqFilesList
    )
{
    DWORD offset;
    DWORD bytesWritten;
    WIN32_FIND_DATA findData;
    MULTISZ_ENUM multiSzEnum;
    TCHAR stub[]=TEXT("");
    PCTSTR reqFilePath = NULL;
    PCTSTR oldFileSpec = NULL;
    PTSTR oldFilePtr = NULL;

    if ((!g_LnkStubBadData) && (Sequencer > 0)) {
        if (SetFilePointer (g_LnkStubDataHandle, (Sequencer - 1) * sizeof (DWORD), NULL, FILE_BEGIN) == 0xFFFFFFFF) {
            g_LnkStubBadData = TRUE;
            return;
        }
        offset = GetFileSize (g_LnkStubDataHandle, NULL);
        if (offset == 0xFFFFFFFF) {
            g_LnkStubBadData = TRUE;
            return;
        }
        if (!WriteFile (
                g_LnkStubDataHandle,
                &offset,
                sizeof (DWORD),
                &bytesWritten,
                NULL
                )) {
            g_LnkStubBadData = TRUE;
            return;
        }
        if (SetFilePointer (g_LnkStubDataHandle, 0, NULL, FILE_END) == 0xFFFFFFFF) {
            g_LnkStubBadData = TRUE;
            return;
        }

        //
        // NOTE: Format of lnkstub.dat is below. lnkstub\lnkstub.c must match.
        //

        if (!WriteFile (g_LnkStubDataHandle, NewLinkPath, SizeOfString (NewLinkPath), &bytesWritten, NULL)) {
            g_LnkStubBadData = TRUE;
            return;
        }

        if (!WriteFile (g_LnkStubDataHandle, NewTarget, SizeOfString (NewTarget), &bytesWritten, NULL)) {
            g_LnkStubBadData = TRUE;
            return;
        }

        if (!WriteFile (g_LnkStubDataHandle, NewArgs, SizeOfString (NewArgs), &bytesWritten, NULL)) {
            g_LnkStubBadData = TRUE;
            return;
        }

        if (!WriteFile (g_LnkStubDataHandle, NewWorkDir, SizeOfString (NewWorkDir), &bytesWritten, NULL)) {
            g_LnkStubBadData = TRUE;
            return;
        }

        if (!WriteFile (g_LnkStubDataHandle, NewIconPath, SizeOfString (NewIconPath), &bytesWritten, NULL)) {
            g_LnkStubBadData = TRUE;
            return;
        }

        if (!WriteFile (g_LnkStubDataHandle, &NewIconNr, sizeof (INT), &bytesWritten, NULL)) {
            g_LnkStubBadData = TRUE;
            return;
        }

        if (!WriteFile (g_LnkStubDataHandle, &ShowMode, sizeof (INT), &bytesWritten, NULL)) {
            g_LnkStubBadData = TRUE;
            return;
        }

        if (!WriteFile (g_LnkStubDataHandle, &Announcement, sizeof (DWORD), &bytesWritten, NULL)) {
            g_LnkStubBadData = TRUE;
            return;
        }

        if (!WriteFile (g_LnkStubDataHandle, &Availability, sizeof (DWORD), &bytesWritten, NULL)) {
            g_LnkStubBadData = TRUE;
            return;
        }

        if (!DoesFileExistEx (NewTarget, &findData)) {
            findData.ftLastWriteTime.dwLowDateTime = 0;
            findData.ftLastWriteTime.dwHighDateTime = 0;
        }

        if (!WriteFile (g_LnkStubDataHandle, &findData.ftLastWriteTime.dwLowDateTime, sizeof (DWORD), &bytesWritten, NULL)) {
            g_LnkStubBadData = TRUE;
            return;
        }

        if (!WriteFile (g_LnkStubDataHandle, &findData.ftLastWriteTime.dwHighDateTime, sizeof (DWORD), &bytesWritten, NULL)) {
            g_LnkStubBadData = TRUE;
            return;
        }

        if (EnumFirstMultiSz (&multiSzEnum, (PTSTR)ReqFilesList->Buf)) {
            do {
                if (!WriteFile (
                        g_LnkStubDataHandle,
                        multiSzEnum.CurrentString,
                        SizeOfString (multiSzEnum.CurrentString),
                        &bytesWritten,
                        NULL
                        )) {
                    g_LnkStubBadData = TRUE;
                    return;
                }
                oldFileSpec = DuplicatePathString (NewTarget, 0);
                oldFilePtr = (PTSTR)GetFileNameFromPath (oldFileSpec);
                if (oldFilePtr) {
                    *oldFilePtr = 0;
                }
                reqFilePath = JoinPaths (oldFileSpec, multiSzEnum.CurrentString);

                if (!DoesFileExistEx (reqFilePath, &findData)) {
                    findData.ftLastWriteTime.dwLowDateTime = 0;
                    findData.ftLastWriteTime.dwHighDateTime = 0;
                }
                if (!WriteFile (g_LnkStubDataHandle, &findData.ftLastWriteTime.dwLowDateTime, sizeof (DWORD), &bytesWritten, NULL)) {
                    g_LnkStubBadData = TRUE;
                    return;
                }
                if (!WriteFile (g_LnkStubDataHandle, &findData.ftLastWriteTime.dwHighDateTime, sizeof (DWORD), &bytesWritten, NULL)) {
                    g_LnkStubBadData = TRUE;
                    return;
                }

                FreePathString (reqFilePath);
                FreePathString (oldFileSpec);
            } while ((!g_LnkStubBadData) && EnumNextMultiSz (&multiSzEnum));

        }
        if (!WriteFile (g_LnkStubDataHandle, stub, SizeOfString (stub), &bytesWritten, NULL)) {
            g_LnkStubBadData = TRUE;
            return;
        }
    }
}


BOOL
RestoreInfoFromDefaultPif (
    IN      PCTSTR UserName,
    IN      HKEY KeyRoot
    )
{
    TCHAR key [MEMDB_MAX];
    MEMDB_ENUM e;
    DWORD value1, value2;
    HKEY cmdKey;

    cmdKey = OpenRegKey (KeyRoot, S_CMDATTRIB_KEY);
    if (!cmdKey) {
        cmdKey = CreateRegKey (KeyRoot, S_CMDATTRIB_KEY);
    }
    if (cmdKey) {

        MemDbBuildKey (key, MEMDB_CATEGORY_DEFAULT_PIF, MEMDB_CATEGORY_LINKEDIT_FULLSCREEN, TEXT("*"), NULL);
        if (MemDbEnumFirstValue (&e, key, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
            value1 = _ttoi (e.szName);
            RegSetValueEx (cmdKey, S_CMD_FULLSCREEN, 0, REG_DWORD, (PCBYTE)&value1, sizeof (DWORD));
        }
        MemDbBuildKey (key, MEMDB_CATEGORY_DEFAULT_PIF, MEMDB_CATEGORY_LINKEDIT_XSIZE, TEXT("*"), NULL);
        if (MemDbEnumFirstValue (&e, key, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
            value1 = _ttoi (e.szName);
            MemDbBuildKey (key, MEMDB_CATEGORY_DEFAULT_PIF, MEMDB_CATEGORY_LINKEDIT_YSIZE, TEXT("*"), NULL);
            if (MemDbEnumFirstValue (&e, key, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
                value2 = _ttoi (e.szName);
                value2 = _rotl (value2, sizeof (DWORD) * 8 / 2);
                value1 |= value2;
                RegSetValueEx (cmdKey, S_CMD_WINDOWSIZE, 0, REG_DWORD, (PCBYTE)&value1, sizeof (DWORD));
            }
        }
        MemDbBuildKey (key, MEMDB_CATEGORY_DEFAULT_PIF, MEMDB_CATEGORY_LINKEDIT_QUICKEDIT, TEXT("*"), NULL);
        if (MemDbEnumFirstValue (&e, key, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
            value1 = _ttoi (e.szName);
            RegSetValueEx (cmdKey, S_CMD_QUICKEDIT, 0, REG_DWORD, (PCBYTE)&value1, sizeof (DWORD));
        }
        MemDbBuildKey (key, MEMDB_CATEGORY_DEFAULT_PIF, MEMDB_CATEGORY_LINKEDIT_FONTNAME, TEXT("*"), NULL);
        if (MemDbEnumFirstValue (&e, key, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
            RegSetValueEx (cmdKey, S_CMD_FACENAME, 0, REG_SZ, (PCBYTE)e.szName, SizeOfString (e.szName));
        }
        MemDbBuildKey (key, MEMDB_CATEGORY_DEFAULT_PIF, MEMDB_CATEGORY_LINKEDIT_XFONTSIZE, TEXT("*"), NULL);
        if (MemDbEnumFirstValue (&e, key, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
            value1 = _ttoi (e.szName);
            MemDbBuildKey (key, MEMDB_CATEGORY_DEFAULT_PIF, MEMDB_CATEGORY_LINKEDIT_YFONTSIZE, TEXT("*"), NULL);
            if (MemDbEnumFirstValue (&e, key, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
                value2 = _ttoi (e.szName);
                value2 = _rotl (value2, sizeof (DWORD) * 8 / 2);
                value1 |= value2;
                RegSetValueEx (cmdKey, S_CMD_FONTSIZE, 0, REG_DWORD, (PCBYTE)&value1, sizeof (DWORD));
            }
        }
        MemDbBuildKey (key, MEMDB_CATEGORY_DEFAULT_PIF, MEMDB_CATEGORY_LINKEDIT_FONTWEIGHT, TEXT("*"), NULL);
        if (MemDbEnumFirstValue (&e, key, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
            value1 = _ttoi (e.szName);
            RegSetValueEx (cmdKey, S_CMD_FONTWEIGHT, 0, REG_DWORD, (PCBYTE)&value1, sizeof (DWORD));
        }
        MemDbBuildKey (key, MEMDB_CATEGORY_DEFAULT_PIF, MEMDB_CATEGORY_LINKEDIT_FONTFAMILY, TEXT("*"), NULL);
        if (MemDbEnumFirstValue (&e, key, MEMDB_ALL_SUBLEVELS, MEMDB_ENDPOINTS_ONLY)) {
            value1 = _ttoi (e.szName);
            RegSetValueEx (cmdKey, S_CMD_FONTFAMILY, 0, REG_DWORD, (PCBYTE)&value1, sizeof (DWORD));
        }

        CloseRegKey (cmdKey);
    }

    return TRUE;
}


BOOL
DoLinkEdit (
    VOID
    )

/*++

Routine Description:

  DoLinkEdit adjusts all PIFs and LNKs that need their targets, working
  directories or icon paths changed.

Arguments:

  none

Return Value:

  TRUE if link editing succeeded, or FALSE if an error occurred.

--*/

{
    FILEOP_ENUM eOp;
    FILEOP_PROP_ENUM eOpProp;
    BOOL forceToShowNormal;
    BOOL ConvertToLnk;
    PTSTR NewTarget;
    PTSTR NewArgs;
    PTSTR NewWorkDir;
    PTSTR NewIconPath;
    PTSTR NewLinkPath;
    INT NewIconNr;
    INT Sequencer;
    DWORD Announcement;
    DWORD Availability;
    INT ShowMode;
    LNK_EXTRA_DATA ExtraData;
    CONVERTPATH_RC C_Result;
    TCHAR tempArgs[MAX_TCHAR_PATH * sizeof (TCHAR)];
    GROWBUFFER reqFilesList = GROWBUF_INIT;

    if (EnumFirstPathInOperation (&eOp, OPERATION_LINK_EDIT)) {
        do {
            DEBUGMSG ((DBG_VERBOSE, "eOp.Path=%s", eOp.Path));

            NewTarget = NULL;
            NewArgs = NULL;
            NewWorkDir = NULL;
            NewIconPath = NULL;
            NewIconNr = 0;
            ConvertToLnk = FALSE;
            forceToShowNormal = FALSE;

            ZeroMemory (&ExtraData, sizeof (LNK_EXTRA_DATA));
            if (EnumFirstFileOpProperty (&eOpProp, eOp.Sequencer, OPERATION_LINK_EDIT)) {
                do {
                    if (StringIMatch (eOpProp.PropertyName, MEMDB_CATEGORY_LINKEDIT_TARGET)) {
                        NewTarget = DuplicatePathString (eOpProp.Property, 0);
                    }
                    if (StringIMatch (eOpProp.PropertyName, MEMDB_CATEGORY_LINKEDIT_ARGS)) {
                        StringCopyTcharCount (tempArgs, eOpProp.Property, ARRAYSIZE(tempArgs));
                        C_Result = ConvertWin9xPath (tempArgs);
                        NewArgs = DuplicatePathString (tempArgs, 0);
                    }
                    if (StringIMatch (eOpProp.PropertyName, MEMDB_CATEGORY_LINKEDIT_WORKDIR)) {
                        NewWorkDir = DuplicatePathString (eOpProp.Property, 0);
                    }
                    if (StringIMatch (eOpProp.PropertyName, MEMDB_CATEGORY_LINKEDIT_ICONPATH)) {
                        NewIconPath = DuplicatePathString (eOpProp.Property, 0);
                    }
                    if (StringIMatch (eOpProp.PropertyName, MEMDB_CATEGORY_LINKEDIT_ICONNUMBER)) {
                        NewIconNr = _tcstoul (eOpProp.Property, NULL, 16);
                    }
                    if (StringIMatch (eOpProp.PropertyName, MEMDB_CATEGORY_LINKEDIT_FULLSCREEN)) {
                        ConvertToLnk = TRUE;
                        ExtraData.FullScreen = _ttoi (eOpProp.Property);
                    }
                    if (StringIMatch (eOpProp.PropertyName, MEMDB_CATEGORY_LINKEDIT_XSIZE)) {
                        ConvertToLnk = TRUE;
                        ExtraData.xSize = _ttoi (eOpProp.Property);
                    }
                    if (StringIMatch (eOpProp.PropertyName, MEMDB_CATEGORY_LINKEDIT_YSIZE)) {
                        ConvertToLnk = TRUE;
                        ExtraData.ySize = _ttoi (eOpProp.Property);
                    }
                    if (StringIMatch (eOpProp.PropertyName, MEMDB_CATEGORY_LINKEDIT_QUICKEDIT)) {
                        ConvertToLnk = TRUE;
                        ExtraData.QuickEdit = _ttoi (eOpProp.Property);
                    }
                    if (StringIMatch (eOpProp.PropertyName, MEMDB_CATEGORY_LINKEDIT_FONTNAME)) {
                        ConvertToLnk = TRUE;
                        StringCopy (ExtraData.FontName, eOpProp.Property);
                    }
                    if (StringIMatch (eOpProp.PropertyName, MEMDB_CATEGORY_LINKEDIT_XFONTSIZE)) {
                        ConvertToLnk = TRUE;
                        ExtraData.xFontSize = _ttoi (eOpProp.Property);
                    }
                    if (StringIMatch (eOpProp.PropertyName, MEMDB_CATEGORY_LINKEDIT_YFONTSIZE)) {
                        ConvertToLnk = TRUE;
                        ExtraData.yFontSize = _ttoi (eOpProp.Property);
                    }
                    if (StringIMatch (eOpProp.PropertyName, MEMDB_CATEGORY_LINKEDIT_FONTWEIGHT)) {
                        ConvertToLnk = TRUE;
                        ExtraData.FontWeight = _ttoi (eOpProp.Property);
                    }
                    if (StringIMatch (eOpProp.PropertyName, MEMDB_CATEGORY_LINKEDIT_FONTFAMILY)) {
                        ConvertToLnk = TRUE;
                        ExtraData.FontFamily = _ttoi (eOpProp.Property);
                    }
                    if (StringIMatch (eOpProp.PropertyName, MEMDB_CATEGORY_LINKEDIT_CODEPAGE)) {
                        ConvertToLnk = TRUE;
                        ExtraData.CurrentCodePage = (WORD)_ttoi (eOpProp.Property);
                    }
                    if (StringIMatch (eOpProp.PropertyName, MEMDB_CATEGORY_LINKEDIT_SHOWNORMAL)) {
                        ConvertToLnk = TRUE;
                        forceToShowNormal = TRUE;
                    }
                } while (EnumNextFileOpProperty (&eOpProp));
            }

            NewLinkPath = GetPathStringOnNt (eOp.Path);

            DEBUGMSG ((DBG_VERBOSE, "Editing shell link %s", NewLinkPath));

            if (!ModifyShellLink(
                    NewLinkPath,
                    NewTarget,
                    NewArgs,
                    NewWorkDir,
                    NewIconPath,
                    NewIconNr,
                    ConvertToLnk,
                    &ExtraData,
                    forceToShowNormal
                    )) {
                LOG ((LOG_ERROR, "Shell Link %s could not be modified", eOp.Path));
            }

            FreePathString (NewLinkPath);

        } while (EnumNextPathInOperation (&eOp));
    }

    if (EnumFirstPathInOperation (&eOp, OPERATION_LINK_STUB)) {

        pInitLnkStubData ();

        do {
            NewTarget = NULL;
            NewArgs = NULL;
            NewWorkDir = NULL;
            NewIconPath = NULL;
            NewIconNr = 0;
            Sequencer = 0;
            Announcement = 0;
            Availability = 0;
            ShowMode = SW_NORMAL;

            if (EnumFirstFileOpProperty (&eOpProp, eOp.Sequencer, OPERATION_LINK_STUB)) {
                do {
                    if (StringIMatch (eOpProp.PropertyName, MEMDB_CATEGORY_LINKSTUB_TARGET)) {
                        NewTarget = DuplicatePathString (eOpProp.Property, 0);
                    }
                    if (StringIMatch (eOpProp.PropertyName, MEMDB_CATEGORY_LINKSTUB_ARGS)) {
                        StringCopyTcharCount (tempArgs, eOpProp.Property, ARRAYSIZE(tempArgs));
                        C_Result = ConvertWin9xPath (tempArgs);
                        NewArgs = DuplicatePathString (tempArgs, 0);
                    }
                    if (StringIMatch (eOpProp.PropertyName, MEMDB_CATEGORY_LINKSTUB_WORKDIR)) {
                        NewWorkDir = DuplicatePathString (eOpProp.Property, 0);
                    }
                    if (StringIMatch (eOpProp.PropertyName, MEMDB_CATEGORY_LINKSTUB_ICONPATH)) {
                        NewIconPath = DuplicatePathString (eOpProp.Property, 0);
                    }
                    if (StringIMatch (eOpProp.PropertyName, MEMDB_CATEGORY_LINKSTUB_ICONNUMBER)) {
                        NewIconNr = _tcstoul (eOpProp.Property, NULL, 16);
                    }
                    if (StringIMatch (eOpProp.PropertyName, MEMDB_CATEGORY_LINKSTUB_SEQUENCER)) {
                        Sequencer = _tcstoul (eOpProp.Property, NULL, 16);
                    }
                    if (StringIMatch (eOpProp.PropertyName, MEMDB_CATEGORY_LINKSTUB_ANNOUNCEMENT)) {
                        Announcement = _tcstoul (eOpProp.Property, NULL, 16);
                    }
                    if (StringIMatch (eOpProp.PropertyName, MEMDB_CATEGORY_LINKSTUB_REPORTAVAIL)) {
                        Availability = _tcstoul (eOpProp.Property, NULL, 16);
                    }
                    if (StringIMatch (eOpProp.PropertyName, MEMDB_CATEGORY_LINKSTUB_REQFILE)) {
                        MultiSzAppend (&reqFilesList, eOpProp.Property);
                    }
                    if (StringIMatch (eOpProp.PropertyName, MEMDB_CATEGORY_LINKSTUB_SHOWMODE)) {
                        ShowMode = _tcstoul (eOpProp.Property, NULL, 16);
                    }
                } while (EnumNextFileOpProperty (&eOpProp));
            }

            NewLinkPath = GetPathStringOnNt (eOp.Path);

            pWriteLnkStubData (
                NewLinkPath,
                NewTarget,
                NewArgs,
                NewWorkDir,
                NewIconPath,
                NewIconNr,
                ShowMode,
                Sequencer,
                Announcement,
                Availability,
                &reqFilesList
                );

            FreeGrowBuffer (&reqFilesList);

        } while (EnumNextPathInOperation (&eOp));

        pDoneLnkStubData ();
    }

    return TRUE;
}


PCTSTR
pGetFileNameFromPath (
    PCTSTR FileSpec
    )
{
    PCTSTR p;

    p = _tcsrchr (FileSpec, TEXT('\\'));
    if (p) {
        p = _tcsinc (p);
    } else {
        p = _tcsrchr (FileSpec, TEXT(':'));
        if (p) {
            p = _tcsinc (p);
        }
    }

    if (!p) {
        p = FileSpec;
    }

    return p;

}


BOOL
DoFileDel (
    VOID
    )
/*++

Routine Description:

  DoFileDel deletes all files marked to be deleted by us (not by an external
  module).

Arguments:

  none

Return Value:

  TRUE if the delete operation succeeded, or FALSE if an error occurred.
  Call GetLastError() for error code.

--*/

{
    FILEOP_ENUM e;
    HKEY Key;
    PDWORD ValuePtr;
    BOOL DoDelete;
    PCTSTR SharedFileName;
    DWORD attr;
    PCTSTR disableName;
    PCTSTR newLocation;
    GROWLIST disableList = GROWLIST_INIT;
    PCTSTR srcPath;
    UINT count;
    UINT u;

    //
    // Enumerate each file in filedel. This is used for cleanup purposes, not
    // for migration purposes. It is called just before syssetup.dll
    // terminates.
    //

    if (EnumFirstPathInOperation (&e, OPERATION_CLEANUP)) {

        do {
            //
            // Check registry for use count
            //

            DoDelete = TRUE;
            Key = OpenRegKeyStr (S_REG_SHARED_DLLS);

            if (Key) {
                //
                // Test SharedDlls for full path, then file name only
                //

                SharedFileName = e.Path;
                ValuePtr = (PDWORD) GetRegValueDataOfType (Key, e.Path, REG_DWORD);

                if (!ValuePtr) {
                    SharedFileName = pGetFileNameFromPath (e.Path);
                    ValuePtr = (PDWORD) GetRegValueDataOfType (
                                            Key,
                                            SharedFileName,
                                            REG_DWORD
                                            );
                }

                //
                // Match found.  Is use count reasonable and greater than one?
                //

                if (ValuePtr) {
                    if (*ValuePtr < 0x10000 && *ValuePtr > 1) {
                        *ValuePtr -= 1;

                        RegSetValueEx (
                            Key,
                            SharedFileName,
                            0,
                            REG_DWORD,
                            (PBYTE) ValuePtr,
                            sizeof (DWORD)
                            );

                        DEBUGMSG ((
                            DBG_FILEMIG,
                            "%s not deleted; share count decremented to %u",
                            SharedFileName,
                            *ValuePtr
                            ));

                    } else {
                        RegDeleteValue (Key, SharedFileName);
                    }

                    DoDelete = FALSE;
                    MemFree (g_hHeap, 0, ValuePtr);
                }

                CloseRegKey (Key);
            }

            if (DoDelete) {

                attr = GetLongPathAttributes (e.Path);
                if (attr != INVALID_ATTRIBUTES) {
                    DEBUGMSG ((DBG_FILEMIG, "Deleting %s", e.Path));

                    if (GetLongPathAttributes (e.Path) & FILE_ATTRIBUTE_DIRECTORY) {
                        SetLongPathAttributes (e.Path, FILE_ATTRIBUTE_DIRECTORY);

                        DEBUGMSG ((DBG_FILEMIG, "Removing %s", e.Path));

                        DeleteDirectoryContents (e.Path);

                        if (!SetLongPathAttributes (e.Path, FILE_ATTRIBUTE_NORMAL) ||
                            !RemoveLongDirectoryPath (e.Path)
                            ) {
                            LOG ((LOG_ERROR, "RemoveDirectory failed for %s", e.Path));
                        }
                    } else {
                        DEBUGMSG ((DBG_FILEMIG, "Deleting %s", e.Path));

                        if (!SetLongPathAttributes (e.Path, FILE_ATTRIBUTE_NORMAL) ||
                            !DeleteLongPath (e.Path)
                            ) {
                            LOG ((LOG_ERROR, "DeleteFile failed for %s", e.Path));
                        }
                    }

                    DEBUGMSG ((DBG_FILEMIG, "Done deleting %s", e.Path));
                }
            }
        } while (EnumNextPathInOperation (&e));
    }

    SetLastError (ERROR_SUCCESS);
    return TRUE;
}


INT
CALLBACK
pRemoveEmptyDirsProc (
    PCTSTR FullFileSpec,
    PCTSTR DontCare,
    WIN32_FIND_DATA *FindDataPtr,
    DWORD EnumTreeID,
    PVOID Param,
    PDWORD CurrentDirData
    )

/*++

Routine Description:

  pRemoveEmptyDirsProc is called for every directory in the tree being
  enumerated (see pRemoveEmptyDirsInTree below).  This enum proc calls
  RemoveLongDirectoryPath, regardless if files exist in it or not.
  RemoveLongDirectoryPath will fail if it is not empty.

Arguments:

  FullFileSpec - The Win32 path and directory name of the item being enumerated
  FindDataPtr  - A pointer to the WIN32_FIND_DATA structure for the item
  EnumTreeID   - Unused
  Param        - A BOOL indicating FALSE if we should only remove empty dirs that we
                 deleted something from, or TRUE if we should delete the empty
                 dir in any case.

Return Value:

  TRUE if the delete operation succeeded, or FALSE if an error occurred.
  Call GetLastError() for error code.

--*/

{
    if ((FindDataPtr->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) == 0) {
        return CALLBACK_CONTINUE;
    }

    //
    // Did we delete any files from this directory?
    //

    if (!Param) {
        if (!TestPathsForOperations (FullFileSpec, ALL_DELETE_OPERATIONS)) {
            DEBUGMSG ((DBG_NAUSEA, "We did not delete anything from %s", FullFileSpec));
            return CALLBACK_CONTINUE;
        }

        if (IsDirectoryMarkedAsEmpty (FullFileSpec)) {
            DEBUGMSG ((DBG_NAUSEA, "This directory was empty to begin with: %s", FullFileSpec));
            return CALLBACK_CONTINUE;
        }
    }

    //
    // Yes, delete the directory.  If it is not empty, RemoveLongDirectoryPath will fail.
    //

    DEBUGMSG ((DBG_NAUSEA, "Trying to remove empty directory %s", FullFileSpec));

    if (!SetLongPathAttributes (FullFileSpec, FILE_ATTRIBUTE_DIRECTORY)) {
        return CALLBACK_CONTINUE;
    }

    if (RemoveLongDirectoryPath (FullFileSpec)) {
        DEBUGMSG ((DBG_NAUSEA, "%s was removed", FullFileSpec));
    }
    else {
        DEBUGMSG ((DBG_NAUSEA, "%s was not removed", FullFileSpec));
        SetLongPathAttributes (FullFileSpec, FindDataPtr->dwFileAttributes);
    }

    return CALLBACK_CONTINUE;
}


BOOL
pRemoveEmptyDirsInTree (
    PCTSTR TreePath,
    BOOL CleanAll
    )

/*++

Routine Description:

  pRemoveEmptyDirsInTree calls EnumerateTree to scan all directories in
  TreePath, deleting those that are empty.

Arguments:

  TreePath  - A full path to the root of the tree to enumerate.  The path
              must not have any wildcards.

  CleanAll - Specifies TRUE if the empty dir should be cleaned in all cases,
             or FALSE if it should be cleaned only if modified by a delete
             operation.

Return Value:

  TRUE if the delete operation succeeded, or FALSE if an error occurred.
  Call GetLastError() for error code.

--*/

{
    BOOL b;

    b = EnumerateTree (
            TreePath,               // Starting path
            pRemoveEmptyDirsProc,   // Enumeration Proc
            NULL,                   // Error-logging proc
            0,                      // MemDb exclusion node--not used
            (PVOID) CleanAll,       // EnumProc param
            ENUM_ALL_LEVELS,        // Level
            NULL,                   // exclusion INF file--not used
            FILTER_DIRECTORIES|FILTER_DIRS_LAST    // Attributes filter
            );

    if (!b) {
        LOG ((LOG_ERROR, "pRemoveEmptyDirsInTree: EnumerateTree failed"));
    }

    return b;
}


BOOL
RemoveEmptyDirs (
    VOID
    )

/*++

Routine Description:

  RemoveEmptyDirs sweeps through the directories in CleanUpDirs and blows away
  any subdirectory that has no files.

Arguments:

  none

Return Value:

  Always TRUE.

--*/

{
    MEMDB_ENUM e;

    if (MemDbGetValueEx (&e, MEMDB_CATEGORY_CLEAN_UP_DIR, NULL, NULL)) {
        do {

            pRemoveEmptyDirsInTree (e.szName, e.dwValue);

        } while (MemDbEnumNextValue (&e));
    }
    return TRUE;
}


VOID
pFixSelfRelativePtr (
    PTOKENSET Base,
    PCVOID *Ptr
    )
{
    if (*Ptr != NULL) {
        *Ptr = (PBYTE) *Ptr - TOKEN_BASE_OFFSET + (UINT) Base +
               sizeof (TOKENSET) + (Base->ArgCount * sizeof (TOKENARG));
    }
}


BOOL
pFileSearchAndReplaceA (
    IN      PCSTR FilePath,
    IN OUT  PTOKENSET TokenSet
    )

/*++

Routine Description:

  pFileSearchAndReplace does all the initialization work necessary to update
  the contents of a file.  It also converts a self-relative token set into an
  absolute token set.  That means the offsets in the struct are converted to
  pointers.  After everything is prepared, pFileSearchAndReplaceWorker is
  called to modify the file.

Arguments:

  FilePath - Specifies the file to process
  TokenSet - Specifies the token set to apply to FilePath.  Receives its
             pointers updated, if necessary.

Return Value:

  TRUE if the file was successfully updated. FALSE otherwise.

--*/

{
    HANDLE InFile = INVALID_HANDLE_VALUE;
    HANDLE OutFile = INVALID_HANDLE_VALUE;
    CHAR TempDir[MAX_MBCHAR_PATH];
    CHAR TempPath[MAX_MBCHAR_PATH];
    PBYTE MapStart = NULL;
    PBYTE MapEnd;
    DWORD Attribs;
    HANDLE Map = NULL;
    BOOL b = FALSE;
    UINT u;

    __try {
        //
        // Detect a TokenSet struct that needs its offsets fixed
        //

        if (TokenSet->SelfRelative) {
            pFixSelfRelativePtr (TokenSet, &TokenSet->CharsToIgnore);

            for (u = 0 ; u < TokenSet->ArgCount ; u++) {
                pFixSelfRelativePtr (TokenSet, &TokenSet->Args[u].DetectPattern);
                pFixSelfRelativePtr (TokenSet, &TokenSet->Args[u].SearchList);
                pFixSelfRelativePtr (TokenSet, &TokenSet->Args[u].ReplaceWith);
            }

            TokenSet->SelfRelative = FALSE;
        }

        DEBUGMSG ((DBG_VERBOSE, "URL mode: %s", TokenSet->UrlMode ? TEXT("YES") : TEXT ("NO")));

        //
        // Save original attributes
        //

        Attribs = GetFileAttributesA (FilePath);
        if (Attribs == INVALID_ATTRIBUTES) {
            DEBUGMSGA ((DBG_ERROR, "Can't get attributes of %s", FilePath));
            __leave;
        }

        //
        // Open the source file
        //

        InFile = CreateFileA (
                    FilePath,
                    GENERIC_READ,
                    0,
                    NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    NULL
                    );

        if (InFile == INVALID_HANDLE_VALUE) {
            DEBUGMSGA ((DBG_ERROR, "Can't open %s", FilePath));
            __leave;
        }

        //
        // Get a destination file name
        //

        GetTempPathA (ARRAYSIZE(TempDir), TempDir);
        GetTempFileNameA (TempDir, "xx$", 0, TempPath);

        OutFile = CreateFileA (
                        TempPath,
                        GENERIC_WRITE,
                        0,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );

        if (OutFile == INVALID_HANDLE_VALUE) {
            DEBUGMSGA ((DBG_ERROR, "Can't create %s", TempPath));
            __leave;
        }

        //
        // Create file mapping
        //

        Map = CreateFileMapping (
                    InFile,
                    NULL,
                    PAGE_READONLY,
                    0,
                    0,
                    NULL
                    );

        if (!Map) {
            DEBUGMSGA ((DBG_ERROR, "Can't create file mapping for %s", FilePath));
            __leave;
        }

        //
        // Map a view of the source file
        //

        MapStart = MapViewOfFile (Map, FILE_MAP_READ, 0, 0, 0);

        if (!MapStart) {
            DEBUGMSGA ((DBG_ERROR, "Can't map view of file for %s", FilePath));
            __leave;
        }

        MapEnd = MapStart + GetFileSize (InFile, NULL);

        //
        // Now do the search and replace
        //

        if (!pFileSearchAndReplaceWorker (
                MapStart,
                MapEnd,
                OutFile,
                TokenSet
                )) {
            __leave;
        }

        //
        // Close the handles
        //

        UnmapViewOfFile (MapStart);
        CloseHandle (Map);
        CloseHandle (OutFile);
        CloseHandle (InFile);

        MapStart = NULL;
        Map = NULL;
        OutFile = INVALID_HANDLE_VALUE;
        InFile = INVALID_HANDLE_VALUE;

        //
        // Remove the original file, and replace it with the new copy
        //

        SetFileAttributesA (FilePath, FILE_ATTRIBUTE_NORMAL);

        //
        // MOVEFILE_REPLACE_EXISTING does not work with non-normal attributes
        //

        if (!OurMoveFileExA (TempPath, FilePath, MOVEFILE_COPY_ALLOWED|MOVEFILE_REPLACE_EXISTING)) {
            DEBUGMSGA ((DBG_ERROR, "Can't move %s to %s", TempPath, FilePath));
            __leave;
        }

        if (!SetFileAttributesA (FilePath, Attribs)) {
            DEBUGMSGA ((DBG_WARNING, "Can't set attributes on %s", FilePath));
        }

        b = TRUE;

    }
    __finally {
        if (MapStart) {
            UnmapViewOfFile (MapStart);
        }

        if (Map) {
            CloseHandle (Map);
        }

        if (OutFile != INVALID_HANDLE_VALUE) {
            CloseHandle (OutFile);
            DeleteFileA (TempPath);
        }

        if (InFile != INVALID_HANDLE_VALUE) {
            CloseHandle (InFile);
        }
    }

    return b;
}


VOID
pConvertUrlToText (
    IN      PCSTR Source,
    OUT     PSTR Buffer     // caller must ensure buffer is able to hold the entire Source
    )
{
    PSTR dest;
    PCSTR src;

    src = Source;
    dest = Buffer;

    while (*src) {
        if (*src == '%' && GetHexDigit(src[1]) != -1 && GetHexDigit(src[2]) != -1) {
            *dest++ = GetHexDigit(src[1]) << 4 | GetHexDigit(src[2]);
            src += 3;
        } else {
            *dest++ = *src++;
        }
    }

    *dest = 0;
}


CHAR
pMakeHex (
    IN      UINT Digit
    )
{
    MYASSERT (Digit < 16);

    if (Digit < 10) {
        Digit += '0';
    } else {
        Digit += 'A' - 10;
    }

    return (CHAR) Digit;
}

UINT
pConvertTextToUrl (
    IN      PCSTR Text,
    OUT     PSTR Buffer,
    IN      UINT BufferTchars
    )
{
    PSTR dest;
    PCSTR src;
    PSTR maxDest;
    PCSTR unsafeChars = "<>\"#{}|^~[]'";
    UINT result = 0;

    src = Text;
    dest = Buffer;
    maxDest = Buffer + BufferTchars - 1;

    while (*src && dest < maxDest) {
        if (*src < 0x21 || *src > 0x7e || strchr (unsafeChars, *src)) {
            if (dest + 3 >= maxDest) {
                break;
            }

            *dest++ = '%';
            *dest++ = pMakeHex (((UINT) (*src)) >> 4);
            *dest++ = pMakeHex (((UINT) (*src)) & 0x0F);
            src++;
        } else if (*src == '\\') {
            *dest++ = '/';
            src++;
        } else {
            *dest++ = *src++;
        }
    }

    if (dest <= maxDest) {
        *dest++ = 0;
        result = dest - Buffer;
    } else if (BufferTchars) {
        *maxDest = 0;
    }

    return result;
}


BOOL
pFileSearchAndReplaceWorker (
    IN      PBYTE MapStart,
    IN      PBYTE MapEnd,
    IN      HANDLE OutFile,
    IN      PTOKENSET TokenSet
    )

/*++

Routine Description:

  pFileSearchAndReplaceWorker implements a general search and replace
  mechanism. It parses a memory mapped file, and writes it to a destination
  file, updating it as necessary.

  After parsing a line, this function strips out the characters to be
  ignored (if any), and then tests the line against each detection
  pattern. If a detection pattern is matched, then the search/replace
  pair(s) are processed, and the paths are updated if specified.

Arguments:

  MapStart - Specifies the first byte of the memory mapped file
  MapEnd   - Specifies one byte after the end of the memory mapped file
  OutFile  - Specifies a handle to a file that is open for writing
  TokenSet - Specifies the set of tokens to process.  This includes global
             settings, and detect/search/replace sets.

Return Value:

  TRUE if the function successfully processed the file, FALSE otherwise.

--*/

{
    PBYTE Start;
    PBYTE End;
    PBYTE Eol;
    BOOL b = FALSE;
    GROWBUFFER Buf = GROWBUF_INIT;
    GROWBUFFER Dest = GROWBUF_INIT;
    GROWBUFFER quoteless = GROWBUF_INIT;
    GROWBUFFER SpcList = GROWBUF_INIT;
    UINT u;
    UINT Count;
    PSTR p;
    PCSTR q;
    PCSTR SrcBuf;
    BOOL Detected;
    PTOKENARG Arg;
    MULTISZ_ENUMA e;
    PCSTR NewStr;
    PCSTR ReplaceStr;
    PCSTR *Element;
    PSTR EndStr;
    DWORD Status;
    CHAR NewPath[MAX_MBCHAR_PATH];
    UINT Len;
    PBYTE Output;
    UINT OutputBytes;
    DWORD DontCare;
    MBCHAR ch;
    INT i;
    UINT reservedTchars;
    PSTR reservedDest;
    UINT removedDblQuotes;
    PCSTR initialPos;
    UINT inQuotes;

    //
    // Initialize the structure
    //

    for (u = 0 ; u < TokenSet->ArgCount ; u++) {

        Arg = &TokenSet->Args[u];
        Arg->DetectPatternStruct = NULL;

    }

    __try {

        //
        // Parse the detect patterns
        //

        for (u = 0 ; u < TokenSet->ArgCount ; u++) {

            Arg = &TokenSet->Args[u];

            Arg->DetectPatternStruct = CreateParsedPatternA (
                                            Arg->DetectPattern
                                            );

            if (!Arg->DetectPatternStruct) {
                DEBUGMSGA ((DBG_ERROR, "File pattern syntax error: %s", Arg->DetectPattern));
                __leave;
            }
        }

        //
        // Identify each line, and then parse the line
        //

        Start = MapStart;

        while (Start < MapEnd) {
            //
            // Find the line
            //

            End = Start;

            while (End < MapEnd && *End && *End != '\r' && *End != '\n') {
                End++;
            }

            Eol = End;

            if (End < MapEnd && *End == '\r') {
                while (End < MapEnd && *End == '\r') {
                    End++;
                }
            }

            if (End < MapEnd && *End == '\n') {
                End++;
            }

            if (End > Start) {

                //
                // OK we now have a line.  Copy it into Buf, removing
                // the characters we don't care about.
                //

                Buf.End = 0;
                Dest.End = 0;
                Detected = FALSE;

                p = (PSTR) GrowBuffer (&Buf, Eol - Start + sizeof (CHAR));

                if (TokenSet->CharsToIgnore) {
                    q = Start;
                    while (q < End) {
                        if (!_mbschr (TokenSet->CharsToIgnore, _mbsnextc (q))) {
                            _copymbchar (p, q);
                            p = _mbsinc (p);
                        }

                        q = _mbsinc (q);
                    }

                    *p = 0;

                    for (u = 0 ; u < TokenSet->ArgCount ; u++) {

                        Arg = &TokenSet->Args[u];
                        Detected = TestParsedPatternA (
                                        Arg->DetectPatternStruct,
                                        (PCSTR) Buf.Buf
                                        );

                        if (Detected) {
                            break;
                        }
                    }

                } else {
                    for (u = 0 ; u < TokenSet->ArgCount ; u++) {

                        Arg = &TokenSet->Args[u];
                        Detected = TestParsedPatternABA (
                                        Arg->DetectPatternStruct,
                                        (PCSTR) Start,
                                        (PCSTR) Eol
                                        );

                        if (Detected) {
                            break;
                        }
                    }
                }

                if (Detected) {

                    //
                    // Copy the line into a work buffer
                    //

                    Buf.End = 0;
                    p = (PSTR) GrowBuffer (&Buf, (End - Start + 1) * sizeof (CHAR));
                    StringCopyABA (p, (PCSTR) Start, (PCSTR) End);

                    Output = Buf.Buf;
                    OutputBytes = Buf.End - sizeof (CHAR);

                    DEBUGMSGA ((DBG_NAUSEA, "Copied line to work buffer: %s", p));

                    //
                    // Perform search and replace on the line
                    //

                    if (Arg->SearchList) {

                        ReplaceStr = Arg->ReplaceWith;

                        if (EnumFirstMultiSzA (&e, Arg->SearchList)) {
                            do {
                                NewStr = StringSearchAndReplaceA (
                                            (PCSTR) Buf.Buf,
                                            e.CurrentString,
                                            ReplaceStr
                                            );

                                if (NewStr) {
                                    Buf.End = 0;
                                    GrowBufCopyStringA (&Buf, NewStr);
                                    FreePathStringA (NewStr);

                                    OutputBytes = Buf.End - sizeof (CHAR);
                                }

                                ReplaceStr = GetEndOfStringA (ReplaceStr) + 1;

                            } while (EnumNextMultiSzA (&e));
                        }
                    }

                    //
                    // Perform path update
                    //

                    if (Arg->UpdatePath) {

                        DEBUGMSG ((DBG_NAUSEA, "Updating path"));

                        Dest.End = 0;
                        SrcBuf = (PCSTR) Buf.Buf;

                        inQuotes = 0;

                        while (*SrcBuf) {
                            if ((SrcBuf[1] == ':' && (SrcBuf[2] == '\\' || SrcBuf[2] == '/')) &&
                                (SrcBuf[3] != '/' && SrcBuf[3] != '\\')
                                ) {

                                quoteless.End = 0;
                                GrowBuffer (&quoteless, SizeOfStringA (SrcBuf));

                                //
                                // Convert from URL to file system char set
                                //

                                if (TokenSet->UrlMode) {
                                    DEBUGMSGA ((DBG_NAUSEA, "URL conversion input: %s", SrcBuf));

                                    pConvertUrlToText (SrcBuf, (PSTR) quoteless.Buf);
                                    q = (PCSTR) quoteless.Buf;

                                    DEBUGMSGA ((DBG_NAUSEA, "URL conversion result: %s", q));
                                } else {
                                    q = SrcBuf;
                                }

                                //
                                // Remove all dbl quotes from buffer, flip
                                // forward slashes into backslashes, stop at
                                // first non-file system character
                                // or at the first quote if the text
                                // is between quotes already
                                //

                                p = (PSTR) quoteless.Buf;

                                initialPos = q;
                                DEBUGMSGA ((DBG_NAUSEA, "CMD line cleanup input: %s", q));

                                removedDblQuotes = 0;

                                while (*q) {
                                    ch = _mbsnextc (q);

                                    if (ch == ':' || ch == '|' || ch == '?' || ch == '*' || ch == '<' || ch == '>') {
                                        if (q != &initialPos[1]) {
                                            break;
                                        }
                                    }

                                    if (ch != '\"') {

                                        if (ch != '/') {
                                            if (IsLeadByte (*q) && q[1]) {
                                                *p++ = *q++;
                                            }
                                            *p++ = *q++;
                                        } else {
                                            *p++ = '\\';
                                            q++;
                                        }
                                    } else {
                                        //
                                        // check parser's status
                                        //
                                        if (inQuotes & 1) {
                                            //
                                            // done with the filename
                                            //
                                            break;
                                        }
                                        q++;
                                        removedDblQuotes++;
                                    }
                                }

                                *p = 0;
                                DEBUGMSGA ((DBG_NAUSEA, "CMD line cleanup result: %s", quoteless.Buf));

                                //
                                // Build a list of spaces
                                //

                                SpcList.End = 0;

                                initialPos = (PCSTR) quoteless.Buf;
                                q = quoteless.Buf + 2;
                                EndStr = p;

                                while (q < EndStr) {
                                    ch = _mbsnextc (q);

                                    if (isspace (ch)) {
                                        Element = (PCSTR *) GrowBuffer (&SpcList, sizeof (PCSTR));
                                        *Element = q;

                                        while (q + 1 < EndStr && isspace (_mbsnextc (q + 1))) {
                                            q++;
                                        }
                                    }
                                    q = _mbsinc (q);
                                }

                                if (q == EndStr || !SpcList.End) {
                                    Element = (PCSTR *) GrowBuffer (&SpcList, sizeof (PCSTR));
                                    *Element = EndStr;
                                }

                                //
                                // Test all paths by using the longest possibility first,
                                // and then by truncating the path at the spaces.
                                //

                                Count = SpcList.End / sizeof (PCSTR);
                                MYASSERT (Count > 0);

                                Element = (PCSTR *) SpcList.Buf;

                                for (i = Count - 1 ; i >= 0 ; i--) {

                                    p = (PSTR) (Element[i]);
                                    ch = *p;
                                    *p = 0;

                                    DEBUGMSGA ((DBG_NAUSEA, "Testing path: %s", initialPos));

                                    Status = GetFileInfoOnNtA (initialPos, NewPath, MAX_MBCHAR_PATH);

                                    DEBUGMSGA ((DBG_NAUSEA, "Results: %x/%s", Status, NewPath));

                                    *p = (CHAR)ch;

                                    if (Status != FILESTATUS_UNCHANGED && Status != FILESTATUS_BACKUP) {
                                        break;
                                    }
                                }

                                *EndStr = 0;

                                //
                                // If there is a new path, update the destination
                                //

                                if (Status != FILESTATUS_UNCHANGED && Status != FILESTATUS_BACKUP) {

                                    if (TokenSet->UrlMode) {
                                        reservedTchars = (TcharCountA (NewPath) * 3) + 1;
                                        reservedDest = GrowBufferReserve (&Dest, reservedTchars * sizeof (CHAR));
                                        Dest.End += pConvertTextToUrl (NewPath, reservedDest, reservedTchars) / sizeof (CHAR);

                                        DEBUGMSGA ((DBG_NAUSEA, "URL conversion output: %s", reservedDest));
                                    } else {
                                        GrowBufAppendStringA (&Dest, NewPath);
                                    }

                                    SrcBuf += (Element[i] - initialPos) + removedDblQuotes;
                                    Dest.End -= sizeof (CHAR);

                                } else {
                                    //
                                    // No changed path here; copy char by char
                                    //

                                    if (IsLeadByte (*SrcBuf) && SrcBuf[1]) {
                                        Len = 2;
                                    } else {
                                        Len = 1;
                                    }

                                    p = GrowBuffer (&Dest, Len);
                                    CopyMemory (p, SrcBuf, Len);
                                    SrcBuf = (PCSTR) ((PBYTE) SrcBuf + Len);
                                }

                            } else {
                                //
                                // keep track of quotes
                                //
                                if (*SrcBuf == '\"') {
                                    inQuotes++;
                                }
                                //
                                // This is not a path, copy the character to Dest
                                //

                                if (IsLeadByte (*SrcBuf) && SrcBuf[1]) {
                                    Len = 2;
                                } else {
                                    Len = 1;
                                }

                                p = GrowBuffer (&Dest, Len);
                                CopyMemory (p, SrcBuf, Len);
                                SrcBuf = (PCSTR) ((PBYTE) SrcBuf + Len);

                            }
                        }

                        Output = Dest.Buf;
                        OutputBytes = Dest.End;
                    }

                } else {
                    //
                    // The line does not change
                    //

                    Output = Start;
                    OutputBytes = End - Start;
                }

                //
                // Write the line
                //

                if (!WriteFile (OutFile, Output, OutputBytes, &DontCare, NULL)) {
                    DEBUGMSG ((DBG_ERROR, "File search/replace: Can't write to output file"));
                    __leave;
                }

                //
                // Write a nul if it is found in the file
                //

                if (End < MapEnd && *End == 0) {
                    if (!WriteFile (OutFile, End, 1, &DontCare, NULL)) {
                        DEBUGMSG ((DBG_ERROR, "File search/replace: Can't write nul to output file"));
                        __leave;
                    }
                    End++;
                }

            } else if (End < MapEnd) {
                DEBUGMSG ((DBG_WHOOPS, "Parse error in pFileSearchAndReplaceWorker"));
                break;
            }

            Start = End;
        }

        b = TRUE;

    }
    __finally {

        FreeGrowBuffer (&Buf);
        FreeGrowBuffer (&Dest);
        FreeGrowBuffer (&SpcList);
        FreeGrowBuffer (&quoteless);

        for (u = 0 ; u < TokenSet->ArgCount ; u++) {

            Arg = &TokenSet->Args[u];
            DestroyParsedPatternA (Arg->DetectPatternStruct);
        }
    }

    return b;

}


BOOL
pIsOkToEdit (
    IN      PCSTR AnsiPath,
    OUT     PSTR NewPath            OPTIONAL
    )

/*++

Routine Description:

  pIsOkToEdit checks an ansi file name to see if it is handled by a migration
  DLL, or if it is deleted.  If neither of those cases apply, the file can be
  edited.  Optionally the function returns the final path for the file.

Arguments:

  AnsiPath - Specifies the path to test
  NewPath  - Receives the final path for the file, which may be the same as
             AnsiPath, or may be different.

Return Value:

  TRUE if the file can be edited, FALSE otherwise.

--*/

{
    DWORD Status;

    //
    // Is this file marked as handled?
    //

    if (IsFileMarkedAsHandledA (AnsiPath)) {
        return FALSE;
    }

    Status = GetFileInfoOnNtA (AnsiPath, NewPath, MEMDB_MAX);

    return !(Status & FILESTATUS_DELETED);
}


BOOL
pProcessFileEdit (
    VOID
    )

/*++

Routine Description:

  pProcessFileEdit enumerates all the files that can be edited, and calls
  pFileSearchAndReplace for each, using the token sets created on the Win9x
  side of setup.

Arguments:

  None.

Return Value:

  TRUE on success, FALSE on error.

--*/

{
    MEMDB_ENUMA e;
    PTOKENSET PathsOnlySet;
    BOOL b = TRUE;
    GROWBUFFER TokenSetCopy = GROWBUF_INIT;
    PTOKENSET Buf;
    CHAR NewPath[MEMDB_MAX];
    DWORD Result;

    Result = GetLastError();

    //
    // Create a set that will update the paths of any file
    //

    PathsOnlySet = (PTOKENSET) MemAlloc (g_hHeap, 0, sizeof (TOKENSET) + sizeof (TOKENARG));

    PathsOnlySet->ArgCount = 1;
    PathsOnlySet->CharsToIgnore = NULL;
    PathsOnlySet->UrlMode = FALSE;
    PathsOnlySet->SelfRelative = FALSE;
    PathsOnlySet->Args[0].DetectPattern = "*";
    PathsOnlySet->Args[0].SearchList = NULL;
    PathsOnlySet->Args[0].ReplaceWith = NULL;
    PathsOnlySet->Args[0].UpdatePath = TRUE;

    if (MemDbGetValueExA (&e, MEMDB_CATEGORY_FILEEDITA, NULL, NULL)) {

        do {

            if (!pIsOkToEdit (e.szName, NewPath)) {
                continue;
            }

            DEBUGMSGA ((DBG_VERBOSE, "Editing %s.", NewPath));

            if (e.bBinary) {
                TokenSetCopy.End = 0;
                Buf = (PTOKENSET) GrowBuffer (&TokenSetCopy, e.BinarySize);
                CopyMemory (Buf, e.BinaryPtr, e.BinarySize);

                if (!pFileSearchAndReplaceA (NewPath, Buf)) {
                    DEBUGMSGA ((DBG_ERROR, "Could not edit %s", NewPath));
                    b = FALSE;
                    Result = GetLastError();
                }

                FreeGrowBuffer (&TokenSetCopy);

            } else {

                if (!pFileSearchAndReplaceA (NewPath, PathsOnlySet)) {
                    DEBUGMSGA ((DBG_ERROR, "Could not edit %s", NewPath));
                    b = FALSE;
                    Result = GetLastError();
                }

            }

        } while (MemDbEnumNextValueA (&e));
    }

    MemFree (g_hHeap, 0, PathsOnlySet);

    SetLastError (Result);
    return b;
}


DWORD
DoFileEdit (
    DWORD Request
    )

/*++

Routine Description:

  DoFileEdit is called by the progress bar manager to query ticks or do the
  file editing.  If querying ticks, then the function determines how many
  files will be edited, and multiplies that by a constant to get the tick
  size.  Otherwise the function edits all the files queued for this operation.

Arguments:

  Request - Specifies the request being made by the progress bar manager

Return Value:

  If Request is REQUEST_QUERYTICKS, the return value indicates the number of
  ticks.  Otherwise, the return value is a Win32 result code.

--*/

{
    MEMDB_ENUMA e;
    UINT u;

    if (Request == REQUEST_QUERYTICKS) {

        u = 0;

        if (MemDbGetValueExA (&e, MEMDB_CATEGORY_FILEEDITA, NULL, NULL)) {
            do {
                if (pIsOkToEdit (e.szName, NULL)) {
                    u++;
                }
            } while (MemDbEnumNextValueA (&e));
        }

        return u * TICKS_FILE_EDIT;
    }

    if (Request != REQUEST_RUN) {
        return 0;
    }

    if (!pProcessFileEdit()) {
        return GetLastError();
    }

    return ERROR_SUCCESS;
}


VOID
pWriteLine (
    IN      HANDLE Handle,
    IN      PCWSTR RootDir,     OPTIONAL
    IN      PCWSTR String
    )
{
    DWORD dontCare;
    PCWSTR fullPath;

    if (RootDir) {
        fullPath = JoinPathsW (RootDir, String);
    } else {
        fullPath = String;
    }

    WriteFile (Handle, fullPath, ByteCountW (fullPath), &dontCare, NULL);

    if (fullPath != String) {
        FreePathStringW (fullPath);
    }

    WriteFile (Handle, L"\r\n", 4, &dontCare, NULL);
}


DWORD
RemoveBootIniCancelOption (
    DWORD Request
    )
{
    HINF inf = INVALID_HANDLE_VALUE;
    PCTSTR bootIni;
    PCTSTR bootIniTmp;
    DWORD result = ERROR_SUCCESS;
    PINFLINE osLine;
    BOOL changed = FALSE;
    DWORD attribs;

    if (Request == REQUEST_QUERYTICKS) {
        return 50;
    }

    if (Request != REQUEST_RUN) {
        return 0;
    }

    bootIni = JoinPaths (g_BootDrivePath, TEXT("boot.ini"));

    __try {
        //
        // Open boot.ini for editing
        //

        inf = OpenInfFile (bootIni);

        if (inf == INVALID_HANDLE_VALUE) {
            DEBUGMSG ((DBG_ERROR, "Can't open %s", bootIni));
            result = GetLastError();
            __leave;
        }

        //
        // Scan boot.ini for a textmode option that has /rollback. Delete it.
        //

        osLine = GetFirstLineInSectionStr (inf, TEXT("Operating Systems"));
        if (!osLine) {
            DEBUGMSG ((DBG_ERROR, "No lines found in [Operating Systems] in %s", bootIni));
            result = ERROR_FILE_NOT_FOUND;
            __leave;
        }

        //
        // Loop until all lines with /rollback are gone
        //

        do {
            do {
                //
                // Check this line for a /rollback option
                //

                if (_tcsistr (osLine->Data, TEXT("/rollback"))) {
                    DEBUGMSG ((DBG_FILEMIG, "Found rollback option: %s", osLine->Data));
                    break;
                }

            } while (osLine = GetNextLineInSection (osLine));

            if (osLine) {
                if (!DeleteLineInInfSection (inf, osLine)) {
                    MYASSERT (FALSE);
                    break;
                }

                DEBUGMSG ((DBG_FILEMIG, "Line sucessfully removed"));
                changed = TRUE;
                osLine = GetFirstLineInSectionStr (inf, TEXT("Operating Systems"));
            }

        } while (osLine);

        //
        // If we changed the file, then write it to disk. Keep the original
        // boot.ini file in case we fail to save.
        //

        attribs = GetFileAttributes (bootIni);
        SetFileAttributes (bootIni, FILE_ATTRIBUTE_NORMAL);
        MYASSERT (attribs != INVALID_ATTRIBUTES);

        bootIniTmp = JoinPaths (g_BootDrivePath, TEXT("boot.~t"));
        SetFileAttributes (bootIniTmp, FILE_ATTRIBUTE_NORMAL);
        DeleteFile (bootIniTmp);

        if (!MoveFile (bootIni, bootIniTmp)) {
            LOG ((LOG_ERROR, (PCSTR) MSG_BOOT_INI_MOVE_FAILED, bootIni, bootIniTmp));
            result = GetLastError();
        } else {

            DEBUGMSG ((DBG_FILEMIG, "Moved %s to %s", bootIni, bootIniTmp));

            if (!SaveInfFile (inf, bootIni)) {
                LOG ((LOG_ERROR, (PCSTR) MSG_BOOT_INI_SAVE_FAILED, bootIni));
                result = GetLastError();

                SetFileAttributes (bootIni, FILE_ATTRIBUTE_NORMAL);
                DeleteFile (bootIni);

                if (!MoveFile (bootIniTmp, bootIni)) {

                    //
                    // This should not happen, because we just successfully
                    // moved the original to the tmp; we should be able to
                    // move the temp back to the original. If we fail, the pc
                    // becomes unbootable. But what can we do?
                    //

                    LOG ((LOG_ERROR, (PCSTR) MSG_BOOT_INI_MOVE_FAILED, bootIniTmp, bootIni));
                }
            } else {
                //
                // boot.ini was successfully updated. Remove the original copy.
                //

                DeleteFile (bootIniTmp);
                MYASSERT (result == ERROR_SUCCESS);

                DEBUGMSG ((DBG_FILEMIG, "%s was saved", bootIni));
            }
        }

        //
        // restore attributes on original if possible.
        //

        SetFileAttributes (bootIni, attribs);
        FreePathString (bootIniTmp);

        // result already set above
    }
    __finally {
        if (inf != INVALID_HANDLE_VALUE) {
            CloseInfFile (inf);
        }

        FreePathString (bootIni);
    }

    return result;

}


ULONGLONG
pGetFileSize(
    IN  PCTSTR FilePath
    )
{
    ULARGE_INTEGER FileSize = {0, 0};

    GetFileSizeFromFilePath(FilePath, &FileSize);

    return FileSize.QuadPart;
}


BOOL
pMapHiveOfUserDoingTheUpgrade (
    VOID
    )
{
    MIGRATE_USER_ENUM e;
    PTSTR profilePath;
    TCHAR hiveFile[MAX_TCHAR_PATH];
    LONG rc;
    HKEY newHkcu = NULL;
    TCHAR rootKey[] = TEXT("HKU\\") S_TEMP_USER_KEY;
    BOOL result = FALSE;
    BOOL hiveLoaded = FALSE;

    __try {
        //
        // Find Administrator
        //

        if (EnumFirstUserToMigrate (&e, ENUM_ALL_USERS)) {
            do {
                if (e.UserDoingTheUpgrade) {
                    break;
                }
            } while (EnumNextUserToMigrate (&e));

            if (e.UserDoingTheUpgrade) {

                DEBUGMSG ((DBG_VERBOSE, "%s is the user doing the upgrade", e.FixedUserName));

                //
                // Load the hive
                //

                if (-1 == pSetupStringTableLookUpStringEx (
                                g_HiveTable,
                                e.FixedUserName,
                                STRTAB_CASE_INSENSITIVE,
                                hiveFile,
                                sizeof (hiveFile)
                                )) {
                    DEBUGMSG ((DBG_WHOOPS, "Can't find NT hive for %s", e.FixedUserName));
                    __leave;
                }

                rc = RegUnLoadKey (HKEY_USERS, S_TEMP_USER_KEY);

                if (rc != ERROR_SUCCESS) {
                    DumpOpenKeys ();
                    SetLastError (rc);
                    DEBUGMSG_IF ((
                        rc != ERROR_INVALID_PARAMETER,
                        DBG_WARNING,
                        "Can't unload temp user key"
                        ));
                }

                rc = RegLoadKey (HKEY_USERS, S_TEMP_USER_KEY, hiveFile);

                if (rc != ERROR_SUCCESS) {
                    LOG ((
                        LOG_ERROR,
                        "Uninstall: Can't load user hive for %s (%s)",
                        e.FixedUserName,
                        hiveFile
                        ));
                    __leave;
                }

                hiveLoaded = TRUE;

                newHkcu = OpenRegKeyStr (rootKey);
                if (newHkcu) {
                    rc = RegOverridePredefKey (HKEY_CURRENT_USER, newHkcu);
                    if (rc != ERROR_SUCCESS) {
                        LOG ((LOG_ERROR, "Uninstall: Can't override HKCU"));
                        __leave;
                    }

                } else {
                    LOG ((
                        LOG_ERROR,
                        "Uninstall: Can't open user hive for %s (%s)",
                        e.FixedUserName,
                        hiveFile
                        ));
                    __leave;
                }

            } else {
                DEBUGMSG ((DBG_ERROR, "Can't find migration user"));
                __leave;
            }
        } else {
            DEBUGMSG ((DBG_WHOOPS, "No users were enumerated"));
            __leave;
        }

        result = TRUE;
    }
    __finally {
        if (newHkcu) {
            CloseRegKey (newHkcu);
        }

        if (hiveLoaded && !result) {
            RegOverridePredefKey (HKEY_CURRENT_USER, NULL);
            RegUnLoadKey (HKEY_USERS, S_TEMP_USER_KEY);
        }
    }

    return result;
}


VOID
pUnmapHiveOfUserDoingTheUpgrade (
    VOID
    )
{
    RegOverridePredefKey (HKEY_CURRENT_USER, NULL);
    RegUnLoadKey (HKEY_USERS, S_TEMP_USER_KEY);
}


BOOL 
pClearPasswordsFromWinntSif(
    PCTSTR WinntSifDir
    )
{
    TCHAR pathWinntSif[MAX_PATH];
    TCHAR password[MAX_PATH];
    BOOL bResult = TRUE;
    UINT i;

    if(!WinntSifDir || 
      (_tcslen(WinntSifDir) + 1/*'\\'*/ + ARRAYSIZE(WINNT_SIF_FILE)) > ARRAYSIZE(pathWinntSif)){
        MYASSERT(FALSE);
        return FALSE;
    }
    _tcscpy(pathWinntSif, WinntSifDir);
    _tcscat(AppendWack(pathWinntSif), WINNT_SIF_FILE);

    {
        struct{
            PCTSTR Section;
            PCTSTR PasswordKey;
        } passwordList[] =  {
                                {S_PAGE_IDENTIFICATION, S_DOMAIN_ADMIN_PW},                 // DomainAdminPassword
                                {WINNT_GUIUNATTENDED, TEXT("AdminPassword")},               // AdminPassword
                                {TEXT("Win9xUpg.UserOptions"), TEXT("UserPassword")},       // UserPassword
                                {TEXT("Win9xUpg.UserOptions"), S_DEFAULT_PASSWORD_VALUE}    // DefaultPassword
                            };

        for(i = 0; i < ARRAYSIZE(passwordList); i++){
            if(GetPrivateProfileString(passwordList[i].Section, 
                                       passwordList[i].PasswordKey, 
                                       TEXT(""), 
                                       password, 
                                       ARRAYSIZE(password), 
                                       pathWinntSif) && password[0] != '\0'){
                if(!WritePrivateProfileString(passwordList[i].Section, 
                                              passwordList[i].PasswordKey, 
                                              TEXT(""), 
                                              pathWinntSif)){
                    MYASSERT(FALSE);
                    bResult = FALSE;
                }
            }
        }
    }
    
    return bResult;
}

DWORD
WriteBackupInfo (
    DWORD Request
    )

/*++

Routine Description:

  WriteBackupInfo outputs files to allow rollback to work properly. It also
  moves the text mode rollback environment into %windir%\undo.

Arguments:

  Request - Specifies the request being made by the progress bar manager

Return Value:

  If Request is REQUEST_QUERYTICKS, the return value indicates the number of
  ticks.  Otherwise, the return value is a Win32 result code.

--*/

{
    UINT u;
    TCHAR src[MAX_PATH];
    TCHAR cabPath[MAX_PATH];
    PCSTR ansiTempDir;
    HKEY key;
    HKEY subKey;
    PCTSTR msg;
    HANDLE delDirsHandle;
    HANDLE delFilesHandle;
    PCTSTR path;
    DWORD dontCare;
    TREE_ENUM treeEnum;
    LONG rc;
    CCABHANDLE cabHandle;
    BOOL res;
    TCHAR pathForFile[MAX_PATH];
    DWORD i;
    WIN32_FILE_ATTRIBUTE_DATA dataOfFile;
    static LPCTSTR arrayOfFilesName[] = {TEXT("boot.cab"), TEXT("backup.cab")};
    PSTR ansiString;
    BOOL validUninstall = TRUE;
    ULARGE_INTEGER AmountOfSpaceForDelFiles;
    ULARGE_INTEGER AmountOfSpaceForBackupFiles;
    INFCONTEXT ic;
    ULARGE_INTEGER tempLargeInteger;
    TCHAR keyPath[MEMDB_MAX];
    DWORD value;
    GROWBUFFER appList = GROWBUF_INIT;
    GROWBUFFER appMultiSz = GROWBUF_INIT;
    PINSTALLEDAPPW installedApp;
    UINT count;
    ULONGLONG *ullPtr;
    BYTE * backupImageInfoPtr = NULL;
    UINT sizeOfbackupImageInfo;
    BACKUPIMAGEINFO backupImageInfo;
    FILEINTEGRITYINFO fileIntegrityInfo[BACKUP_FILE_NUMBER];
    WCHAR fileNameOfFileIntegrityInfo[ARRAYSIZE(fileIntegrityInfo)][MAX_PATH];
    BACKUPIMAGEINFO testbackupImageInfo;
    DRIVEINFO drivesInfo[MAX_DRIVE_NUMBER];
    WCHAR * FileSystemName = NULL;
    WCHAR * VolumeNTPath = NULL;
    BOOL unmapUser;

    if (Request == REQUEST_QUERYTICKS) {
        return 50;
    }

    if (Request != REQUEST_RUN) {
        return 0;
    }

    if (!g_ConfigOptions.EnableBackup) {
        DEBUGMSG ((DBG_ERROR, "Backup is not enabled"));
        return ERROR_SUCCESS;
    }
    ELSE_DEBUGMSG ((DBG_FILEMIG, "Backup is enabled"));

    if(!g_ConfigOptions.PathForBackup) {
        DEBUGMSG ((DBG_ERROR, "Path For Backup does not specified"));
        return ERROR_INVALID_PARAMETER;
    }
    ELSE_DEBUGMSG ((DBG_FILEMIG, "Path For Backup is %s", g_ConfigOptions.PathForBackup));

    FileSystemName = MemAlloc(g_hHeap, 0, MAX_DRIVE_NUMBER * MAX_PATH);
    if(!FileSystemName){
        DEBUGMSG ((DBG_ERROR, "WriteBackupInfo: Can't allocate memory for FileSystemName"));
        return ERROR_NOT_ENOUGH_MEMORY;
    }
    VolumeNTPath = MemAlloc(g_hHeap, 0, MAX_DRIVE_NUMBER * MAX_PATH);
    if(!VolumeNTPath){
        MemFree(g_hHeap, 0, FileSystemName);
        DEBUGMSG ((DBG_ERROR, "WriteBackupInfo: Can't allocate memory for VolumeNTPath"));
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    //Init BACKUPIMAGEINFO structure
    //

    for(i = 0; i < ARRAYSIZE(drivesInfo); i++){
        drivesInfo[i].FileSystemName = &FileSystemName[i * MAX_PATH];
        drivesInfo[i].VolumeNTPath = &VolumeNTPath[i * MAX_PATH];
    }
    backupImageInfo.NumberOfDrives = 0;
    backupImageInfo.DrivesInfo = drivesInfo;
    backupImageInfo.NumberOfFiles = BACKUP_FILE_NUMBER;
    backupImageInfo.FilesInfo = fileIntegrityInfo;
    for(i = 0; i < ARRAYSIZE(fileIntegrityInfo); i++){
        fileIntegrityInfo[i].FileName = fileNameOfFileIntegrityInfo[i];
    }

    //
    // Complete the backup image by writing a list of files that are new with
    // the upgraded OS, or moved in the upgrade process.
    //

    AmountOfSpaceForDelFiles.QuadPart = 0;

    ansiTempDir = CreateDbcs (g_TempDir);
    WriteBackupFilesA (FALSE, ansiTempDir, NULL, NULL, 0, 0, &AmountOfSpaceForDelFiles, NULL);
    DestroyDbcs (ansiTempDir);

    DEBUGMSG((DBG_FILEMIG, "AmountOfSpaceForDelFiles is %d MB", (UINT)AmountOfSpaceForDelFiles.QuadPart>>20));

    AmountOfSpaceForBackupFiles.QuadPart = 0;

    value = 0;
    MemDbBuildKey (keyPath, MEMDB_CATEGORY_STATE, MEMDB_ITEM_ROLLBACK_SPACE, NULL, NULL);
    if(MemDbGetValue (keyPath, &value)){
        AmountOfSpaceForBackupFiles.QuadPart = value;
        AmountOfSpaceForBackupFiles.QuadPart <<= 20;
    }
    ELSE_DEBUGMSG((DBG_FILEMIG, "Can't read MEMDB_ITEM_ROLLBACK_SPACE"));

    DEBUGMSG((DBG_FILEMIG, "AmountOfSpaceForBackupFiles is %d MB", (UINT)AmountOfSpaceForBackupFiles.QuadPart>>20));

    if(AmountOfSpaceForBackupFiles.QuadPart > AmountOfSpaceForDelFiles.QuadPart){
        backupImageInfo.BackupFilesDiskSpace.QuadPart =
            AmountOfSpaceForBackupFiles.QuadPart - AmountOfSpaceForDelFiles.QuadPart;
    }
    else{
        backupImageInfo.BackupFilesDiskSpace.QuadPart = 0;
    }


    //
    // Prepare boot.cab. Some errors are ignored, such as the inability to
    // create a backup dir, or set its attributes. If these cases were to
    // occur, subsequent errors are reported.
    //
    // As serious errors are encountered, we log them and turn off the
    // Add/Remove Programs option. We continue so we can capture all of
    // the possible problems.
    //

    wsprintf (src, TEXT("%s$win_nt$.~bt"), g_BootDrivePath);
    if (!CreateDirectory (g_ConfigOptions.PathForBackup, NULL)) {
        if (GetLastError() != ERROR_ALREADY_EXISTS) {
            LOG ((LOG_ERROR, "WriteBackupInfo: Can't create %s directory", g_ConfigOptions.PathForBackup));
        }
    }

    res = SetFileAttributes (g_ConfigOptions.PathForBackup, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_SYSTEM);
    if(!res) {
        DEBUGMSG ((DBG_ERROR, "Can't set attributes to %s directory", g_ConfigOptions.PathForBackup));
    }

    key = OpenRegKeyStr (S_REGKEY_WIN_SETUP);
    if (key != NULL) {
        if(ERROR_SUCCESS == RegSetValueEx (
                                    key,
                                    S_REG_KEY_UNDO_PATH,
                                    0,
                                    REG_SZ,
                                    (PBYTE)g_ConfigOptions.PathForBackup,
                                    SizeOfString (g_ConfigOptions.PathForBackup))){
            res = TRUE;
        }
        else {
            res = FALSE;
        }

        CloseRegKey (key);
    } else {
        res = FALSE;
    }

    if (!res) {
        LOG ((LOG_ERROR, "WriteBackupInfo:Can't set %s value to %s key in registry, uninstall will be disabled", S_REG_KEY_UNDO_PATH, S_REGKEY_WIN_SETUP));
        validUninstall = FALSE;
    }

    if(!pClearPasswordsFromWinntSif(src)){
        DEBUGMSG ((DBG_ERROR, "WriteBackupInfo:pClearPasswordsFromWinntSif failed"));
    }

    if (validUninstall) {
        PCTSTR pathBootCab = JoinPaths (g_ConfigOptions.PathForBackup, TEXT("boot.cab"));
        DeleteFile(pathBootCab);
        FreePathString(pathBootCab);

        cabHandle = CabCreateCabinet (g_ConfigOptions.PathForBackup, TEXT("boot.cab"), TEXT("dontcare"), 0);
    } else {
        cabHandle = NULL;
    }

    backupImageInfo.BootFilesDiskSpace.QuadPart = 0;
    backupImageInfo.UndoFilesDiskSpace.QuadPart = 0;

    if (!cabHandle) {
        LOG ((LOG_ERROR, "WriteBackupInfo:Can't create CAB file for ~bt in %s, uninstall will be disabled", g_ConfigOptions.PathForBackup));
        validUninstall = FALSE;
    } else {

        if (EnumFirstFileInTree (&treeEnum, src, NULL, FALSE)) {
            do {
                if (treeEnum.Directory) {
                    continue;
                }

                tempLargeInteger.LowPart = treeEnum.FindData->nFileSizeLow;
                tempLargeInteger.HighPart = treeEnum.FindData->nFileSizeHigh;
                backupImageInfo.BootFilesDiskSpace.QuadPart += tempLargeInteger.QuadPart;

                if (!CabAddFileToCabinet (cabHandle, treeEnum.FullPath, treeEnum.FullPath)) {
                    LOG ((LOG_ERROR, "WriteBackupInfo:Can't add %s to boot.cab, uninstall will be disabled", src));
                    validUninstall = FALSE;
                }

            } while (EnumNextFileInTree (&treeEnum));
        }

        wsprintf (src, TEXT("%s\\uninstall\\moved.txt"), g_TempDir);
        wsprintf (cabPath, TEXT("%s\\moved.txt"), g_ConfigOptions.PathForBackup);

        if (!CabAddFileToCabinet (cabHandle, src, cabPath)) {
            LOG ((LOG_ERROR, "WriteBackupInfo:Can't add %s to boot.cab, uninstall will be disabled", src));
            validUninstall = FALSE;
        }

        backupImageInfo.UndoFilesDiskSpace.QuadPart += pGetFileSize(src);


        wsprintf (src, TEXT("%s\\uninstall\\delfiles.txt"), g_TempDir);
        wsprintf (cabPath, TEXT("%s\\delfiles.txt"), g_ConfigOptions.PathForBackup);

        if (!CabAddFileToCabinet (cabHandle, src, cabPath)) {
            LOG ((LOG_ERROR, "WriteBackupInfo:Can't add %s to boot.cab, uninstall will be disabled", src));
            validUninstall = FALSE;
        }

        backupImageInfo.UndoFilesDiskSpace.QuadPart += pGetFileSize(src);

        wsprintf (src, TEXT("%s\\uninstall\\deldirs.txt"), g_TempDir);
        wsprintf (cabPath, TEXT("%s\\deldirs.txt"), g_ConfigOptions.PathForBackup);

        if (!CabAddFileToCabinet (cabHandle, src, cabPath)) {
            LOG ((LOG_ERROR, "WriteBackupInfo:Can't add %s to boot.cab, uninstall will be disabled", src));
            validUninstall = FALSE;
        }

        backupImageInfo.UndoFilesDiskSpace.QuadPart += pGetFileSize(src);

        wsprintf (src, TEXT("%s\\uninstall\\mkdirs.txt"), g_TempDir);
        wsprintf (cabPath, TEXT("%s\\mkdirs.txt"), g_ConfigOptions.PathForBackup);

        if (!CabAddFileToCabinet (cabHandle, src, cabPath)) {
            LOG ((LOG_ERROR, "WriteBackupInfo:Can't add %s to boot.cab, uninstall will be disabled", src));
            validUninstall = FALSE;
        }

        backupImageInfo.UndoFilesDiskSpace.QuadPart += pGetFileSize(src);

        //wsprintf (src, TEXT("%s\\uninstall\\boot.ini"), g_TempDir);
        //wsprintf (cabPath, TEXT("%sboot.ini"), g_BootDrivePath);
        //if (!CabAddFileToCabinet (cabHandle, src, cabPath)) {
        //    DEBUGMSG ((DBG_ERROR, "Can't add %s to boot.cab", src));
        //    validUninstall = FALSE;
        //}
        //backupImageInfo.BootFilesDiskSpace.QuadPart += pGetFileSize(src);

        wsprintf (src, TEXT("%s\\uninstall\\$ldr$"), g_TempDir);
        wsprintf (cabPath, TEXT("%s$ldr$"), g_BootDrivePath);

        if (!CabAddFileToCabinet (cabHandle, src, cabPath)) {
            LOG ((LOG_ERROR, "WriteBackupInfo:Can't add %s to boot.cab, uninstall will be disabled", src));
            validUninstall = FALSE;
        }

        backupImageInfo.BootFilesDiskSpace.QuadPart += pGetFileSize(src);

        wsprintf (src, TEXT("%s\\system32\\autochk.exe"), g_WinDir);
        wsprintf (cabPath, TEXT("%s$win_nt$.~bt\\i386\\autochk.exe"), g_BootDrivePath);

        if (!CabAddFileToCabinet (cabHandle, src, cabPath)) {
            //
            // This is only a warning, because text mode will prompt for the
            // CD when autochk.exe can't be found.
            //
            LOG ((LOG_WARNING, "WriteBackupInfo:Can't add %s to boot.cab, uninstall will be disabled", src));
        }
        backupImageInfo.BootFilesDiskSpace.QuadPart += pGetFileSize(src);

        backupImageInfo.BootFilesDiskSpace.QuadPart += BOOT_FILES_ADDITIONAL_PADDING;
        backupImageInfo.UndoFilesDiskSpace.QuadPart +=
            backupImageInfo.BootFilesDiskSpace.QuadPart + UNDO_FILES_ADDITIONAL_PADDING;

        if (!CabFlushAndCloseCabinet (cabHandle)) {
            LOG ((LOG_ERROR, "WriteBackupInfo:Can't write CAB file for ~bt, uninstall will be disabled"));
            validUninstall = FALSE;
        }
    }

    //
    // Create and write undo integrity info to registry
    //

    if (validUninstall) {
        backupImageInfo.FilesInfo[0].IsCab = TRUE;
        GetIntegrityInfo(TEXT("boot.cab"), g_ConfigOptions.PathForBackup, &backupImageInfo.FilesInfo[0]);
        backupImageInfo.FilesInfo[1].IsCab = TRUE;
        GetIntegrityInfo(TEXT("backup.cab"), g_ConfigOptions.PathForBackup, &backupImageInfo.FilesInfo[1]);

        if(GetUndoDrivesInfo(drivesInfo,
                             &backupImageInfo.NumberOfDrives,
                             g_BootDrivePath[0],
                             g_WinDir[0],
                             g_ConfigOptions.PathForBackup[0])){
            if(GetDisksInfo(&backupImageInfo.DisksInfo, &backupImageInfo.NumberOfDisks)){
                if(Persist_Success == PERSIST_STORE(&backupImageInfoPtr,
                                                    &sizeOfbackupImageInfo,
                                                    BACKUPIMAGEINFO,
                                                    BACKUPIMAGEINFO_VERSION,
                                                    &backupImageInfo)){
                    key = OpenRegKeyStr (S_REGKEY_WIN_SETUP);
                    if (key) {
                        RegSetValueEx (
                            key,
                            S_REG_KEY_UNDO_INTEGRITY,
                            0,
                            REG_BINARY,
                            (PBYTE)backupImageInfoPtr,
                            sizeOfbackupImageInfo
                            );
                        DEBUGMSG((
                           DBG_VERBOSE,
                           "Boot files size is %d KB, Undo file size is %d KB, Backup files size is %d KB",
                           (DWORD)backupImageInfo.BootFilesDiskSpace.QuadPart>>10,
                           (DWORD)backupImageInfo.UndoFilesDiskSpace.QuadPart>>10,
                           (DWORD)backupImageInfo.BackupFilesDiskSpace.QuadPart>>10));
                        CloseRegKey (key);
                    }
                    else {
                        LOG((LOG_ERROR, "WriteBackupInfo:Could not write to registry, uninstall will be disabled"));
                        validUninstall = FALSE;
                    }
                    PERSIST_RELEASE_BUFFER(backupImageInfoPtr);
                }
                else{
                    LOG((LOG_ERROR, "WriteBackupInfo:Could not marshall BACKUPIMAGEINFO structure, GetLastError() == %d, uninstall will be disabled", GetLastError()));
                    validUninstall = FALSE;
                }
            } else {
                LOG((LOG_ERROR, "WriteBackupInfo:GetDisksInfo failed, uninstall will be disabled"));
                validUninstall = FALSE;
            }
        }
        else{
            LOG ((LOG_ERROR, "WriteBackupInfo:GetUndoDrivesInfo failed, uninstall will be disabled"));
            validUninstall = FALSE;
        }
        if(backupImageInfo.DisksInfo){
            FreeDisksInfo(backupImageInfo.DisksInfo, backupImageInfo.NumberOfDisks);
        }
    }

    //
    // Establish Add/Remove Programs entry
    //

    if (validUninstall) {
        key = CreateRegKeyStr (TEXT("HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Uninstall"));
        if (key) {

            subKey = CreateRegKey (key, TEXT("Windows"));
            CloseRegKey (key);

            if (subKey) {

                msg = GetStringResource (MSG_UNINSTALL_DISPLAY_STRING);
                RegSetValueEx (subKey, TEXT("DisplayName"), 0, REG_SZ, (PBYTE) msg, SizeOfString (msg));
                FreeStringResource (msg);

                msg = TEXT("%SYSTEMROOT%\\system32\\osuninst.exe");
                rc = RegSetValueEx (subKey, TEXT("UninstallString"), 0, REG_EXPAND_SZ, (PBYTE) msg, SizeOfString (msg));
                SetLastError (rc);

                rc = RegSetValueEx (subKey, TEXT("DisplayIcon"), 0, REG_EXPAND_SZ, (PBYTE) msg, SizeOfString (msg));
                SetLastError (rc);

                rc = RegSetValueEx (
                                subKey,
                                TEXT("InstallLocation"),
                                0,
                                REG_EXPAND_SZ,
                                (PBYTE) g_ConfigOptions.PathForBackup,
                                SizeOfString (g_ConfigOptions.PathForBackup));

                SetLastError (rc);

                DEBUGMSG_IF ((rc != ERROR_SUCCESS, DBG_ERROR, "Can't create Add/Remove Programs value"));

                CloseRegKey (subKey);
            } else {
                LOG ((LOG_ERROR, "Can't create Add/Remove Programs subkey"));
                validUninstall = FALSE;
            }
        } else {
            validUninstall = FALSE;
            LOG ((LOG_ERROR, "Can't create Add/Remove Programs subkey"));
        }

    }

    if(VolumeNTPath){
        MemFree(g_hHeap, 0, VolumeNTPath);
    }
    if(FileSystemName){
        MemFree(g_hHeap, 0, FileSystemName);
    }

    //
    // Save progress text to the registry
    //

    if (validUninstall) {
        key = CreateRegKeyStr (S_WIN9XUPG_KEY);
        if (key) {
            msg = GetStringResource (MSG_OLEREG);
            RegSetValueEx (key, S_UNINSTALL_DISP_STR, 0, REG_SZ, (PBYTE) msg, SizeOfString (msg));
            FreeStringResource (msg);

            CloseRegKey (key);
        }
    }

    //
    // Write list of installed apps to the registry
    //

    if (validUninstall) {
        CoInitialize (NULL);

        //
        // Map in the default user's hive. Use this for HKCU.
        //

        unmapUser = pMapHiveOfUserDoingTheUpgrade();

        //
        // Get the installed apps.
        //

        installedApp = GetInstalledAppsW (&appList, &count);

        //
        // Unmap the hive.
        //

        if (unmapUser) {
            pUnmapHiveOfUserDoingTheUpgrade();
        }

        //
        // Record the apps in the registry.
        //

        if (installedApp) {
            for (u = 0 ; u < count ; u++) {

                DEBUGMSG ((
                    DBG_FILEMIG,
                    "App previously installed: %ws (%I64X)",
                    installedApp->DisplayName,
                    installedApp->Checksum
                    ));

                GrowBufCopyStringW (&appMultiSz, installedApp->DisplayName);
                ullPtr = (ULONGLONG *) GrowBuffer (&appMultiSz, sizeof (ULONGLONG));
                *ullPtr = installedApp->Checksum;

                installedApp++;
            }

            GrowBufCopyStringW (&appMultiSz, L"");

            key = OpenRegKeyStr (S_REGKEY_WIN_SETUP);
            if (key) {
                rc = RegSetValueEx (
                        key,
                        S_REG_KEY_UNDO_APP_LIST,
                        0,
                        REG_BINARY,
                        appMultiSz.Buf,
                        appMultiSz.End
                        );

                if (rc != ERROR_SUCCESS) {
                    SetLastError (rc);
                    DEBUGMSG ((DBG_ERROR, "Can't write list of installed apps to registry value"));
                }

                CloseRegKey (key);
            }
            ELSE_DEBUGMSG ((DBG_ERROR, "Can't write list of installed apps to registry"));
        }
        ELSE_DEBUGMSG ((DBG_ERROR, "Can't get list of installed apps."));
    }

    FreeGrowBuffer (&appList);
    FreeGrowBuffer (&appMultiSz);

    DEBUGMSG_IF ((!validUninstall, DBG_ERROR, "Uninstall is not available because of a previous error"));
    return ERROR_SUCCESS;
}

DWORD
DisableFiles (
    DWORD Request
    )

/*++

Routine Description:

  DisableFiles runs code to ensure a Win9x file is removed from processing,
  usually because it is suspected of causing problems.

  This function renames all files marked for OPERATION_FILE_DISABLED adding a
  .disabled at the end.

Arguments:

  Request - Specifies the progress bar request, which is either
            REQUEST_QUERYTICKS or REQUEST_RUN.

Return Value:

  The number of ticks (REQUEST_QUERYTICKS) or the status code (REQUEST_RUN).

--*/

{
    FILEOP_ENUM e;
    DWORD attr;
    PCTSTR disableName;
    PCTSTR newLocation;
    GROWLIST disableList = GROWLIST_INIT;
    PCTSTR srcPath;
    UINT count;
    UINT u;

    if (Request == REQUEST_QUERYTICKS) {
        return 50;
    }

    if (Request != REQUEST_RUN) {
        return 0;
    }

    //
    // Enumerate each file in OPERATION_FILE_DISABLED and put it in a grow
    // list, because we will then modify the operations so that uninstall
    // works properly.
    //

    if (EnumFirstPathInOperation (&e, OPERATION_FILE_DISABLED)) {

        do {
            GrowListAppendString (&disableList, e.Path);
        } while (EnumNextPathInOperation (&e));
    }

    //
    // Now process each file
    //

    count = GrowListGetSize (&disableList);

    for (u = 0 ; u < count ; u++) {

        srcPath = GrowListGetString (&disableList, u);

        newLocation = GetPathStringOnNt (srcPath);
        attr = GetLongPathAttributes (newLocation);

        if (attr != INVALID_ATTRIBUTES) {
            SetLongPathAttributes (newLocation, FILE_ATTRIBUTE_NORMAL);
            disableName = JoinText (newLocation, TEXT(".disabled"));

            RemoveOperationsFromPath (srcPath, ALL_MOVE_OPERATIONS|ALL_DELETE_OPERATIONS);
            MarkFileForMoveByNt (srcPath, disableName);

            if (!OurMoveFile (newLocation, disableName)) {
                if (GetLastError() == ERROR_ALREADY_EXISTS) {
                    //
                    // Restart case -- we already moved this file
                    //

                    SetLongPathAttributes (newLocation, FILE_ATTRIBUTE_NORMAL);
                    DeleteLongPath (newLocation);
                }
                ELSE_DEBUGMSG ((DBG_ERROR, "Cannot rename %s to %s", newLocation, disableName));
            }
            FreeText (disableName);
            SetLongPathAttributes (newLocation, attr);
        }

        FreePathString (newLocation);
    }

    FreeGrowList (&disableList);

    return ERROR_SUCCESS;
}

VOID
pUninstallStartMenuCleanupPreparation (
    VOID
    )
{
    INFSTRUCT is = INITINFSTRUCT_POOLHANDLE;
    INFSTRUCT isLinks = INITINFSTRUCT_POOLHANDLE;
    PCTSTR temp;
    BOOL isCommonGroup;
    TCHAR itemFullPath[MAX_PATH];
    PCTSTR itemGroupPtr;
    TCHAR itemGroupPath[MAX_PATH];
    HINF InfSysSetupHandle;
    PINFSECTION sectionWkstaMigInf = NULL;
    PINFSECTION sectionUserMigInf = NULL;


    InfSysSetupHandle = InfOpenInfFile (TEXT("syssetup.inf"));

    if(!InfSysSetupHandle){
        LOG((LOG_ERROR,"Can't open syssetup.inf for UninstallStartMenuCleanupPreparation."));
        MYASSERT(FALSE);
        return;
    }

    //
    //[StartMenu.StartMenuItems]
    //

    if (InfFindFirstLine (InfSysSetupHandle, TEXT("StartMenu.StartMenuItems"), NULL, &is)) {
        do {
            StringCopy(itemFullPath, TEXT("7520"));

            temp = InfGetStringField (&isLinks, 0);
            if (!temp || *temp == 0) {
                continue;
            }

            StringCat(AppendWack(itemFullPath), temp);
            StringCat(itemFullPath, TEXT(".lnk"));

            GrowListAppendString (&g_StartMenuItemsForCleanUpCommon, itemFullPath);
            GrowListAppendString (&g_StartMenuItemsForCleanUpPrivate, itemFullPath);

            DEBUGMSG ((DBG_VERBOSE,"UninstallStartMenuCleanupPreparation: %s", itemFullPath));
        } while (InfFindNextLine (&is));
    }


    //
    //[StartMenuGroups]
    //

    if (InfFindFirstLine (InfSysSetupHandle, TEXT("StartMenuGroups"), NULL, &is)) {
        do {
            itemGroupPtr = InfGetStringField (&is, 1);
            if (!itemGroupPtr || *itemGroupPtr == 0) {
                continue;
            }

            temp = InfGetStringField (&is, 2);
            if (!temp || *temp == 0) {
                continue;
            }

            if('0' == temp[0]){
                isCommonGroup = TRUE;
            }
            else{
                isCommonGroup = FALSE;
            }

            temp = InfGetStringField (&is, 0);
            if (!temp || *temp == 0) {
                continue;
            }

            StringCopy(itemGroupPath, TEXT("7517"));
            StringCat(AppendWack(itemGroupPath), itemGroupPtr);

            if (InfFindFirstLine (InfSysSetupHandle, temp, NULL, &isLinks)) {
                do {
                    StringCopy(itemFullPath, itemGroupPath);

                    temp = InfGetStringField (&isLinks, 0);
                    if (!temp || *temp == 0) {
                        continue;
                    }
                    StringCat(AppendWack(itemFullPath), temp);
                    StringCat(itemFullPath, TEXT(".lnk"));

                    GrowListAppendString (&g_StartMenuItemsForCleanUpCommon, itemFullPath);

                    if(!isCommonGroup){
                        GrowListAppendString (&g_StartMenuItemsForCleanUpPrivate, itemFullPath);
                    }

                    DEBUGMSG ((DBG_VERBOSE,"UninstallStartMenuCleanupPreparation: %s", itemFullPath));
                } while (InfFindNextLine (&isLinks));
            }

        } while (InfFindNextLine (&is));
    }

    InfCleanUpInfStruct (&is);
    InfCleanUpInfStruct (&isLinks);
    InfCloseInfFile (InfSysSetupHandle);
}

DWORD
UninstallStartMenuCleanupPreparation(
    DWORD Request
    )
/*++

Routine Description:

  UninstallStartMenuCleanupPreparation mark files from Start Menu
  sections from syssetup.inf to clean up.

Arguments:

  Request - Specifies the request being made by the progress bar manager

Return Value:

  If Request is REQUEST_QUERYTICKS, the return value indicates the number of
  ticks.  Otherwise, the return value is a Win32 result code.

--*/
{
    if (Request == REQUEST_QUERYTICKS) {
        return 3;
    }

    if (Request != REQUEST_RUN) {
        return 0;
    }

    pUninstallStartMenuCleanupPreparation();

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\migmain\domain.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    domain.c

Abstract:

    This code implements a set of linked list data structures used to
    resolve domain name lookups.  It achieves a similar structure to
    memdb but provides the ability to move an item from list to list
    efficiently.

Author:

    Jim Schmidt (jimschm) 18-Jun-1997

Revision History:

    jimschm     23-Sep-1998 Fixed trusted domains
    jimschm     17-Feb-1998 Updated share security for NT 5 changes

--*/

#include "pch.h"
#include "migmainp.h"

#include "security.h"

#define DBG_ACCTLIST "Accounts"

PACCT_DOMAINS g_FirstDomain;
POOLHANDLE g_DomainPool;
INT g_RetryCount;

BOOL
pAddAllLogonDomains (
    IN      PCTSTR DCName           OPTIONAL
    );



VOID
InitAccountList (
    VOID
    )

/*++

Routine Description:

    Initializer for the account list that is used during account
    lookup.  This memory is freed after all accounts are found.

Arguments:

    none

Return value:

    none

--*/


{
    g_FirstDomain = NULL;
    g_DomainPool = PoolMemInitNamedPool ("Domain List");
    PoolMemDisableTracking (g_DomainPool);
}

VOID
TerminateAccountList (
    VOID
    )

/*++

Routine Description:

    Termination routine for the account lookup code.

Arguments:

    none

Return value:

    none

--*/


{
    g_FirstDomain = NULL;
    PoolMemDestroyPool (g_DomainPool);
}


PCWSTR
pReturnDomainFromEnum (
    IN      PACCT_ENUM EnumPtr
    )

/*++

Routine Description:

    Common code for ListFirstDomain and ListNextDomain.
    Implements return parameter check.

Arguments:

    EnumPtr - The current enumeration pointer supplied by
              ListFirstDomain and ListNextDomain.

Return value:

    A pointer to the domain name allocated in our private
    pool, or NULL if no more domains remain.

--*/


{
    if (!EnumPtr->DomainPtr) {
        return NULL;
    }

    return EnumPtr->DomainPtr->Domain;
}


/*++

Routine Description:

    ListFirstDomain and ListNextDomain are enumerators that list
    trusted domains added by BuildDomainList.  They return a
    pointer to the domain name (managed by a private pool).
    The enumeration structure can be passed to all other functions
    that take a DomainEnumPtr as a parameter.

Arguments:

    DomainEnumPtr - A pointer to a caller-allocated ACCT_ENUM
                    structure, typically allocated on the stack.
                    It does not need to be initialized.

Return value:

    A pointer to the domain name, or NULL if no more domains
    exist in the list.

--*/

PCWSTR
ListFirstDomain (
    OUT     PACCT_ENUM DomainEnumPtr
    )

{
    DomainEnumPtr->DomainPtr = g_FirstDomain;
    return pReturnDomainFromEnum (DomainEnumPtr);
}

PCWSTR
ListNextDomain (
    IN OUT  PACCT_ENUM DomainEnumPtr
    )
{
    DomainEnumPtr->DomainPtr = DomainEnumPtr->DomainPtr->Next;
    return pReturnDomainFromEnum (DomainEnumPtr);
}


BOOL
FindDomainInList (
    OUT     PACCT_ENUM DomainEnumPtr,
    IN      PCWSTR DomainToFind
    )

/*++

Routine Description:

    FindDomainInList searches (sequentially) through all trusted
    domains for the specified domain.  If found, enumeration
    stops and TRUE is returned.  If not found, the enumeration
    pointer is invalid and FALSE is returned.

    Use this function to obtain an enumeration pointer that is
    used in subsequent calls to the user list.

    The search is case-insensitive.

Arguments:

    DomainEnumPtr - An uninitialized, caller-allocated ACCT_ENUM
                    structure, typically allocated on the stack.
                    When a search match is found, this structure
                    can be used with any other function that
                    requires a DomainEnumPtr.

    DomainToFind  - The name of the domain to find.

Return value:

    TRUE if a match was found (and DomainEnumPtr is valid), or
    FALSE if a match was not found (and DomainEnumPtr is not
    valid).

--*/

{
    PCWSTR DomainName;

    DomainName = ListFirstDomain (DomainEnumPtr);
    while (DomainName) {
        if (StringIMatchW (DomainName, DomainToFind)) {
            return TRUE;
        }

        DomainName = ListNextDomain (DomainEnumPtr);
    }

    return FALSE;
}


PCWSTR
pReturnUserFromEnum (
    IN      PACCT_ENUM UserEnumPtr
    )

/*++

Routine Description:

    Implements common code for ListFirstUserInDomain and
    ListNextUserInDomain.  Performs return parameter validation.

Arguments:

    UserEnumPtr - The current enum pointer supplied by
                  ListFirstUserInDomain or ListNextUserInDomain.

Return value:

    The name of the user being enumerated (not domain-qualified),
    or NULL if no more users exist in the domain.

--*/


{
    if (UserEnumPtr->UserPtr) {
        return UserEnumPtr->UserPtr->User;
    }

    return NULL;
}


/*++

Routine Description:

    ListFirstUserInDomain and ListNextUserInDomain enumerate all
    users in the specified domain.

Arguments:

    DomainEnumPtr - The caller-allocated ACCT_ENUM structure that
                    has been initialized by a domain lookup function
                    above.

    UserEnumPtr   - Used to keep track of the current user.  May be
                    the same pointer as DomainEnumPtr.

Return value:

    The name of the user being enumerated (not domain-qualified),
    or NULL if no more users exist in the domain.

--*/


PCWSTR
ListFirstUserInDomain (
    IN      PACCT_ENUM DomainEnumPtr,
    OUT     PACCT_ENUM UserEnumPtr
    )

{
    UserEnumPtr->UserPtr = DomainEnumPtr->DomainPtr->FirstUserPtr;
    return pReturnUserFromEnum (UserEnumPtr);
}

PCWSTR
ListNextUserInDomain (
    IN OUT  PACCT_ENUM UserEnumPtr
    )
{
    if (UserEnumPtr->UserPtr) {
        UserEnumPtr->UserPtr = UserEnumPtr->UserPtr->Next;
    } else {
        UserEnumPtr->UserPtr = UserEnumPtr->DomainPtr->FirstUserPtr;
    }

    return pReturnUserFromEnum (UserEnumPtr);
}


BOOL
IsTrustedDomain (
    IN      PACCT_ENUM DomainEnumPtr
    )

/*++

Routine Description:

    Returns TRUE if the domain is an officially trusted domain,
    or FALSE if the domain is an artificially added domain.  The
    account lookup code adds artificial domains to track the
    state of users.  For example, the domain \unknown is used
    to track users who need auto-lookup.  The domain \failed is
    used to track users who aren't in the domain they were
    expected to be in.  All artifical domains start with a
    backslash.

Arguments:

    DomainEnumPtr - Specifies the domain to examine.  This structure
                    must be the return of a domain enumeration
                    function above.

Return value:

    TRUE  - The domain is a trusted domain
    FALSE - The domain is not really a domain but is instead an
            artifically added domain

--*/



{
    PCWSTR Domain;

    Domain = DomainEnumPtr->DomainPtr->Domain;

    //
    // Test domain name to see if it is one of the reserved names
    //

    if (*Domain == TEXT('\\')) {
        return FALSE;
    }

    return TRUE;
}


BOOL
FindUserInDomain (
    IN      PACCT_ENUM DomainEnumPtr,
    OUT     PACCT_ENUM UserEnumPtr,
    IN      PCWSTR UserToFind
    )

/*++

Routine Description:

    Uses ListFirstUserInDomain and ListNextUserInDomain to
    sequentially search for a user.  The search is case-insensitive.

Arguments:

    DomainEnumPtr - Specifies the domain to search.  This structure
                    must be the return of a domain enumeration function
                    above.

    UserEnumPtr   - Receives the results of the search if a user match
                    is found.  Can be the same as DomainEnumPtr.

    UserToFind    - Specifies the name of the user to find (not
                    domain-qualified).

Return value:

    TRUE  - A match was found and UserEnumPtr is valid
    FALSE - A match was not found and UserEnumPtr is not valid

--*/

{
    PCWSTR UserName;

    UserName = ListFirstUserInDomain (DomainEnumPtr, UserEnumPtr);
    while (UserName) {
        if (StringIMatchW (UserName, UserToFind)) {
            return TRUE;
        }

        UserName = ListNextUserInDomain (UserEnumPtr);
    }

    return FALSE;
}


INT
CountUsersInDomain (
    IN      PACCT_ENUM DomainEnumPtr
    )

/*++

Routine Description:

    Returns the number of users in our domain enumeration structure.

Arguments:

    DomainEnumPtr - Specifies the domain to search.  This structure
                    must be the return of a domain enumeration function
                    above.

Return value:

    The count of the users in the domain.

--*/


{
    return DomainEnumPtr->DomainPtr->UserCount;
}


VOID
AddDomainToList (
    IN      PCWSTR Domain
    )

/*++

Routine Description:

    Allows domains to be added to the list of trusted domains.  Normally,
    BuildDomainList is the only caller to this API, because it is the
    one who knows what the trusted domains are.  However, artificial
    domains are added in other places through this call.

Arguments:

    Domain - Specifies the name of the domain to add

Return value:

    none

--*/

{
    PACCT_DOMAINS NewDomain;

    DEBUGMSG ((DBG_ACCTLIST, "Adding domain '%s' to domain list", Domain));

    NewDomain = (PACCT_DOMAINS) PoolMemGetAlignedMemory (
                                    g_DomainPool,
                                    sizeof (ACCT_DOMAINS)
                                    );

    ZeroMemory (NewDomain, sizeof (ACCT_DOMAINS));
    NewDomain->Next = g_FirstDomain;
    g_FirstDomain = NewDomain;
    NewDomain->Domain = PoolMemDuplicateString (g_DomainPool, Domain);
}


VOID
pLinkUser (
    IN      PACCT_USERS UserPtr,
    IN      PACCT_DOMAINS DomainPtr
    )

/*++

Routine Description:

    The memory structures in this file are linked-list based.  There
    is a linked-list of domains, and for each domain there is a linked-
    list of users.  Each user has a linked list of possible domains.
    The linked lists are designed to be changed while enumerations are
    in progress.

    This function performs the simple link operation for the user list.

Arguments:

    UserPtr     - A pointer to the internally maintained ACCT_USERS structure.

    DomainPtr   - Specifies the domain in which UserPtr is linked to.

Return value:

    none

--*/

{
    UserPtr->Next = DomainPtr->FirstUserPtr;
    if (UserPtr->Next) {
        UserPtr->Next->Prev = UserPtr;
    }
    DomainPtr->FirstUserPtr = UserPtr;
    UserPtr->DomainPtr = DomainPtr;
    DomainPtr->UserCount++;
}


BOOL
AddUserToDomainList (
    IN      PCWSTR User,
    IN      PCWSTR Domain
    )

/*++

Routine Description:

    This function searches for the domain name specified
    and adds the user to the user list for that domain.  If
    the domain cannot be found, the function fails.

Arguments:

    User    - Specifies the name of the user to add

    Domain  - Specifies the name of the domain that the user
              is added to

Return value:

    TRUE if the user was added successfully, or FALSE if the
    domain is not a trusted domain.

--*/

{
    ACCT_ENUM e;
    PACCT_DOMAINS DomainPtr;
    PACCT_USERS NewUser;

    //
    // Find Domain (it must exist in the list)
    //

    if (!FindDomainInList (&e, Domain)) {
        return FALSE;
    }

    DomainPtr = e.DomainPtr;

    //
    // Allocate structure for the user
    //

    NewUser = (PACCT_USERS) PoolMemGetAlignedMemory (
                                g_DomainPool,
                                sizeof (ACCT_USERS)
                                );

    ZeroMemory (NewUser, sizeof (ACCT_USERS));
    pLinkUser (NewUser, DomainPtr);
    NewUser->User = PoolMemDuplicateString (g_DomainPool, User);

    return TRUE;
}


VOID
pDelinkUser (
    IN      PACCT_USERS UserPtr
    )

/*++

Routine Description:

    The memory structures in this file are linked-list based.  There
    is a linked-list of domains, and for each domain there is a linked-
    list of users.  Each user has a linked list of possible domains.
    The linked lists are designed to be changed while enumerations are
    in progress.

    This function performs the simple delink operation for the user list.

Arguments:

    UserPtr     - A pointer to the internally maintained ACCT_USERS structure.

Return value:

    none

--*/

{
    if (UserPtr->Prev) {
        UserPtr->Prev->Next = UserPtr->Next;
    } else {
        UserPtr->DomainPtr->FirstUserPtr = UserPtr->Next;
    }

    if (UserPtr->Next) {
        UserPtr->Next->Prev = UserPtr->Prev;
    }
    UserPtr->DomainPtr->UserCount--;
}


VOID
DeleteUserFromDomainList (
    IN      PACCT_ENUM UserEnumPtr
    )

/*++

Routine Description:

    Performs a delete operation for a user in a domain's user list.
    The memory for this user is not freed right away, because doing
    so may cause enumeration positions to become invalid.  Instead,
    the links are adjusted to skip over this user.

    Memory is freed at termination.

Arguments:

    UserEnumPtr - A pointer to the user to delete, obtained by calling
                  a user enumeration or user search function that
                  returns UserEnumPtr as an OUT.

Return value:

    none

--*/

{
    //
    // Don't actually delete, just delink.  This allows all in-progress
    // enumerations to continue working.
    //

    pDelinkUser (UserEnumPtr->UserPtr);
}


BOOL
MoveUserToNewDomain (
    IN OUT  PACCT_ENUM UserEnumPtr,
    IN      PCWSTR NewDomain
    )

/*++

Routine Description:

    Moves a user from one domain to another by adjusting links only.
    The current enumeration pointer is adjusted to point to the previous
    user so enumeration can continue.  This function may change the
    behavoir other enumerations that are pointing to this user, so
    be careful.  It will never break an enumeration though.

Arguments:

    UserEnumPtr - A pointer to the user to move, obtained by calling a
                  user enumeration or user search function that returns
                  UserEnumPtr as an OUT.

    NewDomain   - The name of the new domain to move the user to.

Return value:

    TRUE if NewDomain is a trusted domain, or FALSE if it is not.
    The user can only be moved to domains in the trust list.

--*/

{
    ACCT_ENUM e;
    PACCT_DOMAINS DomainPtr;
    PACCT_DOMAINS OrgDomainPtr;
    PACCT_USERS PrevUser;

    //
    // Find NewDomain (it must exist in the list)
    //

    if (!FindDomainInList (&e, NewDomain)) {
        return FALSE;
    }

    DomainPtr = e.DomainPtr;
    OrgDomainPtr = UserEnumPtr->UserPtr->DomainPtr;

    //
    // Remove user from original domain
    //

    PrevUser = UserEnumPtr->UserPtr->Prev;
    pDelinkUser (UserEnumPtr->UserPtr);

    //
    // Add user to new domain
    //

    pLinkUser (UserEnumPtr->UserPtr, DomainPtr);

    if (!PrevUser) {
        UserEnumPtr->DomainPtr =  OrgDomainPtr;
    }

    UserEnumPtr->UserPtr = PrevUser;

    return TRUE;
}


VOID
UserMayBeInDomain (
    IN      PACCT_ENUM UserEnumPtr,
    IN      PACCT_ENUM DomainEnumPtr
    )

/*++

Routine Description:

    Provides the caller with a way to flag a domain as a possible
    domain holding the account.  During search, all trusted
    domains are queried, and because an account can be in more
    than one, a list of possible domains is developed.  If the
    final list of possible domains has only one entry, that
    domain is used for the user.  Otherwise, a dialog is presented,
    allowing the installer to choose an action to take for the user.
    The action can be to retry, make a local account, or select
    one of the possible domains.

Arguments:

    UserEnumPtr - Specifies the user that may be in a domain

    DomainEnumPtr - Specifies the domain that the user may be in

Return value:

    none

--*/


{
    PACCT_POSSIBLE_DOMAINS PossibleDomainPtr;

    PossibleDomainPtr = (PACCT_POSSIBLE_DOMAINS)
                            PoolMemGetAlignedMemory (
                                g_DomainPool,
                                sizeof (ACCT_POSSIBLE_DOMAINS)
                                );

    PossibleDomainPtr->DomainPtr = DomainEnumPtr->DomainPtr;
    PossibleDomainPtr->Next      = UserEnumPtr->UserPtr->FirstPossibleDomain;
    UserEnumPtr->UserPtr->FirstPossibleDomain = PossibleDomainPtr;
    UserEnumPtr->UserPtr->PossibleDomains++;
}


VOID
ClearPossibleDomains (
    IN      PACCT_ENUM UserEnumPtr
    )

/*++

Routine Description:

    Provides the caller with a way to reset the possible domain
    list.  This is required if the installer chose to retry the search.

Arguments:

    UserEnumPtr - Specifies the user to reset

Return value:

    none

--*/

{
    PACCT_POSSIBLE_DOMAINS This, Next;

    This = UserEnumPtr->UserPtr->FirstPossibleDomain;
    while (This) {
        Next = This->Next;
        PoolMemReleaseMemory (g_DomainPool, This);
        This = Next;
    }

    UserEnumPtr->UserPtr->FirstPossibleDomain = 0;
    UserEnumPtr->UserPtr->PossibleDomains = 0;
}


PCWSTR
pReturnPossibleDomainFromEnum (
    IN      PACCT_ENUM EnumPtr
    )

/*++

Routine Description:

    Common code for ListFirstPossibleDomain and ListNextPossibleDomain.
    Implements return parameter checking.

Arguments:

    EnumPtr - The current enumeration pointer as supplied by
              ListFirstPossibleDomain or ListNextPossibleDomain.

Return value:

    The name of the domain enumerated, or NULL if no more possible
    domains exist.  (A possible domain is one that a user may or
    may not be in, but a matching account was found in the domain.)

--*/

{
    if (EnumPtr->PossibleDomainPtr) {
        EnumPtr->DomainPtr = EnumPtr->PossibleDomainPtr->DomainPtr;
        return EnumPtr->DomainPtr->Domain;
    }

    return NULL;
}


/*++

Routine Description:

    ListFirstPossibleDomain and ListNextPossibleDomain are enumerators
    that list domains added by UserMayBeInDomain.  They return a
    pointer to the domain name (managed by a private pool).

    A possible domain list is maintained to allow the installer to
    choose between multiple domains when a user has an account on
    more than one domain.

Arguments:

    UserEnumPtr - A pointer to a caller-allocated ACCT_ENUM
                  structure, typically allocated on the stack.
                  It must be initialized by a user enum or user
                  search function.

    PossibleDomainEnumPtr - Maintains the state of the possible
                            domain enumeration.  It can be the
                            same pointer as UserEnumPtr.

Return value:

    A pointer to the possible domain name, or NULL if no more domains
    exist in the list.

--*/

PCWSTR
ListFirstPossibleDomain (
    IN      PACCT_ENUM UserEnumPtr,
    OUT     PACCT_ENUM PossibleDomainEnumPtr
    )
{
    PossibleDomainEnumPtr->PossibleDomainPtr = UserEnumPtr->UserPtr->FirstPossibleDomain;
    return pReturnPossibleDomainFromEnum (PossibleDomainEnumPtr);
}


PCWSTR
ListNextPossibleDomain (
    IN OUT  PACCT_ENUM PossibleDomainEnumPtr
    )
{
    PossibleDomainEnumPtr->PossibleDomainPtr = PossibleDomainEnumPtr->
                                                    PossibleDomainPtr->Next;

    return pReturnPossibleDomainFromEnum (PossibleDomainEnumPtr);
}


INT
CountPossibleDomains (
    IN      PACCT_ENUM UserEnumPtr
    )

/*++

Routine Description:

    Returns the number of possible domains in a user.

Arguments:

    UserEnumPtr - Specifies the user to examine.  This structure
                  must be the return of a user enumeration or user
                  search function above.

Return value:

    The count of the possible domains for a user.

--*/

{
    return UserEnumPtr->UserPtr->PossibleDomains;
}



NET_API_STATUS
pGetDcNameAllowingRetry (
    IN      PCWSTR DomainName,
    OUT     PWSTR ServerName,
    IN      BOOL ForceNewServer
    )

/*++

Routine Description:

    Implements NetGetDCName, but provides a retry capability.

Arguments:

    DomainName - Specifies the domain to obtain the server name for

    ServerName - Specifies a buffer to receive the name of the server

    ForceNewServer - Specifies TRUE if the function should obtain a new
                     server for the domain.  Specifies FALSE if the
                     function should use any existing connection if
                     available.

Return value:

    Win32 error code indicating outcome

--*/

{
    NET_API_STATUS nas;
    UINT ShortCircuitRetries = 1;
    //PCWSTR ArgArray[1];

    do {
        nas = GetAnyDC (
                DomainName,
                ServerName,
                ForceNewServer
                );

        if (nas != NO_ERROR) {

            //
            // Short-circuited, so user isn't bothered.  The alternate behavior
            // is to prompt the user for retry when any domain is down.  (See
            // RetryMessageBox code below.)
            //

            ShortCircuitRetries--;
            if (!ShortCircuitRetries) {
                DEBUGMSG ((DBG_WARNING, "Unable to connect to domain %s", DomainName));
                break;
            }

#if 0
            ArgArray[0] = DomainName;

            if (!RetryMessageBox (MSG_GETPRIMARYDC_RETRY, ArgArray)) {
                DEBUGMSG ((DBG_WARNING, "Unable to connect to domain %s; user chose to cancel", DomainName));
                break;
            }
#endif

            ForceNewServer = TRUE;
        }

    } while (nas != NO_ERROR);

    return nas;
}


VOID
pDisableDomain (
    IN OUT  PACCT_DOMAINS DomainPtr
    )

/*++

Routine Description:

    Disable the specified domain.

Arguments:

    DomainPtr - A pointer to the internally maintained ACCT_DOMAINS
                structure.  This structure is updated to contain
                an empty server name upon return.

Return value:

    None

--*/

{
    g_DomainProblem = TRUE;

    if (DomainPtr->Server && *DomainPtr->Server) {
        PoolMemReleaseMemory (g_DomainPool, (PVOID) DomainPtr->Server);
    }
    DomainPtr->Server = S_EMPTY;
}


NET_API_STATUS
pNetUseAddAllowingRetry (
    IN OUT  PACCT_DOMAINS DomainPtr
    )

/*++

Routine Description:

    Implements NetUseAdd, but provides a retry capability.

Arguments:

    DomainPtr - A pointer to the internally maintained ACCT_DOMAINS
                structure.  This structure is updated to contain
                the server name upon success.

Return value:

    Win32 error code indicating outcome

--*/

{
    NET_API_STATUS rc;
    DWORD DontCare;
    PCWSTR ReplacementName;
    NET_API_STATUS nas;
    USE_INFO_2 ui2;
    WCHAR LocalShareName[72];
    WCHAR NewServerBuf[MAX_SERVER_NAMEW];

    ReplacementName = NULL;

    do {
        //
        // Initialize USE_INFO_2 structure
        //

        ZeroMemory (&ui2, sizeof (ui2));
        StringCopyW (LocalShareName, ReplacementName ? ReplacementName : DomainPtr->Server);
        StringCatW (LocalShareName, L"\\IPC$");
        ui2.ui2_remote = LocalShareName;
        ui2.ui2_asg_type = USE_IPC;

        rc = NetUseAdd (NULL, 2, (PBYTE) &ui2, &DontCare);

        //
        // If NetUseAdd fails, give the user a chance to retry with a different server
        //

        if (rc != NO_ERROR) {
            PCWSTR ArgArray[2];

            DEBUGMSG ((
                DBG_WARNING,
                "User was alerted to problem establishing nul session to %s (domain %s), rc=%u",
                DomainPtr->Server,
                DomainPtr->Domain,
                rc
                ));

            ArgArray[0] = DomainPtr->Server;
            ArgArray[1] = DomainPtr->Domain;

            if (!RetryMessageBox (MSG_NULSESSION_RETRY, ArgArray)) {
                DEBUGMSG ((DBG_WARNING, "Unable to connect to domain %s; user chose to cancel", DomainPtr->Domain));

                pDisableDomain (DomainPtr);
                ReplacementName = NULL;
                break;
            }

            if (ReplacementName) {
                ReplacementName = NULL;
            }

            //
            // Get a new server because current server is not responding.  If we fail to
            // obtain a server name, allow the user to try again.
            //

            do {
                nas = GetAnyDC (DomainPtr->Domain, NewServerBuf, TRUE);

                if (nas != NO_ERROR) {
                    PCWSTR ArgArray[1];

                    DEBUGMSG ((DBG_WARNING, "User was alerted to problem locating server for domain %s", DomainPtr->Domain));

                    ArgArray[0] = DomainPtr->Domain;
                    if (!RetryMessageBox (MSG_GETANYDC_RETRY, ArgArray)) {
                        DEBUGMSG ((DBG_WARNING, "Unable to find a server for domain %s; user chose to cancel", DomainPtr->Domain));

                        // Disable domain and return an error
                        pDisableDomain (DomainPtr);
                        ReplacementName = NULL;
                        break;
                    }
                } else {
                    ReplacementName = NewServerBuf;
                }
            } while (nas != NO_ERROR);
        }
    } while (rc != NO_ERROR);

    //
    // If ReplacementName is not NULL, we need to free the buffer.  Also, if the
    // NetUseAdd call succeeded, we now have to use another server to query the
    // domain.
    //

    if (ReplacementName) {
        if (rc == NO_ERROR) {
            if (DomainPtr->Server && *DomainPtr->Server) {
                PoolMemReleaseMemory (g_DomainPool, (PVOID) DomainPtr->Server);
            }
            DomainPtr->Server = PoolMemDuplicateString (g_DomainPool, ReplacementName);
        }
    }

    return rc;
}


PCWSTR
pLsaStringToCString (
    IN      PLSA_UNICODE_STRING UnicodeString,
    OUT     PWSTR Buffer
    )

/*++

Routine Description:

    A safe string extraction that takes the string in UnicodeString
    and copies it to Buffer.  The caller must ensure Buffer is
    big enough.

Arguments:

    UnicodeString - Specifies the source string to convert

    Buffer - Specifies the buffer that receives the converted string

Return value:

    The Buffer pointer

--*/

{
    StringCopyABW (
        Buffer,
        UnicodeString->Buffer,
        (PWSTR) ((PBYTE) UnicodeString->Buffer + UnicodeString->Length)
        );

    return Buffer;
}


BOOL
BuildDomainList(
    VOID
    )

/*++

Routine Description:

    Creates a trusted domain list by:

    1. Determining the computer domain in which the machine participates in
    2. Opening the DC's policy
    3. Querying the trust list
    4. Adding it to our internal domain list (ACCT_DOMAINS)

    This function will fail if the machine does not participate in a domain, or
    if the domain controller cannot be contacted.

Arguments:

    none

Return value:

    TRUE if the trust list was completely built, or FALSE if an error occurred
    and the trust list is incomplete and is probably empty.  GetLastError
    provides the failure code.

--*/

{
    LSA_HANDLE PolicyHandle;
    BOOL DomainControllerFlag = FALSE;
    NTSTATUS Status;
    NET_API_STATUS nas = NO_ERROR;
    BOOL b = FALSE;
    WCHAR PrimaryDomainName[MAX_SERVER_NAMEW];
    PPOLICY_PRIMARY_DOMAIN_INFO PrimaryDomain;
    WCHAR ServerName[MAX_SERVER_NAMEW];

#if DOMAINCONTROLLER
    PPOLICY_ACCOUNT_DOMAIN_INFO AccountDomain;
#endif

    if (!IsMemberOfDomain()) {
        DEBUGMSG ((DBG_VERBOSE, "Workstation does not participate in a domain."));
        return FALSE;
    }

    //
    // Add special domains used for management of user state
    //

    // users whos domain is not known
    AddDomainToList (S_UNKNOWN_DOMAIN);

    // users whos domain was known but the account doesn't exist
    AddDomainToList (S_FAILED_DOMAIN);

    //
    // Open the policy on this machine
    //

    Status = OpenPolicy (
                NULL,
                POLICY_VIEW_LOCAL_INFORMATION,
                &PolicyHandle
                );

    if (Status != STATUS_SUCCESS) {
        SetLastError (LsaNtStatusToWinError (Status));
        return FALSE;
    }

#if DOMAINCONTROLLER       // disabled, but may be needed for DC installation
    //
    // Obtain the AccountDomain, which is common to all three cases
    //

    Status = LsaQueryInformationPolicy (
                PolicyHandle,
                PolicyAccountDomainInformation,
                &AccountDomain
                );

    if (Status != STATUS_SUCCESS)
        goto cleanup;

    //
    // Note: AccountDomain->DomainSid will contain binary Sid
    //
    AddDomainToList (pLsaStringToCString (&AccountDomain->DomainName, PrimaryDomainName));

    //
    // Free memory allocated for account domain
    //
    LsaFreeMemory (AccountDomain);

    //
    // Find out if this machine is a domain controller
    //
    if (!IsDomainController (NULL, &DomainControllerFlag)) {
        // IsDomainController couldn't find the answer
        goto cleanup;
    }
#endif

    // If not a domain controller...
    if(!DomainControllerFlag) {

        //
        // Get the primary domain
        //
        Status = LsaQueryInformationPolicy (
                        PolicyHandle,
                        POLICY_PRIMARY_DOMAIN_INFORMATION,
                        &PrimaryDomain
                        );

        if (Status != STATUS_SUCCESS) {
            goto cleanup;
        }

        //
        // If the primary domain SID is NULL, we are a non-member, and
        // our work is done.
        //
        if (!PrimaryDomain->Sid) {
            LsaFreeMemory (PrimaryDomain);
            b = TRUE;
            goto cleanup;
        }

        //
        // We found our computer domain, add it to our list
        //
        AddDomainToList (pLsaStringToCString (&PrimaryDomain->Name, PrimaryDomainName));
        LsaFreeMemory (PrimaryDomain);

        //
        // Get the primary domain controller computer name.  If the API fails,
        // alert the user and allow them to retry.  ServerName is allocated by
        // the Net APIs.
        //

        nas = pGetDcNameAllowingRetry (PrimaryDomainName, ServerName, FALSE);

        if (nas != NO_ERROR) {
            goto cleanup;
        }

        //
        // Re-enable the code to open the policy on the domain controller
        //

        //
        // Close the prev policy handle, because we don't need it anymore.
        //
        LsaClose (PolicyHandle);
        PolicyHandle = INVALID_HANDLE_VALUE; // invalidate handle value

        //
        // Open the policy on the domain controller
        //
        Status = OpenPolicy(
                    ServerName,
                    POLICY_VIEW_LOCAL_INFORMATION,
                    &PolicyHandle
                    );

        if (Status != STATUS_SUCCESS) {
            goto cleanup;
        }

    }

    //
    // Build additional trusted logon domain(s) list and
    // indicate if successful
    //

    b = pAddAllLogonDomains (DomainControllerFlag ? NULL : ServerName);

cleanup:

    //
    // Close the policy handle
    //
    if (PolicyHandle != INVALID_HANDLE_VALUE && PolicyHandle) {
        LsaClose (PolicyHandle);
    }

    if (!b) {
        if (Status != STATUS_SUCCESS)
            SetLastError (LsaNtStatusToWinError (Status));
        else if (nas != NO_ERROR)
            SetLastError (nas);
    }

    return b;
}


BOOL
pAddAllLogonDomains (
    IN      PCTSTR DCName           OPTIONAL
    )
{
    NET_API_STATUS rc;
    PWSTR Domains;
    PCWSTR p;

    rc = NetEnumerateTrustedDomains ((PTSTR)DCName, &Domains);

    if (rc != ERROR_SUCCESS) {
        SetLastError (rc);
        return FALSE;
    }

    for (p = Domains ; *p ; p = GetEndOfStringW (p) + 1) {
        AddDomainToList (p);
    }

    NetApiBufferFree (Domains);

    return TRUE;
}



BOOL
pEstablishNulSessionWithDomain (
    IN OUT  PACCT_DOMAINS DomainPtr,
    IN      BOOL ForceNewServer
    )

/*++

Routine Description:

    If a nul session has not been established with a domain, this
    routine finds a server in the domain and establishes the nul
    session.  Every network call is wrapped within a retry loop,
    so the user can retry when network failures occur.

Arguments:

    DomainPtr - Specifies a pointer to our private domain structure.
                This structure indicates the domain to establish
                the nul session with, and it receives the name
                of the server upon successful connection.

    ForceNewServer - Specifies TRUE if the function should obtain a new
                     server for the domain.

Return value:

    TRUE if a nul session was established, or FALSE if an
    error occurred while establishing the nul session.  GetLastError
    provides a failure code.

--*/

{
    NET_API_STATUS nas;
    WCHAR ServerName[MAX_SERVER_NAMEW];
    DWORD rc;

    //
    // Release old name if necessary
    //

    if (ForceNewServer && DomainPtr->Server) {
        if (*DomainPtr->Server) {
            PoolMemReleaseMemory (g_DomainPool, (PVOID) DomainPtr->Server);
        }

        DomainPtr->Server = NULL;
    }

    //
    // Obtain a server name if necessary
    //

    if (!DomainPtr->Server) {
        //
        // Get the primary DC name
        //

        nas = pGetDcNameAllowingRetry (DomainPtr->Domain, ServerName, ForceNewServer);
        if (nas != NO_ERROR) {
            pDisableDomain (DomainPtr);
            return FALSE;
        }

        DomainPtr->Server = PoolMemDuplicateString (g_DomainPool, ServerName);

        //
        // Connect to the server, possibly finding a server that will
        // service us.
        //

        rc = pNetUseAddAllowingRetry (DomainPtr);

        if (rc != NO_ERROR) {
            //
            // Remove the server name because we never connected
            //
            pDisableDomain (DomainPtr);

            SetLastError (rc);
            LOG ((LOG_ERROR, "NetUseAdd failed"));
            return FALSE;
        }
    }

    return *DomainPtr->Server != 0;
}


BOOL
QueryDomainForUser (
    IN      PACCT_ENUM DomainEnumPtr,
    IN      PACCT_ENUM UserEnumPtr
    )

/*++

Routine Description:

    Checks the domain controller for a user account via NetUserGetInfo.

Arguments:

    DomainEnumPtr - Specifies the domain to search.  This structure
                    must be the return of a domain enumeration function
                    above.

    UserEnumPtr   - Specifies the user to look up over the network.

Return value:

    TRUE if the user exists, or FALSE if the user does not exist.  If
    an error occurs, a retry popup appears, allowing the installer to
    retry the search if necessary.

--*/

{
    PACCT_DOMAINS DomainPtr;
    PACCT_USERS UserPtr;
    NET_API_STATUS rc;
    BOOL ForceNewServer = FALSE;
    TCHAR DomainQualifiedUserName[MAX_USER_NAME];
    BYTE SidBuf[MAX_SID_SIZE];
    DWORD SizeOfSidBuf;
    TCHAR DontCareStr[MAX_SERVER_NAME];
    DWORD DontCareSize;
    SID_NAME_USE SidNameUse;

    DomainPtr = DomainEnumPtr->DomainPtr;
    UserPtr   = UserEnumPtr->UserPtr;

    do {
        if (!pEstablishNulSessionWithDomain (DomainPtr, ForceNewServer)) {
            LOG ((LOG_ERROR, "Could not query domain %s for user %s.",
                      DomainPtr->Domain, UserPtr->User));
            return FALSE;
        }

        //
        // Do query
        //

        DEBUGMSG ((DBG_ACCTLIST, "Querying %s for %s", DomainPtr->Server, UserPtr->User));


        rc = NO_ERROR;
        wsprintf (DomainQualifiedUserName, TEXT("%s\\%s"), DomainPtr->Domain, UserPtr->User);

        SizeOfSidBuf = sizeof (SidBuf);
        DontCareSize = sizeof (DontCareStr);

        if (!LookupAccountName (
                DomainPtr->Server,
                DomainQualifiedUserName,
                SidBuf,
                &SizeOfSidBuf,
                DontCareStr,
                &DontCareSize,
                &SidNameUse
                )) {
            rc = GetLastError();
        }

        if (rc != NO_ERROR && rc != ERROR_NONE_MAPPED) {
            PCWSTR ArgArray[2];

            DEBUGMSG ((
                DBG_WARNING,
                "User was alerted to problem querying account %s (domain %s), rc=%u",
                DomainPtr->Server,
                DomainPtr->Domain,
                rc
                ));

            ArgArray[0] = DomainPtr->Server;
            ArgArray[1] = DomainPtr->Domain;

            if (!RetryMessageBox (MSG_NULSESSION_RETRY, ArgArray)) {
                DEBUGMSG ((DBG_WARNING, "Unable to connect to domain %s; user chose to cancel", DomainPtr->Domain));
                pDisableDomain (DomainPtr);
                break;
            }

            ForceNewServer = TRUE;
        }
    } while (rc != NO_ERROR && rc != ERROR_NONE_MAPPED);

    if (rc == NO_ERROR && SidNameUse != SidTypeUser) {
        rc = ERROR_NONE_MAPPED;
    }

    if (rc != NO_ERROR && rc != ERROR_NONE_MAPPED) {
        LOG ((
            LOG_ERROR,
            "User %s not found in %s, rc=%u",
            UserPtr->User, DomainPtr->Domain,
            rc
            ));
    }

    return rc == NO_ERROR;
}


BOOL
pGetUserSecurityInfo (
    IN      PCWSTR User,
    IN      PCWSTR Domain,
    IN OUT  PGROWBUFFER SidBufPtr,
    OUT     SID_NAME_USE *UseType       OPTIONAL
    )

/*++

Routine Description:

    A common routine that searches for a user in our private structures
    and returns the SID and/or the type of user via LookupAccountName.
    The lookup operation is enclosed in a retry loop.

Arguments:

    User        - The name of the user to get security info on

    Domain      - The name of the domain where the user exists.  Can be
                  NULL for the local machine.

    SidBufPtr   - A pointer to a GROWBUFFER.  The SID is appended to
                  the GROWBUFFER.

    UseType     - Specifies the address of a SID_NAME_USE variable, or
                  NULL if use type is not needed.

Return value:

    TRUE if the lookup succeeded, or FALSE if an error occurred from
    either establishing a nul session for a domain or looking up an
    account on the domain.  GetLastError provides the failure code.

--*/

{
    ACCT_ENUM e;
    PACCT_DOMAINS DomainPtr;
    PSID Sid;
    DWORD Size;
    PCWSTR FullUserName = NULL;
    WCHAR DomainName[MAX_SERVER_NAMEW];
    DWORD DomainNameSize;
    SID_NAME_USE use = 0;
    DWORD End;
    BOOL b = FALSE;
    DWORD rc;

    __try {
        End = SidBufPtr->End;

        if (Domain) {
            //
            // Domain account case -- verify domain is in trust list
            //

            if (!FindDomainInList (&e, Domain)) {
                __leave;
            }

            DomainPtr = e.DomainPtr;
            FullUserName = JoinPaths (Domain, User);

        } else {
            //
            // Local account case
            //

            DomainPtr = NULL;

            if (StringIMatch (User, g_EveryoneStr) ||
                StringIMatch (User, g_NoneGroupStr) ||
                StringIMatch (User, g_AdministratorsGroupStr)
                ) {

                FullUserName = DuplicatePathString (User, 0);

            } else {

                FullUserName = JoinPaths (g_ComputerName, User);

            }
        }

        Sid = (PSID) GrowBuffer (SidBufPtr, MAX_SID_SIZE);

        if (DomainPtr && !pEstablishNulSessionWithDomain (DomainPtr, FALSE)) {

            LOG ((
                LOG_ERROR,
                "Could not query domain %s for user %s security info.",
                Domain,
                User
                ));

            __leave;
        }

        Size = MAX_SID_SIZE;
        DomainNameSize = MAX_SERVER_NAMEW;

        do {

            //
            // Look up account name in form of domain\user or computer\user
            //

            b = LookupAccountName (
                    DomainPtr ? DomainPtr->Server : NULL,
                    FullUserName,
                    Sid,
                    &Size,
                    DomainName,
                    &DomainNameSize,
                    &use
                    );

            if (!b) {

                rc = GetLastError();

                //
                // In the local account case, try the lookup again, without
                // the computer name decoration.  This works around a
                // GetComputerName bug.
                //

                if (rc != ERROR_INSUFFICIENT_BUFFER) {
                    if (!DomainPtr) {

                        b = LookupAccountName (
                                NULL,
                                User,
                                Sid,
                                &Size,
                                DomainName,
                                &DomainNameSize,
                                &use
                                );

                        rc = GetLastError();
                    }
                }

                if (!b) {

                    if (rc == ERROR_INSUFFICIENT_BUFFER) {

                        //
                        // Grow the buffer if necessary, then try again
                        //

                        SidBufPtr->End = End;
                        Sid = (PSID) GrowBuffer (SidBufPtr, Size);
                        continue;
                    }

                    //
                    // API failed with an error
                    //

                    LOG ((
                        LOG_ERROR,
                        "Lookup Account On Network: LookupAccountName failed for %s (domain: %s)",
                        FullUserName,
                        Domain ? Domain : TEXT("*local*")
                        ));

                    //
                    // Ignore the error in the case of the local account "none"
                    //

                    if (StringIMatch (User, g_NoneGroupStr)) {
                        b = TRUE;
                    }

                    __leave;
                }
            }

        } while (!b);

        //
        // We now have successfully gotten a sid.  Adjust pointers, return type.
        //

        if (UseType) {
            *UseType = use;
        }

        SidBufPtr->End = End + GetLengthSid (Sid);

        //
        // As a debugging aid, output the type
        //

        DEBUGMSG_IF ((use == SidTypeUser, DBG_VERBOSE, "%s is SidTypeUser", FullUserName));
        DEBUGMSG_IF ((use == SidTypeGroup, DBG_VERBOSE, "%s is SidTypeGroup", FullUserName));
        DEBUGMSG_IF ((use == SidTypeDomain, DBG_VERBOSE, "%s is SidTypeDomain", FullUserName));
        DEBUGMSG_IF ((use == SidTypeAlias, DBG_VERBOSE, "%s is SidTypeAlias", FullUserName));
        DEBUGMSG_IF ((use == SidTypeWellKnownGroup, DBG_VERBOSE, "%s is SidTypeWellKnownGroup", FullUserName));
        DEBUGMSG_IF ((use == SidTypeDeletedAccount, DBG_VERBOSE, "%s is SidTypeDeletedAccount", FullUserName));
        DEBUGMSG_IF ((use == SidTypeInvalid, DBG_VERBOSE, "%s is SidTypeInvalid", FullUserName));
        DEBUGMSG_IF ((use == SidTypeUnknown, DBG_VERBOSE, "%s is SidTypeUnknown", FullUserName));
        DEBUGMSG_IF ((use == SidTypeComputer, DBG_VERBOSE, "%s is SidTypeComputer", FullUserName));

    }
    __finally {

        FreePathString (FullUserName);
    }

    return b;
}


BOOL
GetUserSid (
    IN      PCWSTR User,
    IN      PCWSTR Domain,
    IN OUT  PGROWBUFFER SidBufPtr
    )

/*++

Routine Description:

    This routine is vaild only after the domain list is perpared.
    It queries a domain for a user SID.

Arguments:

    User    - Specifies name of user to look up

    Domain  - Specifies name of domain to query, or NULL for local machine

    SidBufPtr - A ponter to a GROWBUFFER.  The SID is appended to
                the GROWBUFFER.

Return value:

    TRUE if the lookup succeeded, or FALSE if an error occurred from
    either establishing a nul session for a domain or looking up an
    account on the domain.  GetLastError provides the failure code.

--*/

{
    return pGetUserSecurityInfo (User, Domain, SidBufPtr, NULL);
}


BOOL
GetUserType (
    IN      PCWSTR User,
    IN      PCWSTR Domain,
    OUT     SID_NAME_USE *UseType
    )

/*++

Routine Description:

    This routine is valid only after the domain list is prepared.
    It queries a domain for a user SID type.

Arguments:

    User    - Specifies name of user to look up

    Domain  - Specifies name of domain to query, or NULL for local machine

    UseType - Specifies the address of a SID_NAME_USE variable

Return value:

    TRUE if the lookup succeeded, or FALSE if an error occurred from
    either establishing a nul session for a domain or looking up an
    account on the domain.  GetLastError provides the failure code.

--*/

{
    GROWBUFFER SidBuf = GROWBUF_INIT;
    BOOL b;

    b = pGetUserSecurityInfo (User, Domain, &SidBuf, UseType);
    FreeGrowBuffer (&SidBuf);

    return b;
}


VOID
PrepareForRetry (
    VOID
    )

/*++

Routine Description:

    Provides caller a way to reset the abandoned domains.  When an error
    occurs during account lookup, and the installer chooses not to retry,
    the domain is disabled for the rest of the lookup until the installer
    is presented with a dialog detailing the problems.  If they choose to
    retry the search, all disabled domains must be re-enabled, and thats
    what this routine does.

Arguments:

    none

Return value:

    none

--*/

{
    ACCT_ENUM Domain;

    //
    // Enumerate all domains and remove any empty server names
    //

    if (ListFirstDomain (&Domain)) {
        do {
            if (Domain.DomainPtr->Server && Domain.DomainPtr->Server[0] == 0) {
                Domain.DomainPtr->Server = NULL;
            }
        } while (ListNextDomain (&Domain));
    }

    //
    // Reset domain lookup retry count
    //

    g_RetryCount = DOMAIN_RETRY_RESET;
}


BOOL
RetryMessageBox (
    DWORD Id,
    PCTSTR *ArgArray
    )

/*++

Routine Description:

    A wrapper that allows retry message box code to be simplified.

Arguments:

    Id - Specifies the message ID

    ArgArray - Specifies the argument array eventually passed to FormatMessage

Return value:

    TRUE if the user chooses YES, FALSE if the user chooses NO

--*/

{
    DWORD rc;

    if (g_RetryCount < 0) {
        // Either DOMAIN_RETRY_ABORT or DOMAIN_RETRY_NO
        return FALSE;
    }

    if (g_ConfigOptions.IgnoreNetworkErrors) {
        return FALSE;
    }

    rc = ResourceMessageBox (
            g_ParentWnd,
            Id,
            MB_YESNO|MB_ICONQUESTION,
            ArgArray
            );

    if (rc == IDNO && g_RetryCount < DOMAIN_RETRY_MAX) {

        // disabled so the IDD_NETWORK_DOWN dialog never appears
        //g_RetryCount++;

        if (g_RetryCount == DOMAIN_RETRY_MAX) {
            DWORD Result;

            Result = DialogBoxParam (
                        g_hInst,
                        MAKEINTRESOURCE (IDD_NETWORK_DOWN),
                        g_ParentWnd,
                        NetworkDownDlgProc,
                        (LPARAM) (PINT) &g_RetryCount
                        );

            if (Result == IDC_STOP) {
                g_RetryCount = DOMAIN_RETRY_ABORT;
            } else if (Result == IDC_NO_RETRY) {
                g_RetryCount = DOMAIN_RETRY_NO;
            } else {
                g_RetryCount = DOMAIN_RETRY_RESET;
            }
        }
    }

    return rc != IDNO;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\migmain\infparse.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

  infparse.c

Abstract:

  The code in this file read in an INF file, organizing it into a data
  structure that can be maniuplated along with an STF file.  The INF
  data structure is stored along with the STF table data strcture.
  This INF parser does not preserve comments.  It is designed specifically
  for the STF migration code.

  The entry points are:

  InfParse_ReadInfIntoTable - Parses the INF associated with the STF file.

  InfParse_WriteInfToDisk - Writes the INF memory structure to disk

  AddInfSectionToTable - Adds a new section to the INF memory structure

  AddInfLineToTable - Adds a new line to a section's memory structure

  FindInfSectionInTable - Performs a sequential search for a specific
                          section name

  FindLineInInfSection - Locates a line given a specific key

  DeleteLineInInfSection - Removes a line from an INF section

  DeleteSectionInInfFile - Removes a complete section from the INF memory
                           structure

  GetInfSectionLineCount - Returns the number of lines in a section

  GetFirstLineInSectionStruct - Begins a line enumeration given an INF
                                section ptr

  GetFirstLineInSectionStr - Begins a line enumeration given an INF
                             section string

  GetNextLineInSection - Continues a line enumeration

Author:

  Jim Schmidt (jimschm) 20-Sept-1997

Revision History:

--*/

#include "pch.h"
#include "migmainp.h"

#include "stftable.h"

//
// Globals to manage INF file reading
//

static PBYTE g_Buf1, g_Buf2;
static DWORD g_Buf1Start, g_Buf2Start;
static DWORD g_Buf1End, g_Buf2End;

#define INF_BUFFER_SIZE 32768

WCHAR
pStfGetInfFileWchar (
    IN      HANDLE File,
    IN      DWORD Pos,
    OUT     PBOOL Error
    );

PCTSTR
pStfGetNextInfLine (
    IN      HANDLE File,
    IN      PGROWBUFFER LineBuf,
    IN OUT  PDWORD Pos,
    IN      BOOL UnicodeMode
    );


BOOL
InfParse_ReadInfIntoTable (
    IN OUT  PSETUPTABLE TablePtr
    )

/*++

Routine Description:

  Reads the specified file into memory, parsing the lines according to basic
  INF structure.  This routine requires an initalized SETUPTABLE structure.
  (See CreateSetupTable in stftable.c.)

  The INF is assumed to be in the ANSI DBCS character set.

Arguments:

  TablePtr - Specifies the STF table structure that provides the state for
             the STF/INF pair.  Receives the complete INF structure.

Return Value:

  TRUE if parsing was successful, or FALSE if parsing failed.

--*/

{
    WCHAR ch;
    BOOL Error;
    GROWBUFFER LineBuf = GROWBUF_INIT;
    PCTSTR Text;
    DWORD Pos;
    PCTSTR Key, Data;
    PTSTR p, q;
    INT i;
    PSTFINFSECTION Section = NULL;
    DWORD LineFlags;
    BOOL Result = FALSE;

    Section = StfAddInfSectionToTable (TablePtr, S_EMPTY);
    if (!Section) {
        LOG ((LOG_ERROR, "Read Inf Into Table: Could not add comment section"));
        return FALSE;
    }

    g_Buf1Start = 0;
    g_Buf2Start = 0;
    g_Buf1End   = 0;
    g_Buf2End   = 0;

    g_Buf1 = (PBYTE) MemAlloc (g_hHeap, 0, INF_BUFFER_SIZE);
    g_Buf2 = (PBYTE) MemAlloc (g_hHeap, 0, INF_BUFFER_SIZE);

    __try {

        //
        // Determine if this file is UNICODE
        //

        ch = pStfGetInfFileWchar (TablePtr->SourceInfFile, 0, &Error);
        TablePtr->InfIsUnicode = (ch == 0xfeff) && !Error;

        //
        // Parse each line.
        //

        Pos = 0;

        while (TRUE) {
            //
            // Get the line
            //

            Text = pStfGetNextInfLine (
                        TablePtr->SourceInfFile,
                        &LineBuf,
                        &Pos,
                        TablePtr->InfIsUnicode
                        );

            if (!Text) {
                break;
            }

            //
            // If a comment line or blank line, skip it
            //

            p = (PTSTR) SkipSpace (Text);
            if (!p[0] || _tcsnextc (p) == TEXT(';')) {
                if (!StfAddInfLineToTable (TablePtr, Section, NULL, Text, LINEFLAG_ALL_COMMENTS)) {
                    LOG ((LOG_ERROR, "Read Inf Into Table: Can't add line comments to table", Text));
                    __leave;
                }

                continue;
            }

            //
            // If a section line, start the new section
            //

            if (_tcsnextc (p) == TEXT('[')) {
                p = _tcsinc (p);
                q = _tcschr (p, TEXT(']'));
                if (!q) {
                    q = GetEndOfString (p);
                } else {
                    *q = 0;
                }

                Section = StfAddInfSectionToTable (TablePtr, p);
                if (!Section) {
                    LOG ((LOG_ERROR, "Read Inf Into Table: Could not add section %s", p));
                    __leave;
                }
            }

            //
            // Otherwise it must be a valid line
            //

            else {
                if (!Section) {
                    DEBUGMSG ((DBG_WARNING, "InfParse_ReadInfIntoTable: Ignoring unrecognized line %s", p));
                    continue;
                }

                //
                // Split key and line: Skip key that is surrounded by quotes, then
                // find the first
                //

                LineFlags = 0;

                q = p;
                Key = NULL;
                Data = Text;

                while (_tcsnextc (q) == TEXT('\"')) {
                    q = _tcschr (_tcsinc (q), TEXT('\"'));
                    if (!q) {
                        q = p;
                        break;
                    } else {
                        q = _tcsinc (q);
                    }
                }

                i = _tcscspn (q, TEXT("\"="));
                if (_tcsnextc (q + i) == TEXT('=')) {
                    q += i;

                    Data = SkipSpace (_tcsinc (q));
                    *q = 0;
                    q = (PTSTR) SkipSpaceR (Text, q);
                    if (q && *q) {
                        q = _tcsinc (q);
                        *q = 0;
                    }

                    Key = p;

                    if (_tcsnextc (Key) == TEXT('\"')) {
                        LineFlags |= LINEFLAG_KEY_QUOTED;
                        Key = _tcsinc (Key);
                        p = GetEndOfString (Key);
                        p = (PTSTR) SkipSpaceR (Key, p);
                        if (p && *p) {
                            if (_tcsnextc (p) != TEXT('\"')) {
                                p = _tcsinc (p);
                            }

                            *p = 0;
                        }
                    }
                }

                if (!StfAddInfLineToTable (TablePtr, Section, Key, Data, LineFlags)) {
                    LOG ((LOG_ERROR, "Read Inf Into Table: Can't add line %s to table", Text));
                    __leave;
                }
            }
        }

        if (Pos != GetFileSize (TablePtr->SourceInfFile, NULL)) {
            LOG ((LOG_ERROR, "Read Inf Into Table: Could not read entire INF"));
            __leave;
        }

        Result = TRUE;
    }
    __finally {
        MemFree (g_hHeap, 0, g_Buf1);
        MemFree (g_hHeap, 0, g_Buf2);
        FreeGrowBuffer (&LineBuf);
    }

    return Result;
}


BOOL
InfParse_WriteInfToDisk (
    IN      PSETUPTABLE TablePtr
    )

/*++

Routine Description:

  InfParse_WriteInfToDisk writes the INF represented by the given setup
  table to disk.  This is done by enumerating the INF data structures in
  the setup table.  The file name comes from the setup table struct and
  was created in CreateSetupTable in stftable.c.

Arguments:

  TablePtr - Specifies the table to process

Return Value:

  TRUE if successful, FALSE if not.

--*/

{
    PSTFINFSECTION Section;
    PSTFINFLINE Line;

    MYASSERT (TablePtr->SourceInfFile != INVALID_HANDLE_VALUE);
    MYASSERT (TablePtr->DestInfFile != INVALID_HANDLE_VALUE);

    //
    // Write the INF as we have it in memory
    //

    if (!WriteFileStringA (TablePtr->DestInfFile, "\r\n")) {
        LOG ((LOG_ERROR, "Write Inf To Disk: Cannot write new line to INF"));
        return FALSE;
    }

    Section = TablePtr->FirstInfSection;

    while (Section) {
        if (Section->Name[0]) {
            if (!WriteFileStringA (TablePtr->DestInfFile, "[") ||
                !WriteFileString (TablePtr->DestInfFile, Section->Name) ||
                !WriteFileStringA (TablePtr->DestInfFile, "]\r\n")
                ) {
                LOG ((LOG_ERROR, "Write Inf To Disk: Cannot write section name to INF"));
                return FALSE;
            }
        }

        Line = Section->FirstLine;

        while (Line) {
            if (Line->Key) {
                if (Line->LineFlags & LINEFLAG_KEY_QUOTED) {
                    if (!WriteFileStringA (TablePtr->DestInfFile, "\"")) {
                        LOG ((LOG_ERROR, "Write Inf To Disk: Cannot write start key quotes to INF"));
                        return FALSE;
                    }
                }

                if (!WriteFileString (TablePtr->DestInfFile, Line->Key)) {
                    LOG ((LOG_ERROR, "Write Inf To Disk: Cannot write key to INF"));
                    return FALSE;
                }

                if (Line->LineFlags & LINEFLAG_KEY_QUOTED) {
                    if (!WriteFileStringA (TablePtr->DestInfFile, "\"")) {
                        LOG ((LOG_ERROR, "Write Inf To Disk: Cannot write end key quotes to INF"));
                        return FALSE;
                    }
                }

                if (!WriteFileStringA (TablePtr->DestInfFile, " = ")) {
                    LOG ((LOG_ERROR, "Write Inf To Disk: Cannot write equals to INF"));
                    return FALSE;
                }
            }

            if (!WriteFileString (TablePtr->DestInfFile, Line->Data) ||
                !WriteFileStringA (TablePtr->DestInfFile, "\r\n")
                ) {
                LOG ((LOG_ERROR, "Write Inf To Disk: Cannot write key data to INF"));
                return FALSE;
            }

            Line = Line->Next;
        }

        if (!WriteFileStringA (TablePtr->DestInfFile, "\r\n")) {
            LOG ((LOG_ERROR, "Write Inf To Disk: Cannot write end of section line to INF"));
            return FALSE;
        }

        Section = Section->Next;
    }

    return TRUE;
}


PSTFINFSECTION
StfAddInfSectionToTable (
    IN      PSETUPTABLE TablePtr,
    IN      PCTSTR SectionName
    )

/*++

Routine Description:

  Creates a new section in our linked list structure if necessary.
  The return structure can be used to add lines to the section.

Arguments:

  TablePtr - Specifies the table to add the INF section to

  SectionName - Specifies the name of the new section

Return Value:

  A pointer to the new INF section struct, or NULL if an
  error occurred.

--*/

{
    PSTFINFSECTION NewSection;

    //
    // Return early if this section already exists
    //

    NewSection = StfFindInfSectionInTable (TablePtr, SectionName);
    if (NewSection) {
        return NewSection;
    }

    //
    // Allocate a section struct
    //

    NewSection = (PSTFINFSECTION) PoolMemGetAlignedMemory (
                                    TablePtr->InfPool,
                                    sizeof (INFSECTION)
                                    );

    if (!NewSection) {
        return NULL;
    }

    //
    // Fill in members of the struct and link
    //

    ZeroMemory (NewSection, sizeof (INFSECTION));

    NewSection->Name = PoolMemDuplicateString (
                            TablePtr->InfPool,
                            SectionName
                            );

    if (!NewSection->Name) {
        return NULL;
    }

    NewSection->Prev = TablePtr->LastInfSection;
    if (NewSection->Prev) {
        NewSection->Prev->Next = NewSection;
    } else {
        TablePtr->FirstInfSection = NewSection;
    }

    TablePtr->LastInfSection = NewSection;

    return NewSection;
}


PSTFINFLINE
StfAddInfLineToTable (
    IN      PSETUPTABLE TablePtr,
    IN      PSTFINFSECTION SectionPtr,
    IN      PCTSTR Key,                     OPTIONAL
    IN      PCTSTR Data,
    IN      DWORD LineFlags
    )

/*++

Routine Description:

  Adds a line to the specified section.  The caller specifies the
  full formatted data, and an optional key.  The caller does NOT
  supply the equals sign between the key and data.

Arguments:

  TablePtr - Specifies the table to add the INF line to

  SectionName - Specifies the name of the section to add the line to

  Key - If specified, supplies the left-hand side of the equals line

  Data - Specifies the text for the line, or the right-hand side of
         the key = value expression.

  LineFlags - Specifies the flags for the INF line (see LINEFLAG_*)

Return Value:

  TRUE if the line was added to the structure, or FALSE if not.

--*/

{
    PSTFINFLINE NewLine;

    //
    // Allocate line struct
    //

    NewLine = (PSTFINFLINE) PoolMemGetAlignedMemory (
                              TablePtr->InfPool,
                              sizeof (INFLINE)
                              );


    if (!NewLine) {
        return NULL;
    }

    //
    // Fill in members of the struct and link
    //

    ZeroMemory (NewLine, sizeof (INFLINE));

    if (Key) {
        NewLine->Key = PoolMemDuplicateString (
                            TablePtr->InfPool,
                            Key
                            );

        if (!NewLine->Key) {
            return NULL;
        }
    }

    NewLine->Data = PoolMemDuplicateString (
                        TablePtr->InfPool,
                        Data
                        );

    if (!NewLine->Data) {
        return NULL;
    }

    NewLine->Next = NULL;
    NewLine->Prev = SectionPtr->LastLine;
    NewLine->Section = SectionPtr;
    NewLine->LineFlags = LineFlags;

    if (NewLine->Prev) {
        NewLine->Prev->Next = NewLine;
    } else {
        SectionPtr->FirstLine = NewLine;
    }

    SectionPtr->LastLine = NewLine;
    SectionPtr->LineCount++;

    return NewLine;
}


PSTFINFSECTION
StfFindInfSectionInTable (
    IN      PSETUPTABLE TablePtr,
    IN      PCTSTR SectionName
    )

/*++

Routine Description:

  Scans the INF for a specific section.  This routine scans
  the INF structures sequentially and does a case-insensitive
  comparison.

Arguments:

  TablePtr - Specifies the table to search

  SectionName - Specifies the name of the section to find

Return Value:

  A pointer to the matching INF section struct, or NULL if
  the section was not found.

--*/

{
    PSTFINFSECTION Section;

    Section = TablePtr->FirstInfSection;
    while (Section) {
        if (StringIMatch (Section->Name, SectionName)) {
            return Section;
        }

        Section = Section->Next;
    }

    return NULL;
}


PSTFINFLINE
StfFindLineInInfSection (
    IN      PSETUPTABLE TablePtr,
    IN      PSTFINFSECTION Section,
    IN      PCTSTR Key
    )

/*++

Routine Description:

  Scans the specified INF section for a specific key.  This routine
  scans the INF line structures sequentially and does a case-insensitive
  comparison.

Arguments:

  TablePtr - Specifies the table to search

  Section - Specifies the section to search

  Key - Specifies the key to find

Return Value:

  A pointer to the matching INF line struct, or NULL if
  the section was not found.

--*/

{
    PSTFINFLINE Line;

    Line = Section->FirstLine;
    while (Line) {
        if (Line->Key && StringIMatch (Line->Key, Key)) {
            return Line;
        }

        Line = Line->Next;
    }

    return NULL;
}


PSTFINFLINE
StfGetFirstLineInSectionStruct (
    IN      PSTFINFSECTION Section
    )

/*++

Routine Description:

  GetFirstLineInSectionStruct returns the first INFLINE pointer for the
  section, or NULL if no lines exist.  Call GetNextLineInSection to
  continue enumeration.

  This routine does not return lines consisting only of comments.

Arguments:

  Section - Specifies the section structure to enumerate lines frmo

Return Value:

  A pointer to the first INFLINE struct, or NULL if no lines exist.

--*/

{
    if (!Section->FirstLine) {
        return NULL;
    }

    if (Section->FirstLine->LineFlags & LINEFLAG_ALL_COMMENTS) {
        return StfGetNextLineInSection (Section->FirstLine);
    }

    return Section->FirstLine;
}


PSTFINFLINE
StfGetNextLineInSection (
    IN      PSTFINFLINE PrevLine
    )

/*++

Routine Description:

  GetNextLineInSection returns the next INFLINE pointer for the
  section, based on the previous line, or NULL if no lines exist.

  This routine does not return lines with comments.

Arguments:

  PrevLine - Specifies previous line (returned from
             GetFirstLineInSectionStruct or GetFirstLineInSectionStr).

Return Value:

  This routine does not return lines consisting only of comments.

--*/

{
    while (PrevLine) {
        PrevLine = PrevLine->Next;
        if (!PrevLine || !(PrevLine->LineFlags & LINEFLAG_ALL_COMMENTS)) {
            break;
        }
    }

    return PrevLine;
}


PSTFINFLINE
StfGetFirstLineInSectionStr (
    IN      PSETUPTABLE Table,
    IN      PCTSTR Section
    )
/*++

Routine Description:

  GetFirstLineInSectionStruct returns the first INFLINE pointer for the
  section, or NULL if no lines exist.  Call GetNextLineInSection to
  continue enumeration.

Arguments:

  Table - Specifies the setup table containing the parsed INF

  Section - Specifies the name of the section in the INF

Return Value:

  A pointer to the first INFLINE struct, or NULL if no lines exist.

--*/

{
    PSTFINFSECTION SectionPtr;

    SectionPtr = StfFindInfSectionInTable (Table, Section);
    if (!SectionPtr) {
        return NULL;
    }

    return StfGetFirstLineInSectionStruct (SectionPtr);
}


INT
pStfGetInfFileByte (
    IN      HANDLE File,
    IN      DWORD Pos
    )

/*++

Routine Description:

  Returns the byte at the specified position, or -1 if the file could
  not be read at that position.

  Two buffers are used to allow fast relative access.  Memory-mapped
  files were NOT used because problems were introduced when the
  swap file started filling up during GUI mode.

Arguments:

  File - Specifies the file to read

  Pos - Specifies the 32-bit file offset to read (zero-based, in bytes)

Return Value:

  The byte at the specified position, or -1 if an error was encountered.
  (Errors are usually caused by reading past the end of the file.)

--*/

{
    DWORD Read;
    PBYTE BufSwap;

    //
    // If we read the buffer previously, then return data in our buffer
    //

    if (Pos >= g_Buf1Start && Pos < g_Buf1End) {
        return g_Buf1[Pos - g_Buf1Start];
    }

    if (Pos >= g_Buf2Start && Pos < g_Buf2End) {
        return g_Buf2[Pos - g_Buf2Start];
    }

    //
    // Buffer not available; move buffer 2 to buffer 1, then read buffer 2
    //

    g_Buf1Start = g_Buf2Start;
    g_Buf1End = g_Buf2End;
    BufSwap = g_Buf1;
    g_Buf1 = g_Buf2;
    g_Buf2 = BufSwap;

    g_Buf2Start = Pos - (Pos % 256);

    SetFilePointer (File, g_Buf2Start, NULL, FILE_BEGIN);
    if (!ReadFile (File, g_Buf2, INF_BUFFER_SIZE, &Read, NULL)) {
        return -1;
    }

    g_Buf2End = g_Buf2Start + Read;

    if (Pos >= g_Buf2Start && Pos < g_Buf2End) {
        return g_Buf2[Pos - g_Buf2Start];
    }

    return -1;
}

WCHAR
pStfGetInfFileWchar (
    IN      HANDLE File,
    IN      DWORD Pos,
    OUT     PBOOL Error
    )

/*++

Routine Description:

  Returns the WCHAR at the specified position, or 0 if the file could
  not be read at that position.

  Two buffers are used to allow fast relative access.  Memory-mapped
  files were NOT used because problems were introduced when the
  swap file started filling up during GUI mode.

Arguments:

  File - Specifies the file to read

  Pos - Specifies the 32-bit file offset to read (zero-based, in bytes)

  Error - Receives TRUE if an error was encountered, or FALSE if an
          error was not encountered.

Return Value:

  The WCHAR at the specified position, or 0 if an error was encountered.
  (Errors are usually caused by reading past the end of the file.)
  If an error was encountered, the Error variable is also set to TRUE.

--*/

{
    INT c;
    WCHAR ch;

    c = pStfGetInfFileByte (File, Pos);
    if (c == -1 || c == 26) {
        *Error = TRUE;
        return 0;
    }

    ch = (WCHAR)c;

    c = pStfGetInfFileByte (File, Pos + 1);
    if (c == -1 || c == 26) {
        *Error = TRUE;
        return 0;
    }

    ch += c * 256;
    *Error = FALSE;

    return ch;
}


PCSTR
pStfGetInfLineA (
    IN      HANDLE File,
    IN      DWORD StartPos,
    OUT     PDWORD EndPosPtr,       OPTIONAL
    IN OUT  PGROWBUFFER LineBuf
    )

/*++

Routine Description:

  Returns a DBCS string supplying the line.  This string can be
  any length and is nul-terminated.  It does not include the \r or
  \n characters.

  If supplied, the EndPosPtr is updated to point to the start of
  the next line.

Arguments:

  File - Specifies the file to read

  StartPos - Specifies the 32-bit file offset to read (zero-based, in bytes)

  EndPosPtr - If specified, receives the 32-bit file offset of the next
              line, or equal to the file size for the last line.

  LineBuf - Specifies a reused GROWBUFFER that the caller initializes
            and pStfGetInfLineA uses for line allocation.  The caller is
            responsible for cleanup.

Return Value:

  A pointer to the DBCS string supplying the full line (with the \r, \n or
  \r\n sequence stripped), or NULL if an error occurs.

--*/

{
    DWORD EndPos;
    INT c;
    PBYTE Data;
    DWORD Pos;
    DWORD ByteLen = 0;

    EndPos = StartPos;
    for (;;) {
        c = pStfGetInfFileByte (File, EndPos);
        if (c == -1 || c == 26) {
            break;
        }

        if (IsDBCSLeadByte ((BYTE) c)) {
            EndPos++;
            c = pStfGetInfFileByte (File, EndPos);
            if (c == -1 || c == 26) {
                break;
            }
            ByteLen++;
        } else {
            if (c == '\r' || c == '\n') {
                EndPos++;
                if (c == '\r') {
                    c = pStfGetInfFileByte (File, EndPos);
                    if (c == '\n') {
                        EndPos++;
                    }
                }

                break;
            }
        }

        EndPos++;
        ByteLen++;
    }

    //
    // NOTE: If you make a change here, make one below in W version
    //

    // Ctrl+Z ends the file
    if (c == 26) {
        EndPos = GetFileSize (File, NULL);
    }

    // Allocate buffer, caller frees
    LineBuf->End = 0;
    Data = GrowBuffer (LineBuf, ByteLen + 2);
    if (!Data) {
        return NULL;
    }

    // We've been successful -- copy end pos to caller's variable
    if (EndPosPtr) {
        *EndPosPtr = EndPos;
    }

    // End of file condition: zero-length, but not a blank line
    if (!ByteLen && c != '\r' && c != '\n') {
        return NULL;
    }

    // Copy line to buffer
    for (Pos = 0 ; Pos < ByteLen ; Pos++) {
        Data[Pos] = (BYTE)pStfGetInfFileByte (File, StartPos);
        StartPos++;
    }

    Data[Pos] = 0;
    Data[Pos + 1] = 0;

    return (PCSTR) Data;
}


PCWSTR
pStfGetInfLineW (
    IN      HANDLE File,
    IN      DWORD StartPos,
    OUT     PDWORD EndPosPtr,       OPTIONAL
    IN OUT  PGROWBUFFER LineBuf
    )

/*++

Routine Description:

  Returns a UNICODE string supplying the line.  This string can be
  any length and is nul-terminated.  It does not include the \r or
  \n characters.

  If supplied, the EndPosPtr is updated to point to the start of
  the next line.

Arguments:

  File - Specifies the file to read

  StartPos - Specifies the 32-bit file offset to read (zero-based, in bytes)

  EndPosPtr - If specified, receives the 32-bit file offset of the next
              line, or equal to the file size for the last line.

  LineBuf - Specifies a reused GROWBUFFER that the caller initializes
            and pStfGetInfLineA uses for line allocation.  The caller is
            responsible for cleanup.

Return Value:

  A pointer to the UNICODE string supplying the full line (with the \r, \n or
  \r\n sequence stripped), or NULL if an error occurs.

--*/

{
    DWORD EndPos;
    PBYTE Data;
    DWORD Pos;
    DWORD ByteLen = 0;
    WCHAR ch;
    BOOL Error;

    EndPos = StartPos;
    for (;;) {

        ch = pStfGetInfFileWchar (File, EndPos, &Error);

        if (Error) {
            break;
        }

        if (ch == TEXT('\r') || ch == TEXT('\n')) {
            EndPos += 2;
            if (ch == TEXT('\r')) {
                ch = pStfGetInfFileWchar (File, EndPos, &Error);
                if (ch == '\n') {
                    EndPos += 2;
                }
            }

            break;
        }

        EndPos += 2;
        ByteLen += 2;
    }

    //
    // NOTE: If you make a change here, make one above in A version
    //

    // Ctrl+Z ends the file
    if (ch == 26) {
        EndPos = GetFileSize (File, NULL);
    }

    // Allocate buffer
    LineBuf->End = 0;
    Data = GrowBuffer (LineBuf, ByteLen + 2);
    if (!Data) {
        return NULL;
    }

    // We've been successful -- copy end pos to caller's variable
    if (EndPosPtr) {
        *EndPosPtr = EndPos;
    }

    // End of file condition: zero-length, but not a blank line
    if (!ByteLen && ch != L'\r' && ch != L'\n') {
        return NULL;
    }

    // Copy to buffer
    for (Pos = 0 ; Pos < ByteLen ; Pos++) {
        Data[Pos] = (BYTE)pStfGetInfFileByte (File, StartPos);
        StartPos++;
    }

    Data[Pos] = 0;
    Data[Pos + 1] = 0;

    if (EndPosPtr) {
        *EndPosPtr = EndPos;
    }

    return (PCWSTR) Data;
}


PCTSTR
pStfGetNextInfLine (
    IN      HANDLE File,
    IN      PGROWBUFFER LineBuf,
    IN OUT  PDWORD Pos,
    IN      BOOL UnicodeMode
    )

/*++

Routine Description:

  Returns a TCHAR string supplying the line.  This string can be
  any length and is nul-terminated.  It does not include the \r or
  \n characters.

Arguments:

  File - Specifies the file to read

  LineBuf - Specifies a reused GROWBUFFER that the caller initializes
            and pStfGetInfLineA uses for line allocation.  The caller is
            responsible for cleanup.

  Pos - Specifies the byte offset to the start of the line.  Receives
        the byte offset to the next line.

  UnicodeMode - Specifies TRUE if the file being read is a UNICODE file,
                or FALSE if the file being read is a DBCS file.

Return Value:

  A pointer to the TCHAR string supplying the full line (with the \r, \n or
  \r\n sequence stripped), or NULL if an error occurs.

--*/

{
    PCSTR AnsiStr = NULL;
    PCWSTR UnicodeStr = NULL;
    PCTSTR FinalStr;
    BOOL Converted = FALSE;

    //
    // Obtain the text from the file
    //

    if (UnicodeMode) {
        UnicodeStr = pStfGetInfLineW (File, *Pos, Pos, LineBuf);
        if (!UnicodeStr) {
            return NULL;
        }
    } else {
        AnsiStr = pStfGetInfLineA (File, *Pos, Pos, LineBuf);
        if (!AnsiStr) {
            return NULL;
        }
    }

    //
    // Convert to TCHAR
    //

#ifdef UNICODE
    if (AnsiStr) {
        UnicodeStr = ConvertAtoW (AnsiStr);
        if (!UnicodeStr) {
            return NULL;
        }

        Converted = TRUE;
    }

    FinalStr = UnicodeStr;

#else

    if (UnicodeStr) {
        AnsiStr = ConvertWtoA (UnicodeStr);
        if (!AnsiStr) {
            return NULL;
        }

        Converted = TRUE;
    }

    FinalStr = AnsiStr;

#endif

    //
    // Copy converted string into line buffer
    //

    if (Converted) {
        LineBuf->End = 0;
        Converted = MultiSzAppend (LineBuf, FinalStr);
        FreeConvertedStr (FinalStr);

        if (!Converted) {
            return NULL;
        }
    }

    return (PCTSTR) LineBuf->Buf;
}


BOOL
StfDeleteLineInInfSection (
    IN OUT  PSETUPTABLE TablePtr,
    IN      PSTFINFLINE InfLine
    )

/*++

Routine Description:

  DeleteLineInInfSection removes the specified InfLine from its section,
  cleaning up memory used by the line.

Arguments:

  TablePtr - Specifies the table owning the INF line

  InfLine - Specifies the line to delete

Return Value:

  TRUE if the line was deleted successfully, or FALSE if an error
  occurred.

--*/

{
    if (InfLine->Prev) {
        InfLine->Prev->Next = InfLine->Next;
    } else {
        InfLine->Section->FirstLine = InfLine->Next;
    }

    if (InfLine->Next) {
        InfLine->Next->Prev = InfLine->Prev;
    } else {
        InfLine->Section->LastLine = InfLine->Prev;
    }

    if (InfLine->Key) {
        PoolMemReleaseMemory (TablePtr->InfPool, (PVOID) InfLine->Key);
    }

    if (InfLine->Data) {
        PoolMemReleaseMemory (TablePtr->InfPool, (PVOID) InfLine->Data);
    }

    InfLine->Section->LineCount--;

    PoolMemReleaseMemory (TablePtr->InfPool, (PVOID) InfLine);
    return TRUE;
}

BOOL
StfDeleteSectionInInfFile (
    IN OUT  PSETUPTABLE TablePtr,
    IN      PSTFINFSECTION Section
    )

/*++

Routine Description:

  DeleteSectionInInfFile removes the specified section from the INF
  data structure, removing all lines cleaning up
  memory used by the section.

Arguments:

  TablePtr - Specifies the table owning the INF line

  Section - Specifies the section to delete

Return Value:

  TRUE if the section was deleted successfully, or FALSE if an error
  occurred.

--*/

{
    PSTFINFLINE InfLine, DelInfLine;

    InfLine = Section->FirstLine;
    while (InfLine) {
        DelInfLine = InfLine;
        InfLine = InfLine->Next;

        if (!StfDeleteLineInInfSection (TablePtr, DelInfLine)) {
            return FALSE;
        }
    }

    if (Section->Prev) {
        Section->Prev->Next = Section->Next;
    } else {
        TablePtr->FirstInfSection = Section->Next;
    }

    if (Section->Next) {
        Section->Next->Prev = Section->Prev;
    } else {
        TablePtr->LastInfSection = Section->Prev;
    }

    PoolMemReleaseMemory (TablePtr->InfPool, (PVOID) Section->Name);
    PoolMemReleaseMemory (TablePtr->InfPool, (PVOID) Section);

    return TRUE;
}


UINT
StfGetInfSectionLineCount (
    IN      PSTFINFSECTION Section
    )

/*++

Routine Description:

  GetInfSectionLineCount returns the number of lines in the specified
  INF section.

Arguments:

  Section - Specifies the section to query

Return Value:

  The number of lines, or zero if the section has no lines.

--*/

{
    return Section->LineCount;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\migmain\dosmignt.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    dosmignt.c

Abstract:

    handles windows nt side migration of config.sys and autoexec.bat information
    gathered during win9x upgrading. migrates environement settings, prompts, and
    some doskey information. Also modifies the autoexec.nt and config.nt files.

Author:

    Marc R. Whitten (marcw) 15-Feb-1997

Revision History:

--*/
#include "pch.h"
#include "w95upgnt.h"

#define DBG_DOSMIG "Dosmig"


//
// Flag that is set if Doskey /INSERT needs to be set.
//
BOOL g_MigrateDoskeySetting = FALSE;

//
// PoolMem Handle to pool used for dynamic allocations.
//
POOLHANDLE g_Pool = NULL;

//
// Flag that is set if all necessary data has been collected for migration.
//
BOOL g_MigrationPrepared = FALSE;

//
// String that points to the current file being processed.
//
PCTSTR g_CurrentFile = NULL;
PCTSTR g_LastFile = NULL;

//
// Boolean flag indicating wether any changes were made to the flag.
//
BOOL   g_FileChanged = FALSE;


//
// The suppression table holds environment variables we want to ignore.
//
HASHTABLE g_SuppressionTable = NULL;

//
// List of path segments.
//
GROWLIST g_PathList = GROWLIST_INIT;



#define STRINGBUFFER(x) ((PTSTR) (x)->Buf)
#define BUFFEREMPTY(x)  ((x)->End == 0)

typedef enum {

    DOSMIG_UNUSED,
    DOSMIG_BAD,
    DOSMIG_UNKNOWN,
    DOSMIG_USE,
    DOSMIG_MIGRATE,
    DOSMIG_IGNORE,
    DOSMIG_LAST

} DOSMIG_LINETAG, *PDOSMIG_LINETAG;





PCTSTR
pGetFileNameStartFromPath (
    IN PCTSTR Line
    )
/*++

Routine Description:

    This function returns the start of a File name in a(n assumed
    wellformed) path.

Arguments:

    Line - The String containing the path and filename.

Return Value:

    A pointer to the filename portion of the path. Note, this function
    assumes that there may be (potentially valuable) arguments after the
    file name. The pointer does not, therefore point only

--*/
{
    PCTSTR lineStart = Line;
    PCTSTR lineEnd   = Line;

    if (Line == NULL) {
        return NULL;
    }

    while (_istalnum(*lineEnd)      ||
        *lineEnd == TEXT('_')      ||
        *lineEnd == TEXT('.')      ||
        *lineEnd == TEXT('\\')     ||
        *lineEnd == TEXT(':')) {

        if((*lineEnd == TEXT('\\')) || (*lineEnd == TEXT(':'))) {

            lineStart = _tcsinc(lineEnd);

        }
        lineEnd = _tcsinc(lineEnd);
    }

    return lineStart;
}

LONG
pSaveBufferToAnsiFile (
    IN PCTSTR  Path,
    IN PCTSTR  Buffer
    )
{
    HANDLE  fileHandle;
    LONG    rc = ERROR_SUCCESS;
    DWORD   amountWritten;
    PTSTR   savePath = NULL;
    BOOL    sysFile = TRUE;
    PCSTR   ansiString = NULL;
    DWORD   ansiStringLength;
    PCTSTR  ArgList[1];
    PCTSTR  Message = NULL;
    PCTSTR  p;
    PCTSTR  fileName;

    MYASSERT (Path && Buffer);

    //
    // IF this is a system file (i.e. config.sys or autoexec.bat) redirect the
    // file to config.nt or autoexec.nt.
    //
    p = _tcschr (Path, TEXT('\\'));
    if (p) {
        p = _tcsinc (p);
    } else {
        p = Path;
    }

    fileName = p;

    if (StringIMatch (p, TEXT("config.sys"))) {

        savePath = JoinPaths(g_System32Dir,TEXT("config.nt"));

    } else if (StringIMatch (p, TEXT("autoexec.bat"))) {
       
        savePath = JoinPaths(g_System32Dir,TEXT("autoexec.nt"));

    } else {
        sysFile = FALSE;
        savePath = (PTSTR) Path;
    }

    //
    // If the file was not changed during the migration, do nothing.
    //
    if (sysFile || g_FileChanged) {

        //
        // Open a handle to the file to be created.
        //
        fileHandle = CreateFile(
                        savePath,
                        GENERIC_WRITE,
                        0,
                        NULL,
                        sysFile ? OPEN_ALWAYS : CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL
                        );

        if (fileHandle == INVALID_HANDLE_VALUE) {

            rc = GetLastError();

        } else {

            //
            // Append from the end of the file.
            //

            SetFilePointer(
                fileHandle,
                0,
                NULL,
                FILE_END
                );


            ArgList[0] = g_Win95Name;



            Message = ParseMessageID (MSG_DMNT_APPENDSTRING, ArgList);


            ansiString = CreateDbcs (Message);
            ansiStringLength = ByteCountA (ansiString);

            WriteFile(
                fileHandle,
                ansiString,
                ansiStringLength,
                &amountWritten,
                NULL
                );

            FreeStringResource (Message);
            DestroyDbcs (ansiString);

            ansiString = CreateDbcs (Buffer);
            ansiStringLength = ByteCountA (ansiString);

            if (!WriteFile(
                    fileHandle,
                    ansiString,
                    ansiStringLength,
                    &amountWritten,
                    NULL
                    )) {

                LOG((LOG_ERROR, "Error writing buffer to file."));
            }

            DestroyDbcs (ansiString);

            //
            // Log the file change.
            //
            LOG ((
                LOG_INFORMATION,
                "%s was updated with settings from %s",
                savePath,
                fileName
                ));


            CloseHandle(fileHandle);
        }

        if (sysFile) {

            FreePathString(savePath);
        }

    }


    return rc;
}

LONG
pTurnInsertModeOn (
    HKEY UserKey
    )
{
    LONG            rc;
    HKEY            key;
    DWORD           value = 1;

    rc = TrackedRegOpenKeyEx (UserKey,S_CONSOLEKEY,0,KEY_ALL_ACCESS,&key);

    if (rc == ERROR_SUCCESS) {

        rc = RegSetValueEx(
            key,
            S_INSERTMODEVALUE,
            0,
            REG_DWORD,
            (PBYTE) &value,
            sizeof(DWORD)
            );

        CloseRegKey(key);
    }


    return rc;
}


LONG
pTurnAutoParseOff (
    HKEY UserKey
    )
{
    LONG            rc;
    HKEY            key;
    PCTSTR         valueStr = TEXT("0");
    DWORD           valueStrBytes = 2*sizeof(TCHAR);

    rc = TrackedRegOpenKeyEx(UserKey,S_WINLOGONKEY,0,KEY_ALL_ACCESS,&key);

    if (rc == ERROR_SUCCESS) {

        rc = RegSetValueEx(
            key,
            S_AUTOPARSEVALUE,
            0,
            REG_SZ,
            (PBYTE) valueStr,
            valueStrBytes
            );

        if (rc != ERROR_SUCCESS) {
            DEBUGMSG((DBG_WARNING,"DosMig: Unable to Save new ParseAutoexec value. rc: %u (%x)",rc,rc));
        }
        else {
            DEBUGMSG((DBG_DOSMIG,"ParseAutoexec turned off."));
        }

        CloseRegKey(key);
    }
    else {
        DEBUGMSG((DBG_WARNING,"DosMig: Unable to open %s rc: %u (%x)",S_WINLOGONKEY,rc,rc));
    }


    return rc;
}

LONG
pMigrateEnvSetting (
    IN PCTSTR Setting,
    IN PCTSTR EnvValue,
    IN      BOOL PrependSetPrefix,
    IN OUT  PGROWBUFFER Buffer,         OPTIONAL
    OUT     PBOOL AppendedToBuffer      OPTIONAL
    )
{
    LONG  rc = ERROR_SUCCESS;
    GROWBUFFER newSetting = GROWBUF_INIT;
    TCHAR currentPath[MAX_CMDLINE];
    TCHAR matchBuffer[MEMDB_MAX];
    PCTSTR start;
    PCTSTR end;
    HKEY key;
    DWORD sizeNeeded;
    DWORD valueType;
    PTSTR storage;
    BOOL append = FALSE;
    PTSTR p;
    PTSTR q;
    BOOL bRegMigrationSuppressed;
    PTSTR expandKey = TEXT("");


    if (AppendedToBuffer) {
        *AppendedToBuffer = FALSE;
    }

    //
    // Make sure this setting is not suppressed.
    //
    bRegMigrationSuppressed = HtFindString (g_SuppressionTable, Setting) != NULL;
    if (bRegMigrationSuppressed) {
        DEBUGMSG ((DBG_DOSMIG, "pMigrateEnvSetting: NOT Migrating %s = %s in registry. Environment variable is suppressed.", Setting, EnvValue));
    }

    DEBUGMSG((DBG_DOSMIG,"pMigrateEnvSetting: Migrating %s = %s.",Setting,EnvValue));

    if (!bRegMigrationSuppressed) {
        //
        // Attempt to open the registry key.
        //
        rc = TrackedRegOpenKeyEx(
                 HKEY_LOCAL_MACHINE,
                 S_ENVIRONMENTKEY,
                 0,
                 KEY_ALL_ACCESS,
                 &key
                 );

        if (rc != ERROR_SUCCESS) {
            LOG((LOG_ERROR,"Dosmig: Could not open key %s",S_ENVIRONMENTKEY));
            return rc;

        }
    }

    start = EnvValue;

    do {

        //
        // Find end of this portion of the environment string.
        // this is (1) the first ';' encountered, or (2) the trailing NULL
        //
        end = _tcschr(start,TEXT(';'));
        if (!end) {
            end = GetEndOfString(start);
        }

        //
        //  save a copy of the currently found path.
        //
        StringCopyAB(currentPath,start,end);

        //
        // Look for self-replacement case.
        // This is the case where there are multiple statements setting the
        // same environment variable like:
        // set foo=bar
        // set foo=%foo%;bar2
        //
        wsprintf(matchBuffer,TEXT("%%%s%%"),Setting);
        if (!bRegMigrationSuppressed &&
            (StringIMatch(currentPath,matchBuffer) ||
            (StringIMatch(currentPath,TEXT("%PATH%")) &&
            StringIMatch(Setting,TEXT("MIGRATED_PATH"))
            ))) {

            //
            // Get contents of key if it exists.
            //
            rc = RegQueryValueEx(
                key,
                Setting,
                0,
                &valueType,
                NULL,
                &sizeNeeded);

            if (rc == ERROR_SUCCESS) {

                //
                // Now, create a temporary duplicate of the key and
                //
                storage = PoolMemCreateString(g_Pool,sizeNeeded+1);

                if (storage != NULL) {

                    rc = RegQueryValueEx(
                        key,
                        Setting,
                        0,
                        &valueType,
                        (PBYTE) storage,
                        &sizeNeeded
                        );
                    if (rc != ERROR_SUCCESS) {
                        LOG((LOG_ERROR,"Dosmig: ReqQueryValueEx failure."));
                    }

                    //
                    // Add this to the environment string to be set.
                    //
                    if (append) {
                        GrowBufAppendString (&newSetting,TEXT(";"));
                    }

                    GrowBufAppendString (&newSetting,storage);
                    PoolMemReleaseMemory(g_Pool,storage);
                    append = TRUE;

                }
                else {
                    rc = GetLastError();
                    DEBUGMSG((DBG_ERROR,"Dosmig: Error! Unable to allocate storage."));
                }
            }
            else {

                rc = ERROR_SUCCESS;
            }

        }
        else {



            //
            //  append the massaged path, keep it for later use.
            //

            if (append) {
                GrowBufAppendString (&newSetting,TEXT(";"));
            }

            //
            // Make sure we take care of any DIR moves.
            //
            ConvertWin9xCmdLine (currentPath, NULL, NULL);
            GrowBufAppendString (&newSetting, currentPath);

            //
            // store the updated path in the given growbuffer
            //
            if (Buffer) {
                if (PrependSetPrefix && !append) {
                    StringCopy (matchBuffer, TEXT("SET "));
                    q = GetEndOfString (matchBuffer);
                } else {
                    q = matchBuffer;
                }
                if (!append) {
                    wsprintf (q, TEXT("%s=%s"), Setting, currentPath);
                } else {
                    *q++ = TEXT(';');
                    StringCopy (q, currentPath);
                }

                GrowBufAppendString (Buffer, matchBuffer);
                if (AppendedToBuffer) {
                    *AppendedToBuffer = TRUE;
                }
            }

            append = TRUE;
        }

        //
        // set start pointer for next iteration of path.
        //
        start = end;
        if (*start == TEXT(';')) {
            start = _tcsinc(start);
        }

    } while (*start);


    if (!bRegMigrationSuppressed) {
        //
        // Save the value we built up into the registry.
        //
        if (rc == ERROR_SUCCESS && newSetting.Buf && *newSetting.Buf) {

            rc = RegSetValueEx(
                key,
                Setting,
                0,
                REG_EXPAND_SZ,
                (LPBYTE) newSetting.Buf,
                SizeOfString((PCTSTR) newSetting.Buf)
                );

            if (rc != ERROR_SUCCESS) {
                LOG ((LOG_ERROR,"Dosmig: Unexpectedly could not write key into registry."));
            }
            DEBUGMSG_IF((rc == ERROR_SUCCESS,DBG_DOSMIG,"Saved env setting into registry. (%s)",newSetting.Buf));
        }
        else if (rc != ERROR_SUCCESS) {
            LOG((LOG_ERROR,"Dosmig: Some previous failure prevents writing the migrated env variable to the registry."));
        }

        //
        // Clean up resource usage.
        //
        CloseRegKey(key);
    }

    FreeGrowBuffer(&newSetting);

    return rc;
}


LONG
pSetPrompt (
    IN PCTSTR  PromptCommand
    )
{
    LONG    rc = ERROR_SUCCESS;

    PCTSTR promptSetting;


    promptSetting = SkipSpace(CharCountToPointer((PTSTR)PromptCommand,6));
    if (promptSetting && *promptSetting == TEXT('=')) {
        promptSetting = SkipSpace(_tcsinc(promptSetting));
    }

    if (promptSetting) {
        DEBUGMSG((DBG_DOSMIG,"Passing prompt statement off to env migration function."));
        rc = pMigrateEnvSetting(S_PROMPT,promptSetting, FALSE, NULL, NULL);
    }
    ELSE_DEBUGMSG((DBG_DOSMIG,"PromptSetting is empty...ignored."));

    return rc;

}


BOOL
pIsValidPath (
    PCTSTR Path
    )
{
    PCTSTR currPtr;

    if (!Path) {
        return FALSE;
    }

    Path = SkipSpace(Path);

    currPtr = Path;

    do {
        if ((*currPtr == TEXT(',')) ||
            (*currPtr == TEXT(';')) ||
            (*currPtr == TEXT('<')) ||
            (*currPtr == TEXT('>')) ||
            (*currPtr == TEXT('|')) ||
            (*currPtr == TEXT('?')) ||
            (*currPtr == TEXT('*'))
            ) {
            return FALSE;
        }
        currPtr = _tcsinc (currPtr);
    } while (*currPtr);

    if ((*Path==0) || (*(Path+1)==0)) {
        return FALSE;
    }

    currPtr = Path;
    while (*currPtr == TEXT('"')) {
        currPtr = _tcsinc (currPtr);
    }

    currPtr = SkipSpace(currPtr);

    if (!_istalpha (*currPtr) &&
        *currPtr != TEXT('\\') &&
        *currPtr != TEXT('%')) {
            return FALSE;
    }


    return TRUE;
}


LONG
pMigratePathSettings (
    IN PCTSTR PathSettings
    )
{
    LONG rc = ERROR_SUCCESS;
    PTSTR oldPath;
    UINT i;
    UINT size;
    PTSTR end;
    PTSTR p;


    MYASSERT (StringIMatchCharCount (PathSettings, TEXT("PATH"), 4));

    //
    //skip past the 'PATH' portion of this statement.
    //
    oldPath = PoolMemDuplicateString (g_Pool, PathSettings);
    oldPath = CharCountToPointer(oldPath,4);

    //
    //Look for an '=' sign.
    //
    p = _tcschr(oldPath,TEXT('='));
    if (p) {

        //
        // Pass the equals sign.
        //
        oldPath = _tcsinc(p);
    }

    //
    // Skip any white space before the actual beginning of the path.
    //
    while (*oldPath && iswspace(*oldPath)) {
        oldPath = _tcsinc(oldPath);
    }

    if (*oldPath) {
        //
        // If there is actually anything to add to the path, add it.
        //
        p = oldPath;
        while (p && *p) {

            //
            // Look for ';'
            //
            end = _tcschr (p, TEXT(';'));
            if (end) {
                *end = 0;
            }

            //
            // Add this path to our path list.
            //
            size = GrowListGetSize (&g_PathList);
            for (i = 0;i < size; i++) {
                if (StringIMatch (p, GrowListGetString (&g_PathList, i))) {
                    DEBUGMSG ((DBG_DOSMIG, "Skipping path %s. It already exists in path.", p));
                    break;
                }
            }

            if (i == size) {
                //
                // Path was not found in the list of path segments. Add it now.
                //

                if (pIsValidPath (p)) {
                    GrowListAppendString (&g_PathList, p);
                }
                ELSE_DEBUGMSG ((DBG_DOSMIG, "Skipping path %s. It is invalid.", p));
            }

            //
            // Go to the next path segment.
            //
            if (end) {
                p = _tcsinc(end);
            }
            else {
                p = NULL;
            }
        }
    }

    return rc;
}

LONG
pMigrateSetSetting (
    IN          PCTSTR SetLine,
    IN OUT      PGROWBUFFER Buffer,
    OUT         PBOOL AppendedToBuffer
    )
{
    TCHAR       setIdentifier[MEMDB_MAX];
    PTSTR       idEnd;
    PCTSTR     start;
    PCTSTR     end;

    MYASSERT (StringIMatchCharCount (SetLine, TEXT("SET"), 3));

    if (AppendedToBuffer) {
        *AppendedToBuffer = FALSE;
    }
    //
    // First, skip past the set and any whitespace.
    //
    start = SkipSpace(CharCountToPointer((PWSTR)SetLine,3));

    if (!start) {

        //
        // line is of the form SET
        //
        return ERROR_SUCCESS;
    }

    end = _tcschr(start,TEXT('='));

    if (!end) {
        //
        // line is of the form SET dafasdfasdfasdfasd
        //
        return ERROR_SUCCESS;
    }

    if (start==end) {

        //
        // line is of the form SET=
        //
        return ERROR_SUCCESS;
    }

    //
    // Create an identifier now.
    //
    StringCopyAB(setIdentifier,start,end);
    idEnd = GetEndOfString (setIdentifier);

    //
    // Shake off any space.
    //
    idEnd = (PTSTR) SkipSpaceR(setIdentifier,idEnd);

    if (!idEnd) {
        //
        // Line is of the form SET       =
        //
        return ERROR_SUCCESS;
    }
    idEnd = _tcsinc(idEnd);
    *idEnd = TEXT('\0');

    if (StringIMatch(setIdentifier,TEXT("PATH"))) {

        DEBUGMSG((DBG_DOSMIG,"Env setting is really a path statement. passing off to path migration function."));

        //
        // This is really a path setting. let the proper function take care of it.
        //
        start = SkipSpace(CharCountToPointer((PWSTR)SetLine,3));
        if(AppendedToBuffer){
            *AppendedToBuffer = TRUE;
        }
        return pMigratePathSettings(start);
    }

    //
    // Now that setIdentifier is well formed, root out the value to be set.
    //

    //
    // Move start to the beginning of the value to be set.
    //
    start = SkipSpace(_tcsinc(end));

    if (!start) {
        //
        // Line is of the form SET <id>=
        // Nothing to do.
        //
        return ERROR_SUCCESS;
    }

    //
    // Good to go. Let MigrateEnvSetting handle it.
    //
    DEBUGMSG((DBG_DOSMIG,"handing massaged set statement to env migration function."));
    return pMigrateEnvSetting(setIdentifier,start, TRUE, Buffer, AppendedToBuffer);

}


BOOL
pProcessLine (
    DWORD           Type,
    PGROWBUFFER     Buffer,
    PTSTR           Line
    )
{

    BOOL rSuccess = TRUE;
    LONG migrateRc = ERROR_SUCCESS;
    PTSTR  migrateString;
    BOOL bAppendOrigLine;
    TCHAR fixedCmdLine[MAX_CMDLINE];


    //
    // Do type specific massaging of the line
    //
    switch (Type) {

    case DOSMIG_UNKNOWN: case DOSMIG_BAD: case DOSMIG_IGNORE:

        g_FileChanged = TRUE;

        GrowBufAppendString (Buffer,TEXT("REM "));

        //
        // intentionally skipped break.
        //

    case DOSMIG_USE:

        //
        // Perform path conversion on Line, then write it to the file
        //

        StackStringCopy (fixedCmdLine, Line);
        ConvertWin9xCmdLine (fixedCmdLine, NULL, NULL);

        GrowBufAppendString (Buffer, fixedCmdLine);
        GrowBufAppendString (Buffer, TEXT("\r\n"));

        break;

    case DOSMIG_MIGRATE:



        DEBUGMSG((DBG_DOSMIG,"Processing a potentially migrateable line. (%s)",Line));

        if (IsPatternMatch(TEXT("doskey*"),Line) || IsPatternMatch(TEXT("*\\doskey*"),Line)) {
            GrowBufAppendString (Buffer,TEXT("REM "));
        }

        //
        // Skip space and ECHO OFF char (@) if any.
        // Also, skip any path portion of the string.
        // i.e, convert path/doskey to doskey.

        migrateString = (PTSTR) SkipSpace(Line);

        if (*migrateString == TEXT('@')) {
            migrateString =  (PTSTR) _tcsinc(migrateString);
        }

        migrateString = (PTSTR) pGetFileNameStartFromPath(migrateString);

        bAppendOrigLine = TRUE;

        //
        // Now, attempt to determine what migration case this is.
        //
        if (IsPatternMatch(TEXT("prompt*"),migrateString)) {

            DEBUGMSG((DBG_DOSMIG,"Migrating prompt. (%s)",migrateString));
            migrateRc = pSetPrompt(migrateString);
            if (migrateRc != ERROR_SUCCESS) {
                rSuccess = FALSE;
                LOG((LOG_ERROR,"Dosmig: Error trying to Set Prompt."));
            }
            ELSE_DEBUGMSG((DBG_DOSMIG,"Prompt successfully migrated."));
        }
        else if (IsPatternMatch(TEXT("doskey *"),migrateString)) {

            //
            // Doskey migration.
            //

            if (IsPatternMatch(TEXT("*/I*"),migrateString)) {
                g_MigrateDoskeySetting = TRUE;
                DEBUGMSG((DBG_DOSMIG,"Insert mode will be enabled for each user. (%s)",migrateString));
            }
            ELSE_DEBUGMSG((DBG_DOSMIG,"Doskey command found. However, no migrateable doskey settings found. Command ignored."));

        }
        else if (IsPatternMatch(TEXT("path=*"),migrateString)
            ||  IsPatternMatch(TEXT("path *"),migrateString)) {

            //
            // PATH migration.
            //

            DEBUGMSG((DBG_DOSMIG,"Migrating path setting (%s)",migrateString));
            migrateRc = pMigratePathSettings(migrateString);
            if (migrateRc != ERROR_SUCCESS) {
                rSuccess = FALSE;
                LOG((LOG_ERROR,"Dosmig: Error trying to migrate path settings."));
            }
            ELSE_DEBUGMSG((DBG_DOSMIG,"Path successfully migrated."));

        }
        else if (IsPatternMatch(TEXT("set *"),migrateString)) {

            BOOL b;
            //
            // SET migration.
            //
            DEBUGMSG((DBG_DOSMIG,"Migrating env variable. (%s)",migrateString));
            migrateRc = pMigrateSetSetting(migrateString, Buffer, &b);
            bAppendOrigLine = !b;

            if (migrateRc != ERROR_SUCCESS) {
                rSuccess = FALSE;
                LOG((LOG_ERROR,"Dosmig: Error trying to migrate environment setting."));
            }
            ELSE_DEBUGMSG((DBG_DOSMIG,"Env variable successfully migrated."));
        }
        ELSE_DEBUGMSG((DBG_DOSMIG,"Dosmig: Line marked for migration doesn't fit any migration rule.\n%s",Line));

        if (bAppendOrigLine) {
            GrowBufAppendString (Buffer,Line);
        }
        //
        // Last, append a CRLF into the buffer to be written.
        //
        GrowBufAppendString (Buffer,TEXT("\r\n"));

        break;
    default:
        LOG((LOG_ERROR,"Dosmig: Invalid Type in switch statement."));
        break;
    }

    return rSuccess;
}





BOOL
pNewFile (
    DWORD Offset
    ) {

            TCHAR   file[MAX_TCHAR_PATH];
    static  DWORD   curOffset = INVALID_OFFSET;

    BOOL rNewFile = FALSE;


    if (Offset != curOffset && MemDbBuildKeyFromOffset(Offset,file,1,NULL)) {

         //
         // if there isn't a current file, or this is a new file, set the current file
         // to this file.
         //

         if (!g_CurrentFile || !StringMatch(file,g_CurrentFile)) {

             //
             // If this is a genuine new file (i.e. not just the first file, we'll return true.)
             //
             rNewFile = g_CurrentFile != NULL;

             g_LastFile = g_CurrentFile;
             g_CurrentFile = PoolMemDuplicateString(g_Pool,file);
         }
    }

    return rNewFile;
}

VOID
pCompletePathProcessing (
    VOID
    )
{
    UINT i;
    UINT size;
    UINT winDirLen;
    GROWBUFFER buf = GROWBUF_INIT;
    PTSTR p;
    TCHAR pathStatement[2*MAX_TCHAR_PATH];
    TCHAR newPath[MAX_TCHAR_PATH];
    HKEY key;
    DWORD rc;


    //
    // Make sure %systemroot% and %systemroot%\system32 are in the path.
    //
    wsprintf (pathStatement, TEXT("PATH=%s"), g_WinDir);
    pMigratePathSettings (pathStatement);

    wsprintf (pathStatement, TEXT("PATH=%s\\system32"), g_WinDir);
    pMigratePathSettings (pathStatement);

    wsprintf (pathStatement, TEXT("PATH=%s\\system32\\WBEM"), g_WinDir);
    pMigratePathSettings (pathStatement);



    winDirLen = CharCount (g_WinDir);
    size = GrowListGetSize (&g_PathList);

    for (i = 0; i < size; i++) {



        p = (PTSTR) GrowListGetString (&g_PathList, i);

        if (StringIMatch (TEXT("%PATH%"), p)) {
            //
            // Skip self-replacement.
            //
            continue;
        }

        if (GetFileStatusOnNt (p) & FILESTATUS_DELETED) {

            //
            // Skip this path portion. The directory was deleted.
            //
            DEBUGMSG ((DBG_DOSMIG, "Not migrating %s to new %%path%%. Directory was deleted.", p));
            continue;
        }

        //
        // See if the path is moved.
        //
        if (GetFileInfoOnNt (p, newPath, MAX_TCHAR_PATH) & FILESTATUS_MOVED) {

            p = newPath;
        }

        //
        // Replace c:\windows with %systemroot%.
        //
        if (StringIMatchCharCount (g_WinDir, p, winDirLen)) {

            GrowBufAppendString (&buf, TEXT("%SYSTEMROOT%"));
            GrowBufAppendString (&buf, p + winDirLen);
        }
        else {

            GrowBufAppendString (&buf, p);
        }

        GrowBufAppendString (&buf, TEXT(";"));
    }



    if (size) {


        //
        // Take off trailing ';'.
        //
        p = GetEndOfString ((PTSTR) buf.Buf);
        if (p) {
            p--;
            *p = 0;
        }



        //
        // Save into registry.
        //
        key = OpenRegKey (HKEY_LOCAL_MACHINE,S_ENVIRONMENTKEY);
        if (key && key != INVALID_HANDLE_VALUE) {

            rc = RegSetValueEx (
                    key,
                    TEXT("Path"),
                    0,
                    REG_EXPAND_SZ,
                    (PBYTE) buf.Buf,
                    SizeOfString((PCTSTR) buf.Buf)
                    );

            if (rc != ERROR_SUCCESS) {
                DEBUGMSG ((DBG_WARNING, "Unable to create migrated Path variable."));
            }

            CloseRegKey (key);
        }
        ELSE_DEBUGMSG ((DBG_WARNING, "pCompletePathProcessing: Unable to open environment key."));
    }

    //
    // Clean up resources.
    //
    FreeGrowBuffer (&buf);
}

VOID 
pPathListToBuffer(
    GROWBUFFER * growBuf
    )
{
    INT i;

    i = GrowListGetSize (&g_PathList);
    if(i <= 0){
        return;
    }

    GrowBufAppendString (growBuf, TEXT("\r\nPATH="));
    for (--i; i >= 0; i--) {
        GrowBufAppendString (growBuf, GrowListGetString (&g_PathList, i));
        if(i){
            GrowBufAppendString (growBuf, TEXT(";"));
        }
    }
    GrowBufAppendString (growBuf, TEXT("\r\n"));
}

BOOL
pGeneralMigration (
    VOID
    )
{
    BOOL            rSuccess = TRUE;        // return value.
    MEMDB_ENUM      eItems;                 // Enumerator for each dosmig line.
    TCHAR           lineBuffer[MEMDB_MAX];  // Buffer for the contents of the current line.
    GROWBUFFER      buffer = GROWBUF_INIT;
    TCHAR           key[MEMDB_MAX];
    DWORD           offset;
    DWORD           value;
    INFSTRUCT       is = INITINFSTRUCT_POOLHANDLE;
    PTSTR           p = NULL;
    TCHAR           pathStatement[MAX_PATH];


    //
    // Assume that there are no doskey settings to migrate.
    //
    g_MigrateDoskeySetting = FALSE;


    //
    // Set the change flag to false.
    //
    g_FileChanged = FALSE;


    //
    // Read in the suppression table from win95upg.inf and add it the suppression table.
    //
    g_SuppressionTable = HtAlloc ();

    if (InfFindFirstLine (g_WkstaMigInf, S_SUPPRESSED_ENV_VARS, NULL, &is)) {
        do {

            p = InfGetStringField (&is, 0);
            if (p) {
                HtAddString (g_SuppressionTable, p);
            }
        } while (InfFindNextLine (&is));
    }

    InfCleanUpInfStruct (&is);





    //
    // Ok, enumerate through each dosmigration line in memdb. These lines are stored
    // as following:
    //
    //  DOSMIG LINES\<item>\<field>\<data>
    //
    // Where
    //  o item is a 5 digit enumerator string.
    //  o field is one of either TYPE,TEXT,DESC,or FILE
    //  o data is the data associated with the field. For TYPE, data contains a string
    //    representation of the LINETYPE, for TEXT, it contains the actual text of the line
    //    for DESC, it contains a description supplied by DOSMIG95's parse rules and for FILE
    //    it contains the originating file (config.sys, autoexec.bat)
    //

    //
    // Add %system32% by default
    //
    wsprintf (pathStatement, TEXT("PATH=%s\\system32"), g_WinDir);
    pMigratePathSettings (pathStatement);

    if (MemDbEnumItems(&eItems,MEMDB_CATEGORY_DM_LINES)) {

        do {

            //
            // Get the actual line contents.
            //
            if (MemDbGetEndpointValueEx(
                MEMDB_CATEGORY_DM_LINES,
                eItems.szName,
                NULL,
                lineBuffer
                )) {


                //
                // Get the value and flags from this endpoint.
                //
                MemDbBuildKey(key,MEMDB_CATEGORY_DM_LINES,eItems.szName,NULL,lineBuffer);
                MemDbGetValueAndFlags(key, &offset, &value);


                if (pNewFile(offset)) {

                    //
                    // the S_ENVVARS entry is a special case and is not an actual file. All of its entries are simply migrated
                    // into the registry.
                    //
                    if (!StringIMatch(g_LastFile,S_ENVVARS)) {
                        if (_tcsistr(g_LastFile, TEXT("autoexec.bat"))){
                            //
                            // Flush PathList to actual buffer
                            //
                            pPathListToBuffer(&buffer);
                        }
                        pSaveBufferToAnsiFile(g_LastFile,STRINGBUFFER(&buffer));
                    }
                    buffer.End = 0;
                    g_FileChanged = FALSE;
                }

                rSuccess = pProcessLine(value,&buffer,lineBuffer);
                DEBUGMSG_IF((rSuccess, DBG_DOSMIG,"Line successfully processed. (%s)",lineBuffer));
                if (!rSuccess) {
                    LOG ((LOG_ERROR,"Dosmig: Error processing line. (%s)",lineBuffer));
                }

            }
            else {
                LOG((LOG_ERROR,"Dosmig: MemDbGetEndpointValueEx failed trying to retrieve line %s",eItems.szName));
            }

        } while (MemDbEnumNextValue(&eItems) && rSuccess);


        //
        // Get the file name and save the file off.
        //
        if (!StringIMatch(g_CurrentFile,S_ENVVARS)) {
            if (_tcsistr(g_CurrentFile, TEXT("autoexec.bat"))){
                //
                // Flush PathList to actual buffer
                //
                pPathListToBuffer(&buffer);
            }
            pSaveBufferToAnsiFile(g_CurrentFile,STRINGBUFFER(&buffer));
        }

        pCompletePathProcessing ();
        FreeGrowList (&g_PathList);

    }
    ELSE_DEBUGMSG((DBG_DOSMIG,"No lines to migrate..."));

    //
    // Free our growbuffer.
    //
    FreeGrowBuffer(&buffer);

    //
    // Clean up the suppression table.
    //
    HtFree (g_SuppressionTable);


    return rSuccess;
}





BOOL
WINAPI
DosMigNt_Entry (
    IN HINSTANCE hinstDLL,
    IN DWORD     dwReason,
    IN PVOID    lpv
    )
{
    BOOL rSuccess = TRUE;

    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:

        g_Pool  = PoolMemInitNamedPool ("DOS mig - NT side");
        rSuccess = g_Pool != NULL;

        // Set flag to indicate that migration information has not
        // yet been processed.
        g_MigrationPrepared = FALSE;


        break;

    case DLL_PROCESS_DETACH:
        rSuccess = TRUE;
        PoolMemDestroyPool(g_Pool);
        break;
    }

    return rSuccess;
}

LONG
DosMigNt_User (
    IN HKEY User
    )
{
    LONG rc = ERROR_SUCCESS;

    if (!g_MigrationPrepared) {
        if (pGeneralMigration()) {
            g_MigrationPrepared = TRUE;
        }
        else {
            LOG((LOG_ERROR,"Dosmig: General migration failed"));
        }
    }

    if (g_MigrationPrepared) {
        //
        // Turn off autoexec.bat parsing.
        //
        rc = pTurnAutoParseOff(User);

        if (g_MigrateDoskeySetting) {
            rc = pTurnInsertModeOn(User);
            if (rc != ERROR_SUCCESS) {
                LOG ((LOG_ERROR,"Dosmig: Error attempting to turn insert mode on."));
            }
        }

    }

    return rc;
}


LONG
DosMigNt_System(
    VOID
    )
{


    if (!g_MigrationPrepared) {
        if (pGeneralMigration()) {
            g_MigrationPrepared = TRUE;
        }
        else {
            LOG((LOG_ERROR,"Dosmig: General migration failed"));
        }
    }

    return ERROR_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\migmain\filemig.h ===
//
// File migration utilties
//

// Obsolete header file to be deleted
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\migmain\inifiles.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    inifiles.c

Abstract:

    There are two major actions that are performed in this module.
    1. Migration of settings from the INI files to the registry according to
    subkeys from HKLM\Software\Microsoft\Windows NT\CurrentVersion\IniFileMapping.
    Entry point : ProcessIniFileMapping

    2. Processing of INI files not listed in the above key, changing paths to
    files that we moved during upgrade.
    Entry point : ConvertIniFiles

Author:

    Jim Schmidt (jimschm) 11-Sept-1997

Revision History:

    jimschm     23-Sep-1998 Changed to use new fileops
    calinn      29-Jan-1998 Added lookup for Win95 registry
    calinn      19-Jan-1998 added support for Shell settings processing
    calinn      06-Oct-1997 rewrote the whole source
    calinn      11-May-1998 Added MergeIniSettings, various fixes

--*/

#include "pch.h"
#include "migmainp.h"
#include "..\merge\mergep.h"

#define DBG_INIFILES        "IniFiles"
#define DBG_MOVEINISETTINGS "IniFileMove"

#define BufferIncrement 1024

BOOL
pLoadIniFileBuffer (
    IN      PCTSTR FileName,
    IN      PCTSTR SectName,
    IN      PCTSTR KeyName,
    OUT     PTSTR *OutBuff
    );

BOOL
pCopyIniFileToRegistry (
    IN      HKEY KeyHandle,
    IN      PCTSTR FileName,
    IN      BOOL UserMode
    );

BOOL
pTransferSectionByKey (
    IN      PCTSTR OrigFileName,
    IN      PCTSTR FileName,
    IN      PCTSTR Section,
    IN      HKEY SectionKey,
    IN OUT  BOOL *IniFileChanged,
    IN      BOOL UserMode
    );

BOOL
pTransferSectionByValue (
    IN      PCTSTR OrigFileName,
    IN      PCTSTR FileName,
    IN      PCTSTR Section,
    IN      PCTSTR SectionValue,
    IN OUT  BOOL *IniFileChanged,
    IN      BOOL UserMode
    );

BOOL
pSaveMappedValue (
    IN      PCTSTR OrigFileName,
    IN      PCTSTR Section,
    IN      PCTSTR ValueName,
    IN      PCTSTR RegPath,
    IN      PCTSTR Value,
    IN OUT  BOOL *ReverseMapping,
    OUT     PTSTR *ReverseMapValue,
    IN      BOOL UserMode
    );

BOOL
pBuildSuppressionTable (
    IN      BOOL UserMode
    );

VOID
pFreeSuppressionTable (
    VOID
    );

BOOL
pIncompatibleShell (
    VOID
    );

BOOL
pIncompatibleSCR (
    VOID
    );

BOOL
ProcessIniFileMapping (
    IN      BOOL UserMode
    )

/*++

Routine Description:

  ProcessIniFileMapping reads in the INI files, copying data to specific
  locations in the registry.  This copy is based on the IniFileMapping key in
  Software\Microsoft\Windows NT\CurrentVersion.

  These mappings can be overridden based upon the content of the [Suppress Ini File Mappings] section.

Arguments:

  UserMode - Specifies TRUE if per-user sections are to be processed, or
             FALSE if local machine sections are to be processed.

Return Value:

  Always returns TRUE. If some error occured while processing, then there will be a log entry
  specifying that.

--*/

{
    REGKEY_ENUM e;
    HKEY IniMappingKey;
    HKEY OldRegRoot=NULL;

    BOOL Result = TRUE;

    DEBUGMSG ((DBG_INIFILES, "Processing INI file mapping - START"));

    if (UserMode) {
        OldRegRoot = GetRegRoot();
        SetRegRoot (g_hKeyRootNT);
    }

    __try {
        if (!EnumFirstRegKeyStr (&e, S_INIFILEMAPPING_KEY)) {

            //
            // nothing to do here
            //
            __leave;

        }

        //
        // There is at least one file mapping to process.
        // Fill the table of ini file suppression table.
        //
        __try {

            //
            // Trying to load the suppression table, recording the eventual error
            // but going on with the stuff
            //
            if (!pBuildSuppressionTable(UserMode)) {
                Result = FALSE;
            }

            // Special case : SHELL= line from SYSTEM.INI
            // We try to see if the current shell is supported on NT.
            // If not then we will add SHELL to this suppression table
            // ensuring that the NT registry setting will get mapped into
            // the INI file
            if ((!UserMode) &&
                (pIncompatibleShell())
                ) {
                MemDbSetValueEx (
                    MEMDB_CATEGORY_SUPPRESS_INI_MAPPINGSW,
                    TEXT("SYSTEM.INI"),
                    TEXT("BOOT"),
                    TEXT("SHELL"),
                    0,
                    NULL
                    );
            }
            if ((UserMode) &&
                (pIncompatibleSCR())) {
                MemDbSetValueEx (
                    MEMDB_CATEGORY_SUPPRESS_INI_MAPPINGSW,
                    TEXT("SYSTEM.INI"),
                    TEXT("BOOT"),
                    TEXT("SCRNSAVE.EXE"),
                    0,
                    NULL
                    );
            }

            //
            // Now processing keys
            //
            do {

                IniMappingKey = OpenRegKey (e.KeyHandle, e.SubKeyName);
                if (IniMappingKey) {

                    //
                    // Process the file mapping
                    //

                    if (!pCopyIniFileToRegistry (
                            IniMappingKey,
                            e.SubKeyName,
                            UserMode
                            )) {
                        Result = FALSE;
                    }

                    CloseRegKey(IniMappingKey);

                }
                else {

                    DEBUGMSG ((DBG_INIFILES, "IniFileMapping : Could not open %s", e.SubKeyName));
                    Result = FALSE;
                }

            } while (EnumNextRegKey (&e));

            pFreeSuppressionTable();

        }
        __finally {
            AbortRegKeyEnum (&e);
        }
    }
    __finally {

        if (UserMode) {
            SetRegRoot (OldRegRoot);
        }
    }

    DEBUGMSG ((DBG_INIFILES, "Processing INI file mapping - STOP"));

    if (!Result) {
        //
        // we are going to log that at least one error occured while processing IniFileMapping
        //
        DEBUGMSG ((DBG_ERROR, (PCSTR)MSG_INI_FILE_MAPPING_LOG));
    }

    return TRUE;
}

BOOL
pIncompatibleShell (
    VOID
    )
{
    TCHAR key     [MEMDB_MAX];
    TCHAR shellVal[MEMDB_MAX] = TEXT("");
    PCTSTR fileName;
    PCTSTR newName;
    DWORD result;

    fileName = JoinPaths (g_WinDir, TEXT("SYSTEM.INI"));
    newName = GetTemporaryLocationForFile (fileName);

    if (newName) {
        DEBUGMSG ((DBG_INIFILES, "pIncompatibleShell: Using %s for %s", newName, fileName));
        FreePathString (fileName);
        fileName = newName;
    }

    if (!DoesFileExist (fileName)) {
        DEBUGMSG ((DBG_INIFILES, "pIncompatibleShell: %s not found", fileName));
    }

    result = GetPrivateProfileString (
                TEXT("boot"),
                TEXT("shell"),
                TEXT("explorer.exe"),
                shellVal,
                MEMDB_MAX,
                fileName);

    FreePathString (fileName);

    if ((result == 0) ||
        (result + 1 == MEMDB_MAX)
        ) {
        return FALSE;
    }
    MemDbBuildKey (key, MEMDB_CATEGORY_COMPATIBLE_SHELL_NT, shellVal, NULL, NULL);
    return (!MemDbGetValue (key, NULL));
}

BOOL
pIncompatibleSCR (
    VOID
    )
{
    TCHAR scrVal  [MEMDB_MAX] = TEXT("");
    PCTSTR fileName;
    PCTSTR newName;
    DWORD result;

    fileName = JoinPaths (g_WinDir, TEXT("SYSTEM.INI"));
    newName = GetTemporaryLocationForFile (fileName);

    if (newName) {
        DEBUGMSG ((DBG_INIFILES, "pIncompatibleSCR: Using %s for %s", newName, fileName));
        FreePathString (fileName);
        fileName = newName;
    }

    if (!DoesFileExist (fileName)) {
        DEBUGMSG ((DBG_INIFILES, "pIncompatibleSCR: %s not found", fileName));
    }

    result = GetPrivateProfileString (
                TEXT("boot"),
                TEXT("SCRNSAVE.EXE"),
                TEXT(""),
                scrVal,
                MEMDB_MAX,
                fileName);

    FreePathString (fileName);

    if ((result == 0) ||
        (result + 1 == MEMDB_MAX)
        ) {
        return FALSE;
    }

    return IsFileMarkedForDelete (scrVal);
}

BOOL
pLoadIniFileBuffer (
    IN      PCTSTR FileName,
    IN      PCTSTR SectName,
    IN      PCTSTR KeyName,
    OUT     PTSTR *OutBuff
    )

/*++

Routine Description:

  This routine uses GetPrivateProfileString routine trying to load a section buffer, a key buffer or
  a key value (depends on the arguments). The reason why there is such a routine is to be sure that
  we are able to load stuff from INI file while not allocating a lot of memory. This routine incrementaly
  allocates memory, returning when there is enough memory to load stuff from INI file.

Arguments:

  FileName - Specifies INI file to be processed
  SectName - Specifies section to be processed. If NULL the whole section buffer will be loaded
  KeyName  - Specifies the key to be processed. If NULL the whole key buffer will be loaded.
  OutBuff  - Output buffer holding the result.

Return Value:

  TRUE if successful, FALSE otherwise

--*/

{

    DWORD OutBuffSize;
    DWORD ReadSize;
    BOOL Done;

    OutBuffSize = 0;
    *OutBuff = NULL;
    do {
        if (*OutBuff) {
            MemFree (g_hHeap, 0, *OutBuff);
        }
        OutBuffSize += BufferIncrement;
        *OutBuff = MemAlloc (g_hHeap, 0, OutBuffSize * sizeof (TCHAR));
        if (!(*OutBuff)) {
            return FALSE;
        }

        ReadSize = GetPrivateProfileString (
                        SectName,
                        KeyName,
                        TEXT(""),
                        *OutBuff,
                        OutBuffSize,
                        FileName
                        );
        if (SectName && KeyName) {
            Done = (ReadSize < OutBuffSize - 1);
        } else {
            Done = (ReadSize < OutBuffSize - 2);
        }
    } while (!Done);

    return TRUE;

}


BOOL
pCopyIniFileToRegistry (
    IN      HKEY KeyHandle,
    IN      PCTSTR FileName,
    IN      BOOL UserMode
    )

/*++

Routine Description:

  This routine transports settings from the INI file into registry or from the registry to
  the INI file.

Arguments:

  KeyHandle - IniFileMapping key associated with this INI file.
  FileName - Specifies INI file to be processed
  UserMode - Specifies TRUE if per-user sections are to be processed, or
             FALSE if local machine sections are to be processed.

Return Value:

  TRUE if successful, FALSE if at least one error occured

--*/

{
    PCTSTR NewName = NULL;
    PCTSTR FullPath = NULL;
    TCHAR TempPath[MEMDB_MAX];
    PTSTR Section, SectionBuf;
    HKEY SectionKey;
    PCTSTR SectionValue;
    DWORD Attribs = -1;
    BOOL IniFileChanged = FALSE;
    BOOL mapToIniFile = FALSE;
    BOOL Result = TRUE;

    DEBUGMSG ((DBG_INIFILES, "Processing %s - START", FileName));

    //
    // now we have the full path for the INI file
    // Since we are going to use Ini file API we have to copy every file to some other name
    // to avoid mapping requests into registry
    //
    if (!GetTempFileName (g_WinDir, TEXT("INI"), 0, TempPath)) {
        DEBUGMSG ((DBG_ERROR,"Ini File Mapping : Cannot create a temporary file"));
        return FALSE;
    }

    __try {

        FullPath = JoinPaths (g_WinDir, FileName);
        NewName = GetTemporaryLocationForFile (FullPath);
        if (NewName) {
            DEBUGMSG ((DBG_INIFILES, "Using %s for %s", NewName, FullPath));
            FreePathString (FullPath);
            FullPath = NewName;
        }

        Attribs = GetFileAttributes (FullPath);
        if (Attribs == (DWORD)-1) {
            DEBUGMSG ((DBG_INIFILES, "pCopyIniFileToRegistry: %s not found", FullPath));
            __leave;
        }

        //
        // now trying to copy file
        //
        if (!CopyFile (FullPath, TempPath, FALSE)) {
            DEBUGMSG ((DBG_ERROR,"Ini File Mapping : Cannot copy %s to %s", FullPath, TempPath));
            Result = FALSE;
            __leave;
        }
        SetFileAttributes (TempPath, FILE_ATTRIBUTE_NORMAL);

        __try {

            //
            // Next thing we are going to do is to load the sections in a buffer
            //

            if (!pLoadIniFileBuffer (TempPath, NULL, NULL, &SectionBuf)) {

                DEBUGMSG ((DBG_ERROR,"Ini File Mapping : Cannot load section buffer for %s", TempPath));
                return FALSE;
            }

            __try {
                //
                // now we have all sections of the INI file and proceeding
                //

                Section = SectionBuf;

                //
                // there is a loop here for every section in the buffer
                //
                while (*Section) {

                    //
                    // now trying to see if there is a subkey matching section name.
                    //
                    SectionKey = OpenRegKey (KeyHandle, Section);

                    if (SectionKey) {

                        if (!pTransferSectionByKey (
                                FileName,
                                TempPath,
                                Section,
                                SectionKey,
                                &IniFileChanged,
                                UserMode
                                )) {
                            Result = FALSE;
                        }
                        CloseRegKey (SectionKey);
                    }
                    else {

                        SectionValue = GetRegValueString (KeyHandle, Section);

                        if (!SectionValue) {
                            SectionValue = GetRegValueString (KeyHandle, S_EMPTY);
                        }

                        if (SectionValue && (*SectionValue)) {
                            if (!pTransferSectionByValue (
                                    FileName,
                                    TempPath,
                                    Section,
                                    SectionValue,
                                    &IniFileChanged,
                                    UserMode
                                    )) {
                                Result = FALSE;
                            }
                        }

                        if (SectionValue) {
                            MemFree (g_hHeap, 0, SectionValue);
                        }

                    }

                    Section = GetEndOfString (Section) + 1;
                }

            }
            __finally {
                if (SectionBuf) {
                    MemFree (g_hHeap, 0 , SectionBuf);
                }
            }

            //
            // finally, if we made any changes then we will copy the INI file back
            //
            if (IniFileChanged) {

                // flushing the INI file
                WritePrivateProfileString (
                    NULL,
                    NULL,
                    NULL,
                    TempPath
                    );

                if (!CopyFile (TempPath, FullPath, FALSE)) {
                    DEBUGMSG ((DBG_ERROR,"Ini File Mapping : Cannot copy %s to %s", TempPath, FullPath));
                    return FALSE;
                }
            }
        }
        __finally {
            SetFileAttributes (TempPath, FILE_ATTRIBUTE_NORMAL);
            DeleteFile (TempPath);
        }
    }
    __finally {

        if (Attribs != (DWORD)-1) {
            SetFileAttributes (FullPath, Attribs);
        }

        if (FullPath) {
            FreePathString (FullPath);
        }

        SetFileAttributes (TempPath, FILE_ATTRIBUTE_NORMAL);
        DeleteFile (TempPath);

        DEBUGMSG ((DBG_INIFILES, "Processing %s - STOP", FileName));
    }

    return Result;
}


BOOL
pTransferSectionByKey (
    IN      PCTSTR OrigFileName,
    IN      PCTSTR FileName,
    IN      PCTSTR Section,
    IN      HKEY SectionKey,
    IN OUT  BOOL *IniFileChanged,
    IN      BOOL UserMode
    )

/*++

Routine Description:

  This routine transports settings from a specified section of an INI file
  into registry or from the registry to the INI file. If there is a case when
  the settings go from registry to INI file then IniFileChanged is set to TRUE

Arguments:

  FileName - Specifies INI file to be processed
  Section  - Specifies section to be processed
  SectionKey - key associated with this section
  IniFileChanged - Tells the caller that at least one setting was from registry to the INI file
  UserMode - Specifies TRUE if per-user sections are to be processed, or
             FALSE if local machine sections are to be processed.

Return Value:

  TRUE if successful, FALSE if at least one error occured

--*/

{
    PTSTR Key, KeyBuf;
    PTSTR KeyValue;
    PCTSTR SectionValue;
    BOOL ReverseMapping;
    PTSTR ReverseMapValue;

    BOOL Result = TRUE;

    if (!pLoadIniFileBuffer (FileName, Section, NULL, &KeyBuf)) {

        DEBUGMSG ((DBG_ERROR,"Ini File Mapping : Cannot load key buffer for %s in %s", Section, FileName));
        return FALSE;
    }

    __try {
        //
        // now we have all keys of the section and proceeding
        //

        Key = KeyBuf;

        //
        // there is a loop here for every key in the buffer
        //
        while (*Key) {

            //
            // trying to read the value for the key
            //
            if (!pLoadIniFileBuffer (FileName, Section, Key, &KeyValue)) {

                DEBUGMSG ((DBG_ERROR,"Ini File Mapping : Cannot load key %s in %s in %s", Key, Section, FileName));
                Result = FALSE;
                continue;
            }

            __try {

                SectionValue = GetRegValueString (SectionKey, Key);

                if (!SectionValue) {
                    SectionValue = GetRegValueString (SectionKey, S_EMPTY);
                }

                if (SectionValue && (*SectionValue)) {

                    if (!pSaveMappedValue (
                            OrigFileName,
                            Section,
                            Key,
                            SectionValue,
                            KeyValue,
                            &ReverseMapping,
                            &ReverseMapValue,
                            UserMode
                            )) {
                        Result = FALSE;
                    }

                    if (UserMode && ReverseMapping) {
                        if (!WritePrivateProfileString (
                                Section,
                                Key,
                                NULL,
                                FileName
                                )) {
                            DEBUGMSG ((DBG_ERROR,"Ini File Mapping : Cannot erase key %s from %s from %s", Key, Section, OrigFileName));
                            Result = FALSE;
                        }
                        else {
                            *IniFileChanged = TRUE;
                        }
                    }
                    else {
                        if ((ReverseMapping) && (ReverseMapValue)) {

                            // writing the new value
                            if (!WritePrivateProfileString (
                                    Section,
                                    Key,
                                    ReverseMapValue,
                                    FileName
                                    )) {
                                DEBUGMSG ((DBG_ERROR,"Ini File Mapping : Cannot write line %s=%s in %s in %s", Key, ReverseMapValue, Section, FileName));
                                Result = FALSE;
                            }
                            else {
                                *IniFileChanged = TRUE;
                            }
                        }
                    }

                    if (ReverseMapValue) {
                        MemFree (g_hHeap, 0, ReverseMapValue);
                    }
                }

                if (SectionValue) {
                    MemFree (g_hHeap, 0, SectionValue);
                }

            }
            __finally {
                if (KeyValue) {
                    MemFree (g_hHeap, 0, KeyValue);
                }
            }

            Key = GetEndOfString (Key) + 1;
        }

    }
    __finally {
        if (KeyBuf) {
            MemFree (g_hHeap, 0, KeyBuf);
        }
    }

    return Result;
}


BOOL
pTransferSectionByValue (
    IN      PCTSTR OrigFileName,
    IN      PCTSTR FileName,
    IN      PCTSTR Section,
    IN      PCTSTR SectionValue,
    IN OUT  BOOL *IniFileChanged,
    IN      BOOL UserMode
    )

/*++

Routine Description:

  This routine transports settings from a specified section of an INI file
  into registry or from the registry to the INI file. If there is a case when
  the settings go from registry to INI file then IniFileChanged is set to TRUE

Arguments:

  FileName - Specifies INI file to be processed
  Section  - Specifies section to be processed
  SectionValue - ValueName associated with this section
  IniFileChanged - Tells the caller that at least one setting was from registry to the INI file
  UserMode - Specifies TRUE if per-user sections are to be processed, or
             FALSE if local machine sections are to be processed.

Return Value:

  TRUE if successful, FALSE if at least one error occured

--*/

{
    PTSTR Key, KeyBuf;
    PTSTR KeyValue;
    BOOL ReverseMapping;
    PTSTR ReverseMapValue;

    BOOL Result = TRUE;

    if (!pLoadIniFileBuffer (FileName, Section, NULL, &KeyBuf)) {

        DEBUGMSG ((DBG_ERROR,"Ini File Mapping : Cannot load key buffer for %s in %s", Section, FileName));
        return FALSE;
    }

    __try {
        //
        // now we have all keys of the section and proceeding
        //

        Key = KeyBuf;

        //
        // there is a loop here for every key in the buffer
        //
        while (*Key) {

            //
            // trying to read the value for the key
            //
            if (!pLoadIniFileBuffer (FileName, Section, Key, &KeyValue)) {

                DEBUGMSG ((DBG_ERROR,"Ini File Mapping : Cannot load key %s in %s in %s", Key, Section, FileName));
                Result = FALSE;
                continue;
            }

            __try {

                if (!pSaveMappedValue (
                        OrigFileName,
                        Section,
                        Key,
                        SectionValue,
                        KeyValue,
                        &ReverseMapping,
                        &ReverseMapValue,
                        UserMode
                        )) {
                    Result = FALSE;
                }

                if (UserMode && ReverseMapping) {
                    if (!WritePrivateProfileString (
                            Section,
                            Key,
                            NULL,
                            FileName
                            )) {
                        DEBUGMSG ((DBG_ERROR,"Ini File Mapping : Cannot erase key %s from %s from %s", Key, Section, OrigFileName));
                        Result = FALSE;
                    }
                    else {
                        *IniFileChanged = TRUE;
                    }
                }
                else {
                    if ((ReverseMapping) &&(ReverseMapValue)) {

                        // writing the new value
                        if (!WritePrivateProfileString (
                                Section,
                                Key,
                                ReverseMapValue,
                                FileName
                                )) {
                            DEBUGMSG ((DBG_ERROR,"Ini File Mapping : Cannot write line %s=%s in %s in %s", Key, ReverseMapValue, Section, FileName));
                            Result = FALSE;
                        }
                        else {
                            *IniFileChanged = TRUE;
                        }

                    }
                }

                if (ReverseMapValue) {
                    MemFree (g_hHeap, 0, ReverseMapValue);
                }
            }
            __finally {
                if (KeyValue) {
                    MemFree (g_hHeap, 0, KeyValue);
                }
            }

            Key = GetEndOfString (Key) + 1;
        }

    }
    __finally {
        MemFree (g_hHeap, 0, KeyBuf);
    }

    return Result;
}


BOOL
pDoesStrHavePrefix (
    IN OUT  PCTSTR *String,
    IN      PCTSTR Prefix
    )

/*++

Routine Description:

  Simple routine that checks if a specified string has a specified prefix and if so
  advances the string pointer to point exactly after the prefix.

Arguments:

  String - String to be processed
  Prefix - Prefix to be processed

Return Value:

  TRUE if String has Prefix, FALSE otherwise

--*/

{
    UINT Len;

    Len = CharCount (Prefix);
    if (StringIMatchCharCount (*String, Prefix, Len)) {
        *String = CharCountToPointer (*String, Len);
        return TRUE;
    }

    return FALSE;
}


BOOL
pShouldSaveKey (
    IN      PCTSTR OrigFileName,
    IN      PCTSTR Section,
    IN      PCTSTR ValueName,
    IN      PCTSTR RegKey,              OPTIONAL
    IN OUT  BOOL *ReverseMapping,
    IN      BOOL UserMode,
    IN      BOOL ExclusionsOnly
    )

    /*++

Routine Description:

  Simple routine that checks if a setting should go from INI file to registry.
  If the setting is globally suppressed or it's in suppression table returns FALSE

Arguments:

  OrigFileName - Specifies the original Win9x INI file name (not the current one)

  Section - Specifies the section within the INI file

  ValueName - Specifies the key within the INI file section

  RegKey    - Specifies the registry key destination, from the IniFileMapping key;
              optional only if ExclusionsOnly is TRUE

  ReverseMapping - Receives TRUE if the direction of data copy is to go from the
                   NT registry to the INI file; receives FALSE if the direction
                   is from the INI file to the registry

  UserMode - Specifies TRUE to do per-user processing

  ExclusionsOnly - Specifies TRUE if only exclusions should be tested

Return Value:

  TRUE if direction is from INI file to registry, FALSE otherwise

--*/

{
    HKEY key;
    HKEY OldRegRoot = NULL;
    BOOL b = TRUE;
    TCHAR ekey[MEMDB_MAX];
    LONG rc;

    *ReverseMapping = FALSE;
    if (RegKey && IsNtRegObjectSuppressed (RegKey, NULL)) {
        DEBUGMSG ((DBG_NAUSEA, "INI destination is suppressed: %s", RegKey));
        return FALSE;
    }

    //
    // Let's see if this mapping is suppressed
    //
    MemDbBuildKey (
        ekey,
        MEMDB_CATEGORY_SUPPRESS_INI_MAPPINGSW,
        OrigFileName,
        Section,
        ValueName
        );

    if (MemDbGetStoredEndPatternValue (ekey, NULL)) {
        DEBUGMSG ((
            DBG_NAUSEA,
            "INI destination is suppressed: %s\\%s\\%s",
            OrigFileName,
            Section,
            ValueName
            ));
        *ReverseMapping = TRUE;
        return FALSE;
    }

    //
    // If the NT key exists and we don't want to overwrite NT values, reverse
    // the mapping.
    //

    MemDbBuildKey (
        ekey,
        MEMDB_CATEGORY_NO_OVERWRITE_INI_MAPPINGSW,
        OrigFileName,
        Section,
        ValueName
        );

    if (MemDbGetStoredEndPatternValue (ekey, NULL)) {

        if (ExclusionsOnly) {
            return FALSE;
        }

        if (UserMode) {
            OldRegRoot = GetRegRoot();
            SetRegRoot (g_hKeyRootNT);
        }

        key = OpenRegKeyStr (RegKey);

        if (key) {

            rc = RegQueryValueEx (key, ValueName, NULL, NULL, NULL, NULL);

            if (rc == ERROR_SUCCESS) {
                //
                // The NT registry value exists, do not overwrite it.
                // Instead, reverse the mapping so that the INI file
                // gets the NT value.
                //

                DEBUGMSG ((
                    DBG_NAUSEA,
                    "NT value exists; reversing mapping: %s [%s]",
                    RegKey,
                    ValueName
                    ));

                *ReverseMapping = TRUE;

                //
                // don't write the key on return, instead write in INI file
                //
                b = FALSE;
            }

            CloseRegKey (key);
        }

        if (UserMode) {
            SetRegRoot (OldRegRoot);
        }

        return b;
    }

    if (ExclusionsOnly) {
        return TRUE;
    }

    //
    // If Win9x key exists, reverse the mapping (so the Win9x registry setting
    // is used instead of the potentially stale INI file setting)
    //

    if (UserMode) {
        OldRegRoot = GetRegRoot();
        SetRegRoot (g_hKeyRoot95);
    }

    key = OpenRegKeyStr95 (RegKey);

    if (UserMode) {
        SetRegRoot (OldRegRoot);
    }

    if (key != NULL) {
        if (Win95RegQueryValueEx (key, ValueName, NULL, NULL, NULL, NULL) == ERROR_SUCCESS) {
            *ReverseMapping = TRUE;
            DEBUGMSG ((DBG_NAUSEA, "INI destination is suppressed: %s", RegKey));
            b = FALSE;
        }

        CloseRegKey95 (key);
    }

    DEBUGMSG_IF ((b, DBG_NAUSEA, "INI destination is not suppressed: %s", RegKey));

    return b;
}


BOOL
pSaveMappedValue (
    IN      PCTSTR OrigFileName,
    IN      PCTSTR Section,
    IN      PCTSTR ValueName,
    IN      PCTSTR RegPath,
    IN      PCTSTR Value,
    IN OUT  BOOL *ReverseMapping,
    OUT     PTSTR *ReverseMapValue,
    IN      BOOL UserMode
    )

/*++

Routine Description:

  This routine has a valuename and a value that should be saved in a key indicated by RegPath.

Arguments:

  RegPath - Key where setting should be saved
  ValueName - ValueName for the key
  Value - Value for the key
  ReverseMapping - tells the caller that the setting should be saved from registry to INI file
  ReverseMapValue - if ReverseMapping is TRUE that we have the value of the key here
  UserMode - Specifies TRUE if per-user sections are to be processed, or
             FALSE if local machine sections are to be processed.

Return Value:

  TRUE if success, FALSE otherwise

--*/

{
    CHARTYPE ch;
    TCHAR RegKey[MAX_REGISTRY_KEY];
    DWORD rc;
    HKEY SaveKey;
    PCTSTR newValue;
    PTSTR p;

    BOOL Result = TRUE;

    *ReverseMapping = FALSE;
    *ReverseMapValue = NULL;

    //
    // Parse the string
    //

    //
    // Skip past special chars
    //

    while (TRUE) {
        ch = (CHARTYPE)_tcsnextc (RegPath);
        if (ch == TEXT('!') ||
            ch == TEXT('#') ||
            ch == TEXT('@')
            ) {
            RegPath = _tcsinc (RegPath);
        } else {
            break;
        }
    }

    //
    // If SYS:, USR: or \Registry\Machine\ then replace appropriately
    //

    RegKey[0] = 0;

    if (pDoesStrHavePrefix (&RegPath, TEXT("SYS:"))) {
        if (UserMode) {
            return TRUE;
        }

        p = TEXT("HKLM\\SOFTWARE");
    } else if (pDoesStrHavePrefix (&RegPath, TEXT("USR:"))) {
        if (!UserMode) {
            return TRUE;
        }

        p = TEXT("HKR");
    } else if (pDoesStrHavePrefix (&RegPath, TEXT("\\Registry\\Machine\\"))) {
        if (UserMode) {
            return TRUE;
        }

        p = TEXT("HKLM");
    }

    _sntprintf (RegKey, MAX_REGISTRY_KEY, TEXT("%s\\%s"), p, RegPath);

    if (pShouldSaveKey(OrigFileName, Section, ValueName, RegKey, ReverseMapping, UserMode, FALSE)) {


        SaveKey = CreateRegKeyStr (RegKey);
        if (SaveKey) {
            newValue = GetPathStringOnNt (Value);
            rc = RegSetValueEx (
                    SaveKey,
                    ValueName,
                    0,
                    REG_SZ,
                    (PBYTE) newValue,
                    SizeOfString (newValue)
                    );
            CloseRegKey (SaveKey);

            if (rc != ERROR_SUCCESS) {
                SetLastError (rc);

                Result = FALSE;

                DEBUGMSG ((
                    DBG_ERROR,
                    "Process Ini File Mapping: Could not save %s=%s to %s",
                    ValueName,
                    newValue,
                    RegKey
                    ));
            }

            FreePathString (newValue);
        }
        else {
            DEBUGMSG ((DBG_ERROR, "Process Ini File Mapping: Could not create %s", RegKey));
        }
    }
    else {
        if (*ReverseMapping) {

            // trying to open key
            SaveKey = OpenRegKeyStr (RegKey);

            if (SaveKey) {

                *ReverseMapValue = (PTSTR)GetRegValueString (SaveKey, ValueName);

                CloseRegKey (SaveKey);
            }

        }
    }

    return Result;
}



BOOL
pBuildSuppressionTable (
    IN      BOOL UserMode
    )

/*++

Routine Description:

  Loads the "Suppress INI File Mappings" section from "wkstamig.inf" or from "usermig.inf"
  into a stringtable.

Arguments:

  UserMode - Specifies TRUE if section is loaded from usermig.inf
             FALSE if section is loaded from wkstamig.inf
  UserMode

Return Value:

  Always returns TRUE. In case of an error, we are going to log it but returning TRUE
  trying to go on.

--*/

{
    HINF InfHandle;
    TCHAR field[MEMDB_MAX];
    INFCONTEXT context;

    if (UserMode) {
        InfHandle = g_UserMigInf;
    }
    else {
        InfHandle = g_WkstaMigInf;
    }

    if (InfHandle == INVALID_HANDLE_VALUE) {

        DEBUGMSG((DBG_ERROR,"Ini File Mapping : wkstamig.inf or usermig.inf is not loaded"));
        return FALSE;
    }

    if (SetupFindFirstLine (InfHandle, S_SUPPRESS_INI_FILE_MAPPINGS, NULL, &context)) {
        do {
            if (SetupGetStringField (&context, 0, field, MEMDB_MAX, NULL)) {
                MemDbSetValueEx (
                    MEMDB_CATEGORY_SUPPRESS_INI_MAPPINGSW,
                    field,
                    NULL,
                    NULL,
                    0,
                    NULL
                    );
            }
        } while (SetupFindNextLine (&context, &context));
    }

    if (SetupFindFirstLine (InfHandle, S_NO_OVERWRITE_INI_FILE_MAPPINGS, NULL, &context)) {
        do {
            if (SetupGetStringField (&context, 0, field, MEMDB_MAX, NULL)) {
                MemDbSetValueEx (
                    MEMDB_CATEGORY_NO_OVERWRITE_INI_MAPPINGSW,
                    field,
                    NULL,
                    NULL,
                    0,
                    NULL
                    );
            }
        } while (SetupFindNextLine (&context, &context));
    }

    return TRUE;
}


VOID
pFreeSuppressionTable (
    VOID
    )

/*++

Routine Description:

  Simple routine that free the string table if it exists

Arguments:

  none

Return Value:

  none

--*/

{
    MemDbDeleteTree (MEMDB_CATEGORY_SUPPRESS_INI_MAPPINGSW);
    MemDbDeleteTree (MEMDB_CATEGORY_NO_OVERWRITE_INI_MAPPINGSW);
}



enum Separators {
    tab = TEXT('\t'),
    space = TEXT(' '),
    comma = TEXT(','),
    quote = TEXT('\"')
};


BOOL
pAddValue(
    IN OUT  TCHAR **Buffer,
    IN OUT  TCHAR *Value,
    IN      UINT  BufChars
    );

BOOL
pProcessStrValue (
    IN      TCHAR *InBuf,
    OUT     TCHAR *OutBuf,
    IN      UINT BufChars
    );


BOOL
ConvertIniFile (
    IN      PCTSTR IniFilePath
    );


BOOL
pIsDosFullPathPattern (
    IN      PCTSTR String
    )

/*++

Routine Description:

  pIsDosFullPathPattern checks if a string may be a valid DOS full path, i.e.
  a drive letter folowed by a colon and a backslash.

Arguments:

  String - Specifies the string to be tested

Return Value:

  TRUE if the string may represent a valid full DOS path, FALSE if not.

--*/

{
    return String && *String && String[1] == TEXT(':') && String[2] == TEXT('\\');
}


BOOL
ConvertIniFiles (
    VOID
    )

/*++

Routine Description:

  ConvertIniFiles reads in the INI files not listed in IniFileMapping key, and converts every
  full path file name to it's new value if it has been moved during instalation. Calls ConvertIniFile
  for each INI file from Windows directory not listed in IniFileMapping.

  This function is mainly for compatibility with older programs using INI files instead of registry

Arguments:

  none

Return Value:

  TRUE if successful, FALSE if at least one error occured while processing.
  The function will continue even if an error occures while processing a particular ini file
  trying to get the job done as much as possible.

--*/

{
    FILEOP_ENUM fe;
    FILEOP_PROP_ENUM eOpProp;
    MEMDB_ENUM e;
    PCTSTR NtPath;
    PCTSTR filePtr = NULL;
    PCTSTR extPtr = NULL;
    PCTSTR winDirWack = NULL;
    BOOL result = TRUE;

    winDirWack = JoinPaths (g_WinDir, TEXT(""));

    if (EnumFirstPathInOperation (&fe, OPERATION_TEMP_PATH)) {
        do {

            filePtr = GetFileNameFromPath (fe.Path);
            if (!filePtr) {
                continue;
            }
            extPtr = GetFileExtensionFromPath (fe.Path);
            if (!extPtr) {
                continue;
            }
            if (StringIMatch (extPtr, TEXT("INI"))) {

                // this is an INI file that was relocated. Let's process it.

                if (EnumFirstFileOpProperty (&eOpProp, fe.Sequencer, OPERATION_TEMP_PATH)) {

                    // even if Result is false we keep trying to update the file

                    DEBUGMSG ((DBG_INIFILES, "ConvertIniFile: %s (temp=%s)", fe.Path, eOpProp.Property));
                    //
                    // see comments at the beginning of MergeIniFile
                    //
                    if (DoesFileExist (eOpProp.Property)) {
                        if (!ConvertIniFile(eOpProp.Property)) {
                            result = FALSE;
                        }
                    } else {
                        if (EnumNextFileOpProperty (&eOpProp)) {
                            if (!ConvertIniFile(eOpProp.Property)) {
                                result = FALSE;
                            }
                        }
                        ELSE_DEBUGMSG ((
                            DBG_WHOOPS,
                            "ConvertIniFiles: Couldn't get final destination for %s",
                            fe.Path
                            ));
                    }
                }
            }
        } while (EnumNextPathInOperation (&fe));
    }

    FreePathString (winDirWack);

    //
    // also convert all INI files listed in MEMDB_CATEGORY_INIFILES_CONVERT
    //
    if (MemDbGetValueEx (&e, MEMDB_CATEGORY_INIFILES_CONVERT, NULL, NULL)) {
        do {

            NtPath = GetPathStringOnNt (e.szName);

            DEBUGMSG ((DBG_INIFILES, "ConvertIniFile: Nt=%s (Win9x=%s)", NtPath, e.szName));
            if (!ConvertIniFile (NtPath)) {
                result = FALSE;
            }

            FreePathString (NtPath);

        } while (MemDbEnumNextValue (&e));
    }


    if (!result) {
        //
        // we are going to log that at least one error occured while processing IniFileConversion
        //
        DEBUGMSG ((DBG_ERROR, (PCSTR)MSG_INI_FILE_CONVERSION_LOG));

    }

    return TRUE;
}


BOOL
ConvertIniFile (
    IN      PCTSTR IniFilePath
    )

/*++

Routine Description:

  ConvertIniFile reads in the INI file received and converts every full path file name
  to it's new value if it has been moved during instalation.
  It also applies all string substitutions specified in [String Map] section of wkstamig.inf

  This function is called from ConvertIniFiles.

Arguments:

  IniFilePath - Specifies INI file that is to be processed

Return Value:

  TRUE if successful, FALSE if at least one error occured while processing.
  The function will continue even if an error occures while processing a particular ini file
  trying to get the job done as much as possible.

--*/

{
    PTSTR Section = NULL;
    PTSTR SectionBuf = NULL;
    PTSTR SectionDest = NULL;
    PTSTR Key = NULL;
    PTSTR KeyBuf = NULL;
    PTSTR KeyDest = NULL;
    BOOL IniFileChanged = FALSE;
    BOOL Result = TRUE;
    DWORD status;
    TCHAR InValueBuf[MEMDB_MAX];
    TCHAR OutValueBuf[MEMDB_MAX];
    TCHAR TempPath[MEMDB_MAX];
    DWORD Attribs;

    //
    // we want to have ready two full paths:
    // 1. full path to ini file that we are processing (Ex: c:\windows\setup\tmp00001)
    // 2. full path to ini file temporary name while processing (system generated)
    //

    if (!DoesFileExist (IniFilePath)) {
        DEBUGMSG ((DBG_INIFILES, "ConvertIniFile: %s not found", IniFilePath));
        return TRUE;
    }

    if (!GetTempFileName (g_WinDir, TEXT("INI"), 0, TempPath)) {
        DEBUGMSG ((DBG_ERROR,"Convert Ini File : Cannot create a temporary file"));
        return FALSE;
    }

    __try {

        //
        // first of all we copy this INI file to be sure that GetPrivateProfileString function
        // does not map our requests into registry
        //
        if (!CopyFile (IniFilePath, TempPath, FALSE)) {
            DEBUGMSG ((DBG_ERROR,"Convert Ini File : Cannot copy %s to %s", IniFilePath, TempPath));
            Result = FALSE;
            __leave;
        }

        Attribs = GetFileAttributes (TempPath);
        MYASSERT (Attribs != (DWORD)-1);

        SetFileAttributes (TempPath, FILE_ATTRIBUTE_NORMAL);

        //
        // now trying to get section buffer from the INI file
        // We will try to get section buffer in a 1024 bytes buffer. If this is not enough then
        // we will increase buffer size with 1024 and so on.
        //
        if (!pLoadIniFileBuffer (IniFilePath, NULL, NULL, &SectionBuf)) {

            DEBUGMSG ((DBG_ERROR,"Convert Ini File : Cannot load section buffer for %s", IniFilePath));
            Result = FALSE;
            __leave;
        }

        //
        // now we have all sections of the INI file and proceeding
        //
        Section = SectionBuf;
        //
        // there is a loop here for every section in the buffer
        //
        while (*Section) {
            //
            // section name can also contain paths
            //
            if (pIsDosFullPathPattern (Section)) {
                status = GetFileStatusOnNt (Section);
            } else {
                status = FILESTATUS_UNCHANGED;
            }
            if (status & FILESTATUS_DELETED) {
                //
                // delete the whole section
                //
                if (!WritePrivateProfileString (Section, NULL, NULL, TempPath)) {
                    DEBUGMSG ((DBG_ERROR,"Convert Ini File : Cannot delete section %s in %s", Section, IniFilePath));
                    Result = FALSE;
                }
                IniFileChanged = TRUE;

            } else {

                //
                // now trying to get key buffer for this section
                //
                KeyBuf = NULL;
                if (!pLoadIniFileBuffer (IniFilePath, Section, NULL, &KeyBuf)) {
                    DEBUGMSG ((DBG_ERROR,"Convert Ini File : Cannot load key buffer for %s in %s", Section, IniFilePath));
                    Result = FALSE;
                    __leave;
                }

                //
                // section name may contain paths
                //
                SectionDest = Section;

                if (pProcessStrValue (Section, OutValueBuf, MEMDB_MAX)) {
                    //
                    // use this new section name
                    //
                    SectionDest = DuplicateText (OutValueBuf);
                    MYASSERT (SectionDest);
                    IniFileChanged = TRUE;
                    //
                    // delete the whole old section before continuing
                    //
                    if (!WritePrivateProfileString (Section, NULL, NULL, TempPath)) {
                        DEBUGMSG ((DBG_ERROR,"Convert Ini File : Cannot delete section %s in %s", Section, IniFilePath));
                        Result = FALSE;
                    }
                    IniFileChanged = TRUE;
                }

                //
                // now we have all keys from this section and proceeding
                //
                Key = KeyBuf;
                //
                // there is a loop here for every key in the section
                //
                while (*Key) {
                    //
                    // key name can also contain paths
                    //
                    if (pIsDosFullPathPattern (Key)) {
                        status = GetFileStatusOnNt (Key);
                    } else {
                        status = FILESTATUS_UNCHANGED;
                    }
                    if (status & FILESTATUS_DELETED) {
                        //
                        // delete the key
                        //
                        if (!WritePrivateProfileString (SectionDest, Key, NULL, TempPath)) {
                            DEBUGMSG ((DBG_ERROR,"Convert Ini File : Cannot delete key %s in section %s in %s", Key, SectionDest, IniFilePath));
                            Result = FALSE;
                        }
                        IniFileChanged = TRUE;

                    } else {

                        KeyDest = Key;

                        if (pProcessStrValue (Key, OutValueBuf, MEMDB_MAX)) {
                            //
                            // use this new key name
                            //
                            KeyDest = DuplicateText (OutValueBuf);
                            MYASSERT (KeyDest);
                            IniFileChanged = TRUE;
                            //
                            // deleting the previous key
                            //
                            if (!WritePrivateProfileString (
                                    SectionDest,
                                    Key,
                                    NULL,
                                    TempPath
                                    )) {
                                DEBUGMSG ((DBG_ERROR,"Convert Ini File : Cannot delete line %s in %s in %s", Key, SectionDest, IniFilePath));
                                Result = FALSE;
                            }
                        }

                        GetPrivateProfileString(
                            Section,
                            Key,
                            TEXT(""),
                            InValueBuf,
                            MEMDB_MAX,
                            IniFilePath
                            );

                        //
                        // let's see if the key value is a deleted file.
                        // If so, we will simply delete the key.
                        //
                        if (pIsDosFullPathPattern (InValueBuf)) {
                            status = GetFileStatusOnNt (InValueBuf);
                        } else {
                            status = FILESTATUS_UNCHANGED;
                        }
                        if (status & FILESTATUS_DELETED) {
                            //
                            // deleting the old key
                            //
                            if (!WritePrivateProfileString (
                                    SectionDest,
                                    KeyDest,
                                    NULL,
                                    TempPath
                                    )) {
                                DEBUGMSG ((DBG_ERROR,"Convert Ini File : Cannot delete line %s in %s in %s", KeyDest, SectionDest, IniFilePath));
                                Result = FALSE;
                            }
                            IniFileChanged = TRUE;
                        } else {
                            //
                            // now we are going to make a lexical analysis of this value string
                            // to see if there are some candidates (e.g. full path file names)
                            // To find out if there is a full file name we will just see if the second
                            // and the third characters are : respectively \
                            //
                            if (pProcessStrValue (InValueBuf, OutValueBuf, MEMDB_MAX) ||
                                KeyDest != Key ||
                                SectionDest != Section
                                ) {
                                //
                                // writing the new value
                                //
                                if (!WritePrivateProfileString (
                                        SectionDest,
                                        KeyDest,
                                        OutValueBuf,
                                        TempPath
                                        )) {
                                    DEBUGMSG ((DBG_ERROR,"Convert Ini File : Cannot write line %s=%s in %s in %s", KeyDest, OutValueBuf, SectionDest, IniFilePath));
                                    Result = FALSE;
                                }
                                IniFileChanged = TRUE;
                            }
                        }

                        if (KeyDest != Key) {
                            FreeText (KeyDest);
                            KeyDest = NULL;
                        }
                    }

                    Key = GetEndOfString (Key) + 1;
                    KeyDest = NULL;
                }

                if (SectionDest != Section) {
                    FreeText (SectionDest);
                    SectionDest = NULL;
                }
                if (KeyBuf) {
                    MemFree (g_hHeap, 0, KeyBuf);
                    KeyBuf = NULL;
                }
            }

            Section = GetEndOfString (Section) + 1;
            SectionDest = NULL;
        }

        if (SectionBuf) {
            MemFree (g_hHeap, 0, SectionBuf);
            SectionBuf = NULL;
        }

        //
        // finally, if we made any changes then we will copy the INI file back
        //
        if (IniFileChanged) {
            //
            // flushing the INI file
            //
            WritePrivateProfileString (NULL, NULL, NULL, TempPath);

            SetFileAttributes (TempPath, Attribs);
            SetFileAttributes (IniFilePath, FILE_ATTRIBUTE_NORMAL);

            if (!CopyFile (TempPath, IniFilePath, FALSE)) {
                DEBUGMSG ((DBG_ERROR,"Convert Ini File : Cannot copy %s to %s", TempPath, IniFilePath));
                Result = FALSE;
                __leave;
            }
        }
    }
    __finally {

        SetFileAttributes (TempPath, FILE_ATTRIBUTE_NORMAL);
        DeleteFile (TempPath);

        if (KeyDest && KeyDest != Key) {
            FreeText (KeyDest);
            KeyDest = NULL;
        }

        if (SectionDest && SectionDest != Section) {
            FreeText (SectionDest);
            SectionDest = NULL;
        }

        if (KeyBuf) {
            MemFree (g_hHeap, 0, KeyBuf);
            KeyBuf = NULL;
        }

        if (SectionBuf) {
            MemFree (g_hHeap, 0, SectionBuf);
            SectionBuf = NULL;
        }
    }

    return Result;
}


BOOL
pLookupStrValue (
    IN      PCTSTR Value,
    OUT     PTSTR OutBuffer,
    OUT     PINT OutBytes,
    IN      UINT OutBufferSize
    )
{
    if (MappingSearchAndReplaceEx (
            g_CompleteMatchMap,
            Value,
            OutBuffer,
            0,
            OutBytes,
            OutBufferSize,
            STRMAP_COMPLETE_MATCH_ONLY,
            NULL,
            NULL
            )) {
        return TRUE;
    }

    return MappingSearchAndReplaceEx (
                g_SubStringMap,
                Value,
                OutBuffer,
                0,
                OutBytes,
                OutBufferSize,
                STRMAP_ANY_MATCH,
                NULL,
                NULL
                );
}


BOOL
pProcessStrValue (
    IN      TCHAR *InBuf,
    OUT     TCHAR *OutBuf,
    IN      UINT BufChars
    )

/*++

Routine Description:

  Simple lex that identifies lexems separated by comma, space, tab and quote.
  For each lexem calls a function that can change the value of the lexem.
  OBS: When between quote's comma,space and tab are not considered separators

  This function is called from ConvertIniFile.

Arguments:

  InBuf - Specifies buffer to be processed
  OutBuf - Specifies buffer to hold the result
  BufChars - Specifies the size of OutBuf in chars

Return Value:

  TRUE if there was any change.

--*/

{
    TCHAR OrgLexem[MEMDB_MAX];
    TCHAR *Lexem;

    // Status = 0 - initial state
    // Status = 1 - processing a string between quotes
    // Status = 2 - processing a normal string
    INT Status;

    BOOL Result = FALSE;

    //
    // first check to see if the whole string should be replaced;
    // some paths contain spaces, even if they are not between quotes
    //
    Lexem = OutBuf;
    if (pAddValue (&Lexem, InBuf, BufChars)) {
        *Lexem = 0;
        return TRUE;
    }

    Lexem = OrgLexem;

    Status = 0;
    for (;;) {
        *Lexem = 0;
        *OutBuf = 0;
        switch (*InBuf) {
            case 0:

                Result |= pAddValue(&OutBuf, OrgLexem, MEMDB_MAX);
                *OutBuf = 0;
                return Result;

            case quote:

                if (Status == 0) {
                    Status = 1;
                    *OutBuf = *InBuf;
                    InBuf++;
                    OutBuf++;
                    break;
                }

                Result |= pAddValue(&OutBuf, OrgLexem, MEMDB_MAX);
                Lexem = OrgLexem;
                if (Status == 1) {
                    *OutBuf = *InBuf;
                    InBuf++;
                    OutBuf++;
                }
                Status = 0;
                break;

            case space:
            case comma:
            case tab:

                if (Status == 1) {
                    *Lexem = *InBuf;
                    Lexem++;
                    InBuf++;
                    break;
                };

                if (Status == 0) {
                    *OutBuf = *InBuf;
                    InBuf++;
                    OutBuf++;
                    break;
                };

                Result |= pAddValue(&OutBuf, OrgLexem, MEMDB_MAX);
                Lexem = OrgLexem;
                *OutBuf = *InBuf;
                InBuf++;
                OutBuf++;
                Status = 0;
                break;

            default:
                if (Status ==0) {
                    Status = 2;
                };

                *Lexem = *InBuf;
                Lexem++;
                InBuf++;
        }
    }
}


BOOL
pAddValue(
    IN OUT  TCHAR **Buffer,
    IN OUT  TCHAR *Value,
    IN      UINT BufChars
    )

/*++

Routine Description:

  Simple routine that takes a string value, modifies it (or not) and that adds it
  to a buffer.

  This function is called from pProcessStrValue

Arguments:

  Buffer - Specifies buffer to hold the value
  Value  - Specifies the string value to be processed

Return Value:

  TRUE if there was any change.

--*/

{
    DWORD fileStatus;
    PTSTR newValue, Source;
    INT OutBytes;

    BOOL Result = FALSE;

    //
    // replaced (Value[0]) && (!_tcsncmp (Value + 1, TEXT(":\\"), 2)) with the call below
    // for consistency
    //
    if (pIsDosFullPathPattern (Value)) {
        fileStatus = GetFileStatusOnNt (Value);
        if ((fileStatus & FILESTATUS_MOVED) == FILESTATUS_MOVED) {
            Result = TRUE;
            newValue = GetPathStringOnNt (Value);
            //
            // advance outbound pointer
            //
            Source = newValue;
            while (*Source) {
                **Buffer = *Source;
                (*Buffer)++;
                Source++;
            }
            FreePathString (newValue);
        }
    }

    if (!Result) {
        //
        // try to map this sub-string
        //
        if (pLookupStrValue (
                    Value,
                    *Buffer,
                    &OutBytes,
                    BufChars * sizeof (TCHAR)
                    )) {
            Result = TRUE;
            MYASSERT (OutBytes % sizeof (TCHAR) == 0);
            *Buffer += OutBytes / sizeof (TCHAR);
        }
    }

    if (!Result) {
        while (*Value) {
            **Buffer = *Value;
            (*Buffer)++;
            Value++;
        }
    }

    return Result;
}


BOOL
pMoveIniSettingsBySection (
    IN      PCWSTR Section
    )
{
    INFCONTEXT context;
    WCHAR srcData  [MEMDB_MAX];
    WCHAR destData [MEMDB_MAX];
    WCHAR destValue[MEMDB_MAX];
    WCHAR tempPathS[MEMDB_MAX];
    WCHAR tempPathD[MEMDB_MAX];
    INT adnlData = 0;
    LONG value;
    PWSTR valuePtr;
    PCWSTR srcFile;
    PCWSTR srcSect;
    PCWSTR srcKey;
    PCWSTR destFile;
    PCWSTR destSect;
    PCWSTR destKey;
    PWSTR tempPtr;
    PCWSTR srcFullPath = NULL;
    PCWSTR destFullPath = NULL;
    PCWSTR newPath = NULL;
    PTSTR sect, sectionBuf;
    PTSTR key, keyBuf;
    PCWSTR destSectFull;
    PCWSTR destKeyFull;
    BOOL iniFileChanged;
    DWORD result;

    if (SetupFindFirstLine (g_WkstaMigInf, Section, NULL, &context)) {
        do {
            if ((SetupGetStringField (&context, 0, srcData,  MEMDB_MAX, NULL)) &&
                (SetupGetStringField (&context, 1, destData, MEMDB_MAX, NULL))
                ) {
                //
                // We now have a line like : <src INI file>\<src section>\<src key> = <dest INI file>\<dest section>\<dest key>
                //
                __try {
                    *tempPathS = 0;
                    *tempPathD = 0;

                    iniFileChanged = FALSE;

                    srcFile = srcData;

                    tempPtr = wcschr (srcData, L'\\');
                    if (!tempPtr) {
                        __leave;
                    }
                    srcSect = tempPtr + 1;
                    *tempPtr = 0;

                    tempPtr = wcschr (srcSect, L'\\');
                    if (!tempPtr) {
                        __leave;
                    }
                    srcKey = tempPtr + 1;
                    *tempPtr = 0;

                    destFile = destData;

                    tempPtr = wcschr (destData, L'\\');
                    if (!tempPtr) {
                        __leave;
                    }
                    destSect = tempPtr + 1;
                    *tempPtr = 0;

                    tempPtr = wcschr (destSect, L'\\');
                    if (!tempPtr) {
                        __leave;
                    }
                    destKey = tempPtr + 1;
                    *tempPtr = 0;

                    srcFullPath = JoinPaths (g_WinDir, srcFile);

                    newPath = GetTemporaryLocationForFile (srcFullPath);
                    if (newPath) {
                        DEBUGMSG ((DBG_MOVEINISETTINGS, "Using %s for %s", newPath, srcFullPath));
                        FreePathString (srcFullPath);
                        srcFullPath = newPath;
                    }

                    if (!DoesFileExist (srcFullPath)) {
                        DEBUGMSG ((DBG_INIFILES, "pMoveIniSettingsBySection: %s not found", srcFullPath));
                        __leave;
                    }

                    destFullPath = JoinPaths (g_WinDir, destFile);

                    newPath = GetTemporaryLocationForFile (destFullPath);
                    if (newPath) {
                        DEBUGMSG ((DBG_MOVEINISETTINGS, "pMoveIniSettingsBySection: Using %s for %s", newPath, destFullPath));
                        FreePathString (destFullPath);
                        destFullPath = newPath;
                    }

                    // Copy Source File to a temporary location to avoid registry mapping
                    if (!GetTempFileName (g_WinDir, TEXT("INI"), 0, tempPathS)) {
                        DEBUGMSG ((DBG_ERROR,"pMoveIniSettingsBySection: Cannot create a temporary file"));
                        __leave;
                    }
                    if (!CopyFile (srcFullPath, tempPathS, FALSE)) {
                        DEBUGMSG ((DBG_ERROR,"pMoveIniSettingsBySection: Cannot copy %s to %s", srcFullPath, tempPathS));
                        __leave;
                    }

                    // Copy Destination File to a temporary location to avoid registry mapping
                    if (!GetTempFileName (g_WinDir, TEXT("INI"), 0, tempPathD)) {
                        DEBUGMSG ((DBG_ERROR,"pMoveIniSettingsBySection: Cannot create a temporary file"));
                        __leave;
                    }
                    if (!CopyFile (destFullPath, tempPathD, FALSE)) {
                        DEBUGMSG ((DBG_INIFILES,"pMoveIniSettingsBySection: Cannot copy %s to %s", destFullPath, tempPathD));
                    }

                    // if we have an additional field we use it for dividing the key values (if they are numbers)
                    if (!SetupGetIntField (&context, 3, &adnlData)) {
                        adnlData = 0;
                    }
                    //
                    // Next thing we are going to do is to load the sections in a buffer
                    //

                    if (!pLoadIniFileBuffer (tempPathS, NULL, NULL, &sectionBuf)) {

                        DEBUGMSG ((DBG_ERROR,"pMoveIniSettingsBySection: Cannot load section buffer for %s (%s)", tempPathS, srcFullPath));
                        __leave;
                    }

                    //
                    // now walk through each section
                    //
                    __try {
                        sect = sectionBuf;

                        //
                        // there is a loop here for every section in the buffer
                        //
                        while (*sect) {
                            if (IsPatternMatch (srcSect, sect)) {

                                //
                                // Next thing we are going to do is to load the keys in a buffer
                                //

                                if (!pLoadIniFileBuffer (tempPathS, sect, NULL, &keyBuf)) {

                                    DEBUGMSG ((DBG_ERROR,"pMoveIniSettingsBySection: Cannot load key buffer for %s in %s (%s)", sect, tempPathS, srcFullPath));
                                    __leave;
                                }

                                __try {
                                    //
                                    // now we have all keys of the section and proceeding
                                    //

                                    key = keyBuf;

                                    //
                                    // there is a loop here for every key in the buffer
                                    //
                                    while (*key) {

                                        if (IsPatternMatch (srcKey, key)) {

                                            result = GetPrivateProfileString (
                                                        sect,
                                                        key,
                                                        TEXT(""),
                                                        destValue,
                                                        MEMDB_MAX,
                                                        tempPathS);
                                            if ((result == 0) ||
                                                (result + 1 == MEMDB_MAX)
                                                ) {
                                                DEBUGMSG ((
                                                    DBG_MOVEINISETTINGS,
                                                    "pMoveIniSettingsBySection: Cannot read value for %s in %s in %s (%s)",
                                                    key,
                                                    sect,
                                                    tempPathS,
                                                    srcFullPath
                                                    ));
                                            } else {
                                                if (adnlData) {
                                                    value = wcstol (destValue, &valuePtr, 10);
                                                    if (*valuePtr == 0) {
                                                        value = value / adnlData;
                                                        wsprintf (destValue, L"%d", value);
                                                    }
                                                }

                                                destSectFull  = StringSearchAndReplace (destSect, L"*", sect);
                                                if (!destSectFull) {
                                                    destSectFull = DuplicatePathString (destSect,0);
                                                }
                                                destKeyFull   = StringSearchAndReplace (destKey,  L"*", key);
                                                if (!destKeyFull) {
                                                    destKeyFull = DuplicatePathString (destKey,0);
                                                }

                                                iniFileChanged = TRUE;

                                                // writing the new value
                                                if (!WritePrivateProfileString (
                                                        destSectFull,
                                                        destKeyFull,
                                                        destValue,
                                                        tempPathD
                                                        )) {
                                                    DEBUGMSG ((
                                                        DBG_ERROR,
                                                        "Ini File Move : Cannot write line %s=%s in %s in %s (%s)",
                                                        destKeyFull,
                                                        destValue,
                                                        destSectFull,
                                                        tempPathD,
                                                        destFullPath
                                                        ));
                                                    FreePathString (destSectFull);
                                                    FreePathString (destKeyFull);
                                                    __leave;
                                                }
                                                FreePathString (destSectFull);
                                                FreePathString (destKeyFull);
                                            }
                                        }

                                        key = GetEndOfString (key) + 1;
                                    }
                                }
                                __finally {
                                    if (keyBuf) {
                                        MemFree (g_hHeap, 0 , keyBuf);
                                    }
                                }
                            }
                            sect = GetEndOfString (sect) + 1;
                        }
                    }
                    __finally {
                        if (sectionBuf) {
                            MemFree (g_hHeap, 0 , sectionBuf);
                        }
                    }
                    if (iniFileChanged) {
                        // flushing the INI file
                        WritePrivateProfileString (
                            NULL,
                            NULL,
                            NULL,
                            tempPathD
                            );

                        if (!CopyFile (tempPathD, destFullPath, FALSE)) {
                            DEBUGMSG ((DBG_ERROR,"Ini File Move : Cannot copy %s to %s", tempPathD, destFullPath));
                            __leave;
                        }
                    }
                }
                __finally {
                    if (srcFullPath) {
                        FreePathString (srcFullPath);
                        srcFullPath = NULL;
                    }

                    if (destFullPath) {
                        FreePathString (destFullPath);
                        destFullPath = NULL;
                    }

                    if (*tempPathS) {
                        SetFileAttributes (tempPathS, FILE_ATTRIBUTE_NORMAL);
                        DeleteFile (tempPathS);
                    }
                    if (*tempPathD) {
                        SetFileAttributes (tempPathD, FILE_ATTRIBUTE_NORMAL);
                        DeleteFile (tempPathD);
                    }
                }
            }
        } while (SetupFindNextLine (&context, &context));
    }

    return TRUE;
}


BOOL
MoveIniSettings (
    VOID
    )

/*++

Routine Description:

  There are a number of settings that needs to be moved from one INI file to another during setup.
  There is a section called "MoveIniSettings" in wkstamig.inf that lists those settings.
  The format is <INI file (in %WinDir%)>\section\key = <INI file (in %winDir%)>\section\key
  You can use pattern matching is section and key (INI file must be specified in full).
  The only wild character supported in right term is * and is going to be replaced by the equivalent
  left term. For example if you specify:
    foo.ini\FooSect\FooKey = bar.ini\*\*
  then the FooKey key from FooSect section from foo.ini is going to be moved to bar.ini. This is useful
  to move a whole section :
    foo.ini\FooSect\* = bar.ini\*\*

  We are going to use Get/WritePrivateProfileString because we want that all the settings to be mapped
  into the registry is it's the case (this routine is called after IniFileMapping routine).

  This routine is called before IniFileConversion routine so the moved settings are Win95 ones.

Arguments:

  None

Return Value:

  FALSE if any error occured.

--*/

{
    WCHAR codePageStr [20] = L"";
    PWSTR codePageSection = NULL;

    MYASSERT (g_WkstaMigInf != INVALID_HANDLE_VALUE);

    pMoveIniSettingsBySection (S_MOVEINISETTINGS);

    _itow (OurGetACP (), codePageStr, 10);

    codePageSection = JoinTextEx (NULL, S_MOVEINISETTINGS, codePageStr, L".", 0, NULL);

    pMoveIniSettingsBySection (codePageSection);

    FreeText (codePageSection);

    return TRUE;
}


BOOL
MergeIniSettings (
    VOID
    )
{
    FILEOP_ENUM fe;
    FILEOP_PROP_ENUM eOpProp;
    PCTSTR filePtr;
    PCTSTR extPtr;
    PCTSTR winDirWack;
    PCTSTR NtPath;
    BOOL Win9xPriority;
    BOOL result = TRUE;

    //
    // Process INI files that were moved to temporary dir
    //

    winDirWack = JoinPaths (g_WinDir, TEXT(""));

    if (EnumFirstPathInOperation (&fe, OPERATION_TEMP_PATH)) {
        do {

            if (!pBuildSuppressionTable(FALSE)) {
                result = FALSE;
            }

            // Special case : SHELL= line from SYSTEM.INI
            // We try to see if the current shell is supported on NT.
            // If not then we will add SHELL to this suppression table
            // ensuring that the NT registry setting will get mapped into
            // the INI file
            if (pIncompatibleShell()) {
                MemDbSetValueEx (
                    MEMDB_CATEGORY_SUPPRESS_INI_MAPPINGSW,
                    TEXT("SYSTEM.INI"),
                    TEXT("BOOT"),
                    TEXT("SHELL"),
                    0,
                    NULL
                    );
            }

            filePtr = GetFileNameFromPath (fe.Path);
            if (!filePtr) {
                continue;
            }
            extPtr = GetFileExtensionFromPath (fe.Path);
            if (!extPtr) {
                continue;
            }
            if (StringIMatch (extPtr, TEXT("INI"))) {

                // this is an INI file that was relocated. Let's process it.

                if (EnumFirstFileOpProperty (&eOpProp, fe.Sequencer, OPERATION_TEMP_PATH)) {

                    if (StringIMatch (filePtr, TEXT("desktop.ini"))) {
                        Win9xPriority = FALSE;
                    } else {
                        Win9xPriority = !StringIMatchAB (winDirWack, fe.Path, filePtr);
                    }

                    NtPath = GetPathStringOnNt (fe.Path);

                    if (!MergeIniFile(NtPath, eOpProp.Property, Win9xPriority)) {
                        result = FALSE;
                    }

                    FreePathString (NtPath);
                }
            }
        } while (EnumNextPathInOperation (&fe));

        pFreeSuppressionTable();

    }

    FreePathString (winDirWack);

    return TRUE;
}


PTSTR
pMapIniSectionKeyToRegistryKey (
    IN      PCTSTR FileName,
    IN      PCTSTR Section,
    IN      PCTSTR Key
    )
{
    CHARTYPE ch;
    TCHAR RegKey[MAX_REGISTRY_KEY] = S_EMPTY;
    DWORD rc;
    HKEY key, sectKey;
    PTSTR keyStr;
    PTSTR regPath;
    PTSTR data = NULL;
    PTSTR p;

    keyStr = JoinPaths (S_INIFILEMAPPING_KEY, FileName);

    __try {

        key = OpenRegKeyStr (keyStr);
        if (!key) {
            __leave;
        }

        sectKey = OpenRegKey (key, Section);

        if (sectKey) {
            data = GetRegValueString (sectKey, Key);
            if (!data) {
                data = GetRegValueString (sectKey, S_EMPTY);
            }
            CloseRegKey (sectKey);
        } else {
            data = GetRegValueString (key, Section);
            if (!data) {
                data = GetRegValueString (key, S_EMPTY);
            }
        }

        if (data) {
            //
            // convert it to a reg key string
            //
            regPath = data;

            //
            // Skip past special chars
            //
            while (TRUE) {
                ch = (CHARTYPE)_tcsnextc (regPath);
                if (ch == TEXT('!') ||
                    ch == TEXT('#') ||
                    ch == TEXT('@')
                    ) {
                    regPath = _tcsinc (regPath);
                } else {
                    break;
                }
            }

            //
            // If SYS:, USR: or \Registry\Machine\ then replace appropriately
            //
            if (pDoesStrHavePrefix (&regPath, TEXT("SYS:"))) {
                p = TEXT("HKLM\\SOFTWARE");
            } else if (pDoesStrHavePrefix (&regPath, TEXT("USR:"))) {
                p = TEXT("HKR");
            } else if (pDoesStrHavePrefix (&regPath, TEXT("\\Registry\\Machine\\"))) {
                p = TEXT("HKLM");
            }

            _sntprintf (RegKey, MAX_REGISTRY_KEY, TEXT("%s\\%s"), p, regPath);
        }
    }
    __finally {
        if (key) {
            CloseRegKey (key);
        }
        if (data) {
            MemFree (g_hHeap, 0, data);
        }
        FreePathString (keyStr);
        keyStr = NULL;
    }

    if (RegKey[0]) {
        keyStr = DuplicateText (RegKey);
    }

    return keyStr;
}

BOOL
MergeIniFile (
    IN      PCTSTR FileNtLocation,
    IN      PCTSTR FileTempLocation,
    IN      BOOL TempHasPriority
    )
{
    TCHAR TempPath[MEMDB_MAX];
    TCHAR srcValue[MEMDB_MAX];
    TCHAR destValue[MEMDB_MAX];
    DWORD Attribs = -1;

    PTSTR Section, SectionBuf;
    PTSTR Key, KeyBuf;

    BOOL Result = TRUE;
    BOOL IniFileChanged = FALSE;
    PTSTR regKey;
    PTSTR p;
    PCTSTR fileName;

    //
    // sometimes, textmode setup doesn't move files from other drives to Windows drive,
    // probably because textmode setup drive mapping doesn't match Win9x drive mappings.
    // It's possible that the INI file hasn't actually been moved, so in this case there
    // is nothing to do
    // There is no data loss, since the file is actually not moved and it's converted
    // in place in ConvertIniFiles
    //
    if (*g_WinDir != *FileNtLocation &&
        !DoesFileExist (FileTempLocation) &&
        DoesFileExist (FileNtLocation)
        ) {
        //
        // done, file is already in place
        //
        return TRUE;
    }
    //
    // some desktop.ini are located in temp internet dirs that were removed
    // when Win9x was shutting down; ignore these files
    //
    if (!DoesFileExist (FileTempLocation)) {
        if (!StringIMatch (GetFileNameFromPath (FileNtLocation), TEXT("desktop.ini"))) {
            DEBUGMSG ((DBG_ERROR, "MergeIniFile: File does not exist: %s (Nt=%s)", FileTempLocation, FileNtLocation));
            return FALSE;
        }
        return TRUE;
    }
    if (!DoesFileExist (FileNtLocation)) {
        //
        // just copy back to the original file
        // if the file belongs to a directory that NT doesn't install,
        // create it now
        //

        StackStringCopy (TempPath, FileNtLocation);
        p = _tcsrchr (TempPath, TEXT('\\'));
        if (p) {
            *p = 0;

            if (GetFileAttributes (TempPath) == (DWORD)-1) {
                MakeSurePathExists (TempPath, TRUE);
            }
        }

        if (!CopyFile (FileTempLocation, FileNtLocation, FALSE)) {
            DEBUGMSG ((DBG_ERROR,"MergeIniFile: Cannot copy %s to %s", FileTempLocation, FileNtLocation));
            return FALSE;
        }

        return TRUE;
    }
    if (!GetTempFileName (g_WinDir, TEXT("INI"), 0, TempPath)) {
        DEBUGMSG ((DBG_ERROR,"Merge Ini File : Cannot create a temporary file"));
        return FALSE;
    }

    __try {

        //
        // first of all we copy this INI file to be sure that GetPrivateProfileString function
        // does not map our requests into registry
        //
        if (!CopyFile (FileTempLocation, TempPath, FALSE)) {
            DEBUGMSG ((DBG_ERROR,"Merge Ini File : Cannot copy %s to %s", FileTempLocation, TempPath));
            Result = FALSE;
            __leave;
        }

        Attribs = GetFileAttributes (FileNtLocation);
        SetFileAttributes (FileNtLocation, FILE_ATTRIBUTE_NORMAL);
        MYASSERT (Attribs != (DWORD)-1);

        //
        // now trying to get section buffer from the INI file
        // We will try to get section buffer in a 1024 bytes buffer. If this is not enough then
        // we will increase buffer size with 1024 and so on.
        //

        if (!pLoadIniFileBuffer (TempPath, NULL, NULL, &SectionBuf)) {

            DEBUGMSG ((DBG_ERROR,"Merge Ini File : Cannot load section buffer for %s",TempPath));
            Result = FALSE;
            __leave;
        }

        fileName = GetFileNameFromPath (FileNtLocation);
        if (!fileName) {
            Result = FALSE;
            __leave;
        }

        __try {

            //
            // now we have all sections of the INI file and proceeding
            //

            Section = SectionBuf;

            //
            // there is a loop here for every section in the buffer
            //
            while (*Section) {

                //
                // now trying to get key buffer for this section
                //

                if (!pLoadIniFileBuffer (TempPath, Section, NULL, &KeyBuf)) {

                    DEBUGMSG ((DBG_ERROR,"Merge Ini File : Cannot load key buffer for %s in %s", Section, TempPath));
                    Result = FALSE;
                    continue;
                }

                __try {

                    //
                    // now we have all keys from this section and proceeding
                    //
                    Key = KeyBuf;

                    //
                    // there is a loop here for every key in the section
                    //
                    while (*Key) {
                        BOOL unused;

                        //
                        // build the corresponding registry key
                        //
                        regKey = pMapIniSectionKeyToRegistryKey (fileName, Section, Key);

                        if (pShouldSaveKey (fileName, Section, Key, regKey, &unused, FALSE, TRUE)) {

                            GetPrivateProfileString(
                                Section,
                                Key,
                                TEXT(""),
                                srcValue,
                                MEMDB_MAX,
                                TempPath
                                );

                            GetPrivateProfileString(
                                Section,
                                Key,
                                TEXT(""),
                                destValue,
                                MEMDB_MAX,
                                FileNtLocation
                                );

                            if (*srcValue && !*destValue ||
                                TempHasPriority && !StringMatch (srcValue, destValue)) {

                                IniFileChanged = TRUE;

                                // writing the new value
                                if (!WritePrivateProfileString (
                                        Section,
                                        Key,
                                        srcValue,
                                        FileNtLocation
                                        )) {
                                    DEBUGMSG ((DBG_ERROR,"Merge Ini File : Cannot write line %s=%s in %s in %s", Key, srcValue, Section, FileNtLocation));
                                    Result = FALSE;
                                }
                            }
                        }
                        ELSE_DEBUGMSG ((
                            DBG_VERBOSE,
                            "Merge Ini File : Suppressing key %s in section %s of %s",
                            Key,
                            Section,
                            FileNtLocation
                            ));

                        FreeText (regKey);

                        Key = GetEndOfString (Key) + 1;
                    }

                }
                __finally {
                    if (KeyBuf) {
                        MemFree (g_hHeap, 0, KeyBuf);
                    }
                }

                Section = GetEndOfString (Section) + 1;
            }

        }
        __finally {
            if (SectionBuf) {
                MemFree (g_hHeap, 0, SectionBuf);
            }
        }

        //
        // finally, if we made any changes then we will copy the INI file back
        //
        if (IniFileChanged) {

            // flushing the INI file
            WritePrivateProfileString (
                NULL,
                NULL,
                NULL,
                FileNtLocation
                );

        }
    }
    __finally {

        if (Attribs != (DWORD)-1) {
            SetFileAttributes (FileNtLocation, Attribs);
        }

        SetFileAttributes (TempPath, FILE_ATTRIBUTE_NORMAL);
        DeleteFile (TempPath);
    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\migmain\infkey.c ===
BOOL
pSetupGetKey (
    IN      PINFCONTEXT pic,
    OUT     PTSTR KeyBuf,
    OUT     PBOOL KeyExistsOnLine
    )

/*++

Routine Description:

  pSetupGetKey copies the key for the specified INF context.  If
  a key does not exist, then KeyBuf is reset.

Arguments:

  pic - Specifies the INFCONTEXT that indicates which line to query

  KeyBuf - Receives the key, or is emptied of there is no key

  KeyExistsOnLine - Receives TRUE if the line has a key, or FALSE if not.

Return Value:

  TRUE if successful, FALSE if not.

--*/

{
    UINT KeySize;
    PTSTR TempKeyBuf;
    PTSTR TempLineBuf;
    UINT LineSize;

    //
    // Get the key (if it exists)
    //

    *KeyExistsOnLine = FALSE;
    if (!SetupGetStringField (pic, 0, NULL, 0, &KeySize)) {
        //
        // Key does not exist
        //

        KeyBuf[0] = 0;
        return TRUE;
    }

    //
    // Use the caller's buffer if it is big enough
    //

    KeySize *= sizeof (TCHAR);
    if (KeySize >= MAX_KEY * sizeof (TCHAR)) {
        TempKeyBuf = (PTSTR) MemAlloc (g_hHeap, 0, KeySize);
        if (!TempKeyBuf) {
            LOG ((LOG_ERROR, "Setup Get Key: Could not allocate temp buffer"));
            return FALSE;
        }
    } else {
        TempKeyBuf = KeyBuf;
    }

    __try {
        if (!SetupGetStringField (pic, 0, TempKeyBuf, KeySize, NULL)) {
            DEBUGMSG ((DBG_WHOOPS, "pSetupGetKey: Could not read specified INF line"));
            return FALSE;
        }

        //
        // Get the line and compare against the key
        //

        if (SetupGetLineText (pic, NULL, NULL, NULL, NULL, 0, &LineSize)) {
            //
            // If the sizes are the same, we must actually get the text, then
            // compare the key against the line
            //

            LineSize *= sizeof (TCHAR);

            if (LineSize == KeySize) {
                TempLineBuf = (PTSTR) MemAlloc (g_hHeap, 0, LineSize);
                if (!TempLineBuf) {
                    LOG ((LOG_ERROR, "Setup Get Key: Could not allocate line buffer"));
                    return FALSE;
                }

                __try {
                    if (!SetupGetLineText (pic, NULL, NULL, NULL, TempLineBuf, LineSize, NULL)) {
                        DEBUGMSG ((DBG_WHOOPS, "pSetupGetKey: Could not get line text"));
                        return FALSE;
                    }

                    if (!StringCompare (TempLineBuf, TempKeyBuf)) {
                        //
                        // There is no key for this line
                        //

                        TempKeyBuf[0] = 0;
                    } else {
                        //
                        // There is a key for this line
                        //
                        *KeyExistsOnLine = TRUE;
                    }
                }
                __finally {
                    MemFree (g_hHeap, 0, TempLineBuf);
                }
            } else {
                //
                // Since the sizes are different, we know there is a key
                //
                *KeyExistsOnLine = TRUE;
            }
        }

        //
        // If we were not using the caller's buffer, copy as much of the
        // key as will fit
        //

        if (TempKeyBuf != KeyBuf) {
            _tcssafecpy (KeyBuf, TempKeyBuf, MAX_KEY);
        }
    }
    __finally {
        if (TempKeyBuf != KeyBuf) {
            MemFree (g_hHeap, 0, TempKeyBuf);
        }
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\migmain\iniact.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    iniact.c

Abstract:

    This module contains the implementation of the engine and actions on INI files.
    To add a new INI action, just add it to wkstamig.inf or usermig.inf, add it to
    INI_ACTIONS macro list and implement a function with the same name having
    FNINIACT prototype.

Author:

    Ovidiu Temereanca (ovidiut) 07-May-1999

Environment:

    GUI mode Setup.

Revision History:

    07-May-1999     ovidiut Creation and initial implementation.

--*/


//
// includes
//
#include "pch.h"
#include "migmainp.h"


#ifdef DEBUG
#define DBG_INIACT  "IniAct"
#endif

//
// GUID Format: {%08lX-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}
// we care about the exact length of this string
//
#define GUIDSTR_LEN (1 + 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1)
#define DASH_INDEXES      1+8, 1+8+1+4, 1+8+1+4+1+4, 1+8+1+4+1+4+1+4

//
// Add a macro here with an INI Action function name and implement it.
// Make sure wkstamig.inf or usermig.inf use the same function name in [INI Files Actions].
// See FNINIACT definition for the function prototype
//
#define INI_ACTIONS                 \
    DEFMAC (MigrateDesktopIniSCI)   \
    DEFMAC (MigrateDesktopIniESFV)  \

//
// Private prototypes
//

//
// description of rule's settings
//
typedef struct {
    //
    // INI file specification, as appears in INF files (Field 1)
    //
    PCTSTR      IniSpec;
    //
    // Section specified in INF (Field 2)
    //
    PCTSTR      Section;
    //
    // Key specified in INF (Field 3)
    //
    PCTSTR      Key;
    //
    // Data specified in INF (Field 4)
    //
    PCTSTR      Data;
    //
    // Function-dependent strings defined in INF;
    // all strings from section named in Field 5
    // the strings are double-zero terminated
    //
    GROWBUFFER  Settings;
} RULEATTRIBS, *PRULEATTRIBS;


//
// description of an INI file (original, actual, NT location)
//
typedef struct {
    //
    // original (Win9x) INI file location
    //
    PCTSTR      OrigIniPath;
    //
    // actual INI file location (it was copied to a temp location)
    //
    PCTSTR      ActualLocation;
    //
    // NT file location; it may be different than Win9x location
    //
    PCTSTR      NtIniPath;
} INIFILE, *PINIFILE;


//
// the prototype of an INI file processing function
//
typedef BOOL (FNINIACT) (
                IN      PRULEATTRIBS RuleAttribs,
                IN      PINIFILE IniFile
                );

typedef FNINIACT* PFNINIACT;


//
// description of an INI action (there is a list of actions)
//
typedef struct _INIACT {
    //
    // it's a list of actions
    //
    struct _INIACT*   Next;
    //
    // processing function name (Key field in INF)
    //
    PCTSTR          FnName;
    //
    // a pointer to the processing function
    //
    PFNINIACT       FnIniAct;
    //
    // the attributes of this rule as defined in INF + context
    //
    RULEATTRIBS     RuleAttribs;
} INIACT, *PINIACT;


//
// this serves as a map from function name to function pointer
//
typedef struct {
    PCTSTR      FnName;
    PFNINIACT   Fn;
} INIACTMAP, *PINIACTMAP;


//
// global data
//

//
// memory pool used by IniActions
//
static POOLHANDLE g_IniActPool = NULL;
//
// the list of rules
//
static PINIACT g_IniActHead = NULL, g_IniActTail = NULL;

//
// function declarations
//
#define DEFMAC(Name)    FNINIACT Name;

INI_ACTIONS

#undef DEFMAC

//
// map function name -> function pointer
//
#define DEFMAC(Name)    TEXT(#Name), Name,

static INIACTMAP g_IniActionsMapping[] = {
    INI_ACTIONS
    NULL, NULL
};

#undef DEFMAC


BOOL
pLookupRuleFn (
    IN OUT  PINIACT IniAct
    )

/*++

Routine Description:

  pLookupRuleFn tries to find the function specified in IniAct->FnName and put the pointer
  in IniAct->FnIniAct. It will look in the global map g_IniActionsMapping.

Arguments:

  IniAct - Specifies the function name and receives the function pointer.

Return Value:

  TRUE if the function was found, FALSE otherwise

--*/

{
    INT i;

    for (i = 0; g_IniActionsMapping[i].FnName; i++) {
        if (StringMatch (g_IniActionsMapping[i].FnName, IniAct->FnName)) {
            IniAct->FnIniAct = g_IniActionsMapping[i].Fn;
            return TRUE;
        }
    }

    return FALSE;
}


PCTSTR
pGetNextMultiSzString (
    IN      PCTSTR Str
    )

/*++

Routine Description:

  pGetNextMultiSzString skips over the string specified to get to the next string,
  assumed to be in contiguous memory.

Arguments:

  Str - Specifies the string to skip over

Return Value:

  A pointer to the caracter following the string (starting of the next one).

--*/

{
    return (PCTSTR) (((PBYTE)Str) + SizeOfString (Str));
}


VOID
pGetRuleSectionSettings (
    IN OUT  PINIACT IniAct,
    IN      HINF Inf,
    IN      PCTSTR Section
    )

/*++

Routine Description:

  pGetRuleSectionSettings reads all settings from specified Inf file and
  specified section and appends them to IniAct->RuleAttribs.Settings

Arguments:

  IniAct - Receives the strings read

  Inf - Specifies the source INF file

  Section - Specifies the section containing the strings

Return Value:

  none

--*/

{
    INFCONTEXT ctx;
    TCHAR field[MEMDB_MAX];

    if (SetupFindFirstLine (Inf, Section, NULL, &ctx)) {
        do {
            if (SetupGetStringField (&ctx, 0, field, MEMDB_MAX, NULL)) {
                MultiSzAppend (&IniAct->RuleAttribs.Settings, field);
            }
        } while (SetupFindNextLine (&ctx, &ctx));
    }
}


BOOL
pGetIniActData (
    IN OUT  PINFCONTEXT ctx,
    OUT     PINIACT IniAct
    )

/*++

Routine Description:

  pGetIniActData reads all rule settings from the specified INF context
  and puts them in IniAct

Arguments:

  ctx - Specifies the INF context containing the attributes of this rule;
        receives new context data

  IniAct - Receives the data read

Return Value:

  TRUE if attributes read are valid and they make up a valid rule

--*/

{
    TCHAR field[MEMDB_MAX];
    TCHAR FileSpec[MAX_PATH];

    if (!(SetupGetStringField (ctx, 0, field, MEMDB_MAX, NULL) && field[0])) {
        DEBUGMSG ((
            DBG_ASSERT,
            "pGetIniActData: couldn't get function name in Wkstamig.inf"
            ));
        MYASSERT (FALSE);
        return FALSE;
    }
    IniAct->FnName = DuplicateText (field);

    //
    // lookup handling function
    //
    if (!pLookupRuleFn (IniAct)) {
        DEBUGMSG ((
            DBG_ASSERT,
            "pGetIniActData: couldn't find implementation of function [%s] in Wkstamig.inf",
            IniAct->FnName
            ));
        MYASSERT (FALSE);
        return FALSE;
    }

    if (!(SetupGetStringField (ctx, 1, field, MEMDB_MAX, NULL) && field[0])) {
        DEBUGMSG ((
            DBG_ASSERT,
            "pGetIniActData: couldn't get INI file spec in Wkstamig.inf"
            ));
        MYASSERT (FALSE);
        return FALSE;
    }
    //
    // expand env vars first
    //
    if (ExpandEnvironmentStrings (field, FileSpec, MAX_PATH) <= MAX_PATH) {
        //
        // there shouldn't be any % left
        //
        if (_tcschr (FileSpec, TEXT('%'))) {
            DEBUGMSG ((
                DBG_ASSERT,
                "pGetIniActData: invalid INI file spec in Wkstamig.inf"
                ));
            MYASSERT (FALSE);
            return FALSE;
        }
    } else {
        DEBUGMSG ((
            DBG_ASSERT,
            "pGetIniActData: INI file spec too long in Wkstamig.inf"
            ));
        MYASSERT (FALSE);
        return FALSE;
    }
    IniAct->RuleAttribs.IniSpec = DuplicateText (FileSpec);

    //
    // rest of fields are optional
    //
    if (SetupGetStringField (ctx, 2, field, MEMDB_MAX, NULL) && field[0]) {
        IniAct->RuleAttribs.Section = DuplicateText (field);
    }

    if (SetupGetStringField (ctx, 3, field, MEMDB_MAX, NULL) && field[0]) {
        IniAct->RuleAttribs.Key = DuplicateText (field);
    }

    if (SetupGetStringField (ctx, 4, field, MEMDB_MAX, NULL) && field[0]) {
        IniAct->RuleAttribs.Data = DuplicateText (field);
    }

    if (SetupGetStringField (ctx, 5, field, MEMDB_MAX, NULL) && field[0]) {
        //
        // this is actually a section name in the same INF file
        // read its contents and make a multisz string with them
        //
        pGetRuleSectionSettings (IniAct, ctx->Inf, field);
    }

    return TRUE;
}


VOID
pCleanUpIniAction (
    IN OUT  PINIACT IniAct
    )

/*++

Routine Description:

  pCleanUpIniAction frees all resources associated with the given IniAct

Arguments:

  IniAct - Specifies the action to be "emptied"; all resources are freed

Return Value:

  none

--*/

{
    FreeText (IniAct->FnName);
    IniAct->FnName = NULL;

    FreeText (IniAct->RuleAttribs.IniSpec);
    FreeText (IniAct->RuleAttribs.Section);
    FreeText (IniAct->RuleAttribs.Key);
    FreeText (IniAct->RuleAttribs.Data);
    FreeGrowBuffer (&IniAct->RuleAttribs.Settings);
    ZeroMemory (&IniAct->RuleAttribs, sizeof (IniAct->RuleAttribs));
}


BOOL
pCreateIniActions (
    IN      INIACT_CONTEXT Context
    )

/*++

Routine Description:

  pCreateIniActions will create a list of rules read from an INF depending on the Context

Arguments:

  Context - Specifies the context in which the function is called

Return Value:

  TRUE if the list (defined by the globals g_IniActHead and g_IniActTail) is not empty

--*/

{
    INFCONTEXT  InfContext;
    PINIACT IniAct;
    PCTSTR Section;

    if (g_WkstaMigInf == INVALID_HANDLE_VALUE) {
        DEBUGMSG ((DBG_ERROR, "Ini Actions: wkstamig.inf is not loaded"));
        return FALSE;
    }

    if (Context == INIACT_WKS_FIRST) {
        Section = S_INIFILES_ACTIONS_FIRST;
    } else {
        Section = S_INIFILES_ACTIONS_LAST;
    }

    if (SetupFindFirstLine (g_WkstaMigInf, Section, NULL, &InfContext)) {
        do {
            IniAct = PoolMemGetMemory (g_IniActPool, sizeof (*IniAct));
            ZeroMemory (IniAct, sizeof (*IniAct));

            if (pGetIniActData (&InfContext, IniAct)) {
                //
                // add it to the list
                //
                if (g_IniActTail) {
                    g_IniActTail->Next = IniAct;
                    g_IniActTail = IniAct;
                } else {
                    g_IniActHead = g_IniActTail = IniAct;
                }
            } else {
                pCleanUpIniAction (IniAct);
                PoolMemReleaseMemory (g_IniActPool, IniAct);
            }

        } while (SetupFindNextLine (&InfContext, &InfContext));
    }

    return g_IniActHead != NULL;
}


VOID
pFreeIniActions (
    VOID
    )

/*++

Routine Description:

  pFreeIniActions destroys all rules in the global list (see g_IniActHead and g_IniActTail)

Arguments:

  none

Return Value:

  none

--*/

{
    PINIACT NextRule;

    while (g_IniActHead) {
        NextRule = g_IniActHead->Next;
        pCleanUpIniAction (g_IniActHead);
        PoolMemReleaseMemory (g_IniActPool, g_IniActHead);
        g_IniActHead = NextRule;
    }
    g_IniActTail = NULL;
}


BOOL
pEnumFirstIniAction (
    OUT         PINIACT* IniAct
    )

/*++

Routine Description:

  pEnumFirstIniAction enumerates the first rule in the global list and puts a pointer to it
  in IniAct

Arguments:

  IniAct - Receives the first INI rule; NULL if none

Return Value:

  TRUE if there is at least a rule, FALSE if list is empty

--*/

{
    *IniAct = g_IniActHead;
    return *IniAct != NULL;
}


BOOL
pEnumNextIniAction (
    IN OUT      PINIACT* IniAct
    )

/*++

Routine Description:

  pEnumNextIniAction enumerates the next action after IniAct in the global list and puts
  a pointer to it in the same IniAct

Arguments:

  IniAct - Specifies a pointer to an INI rule; will receive a pointer to the next rule;
           receives NULL if last rule

Return Value:

  TRUE if there is a rule following (*IniAct is a valid pointer), FALSE if not

--*/

{
    if (*IniAct) {
        *IniAct = (*IniAct)->Next;
    }
    return *IniAct != NULL;
}


PTSTR
pGetAllKeys (
    IN      PCTSTR IniFilePath,
    IN      PCTSTR Section
    )

/*++

Routine Description:

  pGetAllKeys reads all keys or sections from the specified INI file and returns
  a pointer to allocated memory that contains all keys in the specified section.
  If section is NULL, a list of all sections is retrived instead.

Arguments:

  IniFilePath - Specifies the INI file

  Section - Specifies the section containg the keys; if NULL, sections are retrieved
            instead of keys

Return Value:

  A pointer to a multisz containing all keys or sections; caller must free the memory

--*/

{
    PTSTR Keys = NULL;
    DWORD Size = 64 * sizeof (TCHAR);
    DWORD chars;

    MYASSERT (IniFilePath);
    do {
        if (Keys) {
            PoolMemReleaseMemory (g_IniActPool, Keys);
        }
        Size *= 2;
        Keys = PoolMemGetMemory (g_IniActPool, Size);
        chars = GetPrivateProfileString (
                    Section,
                    NULL,
                    TEXT(""),
                    Keys,
                    Size,
                    IniFilePath
                    );
    } while (chars == Size - 2);

    return Keys;
}


PTSTR
pGetKeyValue (
    IN      PCTSTR IniFilePath,
    IN      PCTSTR Section,
    IN      PCTSTR Key
    )

/*++

Routine Description:

  pGetKeyValue reads the value associated with the given key, section, INI file and returns
  a pointer to allocated memory that contains this value as a string.
  Both section and Key must not be NULL.

Arguments:

  IniFilePath - Specifies the INI file

  Section - Specifies the section

  Key - Specifies the key

Return Value:

  A pointer to a string containing the value; caller must free the memory

--*/

{
    PTSTR Value = NULL;
    DWORD Size = 64 * sizeof (TCHAR);
    DWORD chars;

    MYASSERT (IniFilePath);
    MYASSERT (Section);
    MYASSERT (Key);

    do {
        if (Value) {
            PoolMemReleaseMemory (g_IniActPool, Value);
        }
        Size *= 2;
        Value = PoolMemGetMemory (g_IniActPool, Size);
        chars = GetPrivateProfileString (
                    Section,
                    Key,
                    TEXT(""),
                    Value,
                    Size,
                    IniFilePath
                    );
    } while (chars == Size - 1);

    return Value;
}


BOOL
pIsFileActionRule (
    IN      PINIACT IniAct,
    IN      PINIFILE IniFile
    )

/*++

Routine Description:

  pIsFileActionRule determines if the specified rule applies to the whole INI file

Arguments:

  IniAct - Specifies the INI action

  IniFile - Specifies the INI file

Return Value:

  TRUE if the rule applies to the whole INI file, FALSE if not

--*/

{
    MYASSERT (IniAct);
    return !IniAct->RuleAttribs.Section && !IniAct->RuleAttribs.Key;
}


BOOL
pDoFileAction (
    IN      PINIACT IniAct,
    IN      PINIFILE IniFile
    )

/*++

Routine Description:

  pDoFileAction applies the specified rule to the whole INI file

Arguments:

  IniAct - Specifies the INI action

  IniFile - Specifies the INI file

Return Value:

  the result returned by the INI action processing function on this INI file

--*/

{
    GROWBUFFER GbKeys = GROWBUF_INIT;
    PTSTR Sections, Keys;
    PCTSTR Section, Key;
    BOOL Result;

    MYASSERT (IniAct && IniAct->FnIniAct && !IniAct->RuleAttribs.Section && !IniAct->RuleAttribs.Key);

    Sections = pGetAllKeys (IniFile->ActualLocation, NULL);

    IniAct->RuleAttribs.Section = Sections;

    for (Section = Sections; *Section; Section = pGetNextMultiSzString (Section)) {
        Keys = pGetAllKeys (IniFile->ActualLocation, Section);

        for (Key = Keys; *Key; Key = pGetNextMultiSzString (Key)) {
            MultiSzAppend (&GbKeys, Key);
        }

        PoolMemReleaseMemory (g_IniActPool, Keys);
    }
    //
    // end with another zero (here are 2 TCHAR zeroes...)
    //
    GrowBufAppendDword (&GbKeys, 0);

    IniAct->RuleAttribs.Key = (PCTSTR)GbKeys.Buf;

    Result = (*IniAct->FnIniAct)(&IniAct->RuleAttribs, IniFile);

    IniAct->RuleAttribs.Key = NULL;
    IniAct->RuleAttribs.Section = NULL;

    FreeGrowBuffer (&GbKeys);

    PoolMemReleaseMemory (g_IniActPool, Sections);

    return Result;
}


BOOL
pIsSectionActionRule(
    IN      PINIACT IniAct,
    IN      PINIFILE IniFile
    )

/*++

Routine Description:

  pIsSectionActionRule determines if the specified rule applies to a section
  of the INI file

Arguments:

  IniAct - Specifies the INI action

  IniFile - Specifies the INI file

Return Value:

  TRUE if the rule applies to a section of the INI file, FALSE if not

--*/

{
    MYASSERT (IniAct);
    return IniAct->RuleAttribs.Section && !IniAct->RuleAttribs.Key;
}


BOOL
pDoSectionAction (
    IN      PINIACT IniAct,
    IN      PINIFILE IniFile
    )

/*++

Routine Description:

  pDoSectionAction applies the specified rule to a section of the INI file

Arguments:

  IniAct - Specifies the INI action

  IniFile - Specifies the INI file

Return Value:

  the result returned by the INI action processing function

--*/

{
    PTSTR Keys;
    BOOL Result;

    MYASSERT (IniAct && IniAct->FnIniAct && IniAct->RuleAttribs.Section && !IniAct->RuleAttribs.Key);

    Keys = pGetAllKeys (IniFile->ActualLocation, IniAct->RuleAttribs.Section);

    IniAct->RuleAttribs.Key = Keys;

    Result = (*IniAct->FnIniAct)(&IniAct->RuleAttribs, IniFile);

    IniAct->RuleAttribs.Key = NULL;

    PoolMemReleaseMemory (g_IniActPool, Keys);

    return Result;
}


BOOL
pDoKeyAction (
    IN      PINIACT IniAct,
    IN      PINIFILE IniFile
    )

/*++

Routine Description:

  pDoKeyAction applies the specified rule to a key of the INI file

Arguments:

  IniAct - Specifies the INI action

  IniFile - Specifies the INI file

Return Value:

  the result returned by the INI action processing function

--*/

{
    MYASSERT (IniAct && IniAct->FnIniAct && IniAct->RuleAttribs.Key);

    return (*IniAct->FnIniAct)(&IniAct->RuleAttribs, IniFile);
}


BOOL
pDoIniAction (
    IN      PINIFILE IniFile
    )

/*++

Routine Description:

  This is the actual worker routine called by pDoIniActions for each INI file to
  be migrated.

Arguments:

  IniFile - Specifies the INI file

Return Value:

  TRUE if INI migration was successful for this file, FALSE otherwise

--*/

{
    PINIACT IniAct;
    BOOL Result = TRUE;
    BOOL b;

    //
    // check INI file against all rules; if a rule applies, do it
    //
    if (pEnumFirstIniAction (&IniAct)) {
        do {
            if (!IsPatternMatch (IniAct->RuleAttribs.IniSpec, IniFile->OrigIniPath)) {
                continue;
            }

            //
            // do the action; check for file actions first
            //
            if (pIsFileActionRule (IniAct, IniFile)) {
                b = pDoFileAction (IniAct, IniFile);
            } else {
                //
                // check section actions next
                //
                if (pIsSectionActionRule (IniAct, IniFile)) {
                    //
                    // do it for each section in the current file
                    //
                    b = pDoSectionAction (IniAct, IniFile);
                } else {
                    //
                    // do key actions last
                    //
                    b = pDoKeyAction (IniAct, IniFile);
                }
            }

            DEBUGMSG_IF ((
                !b,
                DBG_INIACT,
                "pDoIniActions: function [%s] failed on file [%s]",
                IniAct->FnName,
                IniFile->OrigIniPath
                ));

            Result &= b;

        } while (pEnumNextIniAction (&IniAct));
    }

    return Result;
}


BOOL
pDoIniActions (
    IN      INIACT_CONTEXT Context
    )

/*++

Routine Description:

  This is the actual worker routine called by DoIniActions. It may be called
  in different contexts.

Arguments:

  Context - Specifies the context in which the function is called

Return Value:

  TRUE if INI files migration was successful, FALSE otherwise

--*/

{
    MEMDB_ENUM  e;
    INIFILE IniFile;
    PCTSTR OrigIniPath;
    PCTSTR ActualLocation;
    PCTSTR NtIniPath;
    PCTSTR MemDbCategory;

    //
    // get all rules first
    //
    if (pCreateIniActions (Context)) {
        //
        // enum all candidates files from corresponding memdb category
        //
        if (Context == INIACT_WKS_FIRST) {
            MemDbCategory = MEMDB_CATEGORY_INIACT_FIRST;
        } else {
            MemDbCategory = MEMDB_CATEGORY_INIACT_LAST;
        }
        if (MemDbGetValueEx (&e, MemDbCategory, NULL, NULL)) {
            do {
                OrigIniPath = e.szName;

                ActualLocation = GetTemporaryLocationForFile (OrigIniPath);
                if (!ActualLocation) {
                    DEBUGMSG ((
                        DBG_ERROR,
                        "Couldn't find temp location for INIACT key: %s\\%s",
                        MemDbCategory,
                        e.szName
                        ));
                    continue;
                }

                NtIniPath = GetPathStringOnNt (OrigIniPath);

                //
                // fill in the members of IniFile
                //
                IniFile.OrigIniPath = OrigIniPath;
                IniFile.ActualLocation = ActualLocation;
                IniFile.NtIniPath = NtIniPath;

                if (!pDoIniAction (&IniFile)) {
                    DEBUGMSG ((
                        DBG_INIACT,
                        "Some errors occured during migration of INI file [%s] -> [%s]",
                        OrigIniPath,
                        NtIniPath
                        ));
                }
                //
                // now convert the INI file (fix paths etc)
                //
//              ConvertIniFile (NtIniPath);

                FreePathString (NtIniPath);
                FreePathString (ActualLocation);

                ZeroMemory (&IniFile, sizeof (IniFile));

            } while (MemDbEnumNextValue (&e));
        }

        pFreeIniActions ();
    }

    return TRUE;
}


BOOL
DoIniActions (
    IN      INIACT_CONTEXT Context
    )

/*++

Routine Description:

  This is the main routine called to perform INI files migration. It may be called
  several times, specifying the context.

Arguments:

  Context - Specifies the context in which the function is called

Return Value:

  TRUE if INI files migration was successful in that context, FALSE otherwise

--*/

{
    BOOL b;

    g_IniActPool = PoolMemInitNamedPool ("IniAct");
    if (!g_IniActPool) {
        return FALSE;
    }

    b = FALSE;
    __try {
        b = pDoIniActions (Context);
    }
    __finally {
        PoolMemDestroyPool (g_IniActPool);
        g_IniActPool = NULL;
    }

    return b;
}


BOOL
pIsValidGuidStr (
    IN      PCTSTR GuidStr
    )

/*++

Routine Description:

  Determines if a GUID represented as a string has a valid representation (braces included).

Arguments:

  GuidStr - Specifies the GUID to check; it must contain the surrounding braces

Return Value:

  TRUE if the specified GUID is valid, or FALSE if it is not.

--*/

{
    DWORD GuidIdx, DashIdx;
    BYTE DashIndexes[4] = { DASH_INDEXES };
    TCHAR ch;

    MYASSERT (GuidStr);

    if (_tcslen (GuidStr) != GUIDSTR_LEN ||
        GuidStr[0] != TEXT('{') ||
        GuidStr[GUIDSTR_LEN - 1] != TEXT('}')) {
        return FALSE;
    }

    for (GuidIdx = 1, DashIdx = 0; GuidIdx < GUIDSTR_LEN - 1; GuidIdx++) {
        //
        // check all digits and dashes positions
        //
        ch = GuidStr[GuidIdx];
        if (DashIdx < 4 && (BYTE)GuidIdx == DashIndexes[DashIdx]) {
            if (ch != TEXT('-')) {
                return FALSE;
            }
            DashIdx++;
        } else {
            if (ch < TEXT('0') || ch > TEXT('9')) {
                if (!(ch >= TEXT('A') && ch <= TEXT('F') || ch >= TEXT('a') && ch <= TEXT('f'))) {
                    return FALSE;
                }
            }
        }
    }

    return TRUE;
}


BOOL
pIsGuidSuppressed (
    PCTSTR GuidStr
    )

/*++

Routine Description:

  Determines if a GUID is suppressed or not.

Arguments:

  GuidStr - Specifies the GUID to look up, which must be valid and
            must contain the surrounding braces

Return Value:

  TRUE if the specified GUID is suppressed, or FALSE if it is not.

--*/

{
    TCHAR Node[MEMDB_MAX];

    MemDbBuildKey (
        Node,
        MEMDB_CATEGORY_GUIDS,
        NULL,
        NULL,
        GuidStr
        );

    return MemDbGetValue (Node, NULL);
}


BOOL
pIsValidShellExtClsid (
    IN      PCTSTR GuidStr
    )

/*++

Routine Description:

  pIsValidShellExtClsid determines if a GUID is a valid shell extension

Arguments:

  GuidStr - Specifies the GUID to look up, which must be valid and
            must contain the surrounding braces

Return Value:

  TRUE if the specified GUID is a valid shell ext, or FALSE if it is not.

--*/

{
#if 0
    HKEY Key;
    LONG rc;
#endif

    //
    // check if the GUID is a known bad guid
    //
    if (pIsGuidSuppressed (GuidStr)) {
        return FALSE;
    }
    return TRUE;

    //
    // I removed the registry check because it is not always accurate;
    // some GUIDS may work without being listed in S_SHELLEXT_APPROVED keys
    // as it's the case with the default GUID {5984FFE0-28D4-11CF-AE66-08002B2E1262}
    //
#if 0
    rc = TrackedRegOpenKeyEx (
            HKEY_LOCAL_MACHINE,
            S_SHELLEXT_APPROVED,
            0,
            KEY_QUERY_VALUE,
            &Key
            );
    if (rc == ERROR_SUCCESS) {
        rc = RegQueryValueEx (Key, GuidStr, NULL, NULL, NULL, NULL);
        CloseRegKey (Key);
    }

    if (rc == ERROR_SUCCESS) {
        return TRUE;
    }

    return FALSE;
#endif
}


BOOL
pFindStrInMultiSzStrI (
    IN      PCTSTR Str,
    IN      PCTSTR MultiSz
    )

/*++

Routine Description:

  pFindStrInMultiSzStrI looks for Str in a list of multi-sz; the search is case-insensitive

Arguments:

  Str - Specifies the string to look for

  MultiSz - Specifies the list to be searched

Return Value:

  TRUE if the string was found in the list, or FALSE if not.

--*/

{
    PCTSTR p;

    for (p = MultiSz; *p; p = pGetNextMultiSzString (p)) {
        if (StringIMatch (p, Str)) {
            return TRUE;
        }
    }

    return FALSE;
}


BOOL
pMigrateSection (
    IN      PCTSTR Section,
    IN      PRULEATTRIBS RuleAttribs,
    IN      PINIFILE IniFile
    )

/*++

Routine Description:

  pMigrateSection migrates a whole section of the INI file.

Arguments:

  Section - Specifies section name

  RuleAttribs - Specifies the rule attributes which govern the migration

  IniFile - Specifies the INI file

Return Value:

  TRUE if the section was transferred successfully, or FALSE if not.

--*/

{
    PTSTR Keys;
    PTSTR Value;
    PCTSTR Key;
    BOOL b = TRUE;

    Keys = pGetAllKeys (IniFile->ActualLocation, Section);

    if (*Keys) {
        //
        // there are keys to transfer; first remove the entire section that will be replaced
        //
        WritePrivateProfileString (
                Section,
                NULL,
                NULL,
                IniFile->NtIniPath
                );
    }

    for (Key = Keys; *Key; Key = pGetNextMultiSzString (Key)) {
        Value = pGetKeyValue (IniFile->ActualLocation, Section, Key);
        b &= WritePrivateProfileString (
                    Section,
                    Key,
                    Value,
                    IniFile->NtIniPath
                    );

        PoolMemReleaseMemory (g_IniActPool, Value);
    }

    PoolMemReleaseMemory (g_IniActPool, Keys);

    return b;
}


BOOL
MigrateDesktopIniSCI (
    IN      PRULEATTRIBS RuleAttribs,
    IN      PINIFILE IniFile
    )

/*++

Routine Description:

  MigrateDesktopIniSCI migrates desktop.ini settings in section [.ShellClassInfo].
  It reads all keys and associated values within the section and writes them back
  to the NT version of this file. The "settings" multisz in this case represents
  a list of keys that must be synchronized; if no Win9x key exists, the corresponding
  NT key must be deleted; if the Win9x key exists, its value is copied

Arguments:

  RuleAttribs - Specifies the rule attributes which govern the migration

  IniFile - Specifies the INI file

Return Value:

  TRUE if the section was transferred successfully, or FALSE if an error occured.

--*/

{
    PCTSTR Key, SKey, NewValue;
    BOOL Found;
    BOOL Result, b;
    PTSTR Win9xValue, NtValue;
    TCHAR Dummy[2];

    DEBUGMSG ((
        DBG_INIACT,
        "Processing: %s -> %s [%s]",
        IniFile->OrigIniPath,
        IniFile->NtIniPath,
        RuleAttribs->Section
        ));

    Result = TRUE;
    //
    // RuleAttribs->Settings points in this case to a list of keys that
    // must be synchronized; if no Win9x key exists, the corresponding
    // NT key must be deleted; if Win9x key exists, its value is copied
    //
    for (SKey = (PCTSTR)RuleAttribs->Settings.Buf;
         *SKey;
         SKey = pGetNextMultiSzString (SKey)
        ) {

        Found = FALSE;
        for (Key = RuleAttribs->Key; *Key; Key = pGetNextMultiSzString (Key)) {
            if (StringIMatch (SKey, Key)) {
                Found = TRUE;
                break;
            }
        }
        if (!Found) {
            //
            // remove NT key if there is one
            //
            if (GetPrivateProfileString (
                        RuleAttribs->Section,
                        SKey,
                        TEXT(""),
                        Dummy,
                        2,
                        IniFile->NtIniPath
                        )) {
                if (!WritePrivateProfileString (
                            RuleAttribs->Section,
                            SKey,
                            NULL,
                            IniFile->NtIniPath
                            )) {
                    Result = FALSE;
                    DEBUGMSG ((DBG_INIACT, "Couldn't remove NT key [%s]", SKey));
                }
                ELSE_DEBUGMSG ((DBG_INIACT, "Removed NT key [%s]", SKey));
            }
        }
    }

    for (Key = RuleAttribs->Key; *Key; Key = pGetNextMultiSzString (Key)) {
        //
        // for each key on Win9x, update NT value;
        // check for suppressed GUIDs
        //
        Win9xValue = pGetKeyValue (IniFile->ActualLocation, RuleAttribs->Section, Key);
        NewValue = Win9xValue;
        if (pIsValidGuidStr (NewValue) && pIsGuidSuppressed (NewValue)) {
            //
            // remove the key
            //
            NewValue = NULL;
        }

        NtValue = pGetKeyValue (IniFile->NtIniPath, RuleAttribs->Section, Key);
        if (!NewValue && *NtValue || !StringMatch (NewValue, NtValue)) {
            b = WritePrivateProfileString (
                            RuleAttribs->Section,
                            Key,
                            NewValue,
                            IniFile->NtIniPath
                            );
            if (b) {
                DEBUGMSG ((
                    DBG_INIACT,
                    "Replaced key [%s] NT value [%s] with 9x value [%s]",
                    Key,
                    NtValue,
                    Win9xValue));
            } else {
                Result = FALSE;
                DEBUGMSG ((
                    DBG_INIACT,
                    "Failed to replace key [%s] NT value [%s] with 9x value [%s]",
                    Key,
                    NtValue,
                    Win9xValue));
            }
        }
        PoolMemReleaseMemory (g_IniActPool, Win9xValue);
        PoolMemReleaseMemory (g_IniActPool, NtValue);
    }

    return Result;
}


BOOL
MigrateDesktopIniESFV (
    IN      PRULEATTRIBS RuleAttribs,
    IN      PINIFILE IniFile
    )

/*++

Routine Description:

  MigrateDesktopIniESFV migrates desktop.ini settings in section [ExtShellFolderViews].
  It reads all keys and associated values within the section and writes them back
  to the NT version of this file. The "settings" multisz is not interpreted in this case.

Arguments:

  RuleAttribs - Specifies the rule attributes which govern the migration

  IniFile - Specifies the INI file

Return Value:

  TRUE if the section was transferred successfully, or FALSE if an error occured.

--*/

{
    PCTSTR ViewID;
    BOOL b, Result;
    DWORD chars;
    PTSTR Win9xValue;
    TCHAR DefaultViewID[GUIDSTR_LEN + 2];
    BOOL ReplaceDefViewID = FALSE;
    PTSTR NtValue;
#ifdef DEBUG
    TCHAR NtViewID[GUIDSTR_LEN + 2];
#endif

    Result = TRUE;

    DEBUGMSG ((
        DBG_INIACT,
        "Processing: %s -> %s [%s]",
        IniFile->OrigIniPath,
        IniFile->NtIniPath,
        RuleAttribs->Section
        ));

    //
    // get the default view id
    //
    chars = GetPrivateProfileString (
                RuleAttribs->Section,
                S_DEFAULT,
                TEXT(""),
                DefaultViewID,
                GUIDSTR_LEN + 2,
                IniFile->ActualLocation
                );
    if (*DefaultViewID && chars != GUIDSTR_LEN || !pIsValidShellExtClsid (DefaultViewID)) {
        //
        // invalid view id
        //
        DEBUGMSG ((
            DBG_INIACT,
            "Invalid Default ViewID [%s]; will not be processed",
            DefaultViewID
            ));
        *DefaultViewID = 0;
    }

    for (ViewID = RuleAttribs->Key; *ViewID; ViewID = pGetNextMultiSzString (ViewID)) {
        //
        // except for Default={ViewID},
        // all the other lines in this section should have the format {ViewID}=value
        // for each {ViewID} there is a section with the same name
        // keeping other keys (attributes of that shell view)
        //
        if (StringIMatch (ViewID, S_DEFAULT)) {
            continue;
        }

        if (pIsValidGuidStr (ViewID) && pIsValidShellExtClsid (ViewID)) {
            //
            // transfer the whole GUID section, if it's not one that shouldn't be migrated
            // a list of GUIDS that shouldn't be migrated is in RuleAttribs->Settings
            //
            if (!pFindStrInMultiSzStrI (ViewID, (PCTSTR)RuleAttribs->Settings.Buf)) {

                b = pMigrateSection (ViewID, RuleAttribs, IniFile);

                if (b) {
                    DEBUGMSG ((DBG_INIACT, "Successfully migrated section [%s]", ViewID));
                    if (*DefaultViewID && !StringIMatch (ViewID, DefaultViewID)) {
                        ReplaceDefViewID = TRUE;
                    }
                    //
                    // set {ViewID}=value in NT desktop.ini
                    //
                    NtValue = pGetKeyValue (IniFile->NtIniPath, RuleAttribs->Section, ViewID);
                    Win9xValue = pGetKeyValue (
                                    IniFile->ActualLocation,
                                    RuleAttribs->Section,
                                    ViewID
                                    );
                    if (!StringIMatch (NtValue, Win9xValue)) {
                        b = WritePrivateProfileString (
                                                RuleAttribs->Section,
                                                ViewID,
                                                Win9xValue,
                                                IniFile->NtIniPath
                                                );
                        DEBUGMSG_IF ((
                            b,
                            DBG_INIACT,
                            "Replaced key [%s] NT value [%s] with 9x value [%s]",
                            ViewID,
                            NtValue,
                            Win9xValue));
                    } else {
                        b = TRUE;
                    }

                    PoolMemReleaseMemory (g_IniActPool, Win9xValue);
                    PoolMemReleaseMemory (g_IniActPool, NtValue);
                }
                ELSE_DEBUGMSG ((DBG_INIACT, "Section [%s] was not migrated successfully", ViewID));
                //
                // update global result
                //
                Result &= b;
            }
        }
        ELSE_DEBUGMSG ((DBG_INIACT, "Invalid ShellExtViewID: [%s]; will not be processed", ViewID));

    }

    if (ReplaceDefViewID) {
        //
        // replace NT default view with Win9x default view
        //
#ifdef DEBUG
        GetPrivateProfileString (
                    RuleAttribs->Section,
                    S_DEFAULT,
                    TEXT(""),
                    NtViewID,
                    GUIDSTR_LEN + 2,
                    IniFile->NtIniPath
                    );
#endif
        b = WritePrivateProfileString (
                        RuleAttribs->Section,
                        S_DEFAULT,
                        DefaultViewID,
                        IniFile->NtIniPath
                        );
        DEBUGMSG_IF ((
            b,
            DBG_INIACT,
            "Replaced default NT ViewID [%s] with Default Win9x ViewID [%s]",
            NtViewID,
            DefaultViewID));

        Result &= b;
    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\migmain\migdlls.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    migdlls.c

Abstract:

    The functions in this module are used to support migration DLLs.

Author:

    Jim Schmidt (jimschm) 04-Feb-1997

Revision History:

    jimschm     23-Sep-1998 Changed to use new IPC mechanism
    jimschm     22-Apr-1998 Added USERPROFILE environment variable to MigrateUserNT
    jimschm     08-Jan-1997 Added alive event, giving certain DLLs up to 30 minutes
                            to complete their work.
    jimschm     08-Dec-1997 Added support for domains (MigrateUserNT's user name
                            param is multi-sz)

--*/

#include "pch.h"
#include "migmainp.h"

#ifndef UNICODE
#error UNICODE required
#endif


HANDLE g_AliveEvent;


BOOL
pConnectToDll (
    VOID
    );

VOID
pDisconnectFromDll (
    VOID
    );

DWORD
pRunMigrationDll (
    VOID
    );

DWORD
pCallInitializeNt (
    IN      PCTSTR WorkingDir,
    IN      PCTSTR *SourceDirArray,
    IN      PVOID Reserved,
    IN      DWORD ReservedBytes
    );

DWORD
pCallMigrateUserNt (
    IN      PCTSTR WorkingDir,
    IN      PCTSTR UnattendFile,
    IN      PCTSTR RootKey,
    IN      PCTSTR Win9xUserName,
    IN      PCTSTR UserDomain,
    IN      PCTSTR FixedUserName,
    IN      PVOID Reserved,
    IN      DWORD ReservedBytes
    );

DWORD
pCallMigrateSystemNt (
    IN      PCTSTR WorkingDir,
    IN      PCTSTR UnattendFile,
    IN      PVOID Reserved,
    IN      DWORD ReservedBytes
    );

static
VOID
pSetCwd (
    OUT     PTSTR SavedWorkDir,
    IN      PCTSTR NewWorkDir
    );


static TCHAR g_DllPath[MAX_TCHAR_PATH];
static TCHAR g_WorkingDir[MAX_TCHAR_PATH];
static TCHAR g_DllDesc[MAX_TCHAR_PATH];
static VENDORINFOW g_VendorInfo;
static TCHAR g_FixedUser[MAX_USER_NAME];
static TCHAR g_UserOnWin9x[MAX_USER_NAME];

static HINSTANCE g_hLibrary;
P_INITIALIZE_NT InitializeNT;
P_MIGRATE_USER_NT MigrateUserNT;
P_MIGRATE_SYSTEM_NT MigrateSystemNT;



VOID
pLogDllFailure (
    IN      HWND Parent,
    IN      UINT MessageId
    )

/*++

Routine Description:

  pLogDllFailure prepares arguments for the specified MessageId, and then
  displays a popup and adds a log entry.  This function gives the user
  information on what to do when the DLL fails.

Arguments:

  Parent    - Specifies the parent window handle of the popup, or NULL if no
              popup is to be displayed.
  MessageId - Specifies the message ID for the error.

Return Value:

  None.

--*/

{
    PCTSTR FixupPhone;
    PCTSTR FixupUrl;
    PCTSTR FixupInstructions;
    PCTSTR LineBreak = S_EMPTY;
    PCTSTR ArgArray[1];

    //
    // Generate fixup strings
    //

    if (g_VendorInfo.SupportNumber[0]) {
        ArgArray[0] = g_VendorInfo.SupportNumber;
        FixupPhone = ParseMessageID (MSG_MIGDLL_SUPPORT_PHONE_FIXUP, ArgArray);
        LineBreak = TEXT("\n");
    } else {
        FixupPhone = S_EMPTY;
    }

    if (g_VendorInfo.SupportUrl[0]) {
        ArgArray[0] = g_VendorInfo.SupportUrl;
        FixupUrl = ParseMessageID (MSG_MIGDLL_SUPPORT_URL_FIXUP, ArgArray);
        LineBreak = TEXT("\n");
    } else {
        FixupUrl = S_EMPTY;
    }

    if (g_VendorInfo.InstructionsToUser[0]) {
        ArgArray[0] = g_VendorInfo.InstructionsToUser;
        FixupInstructions = ParseMessageID (MSG_MIGDLL_INSTRUCTIONS_FIXUP, ArgArray);
        LineBreak = TEXT("\n");
    } else {
        FixupInstructions = S_EMPTY;
    }

    //
    // Display popup and log the error
    //
    LOG ((
        LOG_ERROR,
        (PCSTR) MessageId,
        g_DllDesc,
        g_VendorInfo.CompanyName,
        FixupPhone,
        FixupUrl,
        FixupInstructions,
        LineBreak
        ));
}


VOID
pSetCwd (
    OUT     PTSTR SavedWorkDir,
    IN      PCTSTR NewWorkDir
    )
{
    GetCurrentDirectory (MAX_TCHAR_PATH, SavedWorkDir);
    SetCurrentDirectory (NewWorkDir);
}



BOOL
pCreateEnvironment (
    PVOID *BlockPtr
    )
{
    return CreateEnvironmentBlock (BlockPtr, NULL, FALSE);
}


VOID
pSetEnvironmentBlock (
    PVOID Block
    )
{
    DEBUGMSG ((DBG_VERBOSE, "Block: %s", Block));
}


DWORD
ProcessMigrationDLLs (
    DWORD Request
    )
{
    MEMDB_ENUM e;
    DWORD rc;
    DWORD Ticks = 0;

    if (Request == REQUEST_QUERYTICKS) {
        if (MemDbEnumItems (&e, MEMDB_CATEGORY_MIGRATION_DLL)) {
            do {
                Ticks += TICKS_MIGRATION_DLL;
            } while (MemDbEnumNextValue (&e));
        }

        return Ticks;
    }

#ifdef PRERELEASE

    if (g_ConfigOptions.DiffMode) {
        TakeSnapShot();
    }

#endif

    if (MemDbEnumItems (&e, MEMDB_CATEGORY_MIGRATION_DLL)) {

        do {
            //
            // Retrieve DLL location and settings
            //

            // Obtain the DLL name and working directory
            if (!MemDbGetEndpointValueEx (
                    MEMDB_CATEGORY_MIGRATION_DLL,
                    e.szName,
                    MEMDB_FIELD_DLL,
                    g_DllPath)
                ) {
                LOG ((LOG_ERROR, "DLL path for %s is not listed in memdb; DLL not processed", e.szName));
                continue;   // not expected
            }

            // Obtain the working directory
            if (!MemDbGetEndpointValueEx (
                    MEMDB_CATEGORY_MIGRATION_DLL,
                    e.szName,
                    MEMDB_FIELD_WD,
                    g_WorkingDir)
                ) {
                LOG ((LOG_ERROR, "Working Directory for %s is not listed in memdb; DLL not processed", e.szName));
                continue;   // not expected
            }

            // Obtain a description
            if (!MemDbGetEndpointValueEx (
                    MEMDB_CATEGORY_MIGRATION_DLL,
                    e.szName,
                    MEMDB_FIELD_DESC,
                    g_DllDesc
                    )) {

                StringCopy (g_DllDesc, GetString (MSG_DEFAULT_MIGDLL_DESC));
            }

            ZeroMemory (&g_VendorInfo, sizeof (g_VendorInfo));

            MemDbGetEndpointValueEx (
                MEMDB_CATEGORY_MIGRATION_DLL,
                e.szName,
                MEMDB_FIELD_COMPANY_NAME,
                g_VendorInfo.CompanyName
                );

            MemDbGetEndpointValueEx (
                MEMDB_CATEGORY_MIGRATION_DLL,
                e.szName,
                MEMDB_FIELD_SUPPORT_PHONE,
                g_VendorInfo.SupportNumber
                );

            MemDbGetEndpointValueEx (
                MEMDB_CATEGORY_MIGRATION_DLL,
                e.szName,
                MEMDB_FIELD_SUPPORT_URL,
                g_VendorInfo.SupportUrl
                );

            MemDbGetEndpointValueEx (
                MEMDB_CATEGORY_MIGRATION_DLL,
                e.szName,
                MEMDB_FIELD_SUPPORT_INSTRUCTIONS,
                g_VendorInfo.InstructionsToUser
                );

            //
            // Establish connection with migisol.exe
            //

            if (!pConnectToDll()) {
                continue;
            }

            //
            // Tell migisol.exe to load migration DLL and call NT functions
            //

            rc = pRunMigrationDll();

            //
            // If not success, return a setup failure
            //

            if (rc != ERROR_SUCCESS) {
                SetLastError (rc);
                pLogDllFailure (g_ParentWnd, MSG_MIGDLL_ERROR);
            }

            //
            // Disconnect from migisol.exe and kill the potentially
            // stalled process
            //

            pDisconnectFromDll();

            TickProgressBarDelta (TICKS_MIGRATION_DLL);

        } while (MemDbEnumNextValue (&e));

    }  /* if */

#ifdef PRERELEASE

    if (g_ConfigOptions.DiffMode) {
        CHAR szMigdllDifPath[] = "c:\\migdll.dif";
        if (ISPC98()) {
            szMigdllDifPath[0] = (CHAR)g_System32Dir[0];
        }
        GenerateDiffOutputA (szMigdllDifPath, NULL, TRUE);
    }

#endif

    return ERROR_SUCCESS;
} /* ProcessMigrationDLLs */


BOOL
pConnectToDll (
    VOID
    )
{
    BOOL b = TRUE;
    TCHAR MigIsolPath[MAX_TCHAR_PATH];

    g_AliveEvent = CreateEvent (NULL, FALSE, FALSE, TEXT("MigDllAlive"));
    DEBUGMSG_IF ((!g_AliveEvent, DBG_WHOOPS, "Could not create MigDllAlive event"));

    if (!g_ConfigOptions.TestDlls) {
        //
        // Establish IPC connection
        //

        wsprintf (MigIsolPath, TEXT("%s\\%s"), g_System32Dir, S_MIGISOL_EXE);

        b = OpenIpc (FALSE, MigIsolPath, g_DllPath, g_System32Dir);

        if (!b) {
            LOG ((LOG_WARNING, "Can't establish IPC connection for %s, wd=%s", g_DllPath, g_System32Dir));
            pLogDllFailure (g_ParentWnd, MSG_CREATE_PROCESS_ERROR);
        }
    } else {
        g_hLibrary = LoadLibrary (g_DllPath);

        // If it fails, assume the DLL does not want to be loaded
        if (!g_hLibrary) {
            LOG ((LOG_ERROR, "Cannot load %s", g_DllPath));
            return FALSE;
        }

        // Get proc addresses for NT-side functions
        InitializeNT    = (P_INITIALIZE_NT)     GetProcAddress (g_hLibrary, PLUGIN_INITIALIZE_NT);
        MigrateUserNT   = (P_MIGRATE_USER_NT)   GetProcAddress (g_hLibrary, PLUGIN_MIGRATE_USER_NT);
        MigrateSystemNT = (P_MIGRATE_SYSTEM_NT) GetProcAddress (g_hLibrary, PLUGIN_MIGRATE_SYSTEM_NT);

        if (!InitializeNT || !MigrateUserNT || !MigrateSystemNT) {
            b = FALSE;
        }
    }

    return b;
}


VOID
pDisconnectFromDll (
    VOID
    )
{
    if (g_AliveEvent) {
        CloseHandle (g_AliveEvent);
        g_AliveEvent = NULL;
    }

    if (!g_ConfigOptions.TestDlls) {
        CloseIpc();
    }
    else {
        if (g_hLibrary) {
            FreeLibrary (g_hLibrary);
            g_hLibrary = NULL;
        }
    }
}


BOOL
pGetUserFromIndex (
    DWORD Index
    )

{
    USERPOSITION up;
    DWORD rc;

    g_UserOnWin9x[0] = 0;

    if (Index == INDEX_DEFAULT_USER) {

        StringCopy (g_FixedUser, g_DefaultUserName);

    } else if (Index == INDEX_LOGON_PROMPT) {

        StringCopy (g_FixedUser, S_DOT_DEFAULT);

    } else if (Index == INDEX_ADMINISTRATOR) {

        StringCopy (g_FixedUser, g_AdministratorStr);

    } else {

        rc = Win95RegGetFirstUser (&up, g_FixedUser);
        if (rc != ERROR_SUCCESS) {
            LOG ((LOG_ERROR, "Get User From Index: Win95RegGetFirstUser failed"));
            return FALSE;
        }

        for (Index -= INDEX_MAX ; Win95RegHaveUser(&up) && Index > 0 ; Index--) {
            Win95RegGetNextUser (&up, g_FixedUser);
        }

        if (!Win95RegHaveUser(&up)) {
            return FALSE;
        }

        StringCopy (g_UserOnWin9x, g_FixedUser);
        GetFixedUserName (g_FixedUser);
    }

    if (!g_UserOnWin9x[0]) {
        StringCopy (g_UserOnWin9x, g_FixedUser);
    }

    return TRUE;
}

DWORD
pRunMigrationDll (
    VOID
    )
{
    DWORD rc;
    BOOL AbortThisDll;
    BOOL UnloadRegKey;
    TCHAR UnattendFile[MAX_TCHAR_PATH];
    TCHAR RootKey[MAX_REGISTRY_KEY];
    TCHAR HiveFile[MAX_TCHAR_PATH];
    DWORD Index;
    BOOL IsLogonPromptAccount;
    PCTSTR SourceDirArray[2];
    PCTSTR I386SourceDir;
    PCTSTR p;
    TCHAR Domain[MAX_USER_NAME];
    BOOL Env;
    PVOID Block;
    HKEY NewHkcu;
    LONG MapResult;

    //
    // Initialize unattend file and root key
    //

    wsprintf (UnattendFile, TEXT("%s\\system32\\$winnt$.inf"), g_WinDir);

    //
    // Call InitializeNT
    //

    if (ISPC98()) {
        I386SourceDir = JoinPaths (g_SourceDir, TEXT("NEC98"));
    } else {
        I386SourceDir = JoinPaths (g_SourceDir, TEXT("I386"));
    }

    if (!I386SourceDir) {
        return GetLastError();
    }

    SourceDirArray[0] = I386SourceDir;
    SourceDirArray[1] = NULL;
    rc = pCallInitializeNt (g_WorkingDir, SourceDirArray, NULL, 0);
    if (rc != ERROR_SUCCESS) {
        return rc;
    }

    FreePathString (I386SourceDir);

    //
    // The user loop
    //

    // For each user, call DLL's MigrateUser function
    AbortThisDll = FALSE;
    Index = 0;

    while (!AbortThisDll) {

        if (Index == INDEX_LOGON_PROMPT) {
            wsprintf (RootKey, TEXT("HKU\\%s"), S_DOT_DEFAULT);
            IsLogonPromptAccount = TRUE;
        } else {
            wsprintf (RootKey, TEXT("HKU\\%s"), S_TEMP_USER_KEY);
            IsLogonPromptAccount = FALSE;
        }

        if (!pGetUserFromIndex (Index)) {
            break;
        }

        Index++;

        //
        // If the following lookup fails, it is because the user isn't supposed to
        // migrate, or migration failed.
        //

        if (!IsLogonPromptAccount) {
            if (-1 == pSetupStringTableLookUpStringEx (
                            g_HiveTable,
                            g_FixedUser,
                            STRTAB_CASE_INSENSITIVE,
                            HiveFile,
                            sizeof (HiveFile)
                            )
                ) {
                DEBUGMSG ((
                    DBG_VERBOSE,
                    "pRunMigrationDll: pSetupStringTableLookUpStringEx could not find name of hive for user %s",
                    g_FixedUser
                    ));

                continue;
            }
        }

        //
        // Load NT user hive
        //

        UnloadRegKey = FALSE;
        Env = FALSE;
        NewHkcu = NULL;
        MapResult = 0;

        if (!AbortThisDll) {

            // Don't load .default
            if (!IsLogonPromptAccount) {

                rc = RegUnLoadKey (HKEY_USERS, S_TEMP_USER_KEY);

                if (rc != ERROR_SUCCESS) {
                    DumpOpenKeys ();
                    SetLastError (rc);
                    DEBUGMSG_IF ((rc != ERROR_INVALID_PARAMETER, DBG_ERROR, "Error unloading regkey!"));
                }

                rc = RegLoadKey (HKEY_USERS, S_TEMP_USER_KEY, HiveFile);

                if (rc != ERROR_SUCCESS) {
                    SetLastError(rc);
                    LOG ((
                        LOG_ERROR,
                        "Run Migration Dll: RegLoadKey could not load user hive for %s (%s)",
                        g_FixedUser,
                        HiveFile
                        ));

                    AbortThisDll = TRUE;
                } else {
                    UnloadRegKey = TRUE;
                }
            }
        }

        if (!AbortThisDll) {
            NewHkcu = OpenRegKeyStr (RootKey);
            if (NewHkcu) {
                MapResult = RegOverridePredefKey (HKEY_CURRENT_USER, NewHkcu);
                if (MapResult != ERROR_SUCCESS) {
                    LOG ((LOG_ERROR, "Can't override HKCU"));
                }
            }

            Env = pCreateEnvironment (&Block);
            if (Env) {
                pSetEnvironmentBlock (&Block);
                DestroyEnvironmentBlock (&Block);
            }
        }

        // Call loaded DLL's MigrateUser function
        if (!AbortThisDll) {

            if (g_DomainUserName) {
                p = _tcschr (g_DomainUserName, TEXT('\\'));
            } else {
                p = NULL;
            }

            if (p) {
                StringCopyAB (Domain, g_DomainUserName, p);
            } else {
                Domain[0] = 0;
            }

            rc = pCallMigrateUserNt (
                    g_WorkingDir,
                    UnattendFile,
                    RootKey,
                    IsLogonPromptAccount ? TEXT("") : g_UserOnWin9x,
                    Domain,
                    IsLogonPromptAccount ? TEXT("") : g_FixedUser,
                    NULL,
                    0
                    );

            if (rc != ERROR_SUCCESS) {
                AbortThisDll = TRUE;
            }
        }

        // Restore predefined key
        if (NewHkcu && MapResult == ERROR_SUCCESS) {
            MapResult = RegOverridePredefKey (HKEY_CURRENT_USER, NULL);
            if (MapResult != ERROR_SUCCESS) {
                LOG ((LOG_ERROR, "Can't restore HKCU"));
            }

            CloseRegKey (NewHkcu);
        }

        // Unload temporary key
        if (UnloadRegKey) {
            UnloadRegKey = FALSE;
            rc = RegUnLoadKey (HKEY_USERS, S_TEMP_USER_KEY);
            if (rc != ERROR_SUCCESS) {
                DumpOpenKeys ();
                SetLastError (rc);
                DEBUGMSG_IF ((rc != ERROR_INVALID_PARAMETER, DBG_ERROR, "Error unloading regkey (second case)!"));

            }
        }
    } /* while */

    //
    // System processing
    //

    Env = pCreateEnvironment (&Block);
    if (Env) {
        pSetEnvironmentBlock (&Block);
        DestroyEnvironmentBlock (&Block);
    }

    // Call MigrateSystemNT
    if (!AbortThisDll) {
        rc = pCallMigrateSystemNt (
                g_WorkingDir,
                UnattendFile,
                NULL,
                0
                );

        if (rc != ERROR_SUCCESS) {
            AbortThisDll = TRUE;
        }
    }

    return rc;
}

DWORD
pFinishHandshake (
    IN      PCTSTR FunctionName
    )
{
    DWORD TechnicalLogId;
    DWORD GuiLogId;
    DWORD rc = ERROR_SUCCESS;
    BOOL b;
    UINT Count = 40;            // about 5 minutes
    UINT AliveAllowance = 10;   // about 30 minutes

    do {
        //
        // No OUT parameters on the NT side, so we don't care
        // about the return data
        //

        b = GetIpcCommandResults (
                IPC_GET_RESULTS_NT,
                NULL,
                NULL,
                &rc,
                &TechnicalLogId,
                &GuiLogId
                );

        //
        // If error code is returned, stuff it in setupact.log
        //

        if (b && rc != ERROR_SUCCESS) {
            LOG ((
                LOG_WARNING,
                "Migration DLL %s returned %u (0x%08X) in %s",
                g_DllDesc,
                rc,
                rc,
                FunctionName
                ));
        }


        //
        // Loop if no data received, but process is alive
        //

        if (!b) {
            if (!IsIpcProcessAlive()) {
                rc = ERROR_NOACCESS;
                break;
            }

            // continue if command was not sent yet but exe is still OK
            Count--;
            if (Count == 0) {
                if (WaitForSingleObject (g_AliveEvent, 0) == WAIT_OBJECT_0) {
                    DEBUGMSG ((DBG_WARNING, "Alive allowance given to migration DLL"));

                    AliveAllowance--;
                    if (AliveAllowance) {
                        Count = 24;        // about 3 minutes
                    }
                }

                if (Count == 0) {
                    rc = ERROR_SEM_TIMEOUT;
                    break;
                }
            }
        }

    } while (!b);

    if (b) {
        //
        // Recognize log messages
        //
        if (TechnicalLogId) {
            //
            // LOG message with three args: DllDesc, DllPath, User
            //

            LOG ((
                LOG_ERROR,
                (PCSTR) TechnicalLogId,
                g_DllDesc,
                g_DllPath,
                g_FixedUser
                ));
        }
        if (GuiLogId) {
            LOG ((
                LOG_ERROR,
                (PCSTR) GuiLogId,
                g_DllDesc,
                g_DllPath,
                g_FixedUser
                ));
        }
    }

    return rc;
}


DWORD
pCallInitializeNt (
    IN      PCTSTR WorkingDir,
    IN      PCTSTR *SourceDirArray,
    IN      PVOID Reserved,
    IN      DWORD ReservedBytes
    )
{
    DWORD rc = ERROR_SUCCESS;
    GROWBUFFER GrowBuf = GROWBUF_INIT;
    INT Count;
    PBYTE BufPtr;
    PDWORD ReservedBytesPtr;
    TCHAR SavedCwd [MAX_TCHAR_PATH];

    if (!g_ConfigOptions.TestDlls) {
        __try {
            MultiSzAppend (&GrowBuf, WorkingDir);

            //
            // Prepare multi-sz directory list
            //

            for (Count = 0 ; SourceDirArray[Count] ; Count++) {
                MultiSzAppend (&GrowBuf, SourceDirArray[Count]);
            }

            MultiSzAppend (&GrowBuf, S_EMPTY);

            ReservedBytesPtr = (PDWORD) GrowBuffer (&GrowBuf, sizeof (ReservedBytes));
            *ReservedBytesPtr = ReservedBytes;

            if (ReservedBytes) {
                BufPtr = GrowBuffer (&GrowBuf, ReservedBytes);
                CopyMemory (BufPtr, Reserved, ReservedBytes);
            }

            if (!SendIpcCommand (
                    IPC_INITIALIZE,
                    GrowBuf.Buf,
                    GrowBuf.End
                    )) {

                LOG ((LOG_ERROR, "Call InitializeNT failed to send command"));
                rc = GetLastError();
                __leave;
            }

            rc = pFinishHandshake (TEXT("InitializeNT"));
            if (rc != ERROR_SUCCESS) {
                LOG ((
                    LOG_ERROR,
                    "Call InitializeNT failed to complete handshake, rc=%u",
                    rc
                    ));
            }
        }
        __finally {
            FreeGrowBuffer (&GrowBuf);
        }
    }
    else {

        pSetCwd (
            SavedCwd,       // old
            WorkingDir      // new
            );

        __try {
            //
            // Prepare multi-sz directory list
            //

            for (Count = 0 ; SourceDirArray[Count] ; Count++) {
                MultiSzAppend (&GrowBuf, SourceDirArray[Count]);
            }

            MultiSzAppend (&GrowBuf, S_EMPTY);

            rc = InitializeNT (WorkingDir, (PCTSTR) GrowBuf.Buf, Reserved);

            FreeGrowBuffer (&GrowBuf);
        }
        __finally {
            SetCurrentDirectory (SavedCwd);
        }
    }

    return rc;
}


DWORD
pCallMigrateUserNt (
    IN      PCTSTR WorkingDir,
    IN      PCTSTR UnattendFile,
    IN      PCTSTR RootKey,
    IN      PCTSTR Win9xUserName,
    IN      PCTSTR UserDomain,
    IN      PCTSTR FixedUserName,
    IN      PVOID Reserved,
    IN      DWORD ReservedBytes
    )
{
    DWORD rc = ERROR_SUCCESS;
    GROWBUFFER GrowBuf = GROWBUF_INIT;
    PDWORD ReservedBytesPtr;
    PVOID BufPtr;
    TCHAR SavedCwd [MAX_TCHAR_PATH];
    TCHAR UserBuf[MAX_USER_NAME * 3];
    PTSTR p;
    TCHAR OrgUserProfilePath[MAX_TCHAR_PATH];
    TCHAR UserProfilePath[MAX_TCHAR_PATH];

    if (FixedUserName[0]) {
        GetUserProfilePath (FixedUserName, &p);
        StackStringCopy (UserProfilePath, p);
        FreePathString (p);

        DEBUGMSG ((DBG_VERBOSE, "Profile path for %s is %s", FixedUserName, UserProfilePath));
    } else {
        UserProfilePath[0] = 0;
    }

    GetEnvironmentVariable (S_USERPROFILE, OrgUserProfilePath, MAX_TCHAR_PATH);
    SetEnvironmentVariable (S_USERPROFILE, UserProfilePath);

    if (!g_ConfigOptions.TestDlls) {
        __try {
            MultiSzAppend (&GrowBuf, UnattendFile);
            MultiSzAppend (&GrowBuf, RootKey);
            MultiSzAppend (&GrowBuf, Win9xUserName);
            MultiSzAppend (&GrowBuf, UserDomain);
            MultiSzAppend (&GrowBuf, FixedUserName);
            MultiSzAppend (&GrowBuf, UserProfilePath);

            ReservedBytesPtr = (PDWORD) GrowBuffer (&GrowBuf, sizeof (ReservedBytes));
            *ReservedBytesPtr = ReservedBytes;

            if (ReservedBytes) {
                BufPtr = GrowBuffer (&GrowBuf, ReservedBytes);
                CopyMemory (BufPtr, Reserved, ReservedBytes);
            }

            if (!SendIpcCommand (
                    IPC_MIGRATEUSER,
                    GrowBuf.Buf,
                    GrowBuf.End
                    )) {

                LOG ((LOG_ERROR, "Call MigrateUserNT failed to send command"));
                rc = GetLastError();
                __leave;
            }

            rc = pFinishHandshake (TEXT("MigrateUserNT"));
            if (rc != ERROR_SUCCESS) {
                LOG ((
                    LOG_ERROR,
                    "Call MigrateUserNT failed to complete handshake, rc=%u",
                    rc
                    ));
            }
        }
        __finally {
            FreeGrowBuffer (&GrowBuf);
        }

    } else {

        pSetCwd (
            SavedCwd,       // old
            WorkingDir      // new
            );

        __try {

            HINF UnattendHandle;
            HKEY UserRegHandle;

            UnattendHandle = InfOpenInfFile (UnattendFile);
            if (UnattendHandle == INVALID_HANDLE_VALUE) {
                __leave;
            }

            UserRegHandle = OpenRegKeyStr (RootKey);
            if (!UserRegHandle) {
                rc = GetLastError();
                InfCloseInfFile (UnattendHandle);
                __leave;
            }

            //
            // Transfer user, user domain and fixed name to a buffer
            //

            if (Win9xUserName) {
                StringCopy (UserBuf, Win9xUserName);
            } else {
                UserBuf[0] = 0;
            }

            p = GetEndOfString (UserBuf) + 1;

            if (UserDomain) {
                StringCopy (p, UserDomain);
            } else {
                p[0] = 0;
            }

            p = GetEndOfString (p) + 1;

            if (UserDomain) {
                StringCopy (p, FixedUserName);
            } else {
                p[0] = 0;
            }

            //
            // Call the entry point
            //

            rc = MigrateUserNT (
                        UnattendHandle,
                        UserRegHandle,
                        UserBuf[0] ? UserBuf : NULL,
                        Reserved
                        );

            CloseRegKey (UserRegHandle);
            InfCloseInfFile (UnattendHandle);
        }
        __finally {
            SetCurrentDirectory (SavedCwd);
        }
    }

    SetEnvironmentVariable (S_USERPROFILE, OrgUserProfilePath);

    return rc;
}


DWORD
pCallMigrateSystemNt (
    IN      PCTSTR WorkingDir,
    IN      PCTSTR UnattendFile,
    IN      PVOID Reserved,
    IN      DWORD ReservedBytes
    )
{
    DWORD rc = ERROR_SUCCESS;
    GROWBUFFER GrowBuf = GROWBUF_INIT;
    PDWORD ReservedBytesPtr;
    PVOID BufPtr;
    TCHAR SavedCwd [MAX_TCHAR_PATH];

    if (!g_ConfigOptions.TestDlls) {
        __try {
            MultiSzAppend (&GrowBuf, UnattendFile);

            ReservedBytesPtr = (PDWORD) GrowBuffer (&GrowBuf, sizeof (ReservedBytes));
            *ReservedBytesPtr = ReservedBytes;

            if (ReservedBytes) {
                BufPtr = GrowBuffer (&GrowBuf, ReservedBytes);
                CopyMemory (BufPtr, Reserved, ReservedBytes);
            }

            if (!SendIpcCommand (IPC_MIGRATESYSTEM, GrowBuf.Buf, GrowBuf.End)) {
                LOG ((LOG_ERROR, "Call MigrateSystemNT failed to send command"));
                rc = GetLastError();
                __leave;
            }

            rc = pFinishHandshake (TEXT("MigrateSystemNT"));
            if (rc != ERROR_SUCCESS) {
                LOG ((
                    LOG_ERROR,
                    "Call MigrateSystemNT failed to complete handshake, rc=%u",
                    rc
                    ));
            }
        }
        __finally {
            FreeGrowBuffer (&GrowBuf);
        }
    }
    else {
        pSetCwd (
            SavedCwd,       // old
            WorkingDir      // new
            );

        __try {
            HINF UnattendHandle;

            UnattendHandle = InfOpenInfFile (UnattendFile);
            if (UnattendHandle == INVALID_HANDLE_VALUE) {
                rc = GetLastError();
                __leave;
            }

            rc = MigrateSystemNT (UnattendHandle, Reserved);

            InfCloseInfFile (UnattendHandle);
        }
        __finally {
            SetCurrentDirectory (SavedCwd);
        }
    }

    return rc;
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\base\ntsetup\win95upg\w95upgnt\migmain\migmain.c ===
/*++

Copyright (c) 1996 Microsoft Corporation

Module Name:

    migmain.c

Abstract:

    MigMain is called from w95upgnt.dll, which is called from SYSSETUP.DLL.
    It is the main migration loop on the NT side of setup.  MigMain loops
    through all users on the Win95 side of configuration, migrates their
    registry, creates their account, and fixes up their profile folders.
    Then MigMain migrates all machine-specific settings such as link changes
    and file deletion.

Author:

    Jim Schmidt (jimschm) 12-Jul-1996

Revision History:

    marcw       26-Mar-1999 More boot16 fixes -- hide msdos7 dir, fix to msdos.sys
    marcw       18-Mar-1999 fixes for boot16 environment in localized case.
    jimschm     23-Sep-1998 Changes for fileops & shell.c
    calinn      23-Sep-1998 Changes for memdb fixup
    jimschm     02-Jul-1998 Support for progress bar
    jimschm     11-Jun-1998 Support for dynamic user profile paths in memdb
    jimschm     05-May-1998 Migration of Default User if unattend option is enabled
    jimschm     27-Apr-1998 Added icon preservation
    jimschm     18-Mar-1998 Added pProcessAutoLogon
    calinn      19-Nov-1997 Added pEnable16Boot, will create a 16 bit environment boot entry in boot.ini
    jimschm     01-Oct-1997 Localized Everyone group
    jimschm     13-Sep-1997 Reg Quota for beta 1 workaround
    jimschm     21-Jul-1997 Use of fileops for ConvertWin9xPath (to be moved later)
    jimschm     28-May-1997 Cleaned up
    marcw       21-Mar-1997 added Pathmapping
    jimschm     04-Feb-1997 Moved code into usermig.c and wkstamig.c
    jimschm     15-Jan-1997 Plug-in spec modifications (now in migdlls.c)
    jimschm     03-Jan-1997 Added g_UserName
    jimschm     18-Dec-1996 Extracted code from miginf
    mikeco      O4-Dec-1996 Enumerate/modify PIF and LNK files
    jimschm     23-Oct-1996 Joined ProcessUserInfs and ApplyChanges
    jimschm     02-Oct-1996 Added default user migration

--*/

#include "pch.h"
#include "migmainp.h"

#include "fileops.h"
#include "quota.h"

#ifndef UNICODE
#error UNICODE required
#endif

#ifdef DEBUG

BOOL g_NoReloadsAllowed = FALSE;

#define DBG_VALIDNTFILES    "NtFiles"

#endif

typedef BOOL (*PROFILE_PATH_PROVIDER)(OUT PTSTR AccountName, OUT PTSTR PathProfile);

//
// Globals for migmain.lib
//

HKEY g_hKeyRoot95, g_hKeyRootNT;
PCTSTR g_DomainUserName;
PCTSTR g_Win9xUserName;
PCTSTR g_FixedUserName;
PVOID g_HiveTable;
POOLHANDLE g_HivePool;
PVOID g_NulSessionTable;
PCTSTR g_EveryoneStr;
PCTSTR g_AdministratorsGroupStr;
PCTSTR g_PowerUsersGroupStr;
PCTSTR g_DomainUsersGroupStr;
PCTSTR g_NoneGroupStr;
TCHAR g_IconBin[MAX_TCHAR_PATH];
TCHAR g_DefaultUserName[MAX_USER_NAME];
TCHAR g_ComputerName[MAX_SERVER_NAME];
BOOL g_BlowAwayTempShellFolders = FALSE;
UINT g_Boot16 = BOOT16_AUTOMATIC;

//
// Buffer for GetString's messages
//

static TCHAR g_MsgBuf[2048];

//
// Flag identifying if the SKU is Personal
//
BOOL g_PersonalSKU = FALSE;

//
// Prototypes for migmain.c only
//

BOOL
pSetWin9xUpgValue (
    VOID
    );

VOID
pCountUsers (
    OUT     PDWORD TotalUsersPtr,
    OUT     PDWORD ActiveUsersPtr
    );

BOOL
pMigrateUsers (
    VOID
    );

VOID
pRaiseRegistryQuota (
    PCTSTR Win9xSystemDatSpec
    );

VOID
pEnable16Boot (
    VOID
    );

VOID
pProcessAutoLogon (
    BOOL Final
    );

VOID
pFixUpMemDb (
    VOID
    );



BOOL
WINAPI
MigMain_Entry (
    IN      HINSTANCE hinstDLL,
    IN      DWORD dwReason,
    IN      PVOID lpv
    )

/*++

Routine Description:

  MigMain_Entry is called at DLL initialization time

Arguments:

  hinstDLL  - (OS-supplied) Instance handle for the DLL
  dwReason  - (OS-supplied) Type of initialization or termination
  lpv       - (OS-supplied) Unused

Return Value:

  TRUE because LIB always initializes properly.

--*/

{
    DWORD Size;
    OSVERSIONINFOEX osviex;

    switch (dwReason) {

    case DLL_PROCESS_ATTACH:
        if(!pSetupInitializeUtils()) {
            return FALSE;
        }
        g_hKeyRoot95 = g_hKeyRootNT = NULL;

        g_HivePool = PoolMemInitNamedPool ("Hive path pool");

        if (!g_HivePool) {
            return FALSE;
        }

        // Alloc string tables
        g_HiveTable = pSetupStringTableInitializeEx (MAX_TCHAR_PATH,0);
        if (!g_HiveTable) {
            return FALSE;
        }

        g_NulSessionTable = pSetupStringTableInitializeEx (sizeof(PCWSTR), 0);
        if (!g_NulSessionTable) {
            return FALSE;
        }

        //
        // Determine if upgrading to Personal SKU
        //
        osviex.dwOSVersionInfoSize = sizeof (OSVERSIONINFOEX);
        if (!GetVersionEx ((LPOSVERSIONINFO)&osviex)) {
            MYASSERT (FALSE);
        }
        if (osviex.wProductType == VER_NT_WORKSTATION &&
            (osviex.wSuiteMask & VER_SUITE_PERSONAL)
            ) {
            g_PersonalSKU = TRUE;
        }

#if 0
        if (g_PersonalSKU) {
            g_EveryoneStr            = GetStringResource (MSG_EVERYONE_GROUP);
            g_AdministratorsGroupStr = GetStringResource (MSG_OWNERS_GROUP);
            g_PowerUsersGroupStr     = GetStringResource (MSG_POWER_USERS_GROUP);
            g_DomainUsersGroupStr    = GetStringResource (MSG_DOMAIN_USERS_GROUP);
            g_NoneGroupStr           = GetStringResource (MSG_NONE_GROUP);
        } else {
#endif
        g_EveryoneStr            = GetStringResource (MSG_EVERYONE_GROUP);
        g_AdministratorsGroupStr = GetStringResource (MSG_ADMINISTRATORS_GROUP);
        g_PowerUsersGroupStr     = GetStringResource (MSG_POWER_USERS_GROUP);
        g_DomainUsersGroupStr    = GetStringResource (MSG_DOMAIN_USERS_GROUP);
        g_NoneGroupStr           = GetStringResource (MSG_NONE_GROUP);

        Size = ARRAYSIZE(g_ComputerName);
        if (!GetComputerName (g_ComputerName, &Size)) {
            g_ComputerName[0] = 0;
        }

        MYASSERT (
            g_ComputerName[0] &&
            g_EveryoneStr &&
            g_AdministratorsGroupStr &&
            g_PowerUsersGroupStr &&
            g_DomainUsersGroupStr &&
            g_NoneGroupStr
            );

        FindAccountInit();

        break;


    case DLL_PROCESS_DETACH:
        if (g_HiveTable) {
            pSetupStringTableDestroy (g_HiveTable);
        }

        if (g_NulSessionTable) {
            pSetupStringTableDestroy (g_NulSessionTable);
        }

        if (g_HivePool) {
            PoolMemDestroyPool (g_HivePool);
        }

        FreeStringResource (g_EveryoneStr);
        FreeStringResource (g_AdministratorsGroupStr);
        FreeStringResource (g_DomainUsersGroupStr);

        FindAccountTerminate();
        pSetupUninitializeUtils();
        break;
    }

    return TRUE;
}


#ifdef DEBUG

BOOL
pValidateNtFiles (
    VOID
    )

/*++

Routine Description:

  pValidateNtFiles validates the list of files that are supposed to be installed
  by NT. We check for the flag set on Win95 side and for each entry we check to
  see if the file is realy present (e.g. was installed by NT). If not then we delete
  the entry.

Arguments:

  none

Return Value:

  Always returns TRUE

--*/

{
    MEMDB_ENUMW enumFiles;
    WCHAR key[MEMDB_MAX];
    PWSTR fileName;
    TREE_ENUMW enumTree;
    DWORD value;

    if (MemDbEnumFirstValue (
            &enumFiles,
            TEXT(MEMDB_CATEGORY_NT_FILESA)TEXT("\\*"),
            MEMDB_ALL_SUBLEVELS,
            MEMDB_ENDPOINTS_ONLY
            )) {
        do {
            if (MemDbBuildKeyFromOffsetW (enumFiles.dwValue, key, 1, NULL)) {

                fileName = JoinPaths (key, enumFiles.szName);

                if (!DoesFileExistW (fileName)) {

                    MemDbSetValueEx (
                        MEMDB_CATEGORY_NT_FILES_BAD,
                        enumFiles.szName,
                        NULL,
                        NULL,
                        enumFiles.dwValue,
                        NULL
                        );
                }
                FreePathString (fileName);
            }
            ELSE_DEBUGMSG ((DBG_WHOOPS, "NT_FILES : cannot find installation directory."));
        }
        while (MemDbEnumNextValue (&enumFiles));
    }

    // now we have in MEMDB_CATEGORY_NT_FILES_BAD all files that should be installed
    // by NT but are not. Now we are going to scan the file system and see if they are
    // installed in a different place.
    if (EnumFirstFileInTreeEx (&enumTree, g_WinDrive, TEXT("*.*"), FALSE, FALSE, FILE_ENUM_ALL_LEVELS)) {
        do {
            MemDbBuildKey (key, MEMDB_CATEGORY_NT_FILES_BAD, enumTree.Name, NULL, NULL);
            if (MemDbGetValue (key, &value) && (value != 0)) {
                MemDbSetValue (key, 0);
                MemDbBuildKeyFromOffsetW (value, key, 1, NULL);
                DEBUGMSG ((
                    DBG_VALIDNTFILES,
                    "%s listed to be installed in %s but installed in %s",
                    enumTree.Name,
                    key,
                    enumTree.FullPath));
            }
        } while (EnumNextFileInTree (&enumTree));
    }

    MemDbBuildKey (key, MEMDB_CATEGORY_NT_FILES_BAD, TEXT("*"), NULL, NULL);
    if (MemDbEnumFirstValue (
            &enumFiles,
            key,
            MEMDB_ALL_SUBLEVELS,
            MEMDB_ENDPOINTS_ONLY
            )) {
        do {
            if (enumFiles.dwValue) {
                MemDbBuildKeyFromOffsetW (enumFiles.dwValue, key, 1, NULL);
                DEBUGMSG ((
                    DBG_VALIDNTFILES,
                    "%s listed to be installed in %s but never installed",
                    enumFiles.szName,
                    key,
                    enumTree.FullPath));
            }
        }
        while (MemDbEnumNextValue (&enumFiles));
    }

    return TRUE;
}

#endif


DWORD
pGetS