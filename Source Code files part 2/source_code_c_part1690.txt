*****************/

BOOL
_CanTakePicture (CImageFolder *pFolder, LPITEMIDLIST pidl)
{
    BOOL bRet = FALSE;
    TraceEnter (TRACE_DETAILS, "_CanTakePicture");
    if (IsDeviceIDL(pidl)) // Take picture only allowed from the root folder
    {
        DWORD dwType = IMGetDeviceTypeFromIDL (pidl);
        // eliminate non-cameras
        if (StiDeviceTypeDigitalCamera == dwType ||
            StiDeviceTypeStreamingVideo == dwType)
        {
            // enum the supported events
            CComPtr<IWiaItem> pDevice;
            if (SUCCEEDED(IMGetItemFromIDL(pidl, &pDevice)))
            {
                CComPtr<IEnumWIA_DEV_CAPS> pCaps;
                if (SUCCEEDED(pDevice->EnumDeviceCapabilities(WIA_DEVICE_COMMANDS, &pCaps)))
                {
                    WIA_DEV_CAP wdc;
                    DWORD dw;
                    while ((FALSE == bRet) && S_OK == pCaps->Next(1, &wdc, &dw))
                    {
                        if (IsEqualGUID(WIA_CMD_TAKE_PICTURE, wdc.guid))
                        {
                            bRet = TRUE;
                        }
                        if (wdc.bstrCommandline)
                        {
                            SysFreeString (wdc.bstrCommandline);
                        }
                        if (wdc.bstrDescription)
                        {
                            SysFreeString (wdc.bstrDescription);
                        }
                        if (wdc.bstrIcon)
                        {
                            SysFreeString (wdc.bstrIcon);
                        }
                    }
                }
            }
        }
    }
    TraceLeaveValue ( bRet);
}
HRESULT
CanTakePicture (CImageFolder *pFolder, LPITEMIDLIST pidl , DWORD dwPid, VARIANT *pv)
{
    HRESULT hr = S_OK;
    TraceEnter (TRACE_DETAILS, "CanTakePicture");
    pv->vt = VT_I4;
    pv->ulVal = _CanTakePicture (pFolder, pidl);
    TraceLeaveResult (hr);
}

/*****************************************************************************

  NumPicsTaken

  Builds a BSTR that has the number of pictures stored on the camera.
  If the camera supports # pics remaining, includes that info too.

*****************************************************************************/
HRESULT
NumPicsTaken (CImageFolder *pFolder, LPITEMIDLIST pidl , DWORD dwPid, VARIANT *pv)
{
    HRESULT hr = S_OK;
    static PROPSPEC ps[2] = {{PRSPEC_PROPID, WIA_DPC_PICTURES_TAKEN},
                             {PRSPEC_PROPID, WIA_DPC_PICTURES_REMAINING}};

    PROPVARIANT ppv[2];
    CComPtr<IWiaItem> pItem;

    TraceEnter (TRACE_PROPUI, "NumPicsTaken");
    TraceAssert (dwPid == PID_PICSTAKEN);
    VariantInit (pv);
    if (!pidl)
    {
        pv->vt = VT_BSTR;
        pv->bstrVal = SysAllocString(L"");
    }
    else
    {
        ZeroMemory (ppv, sizeof(ppv));
        hr = IMGetItemFromIDL(pidl, &pItem);
        if (SUCCEEDED(hr))
        {
            CComQIPtr<IWiaPropertyStorage, &IID_IWiaPropertyStorage> pStg(pItem);
            if (pStg)
            {
                hr = pStg->ReadMultiple (2, ps, ppv);
            }
            else
            {
                hr = E_FAIL;
            }
            if (SUCCEEDED(hr))
            {
                TraceAssert (ppv[0].vt != VT_EMPTY);
                CSimpleStringWide strTaken;
                CSimpleStringWide strTemp;

                strTemp.LoadString(IDS_TAKEN, GLOBAL_HINSTANCE);
                strTaken.Format(strTemp, ppv[0].intVal);
                // if it supports pics remaining, append that info
                if (ppv[1].vt != VT_EMPTY)
                {
                    CSimpleStringWide strRemain;
                    strTemp.LoadString(IDS_REMAIN, GLOBAL_HINSTANCE);
                    strRemain.Format(strTemp, ppv[1].intVal);
                    strTaken.Concat(strRemain);
                }
                pv->vt = VT_BSTR;
                pv->bstrVal = SysAllocString (strTaken);
                if (!(pv->bstrVal))
                {
                    pv->vt = VT_EMPTY;
                    hr = E_OUTOFMEMORY;
                }
                FreePropVariantArray (ARRAYSIZE(ppv), ppv);
            }
        }
    }
    
    TraceLeaveResult (hr);

}

/******************************************************************************

    GetFolderPath

    Returns the device id plus the WIA folder path of the current folder
    <deviceid>::<folderpath>

******************************************************************************/

HRESULT GetFolderPath (CImageFolder *pFolder, LPITEMIDLIST pidl, DWORD dwPid, VARIANT *pVariant)
{
    HRESULT hr = S_OK;
    TraceEnter (TRACE_DETAILS, "GetFolderPath");
    LPITEMIDLIST pidlFolder;
    hr = pFolder->GetCurFolder (&pidlFolder);
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidlLast = ILFindLastID(pidlFolder);
        CSimpleStringWide strPath;
        CComBSTR bstrFullPath;
        
        IMGetDeviceIdFromIDL (pidl, strPath);
        IMGetFullPathNameFromIDL (pidlLast, &bstrFullPath);
        strPath.Concat(L"::");
        if (bstrFullPath.m_str)
        {
            strPath.Concat(CSimpleStringWide(bstrFullPath));
        }
        pVariant->vt = VT_BSTR;
        pVariant->bstrVal = SysAllocString (strPath);
        if (!(pVariant->bstrVal))
        {
            hr = E_OUTOFMEMORY;
        }
        Trace(TEXT("FolderPath:%ls"), strPath.String());
        ILFree (pidlFolder);
    }
    TraceLeaveResult (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\src\download.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998 - 1999
 *
 *  TITLE:       download.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      DavidShi
 *
 *  DATE:        4/10/99
 *
 *  DESCRIPTION: Definitions for CImageXFer class
 *
 *****************************************************************************/

#ifndef __download_h__
#define __download_h__

// Provide a function to access the download object. At some point in the
// future we may do away with the global object; encapsulate the access here.
//
HRESULT
XferImage (LPSTGMEDIUM pStg,
           WIA_FORMAT_INFO &fmt,
           LPITEMIDLIST pidl);

HRESULT
XferAudio (LPSTGMEDIUM pStg,
           LPFORMATETC pFmt,
           LPITEMIDLIST pidl);
HRESULT SaveSoundToFile (IWiaItem *pItem, CSimpleString szFile);

HRESULT
RegisterDownloadStart (LPITEMIDLIST pidl, DWORD *pdw);

VOID
EndDownload (DWORD dw);

bool
IsDeviceBusy (LPITEMIDLIST pidl);

// structure for passing download data to the thread proc
struct XFERSTRUCT
{
    LPSTGMEDIUM pStg;
    WIA_FORMAT_INFO fmt;
    LPITEMIDLIST pidl;
    HANDLE hEvent;
    HRESULT hr;
};

struct AUDXFER
{
    LPSTGMEDIUM pStg;
    LPITEMIDLIST pidl;
    LPFORMATETC  pFmt;
    HANDLE hEvent;
    HRESULT hr;
};


//
// define a struct to store data about the download threads
//
struct XFERTHREAD
{
    DWORD dwTid;
    CComBSTR strDeviceId;
    HANDLE hThread;
    LONG  lCount;
};


//
// Define a struct for worker thread initialization

struct XTINIT
{
    XFERTHREAD *pxt;
    HANDLE     hReady;
    XTINIT () {hReady = NULL;pxt=NULL;}
    ~XTINIT () {if (hReady) CloseHandle(hReady);}
};


// Define messages use to communicate with the thread
#define MSG_GETDATA  WM_USER+120 // WPARAM: unused   LPARAM:XFERSTRUCT ptr
#define MSG_GETSOUND MSG_GETDATA+1
//
// CImageXfer provides download thread management for the namespace
// It keeps track of which devices currently have downloads in progress
// so the folder can disable access to items during transfers
// Each device gets its own worker thread for downloads.
//
class CImageXfer : public CUnknown
{
public:
    //
    // CUnknown provides ref counting to prevent DLL unload while our thread is running
    //
    STDMETHODIMP QueryInterface (REFIID riid, LPVOID* ppvObj) ;
    STDMETHODIMP_(ULONG) AddRef () ;
    STDMETHODIMP_(ULONG) Release ();
    CImageXfer ();

    HRESULT Xfer (LPSTGMEDIUM pStg,
                  WIA_FORMAT_INFO &fmt,
                  LPITEMIDLIST pidl);

    HRESULT XferAudio (LPSTGMEDIUM pStg,
                       LPFORMATETC pFmt,
                       LPITEMIDLIST pidl);

    // Register and Signal are used by other components which do
    // downloads, such as CImageStream, to let us know what's going n
    //
    HRESULT RegisterXferBegin (LPITEMIDLIST pidlDevice, DWORD *pdwCookie);
    VOID  SignalXferComplete (DWORD dwCookie);

    bool  IsXferInProgress (LPITEMIDLIST pidlDevice);
private:
    ~CImageXfer ();
    HRESULT FindThread (LPITEMIDLIST pidlDevice, XFERTHREAD **ppxt, bool bCreate=true);
    HRESULT CreateWorker (XFERTHREAD *pxt);

    static VOID XferThreadProc (XTINIT *pInit);


    HDPA m_dpaStatus; // array of status object pointers
    CSimpleCriticalSection m_cs;

    // no copy constructor or assignment operator should work
    CImageXfer &CImageXfer::operator =(IN const CImageXfer &rhs);
    CImageXfer::CImageXfer(IN const CImageXfer &rhs);
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\src\enum.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1997 - 1999
 *
 *  TITLE:       enum.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        11/1/97
 *
 *  DESCRIPTION: definiton of our IEnumIDList class
 *
 *****************************************************************************/

#ifndef __enum_h
#define __enum_h

// use this to free pidls from DPAs
INT _EnumDestroyCB(LPVOID pVoid, LPVOID pData);

class CBaseEnum : public IEnumIDList, IObjectWithSite, CUnknown
{
public:

    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();
    // *** IEnumIDList methods ***
    STDMETHODIMP Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    STDMETHODIMP Reset();
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Clone(IEnumIDList **ppenum);
    // *** IObjectWithSite methods ***
    STDMETHODIMP SetSite(IUnknown* punkSite);
    STDMETHODIMP GetSite(REFIID riid, void** ppunkSite);

private:
    STDMETHODIMP _Init(); 

protected:
    BOOL  m_fInitialized;
    UINT  m_cFetched;
    HDPA  m_hdpa;
    DWORD m_dwFlags;
    CComPtr<IMalloc> m_pMalloc;
    CComPtr<IWiaItem> m_pDevice;
    CComPtr<IUnknown> m_punkSite;
    CBaseEnum (DWORD grfFlags, IMalloc *pm);
    virtual ~CBaseEnum ();
    virtual HRESULT InitDPA () = 0;
};

class CDeviceEnum : public CBaseEnum
{
private:

    ~CDeviceEnum ();

public:
    CDeviceEnum (DWORD grfFlags, IMalloc *pm);
protected:
    HRESULT InitDPA ();
};

class CImageEnum : public CBaseEnum
{
private:
    LPITEMIDLIST  m_pidl;
    ~CImageEnum();

public:
    CImageEnum( LPITEMIDLIST pidl, DWORD grfFlags, IMalloc *pm);

protected:
    HRESULT InitDPA ();

};

HRESULT
_AddItemsFromCameraOrContainer( LPITEMIDLIST pidlFolder,
                                HDPA * phdpa,
                                DWORD dwFlags,
                                IMalloc *pm,
                                bool bIncludeAudio = false
                               );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\src\enum.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       enum.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        11/1/97
 *
 *  DESCRIPTION: IEnumIDList implementation for this project.
 *
 *****************************************************************************/
#pragma warning(disable:4100)
#include "precomp.hxx"
#pragma hdrstop


/*****************************************************************************

   _EnumDestroyCB

   Callback function for HDPA destroy -- lets us free our pidls when
   the object is deleted.

 *****************************************************************************/


INT _EnumDestroyCB(LPVOID pVoid, LPVOID pData)
{
    LPITEMIDLIST pidl = (LPITEMIDLIST)pVoid;

    TraceEnter(TRACE_CALLBACKS, "_EnumDestroyCB");
    DoILFree(pidl);

    TraceLeaveValue(TRUE);
}


/*****************************************************************************

   CImageEnum::CImageEnum,~::CImageEnum

   Constructor/Destructor for class

 *****************************************************************************/

CImageEnum::CImageEnum( LPITEMIDLIST pidl, DWORD grfFlags, IMalloc *pm )
    : CBaseEnum (grfFlags, pm)

{
    HRESULT hr = S_OK;

    TraceEnter(TRACE_ENUM, "CImageEnum::CImageEnum");

    if (!pidl)
    {
        hr = E_FAIL;
        m_pidl= NULL;
    }
    else
    {
        m_pidl = ILClone( pidl );
    }
    TraceLeaveResultNoRet(hr);

}

CImageEnum::~CImageEnum()
{
    TraceEnter (TRACE_ENUM, "CImageEnum::~CImageEnum");
    DoILFree( m_pidl );
    TraceLeave ();

}

HRESULT
CImageEnum::InitDPA ()
{
    return _AddItemsFromCameraOrContainer (m_pidl, &m_hdpa, m_dwFlags, m_pMalloc);
}

/*****************************************************************************

   _AddItemsFromCameraOrContainer

   Queries a device and items for the current level
   of the enumeration (either to root of the device or
   a container within the device).

 *****************************************************************************/

HRESULT
_AddItemsFromCameraOrContainer( LPITEMIDLIST pidlFolder,
                                HDPA * phdpa,
                                DWORD dwFlags,
                                IMalloc *pm,
                                bool bIncludeAudio
                               )
{

    HRESULT hr = E_FAIL;
    CComPtr<IWiaItem> pItem;
    CComPtr<IEnumWiaItem> pEnum;
    ULONG ul;
    ULONG cItems=0;
    CSimpleStringWide strDeviceId;

    TraceEnter (TRACE_ENUM, "_AddItemsFromCameraOrContainer");
    *phdpa = DPA_Create (10);
    if (!*phdpa)
    {
        hr = E_OUTOFMEMORY;
    }
    // First get the count of items and set the event
    else if (SUCCEEDED(IMGetItemFromIDL (pidlFolder, &pItem)))
    {
        IMGetDeviceIdFromIDL (pidlFolder, strDeviceId);
        if (SUCCEEDED(pItem->EnumChildItems (&pEnum)))
        {
            pEnum->GetCount (&cItems);

        }
    }
    if (!cItems)
    {
        hr = S_FALSE;
    }
    // now enum the items and build the DPA
    while (cItems && S_OK == pEnum->Next (1, &pItem, &ul))
    {
        LONG lType;
        LPITEMIDLIST pidl;
        pItem->GetItemType (&lType);
        if (((lType & WiaItemTypeFolder)&& (dwFlags & SHCONTF_FOLDERS))
              || (lType & WiaItemTypeFile) && (dwFlags & SHCONTF_NONFOLDERS))
        {
            pidl = IMCreateCameraItemIDL (pItem,
                                          strDeviceId,
                                          pm,
                                          false);
            if (pidl)
            {
                DPA_AppendPtr (*phdpa, pidl);
                if (bIncludeAudio && IMItemHasSound(pidl))
                {
                    LPITEMIDLIST pAudio = IMCreatePropertyIDL (pidl, WIA_IPC_AUDIO_DATA, pm);
                    if (pAudio)
                    {
                        if (-1 == DPA_AppendPtr (*phdpa, pAudio))
                        {
                            TraceMsg("Failed to insert pAudio into the DPA");
                            DoILFree(pAudio);
                        }
                    }
                }
            }
        }
        hr = S_OK;
        pItem = NULL;
    }

    TraceLeaveResult (hr);
}

/*****************************************************************************

   CBaseEnum::IUnknown stuff

   AddRef, Release, etc.

 *****************************************************************************/

#undef CLASS_NAME
#define CLASS_NAME CBaseEnum
#include "unknown.inc"



/*****************************************************************************

   CBaseEnum::QI Wrapper

   Use common QI code to handle QI requests.

 *****************************************************************************/

STDMETHODIMP CBaseEnum::QueryInterface(REFIID riid, LPVOID* ppvObject)
{
    INTERFACES iface[] =
    {
        &IID_IEnumIDList,     (LPENUMIDLIST)this,
        &IID_IObjectWithSite, (IObjectWithSite*)this,
    };

    return HandleQueryInterface(riid, ppvObject, iface, ARRAYSIZE(iface));
}


CBaseEnum::CBaseEnum (DWORD grfFlags, IMalloc *pm)
    : m_pMalloc (pm), m_dwFlags (grfFlags), m_fInitialized(FALSE), m_hdpa(NULL)
{    
    TraceEnter (TRACE_ENUM, "CBaseEnum::CBaseEnum");
    TraceLeave ();
}


CBaseEnum::~CBaseEnum ()
{
    TraceEnter (TRACE_ENUM, "CBaseEnum::~CBaseEnum");
    if (m_hdpa)
    {
        DPA_DestroyCallback(m_hdpa, _EnumDestroyCB, NULL);
        m_hdpa = NULL;
    }
    TraceLeave ();
}

HRESULT CBaseEnum::SetSite(IUnknown *punkSite)
{
    IUnknown_Set(&m_punkSite, punkSite);
    return S_OK;
}

HRESULT CBaseEnum::GetSite(REFIID riid, void **ppvSite)
{
    HRESULT hr = E_FAIL;
    *ppvSite = NULL;

    if (m_punkSite)
    {
        hr = m_punkSite->QueryInterface(riid, ppvSite);
    }
   
    return hr;
}

/*****************************************************************************

   CBaseEnum::Init

   Initialization code that requires the site, so we can't put it in the constructor

 *****************************************************************************/
HRESULT CBaseEnum::_Init()
{
    m_fInitialized = TRUE;
    return S_OK;
}
/*****************************************************************************

   CBaseEnum::Next

   Called to get the next item in the enumeration.

 *****************************************************************************/

STDMETHODIMP CBaseEnum::Next(ULONG celt, LPITEMIDLIST* rgelt, ULONG* pceltFetched)
{
    HRESULT hr = S_OK;
    ULONG celtOriginal = celt;
    TraceEnter(TRACE_ENUM, "CBaseEnum::Next");

    if (!m_fInitialized)
    {
        _Init();
    }

    ULONG ulRemaining;
    //
    // Validate the arguments and attempt to build the enumerator we
    // are going to be using.
    //
    // let's keep this code simple, most clients only do 1 per call anyway
    if ( !celt || !rgelt )
    {
        hr = E_INVALIDARG;
    }
    if (rgelt)
    {
        *rgelt = NULL;
    }
    if (pceltFetched)
    {
        *pceltFetched = 0;
    }
    if (!m_hdpa)
    {
        hr = InitDPA (); // virtual function to do the work
    }
    if (SUCCEEDED(hr))
    {
        ulRemaining = static_cast<ULONG>(DPA_GetPtrCount (m_hdpa)) - m_cFetched;
        if (!ulRemaining )
        {
            hr = S_FALSE;
        }
        else if (celt > ulRemaining )
        {
            celt = ulRemaining;
        }
    }
    ULONG celtFetched = 0;
    // Read the next available pidl from the DPA
    if (S_OK == hr)
    {        
        LPITEMIDLIST pidl;
        for (ULONG i=0; (i < ulRemaining) && (celtFetched < celt);i++)
        {
            Trace(TEXT("Returning next pidl"));
            pidl = ILClone (reinterpret_cast<LPITEMIDLIST>(DPA_FastGetPtr(m_hdpa, m_cFetched++)));
            *rgelt = pidl;
            rgelt++;
            celtFetched++;
        }
        if (pceltFetched)
        {
            *pceltFetched = celtFetched;
        }
    }
    if (S_OK == hr)
    {
        hr = (celtFetched == celtOriginal) ? S_OK : S_FALSE;
    }
    TraceLeaveResult(hr);

}


/*****************************************************************************

   CBaseEnum::Skip

   Skip celt items ahead in the enumeration.

 *****************************************************************************/

STDMETHODIMP CBaseEnum::Skip(ULONG celt)
{
    HRESULT hr = S_OK;

    TraceEnter(TRACE_ENUM, "CBaseEnum::Skip");

    if (!m_fInitialized)
    {
        _Init();
    }

    m_cFetched += celt;
    if (!m_hdpa || (m_cFetched > static_cast<ULONG>(DPA_GetPtrCount(m_hdpa))))
    {
        m_cFetched -= celt;
        hr = E_INVALIDARG;
    }

    TraceLeaveResult(hr);
}



/*****************************************************************************

   CBaseEnum::Reset

   Resets the enumeration to the beginning (item 0)

 *****************************************************************************/

STDMETHODIMP CBaseEnum::Reset()
{
    TraceEnter(TRACE_ENUM, "CBaseEnum::Reset");

    if (!m_fInitialized)
    {
        _Init();
    }

    m_cFetched = 0;

    TraceLeaveResult(S_OK);
}



/*****************************************************************************

   CBaseEnum::Clone

   Not implemented.

 *****************************************************************************/

STDMETHODIMP CBaseEnum::Clone(LPENUMIDLIST* ppenum)
{
    TraceEnter(TRACE_ENUM, "CBaseEnum::Clone");

    if (!m_fInitialized)
    {
        _Init();
    }

    TraceLeaveResult(E_NOTIMPL);
}



//************ CDeviceEnum methods

CDeviceEnum::CDeviceEnum (DWORD grfFlags, IMalloc *pm)
    : CBaseEnum (grfFlags, pm)
{
    TraceEnter (TRACE_ENUM, "CDeviceEnum::CDeviceEnum");

    TraceLeave ();
}

CDeviceEnum::~CDeviceEnum ()
{
    TraceEnter (TRACE_ENUM, "CDeviceEnum::~CDeviceEnum");
    TraceLeave ();
}



/*****************************************************************************

   IsDeviceInList

   Determines if given deviceid is in the HDPA

 *****************************************************************************/

BOOL
IsDeviceInList (const CSimpleStringWide &strDeviceId, HDPA hdpa)
{
    LPITEMIDLIST pidl;
    BOOL bRet = FALSE;
    CSimpleStringWide strId;
    UINT_PTR i=0;
    TraceEnter (TRACE_ENUM, "IsDeviceInList");

    pidl = reinterpret_cast<LPITEMIDLIST>(DPA_GetPtr(hdpa, i));
    while (pidl)
    {
        IMGetDeviceIdFromIDL (pidl, strId);
        if (strId == strDeviceId)
        {
            bRet = TRUE;
            pidl = NULL;
        }
        else
        {
            pidl = reinterpret_cast<LPITEMIDLIST>(DPA_GetPtr(hdpa, ++i));
        }
    }

    TraceLeave ();
    return bRet;
}



/*****************************************************************************

   CDeviceEnum::InitDPA

   Add devices tot he HDPA from the WIA dev manager.  This is for
   the root level of the namespace.

 *****************************************************************************/


HRESULT
CDeviceEnum::InitDPA( )
{
    HRESULT                     hr = S_OK;
    LPITEMIDLIST                pidl = NULL;

    DWORD dwCount = 0;
    PVOID pData = NULL;
    
    TraceEnter( TRACE_ENUM, "CDeviceEnum::InitDPA" );

    //
    // Create DPA to store items.
    //

    if (!(m_hdpa))
    {
        m_hdpa = DPA_Create( 4 );

       if (!m_hdpa)
       {
           hr = E_OUTOFMEMORY;
       }
    }

    if (SUCCEEDED(hr))
    {
        if ((m_dwFlags & SHCONTF_NONFOLDERS) && 
            !m_pMalloc && 
            (S_FALSE != SHShouldShowWizards(m_punkSite)) 
            && CanShowAddDevice())
        {
            pidl = (LPITEMIDLIST)IMCreateAddDeviceIDL(m_pMalloc);
        }

        if (pidl)
        {
            if (-1 == DPA_AppendPtr( m_hdpa, pidl ))
            {
                TraceMsg("Failed to insert Add Device pidl into the DPA");
                DoILFree(pidl);
            }
        }
        //
        // On Whistler, WIA can enumerate both WIA and STI devices
        // Only show local WIA devices in My Computer, other devices in Control Panel
        // In control panel we enumerate twice, in order to distinguish STI from WIA devices
        // do WIA first
        CComPtr<IWiaDevMgr> pDevMgr;
        
        if (SUCCEEDED(GetDevMgrObject(reinterpret_cast<LPVOID*>(&pDevMgr))))
        {
            CComPtr<IEnumWIA_DEV_INFO> pEnum;
            if (SUCCEEDED(pDevMgr->EnumDeviceInfo(0, &pEnum)))
            {
                CComPtr<IWiaPropertyStorage> ppstg;
                while (S_OK == pEnum->Next(1, &ppstg, NULL))
                {
                    WORD wtype;
                    GetDeviceTypeFromDevice(ppstg, &wtype);
                    if ( ((m_dwFlags & SHCONTF_FOLDERS) && (wtype == StiDeviceTypeDigitalCamera || wtype == StiDeviceTypeStreamingVideo))
                         || ((m_dwFlags & SHCONTF_NONFOLDERS) && (wtype == StiDeviceTypeScanner)) )
                    {
                        pidl = IMCreateDeviceIDL(ppstg, m_pMalloc);
                        if (pidl)
                        {
                            if ( -1 == DPA_AppendPtr( m_hdpa, pidl ) )
                            {
                                TraceMsg("Failed to insert device pidl into the DPA");
                                DoILFree(pidl);
                            }
                        }
                    }
                    ppstg = NULL;
                }
                pEnum = NULL;
                if (!m_pMalloc && (m_dwFlags & SHCONTF_NONFOLDERS)) // we're in control panel
                {
                    if (SUCCEEDED(pDevMgr->EnumDeviceInfo(DEV_MAN_ENUM_TYPE_STI, &pEnum)))
                    {
                        while (S_OK == pEnum->Next(1, &ppstg, NULL))
                        {
                            CSimpleStringWide strDeviceId;
                            PropStorageHelpers::GetProperty(ppstg, WIA_DIP_DEV_ID, strDeviceId);
                            if (!IsDeviceInList(strDeviceId, m_hdpa))
                            {
                                pidl = IMCreateSTIDeviceIDL(strDeviceId, ppstg, m_pMalloc);
                                if (pidl)
                                {
                                    if ( -1 == DPA_AppendPtr( m_hdpa, pidl ) )
                                    {
                                        TraceMsg("Failed to insert device pidl into the DPA");
                                        DoILFree(pidl);
                                    }
                                }
                            }
                            ppstg = NULL;                            
                        }
                    }
                }
            }
        }
    }
    TraceLeaveResult(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\src\factory.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1997 - 1999
 *
 *  TITLE:       factory.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        11/1/97
 *
 *  DESCRIPTION: OLE Class factory implementation for this project.
 *
 *****************************************************************************/
#include "precomp.hxx"
#pragma hdrstop



/*****************************************************************************

   CImageClassFactory::CImageClassFactory,::~CImageClassFactory

   Constructor / Desctructor for this class.

 *****************************************************************************/

CImageClassFactory::CImageClassFactory(REFCLSID rClsid)
{
    m_clsid = rClsid;
}


/*****************************************************************************

   CImageClassFactory::IUnknown stuff

   Use the general IUnknown class for implementation

 *****************************************************************************/

#undef CLASS_NAME
#define CLASS_NAME CImageClassFactory
#include "unknown.inc"


/*****************************************************************************

   CImageClassFactory::QI Wrapper

   setup code for our common QI class

 *****************************************************************************/

STDMETHODIMP
CImageClassFactory::QueryInterface(REFIID riid, LPVOID* ppvObject)
{
    INTERFACES iface[] =
    {
        &IID_IClassFactory, (LPCLASSFACTORY)this,
    };

    return HandleQueryInterface(riid, ppvObject, iface, ARRAYSIZE(iface));

}


/*****************************************************************************

   CImageClassFactory::CreateInstance [IClassFactory]

   Creates an instance of one of the classes we provide in this dll

 *****************************************************************************/

STDMETHODIMP
CImageClassFactory::CreateInstance( IUnknown* pOuter,
                                    REFIID riid,
                                    LPVOID* ppvObject
                                   )
{
    HRESULT hr = E_FAIL;




    TraceEnter(TRACE_FACTORY, "CImageClassFactory::CreateInstance");
    TraceGUID("Interface requested", riid);

    TraceAssert(ppvObject);

    // No support for aggregation, if we have an outer class then bail

    if ( pOuter )
        ExitGracefully(hr, CLASS_E_NOAGGREGATION, "Aggregation is not supported");

    if (IsEqualGUID (m_clsid, CLSID_WiaPropHelp))
    {
        CWiaPropUI *pPropUI = new CWiaPropUI();
        if (!pPropUI)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = pPropUI->QueryInterface (riid, ppvObject);
            pPropUI->Release();
        }
        
    }
    else if (IsEqualGUID (m_clsid, CLSID_WiaPropUI))
    {
        CPropSheetExt *pPropUI = new CPropSheetExt();
        if (!pPropUI)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = pPropUI->QueryInterface (riid, ppvObject);
            pPropUI->Release();
        }
    }
    else if (IsEqualGUID (m_clsid, CLSID_ImageFolderDataObj))
    {
        CImageDataObject *pobj = new CImageDataObject ();
        if (pobj)
        {
            hr = pobj->QueryInterface (riid, ppvObject);
            pobj->Release();
        }
    }
    else
    {
        CImageFolder  *pIMF    = NULL;
        // Our IShellFolder implementation is in CImageFolder along with several
        // other interfaces, therefore lets just create that object and allow
        // the QI process to continue there.
        pIMF = new CImageFolder( );

        if ( !pIMF )
            ExitGracefully(hr, E_OUTOFMEMORY, "Failed to allocate CImageFolder");

        hr = pIMF->QueryInterface(riid, ppvObject);
        pIMF->Release ();

    }
exit_gracefully:


    TraceLeaveResult(hr);
}

STDMETHODIMP
CImageClassFactory::LockServer(BOOL fLock)
{
    return S_OK;                // not supported
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\src\factory.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1997 - 1999
 *
 *  TITLE:       <FILENAME>
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        11/1/97
 *
 *  DESCRIPTION: Class factory class definition
 *
 *****************************************************************************/

#ifndef __factory_h
#define __factory_h

class CImageClassFactory : public IClassFactory, CUnknown
{
    public:
        CImageClassFactory(REFCLSID rClsid);

        // IUnkown
        STDMETHODIMP_(ULONG) AddRef();
        STDMETHODIMP_(ULONG) Release();
        STDMETHODIMP         QueryInterface(REFIID riid, LPVOID* ppvObject);

        // IClassFactory
        STDMETHODIMP CreateInstance(IUnknown* pOuter, REFIID riid, LPVOID* ppvObject);
        STDMETHODIMP LockServer(BOOL fLock);

    private:
        ~CImageClassFactory () {};
        CLSID m_clsid;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\src\folder.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1997 - 1999
 *
 *  TITLE:       folder.h
 *
 *  VERSION:     1.2
 *
 *  AUTHOR:      RickTu/DavidShi
 *
 *  DATE:        11/1/97
 *
 *  DESCRIPTION: CImageFolder defintion
 *
 *****************************************************************************/

#ifndef __folder_h
#define __folder_h


#undef  INTERFACE
#define INTERFACE   IImageFolder

DECLARE_INTERFACE_(IImageFolder, IUnknown)      // shi
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IImageFolder methods ***
    STDMETHOD(GetFolderType)(THIS_ folder_type * pfType) PURE;
    STDMETHOD(GetPidl)(THIS_ LPITEMIDLIST * ppidl) PURE;
    STDMETHOD(DoProperties) (LPDATAOBJECT pDataObject) PURE;
    STDMETHOD(IsDelegated)() PURE;
    STDMETHOD(ViewWindow)(IN OUT HWND *phwnd);
};

#define IMVMID_ARRANGEFIRST     (0)
#define IMVMID_ARRANGEBYNAME    (IMVMID_ARRANGEFIRST + 0)  // Arrange->by name
#define IMVMID_ARRANGEBYCLASS   (IMVMID_ARRANGEFIRST + 1)  // Arrange->by class or type
#define IMVMID_ARRANGEBYDATE    (IMVMID_ARRANGEFIRST + 2)  // Arrange->by date taken
#define IMVMID_ARRANGEBYSIZE    (IMVMID_ARRANGEFIRST + 3)  // Arrange->by size

#define UIKEY_ALL       0
#define UIKEY_SPECIFIC  1
#define UIKEY_MAX       2

extern ITEMIDLIST idlEmpty;

/*-----------------------------------------------------------------------------
/ CImageFolder - our IShell folder implementation
/----------------------------------------------------------------------------*/

class CImageFolder : public IPersistFolder2, IPersistFile, IShellFolder2,
                            IImageFolder, CUnknown,
                            IMoniker, IDelegateFolder
{
    private:

        LPITEMIDLIST         m_pidl;        // IDLIST to our object
        LPITEMIDLIST         m_pidlFull;    // absolute IDLIST to our object
        folder_type          m_type;
        CFolderDetails   *   m_pShellDetails;
        CComPtr<IMalloc>     m_pMalloc; // IMalloc used by IDelegate objects
        HWND                 m_hwnd; // given to us by the view callback

    private:
        STDMETHOD(RealInitialize)(LPCITEMIDLIST pidlRoot, LPCITEMIDLIST pidlBindTo );

        // no copy constructor or assignment operator should work
        CImageFolder &CImageFolder::operator =(IN const CImageFolder &rhs);
        CImageFolder::CImageFolder(IN const CImageFolder &rhs);

        // Define a function for creating the appropriate view callback object
        HRESULT CreateFolderViewCB (IShellFolderViewCB **pFolderViewCB);

        // icon overlay helper
        HRESULT GetOverlayIndexHelper(LPCITEMIDLIST pidl, int * pIndex, DWORD dwFlags);

        // thread proc for async properties display
        struct PROPDATA
        {
            DWORD dwDataCookie;
            CImageFolder *pThis;
            IGlobalInterfaceTable *pgit; // can be passed across thread boundaries
        };
        static VOID PropThreadProc (PROPDATA *pData);
        HRESULT _DoProperties (IDataObject *pDataObject);
        HRESULT GetWebviewProperty (LPITEMIDLIST pidl, const FMTID &fmtid, DWORD dwPid, VARIANT*pv);
        HRESULT GetShellDetail (LPITEMIDLIST pidl, DWORD dwPid, VARIANT *pv);
        ~CImageFolder();



    public:
        CImageFolder();

        // IUnknown
        STDMETHOD(QueryInterface)(REFIID riid, LPVOID* ppvObject);
        STDMETHOD_(ULONG, AddRef)();
        STDMETHOD_(ULONG, Release)();

        // IShellFolder
        STDMETHOD(ParseDisplayName)(HWND hwndOwner, LPBC pbcReserved, LPOLESTR pDisplayName, ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes);
        STDMETHOD(EnumObjects)(HWND hwndOwner, DWORD grfFlags, LPENUMIDLIST * ppEnumIDList);
        STDMETHOD(BindToObject)(LPCITEMIDLIST pidl, LPBC pbcReserved, REFIID riid, LPVOID * ppvOut);
        STDMETHOD(BindToStorage)(LPCITEMIDLIST pidl, LPBC pbcReserved, REFIID riid, LPVOID * ppvObj);
        STDMETHOD(CompareIDs)(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
        STDMETHOD(CreateViewObject)(HWND hwndOwner, REFIID riid, LPVOID * ppvOut);
        STDMETHOD(GetAttributesOf)(UINT cidl, LPCITEMIDLIST * apidl, ULONG * rgfInOut);
        STDMETHOD(GetUIObjectOf)(HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl, REFIID riid, UINT * prgfInOut, LPVOID * ppvOut);
        STDMETHOD(GetDisplayNameOf)(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET pName);
        STDMETHOD(SetNameOf)(HWND hwndOwner, LPCITEMIDLIST pidl, LPCOLESTR pszName, DWORD uFlags, LPITEMIDLIST* ppidlOut);


        // IPersist
        STDMETHOD(GetClassID)(LPCLSID pClassID);

        // IPersistFolder
        STDMETHOD(Initialize)(LPCITEMIDLIST pidlStart);

        // IPersistFolder2
        STDMETHOD(GetCurFolder)(THIS_ LPITEMIDLIST *ppidl);

        // IPersistFile
        STDMETHOD(IsDirty)(void);
        STDMETHOD(Load)(LPCOLESTR pszFileName, DWORD dwMode);
        STDMETHOD(Save)(LPCOLESTR pszFileName, BOOL fRemember);
        STDMETHOD(SaveCompleted)(LPCOLESTR pszFileName);
        STDMETHOD(GetCurFile)(LPOLESTR *ppszFileName);

        //IPersistStream
        STDMETHOD(Load)(IStream *pStm);
        STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty);
        STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize);

        // IImageFolder
        STDMETHOD(GetFolderType)(folder_type * pfType);
        STDMETHOD(GetPidl)(THIS_ LPITEMIDLIST * ppidl);
        STDMETHOD(DoProperties) (LPDATAOBJECT pDataObject);
        STDMETHOD(IsDelegated)() {if (!m_pMalloc) return S_FALSE; return S_OK;};
        STDMETHOD(ViewWindow)(IN OUT HWND *phwnd);
        // IShellFolder2
        STDMETHOD(EnumSearches)(IEnumExtraSearch **ppEnum);
        STDMETHOD(GetDefaultColumn)(DWORD dwReserved, ULONG *pSort, ULONG *pDisplay);
        STDMETHOD(GetDefaultColumnState)(UINT iColumn, DWORD *pbState);
        STDMETHOD(GetDefaultSearchGUID)(LPGUID lpGUID);
        STDMETHOD(GetDetailsEx)(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv);
        STDMETHOD(MapColumnToSCID)(UINT idCol, SHCOLUMNID *pscid);
        STDMETHOD(GetDetailsOf)(LPCITEMIDLIST pidl, UINT iColumn, LPSHELLDETAILS pDetails);

        // IMoniker
        STDMETHOD(BindToObject)(IBindCtx *pbc, IMoniker *pmkToLeft, REFIID riidResult, void **ppvResult);
        STDMETHOD(BindToStorage)(IBindCtx *pbc, IMoniker *pmkToLeft, REFIID riid, void **ppvObj);
        STDMETHOD(Reduce)(IBindCtx *pbc, DWORD dwReduceHowFar, IMoniker **ppmkToLeft, IMoniker **ppmkReduced);
        STDMETHOD(ComposeWith)(IMoniker *pmkRight, BOOL fOnlyIfNotGeneric, IMoniker **ppmkComposite);
        STDMETHOD(Enum)(BOOL fForward, IEnumMoniker **ppenumMoniker);
        STDMETHOD(IsEqual)(IMoniker *pmkOtherMoniker);
        STDMETHOD(Hash)(DWORD *pdwHash);
        STDMETHOD(IsRunning)(IBindCtx *pbc, IMoniker *pmkToLeft, IMoniker *pmkNewlyRunning);
        STDMETHOD(GetTimeOfLastChange)(IBindCtx *pbc, IMoniker *pmkToLeft, FILETIME *pFileTime);
        STDMETHOD(Inverse)(IMoniker **ppmk);
        STDMETHOD(CommonPrefixWith)(IMoniker *pmkOther, IMoniker **ppmkPrefix);
        STDMETHOD(RelativePathTo)(IMoniker *pmkOther, IMoniker **ppmkRelPath);
        STDMETHOD(GetDisplayName)(IBindCtx *pbc, IMoniker *pmkToLeft, LPOLESTR *ppszDisplayName);
        STDMETHOD(ParseDisplayName)(IBindCtx *pbc, IMoniker *pmkToLeft, LPOLESTR pszDisplayName, ULONG *pchEaten, IMoniker **ppmkOut);
        STDMETHOD(IsSystemMoniker)(DWORD *pdwMksys);


        // IDelegateFolder
        STDMETHOD(SetItemAlloc)(IMalloc *pm);
};

// Define an InfoTip object for providing status bar text for our objects
class CInfoTip : public CUnknown, IQueryInfo
{
public:
    CInfoTip (LPITEMIDLIST pidl, BOOL bDelegate);
    // IUnknown
    STDMETHODIMP QueryInterface (REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef () ;
    STDMETHODIMP_(ULONG) Release();

    // IQueryInfo
    STDMETHODIMP GetInfoFlags(DWORD *dwFlags);
    STDMETHODIMP GetInfoTip  (DWORD dwFlags, LPWSTR *ppwszTip);

private:
    LPITEMIDLIST m_pidl;
    BOOL         m_bDelegate;
    ~CInfoTip ();

};


// Define struct to support GetDetailsEx and MapColumnToSCID
typedef struct
{
    short int iCol;
    short int ids;        // string ID for title
    short int cchCol;     // Number of characters wide to make column
    short int iFmt;       // The format of the column;
    const SHCOLUMNID* pscid;
} COL_DATA;

#define DEFINE_SCID(name, fmtid, pid) const SHCOLUMNID name = { fmtid, pid }
// this FMTID is for properties we show in details view. They come straight from WIA
#define PSGUID_WIAPROPS {0x38276c8a,0xdcad,0x49e8,{0x85, 0xe2, 0xb7, 0x38, 0x92, 0xff, 0xfc, 0x84}}

// this FMTID is for extended properties we give to our web view. Each property
// has a function associated with it for generating the VARIANT
/* 6e79e3c5-fd7f-488f-a10d-156636e1c71c */
#define PSGUID_WEBVWPROPS {0x6e79e3c5,0xfd7f,0x488f,{0xa1, 0x0d, 0x15, 0x66, 0x36, 0xe1, 0xc7, 0x1c}}

typedef HRESULT (*FNWEBVWPROP)(CImageFolder *pFolder, LPITEMIDLIST pidl, DWORD dwPid, VARIANT *pVariant);
struct WEBVW_DATA
{
    DWORD dwPid;
    FNWEBVWPROP fnProp;
};

// these are the webview property functions
HRESULT CanTakePicture (CImageFolder *pFolder, LPITEMIDLIST pidl, DWORD dwPid, VARIANT *pVariant);
HRESULT NumPicsTaken (CImageFolder *pFolder, LPITEMIDLIST pidl, DWORD dwPid, VARIANT *pVariant);
HRESULT ExecuteWebViewCommand (CImageFolder *pParent, LPITEMIDLIST pidlFolder, DWORD dwPid);
HRESULT GetFolderPath (CImageFolder *pFolder, LPITEMIDLIST pidl, DWORD dwPid, VARIANT *pVariant);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\src\icon.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       icon.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        11/1/97
 *
 *  DESCRIPTION: IExtractIcon class definition
 *
 *****************************************************************************/

#ifndef __icon_h
#define __icon_h


class CImageExtractIcon : public IExtractIcon, CUnknown
{
    private:
        LPITEMIDLIST m_pidl;

        ~CImageExtractIcon();

    public:
        CImageExtractIcon( LPITEMIDLIST pidl );


        // IUnknown
        STDMETHOD(QueryInterface)(REFIID riid, LPVOID* ppvObject);
        STDMETHOD_(ULONG, AddRef)();
        STDMETHOD_(ULONG, Release)();

        // IExtractIcon
        STDMETHOD(GetIconLocation)(UINT uFlags, LPTSTR szIconFile, UINT cchMax, int* pIndex, UINT* pwFlags);
        STDMETHOD(Extract)(LPCTSTR pszFile, UINT nIconIndex, HICON* pLargeIcon, HICON* pSmallIcon, UINT nIconSize);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\src\idlist.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1997 - 1999
 *
 *  TITLE:       <FILENAME>
 *
 *  VERSION:     1.5
 *
 *  AUTHOR:      RickTu/DavidShi
 *
 *  DATE:        11/1/97
 *
 *  DESCRIPTION: Definitions for our idlists*
 *****************************************************************************/

#ifndef __idlist_h
#define __idlist_h


#define IMIDL_MAGIC             (DWORD)0x03150326

// Flags for IDLIST...

#define IMIDL_DEVICEIDL         (DWORD)0x00000001
#define IMIDL_CAMERAITEM        (DWORD)0x00000002
#define IMIDL_SCANNERITEM       (DWORD)0x00000004
#define IMIDL_CONTAINER         (DWORD)0x00000008
#define IMIDL_REMOTEDEVICE      (DWORD)0x00000010
#define IMIDL_ADDDEVICE         (DWORD)0x80000000
#define IMIDL_STIDEVICEIDL      (DWORD)0x00000020
#define IMIDL_PROPERTY                 0x00000080 // used to denote a propid for a WIA property




// public routines...


LPITEMIDLIST IMCreateAddDeviceIDL( IMalloc *pm);
LPITEMIDLIST IMCreateDeviceIDL( IWiaPropertyStorage * pDevProp, IMalloc *pm );
LPITEMIDLIST IMCreateDeviceIDL( IWiaItem *pRootItem, IMalloc *pm);
LPITEMIDLIST IMCreateDeviceIDL (PSTI_DEVICE_INFORMATION pDevice, IMalloc *pm);
LPITEMIDLIST IMCreateCameraItemIDL( IWiaItem * pWiaItem, LPCWSTR szDeviceId, IMalloc *pm, bool bPreFetchThumb=false );
LPITEMIDLIST IMCreateScannerItemIDL( IWiaItem *pWiaItem, IMalloc *pm );
LPITEMIDLIST IMCreateSTIDeviceIDL (PSTI_DEVICE_INFORMATION psdi, IMalloc *pm);
BOOL         IMIsOurIDL( LPITEMIDLIST pidl );
HRESULT      IMGetParsingNameFromIDL( LPITEMIDLIST pidl, CSimpleStringWide &strName );
HRESULT      IMGetCreateTimeFromIDL( LPITEMIDLIST pidl, LPFILETIME pTime );
HRESULT      IMGetImageSizeFromIDL( LPITEMIDLIST pidl, ULONG * pSize );
HRESULT      IMGetImagePreferredFormatFromIDL( LPITEMIDLIST pidl, GUID * pPreferredFormat, LPTSTR pExt );
DWORD        IMGetDeviceTypeFromIDL( LPITEMIDLIST pidl, bool bBrief=true );
ULONG        IMGetItemTypeFromIDL (LPITEMIDLIST pidl);
HRESULT      IMGetFullPathNameFromIDL( LPITEMIDLIST pidl, BSTR * ppFullPath );
HRESULT      IMGetIconInfoFromIDL( LPITEMIDLIST pidl, LPTSTR pIconPath, UINT cch, INT * pIndex, UINT *pwFlags );
HRESULT      IMCreateIDLFromParsingName( LPOLESTR pName, LPITEMIDLIST * ppidl, LPCWSTR szDeviceId, IMalloc *pm, LPCWSTR szFolder = NULL );
BOOL         IsDeviceIDL( LPITEMIDLIST pidlIN );
BOOL         IsCameraItemIDL( LPITEMIDLIST pidlIN );
BOOL         IsScannerItemIDL( LPITEMIDLIST pidlIN );
BOOL         IsContainerIDL( LPITEMIDLIST pidlIN );
BOOL         IsAddDeviceIDL( LPITEMIDLIST pidlIN );
BOOL         IsRemoteItemIDL (LPITEMIDLIST pidlIN);
BOOL         IsSTIDeviceIDL (LPITEMIDLIST pidlIN);
LPITEMIDLIST IMCreateIDLFromItem (IWiaItem *pItem, IMalloc *pm);
BOOL         IMItemHasSound (LPITEMIDLIST pidl);
LONG         IMGetAccessFromIDL (LPITEMIDLIST pidl);

BOOL IMGetAudioFormat (LPITEMIDLIST pidl, CSimpleStringWide &strExt);

HRESULT      IMGetNameFromIDL (LPITEMIDLIST pidl, CSimpleStringWide &strName);
HRESULT      IMGetPropertyFromIDL (LPITEMIDLIST pidl, HGLOBAL *phGlobal);
LPITEMIDLIST IMCreatePropertyIDL (LPITEMIDLIST pidlItem, PROPID propid, IMalloc *pm);
BOOL         IsPropertyIDL (LPITEMIDLIST pidlIN);
HRESULT      STIDeviceIDLFromId (LPCWSTR szId, LPITEMIDLIST *ppidl, IMalloc *pm);
LPITEMIDLIST IMCreateSTIDeviceIDL(const CSimpleStringWide &strDeviceId, IWiaPropertyStorage *ppstg, IMalloc *pm);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\src\folder.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1997 - 2000
 *
 *  TITLE:       folder.cpp
 *
 *  VERSION:     1.3
 *
 *  AUTHOR:      RickTu/DavidShi
 *
 *  DATE:        11/1/97
 *
 *  DESCRIPTION: This code implements the IShellFolder interface (and
 *               associated interfaces) for the WIA shell extension.
 *
 *****************************************************************************/

#include "precomp.hxx"
#include "runnpwiz.h"
#pragma hdrstop

void RegisterImageClipboardFormats(void);

ITEMIDLIST idlEmpty = { 0, 0 };

static const TCHAR  cszAllDevices[]    = TEXT("AllDevices");
static const TCHAR  cszScannerDevice[] = TEXT("Scanner");
static const TCHAR  cszCameraDevice[]  = TEXT("Camera");
static const TCHAR  cszCameraContainerItems[] = TEXT("CameraContainerItems");
static const TCHAR  cszAddDevice[]     = TEXT("AddDevice");
static const WCHAR  cszAddDeviceName[] = TEXT("ScanCam_NewDevice");

DEFINE_GUID(FMTID_WiaProps, 0x38276c8a,0xdcad,0x49e8,0x85, 0xe2, 0xb7, 0x38, 0x92, 0xff, 0xfc, 0x84);


/*****************************************************************************

   _GetKeysForIDL

   Returns registry keys associated with the given idlists...

   In:
     cidl    -> # of idliss in aidl
     aidl    -> array of idlists
     cKeys   -> size of aKeys
     aKeys   -> array to hold retrieved registry keys

   Out:
     HRESULT

 *****************************************************************************/

static const TCHAR c_szMenuKey[] = TEXT("CLSID\\%s\\");
#define LEN_CLSID    50
HRESULT
_GetKeysForIDL( UINT cidl,
                LPCITEMIDLIST *aidl,
                UINT cKeys,
                HKEY *aKeys
               )
{
    HRESULT             hr = S_OK;


    TCHAR               szGeneric[ MAX_PATH ]; // key for global extensions
    TCHAR               szSpecific [MAX_PATH] = TEXT(""); // key for extensions specific to this device
    LONG                lRes;
    LPITEMIDLIST        pidl;
    BOOL                bDevice;
    BOOL                bAddDevice;

    TraceEnter( TRACE_FOLDER, "_GetKeysForIDL" );

    //
    // zero out the array of registry keys...
    //

    ZeroMemory( (LPVOID)aKeys, cKeys * sizeof(HKEY) );


    lstrcpy( szGeneric, REGSTR_PATH_NAMESPACE_CLSID );
    lstrcat( szGeneric, TEXT("\\") );

    //
    // If there is just one device selected, then get the correct
    // verbs for that device...
    //
    pidl = (LPITEMIDLIST)*aidl;

    bDevice = IsDeviceIDL( pidl );
    bAddDevice = IsAddDeviceIDL (pidl);
    if ((cidl == 1) && (bDevice))
    {
        DWORD dwDeviceType  = IMGetDeviceTypeFromIDL( pidl );
        switch (dwDeviceType)
        {
        case StiDeviceTypeStreamingVideo:
        case StiDeviceTypeDigitalCamera:
            lstrcat( szGeneric, cszCameraDevice );
            break;

        case StiDeviceTypeScanner:
            lstrcat( szGeneric, cszScannerDevice );
            break;

        case StiDeviceTypeDefault:
        default:
            lstrcat( szGeneric, cszAllDevices );
            break;

        }
    }
    else if ((cidl == 1) && (bAddDevice))
    {
        lstrcat( szGeneric, cszAddDevice );
    }
    else
    {

        BOOL bAllCameraItemContainers = TRUE;
        INT i;

        //
        // If all items are camera item and not a container, use the
        // camera item key
        //

        for (i = 0; i < (INT)cidl; i++)
        {
            if (IsCameraItemIDL( (LPITEMIDLIST)aidl[i] ))
            {
                if (IsContainerIDL( (LPITEMIDLIST)aidl[i]))
                {
                    bAllCameraItemContainers &= TRUE;
                }
            }
            else
            {
                bAllCameraItemContainers = FALSE;
            }
        }

        if ( bAllCameraItemContainers )
        {
            lstrcat( szGeneric, cszCameraContainerItems );
        }
        else
        {
            ExitGracefully( hr, E_FAIL, "no keys to open for these pidls" );
        }

    }
    // Get the keys for the specific device chosen, or for the device that contains the chosen items
    if (!bAddDevice && (cidl==1  || !bDevice))
    {
        CComPtr<IWiaPropertyStorage>   pWiaItemRoot;
        CSimpleStringWide   strDeviceId(L"");
        TCHAR    szClsid[LEN_CLSID];

        IMGetDeviceIdFromIDL (pidl, strDeviceId);
        hr = GetDeviceFromDeviceId (strDeviceId, IID_IWiaPropertyStorage, (LPVOID*)&pWiaItemRoot, FALSE);
        FailGracefully (hr, "GetDeviceFromDeviceId failed in _GetKeysForIDL");
        if (S_OK == GetClsidFromDevice (pWiaItemRoot, szClsid))
        {
            lstrcat (szSpecific, TEXT("CLSID\\"));
            lstrcat (szSpecific, szClsid);
            RegOpenKeyEx (HKEY_CLASSES_ROOT, szSpecific, 0, KEY_READ, &aKeys[UIKEY_SPECIFIC]);
        }
    }

    Trace(TEXT("attempting to open: HKEY_CLASSES_ROOT\\%s"), szGeneric );
    lRes = RegOpenKeyEx( HKEY_CLASSES_ROOT, szGeneric, 0, KEY_READ, &aKeys[UIKEY_ALL] );
    if (lRes != NO_ERROR)
        ExitGracefully( hr, E_FAIL, "couldn't open generic hkey" );

exit_gracefully:
    TraceLeaveResult(hr);

}


/*****************************************************************************

   _MergeArrangeMenu

   Merge our verbs into the view menu

 *****************************************************************************/

HRESULT
_MergeArrangeMenu( LPARAM arrangeParam,
                   LPQCMINFO pInfo
                   )
{

    MENUITEMINFO mii = { SIZEOF(MENUITEMINFO), MIIM_SUBMENU };
    UINT idCmdFirst = pInfo->idCmdFirst;
    HMENU hMyArrangeMenu;

    TraceEnter(TRACE_FOLDER, "_MergeArrangeMenu");
    Trace(TEXT("arrangeParam %08x, pInfo->idCmdFirst %08x"), arrangeParam, idCmdFirst);

    if ( GetMenuItemInfo(pInfo->hmenu, SFVIDM_MENU_ARRANGE, FALSE, &mii) )
    {
        hMyArrangeMenu = LoadMenu(GLOBAL_HINSTANCE, MAKEINTRESOURCE(IDR_ARRANGE));

        if ( hMyArrangeMenu )
        {
            pInfo->idCmdFirst = Shell_MergeMenus(mii.hSubMenu,
                                                 GetSubMenu(hMyArrangeMenu, 0),
                                                 0,
                                                 idCmdFirst, pInfo->idCmdLast,
                                                 0);
            DestroyMenu(hMyArrangeMenu);
        }
    }

    TraceLeaveResult(S_OK);
}

/*****************************************************************************
    _FormatCanPreview
    
    Checks the image format against the list of known image formats the
    preview applet works with
    
*****************************************************************************/
static const GUID* caSuppFmt[] = 
{
    &WiaImgFmt_JPEG,
    &WiaImgFmt_TIFF,
    &WiaImgFmt_BMP,
    &WiaImgFmt_MEMORYBMP,
    &WiaImgFmt_EXIF,
    &WiaImgFmt_GIF,
    &WiaImgFmt_PNG,
    &WiaImgFmt_EMF,
    &WiaImgFmt_WMF,
    &WiaImgFmt_ICO,
    &WiaImgFmt_JPEG2K,    
};

BOOL _FormatCanPreview(const GUID* pFmt)
{
    BOOL bRet = FALSE;
    for (int i=0;i<ARRAYSIZE(caSuppFmt) && !bRet;i++)
    {
        bRet = (*pFmt == *caSuppFmt[i]);
    }
    return bRet;
}
/*****************************************************************************

   _MergeContextMenu

   Merge in our verbs int the context menu for
   the items specified in the data object...

 *****************************************************************************/

HRESULT
_MergeContextMenu( LPDATAOBJECT pDataObject,
                   UINT uFlags,
                   LPQCMINFO pInfo,
                   bool bDelegate
                  )
{
    HRESULT         hr = S_OK;
    HMENU           hMyContextMenu = NULL;
    UINT            cidl = 0;
    LPITEMIDLIST    pidl = NULL;
    INT             i;
    ULONG           uItems  = 0;
    LPIDA           lpida = NULL;
    LPITEMIDLIST    pidlImage = NULL;

    TraceEnter(TRACE_FOLDER, "_MergeContextMenu");

    // ON NT everything should work
    #ifdef NODELEGATE
    bDelegate = true;
    #endif
    //
    // First, get the IDA for the data object...
    //

    hr = GetIDAFromDataObject( pDataObject, &lpida );
    FailGracefully( hr, "couldn't get lpida from dataobject!" );

    //
    // Loop through all the items to see what we got...
    //

    #define CAMERA_ITEM       0x0001
    #define CAMERA_CONTAINER  0x0002
    #define OTHER_ITEM        0x0004

    //
    // S_FALSE tells the shell not to add any menu items of its own...
    // S_OK means add the default shell stuff
    hr = S_OK;
    cidl = lpida->cidl;

    // Check for trying to invoke a scanner
    if (cidl == 1)
    {                
        pidl = (LPITEMIDLIST)(((LPBYTE)lpida) + lpida->aoffset[1]);
        if (IsDeviceIDL(pidl))
        {

            DWORD dwType = IMGetDeviceTypeFromIDL (pidl);
            CSimpleStringWide strDeviceId;
            CComPtr<IWiaPropertyStorage> pProps;
            IMGetDeviceIdFromIDL (pidl, strDeviceId);
            // don't add menu items if the device isn't installed. This keeps the user from getting
            // commands on shortcuts to disconnected devices.
            if (SUCCEEDED(GetDeviceFromDeviceId (strDeviceId, IID_IWiaPropertyStorage, reinterpret_cast<LPVOID*>(&pProps), FALSE)))
            {
            
                switch  (dwType)
                {
                    case StiDeviceTypeScanner :
                        hMyContextMenu = LoadMenu (GLOBAL_HINSTANCE, MAKEINTRESOURCE(IDR_SCANNER));
                        // set scanning to be the default option for a scanner
                        SetMenuDefaultItem (GetSubMenu (hMyContextMenu, 0), 
                                            bDelegate ? IMID_S_ACQUIRE : IMID_S_WIZARD, 
                                            MF_BYCOMMAND);
                        hr = S_FALSE;
                        break;

                    case StiDeviceTypeStreamingVideo:
                    case StiDeviceTypeDigitalCamera:
                        hMyContextMenu = LoadMenu (GLOBAL_HINSTANCE, MAKEINTRESOURCE(IDR_CAMERA));
                        //
                        // If we are non-delegated, i.e. in Control Panel, we don't want an Open verb
                        if (!bDelegate)
                        {
                            SetMenuDefaultItem (GetSubMenu(hMyContextMenu, 0), IMID_C_WIZARD, MF_BYCOMMAND);
                            hr = S_FALSE;
                        }

                        break;
                }
            }
            else
            {
                hr = S_FALSE;
            }
            goto buildmenu;
        }
        ProgramDataObjectForExtension (pDataObject, pidl);
    }

    for (i = 1; (i-1) < (INT)cidl; i++)
    {
        pidl = (LPITEMIDLIST)(((LPBYTE)lpida) + lpida->aoffset[i]);

        if (IsCameraItemIDL( pidl ))
        {
            if (IsContainerIDL( pidl ))
            {
                uItems |= CAMERA_CONTAINER;
            }
            else
            {
                uItems |= CAMERA_ITEM;
                pidlImage = pidl;
            }
        }
        else if (IsPropertyIDL (pidl))
        {
            // Don't mark audio properties as anything special
            continue;
        }
        else
        {
            uItems |= OTHER_ITEM;
        }
    }

    //
    // Based on what kinds of pidls we have, add the corresponding
    // menu items to the context menu
    //

    if ( (!(uItems & OTHER_ITEM))
           &&
         (uItems & (CAMERA_ITEM | CAMERA_CONTAINER))
        )
    {
        if (uItems & CAMERA_CONTAINER)
        {
            Trace(TEXT("Don't have a context menu for camera containers yet"));
            hMyContextMenu = NULL;
            if (uItems & CAMERA_ITEM)
            {
                hr = S_FALSE;
            }
            else
            {
                hr = S_OK;
            }

        }
        else
        {
            CLSID clsid;
            hMyContextMenu = LoadMenu(GLOBAL_HINSTANCE,
                                      MAKEINTRESOURCE(IDR_CAMERAITEMS));
            // remove sound entries if not applicable
            // Objects with sounds have a pidl for the image plus a pidl
            // for the sound property
            if (cidl != 2 || !IMItemHasSound(pidlImage))
            {
                RemoveMenu(hMyContextMenu, IMID_CI_PLAYSND, MF_BYCOMMAND);
                RemoveMenu(hMyContextMenu, IMID_CI_SAVESND, MF_BYCOMMAND);

            }
            // Add Save in My Pictures, using the proper string
            LPITEMIDLIST pidlPics;
            if (SUCCEEDED(SHGetFolderLocation(NULL, 
                                              CSIDL_MYPICTURES | CSIDL_FLAG_CREATE, 
                                              NULL, 
                                              SHGFP_TYPE_CURRENT, 
                                              &pidlPics)))
            {
                SHFILEINFO sfi={0};
                if(SHGetFileInfo((LPCTSTR)pidlPics, 0, 
                                 &sfi, sizeof(sfi), 
                                 SHGFI_PIDL | SHGFI_DISPLAYNAME))
                {
                    MENUITEMINFO mii = {0};
                    // pick a reasonable max number of characters to put in the menu string
                    TCHAR szMaxPath[32];
                    CSimpleStringWide strSave;
                    mii.cbSize = sizeof(mii);
                    mii.fMask = MIIM_STRING | MIIM_ID;
                    mii.wID = IMID_CI_MYPICS;
                    PathCompactPathEx(szMaxPath, sfi.szDisplayName, ARRAYSIZE(szMaxPath), 0);
                    strSave.Format(IDS_SAVE_MYPICS, GLOBAL_HINSTANCE, szMaxPath);
                    mii.dwTypeData = const_cast<LPWSTR>(strSave.String());
                    InsertMenuItem(GetSubMenu(hMyContextMenu, 0), 1, TRUE, &mii);                
                }
                DoILFree(pidlPics);
            }
            //
            // If the preferred image format is not one that can be Previewed, remove
            // the preview verb
            //
            GUID guidFormat;
            IMGetImagePreferredFormatFromIDL(pidl, &guidFormat, NULL);
            if (!_FormatCanPreview(&guidFormat))
            {
                RemoveMenu(hMyContextMenu, IMID_CI_PREVIEW, MF_BYCOMMAND);
                SetMenuDefaultItem (GetSubMenu (hMyContextMenu, 0), 
                                    IMID_CI_MYPICS,
                                    MF_BYCOMMAND);
            }
            hr = S_FALSE;
        }
    }
    //
    // Add the items to the menu...
    //
buildmenu:


    if ( hMyContextMenu )
    {
        pInfo->idCmdFirst = Shell_MergeMenus( pInfo->hmenu,
                                              GetSubMenu(hMyContextMenu,0),
                                              0,  // pInfo->indexMenu?
                                              pInfo->idCmdFirst,
                                              pInfo->idCmdLast,
                                              MM_ADDSEPARATOR | MM_DONTREMOVESEPS
                                             );
        DestroyMenu(hMyContextMenu);



    }


exit_gracefully:

    if (lpida)
    {
        LocalFree( lpida );
        lpida = NULL;
    }

    TraceLeaveResult(hr);


}



/*****************************************************************************

   _FolderItemCMCallBack

   Handles callbacks for the context menu which is
   displayed when the user right clicks on objects
   within the view.

 *****************************************************************************/

HRESULT
CALLBACK
_FolderItemCMCallback( LPSHELLFOLDER psf,
                       HWND hwndView,
                       LPDATAOBJECT pDataObject,
                       UINT uMsg,
                       WPARAM wParam,
                       LPARAM lParam
                      )
{
    HRESULT hr = NOERROR;

    TraceEnter( TRACE_CALLBACKS, "_FolderItemCMCallback" );
    TraceMenuMsg( uMsg, wParam, lParam );


    bool bDelegate;
    CComQIPtr<IImageFolder, &IID_IImageFolder> pif(psf);
    if (!pif)
    {
        bDelegate = false;
    }
    else
    {
        bDelegate = (S_OK == pif->IsDelegated());
    }
    switch ( uMsg )
    {
        case DFM_MERGECONTEXTMENU:
            {

                hr = _MergeContextMenu( pDataObject, (UINT)wParam, (LPQCMINFO)lParam, bDelegate );
            }

            break;

        case DFM_GETVERBW:
            {
                hr = S_FALSE;
                Trace(TEXT("Asked for verb %d"), LOWORD(wParam));
                if (LOWORD(wParam) == IMID_C_TAKE_PICTURE)
                {
                    wcscpy(reinterpret_cast<LPWSTR>(lParam), L"TakePicture");
                    hr = S_OK;
                }
                else if (LOWORD(wParam) == IMID_C_WIZARD)
                {
                    wcscpy(reinterpret_cast<LPWSTR>(lParam), L"SaveAll");
                    hr = S_OK;
                }
                else if (LOWORD(wParam) == IMID_CI_PRINT)
                {
                    wcscpy(reinterpret_cast<LPWSTR>(lParam), L"print");
                    hr = S_OK;
                }
            }
            break;

        case DFM_MAPCOMMANDNAME:
            hr = E_NOTIMPL;
            if (!lstrcmpi(reinterpret_cast<LPCTSTR>(lParam), TEXT("TakePicture")))
            {
                *(reinterpret_cast<int *>(wParam)) = IMID_C_TAKE_PICTURE;
                hr = S_OK;
            }
            else if (!lstrcmpi(reinterpret_cast<LPCTSTR>(lParam), TEXT("SaveAll")))
            {
                *(reinterpret_cast<int *>(wParam)) = IMID_C_WIZARD;
                hr = S_OK;
            } 
            else if (!lstrcmpi(reinterpret_cast<LPCTSTR>(lParam), TEXT("print")))
            {
                *(reinterpret_cast<int *>(wParam)) = IMID_CI_PRINT;
                hr = S_OK;
            }
            break;

        case DFM_INVOKECOMMANDEX:
        {
            switch ( wParam )
            {
                case DFM_CMD_DELETE:
                    hr = DoDeleteItem( hwndView, pDataObject, FALSE );
                    break;

                case DFM_CMD_PROPERTIES:
                {

                    pif->DoProperties( pDataObject );
                }

                    break;

                case IMID_CI_PREVIEW:
                    DoPreviewVerb( hwndView, pDataObject );
                    break;

                case IMID_CI_MYPICS:
                    DoSaveInMyPics( hwndView, pDataObject );
                    break;


                case IMID_CI_PLAYSND:
                    DoPlaySndVerb (hwndView, pDataObject);
                    break;

                case IMID_CI_SAVESND:
                    DoSaveSndVerb (hwndView, pDataObject);
                    break;

                case IMID_S_ACQUIRE:
                    DoAcquireScanVerb (hwndView, pDataObject);
                    break;

                case IMID_S_WIZARD:
                case IMID_C_WIZARD:
                    DoWizardVerb (hwndView, pDataObject);
                    break;

                case IMID_C_TAKE_PICTURE:
                    DoTakePictureVerb (hwndView, pDataObject);
                    break;

                case IMID_CI_PRINT:
                    DoPrintVerb (hwndView, pDataObject);
                    break;

                default:
                    hr = S_FALSE;
                    break;
            }

            break;
        }
#ifndef NODELEGATE
        case DFM_GETDEFSTATICID:
        {

            if (bDelegate)
            {
               hr = E_NOTIMPL; // let the shell set the default
            }
            else
            {
                // properties is the default verb
                *(reinterpret_cast<UINT*>(lParam)) = (UINT) DFM_CMD_PROPERTIES;
                hr = S_OK;
            }

            break;
        }
#endif
        case DFM_GETHELPTEXT:
            LoadStringA (GLOBAL_HINSTANCE, LOWORD(wParam)+IDS_MH_IDFIRST,
                         reinterpret_cast<LPSTR>(lParam),
                         HIWORD(wParam));
            break;
#ifdef UNICODE
        case DFM_GETHELPTEXTW:
            LoadStringW (GLOBAL_HINSTANCE, LOWORD(wParam)+IDS_MH_IDFIRST,
                         reinterpret_cast<LPWSTR>(lParam),
                         HIWORD(wParam));
            break;
#endif // UNICODE
        default:
            hr = E_NOTIMPL;
            break;
    }

    TraceLeaveResult(hr);
}



/*****************************************************************************

   _FolderCMCallBack

   Handles callbacks for the context menu which is
   displayed when the user right clicks on folder
   background itself...

 *****************************************************************************/

HRESULT
CALLBACK
_FolderCMCallback( LPSHELLFOLDER psf,
                   HWND hwndView,
                   LPDATAOBJECT
                   pDataObject,
                   UINT uMsg,
                   WPARAM wParam,
                   LPARAM lParam
                  )
{
    HRESULT hr = NOERROR;

    TraceEnter( TRACE_CALLBACKS, "_FolderCMCallback" );
    TraceMenuMsg( uMsg, wParam, lParam );

    switch ( uMsg )
    {
/*        case DFM_MERGECONTEXTMENU:
            hr = _MergeArrangeMenu( ShellFolderView_GetArrangeParam(hwndView),
                                    (LPQCMINFO)lParam
                                   );
            break;*/

        case DFM_GETHELPTEXT:
        {
            hr = S_OK;

            switch ( LOWORD(wParam) )
            {
                case IMVMID_ARRANGEBYNAME:
                    LoadStringA( GLOBAL_HINSTANCE,
                                IDS_BYOBJECTNAME,
                                (LPSTR)lParam,
                                HIWORD(wParam)
                               );
                    break;

                case IMVMID_ARRANGEBYCLASS:
                    LoadStringA( GLOBAL_HINSTANCE,
                                IDS_BYTYPE,
                                (LPSTR)lParam,
                                HIWORD(wParam)
                               );
                    break;

                case IMVMID_ARRANGEBYDATE:
                    LoadStringA( GLOBAL_HINSTANCE,
                                IDS_BYDATE,
                                (LPSTR)lParam,
                                HIWORD(wParam)
                               );
                    break;

                case IMVMID_ARRANGEBYSIZE:
                    LoadStringA( GLOBAL_HINSTANCE,
                                IDS_BYSIZE,
                                (LPSTR)lParam,
                                HIWORD(wParam)
                               );
                    break;

                default:
                    hr = S_FALSE;
                    break;
            }
        }
        break;

        case DFM_MAPCOMMANDNAME:

            if (!lstrcmpi(reinterpret_cast<LPCTSTR>(lParam), TEXT("TakePicture")))
            {
                *(reinterpret_cast<int *>(wParam)) = IMID_C_TAKE_PICTURE;
                hr = S_OK;
            }
            else
                hr = E_NOTIMPL;
            break;

        case DFM_INVOKECOMMAND:
        {
            UINT idCmd = (UINT)wParam;

            switch ( idCmd )
            {
                case IMVMID_ARRANGEBYNAME:
                case IMVMID_ARRANGEBYCLASS:
                case IMVMID_ARRANGEBYDATE:
                case IMVMID_ARRANGEBYSIZE:
                    ShellFolderView_ReArrange(hwndView, idCmd);
                    break;

                default:
                    hr = S_FALSE;
                    break;
            }

            break;
        }

        default:
            hr = E_NOTIMPL;
            break;
    }

    TraceLeaveResult(hr);
}

/*****************************************************************************

   CImageFolder contructor / desctructor

   <Notes>

 *****************************************************************************/

CImageFolder::CImageFolder( )
  : m_pidl(NULL),
    m_pidlFull(NULL),
    m_type(FOLDER_IS_UNKNOWN),
    m_pShellDetails(NULL),
    m_hwnd(NULL)
{
    TraceEnter(TRACE_FOLDER, "CImageFolder::CImageFolder");

    TraceLeave();
}

CImageFolder::~CImageFolder()
{
    TraceEnter(TRACE_FOLDER, "CImageFolder::~CImageFolder");
    #ifdef DEBUG
    if (m_pidl)
    {
        CSimpleStringWide str;
        IMGetNameFromIDL (m_pidl, str);
        Trace(TEXT("Destroying folder object for %ls"), str.String());
    }
    #endif
    DoILFree( m_pidl );
    DoILFree( m_pidlFull );


    DoRelease (m_pShellDetails);
    TraceLeave();
}


/*****************************************************************************

   CImageFolder::IUnknown stuff

   Use our common implementation for IUnknown methods

 *****************************************************************************/

#undef CLASS_NAME
#define CLASS_NAME CImageFolder
#include "unknown.inc"



/*****************************************************************************

   CImageFolder::QI Wrapper

   Use our common implementation for QI calls.

 *****************************************************************************/

STDMETHODIMP
CImageFolder::QueryInterface( REFIID riid, LPVOID* ppvObject)
{
    HRESULT hr = S_OK;

    TraceEnter( TRACE_QI, "CImageFolder::QueryInterface" );
    TraceGUID("Interface requested", riid);



    if (IsEqualIID (IID_IShellDetails, riid))
    {
        if (!m_pShellDetails)
        {
            m_pShellDetails = new CFolderDetails (m_type);
            if (!m_pShellDetails)
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    INTERFACES iface[] =
    {
        &IID_IShellFolder,    (IShellFolder *)    this,
        &IID_IShellFolder2,   (IShellFolder2 *)   this,
        &IID_IPersist,        (IPersistFolder2 *) this,
        &IID_IPersistFolder,  (IPersistFolder *)  this,
        &IID_IPersistFolder2, (IPersistFolder2 *) this,
        &IID_IPersistStream,  (IPersistStream *)  this,
        &IID_IMoniker,        (IMoniker *)        this,
        &IID_IImageFolder,    (IImageFolder *)    this,
        &IID_IDelegateFolder, (IDelegateFolder *) this,
        &IID_IShellDetails,   (IShellDetails *)   m_pShellDetails,

    };
    if SUCCEEDED(hr)
    {


        //
        // Next, try the normal cases...
        //
        hr = HandleQueryInterface(riid, ppvObject, iface, ARRAYSIZE(iface));
    }
    TraceLeaveResult(hr);
}


/*****************************************************************************

   CImageFolder::RealInitialize

   Does actual initalization of the folder object.

 *****************************************************************************/

STDMETHODIMP
CImageFolder::RealInitialize( LPCITEMIDLIST pidlRoot,
                              LPCITEMIDLIST pidlBindTo
                             )
{
    HRESULT hr = E_FAIL;

    TraceEnter(TRACE_FOLDER, "CImageFolder::RealInitialize");


    if ( !pidlBindTo )
    {
        m_pidl = ILClone(ILFindLastID(pidlRoot));
        m_pidlFull = ILClone(pidlRoot);
    }
    else
    {
        m_pidl = ILClone(ILFindLastID(pidlBindTo));
        m_pidlFull = ILCombine(pidlRoot, pidlBindTo);
    }

    if ( !m_pidl )
        ExitGracefully(hr, E_OUTOFMEMORY, "Failed to create root IDLIST");



    if (!pidlBindTo && !IMIsOurIDL(m_pidl))// && IsIDLRootOfNameSpace( m_pidl, TRUE ))
    {
        m_type = FOLDER_IS_ROOT;
        hr = S_OK;
    }
    else if (StiDeviceTypeScanner == IMGetDeviceTypeFromIDL( m_pidl ))
    {

        m_type = FOLDER_IS_SCANNER_DEVICE;
        hr = S_OK;
    }
    else if (StiDeviceTypeStreamingVideo  == IMGetDeviceTypeFromIDL( m_pidl ))
    {
        m_type = FOLDER_IS_VIDEO_DEVICE;
        hr = S_OK;
    }
    else if (StiDeviceTypeDigitalCamera == IMGetDeviceTypeFromIDL( m_pidl ))
    {
        m_type = FOLDER_IS_CAMERA_DEVICE;
        hr = S_OK;
    }
    else if (IsCameraItemIDL( m_pidl ) )
    {
        if (IsContainerIDL( m_pidl ))
        {
            m_type = FOLDER_IS_CONTAINER;
            hr = S_OK;

        }
        else
        {
            m_type = FOLDER_IS_CAMERA_ITEM;
            hr = S_OK;
        }
    }

exit_gracefully:
#ifdef DEBUG
            CComBSTR str;
            IMGetFullPathNameFromIDL (m_pidl, &str);
            Trace(TEXT("folder item full path: %ls"), str.m_str);
#endif
    Trace(TEXT("Folder type is %d"), m_type);
    TraceLeaveResult(hr);
}



/*****************************************************************************

   CImageFolder::GetFolderType

   Returns the type (m_type) of this folder

 *****************************************************************************/

HRESULT
CImageFolder::GetFolderType( folder_type * pfType )
{
    HRESULT hr = S_OK;

    TraceEnter(TRACE_FOLDER, "CImageFolder(IImageFolder)::GetFolderType" );

    if (!pfType)
        ExitGracefully( hr, E_INVALIDARG, "pfType is NULL!" );

    *pfType = m_type;

exit_gracefully:

    TraceLeaveResult( hr );
}


/*****************************************************************************

   CImageFolder::GetPidl

   Returns a pointer to the pidl for this object

 *****************************************************************************/

HRESULT
CImageFolder::GetPidl( LPITEMIDLIST * ppidl )
{
    HRESULT hr = S_OK;

    TraceEnter( TRACE_FOLDER, "CImageFolder(IImageFolder)::GetPidl" );

    if (!ppidl)
        ExitGracefully( hr, E_INVALIDARG, "ppidl is NULL!" );

    *ppidl = m_pidlFull;

exit_gracefully:

    TraceLeaveResult( hr );
}


/*****************************************************************************

    CImageFolder::ViewWindow
    
    The view callback assigns our window, and DUI command targets query us for it
    
*****************************************************************************/

STDMETHODIMP
CImageFolder::ViewWindow(HWND *phwnd)
{
    HRESULT hr = E_INVALIDARG;
    if (phwnd)
    {
        if (!*phwnd)
        {
            *phwnd = m_hwnd;
        }
        else
        {
            m_hwnd = *phwnd;
        }
        hr = S_OK;
    }
    return hr;
}

/*****************************************************************************

   CImageFolder::GetClassID [IPersist]

   Returns the classid for the folder

 *****************************************************************************/

STDMETHODIMP
CImageFolder::GetClassID(LPCLSID pClassID)
{
    TraceEnter(TRACE_FOLDER, "CImageFolder(IPersist)::GetClassID");

    TraceAssert(pClassID);
    if (!pClassID)
    {
        TraceLeaveResult (E_INVALIDARG);
    }

    if ( (m_type == FOLDER_IS_SCANNER_DEVICE) ||
         (m_type == FOLDER_IS_CAMERA_DEVICE)  ||
         (m_type == FOLDER_IS_VIDEO_DEVICE)  ||
         (m_type == FOLDER_IS_CONTAINER)
       )
    {
        *pClassID = CLSID_DeviceImageExt;
    }
    else
    {
        *pClassID = CLSID_ImageExt;
    }

    TraceLeaveResult(S_OK);
}



/*****************************************************************************

   CImageFolder::Initialize [IPersistFolder]

   Initalize the shell folder -- pidlStart tells us where we are rooted.

 *****************************************************************************/

STDMETHODIMP
CImageFolder::Initialize(LPCITEMIDLIST pidlStart)
{
    HRESULT hr;

    TraceEnter(TRACE_FOLDER, "CImageFolder(IPersistFolder)::Initialize");

    hr = RealInitialize(pidlStart, NULL);

    TraceLeaveResult(hr);
}



/*****************************************************************************

   CImageFolder::GetCurFolder [IPersistFolder2]

   Return the pidl of the current folder.

 *****************************************************************************/

STDMETHODIMP
CImageFolder::GetCurFolder(LPITEMIDLIST *ppidl)
{
    HRESULT hr = S_OK;

    TraceEnter(TRACE_FOLDER, "CImageFolder(IPersistFolder2)::GetCurrFolder");

    if (!ppidl)
        ExitGracefully( hr, E_INVALIDARG, "ppidl is NULL!" );

    *ppidl = ILClone( m_pidlFull );

    if (!*ppidl)
        ExitGracefully( hr, E_OUTOFMEMORY, "couldn't clone m_pidl!" );


exit_gracefully:

    TraceLeaveResult(hr);
}



/*****************************************************************************

   CImageFolder::ParseDisplayName [IShellFolder]

   Given a display name, hand back a pidl.

 *****************************************************************************/

STDMETHODIMP
CImageFolder::ParseDisplayName( HWND hwndOwner,
                                LPBC pbcReserved,
                                LPOLESTR pDisplayName,
                                ULONG* pchEaten,
                                LPITEMIDLIST* ppidl,
                                ULONG *pdwAttributes
                               )
{
    HRESULT hr = S_OK;

    CSimpleStringWide strDeviceId(L"");
    
    TraceEnter(TRACE_FOLDER, "CImageFolder(IShellFolder)::ParseDisplayName");
    Trace(TEXT("Display name to parse: %ls"), pDisplayName);
    //
    // Try to get a pidl for the display name
    //
    if (pdwAttributes)
    {
        *pdwAttributes = 0; // we don't support setting attributes here
    }
    if (ppidl)
    {
        *ppidl =NULL;
    }
    else 
    {
        hr = E_INVALIDARG;
    }


    // Skip the cszImageCLSID string if it's there
    if (SUCCEEDED(hr) && (*pDisplayName == L';'))
    {
        size_t skip = wcslen(cszImageCLSID)+3;
        if (skip >= wcslen(pDisplayName))
        {
            hr = E_FAIL;
        }
        else
        {
            pDisplayName += skip;
        }
    }
    if (SUCCEEDED(hr))
    {
        if (!wcscmp(pDisplayName, cszAddDeviceName))
        {
            if (CanShowAddDevice())
            {
                *ppidl = IMCreateAddDeviceIDL(m_pMalloc);
                if (*ppidl)
                {
                    hr = S_OK;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            else
            {
                hr = E_FAIL;
            }
        }
        else
        {
            LPCWSTR szFolderPath = NULL;
            CSimpleStringWide strFolder;
            IMGetDeviceIdFromIDL (m_pidl, strDeviceId);
            if (IsContainerIDL(m_pidl))
            {
                IMGetParsingNameFromIDL(m_pidl, strFolder);
                szFolderPath = strFolder.String();
            }
            
            // szDeviceId will be an empty string if m_pidl is a full regitem pidl
            hr = IMCreateIDLFromParsingName( pDisplayName, 
                                             ppidl, 
                                             strDeviceId, 
                                             m_pMalloc,
                                             szFolderPath );            
        }
    }

    TraceLeaveResult(hr);
}



/*****************************************************************************

   CImageFolder::EnumObject [IShellFolder]

   Hand back an enumerator for the objects at this level of the namespace.

 *****************************************************************************/

STDMETHODIMP
CImageFolder::EnumObjects( HWND hwndOwner,
                           DWORD grfFlags,
                           LPENUMIDLIST* ppEnumIdList
                          )
{
    HRESULT hr = E_INVALIDARG;


    TraceEnter(TRACE_FOLDER, "CImageFolder(IShellFolder)::EnumObjects");

    //
    // Check for bad params...
    //

    if (ppEnumIdList )
    {


        //
        // Depending on the type, create our enumerator object
        // to hand back the items...
        //

        switch( m_type )
        {
            case FOLDER_IS_ROOT:
            {
                CDeviceEnum *pEnum = NULL;
                pEnum = new CDeviceEnum (grfFlags, m_pMalloc);
                if (!pEnum)
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    *ppEnumIdList = static_cast<LPENUMIDLIST>(pEnum);
                    hr = S_OK;
                }
            }
                break;
            case FOLDER_IS_SCANNER_DEVICE:
            case FOLDER_IS_CAMERA_DEVICE:
            case FOLDER_IS_VIDEO_DEVICE:
            case FOLDER_IS_CONTAINER:
            {
                CImageEnum *pEnum = NULL;
                pEnum = new CImageEnum( m_pidl, grfFlags, m_pMalloc );

                if ( !pEnum )
                {
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    *ppEnumIdList = static_cast<LPENUMIDLIST>(pEnum);
                    hr = S_OK;
                }
            }
                break;

            default:
                hr = E_FAIL;
                break;
        }
    }

    TraceLeaveResult(hr);
}



/*****************************************************************************

   CImageFolder::BindToObject [IShellFolder]

   Attempt to return the requested interface for the specified
   object (pidl).

 *****************************************************************************/

STDMETHODIMP
CImageFolder::BindToObject( LPCITEMIDLIST pidl,
                            LPBC pbcReserved,
                            REFIID riid,
                            LPVOID* ppvOut
                           )
{
    HRESULT hr = E_FAIL;
    CImageFolder* psf = NULL;

    LPCITEMIDLIST pidlNext;
    LPITEMIDLIST pidlActual = ILFindLastID(pidl);
    TraceEnter(TRACE_FOLDER, "CImageFolder(IShellFolder)::BindToObject");
    Trace(TEXT("Entry IDLIST is %p"), pidl);
    TraceGUID("Interface being requested", riid);
    if (ppvOut)
    {
        *ppvOut = NULL;
    }
    //
    // Check for bad params...
    //

    if ( !pidl || !ppvOut )
        ExitGracefully(hr, E_INVALIDARG, "Bad parameters for BindToObject");


    if (IsEqualGUID(riid, IID_IStream))
    {
        if (IsCameraItemIDL(pidlActual))
        {
            CImageStream *pstrm = new CImageStream(m_pidlFull, pidlActual);
            if (pstrm)
            {
                hr = pstrm->QueryInterface(riid, ppvOut);
                pstrm->Release();
            }
        }
        else
        {
            hr = E_FAIL;
        }
        goto exit_gracefully;
    }
    //
    // Create a new folder which will be the new object...
    //
    psf = new CImageFolder( );

    if ( !psf )
        ExitGracefully(hr, E_OUTOFMEMORY, "Failed to allocate new CDeviceFolder");

#ifdef DEBUG
    if (IMIsOurIDL( (LPITEMIDLIST)pidlActual ))
    {
        CSimpleStringWide strName;


        IMGetNameFromIDL( (LPITEMIDLIST)pidlActual, strName );
        Trace(TEXT("Trying to bind to object: %ls"),strName.String());
    }
#endif

    //
    // Init our new folder object to the right place...
    //

    psf->SetItemAlloc (m_pMalloc);
    hr = psf->RealInitialize( m_pidlFull, (LPITEMIDLIST)pidl );

    if ( FAILED(hr) )
    {
        Trace(TEXT("Couldn't RealInitialize psf, discarding the object"));

        goto exit_gracefully;
    }

    //
    // Make sure we bind to the last item in the idlist...
    //

/*    pidlNext = ILGetNext(pidl);
    if (pidlNext->mkid.cb)
    {
        //
        // There's more stuff, so bind to it...
        //
        #ifdef DEBUG
        CSimpleStringWide strNext;
        IMGetNameFromIDL (const_cast<LPITEMIDLIST>(pidlNext), strNext);
        Trace(TEXT("Binding to next item in the pidl: %ls"), strNext.String());
        #endif
        hr = psf->BindToObject( pidlNext, pbcReserved, riid, ppvOut );

    }
    else*/
    {
        hr = psf->QueryInterface( riid, ppvOut );
        if (FAILED(hr))
        {
            Trace(TEXT("Couldn't QI psf, discarding the object"));
            goto exit_gracefully;
        }
    }

exit_gracefully:
    DoRelease (psf);
    TraceLeaveResult(hr);
}



/*****************************************************************************

   CImageFolder::BindToStorage [IShellFolder]

   Attempt to return the requested interface for the specified
   object's storage (pidl).

 *****************************************************************************/

STDMETHODIMP
CImageFolder::BindToStorage( LPCITEMIDLIST pidl,
                             LPBC pbcReserved,
                             REFIID riid,
                             LPVOID* ppvObj
                            )
{
    HRESULT hr = E_NOINTERFACE;
    TraceEnter(TRACE_FOLDER, "CImageFolder::BindToStorage");    
    TraceLeaveResult(hr);
}


/*****************************************************************************

   CImageFolder::CompareIDs [IShellFolder]

   Compare the two pidls according the the sort settings and return
   lesser or greater "ness" information.  :-)

 *****************************************************************************/
extern const SHCOLUMNID SCID_DEVCLASS;
extern const SHCOLUMNID SCID_ITEMTYPE;
STDMETHODIMP
CImageFolder::CompareIDs( LPARAM lParam,
                          LPCITEMIDLIST pidlIN1,
                          LPCITEMIDLIST pidlIN2
                         )
{
    LPITEMIDLIST            pidl1, pidl2;
    HRESULT                 hr = E_FAIL;
    INT                     iResult = 0;
    LPITEMIDLIST            pidlT1, pidlT2;
    LPITEMIDLIST            pidlTemp = NULL;
    CComPtr<IShellFolder>   pShellFolder;

    TraceEnter(TRACE_COMPAREIDS, "CImageFolder(IShellFolder)::CompareIDs");

    pidl1 = const_cast<LPITEMIDLIST>(pidlIN1);
    pidl2 = const_cast<LPITEMIDLIST>(pidlIN2);

    Trace(TEXT("pidl1 %08x, pidl2 %08x"), pidl1, pidl2);
    Trace(TEXT("lParam == %d"), lParam);

    //
    // Check for bad params...
    //

    TraceAssert(pidl1);
    TraceAssert(pidl2);

    if ( !IMIsOurIDL(pidl1) ||
         !IMIsOurIDL(pidl2)
       )
    {
        ExitGracefully( hr, E_FAIL, "Not our idlists!" );
    }

    //
    // Do special sorting for "Add Device" -- it is always the first
    // item...
    //

    if (IsAddDeviceIDL( pidl1 ))
    {
        if (IsAddDeviceIDL( pidl2 ))
        {
            iResult = 0;
            goto exit_result;
        }

        iResult = -1;
        goto exit_result;
    }
    else if (IsAddDeviceIDL( pidl2 ))
    {
        iResult = 1;
        goto exit_result;
    }

    //
    // lParam indicates which column we are sorting on, so get the
    // info from the IDL's accordingly and return the information...
    //

    switch (lParam & SHCIDS_COLUMNMASK)
    {
        case IMVMID_ARRANGEBYNAME:
        {
            CSimpleStringWide  strName1;
            CSimpleStringWide  strName2;

            IMGetNameFromIDL(pidl1, strName1);
            IMGetNameFromIDL(pidl2, strName2);
            Trace(TEXT("Names: - %ls -, - %ls -"),strName1.String(), strName2.String());
            iResult = _wcsicmp(strName1, strName2);
        }
            break;

        case IMVMID_ARRANGEBYSIZE:
        {
            ULONG u1 = 0;
            ULONG u2 = 0;
            IMGetImageSizeFromIDL (pidl1, &u1);
            IMGetImageSizeFromIDL (pidl2, &u2);
            if (u1 > u2)
            {
                iResult = 1;
            }
            else if (u1 == u2)
            {
                iResult = 0;
            }
            else
            {
                iResult  = -1;
            }
        }
        break;

        case IMVMID_ARRANGEBYDATE:
        {
           ULONGLONG t1 =0;
           ULONGLONG t2 =0;
           TraceAssert (sizeof(FILETIME) == sizeof(ULONGLONG));
           IMGetCreateTimeFromIDL (pidl1, reinterpret_cast<FILETIME*>(&t1));
           IMGetCreateTimeFromIDL (pidl2, reinterpret_cast<FILETIME*>(&t2));
           if (t1 > t2)
           {
               iResult = 1;
           }
           else if (t1 == t2)
           {
               iResult = 0;
           }
           else
           {
               iResult = -1;
           }
        }
        break;

        case IMVMID_ARRANGEBYCLASS:
            {
                Trace(TEXT("IMVMID_ARRANGEBYCLASS"));
                VARIANT var1, var2;
                SHCOLUMNID scid;
                CSimpleStringWide str1, str2;
                // use the appropriate detail string to sort
                if (IsDeviceIDL(pidl1))
                {
                    scid.fmtid = FMTID_Storage;
                    scid.pid = PID_STG_STORAGETYPE;
                }
                else
                {
                    Trace(TEXT("Sorting by item type"));
                    scid.fmtid = FMTID_WiaProps;
                    scid.pid = WIA_IPA_ITEM_FLAGS;
                }
                VariantInit(&var1);
                VariantInit(&var2);
                if (SUCCEEDED(GetDetailsEx(pidlIN1, &scid, &var1)) && SUCCEEDED(GetDetailsEx(pidlIN2, &scid, &var2)))
                {
                    Trace(TEXT("type1: %ls, type2: %ls"), var1.bstrVal, var2.bstrVal);
                    iResult = _wcsicmp(var1.bstrVal, var2.bstrVal);
                    if (!iResult)
                    {
                        IMGetNameFromIDL(pidl1, str1);
                        IMGetNameFromIDL(pidl2, str2);
                        Trace(TEXT("name1: %ls, type2: %ls"), str1.String(), str2.String());
                        iResult = _wcsicmp(str1, str2);
                    }
                    hr = S_OK;
                }
                else
                {
                    hr = E_FAIL;
                }
                VariantClear(&var1);
                VariantClear(&var2);
                if (FAILED(hr))
                {
                    goto exit_gracefully;
                }
            }
            
            break;
        default:

            ExitGracefully(hr, E_INVALIDARG, "Bad sort column");
            break;
    }

    //
    // If they match then check that they are absolutely identical, if that is
    // the case then continue down the IDLISTs if more elements present.
    // Nobody should ever call us with a nested PIDL to check things like
    // size.

    if ( iResult == 0 )
    {
        if (lParam & SHCIDS_ALLFIELDS)
        {
            iResult = memcmp(pidl1, pidl2, ILGetSize(pidl1));
            Trace(TEXT("memcmp of pidl1, pidl2 yeilds %d"), iResult);

            if ( iResult != 0 )
                goto exit_result;

        }

        pidlT1 = ILGetNext(pidl1);
        pidlT2 = ILGetNext(pidl2);

        if ( ILIsEmpty(pidlT1) )
        {
            if ( ILIsEmpty(pidlT2) )
            {
                iResult = 0;
            }
            else
            {
                iResult = -1;
            }

            goto exit_result;
        }
        else if ( ILIsEmpty(pidlT2) )
        {
            iResult = 1;
            goto exit_result;
        }

        //
        // Both IDLISTs have more elements, therefore continue down them
        // binding to the next element in 1st IDLIST and then calling its
        // compare method.
        //

        pidlTemp = ILClone(pidl1);

        if ( !pidlTemp )
            ExitGracefully(hr, E_OUTOFMEMORY, "Failed to clone IDLIST for binding");

        ILGetNext(pidlTemp)->mkid.cb = 0;

        hr = BindToObject(pidlTemp, NULL, IID_IShellFolder, (LPVOID*)&pShellFolder);
        FailGracefully(hr, "Failed to get the IShellFolder implementation from pidl1");

        hr = pShellFolder->CompareIDs(lParam, pidlT1, pidlT2);
        Trace(TEXT("CompareIDs returned %08x"), ShortFromResult(hr));

        goto exit_gracefully;
    }

exit_result:

    Trace(TEXT("Exiting with iResult %d"), iResult);
    hr = ResultFromShort(iResult);

exit_gracefully:

    DoILFree(pidlTemp);

    TraceLeaveResult(hr);
}



/*****************************************************************************

   CImageFolder::CreateViewObject [IShellFolder]

   Hand back the IShellView, etc. to use for this IShellFolder.

 *****************************************************************************/

STDMETHODIMP
CImageFolder::CreateViewObject( HWND hwndOwner,
                                REFIID riid,
                                LPVOID* ppvOut
                               )
{
    HRESULT hr = E_NOINTERFACE;

    TraceEnter(TRACE_FOLDER, "CImageFolder(IShellFolder)::CreateViewObject");
    TraceGUID("View object requested", riid);

    TraceAssert(ppvOut);

    if (ppvOut)
    {
        *ppvOut = NULL;
    }


    //
    // Does the caller want an IShellView?
    //

    if ( IsEqualIID(riid, IID_IShellView) )
    {
        //
        // Create an IShellView and hand it off...
        //
        CComPtr<IShellFolderViewCB> pv;
        hr = CreateFolderViewCB (&pv);
        if (SUCCEEDED (hr))
        {
            SFV_CREATE sc;
            sc.cbSize = sizeof(sc);
            sc.psvOuter = NULL;
            sc.pshf = this;
            sc.psfvcb  = pv;
            hr = SHCreateShellFolderView (&sc, reinterpret_cast<IShellView**>(ppvOut));
        }
        #ifdef DEBUG
        if (m_pidl)
        {
            CSimpleStringWide str;
            IMGetNameFromIDL  (m_pidl, str);
            Trace(TEXT("Created shell view for folder %ls"), str.String());
        }
        #endif
    }
    //
    // Does the caller want IShellDetails (or its associates)?
    //

    else if ( IsEqualIID(riid, IID_IShellDetails) ||
              IsEqualIID(riid, IID_IShellDetails3)
             )
    {
        //
        // Get a ptr to them and hand them off...
        //

        hr = this->QueryInterface(riid, ppvOut);
    }

    //
    // Does the caller want IContextMenu?
    //

    else if ( IsEqualIID(riid, IID_IContextMenu) )
    {
        //
        // Create an IContextMenu and hand it off...
        //

        hr = CDefFolderMenu_Create2( m_pidl,
                                     hwndOwner,
                                     NULL,
                                     0,
                                     this,
                                     _FolderCMCallback,
                                     NULL,
                                     0,
                                     (LPCONTEXTMENU*)ppvOut
                                    );

    }

    TraceLeaveResult(hr);
}



/*****************************************************************************

   CImageFolder::GetAttributesOf [IShellFolder]

   Return the SFGAO_ attributes for the specified items

 *****************************************************************************/

STDMETHODIMP
CImageFolder::GetAttributesOf( UINT cidl,
                               LPCITEMIDLIST* apidl,
                               ULONG* rgfInOut
                              )
{
    HRESULT hr = S_OK;
    UINT i;

    ULONG uFlags = 0;
    bool bDelegate;
    TraceEnter(TRACE_FOLDER, "CImageFolder(IShellFolder)::GetAttributesOf");
    Trace(TEXT("cidl = %d"), cidl);
    #if (defined(DEBUG) && defined(SHOW_ATTRIBUTES))
    PrintAttributes(*rgfInOut);
    #endif
    #ifdef NODELEGATE
    bDelegate = true;
    #else
    bDelegate = m_pMalloc.p != NULL;
    #endif
    if (cidl == 0 || ((cidl == 1) && ((*apidl)->mkid.cb == 0) ))
    {

        //
        // Return attributes for folder itself...
        //
        Trace(TEXT("Asked for attributes of the folder"));

        // Since we are delegated we never have subfolders.
        uFlags  |= (SFGAO_STORAGEANCESTOR | SFGAO_FOLDER | SFGAO_CANLINK | SFGAO_CANRENAME);

    }
    else
    {
        //
        // Figure out what kind of items we have and return the
        // relevant attributes...
        //

        for (i = 0; i < cidl; i++)
        {
         #ifdef DEBUG
            CSimpleStringWide strName;
            IMGetNameFromIDL ((LPITEMIDLIST)*apidl, strName);
            Trace(TEXT("Asked for attributes of %ls"), strName.String());
         #endif
            // IsDeviceIDL returns FALSE for STI devices
            // We can only navigate WIA devices
            if (IsDeviceIDL( (LPITEMIDLIST)*apidl ))
            {

                uFlags |= SFGAO_CANRENAME;
                if (bDelegate)
                {
                    uFlags |= SFGAO_CANLINK;
                }
                else if (cidl == 1 && UserCanModifyDevice())
                {
                // In My Computer, we can create a shortcut
                // In Control Panel, we can delete the device.
                    uFlags |= SFGAO_CANDELETE;
                }

                // Only treat this as a folder if we are in My Computer, i.e. delegated
                if ( bDelegate &&
                     (IMGetDeviceTypeFromIDL((LPITEMIDLIST)*apidl) == StiDeviceTypeDigitalCamera) ||
                     (IMGetDeviceTypeFromIDL((LPITEMIDLIST)*apidl) == StiDeviceTypeStreamingVideo) )
                {
                    uFlags |=   SFGAO_FOLDER | SFGAO_STORAGEANCESTOR;
                }
                else
                {
                    uFlags &= ~(SFGAO_FOLDER | SFGAO_STORAGEANCESTOR);
                }

                uFlags |= SFGAO_HASPROPSHEET;


            }
            else if (IsCameraItemIDL( (LPITEMIDLIST)*apidl ) )
            {
                BOOL bCanDelete = (IMGetAccessFromIDL ((LPITEMIDLIST)*apidl) & WIA_ITEM_CAN_BE_DELETED);

                uFlags |=  SFGAO_CANCOPY | SFGAO_READONLY; // all our items are read-only;

                if (bCanDelete)
                {
                    uFlags  |= SFGAO_CANDELETE;
                }
                else
                {
                    uFlags &= ~SFGAO_CANDELETE;
                }

                if (IsContainerIDL( (LPITEMIDLIST)*apidl ))
                {
                    uFlags |= (SFGAO_FOLDER | SFGAO_BROWSABLE | SFGAO_STORAGEANCESTOR);
                    uFlags &= ~SFGAO_HASPROPSHEET;

                }
                else
                {
                    // undo any bits set by folder items
                    uFlags &= ~(SFGAO_FOLDER | SFGAO_BROWSABLE);
                    uFlags |= SFGAO_HASPROPSHEET ;
                    uFlags |= SFGAO_STREAM;
                }
            }
            else if (IsAddDeviceIDL( (LPITEMIDLIST)*apidl ))
            {
                uFlags |= SFGAO_READONLY | SFGAO_CANLINK;

            }
            else if (IsSTIDeviceIDL ((LPITEMIDLIST)*apidl))
            {

                uFlags |= SFGAO_CANDELETE;
                if (cidl == 1)
                {
                    uFlags |= SFGAO_HASPROPSHEET;
                }
            }
            apidl++;
        }

    }
    *rgfInOut &= uFlags;

#if (defined(DEBUG) && defined(SHOW_ATTRIBUTES))
    PrintAttributes(*rgfInOut);
#endif

    TraceLeaveResult(hr);
}


/*****************************************************************************

   CImageFolder::GetUIObjectOf [IShellFolder]

   Return the requested interface for the items specified.

 *****************************************************************************/

STDMETHODIMP
CImageFolder::GetUIObjectOf( HWND hwndOwner,
                             UINT cidl,
                             LPCITEMIDLIST* aidl,
                             REFIID riid,
                             UINT* prgfReserved,
                             LPVOID* ppvOut
                            )
{
    HRESULT  hr  = E_NOINTERFACE;

    TraceEnter(TRACE_FOLDER, "CImageFolder(IShellFolder)::GetUIObjectOf");
    TraceGUID("UI object requested", riid);

    //
    // Check for bad params
    //
    if (ppvOut)
    {
        *ppvOut = NULL;
    }
    TraceAssert(cidl > 0);
    TraceAssert(aidl);
    TraceAssert(ppvOut);

    //
    // Does the caller want IExtractIcon?
    //

    if ( IsEqualIID(riid, IID_IExtractIcon) )
    {
        CImageExtractIcon*  pExtractIcon = NULL;
        //
        // Our IExtractIcon handler only handles single items...
        //

        if ( cidl != 1 || !IMIsOurIDL((LPITEMIDLIST)*aidl))
            ExitGracefully(hr, E_FAIL, "Bad number of objects to get icon from, or invalid pidl");

        //
        // Create the new object
        //

        pExtractIcon = new CImageExtractIcon( (LPITEMIDLIST)*aidl );

        if ( !pExtractIcon )
            ExitGracefully(hr, E_OUTOFMEMORY, "Failed to create CImageExtractIcon");

        //
        // Get the correct iterface on the new object and hand it back...
        //

        hr = pExtractIcon->QueryInterface(riid, ppvOut);
        pExtractIcon->Release();

    }

    //
    // Does the caller want IContextMenu?
    //

    else if ( IsEqualIID(riid, IID_IContextMenu) )
    {
        HKEY aKeys[ UIKEY_MAX ];

        //
        // See if there are any context menu items in the
        // registry for these IDL's...
        //

        _GetKeysForIDL( cidl, aidl, ARRAYSIZE(aKeys), aKeys );

        //
        // Create a default context menu but specify
        // out callback...
        //

        hr = CDefFolderMenu_Create2( m_pidlFull,
                                     hwndOwner,
                                     cidl,
                                     aidl,
                                     this,
                                     _FolderItemCMCallback,
                                     ARRAYSIZE(aKeys),
                                     aKeys,
                                     (LPCONTEXTMENU*)ppvOut
                                    );
        for (int i=0;i<ARRAYSIZE(aKeys);i++)
        {
            if (aKeys[i])
            {
                RegCloseKey (aKeys[i]);
            }
        }

    }

    //
    // Does the caller want IDataObject?
    //

    else if ( IsEqualIID(riid, IID_IDataObject) )
    {
        CImageDataObject*   pDataObject  = NULL;
        //
        // Create the new object to hand back...
        //

        pDataObject = new CImageDataObject();


        if ( !pDataObject )
            ExitGracefully(hr, E_OUTOFMEMORY, "Failed to create DataObject");

        hr = pDataObject->Init (m_pidlFull, cidl, aidl, m_pMalloc);
        //
        // Get the requested interface on it...
        //

        if (SUCCEEDED(hr))
        {
            hr = pDataObject->QueryInterface(riid, ppvOut);
        }

        pDataObject->Release();
    }

    //
    // Does the caller want IExtractImage (used for thumbnail extraction)?
    //

    else if ( IsEqualIID(riid, IID_IExtractImage) )
    {
        //
        // Our IExtractImage handler can only take one item at a time...
        //
        CExtractImage*      pExtract     = NULL;
        if (cidl != 1)
            ExitGracefully( hr, E_FAIL, "Bad number of objects to get IExtractImage for..." );

        //
        // Our IExtractImage handler only works for camera items...
        //

        if (!IsCameraItemIDL( (LPITEMIDLIST)*aidl ))
            ExitGracefully( hr, E_FAIL, "Not a camera item idlist!" );

        //
        // Create a new object...
        //

        pExtract = new CExtractImage( (LPITEMIDLIST)*aidl );

        if ( !pExtract )
            ExitGracefully(hr, E_OUTOFMEMORY, "Failed to create CExtractImage");

        //
        // Get the requested interface on the new object and hand it back...
        //

        hr = pExtract->QueryInterface(riid, ppvOut);
        pExtract->Release ();

    }
    else if (cidl ==1 && IsEqualIID(riid, IID_IQueryInfo))
    {
        CInfoTip *ptip = new CInfoTip ((LPITEMIDLIST)*aidl, m_pMalloc.p != NULL);
        if (!ptip)
        {
            ExitGracefully (hr, E_OUTOFMEMORY, "Failed to create CInfoTip");
        }
        hr = ptip->QueryInterface(riid,ppvOut);
        ptip->Release();
    }
    else if (IsEqualIID(riid, IID_IShellPropSheetExt))
    {


        CPropSheetExt *pPropUI = new CPropSheetExt;
        if (!pPropUI)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = pPropUI->QueryInterface(riid, ppvOut);
            pPropUI->Release ();
        }

    }

exit_gracefully:


    TraceLeaveResult(hr);
}



/*****************************************************************************

   GetInFolderName

   Returns the approriate short or friendly display name for the item.

 *****************************************************************************/

HRESULT
GetInFolderName( UINT uFlags,
                 LPCITEMIDLIST pidl,
                 LPSTRRET pName
                )
{
    HRESULT hr;
    CSimpleStringWide strName;

    TraceEnter( TRACE_FOLDER, "GetInFolderName" );



    //
    // Check to see if they want the parsing name or not...
    //

    if (uFlags & SHGDN_FORPARSING)
    {
        if (uFlags & SHGDN_FORADDRESSBAR)
        {
            goto GetRegularName;
        }

        hr = IMGetParsingNameFromIDL( const_cast<LPITEMIDLIST>(pidl), strName );
        FailGracefully( hr, "Couldn't get parsing name for IDL" );

        Trace(TEXT("InFolder parsing name is: %ls"),strName.String());
    }
    else
    {
GetRegularName:

        hr = IMGetNameFromIDL( (LPITEMIDLIST)pidl, strName );
        FailGracefully( hr, "Couldn't get display name for IDL" );


        Trace(TEXT("InFolder name is: %ls"),strName.String());
    }
    // always concat the extension for camera items
    if (IsCameraItemIDL( (LPITEMIDLIST)pidl ) && (!IsContainerIDL((LPITEMIDLIST)pidl)))
    {
        TCHAR szExt[ MAX_PATH ];
        hr = IMGetImagePreferredFormatFromIDL( (LPITEMIDLIST)pidl, NULL, szExt );
        if (SUCCEEDED(hr))
        {
            strName.Concat (CSimpleStringConvert::WideString (CSimpleString(szExt )));
        }
        else
        {
            CSimpleString bmp( IDS_BMP_EXT, GLOBAL_HINSTANCE );
            strName.Concat (CSimpleStringConvert::WideString( bmp) );
            hr = S_OK;
        }
    }
    // now call the shell to format the display name according to user settings
    if (!IsDeviceIDL((LPITEMIDLIST)pidl)&& !(uFlags & SHGDN_FORPARSING))
    {
        SHFILEINFO sfi = { 0 };
        DWORD dwAttrib = IsContainerIDL((LPITEMIDLIST)pidl) ? FILE_ATTRIBUTE_DIRECTORY:0;
        if (SHGetFileInfo(strName, dwAttrib, &sfi, sizeof(sfi), SHGFI_USEFILEATTRIBUTES|SHGFI_DISPLAYNAME))
        {
            strName = sfi.szDisplayName;
        }

    }

    hr = StrRetFromString( pName, strName );

exit_gracefully:

    TraceLeaveResult(hr);

}



/*****************************************************************************

   GetNormalName

   Returns the appropriate full display name for the item. On Win2k we use the
   regitem prefix, on millennium we use a non-regitem to work as a delegate folder

 *****************************************************************************/
#ifdef NODELEGATE
static const WCHAR cszPrefix[] = L"::";
#else
static const WCHAR cszPrefix[] = L";;";
#endif
HRESULT
GetNormalName( UINT uFlags,
               LPCITEMIDLIST pidl,
               LPCITEMIDLIST pidlFolder,
               LPSTRRET pName
              )
{
    HRESULT hr;
    CSimpleStringWide strName;
    CSimpleStringWide strTmp;
    LPITEMIDLIST pidlTmp;

    TraceEnter( TRACE_FOLDER, "GetNormalName" );


    //
    // If it's FORPARSING but not FORADDRESSBAR then do the whole
    // she-bang -- from the root of the folder...
    //

    if ( (uFlags & SHGDN_FORPARSING) && (!(uFlags & SHGDN_FORADDRESSBAR) ))
    {

        //
        // First walk folder pidl, then item pidl to make
        // fully qualified folder name
        //

        pidlTmp = const_cast<LPITEMIDLIST>(pidlFolder);
        // Find the first pidl that belongs to us
        while (pidlTmp && pidlTmp->mkid.cb && !IMIsOurIDL(pidlTmp))
        {
            pidlTmp = ILGetNext(pidlTmp);
        }
        strName.Concat (cszPrefix);
        strName.Concat (cszImageCLSID );
        //
        // Add the parsing name for the device if it is one

        if (pidlTmp && IsDeviceIDL(pidlTmp))
        {
            IMGetParsingNameFromIDL(pidlTmp, strTmp);
            if (strName.Length())
            {
                strName.Concat(L"\\");
            }
            strName.Concat (strTmp);
        }
        //
        // The last item in the list should contain a fully qualified
        // path name (at least relative to the device).  So once we
        // get that string, we can concatinate to the scanners & cameras
        // + device GUID strings...
        //

        pidlTmp = ILFindLastID( pidl );

        hr = IMGetParsingNameFromIDL( pidlTmp, strTmp );
        FailGracefully( hr, "failed to get parsing name for pidl" );

        if (strName.Length())
        {
            strName.Concat (L"\\");
        }
        strName.Concat (strTmp );
    }
    else
    {
        for ( pidlTmp = (LPITEMIDLIST)pidl;
              pidlTmp && pidlTmp->mkid.cb;
              pidlTmp = ILGetNext(pidlTmp)
             )
        {
            hr = IMGetNameFromIDL( (LPITEMIDLIST)pidlTmp, strTmp );
            FailGracefully( hr, "failed to get display name for pidl" );

            if (strName.Length())
            {
                strName.Concat (L"\\" );
            }
            strName.Concat ( strTmp );
        }
    }

#ifdef DEBUG
    if (uFlags & SHGDN_FORPARSING)
    {
        Trace(TEXT("Parsing name is: %ls"),strName.String());
    }
    else
    {
        Trace(TEXT("Normal name is: %ls"),strName.String());
    }
#endif

    hr = StrRetFromString( pName, strName );

exit_gracefully:

    TraceLeaveResult(hr);
}



/*****************************************************************************

   CImageFolder::GetDisplayNameOf [IShellFolder]

   Return the various forms of the name for the specified item.

 *****************************************************************************/

STDMETHODIMP
CImageFolder::GetDisplayNameOf( LPCITEMIDLIST pidl,
                                DWORD uFlags,
                                LPSTRRET pName
                               )
{
    HRESULT hr = E_FAIL;

    TraceEnter(TRACE_FOLDER, "CImageFolder(IShellFolder)::GetDisplayNameOf");

#ifdef DEBUG
    TCHAR szName[ MAX_PATH ];
    wsprintf( szName, TEXT("uFlags(0x%0x) = "), uFlags );

    if (uFlags & SHGDN_INFOLDER)
    {
        lstrcat( szName, TEXT("INFOLDER ") );
    }
    else
    {
        lstrcat( szName, TEXT("NORMAL ") );
    }

    if (uFlags & SHGDN_FOREDITING)
    {
        lstrcat( szName, TEXT("FOREDITING ") );
    }

//
// RickTu: It seems this flag has been removed in latest shell headers.  2/15/99
//
//    if (uFlags & SHGDN_INCLUDE_NONFILESYS)
//    {
//        lstrcat( szName, TEXT("INCLUDE_NONFILESYS ") );
//    }

    if (uFlags & SHGDN_FORADDRESSBAR)
    {
        lstrcat( szName, TEXT("FORADDRESSBAR ") );
    }

    if (uFlags & SHGDN_FORPARSING)
    {
        lstrcat( szName, TEXT("FORPARSING ") );
    }
    Trace(szName);
    szName[0] = 0;
#endif

    //
    // Check for bad params...
    //

    TraceAssert(pName);

    if ( !pName )
    {
        hr = E_INVALIDARG;
    }
    else
    {
        //
        // Figure out what name to return based on the flags passed in...
        //
        // special case the Add Device icon for SHGDN_FORPARSING, as this name is canonical, not localized
        if (IsAddDeviceIDL(const_cast<LPITEMIDLIST>(pidl)) &&  (uFlags & SHGDN_FORPARSING))
        {
            hr = StrRetFromString(pName, cszAddDeviceName);
        }
        else
        {
            if (uFlags & SHGDN_INFOLDER)
            {
                hr = GetInFolderName( uFlags, pidl, pName );            
            }
            else
            {
                //
                // If SHGDN_INFOLDER is not set, then it must be Normal...
                //
                hr = GetNormalName( uFlags, pidl, m_pidlFull, pName );            
            }
        }
    }

    TraceLeaveResult(hr);
}


/*****************************************************************************

    IsValidDeviceName

    Make sure the name is non empty and has chars other than space. Also make sure
    it's not a duplicate

*****************************************************************************/

bool
IsValidDeviceName (LPCOLESTR pName)
{
    bool bRet = false;
    TraceEnter (TRACE_FOLDER, "IsValidDeviceName");
    Trace (TEXT("New name: %ls"), pName);
    LPCOLESTR psz = pName;
    if (psz && *psz)
    {
        while (*psz)
        {
            if (*psz != L' ')
            {
                bRet = true;
            }
            psz++;
        }
    }
    // disallow overly long names
    if (bRet)
    {
        bRet = (psz - pName <= 64);
    }
    if (bRet)
    {
        // check for duplicates in WIA
        CComPtr<IWiaDevMgr> pDevMgr;
        if (SUCCEEDED(GetDevMgrObject (reinterpret_cast<LPVOID*>(&pDevMgr))))
        {
            CComPtr<IEnumWIA_DEV_INFO> pEnum;
            CComPtr<IWiaPropertyStorage> pStg;
            ULONG ul;
            if (SUCCEEDED(pDevMgr->EnumDeviceInfo (DEV_MAN_ENUM_TYPE_STI | DEV_MAN_ENUM_TYPE_INACTIVE, &pEnum)))
            {
                CSimpleStringWide strName;
                while (bRet && S_OK == pEnum->Next(1, &pStg, &ul))
                {
                    PropStorageHelpers::GetProperty (pStg, WIA_DIP_DEV_NAME, strName);

                    if (!_wcsicmp(strName, pName))
                    {
                        Trace(TEXT("Found a WIA device of the same name! %ls"), pName);
                        bRet = false;
                    }
                    pStg = NULL;
                }
            }
        }
    }
    TraceLeave();
    return bRet;
}
/*****************************************************************************

   CImageFolder::SetNameOf [IShellFolder]

   Set/Reset the name of the specified item. In order to make the shell updates
   correct, we need to bind to our delegated folder in My Computer to perform the
   rename and issue the update.

 *****************************************************************************/

STDMETHODIMP
CImageFolder::SetNameOf( HWND hwndOwner,
                         LPCITEMIDLIST pidl,
                         LPCOLESTR pName,
                         DWORD uFlags,
                         LPITEMIDLIST * ppidlOut
                        )
{
    HRESULT hr = E_FAIL;
    TraceEnter(TRACE_FOLDER, "CImageFolder(IShellFolder)::SetNameOf ");

    CSimpleStringWide strDeviceId;
    DWORD dwType;
    LPITEMIDLIST pidlNew = NULL;
    BOOL bUpdate = FALSE;
    // do the actual rename
    if (ppidlOut)
    {
        *ppidlOut = NULL;
    }
    // How should we treat uFlags?
    CSimpleStringWide strName;
    IMGetNameFromIDL(const_cast<LPITEMIDLIST>(pidl), strName);
    if (!lstrcmpi(strName, pName))
    {
        hr = S_OK; // same name, no-op
    }
    else if (IsDeviceIDL(const_cast<LPITEMIDLIST>(pidl)))
    {
        CComPtr<IWiaPropertyStorage> pStg;
        if (IsValidDeviceName(pName))
        {

            IMGetDeviceIdFromIDL (const_cast<LPITEMIDLIST>(pidl), strDeviceId);
            dwType = IMGetDeviceTypeFromIDL (const_cast<LPITEMIDLIST>(pidl));
            Trace (TEXT("Attempting rename of %ls"), strDeviceId.String());
            // enumerate the devices, looking for one with the same device id
            // we can only change the name using the IPropertyStorage returned
            // by the enumerator, not from QI on the device
            hr = GetDeviceFromDeviceId (strDeviceId,
                                        IID_IWiaPropertyStorage,
                                        reinterpret_cast<LPVOID*>(&pStg),
                                        FALSE);
        }
        if (SUCCEEDED(hr))
        {

            PROPVARIANT pv;
            pv.vt = VT_LPWSTR;
            pv.pwszVal = const_cast<LPWSTR>(pName);
            if (PropStorageHelpers::SetProperty(pStg, WIA_DIP_DEV_NAME, pv))
            {
                hr = S_OK;
                bUpdate = TRUE;
                pidlNew = IMCreateDeviceIDL (pStg, m_pMalloc);
                if (ppidlOut)
                {
                    Trace (TEXT("Returning new pidl"));
                    *ppidlOut = ILClone( pidlNew);
                }
            }
            else
            {
                Trace(TEXT("SetProperty failed"));
                hr = E_FAIL;
            }
        }
        else
        {
            CSimpleStringWide strCurName;
            Trace(TEXT("No device found, or invalid name %ls"), pName);
            CSimpleString strMessage;
            IMGetNameFromIDL (const_cast<LPITEMIDLIST>(pidl), strCurName);
            strMessage.Format (IDS_INVALIDNAME, GLOBAL_HINSTANCE, strCurName.String());
            UIErrors::ReportMessage(NULL, GLOBAL_HINSTANCE,
                                    NULL,
                                    MAKEINTRESOURCE(IDS_INVALIDNAME_TITLE),
                                    strMessage);

        }
    }

    // Also issue the changenotify for the shell
    if (bUpdate)
    {

        Trace (TEXT("SetNameOf: Updating device %ls"), strDeviceId.String());

        // Update the shell
        // For folders we have to use SHCNE_RENAMEFOLDER in addition to updateitem

        switch (IMGetDeviceTypeFromIDL (const_cast<LPITEMIDLIST>(pidl)))
        {
                case StiDeviceTypeDigitalCamera:
                case StiDeviceTypeStreamingVideo:
                {

                    LPITEMIDLIST pidlFullOld = ILCombine (m_pidlFull, pidl);
                    LPITEMIDLIST pidlFullNew = ILCombine (m_pidlFull, pidlNew);
                    if (pidlFullOld && pidlFullNew)
                    {
                        SHChangeNotify (SHCNE_RENAMEFOLDER,
                                        SHCNF_IDLIST, pidlFullOld, pidlFullNew);
                    }
                    DoILFree (pidlFullOld);
                    DoILFree (pidlFullNew);
                }
                    break;

                default:

                    break;

        }
        IssueChangeNotifyForDevice (NULL, SHCNE_UPDATEDIR, NULL);

    }
    DoILFree (pidlNew);
    TraceLeaveResult(hr);
}





/*****************************************************************************

   CImageFolder::CreateFolderViewCB [Internal]

   Create the view callback object appropriate to the type of folder.

 *****************************************************************************/

HRESULT
CImageFolder::CreateFolderViewCB (IShellFolderViewCB **pFolderViewCB)
{
    HRESULT hr = E_OUTOFMEMORY;
    CBaseView *pView = NULL;
    CSimpleStringWide strDeviceId;
    TraceEnter (TRACE_FOLDER, "CreateFolderViewCB");

    switch (m_type)
    {
        case FOLDER_IS_ROOT:
            pView = new CRootView (this);
            break;
        case FOLDER_IS_VIDEO_DEVICE:
        case FOLDER_IS_CAMERA_DEVICE:
        case FOLDER_IS_CONTAINER:
        case FOLDER_IS_CAMERA_ITEM:
            IMGetDeviceIdFromIDL (m_pidl, strDeviceId);
            pView = new CCameraView (this, strDeviceId, m_type);
            break;
        default:
            hr = E_FAIL;
            break;
    }
    if (pView)
    {
        hr = pView->QueryInterface (IID_IShellFolderViewCB, reinterpret_cast<LPVOID*>(pFolderViewCB));
    }
    DoRelease (pView);
    TraceLeaveResult (hr);
}



/*****************************************************************************

   CImageFolder::IsDirty [IPersistFile]

     Tell caller whether bits are dirty.

 *****************************************************************************/

STDMETHODIMP
CImageFolder::IsDirty(void)
{
    TraceEnter( TRACE_FOLDER, "CImageFolder(IPersistFile)::IsDirty (not implemented)" );
    TraceLeaveResult(E_NOTIMPL);
}


/*****************************************************************************

   CImageFolder::Load [IPersistFile]

     Load the bits from the specified file.

 *****************************************************************************/

STDMETHODIMP
CImageFolder::Load(LPCOLESTR pszFileName, DWORD dwMode)
{
    TraceEnter( TRACE_FOLDER, "CImageFolder(IPersistFile)::Load (not implemented)" );
    TraceLeaveResult(E_NOTIMPL);
}


/*****************************************************************************

   CImageFolder::Save [IPersistFile]

     Save the bits to the specified file.

 *****************************************************************************/

STDMETHODIMP
CImageFolder::Save(LPCOLESTR pszFileName, BOOL fRemember)
{
    TraceEnter( TRACE_FOLDER, "CImageFolder(IPersistFile)::Save (not implemented)" );
    TraceLeaveResult(E_NOTIMPL);
}


/*****************************************************************************

   CImageFolder::SaveCompleted [IPersistFile]

     Check to see if the save completed.

 *****************************************************************************/

STDMETHODIMP
CImageFolder::SaveCompleted(LPCOLESTR pszFileName)
{
    TraceEnter( TRACE_FOLDER, "CImageFolder(IPersistFile)::SaveCompleted (not implemented)" );
    TraceLeaveResult(E_NOTIMPL);
}



/*****************************************************************************

   CImageFolder::GetCurFile [IPersistFile]

     Get the name of the file in question.

 *****************************************************************************/

STDMETHODIMP
CImageFolder::GetCurFile(LPOLESTR *ppszFileName)
{
    TraceEnter( TRACE_FOLDER, "CImageFolder(IPersistFile)::GetCurFile (not implemented)" );
    TraceLeaveResult(E_NOTIMPL);
}

/*****************************************************************************

   CImageFolder::SetItemAlloc [IDelegateFolder]

     Store allocator for our pidls

 *****************************************************************************/
STDMETHODIMP
CImageFolder::SetItemAlloc(IMalloc *pm)
{
    TraceEnter (TRACE_FOLDER, "CImageFolder::SetItemAlloc");
    m_pMalloc = pm;
    TraceLeaveResult (S_OK);
}


/*****************************************************************************
    CInfoTip::GetInfoFlags

    Not implemented, nor used by the shell

*****************************************************************************/
// CInfoTip methods
STDMETHODIMP
CInfoTip::GetInfoFlags(DWORD *pdwFlags)
{
    *pdwFlags = 0;
    return E_NOTIMPL;
}

/*****************************************************************************
    Tip::GetInfoTip

    Return an infotip for the selected item.

*****************************************************************************/

STDMETHODIMP
CInfoTip::GetInfoTip (DWORD dwFlags, WCHAR **ppwszTip)
{
    HRESULT hr = E_FAIL;
    UINT idStr = 0;

    TraceEnter (TRACE_FOLDER, "CInfoTip::GetInfoTip");
    *ppwszTip = NULL;
    if (IsAddDeviceIDL(m_pidl))
    {
        idStr = IDS_ADDDEV_DESC;
    }
    else if (IsDeviceIDL(m_pidl))
    {
        switch (IMGetDeviceTypeFromIDL (m_pidl))
        {
            case StiDeviceTypeDigitalCamera:
            case StiDeviceTypeStreamingVideo:
                if (m_bDelegate)
                {
                    idStr = IDS_WIACAM_MYCOMP_INFOTIP;
                }
                else
                {
                    idStr = IDS_WIACAM_INFOTIP;
                }
                break;
            case StiDeviceTypeScanner:
                idStr = IDS_WIASCAN_INFOTIP;
                break;

        }
    }
    else if (IsSTIDeviceIDL(m_pidl))
    {
        idStr = IDS_STIDEVICE_INFOTIP;
    }

    if (idStr)
    {
        TCHAR szString[MAX_PATH] = TEXT("\0");
        LPWSTR pRet;
        CComPtr<IMalloc> pMalloc;
        SIZE_T cb;
        hr = SHGetMalloc (&pMalloc);
        if (SUCCEEDED(hr))
        {
            LoadString (GLOBAL_HINSTANCE, idStr, szString, ARRAYSIZE(szString));
            cb = (_tcslen(szString)+1)*sizeof(WCHAR);
            pRet = reinterpret_cast<LPWSTR>(pMalloc->Alloc (cb));
            if (pRet)
            {
                #ifdef UNICODE
                lstrcpy (pRet, szString);
                #else
                MultiByteToWideChar (CP_ACP, 0, szString, -1, pRet, cb/sizeof(WCHAR));
                #endif
                hr = S_OK;
                *ppwszTip = pRet;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    TraceLeaveResult (hr);
}

/*****************************************************************************
    CInfoTip::QueryInterface

*****************************************************************************/

STDMETHODIMP
CInfoTip::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    INTERFACES iface[] =
    {&IID_IQueryInfo, static_cast<IQueryInfo*>(this)};

    return HandleQueryInterface (riid, ppvObj, iface, ARRAYSIZE(iface));

}

#undef CLASS_NAME
#define CLASS_NAME CInfoTip
#include "unknown.inc"

/*****************************************************************************
    CInfoTip constructor

*****************************************************************************/

CInfoTip::CInfoTip(LPITEMIDLIST pidl, BOOL bDelegate)
    : m_bDelegate(bDelegate)
{
    m_pidl = ILClone (pidl);
}

/*****************************************************************************
    CInfoTip destructor

*****************************************************************************/

CInfoTip::~CInfoTip ()
{
    DoILFree (m_pidl);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\src\idlist.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998 - 1999
 *
 *  TITLE:       idlist.cpp
 *
 *  VERSION:     1.5
 *
 *  AUTHOR:      RickTu/DavidShi
 *
 *  DATE:        11/1/97
 *
 *  DESCRIPTION: Code which handles our idlists
 *
 *****************************************************************************/

#include "precomp.hxx"
#include "wiaffmt.h"
#pragma hdrstop



/*****************************************************************************

   Define our IDLIST formats

 *****************************************************************************/


#pragma pack(1)

struct _myidlheader {
    WORD cbSize;  // size of entire item ID
    WORD wOuter;  // Private data owned by the outer folder
    WORD cbInner; // Size of delegate's data
    DWORD dwMagic;
    DWORD dwFlags;
    ULONG ulType;
    WCHAR szDeviceId[STI_MAX_INTERNAL_NAME_LENGTH];
};

typedef struct _myidlheader MYIDLHEADER;
typedef UNALIGNED MYIDLHEADER* LPMYIDLHEADER;

struct _deviceidlist {
    MYIDLHEADER hdr;
    DWORD dwDeviceType;
    WCHAR szFriendlyName[1];
};

struct _cameraitemidlist {
    MYIDLHEADER hdr;
    BOOL        bHasAudioProperty;
    size_t      dwFullPathOffset;
    WCHAR       szFriendlyName[1];
};

struct _scanneritemidlist {
    MYIDLHEADER hdr;
    size_t      dwFullPathOffset;
    WCHAR       szFriendlyName[1];
};

struct _adddeviceidlist {
    MYIDLHEADER hdr;
};

struct _stideviceidlist {
    MYIDLHEADER hdr;
    DWORD dwDeviceType;
    WCHAR szFriendlyName[1];
};

struct _propertyidlist {
    MYIDLHEADER hdr;
    PROPID      propid;
    size_t      dwNameOffset;
    WCHAR       szFullPath[1];
};

typedef struct _propertyidlist PROPIDLIST;
typedef UNALIGNED PROPIDLIST* LPPROPIDLIST;

#pragma pack()

typedef struct _deviceidlist DEVICEIDLIST;
typedef UNALIGNED DEVICEIDLIST* LPDEVICEIDLIST;

typedef struct _cameraitemidlist CAMERAITEMIDLIST;
typedef UNALIGNED CAMERAITEMIDLIST* LPCAMERAITEMIDLIST;

typedef struct _scanneritemidlist SCANNERITEMIDLIST;
typedef UNALIGNED SCANNERITEMIDLIST* LPSCANNERITEMIDLIST;

typedef struct _adddeviceidlist ADDDEVICEIDLIST;
typedef UNALIGNED ADDDEVICEIDLIST* LPADDDEVICEIDLIST;

typedef struct _stideviceidlist STIDEVICEIDLIST;
typedef UNALIGNED STIDEVICEIDLIST *LPSTIDEVICEIDLIST;
const TCHAR c_szTHISDLL[] = TEXT("wiashext.dll");


const WCHAR g_cszDevIdPrefix[] = L"devid:";
const WCHAR g_cszDevIdSuffix[] = L":";
const WCHAR g_chDevIdSuffix = L':';

/*****************************************************************************

   IsAddDeviceIDL

   Given an idlist, checks to see if it is a add device idl

 *****************************************************************************/

BOOL
IsAddDeviceIDL( LPITEMIDLIST pidlIN )
{
    LPADDDEVICEIDLIST pidl = (LPADDDEVICEIDLIST)pidlIN;

    #ifdef VERBOSE
    TraceEnter( TRACE_IDLIST, "IsAddDeviceIDL" );
    #endif

    if ( IMIsOurIDL( pidlIN ) )
    {
        if (pidl->hdr.dwFlags & IMIDL_ADDDEVICE)
        {
            #ifdef VERBOSE
            Trace(TEXT("returning TRUE"));
            TraceLeaveValue(TRUE);
            #else
            return TRUE;
            #endif
        }
    }

    #ifdef VERBOSE
    Trace(TEXT("returning FALSE"));
    TraceLeaveValue(FALSE);
    #else
    return FALSE;
    #endif
}



/*****************************************************************************

   IsScannerItemIDL

   Given an idlist, checks to see if it is a scanner item IDL

 *****************************************************************************/

BOOL
IsScannerItemIDL( LPITEMIDLIST pidlIN )
{
    LPSCANNERITEMIDLIST pidl = (LPSCANNERITEMIDLIST)pidlIN;

    #ifdef VERBOSE
    TraceEnter( TRACE_IDLIST, "IsScannerItemIDL" );
    #endif

    if ( IMIsOurIDL( pidlIN ) )
    {
        if (pidl->hdr.dwFlags & IMIDL_SCANNERITEM)
        {
            #ifdef VERBOSE
            Trace(TEXT("returning TRUE"));
            TraceLeaveValue(TRUE);
            #else
            return TRUE;
            #endif
        }
    }

    #ifdef VERBOSE
    Trace(TEXT("returning FALSE"));
    TraceLeaveValue(FALSE);
    #else
    return FALSE;
    #endif
}


/*****************************************************************************

   IsRemoteItemIDL

   <Notes>

 *****************************************************************************/

BOOL
IsRemoteItemIDL (LPITEMIDLIST pidlIN)
{
    LPDEVICEIDLIST pidl = reinterpret_cast<LPDEVICEIDLIST>(pidlIN);
    if (IMIsOurIDL(pidlIN))
    {
        return pidl->hdr.dwFlags & IMIDL_REMOTEDEVICE;
    }
    return FALSE;
}


/*****************************************************************************

   IsCameraItemIDL

   Given an idlist, checks to see if it is a camera item.

 *****************************************************************************/

BOOL
IsCameraItemIDL( LPITEMIDLIST pidlIN )
{
    LPCAMERAITEMIDLIST pidl = (LPCAMERAITEMIDLIST)pidlIN;

    #ifdef VERBOSE
    TraceEnter( TRACE_IDLIST, "IsCameraItemIDL" );
    #endif

    if ( IMIsOurIDL( pidlIN ) )
    {
        if (pidl->hdr.dwFlags & IMIDL_CAMERAITEM)
        {
            #ifdef VERBOSE
            Trace(TEXT("returning TRUE"));
            TraceLeaveValue(TRUE);
            #else
            return TRUE;
            #endif
        }
    }

    #ifdef VERBOSE
    Trace(TEXT("returning FALSE"));
    TraceLeaveValue(FALSE);
    #else
    return FALSE;
    #endif
}



/*****************************************************************************

   IsContainerIDL

   Given an idlist, checks to see if it is a camera item container IDL

 *****************************************************************************/

BOOL
IsContainerIDL( LPITEMIDLIST pidlIN )
{
    LPCAMERAITEMIDLIST pidl = (LPCAMERAITEMIDLIST)pidlIN;

    #ifdef VERBOSE
    TraceEnter( TRACE_IDLIST, "IsContainerIDL" );
    #endif

    if ( IMIsOurIDL( pidlIN ) )
    {
        if (pidl->hdr.dwFlags & IMIDL_CONTAINER)
        {
            #ifdef VERBOSE
            Trace(TEXT("returning TRUE"));
            TraceLeaveValue(TRUE);
            #else
            return TRUE;
            #endif
        }
    }

    #ifdef VERBOSE
    Trace(TEXT("returning FALSE"));
    TraceLeaveValue(FALSE);
    #else
    return FALSE;
    #endif
}



/*****************************************************************************

   IsDeviceIDL

   Given an idlist, checks to see if it is a device IDL

 *****************************************************************************/

BOOL
IsDeviceIDL( LPITEMIDLIST pidlIN )
{
    LPDEVICEIDLIST pidl = (LPDEVICEIDLIST)pidlIN;

    #ifdef VERBOSE
    TraceEnter( TRACE_IDLIST, "IsDeviceIDL" );
    #endif

    if ( IMIsOurIDL( pidlIN ) )
    {
        if (pidl->hdr.dwFlags & IMIDL_DEVICEIDL)
        {
            #ifdef VERBOSE
            Trace(TEXT("returning TRUE"));
            TraceLeaveValue(TRUE);
            #else
            return TRUE;
            #endif
        }
    }

    #ifdef VERBOSE
    Trace(TEXT("returning FALSE"));
    TraceLeaveValue(FALSE);
    #else
    return FALSE;
    #endif
}



/*****************************************************************************

   IsSTIDeviceIDL

   <Notes>

 *****************************************************************************/

BOOL
IsSTIDeviceIDL (LPITEMIDLIST pidl)
{
    BOOL bRet = FALSE;
    TraceEnter (TRACE_IDLIST, "IsSTIDeviceIDL");
    if (IMIsOurIDL(pidl))
    {
        bRet = IMIDL_STIDEVICEIDL & reinterpret_cast<LPSTIDEVICEIDLIST>(pidl)->hdr.dwFlags;
    }
    TraceLeave ();
    return bRet;
}

/*****************************************************************************
    IsPropertyIDL

*****************************************************************************/
BOOL
IsPropertyIDL (LPITEMIDLIST pidl)
{
    BOOL bRet = FALSE;
    TraceEnter (TRACE_IDLIST, "IsPropertyIDL");
    if (IMIsOurIDL(pidl))
    {
        bRet = IMIDL_PROPERTY & reinterpret_cast<LPPROPIDLIST>(pidl)->hdr.dwFlags;
    }
    TraceLeave ();
    return bRet;
}


/*****************************************************************************

   AllocPidl

   Allocate the pidl, init the header size.

*****************************************************************************/

LPVOID
AllocPidl (size_t size, IMalloc *pm, const CSimpleStringWide &strDeviceId)
{
    TraceEnter (TRACE_IDLIST, "AllocPidl");
    Trace(TEXT("Size is %d"), size);
    LPVOID pRet;
    if (pm)
    {
       pRet = pm->Alloc (size+sizeof(WORD));
       // we don't zero out the allocation because the delegate imalloc
       // did it for us then wrote to the buffer.
    }
    else
    {
        pRet = SHAlloc (size+sizeof(WORD));
        ZeroMemory (pRet, size+sizeof(WORD));
    }

    if (pRet)
    {
        if (!pm)
        {
            reinterpret_cast<_myidlheader*>(pRet)->cbSize = static_cast<WORD>(size);
        }
        reinterpret_cast<_myidlheader*>(pRet)->dwMagic = IMIDL_MAGIC;
        wcscpy (reinterpret_cast<_myidlheader*>(pRet)->szDeviceId, strDeviceId);
    }

    TraceLeave ();
    return pRet;
}

/*****************************************************************************

   IMCreateAddDeviceIDL

   Return an IDL for the Imaging Devices folder that represents an
   item to add devices.

 *****************************************************************************/

LPITEMIDLIST
IMCreateAddDeviceIDL(IMalloc *pm )
{

    TraceEnter( TRACE_IDLIST, "IMCreateAddDeviceIDL" );


    LPADDDEVICEIDLIST pidl;

    pidl = reinterpret_cast<LPADDDEVICEIDLIST>(AllocPidl (sizeof(ADDDEVICEIDLIST),
                                                          pm,
                                                          CSimpleStringWide(L"")));



    if (pidl)
    {
        //
        // Store the info for the pidl...
        //
        pidl->hdr.dwFlags = IMIDL_ADDDEVICE;
        pidl->hdr.ulType = 0;
    }

    TraceLeave();

    return (LPITEMIDLIST)pidl;
}


/*****************************************************************************

   IMCreateDeviceIDL

   Return an IDL for the Imaging Devices folder that represents an
   imaging device, given an IWiaItem.

 *****************************************************************************/

LPITEMIDLIST IMCreateDeviceIDL (IWiaItem *pItem, IMalloc *pm)
{
    LPITEMIDLIST pidl = NULL;


    CComQIPtr<IWiaPropertyStorage, &IID_IWiaPropertyStorage> pps(pItem);

    if (pps)
    {
         pidl = IMCreateDeviceIDL (pps, pm);
    }
    return pidl;
}


/*****************************************************************************

   IMCreateDeviceIDL

   Return an IDL for the Imaging Devices folder that represents an
   imaging device, given an IWiaPropertyStorage.

 *****************************************************************************/

LPITEMIDLIST
IMCreateDeviceIDL( IWiaPropertyStorage * pDevProp, IMalloc *pm )
{
    HRESULT hr = S_OK;


    PROPSPEC        PropSpec[4];
    PROPVARIANT     PropVar[4];
    DWORD           dwFlags = 0;
    LPDEVICEIDLIST  pidl = NULL;
    INT             cbSize = 0, cbFriendlyName = 0;
    CSimpleStringWide  strFriendlyName;


    TraceEnter(TRACE_IDLIST, "IMCreateDeviceIDL");

    //
    // Get device Name and DeviecID
    // init propspec and propvar for call to ReadMultiple
    //

    memset(&PropVar,0,sizeof(PropVar));

    // Prop 0 is device name
    PropSpec[0].ulKind = PRSPEC_PROPID;
    PropSpec[0].propid = WIA_DIP_DEV_NAME;

    // Prop 1 is device id
    PropSpec[1].ulKind = PRSPEC_PROPID;
    PropSpec[1].propid = WIA_DIP_DEV_ID;

    // Prop 2 is device type
    PropSpec[2].ulKind = PRSPEC_PROPID;
    PropSpec[2].propid = WIA_DIP_DEV_TYPE;

    // Prop 3 is server name
    PropSpec[3].ulKind = PRSPEC_PROPID;
    PropSpec[3].propid = WIA_DIP_SERVER_NAME;

    hr = pDevProp->ReadMultiple( sizeof(PropSpec) / sizeof(PROPSPEC),
                                 PropSpec,
                                 PropVar
                                );

    FailGracefully( hr, "couldn't get current values of DeviceID and Name" );

    if ((PropVar[0].vt != VT_BSTR) || (!PropVar[0].bstrVal) ||
        (PropVar[1].vt != VT_BSTR) || (!PropVar[1].bstrVal))
    {
        FailGracefully( hr, "didn't get BSTR's back for DeviceID and Name" );
    }



    strFriendlyName = PropVar[0].bstrVal;


    // For remote devices, add " on <servername>"
    if (wcscmp (L"local", PropVar[3].bstrVal))
    {
        CSimpleString strOn(IDS_ON, GLOBAL_HINSTANCE);
        CSimpleStringWide strServer (PropVar[3].bstrVal);

        strFriendlyName.Concat(CSimpleStringConvert::WideString(strOn));
        strFriendlyName.Concat(strServer);
        dwFlags = IMIDL_REMOTEDEVICE;

    }
    //
    // Don't count NULL terminator because it's already accounted
    // for in the pidl structure
    //
    cbFriendlyName = strFriendlyName.Length()*sizeof(WCHAR);

    //
    // Calculate the size and allocate a pidl
    //

    cbSize = sizeof(DEVICEIDLIST) +
             cbFriendlyName;


    pidl = reinterpret_cast<LPDEVICEIDLIST>(AllocPidl(cbSize, pm, CSimpleStringWide(PropVar[1].bstrVal)));
    if (pidl)
    {


        //
        // Store the info for the pidl...
        //

        pidl->hdr.dwFlags = dwFlags | IMIDL_DEVICEIDL;
        pidl->hdr.ulType  = WiaItemTypeRoot | WiaItemTypeDevice;

        //
        // stick the friendly name in the pidl...
        //

        ua_wcscpy( pidl->szFriendlyName, strFriendlyName );


        //
        // Store the device type...
        //

        pidl->dwDeviceType = PropVar[2].lVal;
    }

exit_gracefully:

    FreePropVariantArray( sizeof(PropVar)/sizeof(PROPVARIANT),PropVar );

    TraceLeave();

    return (LPITEMIDLIST)pidl;

}

LPITEMIDLIST
IMCreateDeviceIDL (PSTI_DEVICE_INFORMATION pDevice, IMalloc *pm)
{
    TraceEnter(TRACE_IDLIST, "IMCreateDeviceIDL (PSTI_DEVICE_INFORMATION)");
    DEVICEIDLIST UNALIGNED *pidl;
    PCWSTR pWStrAligned;

    size_t cbSize;

    cbSize = sizeof(DEVICEIDLIST) + (wcslen(pDevice->pszLocalName)*sizeof(WCHAR));

    WSTR_ALIGNED_STACK_COPY( &pWStrAligned,
                             pDevice->szDeviceInternalName );

    pidl = reinterpret_cast<LPDEVICEIDLIST>(AllocPidl(cbSize, pm, CSimpleStringWide(pWStrAligned)));
    if (pidl)
    {
        pidl->dwDeviceType = pDevice->DeviceType;
        pidl->hdr.dwFlags = IMIDL_DEVICEIDL;
        pidl->hdr.ulType  = WiaItemTypeRoot | WiaItemTypeDevice;
        ua_wcscpy (pidl->szFriendlyName, pDevice->pszLocalName);

    }
    TraceLeave();
    return reinterpret_cast<LPITEMIDLIST>(pidl);
}
static PROPSPEC c_psCamItem [] =
{
    {PRSPEC_PROPID, WIA_IPA_ITEM_NAME},
    {PRSPEC_PROPID, WIA_IPA_FULL_ITEM_NAME},
  //{PRSPEC_PROPID, WIA_IPA_PREFERRED_FORMAT},
    {PRSPEC_PROPID, WIA_IPC_AUDIO_AVAILABLE},
  //  {PRSPEC_PROPID, WIA_IPA_ACCESS_RIGHTS},
    {PRSPEC_PROPID, WIA_IPC_THUMBNAIL},
    {PRSPEC_PROPID, WIA_IPC_THUMB_WIDTH},
    {PRSPEC_PROPID, WIA_IPC_THUMB_HEIGHT},
};

/*****************************************************************************

   IMCreateCameraItemIDL

   Return an IDL for the Imaging Devices folder that represents an item
   (either folder or picture) from a camera. If bPreFetchThumb is set, we need
   to query the thumbnail property to make sure WIA has it cached for later use

 *****************************************************************************/

LPITEMIDLIST
IMCreateCameraItemIDL( IWiaItem * pItem,
                       LPCWSTR szDeviceId,
                       IMalloc *pm,
                       bool bPreFetchThumb )
{


    HRESULT                 hr = S_OK;
    LPWSTR                  pExt;
    WCHAR                   szName[ MAX_PATH ];
    WCHAR                   szFullPath[ MAX_PATH ];
    LPCAMERAITEMIDLIST      pidl = NULL;
    INT                     cbSize = 0, cbName = 0, cbFullPath = 0;
    LONG                   lType;
    PROPSPEC                *pPropSpec = c_psCamItem;
    PROPVARIANT             PropVar[6];

    ULONG                   cProps = ARRAYSIZE(c_psCamItem);

    if (!bPreFetchThumb)
    {
        cProps -= 3; // only read thumbnail if asked
    }


    TraceEnter( TRACE_IDLIST, "IMCreateCameraItemIDL" );

    memset(&PropVar,0,sizeof(PropVar));


    CComQIPtr<IWiaPropertyStorage, &IID_IWiaPropertyStorage> pps(pItem);

    //
    // First, get the type of this item...
    //

    hr = pItem->GetItemType( &lType );
    FailGracefully( hr, "Couldn't get item type" );

    //
    // Get the item properties...
    //

    *szName = 0;
    *szFullPath = 0;


    if (!pps)
    {
        ExitGracefully( hr, E_FAIL, "couldn't QI IWiaPropertyStorage for item" );
    }

    hr = pps->ReadMultiple(cProps,
                           pPropSpec,
                           PropVar);
    FailGracefully( hr, "ReadMultiple failed for item..." );


    if (PropVar[0].pwszVal)
        wcscpy(szName,PropVar[0].pwszVal);

    if (PropVar[1].pwszVal)
        wcscpy(szFullPath,PropVar[1].pwszVal);


    pExt = PathFindExtensionW( szName );
    if (pExt && (*pExt == L'.'))
    {
        *pExt = 0;
    }


    //
    // Create the pidl...
    //

    cbName     = (wcslen(szName)     + 1) * sizeof(WCHAR);
    cbFullPath = (wcslen(szFullPath) + 1) * sizeof(WCHAR);

    cbSize     = sizeof(CAMERAITEMIDLIST) + cbName + cbFullPath;

    pidl       = static_cast<LPCAMERAITEMIDLIST>(AllocPidl( cbSize, pm, CSimpleStringWide(szDeviceId)) );

    if (pidl)
    {

        //
        // Store the info for the pidl...
        //

        pidl->hdr.dwFlags = IMIDL_CAMERAITEM;
        pidl->hdr.ulType  = lType;
        pidl->bHasAudioProperty = PropVar[2].ulVal ? TRUE:FALSE;
        //
        // store container info
        //

        if (lType & WiaItemTypeFolder)
        {
            pidl->hdr.dwFlags |= IMIDL_CONTAINER;
        }

        //
        // store the friendly name
        //

        ua_wcscpy( pidl->szFriendlyName, szName );

        //
        // store the full path
        //

        pidl->dwFullPathOffset = sizeof(CAMERAITEMIDLIST) + cbName;
        wcscpy( (LPWSTR)((LPBYTE)pidl + pidl->dwFullPathOffset), szFullPath );
    }


exit_gracefully:

    FreePropVariantArray( cProps,PropVar );
    TraceLeave();

    return (LPITEMIDLIST)pidl;
}



/*****************************************************************************

   IMCreateScannerItemIDL

   Return an IDL for the Imaging Devices folder that represents
   an item from a scanner.

 *****************************************************************************/

LPITEMIDLIST
IMCreateScannerItemIDL( IWiaItem *pItem, IMalloc *pm )
{


    CComPtr<IWiaItem>   pRoot;
    WCHAR               pWiaItemRootId[MAX_PATH];
    CSimpleStringWide   strFullName;
    CSimpleStringWide   strFriendlyName;
    INT                 cbFriendlyName, cbSize, cbFullName;
    LPSCANNERITEMIDLIST pidl;

    TraceEnter( TRACE_IDLIST, "IMCreateScannerItemIDL" );

    // Get the properties of interest

    PropStorageHelpers::GetProperty(pItem, WIA_IPA_FULL_ITEM_NAME, strFullName);
    PropStorageHelpers::GetProperty(pItem, WIA_IPA_ITEM_NAME, strFriendlyName);
    pItem->GetRootItem (&pRoot);
    GetDeviceIdFromDevice (pRoot, pWiaItemRootId);

    //
    // Don't count NULL terminator because it's already accounted
    // for in the pidl structure
    //

    cbFriendlyName = strFriendlyName.Length() * sizeof(WCHAR);

    cbFullName = (strFullName.Length()+1) * sizeof(WCHAR);


    //
    // Calculate the size and allocate a pidl
    //

    cbSize = sizeof(SCANNERITEMIDLIST) +
             cbFriendlyName       +
             cbFullName;

    pidl = static_cast<LPSCANNERITEMIDLIST>(AllocPidl( cbSize, pm, CSimpleStringWide(pWiaItemRootId)) );

    if (pidl)
    {
        //
        // Store the info for the pidl...
        //


        pidl->hdr.dwFlags = IMIDL_SCANNERITEM;

        //
        // stick the friendly name in the pidl...
        //

        ua_wcscpy( pidl->szFriendlyName, strFriendlyName );

        // add the full path name
        pidl->dwFullPathOffset = sizeof(SCANNERITEMIDLIST)+cbFriendlyName;
        wcscpy ( (LPWSTR)((LPBYTE)pidl + pidl->dwFullPathOffset), strFullName);
    }

    TraceLeave();

    return reinterpret_cast<LPITEMIDLIST>(pidl);

}

HRESULT
IMGetPropFromIDL (LPITEMIDLIST pidl, PROPID pid, PROPVARIANT &pv)
{
    HRESULT hr = E_FAIL;
    bool bRead = false;
    TraceEnter (TRACE_IDLIST, "IMGetPropFromIDL");
    CComPtr<IWiaItem> pDevice;

    hr = GetDeviceFromDeviceId (reinterpret_cast<_myidlheader*>(pidl)->szDeviceId,
                                IID_IWiaItem,
                                reinterpret_cast<LPVOID*>(&pDevice),
                                FALSE);
    if (SUCCEEDED(hr))
    {
        if (IsDeviceIDL(pidl))
        {
            bRead = PropStorageHelpers::GetProperty(pDevice, pid, pv);
        }
        else
        {
            CComPtr<IWiaItem> pItem;
            CComBSTR strName;
            IMGetFullPathNameFromIDL (pidl, &strName);
            hr = pDevice->FindItemByName (0,
                                          strName,
                                          &pItem);
            if (SUCCEEDED(hr))
            {
                bRead = PropStorageHelpers::GetProperty(pItem, pid, pv);
            }
        }
        hr = bRead ? S_OK : E_FAIL;
    }

    TraceLeaveResult (hr);
}
/*****************************************************************************

   IMGetCreateTimeFromIDL

   If it's a camera item idl, return the create time

 *****************************************************************************/

HRESULT
IMGetCreateTimeFromIDL( LPITEMIDLIST pidl, LPFILETIME pTime )
{
    HRESULT hr = S_OK;


    TraceEnter( TRACE_IDLIST, "IMGetCreateTimeFromIDL" );
    TraceAssert (IMIsOurIDL(pidl));
    ZeroMemory (pTime, sizeof(FILETIME));
    PROPVARIANT pv;

    hr = IMGetPropFromIDL (pidl, WIA_IPA_ITEM_TIME, pv);
    if (SUCCEEDED(hr))
    {
        if (pv.vt != VT_NULL && pv.vt != VT_EMPTY && pv.caub.pElems)
        {
            FILETIME ft;
            SystemTimeToFileTime( reinterpret_cast<SYSTEMTIME*>(pv.caub.pElems),
                                  &ft );
            LocalFileTimeToFileTime (&ft, pTime);
        }
        else
        {
            hr = E_FAIL;
        }
        PropVariantClear(&pv);
    }

    TraceLeaveResult(hr);
}


/*****************************************************************************

   IMGetImageSizeFromIDL

   If it's a camera item idl, return the size of the image

 *****************************************************************************/

HRESULT
IMGetImageSizeFromIDL( LPITEMIDLIST pidl, ULONG * pSize )
{
    HRESULT hr = E_INVALIDARG;

    TraceEnter( TRACE_IDLIST, "IMGetImageSizeFromIDL" );

    *pSize = 0;
    if (IsCameraItemIDL( pidl ))
    {
        PROPVARIANT pv;
        hr = IMGetPropFromIDL (pidl, WIA_IPA_ITEM_SIZE, pv);
        if (SUCCEEDED(hr))
        {
            *pSize = pv.ulVal;
            PropVariantClear(&pv);
        }
    }

    TraceLeaveResult(hr);
}



/*****************************************************************************

   IMGetImagePreferredFormatFromIDL

   If it's a camera item idl, return the image type
   Note: LPTSTR pExt  (if not NULL, is filled in w/ext ("jpg", etc.))

 *****************************************************************************/


HRESULT
IMGetImagePreferredFormatFromIDL( LPITEMIDLIST pidl,
                                  GUID * pPreferredFormat,
                                  LPTSTR pExt
                                 )
{
    HRESULT hr = E_INVALIDARG;
    
    TraceEnter( TRACE_IDLIST, "IMGetImagePreferredFormatFromIDL" );

    if (IsCameraItemIDL( pidl ))
    {
        PROPVARIANT pv;
        PropVariantInit(&pv);
        hr = IMGetPropFromIDL (pidl, WIA_IPA_PREFERRED_FORMAT, pv);

        if (SUCCEEDED(hr))
        {
            if (pPreferredFormat )
            {
                *pPreferredFormat = *(pv.puuid);
            }

            if (pExt)
            {
                *pExt = 0;
                CSimpleString strExt = CWiaFileFormat::GetExtension(*(pv.puuid));
                if (!strExt.Length())
                {
                    // go the slow way
                    CComPtr<IWiaItem> pItem;
                    if (SUCCEEDED(IMGetItemFromIDL(pidl, &pItem)))
                    {
                        strExt = CWiaFileFormat::GetExtension(*(pv.puuid),TYMED_FILE,pItem);
                    }
                }
                PathAddExtension(pExt, CSimpleString(TEXT(".")) + strExt );
            }
            PropVariantClear(&pv);
        }        
    }
    else
    {
        // default to bmp
        if (pPreferredFormat)
        {
            *pPreferredFormat = WiaImgFmt_BMP;
        }
        if (pExt)
        {
            lstrcpy (pExt, TEXT(".bmp"));
        }
    }

    TraceLeaveResult(hr);
}



/*****************************************************************************

   IMgetItemTypeFromIDL

   Return the ulType from the pidl header

 *****************************************************************************/

ULONG
IMGetItemTypeFromIDL ( LPITEMIDLIST pidl )
{
    ULONG uRet = 0;
    TraceEnter (TRACE_IDLIST, "IMGetItemTypeFromIDL");

    if (IMIsOurIDL(pidl))
    {
        uRet = reinterpret_cast<_myidlheader*>(pidl)->ulType;
    }
    TraceLeave();
    return uRet;
}



/*****************************************************************************

   IMGetDeviceTypeFromIDL

   If it's a device item idl, return the sti device type.

 *****************************************************************************/

DWORD
IMGetDeviceTypeFromIDL( LPITEMIDLIST pidl, bool bBrief )
{

    DWORD dwRet = StiDeviceTypeDefault;
    TraceEnter( TRACE_IDLIST, "IMGetDeviceTypeFromIDL" );

    if (IsSTIDeviceIDL(pidl))
    {
        dwRet = reinterpret_cast<LPSTIDEVICEIDLIST>(pidl)->dwDeviceType;
    }
    else if (IsDeviceIDL(pidl))
    {
        dwRet = reinterpret_cast<LPDEVICEIDLIST>(pidl)->dwDeviceType;
    }
    TraceLeave ();
    return bBrief ? GET_STIDEVICE_TYPE(dwRet) : dwRet;

}


/*****************************************************************************

   IMGetFullPathNameFromIDL

   If it's not a root item idl, return full item path

 *****************************************************************************/

HRESULT
IMGetFullPathNameFromIDL( LPITEMIDLIST pidl, BSTR * ppFullPath )
{


    HRESULT hr = E_INVALIDARG;
    TraceEnter( TRACE_IDLIST, "IMGetFullPathNameFromIDL" );


    *ppFullPath = NULL;
    if (!IsDeviceIDL( pidl ) && !IsSTIDeviceIDL(pidl)  && ppFullPath)
    {
        if (IsCameraItemIDL (pidl))
        {
            *ppFullPath = SysAllocString( (LPOLESTR)((LPBYTE)pidl + ((LPCAMERAITEMIDLIST)pidl)->dwFullPathOffset) );
        }
        else if (IsScannerItemIDL (pidl))
        {
            *ppFullPath = SysAllocString( (LPOLESTR)((LPBYTE)pidl + ((LPSCANNERITEMIDLIST)pidl)->dwFullPathOffset) );
        }
        if (!(*ppFullPath))
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = S_OK;
        }
    }

    TraceLeaveResult(hr);

}



/*****************************************************************************

   IMIsOurIDL

   Check if this pidl is one of ours

 *****************************************************************************/

BOOL
IMIsOurIDL( LPITEMIDLIST pidl )
{

    TraceEnter( TRACE_IDLIST, "IMIsOurIDL" );


    if ( pidl && ((((LPMYIDLHEADER)pidl)->cbSize >= sizeof(MYIDLHEADER)) &&
         (((LPMYIDLHEADER)pidl)->dwMagic == IMIDL_MAGIC)
        ))
    {
        TraceLeave();
        return TRUE;
    }

    TraceLeave();

    return FALSE;

}



/*****************************************************************************

   IMGetIconInfoFromIDL

   Check the pidl for the type of item and return the correct icon...
   NOTE: pIconPath is assumed to be MAX_PATH big

 *****************************************************************************/

HRESULT
IMGetIconInfoFromIDL( LPITEMIDLIST pidl,
                      LPTSTR pIconPath,
                      UINT cch,
                      INT * pIndex,
                      UINT *pwFlags
                     )
{
    HRESULT hr = S_OK;
    CSimpleStringWide strDeviceId;

    TraceEnter(TRACE_IDLIST, "IMGetIconInfoFromIDL");

    if (!pIconPath)
        ExitGracefully( hr, E_INVALIDARG, "pIconPath is invalid" );

    if (!pIndex)
        ExitGracefully( hr, E_INVALIDARG, "pIndex is invalid" );

    if (pwFlags)
    {
        *pwFlags = 0;
    }
    *pIconPath = 0;
    *pIndex = 0;
    if (IsDeviceIDL(pidl))
    {
        IMGetDeviceIdFromIDL(pidl, strDeviceId);
        lstrcpy(pIconPath, strDeviceId);
    }
    else
    {
        lstrcpy(pIconPath, c_szTHISDLL);
    }
    if (!IMIsOurIDL(pidl))
        ExitGracefully( hr, E_FAIL, "Not a Still Image Extension idlist" );

    if (IsDeviceIDL( pidl ) || IsSTIDeviceIDL(pidl))
    {
        switch( IMGetDeviceTypeFromIDL( pidl ) )
        {
        case StiDeviceTypeScanner:
            
            if (IsRemoteItemIDL(pidl))
            {                
                *pIndex = -IDI_REMOTESCAN;
            }
            else if (IsDeviceIDL(pidl))
            {                
                *pIndex = - IDI_SCANNER;
                if (pwFlags) *pwFlags = GIL_NOTFILENAME | GIL_DONTCACHE;
            }
            else
            {                
                *pIndex = - IDI_STIDEVICE;
            }

            break;

        case StiDeviceTypeDigitalCamera:
            if (IsRemoteItemIDL(pidl))
            {
                *pIndex = -IDI_REMOTECAM;
            }
            else if (IsDeviceIDL(pidl))
            {
                *pIndex = - IDI_CAMERA;
                if (pwFlags) *pwFlags = GIL_NOTFILENAME | GIL_DONTCACHE;
            }
            else
            {
                *pIndex = - IDI_STIDEVICE;
            }            
            break;

        case StiDeviceTypeStreamingVideo:
            *pIndex = - IDI_VIDEO_CAMERA;
            if (pwFlags) *pwFlags = GIL_NOTFILENAME | GIL_DONTCACHE;
            break;

        case StiDeviceTypeDefault:
            *pIndex = - IDI_UNKNOWN;
            break;
        }
    }

    else if (IsCameraItemIDL( pidl ))
    {
        if (((LPCAMERAITEMIDLIST)pidl)->hdr.dwFlags & IMIDL_CONTAINER)
        {
            *pIndex = - IDI_FOLDER;
        }
        else if (IMItemHasSound (pidl))
        {
            *pIndex = -IDI_AUDIO_IMAGE;
        }
        else if (WiaItemTypeAudio & IMGetItemTypeFromIDL (pidl))
        {
            *pIndex = - IDI_GENERIC_AUDIO;
        }
        else
        {
            *pIndex = - IDI_GENERIC_IMAGE;
        }
    }

    else if (IsAddDeviceIDL( pidl ))
    {        
        *pIndex = - IDI_ADDDEVICE;
    }


exit_gracefully:

    TraceLeaveResult(hr);

}



/*****************************************************************************

   IMGetNameFromIDL

   <Notes>

 *****************************************************************************/

HRESULT
IMGetNameFromIDL( LPITEMIDLIST pidl,
                  CSimpleStringWide &strName)
{
    HRESULT hr = S_OK;
    PCWSTR pWStrAligned;


    TraceEnter(TRACE_IDLIST, "IMGetNameFromIDL");


    strName = L"";

    if (IMIsOurIDL(pidl))
    {

        if (IsDeviceIDL( pidl ))
        {
            WSTR_ALIGNED_STACK_COPY( &pWStrAligned,
                                 reinterpret_cast<LPDEVICEIDLIST>(pidl)->szFriendlyName );
            strName = pWStrAligned;
        }
        else if (IsCameraItemIDL( pidl ))
        {
        WSTR_ALIGNED_STACK_COPY( &pWStrAligned,
                                     reinterpret_cast<LPCAMERAITEMIDLIST>(pidl)->szFriendlyName );
            strName = pWStrAligned;
        }
        else if (IsScannerItemIDL( pidl ))
        {
            WSTR_ALIGNED_STACK_COPY( &pWStrAligned,
                                 reinterpret_cast<LPSCANNERITEMIDLIST>(pidl)->szFriendlyName );
            strName = pWStrAligned;
        }
        else if (IsAddDeviceIDL( pidl ))
        {
            CSimpleString adddev( IDS_ADD_DEVICE, GLOBAL_HINSTANCE );
            strName = CSimpleStringConvert::WideString (adddev);
        }
        else if (IsSTIDeviceIDL(pidl))
        {
        WSTR_ALIGNED_STACK_COPY( &pWStrAligned,
                                     reinterpret_cast<LPSTIDEVICEIDLIST>(pidl)->szFriendlyName );
            strName = pWStrAligned;
        }
        else if (IsPropertyIDL(pidl))
        {
            LPPROPIDLIST pidlProp;
            pidlProp = reinterpret_cast<LPPROPIDLIST>(pidl);
            strName=reinterpret_cast<LPWSTR>(reinterpret_cast<LPBYTE>(pidl)+pidlProp->dwNameOffset);
        }
        else
        {
            hr = E_FAIL;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    TraceLeaveResult(hr);

}



/*****************************************************************************

   IMGetDeviceIdFromIDL

   <Notes>

 *****************************************************************************/

STDAPI_(HRESULT)
IMGetDeviceIdFromIDL( LPITEMIDLIST pidl,
                      CSimpleStringWide &strDeviceId
                     )
{
    HRESULT hr = E_INVALIDARG;


    TraceEnter(TRACE_IDLIST, "IMGetDeviceIdFromIDL");

    if (IMIsOurIDL(pidl) && !IsAddDeviceIDL(pidl))
    {
        strDeviceId = reinterpret_cast<_myidlheader*>(pidl)->szDeviceId;
        Trace(TEXT("Device id is %ls"), strDeviceId.String());
        hr = S_OK;
    }


    TraceLeaveResult(hr);
}



/*****************************************************************************

   IMGetParsingNameFromIDL

   <Notes>

 *****************************************************************************/

HRESULT
IMGetParsingNameFromIDL( LPITEMIDLIST pidl,
                         CSimpleStringWide &strName
                        )
{
    HRESULT hr = E_INVALIDARG;
    CSimpleStringWide strDeviceId;

    TraceEnter(TRACE_IDLIST, "IMGetParsingNameFromIDL");

    strName = L"";

    if (IMIsOurIDL(pidl))
    {
        if (IsDeviceIDL(pidl) || IsSTIDeviceIDL(pidl))
        {
            hr = IMGetDeviceIdFromIDL( pidl, strDeviceId );
            if (SUCCEEDED(hr))
            {
                strName = g_cszDevIdPrefix;
                strName.Concat (strDeviceId);
                strName.Concat (g_cszDevIdSuffix);

            }
        }
        else if (IsCameraItemIDL( pidl ))
        {
            CComBSTR strFullPath;
            IMGetFullPathNameFromIDL (pidl, &strFullPath);
            strName = strFullPath;
            hr = S_OK;
        }
        else if (IsAddDeviceIDL(pidl))
        {
            hr = IMGetNameFromIDL (pidl, strName);

        }
        else
        {
            Trace(TEXT("Scanner item or property IDL -- not supported!"));
        }
    }
    TraceLeaveResult(hr);
}



/*****************************************************************************

   STIDeviceIDLFromId

   Given an id, see if it matches an STI device

 *****************************************************************************/

HRESULT
STIDeviceIDLFromId (LPCWSTR szId, LPITEMIDLIST *ppidl, IMalloc *pm)
{
    HRESULT hr;

    PSTI psti;
    PSTI_DEVICE_INFORMATION psdi = NULL;

    TraceEnter (TRACE_IDLIST, "STIDeviceIDLFromId");
    if (!ppidl)
    {
        hr = E_INVALIDARG;
    }
    else
    {

        *ppidl = NULL;
        hr = StiCreateInstance (GLOBAL_HINSTANCE,
                                STI_VERSION,
                                &psti,
                                NULL);
    }
    if (SUCCEEDED(hr))
    {
        hr = psti->GetDeviceInfo (const_cast<LPWSTR>(szId), reinterpret_cast<LPVOID*>(&psdi));
        if (SUCCEEDED(hr))
        {
            *ppidl = IMCreateSTIDeviceIDL (psdi, pm);
            LocalFree (psdi);
            if (!*ppidl)
            {
                hr = E_OUTOFMEMORY;
            }
        }
        DoRelease (psti);
    }

    TraceLeaveResult (hr);
}



/******************************************************************************

    MakePidlFromItem

    Given a device ID and item path, construct the item's PIDL

******************************************************************************/

HRESULT
MakePidlFromItem (CSimpleStringWide &strDeviceId,
                  CSimpleStringWide &strPath,
                  LPITEMIDLIST *ppidl,
                  IMalloc *pm,
                  LPCWSTR szFolder,
                  LPWSTR pExt)
{
    HRESULT hr;
    CComPtr<IWiaItem> pRoot;
    LPITEMIDLIST pidl = NULL;


    TraceEnter (TRACE_IDLIST, "MakePidlFromItem");
    hr = GetDeviceFromDeviceId (strDeviceId, IID_IWiaItem, reinterpret_cast<LPVOID*>(&pRoot), FALSE);
    if (SUCCEEDED(hr))
    {
        WCHAR szPath[MAX_PATH];                
        CComPtr<IWiaItem> pItem;
        WORD wDeviceType;
        lstrcpynW(szPath, strPath.String(), ARRAYSIZE(szPath));
        PathRemoveExtension(szPath);
        GetDeviceTypeFromDevice (pRoot, &wDeviceType);
        hr = pRoot->FindItemByName (0, CComBSTR (szPath), &pItem);        
        if (S_OK != hr)
        {
            Trace(TEXT("FindItemByName failed for %ls"), strPath.String());
            //
            // Maybe it's not the full path name but just the plain file name
            if (szFolder)
            {
                hr = pRoot->FindItemByName(0, CComBSTR(szFolder), &pItem);
            }
            else
            {
                pItem = pRoot;
            }
            if (pItem)
            {
                Trace(TEXT("Looking for item by enumeration"));
                CComPtr<IEnumWiaItem> pEnum;
                if (SUCCEEDED(pItem->EnumChildItems(&pEnum)))
                {
                    BOOL bFound = FALSE;
                    CComPtr<IWiaItem> pChild;
                    CSimpleStringWide strName;
                    if (pExt && *pExt == L'.')
                    {
                        pExt++;
                    }
                    while (!bFound && S_OK == pEnum->Next(1, &pChild, NULL))
                    {
                        PropStorageHelpers::GetProperty(pChild, WIA_IPA_ITEM_NAME, strName);
                        if (!lstrcmpiW(strName.String(), szPath))
                        {
                            // we must also match default extension in this case
                            if (pExt && *pExt)
                            {
                                Trace(TEXT("Extension to match: %ls"), pExt);
                                GUID guidFmt;
                                PropStorageHelpers::GetProperty(pChild, WIA_IPA_PREFERRED_FORMAT, guidFmt);
                                CSimpleStringWide strExt = CWiaFileFormat::GetExtension(guidFmt,TYMED_FILE,pChild);
                                Trace(TEXT("Default extension: %ls"), strExt.String());
                                bFound = !lstrcmpiW(strExt.String(), pExt);
                            }
                            else
                            {
                                bFound = TRUE;                              
                            }
                            if (bFound)
                            {
                                pItem = pChild;
                                hr = S_OK;
                            }
                            else
                            {
                                pChild = NULL;
                            }
                        }                       
                    }
                }
            }
        }
        if (S_OK == hr && pItem)
        {       
            if ((wDeviceType == StiDeviceTypeDigitalCamera) ||
                 (wDeviceType == StiDeviceTypeStreamingVideo))
            {
                pidl = IMCreateCameraItemIDL (pItem, strDeviceId, pm);
            }
            else if (wDeviceType == StiDeviceTypeScanner)
            {
                pidl = IMCreateScannerItemIDL (pItem, pm);
            }
            else
            {
                Trace (TEXT("Unknown item type %x in MakePidlFromItem"));
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }
    *ppidl = pidl;
    TraceLeaveResult (hr);
}

/*****************************************************************************

   IMCreateIDLFromParsingName

   <Notes>

 *****************************************************************************/

HRESULT
IMCreateIDLFromParsingName( LPOLESTR pName,
                            LPITEMIDLIST * ppidl,
                            LPCWSTR pId,
                            IMalloc *pm,
                            LPCWSTR szFolder
                           )
{
    HRESULT                     hr = S_OK;
    CComPtr<IWiaPropertyStorage>   pDevProp;
    CComPtr<IWiaItem>           pWiaItemRoot;
    CComPtr<IWiaItem>           pItem;
    WCHAR                       szDeviceId[ MAX_PATH ];
    CSimpleBStr                 bstrFullPath;
    size_t                      uOffset = 0;
    bool                        bItemIdl = true;
    TraceEnter( TRACE_IDLIST, "IMCreateIDLFromParsingName" );


    TraceAssert (ppidl && pName);


    if (ppidl)
    {
        *ppidl = NULL;
    }

    if (!pId || !(*pId) ) // the first part of the name is the device id
    {
        uOffset = wcslen(g_cszDevIdPrefix);
        if (!wcsncmp(pName, g_cszDevIdPrefix, uOffset))
        {
            for (size_t i=0;*(pName+i+uOffset) != g_chDevIdSuffix;i++)
            {
                szDeviceId[i] = pName[i+uOffset];
            }
            szDeviceId[i] = L'\0';
            uOffset+=(i+1);
            if (pName[uOffset]==L'\\')
            {
                uOffset++; // skip leading '\'
            }
            //
            // Now, generate a pidl
            //
            Trace (TEXT("uOffset: %d, wcslen(pName): %d"), uOffset, wcslen(pName));
            if (uOffset == wcslen(pName))
            {
                Trace(TEXT("Generating pidl for device %ls"), szDeviceId);
                bItemIdl = false;
                //
                // We're just generating a device IDL
                //

                hr = GetDeviceFromDeviceId( szDeviceId, IID_IWiaPropertyStorage, (LPVOID *)&pDevProp , FALSE);
                if (FAILED(hr))
                {
                    // see if this is an STI device
                    hr = STIDeviceIDLFromId (szDeviceId, ppidl, pm);
                }
                else
                {
                    *ppidl = IMCreateDeviceIDL( pDevProp, pm );
                    if (!*ppidl)
                    {
                       hr = E_FAIL;
                    }
                }
            }
        }
        else
        {
            hr = E_INVALIDARG;
            Trace(TEXT("Unexpected parsing name %ls"), pName);
        }
    }
    else
    {
        wcsncpy (szDeviceId, pId, ARRAYSIZE(szDeviceId));
    }
    if (SUCCEEDED(hr) && bItemIdl)
    {
        //
        // Get the item in question
        // pName+uOffset should point to the item's full path name
        Trace(TEXT("Generating pidl for item %ls on device %ls"), pName+uOffset, szDeviceId);
        LPWSTR pExt = PathFindExtension(pName+uOffset);
        hr = MakePidlFromItem (CSimpleStringWide(szDeviceId), CSimpleStringWide(pName+uOffset), ppidl, pm, szFolder, pExt);
    }

    TraceLeaveResult( hr );

}





/*****************************************************************************

   IMGetItemFromIDL

   Creates an IWiaItem pointer for a pidl

 *****************************************************************************/

HRESULT
IMGetItemFromIDL (LPITEMIDLIST pidl, IWiaItem **ppItem, BOOL bShowProgress)
{
    CSimpleStringWide   strDeviceId;
    CComPtr<IWiaItem>   pDevice = NULL;
    CComBSTR            bstrFullPath;
    HRESULT             hr = S_OK;

    TraceEnter (TRACE_IDLIST, "IMGetItemFromIDL");

    IMGetDeviceIdFromIDL (pidl, strDeviceId);
    if (IsSTIDeviceIDL(pidl))
    {
        hr = E_INVALIDARG;
    }
    else
    {
        hr = GetDeviceFromDeviceId (strDeviceId, IID_IWiaItem, reinterpret_cast<LPVOID*>(&pDevice), bShowProgress);
    }
    if (SUCCEEDED(hr))
    {
        if (IsDeviceIDL (pidl))
        {
            pDevice->QueryInterface (IID_IWiaItem, reinterpret_cast<LPVOID*>(ppItem));
        }
        else
        {
            IMGetFullPathNameFromIDL (pidl, &bstrFullPath);
            Trace(TEXT("Full path name of item: %ls"), bstrFullPath.m_str);
            hr = pDevice->FindItemByName (0, bstrFullPath, ppItem);
            Trace(TEXT("FindItemByName returned %x"), hr);
            if (S_FALSE == hr)
            {
                hr  = E_FAIL;
            }           
        }
    }

    TraceLeaveResult (hr);
}






/*****************************************************************************

   IMCreateSTIDeviceIDL

   Make an IDL for legacy STI devices

 *****************************************************************************/

LPITEMIDLIST
IMCreateSTIDeviceIDL (PSTI_DEVICE_INFORMATION psdi, IMalloc *pm)
{
    LPSTIDEVICEIDLIST pidl = NULL;
    DWORD cbSize , cbFriendlyName;

    TraceEnter (TRACE_IDLIST, "IMCreateSTIDeviceIDL");
    if (psdi)
    {

        cbFriendlyName = wcslen (psdi->pszLocalName)*sizeof(WCHAR);
        cbSize = sizeof(STIDEVICEIDLIST) + cbFriendlyName;

        pidl = static_cast<LPSTIDEVICEIDLIST>(AllocPidl(cbSize, pm, CSimpleStringWide(psdi->szDeviceInternalName)));
        if (pidl)
        {

            pidl->hdr.dwFlags = IMIDL_STIDEVICEIDL;
            pidl->hdr.ulType = 0;
            pidl->dwDeviceType = psdi->DeviceType;
            ua_wcscpy (pidl->szFriendlyName, psdi->pszLocalName);
        }
    }
    TraceLeave ();
    return reinterpret_cast<LPITEMIDLIST>(pidl);
}

/*****************************************************************************

   IMCreateSTIDeviceIDL

   Make an IDL for legacy STI devices using a WIA interface. allegedly faster than STI

 *****************************************************************************/

LPITEMIDLIST 
IMCreateSTIDeviceIDL (const CSimpleStringWide &strDeviceId, IWiaPropertyStorage *ppstg, IMalloc *pm)
{
    LPSTIDEVICEIDLIST pidl = NULL;
    DWORD cbSize , cbFriendlyName;
    CSimpleStringWide strName;
    PropStorageHelpers::GetProperty(ppstg, WIA_DIP_DEV_NAME, strName);
    cbSize = sizeof(STIDEVICEIDLIST) + (strName.Length() * sizeof(WCHAR));
    LONG lType;
    TraceEnter (TRACE_IDLIST, "IMCreateSTIDeviceIDL (WIA)");
    
    pidl = static_cast<LPSTIDEVICEIDLIST>(AllocPidl(cbSize, pm, strDeviceId));
    if (pidl)
    {
        pidl->hdr.dwFlags = IMIDL_STIDEVICEIDL;
        pidl->hdr.ulType = 0;
        PropStorageHelpers::GetProperty(ppstg, WIA_DIP_DEV_TYPE, lType);
        pidl->dwDeviceType = static_cast<DWORD>(lType);
        ua_wcscpy(pidl->szFriendlyName, strName.String());
    }
    TraceLeaveValue(reinterpret_cast<LPITEMIDLIST>(pidl));
}


/******************************************************************************

    IMItemHasSound

    Determines if the given item has a sound annotation property

******************************************************************************/

BOOL
IMItemHasSound (LPITEMIDLIST pidl)
{
    BOOL bRet = FALSE;
    TraceEnter (TRACE_IDLIST, "IMItemHasSound");
    if (IsCameraItemIDL (pidl))
    {
        bRet = reinterpret_cast<_cameraitemidlist*>(pidl)->bHasAudioProperty;
    }
    TraceLeave ();
    return bRet;
}



/******************************************************************************

    IMCreatePropertyIDL

    Create an idlist for the given WIA PROPID for an item. Used for dragging
    and dropping a property value as a separate file, audio being the most
    obvious.

******************************************************************************/

LPITEMIDLIST
IMCreatePropertyIDL (LPITEMIDLIST pidlItem, PROPID propid, IMalloc *pm)
{

    TraceEnter (TRACE_IDLIST, "IMCreatePropertyIDL");
    size_t cbSize;
    size_t cbFullPath = 0;
    size_t cbName;
    CSimpleStringWide strName;
    CSimpleStringWide  strDeviceId;
    CComBSTR strFullName = static_cast<BSTR>(NULL);
    LPPROPIDLIST pidlProp = NULL;

    IMGetDeviceIdFromIDL (pidlItem, strDeviceId);

    if (!IsDeviceIDL(pidlItem) && !IsSTIDeviceIDL(pidlItem))
    {
        if (SUCCEEDED(IMGetFullPathNameFromIDL (pidlItem, &strFullName)))
        {
            cbFullPath = wcslen(strFullName)*sizeof(WCHAR);
            IMGetNameFromIDL (pidlItem, strName);
            cbName = (strName.Length()+1)*sizeof(WCHAR);
            cbSize = sizeof(PROPIDLIST)+cbFullPath+cbName;
            pidlProp = static_cast<LPPROPIDLIST>(AllocPidl(cbSize, pm, strDeviceId));
        }
    }
    if (pidlProp)
    {
        pidlProp->hdr.dwFlags = IMIDL_PROPERTY;
        pidlProp->hdr.ulType = 0;
        pidlProp->propid  = propid;
        ua_wcscpy (pidlProp->szFullPath, strFullName);
        pidlProp->dwNameOffset = sizeof(PROPIDLIST)+cbFullPath;
        wcscpy (reinterpret_cast<LPWSTR>(reinterpret_cast<LPBYTE>(pidlProp)+pidlProp->dwNameOffset), strName);
    }
    TraceLeave ();
    return reinterpret_cast<LPITEMIDLIST>(pidlProp);
}


/******************************************************************************

    IMGetAudioFormat

    Return the proper extension for the item's audio annotation.
    Currently WIA only supports .wav

******************************************************************************/

BOOL
IMGetAudioFormat (LPITEMIDLIST pidl, CSimpleStringWide &strExt)
{

    strExt = L".wav";
    return TRUE;
}

/******************************************************************************

    IMGetPropertyFromIDL

    Retrieve the property for a PROPIDLIST and return it as an HGLOBAL

******************************************************************************/

HRESULT
IMGetPropertyFromIDL (LPITEMIDLIST pidl, HGLOBAL *phGlobal)
{
    HRESULT hr;
    LPPROPIDLIST pProp = reinterpret_cast<LPPROPIDLIST>(pidl);
    PCWSTR pWStrAligned;
    CSimpleStringWide strDeviceId;
    CComPtr<IWiaItem> pDevice;
    CComPtr<IWiaItem> pItem;

    TraceEnter (TRACE_IDLIST, "IMGetPropertyFromIDL");
    TraceAssert (IsPropertyIDL (pidl));

    IMGetDeviceIdFromIDL (pidl, strDeviceId);
    hr = GetDeviceFromDeviceId(strDeviceId,
                               IID_IWiaItem,
                               reinterpret_cast<LPVOID*>(&pDevice),
                               FALSE);

    if (SUCCEEDED(hr))
    {
        WSTR_ALIGNED_STACK_COPY( &pWStrAligned, pProp->szFullPath );
        hr = pDevice->FindItemByName (0, CComBSTR( pWStrAligned ), &pItem);
        if (SUCCEEDED(hr))
        {
            PROPVARIANT pv;

            if (PropStorageHelpers::GetProperty(pItem, pProp->propid, pv))
            {
                *phGlobal = GlobalAlloc (GHND, pv.caub.cElems);
                if (*phGlobal)
                {
                    LPVOID pData = GlobalLock (*phGlobal);
                    CopyMemory (pData, pv.caub.pElems, pv.caub.cElems);
                    GlobalUnlock (*phGlobal);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
                PropVariantClear (&pv);
            }
            else
            {
                hr = E_FAIL;
            }
        }

    }
    TraceLeaveResult (hr);
}

/******************************************************************************

    IMGetAccessFromIDL

    Determine the access rights for the given item.

*******************************************************************************/

LONG
IMGetAccessFromIDL (LPITEMIDLIST pidl)
{
    LONG lRet = WIA_ITEM_RD;
    TraceEnter (TRACE_IDLIST, "IMGetAccessFromIDL");

    if (IsCameraItemIDL(pidl))
    {
        PROPVARIANT pv;
        pv.ulVal = 0;
        if (SUCCEEDED(IMGetPropFromIDL (pidl, WIA_IPA_ACCESS_RIGHTS, pv)))
        {
            lRet = static_cast<LONG>(pv.ulVal);
        }
    }
    else if (!IsPropertyIDL(pidl))
    {
        lRet = 0;
    }
    TraceLeave();
    return lRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\src\icon.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       icon.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        11/1/97
 *
 *  DESCRIPTION: Implements our IExtractIcon interface
 *
 *****************************************************************************/

#include "precomp.hxx"
#include "uiexthlp.h"
#pragma hdrstop


/*****************************************************************************

   CImageExtractIcon::CImageExtractIcon,::~CImageExtractIcon

   Constructor / Desctructor for class

 *****************************************************************************/

CImageExtractIcon::CImageExtractIcon( LPITEMIDLIST pidl )
{
    if (pidl)
    {
        m_pidl = ILClone( pidl );
    }
    else
    {
        m_pidl = NULL;
    }


}

CImageExtractIcon::~CImageExtractIcon()
{
    DoILFree( m_pidl );
}



/*****************************************************************************

   CImageExtractIcon::IUnknown stuff

   AddRef, Release, etc. -- impl via our common class

 *****************************************************************************/

#undef CLASS_NAME
#define CLASS_NAME CImageExtractIcon
#include "unknown.inc"


/*****************************************************************************

   CImageExtractIcon::QI wrapper

   We only support IUnknown & IExtractIcon

 *****************************************************************************/

STDMETHODIMP CImageExtractIcon::QueryInterface(REFIID riid, LPVOID* ppvObject)
{
    INTERFACES iface[] =
    {
        &IID_IExtractIcon, (LPEXTRACTICON)this,
    };

    return HandleQueryInterface(riid, ppvObject, iface, ARRAYSIZE(iface));
}


/*****************************************************************************

   CImageExtractIcon::GetIconLocation [IExtractIcon]

   Returns the file name that holds the icon
   resource for this item.

 *****************************************************************************/

STDMETHODIMP
CImageExtractIcon::GetIconLocation( UINT uFlags,
                                    LPTSTR szIconFile,
                                    UINT cchMax,
                                    int* pIndex,
                                    UINT* pwFlags
                                   )
{
    HRESULT hr = E_NOTIMPL;

    TraceEnter(TRACE_ICON, "CImageExtractIcon::GetIconLocation");

    if (!m_pidl)
        ExitGracefully( hr, E_FAIL, "m_pidl is not defined!" );


    hr = IMGetIconInfoFromIDL( m_pidl, szIconFile, cchMax, pIndex, pwFlags );

exit_gracefully:

    TraceLeaveResult(hr);
}


/*****************************************************************************

   CImageExtractIcon::Extract [IExtractIcon]

   Actually returns an icon for the item.

 *****************************************************************************/

STDMETHODIMP
CImageExtractIcon::Extract( LPCTSTR pszIconFile,
                            UINT nIconIndex,
                            HICON* pLargeIcon,
                            HICON* pSmallIcon,
                            UINT nIconSize
                           )
{
    HRESULT hr = S_FALSE; // let the shell do it

    TraceEnter(TRACE_ICON, "CImageExtractIcon::Extract");
    if (IsDeviceIDL(m_pidl))
    {
        CSimpleStringWide strDeviceId;
        CComPtr<IWiaPropertyStorage> pps;
        CSimpleStringWide strUIClsid;
        IMGetDeviceIdFromIDL(m_pidl, strDeviceId);
        //
        // if this really hurts performance we need to modify our PIDL to indicate whether the
        // given device has a UI extension so we can skip the device enum in the general case
        //
        if (SUCCEEDED(GetDeviceFromDeviceId(strDeviceId, IID_IWiaPropertyStorage, reinterpret_cast<void**>(&pps), FALSE)))
        {
            PropStorageHelpers::GetProperty (pps, WIA_DIP_UI_CLSID, strUIClsid);
        }
        else
        {
            strUIClsid = strDeviceId; // something we know will fall back to the default
        }
        hr = WiaUiExtensionHelper::GetDeviceIcons(CComBSTR(strUIClsid), 
                                                  IMGetDeviceTypeFromIDL(m_pidl, false),
                                                  pSmallIcon, pLargeIcon, nIconSize);        
    }
    TraceLeaveResult(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\src\image.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1997 - 1999
 *
 *  TITLE:       image.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        11/1/97
 *
 *  DESCRIPTION: CExtractImage class which implement IExtractImage interface
 *               for thumbnail view.
 *
 *****************************************************************************/

#include "precomp.hxx"
#pragma hdrstop



/*****************************************************************************

   CExtractImage constructor / desctructor


 *****************************************************************************/

CExtractImage::CExtractImage( LPITEMIDLIST pidl )
  : m_dwRecClrDepth(0)

{
    m_rgSize.cx     = 0;
    m_rgSize.cy     = 0;

    m_pidl          = ILClone( pidl );
}

CExtractImage::~CExtractImage()
{
    DoILFree( m_pidl );


}


/*****************************************************************************

   CExtractImage::IUnknown stuff

   Use our common implementation to handle IUnknown methods

 *****************************************************************************/

#undef CLASS_NAME
#define CLASS_NAME CExtractImage
#include "unknown.inc"


/*****************************************************************************

   CExtractImage::QI Wrapper

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CExtractImage::QueryInterface(REFIID riid, LPVOID* ppvObject)
{

    TraceEnter( TRACE_QI, "CExtractImage::QueryInterface" );
    TraceGUID("Interface requested", riid);

    HRESULT hr;

    INTERFACES iface[] =
    {
        &IID_IExtractImage,  (IExtractImage  *)this,
        &IID_IExtractImage2, (IExtractImage2 *)this,
    };

    hr = HandleQueryInterface(riid, ppvObject, iface, ARRAYSIZE(iface));

    TraceLeaveResult(hr);
}



/*****************************************************************************

   CExtractImage::GetLocation [IExtractImage]

   Return a file location for the thumbnail, also returns flags so that
   image extraction is asynchronous.

 *****************************************************************************/

STDMETHODIMP
CExtractImage::GetLocation( LPWSTR pszPathBuffer,
                            DWORD cch,
                            DWORD * pdwPriority,
                            const SIZE * prgSize,
                            DWORD dwRecClrDepth,
                            DWORD *pdwFlags
                           )
{
    HRESULT hr = NOERROR;

    TraceEnter( TRACE_EXTRACT, "CExtractImage::GetLocation" );
    CComBSTR strName;


    //
    // Check incoming args...
    //

    if ( !pdwFlags || !pszPathBuffer || !prgSize || !cch  )
        ExitGracefully( hr, E_INVALIDARG, "bad incoming arguments" );

    m_rgSize = *prgSize;
    m_dwRecClrDepth = dwRecClrDepth;

    //
    // Only need to do this for items, not containers...
    //

    if (IsContainerIDL( m_pidl ))
        ExitGracefully( hr, E_FAIL, "Only do this for non-containers" );



    hr = IMGetFullPathNameFromIDL (m_pidl, &strName);
    wcsncpy (pszPathBuffer, strName, cch-1);
    pszPathBuffer[cch-1] = L'\0';
    *pdwFlags = IEIFLAG_ASYNC;
    hr = E_PENDING;
exit_gracefully:

    TraceLeaveResult( hr );
}


VOID
DrawSoundIcon(HDC hdc, HBITMAP hbmpSource)
{
    HDC hdcMem = CreateCompatibleDC(hdc);
    if (hdcMem)
    {
        SetBrushOrgEx(hdcMem, 0, 0, NULL);
        HBITMAP hOld = reinterpret_cast<HBITMAP>(SelectObject(hdcMem, hbmpSource));
        HICON hIcon = LoadIcon(GLOBAL_HINSTANCE, MAKEINTRESOURCE(IDI_GENERIC_AUDIO));
        if (hIcon)
        {
            BITMAP bm = {0};
            int iWidth = GetSystemMetrics(SM_CXSMICON);
            int iHeight= GetSystemMetrics(SM_CYSMICON);
            GetObject(hbmpSource, sizeof(bm), &bm);
            DrawIconEx(hdcMem,
                       bm.bmWidth-iWidth,
                       bm.bmHeight-iHeight,
                       hIcon,
                       iWidth, iHeight, 0,
                       NULL, DI_NORMAL);
            DestroyIcon(hIcon);
        }
        SelectObject(hdcMem, hOld);
        DeleteDC(hdcMem);
    }
}
/*****************************************************************************

   CExtractImage::Extract [IExtractImage]

   Returns bitmap to be used as the thumbnail for the item this
   object represents.

 *****************************************************************************/

STDMETHODIMP
CExtractImage::Extract( HBITMAP * phBmpThumbnail )
{

    HRESULT             hr;
    BITMAPINFO          bmi;
    PBYTE               pBitmap     = NULL;
    HDC                 hdc         = NULL;
    HWND                hwnd        = NULL;
    HBITMAP             hdib        = NULL;
    CSimpleStringWide   strDeviceId;
    CComPtr<IWiaItem>   pWiaItemRoot;
    CComPtr<IWiaItem>   pItem;
    PROPSPEC            PropSpec[3];
    PROPVARIANT         PropVar[3];
    CComBSTR            bstrFullPath;
    CComPtr<IWiaPropertyStorage> pps;


    TraceEnter( TRACE_EXTRACT, "CExtractImage::Extract" );

    //
    // Check params...
    //

    if (!phBmpThumbnail)
        ExitGracefully( hr, E_INVALIDARG, "phBmpThumbnail is NULL!" );

    *phBmpThumbnail = NULL;
    memset(&PropVar,0,sizeof(PropVar));

    //
    // Is this item a container?  If so, no image to extract!!!
    //

    if (IsContainerIDL( m_pidl ))
    {
        ExitGracefully( hr, E_FAIL, "m_pidl is a container" );
    }

    //
    // Get the DeviceId...
    //

    hr = IMGetDeviceIdFromIDL( m_pidl, strDeviceId );
    FailGracefully( hr, "couldn't get DeviceId string!" );

    //
    // Create the device...
    //

    hr = GetDeviceFromDeviceId( strDeviceId, IID_IWiaItem, (LPVOID *)&pWiaItemRoot, FALSE );
    FailGracefully( hr, "couldn't get Camera device from DeviceId string..." );

    //
    // Get actual item in question...
    //

    hr = IMGetFullPathNameFromIDL( m_pidl, &bstrFullPath );
    FailGracefully( hr, "couldn't get FullPathName from pidl" );

    hr = pWiaItemRoot->FindItemByName( 0, bstrFullPath, &pItem );
    FailGracefully( hr, "couldn't find item by name" );
    if (hr !=S_OK)
    {
        Trace (TEXT("FindItemByName returned S_FALSE for item %ls"), bstrFullPath);
        goto exit_gracefully;
    }
    //
    // Get the thumbnail property...
    //

    hr = pItem->QueryInterface( IID_IWiaPropertyStorage,
                                (void **)&pps
                               );
    FailGracefully( hr, "couldn't get IMAGE_INFORMATION property object" );

    //
    // Read MAGE_INFORMATION and IMAGE_THUMBNAIL Properties.
    // init propspec and propvar for call to ReadMultiple
    //

    PropSpec[0].ulKind = PRSPEC_PROPID;
    PropSpec[0].propid = WIA_IPC_THUMB_WIDTH;

    PropSpec[1].ulKind = PRSPEC_PROPID;
    PropSpec[1].propid = WIA_IPC_THUMB_HEIGHT;

    PropSpec[2].ulKind = PRSPEC_PROPID;
    PropSpec[2].propid = WIA_IPC_THUMBNAIL;

    hr = pps->ReadMultiple(sizeof(PropSpec) / sizeof(PROPSPEC),
                           PropSpec,
                           PropVar);

    FailGracefully( hr, "couldn't get current value of IMAGE_PROPERTY" );

    //
    // Convert thumbnail to bitmap
    //

    bmi.bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth           = PropVar[0].ulVal;
    bmi.bmiHeader.biHeight          = PropVar[1].ulVal;
    bmi.bmiHeader.biPlanes          = 1;
    bmi.bmiHeader.biBitCount        = 24;
    bmi.bmiHeader.biCompression     = BI_RGB;
    bmi.bmiHeader.biSizeImage       = 0;
    bmi.bmiHeader.biXPelsPerMeter   = 0;
    bmi.bmiHeader.biYPelsPerMeter   = 0;
    bmi.bmiHeader.biClrUsed         = 0;
    bmi.bmiHeader.biClrImportant    = 0;

    hwnd   = GetDesktopWindow();
    hdc    = GetDC( hwnd );
    hdib   = CreateDIBSection( hdc, &bmi, DIB_RGB_COLORS, (LPVOID *)&pBitmap, NULL, 0 );
    if (!hdib)
        ExitGracefully( hr, E_OUTOFMEMORY, "couldn't create hdib!" );

    //
    // Transfer thumbnail bits to bitmap bits
    //

    CopyMemory( pBitmap, PropVar[2].caub.pElems, PropVar[2].caub.cElems );

    //
    // Scale bitmap as necessary
    //

    if ( m_rgSize.cx == (INT)PropVar[0].ulVal && m_rgSize.cy == (INT)PropVar[1].ulVal )
    {
        *phBmpThumbnail = hdib;
    }
    else
    {
        hr = ScaleImage( hdc, hdib, *phBmpThumbnail, m_rgSize );
        DeleteObject( hdib );
        FailGracefully( hr, "ScaleImage failed" );
        //
        // The shell no longer overlays the item's icon on the thumbnail.
        // Therefore we have to draw the icon on ourself.
        //
        if (IMItemHasSound(m_pidl))
        {
            DrawSoundIcon(hdc, *phBmpThumbnail);
        }
    }

exit_gracefully:

    FreePropVariantArray( sizeof(PropVar)/sizeof(PROPVARIANT),PropVar );


    if (hdc)
    {
        ReleaseDC( NULL, hdc );
        hdc = NULL;
    }



    TraceLeaveResult( hr );
}



/*****************************************************************************

   CExtractImage::GetDateStamp [IExtractImage2]

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CExtractImage::GetDateStamp( FILETIME * pDateStamp )
{
    HRESULT          hr                = NOERROR;

    TraceEnter( TRACE_EXTRACT, "CExtractImage::GetDateStamp" );

    if (!pDateStamp)
        ExitGracefully( hr, E_INVALIDARG, "pDateStamp was NULL" );

    //
    // Is this item a container?  If so, don't need to give a date/time stamp
    //

    if (IsContainerIDL( m_pidl ))
        ExitGracefully( hr, E_FAIL, "m_pidl is a container" );

    hr = IMGetCreateTimeFromIDL( m_pidl, pDateStamp );

exit_gracefully:

    TraceLeaveResult( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\src\image.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998 - 1999
 *
 *  TITLE:       image.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu/DavidShi
 *
 *  DATE:        6/1/98
 *
 *  DESCRIPTION: CExtractImage class definition
 *
 *****************************************************************************/

#ifndef __image_h
#define __image_h

class CExtractImage : public IExtractImage2, CUnknown
{

    private:

        LPITEMIDLIST m_pidl;
        SIZE         m_rgSize;
        DWORD        m_dwRecClrDepth;


    public:
        CExtractImage( LPITEMIDLIST pidl );
        ~CExtractImage();


        // *** IUnknown methods ***
        STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID * ppvObj);
        STDMETHOD_(ULONG,AddRef) (THIS);
        STDMETHOD_(ULONG,Release) (THIS);

        // *** IExtractImage methods ***
        STDMETHOD (GetLocation) ( THIS_ LPWSTR pszPathBuffer,
                                  DWORD cch,
                                  DWORD * pdwPriority,
                                  const SIZE * prgSize,
                                  DWORD dwRecClrDepth,
                                  DWORD *pdwFlags );

        STDMETHOD (Extract)( THIS_ HBITMAP * phBmpThumbnail);

        // *** IExtractImage2 methods ***
        STDMETHOD (GetDateStamp)( FILETIME * pDateStamp );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\src\moniker.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       moniker.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        8/10/98
 *
 *  DESCRIPTION: Bolier plate (minimal implementation) of IMoniker.  It is
 *               used primarily with ComDlg32 file open/save dialogs.
 *
 *****************************************************************************/

#include "precomp.hxx"
#pragma hdrstop


/*****************************************************************************

   CImageFolder::BindToObject [IMoniker]

   Bind to the given moniker. (NOT IMPL)

 *****************************************************************************/

STDMETHODIMP
CImageFolder::BindToObject(
        IBindCtx *pbc,
        IMoniker *pmkToLeft,
        REFIID riidResult,
        void **ppvResult
    )
{
    HRESULT hr = E_NOTIMPL;

    TraceEnter( TRACE_MONIKER, "CImageFolder[IMoniker]::BindToObject" );

    TraceLeaveResult(hr);
}


/*****************************************************************************

   CImageFolder::BindToStorage [IMoniker]

   Bind to the given storage.

 *****************************************************************************/

STDMETHODIMP
CImageFolder::BindToStorage(
        IBindCtx *pbc,
        IMoniker *pmkToLeft,
        REFIID riid,
        void **ppvObj
    )
{
    HRESULT hr = E_NOINTERFACE;
    CImageStream *pStream = NULL;
    TraceEnter( TRACE_MONIKER, "CImageFolder[IMoniker]::BindToStorage" );

    //
    // return the correct interface for the item...
    //

    if (pmkToLeft)
    {
        ExitGracefully( hr, E_INVALIDARG, "pmkToLeft was non-null" );
    }

    if ( IsEqualIID(riid, IID_IStream) || IsEqualIID(riid, IID_ISequentialStream) )
    {
        //
        // Create a new stream object...
        //

        pStream = new CImageStream( m_pidlFull, m_pidl );

        if ( !pStream )
            ExitGracefully(hr, E_OUTOFMEMORY, "Failed to create CImageStream");

        //
        // Get the requested interface on the new object and hand it back...
        //

        hr = pStream->QueryInterface(riid, ppvObj);
    }

exit_gracefully:
    DoRelease (pStream);
    TraceLeaveResult(hr);
}


/*****************************************************************************

   CImageFolder::Reduce [IMoniker]

   Reduce the given moniker.  (NOT IMPL)

 *****************************************************************************/

STDMETHODIMP
CImageFolder::Reduce(
        IBindCtx *pbc,
        DWORD dwReduceHowFar,
        IMoniker **ppmkToLeft,
        IMoniker **ppmkReduced
    )
{
    HRESULT hr = E_NOTIMPL;

    TraceEnter( TRACE_MONIKER, "CImageFolder[IMoniker]::Reduce" );

    TraceLeaveResult(hr);
}


/*****************************************************************************

   CImageFolder::ComposeWith [IMoniker]

   Combine the two monikers provided.  (NOT IMPL)

 *****************************************************************************/

STDMETHODIMP
CImageFolder::ComposeWith(
        IMoniker *pmkRight,
        BOOL fOnlyIfNotGeneric,
        IMoniker **ppmkComposite
    )
{
    HRESULT hr = E_NOTIMPL;

    TraceEnter( TRACE_MONIKER, "CImageFolder[IMoniker]::ComposeWith" );

    TraceLeaveResult(hr);
}



/*****************************************************************************

   CImageFolder::Enum [IMoniker]

   Return an enumerator which gives back monikers
   for the items in the folder.  (NOT_IMPL)

 *****************************************************************************/

STDMETHODIMP
CImageFolder::Enum(
        BOOL fForward,
        IEnumMoniker **ppenumMoniker
    )
{
    HRESULT hr = E_NOTIMPL;

    TraceEnter( TRACE_MONIKER, "CImageFolder[IMoniker]::Enum" );

    TraceLeaveResult(hr);
}


/*****************************************************************************

   CImageFolder::IsEqual [IMoniker]

   Compare two monikers.  (NOT IMPL)

 *****************************************************************************/

STDMETHODIMP
CImageFolder::IsEqual(IMoniker *pmkOtherMoniker)
{
    HRESULT hr = E_NOTIMPL;

    TraceEnter( TRACE_MONIKER, "CImageFolder[IMoniker]::IsEqual" );

    TraceLeaveResult(hr);
}


/*****************************************************************************

   CImageFolder::Hash [IMoniker]

   (NOT IMPL)

 *****************************************************************************/

STDMETHODIMP
CImageFolder::Hash(DWORD *pdwHash)
{
    HRESULT hr = E_NOTIMPL;

    TraceEnter( TRACE_MONIKER, "CImageFolder[IMoniker]::Hash" );

    TraceLeaveResult(hr);
}



/*****************************************************************************

   CImageFolder::IsRunning [IMoniker]

   (NOT IMPL)

 *****************************************************************************/

STDMETHODIMP
CImageFolder::IsRunning(
        IBindCtx *pbc,
        IMoniker *pmkToLeft,
        IMoniker *pmkNewlyRunning
    )
{
    HRESULT hr = E_NOTIMPL;

    TraceEnter( TRACE_MONIKER, "CImageFolder[IMoniker]::IsRunning" );

    TraceLeaveResult(hr);
}



/*****************************************************************************

   CImageFolder::GetTimeOfLastChange [IMoniker]

   (NOT IMPL)

 *****************************************************************************/

STDMETHODIMP
CImageFolder::GetTimeOfLastChange(
        IBindCtx *pbc,
        IMoniker *pmkToLeft,
        FILETIME *pFileTime
    )
{
    HRESULT hr = E_NOTIMPL;

    TraceEnter( TRACE_MONIKER, "CImageFolder[IMoniker]::GetTimeOfLastChange" );

    TraceLeaveResult(hr);
}


/*****************************************************************************

   CImageFolder::Inverse [IMoniker]

   (NOT IMPL YET)

 *****************************************************************************/

STDMETHODIMP
CImageFolder::Inverse(IMoniker **ppmk)
{
    HRESULT hr = E_NOTIMPL;

    TraceEnter( TRACE_MONIKER, "CImageFolder[IMoniker]::Inverse" );

    TraceLeaveResult(hr);
}



/*****************************************************************************

   CImageFolder::CommonPrefixWith [IMoniker]

   (NOT IMPL YET)

 *****************************************************************************/

STDMETHODIMP
CImageFolder::CommonPrefixWith(
        IMoniker *pmkOther,
        IMoniker **ppmkPrefix
    )
{
    HRESULT hr = E_NOTIMPL;

    TraceEnter( TRACE_MONIKER, "CImageFolder[IMoniker]::CommonPrefixWith" );

    TraceLeaveResult(hr);
}



/*****************************************************************************

   CImageFolder::RelativePathTo [IMoniker]

   (NOT IMPL)

 *****************************************************************************/

STDMETHODIMP
CImageFolder::RelativePathTo(
        IMoniker *pmkOther,
        IMoniker **ppmkRelPath
    )
{
    HRESULT hr = E_NOTIMPL;

    TraceEnter( TRACE_MONIKER, "CImageFolder[IMoniker]::RelativePathTo" );

    TraceLeaveResult(hr);
}



/*****************************************************************************

   CImageFolder::GetDisplayName [IMoniker]

   (NOT IMPL)

 *****************************************************************************/

STDMETHODIMP
CImageFolder::GetDisplayName(
        IBindCtx *pbc,
        IMoniker *pmkToLeft,
        LPOLESTR *ppszDisplayName
    )
{
    HRESULT hr = E_FAIL;
    CSimpleStringWide strName(L"");

    TraceEnter( TRACE_MONIKER, "CImageFolder[IMoniker]::GetDisplayName" );

    //
    // Check for bad args
    //

    if (!ppszDisplayName)
        ExitGracefully( hr, E_INVALIDARG, "ppszDisplayName was NULL!" );

    if (pmkToLeft)
        ExitGracefully( hr, E_INVALIDARG, "call with a left moniker, we don't support that!" );

    //
    // Generate the normal infolder name for this item
    //


    if (m_pidl)
    {
        hr = IMGetNameFromIDL( (LPITEMIDLIST)m_pidl, strName );
        FailGracefully( hr, "Couldn't get display name for IDL" );

        if (IsCameraItemIDL( (LPITEMIDLIST)m_pidl ) && (!IsContainerIDL((LPITEMIDLIST)m_pidl)))
        {
            TCHAR szExt[MAX_PATH];
            GUID guidFormat;

            hr = IMGetImagePreferredFormatFromIDL( (LPITEMIDLIST)m_pidl, &guidFormat, szExt );
            if (SUCCEEDED(hr))
            {
                strName.Concat (CSimpleStringConvert::WideString(CSimpleString(szExt)) );
            }
            else
            {
                CSimpleString bmp( IDS_BMP_EXT, GLOBAL_HINSTANCE );

                strName.Concat (CSimpleStringConvert::WideString(bmp) );
                hr = S_OK;
            }
        }


    }

    //
    // Conver the name to an LPOLESTR.  This str has to be allocated by
    // IMalloc::Alloc (which CoTaskMemAlloc does) as it will be freed by
    // the caller using IMalloc::Free (as per IMoniker spec).
    //

    if (strName.Length())
    {

        UINT cch = strName.Length() + 1;

        *ppszDisplayName = (LPOLESTR)CoTaskMemAlloc( cch * sizeof(OLECHAR) );
        if (*ppszDisplayName)
        {
            hr = S_OK;
            wcscpy( *ppszDisplayName, strName );
        }
    }


exit_gracefully:

    if (FAILED(hr) && ppszDisplayName)
    {
        *ppszDisplayName = NULL;
    }

    TraceLeaveResult(hr);
}



/*****************************************************************************

   CImageFolder::ParseDisplayName [IMoniker]

   (NOT IMPL)

 *****************************************************************************/

STDMETHODIMP
CImageFolder::ParseDisplayName(
        IBindCtx *pbc,
        IMoniker *pmkToLeft,
        LPOLESTR pszDisplayName,
        ULONG *pchEaten,
        IMoniker **ppmkOut
    )
{
    HRESULT hr = E_NOTIMPL;

    TraceEnter( TRACE_MONIKER, "CImageFolder[IMoniker]::ParseDisplayName" );

    TraceLeaveResult(hr);
}



/*****************************************************************************

   CImageFolder::IsSystemMoniker [IMoniker]

   Returns whether or not this is a system moniker class (always returns
   that it isn't).

 *****************************************************************************/

STDMETHODIMP
CImageFolder::IsSystemMoniker(DWORD *pdwMksys)
{
    HRESULT hr = S_FALSE;

    TraceEnter( TRACE_MONIKER, "CImageFolder[IMoniker]::IsSystemMoniker" );

    if (pdwMksys)
    {
        *pdwMksys = MKSYS_NONE;
    }

    TraceLeaveResult(hr);
}



/*****************************************************************************

   CImageFolder::Load [IPersistStream]

   (NOT IMPL)

 *****************************************************************************/

STDMETHODIMP
CImageFolder::Load(IStream *pStm)
{
    HRESULT hr = E_NOTIMPL;

    TraceEnter( TRACE_MONIKER, "CImageFolder(PS)::Load" );

    TraceLeaveResult(hr);
}



/*****************************************************************************

   CImageFolder::Save [IPersistStream]

   (NOT IMPL)

 *****************************************************************************/

STDMETHODIMP
CImageFolder::Save(IStream *pStm, BOOL fClearDirty)
{
    HRESULT hr = E_NOTIMPL;

    TraceEnter( TRACE_MONIKER, "CImageFolder(PS)::Save" );

    TraceLeaveResult(hr);
}



/*****************************************************************************

   CImageFolder::GetSizeMax [IPersistStream]

   (NOT IMPL)

 *****************************************************************************/

STDMETHODIMP
CImageFolder::GetSizeMax(ULARGE_INTEGER *pcbSize)
{
    HRESULT hr = E_NOTIMPL;

    TraceEnter( TRACE_MONIKER, "CImageFolder(PS)::GetSizeMax" );

    TraceLeaveResult(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\src\moniker.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998 - 1999
 *
 *  TITLE:       moniker.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        8/10/98
 *
 *  DESCRIPTION: IMoniker class definition for shelle extension
 *
 *****************************************************************************/

#ifndef __moniker_h
#define __moniker_h

class CImageMoniker : public IMoniker, CUnknown
{
    private:
        LPITEMIDLIST m_pidl;
        ~CImageMoniker();

    public:
        CImageMoniker( LPITEMIDLIST pidl );


        // IUnknown
        STDMETHOD(QueryInterface)(REFIID riid, LPVOID* ppvObject);
        STDMETHOD_(ULONG, AddRef)();
        STDMETHOD_(ULONG, Release)();

        // IMoniker
        STDMETHOD(BindToObject)(IBindCtx *pbc, IMoniker *pmkToLeft, REFIID riidResult, void **ppvResult);
        STDMETHOD(BindToStorage)(IBindCtx *pbc, IMoniker *pmkToLeft, REFIID riid, void **ppvObj);
        STDMETHOD(Reduce)(IBindCtx *pbc, DWORD dwReduceHowFar, IMoniker **ppmkToLeft, IMoniker **ppmkReduced);
        STDMETHOD(ComposeWith)(IMoniker *pmkRight, BOOL fOnlyIfNotGeneric, IMoniker **ppmkComposite);
        STDMETHOD(Enum)(BOOL fForward, IEnumMoniker **ppenumMoniker);
        STDMETHOD(IsEqual)(IMoniker *pmkOtherMoniker);
        STDMETHOD(Hash)(DWORD *pdwHash);
        STDMETHOD(IsRunning)(IBindCtx *pbc, IMoniker *pmkToLeft, IMoniker *pmkNewlyRunning);
        STDMETHOD(GetTimeOfLastChange)(IBindCtx *pbc, IMoniker *pmkToLeft, FILETIME *pFileTime);
        STDMETHOD(Inverse)(IMoniker **ppmk);
        STDMETHOD(CommonPrefixWith)(IMoniker *pmkOther, IMoniker **ppmkPrefix);
        STDMETHOD(RelativePathTo)(IMoniker *pmkOther, IMoniker **ppmkRelPath);
        STDMETHOD(GetDisplayName)(IBindCtx *pbc, IMoniker *pmkToLeft, LPOLESTR *ppszDisplayName);
        STDMETHOD(ParseDisplayName)(IBindCtx *pbc, IMoniker *pmkToLeft, LPOLESTR pszDisplayName, ULONG *pchEaten, IMoniker **ppmkOut);
        STDMETHOD(IsSystemMoniker)(DWORD *pdwMksys);

        //IPersistStream
        STDMETHOD(IsDirty)();
        STDMETHOD(Load)(IStream *pStm);
        STDMETHOD(Save)(IStream *pStm, BOOL fClearDirty);
        STDMETHOD(GetSizeMax)(ULARGE_INTEGER *pcbSize);

        //IPersist
        STDMETHOD(GetClassID)(LPCLSID pClassID);

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\src\progcb.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       proccb.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        6/4/98
 *
 *  DESCRIPTION: Implements code to have IBandedTransfer work
 *
 *****************************************************************************/

#include "precomp.hxx"
#pragma hdrstop




/*****************************************************************************

   CWiaDataCallback::CWiaDataCallback,::~CWiaDataCallback

   Constructor / Destructor for class

 *****************************************************************************/

CWiaDataCallback::CWiaDataCallback( LPCTSTR pImageName, LONG cbImage, HWND hwndOwner )
{



    TraceEnter( TRACE_CALLBACKS, "CWiaDataCallback::CWiaDataCallback()" );

    //
    // Save incoming params...
    //

    if (pImageName && *pImageName)
    {
        lstrcpy( m_szImageName, pImageName );
    }
    else
    {
        m_szImageName[0] = 0;
    }

    m_cbImage     = cbImage;
    m_lLastStatus = 0;
    m_bShowBytes  = FALSE;

    Trace(TEXT("Creating the progress dialog "));

    if (SUCCEEDED(CoCreateInstance( CLSID_WiaDefaultUi, NULL, CLSCTX_INPROC_SERVER, IID_IWiaProgressDialog, (void**)&m_pWiaProgressDialog )) && m_pWiaProgressDialog)
    {
        if (!SUCCEEDED(m_pWiaProgressDialog->Create( hwndOwner, 0 )))
        {
            m_pWiaProgressDialog->Destroy();
            m_pWiaProgressDialog = NULL;
        }

        if (m_pWiaProgressDialog)
        {
            //
            // Get the name of the image
            //
            CSimpleString strImageName(pImageName);

            //
            // Set the text in the progress dialog and show it
            //
            m_pWiaProgressDialog->SetTitle( CSimpleStringConvert::WideString(CSimpleString().Format( IDS_RETREIVING, GLOBAL_HINSTANCE, strImageName.String())));
            m_pWiaProgressDialog->SetMessage( L"" );
            m_pWiaProgressDialog->Show();
        }
    }


    TraceLeave();

}


CWiaDataCallback::~CWiaDataCallback()
{

    TraceEnter( TRACE_CALLBACKS, "CWiaDataCallback::~CWiaDataCallback()" );

    //
    // Destroy the progress window and release the interface
    //
    if (m_pWiaProgressDialog)
    {
        m_pWiaProgressDialog->Destroy();
        m_pWiaProgressDialog = NULL;
    }

    TraceLeave();
}



/*****************************************************************************

   CWiaDataCallback::AddRef,Release

   IUnknown impl

 *****************************************************************************/

#undef CLASS_NAME
#define CLASS_NAME CWiaDataCallback
#include "unknown.inc"


/*****************************************************************************

   CWiaDataCallback::QI Wrapper

   Setup code & wrapper for common QI code

 *****************************************************************************/

STDMETHODIMP CWiaDataCallback::QueryInterface(REFIID riid, LPVOID* ppvObject)
{
    INTERFACES iface[] =
    {
        &IID_IWiaDataCallback, (IWiaDataCallback *)this
    };

    return HandleQueryInterface(riid, ppvObject, iface, ARRAYSIZE(iface));
}


/*****************************************************************************

   CWiaDataCallback::BandedDataCallback

   Actual method that gets called to give status

 *****************************************************************************/

STDMETHODIMP
CWiaDataCallback::BandedDataCallback(LONG lMessage,
                                     LONG lStatus,
                                     LONG lPercentComplete,
                                     LONG lOffset,
                                     LONG lLength,
                                     LONG lReserved,
                                     LONG lResLength,
                                     BYTE *pbData)
{

    HRESULT hr = S_OK;
    TraceEnter( TRACE_CALLBACKS, "CWiaDataCallback::BandedDataCallback" );

    BOOL bCancelled = FALSE;
    if (m_pWiaProgressDialog && SUCCEEDED(m_pWiaProgressDialog->Cancelled(&bCancelled)) && bCancelled)
    {
        hr = S_FALSE;
    }
    //
    // Check to make sure we being called for status update...
    //

    else if (lMessage == IT_MSG_STATUS)
    {
        //
        // Make sure the dlg is created...
        //

        if (m_pWiaProgressDialog)
        {
            //
            // Get the right status string for this status event
            //

            if (m_lLastStatus != lStatus)
            {
                CSimpleString strStatusText;

                switch (lStatus)
                {
                default:
                case IT_STATUS_TRANSFER_FROM_DEVICE:
                    strStatusText = CSimpleString(IDS_DOWNLOADING_IMAGE, GLOBAL_HINSTANCE);
                    m_bShowBytes = TRUE;
                    break;

                case IT_STATUS_PROCESSING_DATA:
                    strStatusText = CSimpleString(IDS_PROCESSING_IMAGE, GLOBAL_HINSTANCE);
                    m_bShowBytes = FALSE;
                    break;

                case IT_STATUS_TRANSFER_TO_CLIENT:
                    strStatusText = CSimpleString (IDS_TRANSFERRING_IMAGE, GLOBAL_HINSTANCE);
                    m_bShowBytes = FALSE;
                    break;
                }


                if (strStatusText && m_pWiaProgressDialog)
                {
                    m_pWiaProgressDialog->SetMessage( CSimpleStringConvert::WideString(strStatusText) );
                }
                m_lLastStatus = lStatus;
            }

            //
            // Update the gas gauge...
            //
            m_pWiaProgressDialog->SetPercentComplete(lPercentComplete);
        }

    }
    if (100 == lPercentComplete && m_pWiaProgressDialog)
    {
        //
        // Close the status window and release the interface
        //
        m_pWiaProgressDialog->Destroy();
        m_pWiaProgressDialog = NULL;

    }

    TraceLeaveResult(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\src\propset.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999
 *
 *  TITLE:       propset.cpp
 *
 *  VERSION:     1
 *
 *
 *  DATE:        06/15/1999
 *
 *  DESCRIPTION: This code implements the IPropertySetStorage interface
 *               for the WIA shell extension.
 *
 *****************************************************************************/
#include "precomp.hxx"
#pragma hdrstop

const GUID FMTID_ImageAcquisitionItemProperties = {0x38276c8a,0xdcad,0x49e8,{0x85, 0xe2, 0xb7, 0x38, 0x92, 0xff, 0xfc, 0x84}};

const GUID *SUPPORTED_FMTS[] =
{
    &FMTID_ImageAcquisitionItemProperties,
};

/******************************************************************************

CPropSet constructor/destructor

Init or destroy private data

******************************************************************************/

CPropSet::CPropSet (LPITEMIDLIST pidl)
{
    m_pidl = ILClone (pidl);
}

CPropSet::~CPropSet ()
{
    DoILFree (m_pidl);
}



/******************************************************************************

CPropSet::QueryInterface



******************************************************************************/

STDMETHODIMP
CPropSet::QueryInterface (REFIID riid, LPVOID *pObj)
{
    INTERFACES iFace[] =
    {
        &IID_IPropertySetStorage, (IPropertySetStorage *)(this),
    };

    return HandleQueryInterface (riid, pObj, iFace, ARRAYSIZE(iFace));
}

#undef CLASS_NAME
#define CLASS_NAME CPropSet
#include "unknown.inc"

/******************************************************************************

CPropSet::Create

Create the requested IPropertyStorage sub-object. Not supported; our properties are read-only

******************************************************************************/

STDMETHODIMP
CPropSet::Create (REFFMTID rfmtid,
                  const CLSID *pclsid,
                  DWORD dwFlags,
                  DWORD dwMode,
                  IPropertyStorage **ppstg)
{
    TraceEnter (TRACE_PROPS, "CPropSet::Create");
    TraceLeaveResult (E_UNEXPECTED);
}

/******************************************************************************

CPropSet::Open

Return the requested IPropertyStorage


******************************************************************************/
#define VALID_MODES STGM_DIRECT | STGM_READ | STGM_WRITE | STGM_READWRITE | STGM_SHARE_DENY_NONE

STDMETHODIMP
CPropSet::Open (REFFMTID rfmtid,
                DWORD dwMode,
                IPropertyStorage **ppStg)
{
    HRESULT hr = STG_E_FILENOTFOUND;
    TraceEnter (TRACE_PROPS, "CPropSet::Open");
    if (IsEqualGUID (rfmtid, FMTID_ImageAcquisitionItemProperties))
    {
        if ((!VALID_MODES) & dwMode)
        {
            hr = STG_E_INVALIDFUNCTION;
        }
        else
        {
            CComPtr<IWiaItem> pItem;
            IMGetItemFromIDL (m_pidl, &pItem);
            hr = pItem->QueryInterface (IID_IPropertyStorage,
                                   reinterpret_cast<LPVOID*>(ppStg));
        }
    }
    TraceLeaveResult (hr);
}

/******************************************************************************

CPropSet::Delete

Delete the specified property set. Not supported.

******************************************************************************/

STDMETHODIMP
CPropSet::Delete (REFFMTID rfmtid)
{
    return STG_E_ACCESSDENIED;
}


/******************************************************************************

CPropSet::Enum

Return an enumerator of our property sets

******************************************************************************/

STDMETHODIMP
CPropSet::Enum (IEnumSTATPROPSETSTG **ppEnum)
{
    HRESULT hr = S_OK;
    TraceEnter (TRACE_PROPS, "CPropSet::Enum");
    *ppEnum = new CPropStgEnum (m_pidl);
    if (!*ppEnum)
    {
        hr = STG_E_INSUFFICIENTMEMORY;
    }
    TraceLeaveResult (hr);
}


/******************************************************************************

CPropStgEnum constructor



******************************************************************************/

CPropStgEnum::CPropStgEnum (LPITEMIDLIST pidl, ULONG idx) : m_cur(idx)
{
    ZeroMemory (&m_stat, sizeof(m_stat));
    m_pidl = ILClone (pidl);
}


/******************************************************************************

CPropStgEnum::QueryInterface



******************************************************************************/

STDMETHODIMP
CPropStgEnum::QueryInterface (REFIID riid, LPVOID* pObj)
{
    INTERFACES iFace[] = {&IID_IEnumSTATPROPSETSTG, (IEnumSTATPROPSETSTG *)this,};

    return HandleQueryInterface (riid, pObj, iFace, ARRAYSIZE(iFace));
}

#undef CLASS_NAME
#define CLASS_NAME CPropStgEnum
#include "unknown.inc"


/******************************************************************************

CPropStgEnum::Next

Return the next STATPROPSETSTG struct in our list

******************************************************************************/

STDMETHODIMP
CPropStgEnum::Next (ULONG celt, STATPROPSETSTG *rgelt, ULONG *pceltFetched)
{
    HRESULT hr = S_OK;
    ULONG i=0;
    CComPtr<IWiaItem> pItem;
    CComQIPtr<IPropertyStorage, &IID_IPropertyStorage> pps;

    TraceEnter (TRACE_PROPS, "CPropStgEnum::Next");
    if (!celt || !rgelt || (celt > 1 && !pceltFetched))
    {
        TraceLeaveResult (E_INVALIDARG);
    }
    if (!m_cur)
    {
        // init our STATPROPSETSTG struct
        if (SUCCEEDED(IMGetItemFromIDL(m_pidl, &pItem)))
        {
            pps = pItem;
            pps->Stat(&m_stat);
        }
    }
    // We use the same STATPROPSETSTG given us by WIA but replace the FMTID

    if (celt && m_cur < ARRAYSIZE(SUPPORTED_FMTS))
    {
        for (i = 1;i<=celt && m_cur < ARRAYSIZE(SUPPORTED_FMTS);i++,rgelt++,m_cur++)
        {
            *rgelt = m_stat;
            (*rgelt).fmtid = *(SUPPORTED_FMTS[m_cur]);
        }
    }
    if (i<celt)
    {
        hr = S_FALSE;
    }
    if (pceltFetched)
    {
        *pceltFetched = i;
    }

    TraceLeaveResult (hr);
}

/******************************************************************************

CPropStgEnum::Skip

Skips items in the enumeration

******************************************************************************/
STDMETHODIMP
CPropStgEnum::Skip (ULONG celt)
{
    HRESULT hr = S_OK;
    ULONG maxSkip = ARRAYSIZE(SUPPORTED_FMTS) - m_cur;
    TraceEnter (TRACE_PROPS, "CPropStgEnum::Skip");
    m_cur = min (ARRAYSIZE(SUPPORTED_FMTS), m_cur+celt);
    if (maxSkip < celt)
    {
        hr = S_FALSE;
    }
    TraceLeaveResult (hr);
}

/******************************************************************************

CPropStgEnum::Reset

Reset the enumeration index to 0

******************************************************************************/

STDMETHODIMP
CPropStgEnum::Reset ()
{
    TraceEnter (TRACE_PROPS, "CPropStgEnum::Reset");
    m_cur = 0;
    TraceLeaveResult (S_OK);
}


/******************************************************************************

CPropStgEnum::Clone

Copy the enumeration object

******************************************************************************/

STDMETHODIMP
CPropStgEnum::Clone (IEnumSTATPROPSETSTG **ppEnum)
{
    HRESULT hr = S_OK;
    TraceEnter (TRACE_PROPS, "CPropStgEnum::Clone");
    *ppEnum = new CPropStgEnum (m_pidl, m_cur);
    if (!*ppEnum)
    {
        hr = E_OUTOFMEMORY;
    }
    TraceLeaveResult (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\src\progcb.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       progcg.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        6/4/98
 *
 *  DESCRIPTION: Progress callback class definitions
 *
 *****************************************************************************/

#ifndef __progcb_h
#define __progcb_h



class CWiaDataCallback : public IWiaDataCallback, CUnknown
{
    private:
        CComPtr<IWiaProgressDialog> m_pWiaProgressDialog;
        BOOL          m_bShowBytes;
        LONG          m_lLastStatus;
        TCHAR         m_szImageName[ MAX_PATH ];
        LONG          m_cbImage;
        ~CWiaDataCallback();

    public:
        CWiaDataCallback( LPCTSTR pImageName, LONG cbImage, HWND hwndOwner );


        // IUnknown
        STDMETHOD(QueryInterface)(REFIID riid, LPVOID* ppvObject);
        STDMETHOD_(ULONG, AddRef)();
        STDMETHOD_(ULONG, Release)();

        // IWiaDataCallback
        STDMETHOD(BandedDataCallback) (THIS_
                                       LONG lMessage,
                                       LONG lStatus,
                                       LONG lPercentComplete,
                                       LONG lOffset,
                                       LONG lLength,
                                       LONG lReserved,
                                       LONG lResLength,
                                       BYTE *pbData);
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\src\propset.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999
 *
 *  TITLE:       propset.h
 *
 *  VERSION:     1
 *
 *
 *  DATE:        06/15/1999
 *
 *  DESCRIPTION: This code implements the IPropertySetStorage interface
 *               for the WIA shell extension.
 *
 *****************************************************************************/

class CPropSet : public CUnknown, public IPropertySetStorage
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface (REFIID riid, LPVOID *pObj);
    STDMETHODIMP_(ULONG) AddRef ();
    STDMETHODIMP_(ULONG) Release ();

    // IPropertySetStorage
    STDMETHODIMP Create( REFFMTID rfmtid,
        const CLSID  *pclsid,
        DWORD grfFlags,
        DWORD grfMode,
        IPropertyStorage **ppprstg);

    STDMETHODIMP Open( REFFMTID rfmtid,
        DWORD grfMode,
        IPropertyStorage **ppprstg);

    STDMETHODIMP Delete(REFFMTID rfmtid);

    STDMETHODIMP Enum( IEnumSTATPROPSETSTG **ppenum);

    CPropSet (LPITEMIDLIST pidl);

private:
    LPITEMIDLIST m_pidl;
    ~CPropSet ();
};

class CPropStgEnum : public CUnknown, public IEnumSTATPROPSETSTG
{
public:
    // IEnumSTATPROPSETSTG
    STDMETHODIMP Next(ULONG celt, STATPROPSETSTG *rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt);
    STDMETHODIMP Reset(void) ;
    STDMETHODIMP Clone(IEnumSTATPROPSETSTG **ppenum);

    //IUnknown
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    STDMETHODIMP QueryInterface(THIS_ REFIID, OUT PVOID *);

    CPropStgEnum (LPITEMIDLIST pidl, ULONG idx=0);
private:
    ~CPropStgEnum () {DoILFree(m_pidl);};
    ULONG m_cur;
    STATPROPSETSTG m_stat;
    LPITEMIDLIST m_pidl;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\src\propui.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999
 *
 *  TITLE:       propui.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      DavidShi
 *
 *  DATE:        4/1/99
 *
 *  DESCRIPTION: CWiaPropUI Definition
 *
 *****************************************************************************/

#ifndef _propui_h_
#define _propui_h_

#define STIPAGE_NONE            0x00000000
#define STIPAGE_ICM             0x00000001
#define STIPAGE_EVENTS          0x00000002
#define STIPAGE_PORTS           0x00000004
#define STIPAGE_GENERAL         0x00000008
#define STIPAGE_EXTEND          0x00000010
#define STIPAGE_DEBUG           0x80000000
#define STIPAGE_ALL             0xFFFFFFFF


struct PROPTHREADDATA
{
    CSimpleString strName;
    HKEY *aKeys;
    UINT cKeys;
    CSimpleStringWide strDeviceId;
    CSimpleStringWide strItemName;
};


const TCHAR c_szPropkey[] = TEXT("CLSID\\%s");
const TCHAR c_szParentClass[] = TEXT("PropUISheetParent");
const TCHAR c_szParentName[] = TEXT("PropUISheetParent");
const TCHAR c_szScannerKey[] = TEXT("CLSID\\%ls\\Scanner");
const TCHAR c_szCameraKey[] = TEXT("CLSID\\%ls\\Camera");
const TCHAR c_szStiPropKey[] = TEXT("CLSID\\%ls\\STIDevices");
const TCHAR c_szPropSheetHandler[] = TEXT("shellex\\PropertySheetHandlers");
const TCHAR c_szContextMenuHandler[] = TEXT("shellext\\ContextMenuHandlers");
const TCHAR c_szConnectSettings[] = TEXT("OnConnect\\%ls");

// Implement COM interface

class CPropSheetExt : public IShellPropSheetExt, public IShellExtInit, public CUnknown
{
public:
    STDMETHODIMP QueryInterface (REFIID riid, LPVOID* ppvObj) ;
    STDMETHODIMP_(ULONG) AddRef () ;
    STDMETHODIMP_(ULONG) Release ();


    // IShellExtInit
    STDMETHODIMP Initialize (LPCITEMIDLIST pidlFolder,LPDATAOBJECT lpdobj,HKEY hkeyProgID);

    // IShellPropSheetExt
    STDMETHODIMP AddPages (LPFNADDPROPSHEETPAGE lpfnAddPage,LPARAM lParam);
    STDMETHODIMP ReplacePage (UINT uPageID,LPFNADDPROPSHEETPAGE lpfnReplacePage,LPARAM lParam) {return E_NOTIMPL;};
    CPropSheetExt ();
private:
    HRESULT  AddSTIPages (LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lparam, MySTIInfo *pDevInfo);
    HRESULT  AddICMPage (LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lparam);
    HRESULT  AddDevicePages (IWiaItem *pDevice, LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lparam, DWORD dwType);
    HRESULT  AddPagesForIDL (LPITEMIDLIST pidl, bool bGeneralPageOnly, LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lparam);
    ~CPropSheetExt ();

    CComPtr<IDataObject> m_pdo;
};

class CWiaPropUI: public IWiaPropUI, public CUnknown
{
public:
    STDMETHODIMP QueryInterface (REFIID riid, LPVOID* ppvObj) ;
    STDMETHODIMP_(ULONG) AddRef () ;
    STDMETHODIMP_(ULONG) Release ();

    // IWiaPropUI methods

    STDMETHODIMP ShowItemProperties(IN HWND hParent,LPCWSTR szDeviceId, IN LPCWSTR szItemName, ULONG uFlags);
    STDMETHODIMP GetItemPropertyPages (IWiaItem *pItem,
                                       IN OUT LPPROPSHEETHEADER ppsh);

    CWiaPropUI ();

private:

    ~CWiaPropUI();

    // Helper functions
    VOID     InitMembers (HWND hParent,
                          LPCWSTR szDeviceId,
                          LPCWSTR szItemName,
                          ULONG  uFlags) ;

    HRESULT  OnShowItem ();
    HRESULT  LaunchSheet (HKEY *aKeys,
                          UINT cKeys);

    DWORD                   m_dwFlags;
    CComPtr<IWiaItem>       m_pDevice;
    CComPtr<IWiaItem>       m_pItem;
    HWND                    m_hParent;
    CSimpleStringWide       m_strDeviceId;
    CSimpleStringWide       m_strTitle;
    CComPtr<IDataObject>    m_pdo;
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\src\prpages.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999
 *
 *  TITLE:       prpages.h
 *
 *  VERSION:     1.0
 *
 *  DATE:        11/9/99
 *
 *  DESCRIPTION: WIA Property pages classes
 *
 *****************************************************************************/
#ifndef __PRPAGES_H_
#define __PRPAGES_H_
#include "wiacsh.h"


//
// Defines for using WiaCreatePorts & WiaDestroyPorts
//
// These were stolen from exports.h in printscan\wia\setup\clsinst
//

typedef struct _WIA_PORTLIST {

    DWORD   dwNumberOfPorts;
    LPWSTR  szPortName[1];

} WIA_PORTLIST, *PWIA_PORTLIST;


typedef PWIA_PORTLIST (CALLBACK *PFN_WIA_CREATE_PORTLIST)  (LPWSTR        szDeviceId);
typedef void          (CALLBACK *PFN_WIA_DESTROY_PORTLIST) (PWIA_PORTLIST pWiaPortList);

struct MySTIInfo
{
    PSTI_DEVICE_INFORMATION psdi;
    DWORD                   dwPageMask; // which pages to add
    VOID                    AddRef () {InterlockedIncrement(&m_cRef);};
    VOID                    Release () {
                                        InterlockedDecrement(&m_cRef);
                                        if (!m_cRef) delete this;
                                       };
    MySTIInfo () { m_cRef = 1;};
private:
    LONG                    m_cRef;
    ~MySTIInfo () {if (psdi) LocalFree (psdi);};
};


class CPropertyPage {

    //  Dialog procedure

    static INT_PTR CALLBACK    DlgProc(HWND hwnd, UINT uMsg, WPARAM wp,
                                    LPARAM lp);
private:
    BOOL m_bInit;
    static UINT PropPageCallback (HWND hwnd, UINT uMsg, PROPSHEETPAGE *psp);
    const DWORD *m_pdwHelpIDs;

protected:

    HWND                    m_hwnd, m_hwndSheet;
    PROPSHEETPAGE           m_psp;
    HPROPSHEETPAGE          m_hpsp;
    LONG                    m_cRef;
    PSTI_DEVICE_INFORMATION m_psdi;
    CComPtr<IWiaItem>       m_pItem;
    MySTIInfo              *m_pDevInfo;
    virtual                ~CPropertyPage();
    void                    EnableApply ();
    CSimpleStringWide       m_strDeviceId;
    CSimpleStringWide       m_strUIClassId;

public:


    CPropertyPage(unsigned uResource, MySTIInfo *pDevInfo, IWiaItem *pItem = NULL, const DWORD *pHelpIDs=NULL);
    LONG    AddRef ();
    LONG    Release ();

    HRESULT AddPage (LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam, bool bUseName = false);

    BOOL    Enroll(PROPSHEETHEADER& psh) {
        if   (!m_hpsp)
            m_hpsp = CreatePropertySheetPage(&m_psp);

        if  (!m_hpsp)
            return  FALSE;

        psh.phpage[psh.nPages++] = m_hpsp;
        return  TRUE;
    }

    inline VOID SetWindow(HWND hwnd) {m_hwnd = hwnd;}
    inline VOID SetWndSheet(HWND hwnd) {m_hwndSheet = hwnd;}

    //  virtual functions to give subclasses control
    virtual VOID OnHelp (WPARAM wp, LPARAM lp) {if (0xffff != LOWORD(reinterpret_cast<HELPINFO*>(lp)->iCtrlId)) WiaHelp::HandleWmHelp(wp, lp, m_pdwHelpIDs);};
    virtual VOID OnContextMenu (WPARAM wp, LPARAM lp) {if (65535 != GetWindowLong(reinterpret_cast<HWND>(wp), GWL_ID)) WiaHelp::HandleWmContextMenu (wp, lp, m_pdwHelpIDs);};

    virtual bool ItemSupported (IWiaItem *pItem) {return true;};
    virtual INT_PTR OnInit() { return   TRUE; }

    virtual INT_PTR OnCommand(WORD wCode, WORD widItem, HWND hwndItem) { return  FALSE; }

    virtual LONG    OnSetActive() { return  0L; }

    virtual LONG    OnApplyChanges(BOOL bHitOK) {return PSNRET_NOERROR;}

    virtual LONG    OnKillActive() {return FALSE;}

    virtual LONG    OnQueryCancel() {return FALSE;}
    virtual VOID    OnReset(BOOL bHitCancel) {};

    virtual void    OnDrawItem(LPDRAWITEMSTRUCT lpdis) { return; }
    virtual INT_PTR OnRandomMsg(UINT msg, WPARAM wp, LPARAM lp) {return 0;};
    virtual bool    OnNotify(LPNMHDR pnmh, LRESULT *presult) {return false;};
    // Sheets that allow the user to change settings need to implement these
    // functions for proper Apply button management.
    virtual void    SaveCurrentState () {}
    virtual bool    StateChanged () {return false;}
};

class CDevicePage : public CPropertyPage
{
    public:

        CDevicePage(unsigned uResource, IWiaItem *pItem , const DWORD *pHelpIDs);
};

class CWiaScannerPage : public CDevicePage
{
    public:
        CWiaScannerPage (IWiaItem *pItem);
        INT_PTR OnInit ();
        INT_PTR OnCommand (WORD wCode, WORD widItem, HWND hwndItem);
};

class CWiaCameraPage : public CDevicePage
{
    public:
        CWiaCameraPage (IWiaItem *pItem);
        ~CWiaCameraPage ();
        INT_PTR OnInit ();
        INT_PTR OnCommand (WORD wCode, WORD widItem, HWND hwndItem);
        void    SaveCurrentState ();
        bool    StateChanged ();
        INT_PTR OnRandomMsg (UINT msg, WPARAM wp, LPARAM lp);
        LONG    OnApplyChanges (BOOL bHitOK);

    private:

        VOID UpdatePictureSize (IWiaPropertyStorage *pps);
        HRESULT WriteImageSizeToDevice ();
        VOID UpdateImageSizeStatic (LRESULT lIndex);
        HRESULT WriteFlashModeToDevice ();
        HRESULT WritePortSelectionToDevice();


        POINT *m_pSizes;      // sorted list of supported resolutions
        size_t    m_nSizes;   // the length of m_pSizes;
        LRESULT   m_nSelSize; // which size is selected in the slider
        LRESULT   m_lFlash;   // which flash mode is selected. Set to -1 if read-only
        HMODULE   m_hStiCi;

    public:

        PFN_WIA_CREATE_PORTLIST  m_pfnWiaCreatePortList;
        PFN_WIA_DESTROY_PORTLIST m_pfnWiaDestroyPortList;
        TCHAR m_szPort[128]; // hold initial port setting
        TCHAR m_szPortSpeed[64];

};


class CWiaFolderPage  : public CPropertyPage
{
    public:
        CWiaFolderPage (IWiaItem *pItem);
};

class CWiaCameraItemPage  : public CPropertyPage
{
    public:
        CWiaCameraItemPage (IWiaItem *pItem);

        INT_PTR OnInit ();
        bool ItemSupported (IWiaItem *pItem);
};

//
// This struct holds per-item data for each event in the event list.
// The data uses CLSIDs, not offsets into the app listbox, to avoid
// dependency problems in the future.
//
struct EVENTINFO
{
    GUID guidEvent;
    INT   nHandlers;      // number of entries in the apps listbox
    bool  bHasDefault;    // whether it already has a default handler
    bool  bNewHandler;    // set when clsidNewHandler is filled in
    CLSID clsidHandler;   // current default handler
    CLSID clsidNewHandler;// current selection in the app listbox
    CComBSTR strIcon;
    CComBSTR strName;
    CComBSTR strDesc;
    CComBSTR strCmd;
    ULONG ulFlags;
};
LRESULT WINAPI MyComboWndProc (HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);

class CAppListBox
{
public:
    CAppListBox (HWND hList, HWND hStatic, HWND hNoApps);

    UINT FillAppListBox (IWiaItem *pItem, EVENTINFO *pei);
    void FreeAppData ();
    ~CAppListBox();
private:
    HIMAGELIST m_himl;
    HWND m_hwnd;
    HWND m_hstatic;
    HWND m_hnoapps;
    WNDPROC m_ProcOld;

};




class CWiaEventsPage : public CPropertyPage
{
    public:
        CWiaEventsPage (IWiaItem *pItem);
        ~CWiaEventsPage();
        INT_PTR OnInit();
        LONG OnApplyChanges(BOOL bHitOK);
        INT_PTR OnCommand(WORD wCode, WORD widItem, HWND hwndItem);
        void    SaveCurrentState ();
        bool    StateChanged();
        bool    ItemSupported(IWiaItem *pItem);
        bool    OnNotify(LPNMHDR pnmh, LRESULT *presult);


    private:
        void FillEventListBox();

        void GetEventFromList(LONG idx, EVENTINFO **ppei);
        INT_PTR HandleEventComboNotification(WORD wCode, HWND hCombo);
        INT_PTR HandleAppComboNotification(WORD wCode, HWND hCombo);
        bool RegisterWiaxfer(LPCTSTR);
        void GetSavePath();
        void UpdateWiaxferSettings();
        DWORD GetConnectionSettings();
        void EnableAutoSave(BOOL bEnable);
        LONG ApplyAutoSave();
        void SaveConnectState();
        void CWiaEventsPage::VerifyCurrentAction(DWORD &dwAction);
        TCHAR m_szFolderPath[MAX_PATH];
        BOOL  m_bAutoDelete;
        BOOL  m_bUseDate;
        bool  m_bHandlerChanged; // determines if Apply should be enabled
        DWORD m_dwAction; // what to do for device connect
        CAppListBox *m_pAppsList;
        HIMAGELIST m_himl;
        BOOL  m_bReadOnly;
};

// helper functions
UINT FillAppListBox (HWND hDlg, INT idCtrl, IWiaItem *pItem, EVENTINFO *pei);
bool GetSelectedHandler (HWND hDlg, INT idCtrl, WIA_EVENT_HANDLER &weh);
void FreeAppData (HWND hDlg, INT idCtrl);
bool AddIconToImageList (HIMAGELIST himl, BSTR strIconPath);
void SetAppSelection (HWND hDlg, INT idCtrl, CLSID &clsidSel);
HRESULT SetDefaultHandler (IWiaItem *pItem, EVENTINFO *pei);
void GetEventInfo (IWiaItem *pItem, const GUID &guid, EVENTINFO **ppei);
LPWSTR ItemNameFromIndex (int i);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\src\propui.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999
 *
 *  TITLE:       propui.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      DavidShi
 *
 *  DATE:        4/1/99
 *
 *  DESCRIPTION: CWiaPropUI & Associated classes
 *
 *****************************************************************************/


#include "precomp.hxx"
#pragma hdrstop
#include "stiprop.h"


/*****************************************************************************

   PropertySheetFromDevice

   Given a root item IWiaItem pointer, show a property sheet for it

 *****************************************************************************/

STDAPI_(HRESULT)
PropertySheetFromDevice (IN LPCWSTR  szDeviceId,
                         DWORD      dwFlags,
                         HWND       hParent)
{
    HRESULT             hr      = S_OK;
    CWiaPropUI*         pObj    = NULL;
    CComQIPtr<IWiaPropUI, &IID_IWiaPropUI> pPropUI;


    TraceEnter (TRACE_PROPUI, "PropertySheetFromDevice");

    if (!szDeviceId )
    {
        ExitGracefully( hr, E_INVALIDARG, "Invalid params to PropertySheetFromDevice" );
    }

    pObj = new CWiaPropUI();
    if (!pObj)
    {
        ExitGracefully (hr, E_OUTOFMEMORY, "Unable to allocate CWiaPropUI in PropertySheetFromDevice");
    }

    pPropUI = pObj; // Implicit QI for IID_IWiaPropUI
    if (!pPropUI)
    {
        ExitGracefully (hr, E_FAIL, "QueryInterface for IWiaPropUI failed");
    }

    // Get device props from the device
    //

    hr = pPropUI->ShowItemProperties (hParent, szDeviceId, NULL, dwFlags);

exit_gracefully:
    DoRelease (pObj);
    TraceLeaveResult (hr);
}



/*****************************************************************************

   PropertySheetFromItem

   Given an IWiaItem pointer, show a property sheet for it

 *****************************************************************************/

STDAPI_(HRESULT)
PropertySheetFromItem (IN LPCWSTR    szDeviceId,
                       IN LPCWSTR    szItemName,
                       DWORD        dwFlags,
                       HWND         hParent)
{
    HRESULT             hr      = S_OK;
    CWiaPropUI*         pObj    = NULL;
    CComQIPtr<IWiaPropUI, &IID_IWiaPropUI> pPropUI;

    TraceEnter (TRACE_PROPUI, "PropertySheetFromItem");
    if (!szItemName || !szDeviceId )
    {
        ExitGracefully( hr, E_INVALIDARG, "Invalid params to PropertySheetFromItem" );
    }

    pObj = new CWiaPropUI();
    if (!pObj)
    {
        ExitGracefully (hr, E_OUTOFMEMORY, "Unable to allocate CWiaPropUI in PropertySheetFromDevice");
    }

    pPropUI = pObj; // Implicit QI for IID_IWiaPropUI

    FailGracefully (hr,"Invalid params to PropertySheetFromDevice");

    // Get item props
    //

    hr = pPropUI->ShowItemProperties (hParent, szDeviceId, szItemName, dwFlags);

exit_gracefully:
    DoRelease (pObj);
    TraceLeaveResult (hr);
}


/*****************************************************************************

   CWiaPropUI constructor / destructor

   Constructor accepts a LPCITEMIDLIST for the item to display

 *****************************************************************************/

CWiaPropUI::CWiaPropUI ()
  : m_dwFlags(0)
{
    TraceEnter (TRACE_PROPUI, "CWiaPropUI::CWiaPropUI");
    TraceLeave ();

}

CWiaPropUI::~CWiaPropUI()
{

    TraceEnter (TRACE_PROPUI, "CWiaPropUI::~CWiaPropUI");
    TraceLeave ();
}


/*****************************************************************************

   CWiaPropUI::IUnknown stuff

   Use common implementation for IUnknown methods

 *****************************************************************************/

#undef CLASS_NAME
#define CLASS_NAME CWiaPropUI
#include "unknown.inc"


/*****************************************************************************

   CWiaPropUI::QI Wrapper

   Use common QI implementation to handle QI calls.

 *****************************************************************************/

STDMETHODIMP
CWiaPropUI::QueryInterface (REFIID  riid,
                            LPVOID* ppvObj
                            )
{
    HRESULT hr;
    INTERFACES iface[]=
    {
        &IID_IWiaPropUI,         static_cast<IWiaPropUI*>(this),
    };

    TraceEnter( TRACE_PROPUI, "CWiaPropUI::QueryInterface" );

    hr = HandleQueryInterface(riid, ppvObj, iface, ARRAYSIZE(iface));

    TraceLeaveResult( hr );
}



/*****************************************************************************

   CWiaPropUI::InitMembers

   Initialize member variables from input params

 *****************************************************************************/

VOID
CWiaPropUI::InitMembers (HWND   hParent,
                         LPCWSTR szDeviceId,
                         LPCWSTR szItemName,
                         DWORD  dwFlags)
{

    m_strDeviceId = szDeviceId;

    TraceEnter (TRACE_PROPUI, "CWiaPropUI::InitMembers");
    m_hParent = hParent;

    GetDeviceFromDeviceId (m_strDeviceId,
                           IID_IWiaItem,
                           reinterpret_cast<LPVOID*>(&m_pDevice),
                           TRUE);

    m_dwFlags = dwFlags;

    if (szItemName)
    {
        TraceAssert (m_pDevice);
        m_pDevice->FindItemByName (0, CComBSTR(szItemName),&m_pItem);
        PropStorageHelpers::GetProperty (m_pItem, WIA_IPA_ITEM_NAME, m_strTitle);

    }
    else
    {
        PropStorageHelpers::GetProperty (m_pDevice, WIA_DIP_DEV_NAME, m_strTitle);
    }

    TraceLeave ();
}


/*****************************************************************************

   CWiaPropUI::ShowItemProperties

   Loads the General property page based on the device and item type,
   then adds pages created by IShellPropSheetExt handlers.

 *****************************************************************************/

STDMETHODIMP
CWiaPropUI::ShowItemProperties (HWND    hParent,
                                LPCWSTR  szDeviceId,
                                LPCWSTR  szItemName,
                                DWORD   dwFlags)
{
    HRESULT hr = S_OK;



    TraceEnter (TRACE_PROPUI, "CWiaPropUI::ShowItemProperties");
    if (!szDeviceId)
    {
        ExitGracefully( hr, E_INVALIDARG, "NULL deviceid in ShowItemProperties" );
    }

    InitMembers (hParent, szDeviceId, szItemName, dwFlags);
    hr = OnShowItem ();

exit_gracefully:

    TraceLeaveResult(hr);
}




/****************************************************************************

CWiaPropUI::LaunchSheet

Create the dataobject and launch the propsheet

*****************************************************************************/
HRESULT
CWiaPropUI::LaunchSheet (HKEY *aKeys,
                         UINT cKeys)
{
    HRESULT hr = S_OK;
    TraceEnter (TRACE_PROPUI, "CWiaPropUI::LaunchSheet");
    CSimpleStringWide strName;
    CComPtr<IWiaItem> pItem;
    CComPtr<IDataObject> pDataObj;
    GetDataObjectForItem (m_pItem?m_pItem : m_pDevice, &pDataObj);

    BOOL bParent = IsWindow (m_hParent);
    if (bParent)
    {
        EnableWindow (m_hParent, FALSE);
    }
    if (!SHOpenPropSheet (CSimpleStringConvert::NaturalString(m_strTitle), aKeys, cKeys, NULL, pDataObj, NULL, NULL))
    {
        hr =  E_FAIL;
        Trace (TEXT("SHOpenPropSheet failed in LaunchSheet"));
    }
    if (bParent)
    {
        EnableWindow (m_hParent, TRUE);
    }
    for (UINT i=0;i<cKeys;i++)
    {
        if (aKeys[i])
        {
            RegCloseKey(aKeys[i]);
        }
    }
    TraceLeaveResult (hr);
}



/*****************************************************************************

   CWiaPropUI::OnShowItem

   Show property page for an IWiaItem

 *****************************************************************************/


HRESULT
CWiaPropUI::OnShowItem ()
{
    HRESULT                 hr          = S_OK;

    UINT                    cKeys       = 1;
    HKEY                    aKeys[2];



    TraceEnter (TRACE_PROPUI, "CWiaPropUI::OnShowItem");

    ZeroMemory (aKeys, sizeof(aKeys));
    //
    // First, find the extension for this particular device
    //
    aKeys[1] = GetDeviceUIKey (m_pDevice, WIA_UI_PROPSHEETHANDLER);
    if (aKeys[1])
    {
        cKeys++;
    }

    //
    // Now find the extensions for this type of device
    //
    aKeys[0] = GetGeneralUIKey (m_pDevice, WIA_UI_PROPSHEETHANDLER);
    if (!aKeys[0])
    {
        ExitGracefully (hr, E_FAIL, "GetGeneralKey failed in OnShowItem");
    }
    hr = LaunchSheet (aKeys, cKeys);

exit_gracefully:


    TraceLeaveResult (hr);
}

/****************************************************************************
   TestKeyForExtension


   Make sure the desired UI extension is available

 *****************************************************************************/

BOOL
TestKeyForExtension (const CSimpleReg &hk, DWORD dwType)
{
    CSimpleString szType;
    BOOL    bRet   = TRUE;
    TraceEnter (TRACE_PROPUI, "TestKeyForExtension");
    switch (dwType)
    {
        case WIA_UI_PROPSHEETHANDLER:
            szType = c_szPropSheetHandler;
            break;

        case WIA_UI_CONTEXTMENUHANDLER:
            szType = c_szContextMenuHandler;
            break;

        default:
            Trace (TEXT("Unknown ui type in TestKeysForExtension %d"),dwType);
            bRet = FALSE;
            break;
    }
    Trace(TEXT("Looking for key %s"), szType.String());
    if (szType.Length())
    {
        CSimpleReg regSubkey( hk, szType, false, KEY_READ );
        if (!regSubkey.OK())
        {
            Trace (TEXT("UI %d not supported"), dwType);
            bRet = FALSE;
        }
    }
    TraceLeave ();
    return bRet;

}


/*****************************************************************************

   GetDeviceUIKey

   Retrieves the reg key for any installed UI extension for this device

 *****************************************************************************/

STDAPI_(HKEY)
GetDeviceUIKey (IUnknown *pWiaItemRoot, DWORD dwType)
{
    CSimpleReg hkTest;
    TCHAR   szClsid[MAX_PATH];
    TCHAR   szRegPath[MAX_PATH];
    HKEY    hk = NULL;
    TraceEnter (TRACE_PROPUI, "GetDeviceUIKey");
    if (S_OK == GetClsidFromDevice (pWiaItemRoot, szClsid))
    {
        wsprintf (szRegPath, c_szPropkey, szClsid);
        hkTest = CSimpleReg (HKEY_CLASSES_ROOT, szRegPath, false, KEY_READ );
        Trace(TEXT("szRegPath for UI key: %s"), szRegPath);
        if (TestKeyForExtension (hkTest, dwType))
        {
            RegOpenKeyEx (hkTest, NULL, 0, KEY_READ, &hk);
        }
    }
    TraceLeave ();
    return hk;
}



/*****************************************************************************

   GetGeneralUIKey

   Retrieves the reg key of the General prop sheet page for this item type

 *****************************************************************************/

STDAPI_(HKEY)
GetGeneralUIKey (IUnknown *pWiaItemRoot, DWORD dwType)
{

    HKEY hk = NULL;
    LPCTSTR pszDevice = NULL;
    CSimpleReg  hkTest;
    TCHAR   szRegPath[MAX_PATH];
    WORD    wType;


    TraceEnter (TRACE_PROPUI, "GetGeneralUIKey");

    if (SUCCEEDED(GetDeviceTypeFromDevice (pWiaItemRoot, &wType)))
    {
        switch (wType)
        {
            case StiDeviceTypeScanner:
                pszDevice = c_szScannerKey;
                break;
            case StiDeviceTypeStreamingVideo:
            case StiDeviceTypeDigitalCamera:
                pszDevice = c_szCameraKey;
                break;
            default:
                Trace (TEXT("Unknown device type in GetGeneralUIKey"));
                break;
        }
        wsprintf (szRegPath, pszDevice, cszImageCLSID);

        hkTest = CSimpleReg (HKEY_CLASSES_ROOT,szRegPath,false,KEY_READ);
        if (TestKeyForExtension (hkTest, dwType))
        {
            RegOpenKeyEx (hkTest, NULL, 0, KEY_READ, &hk);
        }
    }
    TraceLeave ();
    return hk;
}

#define MAX_PAGES 20


/*****************************************************************************

   AddPropPageProc

   Given a propertysheet page, adds it to the array of pages
   in the propsheetheader. Assumes the array is adequately allocated.

 *****************************************************************************/

BOOL CALLBACK AddPropPageProc (HPROPSHEETPAGE hPage, LPPROPSHEETHEADER ppsh)
{
    BOOL bRet= TRUE;
    TraceEnter (TRACE_PROPUI, "AddPropPageProc");
    if (ppsh->nPages >= MAX_PAGES)
    {
        Trace (TEXT("Max pages reached in AddPropPageProc"));
        bRet = FALSE;
    }
    else
    {
        ppsh->phpage[ppsh->nPages++] = hPage;
    }

    TraceLeave ();
    return bRet;
}



/*****************************************************************************

   ExtendPropSheetFromClsid

   <Notes>

 *****************************************************************************/

HRESULT
ExtendPropSheetFromClsid (REFCLSID          clsid,
                          LPPROPSHEETHEADER ppsh,
                          IDataObject*      pDataObj)
{
    HRESULT                     hr;
    CComPtr<IShellExtInit>      pInit;
    CComQIPtr<IShellPropSheetExt, &IID_IShellPropSheetExt> pExt;

    TraceEnter (TRACE_PROPUI, "ExtendPropSheetFromClsid");
    hr = CoCreateInstance (clsid,
                           NULL,
                           CLSCTX_INPROC_SERVER,
                           IID_IShellExtInit,
                           reinterpret_cast<LPVOID*>(&pInit));

    FailGracefully (hr, "CoCreateInstance failed in ExtendPropSheetFromClsid");
    hr = pInit->Initialize (NULL, pDataObj, NULL);
    FailGracefully (hr, "Initialize failed in ExtendPropSheetFromClsid");

    pExt = pInit;   // implicit QI for IID_IShellPropSheetExt
    if (!pExt)
    {
        ExitGracefully( hr, E_FAIL, "QueryInterface for IShellPropSheetExt failed in ExtendPropSheetFromClsid" );
    }

    hr = pExt->AddPages (reinterpret_cast<LPFNADDPROPSHEETPAGE>(AddPropPageProc),
                         reinterpret_cast<LPARAM>(ppsh));
    FailGracefully (hr, "AddPages failed in ExtendPropSheetFromClsid");

exit_gracefully:

    TraceLeaveResult (hr);
}


/*****************************************************************************

   ExtendPropSheetFromKey

   Reads the CLSIDs stored in the given registry key
   and invokes the IPropertySheetExt handler

 *****************************************************************************/

HRESULT
ExtendPropSheetFromKey (HKEY                hkey,
                        LPPROPSHEETHEADER   ppsh,
                        IDataObject*        pDataObj)
{
    HRESULT hr    = S_OK;
    DWORD   i     = 0;
    DWORD   dwLen = MAX_PATH;
    TCHAR   szSubKey[MAX_PATH];

    CLSID   clsid;

    TraceEnter (TRACE_PROPUI, "ExtendPropSheetFromKey");
    // enum the keys
    while (ERROR_SUCCESS == RegEnumKeyEx (hkey,
                                          i++,
                                          szSubKey,
                                          &dwLen,
                                          NULL,
                                          NULL,
                                          NULL,
                                          NULL))
    {
        LPWSTR pClsid;
        #ifdef UNICODE
        pClsid = szSubKey;
        #else
        WCHAR szw[MAX_PATH];

        MultiByteToWideChar (CP_ACP, 0, szSubKey, -1, szw, ARRAYSIZE(szw));
        pClsid = szw;
        #endif

        dwLen = MAX_PATH;

        // szSubKey is the string name of a CLSID
        if (SUCCEEDED(CLSIDFromString (pClsid, &clsid)))
        {
            hr = ExtendPropSheetFromClsid(clsid, ppsh, pDataObj);
            FailGracefully (hr, "ExtendPropSheetFromClsid failed in ExtendPropSheetFromKey");
        }
    }
exit_gracefully:
    TraceLeaveResult (hr);
}


/*****************************************************************************

   CWiaPropUI::GetItemPropertyPages

   Fill in the propsheetheader with array of hpropsheetpages for the given item

 *****************************************************************************/

HRESULT
CWiaPropUI::GetItemPropertyPages (IWiaItem *pItem, LPPROPSHEETHEADER ppsh)
{

    HRESULT             hr      = S_OK;
    HKEY                hSubkey = NULL;
    HKEY                aKeys[2];
    CComPtr<IWiaItem>   pDevice;
    CComPtr<IDataObject>pdo;
    LONG lType;
    WORD wDevType;
    TraceEnter (TRACE_PROPUI, "CWiaPropUI::GetItemPropertyPages");


    ppsh->dwFlags &= ~PSH_PROPSHEETPAGE;
    // Use LocalAlloc instead of new, because client will be freeing this array, just to make sure we're
    // using the same allocator/deallocator methods
    ppsh->phpage = reinterpret_cast<HPROPSHEETPAGE*>(LocalAlloc (LPTR,sizeof (HPROPSHEETPAGE) * MAX_PAGES));
    if (!(ppsh->phpage))
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        pItem->GetItemType (&lType);
        pItem->GetRootItem (&pDevice);
        VerifyCachedDevice(pDevice);
        GetDeviceTypeFromDevice (pDevice, &wDevType);
        //
        // special-case scanner items, They aren't enumerated in the namespace
        // so we have to build the dataobject directly
        if (!(lType & WiaItemTypeRoot) && wDevType == StiDeviceTypeScanner)
        {
            LPITEMIDLIST pidl = IMCreateScannerItemIDL (pItem, NULL);
            CImageDataObject *pido = new CImageDataObject (pItem);
            if (pido)
            {
                hr = pido->Init(NULL, 1,
                                const_cast<LPCITEMIDLIST*>(&pidl),
                                NULL);
                if (SUCCEEDED(hr))
                {
                    hr = pido->QueryInterface(IID_IDataObject,
                                              reinterpret_cast<LPVOID*>(&pdo));
                    ProgramDataObjectForExtension (pdo, pItem);
                }
                pido->Release ();
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = GetDataObjectForItem (pItem, &pdo);
        }
    }
    if (SUCCEEDED(hr))
    {

        aKeys[0] = GetGeneralUIKey (pDevice, WIA_UI_PROPSHEETHANDLER);
        aKeys[1] = GetDeviceUIKey (pDevice, WIA_UI_PROPSHEETHANDLER);
        for (int i=0;i<2;i++)
        {
            if (aKeys[i])
            {
                RegOpenKeyEx (aKeys[i],
                              c_szPropSheetHandler,
                              0,
                              KEY_READ,
                              &hSubkey);
                if (hSubkey)
                {
                    ExtendPropSheetFromKey (hSubkey, ppsh, pdo);
                    RegCloseKey (hSubkey);
                    hSubkey = NULL;
                }

                RegCloseKey (aKeys[i]);
            }
        }
    }

    if ((FAILED(hr) || !(ppsh->nPages)) && ppsh->phpage)
    {
        LocalFree(ppsh->phpage);
    }
    TraceLeaveResult (hr);

}



CPropSheetExt::CPropSheetExt ()
{
    TraceEnter (TRACE_PROPUI, "CPropSheetExt::CPropSheetExt");
    TraceLeave ();
}

CPropSheetExt::~CPropSheetExt ()
{
    TraceEnter (TRACE_PROPUI, "CPropSheetExt::~CPropSheetExt");
    TraceLeave ();

}

STDMETHODIMP
CPropSheetExt::QueryInterface (REFIID  riid,
                                LPVOID* ppvObj
                                )
{
    HRESULT hr;
    INTERFACES iface[]=
    {

        &IID_IShellExtInit,         static_cast<IShellExtInit*>(this),
        &IID_IShellPropSheetExt,    static_cast<IShellPropSheetExt*>(this)
    };

    TraceEnter( TRACE_PROPUI, "CPropSheetExt::QueryInterface" );

    hr = HandleQueryInterface(riid, ppvObj, iface, ARRAYSIZE(iface));

    TraceLeaveResult( hr );
}

#undef CLASS_NAME
#define CLASS_NAME CPropSheetExt
#include "unknown.inc"

/*****************************************************************************

   CPropSheetExt::Initialize

   Called by the shell to init the property sheet extension. Just store the
   data object for future use

 *****************************************************************************/

STDMETHODIMP
CPropSheetExt::Initialize (LPCITEMIDLIST   pidlFolder,
                           LPDATAOBJECT    lpdobj,
                           HKEY            hkeyProgID)
{
    HRESULT         hr   = S_OK;


    TraceEnter (TRACE_PROPUI, "CPropSheetExt::Initialize");
    if (!lpdobj)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        m_pdo = lpdobj;
    }
    TraceLeaveResult (hr);

}

// max. number of General tabs on one multi-sel sheet
#define MAX_PROPERTY_PAGES   12

STDMETHODIMP
CPropSheetExt::AddPages (LPFNADDPROPSHEETPAGE lpfnAddPage,LPARAM lParam)
{
    HRESULT                 hr = S_OK;
    LPIDA  pida= NULL;
    LPITEMIDLIST pidl = NULL;
    TraceEnter (TRACE_PROPUI, "CPropSheetExt::AddPages");
    //
    // Initialize the common controls
    //
    INITCOMMONCONTROLSEX ice;
    ice.dwSize = sizeof(ice);
    ice.dwICC = 0xfff; // just register everything, we might need them one day
    if (!InitCommonControlsEx (&ice))
    {
        Trace(TEXT("InitCommonControlsEx failed! Error: %x"), GetLastError());
    }


    //
    // Loop through the array of idlists indicated by the dataobject.
    // If only 1 item is in the list, add all its pages.
    // If more than 1 item is in the list, add the general page for that item
    //
    hr = GetIDAFromDataObject (m_pdo, &pida, true);
    if (SUCCEEDED(hr))
    {
        if (pida->cidl == 1)
        {
            pidl = reinterpret_cast<LPITEMIDLIST>(reinterpret_cast<LPBYTE>(pida) + pida->aoffset[1]);
            hr = AddPagesForIDL (pidl, false, lpfnAddPage, lParam);
        }
        else
        {
            for (UINT i=1;SUCCEEDED(hr) &&  i < MAX_PROPERTY_PAGES && i<=pida->cidl;i++)
            {
                pidl = reinterpret_cast<LPITEMIDLIST>(reinterpret_cast<LPBYTE>(pida) + pida->aoffset[i]);
                if (!IsContainerIDL(pidl) )
                {
                    hr = AddPagesForIDL (pidl, true, lpfnAddPage, lParam);
                }
            }
        }
    }
    if (pida)
    {
        LocalFree (pida);
    }
    TraceLeaveResult (hr);
}


HRESULT
CPropSheetExt::AddPagesForIDL (LPITEMIDLIST pidl,
                               bool bGeneralPageOnly,
                               LPFNADDPROPSHEETPAGE lpfnAddPage,
                               LPARAM lParam)
{
    HRESULT hr = S_OK;
    TraceEnter (TRACE_PROPUI, "CPropSheetExt::AddPagesForIDL");
    //
    // Handle WIA devices
    //
    if (!IsSTIDeviceIDL(pidl))
    {
        //
        // Get the IWiaItem * from the id list
        //
        CComPtr<IWiaItem> pItem;
        hr = IMGetItemFromIDL (pidl, &pItem, TRUE);
        if (SUCCEEDED(hr))
        {
            //
            // If this is a camera item (non-root) page, and it is not a folder
            //
            if (IsCameraItemIDL(pidl) && !IsContainerIDL(pidl))
            {
                //
                // Get the property that determines whether or not we should suppress this page
                // Ignore the return value, because if the item doesn't implement it,
                // nSuppressPropertyPages will still be 0, and the default is to display the property page
                //
                LONG nSuppressPropertyPages = 0;
                PropStorageHelpers::GetProperty( pItem, WIA_IPA_SUPPRESS_PROPERTY_PAGE, nSuppressPropertyPages );

                //
                // If the WIA_PROPPAGE_CAMERA_ITEM_GENERAL flag is not set for this item,
                // add the general camera item property page for it.
                //
                if ((nSuppressPropertyPages & WIA_PROPPAGE_CAMERA_ITEM_GENERAL) == 0)
                {
                    //
                    // we only have one page for pictures, so add it
                    //
                    CPropertyPage *pPage = new CWiaCameraItemPage (pItem);
                    if (pPage)
                    {
                        if (pPage->ItemSupported(pItem))
                        {
                            hr = pPage->AddPage(lpfnAddPage, lParam);
                        }
                        DoRelease(pPage);
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
            //
            // If this is a root (device) item
            //
            else if (IsDeviceIDL(pidl))
            {
                //
                // Get the device type
                //
                DWORD dwType = IMGetDeviceTypeFromIDL (pidl);

                if (!bGeneralPageOnly)
                {
                    hr = AddDevicePages (pItem, lpfnAddPage, lParam, dwType);
                }
                else
                {
                    //
                    // We are only going to add at most one page here, so if pPage is
                    // still NULL after we're done, we won't add any.
                    //
                    CPropertyPage *pPage = NULL;

                    switch (dwType)
                    {
                        default:
                        case StiDeviceTypeDefault:
                        case StiDeviceTypeScanner:
                            pPage = new CWiaScannerPage (pItem);
                            //
                            // If we can't create this page, we must be out of memory
                            //
                            if (!pPage)
                            {
                                hr = E_OUTOFMEMORY;
                            }
                            break;

                        case StiDeviceTypeDigitalCamera:
                        case StiDeviceTypeStreamingVideo:
                            pPage = new CWiaCameraPage (pItem);
                            //
                            // If we can't create this page, we must be out of memory
                            //
                            if (!pPage)
                            {
                                hr = E_OUTOFMEMORY;
                            }
                            break;
                    }

                    if (pPage)
                    {
                        hr = pPage->AddPage(lpfnAddPage,lParam, true);
                        DoRelease(pPage);
                    }
                }
            }
        }
    }
    //
    // Handle STI devices
    //
    else
    {
        MySTIInfo *pDevInfo;
        pDevInfo = new MySTIInfo;


        if (pDevInfo)
        {
            CSimpleStringWide strDeviceId;
            IMGetDeviceIdFromIDL (pidl, strDeviceId);
            pDevInfo->dwPageMask = bGeneralPageOnly ? STIPAGE_GENERAL : 0xffffffff;
            hr = GetSTIInfoFromId (strDeviceId, &pDevInfo->psdi);
            if (SUCCEEDED(hr))
            {
                hr = AddSTIPages (lpfnAddPage, lParam, pDevInfo);
            }

            pDevInfo->Release ();
        }

        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    TraceLeaveResult (hr);
}


HRESULT
CPropSheetExt::AddDevicePages(IWiaItem *pDevice, LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam, DWORD dwType)
{
    HRESULT hr = S_OK;
    TraceEnter(TRACE_PROPUI, "CPropSheetExt::AddDevicePages");
    CPropertyPage *pPage ;


    switch (dwType)
    {
        default:
        case StiDeviceTypeDefault:
        case StiDeviceTypeScanner:
            pPage = new CWiaScannerPage (pDevice);
            break;
        case StiDeviceTypeDigitalCamera:
        case StiDeviceTypeStreamingVideo:
            pPage = new CWiaCameraPage (pDevice);
            break;
    }
    if (pPage)
    {
        hr = pPage->AddPage(lpfnAddPage,lParam);
        pPage->Release ();

    }
    else
    {
        hr = E_OUTOFMEMORY;
    }
    // the general page is required. Other pages we can live without in low memory.
    if (SUCCEEDED(hr))
    {
        pPage = new CWiaEventsPage (pDevice);
        if (pPage)
        {
            if (pPage->ItemSupported(pDevice))
            {
                pPage->AddPage(lpfnAddPage, lParam);
            }
            pPage->Release ();
        }
        AddICMPage (lpfnAddPage, lParam);
    }
    TraceLeaveResult (hr);
}


/*****************************************************************************

   CPropSheetExt::AddStiPages

   Add the property sheets for the current STI device

 *****************************************************************************/


HRESULT
CPropSheetExt::AddSTIPages (LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam, MySTIInfo *pDevInfo)
{
    TraceEnter (TRACE_PROPUI, "CPropSheetExt::AddSTIPages");
    BOOL bIsPnP;
    CSTIGeneralPage *pGeneralPage = NULL;
    CPortSettingsPage *pPortPage = NULL;
    CEventMonitor *pEventPage = NULL;
    HRESULT hr = S_OK;

    CSimpleString csKey(IsPlatformNT() ? REGSTR_PATH_STIDEVICES_NT : REGSTR_PATH_STIDEVICES);
    csKey += TEXT("\\");
    csKey += CSimpleStringConvert::NaturalString(CSimpleStringWide(pDevInfo->psdi -> szDeviceInternalName));
    csKey += REGSTR_PATH_EVENTS;
    CSimpleReg regEvents (HKEY_LOCAL_MACHINE, csKey, false, KEY_READ );

    bIsPnP = IsPnPDevice (pDevInfo->psdi);

    // general page, for all devices
    if (pDevInfo->dwPageMask & STIPAGE_GENERAL)
    {

        pGeneralPage= new CSTIGeneralPage (pDevInfo, bIsPnP);
        if (pGeneralPage)
        {
            pGeneralPage->AddPage (lpfnAddPage, lParam);
        }
        else
        {
            ExitGracefully (hr, E_OUTOFMEMORY, "");
        }
    }
    if (pDevInfo->dwPageMask & STIPAGE_PORTS)
    {

        // port settings page for serial devices
        pPortPage = new CPortSettingsPage (pDevInfo);
        if (pPortPage && pPortPage->IsNeeded())
        {
            pPortPage->AddPage (lpfnAddPage, lParam);
        }
    }

    //  Only use the event page if there are events...



    if ((STIPAGE_EVENTS & pDevInfo->dwPageMask) && regEvents.SubKeyCount ())
    {
        pEventPage = new CEventMonitor (pDevInfo);
        if (pEventPage)
        {
            pEventPage->AddPage (lpfnAddPage, lParam);
        }

    }


    if ((STIPAGE_EXTEND & pDevInfo->dwPageMask) && pDevInfo->psdi->pszPropProvider)
    {
        HMODULE hmExtension;

        CDelimitedString dsInterface (CSimpleStringConvert::NaturalString (CSimpleStringWide(pDevInfo->psdi->pszPropProvider)),
                                      TEXT(","));
        if (dsInterface.Size() < 2)
        {
            dsInterface.Append (CSimpleString(TEXT("EnumStiPropPages")));

        }
        hmExtension = LoadLibrary (dsInterface[0]); // will stay loaded until process exit
        if (hmExtension)
        {
            typedef BOOL    (WINAPI *ADDER)(PSTI_DEVICE_INFORMATION psdi, FARPROC fp, LPARAM lp);

            ADDER   adder = reinterpret_cast<ADDER>( GetProcAddress(hmExtension, CSimpleStringConvert::AnsiString(dsInterface[1])));

            if  (!adder || !(*adder)(pDevInfo->psdi, reinterpret_cast<FARPROC> (lpfnAddPage), lParam))
            {
                FreeLibrary(hmExtension);
                hmExtension = NULL;
            }
        }
    }


    // Add the ICM page
    if (STIPAGE_ICM & pDevInfo->dwPageMask)
    {
        AddICMPage (lpfnAddPage, lParam);
    }



exit_gracefully:
    DoRelease (pGeneralPage);
    DoRelease (pPortPage);
    DoRelease (pEventPage);
    TraceLeaveResult (hr);
}


CONST GUID CLSID_SCANNERUI = {0x176d6597, 0x26d3, 0x11d1, 0xb3, 0x50, 0x08,
           0x00, 0x36, 0xa7, 0x5b, 0x03};

/**************************************

CPropSheetExt::AddICMPage

Add the ICM page for this device

***************************************/


HRESULT
CPropSheetExt::AddICMPage (LPFNADDPROPSHEETPAGE lpfnAddPage,LPARAM lParam)
{
    HRESULT hr = S_OK;
    CComQIPtr<IShellExtInit, &IID_IShellExtInit> pInit;
    CComPtr<IShellPropSheetExt> pExt ;
    TraceEnter (TRACE_PROPUI, "CWiaPropUI::AddICMPage");

    hr = CoCreateInstance (CLSID_SCANNERUI,
                            NULL,
                            CLSCTX_INPROC_SERVER,
                            IID_IShellPropSheetExt,
                            reinterpret_cast<LPVOID*>(&pExt)
                           );
    FailGracefully (hr, "No ICM handler registered");
    pInit = pExt;
    if (!pInit)
    {
        ExitGracefully (hr, E_FAIL, "");
    }
    hr = pInit->Initialize (NULL, m_pdo, NULL);
    FailGracefully (hr, "Initialize failed for ICM sheet");
    hr = pExt->AddPages (lpfnAddPage, lParam);



exit_gracefully:
    TraceLeaveResult (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\src\prpages.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999
 *
 *  TITLE:       prpages.cpp
 *
 *  VERSION:     1.0
 *
 *  DATE:        11/9/99
 *
 *  DESCRIPTION: WIA Property pages classes implementation
 *
 *****************************************************************************/
#include "precomp.hxx"
#include "uiexthlp.h"
#include "propstrm.h"
#include "psutil.h"
#include "winsvc.h"
#pragma hdrstop


void DeleteHandler(WIA_EVENT_HANDLER *peh)
{
    if (peh)
    {
        if (peh->bstrCommandline)
        {
            SysFreeString(peh->bstrCommandline);
        }
        if (peh->bstrDescription)
        {
            SysFreeString(peh->bstrDescription);
        }
        if (peh->bstrIcon)
        {
            SysFreeString(peh->bstrIcon);
        }
        if(peh->bstrName)
        {
            SysFreeString(peh->bstrName);
        }
        delete peh;
    }
}

/*****************************************************************************

    CPropertyPage::PropPageCallback

    Called by the system at various points of the propsheetpage's lifetime.
    We use this function to manage refcounts on the parent object.

*****************************************************************************/

UINT
CPropertyPage::PropPageCallback (HWND hwnd, UINT uMsg, PROPSHEETPAGE *psp)
{
    TraceEnter (TRACE_PROPUI, "CPropertyPage::PropPageCallback");
    CPropertyPage *pcpp = reinterpret_cast<CPropertyPage *>(psp->lParam);
    TraceAssert (pcpp);
    switch (uMsg)
    {
        case PSPCB_ADDREF:
            pcpp->AddRef ();
            break;

        case PSPCB_RELEASE:
            pcpp->Release();
            break;

        case PSPCB_CREATE:
        default:
            break;

    }
    TraceLeaveValue (1);
}

/*****************************************************************************

   CPropertyPage::DlgProc

   Pass messages to derived class virtual functions as appropriate.

 *****************************************************************************/


INT_PTR CALLBACK
CPropertyPage::DlgProc(HWND hwnd,
                       UINT uMsg,
                       WPARAM wp,
                       LPARAM lp)
{

    TraceEnter (TRACE_CORE, "CPropertyPage::DlgProc");
    Trace(TEXT("Msg: %x, wp:%x, lp:%x"), uMsg, wp, lp);
    CPropertyPage *pcpp = reinterpret_cast<CPropertyPage*>(GetWindowLongPtr(hwnd, DWLP_USER));
    INT_PTR iRet = TRUE;
    switch  (uMsg) {

        case    WM_INITDIALOG:
            pcpp = reinterpret_cast<CPropertyPage *>(reinterpret_cast<PROPSHEETPAGE *>( lp) -> lParam);

            SetWindowLongPtr(hwnd, DWLP_USER,reinterpret_cast<LONG_PTR>(pcpp));

            pcpp -> m_hwnd = hwnd;

            // We are in init mode
            pcpp->m_bInit = TRUE;
            iRet = pcpp -> OnInit();
            pcpp->SaveCurrentState ();
            // Init mode has completed
            pcpp->m_bInit = FALSE;
            break;

        case WM_HELP:      // F1

            pcpp->OnHelp (wp, lp);
            return TRUE;

        case WM_CONTEXTMENU:      // right mouse click
            pcpp->OnContextMenu (wp, lp);

            return TRUE;

        case  WM_COMMAND:
           iRet =  pcpp -> OnCommand(HIWORD(wp), LOWORD(wp), (HWND) lp);
           // ignore messages during initialization
           if (!(pcpp->m_bInit) && pcpp->StateChanged ())
           {
               pcpp->EnableApply ();

           }
           break;

        case  WM_NOTIFY:
        {

            LRESULT lResult = PSNRET_NOERROR;
            LPNMHDR lpnmh = reinterpret_cast<LPNMHDR>( lp);

            if (!pcpp->OnNotify(lpnmh, &lResult))
            {
                if  (lpnmh -> code == PSN_SETACTIVE)
                    pcpp -> m_hwndSheet = lpnmh -> hwndFrom;

                LPPSHNOTIFY pn = reinterpret_cast<LPPSHNOTIFY>(lp);
                Trace (TEXT("CPropertyPage::DlgProc :WM_NOTIFY. code=%d, lParam=%d"), pn->hdr.code, pn->lParam);

                switch (pn->hdr.code)
                {
                    case PSN_APPLY:
                        if (pcpp->StateChanged())
                        {
                            pcpp->SaveCurrentState ();
                            lResult = pcpp->OnApplyChanges (static_cast<BOOL>(pn->lParam));
                        }
                        break;

                    case PSN_SETACTIVE:
                        lResult = pcpp->OnSetActive ();

                        break;

                    case PSN_QUERYCANCEL:
                        lResult = pcpp->OnQueryCancel();
                        break;

                    case PSN_KILLACTIVE:
                        lResult = pcpp->OnKillActive ();
                        break;

                    case PSN_RESET:
                        pcpp->OnReset (!(pn->lParam));
                        break;

                    default:
                        lResult = PSNRET_NOERROR;
                        iRet = FALSE;
                        break;
                }
            }
            SetWindowLongPtr (hwnd, DWLP_MSGRESULT, lResult);

        }
        break;

        case    WM_MEASUREITEM: {
            #define MINIY       16
            #define MINIX       16


            // Code lifted from setupx
            // WARNING...this message occurs before WM_INITDIALOG and is not virtualized...
            // ...it could be but don't try to use pcpp.

            LPMEASUREITEMSTRUCT lpMi;
            SIZE                size;
            HDC                 hDC;

            hDC  = GetDC(hwnd);
            if (hDC)
            {

                lpMi = reinterpret_cast<LPMEASUREITEMSTRUCT>(lp);

                SelectFont(hDC, GetWindowFont(GetParent(hwnd)));
                GetTextExtentPoint32(hDC, TEXT("X"), 1, &size);

                // size is the max of character size of shell icon size plus the border
                lpMi->itemHeight = max(size.cy, MINIY) + GetSystemMetrics(SM_CYBORDER) * 2;

                ReleaseDC(hwnd, hDC);
            }
        }
        break;

        case WM_DRAWITEM:
            pcpp -> OnDrawItem(reinterpret_cast<LPDRAWITEMSTRUCT>(lp));
            break;

        case WM_DESTROY:
        {
            // Delete the icon resource we loaded to put into the page...

            HICON hIcon;

            hIcon = reinterpret_cast<HICON>(SendDlgItemMessage (hwnd, IDC_ITEMICON, STM_SETICON, 0, 0));

            if (hIcon)
            {
                DestroyIcon(hIcon);
            }
        }
        break;

        default:

            if (pcpp)
            {
                iRet = pcpp->OnRandomMsg (uMsg, wp, lp);
                // ignore messages during initialization
                if (!(pcpp->m_bInit) && pcpp->StateChanged ())
                {
                    pcpp->EnableApply ();
                }
            }
            else
            {
                iRet = FALSE;
            }
            break;
    }
    TraceLeave ();
    return iRet;

}



/*****************************************************************************

   CPropertyPage constructor / destructor

   Init private data, etc.

 *****************************************************************************/

CPropertyPage::CPropertyPage(unsigned uResource,
                             MySTIInfo *pDevInfo,
                             IWiaItem *pItem,
                             const DWORD *pHelpIDs)
{
    TraceEnter (TRACE_PROPUI, "CPropertyPage::CPropertyPage");

    CComPtr<IWiaItem> pDevice;

    TraceAssert (pDevInfo || pItem);
    m_pdwHelpIDs = pHelpIDs;
    m_bInit = FALSE;
    m_pDevInfo = pDevInfo;
    if (pDevInfo)
    {
        m_psdi = pDevInfo->psdi;
        pDevInfo->AddRef();
    }
    else
    {
        m_psdi = NULL;
    }

    m_psp.hInstance = GLOBAL_HINSTANCE;
    m_psp.dwSize = sizeof(m_psp);
    m_psp.dwFlags = PSP_DEFAULT | PSP_USECALLBACK;
    m_psp.pszTemplate = MAKEINTRESOURCE(uResource);

    m_psp.pfnDlgProc = DlgProc;
    m_psp.lParam = (LPARAM) this;
    m_psp.pfnCallback = PropPageCallback;

    m_hwnd = m_hwndSheet = NULL;
    m_hpsp = NULL;
    if (pItem)
    {
        m_pItem = pItem;
        CComPtr<IWiaItem> pRoot;
        pItem->GetRootItem (&pRoot);
        PropStorageHelpers::GetProperty (pRoot, WIA_DIP_DEV_ID,   m_strDeviceId);
        PropStorageHelpers::GetProperty (pRoot, WIA_DIP_UI_CLSID, m_strUIClassId);
    }

    m_cRef = 1;
    TraceLeave ();
}

CPropertyPage::~CPropertyPage ()
{
    TraceEnter (TRACE_PROPUI, "CPropertyPage::~CPropertyPage");
    LONG cRef;

    if (m_pDevInfo)
    {
        m_pDevInfo->Release();
    }
    TraceLeave ();
}

/*****************************************************************************

   CPropertyPage::AddRef

   <Notes>

 *****************************************************************************/

LONG
CPropertyPage::AddRef ()
{
    return InterlockedIncrement (&m_cRef);
}


/*****************************************************************************

   CPropertyPage::Release

   <Notes>

 *****************************************************************************/

LONG
CPropertyPage::Release ()
{
    LONG lRet;
    lRet = InterlockedDecrement (&m_cRef);
    if (!lRet)
    {
        delete this;
    }
    return lRet;

}

HRESULT
CPropertyPage::AddPage (LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam, bool bUseName)
{
    CSimpleStringWide strValue;
    // override the tab label with the name of the item if requested
    if (bUseName)
    {

        if (m_pDevInfo)
        {
            m_psp.dwFlags |= PSP_USETITLE;
            m_psp.pszTitle = m_pDevInfo->psdi->pszLocalName;
        }
        else
        {
            LONG lType;
            PROPID pid;

            m_pItem->GetItemType(&lType);
            if (lType & WiaItemTypeRoot)
            {
                pid = WIA_DIP_DEV_NAME;
            }
            else
            {
                pid = WIA_IPA_ITEM_NAME;
            }
            if (PropStorageHelpers::GetProperty(m_pItem, pid, strValue ))
            {
                m_psp.dwFlags |= PSP_USETITLE;
                m_psp.pszTitle = strValue.String();
            }
        }
    }
    if   (!m_hpsp)
        m_hpsp = CreatePropertySheetPage(&m_psp);

    if  (!m_hpsp)
        return  E_FAIL;

    return (*lpfnAddPage)(m_hpsp, lParam) ? S_OK: E_FAIL;

}
void
CPropertyPage::EnableApply ()
{
    PropSheet_Changed (m_hwndSheet, m_hwnd);
}


//
// Define a struct associating a dialog control with a property
//
struct CONTROLPROP
{
    DWORD dwPropid;
    SHORT resId;
};

typedef CONTROLPROP *PCONTROLPROP;

//
// Define a function for updating the page in ways the CONTROLPROP array can't
//
typedef VOID (CALLBACK *UPDATEPROC)(HWND, BOOL, IWiaPropertyStorage*);
//
// Now define a struct containing the CONTROLPROP array
// and UPDATEPROC for a page
//
struct PAGEDATA
{
    UPDATEPROC pfnUpdate;
    PCONTROLPROP pProps;
    INT   nProps;
};

VOID CALLBACK CameraUpdateProc (      HWND hwnd, BOOL bInit, IWiaPropertyStorage *pps);
VOID CALLBACK CameraItemUpdateProc (  HWND hwnd, BOOL bInit, IWiaPropertyStorage *pps);
VOID CALLBACK CameraFolderUpdateProc (HWND hwnd, BOOL bInit, IWiaPropertyStorage *pps);
VOID CALLBACK ScannerUpdateProc (     HWND hwnd, BOOL bInit, IWiaPropertyStorage *pps);


static CONTROLPROP CameraProps[] =
{
    {WIA_DIP_DEV_DESC,           IDC_DESCRIPTION},
    {WIA_DPC_BATTERY_STATUS,     IDC_BATTERY},
    {WIA_DIP_VEND_DESC,          IDC_MANUFACTURER},
    {WIA_DIP_PORT_NAME,          IDC_WIA_PORT_STATIC},

};


static CONTROLPROP CameraItemProps[] =
{
    {WIA_IPA_ITEM_NAME,          IDC_IMAGE_NAME},
    {WIA_IPA_ITEM_TIME,          IDC_IMAGE_TIME}
};

static CONTROLPROP CameraFolderProps[] =
{
{0,0}
};


static CONTROLPROP ScannerProps[] =
{
{WIA_DIP_DEV_DESC, IDC_DESCRIPTION},
{WIA_DIP_VEND_DESC, IDC_MANUFACTURER},
{WIA_DIP_PORT_NAME, IDC_WIA_PORT_STATIC},
};

static const PAGEDATA PropPages[] =
{
    {CameraUpdateProc,          CameraProps,        ARRAYSIZE(CameraProps)},
    {ScannerUpdateProc,         ScannerProps,       ARRAYSIZE(ScannerProps)},
    {CameraItemUpdateProc,      CameraItemProps,    ARRAYSIZE(CameraItemProps)},
    {CameraFolderUpdateProc,    CameraFolderProps,  ARRAYSIZE(CameraFolderProps)},
};

enum EPageIndex
{
    kCamera = 0,
    kScanner = 1,
    kCameraItem = 2,
    kCameraFolder = 3,
};



/*****************************************************************************

   GetPageData

   Returns PAGEDATA struct appropriate for the type of item or device

 *****************************************************************************/


const PAGEDATA *
GetPageData (IWiaItem *pWiaItemRoot, IWiaItem *pItem)
{
    LONG lItemType = WiaItemTypeImage;
    WORD wDeviceType;
    EPageIndex idx = kCamera;
    TraceEnter (TRACE_PROPUI, "GetPageData");
    if (pItem)
    {
        pItem->GetItemType (&lItemType);
    }

    GetDeviceTypeFromDevice (pWiaItemRoot, &wDeviceType);
    switch (wDeviceType)
    {
        case StiDeviceTypeScanner:
            TraceAssert (!pItem);
            idx = kScanner;
            break;
        case StiDeviceTypeStreamingVideo:
        case StiDeviceTypeDigitalCamera:
            if (!pItem)
            {
                idx = kCamera;
            }
            else if (lItemType & (WiaItemTypeImage | WiaItemTypeVideo | WiaItemTypeFile))
            {
                idx = kCameraItem;
            }
            else if (lItemType & WiaItemTypeFolder)
            {
                idx = kCameraFolder;
            }
            else
            {
                Trace (TEXT("Unknown item type in GetPageData"));
            }
            break;
        default:
            Trace (TEXT("Unknown device type in GetPageData"));
            break;
    }
    TraceLeave ();
    return &PropPages[idx];
}


/*****************************************************************************

   ConstructPortChoices
   Builds a list of ports this device can be on, if they can be changed.

 *****************************************************************************/

static LPCWSTR caPortSpeeds [] =
{L"9600",
 L"19200",
 L"38400",
 L"57600",
 L"115200",
 NULL,
};

VOID
ConstructPortChoices (HWND                 hwnd,
                      LPCWSTR              szPortSpeed,
                      IWiaPropertyStorage* pps)
{
    TraceEnter (TRACE_PROPUI, "ConstructPortChoices");
    #ifdef UNICODE
    Trace(TEXT("passed in szPortSpeed is %s"),(szPortSpeed && (*szPortSpeed)) ? szPortSpeed : TEXT("<NULL>"));
    #endif

    CComQIPtr<IWiaItem, &IID_IWiaItem> pItem(pps);
    CWiaCameraPage * pWiaCamPage = (CWiaCameraPage *)GetWindowLongPtr( hwnd, DWLP_USER );


    if (!pps || !pWiaCamPage)
    {
        Trace(TEXT("bad params -- pProps | pps is NULL"));
        goto exit_gracefully;
    }

    //
    // Get current port name
    //
    GetDlgItemText(hwnd, IDC_WIA_PORT_STATIC, pWiaCamPage->m_szPort, ARRAYSIZE(pWiaCamPage->m_szPort));

    Trace(TEXT("pWiaCamPage->m_szPort is '%s'"),pWiaCamPage->m_szPort);
    wcsncpy(pWiaCamPage->m_szPortSpeed, szPortSpeed, ARRAYSIZE(pWiaCamPage->m_szPortSpeed));
    //
    // Get list of all possible ports
    //
    WCHAR szDeviceId[ MAX_PATH ];
    *szDeviceId = 0;

    if (pItem)
    {
        PWIA_PORTLIST pWiaPorts = NULL;

        GetDeviceIdFromDevice( pItem, szDeviceId );
        if (pWiaCamPage->m_pfnWiaCreatePortList && pWiaCamPage->m_pfnWiaDestroyPortList)
        {
            pWiaPorts = pWiaCamPage->m_pfnWiaCreatePortList( szDeviceId );

            if (pWiaPorts)
            {
                //
                // Clear out any old port lists
                //

                SendDlgItemMessage( hwnd, IDC_WIA_PORT_LIST, CB_RESETCONTENT, 0, 0 );

                //
                // Add each possible port to the combobox
                //

                for (INT i=0; i < (INT)(pWiaPorts->dwNumberOfPorts); i++)
                {
                    #ifdef UNICODE
                    SendMessage( GetDlgItem( hwnd, IDC_WIA_PORT_LIST ), CB_ADDSTRING, 0, (LPARAM)pWiaPorts->szPortName[i] );
                    #else
                    CHAR sz[ 64 ];

                    WideCharToMultiByte( CP_ACP, 0, pWiaPorts->szPortName[i], -1, sz, ARRAYSIZE(sz), NULL, NULL );
                    SendMessage( GetDlgItem( hwnd, IDC_WIA_PORT_LIST ), CB_ADDSTRING, 0, (LPARAM)sz );
                    #endif
                }

                //
                // Select the current port
                //

                if (CB_ERR != SendMessage( GetDlgItem( hwnd, IDC_WIA_PORT_LIST ), CB_SELECTSTRING, (WPARAM)-1, (LPARAM)pWiaCamPage->m_szPort ))
                {
                    ShowWindow(GetDlgItem(hwnd, IDC_WIA_PORT_LIST), SW_SHOW);
                    ShowWindow(GetDlgItem(hwnd, IDC_WIA_PORT_STATIC), SW_HIDE);
                }

                pWiaCamPage->m_pfnWiaDestroyPortList( pWiaPorts );

                ShowWindow(GetDlgItem(hwnd, IDC_BATTERY_LABEL), SW_HIDE);
                ShowWindow(GetDlgItem(hwnd, IDC_BATTERY), SW_HIDE);
                ShowWindow(GetDlgItem(hwnd, IDC_PORT_SPEED), SW_SHOW);
                ShowWindow(GetDlgItem(hwnd, IDC_PORT_SPEED_LABEL), SW_SHOW);

                //
                // Reset port speed list
                //

                SendDlgItemMessage( hwnd, IDC_PORT_SPEED, CB_RESETCONTENT, 0, 0 );

                //
                // Fill the list of port speeds
                //

                for (LPCWSTR *ppszPort=caPortSpeeds;*ppszPort;ppszPort++)
                {
                    SendDlgItemMessage(hwnd, IDC_PORT_SPEED, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(*ppszPort));
                }
                if (szPortSpeed && *szPortSpeed)
                {
                    Trace(TEXT("Selecting port speed of %s"),szPortSpeed);
                    SendDlgItemMessage(hwnd, IDC_PORT_SPEED, CB_SELECTSTRING, (WPARAM)-1, reinterpret_cast<LPARAM>(szPortSpeed));
                }
            }
        }
    }
exit_gracefully:
    TraceLeave();
}


/*****************************************************************************

   FillPropsFromStorage
   Given the array of property IDs and resources,
   fill in the data

 *****************************************************************************/

VOID
FillPropsFromStorage (HWND              hwnd,
                      PCONTROLPROP      pProps,
                      INT               nProps,
                      IWiaPropertyStorage* pps,
                      DWORD             dwFlags)
{

    PROPVARIANT *ppv;
    PROPSPEC    *pSpec;
    INT          i;
    WORD         wId;

    TraceEnter (TRACE_PROPUI, "FillPropsFromStorage");

    ppv   = new PROPVARIANT[nProps];
    pSpec = new PROPSPEC[nProps];

    if (!ppv || !pSpec)
    {
        Trace (TEXT("Out of memory in FillPropsFromStorage"));
        goto exit_gracefully;
    }
    ZeroMemory (ppv, sizeof(PROPSPEC)*nProps);
    // fill in the PROPSPEC array
    for (i=0;i<nProps;i++)
    {
        pSpec[i].ulKind = PRSPEC_PROPID;
        pSpec[i].propid = pProps[i].dwPropid;
    }
    // Query for the properties
    if (SUCCEEDED(pps->ReadMultiple (nProps, pSpec, ppv)))
    {
        // loop through the properties, filling in controls
        for (i=0;i<nProps;i++)
        {
            wId = pProps[i].resId;
            switch (ppv[i].vt)
            {
                case VT_LPWSTR:
                    #ifdef UNICODE
                    SetDlgItemText (hwnd,
                                    wId,
                                    ppv[i].pwszVal);
                    #else
                    {
                        CHAR sz[ MAX_PATH ];
                        WideCharToMultiByte (CP_ACP, 0, ppv[i].pwszVal,
                                             -1, sz, ARRAYSIZE(sz),
                                             NULL, NULL );
                        SetDlgItemText (hwnd, wId, sz);
                    }
                    #endif // UNICODE
                    break;
                case VT_BSTR:
                    #ifdef UNICODE
                    SetDlgItemText (hwnd,
                                    wId,
                                    ppv[i].bstrVal);
                    #else
                    {
                        CHAR sz[ MAX_PATH ];
                        WideCharToMultiByte (CP_ACP, 0, ppv[i].bstrVal,
                                             -1, sz, ARRAYSIZE(sz),
                                             NULL, NULL );
                        SetDlgItemText (hwnd, wId, sz);
                    }
                    #endif
                    break;

                case VT_I4:
                    SetDlgItemInt (hwnd,
                                   wId,
                                   static_cast<UINT>(ppv[i].lVal),
                                   TRUE);
                    break;

                case VT_UI4:
                    SetDlgItemInt (hwnd,
                                   wId,
                                   ppv[i].ulVal,
                                   TRUE);
                    break;
                case VT_FILETIME:
                default:
                    Trace(TEXT("Unexpected property type for %d in FillPropsFromStorage %x"), pSpec[i].propid, ppv[i].vt);
                    break;
            }
            if (dwFlags & PROPUI_READONLY)
            {
                EnableWindow (GetDlgItem (hwnd,wId),
                              FALSE);
            }
        }
    }
    else
    {
        Trace (TEXT("ReadMultiple failed in FillPropsFromStorage"));
    }
exit_gracefully:
    if (pSpec)
    {
        delete [] pSpec;
    }
    FreePropVariantArray (nProps, ppv);
    if (ppv)
    {
        delete [] ppv;
    }
    TraceLeave();
}


/*****************************************************************************

   FillItemGeneralProps

   Given an IWiaItem, fill in the General prop page for it

 *****************************************************************************/

VOID
FillItemGeneralProps (HWND      hwnd,
                      IWiaItem* pWiaItemRoot,
                      IWiaItem* pItem,
                      DWORD     dwFlags)
{
    const PAGEDATA  *pPage;

    TraceEnter (TRACE_PROPUI, "FillItemGeneralProps");

    CComQIPtr<IWiaPropertyStorage, &IID_IWiaPropertyStorage> pps(pItem);
    pPage = GetPageData (pWiaItemRoot,pItem);
    if (pps && pPage)
    {
        FillPropsFromStorage (hwnd,
                              pPage->pProps,
                              pPage->nProps,
                              pps,
                              dwFlags);

        // invoke the update proc
        (pPage->pfnUpdate)(hwnd, TRUE, pps);
    }

    TraceLeave();
}


/*****************************************************************************

   FillCameraGeneralProps

   Fill in the General prop page for the camera device

 *****************************************************************************/

VOID
FillDeviceGeneralProps (HWND        hwnd,
                        IWiaItem*   pWiaItemRoot,
                        DWORD       dwFlags)
{
    const PAGEDATA   *pPage;

    TraceEnter (TRACE_PROPUI, "FillDeviceGeneralProps");

    CComQIPtr<IWiaPropertyStorage, &IID_IWiaPropertyStorage> pps(pWiaItemRoot);
    pPage = GetPageData (pWiaItemRoot, NULL);

    if (pps && pPage)
    {
        FillPropsFromStorage (hwnd,
                              pPage->pProps,
                              pPage->nProps,
                              pps,
                              dwFlags);

        // invoke the update proc
        (pPage->pfnUpdate)(hwnd, TRUE, pps);
    }

    TraceLeave();
}

// define a  struct to match WIA flash modes with friendly strings
// relies on FLASHMODE_* being 1-based enumeration
struct FMODE
{
    INT iMode;
    UINT idString;
} cFlashModes [] =
{
    FLASHMODE_AUTO, IDS_FLASHMODE_AUTO,
    FLASHMODE_OFF, IDS_FLASHMODE_OFF,
    FLASHMODE_FILL, IDS_FLASHMODE_FILL,
    FLASHMODE_REDEYE_AUTO, IDS_FLASHMODE_REDEYE_AUTO,
    FLASHMODE_REDEYE_FILL, IDS_FLASHMODE_REDEYE_FILL,
    FLASHMODE_EXTERNALSYNC, IDS_FLASHMODE_EXTERNALSYNC,
    0, IDS_FLASHMODE_DEVICE,
};

/*****************************************************************************

    FillFlashList

    Given the valid values for the flash property, fill in the listbox
    with friendly strings

*****************************************************************************/

VOID
FillFlashList (HWND hwnd, const PROPVARIANT &pvValues, INT iMode)
{
    TraceEnter (TRACE_PROPUI, "FillFlashList");
    INT iTemp;
    CSimpleString strMode;
    TCHAR szNum[10];
    LRESULT lPos;
    Trace(TEXT("Flash mode has %d values"), WIA_PROP_LIST_COUNT(&pvValues));
    ShowWindow(hwnd, SW_SHOW);
    for (size_t i=0;i<WIA_PROP_LIST_COUNT(&pvValues);i++)
    {
        iTemp = pvValues.caul.pElems[WIA_LIST_VALUES + i];
        if (iTemp >= ARRAYSIZE(cFlashModes)) // it's a custom mode
        {
            strMode.LoadString(IDS_FLASHMODE_DEVICE, GLOBAL_HINSTANCE);
            strMode.Concat (_itot(iTemp, szNum, 10));
        }
        else
        {
            strMode.LoadString(cFlashModes[iTemp-1].idString, GLOBAL_HINSTANCE);
        }
        // add the string to the list
        lPos = SendMessage (hwnd, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(strMode.String()));
        if (lPos != CB_ERR)
        {
            // associate its mode with it
            SendMessage (hwnd, CB_SETITEMDATA, lPos, iTemp);
            if (iTemp == iMode)
            {
                // set the current selection
                SendMessage (hwnd, CB_SETCURSEL, lPos, 0);
            }
        }
    }
    TraceLeave ();
}
/*****************************************************************************

    UpdateFlashMode

    Updates the flash mode controls on the camera general page. If the device
    supports Write access to the property AND provides a set of valid values,
    we enable the list box and fill it in with friendly names of the flash modes.
    For modes whose values fall outside the set of standard WIA identifiers,
    we substitute "Device Mode #", where # starts at 1 .

*****************************************************************************/
VOID
UpdateFlashMode (HWND hwnd, INT iMode, ULONG ulFlags, const PROPVARIANT &pvValues)
{
    TraceEnter (TRACE_PROPUI, "UpdateFlashMode");

    // First get the current mode string
    FMODE *pMode;
    CSimpleString strMode;
    TCHAR szNum[MAX_PATH];
    for (pMode = cFlashModes;pMode->iMode && iMode != pMode->iMode;pMode++);//intentional
    strMode.LoadString (pMode->idString, GLOBAL_HINSTANCE);
    if (pMode->idString == IDS_FLASHMODE_DEVICE)
    {
        strMode.Concat (_itot(iMode, szNum, 10));
    }
    if (!(ulFlags & WIA_PROP_WRITE) || !(ulFlags & WIA_PROP_LIST))
    {
        strMode.SetWindowText(GetDlgItem (hwnd, IDC_FLASH_MODE_STATIC));
        ShowWindow (GetDlgItem (hwnd, IDC_FLASH_MODE_LIST), SW_HIDE);
    }
    else
    {
        ShowWindow (GetDlgItem(hwnd, IDC_FLASH_MODE_STATIC), SW_HIDE);
        FillFlashList (GetDlgItem(hwnd, IDC_FLASH_MODE_LIST), pvValues, iMode);
    }
    TraceLeave ();
}


VOID
UpdateTimeStatic(HWND hwnd, PROPVARIANT *ppv)
{
    TCHAR szTime[MAX_PATH] = TEXT("");
    TCHAR szDate[MAX_PATH] = TEXT("");

    TimeToStrings (reinterpret_cast<SYSTEMTIME*>(ppv->caub.pElems),
                   szTime, szDate);
    CSimpleString strText;
    strText.Format (TEXT("%s, %s"), szDate, szTime);
    strText.SetWindowText(GetDlgItem (hwnd, IDC_CURRENT_TIME));

}
/*****************************************************************************

   CameraUpdateProc

   Update controls in the camera General tab. Doesn't touch the picture size
   slider because that control needs data that is private to the CWiaCameraPage
   object.

 *****************************************************************************/

VOID CALLBACK
CameraUpdateProc (HWND              hwnd,
                  BOOL              bInit,
                  IWiaPropertyStorage* pps)
{

    TraceEnter (TRACE_PROPUI, "CameraUpdateProc");
    UINT    iConnect;

    CSimpleString   strTemp;

    // read more properties that require special formatting
    static PROPSPEC ps[] = {{PRSPEC_PROPID,WIA_DPC_PICTURES_TAKEN},
                            {PRSPEC_PROPID,WIA_DPC_PICTURES_REMAINING},
                            {PRSPEC_PROPID,WIA_DPC_FLASH_MODE},
                            {PRSPEC_PROPID,WIA_DPA_DEVICE_TIME},
                            {PRSPEC_PROPID,WIA_DPC_POWER_MODE},
                            {PRSPEC_PROPID,WIA_DIP_DEV_ID}}; // this is so we can get port choices


    PROPVARIANT pv[ARRAYSIZE(ps)];
    ZeroMemory (pv, sizeof(pv));
    if (pps && SUCCEEDED(pps->ReadMultiple(ARRAYSIZE(ps), ps, pv)))
    {
        CSimpleString strFormat;
        PROPVARIANT pvValidValues[ARRAYSIZE(ps)];
        ULONG ulFlags[ARRAYSIZE(ps)];

        pps->GetPropertyAttributes(ARRAYSIZE(ps), ps, ulFlags, pvValidValues);
        // Pictures taken/remaining aren't supported by all cameras, so
        // make sure those propvariants are populated before
        // constructing the string
        if (pv[0].vt != VT_EMPTY) // num taken is supported
        {
            if (pv[1].vt != VT_EMPTY && pv[1].lVal >= 0) // num remaining is supported
            {
                strFormat.LoadString(IDS_PICTURE_COUNT, GLOBAL_HINSTANCE);
                strTemp.Format (strFormat, pv[0].lVal, pv[0].lVal + pv[1].lVal);
            }
            else
            {
                // just show number taken
                strTemp.Format (TEXT("%d"), pv[0].ulVal);
            }
            strTemp.SetWindowText (GetDlgItem(hwnd, IDC_TAKEN));
        }

        // Update the flash mode
        if (pv[2].vt != VT_EMPTY)
        {
            UpdateFlashMode (hwnd, pv[2].intVal, ulFlags[2], pvValidValues[2]);
        }

        // Show the device time if supported. Also, if the time property is R/W,
        // enable the button
        if (pv[3].vt != VT_EMPTY && pv[3].caub.cElems)
        {
            UpdateTimeStatic(hwnd, &pv[3]);
            ShowWindow (GetDlgItem(hwnd, IDC_SET_TIME), (ulFlags[3] & WIA_PROP_WRITE) ? SW_SHOW : SW_HIDE);
        }

        // Show the current power source ,if available
        if (pv[4].vt != VT_EMPTY)
        {
            strTemp.GetWindowText(GetDlgItem(hwnd, IDC_BATTERY));
            if (strTemp.String()[0] != TEXT('(')) // battery status is a number
            {
                CSimpleString strMode;
                strMode.LoadString(pv[4].vt == POWERMODE_BATTERY ? IDS_ON_BATTERY : IDS_PLUGGED_IN,
                                   GLOBAL_HINSTANCE);
                strTemp.Concat(strMode);
                strTemp.SetWindowText(GetDlgItem(hwnd, IDC_BATTERY));
            }
        }


        // if we got a device id, then look for com port settings
        if (pv[5].vt != VT_EMPTY)
        {
            // Get a property storage on the device node to check for com port/baudrate
            CComPtr<IWiaPropertyStorage> ppsDev;
            if (SUCCEEDED(GetDeviceFromDeviceId( pv[5].pwszVal, IID_IWiaPropertyStorage, reinterpret_cast<LPVOID *>(&ppsDev), FALSE )) && ppsDev)
            {
                static PROPSPEC psDev[] = {{PRSPEC_PROPID, WIA_DIP_HW_CONFIG},
                                           {PRSPEC_PROPID, WIA_DIP_BAUDRATE}};

                PROPVARIANT pvDev[ARRAYSIZE(psDev)];
                ZeroMemory (pvDev, sizeof(pvDev));

                // Read port & baudrate
                if (SUCCEEDED(ppsDev->ReadMultiple(ARRAYSIZE(psDev), psDev, pvDev)))
                {
                    if (pvDev[0].vt != VT_EMPTY)
                    {
                        if (pvDev[0].ulVal & STI_HW_CONFIG_SERIAL)
                        {
                            // purposely using pps, instead of ppsDev
                            ConstructPortChoices( hwnd, pvDev[1].pwszVal, pps );
                        }
                    }

                }

            }
        }

    }




    TraceLeave ();
}

/*****************************************************************************

    GetItemSize

    Queries the item for its size when transferred via preferred format and media
    type

*****************************************************************************/

UINT GetItemSize(IWiaPropertyStorage *pps)
{
    CComQIPtr<IWiaItem, &IID_IWiaItem> pItem(pps);
    // Save the current property stream in case changing
    // the transfer format alters it badly.
    CAutoRestorePropertyStream arps(pItem);
    GUID guidFmt;
    LONG lVal = 0;
    //
    // Query the preferred format and tymed and set them as the current
    // values for the item, then query the size
    //
    PropStorageHelpers::GetProperty(pItem, WIA_IPA_PREFERRED_FORMAT, guidFmt);
    PropStorageHelpers::SetProperty(pItem, WIA_IPA_FORMAT,  guidFmt);
    PropStorageHelpers::GetProperty(pItem, WIA_IPA_ITEM_SIZE, lVal);
    return static_cast<UINT>(lVal);
}
/*****************************************************************************

   CameraItemUpdateProc

   <Notes>

 *****************************************************************************/

VOID CALLBACK
CameraItemUpdateProc (HWND hwnd, BOOL bInit, IWiaPropertyStorage *pps)
{


    TCHAR       szDate[MAX_PATH] = TEXT("");
    TCHAR       szTime[MAX_PATH] = TEXT("");

    PROPVARIANT pv[2];
    PROPSPEC    ps[2];
    SYSTEMTIME  st;

    TraceEnter (TRACE_PROPUI, "CameraItemUpdateProc");

    // Convert the size string to something friendly
    UINT uSize = GetItemSize (pps);
    StrFormatByteSize (uSize, szDate, ARRAYSIZE(szDate));
    SetDlgItemText (hwnd, IDC_IMAGE_SIZE, szDate);
    *szDate = TEXT('\0');
    // Get the FILETIME and convert to something readable
    ps[0].ulKind = ps[1].ulKind = PRSPEC_PROPID;
    ps[0].propid = WIA_IPA_ITEM_TIME;
    ps[1].propid = WIA_IPA_PREFERRED_FORMAT;
    if (S_OK == (pps->ReadMultiple (ARRAYSIZE(ps), ps, pv)))
    {

        if (pv[0].vt > VT_NULL &&  pv[0].caub.pElems && pv[0].caub.cElems)
        {
            st  = *(reinterpret_cast<SYSTEMTIME *>(pv[0].caub.pElems));
            TimeToStrings (&st, szTime, szDate);
        }

        SetDlgItemText( hwnd, IDC_IMAGE_DATE, szDate );
        SetDlgItemText( hwnd, IDC_IMAGE_TIME, szTime );

        //
        // Map the format GUID to an extension and file format description
        //
        if (pv[1].puuid)
        {
            CComQIPtr<IWiaItem, &IID_IWiaItem>pItem(pps);
            CSimpleString strExt = CSimpleString(TEXT(".")) + WiaUiExtensionHelper::GetExtensionFromGuid(pItem,*pv[1].puuid);
            DWORD cch = ARRAYSIZE(szDate);
            CSimpleString strDesc;
            if (SUCCEEDED(AssocQueryString(0, ASSOCSTR_FRIENDLYDOCNAME, strExt, NULL, szDate, &cch)))
            {
                strDesc = szDate;
            }
            else
            {
                strDesc.LoadString(IDS_OTHER_FORMAT, GLOBAL_HINSTANCE);
            }
            strDesc.SetWindowText (GetDlgItem (hwnd, IDC_IMAGE_FORMAT));
        }
        FreePropVariantArray (ARRAYSIZE(pv), pv);
    }
    TraceLeave ();

}



/*****************************************************************************

   CameraFolderUpdateProc

   <Notes>

 *****************************************************************************/

VOID CALLBACK
CameraFolderUpdateProc (HWND hwnd, BOOL bInit, IWiaPropertyStorage *pps)
{

    TraceEnter (TRACE_PROPUI, "CameraFolderUpdateProc");
    TraceLeave ();

}


/*****************************************************************************

   ScannerUpdateProc

   <Notes>

 *****************************************************************************/

VOID CALLBACK
ScannerUpdateProc (HWND hwnd, BOOL bInit, IWiaPropertyStorage *pps)
{

    TraceEnter (TRACE_PROPUI, "ScannerUpdateProc");
    // need the STI device status and the X and Y optical resolution
    static const PROPSPEC ps[3] = {{PRSPEC_PROPID, WIA_DPS_OPTICAL_XRES},
                            {PRSPEC_PROPID, WIA_DPS_OPTICAL_YRES},
                            {PRSPEC_PROPID, WIA_DIP_DEV_ID}};

    PROPVARIANT pv[3];
    ZeroMemory (pv, sizeof(pv));
    CSimpleString strResolution;
    CSimpleString strStatus;
    // optical resolution "XxY DPI"
    if (S_OK == pps->ReadMultiple(3, ps, pv))
    {
        strResolution.Format(TEXT("%dx%d DPI"), pv[0].ulVal, pv[1].ulVal);
        strResolution.SetWindowText(GetDlgItem(hwnd, IDC_RESOLUTION));
    }
    // "Online" or "Offline"
    if (bInit)
    {
        CComPtr<IStillImage> pSti;
        if (SUCCEEDED(StiCreateInstance (GLOBAL_HINSTANCE, STI_VERSION, &pSti, NULL)))
        {
            CComPtr<IStiDevice> pDevice;
            if (SUCCEEDED(pSti->CreateDevice(pv[2].bstrVal, 0, &pDevice, NULL)))
            {
                STI_DEVICE_STATUS sds;
                ZeroMemory (&sds, sizeof(sds));
                sds.dwSize = sizeof(sds);
                sds.StatusMask = STI_DEVSTATUS_ONLINE_STATE;
                if (SUCCEEDED(pDevice->LockDevice(1000)))
                {
                    if (SUCCEEDED(pDevice->GetStatus(&sds)))
                    {
                        Trace(TEXT("Device online state: %x\n"), sds.dwOnlineState);
                        if (sds.dwOnlineState & STI_ONLINESTATE_OPERATIONAL)
                        {
                            strStatus.LoadString(IDS_OPERATIONAL, GLOBAL_HINSTANCE);
                        }
                        else
                        {
                            strStatus.LoadString(IDS_OFFLINE, GLOBAL_HINSTANCE);
                        }
                        strStatus.SetWindowText(GetDlgItem(hwnd, IDC_DEVICE_STATUS));
                        pDevice->UnLockDevice();
                    }
                }
            }
        }
    }
    FreePropVariantArray (3, pv);
    TraceLeave ();
}


/******************************************************************************

    TestWiaDevice

    Runs a simple diagnostic on the device and displays a dialog with the result

*******************************************************************************/

VOID
TestWiaDevice (HWND hwnd, IWiaItem *pItem)
{

    HRESULT hr;
    STI_DIAG sd = {0};
    sd.dwSize = sizeof(sd);
    TraceEnter(TRACE_PROPUI, "TestWiaDevice");
    hr = pItem->Diagnostic(sizeof(sd), reinterpret_cast<LPBYTE>(&sd));
    if (S_OK == hr)
    {
        if (S_OK == sd.sErrorInfo.dwGenericError )
        {
            UIErrors::ReportMessage(hwnd,
                                    GLOBAL_HINSTANCE,
                                    NULL,
                                    MAKEINTRESOURCE(IDS_DIAGNOSTIC_SUCCESS),
                                    MAKEINTRESOURCE(IDS_SUCCESS),
                                    MB_ICONINFORMATION);

        }
        else
        {

            UIErrors::ReportMessage(hwnd,
                                    GLOBAL_HINSTANCE,
                                    NULL,
                                    MAKEINTRESOURCE(IDS_DIAGNOSTIC_FAILED),
                                    MAKEINTRESOURCE(IDS_NO_SUCCESS),
                                    MB_ICONSTOP);

        }
    }
    else
    {
        UIErrors::ReportMessage(hwnd,
                                GLOBAL_HINSTANCE,
                                NULL,
                                MAKEINTRESOURCE(IDS_DIAGNOSTIC_FAILED),
                                MAKEINTRESOURCE(IDS_TEST_UNAVAIL),
                                MB_ICONSTOP);
    }
    TraceLeave ();
}

/******************************************************************************

SetDeviceTime

Sync the PC time with the device

******************************************************************************/

VOID
SetDeviceTime (HWND hwndCameraPage, IWiaItem *pDevice)
{
    SYSTEMTIME st;
    PROPVARIANT pv = {0};
    GetLocalTime(&st);
    pv.vt = VT_UI2 | VT_VECTOR;
    pv.caui.cElems = sizeof(SYSTEMTIME)/sizeof(USHORT);
    pv.caui.pElems = reinterpret_cast<USHORT*>(&st);
    if(PropStorageHelpers::SetProperty(pDevice, WIA_DPA_DEVICE_TIME, pv))
    {
        UpdateTimeStatic(hwndCameraPage, &pv);
    }
    else
    {
        UIErrors::ReportMessage(hwndCameraPage, GLOBAL_HINSTANCE, NULL, 
                                MAKEINTRESOURCE(IDS_TIME_ERR_TITLE),
                                MAKEINTRESOURCE(IDS_TIME_ERR), 
                                MB_ICONWARNING | MB_OK);
    }
}

static const DWORD pScannerGeneralHelp[] =
{
    -1L, -1L,
    IDC_DESCRIPTION, IDH_WIA_DESCRIBE,
    IDC_MANUFACTURER_LABEL, IDH_WIA_MAKER,
    IDC_MANUFACTURER, IDH_WIA_MAKER,
    IDC_TESTSCAN, IDH_WIA_TEST_BUTTON,
    IDC_PORT_LABEL, IDH_WIA_PORT_NAME,
    IDC_WIA_PORT_STATIC, IDH_WIA_PORT_NAME,
    IDC_STATUS_LABEL, IDH_WIA_STATUS,
    IDC_DEVICE_STATUS, IDH_WIA_STATUS,
    IDC_RESOLUTION_LABEL, IDH_WIA_PIC_RESOLUTION,
    IDC_RESOLUTION, IDH_WIA_PIC_RESOLUTION,
    0,0
};
/******************************************************************************

    CWiaScannerPage::CWiaScannerPage

******************************************************************************/
CWiaScannerPage::CWiaScannerPage (IWiaItem *pItem) : CDevicePage (IDD_SCANNER_GENERAL, pItem, pScannerGeneralHelp)
{
}


/******************************************************************************

    CWiaScannerPage::OnInit

    Fill in the icon and WIA properties

******************************************************************************/

INT_PTR
CWiaScannerPage::OnInit ()
{
    TraceEnter (TRACE_PROPUI, "CWiaScannerPage::OnInit");

    HICON hIcon = NULL;
    WiaUiExtensionHelper::GetDeviceIcons(CComBSTR(m_strUIClassId.String()),MAKELONG(0,StiDeviceTypeScanner),NULL,&hIcon,0);

    HICON old = reinterpret_cast<HICON>(SendDlgItemMessage (m_hwnd, IDC_ITEMICON, STM_SETICON, reinterpret_cast<WPARAM>(hIcon), 0));
    if (old)
    {
        DestroyIcon( old );
    }
    FillDeviceGeneralProps (m_hwnd, m_pItem, 0);
    TraceLeaveValue (TRUE);
}

/******************************************************************************

    CWiaScannerPage::OnCommand

    Handle the test button

******************************************************************************/

INT_PTR
CWiaScannerPage::OnCommand (WORD wCode, WORD widItem, HWND hwndItem)
{
    TraceEnter (TRACE_PROPUI, "CWiaScannerPage::OnCommand");
    switch (widItem)
    {
        case IDC_TESTSCAN:
            TestWiaDevice (m_hwnd, m_pItem);
            break;

    }
    TraceLeaveValue (0);
}

/******************************************************************************

    SubclassComboBox

    Set the wndproc for the ComboBox part of the ComboEx control to our wndproc

******************************************************************************/

static TCHAR cszPropProcPtr[] = TEXT("OldProcPtr");
VOID
SubclassComboBox (HWND hList)
{
    TraceEnter (TRACE_PROPUI, "SubclassComboBox");
    LONG_PTR lOldProc   ;

    HWND hCombo = FindWindowEx (hList, NULL, TEXT("ComboBox"), NULL);
    if (hCombo)
    {
        lOldProc = SetWindowLongPtr (hCombo, GWLP_WNDPROC,
                                  reinterpret_cast<LONG_PTR>(MyComboWndProc));
        SetProp (hCombo, cszPropProcPtr, reinterpret_cast<HANDLE>(lOldProc));
    }
    TraceLeave ();
}
/*****************************************************************************

    CAppListBox

    This classes subclasses the ComboBox to work around a bug
    that causes the list to drop down at bad times. Uses a window property
    to store the previous wndproc

*****************************************************************************/

CAppListBox::CAppListBox (HWND hList, HWND hStatic, HWND hNoApps)
{
    m_hwnd = hList;
    m_hstatic = hStatic;
    m_hnoapps = hNoApps;
    SubclassComboBox (hList);
    m_himl = NULL;
}

CAppListBox::~CAppListBox()
{
    if (m_himl)
    {
        ImageList_Destroy (m_himl);
    }
    FreeAppData();
}


/*****************************************************************************

    MyComboWndProc

    Bypass the combobox's window proc for WM_LBUTTONDOWN and WM_RBUTTONDOWN
    messages, send them to user32's combobox proc instead. Comctl32's subclass
    proc is buggy! We can do this because we don't need drag/drop support

*****************************************************************************/
LRESULT WINAPI
MyComboWndProc (HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{
    static WNDPROC pfnDefProc = NULL;
    WNDPROC pfnWndProc = reinterpret_cast<WNDPROC>(GetProp (hwnd, cszPropProcPtr));

    if (!pfnDefProc)
    {
        WNDCLASS wc;
        wc.lpfnWndProc = NULL;
        GetClassInfo (GetModuleHandle(TEXT("user32.dll")),TEXT("ComboBox"), &wc);
        pfnDefProc = wc.lpfnWndProc;
    }
    if (msg == WM_LBUTTONDOWN || msg == WM_RBUTTONDOWN)
    {
        if (pfnDefProc)
        {
            return pfnDefProc(hwnd, msg, wp, lp);
        }
    }
    if (msg == WM_DESTROY)
    {
        RemoveProp (hwnd, cszPropProcPtr);
    }
    if (pfnWndProc)
    {
        return pfnWndProc (hwnd, msg, wp, lp);
    }
    else
    {
        return CallWindowProc (DefWindowProc, hwnd, msg, wp, lp);
    }

}

// WIAXFER.EXE's clsid
static const CLSID CLSID_PersistCallback = {0x7EFA65D9,0x573C,0x4E46,{0x8C,0xCB,0xE7,0xFB,0x9E,0x56,0xCD,0x57}};

/*****************************************************************************

    CAppListBox::FillAppListBox

    Query WIA for the connection event handlers registered for our item
    and add their info to the list box

*****************************************************************************/

UINT
CAppListBox::FillAppListBox (IWiaItem *pItem, EVENTINFO *pei)
{
    TraceEnter (TRACE_PROPUI, "CAppListBoxPage::FillAppListBox");

    CComPtr<IEnumWIA_DEV_CAPS> pEnumHandlers;

    WIA_EVENT_HANDLER wehHandler;
    WIA_EVENT_HANDLER *pData = NULL;

    COMBOBOXEXITEM cbex = {0};
    CSimpleString strItem;
    HICON hIcon;
    INT cxIcon = min(16,GetSystemMetrics (SM_CXSMICON));
    INT cyIcon = min(16,GetSystemMetrics (SM_CYSMICON));

    HRESULT hr;
    WPARAM nDefault = 0;
    DWORD dw;
    UINT nHandlers=0;
    INT nIcons=0;

    if (m_himl)
    {
        ImageList_Destroy(m_himl);
    }
    // Create our event icon image list and add the default icon to it
    m_himl = ImageList_Create (cxIcon,
                             cyIcon,
                             PrintScanUtil::CalculateImageListColorDepth() | ILC_MASK,
                             10,
                             100);
    hIcon = reinterpret_cast<HICON>(LoadImage (GLOBAL_HINSTANCE,
                                               MAKEINTRESOURCE(IDI_EVENT),
                                               IMAGE_ICON,
                                               cxIcon,
                                               cyIcon,
                                               LR_SHARED | LR_DEFAULTCOLOR));

    if (-1 != ImageList_AddIcon (m_himl, hIcon))
    {
        nIcons++;
    }

    // Empty the combobox
    cbex.mask = CBEIF_LPARAM;
    for (cbex.iItem = 0;SendMessage(m_hwnd, CBEM_GETITEM, NULL, reinterpret_cast<LPARAM>(&cbex));cbex.iItem++)
    {
        if (cbex.lParam)
        {
            DeleteHandler(reinterpret_cast<WIA_EVENT_HANDLER*>(cbex.lParam));
        }
    }
    SendMessage (m_hwnd, CB_RESETCONTENT, 0, 0);
    // Turn off redraws until we've added the complete list
    SendMessage (m_hwnd, WM_SETREDRAW, FALSE, 0);

    // Assign this imagelist to the comboboxex


    SendMessage (m_hwnd, CBEM_SETIMAGELIST, 0, reinterpret_cast<LPARAM>(m_himl));

    // For the given event, enumerate the installed handlers
    if (!pei)
    {
        hr = E_FAIL;
    }
    else
    {
        hr = pItem->EnumRegisterEventInfo (0,
                                           &pei->guidEvent,
                                           &pEnumHandlers);
    }

    while (S_OK == hr)
    {
        hr = pEnumHandlers->Next(1, &wehHandler, &dw);

        if (S_OK == hr)
        {
            // ignore wiaacmgr, WIA_EVENT_HANDLER_NO_ACTION and WIA_EVENT_HANDLER_PROMPT
            if (!IsEqualGUID(wehHandler.guid, CLSID_PersistCallback)
                && !IsEqualGUID(wehHandler.guid, WIA_EVENT_HANDLER_NO_ACTION)
                && !IsEqualGUID(wehHandler.guid, WIA_EVENT_HANDLER_PROMPT))
            {
                pData = new WIA_EVENT_HANDLER;
            }

        }

        if (pData)
        {

            // Add the string and icon to the comboboxex
            // and save the structure as item data

            strItem = CSimpleStringConvert::NaturalString (CSimpleStringWide(wehHandler.bstrName));

            CopyMemory (pData, &wehHandler, sizeof(wehHandler));
            ZeroMemory (&cbex, sizeof(cbex));
            cbex.mask = CBEIF_TEXT | CBEIF_LPARAM | CBEIF_IMAGE | CBEIF_SELECTEDIMAGE;
            cbex.iItem = -1;
            cbex.pszText = const_cast<LPTSTR>(strItem.String());

            if (pData->bstrIcon)
            {
                if (AddIconToImageList (m_himl, pData->bstrIcon))
                {
                    cbex.iImage = cbex.iSelectedImage = nIcons++;
                }
            }

            cbex.lParam = reinterpret_cast<LPARAM>(pData);
            if (-1 == SendMessage (m_hwnd,
                                   CBEM_INSERTITEM,
                                   0,
                                   reinterpret_cast<LPARAM>(&cbex)))
            {
                DeleteHandler (pData);
            }
            else
            {
                if (pData->ulFlags & WIA_IS_DEFAULT_HANDLER)
                {
                    nDefault = nHandlers;
                }
                nHandlers++;
            }

        }
        pData = NULL;
    }
    if (pei)
    {
        pei->nHandlers = nHandlers;
    }



    EnableWindow (m_hstatic, nHandlers > 0);

    ShowWindow (m_hwnd, nHandlers > 0 ? SW_SHOW : SW_HIDE);

    ShowWindow (m_hnoapps, nHandlers > 0 ? SW_HIDE : SW_SHOW);
    // Set selection to the current default or the user's current choice
    if (pei && pei->bNewHandler)
    {
        SetAppSelection (GetParent(m_hwnd), IDC_WIA_APPS, pei->clsidNewHandler);
    }
    else
    {
        SendMessage (m_hwnd, CB_SETCURSEL, nDefault, 0);
    }


    SendMessage (m_hwnd, WM_SETREDRAW, TRUE, 0);
    TraceLeave ();
    return nHandlers;
}

/*****************************************************************************

    CAppListBox::FreeAppData

    Free event data associated with the given applist listbox

*****************************************************************************/

void
CAppListBox::FreeAppData ()
{
    TraceEnter (TRACE_PROPUI, "CAppListBox::FreeAppData");
    COMBOBOXEXITEM ci;
    LRESULT i, nItems;
    ZeroMemory (&ci, sizeof(ci));
    nItems = SendMessage (m_hwnd,
                          CB_GETCOUNT ,
                          0,0);
    for (i=0;i<nItems;i++)
    {
        SendMessage (m_hwnd,
                     CBEM_GETITEM,
                     i,
                     reinterpret_cast<LPARAM>(&ci));
        if (ci.lParam)
        {
            WIA_EVENT_HANDLER *peh = reinterpret_cast<WIA_EVENT_HANDLER*>(ci.lParam);
            DeleteHandler(peh);            
        }
    }
    TraceLeave ();
}

static const DWORD pCameraGeneralHelp[] =
{
    -1L, -1L,
    IDC_DESCRIPTION, IDH_WIA_DESCRIBE,
    IDC_MANUFACTURER_LABEL, IDH_WIA_MAKER,
    IDC_MANUFACTURER, IDH_WIA_MAKER,
    IDC_TAKEN, IDH_WIA_PICS_TAKEN,
    IDC_BATTERY_LABEL, IDH_WIA_BATTERY_STATUS,
    IDC_BATTERY, IDH_WIA_BATTERY_STATUS,
    IDC_TESTCAM, IDH_WIA_TEST_BUTTON,
    IDC_PORT_LABEL, IDH_WIA_PORT_NAME,
    IDC_WIA_PORT_STATIC, IDH_WIA_PORT_NAME,
    IDC_WIA_PORT_LIST, IDH_WIA_PORT_NAME,
    IDC_TAKEN_LABEL, IDH_WIA_PICS_TAKEN,
    IDC_FLASH_LABEL, IDH_WIA_FLASH_MODE,
    IDC_FLASH_MODE_LIST, IDH_WIA_FLASH_MODE_LIST,
    IDC_FLASH_MODE_STATIC, IDH_WIA_FLASH_MODE,
    IDC_PORT_SPEED, IDH_WIA_PORT_SPEED,
    IDC_PORT_SPEED_LABEL, IDH_WIA_PORT_SPEED,
    IDC_TIME_LABEL, IDH_WIA_CAMERA_TIME_STATIC,
    IDC_CURRENT_TIME, IDH_WIA_CAMERA_TIME_STATIC,
    IDC_SET_TIME, IDH_WIA_CAMERA_TIME_BUTTON,
    IDC_IMAGESIZE_SLIDER, IDH_WIA_IMAGE_SIZE_SLIDER,
    IDC_IMAGESIZE_STATIC, IDH_WIA_IMAGE_SIZE_STATIC,
    IDC_ITEMICON, 0,
    0,0
};
/*****************************************************************************

   CWiaCameraPage::CWiaCameraPage

   <Notes>

 *****************************************************************************/

CWiaCameraPage::CWiaCameraPage (IWiaItem *pItem) :
                CDevicePage (IDD_CAMERA_GENERAL, pItem, pCameraGeneralHelp)
{
    TraceEnter (TRACE_PROPUI, "CWiaCameraPage::CWiaCameraPage");
    m_pSizes = NULL;
    m_nSizes = 0;
    m_nSelSize = 0;
    m_lFlash = -1;
    m_szPort[0] = 0;
    m_szPortSpeed[0] = 0;


    //
    // Load sti_ci to get the port list functions
    //

    TCHAR szPath[ MAX_PATH ];
    UINT  uLen = lstrlen( TEXT("\\system32\\sti_ci.dll") )+1;
    UINT  uRes;

    *szPath=0;
    uRes = GetSystemWindowsDirectory( szPath, MAX_PATH - uLen );

    if (uRes && (uRes <= (MAX_PATH-uLen)))
    {
        lstrcat( szPath, TEXT("\\system32\\sti_ci.dll") );
        m_hStiCi = LoadLibrary( szPath );
    }



    if (m_hStiCi)
    {
        m_pfnWiaCreatePortList  = (PFN_WIA_CREATE_PORTLIST)GetProcAddress( m_hStiCi, "WiaCreatePortList" );
        m_pfnWiaDestroyPortList = (PFN_WIA_DESTROY_PORTLIST)GetProcAddress( m_hStiCi, "WiaDestroyPortList" );
    }
    else
    {
        m_pfnWiaCreatePortList  = NULL;
        m_pfnWiaDestroyPortList = NULL;

    }

    SetWindowLongPtr( m_hwnd, DWLP_USER, (LONG_PTR)this );

    TraceLeave ();
}

CWiaCameraPage::~CWiaCameraPage ()
{
    if (m_hStiCi)
    {
        m_pfnWiaCreatePortList  = NULL;
        m_pfnWiaDestroyPortList = NULL;
        FreeLibrary( m_hStiCi );
    }

    if (m_pSizes)
    {
        delete [] m_pSizes;
    }

}

/*****************************************************************************
   fnComparePt

   Used to call qsort() to sort array of POINT structs


*****************************************************************************/
int __cdecl fnComparePt (const void *ppt1, const void *ppt2)
{
    LONG prod1, prod2; // image resolutions shouldn't be big enough to overflow a LONG
    prod1 = reinterpret_cast<const POINT*>(ppt1)->x * reinterpret_cast<const POINT*>(ppt1)->y;
    prod2 = reinterpret_cast<const POINT*>(ppt2)->x * reinterpret_cast<const POINT*>(ppt2)->y;
    if (prod1 < prod2)
    {
        return -1;
    }
    else if (prod1 == prod2)
    {
        return 0;
    }
    return 1;
}

/*****************************************************************************

    CWiaCameraPage::UpdatePictureSize

    Determines the appearance of the Picture Size slider on the camera general
    page. Hides it if the property isn't writable or there is no list of valid
    values.

*****************************************************************************/
VOID
CWiaCameraPage::UpdatePictureSize (IWiaPropertyStorage *pps)
{
    INT iWidth;
    INT iHeight;
    PROPVARIANT vValidVals[2];
    PROPVARIANT *pvWidthVals = &vValidVals[0];
    PROPVARIANT *pvHeightVals = &vValidVals[1];
    ULONG       ulFlags[2];
    PROPSPEC ps[2] = {{PRSPEC_PROPID, WIA_DPC_PICT_WIDTH},
                      {PRSPEC_PROPID, WIA_DPC_PICT_HEIGHT}};
    PROPVARIANT vCurVals[2];

    TraceEnter (TRACE_PROPUI, "CWiaCameraPage::UpdatePictureSize");


    ZeroMemory (vCurVals, sizeof(vCurVals));
    ZeroMemory (vValidVals, sizeof(vValidVals));
    pps->ReadMultiple (2, ps, vCurVals);
    pps->GetPropertyAttributes(2, ps, ulFlags, vValidVals);
    iWidth = vCurVals[0].intVal;
    iHeight = vCurVals[1].intVal;

    HWND hSlider = GetDlgItem(m_hwnd, IDC_IMAGESIZE_SLIDER);

    m_nSizes = WIA_PROP_LIST_COUNT(pvWidthVals);
    Trace(TEXT("Camera supports %d image resolutions"), m_nSizes);
    if (!(ulFlags[0] & (WIA_PROP_WRITE | WIA_PROP_LIST)) ||
        !(ulFlags[1] & (WIA_PROP_WRITE | WIA_PROP_LIST)) ||
          WIA_PROP_LIST_COUNT(pvHeightVals)!= m_nSizes  )
    {
        // hide the slider; the property isn't modifiable, or the camera
        // doesn't support a proper list of valid values
         ShowWindow (hSlider, SW_HIDE);
         // allocate only 1 possible size value
         if (iWidth && iHeight && !m_pSizes)
         {
             m_nSizes = 1;
             m_nSelSize = 0;
             m_pSizes = new POINT[m_nSizes];
             if (m_pSizes)
             {
                 m_pSizes[0].x = iWidth;
                 m_pSizes[0].y = iHeight;
             }
         }
    }
    else
    {
        //
        //build the array of sizes
        if (!m_pSizes)
        {
            m_pSizes = new POINT[m_nSizes];
            if (m_pSizes)
            {
                // set the ticks on the slider
                SendMessage (hSlider,
                             TBM_SETRANGE,
                             FALSE,
                             static_cast<LPARAM>(MAKELONG(0, m_nSizes-1)));

                for (size_t i=0;i<m_nSizes;i++)
                {
                    m_pSizes[i].x = pvWidthVals->cal.pElems[WIA_LIST_VALUES + i];//WIA_PROP_LIST_VALUE(pvWidthVals, i);
                    m_pSizes[i].y = pvHeightVals->cal.pElems[WIA_LIST_VALUES + i];//WIA_PROP_LIST_VALUE(pvHeightVals, i);
                }
                // sort the list by ascending order of x*y
                qsort (m_pSizes, m_nSizes, sizeof(POINT), fnComparePt);
                // now go through the sorted list looking for the current value
                // to set the slider
                for (size_t i=0;i<m_nSizes;i++)
                {
                    if (m_pSizes[i].x == iWidth && m_pSizes[i].y == iHeight)
                    {
                        SendMessage (hSlider,
                                     TBM_SETPOS,
                                     TRUE,
                                     i);
                        m_nSelSize = i;

                    }
                }
                // Display the slider and labels
                ShowWindow (hSlider, SW_SHOW);
                ShowWindow (GetDlgItem(m_hwnd, IDC_LOW_QUALITY), SW_SHOW);
                ShowWindow (GetDlgItem(m_hwnd, IDC_HIGH_QUALITY), SW_SHOW);
            }
        }
    }
    // Update the current resolution string
    UpdateImageSizeStatic (m_nSelSize);
    FreePropVariantArray (2, vCurVals);
    FreePropVariantArray (2, vValidVals);
    TraceLeave();
}

/*****************************************************************************

   CWiaCameraPage::OnInit

   <Notes>

 *****************************************************************************/

INT_PTR
CWiaCameraPage::OnInit ()
{
    TraceEnter (TRACE_PROPUI, "CWiaCameraPage::OnInit");

    WORD wType = StiDeviceTypeDefault;
    GetDeviceTypeFromDevice (m_pItem, &wType);

    HICON hIcon = NULL;
    WiaUiExtensionHelper::GetDeviceIcons(CComBSTR(m_strUIClassId.String()),MAKELONG(0,wType),NULL,&hIcon,0);

    HICON old = reinterpret_cast<HICON>(SendDlgItemMessage (m_hwnd, IDC_ITEMICON, STM_SETICON, reinterpret_cast<WPARAM>(hIcon), 0));
    if (old)
    {
        DestroyIcon(old);
    }
    FillDeviceGeneralProps (m_hwnd, m_pItem, 0);
    m_lFlash = SendDlgItemMessage (m_hwnd, IDC_FLASH_MODE_LIST, CB_GETCURSEL, 0, 0);
    Trace(TEXT("m_lFlash is %d"), m_lFlash);
    CComQIPtr<IWiaPropertyStorage, &IID_IWiaPropertyStorage> p(m_pItem);
    if (p)
    {
        UpdatePictureSize (p);
    }
    TraceLeave ();
    return TRUE;
}

/*****************************************************************************

   CWiaCameraPage::OnCommand

   Handle the Test Device button press

 *****************************************************************************/

INT_PTR
CWiaCameraPage::OnCommand (WORD wCode, WORD widItem, HWND hwndItem)
{
    TraceEnter (TRACE_PROPUI, "CWiaCameraPage::OnCommand");

    switch (widItem)
    {
        case IDC_TESTCAM:
            TestWiaDevice (m_hwnd, m_pItem);
            break;

        case IDC_SET_TIME:
            SetDeviceTime (m_hwnd, m_pItem);
            break;

    }
    TraceLeaveValue (0);
}

/*****************************************************************************

   CWiaCameraPage::StateChanged

   Determine if the user changed anything on the dialog since the last
   SaveCurrentState() call

 *****************************************************************************/
bool
CWiaCameraPage::StateChanged ()
{
    bool bRet = false;
    TraceEnter(TRACE_PROPUI, "CWiaCameraPage::StateChanged");
    if (SendMessage(GetDlgItem(m_hwnd, IDC_IMAGESIZE_SLIDER), TBM_GETPOS, 0, 0) != m_nSelSize)
    {
        bRet = true;
    }
    if (!bRet && m_lFlash != -1)
    {
        bRet = (m_lFlash != SendDlgItemMessage (m_hwnd, IDC_FLASH_MODE_LIST, CB_GETCURSEL, 0, 0));

    }
    if (!bRet && IsWindowVisible(GetDlgItem(m_hwnd, IDC_WIA_PORT_LIST)))
    {
        LRESULT iSel = SendDlgItemMessage( m_hwnd, IDC_WIA_PORT_LIST, CB_GETCURSEL, 0, 0 );

        if (iSel != CB_ERR)
        {
            TCHAR szCurPort[ 128 ];
            *szCurPort = 0;
            LRESULT iRes;

            iRes = SendDlgItemMessage( m_hwnd, IDC_WIA_PORT_LIST, CB_GETLBTEXT, (WPARAM)iSel, (LPARAM)szCurPort );

            if ((iRes != CB_ERR) && *szCurPort)
            {
                if (lstrcmpi( szCurPort, m_szPort) != 0)
                {
                    bRet = TRUE;
                }
            }
            *szCurPort = 0;
            iSel = SendDlgItemMessage( m_hwnd, IDC_PORT_SPEED, CB_GETCURSEL, 0, 0 );
            iRes = SendDlgItemMessage( m_hwnd, IDC_PORT_SPEED, CB_GETLBTEXT, (WPARAM)iSel, (LPARAM)szCurPort );

            if (lstrcmpi( szCurPort, m_szPortSpeed) != 0)
            {
                    bRet = TRUE;
            }
        }
    }
    TraceLeaveValue (bRet);
}

void
CWiaCameraPage::SaveCurrentState()
{
    TraceEnter (TRACE_PROPUI, "CWiaCameraPage::SaveCurrentState");
    TraceLeave ();
}

void
CWiaCameraPage::UpdateImageSizeStatic (LRESULT lIndex)
{
    CSimpleString strResolution;
    if (m_pSizes)
    {
        strResolution.Format(TEXT("%d x %d"), m_pSizes[lIndex].x, m_pSizes[lIndex].y);
        strResolution.SetWindowText(GetDlgItem(m_hwnd, IDC_IMAGESIZE_STATIC));
    }
}

INT_PTR
CWiaCameraPage::OnRandomMsg (UINT msg, WPARAM wp, LPARAM lp)
{
    switch (msg)
    {
        case WM_HSCROLL: // from our trackbar
            {
                LRESULT l = SendDlgItemMessage (m_hwnd, IDC_IMAGESIZE_SLIDER,
                                                TBM_GETPOS, 0, 0);
                UpdateImageSizeStatic (l);
                return TRUE;
            }
    }
    return FALSE;
}

LONG
CWiaCameraPage::OnApplyChanges(BOOL bHitOK)
{
    LONG lRet = PSNRET_NOERROR;
    TraceEnter (TRACE_PROPUI, "CWiaCameraPage::OnApplyChanges");
    HRESULT hr = WriteImageSizeToDevice ();
    if (SUCCEEDED(hr))
    {
        hr = WriteFlashModeToDevice ();
    }
    if (SUCCEEDED(hr) && IsWindowVisible(GetDlgItem(m_hwnd, IDC_WIA_PORT_LIST)))
    {
        hr = WritePortSelectionToDevice();
    }
    if (FAILED(hr))
    {
        UIErrors::ReportError(m_hwnd, GLOBAL_HINSTANCE, UIErrors::ErrCommunicationsFailure);
        lRet = PSNRET_INVALID;
    }

    if (!bHitOK)
    {
        // if the user hit Apply, re-read the device properties, as they may have changed
        CComQIPtr<IWiaPropertyStorage, &IID_IWiaPropertyStorage> pps(m_pItem);
        CameraUpdateProc (m_hwnd, FALSE, pps);
    }
    TraceLeaveValue (lRet);
}

HRESULT
CWiaCameraPage::WritePortSelectionToDevice()
{
    HRESULT hr = E_FAIL;
    TraceEnter (TRACE_PROPUI, "CWiaCameraPage::WritePortSelectionToDevice");

    LRESULT iSel = SendDlgItemMessage( m_hwnd, IDC_WIA_PORT_LIST, CB_GETCURSEL, 0, 0 );

    if (iSel != CB_ERR)
    {
        TCHAR szCurPort[128] = TEXT("");
        TCHAR szBaudRate[64] = TEXT("");
        LRESULT iRes;

        iRes = SendDlgItemMessage( m_hwnd, IDC_WIA_PORT_LIST, CB_GETLBTEXT, (WPARAM)iSel, (LPARAM)szCurPort );
        if (iRes != CB_ERR)
        {
            // the user isn't required to pick a baud rate
            iSel = SendDlgItemMessage( m_hwnd, IDC_PORT_SPEED, CB_GETCURSEL, 0, 0);
            if (iSel != CB_ERR)
            {
                iRes = SendDlgItemMessage( m_hwnd, IDC_PORT_SPEED, CB_GETLBTEXT, (WPARAM)iSel, (LPARAM)szBaudRate );
            }
        }
        Trace(TEXT("Chosen port: %s, speed:%s"), szCurPort, szBaudRate);
        if ((iRes != CB_ERR) && (*szCurPort))
        {
            if ((lstrcmpi( szCurPort, m_szPort ) != 0) || (lstrcmpi(szBaudRate, m_szPortSpeed) != 0))
            {
                CComPtr<IWiaPropertyStorage> pps;

                hr = GetDeviceFromDeviceId( m_strDeviceId, IID_IWiaPropertyStorage, reinterpret_cast<LPVOID *>(&pps), FALSE );
                if (SUCCEEDED(hr) && pps)
                {
                    static const PROPSPEC ps[2] = {{PRSPEC_PROPID, WIA_DIP_PORT_NAME},
                                                   {PRSPEC_PROPID, WIA_DIP_BAUDRATE}};
                    PROPVARIANT pv[2];
                    ULONG       ulItems = (*szBaudRate ? 2:1);

                    ZeroMemory (pv, sizeof(pv));
                    #ifdef UNICODE
                    pv[0].vt = VT_LPWSTR;
                    pv[0].pwszVal = szCurPort;
                    pv[1].vt = VT_LPWSTR;
                    pv[1].pwszVal = szBaudRate;
                    #else
                    pv[0].vt = VT_LPSTR;
                    pv[0].pszVal = szCurPort;
                    pv[1].vt = VT_LPSTR;
                    pv[1].pszVal = szBaudRate;
                    #endif

                    hr = pps->WriteMultiple (ulItems, ps, pv, 2);

                    if (SUCCEEDED(hr))
                    {
                        Trace(TEXT("pps->WriteMultiple( %d items, comport = %s, baudrate = %s ) was successful"),ulItems,szCurPort,szBaudRate);
                        //
                        // The "nominal" port value has changed, record it.
                        //

                        lstrcpy( m_szPort, szCurPort );
                        lstrcpy( m_szPortSpeed, szBaudRate);
                        SetDlgItemText (m_hwnd, IDC_WIA_PORT_STATIC, m_szPort);
                    }
                }
            }
            else
            {
                hr = S_OK;
            }
        }
    }
    TraceLeaveResult (hr);
}

HRESULT
CWiaCameraPage::WriteImageSizeToDevice ()
{
    TraceEnter(TRACE_PROPUI, "CWiaCameraPage::WriteImageSizeToDevice");
    static const PROPSPEC ps[2] = {{PRSPEC_PROPID, WIA_DPC_PICT_WIDTH},
                                   {PRSPEC_PROPID, WIA_DPC_PICT_HEIGHT}};
    PROPVARIANT pv[2] = {0};
    HRESULT hr = S_OK;
    LRESULT nNewSize = SendDlgItemMessage (m_hwnd, IDC_IMAGESIZE_SLIDER, TBM_GETPOS, 0, 0);   
    if (m_pSizes && m_nSizes > 1)
    {
        CComQIPtr<IWiaPropertyStorage, &IID_IWiaPropertyStorage>pps(m_pItem);
        if (pps)
        {
            pv[0].vt= VT_I4;
            pv[0].intVal = m_pSizes[nNewSize].x;
            pv[1].vt= VT_I4;
            pv[1].intVal = m_pSizes[nNewSize].y;
            hr = pps->WriteMultiple (2, ps, pv,2);
        }
        else
        {
            hr = E_FAIL;
        }
        if (S_OK == hr)
        {
            m_nSelSize = nNewSize;
        }
    }
    TraceLeaveResult (hr);
}

HRESULT
CWiaCameraPage::WriteFlashModeToDevice()
{
    HRESULT hr = S_OK;
    TraceEnter (TRACE_PROPUI, "CWiaCameraPage::WriteFlashModeToDevice");
    if (m_lFlash != -1)
    {
        LRESULT lFlash = SendDlgItemMessage (m_hwnd, IDC_FLASH_MODE_LIST, CB_GETCURSEL, 0, 0);
    
        INT iMode = static_cast<INT>(SendDlgItemMessage(m_hwnd, IDC_FLASH_MODE_LIST, CB_GETITEMDATA, lFlash, 0));

        if (!PropStorageHelpers::SetProperty(m_pItem, WIA_DPC_FLASH_MODE, iMode))
        {
            hr = WIA_ERROR_INCORRECT_HARDWARE_SETTING;
        }
        else
        {
            m_lFlash = lFlash;
        }
    }
    TraceLeaveResult (hr);
}
/*****************************************************************************

   CWiaFolderPage::CWiaFolderPage

   <Notes>

 *****************************************************************************/

CWiaFolderPage::CWiaFolderPage (IWiaItem *pItem) : CPropertyPage (IDD_CONTAINER_GENERAL, NULL, pItem)
{
}


static const DWORD pItemHelp [] =
{
    IDC_ITEMICON, -1,
    IDC_STATIC_NAME, IDH_WIA_PIC_NAME,
    IDC_STATIC_DATE, IDH_WIA_DATE_TAKEN,
    IDC_STATIC_TIME, IDH_WIA_TIME_TAKEN,
    IDC_STATIC_FORMAT, IDH_WIA_IMAGE_FORMAT,
    IDC_STATIC_SIZE, IDH_WIA_PICTURE_SIZE,
    IDC_IMAGE_NAME, IDH_WIA_PIC_NAME,
    IDC_IMAGE_DATE, IDH_WIA_DATE_TAKEN,
    IDC_IMAGE_TIME, IDH_WIA_TIME_TAKEN,
    IDC_IMAGE_FORMAT, IDH_WIA_IMAGE_FORMAT,
    IDC_IMAGE_SIZE, IDH_WIA_PICTURE_SIZE,
    0,0
};

/*****************************************************************************

   CWiaCameraItemPage::CWiaCameraItemPage

   <Notes>

 *****************************************************************************/

CWiaCameraItemPage::CWiaCameraItemPage (IWiaItem *pItem)
                   :CPropertyPage (IDD_IMAGE_GENERAL, NULL, pItem, pItemHelp)
{

}


/*****************************************************************************

   CWiaCameraItemPage::OnInit

   <Notes>

 *****************************************************************************/

INT_PTR
CWiaCameraItemPage::OnInit ()
{
    IWiaItem *pRoot;

    SHFILEINFO sfi;
    LPITEMIDLIST pidl;


    TCHAR szPath[MAX_PATH];

    // make a pidl for the item to leverage the format code
    pidl = IMCreateCameraItemIDL (m_pItem, m_strDeviceId, NULL);
    IMGetImagePreferredFormatFromIDL (pidl, NULL, szPath);
    ZeroMemory (&sfi, sizeof(sfi));
    SHGetFileInfo (szPath,
                   FILE_ATTRIBUTE_NORMAL,
                   &sfi,
                   sizeof(sfi), SHGFI_ICON | SHGFI_USEFILEATTRIBUTES);

    // Use our bitmap icon if shgetfileinfo didn't work
    if (!(sfi.hIcon))
    {
        sfi.hIcon = LoadIcon (GLOBAL_HINSTANCE, MAKEINTRESOURCE(IDI_PICTURE_BMP));
    }
    HICON old = reinterpret_cast<HICON>(SendDlgItemMessage (m_hwnd, IDC_ITEMICON, STM_SETICON, reinterpret_cast<WPARAM>(sfi.hIcon), 0));
    if (old)
    {
        DestroyIcon(old);
    }
    m_pItem->GetRootItem (&pRoot);
    FillItemGeneralProps (m_hwnd, pRoot, m_pItem, 0);
    DoILFree (pidl);
    return TRUE;
}

bool
CWiaCameraItemPage::ItemSupported (IWiaItem *pItem)
{
    // We only support properties for image items
    bool bRet = false;
    LONG lType;
    if (SUCCEEDED(pItem->GetItemType(&lType)))
    {
        if (lType & (WiaItemTypeImage | WiaItemTypeVideo | WiaItemTypeFile))
        {
            bRet = true;
        }
    }
    return bRet;
}


//
// Define constants for dwords stored in the registry
#define ACTION_RUNAPP    0
#define ACTION_AUTOSAVE  1
#define ACTION_NOTHING   2
#define ACTION_PROMPT    3
#define ACTION_MAX       3
/*****************************************************************************

   CWiaEventsPage::GetConnectionSettings

   Fills in the connect event autosave controls with the current user settings.

/*****************************************************************************/

DWORD
CWiaEventsPage::GetConnectionSettings ()
{
    TraceEnter (TRACE_PROPUI, "CWiaEventsPage::GetConnectionSettings");
    DWORD dwAction = ACTION_RUNAPP;

    CSimpleString strSubKey;
    strSubKey.Format (c_szConnectSettings, m_strDeviceId.String());
    CSimpleReg reg (HKEY_CURRENT_USER, REGSTR_PATH_USER_SETTINGS, false, KEY_READ, NULL);
    CSimpleReg regSettings (reg, strSubKey, false, KEY_READ, NULL);
    CSimpleString strFolderPath;
    DWORD bAutoDelete = 0;
    DWORD bUseDate = 0;
    TCHAR szMyPictures[MAX_PATH];


    SHGetFolderPath (NULL, CSIDL_MYPICTURES, NULL, 0, szMyPictures);
    strFolderPath = szMyPictures; // default path if registry fails

    // Find out the current settings in the registry
    if (regSettings.OK())
    {
        dwAction = regSettings.Query(REGSTR_VALUE_CONNECTACT, dwAction);
        if (dwAction > ACTION_MAX)
        {
                dwAction = ACTION_RUNAPP;
        }

        strFolderPath = regSettings.Query (REGSTR_VALUE_SAVEFOLDER, CSimpleString(reinterpret_cast<LPCTSTR>(szMyPictures)));
        bAutoDelete = regSettings.Query (REGSTR_VALUE_AUTODELETE, bAutoDelete);
        bUseDate = regSettings.Query(REGSTR_VALUE_USEDATE, bUseDate);
    }
    // If another app has made itself the default handler for connection since
    // the last time the user invoked this sheet, we need to make sure
    // we reflect that in the active action.
    if (dwAction != ACTION_RUNAPP)
    {
        VerifyCurrentAction (dwAction);
    }

    // turn on the defaults
    CheckDlgButton (m_hwnd, IDB_DELETEONSAVE, bAutoDelete);
    CheckDlgButton (m_hwnd, IDB_USEDATE, bUseDate);
    strFolderPath.SetWindowText(GetDlgItem (m_hwnd, IDC_FOLDERPATH));



    TraceLeaveValue(dwAction);
}


/*****************************************************************************

    CWiaEventsPage::EnableAutoSave

    Enable controls appropriate to the Automatically save.. option

*****************************************************************************/

void
CWiaEventsPage::EnableAutoSave(BOOL bEnable)
{
    TraceEnter (TRACE_PROPUI, "CWiaEventsPage::EnableAutoSave");

    EnableWindow (GetDlgItem(m_hwnd, IDB_QUIETSAVE), bEnable && !m_bReadOnly);
    BOOL bAutoSave = IsDlgButtonChecked (m_hwnd, IDB_QUIETSAVE);
    EnableWindow (GetDlgItem (m_hwnd, IDB_USEDATE), bAutoSave);
    EnableWindow (GetDlgItem (m_hwnd, IDB_DELETEONSAVE), bAutoSave);
    EnableWindow (GetDlgItem (m_hwnd, IDC_FOLDERPATH), bAutoSave);
    EnableWindow (GetDlgItem (m_hwnd, IDB_BROWSE), bAutoSave);
}


static const TCHAR c_szWiaxferRegister[] = TEXT("wiaacmgr.exe /RegConnect %ls");
static const TCHAR c_szWiaxferUnregister[] = TEXT("wiaacmgr.exe /UnregConnect %ls");

/*****************************************************************************

    CWiaEventsPage::RegisterWiaxfer

    Invoke wiaxfer to register itself

*****************************************************************************/

bool
CWiaEventsPage::RegisterWiaxfer (LPCTSTR szCmd)
{
    TCHAR szCmdLine[MAX_PATH+100];
    STARTUPINFO sui;
    PROCESS_INFORMATION pi;
    bool bRet = true;
    TraceEnter (TRACE_PROPUI, "CWiaEventsPage::RegisterWiaxfer");
    wsprintf (szCmdLine, szCmd, m_strDeviceId.String());
    ZeroMemory (&sui, sizeof(sui));
    sui.cb = sizeof(sui);
    if (!CreateProcess (NULL, szCmdLine,
                        NULL,
                        NULL,
                        TRUE,
                        0,
                        NULL,
                        NULL,
                        &sui,
                        &pi))
    {
        bRet = false;
    }
    else
    {
        CloseHandle (pi.hProcess);
        CloseHandle (pi.hThread);
    }
    TraceLeave ();
    return bRet;
}

LONG
CWiaEventsPage::ApplyAutoSave()
{
    // Attempt to register the wiaxfer application as the default handler
    TraceEnter (TRACE_PROPUI, "CWiaEventsPage::ApplyAutoSave");
    LONG lRet = PSNRET_NOERROR;

    // validate folder path is not empty. wiaxfer will validate it for
    // real when the camera actually connects

    if (!(*m_szFolderPath))
    {
        UIErrors::ReportMessage (NULL,
                                 GLOBAL_HINSTANCE,
                                 NULL,
                                 MAKEINTRESOURCE(IDS_INVALID_PATH_CAPTION),
                                 MAKEINTRESOURCE(IDS_INVALID_PATH),
                                 MB_ICONSTOP);
        lRet = PSNRET_INVALID;
    }
    else
    {
        UpdateWiaxferSettings ();
        if (!RegisterWiaxfer (c_szWiaxferRegister))
        {
            UIErrors::ReportMessage (NULL,
                                     GLOBAL_HINSTANCE,
                                     NULL,
                                     MAKEINTRESOURCE(IDS_NO_WIAXFER_CAPTION),
                                     MAKEINTRESOURCE(IDS_NO_WIAXFER),
                                     MB_ICONSTOP);
            lRet = PSNRET_INVALID;
        }
    }
    TraceLeave ();
    return lRet;
}



static const TCHAR c_szConnectionSettings[] = TEXT("OnConnect\\%ls");

void
CWiaEventsPage::UpdateWiaxferSettings ()
{
    TraceEnter (TRACE_PROPUI, "CWiaEventsPage::UpdateWiaxferSettings");
    CSimpleReg regSettings (HKEY_CURRENT_USER, REGSTR_PATH_USER_SETTINGS, true, KEY_READ|KEY_WRITE );
    CSimpleString strSubKey;
    // Settings are per-device
    strSubKey.Format (c_szConnectionSettings, m_strDeviceId.String());
    CSimpleReg regActions (regSettings, strSubKey, true, KEY_READ|KEY_WRITE );


    if (regActions.Open ())
    {
        // Set the default action
        regActions.Set(REGSTR_VALUE_CONNECTACT, m_dwAction);

        if (ACTION_AUTOSAVE == m_dwAction)
        {
            // Set the actions for auto-download
            regActions.Set(REGSTR_VALUE_SAVEFOLDER, m_szFolderPath);
            regActions.Set(REGSTR_VALUE_AUTODELETE, m_bAutoDelete?1:0);
            regActions.Set(REGSTR_VALUE_USEDATE, m_bUseDate?1:0);
        }
        else
        {
            // Nothing to do for ACTION_RUNAPP or ACTION_NOTHING
        }
    }
    TraceLeave ();
}

void
CWiaEventsPage::SaveConnectState ()
{
    TraceEnter (TRACE_PROPUI, "CWiaEventsPage::SaveConnectState");
    GetDlgItemText (m_hwnd, IDC_FOLDERPATH, m_szFolderPath, MAX_PATH);
    m_bAutoDelete = IsDlgButtonChecked (m_hwnd, IDB_DELETEONSAVE);
    m_bUseDate = IsDlgButtonChecked (m_hwnd, IDB_USEDATE);
    if (IsDlgButtonChecked (m_hwnd, IDB_LAUNCHAPP))
    {
        m_dwAction = ACTION_RUNAPP;
    }
    else if (IsDlgButtonChecked (m_hwnd, IDB_QUIETSAVE))
    {
        m_dwAction = ACTION_AUTOSAVE;
    }
    else if (IsDlgButtonChecked (m_hwnd, IDC_PROMPT))
    {
        m_dwAction = ACTION_PROMPT;
    }
    else
    {
        m_dwAction = ACTION_NOTHING;
    }

    TraceLeave ();
}


int
ConnectPageBrowseCallback (HWND hwnd, UINT msg, LPARAM lp, LPARAM szPath )
{
    // set the default selection to the current folder path
    if (BFFM_INITIALIZED == msg)
    {
        SendMessage (hwnd, BFFM_SETSELECTION, TRUE, szPath);
    }
    return 0;
}
void
CWiaEventsPage::GetSavePath ()
{
    BROWSEINFO bi;
    ULONG ul;
    CSimpleString strCaption(IDS_SAVEPATH_CAPTION, GLOBAL_HINSTANCE);
    LPITEMIDLIST pidlCurrent;
    TCHAR szNewPath[MAX_PATH] = TEXT("\0");
    HRESULT hr;
    TraceEnter (TRACE_PROPUI, "CWiaEventsPage::GetSavePath");

    ZeroMemory (&bi, sizeof(bi));


    bi.hwndOwner = m_hwnd;
    bi.lpszTitle = strCaption;
    bi.ulFlags = BIF_RETURNONLYFSDIRS | BIF_USENEWUI;
    bi.pszDisplayName = szNewPath;
    bi.lParam = reinterpret_cast<LPARAM>(m_szFolderPath);
    bi.lpfn = ConnectPageBrowseCallback;
    pidlCurrent = SHBrowseForFolder (&bi);
    if (pidlCurrent)
    {
        SHGetPathFromIDList (pidlCurrent, szNewPath);
        SetDlgItemText (m_hwnd, IDC_FOLDERPATH, szNewPath);
        ILFree (pidlCurrent);
    }
    DoILFree (bi.pidlRoot);
    TraceLeave ();
}

/*****************************************************************************

    CWiaEventsPage::VerifyCurrentAction

    Make sure CLSID_PersistCallback is registered as the default connection
    event handler for this device. If it isn't, unregister wiaxfer.

*****************************************************************************/

void
CWiaEventsPage::VerifyCurrentAction (DWORD &dwAction)
{

    TraceEnter (TRACE_PROPUI, "CWiaEventsPage::VerifyCurrentAction");
    EVENTINFO *pei;
    GUID guidEvent = WIA_EVENT_DEVICE_CONNECTED;
    GetEventInfo (m_pItem, guidEvent, &pei);
    if (pei)
    {
        if (pei->bHasDefault && IsEqualCLSID(WIA_EVENT_HANDLER_PROMPT, pei->clsidHandler))
        {
            dwAction = ACTION_PROMPT;
        }

        else if (!(pei->bHasDefault) ||
            !IsEqualCLSID(CLSID_PersistCallback, pei->clsidHandler))
        {
            dwAction = ACTION_RUNAPP;
            RegisterWiaxfer (c_szWiaxferUnregister);
        }

        delete pei;
    }
    TraceLeave ();
}

/*****************************************************************************

    CWiaEventsPage constructor

*****************************************************************************/
static const DWORD pEventsHelpIds [] =
{
    -1L,-1L,
    IDC_SELECTTEXT, IDH_WIA_EVENT_LIST,
    IDC_WIA_EVENT_LIST, IDH_WIA_EVENT_LIST,
    IDC_WIA_APPS, IDH_WIA_APP_LIST,
    IDB_LAUNCHAPP, IDH_WIA_START_PROG,
    IDC_PROMPT, IDH_WIA_PROMPT_PROG,
    IDC_NOACTION , IDH_WIA_NO_ACTION,
    IDB_DELETEONSAVE, IDH_WIA_DELETE_IMAGES,
    IDB_USEDATE, IDH_WIA_SUBFOLD_DATE,
    IDB_BROWSE, IDH_WIA_BROWSE,
    IDB_QUIETSAVE, IDH_WIA_SAVE_TO,
    IDC_FOLDERPATH, IDH_WIA_SAVE_TO_FOLDER,
    0,0
};
CWiaEventsPage::CWiaEventsPage(IWiaItem *pItem)
               : CPropertyPage (IDD_WIA_EVENTS, NULL, pItem, pEventsHelpIds)
{
    TraceEnter (TRACE_PROPUI, "CWiaEventsPage::CWiaEventsPage");
    m_bHandlerChanged = false;
    m_pAppsList = NULL;
    m_himl = NULL;
    m_bReadOnly = FALSE;
    TraceLeave ();
}

CWiaEventsPage::~CWiaEventsPage ()
{
    TraceEnter (TRACE_PROPUI, "CWiaEventsPage::~CWiaEventsPage");
    if (m_pAppsList)
    {
        delete m_pAppsList;
    }


    if (m_himl)
    {
        ImageList_Destroy(m_himl);
    }
    TraceLeave ();
}

/*****************************************************************************

    CWiaEventsPage::OnInit

    Enum available WIA events for this item as well as the apps registered
    to handle each one. Fill in the lists of each.

*****************************************************************************/
INT_PTR
CWiaEventsPage::OnInit()
{
    TraceEnter (TRACE_PROPUI, "CWiaEventsPage::OnInit");
    EVENTINFO *pei;
    //
    // Find out if the user has rights to control services
    // if not, disable all the controls except the ones controlling
    // how auto-download works. Those settings are per-user
    //
    SC_HANDLE hSCM = ::OpenSCManager(NULL,NULL,SC_MANAGER_ALL_ACCESS);

    if (!hSCM) 
    {
        m_bReadOnly = TRUE;
    }
    else
    {
        CloseServiceHandle(hSCM);
    }
    SubclassComboBox (GetDlgItem (m_hwnd, IDC_WIA_EVENT_LIST));
    FillEventListBox();
    m_pAppsList = new CAppListBox (GetDlgItem(m_hwnd, IDC_WIA_APPS),
                                   GetDlgItem(m_hwnd, IDB_LAUNCHAPP),
                                   GetDlgItem(m_hwnd, IDS_NO_APPS));
    // Get the current event selection and update the apps list accordingly
    m_dwAction = GetConnectionSettings ();
    HandleEventComboNotification (CBN_SELCHANGE, GetDlgItem (m_hwnd, IDC_WIA_EVENT_LIST));
    
    TraceLeave ();
    return TRUE;
}

/*****************************************************************************

    CWiaEventsPage::OnApplyChanges

    Cycle through the events, looking for ones whose default app clsid has
    changed. Update the default event handler accordingly for each event.

*****************************************************************************/

LONG
CWiaEventsPage::OnApplyChanges (BOOL bHitOK)
{
    TraceEnter (TRACE_PROPUI, "CWiaEventsPage::OnApplyChanges");
    LRESULT nItems = SendDlgItemMessage (m_hwnd, IDC_WIA_EVENT_LIST,
                                         CB_GETCOUNT, 0, 0);
    EVENTINFO *pei;
    LONG lRet = PSNRET_NOERROR;
    for (--nItems;nItems>=0;nItems--)
    {
        GetEventFromList (static_cast<LONG>(nItems), &pei);
        if (IsEqualCLSID(pei->clsidNewHandler, CLSID_PersistCallback))
        {
            lRet = ApplyAutoSave ();
        }
        if (pei && pei->bNewHandler) // user picked a new handler
        {
            if (!pei->bHasDefault || !IsEqualGUID (pei->clsidHandler, pei->clsidNewHandler))
            {
                // the new handler differs from the old one

                if (FAILED(SetDefaultHandler (m_pItem, pei)))
                {
                    UIErrors::ReportMessage (m_hwnd, GLOBAL_HINSTANCE, NULL,
                                             MAKEINTRESOURCE(IDS_REGISTER_FAILED_TITLE),
                                             MAKEINTRESOURCE(IDS_REGISTER_FAILED));

                    lRet = PSNRET_INVALID;
                }

            }
            if (lRet == PSNRET_NOERROR )
            {
                pei->bHasDefault = true;
                pei->clsidHandler = pei->clsidNewHandler;
            }
        }
    }
    m_bHandlerChanged = false; // reset changed state
    TraceLeaveValue (lRet);
}

/*****************************************************************************

    CWiaEventsPage::OnCommand


*****************************************************************************/


INT_PTR
CWiaEventsPage::OnCommand(WORD wCode, WORD widItem, HWND hwndItem)
{
    INT_PTR iRet = 1;
    TraceEnter (TRACE_PROPUI, "CWiaEventsPage::OnCommand");

    switch (widItem)
    {
        case IDC_WIA_EVENT_LIST:
            iRet = HandleEventComboNotification (wCode, hwndItem);
            break;

        case IDC_WIA_APPS:
            iRet = HandleAppComboNotification (wCode, hwndItem);
            break;

        case IDB_LAUNCHAPP:
            if (IsDlgButtonChecked(m_hwnd, IDB_LAUNCHAPP))
            {
                EnableWindow (GetDlgItem(m_hwnd, IDC_WIA_APPS), TRUE);
                HandleAppComboNotification (CBN_SELCHANGE, GetDlgItem(m_hwnd, IDC_WIA_APPS));

            };
            break;

        case IDB_BROWSE:
            GetSavePath ();
            break;

        case IDB_QUIETSAVE:
        case IDC_PROMPT:
        case IDC_NOACTION:
            GUID guid;
            EVENTINFO *pei;

            if (!IsDlgButtonChecked(m_hwnd, IDB_LAUNCHAPP))
            {
                EnableWindow (GetDlgItem(m_hwnd, IDC_WIA_APPS), FALSE);
            };
            LRESULT lEvent = SendDlgItemMessage (m_hwnd,
                                                 IDC_WIA_EVENT_LIST,
                                                 CB_GETCURSEL, 0, 0);
            if (IsDlgButtonChecked(m_hwnd, widItem) && lEvent >= 0)
            {
                BOOL bConnect;
                GetEventFromList (static_cast<LONG>(lEvent), &pei);
                bConnect= IsEqualCLSID (pei->guidEvent, WIA_EVENT_DEVICE_CONNECTED);
                if (pei)
                {
                    pei->bNewHandler = true;
                    if (widItem == IDC_NOACTION)
                    {
                        if (bConnect)
                        {
                            m_dwAction = ACTION_NOTHING;
                        }
                        guid = WIA_EVENT_HANDLER_NO_ACTION;
                    }
                    else if (widItem == IDC_PROMPT)
                    {
                        if (bConnect)
                        {
                            m_dwAction = ACTION_PROMPT;
                        }
                        guid = WIA_EVENT_HANDLER_PROMPT;
                    }
                    else
                    {
                        if (bConnect)
                        {
                            m_dwAction = ACTION_AUTOSAVE;
                        }
                        guid = CLSID_PersistCallback;
                    }
                    pei->clsidNewHandler = guid;
                    pei->strDesc = L"internal handler";
                    pei->strIcon = L"wiashext.dll, -101";
                    pei->strName = L"internal";
                    pei->strCmd = (BSTR)NULL;
                    pei->ulFlags = WIA_IS_DEFAULT_HANDLER;
                    if (!pei->bHasDefault ||
                        !IsEqualGUID(guid, pei->clsidHandler))
                    {
                        m_bHandlerChanged = true;
                    }
                }
            }
            break;
    }
    // Turn off controls related to auto-save if that button is not checked
    BOOL bAutoSave = IsDlgButtonChecked (m_hwnd, IDB_QUIETSAVE);
    EnableWindow (GetDlgItem (m_hwnd, IDB_USEDATE), bAutoSave);
    EnableWindow (GetDlgItem (m_hwnd, IDB_DELETEONSAVE), bAutoSave);
    EnableWindow (GetDlgItem (m_hwnd, IDC_FOLDERPATH), bAutoSave);
    EnableWindow (GetDlgItem (m_hwnd, IDB_BROWSE), bAutoSave);
    TraceLeave ();
    return iRet;
}

/*****************************************************************************

    CWiaEventsPage::HandleEventComboNotification


    When the combobox selection changes, free the current application data
    and re-fill the app list

*****************************************************************************/


INT_PTR
CWiaEventsPage::HandleEventComboNotification(WORD wCode, HWND hCombo)
{
    TraceEnter (TRACE_PROPUI, "CWiaEventsPage::HandleEventComboNotification");
    switch (wCode)
    {
        case CBN_SELCHANGE:
        {
            if (m_pAppsList)
            {
                LRESULT lItem;
                EVENTINFO *pei;
                m_pAppsList->FreeAppData ();
                lItem = SendMessage (hCombo, CB_GETCURSEL, 0, 0);
                if (lItem >= 0)
                {
                    EnableWindow (GetDlgItem (m_hwnd, IDC_NOACTION), !m_bReadOnly);
                    GetEventFromList (static_cast<LONG>(lItem), &pei);
                    bool bConnect = false;
                    if (pei)
                    {
                        if (IsEqualCLSID (pei->guidEvent, WIA_EVENT_DEVICE_CONNECTED))
                        {
                            bConnect= true;
                        }
                        m_pAppsList->FillAppListBox (m_pItem, pei);
                        if (pei->nHandlers)
                        {
                            EnableWindow (GetDlgItem (m_hwnd, IDB_LAUNCHAPP), !m_bReadOnly);
                            EnableWindow (GetDlgItem (m_hwnd, IDC_WIA_APPS), !m_bReadOnly);

                        }
                        // disable the "prompt" button if needed
                        EnableWindow (GetDlgItem(m_hwnd, IDC_PROMPT), (!m_bReadOnly && pei->nHandlers >= 2));

                        // Make sure our radio buttons are in the proper state
                        if (IsEqualCLSID (pei->clsidNewHandler, WIA_EVENT_HANDLER_PROMPT))
                        {
                            CheckRadioButton (m_hwnd, IDB_LAUNCHAPP, IDB_QUIETSAVE, IDC_PROMPT);
                        }
                        else if (!(pei->nHandlers) || IsEqualCLSID (pei->clsidNewHandler, WIA_EVENT_HANDLER_NO_ACTION))
                        {
                            CheckRadioButton (m_hwnd, IDB_LAUNCHAPP, IDB_QUIETSAVE, IDC_NOACTION);
                        }
                        else if (IsEqualCLSID (pei->clsidNewHandler, CLSID_PersistCallback))
                        {
                            CheckRadioButton (m_hwnd, IDB_LAUNCHAPP, IDB_QUIETSAVE, IDB_QUIETSAVE);
                        }
                        else
                        {
                            CheckRadioButton (m_hwnd, IDB_LAUNCHAPP, IDB_QUIETSAVE, IDB_LAUNCHAPP);
                        }
                        // only enable the app list if "run an app" is selected
                        if (!IsDlgButtonChecked (m_hwnd, IDB_LAUNCHAPP) || m_bReadOnly)
                        {
                            EnableWindow (GetDlgItem(m_hwnd, IDC_WIA_APPS), FALSE);
                        }
                        EnableAutoSave (bConnect?TRUE:FALSE);
                    }
                }
            }
        }
        break;
    }
    TraceLeave ();
    return 0;
}

bool
CWiaEventsPage::StateChanged()
{
    TCHAR szNewPath[MAX_PATH];
    BOOL bNewDel;
    LONG lNewSel;
    bool bRet = m_bHandlerChanged;
    TraceEnter (TRACE_PROPUI, "CWiaEventsPage::StateChanged");
    GetDlgItemText (m_hwnd, IDC_FOLDERPATH, szNewPath, MAX_PATH);
    // empty path is an invalid state
    if (lstrcmp(szNewPath, m_szFolderPath) || !*m_szFolderPath)
    {
        bRet= true;
    }
    bNewDel = IsDlgButtonChecked (m_hwnd, IDB_DELETEONSAVE);
    if (bNewDel != m_bAutoDelete)
    {
        bRet = true;
    }
    bNewDel = IsDlgButtonChecked (m_hwnd, IDB_USEDATE);
    if (bNewDel != m_bUseDate)
    {
        bRet =  true;
    }
    TraceLeaveValue (bRet);
}

void
CWiaEventsPage::SaveCurrentState()
{
    SaveConnectState ();

}

/*****************************************************************************

    CWiaEventsPage::FillEventsListBox

    Enumerate the supported events for our device, and add a comboboxitemex
    entry for each one. The LPARAM of the item is a pointer to an EVENTINFO
    struct.

*****************************************************************************/

void
CWiaEventsPage::FillEventListBox ()
{

    WIA_DEV_CAP wdc;
    CComPtr<IEnumWIA_DEV_CAPS> pEnum;

    COMBOBOXEXITEM cbex;
    HICON      hIcon;
    INT cxIcon = min(16,GetSystemMetrics (SM_CXSMICON));
    INT cyIcon = min(16,GetSystemMetrics (SM_CYSMICON));
    UINT nEvents = 0;
    HWND hCombo;
    WORD wType;
    INT iDefault = 0;
    TraceEnter (TRACE_PROPUI, "CWiaEventsPage::FillEventListBox");

    if (m_himl)
    {
        ImageList_Destroy(m_himl);
    }
    // Create our event icon image list and add the default icon to it
    m_himl = ImageList_Create (cxIcon,
                             cyIcon,
                             PrintScanUtil::CalculateImageListColorDepth()|ILC_MASK,
                             10,
                             100);

    hIcon = LoadIcon (GLOBAL_HINSTANCE, MAKEINTRESOURCE(IDI_EVENT));
   /* hIcon = reinterpret_cast<HICON>(LoadImage (GLOBAL_HINSTANCE,
                                               MAKEINTRESOURCE(IDI_EVENT),
                                               IMAGE_ICON,
                                               cxIcon,
                                               cyIcon,
                                               LR_SHARED | LR_DEFAULTCOLOR));*/
    ImageList_AddIcon (m_himl, hIcon);

    // ImageList has made a (bitmap) copy of our icon, so we can destroy it now
    DestroyIcon( hIcon );


    hCombo = GetDlgItem (m_hwnd, IDC_WIA_EVENT_LIST);

    // Turn off redraws until we've added the complete list
    SendMessage (hCombo, WM_SETREDRAW, FALSE, 0);

    // Assign this imagelist to the comboboxex
    SendMessage (hCombo, CBEM_SETIMAGELIST, 0, reinterpret_cast<LPARAM>(m_himl));

    GetDeviceTypeFromDevice (m_pItem, &wType);
    // Enum the events this device supports and add them to the list
    if (SUCCEEDED(m_pItem->EnumDeviceCapabilities(WIA_DEVICE_EVENTS,
                                                  &pEnum)))
    {

        INT i = 1; // current image list index
        EVENTINFO *pei;
        CSimpleStringWide strNameW;
        CSimpleString strName;
        INT iItem; //index of inserted item
        while (S_OK == pEnum->Next (1, &wdc, NULL))
        {

            Trace(TEXT("wdc.ulFlags == %x"), wdc.ulFlags);
            // only enum Action events
            if (!(wdc.ulFlags & WIA_ACTION_EVENT))
            {
                continue;
            }
            strNameW = wdc.bstrName;
            ZeroMemory (&cbex, sizeof(cbex));
            cbex.mask = CBEIF_TEXT | CBEIF_LPARAM | CBEIF_SELECTEDIMAGE | CBEIF_IMAGE;
            strName = CSimpleStringConvert::NaturalString(strNameW);
            cbex.pszText = const_cast<LPTSTR>(strName.String());
            cbex.iItem = -1;

            // Set the appropriate icon
            if (wdc.bstrIcon && *(wdc.bstrIcon))
            {
                if (AddIconToImageList (m_himl, wdc.bstrIcon))
                {
                    cbex.iImage = cbex.iSelectedImage = i++;
                }

            } // default to 0, the default icon

            // Save the current event info as lParam
            GetEventInfo (m_pItem, wdc.guid, &pei);
            cbex.lParam = reinterpret_cast<LPARAM>(pei);
            iItem = (INT)SendMessage (hCombo,
                                 CBEM_INSERTITEM,
                                 0,
                                 reinterpret_cast<LPARAM>(&cbex));
            if (-1 == iItem)
            {
                DoDelete( pei); // clean up if insert failed
            }
            else
            {
                //
                // If the inserted GUID is the scan event for scanners or the connect event for
                // cameras, make it the default selection
                if ((wType == StiDeviceTypeDigitalCamera && wdc.guid == WIA_EVENT_DEVICE_CONNECTED)
                    || (wType == StiDeviceTypeScanner && wdc.guid == WIA_EVENT_SCAN_IMAGE))
                {
                    Trace(TEXT("Default item should be %d: %s"), iItem, cbex.pszText);
                    iDefault = iItem;
                }
                nEvents++;
            }
        }
    }
    // Inform the user if there are no events
    if (!nEvents)
    {
        EnableWindow (GetDlgItem(m_hwnd, IDC_SELECTTEXT), FALSE);
        ShowWindow (GetDlgItem(m_hwnd, IDC_SELECTTEXT), SW_HIDE);
        ShowWindow (hCombo, SW_HIDE);
        ShowWindow (GetDlgItem(m_hwnd, IDC_NOEVENTS), SW_SHOW);

    }
    else
    {
        ShowWindow (GetDlgItem(m_hwnd, IDC_NOEVENTS), SW_HIDE);
    }
    SendMessage (hCombo, CB_SETCURSEL, iDefault, 0);
    SendMessage (hCombo, WM_SETREDRAW, TRUE, 0);
    TraceLeave ();
}


/*****************************************************************************
    CWiaEventsPage::GetEventFromList

    Retrieve the EVENTINFO struct for the given index

*****************************************************************************/
void
CWiaEventsPage::GetEventFromList (LONG idx, EVENTINFO **ppei)
{
    TraceEnter (TRACE_PROPUI, "CWiaEventsPage::GetEventFromList");
    TraceAssert (ppei);
    HWND hCombo = GetDlgItem (m_hwnd, IDC_WIA_EVENT_LIST);
    COMBOBOXEXITEM cbex = {0};
    cbex.mask = CBEIF_LPARAM;
    cbex.iItem = idx;
    SendMessage (hCombo,
                 CBEM_GETITEM,
                 0,
                 reinterpret_cast<LPARAM>(&cbex));
    *ppei = reinterpret_cast<EVENTINFO*>(cbex.lParam);

    TraceLeave ();
}

/*****************************************************************************

    CWiaEventsPage::HandleAppComboNotification

    When the user changes the selected app to handle the current selected event,
    update that event's EVENTINFO struct.

*****************************************************************************/
INT_PTR
CWiaEventsPage::HandleAppComboNotification (WORD wCode, HWND hCombo)
{
    TraceEnter (TRACE_PROPUI, "CWiaEventsPage::HandleAppComboNotification");
    switch (wCode)
    {
        case CBN_SELCHANGE:
        {
            EVENTINFO *pei;
            WIA_EVENT_HANDLER weh;
            LRESULT lEvent = SendDlgItemMessage (m_hwnd,
                                                 IDC_WIA_EVENT_LIST,
                                                 CB_GETCURSEL, 0, 0);
            if (lEvent >= 0)
            {
                GetSelectedHandler (m_hwnd, IDC_WIA_APPS, weh);
                GetEventFromList (static_cast<LONG>(lEvent), &pei);
                if (pei)
                {
                    pei->bNewHandler = true;
                    pei->clsidNewHandler = weh.guid;
                    pei->strDesc = weh.bstrDescription;
                    pei->strIcon = weh.bstrIcon;
                    pei->strName = weh.bstrName;
                    pei->ulFlags = weh.ulFlags;
                    pei->strCmd  = weh.bstrCommandline;
                    if (!pei->bHasDefault ||
                        !IsEqualGUID(weh.guid, pei->clsidHandler))
                    {
                        m_bHandlerChanged = true;
                    }
                }
            }
        }
        break;
    }
    TraceLeave ();
    return 0;
}

/*****************************************************************************

    CWiaEventsPage::OnNotify

    Handle notifications from the event comboex

*****************************************************************************/

bool
CWiaEventsPage::OnNotify(LPNMHDR pnmh, LRESULT *presult)
{
    bool bRet = false;
    TraceEnter(TRACE_PROPUI, "CWiaEventsPage::OnNotify)");
    if (pnmh->hwndFrom == GetDlgItem(m_hwnd, IDC_WIA_EVENT_LIST))
    {

        NMCOMBOBOXEX *pnmc = reinterpret_cast<NMCOMBOBOXEX*>(pnmh);
        switch (pnmh->code)
        {
            case CBEN_DELETEITEM:
                //
                // We get this message when the comboboxex is destroyed
                // Need to free the EVENTINFO structs we store with each item
                //
                Trace(TEXT("Got CBEN_DELETEITEM. item: %d, mask: %x"),
                      pnmc->ceItem.iItem, pnmc->ceItem.mask);
                if (pnmc->ceItem.mask & CBEIF_LPARAM)
                {
                    delete reinterpret_cast<EVENTINFO *>(pnmc->ceItem.lParam);
                }
                break;
        }
        bRet = true;
    }
    TraceLeaveValue(bRet);
}


/*****************************************************************************

    GetSelectedHandler

    Retrieve the WIA_EVENT_HANDLER info from the listbox for the current
    selection

*****************************************************************************/
bool
GetSelectedHandler (HWND hDlg, INT idCtrl, WIA_EVENT_HANDLER &weh)
{

    bool bRet = false;
    COMBOBOXEXITEM cbex;

    TraceEnter (TRACE_PROPUI, "GetSelectedHandler");
    ZeroMemory (&weh, sizeof(weh));
    ZeroMemory (&cbex, sizeof(cbex));
    cbex.mask = CBEIF_LPARAM;
    cbex.iItem = SendDlgItemMessage (hDlg,
                                     idCtrl,
                                     CB_GETCURSEL,
                                     0,0);
    if (cbex.iItem >=0)
    {
        SendDlgItemMessage (hDlg,
                            idCtrl,
                            CBEM_GETITEM,
                            0,
                            reinterpret_cast<LPARAM>(&cbex));
        if (cbex.lParam)
        {
            weh = *(reinterpret_cast<WIA_EVENT_HANDLER*>(cbex.lParam));
            bRet = true;
        }
    }

    TraceLeave ();
    return bRet;
}



/*****************************************************************************

     AddIconToImageList

     Load the icon indicated by bstrIconPath and add it to himl

*****************************************************************************/

bool
AddIconToImageList (HIMAGELIST himl, BSTR strIconPath)
{
    bool bRet = false;
    TraceEnter (TRACE_PROPUI, "AddIconToImageList");

    TCHAR szPath[MAX_PATH];
    LONG  nIcon;
    INT   nComma=0;
    HICON hIcon = NULL;
    HICON hUnused;
    HRESULT hr;
    while (strIconPath[nComma] && strIconPath[nComma] != L',')
    {
        nComma++;
    }
    if (strIconPath[nComma])
    {
        ZeroMemory (szPath, sizeof(szPath));
        nIcon = wcstol (strIconPath+nComma+1, NULL, 10);
#ifdef UNICODE
        wcsncpy (szPath, strIconPath, nComma);
        *(szPath+nComma)=L'\0';
#else
        WideCharToMultiByte (CP_ACP,
                             0,
                             strIconPath, nComma,
                             szPath, MAX_PATH,
                             NULL,NULL);
#endif
        Trace (TEXT("icon path is %s, %d"), szPath, nIcon);
        hr = SHDefExtractIcon (szPath, nIcon, 0, &hUnused, &hIcon, 0);
        Trace(TEXT("SHDefExtractIcon returned %x"), hr);
        if (SUCCEEDED(hr) && hIcon)
        {
            ImageList_AddIcon (himl, hIcon);
            DestroyIcon(hIcon);
            DestroyIcon(hUnused);
            bRet = true;
        }
    }

    TraceLeave ();
    return bRet;
}

/*****************************************************************************

    SetAppSelection

    Given a clsid, find it in the app combobox and select it

*****************************************************************************/

void
SetAppSelection (HWND hDlg, INT idCtrl, CLSID &clsidSel)
{
    TraceEnter (TRACE_PROPUI, "SetAppSelection");
    COMBOBOXEXITEM cbex;
    WIA_EVENT_HANDLER *peh;
    HWND hCombo = GetDlgItem (hDlg, idCtrl);
    LRESULT lItems = SendMessage (hCombo,
                                  CB_GETCOUNT,
                                  0,0);
    cbex.mask = CBEIF_LPARAM;

    for (cbex.iItem=0;cbex.iItem < lItems;cbex.iItem++)
    {
        cbex.lParam = NULL;
        SendMessage (hCombo,
                     CBEM_GETITEM,
                     0,
                     reinterpret_cast<LPARAM>(&cbex));
        peh = reinterpret_cast<WIA_EVENT_HANDLER*>(cbex.lParam);
        if (peh)
        {
            if (IsEqualCLSID(clsidSel, peh->guid))
            {
                SendMessage (hCombo,
                             CB_SETCURSEL,
                             cbex.iItem, 0);
            }
        }
    }

    TraceLeave ();
}

/*****************************************************************************

    SetDefaultHandler

    Register the new default handler for the selected event for our item

*****************************************************************************/

HRESULT
SetDefaultHandler (IWiaItem *pItem, EVENTINFO *pei)
{
    HRESULT hr;
    TraceEnter (TRACE_PROPUI, "SetDefaultHandler");

    CComPtr<IWiaDevMgr> pDevMgr;
    WCHAR szDeviceId[STI_MAX_INTERNAL_NAME_LENGTH];
    GetDeviceIdFromDevice (pItem, szDeviceId);
    CComBSTR strDeviceId(szDeviceId);
    hr = GetDevMgrObject (reinterpret_cast<LPVOID*>(&pDevMgr));
    if (SUCCEEDED(hr))
    {
        pDevMgr->RegisterEventCallbackCLSID (WIA_REGISTER_EVENT_CALLBACK,
                                             strDeviceId,
                                             &pei->guidEvent,
                                             &pei->clsidNewHandler,
                                             pei->strName,
                                             pei->strDesc,
                                             pei->strIcon);

        hr = pDevMgr->RegisterEventCallbackCLSID (WIA_SET_DEFAULT_HANDLER,
                                                  strDeviceId,
                                                  &pei->guidEvent,
                                                  &pei->clsidNewHandler,
                                                  pei->strName,
                                                  pei->strDesc,
                                                  pei->strIcon);
    }

    TraceLeaveResult (hr);
}

/*****************************************************************************

    GetEventInfo

    Return the current default handler and number of handlers for this event

*****************************************************************************/

void
GetEventInfo (IWiaItem *pItem, const GUID &guid, EVENTINFO **ppei)
{
    TraceEnter (TRACE_PROPUI, "CWiaEventsPage::GetEventInfo");
    CComPtr<IEnumWIA_DEV_CAPS> pEnum;
    WIA_EVENT_HANDLER weh;
    EVENTINFO *pei;
    HRESULT hr;
    pei = new EVENTINFO;
    if (pei)
    {
        ZeroMemory (pei, sizeof(EVENTINFO));
        pei->guidEvent = guid;
    }

    hr = pItem->EnumRegisterEventInfo (0,
                                       &guid,
                                       &pEnum);

    if (pei && S_OK == hr)
    {
        TraceAssert (pEnum.p);
        while (S_OK == pEnum->Next (1, &weh, 0))
        {
            pei->nHandlers++;
            if (weh.ulFlags & WIA_IS_DEFAULT_HANDLER)
            {
                pei->bHasDefault = true;
                pei->clsidHandler = weh.guid;
                pei->clsidNewHandler = weh.guid;
                pei->strCmd = weh.bstrCommandline;
            }
            // Free the enumerated strings
            SysFreeString (weh.bstrDescription);
            SysFreeString (weh.bstrIcon);
            SysFreeString (weh.bstrName);
            SysFreeString (weh.bstrCommandline);
        }
    }
    *ppei = pei;
    TraceLeave ();
}

bool CWiaEventsPage::ItemSupported(IWiaItem *pItem)
{
    bool bRet = false;
    CComPtr<IEnumWIA_DEV_CAPS> pEnum;
    if (SUCCEEDED(pItem->EnumDeviceCapabilities(WIA_DEVICE_EVENTS,
                                                  &pEnum)))
    {
        WIA_DEV_CAP wdc;
        ULONG ul = 0;
        while (!bRet && S_OK == pEnum->Next(1, &wdc, &ul))
        {
            bRet =  ((wdc.ulFlags & WIA_ACTION_EVENT) > 0);
            if (wdc.bstrCommandline)
            {
                SysFreeString (wdc.bstrCommandline);
            }
            if (wdc.bstrDescription)
            {
                SysFreeString (wdc.bstrDescription);
            }
            if (wdc.bstrIcon)
            {
                SysFreeString (wdc.bstrIcon);
            }
            if (wdc.bstrName)
            {
                SysFreeString (wdc.bstrName);
            }

        }
    }
    return bRet;
}

CDevicePage::CDevicePage (unsigned uResource, IWiaItem *pItem , const DWORD *pHelpIDs) :
    CPropertyPage (uResource, NULL, pItem, pHelpIDs)
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\src\sources.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1989 - 1999

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

USE_SHFUSION=1

!include          $(PROJECT_ROOT)\ui\uienv.inc
SOURCES_USED    = $(SOURCES_USED) $(PROJECT_ROOT)\ui\uienv.inc

#NO_BROWSER_FILE = 1
TARGETNAME      = wiashext
TARGETTYPE      = DYNLINK
TARGETPATH      = obj
TARGETEXT       = dll
TARGETPATHLIB   = $(PROJECT_ROOT)\ui\lib\$(PLATFORM_SUFFIX)
DLLDEF          = ..\wiashext.def
DLLENTRY        = _DllMainCRTStartup
DLLBASE         = 0x77000000
USE_MSVCRT      = 1

ATL_VER         = 30
USE_STATIC_ATL  = 1
TARGETLIBS=$(TARGETLIBS)\
        $(SHELL_LIB_PATH)\shfusion.lib                                  \
        $(SHELL_LIB_PATH)\shdocvw.lib                                   \
        $(PROJECT_ROOT)\ui\shellext\lib\$(PLATFORM_SUFFIX)\*\common.lib \
        $(SDK_LIB_PATH)\wininet.lib

DELAYLOAD=winmm.dll;setupapi.dll;sti.dll
          
DLOAD_ERROR_HANDLER=kernel32

INCLUDES=   $(INCLUDES);                     \
            $(PROJECT_ROOT)\ui\shellext\inc; \
            $(PROJECT_ROOT)\ui\shellext\src;\
            $(PROJECT_ROOT)\ui\shellext\src\res             

SOURCES=\
        ..\resource.rc     \
        ..\baseview.cpp    \
        ..\dataobj2.cpp    \
        ..\details.cpp     \
        ..\dll.cpp         \
        ..\enum.cpp        \
        ..\factory.cpp     \
        ..\folder.cpp      \
        ..\icon.cpp        \
        ..\image.cpp       \
        ..\idlist.cpp      \
        ..\moniker.cpp     \
        ..\progcb.cpp      \
        ..\propui.cpp      \
        ..\stream.cpp      \
        ..\util.cpp        \
        ..\verbs.cpp       \
        ..\stiprop.cpp     \
        ..\prpages.cpp     
               

PRECOMPILED_INCLUDE=..\precomp.hxx
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

#
#
# Fusion manifest
#
SXS_MANIFEST_RESOURCE_ID=123
SXS_APPLICATION_MANIFEST=wiashext.Manifest
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\src\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       resource.h
//
//--------------------------------------------------------------------------


#define IDI_STIEXT                      100
#define IDI_CAMERA                      101
#define IDI_SCANNER                     102
#define IDI_PICTURE_JPG                 103
#define IDI_UNKNOWN                     104
#define IDI_FOLDER                      105
#define IDI_ADDDEVICE                   106
#define IDI_PICTURE_BMP                 107
#define IDI_REMOTECAM                   108
#define IDI_REMOTESCAN                  109
#define IDI_SELECT                      110
#define IDI_UNSELECT                    111
#define IDI_DEFAULT                     112
#define IDI_STILL_IMAGE                 113
#define IDI_VIDEO_CAMERA                114
#define IDI_EVENT                       IDI_DEFAULT
#define IDI_STIDEVICE                   115
#define IDI_GENERIC_IMAGE               116
#define IDI_AUDIO_IMAGE                 117
#define IDI_GENERIC_AUDIO               118
#define IDI_USE_WIZARD                  119
#define IDI_TAKE_PICTURE                120
#define IDI_SHOW_PROPERTIES             130
#define IDI_DELETE_ALL_IMAGES           131

#define IDC_STATIC                       -1
#define IDS_MULTIPROP_SEL               174
#define IDS_USE_WIZARD                  175
#define IDS_TAKE_PICTURE                176
#define IDS_CAMERA_PROPERTIES           177
#define IDS_DELETE_ALL                  178
#define IDS_DEVICENAME                  200
#define IDS_DEVICECLASS                 201
#define IDS_ITEMNAME                    220
#define IDS_ITEMTYPE                    221
#define IDS_ITEMDATE                    222
#define IDS_ITEMSIZE                    223
#define IDS_BYOBJECTNAME                250
#define IDS_BYTYPE                      251
#define IDS_BYDATE                      252
#define IDS_BYSIZE                      253
#define IDS_BMP_EXT                     254
#define IDS_JPEG_EXT                    255
#define IDS_EXTENSION_NAME              256
#define IDS_ADD_DEVICE                  257
#define IDS_DOWNLOADING_IMAGE           258
#define IDS_PROCESSING_IMAGE            259
#define IDS_TRANSFERRING_IMAGE          260
#define IDS_DEVICE_MANAGER              261
#define IDS_BYTES                       264
#define IDS_RETREIVING                  265
#define IDS_CONNECTING_TO               266
#define IDS_NUM_BYTES                   267
#define IDS_GENERAL                     268
#define IDS_DOWNLOAD_COMPLETE           269
#define IDS_DOWNLOAD_FAILED             270
#define IDS_DOWNLOAD_CAPTION            271
#define IDS_ON                          272
#define IDS_YES                         273
#define IDS_NO                          274
#define IDS_CAMERADEVICE                275
#define IDS_SCANNERDEVICE               276
#define IDS_UNKNOWNDEVICE               277
#define IDS_STILLIMAGE                  278
#define IDS_AUDIOITEM                   279
#define IDS_FOLDER                      280
#define IDS_UNKNOWNTYPE                 281
#define IDS_TITLECONFIRM                282
#define IDS_TITLECONFIRM_MULTI          283
#define IDS_CONFIRM                     284
#define IDS_CONFIRM_MULTI               285
#define IDS_TITLECONFIRM_FOLDER         286
#define IDS_CONFIRM_FOLDER              287
#define IDS_NOT_IMPLEMENTED             288
#define IDS_ADDWIZARDFAILED             289
#define IDS_OPERATIONAL                 290
#define IDS_PENDING                     291
#define IDS_ERROR                       292
#define IDS_PAUSED                      293
#define IDS_PAPER_JAM                   294
#define IDS_PAPER_PROBLEM               295
#define IDS_OFFLINE                     296
#define IDS_IO_ACTIVE                   297
#define IDS_BUSY                        298
#define IDS_TRANSFERRING                299
#define IDS_INITIALIZING                300
#define IDS_WARMING_UP                  301
#define IDS_USER_INTERVENTION           302
#define IDS_POWER_SAVE                  303
#define IDS_UNAVAILABLE                 304
#define IDS_BROWSER_TITLE               305
#define IDS_DIAGNOSTIC_FAILED           306
#define IDS_DIAGNOSTIC_SUCCESS          307
#define IDS_SUCCESS                     308
#define IDS_NO_SUCCESS                  309
#define IDS_CAMERA_EVENTS               310
#define IDS_SCANNER_EVENTS              311
#define IDS_SCANNER_CLIENT              312
#define IDS_TSHOOT_CMD                  313
#define IDS_CONFIRM_REMOVAL             314
#define IDS_REMOVAL_MESSAGE             315
#define IDS_USER_NOT_ADMIN              316
#define IDS_SCNAME                      317
#define IDS_NO_EVENTS                   318
#define IDS_NO_APPS                     319
#define IDS_OTHER_FORMAT                320
#define IDS_NO_WIAXFER                  322
#define IDS_NO_APP_SELECTED             323
#define IDS_NO_SCAN_CAPTION             324
#define IDS_NO_WIAXFER_CAPTION          325
#define IDS_INVALID_PATH_CAPTION        326
#define IDS_INVALID_PATH                327
#define IDS_SAVEPATH_CAPTION            328
#define IDS_ADDDEV_DESC                 329
#define IDS_FOLDER_DESC                 330
#define IDS_DISPLAYNAME                 331 // this value is referenced in the inf
#define IDS_WIACAM_INFOTIP              332
#define IDS_WIASCAN_INFOTIP             333
#define IDS_STIDEVICE_INFOTIP           334
#define IDS_PLAYINGSOUND                335
#define IDS_WIAVID_INFOTIP              336
#define IDS_INVALIDNAME_TITLE           337
#define IDS_INVALIDNAME                 338
#define IDS_TITLECONFIRM_DEVICE         339
#define IDS_WAVEFILE                    340
#define IDS_MPFILE                      341
#define IDS_TEST_UNAVAIL                342
#define IDS_REGISTER_FAILED_TITLE       343
#define IDS_REGISTER_FAILED             344
#define IDS_SNAPSHOTCAPTION             345
#define IDS_SNAPSHOTERR                 346
#define IDS_PICTURE_COUNT               347
#define IDS_PLUGGED_IN                  348
#define IDS_ON_BATTERY                  349
#define IDS_FLASHMODE_AUTO              350
#define IDS_FLASHMODE_OFF               351
#define IDS_FLASHMODE_FILL              352
#define IDS_FLASHMODE_REDEYE_AUTO       353
#define IDS_FLASHMODE_REDEYE_FILL       354
#define IDS_FLASHMODE_EXTERNALSYNC      355
#define IDS_FLASHMODE_DEVICE            356
#define IDS_TAKEN                       357
#define IDS_REMAIN                      358
#define IDS_SAVE_MYPICS                 359
#define IDS_COMMUNICATING_CAPTION       360
#define IDS_COMMUNICATING_WAITING       361
#define IDS_COMMUNICATING_BUSY          362
#define IDS_TITLEDELETE_ERROR           363
#define IDS_DELETE_ERROR                364
#define IDS_NO_SCAN                     365
#define IDS_WIZARD                      366
#define IDS_WIZARD_TYPE                 367

#define IDR_CAMERAITEMS                 369
#define IDR_ARRANGE                     370

#define IDR_CAMERA                      375
#define IDR_SCANNER                     377

#define IDS_CANT_INSTALL                380
#define IDS_PRIVILEGE_CAPTION           381
#define IDC_FORCE_ENUM                  401
#define IDD_GENERALPNP_PAGE             402
#define IDD_GENERAL_PAGE                403
#define IDD_EVENT_MONITOR               404
#define IDD_GENERAL                     405
#define IDD_CONTROL_PANEL               406
#define IDD_LOGGING_PAGE                407
#define IDD_PREVIEW_WARN                410
#define IDC_WARN                        411
#define IDC_STATIC1                     412
#define IDC_STATIC2                     413


#define IDD_IMAGE_GENERAL               525
#define IDC_STATIC_NAME                 526
#define IDC_STATIC_SIZE                 527
#define IDC_STATIC_DATE                 528
#define IDC_STATIC_FORMAT               529
#define IDC_IMAGE_NAME                  530
#define IDC_IMAGE_SIZE                  531
#define IDC_IMAGE_DATE                  532
#define IDC_IMAGE_FORMAT                533
#define IDC_STATIC_TIME                 534
#define IDC_IMAGE_TIME                  535
#define IDC_STATIC_CONTAINS             536
#define IDC_IMAGE_CONTAINS              537

#define IDD_CONTAINER_GENERAL           550

#define IDC_WIA_PORT_STATIC             574
#define IDD_CAMERA_GENERAL              575
#define IDC_DESCRIPTION                 576
#define IDC_ITEMICON                    577
#define IDC_TIME_LABEL                  578
#define IDC_WIA_PORT_LIST               579
#define IDC_TAKEN_LABEL                 580
#define IDC_MANUFACTURER                581
#define IDC_TAKEN                       582
#define IDC_FLASH_LABEL                 583
#define IDC_FLASH_MODE_STATIC           584
#define IDC_FLASH_MODE_LIST             585
#define IDC_BATTERY_LABEL               586
#define IDC_BATTERY                     587
#define IDC_SET_TIME                    588
#define IDC_CURRENT_TIME                589
#define IDC_IMAGESIZE_SLIDER            590
#define IDC_IMAGESIZE_STATIC            591
#define IDC_TESTCAM                     592
#define IDC_LOW_QUALITY                 593
#define IDC_HIGH_QUALITY                594
#define IDC_PORT_SPEED_LABEL            595
#define IDC_PORT_SPEED                  596
#define IDC_MANUFACTURER_LABEL          597

#define IDD_DOWNLOAD                    600
#define IDC_PROGRESS                    601
#define IDC_BYTES_DOWNLOADED            602
#define IDC_STATUS                      603

#define IDD_SCANNER_GENERAL             700
#define IDC_STATUS_LABEL                701
#define IDC_DEVICE_STATUS               702


#define IDD_CAMERA_CONNECT              750
#define IDB_RUNAPP                      751
#define IDB_DONOTHING                   753
#define IDC_PORT_LABEL                  754
#define IDC_RESOLUTION_LABEL            755
#define IDC_RESOLUTION                  756
#define IDC_TESTSCAN                    757

#define IDD_WIA_EVENTS                  800
#define IDC_WIA_EVENT_LIST              801
#define IDC_WIA_APPS                    802
#define IDB_LAUNCHAPP                   803
#define IDC_PROMPT                      804
#define IDC_NOACTION                    805
#define IDB_QUIETSAVE                   806
#define IDC_SELECTTEXT                  752
#define IDC_NOEVENTS                    807
#define IDC_SELECTEDAPP                 754
#define IDC_FOLDERPATH                  755
#define IDB_BROWSE                      756
#define IDB_DELETEONSAVE                757
#define IDB_USEDATE                     758

#define IDC_DEVICE_LIST                 1000
#define IDC_BUTTON_ADD                  1001
#define IDD_INTRO_TEXT                  1001
#define IDC_BUTTON_PROP                 1002
#define IDC_BUTTON_REMOVE               1003
#define IDC_SCANNER_ICON                1004
#define IDC_CURRENT_DEFAULT             1005
#define IDC_BUTTON_TEST                 1006
#define IDC_DEVICE_ICON                 1007
#define IDC_FRIENDLY                    1008
#define IDC_MAKER                       1009
#define IDC_DESCRIBE                    1010
#define IDC_CAP_ADF                     1011
#define IDC_PORT_NAME                   1012
#define IDC_TWAIN_DS                    1013
#define IDC_PUSHBUTTON                  1014
#define IDC_BUTTON_TSHOOT               1015
#define IDC_TEST_BUTTON                 1019
#define IDC_ONLINE                      1020
#define IDC_OTHER_STATUS                1022
#define IDC_EVENT_LIST                  1023
#define IDC_EVENT_TEXT                  1024
#define IDC_COMMAND                     1025
#define IDC_BROWSE_BUTTON               1026
#define IDC_APP_LIST                    1028
#define IDC_SELECTALL                   1030
#define IDC_SELECTNONE                  1031
#define IDC_LOGGERS_LIST                1032
#define IDC_LOG_RADIO_NONE              1033
#define IDC_LOG_RADIO_ERRORS            1034
#define IDC_LOG_RADIO_ALL               1035
#define IDC_LOGGER_DESCRIPTION          1036
#define IDC_LOG_CHECK_TRACE             1038
#define IDC_LOG_CHECK_WARNING           1039
#define IDC_LOG_CHECK_ERRORS            1040
#define IDC_CHECK_DISABLE_EVENTS        1041
#define IDC_BUTTON_WIRELESSLINK         1042
#define IDC_LOG_SETTINGS                1043
#define IDC_COM_SETTINGS                1044

#define IDD_XFERSOUND                   1050
#define IDC_SNDSTATUS                   1051

#define IDD_TAKEPICTURE                 1100

#define WIZ_LOCALPORT                   1700
#define IDD_LOCALPORT_LIST              1702
#define IDD_LOCALPORT_CONFIGURE         1703
#define IDD_SERIAL_PORT_SETTS_PAGE      1710
#define IDD_PORT_SETTS_PAGE             1711
#define IDC_BAUDRATE_COMBO              1711

#define IDS_SCANCAM_INTRO               2000
#define IDS_SCANCAM_NOSELTEXT           2001
#define IDS_SCANCAM_GETPIX              2002
#define IDS_SCANCAM_PROPERTIES          2003
#define IDS_SCANCAM_TASKS_HEADER        2004
#define IDS_CAMERA_TASKS_HEADER         2005
#define IDS_SCANCAM_TASKS_HEADER_TIP    2006
#define IDS_SCANCAM_ADDDEVICE_TIP       2007
#define IDS_SCANCAM_GETPIX_TIP          2008
#define IDS_SCANCAM_PROPERTIES_TIP      2009

#define IDS_WIACAM_MYCOMP_INFOTIP       2010
#define IDS_TIME_ERR_TITLE              2020
#define IDS_TIME_ERR                    2021

//
// Defines for camera item context menu id's
//
#define IMID_CI_FIRST       (0)
#define IMID_CI_PREVIEW     (IMID_CI_FIRST + 00)
#define IMID_CI_MYPICS      (IMID_CI_FIRST + 01)
#define IMID_CI_LOCK        (IMID_CI_FIRST + 04)
#define IMID_CI_ROTRIGHT    (IMID_CI_FIRST + 05)
#define IMID_CI_ROTLEFT     (IMID_CI_FIRST + 06)
#define IMID_CI_PLAYSND     (IMID_CI_FIRST + 07)
#define IMID_CI_SAVESND     (IMID_CI_FIRST + 8)
#define IMID_CI_PRINT       (IMID_CI_FIRST + 13)
//
// Defines for camera context menu id's
//

#define IMID_C_TAKE_PICTURE (IMID_CI_FIRST +9)
#define IMID_C_WIZARD       (IMID_CI_FIRST +10)
//
// scanner context menu

#define IMID_S_ACQUIRE  (IMID_CI_FIRST + 11)
#define IMID_S_WIZARD   (IMID_CI_FIRST + 12)


// IDs for menuhelp/status bar text

#define IDS_MH_IDFIRST    0x1200
#define SFVIDS_MH_PREVIEW   (IDS_MH_IDFIRST+IMID_CI_PREVIEW)
#define SFVIDS_MH_MYPICS    (IDS_MH_IDFIRST+IMID_CI_MYPICS)
#define SFVIDS_MH_LOCK      (IDS_MH_IDFIRST+IMID_CI_LOCK)
#define SFVIDS_MH_ROTRIGHT  (IDS_MH_IDFIRST+IMID_CI_ROTRIGHT)
#define SFVIDS_MH_ROTLEFT   (IDS_MH_IDFIRST+IMID_CI_ROTLEFT)
#define SFVIDS_MH_PLAYSND   (IDS_MH_IDFIRST+IMID_CI_PLAYSND)
#define SFVIDS_MH_SAVESND   (IDS_MH_IDFIRST+IMID_CI_SAVESND)
#define SFVIDS_MH_TAKEPICTURE   (IDS_MH_IDFIRST+IMID_C_TAKE_PICTURE)
#define SFVIDS_MH_ACQUIRE   (IDS_MH_IDFIRST+IMID_S_ACQUIRE)
#define SFVIDS_MH_CWIZARD    (IDS_MH_IDFIRST+IMID_C_WIZARD)
#define SFVIDS_MH_SWIZARD    (IDS_MH_IDFIRST+IMID_S_WIZARD)
#define SFVIDS_MH_PUBLISH    (IDS_MH_IDFIRST+IMID_CI_PUBLISH)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\src\stiprop.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       stiprop.h
//
//--------------------------------------------------------------------------


BOOL IsPnPDevice(PSTI_DEVICE_INFORMATION psdi, CSimpleString *szConnection = NULL);
HANDLE SelectDevInfoFromFriendlyName(const CSimpleStringWide &pszLocalName);
HRESULT GetSti ();

class CSTIPropertyPage : public CPropertyPage
{
public:
    CSTIPropertyPage (unsigned uResource, MySTIInfo *pDevInfo, IWiaItem *pItem=NULL) :
        CPropertyPage (uResource, pDevInfo, pItem)
    {
        // Make sure STI is loaded
        GetSti ();
    }

    VOID OnHelp (WPARAM wp, LPARAM lp);
    VOID OnContextMenu (WPARAM wp, LPARAM lp);

};
class CSTIGeneralPage : public CSTIPropertyPage
{

public:

    CSTIGeneralPage(MySTIInfo *pDevInfo, BOOL pnp) :
      CSTIPropertyPage(pnp ? IDD_GENERAL_PAGE : IDD_GENERALPNP_PAGE, pDevInfo, NULL) {m_bIsPnP = pnp;}

    INT_PTR    OnInit();
    INT_PTR    OnCommand(WORD wCode, WORD widItem, HWND hwndItem);
    LONG    OnApplyChanges(BOOL bHitOK);
    BOOL    BuildPortList (HWND hwndParent, UINT CtrlId);
    UINT    GetDeviceStatus (void);

    BOOL            m_bIsPnP;
    CSimpleString m_szConnection;
};

/*
class CLoggingPage : public CPropertyPage
{

public:

    HKEY            m_hkThis;

    CLoggingPage();
    ~CLoggingPage();

    VOID FillLoggerList(HWND hwnd,UINT  id);

    INT_PTR    OnInit();
    INT_PTR    OnCommand(WORD wCode, WORD widItem, HWND hwndItem);
    INT_PTR    OnNotify(UINT uCode, LPNMHDR lpnmh);
};
*/
class CPortSettingsPage : public CSTIPropertyPage
{

    UINT m_uBaudRate;
public:

    CPortSettingsPage(MySTIInfo *pDevInfo) :
      CSTIPropertyPage(IDD_SERIAL_PORT_SETTS_PAGE, pDevInfo) { }

    INT_PTR  OnInit();
    INT_PTR  OnCommand(WORD wCode, WORD widItem, HWND hwndItem);
    LONG     OnApplyChanges(BOOL bHitOK);
    //BOOL    BuildPortList (HWND hwndParent, UINT CtrlId);
    UINT BuildBaudRateList(HWND hwndParent,UINT CtrlId);

    BOOL    IsNeeded(VOID);
};

class CIdMatrix
{

    LPBYTE          m_lpMatrix;
    UINT            m_uiCount;

public:

    CIdMatrix() {m_lpMatrix=NULL; m_uiCount = 0;}

    ~CIdMatrix() {if (m_lpMatrix) delete m_lpMatrix;}

    void    SetCount(UINT uic) {

        if (!uic)
            return;

        if (m_lpMatrix)
            delete m_lpMatrix;

        m_lpMatrix = new BYTE[uic + 1];
        m_uiCount = uic;

        return;

    }

    void    Clear(void) {

        if (!m_lpMatrix)
            return;

        for (UINT i = 0; i < (m_uiCount + 1); i++)
            *(m_lpMatrix + i) = 0 ;

        return;
    }

    void    Set(void) {

        if (!m_lpMatrix)
            return;

        for (UINT i = 0; i < (m_uiCount + 1); i++)
            *(m_lpMatrix + i) = 1 ;

        return;
    }

    void    Toggle(UINT Idx) {

        if (!m_lpMatrix || Idx > m_uiCount)
            return;

        LPBYTE lpb = &m_lpMatrix[Idx ];
        *lpb ^= 1;
        return;

    }

    BOOL    IsSet(UINT Idx)  {

        if (!m_lpMatrix || Idx > m_uiCount)
            return FALSE;

        LPBYTE lpb = &m_lpMatrix[Idx];

        return *lpb ? TRUE : FALSE;

    }

    UINT    EnumIdx (UINT Idx) {

        // Idx is the last one we enumerated
        if (!m_lpMatrix || ++Idx > m_uiCount) return static_cast<UINT>(-1);

        for (; Idx <= m_uiCount; Idx++) {

            if (m_lpMatrix[Idx])
            {
                return Idx;
            }


        }

        return static_cast<UINT>(-1);
    }

};

class CEventMonitor : public CSTIPropertyPage {

    HWND            m_hwndList;
    CSimpleReg      m_hkThis;
    // BUGBUG Temporary
    CSimpleReg            m_hkThisDevice;
    BOOL            m_ListChanged;
    CIdMatrix       m_IdMatrix;
    FARPROC         m_lpfnOldProc;
    DWORD           m_dwUserDisableNotifications;

public:

    CEventMonitor(MySTIInfo *pDevInfo);



    void    SetSelectionChanged (BOOL Changed) {m_ListChanged = Changed;}
    BOOL    HasSelectionChanged (void) {return m_ListChanged;}

    void    FillListbox (HWND hwndParent, UINT CtrlId);
    BOOL    BuildEventList (HWND hwndParent, UINT CtrlId);

    UINT    DrawCheckBox (HDC hDC, RECT rcItem, BOOL Checked);

    static LRESULT CALLBACK ListSubProc (HWND hwnd, UINT msg, WPARAM wp, LPARAM lp);

    INT_PTR OnInit();
    INT_PTR OnCommand(WORD wCode, WORD widItem, HWND hwndItem);
    LONG    OnApplyChanges(BOOL bHitOK);
    VOID    OnReset (BOOL bHitCancel);
    VOID    OnDrawItem(LPDRAWITEMSTRUCT lpdis);

    bool    StateChanged () {if (HasSelectionChanged()) return true;
                             else return false;}

private:
    static bool EventListEnumProc (CSimpleReg::CKeyEnumInfo &Info);
    static bool FillListEnumProc (CSimpleReg::CValueEnumInfo &Info);
    ~CEventMonitor();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\src\stream.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998 - 2001
 *
 *  TITLE:       stream.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        8/10/98
 *
 *  DESCRIPTION: IStream interface for streaming back images to callers
 *
 *****************************************************************************/

#include "precomp.hxx"
#pragma hdrstop

DWORD _ImageStreamThreadProc( LPVOID lpv );

#define TRANSFER_BUFFER_SIZE 0x1000
#define SLOP                 0x0200


/*****************************************************************************

   CImageStream::CImageStream,~CImageStream

   Constructor/Destructor for class

 *****************************************************************************/

CImageStream::CImageStream( LPITEMIDLIST pidlFull,
                            LPITEMIDLIST pidl,
                            BOOL bShowProgress)
    : m_ulReadPos(0),
      m_ulWritePos(0),
      m_ulSize(0),
      m_bTransferred(FALSE),
      m_pBuffer(NULL),
      m_guidFormat(WiaImgFmt_MEMORYBMP),
      m_bFirstTransfer(TRUE),
      m_bProgress(bShowProgress),
      m_hResultDownload (S_OK),
      m_hEventStart (NULL),
      m_dwCookie(0)
{
    //
    // Save the args
    //

    if (pidlFull)
    {
        m_pidlFull = ILClone( pidlFull );
    }
    else
    {
        m_pidlFull = NULL;
    }

    if (pidl)
    {
        m_pidl = ILClone( pidl );
    }
    else
    {
        m_pidl = NULL;
    }


}

CImageStream::~CImageStream()
{


    DoILFree( m_pidlFull );
    DoILFree( m_pidl );
    DoLocalFree( m_pBuffer );
    DoCloseHandle( m_hThread );
    DoCloseHandle (m_hEventStart);    
    if (m_dwCookie)
    {
        m_pgit->RevokeInterfaceFromGlobal(m_dwCookie);
    }
}

/******************************************************************************

    CImageStream::InitItem

    InitItem stores the IWiaItem interface pointer in a global interface
    table so the thread proc can just marshal it instead of having
    to call CreateDevice again

******************************************************************************/
HRESULT
CImageStream::InitItem ()
{
    HRESULT hr = S_OK;
    CComPtr<IWiaItem> pItem;
    DWORD dwCookie = 0;
    TraceEnter (TRACE_STREAM, "CImageStream::InitItem");
    if (!m_dwCookie)
    {

        if (!m_pgit)
        {
            hr = CoCreateInstance (CLSID_StdGlobalInterfaceTable,
                                   NULL, CLSCTX_INPROC_SERVER,
                                   IID_IGlobalInterfaceTable,
                                   reinterpret_cast<LPVOID*>(&m_pgit));
        }

        if (SUCCEEDED(hr))
        {
            hr = IMGetItemFromIDL(m_pidl, &pItem);
            if (SUCCEEDED(hr))
            {
                hr = m_pgit->RegisterInterfaceInGlobal (pItem,
                                                        IID_IWiaItem,
                                                        &m_dwCookie);
                if (FAILED(hr))
                {
                    Trace(TEXT("Failed to register in GIT: %x"), hr);
                }
            }
        }
    }
    TraceLeaveResult (hr);
}


/*****************************************************************************

   CImageStream::AddRef,Release,etc.

   IUnknown methods.

 *****************************************************************************/

#undef CLASS_NAME
#define CLASS_NAME CImageStream
#include "unknown.inc"


/*****************************************************************************

   CImageStream::QI wrapper

 *****************************************************************************/

STDMETHODIMP CImageStream::QueryInterface(REFIID riid, LPVOID* ppvObject)
{
    INTERFACES iface[] =
    {
        &IID_IStream,           (IStream           *)this,
        &IID_ISequentialStream, (ISequentialStream *)this,
        &IID_IWiaDataCallback,   (IWiaDataCallback   *)this
    };

    return HandleQueryInterface(riid, ppvObject, iface, ARRAYSIZE(iface));
}


/*****************************************************************************

   CImageStream::Seek [IStream]

   Sets the current stream pointer.

 *****************************************************************************/

STDMETHODIMP
CImageStream::Seek( LARGE_INTEGER dlibMove,
                    DWORD dwOrigin,
                    ULARGE_INTEGER *plibNewPosition
                   )
{
    HRESULT hr = STG_E_INVALIDFUNCTION;

    TraceEnter( TRACE_STREAM, "CImageStream(IStream)::Seek" );
    // sleep until we know the size of the image
    hr = _InitWorker();
    if (SUCCEEDED(hr))
    {
        LARGE_INTEGER liNew;
        hr = STG_E_INVALIDFUNCTION;
        switch (dwOrigin)
        {
            case STREAM_SEEK_SET:
                Trace(TEXT("dwOrigin = STREAM_SEEK_SET"));
                liNew = dlibMove;
                break;

            case STREAM_SEEK_CUR:
                Trace(TEXT("dwOrigin = STREAM_SEEK_CUR"));
                liNew.QuadPart = (LONGLONG)((LONG)m_ulReadPos) + dlibMove.QuadPart;
                break;

            case STREAM_SEEK_END:
                Trace(TEXT("dwOrigin = STREAM_SEEK_END"));
                liNew.QuadPart = (LONGLONG)((LONG)m_ulSize) + dlibMove.LowPart;
                break;

        }

        Trace(TEXT("liNew = %d:%d, m_ulSize = %d, dlibMove = %d:%d"),liNew.HighPart,liNew.LowPart,m_ulSize,dlibMove.HighPart,dlibMove.LowPart);

        if ((liNew.QuadPart <= (LONGLONG)(LONG)m_ulSize) && (liNew.QuadPart >= 0))
        {
            m_ulReadPos = liNew.LowPart;
            if (plibNewPosition)
            {
                plibNewPosition->HighPart = 0;
                plibNewPosition->LowPart = m_ulReadPos;
                Trace(TEXT("plibNewPosition = %d:%d"),plibNewPosition->HighPart,plibNewPosition->LowPart);
            }
            hr = S_OK;
        }
    }
    TraceLeaveResult(hr);
}


/*****************************************************************************

   CImageStream::SetSize [IStream]

   (NOT IMPL)

 *****************************************************************************/

STDMETHODIMP
CImageStream::SetSize( ULARGE_INTEGER libNewSize )
{
    HRESULT hr = E_NOTIMPL;

    TraceEnter( TRACE_STREAM, "CImageStream(IStream)::SetSize" );

    TraceLeaveResult(hr);
}




/*****************************************************************************

   CImageStream::CopyTo [IStream]

   Copies the contents of the stream to another
   specified stream.

 *****************************************************************************/

STDMETHODIMP
CImageStream::CopyTo( IStream *pstm,
                      ULARGE_INTEGER cb,
                      ULARGE_INTEGER *pcbRead,
                      ULARGE_INTEGER *pcbWritten
                     )
{


    TraceEnter( TRACE_STREAM, "CImageStream(IStream)::CopyTo" );
    HANDLE hThread;
    DWORD dw;

    //
    // NOTE: to satisfy RPC requirements that outgoing calls can't be made
    // from a thread responding to a sent message, spawn a thread
    // to do the work
    //


    m_hResultDownload = InitItem ();
    if (SUCCEEDED(m_hResultDownload))
    {
        AddRef ();

        hThread = CreateThread (NULL,
                                0,
                                _ImageStreamThreadProc,
                                reinterpret_cast<LPVOID>(this),
                                0,
                                &dw );

        if (hThread)
        {
            WaitForSingleObject (hThread, INFINITE);
            if (S_OK == m_hResultDownload)
            {

                if (cb.HighPart || (m_ulWritePos <= cb.LowPart))
                {
                    if (m_pBuffer)
                    {
                        //
                        // Copy the stream data
                        //

                        m_hResultDownload = pstm->Write( (void *)m_pBuffer, m_ulWritePos, NULL );
                        if (pcbWritten)
                        {
                            (*pcbWritten).HighPart = 0;
                            (*pcbWritten).LowPart = m_ulWritePos;
                        }
                    }
                }
            }
            CloseHandle( hThread );
        }

        else
        {
            Release ();
        }
    }
    TraceLeaveResult(m_hResultDownload);
}


/*****************************************************************************

   CImageStream::Commit [IStream]

   (NOT IMPL)

 *****************************************************************************/

STDMETHODIMP
CImageStream::Commit(DWORD grfCommitFlags)
{
    HRESULT hr = E_NOTIMPL;

    TraceEnter( TRACE_STREAM, "CImageStream(IStream)::Commit" );

    TraceLeaveResult(hr);
}


/*****************************************************************************

   CImageStream::Revert [IStream]

   (NOT IMPL)

 *****************************************************************************/

STDMETHODIMP
CImageStream::Revert(void)
{
    HRESULT hr = E_NOTIMPL;

    TraceEnter( TRACE_STREAM, "CImageStream(IStream)::Revert" );

    TraceLeaveResult(hr);
}


/*****************************************************************************

   CImageStream::LockRegion [IStream]

   (NOT IMPL)

 *****************************************************************************/

STDMETHODIMP
CImageStream::LockRegion( ULARGE_INTEGER libOffset,
                          ULARGE_INTEGER cb,
                          DWORD dwLockType
                         )
{
    HRESULT hr = E_NOTIMPL;

    TraceEnter( TRACE_STREAM, "CImageStream(IStream)::LockRegion" );

    TraceLeaveResult(hr);
}


/*****************************************************************************

   CImageStream::UnlockRegion [IStream]

   (NOT IMPL)

 *****************************************************************************/

STDMETHODIMP
CImageStream::UnlockRegion( ULARGE_INTEGER libOffset,
                            ULARGE_INTEGER cb,
                            DWORD dwLockType
                           )
{
    HRESULT hr = E_NOTIMPL;

    TraceEnter( TRACE_STREAM, "CImageStream(IStream)::UnlockRegion" );

    TraceLeaveResult(hr);
}


/*****************************************************************************

   CImageStream::Stat [IStream]

   (NOT IMPL)

 *****************************************************************************/

STDMETHODIMP
CImageStream::Stat( STATSTG *pstatstg,
                    DWORD grfStatFlag
                   )
{
    HRESULT hr = S_OK;

    TraceEnter( TRACE_STREAM, "CImageStream(IStream)::Stat" );
    ZeroMemory(pstatstg, sizeof(pstatstg));

    if (!(STATFLAG_NONAME & grfStatFlag))
    {
        CSimpleStringWide strName;
        TCHAR szExt[MAX_PATH];
        IMGetNameFromIDL(m_pidl, strName);

        hr = IMGetImagePreferredFormatFromIDL( m_pidl, NULL, szExt );
        if (SUCCEEDED(hr))
        {
            strName.Concat (CSimpleStringConvert::WideString (CSimpleString(szExt )));
            pstatstg->pwcsName = reinterpret_cast<LPOLESTR>(CoTaskMemAlloc((strName.Length()+1)*sizeof(WCHAR)));
            if (!(pstatstg->pwcsName))
            {
                hr = STG_E_INSUFFICIENTMEMORY;
            }
            else
            {
                wcscpy(pstatstg->pwcsName, strName.String());
            }
        }
    }
    if (SUCCEEDED(hr))
    {
        pstatstg->grfMode = STGM_READ | STGM_SHARE_EXCLUSIVE;
    }
    TraceLeaveResult(hr);
}


/*****************************************************************************

   CImageStream::Clone [IStream]

   Makes a copy of the stream object.

 *****************************************************************************/

STDMETHODIMP
CImageStream::Clone( IStream **ppstm )
{
    HRESULT hr;
    CImageStream * pStream;

    TraceEnter( TRACE_STREAM, "CImageStream(IStream)::Clone" );

    if (!ppstm)
    {
        ExitGracefully( hr, E_INVALIDARG, "ppstm is NULL!" );
    }

    pStream = new CImageStream( m_pidlFull, m_pidl, m_bProgress );

    if ( !pStream )
        ExitGracefully(hr, E_OUTOFMEMORY, "Failed to create CImageStream");

    //
    // Get the requested interface on the new object and hand it back...
    //

    hr = pStream->QueryInterface( IID_IStream, (LPVOID *)ppstm);

    pStream->Release ();

exit_gracefully:

    TraceLeaveResult(hr);

}

HRESULT
CImageStream::_InitWorker()
{
    HRESULT hr = S_OK;
    TraceEnter(TRACE_STREAM, "CImageStream::_InitWorker");
    if (!m_hThread)
    {
        DWORD dw;
        hr = InitItem ();
        if (SUCCEEDED(hr))
        {
            m_hEventStart = CreateEvent (NULL, FALSE, FALSE, NULL);
            if (!m_hEventStart)
            {
                Trace(TEXT("CreateEvent failed in CImageStream::_InitWorker"));
                hr = E_FAIL;
            }
        }
        if (SUCCEEDED(hr))
        {
            AddRef ();
            m_hThread = CreateThread( NULL, 0, _ImageStreamThreadProc, (LPVOID)this, 0, &dw );
            if (!m_hThread)
            {
                Trace(TEXT("CreateThread failed in _InitWorker %d"), GetLastError());
                Release ();
            }
            else
            {
                WaitForSingleObject (m_hEventStart,120000); // wait up to 120 seconds
            }
            if (!m_ulWritePos)
            {
                Trace(TEXT("No data ready, bailing"));
                hr = E_FAIL;
            }
        }
    }
    return hr;
}
/*****************************************************************************

   CImageStream::Read [ISequentialStream]

   Read the specified number of bytes from the
   stream into the buffer provided.

 *****************************************************************************/

STDMETHODIMP
CImageStream::Read( void *pv,
                    ULONG cb,
                    ULONG *pcbRead
                   )
{
    HRESULT hr = E_FAIL;


    ULONG ulWrite = 0;
    TraceEnter( TRACE_STREAM, "CImageStream(IStream)::Read" );
    Trace(TEXT("Bytes to read = %d"),cb );

    //
    // Check the params
    //

    if (!pv || !cb)
    {
        Trace(TEXT("pv = 0x%x, cb = %d, pcbRead = 0x%x"),pv,cb,pcbRead);
        ExitGracefully( hr, STG_E_INVALIDPOINTER, "bad incoming params" );
    }

    //
    // If we haven't started the download thread, do so now...
    //

    hr = _InitWorker();
    FailGracefully (hr, "_InitWorker failed");
    //
    // Read the bits once they are available
    //
    ulWrite = m_ulWritePos;
    if (ulWrite)
    {
        ULONG ulBytesLeftInStream = 0;

        //
        // Wait for enough data to be available (or we're at the end of
        // the file)
        //

        do
        {
            ulBytesLeftInStream = m_ulWritePos - m_ulReadPos;
            Trace(TEXT("CImageStream::Read --> %d bytes ready in stream"),ulBytesLeftInStream);

            if ((m_ulReadPos > m_ulWritePos) || (!m_bTransferred &&  (ulBytesLeftInStream < cb)))
            {
                Sleep( 500 );
            }
            // Seek guarantees m_ulReadPos will never exceed the image size
        } while(!m_bTransferred && (ulBytesLeftInStream < cb));

        // if the transfer completed, re-eval bytes left to make sure it's
        // synched
        if (m_bTransferred)
        {
            ulBytesLeftInStream = m_ulWritePos - m_ulReadPos;
        }
        if (S_OK == m_hResultDownload)
        {

            //
            // Read what we can out of the file, a read that
            // completes with less than cb bytes is considered
            // the end of the file
            //

            memcpy( pv, (LPBYTE)m_pBuffer + m_ulReadPos, min(cb, ulBytesLeftInStream) );

            if (pcbRead)
            {
                *pcbRead = min(cb, ulBytesLeftInStream);
            }

            m_ulReadPos += min(cb, ulBytesLeftInStream);

        }

    }
    hr = m_hResultDownload;
exit_gracefully:

    TraceLeaveResult(hr);
}


/*****************************************************************************

   CImageStream::Revert [ISequentialStream]

   Writes the specified number of bytes into the
   stream from the buffer provided.

 *****************************************************************************/

STDMETHODIMP
CImageStream::Write( const void *pv,
                     ULONG cb,
                     ULONG *pcbWritten
                    )
{
    HRESULT hr = E_NOTIMPL;

    TraceEnter( TRACE_STREAM, "CImageStream(IStream)::Write" );

    TraceLeaveResult(hr);
}



/*****************************************************************************

   _ImageStreamThreadProc

   Actually does the work to get the bits from WIA and write them to
   the buffer we care about.

 *****************************************************************************/

DWORD _ImageStreamThreadProc( LPVOID lpv )
{
    HRESULT hr = E_FAIL;
    HRESULT hrCo = E_FAIL;

    CImageStream * pStream = (CImageStream *)lpv;
    WIA_FORMAT_INFO Format;
    WIA_DATA_TRANSFER_INFO  wiaDataTransInfo;

    LONG lBufSize = 65535;

    TraceEnter( TRACE_STREAM, "_ImageStreamThreadProc" );

    if (pStream)
    {
        hrCo = CoInitialize(NULL);
    }
    if (SUCCEEDED(hrCo))
    {
        CComPtr<IWiaItem>         pItem;
        CComPtr<IWiaDataTransfer> pWiaDataTran;
        CComPtr<IWiaDataCallback> pWiaDataCallback;

        //
        // Init the structure
        //  

        Format.lTymed    = TYMED_CALLBACK;

        TraceAssert (pStream->m_dwCookie);

        hr = pStream->m_pgit->GetInterfaceFromGlobal (pStream->m_dwCookie,
                                                      IID_IWiaItem,
                                                      reinterpret_cast<LPVOID*>(&pItem));
        if (SUCCEEDED(hr))
        {
        
            //
        // fill out structures for IBandedTransfer
        //

            if (!PropStorageHelpers::GetProperty (pItem, WIA_IPA_PREFERRED_FORMAT, Format.guidFormatID) ||
                IsEqualGUID(Format.guidFormatID, WiaImgFmt_BMP))
            {
                Format.guidFormatID = WiaImgFmt_MEMORYBMP;
            }

            pStream->m_guidFormat = Format.guidFormatID;
            SetTransferFormat (pItem, Format);
            //
            // Get the image transfer interface
            //

            hr = pItem->QueryInterface(IID_IWiaDataTransfer, (LPVOID *)&pWiaDataTran);
            if (SUCCEEDED(hr))
            {
            
            //
            // Set up callback so we can show progress...
            //

                hr = pStream->QueryInterface(IID_IWiaDataCallback, (LPVOID *)&pWiaDataCallback);
                if (SUCCEEDED(hr))
                {
                    //
                    // Get the picture data...
                    //
                    PropStorageHelpers::GetProperty(pItem,
                                                    WIA_IPA_MIN_BUFFER_SIZE,
                                                    lBufSize);
                    ZeroMemory(&wiaDataTransInfo, sizeof(WIA_DATA_TRANSFER_INFO));
                    wiaDataTransInfo.ulSize = sizeof(WIA_DATA_TRANSFER_INFO);
                    wiaDataTransInfo.ulBufferSize = static_cast<ULONG>(2*lBufSize);
                    wiaDataTransInfo.bDoubleBuffer = TRUE;
                    hr = pWiaDataTran->idtGetBandedData( &wiaDataTransInfo, pWiaDataCallback );
                }
            }
            pStream->m_pgit->RevokeInterfaceFromGlobal (pStream->m_dwCookie); 
            pStream->m_dwCookie = 0;
        }
    }


    //
    // Signal that the file has been completely downloaded
    //
    if (pStream)
    {
        pStream->m_hResultDownload = hr;
        InterlockedExchange (&pStream->m_bTransferred, TRUE);
        //
        // Make sure the dialog goes away...
        //

        if (pStream->m_pWiaProgressDialog)
        {
            pStream->m_pWiaProgressDialog->Destroy();
            pStream->m_pWiaProgressDialog = NULL;
        }
        if (FAILED(hr))
        {
            // wake up the Read for the error
            SetEvent (pStream->m_hEventStart);
        }
        pStream->Release ();
    }

    if (SUCCEEDED(hrCo))
    {
        MyCoUninitialize();
    }

    Trace(TEXT("_ImageStreamThreadProc, exiting w/hr = 0x%x"), hr );
    TraceLeave();
    ExitThread((DWORD)hr);
    return 0;
}


/*****************************************************************************

   CImageStream::BandedDataCallback

   Callback method from WIA -- calls us with a chunk of image data.

 *****************************************************************************/

STDMETHODIMP
CImageStream::BandedDataCallback (LONG lReason,
                                  LONG lStatus,
                                  LONG lPercentComplete,
                                  LONG lOffset,
                                  LONG lLength,
                                  LONG lReserved,
                                  LONG lResLength,
                                  BYTE *pbData)
{

    HRESULT hr = S_OK;

    TraceEnter( TRACE_STREAM, "CImageStream(IWiaDataCallback)::BandedDataCallback" );


    Trace(TEXT(" lReason=0x%x, lPercentComplete=%d, lStatus = 0x%x, lOffset = 0x%x, lLength = 0x%x"),
          lReason, lPercentComplete, lStatus, lOffset, lLength
          );

    switch( lReason )
    {

        case IT_MSG_DATA_HEADER:
        {
            WIA_DATA_CALLBACK_HEADER * pHead = (WIA_DATA_CALLBACK_HEADER *)pbData;

            if (pHead && (pHead->lSize == sizeof(WIA_DATA_CALLBACK_HEADER)))
            {
                if (IsEqualGUID (m_guidFormat, WiaImgFmt_MEMORYBMP))
                {
                    Trace (TEXT("Adding sizeof(BITMAPFILEHEADER) to image size"));
                    m_ulSize = sizeof(BITMAPFILEHEADER) + pHead->lBufferSize;
                }
                else
                {
                    m_ulSize = pHead->lBufferSize;
                }

                Trace(TEXT("Got header, creating a %d byte buffer"), m_ulSize);
                m_pBuffer = LocalAlloc( LPTR, m_ulSize );
                if (m_pBuffer)
                {
                    if (m_bProgress)
                    {
                        if (SUCCEEDED(CoCreateInstance( CLSID_WiaDefaultUi, NULL, CLSCTX_INPROC_SERVER, IID_IWiaProgressDialog, (void**)&m_pWiaProgressDialog )) && m_pWiaProgressDialog)
                        {
                            if (!SUCCEEDED(m_pWiaProgressDialog->Create( NULL, WIA_PROGRESSDLG_NO_CANCEL|WIA_PROGRESSDLG_NO_ANIM)))
                            {
                                m_pWiaProgressDialog->Destroy();
                                m_pWiaProgressDialog = NULL;
                            }
                        }
                    }

                    if (m_pWiaProgressDialog)
                    {
                        m_pWiaProgressDialog->SetTitle( CSimpleStringConvert::WideString(CSimpleString(IDS_RETREIVING, GLOBAL_HINSTANCE)));
                        m_pWiaProgressDialog->SetMessage( L"" );
                        m_pWiaProgressDialog->Show();
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
        break;


        case IT_MSG_STATUS:
        {
            if (lStatus & IT_STATUS_TRANSFER_FROM_DEVICE)
            {
                static BOOL bSetText = FALSE;

                if (m_pWiaProgressDialog)
                {
                    if (!bSetText)
                    {
                        m_pWiaProgressDialog->SetMessage( CSimpleStringConvert::WideString(CSimpleString (IDS_DOWNLOADING_IMAGE, GLOBAL_HINSTANCE)));
                        bSetText = TRUE;
                    }
                    m_pWiaProgressDialog->SetPercentComplete( lPercentComplete );
                }
            }
        }
        break;

        case IT_MSG_DATA:
        {
            if (m_pBuffer)
            {
                bool bSet = false;
                if ((m_ulWritePos+lLength) > m_ulSize)
                {
                    TraceAssert (FALSE);
                    Trace(TEXT("m_ulWritePos+lLength > m_ulSize!"));
                    lLength = m_ulSize - m_ulWritePos;
                }
                if (m_bFirstTransfer)
                    {
                        bSet = true;
                        if (m_pWiaProgressDialog)
                        {
                            m_pWiaProgressDialog->SetMessage( CSimpleStringConvert::WideString(CSimpleString(IDS_DOWNLOADING_IMAGE, GLOBAL_HINSTANCE)));
                        }


                        if (IsEqualGUID (m_guidFormat, WiaImgFmt_MEMORYBMP) )
                        {
                            UINT uiSrcScanLineWidth;
                            UINT uiScanLineWidth;
                            UINT cbDibSize;
                            UINT cbClrTableSize;
                            BITMAPINFO * pbi = (BITMAPINFO *)pbData;

                            //
                            // If we're transferring as a DIB, we need to write out the
                            // BITMAPFILEHEADER first...
                            //



                            // Calculate the size of the color table
                            if ((pbi->bmiHeader.biClrUsed==0) && (pbi->bmiHeader.biBitCount!=24))
                            {
                                cbClrTableSize = sizeof(RGBQUAD) * (DWORD)(1 << pbi->bmiHeader.biBitCount);
                            }
                            else
                            {
                                cbClrTableSize = sizeof(RGBQUAD) * pbi->bmiHeader.biClrUsed;
                            }

                            // Align scanline to ULONG boundary
                            uiSrcScanLineWidth = (pbi->bmiHeader.biWidth * pbi->bmiHeader.biBitCount) / 8;
                            uiScanLineWidth    = (uiSrcScanLineWidth + 3) & 0xfffffffc;

                            // Calculate DIB size and allocate memory for the DIB.
                            cbDibSize = (pbi->bmiHeader.biHeight > 0) ?
                                            pbi->bmiHeader.biHeight  * uiScanLineWidth :
                                          -(pbi->bmiHeader.biHeight) * uiScanLineWidth;

                            cbDibSize += (sizeof(BITMAPFILEHEADER) + pbi->bmiHeader.biSize + cbClrTableSize);



                            BITMAPFILEHEADER bmfh;

                            bmfh.bfType = 'MB';
                            bmfh.bfSize = cbDibSize;
                            bmfh.bfOffBits = lLength + sizeof(BITMAPFILEHEADER);

                            memcpy( (LPBYTE)m_pBuffer + m_ulWritePos, &bmfh, sizeof(BITMAPFILEHEADER) );
                            InterlockedExchangeAdd (reinterpret_cast<LONG*>(&m_ulWritePos),sizeof(BITMAPFILEHEADER));

                            
                        }
                        m_bFirstTransfer = FALSE;
                    }

                memcpy( (LPBYTE)m_pBuffer + m_ulWritePos, pbData, lLength );
                InterlockedExchangeAdd (reinterpret_cast<LONG*>(&m_ulWritePos), lLength);

                if (bSet)
                {
                    Trace (TEXT("Setting the start event from the callback"));
                    SetEvent (m_hEventStart); // let the Read know there is data
                }

                Trace(TEXT("m_ulWritePos = %d, just transferred %d bytes"), m_ulWritePos, lLength);

                if (m_pWiaProgressDialog && m_ulSize)
                {
                    Trace (TEXT("Updating the status percent"));
                    m_pWiaProgressDialog->SetPercentComplete( (m_ulWritePos * 100) / m_ulSize );
                }
            }
            else
            {
                Trace (TEXT("m_pBuffer is NULL, returning E_FAIL"));
                hr = E_FAIL;
            }

        }
        break;

        case IT_MSG_TERMINATION:
        {
            if (m_pWiaProgressDialog)
            {
                m_pWiaProgressDialog->SetPercentComplete( 100 );
            }
            // an error occurred, no data received
            if (m_bFirstTransfer)
            {
                SetEvent(m_hEventStart);
            }

            Trace(TEXT("transfer complete"));
            m_bTransferred = TRUE;
        }
        break;

    }


    if ((lStatus == IT_STATUS_TRANSFER_TO_CLIENT) && (lPercentComplete == 100))
    {
        m_bTransferred = TRUE;
        Trace(TEXT("transfer complete"));
    }
    Trace (TEXT("LEAVE: CImageStream::BandedDataCallback: %x"), hr);
    TraceLeaveResult(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\src\stiprop.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1997 - 1999
 *
 *  TITLE:       stiprop.cpp
 *
 *  VERSION:     2.0
 *
 *  AUTHOR:      VladS/DavidShi
 *
 *  DATE:        ??
 *
 *  DESCRIPTION: code which displays properties of STI devices
 *
 *****************************************************************************/

#include "precomp.hxx"
#pragma hdrstop

#include <windowsx.h>
#include    <setupapi.h>
#ifdef _TEXT
    #undef _TEXT
#endif
#include    <tchar.h>

#include <devguid.h>
extern "C" {
#ifdef ADD_ICM_UI

    #include <shlguid.h>
    #include <shlobjp.h>
    #include <shlwapi.h>
#endif
}
#include    <stiapi.h>

#include "stiprop.h"


// This definition comes from stici.h (STI Class installer)
#define MAX_DESCRIPTION     64
#define PORTS               TEXT("Ports")
#define PORTNAME            TEXT("PortName")
#define SERIAL              TEXT("Serial")
#define PARALLEL            TEXT("Parallel")
#define AUTO                TEXT("AUTO")

#define STI_SERVICE_NAME            TEXT("StiSvc")
#define STI_SERVICE_CONTROL_REFRESH 130

#define BIG_ENOUGH 256

// Some Useful macro
#define AToU(dst, cchDst, src) \
    MultiByteToWideChar(CP_ACP, 0, src, -1, dst, cchDst)
#define UToA(dst, cchDst, src) \
    WideCharToMultiByte(CP_ACP, 0, src, -1, dst, cchDst, 0, 0)

#ifdef UNICODE
    #define TToU(dst, cchDst, src)  lstrcpyn(dst, src, cchDst)
    #define UToT(dst, cchDst, src)  lstrcpyn(dst, src, cchDst)
#else
    #define TToU AToU
    #define UToT UToA
#endif


#define ADD_ICM_UI
// #define USE_SHELLDLL
DWORD aInfoPageIds[] = {

    IDC_TEST_BUTTON,            IDH_WIA_TEST_BUTTON,
    IDC_FRIENDLY,               IDH_WIA_FRIENDLY,
    IDC_MAKER,                  IDH_WIA_MAKER,
    IDC_DESCRIBE,               IDH_WIA_DESCRIBE,
    IDC_PORT_NAME,              IDH_WIA_PORT_NAME,
    IDC_EVENT_LIST,             IDH_WIA_EVENT_LIST,
    IDC_APP_LIST,               IDH_WIA_APP_LIST,
    IDC_COM_SETTINGS,           IDH_WIA_PORT_NAME,
    IDC_PORT_NAME,              IDH_WIA_PORT_NAME,
    //IDC_BAUDRATE_COMBO,         IDH_WIA_BAUD_RATE,
    0,0
};
//#include    "sticp.h"

static CComPtr<IStillImage> g_pSti;


BOOL
SendRefreshToStiMon(
                   VOID
                   );

#define MINIY       16
#define MINIX       16


typedef struct _DEVICEEVENT
{

    CSimpleString LaunchApplications;
    CSimpleString Description;
    DWORD          Launchable;
    CSimpleReg    hKeyEvent;
    GUID    Guid;


} DEVICEEVENT, *PDEVICEEVENT;

#define STR_HELPFILE TEXT("camera.hlp")
/*****************************************************************************

    CSTIPropertyPage::OnHelp
    CSTIPropertyPage::OnContextMenu

    Handle help commands

*****************************************************************************/
VOID
CSTIPropertyPage::OnHelp(WPARAM wp, LPARAM lp)
{
    if (0xffff != LOWORD(reinterpret_cast<LPHELPINFO>(lp)->iCtrlId))
    {

        WinHelp (reinterpret_cast<HWND>(reinterpret_cast<LPHELPINFO>(lp)->hItemHandle),
                 STR_HELPFILE,
                 HELP_WM_HELP,
                 reinterpret_cast<ULONG_PTR>(aInfoPageIds));
    }
}

VOID
CSTIPropertyPage::OnContextMenu(WPARAM wp, LPARAM lp)
{
    WinHelp (reinterpret_cast<HWND>(wp),
             STR_HELPFILE,
             HELP_CONTEXTMENU,
             reinterpret_cast<ULONG_PTR>(aInfoPageIds));

}
/*****************************************************************************

   GetSti

   Helper function to init IStillImage

 *****************************************************************************/


HRESULT GetSti ()
{
    HRESULT hr = S_OK;
    if (!g_pSti)
    {
        hr = ::StiCreateInstance (GLOBAL_HINSTANCE,
                             STI_VERSION,
                             &g_pSti,
                             NULL);
    }
    return hr;
}


/*****************************************************************************

   CSTIGeneralPage::OnInit

   Handles WM_INITDIALOG for general STI property page

 *****************************************************************************/

INT_PTR
CSTIGeneralPage::OnInit()
{

    UINT uDevStatus;



    if (!m_bIsPnP)
    {
        BuildPortList(m_hwnd, IDC_COM_SETTINGS);
    }
    HICON hIcon = LoadIcon(GLOBAL_HINSTANCE,
                           MAKEINTRESOURCE( (GET_STIDEVICE_TYPE(m_psdi -> DeviceType) == StiDeviceTypeScanner) ?
                                            IDI_SCANNER : IDI_CAMERA));

    SendDlgItemMessage(m_hwnd,
                       IDC_DEVICE_ICON,
                       STM_SETICON,
                       (WPARAM) hIcon,
                       0);

    CSimpleString csWork = CSimpleStringConvert::NaturalString (CSimpleStringWide(m_psdi -> pszLocalName));
    csWork.SetWindowText (GetDlgItem(m_hwnd, IDC_FRIENDLY));

    csWork = CSimpleStringConvert::NaturalString (CSimpleStringWide(m_psdi -> pszVendorDescription));
    csWork.SetWindowText (GetDlgItem(m_hwnd,  IDC_MAKER));

    csWork = CSimpleStringConvert::NaturalString (CSimpleStringWide(m_psdi -> pszDeviceDescription));
    csWork.SetWindowText (GetDlgItem(m_hwnd, IDC_DESCRIBE));

    csWork = CSimpleStringConvert::NaturalString (CSimpleStringWide(m_psdi -> pszPortName));
    csWork.SetWindowText (GetDlgItem(m_hwnd, IDC_PORT_NAME));


    uDevStatus = GetDeviceStatus();
    csWork.LoadString(uDevStatus, GLOBAL_HINSTANCE);

    csWork.SetWindowText (GetDlgItem(m_hwnd, IDC_OTHER_STATUS));

    EnableWindow(GetDlgItem(m_hwnd, IDC_TEST_BUTTON),
                 (IDS_OPERATIONAL == uDevStatus));

    return  TRUE;
}


/*****************************************************************************

   CSTIGeneralPage::OnCommand

   WM_COMMAND handler -- all we need to handle is the TEST button

 *****************************************************************************/

INT_PTR
CSTIGeneralPage::OnCommand(WORD wCode, WORD widItem, HWND hwndItem)
{


    if ((CBN_SELCHANGE == wCode) && (IDC_COM_SETTINGS == widItem))
    {
        // Enable Apply button
        SendMessage(GetParent(m_hwnd), PSM_CHANGED, (WPARAM)m_hwnd, 0);
        return TRUE;
    }


    if (wCode != BN_CLICKED || widItem != IDC_TEST_BUTTON)
        return  FALSE;

    //  Attempt to create the device, and call the diagnostic routine
    PSTIDEVICE          psdThis = NULL;
    STI_DIAG            diag;

    HRESULT hr = g_pSti -> CreateDevice(m_psdi -> szDeviceInternalName,
                                        STI_DEVICE_CREATE_STATUS, &psdThis, NULL);

    if (SUCCEEDED(hr) && psdThis)
    {
        CWaitCursor    waitCursor;

        //
        // Need to claim device before using
        //
        hr = psdThis -> LockDevice(2000);
        if (SUCCEEDED(hr))
        {
            hr = psdThis -> Diagnostic(&diag);
            psdThis -> UnLockDevice();
        }

        psdThis -> Release();   //  We're done with it
    }
    else
    {
        hr = E_FAIL;
    }
    //
    // Display message box
    //
    if (SUCCEEDED(hr))
    {
        if (NOERROR == diag.sErrorInfo.dwGenericError )
        {

            UIErrors::ReportMessage(m_hwnd,
                                    GLOBAL_HINSTANCE,
                                    NULL,
                                    MAKEINTRESOURCE(IDS_DIAGNOSTIC_SUCCESS),
                                    MAKEINTRESOURCE(IDS_SUCCESS),
                                    MB_ICONINFORMATION);

        }
        else
        {

            UIErrors::ReportMessage(m_hwnd,
                                    GLOBAL_HINSTANCE,
                                    NULL,
                                    MAKEINTRESOURCE(IDS_DIAGNOSTIC_FAILED),
                                    MAKEINTRESOURCE(IDS_NO_SUCCESS),
                                    MB_ICONSTOP);

        }
    }
    else
    {

        UIErrors::ReportMessage(m_hwnd,
                                GLOBAL_HINSTANCE,
                                NULL,
                                MAKEINTRESOURCE(IDS_DIAGNOSTIC_FAILED),
                                MAKEINTRESOURCE(IDS_TEST_UNAVAIL),
                                MB_ICONSTOP);

    }

    return  TRUE;
}


/*****************************************************************************

   CSTIGeneralPage::OnApplyChanges

   <Notes>

 *****************************************************************************/

LONG
CSTIGeneralPage::OnApplyChanges (BOOL bHitOK)
{
    if (m_bIsPnP)
    {
        return PSNRET_NOERROR;
    }
    CSimpleString szText;
    WCHAR szPortName[BIG_ENOUGH];
    STI_DEVICE_INFORMATION l_sdi;
    extern HWND g_hDevListDlg;
    UINT        uDevStatus;
    CSimpleString     csWork;

    l_sdi = *m_psdi;
    szText.GetWindowText (GetDlgItem (m_hwnd, IDC_COM_SETTINGS));
    lstrcpyW (szPortName, CSimpleStringConvert::WideString (szText));
    l_sdi.pszPortName = szPortName;
    g_pSti->SetupDeviceParameters(&l_sdi);

//
// pszPortName is buffered locally. Originally it points system static memory
// so the pointer may be changed to point local buffer. It's safe to copy
// strings.
//
    lstrcpyW(m_psdi->pszPortName, szPortName);
    uDevStatus = GetDeviceStatus();
    csWork.LoadString(uDevStatus, GLOBAL_HINSTANCE);

    csWork.SetWindowText (GetDlgItem(m_hwnd, IDC_OTHER_STATUS));
    EnableWindow(GetDlgItem(m_hwnd, IDC_TEST_BUTTON),
                 (IDS_OPERATIONAL == uDevStatus));
    return PSNRET_NOERROR;
}


/*****************************************************************************

   CSTIGeneralPage::BuildPortList

   <Notes>

 *****************************************************************************/

BOOL
CSTIGeneralPage::BuildPortList (HWND hwndParent, UINT CtrlId)
{

    HKEY                    hkPort;
    CSimpleString           szPort;
    CSimpleString           szTemp;
    HANDLE                  hDevInfo;
    GUID                    Guid;
    DWORD                   dwRequired;
    LONG                    Idx,id,CurrentId;
    DWORD                   err;
    SP_DEVINFO_DATA         spDevInfoData;
    HWND                    hwndCombo;


//
//  Retrieve a list of all of the ports on this box
//


    dwRequired = 0;
    SetupDiClassGuidsFromName (PORTS, &Guid, sizeof(GUID), &dwRequired);

    hDevInfo = SetupDiGetClassDevs (&Guid, NULL, NULL, DIGCF_PRESENT | DIGCF_PROFILE);
    if (hDevInfo == INVALID_HANDLE_VALUE)
    {
        return TRUE;
    }

    hwndCombo = GetDlgItem(hwndParent, CtrlId);
    memset (&spDevInfoData, 0, sizeof(SP_DEVINFO_DATA));
    spDevInfoData.cbSize = sizeof (SP_DEVINFO_DATA);
    szTemp = CSimpleStringConvert::NaturalString(CSimpleStringWide(m_psdi->pszPortName));


//
// Clear all item in list box
//
    SendMessage(hwndCombo, CB_RESETCONTENT, 0, 0);

    CurrentId = -1;

//
// AUTO is added if capable
//

    if (m_psdi->DeviceCapabilities.dwGeneric & STI_GENCAP_AUTO_PORTSELECT)
    {
        id = (int) SendMessage(hwndCombo, CB_ADDSTRING,
                               0, (LPARAM)AUTO);
        if (!_tcsicmp(szTemp, AUTO))
        {
            CurrentId = id;
        }
    }

    for (Idx = 0; SetupDiEnumDeviceInfo (hDevInfo, Idx, &spDevInfoData); Idx++)
    {

        hkPort = SetupDiOpenDevRegKey (hDevInfo, &spDevInfoData, DICS_FLAG_GLOBAL,
                                       0, DIREG_DEV, KEY_READ);

        if (hkPort == INVALID_HANDLE_VALUE)
        {
            err = GetLastError();
            continue;
        }


        if (!szPort.Load (hkPort, PORTNAME))
        {
            err = GetLastError();
            continue;
        }

        if (_tcsstr(szPort, TEXT("COM")))
        {
            // Communications Port
            if (_tcsicmp(m_szConnection, PARALLEL))
            {
                id = (int) SendMessage(hwndCombo, CB_ADDSTRING,
                                       0, reinterpret_cast<LPARAM>(static_cast<LPCTSTR>(szPort)));
            }
            else
            {
                id = LB_ERR;
            }
        }
        else if (_tcsstr(szPort, TEXT("LPT")))
        {
            // Printer Port
            if (_tcsicmp(m_szConnection, SERIAL))
            {
                id = (int) SendMessage(hwndCombo, CB_ADDSTRING,
                                       0, reinterpret_cast<LPARAM>(static_cast<LPCTSTR>(szPort)));
            }
            else
            {
                id = LB_ERR;
            }
        }
        else
        {
            // BOTH or Unknown port
            id = (int) SendMessage(hwndCombo, CB_ADDSTRING,
                                   0, reinterpret_cast<LPARAM>(static_cast<LPCTSTR>(szPort)));
        }
        if (id != LB_ERR)
        {
            SendMessage(hwndCombo, CB_SETITEMDATA,
                        id, Idx);
        }
        if (!_tcsicmp(szTemp, szPort))
        {
            CurrentId = id;
        }
    }

    if (CurrentId == -1)
    {

        //
        // CreateFile name is not COM/LPT/AUTO. add this name to the bottom.
        //

        CurrentId = (int) SendMessage(hwndCombo, CB_ADDSTRING,
                                      0, reinterpret_cast<LPARAM>(static_cast<LPCTSTR>(szTemp)));
    }

    SendMessage(hwndCombo, CB_SETCURSEL, CurrentId, 0);
    SendMessage(hwndParent,
                WM_COMMAND,
                MAKELONG (CtrlId, CBN_SELCHANGE),
                reinterpret_cast<LPARAM>(hwndCombo));

    SetupDiDestroyDeviceInfoList(hDevInfo);
    return  TRUE;

}


/*****************************************************************************

   CSTIGeneralPage::GetDeviceStatus

   <Notes>

 *****************************************************************************/

UINT
CSTIGeneralPage::GetDeviceStatus (void)
{
    PSTIDEVICE          psdThis = NULL;
    STI_DEVICE_STATUS   sds;
    UINT                idMessageString;

    TraceEnter (TRACE_PROPUI, "CSTIGeneralPage::GetDeviceStatus");
    HRESULT hr = g_pSti -> CreateDevice(m_psdi -> szDeviceInternalName,
                                        STI_DEVICE_CREATE_STATUS,
                                        &psdThis,
                                        NULL);

    if (SUCCEEDED(hr) && psdThis)
    {
        CWaitCursor    waitCursor;

        //
        // Need to claim device before using
        //
        hr = psdThis -> LockDevice(2000);
        if (SUCCEEDED(hr))
        {
            ZeroMemory(&sds,sizeof(sds));
            sds.StatusMask = STI_DEVSTATUS_ONLINE_STATE;

            hr = psdThis -> GetStatus(&sds);
            psdThis -> UnLockDevice();
        }
        else
        {
            Trace ( TEXT("Failed to lock device for GetStatus HRes=%X"),hr);
        }

        psdThis -> Release();
    }
    else
    {
        hr = E_FAIL;
        Trace (TEXT(  "Failed to Create device for GetStatus HRes=%X"),hr);
    }


    //
    // Figure out message string to display as status and load appropriate resource
    //
    idMessageString = IDS_UNAVAILABLE;

    if (SUCCEEDED(hr) )
    {
        if ( sds.dwOnlineState & STI_ONLINESTATE_OPERATIONAL)
        {
            idMessageString = IDS_OPERATIONAL;
        }
        else
        {
            idMessageString = IDS_OFFLINE;
        }
    }
    TraceLeave ();
    return idMessageString;
}


/*****************************************************************************

   CEventMonitor constructor / desctructor

   <Notes>

 *****************************************************************************/

CEventMonitor::CEventMonitor(MySTIInfo *pDevInfo) :
CSTIPropertyPage(IDD_EVENT_MONITOR, pDevInfo)
{

    CSimpleString csKey(IsPlatformNT() ? REGSTR_PATH_STIDEVICES_NT : REGSTR_PATH_STIDEVICES);
    csKey += TEXT("\\");
    csKey += CSimpleStringConvert::NaturalString (CSimpleStringWide(m_psdi -> szDeviceInternalName));

    csKey += REGSTR_PATH_EVENTS;
    m_hkThis = CSimpleReg (HKEY_LOCAL_MACHINE, csKey, true, KEY_READ|KEY_WRITE );
}

CEventMonitor::~CEventMonitor()
{
// Unsubclass the listbox
    SetWindowLongPtr (GetDlgItem (m_hwnd, IDC_APP_LIST),
                      GWLP_WNDPROC,
                      reinterpret_cast<LONG_PTR>(m_lpfnOldProc));
}



/*****************************************************************************

   CEventMonitor::OnInit

   OnInit handler- initializes the dialog box controls

 *****************************************************************************/

INT_PTR
CEventMonitor::OnInit()
{

    // Loads and sets the right Icon.
    HICON hIcon = LoadIcon(GLOBAL_HINSTANCE, MAKEINTRESOURCE(
                                                            (GET_STIDEVICE_TYPE(m_psdi -> DeviceType) == StiDeviceTypeScanner) ?
                                                            IDI_SCANNER : IDI_CAMERA));

    SendDlgItemMessage(m_hwnd,
                       IDC_DEVICE_ICON,
                       STM_SETICON,
                       (WPARAM) hIcon,
                       0);

    // Loads the right text (depending upon device type)
    CSimpleString csEventText;

    if (GET_STIDEVICE_TYPE(m_psdi->DeviceType) == StiDeviceTypeScanner)
    {

        csEventText.LoadString(IDS_SCANNER_EVENTS, GLOBAL_HINSTANCE);

    }
    else
    {

        csEventText.LoadString(IDS_CAMERA_EVENTS, GLOBAL_HINSTANCE);

    }

    csEventText.SetWindowText (GetDlgItem (m_hwnd, IDC_EVENT_TEXT));

    //
    // Set the current state of notifications for a device .
    // Nb: We don't contact STIMON here, just read registry setting
    //
    DWORD   dwType = REG_DWORD;
    DWORD   cbData = sizeof(m_dwUserDisableNotifications);
    HRESULT hr;

    hr = g_pSti -> GetDeviceValue(m_psdi -> szDeviceInternalName,
                                  STI_DEVICE_VALUE_DISABLE_NOTIFICATIONS,
                                  &dwType,
                                  (LPBYTE)&m_dwUserDisableNotifications,
                                  &cbData);

    if (!SUCCEEDED(hr))
    {
        m_dwUserDisableNotifications = FALSE;
    }

    CheckDlgButton(m_hwnd,IDC_CHECK_DISABLE_EVENTS,m_dwUserDisableNotifications);

    //
    // Fill the list box first so that there is something to select against
    // when we select the first item in the Combobox (CBN_SELCHANGE).
    //
    FillListbox (m_hwnd, IDC_APP_LIST);

    // Put up the friendly name.
    CSimpleString csWork = CSimpleStringConvert::NaturalString(CSimpleStringWide(m_psdi -> pszLocalName));
    csWork.SetWindowText(GetDlgItem(m_hwnd, IDC_FRIENDLY));

    BuildEventList (m_hwnd, IDC_EVENT_LIST);

    // Select the first item in the Combobox.
    SetSelectionChanged (FALSE);
    SendMessage(m_hwndList, CB_SETCURSEL, 0, 0);

    // Complete the initial selections in the listbox.
    SendMessage(m_hwnd,
                WM_COMMAND,
                MAKELONG (IDC_EVENT_LIST, CBN_SELCHANGE),
                (LPARAM)m_hwndList);

    // Finally sub-class the listbox window
    SetWindowLongPtr (GetDlgItem (m_hwnd, IDC_APP_LIST),
                      GWLP_USERDATA,
                      (LONG_PTR)this);
    m_lpfnOldProc = (FARPROC) SetWindowLongPtr (GetDlgItem (m_hwnd, IDC_APP_LIST),
                                                GWLP_WNDPROC,
                                                (LONG_PTR)ListSubProc);

    return TRUE;
}


/*****************************************************************************

   CEventMonitor::OnCommand

   Handle WM_COMMAND messages

 *****************************************************************************/

INT_PTR
CEventMonitor::OnCommand(WORD wCode, WORD widItem, HWND hwndItem)
{

    PDEVICEEVENT    pDeviceEvent;

    switch (widItem)
    {

    case    IDC_EVENT_LIST:

        switch (wCode)
        {

        case    CBN_SELCHANGE: {

                TCHAR       szText[BIG_ENOUGH];
                LRESULT     Idx;

                if (HasSelectionChanged())
                {

                    // update the old list
                    GetDlgItemText (m_hwnd, widItem, szText, ARRAYSIZE(szText));

                    Idx = SendMessage(hwndItem,
                                      CB_FINDSTRING,
                                      static_cast<WPARAM>(-1),
                                      (LPARAM)(LPTSTR)szText);

                    if (Idx != CB_ERR)
                    {

                        // delete the old list
                        pDeviceEvent = (PDEVICEEVENT) SendMessage (hwndItem,
                                                                   CB_GETITEMDATA,
                                                                   Idx,
                                                                   0);

                        if ( (INT_PTR) pDeviceEvent == CB_ERR)
                        {

                            break;
                        }



                        // build the new list
                        pDeviceEvent->LaunchApplications = TEXT("");


                        int AddCount;
                        int AppIdx;

                        for (AddCount = 0, AppIdx = -1;
                            (AppIdx = m_IdMatrix.EnumIdx(AppIdx)) != -1; NULL)
                        {

                            if (SendDlgItemMessage (m_hwnd, IDC_APP_LIST, LB_GETTEXT,
                                                    AppIdx, (LPARAM)(LPTSTR)szText) != LB_ERR)
                            {

                                if (AddCount)
                                {

                                    pDeviceEvent->LaunchApplications += TEXT(",");
                                }

                                pDeviceEvent->LaunchApplications += szText;

                                AddCount++;
                            }
                        }

                        SetSelectionChanged(FALSE);
                    }


                }

                // This is the new selection
                Idx = SendMessage(hwndItem,
                                  CB_GETCURSEL,
                                  0,
                                  0);

                if (Idx == CB_ERR)
                {

                    return  TRUE;
                }

                m_IdMatrix.Clear();

                pDeviceEvent = (PDEVICEEVENT) SendMessage (hwndItem, CB_GETITEMDATA,
                                                           Idx, 0);

                if ( (INT_PTR) pDeviceEvent == CB_ERR)
                {

                    break;
                }

                // check for wildcard in first item
                if (pDeviceEvent->LaunchApplications.Length()  &&
                    !lstrcmpi (pDeviceEvent->LaunchApplications, TEXT("*")))
                {

                    // Select the entire list

                    m_IdMatrix.Set();

                }
                else
                {

                    // Traversing through the listbox doing searches.
                    // but we are going to have to do the compare somewhere.

                    LRESULT AppMax = SendDlgItemMessage (m_hwnd, IDC_APP_LIST,
                                                         LB_GETCOUNT, 0, 0);

                    if (AppMax != LB_ERR)
                    {

                        for (int i = 0; i < AppMax; i++)
                        {

                            if (SendDlgItemMessage (m_hwnd, IDC_APP_LIST,
                                                    LB_GETTEXT, i, (LPARAM)(LPTSTR)szText) == LB_ERR)
                            {

                                continue;
                            }

                            if (pDeviceEvent->LaunchApplications.Length() &&
                                _tcsstr (pDeviceEvent->LaunchApplications, szText))
                            {
                                m_IdMatrix.Toggle (i);

                            }

                        }

                    }

                }

                // Force the repaint.
                InvalidateRect (GetDlgItem (m_hwnd, IDC_APP_LIST), NULL, TRUE);

                return  TRUE;
            }

        default:
            break;

        }

        break;

    case    IDC_APP_LIST:

        switch (wCode)
        {

        case    LBN_DBLCLK: {

                // This is the new selection
                LRESULT Idx = SendMessage(hwndItem,
                                          LB_GETCURSEL,
                                          0,
                                          0);

                if (Idx == LB_ERR)
                    return  TRUE;

                m_IdMatrix.Toggle((UINT)Idx);

                // Force the repaint.
                InvalidateRect (hwndItem, NULL, FALSE);

                SetSelectionChanged (TRUE);

                PropSheet_Changed (GetParent(m_hwnd), m_hwnd);

                return  TRUE;
            }

        default:
            break;

        }

        break;

    case IDC_CHECK_DISABLE_EVENTS:
        //
        // Disable check box changed it' state - enable Apply button
        PropSheet_Changed (GetParent(m_hwnd), m_hwnd);
        SetSelectionChanged (TRUE);


        break;

    default:
        break;

    }

    return  FALSE;
}


/*****************************************************************************

   CEventMonitor::OnApplyChanges

   <Notes>

 *****************************************************************************/

LONG
CEventMonitor::OnApplyChanges(BOOL bHitOK)
{

    TCHAR szText[BIG_ENOUGH];

    HWND hwndEvents = GetDlgItem (m_hwnd, IDC_EVENT_LIST);

    LRESULT uiCount = SendMessage (hwndEvents, CB_GETCOUNT,
                                   0,0);

    LRESULT CurrentIdx = SendMessage(hwndEvents, CB_GETCURSEL,
                                     0,0);

    PDEVICEEVENT    pDeviceEvent;

    for (INT u = 0; u < uiCount; u++)
    {

        if ((CurrentIdx == u) && HasSelectionChanged())
        {

            pDeviceEvent = (PDEVICEEVENT) SendMessage (hwndEvents,
                                                       CB_GETITEMDATA,
                                                       u,
                                                       0);

            if ( (INT_PTR) pDeviceEvent == CB_ERR)
            {

                break;
            }



            // build the new list
            pDeviceEvent->LaunchApplications = TEXT("");


            int AddCount;
            int AppIdx;

            for (AddCount = 0, AppIdx = -1;
                (AppIdx = m_IdMatrix.EnumIdx(AppIdx)) != -1; NULL)
            {

                if (SendDlgItemMessage (m_hwnd, IDC_APP_LIST, LB_GETTEXT,
                                        AppIdx, (LPARAM)(LPTSTR)szText) != LB_ERR)
                {

                    if (AddCount)
                    {

                        pDeviceEvent->LaunchApplications += TEXT(",");
                    }

                    pDeviceEvent->LaunchApplications += szText;

                    AddCount++;
                }

            }

            if (!bHitOK)
            {

                SetSelectionChanged(FALSE);

            }

        }
        else
        {

            pDeviceEvent = (PDEVICEEVENT) SendMessage (hwndEvents,
                                                       CB_GETITEMDATA, u, 0);

        }

        pDeviceEvent->LaunchApplications.Store (pDeviceEvent->hKeyEvent, REGSTR_VAL_LAUNCH_APPS);

        if (bHitOK)
        {
            DoDelete (pDeviceEvent);
        }

    }

    //
    // reset List box content
    //
    if (bHitOK)
    {

        SendMessage (hwndEvents, CB_RESETCONTENT, 0, 0);

    }

    //
    // Save disabling flag state
    //
    m_dwUserDisableNotifications = IsDlgButtonChecked(m_hwnd,IDC_CHECK_DISABLE_EVENTS);

    g_pSti -> SetDeviceValue(m_psdi -> szDeviceInternalName,
                             STI_DEVICE_VALUE_DISABLE_NOTIFICATIONS,
                             REG_DWORD,
                             (LPBYTE)&m_dwUserDisableNotifications,
                             sizeof(m_dwUserDisableNotifications));


    //
    // Inform STIMON about the change , just made
    //
    SendRefreshToStiMon();
    return  PSNRET_NOERROR;
}


/*****************************************************************************

   CEventMonitor::OnReset

   <Notes>

 *****************************************************************************/

VOID
CEventMonitor::OnReset (BOOL bHitCancel)
{


    HWND hwndEvents = GetDlgItem (m_hwnd, IDC_EVENT_LIST);

    PDEVICEEVENT    pDeviceEvent;
    LRESULT         dwRet;

    for (unsigned u = 0;
        (dwRet = SendMessage (hwndEvents, CB_GETITEMDATA, u, 0)) != CB_ERR;
        u++)
    {

        pDeviceEvent = (PDEVICEEVENT)dwRet;

        DoDelete (pDeviceEvent);

    }

    m_dwUserDisableNotifications = FALSE;

    CheckDlgButton(m_hwnd,IDC_CHECK_DISABLE_EVENTS,m_dwUserDisableNotifications);

}


/*****************************************************************************

   CEventMonitor::OnDrawItem

   <Notes>

 *****************************************************************************/

void
CEventMonitor::OnDrawItem(LPDRAWITEMSTRUCT lpdis)
{

    // Code also lifted from setupx.

    HDC     hDC;
    TCHAR   szText[BIG_ENOUGH];
    int     bkModeSave;
    SIZE    size;
    DWORD   dwBackColor;
    DWORD   dwTextColor;
    UINT    itemState;
    RECT    rcItem;
    HICON   hIcon;

    hDC         = lpdis->hDC;
    itemState   = lpdis->itemState;
    rcItem      = lpdis->rcItem;
    hIcon       = (HICON)lpdis->itemData;


    if ((int)lpdis->itemID < 0)
        return;

    SendMessage(lpdis->hwndItem, LB_GETTEXT, lpdis->itemID, (LPARAM)(LPTSTR)szText);

    GetTextExtentPoint32(hDC, szText, lstrlen(szText), &size);

    if (lpdis->itemAction != ODA_FOCUS)
    {
        bkModeSave = GetBkMode(hDC);

        dwBackColor = SetBkColor(hDC, GetSysColor((itemState & ODS_SELECTED) ?
                                                  COLOR_HIGHLIGHT : COLOR_WINDOW));
        dwTextColor = SetTextColor(hDC, GetSysColor((itemState & ODS_SELECTED) ?
                                                    COLOR_HIGHLIGHTTEXT : COLOR_WINDOWTEXT));

        // fill in the background; do this before mini-icon is drawn
        ExtTextOut(hDC, 0, 0, ETO_OPAQUE, &rcItem, NULL, 0, NULL);

        // Draw the "preferred list" checkbox next
        rcItem.left += DrawCheckBox (hDC, rcItem, m_IdMatrix.IsSet(lpdis->itemID));

        // Draw the icon
        DrawIconEx (hDC,
                    rcItem.left,
                    rcItem.top + ((rcItem.bottom - rcItem.top) - MINIY) / 2,
                    hIcon,
                    0,
                    0,
                    0,
                    NULL,
                    DI_NORMAL);

        rcItem.left += (MINIX + 2);

        // draw the text transparently on top of the background
        SetBkMode(hDC, TRANSPARENT);

        ExtTextOut(hDC,
                   rcItem.left,
                   rcItem.top + ((rcItem.bottom - rcItem.top) - size.cy) / 2,
                   0,
                   NULL,
                   szText,
                   lstrlen(szText),
                   NULL);

        // Restore hdc colors.
        SetBkColor  (hDC, dwBackColor);
        SetTextColor(hDC, dwTextColor);
        SetBkMode   (hDC, bkModeSave);
    }

    if (lpdis->itemAction == ODA_FOCUS || (itemState & ODS_FOCUS))
        DrawFocusRect(hDC, &rcItem);
}


BOOL
/*****************************************************************************

   CEventMonitor::BuildEventList

   Enumerate the events for the current STI device

 *****************************************************************************/

CEventMonitor::BuildEventList (HWND hwndParent, UINT CtrlId)
{

    m_hwndList = GetDlgItem(hwndParent, CtrlId);

    return m_hkThis.EnumKeys (EventListEnumProc, reinterpret_cast<LPARAM>(this), true);
}

/*****************************************************************************

CEventMonitor::EventListEnumProc

Fill the event list combobox with the enumerated events

******************************************************************************/

bool
CEventMonitor::EventListEnumProc (CSimpleReg::CKeyEnumInfo &Info)
{
    CEventMonitor *pThis = reinterpret_cast<CEventMonitor *>(Info.lParam);

    PDEVICEEVENT pDeviceEvent;
    pDeviceEvent =  new DEVICEEVENT;

    if (!pDeviceEvent)
    {

        return false;
    }
    ZeroMemory (pDeviceEvent, sizeof(DEVICEEVENT));

    pDeviceEvent->hKeyEvent = CSimpleReg (pThis->m_hkThis, Info.strName);

    if (!pDeviceEvent->hKeyEvent.Open ())
    {
        delete pDeviceEvent;
        return false;
    }


    //
    // First check if its launchable (absence of the key assume means launchable???)
    //

    pDeviceEvent->Launchable = pDeviceEvent->hKeyEvent.Query (REGSTR_VAL_LAUNCHABLE, TRUE);
    if (!(pDeviceEvent->Launchable))
    {
        delete pDeviceEvent;
    }
    else
    {
        pDeviceEvent->Description = TEXT("");


        pDeviceEvent->Description.Load (pDeviceEvent->hKeyEvent, TEXT(""));

        pDeviceEvent->LaunchApplications =TEXT("");


        pDeviceEvent->LaunchApplications.Load (pDeviceEvent->hKeyEvent, REGSTR_VAL_LAUNCH_APPS);

        //
        // Load into the combo box
        //
        LRESULT id = SendMessage(pThis->m_hwndList,
                                 CB_ADDSTRING,
                                 0,
                                 reinterpret_cast<LPARAM>(static_cast<LPCTSTR>(pDeviceEvent->Description)));

        SendMessage(pThis->m_hwndList, CB_SETITEMDATA, id, reinterpret_cast<LPARAM>(pDeviceEvent));

    }

    return true;
}

/*****************************************************************************

CEventMonitor::FillListEnumProc

Fills an array of strings with value names and values from the regkey enumeration

******************************************************************************/

bool
CEventMonitor::FillListEnumProc (CSimpleReg::CValueEnumInfo &Info)
{
    CSimpleDynamicArray<CSimpleString> *pValueList;
    CSimpleString pValue;
    pValueList = reinterpret_cast<CSimpleDynamicArray<CSimpleString> *>(Info.lParam);

    if (Info.nType == REG_SZ || Info.nType == REG_EXPAND_SZ)
    {
        // first append the value name
        pValueList->Append(Info.strName);
        // then append the value
        pValue = Info.reg.Query (Info.strName, TEXT(""));
        pValueList->Append (pValue);
    }
    return true;
}

/*****************************************************************************

   CEventMonitor::FillListbox

   Enumerate the list of registered event handlers and fill the list box

 *****************************************************************************/

void
CEventMonitor::FillListbox(HWND hwndParent, UINT CtrlId)
{


    HWND        hwnd;

    CSimpleString   szAppFriendly;
    TCHAR   szAppPath[MAX_PATH*2];;
    SHFILEINFO  shfi;

    LRESULT     Idx = LB_ERR;
    HICON       hIcon;
    CSimpleDynamicArray<CSimpleString> ValueList;


    hwnd = GetDlgItem (hwndParent, CtrlId);

    CSimpleReg  hkApps(HKEY_LOCAL_MACHINE, REGSTR_PATH_REG_APPS);
    hkApps.Open();


    // Turn off listbox updates
    //
    SendMessage( hwnd, WM_SETREDRAW, 0,  0L );
    SendMessage( hwnd, LB_RESETCONTENT, 0,  0L ); // Make sure it's empty.

    // Load a "default" Icon.
    //
    hIcon = (HICON)LoadImage(GLOBAL_HINSTANCE,
                             MAKEINTRESOURCE(IDI_DEFAULT),
                             IMAGE_ICON,
                             16,
                             16,
                             LR_SHARED);

    // Build the list of value names and values
    //
    if (hkApps.EnumValues (FillListEnumProc, reinterpret_cast<LPARAM>(&ValueList)))
    {

        // cycle through the strings in the list to fill the listbox
        for (INT i=0;i<ValueList.Size();i+=2)
        {

            szAppFriendly = ValueList[i];
            Idx = SendMessage( hwnd,
                               LB_ADDSTRING,
                               0,
                               reinterpret_cast<LPARAM>(static_cast<LPCTSTR>(szAppFriendly )));

            if (Idx != LB_ERR)
            {

                ZeroMemory(&shfi,sizeof(shfi));

                shfi.hIcon = NULL;

                //
                // Command line parsing to remove arguments...
                //

                LPTSTR   pszLastSpace = NULL;
                lstrcpyn (szAppPath, ValueList[i+1], ARRAYSIZE(szAppPath));
                if (* szAppPath == TEXT('"'))
                {

                    //
                    // Remove leading and trailing quotes
                    //

                    PathRemoveArgs(szAppPath);

                    // use MoveMemory because it is safe with overlapping memory
                    MoveMemory(szAppPath,szAppPath+1,sizeof(szAppPath)-sizeof(TCHAR));
                    pszLastSpace = _tcschr(szAppPath,TEXT('"'));
                    if (pszLastSpace)
                    {
                        *pszLastSpace = TEXT('\0');
                    }
                }
                else
                {
                    pszLastSpace = _tcschr(szAppPath,TEXT('/'));
                }

                //
                // At this point szAppPath should contain original buffer with only executable file
                // specification in it, and pszLastSpace may be NULL
                //
                do
                {

                    if (pszLastSpace)
                    {
                        *pszLastSpace = TEXT('\0');
                    }

                    if (SHGetFileInfo(szAppPath,
                                  0,
                                  &shfi,
                                  sizeof( SHFILEINFO ),
                                  SHGFI_ICON | SHGFI_SHELLICONSIZE | SHGFI_SMALLICON) && shfi.hIcon)
                    {
                        break;
                    }

                } while ( (pszLastSpace = _tcsrchr(szAppPath,TEXT(' '))) != NULL);


                if (shfi.hIcon)
                {

                    SendMessage( hwnd,
                             LB_SETITEMDATA,
                             Idx,
                             (LPARAM)shfi.hIcon);
                }
                else
                {

                    SendMessage( hwnd,
                             LB_SETITEMDATA,
                             Idx,
                             (LPARAM)hIcon);
                }
            }
        }
    }

    if ( Idx != LB_ERR )
    {
        // Make sure we had some elements and no errors.
        SendMessage( hwnd, LB_SETCURSEL, 0, 0L );
    }

    // Now turn on listbox updates.
    SendMessage( hwnd, WM_SETREDRAW, (WPARAM) 1,  0L );

    if ((Idx = SendMessage (hwnd, LB_GETCOUNT, 0, 0)) != LB_ERR)
        m_IdMatrix.SetCount ((UINT)Idx);


}


/*****************************************************************************

   CEventMonitor::DrawCheckBox

   <Notes>

 *****************************************************************************/

UINT
CEventMonitor::DrawCheckBox (HDC hDC, RECT rcItem, BOOL Checked)
{


    HICON  hIcon;

    hIcon = (HICON)LoadImage(GLOBAL_HINSTANCE,
                             Checked ? MAKEINTRESOURCE(IDI_SELECT) : MAKEINTRESOURCE(IDI_UNSELECT),
                             IMAGE_ICON,
                             16,
                             16,
                             LR_SHARED);

    if (hIcon)
    {

        // Draw the icon
        DrawIconEx (hDC,
                    rcItem.left,
                    rcItem.top + ((rcItem.bottom - rcItem.top) - MINIY) / 2,
                    hIcon,
                    0,
                    0,
                    0,
                    NULL,
                    DI_NORMAL);

    }

    return (MINIX + 2);

}


/*****************************************************************************

   CEventMonitor::ListSubProc

   <Notes>

 *****************************************************************************/

LRESULT
CALLBACK
CEventMonitor::ListSubProc (HWND hwnd,
                            UINT msg,
                            WPARAM wParam,
                            LPARAM lParam)
{


    // Snatched from setupx

    LRESULT    rc;
    WORD        Id;

    CEventMonitor *pcem = (CEventMonitor *) GetWindowLongPtr (hwnd, GWLP_USERDATA);

    Id = LOWORD(GetWindowLong(hwnd, GWLP_ID));
    // Convert single click on icon to double click

    if (msg == WM_LBUTTONDOWN && LOWORD(lParam) <= MINIX)
    {

        // Call the standard window proc to handle the msg (and
        // select the proper list item)
        rc = CallWindowProc((WNDPROC)pcem->m_lpfnOldProc, hwnd, msg, wParam, lParam);

        // Now do the double click thing
        SendMessage(pcem->m_hwnd,
                    WM_COMMAND,
                    (WPARAM)MAKELONG (Id, LBN_DBLCLK),
                    (LPARAM)hwnd);

        //
        // now send a WM_LBUTTONDOWN to listbox so it
        // doesn't get stuck down (chicago problem).
        //

        CallWindowProc((WNDPROC)pcem->m_lpfnOldProc,
                       hwnd,
                       WM_LBUTTONUP,
                       wParam,
                       lParam);

        return (BOOL)rc;
    }

    if (msg == WM_KEYDOWN && wParam == VK_SPACE)
    {

        // Treat spacebar as double click
        SendMessage(pcem->m_hwnd,
                    WM_COMMAND,
                    (WPARAM)MAKELONG (Id, LBN_DBLCLK),
                    (LPARAM)hwnd);
    }

    return CallWindowProc((WNDPROC)pcem->m_lpfnOldProc,
                          hwnd,
                          msg,
                          wParam,
                          lParam);
}



/*****************************************************************************

   CPortSettingsPage::OnInit

   Initialize dialog window

 *****************************************************************************/

INT_PTR
CPortSettingsPage::OnInit(VOID)
{

    // Populate port names combobox
    //BuildPortList(m_hwnd, IDC_COM_SETTINGS);

    // BUGBUG How to synchronize with general page ???? May be, move port list here
    SetDlgItemText(m_hwnd,
                   IDC_PORT_NAME,
                   CSimpleStringConvert::NaturalString(CSimpleStringWide(m_psdi -> pszPortName)));


    // Populate baud rate combobox
    m_uBaudRate = BuildBaudRateList(m_hwnd,IDC_BAUDRATE_COMBO);

    return  TRUE;
}


/*****************************************************************************

   CPortSettingsPage::BuildBaudRateList

   Fill out legal baud rates. Return current device baud rate

 *****************************************************************************/

UINT
CPortSettingsPage::BuildBaudRateList(HWND hwndParent,
                                     UINT CtrlId)
{


    UINT        uBaudRate;


    WORD        nComboChoice;
    HWND        hBaudBox = NULL;
    HRESULT     hr = E_FAIL;
    DWORD       dwType = REG_DWORD;
    DWORD       cbData = sizeof(uBaudRate);

    TraceAssert(g_pSti);

    hr = g_pSti->GetDeviceValue(m_psdi -> szDeviceInternalName,
                                REGSTR_VAL_BAUDRATE,
                                &dwType,
                                (LPBYTE)&uBaudRate,
                                &cbData);
    if (!SUCCEEDED(hr))
    {
        uBaudRate = 115200;
    }

    hBaudBox = GetDlgItem(hwndParent,CtrlId);

    //
    // Clear Contents of ComboBox
    //
    SendMessage(hBaudBox,
                CB_RESETCONTENT,
                0,
                0L);

    //
    // Populate ComboBox with Baud Choices
    // BUGBUG Should it be programmatic ?
    //
    ComboBox_AddString(hBaudBox,TEXT("9600"));
    ComboBox_AddString(hBaudBox,TEXT("19200"));
    ComboBox_AddString(hBaudBox,TEXT("38400"));
    ComboBox_AddString(hBaudBox,TEXT("57600"));
    ComboBox_AddString(hBaudBox,TEXT("115200"));

    //
    // Set ComboBox to highlight the value obtained from registry
    //
    switch (uBaudRate)
    {
    case 9600:   nComboChoice = 0; break;
    case 19200:  nComboChoice = 1; break;
    case 38400:  nComboChoice = 2; break;
    case 57600:  nComboChoice = 3; break;
    case 115200: nComboChoice = 4; break;
    default: nComboChoice = 4;
    }

    ComboBox_SetCurSel(hBaudBox,nComboChoice);

    return uBaudRate;
}


/*****************************************************************************

   CPortSettingsPage::OnCommand

   Enable the Apply button when the combobox selection changes

 *****************************************************************************/

INT_PTR
CPortSettingsPage::OnCommand(WORD wCode,
                             WORD widItem,
                             HWND hwndItem)
{


    if (CBN_SELCHANGE == wCode )
    {
        // Enable Apply button
        ::SendMessage(::GetParent(m_hwnd),
                      PSM_CHANGED,
                      (WPARAM)m_hwnd,
                      0);
        return TRUE;
    }

    return  FALSE;
}


/*****************************************************************************

   CPortSettingsPage::OnApplyChanges

   <Notes>

 *****************************************************************************/

LONG
CPortSettingsPage::OnApplyChanges(BOOL bHitOK)
{
    UINT    nComboChoice;
    HWND    hBaudBox ;
    UINT    uBaudRate = 0;

    hBaudBox = GetDlgItem(m_hwnd,IDC_BAUDRATE_COMBO);

    nComboChoice = ComboBox_GetCurSel(hBaudBox);

    //
    // Translate current selection into baudrate
    //
    switch (nComboChoice)
    {
    case 0: uBaudRate = 9600; break;
    case 1: uBaudRate = 19200; break;
    case 2: uBaudRate = 38400; break;
    case 3: uBaudRate = 57600; break;
    case 4: uBaudRate = 115200; break;
    default: uBaudRate = 115200;
    }


    //
    // Set New Baud Rate in STI Registry
    //
    if (uBaudRate != m_uBaudRate)
    {

        TraceAssert(g_pSti);

        g_pSti->SetDeviceValue(m_psdi -> szDeviceInternalName,
                               REGSTR_VAL_BAUDRATE,
                               REG_DWORD,
                               (LPBYTE)&uBaudRate,
                               sizeof(uBaudRate));
        m_uBaudRate = uBaudRate;
    }

    return PSNRET_NOERROR;
}


/*****************************************************************************

   CPortSettingsPage::IsNeeded

   <Notes>

 *****************************************************************************/

BOOL
CPortSettingsPage::IsNeeded(VOID)
{
    if (m_psdi->dwHardwareConfiguration & STI_HW_CONFIG_SERIAL)
    {
        return TRUE;
    }

    return FALSE;
}


/*****************************************************************************

   SendRefreshToStiMon

   Send refresh message to Sti Monitor, if it is running.  Currently CPL
   requests reread of all registry information for all active devices.

 *****************************************************************************/

BOOL
SendRefreshToStiMon(VOID)
{
    BOOL            rVal = FALSE;
    SC_HANDLE       hSvcMgr = NULL;
    SC_HANDLE       hService = NULL;
    SERVICE_STATUS  ServiceStatus;

    //
    // Open Service Control Manager.
    //

    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (hSvcMgr)
    {
        //
        // Open WIA service.
        //

        hService = OpenService(
            hSvcMgr,
            STI_SERVICE_NAME,
            SERVICE_USER_DEFINED_CONTROL
            );

        if (hService)
        {
            //
            // Inform WIA service to refresh its device settings.
            //

            rVal = ControlService(hService,
                                  STI_SERVICE_CONTROL_REFRESH,
                                  &ServiceStatus);
            if (!rVal)
            {
                //Trace(TEXT("SendRefreshToStiMon: ERROR!! ControlService failed. Err=0x%x\n"), GetLastError());
            }
        } else {
            //Trace(TEXT("SendRefreshToStiMon: ERROR!! OpenService failed. Err=0x%x\n"), GetLastError());
        }

    } else {
        //Trace(TEXT("SendRefreshToStiMon: ERROR!! OpenSCManager failed. Err=0x%x\n"), GetLastError());
    }


    //
    //  Close Handles
    //

    if(NULL != hService){
        CloseServiceHandle( hService );
        hService = NULL;
    }
    if(NULL != hSvcMgr){
        CloseServiceHandle( hSvcMgr );
        hSvcMgr = NULL;
    }

    return rVal;
}


/*****************************************************************************

   IsPnPDevice

   <Notes>

 *****************************************************************************/

BOOL
IsPnPDevice(PSTI_DEVICE_INFORMATION psdi, CSimpleString *pszConnection)

{
    CSimpleString           szInfPath;
    CSimpleString           szInfSection;
    HANDLE                  hDevInfo;


    SP_DEVINFO_DATA         spDevInfoData;
    DWORD                   err;
    HINF                    hInf;
    HKEY                    hKeyDevice;
    ULONG                   cbData;
    BOOL                    bIsPnP = TRUE;


    if (pszConnection)
    {
        *pszConnection = TEXT("");
    }

    hDevInfo = SelectDevInfoFromFriendlyName(psdi->pszLocalName);
    if(hDevInfo != INVALID_HANDLE_VALUE)
    {
        memset (&spDevInfoData, 0, sizeof(SP_DEVINFO_DATA));
        spDevInfoData.cbSize = sizeof(SP_DEVINFO_DATA);
        SetupDiGetSelectedDevice(hDevInfo, &spDevInfoData);
    }
    else
    {
        return TRUE;
    }


    hKeyDevice = SetupDiOpenDevRegKey (hDevInfo,
                                       &spDevInfoData,
                                       DICS_FLAG_GLOBAL,
                                       0,
                                       DIREG_DRV,
                                       KEY_READ);
    if (hKeyDevice != INVALID_HANDLE_VALUE)
    {

        //
        // See if it's PnP or not
        //

        cbData = sizeof(bIsPnP);
        if (RegQueryValueEx(hKeyDevice,
                           REGSTR_VAL_ISPNP,
                           NULL,
                           NULL,
                           (LPBYTE)&bIsPnP,
                           &cbData) != ERROR_SUCCESS)
        {

            //
            // IsPnP is not found..
            //

            RegCloseKey(hKeyDevice);
            goto IsPnPDevice_Err;
        }

        if (!szInfPath.Load(hKeyDevice,REGSTR_VAL_INFPATH))

        {

            //
            //InfPath is not found..
            //

           RegCloseKey(hKeyDevice);
           goto IsPnPDevice_Err;
        }


        if (!szInfSection.Load(hKeyDevice,REGSTR_VAL_INFSECTION))

        {
            //
            //InfSection is not found..
            //

            RegCloseKey(hKeyDevice);
            goto IsPnPDevice_Err;
        }

        RegCloseKey(hKeyDevice);
    }

    SetupDiDestroyDeviceInfoList(hDevInfo);
    hDevInfo = NULL;
    //
    // Open Inf file and copy connection type to szConnection
    //
    if (pszConnection)
    {

       TCHAR szBuffer[MAX_PATH];
       hInf = SetupOpenInfFile(szInfPath,
                               NULL,
                               INF_STYLE_WIN4,
                               NULL);

       if (hInf == INVALID_HANDLE_VALUE)
       {
           err = GetLastError();
           goto IsPnPDevice_Err;
       }

       if(!SetupGetLineText(NULL,
                            hInf,
                            szInfSection,
                            TEXT("Connection"),
                            szBuffer,
                            MAX_PATH,
                            &cbData))
       {
           *pszConnection = TEXT("BOTH");
       }
       else
       {
           *pszConnection = szBuffer;
       }
       SetupCloseInfFile(hInf);
    }
IsPnPDevice_Err:

    if(hDevInfo)
    {
        SetupDiDestroyDeviceInfoList(hDevInfo);
    }
    return bIsPnP;
}


/*****************************************************************************

   SelectDevInfoFromFriendlyName

   <Notes>

 *****************************************************************************/

HANDLE
SelectDevInfoFromFriendlyName(const CSimpleStringWide &pszLocalName)
{

    CSimpleString           szTemp;
    CSimpleString           szFriendlyName;
    HANDLE                  hDevInfo;
    GUID                    Guid = GUID_DEVCLASS_IMAGE;
    DWORD                   Idx;
    SP_DEVINFO_DATA         spDevInfoData;
    DWORD                   err;
    BOOL                    Found = FALSE;
    HKEY                    hKeyDevice;


    szFriendlyName = CSimpleStringConvert::NaturalString (pszLocalName);
    hDevInfo = SetupDiGetClassDevs (&Guid, NULL, NULL, DIGCF_PROFILE);

    if (hDevInfo == INVALID_HANDLE_VALUE)
    {
        err = GetLastError();
        return INVALID_HANDLE_VALUE;
    }

    spDevInfoData.cbSize = sizeof (SP_DEVINFO_DATA);
    for (Idx = 0; SetupDiEnumDeviceInfo (hDevInfo, Idx, &spDevInfoData); Idx++)
    {
        hKeyDevice = SetupDiOpenDevRegKey (hDevInfo,
                                           &spDevInfoData,
                                           DICS_FLAG_GLOBAL,
                                           0,
                                           DIREG_DRV,
                                           KEY_READ);

        if (hKeyDevice != INVALID_HANDLE_VALUE)
        {

            //
            // Is SubClass = STILLIMAGE?
            //

            if (!szTemp.Load (hKeyDevice, REGSTR_VAL_SUBCLASS) ||
                (_tcsicmp(szTemp, STILLIMAGE) != 0))
            {

                //
                // Skip this one.
                //

                RegCloseKey(hKeyDevice);
                continue;
            }

            //
            // Is FriendlyName same as pszLocalName?
            //


            if (!szTemp.Load (hKeyDevice, REGSTR_VAL_FRIENDLY_NAME))
            {
                if(_tcsicmp(szTemp, szFriendlyName) != 0)
                {

                    //
                    // Skip this one.
                    //

                    RegCloseKey(hKeyDevice);
                    continue;
                }
            }
            else
            {
                RegCloseKey(hKeyDevice);
                continue;
            }


            //
            // Found the target!
            //

            Found = TRUE;
            RegCloseKey(hKeyDevice);
            break;
        }

    }


    if(!Found)
    {

       //
       // FriendleName is not found. Something is corrupted.
       //
       SetupDiDestroyDeviceInfoList(hDevInfo);
       return INVALID_HANDLE_VALUE;
    }

    SetupDiSetSelectedDevice(hDevInfo,
                             &spDevInfoData);
    return hDevInfo;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\src\stream.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998 - 1999
 *
 *  TITLE:       stream.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        8/10/98
 *
 *  DESCRIPTION: CImageStream defintion
 *
 *****************************************************************************/

#ifndef __stream_h
#define __stream_h

class CImageStream : public IStream, IWiaDataCallback, CUnknown
{
    private:
        HANDLE                  m_hThread;
        ULONG                   m_ulReadPos;
        ULONG                   m_ulWritePos;
        LONG                    m_bFirstTransfer;
        ULONG                   m_ulSize;
        BOOL                    m_bProgress;

        ~CImageStream( );

        HRESULT InitItem ();
        HRESULT _InitWorker();
    public:
        LONG                    m_bTransferred;
        LPITEMIDLIST            m_pidl;
        LPITEMIDLIST            m_pidlFull;
        LPVOID                  m_pBuffer;
        GUID                    m_guidFormat;

        CComPtr<IWiaProgressDialog> m_pWiaProgressDialog;
        HRESULT                 m_hResultDownload; // status of current download
        HANDLE                  m_hEventStart; // handle to set when download starts
        DWORD                   m_dwCookie;
        CComPtr<IGlobalInterfaceTable> m_pgit;


    public:
        CImageStream( LPITEMIDLIST pidlFull,
                      LPITEMIDLIST pidl,
                      BOOL bShowProgress = FALSE);


        // IUnknown
        STDMETHOD(QueryInterface)(REFIID riid, LPVOID* ppvObject);
        STDMETHOD_(ULONG, AddRef)();
        STDMETHOD_(ULONG, Release)();

        // IStream
        STDMETHOD(Seek)(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
        STDMETHOD(SetSize)(ULARGE_INTEGER libNewSize);
        STDMETHOD(CopyTo)(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
        STDMETHOD(Commit)(DWORD grfCommitFlags);
        STDMETHOD(Revert)(void);
        STDMETHOD(LockRegion)(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
        STDMETHOD(UnlockRegion)(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
        STDMETHOD(Stat)(STATSTG *pstatstg, DWORD grfStatFlag);
        STDMETHOD(Clone)(IStream **ppstm);

        // ISequentialStream
        STDMETHOD(Read)(void *pv, ULONG cb, ULONG *pcbRead);
        STDMETHOD(Write)(const void *pv, ULONG cb, ULONG *pcbWritten);

        // IWiaDataCallback
        STDMETHOD(BandedDataCallback) (LONG lMessage,
                                       LONG lStatus,
                                       LONG lPercentComplete,
                                       LONG lOffset,
                                       LONG lLength,
                                       LONG lReserved,
                                       LONG lResLength,
                                       BYTE *pbData);
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\src\util.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998-2001
 *
 *  TITLE:       util.cpp
 *
 *  VERSION:     1.1
 *
 *  AUTHOR:      RickTu,DavidShi
 *
 *  DATE:        11/1/97
 *
 *  DESCRIPTION: utility functions needed for this dll
 *
 *****************************************************************************/

#include "precomp.hxx"
#pragma hdrstop
#include "runwiz.h"

DWORD g_tls;
HRESULT
GetDeviceFromEnum (IWiaDevMgr *pDevMgr, BSTR strDeviceId, PVOID *ppStg)
{
    HRESULT hr;

    CComPtr<IEnumWIA_DEV_INFO> pEnum;
    CComPtr<IWiaPropertyStorage> pStg;
    TraceEnter (TRACE_UTIL,"GetDeviceFromEnum");
    {

        ULONG ul;
        bool bFound = false;
        CSimpleStringWide strId;
        hr = pDevMgr->EnumDeviceInfo (0, &pEnum);

        while (SUCCEEDED(hr) && !bFound && S_OK == pEnum->Next (1, &pStg, &ul))
        {
            PropStorageHelpers::GetProperty(pStg, WIA_DIP_DEV_ID, strId);
            if (!wcscmp(strId, strDeviceId))
            {
                bFound = true;
                hr = pStg->QueryInterface(IID_IWiaPropertyStorage, ppStg);
            }
        }
        if (!bFound)
        {
            Trace(TEXT("Device %ls not found in enumeration!"), strDeviceId);
            hr = E_FAIL;
        }
    }
    TraceLeaveResult (hr);
}

/*****************************************************************************

    InvalidateDeviceCache

    Delete the current thread's device cache.

*****************************************************************************/

VOID
InvalidateDeviceCache ()
{
    TraceEnter (TRACE_UTIL, "InvalidateDeviceCache");
    TLSDATA *pData = reinterpret_cast<TLSDATA*>(TlsGetValue (g_tls));
    if (pData)
    {
        delete pData;
    }
    TlsSetValue (g_tls, NULL);
    TraceLeave ();
}
/*****************************************************************************

   GetDeviceFromDeviceId

   Given a device id, return the appropriate interface for that device. We cache
   interface pointers for a given device id in a structure on the current
   thread's TLS index.

 *****************************************************************************/
enum CreateDelayParams
{
    MaxRetries = 10,
    MinSleepTime = 100,
    SleepIncrement = 500
};

HRESULT
GetDeviceFromDeviceId( LPCWSTR pWiaItemRootId,
                       REFIID riid,
                       LPVOID * ppWiaItemRoot,
                       BOOL bShowProgress
                      )
{
    HRESULT             hr = E_FAIL;
    CComPtr<IWiaDevMgr> pDevMgr;
    TraceEnter( TRACE_UTIL, "GetDeviceFromDeviceId" );

    *ppWiaItemRoot = NULL;

    if (IsEqualGUID(riid, IID_IWiaPropertyStorage))
    {
        if (SUCCEEDED(CoCreateInstance (CLSID_WiaDevMgr,
                                   NULL,
                                   CLSCTX_LOCAL_SERVER,
                                   IID_IWiaDevMgr,
                                   reinterpret_cast<LPVOID*>(&pDevMgr))))
        {
            hr = GetDeviceFromEnum (pDevMgr,
                                    CComBSTR(pWiaItemRootId),
                                    ppWiaItemRoot);
        }
    }
    else
    {
        TLSDATA *pData = reinterpret_cast<TLSDATA*>(TlsGetValue (g_tls));
        TLSDATA *pCur = pData;

        while (pCur && !*ppWiaItemRoot)
        {
            if (!wcscmp(pWiaItemRootId, pCur->strDeviceId))
            {
                Trace(TEXT("Found device in cache"));
                hr = pCur->pDevice->QueryInterface (riid, ppWiaItemRoot);
                // if this fails, set the node's device id to a bogus id
                // and fall back to createdevice
                if (FAILED(hr))
                {
                    Trace(TEXT("QI on the root item failed: %x"), hr);
                    pCur->strDeviceId = CComBSTR(L"bogusdeviceid");
                    pCur->pDevice = NULL;
                    *ppWiaItemRoot = NULL;
                    pCur = NULL;
                }
            }
            else
            {
                pCur = pCur->pNext;
            }
        }
        if (!*ppWiaItemRoot)
        {
            CComPtr<IWiaItem> pDevice;
            if (SUCCEEDED(CoCreateInstance (CLSID_WiaDevMgr,
                                   NULL,
                                   CLSCTX_LOCAL_SERVER,
                                   IID_IWiaDevMgr,
                                   reinterpret_cast<LPVOID*>(&pDevMgr))))
            {
                INT c=MaxRetries;
                CComPtr<IWiaProgressDialog> pProgress;
                BOOL bCancelled =FALSE;
                if (bShowProgress && SUCCEEDED(CoCreateInstance(CLSID_WiaDefaultUi,
                                               NULL,
                                               CLSCTX_INPROC_SERVER,
                                               IID_IWiaProgressDialog,
                                               reinterpret_cast<void**>(&pProgress))))
                {
                    if (!SUCCEEDED(pProgress->Create(NULL, WIA_PROGRESSDLG_ANIM_DEFAULT_COMMUNICATE | WIA_PROGRESSDLG_NO_PROGRESS)))
                    {
                        pProgress->Destroy();
                        pProgress = NULL;
                        bShowProgress = FALSE;
                    }
                    else
                    {
                        pProgress->SetTitle(CSimpleStringConvert::WideString(CSimpleString(IDS_COMMUNICATING_CAPTION, GLOBAL_HINSTANCE)));
                        pProgress->SetMessage(CSimpleStringConvert::WideString(CSimpleString(IDS_COMMUNICATING_WAITING, GLOBAL_HINSTANCE)));
                        pProgress->Show();
                    }
                }
                else
                {
                    bShowProgress = FALSE;
                }
                // Try to call CreateDevice up to 10 times if it is returning
                // WIA_ERROR_BUSY
                // if caller wants progress UI, show the progress dialog
                // and don't terminate unless the user presses cancel or
                // the create returns something besides WIA_ERROR_BUSY
                do
                {
                    Trace(TEXT("Calling CreateDevice"));
                    DWORD dwSleep = MinSleepTime;
                    hr = pDevMgr->CreateDevice (CComBSTR(pWiaItemRootId),
                                                &pDevice);
                    if (hr == WIA_ERROR_BUSY)
                    {
                        Sleep(dwSleep);
                        if (bShowProgress)
                        {
                            pProgress->SetMessage(CSimpleStringConvert::WideString(CSimpleString(IDS_COMMUNICATING_BUSY, GLOBAL_HINSTANCE)));
                            pProgress->Cancelled(&bCancelled);
                        }
                        else
                        {
                            c--;
                        }
                        dwSleep += SleepIncrement;
                    }
                } while (c && hr == WIA_ERROR_BUSY && !bCancelled);
                if (bShowProgress)
                {
                    pProgress->Cancelled(&bCancelled);
                    pProgress->Destroy();
                    if (bCancelled)
                    {
                        hr = E_ABORT;
                    }
                }
            }
            if (SUCCEEDED(hr))
            {
                // Add the new device pointer to the tls list
                // if the alloc fails, we just don't cache the interface
                TLSDATA *pNew = new TLSDATA;
                if (pNew)
                {
                    pNew->pDevice = pDevice;
                    pNew->pNext = pData;
                    pNew->strDeviceId = CComBSTR(pWiaItemRootId);
                    if (!TlsSetValue (g_tls, pNew))
                    {
                        Trace(TEXT("TlsSetValue failed."));
                        delete pNew ;
                    }
                }
            }
            if (SUCCEEDED(hr) && pDevice.p)
            {
                hr = pDevice->QueryInterface (riid, ppWiaItemRoot);
            }
        }
    }
    TraceLeaveResult(hr);
}




/*****************************************************************************

   GetDeviceIdFromDevice

   Read the DeviceId property.  Assumes the szDeviceId param is big enough.

 *****************************************************************************/

HRESULT
GetDeviceIdFromDevice (IWiaItem *pWiaItemRoot, LPWSTR szDeviceId)
{
    HRESULT hr = E_FAIL;

    TraceEnter (TRACE_UTIL, "GetDeviceIdFromDevice");

    *szDeviceId = L'\0';
    CSimpleStringWide strDeviceId;
    if (PropStorageHelpers::GetProperty (pWiaItemRoot, WIA_DIP_DEV_ID, strDeviceId))
    {
        wcscpy (szDeviceId, strDeviceId);
        hr = S_OK;
    }
    TraceLeaveResult (hr);
}



/*****************************************************************************

   GetDeviceIdFromItem

   Read the DeviceId property. Assumes the szDeviceId param is big enough

 *****************************************************************************/

HRESULT
GetDeviceIdFromItem (IWiaItem *pItem, LPWSTR szDeviceId)
{
    HRESULT             hr = E_FAIL;
    CComPtr<IWiaItem>   pWiaItemRoot;

    TraceEnter (TRACE_UTIL, "GetDeviceIdFromItem");

    *szDeviceId = TEXT('\0');

    if (pItem)
    {
        hr = pItem->GetRootItem (&pWiaItemRoot);
        if (pWiaItemRoot)
        {
            hr = GetDeviceIdFromDevice (pWiaItemRoot, szDeviceId);
        }
    }

    TraceLeaveResult (hr);
}


/*****************************************************************************

   GetClsidFromDevice

   Returns the CLSID of the device's UI extensions

 *****************************************************************************/

HRESULT
GetClsidFromDevice (IUnknown *punk,
                    LPTSTR szClsid)
{
    HRESULT hr = E_FAIL;
    CComQIPtr<IWiaPropertyStorage, &IID_IWiaPropertyStorage> pps(punk);
    TraceEnter (TRACE_UTIL, "GetClsidFromDevice");

    *szClsid = TEXT('\0');
    if (pps)
    {
        PROPSPEC psp;
        PROPVARIANT pv;

        psp.ulKind = PRSPEC_PROPID;
        psp.propid = WIA_DIP_UI_CLSID;
        if (S_OK == (hr = pps->ReadMultiple (1, &psp, &pv)))
        {
            Trace(TEXT("bstrVal for clsid is %ls"), pv.bstrVal);
            #ifdef UNICODE
            lstrcpy (szClsid, pv.bstrVal);
            #else
            // NOTE: MAX_PATH for szName is a guess, we're assuming it's big
            //       enough to handle whatever is in pv.bstrVal

            WideCharToMultiByte (CP_ACP, 0, pv.bstrVal, -1, szClsid, MAX_PATH, NULL, NULL);
            #endif
            FreePropVariantArray (1, &pv);
        }
    }
    Trace(TEXT("UI Clsid is %s"), szClsid);
    TraceLeaveResult (hr);
}


/*****************************************************************************

   GetDeviceTypeFromDevice

   Returns type of the device

 *****************************************************************************/

HRESULT
GetDeviceTypeFromDevice (IUnknown *pWiaItemRoot, WORD *pwType)
{
    HRESULT hr = E_FAIL;
    LONG lType = 0;
    TraceEnter (TRACE_UTIL, "GetDeviceTypeFromDevice");
    if (pwType)
    {
        *pwType = StiDeviceTypeDefault;
    }
    if (pwType && PropStorageHelpers::GetProperty(pWiaItemRoot, WIA_DIP_DEV_TYPE, lType))
    {
        *pwType = GET_STIDEVICE_TYPE(lType);
        hr = S_OK;
    }

    TraceLeaveResult (hr);
}



/*****************************************************************************

   GetDevMgrObject

   Gets the global devmgr object

 *****************************************************************************/

HRESULT
GetDevMgrObject( LPVOID * ppDevMgr )
{

    HRESULT hr = E_FAIL;
    TraceEnter (TRACE_UTIL, "GetDevMgrObject");
    hr = CoCreateInstance (CLSID_WiaDevMgr,
                      NULL,
                      CLSCTX_LOCAL_SERVER,
                      IID_IWiaDevMgr,
                      ppDevMgr);

    TraceLeaveResult( hr );
}





/*****************************************************************************

   SetTransferFormat

   Tell the device what kind of image data we want

 *****************************************************************************/

VOID
SetTransferFormat (IWiaItem *pItem, WIA_FORMAT_INFO &fmt)
{
    HRESULT hr = E_FAIL;

    TraceEnter( TRACE_UTIL, "SetTransferFormat" );

    CComQIPtr<IWiaPropertyStorage, &IID_IWiaPropertyStorage> pps(pItem);

    if (pps)
    {
        PROPVARIANT pv[2];

        PROPSPEC ps[2] = {
                          {PRSPEC_PROPID, WIA_IPA_FORMAT},
                          {PRSPEC_PROPID, WIA_IPA_TYMED}
                         };
        pv[0].vt = VT_CLSID;
        pv[1].vt = VT_I4;
        pv[0].puuid = &(fmt.guidFormatID);
        pv[1].lVal = fmt.lTymed;
        TraceGUID ("Transfer format guid:", fmt.guidFormatID);
        Trace (TEXT("Tymed: %d"), fmt.lTymed);
        hr = pps->WriteMultiple (2, ps, pv, 2);

        Trace(TEXT("WriteMultiple returned %x in SetTransferFormat"), hr);

    }

    TraceLeaveResultNoRet (hr);
}


/*****************************************************************************

   AddDeviceWasChosen

   RunnDll32 entrypoint for when the "add device" button is chosen.

 *****************************************************************************/
#ifdef UNICODE
static const WCHAR cszClassInst[] = L"sti_ci.dll";
#else
static const CHAR cszClassInst[] = "sti_ci32.dll";
#endif
static const CHAR cszAddProc[] = "WiaAddDevice";
static const CHAR cszRemoveProc[] = "WiaRemoveDevice";

typedef HANDLE (WINAPI *AddDevProc)();
typedef BOOL (WINAPI *RemoveDevProc)(STI_DEVICE_INFORMATION *);
void
AddDeviceWasChosen(HWND hwndStub, HINSTANCE hAppInstance, LPSTR pszCmdLine, int nCmdShow)
{

    HMODULE hClassInst = NULL;
    HRESULT hr = E_FAIL;
    AddDevProc fnAddDevice;
    TraceEnter( TRACE_UTIL, "AddDeviceWasChosen" );

    if (!UserCanModifyDevice())
    {
        UIErrors::ReportMessage(hwndStub, GLOBAL_HINSTANCE, NULL,
                                MAKEINTRESOURCE(IDS_PRIVILEGE_CAPTION),
                                MAKEINTRESOURCE(IDS_CANT_INSTALL), MB_OK);
    }
    else
    {
        hr = CoInitialize (NULL);
    }

    if (SUCCEEDED(hr))
    {
        // Get absolute path to executable...
        TCHAR szPath[ MAX_PATH ];
        UINT  uLen = lstrlen( cszClassInst ) + lstrlen( TEXT("\\system32\\") ) + 1;
        UINT  uRes;

        *szPath = 0;
        uRes = GetSystemWindowsDirectory( szPath, MAX_PATH - uLen );

        if (uRes && (uRes <= (MAX_PATH - uLen)))
        {
            lstrcat( szPath, TEXT("\\system32\\") );
            lstrcat( szPath, cszClassInst );
            hClassInst = LoadLibrary( szPath );
        }

        if (hClassInst)
        {
            fnAddDevice = reinterpret_cast<AddDevProc>(GetProcAddress(hClassInst, cszAddProc));
            if (fnAddDevice)
            {

                HANDLE hProcess;
                hProcess = fnAddDevice();
                if (hProcess)
                {
                    WiaUiUtil::MsgWaitForSingleObject (hProcess, INFINITE);
                    CloseHandle (hProcess);
                }
                // our folder will get a connect event when installation completes.
            }
            FreeLibrary (hClassInst);
        }

        MyCoUninitialize();
    }

    TraceLeave();
}

void AddDeviceWasChosenW(HWND hwndStub, HINSTANCE hAppInstance, LPWSTR pszCmdLine, int nCmdShow)
{
    TraceEnter( TRACE_UTIL, "AddDeviceWasChosenW" );


    // we don't use the commandline param for anything
    AddDeviceWasChosen (hwndStub, hAppInstance, NULL, 0);
    TraceLeave();
}

/*****************************************************************************

    RemoveDevice

    Uninstalls the device with the given device ID
*****************************************************************************/

LRESULT
RemoveDeviceThreadProc (BSTR strDeviceId)
{
    STI_DEVICE_INFORMATION *psdi;
    CComPtr<IStillImage> pSti;
    HRESULT hr ;

    HMODULE hClassInst;
    RemoveDevProc fnRemoveDevice;

    TraceEnter (TRACE_UTIL, "RemoveDeviceThreadProc");
    hr = StiCreateInstance (GLOBAL_HINSTANCE, STI_VERSION, &pSti, NULL);
    if (SUCCEEDED(hr) && pSti)
    {
        hr = pSti->GetDeviceInfo (const_cast<LPWSTR>(strDeviceId),
                                  reinterpret_cast<LPVOID*>(&psdi));
        if (SUCCEEDED(hr) && psdi)
        {
            hClassInst = LoadLibrary (cszClassInst);
            fnRemoveDevice = reinterpret_cast<RemoveDevProc>(GetProcAddress(hClassInst, cszRemoveProc));
            if (fnRemoveDevice)
            {
                if (!fnRemoveDevice (psdi))
                {
                    hr = S_FALSE;
                    UIErrors::ReportMessage(NULL,
                                            GLOBAL_HINSTANCE,
                                            NULL,
                                            MAKEINTRESOURCE(IDS_TITLEDELETE_ERROR),
                                            MAKEINTRESOURCE(IDS_DELETE_ERROR),
                                            MB_ICONINFORMATION);
                }
            }
            if (hClassInst)
            {
                FreeLibrary (hClassInst);
            }
            LocalFree (psdi);
        }
    }
    SysFreeString (strDeviceId);
    TraceLeaveValue (0);
}

HRESULT
RemoveDevice (LPCWSTR strDeviceId)
{
    HRESULT hr = E_FAIL;
    DWORD dwTid;
    TraceEnter (TRACE_UTIL, "RemoveDevice");
    HANDLE hThread = CreateThread (NULL, 0,
                                   reinterpret_cast<LPTHREAD_START_ROUTINE>(RemoveDeviceThreadProc),
                                   SysAllocString (strDeviceId), 0, &dwTid);
    if (hThread)
    {
        CloseHandle (hThread);
        hr = S_OK;
    }
    TraceLeaveResult (hr);
}
/*****************************************************************************

   TimeToStrings

   Assumes buffers at least MAX_PATH long

 *****************************************************************************/

BOOL
TimeToStrings ( SYSTEMTIME *pst,
                LPTSTR szTime,
                LPTSTR szDate)
{

    BOOL iRes = TRUE;
    TraceEnter (TRACE_UTIL, "TimeToStrings");
    // make sure we're one-based
    if (!pst->wMonth)
    {
        pst->wMonth = 1; // force January
    }
    if (szDate)
    {
        *szDate = TEXT('\0');
        iRes = GetDateFormat( LOCALE_USER_DEFAULT,
                              0,
                              pst,
                              NULL, //TEXT("ddd',' MMM dd yyyy"),
                              szDate,
                              MAX_PATH
                             );

        if (!iRes)
        {
            Trace (TEXT("GetDateFormat failed in CameraItemUpdateProc: %d"), GetLastError());
        }
    }

    if (iRes && szTime)
    {
        *szTime = TEXT('\0');

        //
        // Set the image/container time
        //


        iRes = GetTimeFormat( LOCALE_USER_DEFAULT,
                              0,
                              pst,
                              NULL,//TEXT("hh':'mm':'ss tt"),
                              szTime,
                              MAX_PATH
                             );
        if (!iRes)
        {
            Trace (TEXT("GetTimeFormat failed in CameraItemUpdateProc: %d"), GetLastError());
        }
    }
    TraceLeave ();
    return iRes;
}


#if (defined(DEBUG) && defined(SHOW_PATHS))
////////////////////////////////////////////////////////
//
// PrintPath
//
//   Debug code to print out a path, given a pidl.
//
////////////////////////////////////////////////////////
void PrintPath( LPITEMIDLIST pidl )
{
    TCHAR szPath[ MAX_PATH ];

    TraceEnter (TRACE_UTIL, "PrintPath");
    if (SHGetPathFromIDList( pidl, szPath ))
    {
        LPTSTR pFileName = PathFindFileName( szPath );

        Trace(TEXT("shell pidl points to '%s'"), pFileName );
    }
    else
    {
        Trace(TEXT("*** Couldn't get path from shell pidl! ***"));
    }
    TraceLeave ();
}

////////////////////////////////////////////////////////
//
// StrretToString
//
//   Converts a strret to a sz
//
////////////////////////////////////////////////////////
void StrretToString( LPSTRRET pStr, LPITEMIDLIST pidl, LPTSTR psz, UINT cch )
{
    switch( pStr->uType )
    {
        case STRRET_WSTR:
#ifdef UNICODE
            lstrcpy( psz, pStr->pOleStr );
#else
            lstrcpy( psz, TEXT("NO CONV OLESTR <--> ANSI") );
#endif
            break;

        case STRRET_OFFSET:
#ifdef UNICODE
            MultiByteToWideChar( CP_ACP, 0,
                                 (LPSTR)((LPBYTE)pidl + pStr->uOffset),
                                 -1, psz, cch
                                );
#else
            lstrcpy( psz, (LPTSTR)((LPBYTE)pidl + pStr->uOffset) );
#endif
            break;

        case STRRET_CSTR:
#ifdef UNICODE
            MultiByteToWideChar( CP_ACP, 0,
                                 pStr->cStr, -1,
                                 psz, cch
                                );
#else
            lstrcpy( psz, pStr->cStr );
#endif
    }

}
#endif


BOOL
IsPlatformNT()
{
    OSVERSIONINFO  ver;
    BOOL            bReturn = FALSE;

    ZeroMemory(&ver,sizeof(ver));
    ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if(!GetVersionEx(&ver)) {
        bReturn = FALSE;
    }
    else {
        switch(ver.dwPlatformId) {

            case VER_PLATFORM_WIN32_WINDOWS:
                bReturn = FALSE;
                break;

            case VER_PLATFORM_WIN32_NT:
                bReturn = TRUE;
                break;

            default:
                bReturn = FALSE;
                break;
        }
    }

    return bReturn;

}  //  endproc

/******************************************************************************

GetRealSizeFromItem

Query the item for its size based on the current format and tymed settings

******************************************************************************/


ULONG
GetRealSizeFromItem (IWiaItem *pItem)
{
    ULONG uRet = 0;
    CComQIPtr <IWiaPropertyStorage, &IID_IWiaPropertyStorage> pps;
    TraceEnter (TRACE_UTIL, "GetRealSizeFromItem");
    pps = pItem;
    if (pps)
    {
        PROPVARIANT pv;
        PROPSPEC ps;
        ps.ulKind = PRSPEC_PROPID;
        ps.propid = WIA_IPA_ITEM_SIZE;
        if (S_OK == pps->ReadMultiple(1, &ps, &pv))
        {
            uRet = pv.ulVal;
            PropVariantClear (&pv);
        }
    }
    TraceLeave();
    return uRet;
}


HRESULT
SaveSoundToFile (IWiaItem *pItem, CSimpleString szFile)
{
    HRESULT hr = E_FAIL;
    HANDLE hFile;
    CComQIPtr<IWiaPropertyStorage, &IID_IWiaPropertyStorage> pps(pItem);
    PROPVARIANT pv;
    PROPSPEC ps;
    TraceEnter (TRACE_UTIL, "SaveSoundToFile");
    ps.ulKind = PRSPEC_PROPID;
    ps.propid = WIA_IPC_AUDIO_DATA;
    if (pps)
    {
        hr = pps->ReadMultiple (1, &ps, &pv);
        if (S_OK == hr)
        {
            TraceAssert (pv.caub.cElems);
            hFile = CreateFile (szFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
            if (INVALID_HANDLE_VALUE != hFile)
            {
                DWORD dwWritten;
                if (!WriteFile (hFile, pv.caub.pElems, pv.caub.cElems, &dwWritten, NULL))
                {
                    DWORD dw = GetLastError ();
                    hr = HRESULT_FROM_WIN32(dw);
                }
                else if (dwWritten < pv.caub.cElems)
                {
                    hr = HRESULT_FROM_WIN32(ERROR_DISK_FULL);
                }
                else
                {
                    hr = S_OK;
                }
                CloseHandle (hFile);
                if (FAILED(hr))
                {
                    DeleteFile (szFile);
                }
            }
            else
            {
                DWORD dw = GetLastError ();
                hr = HRESULT_FROM_WIN32(dw);
            }
        }
        else
        {
            hr = E_FAIL; //S_FALSE is the same as a failure for us
        }
    }
    PropVariantClear (&pv);
    TraceLeaveResult (hr);
}

STDAPI_(HRESULT)
TakeAPicture (BSTR strDeviceId)
{
    HRESULT hr;
    TraceEnter (TRACE_UTIL, "TakeAPicture");
    CComPtr<IWiaItem> pDevice;
    CComPtr<IWiaItem> pItem;
    hr = GetDeviceFromDeviceId (strDeviceId,
                                IID_IWiaItem,
                                reinterpret_cast<LPVOID*>(&pDevice),
                                TRUE);
    if (SUCCEEDED(hr))
    {
        CSimpleStringWide strName;
        hr = pDevice->DeviceCommand (0,
                                     &WIA_CMD_TAKE_PICTURE,
                                     &pItem);
        if (SUCCEEDED(hr))
        {
            IssueChangeNotifyForDevice (strDeviceId, SHCNE_UPDATEDIR, NULL);
        }
    }
    TraceLeaveResult (hr);
}

/******************************************************************************

    IssueChangeNotifyForDevice

    Given a device id, find this device in the My Computer folder and
    get its full PIDL. Issue a SHChangeNotify as requested.
******************************************************************************/

VOID
IssueChangeNotifyForDevice (LPCWSTR szDeviceId, LONG lEvent, LPITEMIDLIST pidl)
{
    TraceEnter (TRACE_UTIL, "IssueChangeNotifyForDevice");
    LPITEMIDLIST pidlFolder = NULL;
    LPITEMIDLIST pidlCpl    = NULL;
    LPITEMIDLIST pidlUpdate = NULL;
    if (!szDeviceId)
    {
        SHGetSpecialFolderLocation (NULL, CSIDL_DRIVES, &pidlFolder);
        SHGetSpecialFolderLocation (NULL, CSIDL_CONTROLS, &pidlCpl);
    }
    else
    {
        CComPtr<IShellFolder> psfDevice;
        BindToDevice (szDeviceId, IID_IShellFolder,
                      reinterpret_cast<LPVOID*>(&psfDevice),
                      &pidlFolder);
    }
    if (pidlFolder)
    {
        if (pidl)
        {
            pidlUpdate = ILCombine (pidlFolder, pidl);
        }
        else
        {
            pidlUpdate = ILClone(pidlFolder);
        }
        if (pidlUpdate)
        {
            SHChangeNotify (lEvent,
                            SHCNF_IDLIST,
                            pidlUpdate, 0);
            ILFree (pidlUpdate);
        }
        if (pidlCpl)
        {
            SHChangeNotify (lEvent,
                            SHCNF_IDLIST,
                            pidlCpl, 0);
            ILFree (pidlCpl);
        }
        ILFree (pidlFolder);
    }
    TraceLeave ();
}

bool IsDeviceInFolder (const CSimpleStringWide &strDeviceId, IShellFolder *psf, LPITEMIDLIST *ppidl)
{
    bool bRet = false;
    CComPtr<IEnumIDList> pEnum;

    TraceEnter (TRACE_UTIL, "IsDeviceInFolder");
    if (SUCCEEDED(psf->EnumObjects (NULL, SHCONTF_FOLDERS | SHCONTF_NONFOLDERS, &pEnum)))
    {
        LPITEMIDLIST pidlItem;
        ULONG ul;
        while (!bRet && S_OK == pEnum->Next(1,&pidlItem, &ul))
        {
            if (IsDeviceIDL(pidlItem) || IsSTIDeviceIDL(pidlItem))
            {
                CSimpleStringWide strId;
                IMGetDeviceIdFromIDL (pidlItem, strId);
                if (!_wcsicmp(strId,strDeviceId))
                {
                    bRet = true;
                    if (ppidl)
                    {
                        *ppidl = ILClone(pidlItem);
                    }
                }
            }
            DoILFree (pidlItem);
        }
    }

    TraceLeaveValue (bRet);
}
/******************************************************************************

    GetDeviceParentFolder

    Find the folder that is the parent of the given device. First we try
    My Computer directly, then we try My Computer/Scanners and Cameras. Also fills in the full pidl
    for the device

******************************************************************************/

HRESULT GetDeviceParentFolder (const CSimpleStringWide &strDeviceId,
                               CComPtr<IShellFolder> &psf,
                               LPITEMIDLIST *ppidlFull)
{
    HRESULT hr = E_FAIL;
    TraceEnter (TRACE_UTIL, "GetDeviceParentFolder");
    CComPtr<IShellFolder> psfDrives;
    CComPtr<IShellFolder> psfDesktop;
    CComPtr<IEnumIDList> pEnum;
    LPITEMIDLIST pidl1 = NULL;
    LPITEMIDLIST pidlItem = NULL;

    Trace (TEXT("Looking in my computer for %ls"), strDeviceId.String());

    if (ppidlFull)
    {
        *ppidlFull = NULL;
    }

    hr = SHGetDesktopFolder (&psfDesktop);
    if (FAILED(hr))
    {
        TraceLeaveResult(hr);
    }

    // First, try to find the device in My Computer.
    if (SUCCEEDED(SHGetSpecialFolderLocation (NULL, CSIDL_DRIVES,  &pidl1)))
    {

        hr = psfDesktop->BindToObject (pidl1,
                                       NULL,
                                       IID_IShellFolder,
                                       reinterpret_cast<LPVOID*>(&psfDrives));
        if (SUCCEEDED(hr) && IsDeviceInFolder (strDeviceId, psfDrives, &pidlItem))
        {
            if (ppidlFull)
            {
                *ppidlFull = ILCombine (pidl1, pidlItem);
            }
            psf = psfDrives;
            hr = S_OK;
        }
        else
        {
            hr = E_FAIL;
        }

    }
    if (FAILED(hr))
    {
        Trace(TEXT("Looking in control panel\\scanners and cameras"));
        LPITEMIDLIST pidlFolder;
        // If no luck in my computer, try the scanners and cameras folder in control panel
        // Note that on winnt we have to use ::{} around our guid, and on millennium we use ;;{}
        // this is so ParseDisplayName does the right thing
        #ifdef NODELEGATE
        static  WCHAR szFolderPath[MAX_PATH] = L"::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\::{E211B736-43FD-11D1-9EFB-0000F8757FCD}";
        #else
        static  WCHAR szFolderPath[MAX_PATH] = L"::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\::{21EC2020-3AEA-1069-A2DD-08002B30309D}\\;;{E211B736-43FD-11D1-9EFB-0000F8757FCD}";
        #endif
        if (SUCCEEDED(psfDesktop->ParseDisplayName(NULL, NULL,
                                                   szFolderPath,
                                                   NULL,
                                                   &pidlFolder,
                                                   NULL)))
        {
            if (SUCCEEDED(psfDesktop->BindToObject (pidlFolder,
                                                    NULL,
                                                    IID_IShellFolder,
                                                    reinterpret_cast<LPVOID*>(&psfDrives))))
            {
                if (IsDeviceInFolder (strDeviceId, psfDrives, &pidlItem))
                {
                    psf = psfDrives;
                    if (ppidlFull)
                    {
                        *ppidlFull = ILCombine (pidlFolder, pidlItem);
                    }
                    hr = S_OK;
                }

            }
            else
            {
                Trace(TEXT("BindToObject returned %x"), hr);
            }
        }
        else
        {
            Trace(TEXT("ParseDisplayName returned %x"), hr);
        }
        DoILFree (pidlFolder);
    }

    DoILFree (pidl1);
    DoILFree (pidlItem);

    TraceLeaveResult (hr);
}

/******************************************************************************

    BindToDevice

    Returns an interface for the given WIA device, as well as its full PIDL

******************************************************************************/
HRESULT BindToDevice (const CSimpleStringWide &strDeviceId,
                      REFIID riid,
                      LPVOID *ppvObj,
                      LPITEMIDLIST *ppidlFull)
{
    HRESULT hr = E_FAIL;
    TraceEnter (TRACE_UTIL, "BindToDevice");

    CComPtr<IShellFolder> psfParent;
    LPITEMIDLIST pidlDevice;

    hr = GetDeviceParentFolder(strDeviceId, psfParent, &pidlDevice);
    if (SUCCEEDED(hr))
    {
        if (ppvObj)
        {
            hr = psfParent->BindToObject (ILFindLastID(pidlDevice),
                                          NULL,
                                          riid,
                                          ppvObj);
        }
        if (ppidlFull)
        {
            *ppidlFull = ILClone(pidlDevice);
        }
    }
    DoILFree (pidlDevice);
    TraceLeaveResult (hr);
}



HRESULT
GetFullPidlForItem (const CSimpleStringWide &strDeviceId,
                    const CSimpleStringWide &strPath,
                    LPITEMIDLIST *ppidl)
{
    HRESULT hr;
    CComPtr<IShellFolder> psfDevice;
    CComPtr<IShellFolder> psfParent;
    LPITEMIDLIST pidlDevice = NULL;
    STRRET strretDisplay;
    WCHAR szDisplayName[MAX_PATH];
    TraceEnter (TRACE_UTIL, "GetFullPidlForItem");
    *ppidl = NULL;
    // first, get the displayname of the device

    hr = GetDeviceParentFolder (strDeviceId,
                                psfParent, &pidlDevice);
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidl = ILFindLastID(pidlDevice);
        psfParent->GetDisplayNameOf (pidl,
                                     SHGDN_FORPARSING,
                                     &strretDisplay);

        StrRetToBufW (&strretDisplay, pidl, szDisplayName, MAX_PATH);
        hr = psfParent->BindToObject (const_cast<LPCITEMIDLIST>(pidl),
                                      NULL,
                                      IID_IShellFolder,
                                      reinterpret_cast<LPVOID*>(&psfDevice));
        if (SUCCEEDED(hr))
        {
            // Concat the full item name to the device displayname
            wcscat (szDisplayName, L"\\");
            wcscat (szDisplayName, strPath);
            wcscpy (szDisplayName ,strPath);
            hr = psfDevice->ParseDisplayName (NULL,
                                              NULL,
                                              szDisplayName,
                                              NULL,
                                              ppidl,
                                              NULL);
        }
    }
    DoILFree (pidlDevice);
    TraceLeaveResult (hr);
}

/******************************************************************************

    GetDataObjectForStiDevice

    Since we don't show STI devices in a delegated folder, we can init
    the CImageDataObject directly.

*******************************************************************************/

HRESULT
GetDataObjectForStiDevice (LPCWSTR szDeviceId, IDataObject **ppdo)
{
    HRESULT hr = E_OUTOFMEMORY;

    LPITEMIDLIST pidl;

    STIDeviceIDLFromId (szDeviceId, &pidl, NULL);
    CImageDataObject *pido = new CImageDataObject (NULL);
    TraceEnter (TRACE_UTIL, "GetDataObjectForStiDevice");
    *ppdo = NULL;
    if (pido)
    {
        hr = pido->Init(NULL, 1,
                   const_cast<LPCITEMIDLIST*>(&pidl),
                   NULL);
        if (SUCCEEDED(hr))
        {
            hr = pido->QueryInterface (IID_IDataObject,
                                       reinterpret_cast<LPVOID*>(ppdo));
        }
        pido->Release();
    }

    TraceLeaveResult(hr);
}


HRESULT GetDataObjectForItem (IWiaItem *pItem, IDataObject **ppdo)
{
    HRESULT hr;
    TraceEnter (TRACE_UTIL, "GetDataObjectForItem");
    CComPtr<IWiaItem> pDevice;
    CSimpleStringWide strDeviceId;
    *ppdo =NULL;
    LPITEMIDLIST pidlItem;
    LONG lType = 0;

    pItem->GetRootItem (&pDevice);
    PropStorageHelpers::GetProperty(pDevice, WIA_DIP_DEV_ID, strDeviceId);
    pItem->GetItemType (&lType);
    if (lType & WiaItemTypeRoot)
    {
        // it's a device
        pidlItem = IMCreateDeviceIDL (pItem, NULL);
    }
    else // it's a camera item
    {
        pidlItem = IMCreateCameraItemIDL (pItem, strDeviceId, NULL);
    }
    if (!pidlItem)
    {
        hr = E_FAIL;
    }
    else
    {
        CImageDataObject *pobj = new CImageDataObject (pItem);
        if (!pobj)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = pobj->Init (NULL,
                             1,
                             const_cast<LPCITEMIDLIST*>(&pidlItem),
                             NULL);
            if (SUCCEEDED(hr))
            {
                *ppdo = pobj;
                // add the proper clipboard format for extensions to use.
                ProgramDataObjectForExtension (pobj, pItem);
            }
        }
        ILFree(pidlItem);
    }

    TraceLeaveResult (hr);
}

HRESULT
MakeFullPidlForDevice (LPCWSTR pDeviceId, LPITEMIDLIST *ppidl)
{
    CComPtr<IShellFolder> psf;
    HRESULT hr;
    TraceEnter (TRACE_UTIL, "MakeFullPidlForDevice");
    hr = GetDeviceParentFolder (pDeviceId, psf, ppidl);
    TraceLeaveResult (hr);
}
/******************************************************************************

    TryEnumDeviceInfo

    Attempt to enumerate installed devices.
******************************************************************************/

HRESULT
TryEnumDeviceInfo (DWORD dwFlags, IEnumWIA_DEV_INFO **ppEnum)
{
    HRESULT hr = E_FAIL;
    CComPtr<IWiaDevMgr> pDevMgr;
    TraceEnter (TRACE_UTIL, "TryEnumDeviceInfo");

    {
        hr = GetDevMgrObject (reinterpret_cast<LPVOID*>(&pDevMgr));
        if (SUCCEEDED(hr))
        {
            hr = pDevMgr->EnumDeviceInfo (dwFlags, ppEnum);
        }
    }
    TraceLeaveResult (hr);
}

/*****************************************************************************

   GetSTIInfoFromId

   Copy the STI_DEVICE_INFORMATION struct from STI

 *****************************************************************************/

HRESULT
GetSTIInfoFromId (LPCWSTR szDeviceId, PSTI_DEVICE_INFORMATION *ppsdi)
{
    HRESULT hr = E_INVALIDARG;
    PSTI psti = NULL;

    TraceEnter (TRACE_IDLIST, "GetSTIInfoFromId");
    if (ppsdi)
    {

        hr = StiCreateInstance (GLOBAL_HINSTANCE,
                                STI_VERSION,
                                &psti,
                                NULL);
        if (SUCCEEDED(hr))
        {
            hr = psti->GetDeviceInfo (const_cast<LPWSTR>(szDeviceId), reinterpret_cast<LPVOID*>(ppsdi));
        }
        else
        {
            Trace(TEXT("StiCreateInstance failed %x in GetSTIInfoFromId"), hr);
        }
    }

    DoRelease (psti);
    TraceLeaveResult (hr);
}


#if (defined(DEBUG) && defined(SHOW_ATTRIBUTES))

////////////////////////////////////////////////////////
//
// PrintAttributes
//
//
//
////////////////////////////////////////////////////////
void PrintAttributes( DWORD dwAttr )
{

    TCHAR sz[ MAX_PATH ];
    TraceEnter (TRACE_UTIL, "PrintAttributes");
    lstrcpy( sz, TEXT("Attribs = ") );
    if (dwAttr & SFGAO_CANCOPY)
    {
        lstrcat( sz, TEXT("SFGAO_CANCOPY ") );
    }
    if (dwAttr & SFGAO_CANMOVE)
    {
        lstrcat( sz,TEXT("SFGAO_CANMOVE "));
    }
    if (dwAttr & SFGAO_CANLINK)
    {
        lstrcat( sz, TEXT("SFGAO_CANLINK "));
    }
    if (dwAttr & SFGAO_CANRENAME)
    {
        lstrcat( sz, TEXT("SFGAO_CANRENAME "));
    }
    if (dwAttr & SFGAO_CANDELETE)
    {
        lstrcat( sz, TEXT("SFGAO_CANDELETE "));
    }
    if (dwAttr & SFGAO_HASPROPSHEET)
    {
        lstrcat( sz, TEXT("SFGAO_HASPROPSHEET "));
    }
    if (dwAttr & SFGAO_DROPTARGET)
    {
        lstrcat( sz, TEXT("SFGAO_DROPTARGET "));
    }
    if (dwAttr & SFGAO_LINK)
    {
        lstrcat( sz, TEXT("SFGAO_LINK "));
    }
    if (dwAttr & SFGAO_SHARE)
    {
        lstrcat( sz, TEXT("SFGAO_SHARE "));
    }
    if (dwAttr & SFGAO_READONLY)
    {
        lstrcat( sz, TEXT("SFGAO_READONLY "));
    }
    if (dwAttr & SFGAO_GHOSTED)
    {
        lstrcat( sz, TEXT("SFGAO_GHOSTED "));
    }
    if (dwAttr & SFGAO_HIDDEN)
    {
        lstrcat( sz, TEXT("SFGAO_HIDDEN "));
    }
    if (dwAttr & SFGAO_FOLDER)
    {
        lstrcat (sz, TEXT("SFGAO_FOLDER"));
    }
    if (dwAttr & SFGAO_FILESYSANCESTOR)
    {
        lstrcat( sz, TEXT("SFGAO_FILESYSANCESTOR "));
    }
    if (dwAttr & SFGAO_FILESYSTEM)
    {
        lstrcat( sz, TEXT("SFGAO_FILESYSTEM "));
    }
    if (dwAttr & SFGAO_HASSUBFOLDER)
    {
        lstrcat( sz, TEXT("SFGAO_HASSUBFOLDER "));
    }
    if (dwAttr & SFGAO_VALIDATE)
    {
        lstrcat( sz, TEXT("SFGAO_VALIDATE "));
    }
    if (dwAttr & SFGAO_REMOVABLE)
    {
        lstrcat( sz, TEXT("SFGAO_REMOVABLE "));
    }
    if (dwAttr & SFGAO_COMPRESSED)
    {
        lstrcat( sz, TEXT("SFGAO_COMPRESSED "));
    }
    if (dwAttr & SFGAO_BROWSABLE)
    {
        lstrcat( sz, TEXT("SFGAO_BROWSABLE "));
    }
    if (dwAttr & SFGAO_NONENUMERATED)
    {
        lstrcat( sz, TEXT("SFGAO_NONENUMERATED "));
    }
    if (dwAttr & SFGAO_NEWCONTENT)
    {
        lstrcat( sz, TEXT("SFGAO_NEWCONTENT "));
    }
    if (dwAttr & SFGAO_CANMONIKER)
    {
        lstrcat( sz, TEXT("SFGAO_CANMONIKER "));
    }
    Trace( sz );
    TraceLeave ();
}
#endif


BOOL
UserCanModifyDevice ()
{
    // checks the current user's token for SE_LOAD_DRIVER_PRIVILEGE
    BOOL bRet = FALSE;
    HANDLE Token;
    // use a static PRIVILEGE_SET because we only look for one LUID
    PRIVILEGE_SET pset;
    pset.Control = PRIVILEGE_SET_ALL_NECESSARY;
    pset.PrivilegeCount = 1;
    if (OpenProcessToken(GetCurrentProcess(),TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,&Token))
    {
        TOKEN_PRIVILEGES tp;
        tp.PrivilegeCount = 1;
        LookupPrivilegeValue(NULL, SE_LOAD_DRIVER_NAME, &pset.Privilege[0].Luid);
        tp.Privileges[0].Luid = pset.Privilege[0].Luid;
        tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
        AdjustTokenPrivileges(Token, false, &tp, 0, NULL, NULL);
        PrivilegeCheck(Token, &pset, &bRet);

        CloseHandle(Token);
    }

    return bRet;
}

BOOL
CanShowAddDevice()
{
#if 0
    OSVERSIONINFOEX osvi = {0};
    ULONGLONG dwlConditionMask =0;
    //
    //  On Whistler Personal, hide the icon if the
    // current user lacks installation privileges. On other SKUs the user is more likely
    // to know about shift-rclick for "Run As..."
    //
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    osvi.wSuiteMask = VER_SUITE_PERSONAL;
    VER_SET_CONDITION( dwlConditionMask, VER_SUITENAME, VER_OR );
    return UserCanModifyDevice() || !VerifyVersionInfo( &osvi,VER_SUITENAME,dwlConditionMask);
#else
    return TRUE;
#endif
}

void VerifyCachedDevice(IWiaItem *pRoot)
{
    WCHAR szDeviceId[STI_MAX_INTERNAL_NAME_LENGTH];
    TLSDATA *pData = reinterpret_cast<TLSDATA*>(TlsGetValue (g_tls));
    TLSDATA *pCur = pData;
    GetDeviceIdFromDevice(pRoot, szDeviceId);
    while (pCur && wcscmp(szDeviceId, pCur->strDeviceId))
    {
        pCur = pCur->pNext;
    }
    if (!pCur)
    {
        pCur = new TLSDATA;
        if (pCur)
        {
            pCur->pDevice = pRoot;
            pCur->pNext = pData;
            pCur->strDeviceId = CComBSTR(szDeviceId);
            if (!TlsSetValue (g_tls, pCur))
            {
                delete pCur ;
            }
        }
    }
    else
    {
        //
        // replace the current root item with the new one, as the old one may be disconnected
        // and we don't have an event handler to catch it.
        //
        pCur->pDevice = pRoot;
    }
}

void MyCoUninitialize()
{
    // Make sure we release open IWiaItem interfaces before COM unloads
    InvalidateDeviceCache();
    CoUninitialize();
}

DWORD WINAPI _RunWizardThread(void *pszDeviceId)
{
    InterlockedIncrement (&GLOBAL_REFCOUNT);
    if (SUCCEEDED(CoInitialize(NULL)))
    {
        RunWiaWizard::RunWizard(reinterpret_cast<LPCWSTR>(pszDeviceId));
        CoUninitialize();
    }   
    delete [] reinterpret_cast<WCHAR *>(pszDeviceId);
    InterlockedDecrement(&GLOBAL_REFCOUNT);
    return 0;
}

void RunWizardAsync(LPCWSTR pszDeviceId)
{
    // make a heap copy of the string for consumption by the thread
    WCHAR *pString = new WCHAR[wcslen(pszDeviceId)+1];
    if (pString)
    {
        wcscpy(pString, pszDeviceId);
        DWORD dw;
        HANDLE hThread = CreateThread(NULL, 0, 
                                      _RunWizardThread,
                                      reinterpret_cast<void*>(pString),
                                      0, &dw);
        if (hThread)
        {
            CloseHandle(hThread);
        }
        else
        {
            delete [] pString;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\src\verbs.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998 - 2000
 *
 *  TITLE:       verbs.h
 *
 *  VERSION:     1.1
 *
 *  AUTHOR:      RickTu/DavidShi
 *
 *  DATE:        5/27/98
 *
 *  DESCRIPTION: Definitions used by verb code
 *
 *****************************************************************************/

#ifndef __verbs_h
#define __verbs_h


HRESULT DoAcquireScanVerb (HWND hwndOwner, LPDATAOBJECT pDataObject);
HRESULT DoSaveSndVerb (HWND hwndOwner, LPDATAOBJECT pDataObject);
HRESULT DoPlaySndVerb (HWND hwndOwner, LPDATAOBJECT pDataObject);
HRESULT DoPreviewVerb(   HWND hwndOwner, LPDATAOBJECT pDataObject );
HRESULT DoSaveInMyPics(  HWND hwndOwner, LPDATAOBJECT pDataObject );
HRESULT DoDeleteItem( HWND hwndOwner, LPDATAOBJECT pDataObject, BOOL bNoUI );
HRESULT DoGotoMyPics(    HWND hwndOwner, LPDATAOBJECT pDataObject );
HRESULT DoWizardVerb (HWND hwndOwner, LPDATAOBJECT pDataObject );
HRESULT DoPrintVerb (HWND hwndOwner, LPDATAOBJECT pDataObject );
HRESULT DoTakePictureVerb (HWND hwndOwner, LPDATAOBJECT pDataObject);
HRESULT GetIDAFromDataObject( LPDATAOBJECT pDataObject, LPIDA * ppida, bool bShellFmt = false);
const WCHAR cszImageCLSID[] =  L"{E211B736-43FD-11D1-9EFB-0000F8757FCD}";
const TCHAR g_cszTempFilePrefix[] =  TEXT("_CA");
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\src\version.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       version.h
//
//--------------------------------------------------------------------------

// Resources for the common version chunk

#ifndef APSTUDIO_INVOKED
/////////////////////////////////////////////////////////////////////////////
//
// Generated from the TEXTINCLUDE 3 resource.
//
#define VER_FILETYPE                    VFT_DLL
#define VER_FILESUBTYPE                 VFT_UNKNOWN
#define VER_FILEDESCRIPTION_STR         "Imaging Devices Shell Folder UI"
#define VER_INTERNALNAME_STR            "wiashext"
#define VER_ORIGINALFILENAME_STR        "wiashext.dll"

#include <ntverp.h>
#include <common.ver>

/////////////////////////////////////////////////////////////////////////////
#endif    // not APSTUDIO_INVOKED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\src\util.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1997 - 2001
 *
 *  TITLE:       util.h
 *
 *  VERSION:     1.1
 *
 *  AUTHOR:      RickTu/DavidShi
 *
 *  DATE:        11/7/97
 *
 *  DESCRIPTION: utility function defintions, etc.
 *
 *****************************************************************************/



#ifndef __util_h
#define __util_h

#define DC_INITIALIZE       (WM_USER+1)
#define DC_DESTROY          (WM_USER+2)
#define DC_GETDEVICE        (WM_USER+3)  // wParam = lpcr, lParam = Handle of event to signal
#define DC_GETDEVMGR        (WM_USER+4)  // wParam = Ptr to DWORD = g_dwDevMgrCookie on return, NULL if error, lParam = Handle of event to signal
#define DC_REFRESH          (WM_USER+5) // lparam = ptr to device id to recreate


void RecreateDevice (LPCWSTR szDeviceId);

BOOL RegDelnode (HKEY hKeyRoot, LPTSTR lpSubKey);

HRESULT GetDeviceIdFromDevice (IWiaItem *pWiaItemRoot, LPWSTR szDeviceId);
HRESULT GetDeviceIdFromItem (IWiaItem *pItem, LPWSTR szDeviceId);
HRESULT GetClsidFromDevice (IUnknown *pWiaItemRoot, LPTSTR szClsid);
HRESULT GetDeviceTypeFromDevice (IUnknown *pWiaItemRoot, WORD *pwType);
HRESULT GetDevMgrObject( LPVOID * ppDevMgr );
HRESULT TryEnumDeviceInfo (DWORD dwFlags, IEnumWIA_DEV_INFO **ppEnum);
ULONG   GetRealSizeFromItem (IWiaItem *pItem);
VOID    SetTransferFormat (IWiaItem *pItem, WIA_FORMAT_INFO &fmt);
BOOL    TimeToStrings (SYSTEMTIME *pst, LPTSTR szTime, LPTSTR szDate);
BOOL    IsPlatformNT();
HRESULT RemoveDevice (LPCWSTR strDeviceId);
VOID    IssueChangeNotifyForDevice (LPCWSTR szDeviceId, LONG lEvent, LPITEMIDLIST pidl);
HRESULT BindToDevice (const CSimpleStringWide &strDeviceId, REFIID riid, LPVOID *ppvObj, LPITEMIDLIST *ppidl=NULL);
HRESULT GetFullPidlForItem (const CSimpleStringWide &strDeviceId, const CSimpleStringWide &strPath, LPITEMIDLIST *ppidl);
HRESULT GetDataObjectForItem (IWiaItem *pItem, IDataObject **ppdo);
HRESULT GetDataObjectForStiDevice (LPITEMIDLIST pidl, IDataObject **ppdo);
HRESULT MakeFullPidlForDevice (LPCWSTR pDeviceId, LPITEMIDLIST *ppidl);
HRESULT GetSTIInfoFromId (LPCWSTR szDeviceId, PSTI_DEVICE_INFORMATION *ppsdi);
HRESULT SaveSoundToFile (IWiaItem *pItem, CSimpleString szFile);
VOID    InvalidateDeviceCache ();
VOID    VerifyCachedDevice(IWiaItem *pRoot);

HRESULT GetDeviceParentFolder (const CSimpleStringWide &strDeviceId, CComPtr<IShellFolder> &psf,LPITEMIDLIST *ppidlFull);

#if (defined(DEBUG) && defined(SHOW_PATHS))
void PrintPath( LPITEMIDLIST pidl );
void StrretToString( LPSTRRET pStr, LPITEMIDLIST pidl, LPTSTR psz, UINT cch );
#endif

#if (defined(DEBUG) && defined(SHOW_ATTRIBUTES))
void PrintAttributes( DWORD dwAttr );
#endif
BOOL UserCanModifyDevice ();
BOOL CanShowAddDevice();
void MyCoUninitialize();
struct TLSDATA
{
    CComBSTR strDeviceId;
    CComPtr<IWiaItem> pDevice;
    TLSDATA *pNext;
    ~TLSDATA()
    {
        if (pNext) delete pNext;
    }
};

void RunWizardAsync(LPCWSTR pszDeviceId);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shimgvwr\imagedoc.cpp ===
// ImageDoc.cpp : implementation of the CImageDoc class
//

#include "stdafx.h"
#include "shimgvwr.h"

#include "ImageDoc.h"
#include "imageview.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
extern CPreviewApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CImageDoc

IMPLEMENT_DYNCREATE(CImageDoc, CDocument)

BEGIN_MESSAGE_MAP(CImageDoc, CDocument)
    //{{AFX_MSG_MAP(CImageDoc)
    ON_COMMAND(ID_FILE_SCAN, OnFileScan)
    ON_COMMAND(ID_FILE_PROPERTIES, OnFileProperties)
    ON_COMMAND(ID_FILE_SEND_MAIL, OnFileSendMail)
    ON_COMMAND(ID_FILE_PAPER_TILE, OnFilePaperTile)
    ON_COMMAND(ID_FILE_PAPER_CENTER, OnFilePaperCenter)
    ON_COMMAND(ID_FILE_SAVE_AS, OnFileSaveAs) 
    ON_UPDATE_COMMAND_UI(ID_FILE_SCAN, OnUpdateFileScan)
// these items are enabled if the current file is not a temp file
    ON_UPDATE_COMMAND_UI(ID_FILE_PROPERTIES, OnUpdateFileMenu)
    ON_UPDATE_COMMAND_UI(ID_FILE_SEND_MAIL, OnUpdateFileMenu)
    ON_UPDATE_COMMAND_UI(ID_FILE_PAPER_TILE, OnUpdateFileMenu)
    ON_UPDATE_COMMAND_UI(ID_FILE_PAPER_CENTER, OnUpdateFileMenu)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CImageDoc construction/destruction

CImageDoc::CImageDoc()
{
    m_bUseTempPath = false;

}

CImageDoc::~CImageDoc()
{
    DelTempFile ();
}

BOOL CImageDoc::OnNewDocument()
{
    
    if (!CDocument::OnNewDocument())
        return FALSE;
    DelTempFile ();

    
    return TRUE;
}
void MySplitPath (const TCHAR *szPath, TCHAR *szDrive, TCHAR *szDir, TCHAR *szName, TCHAR *szExt)
    {
       // Found this in tchar.h
       _tsplitpath (szPath, szDrive, szDir, szName, szExt);
    }

// Remove the name part of a file path.  Return just the drive and directory, and name.
//
CString StripExtension(const TCHAR* szFilePath)
    {
    TCHAR szPath [_MAX_DRIVE + _MAX_DIR + _MAX_FNAME];
    TCHAR szDir [_MAX_DIR];
    TCHAR szName [_MAX_FNAME];
    MySplitPath(szFilePath, szPath, szDir, szName, NULL);
    lstrcat(szPath, szDir);
    lstrcat(szPath, szName);
    return CString(szPath);
    }


void CImageDoc::OnFileSaveAs ()
{
    CString sNewName = StripExtension(GetPathName());
    if (theApp.DoPromptFileName (sNewName, AFX_IDS_SAVEFILE,
                                 OFN_HIDEREADONLY | OFN_PATHMUSTEXIST,
                                 FALSE))
    {
        if (!OnSaveDocument (sNewName))
        {
            // be sure to delete the file
            TRY
                {
                CFile::Remove( sNewName );
                }
            CATCH_ALL(e)
                {
                TRACE0( "Warning: failed to delete file after failed SaveAs\n" );
                }
            END_CATCH_ALL
            
        }        
    }
}

BOOL CImageDoc::OnSaveDocument(LPCTSTR szPathName)
{
    // the view deals with the preview control, so ask it to do the save
    BOOL bRet = FALSE; 
    
    POSITION pos = GetFirstViewPosition();
    CImageView *pView = dynamic_cast<CImageView*>(GetNextView(pos));
    if (pView)
    {
        HRESULT hr = pView->SaveImageAs(szPathName);
        if (SUCCEEDED(hr))
        {
            SetModifiedFlag (FALSE);
            SetPathName(szPathName);
            UpdateAllViews(NULL);
            bRet = TRUE;
        }
        else
        {
            LPTSTR szMsg = NULL;
            FormatMessage (FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER,
                           NULL,
                           hr,
                           0,
                           reinterpret_cast<LPTSTR>(&szMsg),
                           1,
                           NULL);
            if (szMsg)
            {
                AfxMessageBox (szMsg, MB_ICONHAND|MB_OK);
            }

        }
    }
    return bRet;
}


/////////////////////////////////////////////////////////////////////////////
// CImageDoc serialization

void CImageDoc::Serialize(CArchive& ar)
{
    if (ar.IsStoring())
    {
        // TODO: add storing code here
    }
    else
    {
        // TODO: add loading code here
    }
}

/////////////////////////////////////////////////////////////////////////////
// CImageDoc diagnostics

#ifdef _DEBUG
void CImageDoc::AssertValid() const
{
    CDocument::AssertValid();
}

void CImageDoc::Dump(CDumpContext& dc) const
{
    CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CImageDoc commands

BOOL CImageDoc::OnOpenDocument(LPCTSTR lpszPathName) 
{
    
    if (!CDocument::OnOpenDocument(lpszPathName))
        return FALSE;
    DelTempFile ();

    return TRUE;
}

const CString& 
CImageDoc::GetImagePathName() const
{
    if (m_bUseTempPath)
    {
        return m_strTempPath;
    }
    else
    {
        return GetPathName();
    }
}

void
CImageDoc::SetTempFileName(const CString &strTempFile)
{
    m_strTempPath = strTempFile;
    m_bUseTempPath = true;
    CString strUntitled;
    strUntitled.LoadString(AFX_IDS_UNTITLED);
    SetPathName (strUntitled, FALSE);
}

void
CImageDoc::DelTempFile()
{
    if (m_bUseTempPath)
    {    
        m_bUseTempPath = false;
        CFile::Remove(m_strTempPath);
    }
}

void CImageDoc::OnFileScan() 
{
    
    // First, make a new document
    OnNewDocument();
    GetDevMgr();
    // Now do a scan to a temp file
    CString strTempPath;
    LPTSTR szPath;
    GUID guidFmt = WiaImgFmt_JPEG;
    GetTempPath (MAX_PATH, szPath = strTempPath.GetBufferSetLength(MAX_PATH));
    GetTempFileName (szPath, TEXT("img"),0,szPath);
    strTempPath.ReleaseBuffer();
    POSITION pos = GetFirstViewPosition();
    if (S_OK == m_pDevMgr->GetImageDlg(GetNextView(pos)->GetSafeHwnd(), 
                                       StiDeviceTypeDefault,
                                       WIA_DEVICE_DIALOG_SINGLE_IMAGE,
                                       WIA_INTENT_NONE,
                                       NULL,
                                       CComBSTR(strTempPath),
                                       &guidFmt))

    {
        
        
        SetTempFileName(strTempPath);
        SetModifiedFlag(TRUE);
        UpdateAllViews(NULL);
    }

}

void CImageDoc::OnUpdateFileScan(CCmdUI* pCmdUI) 
{
    pCmdUI->Enable(bWIADeviceInstalled());

}


bool
CImageDoc::bWIADeviceInstalled()
{
    bool bRet = false;
    GetDevMgr();
    if (m_pDevMgr.p)
    {
        CComPtr<IEnumWIA_DEV_INFO> pEnum;
        
        
        if (SUCCEEDED(m_pDevMgr->EnumDeviceInfo (0, &pEnum)))
        {
            ULONG ul = 0;
            if (SUCCEEDED(pEnum->GetCount(&ul)))
            {
                bRet = ul ? true : false;
            }
        }
    }
    return bRet;
}

void 
CImageDoc::OnFileProperties ()
{
    SHELLEXECUTEINFO sei;
    CString strPath = GetImagePathName();
    ZeroMemory (&sei, sizeof(sei));
    sei.cbSize = sizeof(sei);
    sei.fMask = SEE_MASK_INVOKEIDLIST;
    POSITION pos = GetFirstViewPosition();
    sei.hwnd = GetNextView(pos)->GetSafeHwnd();
    sei.lpVerb = TEXT("properties");
    sei.lpFile = strPath;
    sei.nShow = SW_SHOW;
 
    ShellExecuteEx (&sei);
}


    
void 
CImageDoc::OnFilePaperCenter ()
{
    SetWallpaper (false);
}

void 
CImageDoc::OnFilePaperTile ()
{
    SetWallpaper (true);
}

void
CImageDoc::SetWallpaper(bool bTile)
{
    // need to modify the registry directly in addition to the SPI
    DWORD dwDisp;
    HKEY  hKey = 0;

    if (RegCreateKeyEx( HKEY_CURRENT_USER, TEXT("Control Panel\\Desktop"),
                        REG_OPTION_RESERVED, TEXT(""),
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS, NULL, &hKey, &dwDisp ) == ERROR_SUCCESS)
    {
        RegSetValueEx( hKey, TEXT("TileWallpaper"), 0, REG_SZ,
                        reinterpret_cast<BYTE *>(bTile? TEXT("1"): TEXT("0")), 2*sizeof(TCHAR) );
        RegCloseKey( hKey );
    }
    CString strPath = GetImagePathName();
    SystemParametersInfo( SPI_SETDESKWALLPAPER, bTile? 1: 0,
             (LPVOID)(strPath.GetBuffer( strPath.GetLength() )),
             SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE );
    strPath.ReleaseBuffer();
}

void 
CImageDoc::OnUpdateFileMenu (CCmdUI* pCmdUI)
{
    BOOL bEnable = GetPathName().GetLength();
    switch (pCmdUI->m_nID)
    {
        case ID_FILE_SEND_MAIL:
            OnUpdateFileSendMail(pCmdUI);
            return;
        default:
            bEnable = bEnable && !m_bUseTempPath;
            break;
    }
    pCmdUI->Enable(bEnable);
}

void
CImageDoc::GetDevMgr ()
{
    if (!m_pDevMgr)            // Create our WIA device manager pointer
        CoCreateInstance (CLSID_WiaDevMgr, 
                      NULL, 
                      CLSCTX_LOCAL_SERVER, 
                      IID_IWiaDevMgr,   
                      reinterpret_cast<LPVOID*>(&m_pDevMgr));

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shellext\src\verbs.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998 - 1999
 *
 *  TITLE:       <FILENAME>
 *
 *  VERSION:     1.1
 *
 *  AUTHOR:      RickTu/DavidShi
 *
 *  DATE:        5/27/98
 *
 *  DESCRIPTION: This file contains the code which implements the verbs
 *               on the objects in our shell namespace extension
 *
 *****************************************************************************/

#include "precomp.hxx"
#include "prwiziid.h"
#include "wininet.h"
#include <wiadevd.h>
#pragma hdrstop



static const TCHAR cszCameraItems [] = TEXT("CameraItems");
static const TCHAR cszTempFileDir [] = TEXT("TemporaryImageFiles");
/*****************************************************************************

   GetSetSettingsBool

   Goes to the registry to get the specified boolean setting and
   returns TRUE or FALSE depending on what is found there...

 *****************************************************************************/

BOOL
GetSetSettingsBool( LPCTSTR pValue, BOOL bSet, BOOL bValue )
{
    HKEY hKey = NULL;
    BOOL bRes = bValue;
    DWORD dwType, dwData, cbData;
    LONG lRes;

    //
    // param validation
    //

    if (!pValue)
        goto exit_gracefully;

    //
    // Try to open the settings key for this user...
    //

    lRes = RegCreateKeyEx( HKEY_CURRENT_USER,
                           REGSTR_PATH_SHELL_USER_SETTINGS,
                           0,
                           NULL,
                           REG_OPTION_NON_VOLATILE,
                           KEY_ALL_ACCESS,
                           NULL,
                           &hKey,
                           NULL );

    if ((lRes != ERROR_SUCCESS) || (hKey == NULL))
        goto exit_gracefully;

    if (!hKey)
        goto exit_gracefully;

    if (bSet)
    {
        lRes = RegSetValueEx( hKey,
                              pValue,
                              0,
                              REG_DWORD,
                              (LPBYTE)&bValue,
                              sizeof(BOOL)
                             );

        bRes = (lRes == ERROR_SUCCESS);
    }
    else
    {
        //
        // Try to get the DWORD value for this item...
        //

        cbData = sizeof(dwData);
        dwData = 0;
        lRes = RegQueryValueEx( hKey,
                                pValue,
                                NULL,
                                &dwType,
                                (LPBYTE)&dwData,
                                &cbData
                               );

        if ((dwType == REG_DWORD) && dwData)
        {
            bRes = TRUE;
        }
    }

exit_gracefully:

    if (hKey)
    {
        RegCloseKey( hKey );
    }

    return bRes;

}



/*****************************************************************************

   GetIDAFromDataObject

   Utility function to get list of IDLISTs from a dataobject

 *****************************************************************************/

HRESULT
GetIDAFromDataObject( LPDATAOBJECT pDataObject, LPIDA * ppida, bool bShellFmt )
{

    HRESULT         hr = E_FAIL;
    FORMATETC       fmt;
    STGMEDIUM       stgmed;
    SIZE_T          uSize;
    LPVOID          lpv;
    LPIDA           lpida = NULL;

    TraceEnter( TRACE_VERBS, "GetIDAFromDataObject" );
    ZeroMemory (&fmt, sizeof(fmt));
    ZeroMemory (&stgmed, sizeof(stgmed));
    //
    // Check incoming params...
    //

    if (!ppida)
    {
        ExitGracefully( hr, E_INVALIDARG, "ppida is null" );
    }
    *ppida = NULL;

    if (!pDataObject)
    {
        ExitGracefully( hr, E_INVALIDARG, "pDataObject is null" );
    }

    //
    // Make sure the format we want is registered...
    //

    RegisterImageClipboardFormats();

    //
    // Ask for IDA...
    //

    fmt.cfFormat = bShellFmt ? g_cfShellIDList : g_cfMyIDList;
    fmt.ptd      = NULL;
    fmt.dwAspect = DVASPECT_CONTENT;
    fmt.lindex   = -1;
    fmt.tymed    = TYMED_HGLOBAL;

    stgmed.tymed          = TYMED_HGLOBAL;
    stgmed.hGlobal        = NULL;
    stgmed.pUnkForRelease = NULL;

    hr = pDataObject->GetData( &fmt, &stgmed );
    FailGracefully( hr, "GetData for idlists failed" );

    //
    // Make a copy of it...
    //

    uSize = GlobalSize( (HGLOBAL)stgmed.hGlobal );
    if (!uSize)
    {
        ExitGracefully( hr, E_FAIL, "Couldn't get size of memory block" );
    }

    lpida = (LPIDA)LocalAlloc( LPTR, uSize );
    if (lpida)
    {

        lpv = (LPVOID)GlobalLock( (HGLOBAL)stgmed.hGlobal );
        CopyMemory( (PVOID)lpida, lpv, uSize );
        GlobalUnlock( stgmed.hGlobal );

        hr = S_OK;
        *ppida = lpida;

    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

exit_gracefully:

    if (stgmed.hGlobal)
    {
        ReleaseStgMedium( &stgmed );
    }

    TraceLeaveResult(hr);

}




/*****************************************************************************

   PreviewImage

   Download the pic and run the default viewer.

 *****************************************************************************/

HRESULT PreviewImage(LPTSTR pFileName, HWND hwndOwner )
{
    TraceEnter( TRACE_VERBS, "PreviewImage" );

    SHELLEXECUTEINFO sei;
    HRESULT hr = S_OK;

    //
    // Download the picture from the camera...
    //

    DWORD dwAttrib = GetFileAttributes( pFileName );

    if (dwAttrib != -1)
    {
        // being a preview, file is read-only
        if (!SetFileAttributes(pFileName, (dwAttrib | FILE_ATTRIBUTE_READONLY)))
        {
            Trace(TEXT("couldn't add READONLY (0x%x) attribute on %s, GLE=%d"),dwAttrib | FILE_ATTRIBUTE_READONLY,pFileName,GetLastError());
        }
    }
    else
    {
        Trace(TEXT("couldn't get file attributes for %s, GLE=%d"),pFileName,GetLastError());
    }

    //
    // Exec the app to view the picture
    //
    ZeroMemory( &sei,  sizeof(sei) );
    sei.cbSize = sizeof(sei);
    sei.lpFile = pFileName;
    sei.nShow = SW_NORMAL;
    sei.fMask = SEE_MASK_WAITFORINPUTIDLE | SEE_MASK_INVOKEIDLIST;

    if (!ShellExecuteEx (&sei))
    {
        DWORD dw= GetLastError();
        hr = HRESULT_FROM_WIN32(hr);
    }

    TraceLeaveResult(hr);
}


#define FILETIME_UNITS_PER_DAY 0xC92A69C000
void DeleteOldFiles(const CSimpleString &strTempDir, bool bTempName)
{
    WIN32_FIND_DATA wfd;
    HANDLE hFind;
    LPCTSTR szFormat;
    SYSTEMTIME stCurrentTime;
    ULONGLONG  ftCurrentTime;
    CSimpleString strMask;

    TraceEnter(TRACE_VERBS, "DeleteOldFiles");
    GetSystemTime (&stCurrentTime);
    SystemTimeToFileTime (&stCurrentTime, reinterpret_cast<FILETIME*>(&ftCurrentTime));

    ZeroMemory (&wfd, sizeof(wfd));
    if (bTempName)
    {
        strMask.Format (TEXT("%s\\%s*.*"), strTempDir.String(), g_cszTempFilePrefix);
    }
    else
    {
        strMask.Format (TEXT("%s\\*.*"), strTempDir.String());
    }

    Trace(TEXT("strMask for deletion is %s"), strMask.String());
    hFind  = FindFirstFile (strMask, &wfd);

    if (INVALID_HANDLE_VALUE != hFind)
    {
        ULONGLONG uiDiff;
        do
        {
            uiDiff = ftCurrentTime - *(reinterpret_cast<ULONGLONG*>(&wfd.ftLastWriteTime));
            if (uiDiff > FILETIME_UNITS_PER_DAY)
            {
                SetFileAttributes(wfd.cFileName, FILE_ATTRIBUTE_NORMAL);
                DeleteFile (wfd.cFileName);
            }
        } while (FindNextFile (hFind, &wfd));
        FindClose (hFind);
    }
    TraceLeave();
}

HRESULT OldDoPreviewVerb(HWND hwndOwner, LPDATAOBJECT pDataObject)
{
    LPIDA           lpida = NULL;
    LPITEMIDLIST    pidl;
    UINT            cidl;
    INT             i;

    HRESULT hr = E_FAIL;
    TraceEnter( TRACE_VERBS, "OldDoPreviewVerb" );
    //
    // Get the lpida for the dataobject
    //

    hr = GetIDAFromDataObject( pDataObject, &lpida );
    FailGracefully( hr, "couldn't get lpida from dataobject" );

    //
    // Loop through and do open for the items we understand.
    //
    // Currently this is: camera items (not containers)
    //

    cidl = lpida->cidl;

    for (i = 1; (i-1) < (INT)cidl; i++)
    {
        pidl = (LPITEMIDLIST)(((LPBYTE)lpida) + lpida->aoffset[i]);

        if (IsCameraItemIDL( pidl ))
        {
            if (IsContainerIDL( pidl ))
            {
                //
                // We don't do anything for those right now...
                //
            }
            else
            {
                CSimpleStringWide strImgName;
                ULONG ulSize;
                GUID lFormat;
                TCHAR szFileName[MAX_PATH];
                FILETIME ftCreate;
                FILETIME ftExp = {0};
                TCHAR szExt[MAX_PATH];
                hr = IMGetImagePreferredFormatFromIDL( pidl, &lFormat, szExt );

                //
                // Generate temp file name...
                //
                IMGetNameFromIDL(pidl, strImgName);
                IMGetImageSizeFromIDL(pidl, &ulSize);
                IMGetCreateTimeFromIDL(pidl, &ftCreate);
                CSimpleStringWide strCacheName = CSimpleStringWide(L"temp:")+strImgName+CSimpleStringWide(szExt);
                if (CreateUrlCacheEntry(strCacheName, ulSize, szExt+1,szFileName, 0))
                {
                    //
                    // Show it
                    //
                    Trace(TEXT("downloading bits to %s"),szFileName);
                    hr = DownloadPicture( szFileName, pidl, hwndOwner );
                    if (SUCCEEDED(hr))
                    {
                        if (CommitUrlCacheEntry(strCacheName, szFileName, ftExp, ftCreate, STICKY_CACHE_ENTRY, NULL, 0, NULL, NULL))
                        {
                            hr = PreviewImage(szFileName, hwndOwner);
                        }
                        else
                        {
                            DWORD dw = GetLastError();
                            hr = HRESULT_FROM_WIN32(dw);
                        }
                    }
                }
                else
                {
                    DWORD dw = GetLastError();
                    hr = HRESULT_FROM_WIN32(dw);
                }
            }
        }
    }


exit_gracefully:

    if (lpida)
    {
        LocalFree(lpida);
        lpida = NULL;
    }
    TraceLeaveResult(hr);
}
/*****************************************************************************

   DoPreviewVerb

   User selected "Preview" on the item in question.

 *****************************************************************************/
/* e84fda7c-1d6a-45f6-b725-cb260c236066 */
DEFINE_GUID(CLSID_PhotoVerbs,
            0xe84fda7c, 0x1d6a, 0x45f6, 0xb7, 0x25, 0xcb, 0x26, 0x0c, 0x23, 0x60, 0x66);


HRESULT DoPreviewVerb( HWND hwndOwner, LPDATAOBJECT pDataObject )
{

    HRESULT         hr = E_FAIL;
    CComPtr<IShellExtInit> pExtInit;

    TraceEnter( TRACE_VERBS, "DoPreviewVerb" );
    hr = CoCreateInstance(CLSID_PhotoVerbs,
                          NULL,
                          CLSCTX_INPROC,
                          IID_IShellExtInit,
                          reinterpret_cast<VOID**>(&pExtInit));
    if (SUCCEEDED(hr))
    {
        hr = pExtInit->Initialize(NULL, pDataObject, NULL);
        if (SUCCEEDED(hr))
        {
            CComQIPtr<IContextMenu, &IID_IContextMenu> pcm(pExtInit);
            hr = SHInvokeCommandOnContextMenu(hwndOwner, NULL, pcm, 0, "preview");            
        }
    }
    else
    {
        // if the preview app isn't around, invoke the default handler
        // using a temp file
        hr = OldDoPreviewVerb(hwndOwner, pDataObject);
    }

    TraceLeaveResult(hr);

}



/*****************************************************************************

   DoSaveInMyPics

   User selected "Save to my pictures" on the items in question

 *****************************************************************************/

HRESULT DoSaveInMyPics( HWND hwndOwner, LPDATAOBJECT pDataObject )
{
    HRESULT         hr    = S_OK;
    LPITEMIDLIST    pidlMyPics = NULL;

    CComPtr<IShellFolder> pDesktop;
    CComPtr<IShellFolder> pMyPics;
    CComPtr<IDropTarget>  pDrop;
    CWaitCursor *pwc;
    TraceEnter( TRACE_VERBS, "DoSaveInMyPics" );

    //
    // Check for bad params...
    //

    if (!pDataObject)
        ExitGracefully( hr, E_INVALIDARG, "pDataObject was NULL!" );


    //
    // Get the path for the My Pictures directory...
    //

    hr = SHGetFolderLocation(hwndOwner, CSIDL_MYPICTURES, NULL, 0, &pidlMyPics );
    FailGracefully( hr, "My Pictures is undefined!!!" );

    //
    // Get an IDropTarget for My Pictures
    hr = SHGetDesktopFolder (&pDesktop);
    if (SUCCEEDED(hr) && pDesktop)
    {
        hr = pDesktop->BindToObject (pidlMyPics,
                                     NULL,
                                     IID_IShellFolder,
                                     reinterpret_cast<LPVOID*>(&pMyPics));
        FailGracefully (hr, "Unable to get IShellFolder for My Pictures");
        hr = pMyPics->CreateViewObject (hwndOwner,
                                        IID_IDropTarget,
                                        reinterpret_cast<LPVOID*>(&pDrop));
        FailGracefully (hr, "Unable to get IDropTarget for My Pictures");
        //
        // Call SHLWAPI's SHSimulateDragDrop to do the work. This is a private API
        //
        pwc = new CWaitCursor ();
        hr = SHSimulateDrop (pDrop, pDataObject, MK_CONTROL|MK_LBUTTON, NULL, NULL);
        DoDelete (pwc);
    }



exit_gracefully:

    if (FAILED(hr) && HRESULT_CODE(hr) != ERROR_CANCELLED)
    {
        UIErrors::ReportMessage(hwndOwner,
                                GLOBAL_HINSTANCE,
                                NULL,
                                MAKEINTRESOURCE(IDS_DOWNLOAD_CAPTION),
                                MAKEINTRESOURCE (IDS_DOWNLOAD_FAILED),
                                MB_OK);

    }
    else if (SUCCEEDED(hr))
    {

        TCHAR szPath[MAX_PATH];
        SHGetFolderPath (hwndOwner, CSIDL_MYPICTURES, NULL, 0, szPath);
        ShellExecute (hwndOwner,
                      NULL,
                      szPath,
                      NULL,
                      szPath,
                      SW_SHOW);

    }
    DoILFree (pidlMyPics);
    TraceLeaveResult(hr);

}



/*****************************************************************************

   CImageFolder::DoProperties

   User selected "Properties" on the item in question.

 *****************************************************************************/
STDMETHODIMP
CImageFolder::DoProperties(LPDATAOBJECT pDataObject)
{
    HRESULT hr = E_FAIL;
    IGlobalInterfaceTable *pgit = NULL;
    TraceEnter (TRACE_VERBS, "CImageFolder::DoProperties");

    hr = CoCreateInstance (CLSID_StdGlobalInterfaceTable,
                           NULL,
                           CLSCTX_INPROC_SERVER,
                           IID_IGlobalInterfaceTable,
                           reinterpret_cast<LPVOID *>(&pgit));

    if (pgit)
    {
        PROPDATA *pData = new PROPDATA;
        if (!pData)
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = pgit->RegisterInterfaceInGlobal (pDataObject, IID_IDataObject, &pData->dwDataCookie);
        }
        if (SUCCEEDED(hr))
        {
            DWORD dw;
            pData->pThis = this;
            pData->pgit = pgit;
            pgit->AddRef();
            AddRef ();

            HANDLE hThread= CreateThread (NULL,
                                          0,
                                          reinterpret_cast<LPTHREAD_START_ROUTINE>(PropThreadProc),
                                          reinterpret_cast<LPVOID>(pData),
                                          0,
                                          &dw);
            if (hThread)
            {
                CloseHandle(hThread);
            }
            else
            {
                delete pData;
                dw = GetLastError ();
                hr = HRESULT_FROM_WIN32(dw);
                Release ();
                pgit->RevokeInterfaceFromGlobal (pData->dwDataCookie);
            }
        }
        else
        {
            DoDelete (pData);
        }
        pgit->Release();
    }

    TraceLeaveResult (hr);
}

VOID
CImageFolder::PropThreadProc (PROPDATA *pData)
{
    HRESULT hr = E_FAIL;
    TraceEnter (TRACE_VERBS, "CImageFolder::PropThreadProc");
    InterlockedIncrement (&GLOBAL_REFCOUNT); // prevent MyCoUninitialize from unloading the DLL

    if (pData && pData->pgit && pData->pThis)
    {
        hr = CoInitialize(NULL);

        if (SUCCEEDED(hr))
        {
            CComPtr<IDataObject> pdo;

            hr = pData->pgit->GetInterfaceFromGlobal (pData->dwDataCookie,
                                                     IID_IDataObject,
                                                     reinterpret_cast<LPVOID*>(&pdo));
            if (SUCCEEDED(hr))
            {

                hr = pData->pThis->_DoProperties(pdo);

            }
            pData->pgit->RevokeInterfaceFromGlobal (pData->dwDataCookie);

            if (FAILED(hr) && hr != E_ABORT)
            {
                UIErrors::ReportError(NULL, GLOBAL_HINSTANCE, UIErrors::ErrCommunicationsFailure);
            }
            pData->pgit->Release();
            pData->pThis->Release ();
            delete pData;
        }
        if (SUCCEEDED(hr))
        {
            MyCoUninitialize ();
        }
    }

    InterlockedDecrement (&GLOBAL_REFCOUNT);
    TraceLeave ();
}


HRESULT
CImageFolder::_DoProperties( LPDATAOBJECT pDataObject )
{

    HRESULT         hr    = S_OK;
    LPIDA           lpida = NULL;
    LPITEMIDLIST    pidl;
    CSimpleStringWide strDeviceId;
    CSimpleStringWide strTitle;
    CSimpleStringWide strName;
    CComPtr<IWiaPropertyStorage> pDevice;
    HKEY            aKeys[2];
    int cKeys=1;
    TraceEnter( TRACE_VERBS, "CImageFolder::_DoProperties" );

    //
    // Check for bad params...
    //

    if (!pDataObject)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        //
        // Get the lpida for the dataobject
        //

        hr = GetIDAFromDataObject (pDataObject, &lpida, true);
        if (SUCCEEDED(hr))
        {

            pidl = reinterpret_cast<LPITEMIDLIST>(reinterpret_cast<LPBYTE>(lpida) + lpida->aoffset[1]);
            IMGetDeviceIdFromIDL (pidl, strDeviceId);
            IMGetNameFromIDL (pidl, strName);
            if (lpida->cidl > 1)
            {
                strTitle.Format (IDS_MULTIPROP_SEL, GLOBAL_HINSTANCE, strName.String());
            }
            else
            {
                strTitle = strName;
            }

            if (!IsSTIDeviceIDL(pidl))
            {
                hr = GetDeviceFromDeviceId (strDeviceId,
                                            IID_IWiaPropertyStorage,
                                            reinterpret_cast<LPVOID*>(&pDevice),
                                            TRUE);
                if (SUCCEEDED(hr))
                {
                    if (1 == lpida->cidl)
                    {
                        ProgramDataObjectForExtension (pDataObject, pidl);
                    }
                    aKeys[1] = GetDeviceUIKey (pDevice, WIA_UI_PROPSHEETHANDLER);
                    if (aKeys[1])
                    {
                        cKeys++;
                    }

                    //
                    // Now find the extensions for this type of device
                    //
                    aKeys[0] = GetGeneralUIKey (pDevice, WIA_UI_PROPSHEETHANDLER);
                }
            }
            else

            {
                CSimpleString strKeyPath;
                strKeyPath.Format (c_szStiPropKey, cszImageCLSID);
                RegCreateKeyEx (HKEY_CLASSES_ROOT,
                                strKeyPath,
                                0,
                                NULL,
                                0,
                                KEY_READ,
                                NULL,
                                &aKeys[0],
                                NULL);
                aKeys[1] = NULL;
            }
        }
    }
    if (SUCCEEDED(hr))
    {
        if (!aKeys[0])
        {
            hr = E_FAIL;
            Trace(TEXT("GetGeneralKey failed in DoProperties"));
        }
        else
        {
            Trace(TEXT("Calling SHOpenPropSheet!"));
            SHOpenPropSheet (CSimpleStringConvert::NaturalString(strTitle),
                             aKeys, cKeys, NULL, pDataObject, NULL, NULL);
        }
        for (cKeys=1;cKeys>=0;cKeys--)
        {
            if (aKeys[cKeys])
            {
                RegCloseKey (aKeys[cKeys]);
            }
        }
    }

    if (lpida)
    {
        LocalFree(lpida);
    }

    TraceLeaveResult(hr);
}


/*****************************************************************************

   ConfirmItemDelete

   Prompt the user to confirm they REALLY want to delete the items from the device

 *****************************************************************************/

BOOL
ConfirmItemDelete (HWND hwndOwner, LPIDA pida)
{
    TCHAR           szConfirmTitle[MAX_PATH];
    TCHAR           szConfirmText [MAX_PATH];
    TCHAR           szFormattedText [MAX_PATH];
    CSimpleStringWide strItemName;
    CSimpleString   strName;
    INT             idTitle;
    LPITEMIDLIST    pidl;
    BOOL            bRet;

    TraceEnter (TRACE_VERBS, "ConfirmItemDelete");

    pidl = (reinterpret_cast<LPITEMIDLIST>(reinterpret_cast<LPBYTE>(pida)+pida->aoffset[1]));
    IMGetNameFromIDL (pidl, strItemName);
    strName = CSimpleStringConvert::NaturalString (strItemName);
    if (pida->cidl > 1)
    {
        idTitle = IDS_TITLECONFIRM_MULTI;

        LoadString (GLOBAL_HINSTANCE, IDS_CONFIRM_MULTI, szConfirmText, ARRAYSIZE(szConfirmText));
        wsprintf (szFormattedText, szConfirmText, pida->cidl);
    }
    else if (IsContainerIDL(pidl))
    {
        idTitle = IDS_TITLECONFIRM_FOLDER;
        LoadString (GLOBAL_HINSTANCE, IDS_CONFIRM_FOLDER, szConfirmText, ARRAYSIZE(szConfirmText));
        wsprintf (szFormattedText, szConfirmText, strName.String());
    }
    else if (IsDeviceIDL(pidl) || IsSTIDeviceIDL(pidl))
    {
        idTitle = IDS_TITLECONFIRM_DEVICE;
        LoadString (GLOBAL_HINSTANCE, IDS_CONFIRM, szConfirmText, ARRAYSIZE(szConfirmText));
        wsprintf (szFormattedText, szConfirmText, strName.String());
    }
    else
    {
        idTitle = IDS_TITLECONFIRM;
        LoadString (GLOBAL_HINSTANCE, IDS_CONFIRM, szConfirmText, ARRAYSIZE(szConfirmText));
        wsprintf (szFormattedText, szConfirmText, strName.String());
    }
    LoadString (GLOBAL_HINSTANCE, idTitle, szConfirmTitle, ARRAYSIZE(szConfirmTitle));


    bRet = (IDYES==MessageBox (hwndOwner,
                               szFormattedText,
                               szConfirmTitle,
                               MB_YESNO | MB_ICONWARNING | MB_SETFOREGROUND | MB_APPLMODAL
                               ));
    TraceLeave ();
    return bRet;
}



/*****************************************************************************

   DoDeletePicture

   User selected "Delete" on the items in question.

 *****************************************************************************/

HRESULT
DoDeleteItem( HWND hwndOwner, LPDATAOBJECT pDataObject, BOOL bNoUI )
{
    HRESULT             hr           = S_OK;
    LPIDA               lpida        = NULL;
    CComBSTR            bstrFullPath ;
    LPITEMIDLIST        pidl,pidlParent;
    UINT                cidl;
    CSimpleStringWide   strDeviceId;
    UINT                 i;
    BOOL                bDoIt = FALSE;
    CComPtr<IWiaItem>   pWiaItemRoot;
    CComPtr<IWiaItem>   pItem;
    LPITEMIDLIST pidlReal;
    TraceEnter( TRACE_VERBS, "DoDeleteItem" );

    //
    // Check for bad params...
    //

    if (!pDataObject)
        ExitGracefully( hr, E_INVALIDARG, "pDataObject was NULL!" );

    //
    // Get the lpida for the dataobject
    //

    hr = GetIDAFromDataObject( pDataObject, &lpida, true );
    FailGracefully( hr, "couldn't get lpida from dataobject" );

    //
    // Loop through for each item...
    //

    cidl = lpida->cidl;
    pidlParent = (LPITEMIDLIST)(((LPBYTE)lpida) + lpida->aoffset[0]);
    if (cidl)
    {
        if (bNoUI)
        {
            bDoIt = TRUE;
        }
        else
        {
            bDoIt = ConfirmItemDelete (hwndOwner, lpida);
        }
    }

    if (bDoIt)
    {

      for (i = 1; (i-1) < cidl; i++)
      {

        pidl = (LPITEMIDLIST)(((LPBYTE)lpida) + lpida->aoffset[i]);

        //
        // Get the DeviceId...

        hr = IMGetDeviceIdFromIDL( pidl,strDeviceId);
        FailGracefully( hr, "IMGetDeviceIdFromIDL failed" );

        if (IsDeviceIDL (pidl) || IsSTIDeviceIDL (pidl))
        {
            hr = RemoveDevice (strDeviceId);
        }
        else if (IsPropertyIDL (pidl)) // ignore sound idls
        {
            continue;
        }
        else
        {
            //
            //  Create the device...
            //

            hr = GetDeviceFromDeviceId( strDeviceId,
                                        IID_IWiaItem,
                                        (LPVOID *)&pWiaItemRoot,
                                        TRUE
                                        );
            FailGracefully( hr, "GetDeviceFromDeviceId failed" );

            //
            // Get actual item in question...
            //

            hr = IMGetFullPathNameFromIDL( pidl, &bstrFullPath );
            FailGracefully( hr, "couldn't get full path name from pidl" );

            // BUGBUG: When access rights are implemented, check them

            hr = pWiaItemRoot->FindItemByName( 0, bstrFullPath, &pItem );
            FailGracefully( hr, "Couldn't find item by name" );

            if (pItem)
            {

                // physically remove the item
                hr = WiaUiUtil::DeleteItemAndChildren(pItem);
            }
            // inform the shell of our action
            // for device removal, our folder will get a disconnect event
            pidlReal = ILCombine( pidlParent, pidl );
            if (SUCCEEDED(hr) && pidlReal)
            {
                UINT uFlags = SHCNF_IDLIST;
                if (i+1 == cidl)
                {
                    uFlags |= SHCNF_FLUSH;//only flush at the end
                }
                SHChangeNotify( SHCNE_DELETE,
                                uFlags,
                                pidlReal,
                                NULL );

            }
            DoILFree( pidlReal );
        }
      }
    }
    
exit_gracefully:

    if (lpida)
    {
        LocalFree(lpida);
        lpida = NULL;
    }
    if (FAILED(hr))
    {
        // show an error message here
        hr = S_FALSE; // keep web view from popping up error boxes
    }
    TraceLeaveResult( hr );

}

/*****************************************************************************

   DoDeleteAllItems

   Called by camocx to delete all the items in a camera

 *****************************************************************************/

STDAPI_(HRESULT)
DoDeleteAllItems( BSTR bstrDeviceId, HWND hwndOwner )
{
    HRESULT hr = E_FAIL;

    CComPtr<IShellFolder> psfDevice;
    CComPtr<IEnumIDList> pEnum;
    LPITEMIDLIST *aidl = NULL;
    INT cidl = 0;

    HDPA dpaItems = DPA_Create (5);
    TraceEnter (TRACE_VERBS, "DoDeleteAllItems");

    hr = BindToDevice (bstrDeviceId,
                       IID_IShellFolder,
                       reinterpret_cast<LPVOID*>(&psfDevice));
    if (SUCCEEDED(hr))
    {
        Trace(TEXT("Found the device folder, getting the data object"));
        hr = psfDevice->EnumObjects (NULL,
                                     SHCONTF_FOLDERS | SHCONTF_NONFOLDERS,
                                     &pEnum);
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidlItem;
            ULONG ul;
            CComPtr<IDataObject> pdo;
            while (S_OK == pEnum->Next (1, &pidlItem, &ul))
            {
                DPA_AppendPtr (dpaItems, pidlItem);
            }
            cidl = DPA_GetPtrCount(dpaItems);
            if (cidl)
            {
                aidl = new LPITEMIDLIST[cidl];
                if (aidl)
                {
                    for (INT i=0;aidl && i<cidl;i++)
                    {
                        aidl[i] = reinterpret_cast<LPITEMIDLIST>(DPA_FastGetPtr(dpaItems, i));
                    }
                    hr = psfDevice->GetUIObjectOf (NULL,
                                                   static_cast<UINT>(cidl),
                                                   const_cast<LPCITEMIDLIST*>(aidl),
                                                   IID_IDataObject,
                                                   NULL,
                                                   reinterpret_cast<LPVOID*>(&pdo));
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
            if (cidl && SUCCEEDED(hr))
            {
                hr = DoDeleteItem (hwndOwner, pdo, FALSE);
                //
                // If deletion via individual items fails, try WIA_CMD_DELETE_ALL_ITEMS
                //
                if (S_OK != hr)
                {
                    CComPtr<IWiaItem> pDevice;
                    Trace(TEXT("DoDeleteItem failed %x, using WIA_CMD_DELETE_ALL_ITEMS"), hr);
                    hr = GetDeviceFromDeviceId(bstrDeviceId, 
                                               IID_IWiaItem, 
                                               reinterpret_cast<LPVOID*>(&pDevice), 
                                               TRUE);
                    if (SUCCEEDED(hr))
                    {
                        hr = WiaUiUtil::IsDeviceCommandSupported(pDevice, WIA_CMD_DELETE_ALL_ITEMS) ? S_OK : E_FAIL;
                        if (SUCCEEDED(hr))
                        {
                            CComPtr<IWiaItem> pUnused;
                            hr = pDevice->DeviceCommand(0,
                                                        &WIA_CMD_DELETE_ALL_ITEMS,
                                                        &pUnused);
                            Trace(TEXT("DeviceCommand returned %x"), hr);
                            if (SUCCEEDED(hr))
                            {
                                IssueChangeNotifyForDevice(bstrDeviceId, SHCNE_UPDATEDIR, NULL);
                            }       
                        }
                    }
                }
            }
            if (aidl)
            {
                delete [] aidl;
            }

        }
    }
    DPA_DestroyCallback (dpaItems, _EnumDestroyCB, NULL);
    TraceLeaveResult (hr);
}

/*****************************************************************************

   DoGotoMyPics

   <Notes>

 *****************************************************************************/


HRESULT DoGotoMyPics( HWND hwndOwner, LPDATAOBJECT pDataObject )
{
    HRESULT         hr           = S_OK;


    TraceEnter( TRACE_VERBS, "DoGotoMyPics" );

    TraceLeaveResult( hr );

}

/*****************************************************************************

   DoSaveSndVerb

   Download the image's sound property to a file and save to the requested
   location.

 *****************************************************************************/


HRESULT
DoSaveSndVerb (HWND hwndOwner, LPDATAOBJECT pDataObject)
{
    HRESULT hr = E_FAIL;
    LPIDA pida = NULL;
    TraceEnter (TRACE_VERBS, "DoSaveSndVerb");
    if (SUCCEEDED(GetIDAFromDataObject (pDataObject, &pida)))
    {
        // There's the image pidl plus the audio property pidl
        TraceAssert (pida->cidl==2);
        LPITEMIDLIST pidl = reinterpret_cast<LPITEMIDLIST>(reinterpret_cast<LPBYTE>(pida) + pida->aoffset[1]);
        CComPtr<IWiaItem> pItem;
        TCHAR szFileName[MAX_PATH] = TEXT("\0");
        OPENFILENAME ofn;


        ZeroMemory (&ofn, sizeof(ofn));
        ofn.hInstance = GLOBAL_HINSTANCE;
        ofn.hwndOwner = hwndOwner;
        ofn.lpstrFile = szFileName;
        ofn.lpstrFilter = TEXT("WAV file\0*.wav\0");
        ofn.lpstrDefExt = TEXT("wav");
        ofn.lStructSize = sizeof(ofn);
        ofn.nMaxFile = ARRAYSIZE(szFileName);;
        ofn.Flags = OFN_OVERWRITEPROMPT;
        if (GetSaveFileName (&ofn))
        {
            Trace(TEXT("File name to save:%s"), szFileName);
            hr = IMGetItemFromIDL (pidl,&pItem, TRUE);
            if (SUCCEEDED(hr))
            {
                hr = SaveSoundToFile (pItem, szFileName);
            }
            if (FAILED(hr) && hr != E_ABORT)
            {
                UIErrors::ReportError(hwndOwner, GLOBAL_HINSTANCE, UIErrors::ErrCommunicationsFailure);
            }
        }
        else
        {
            Trace(TEXT("GetSaveFileName failed, error %d"), CommDlgExtendedError());
        }
    }
    if (pida)
    {
        LocalFree(pida);

    }
    TraceLeaveResult (hr);
}

/******************************************************************************

    DoPlaySndVerb

    Save the item's audio property to a temp file, play the sound, then delete the file
    We do this in a separate thread to keep the UI responsive and to guarantee the
    temp file gets cleaned up.

*******************************************************************************/

struct PSDATA
{
    HWND hwndOwner;
    LPITEMIDLIST pidl;
};

INT_PTR
PlaySndDlgProc (HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{
    INT_PTR iRet = TRUE;
    TraceEnter (TRACE_VERBS, "PlaySndDlgProc");
    PSDATA *pData;
    switch (msg)
    {
        case WM_INITDIALOG:
            SetWindowLongPtr (hwnd, DWLP_USER, lp);
            PostMessage (hwnd, WM_USER+1, 0, 0);
            break;

        case WM_USER+1:
        {

            // get a temp file name
            HRESULT hr;
            CComPtr<IWiaItem> pItem;
            TCHAR szTempFile[MAX_PATH] = TEXT("");
            GetTempPath (MAX_PATH, szTempFile);
            GetTempFileName (szTempFile, TEXT("psv"), 0, szTempFile);
            pData = reinterpret_cast<PSDATA*>(GetWindowLongPtr(hwnd, DWLP_USER));
            TraceAssert (pData);
            // save to the temp file
            IMGetItemFromIDL (pData->pidl, &pItem);
            hr = SaveSoundToFile( pItem, szTempFile);
            if (SUCCEEDED(hr))
            {
                CSimpleString strStatus(IDS_PLAYINGSOUND, GLOBAL_HINSTANCE);
                strStatus.SetWindowText (GetDlgItem(hwnd, IDC_SNDSTATUS));
                if (!PlaySound (szTempFile, NULL, SND_FILENAME | SND_NOWAIT))
                {
                    DWORD dw = GetLastError ();
                    hr = HRESULT_FROM_WIN32(dw);
                }
            }
            else
            {
                Trace(TEXT("SaveSoundToFile failed"));
            }
            DeleteFile (szTempFile);
            if (FAILED(hr))
            {
                UIErrors::ReportError (hwnd, GLOBAL_HINSTANCE, UIErrors::ErrCommunicationsFailure);
            }
            EndDialog (hwnd, 0);
        }
            break;
        default:
            iRet = FALSE;
            break;
    }
    TraceLeaveValue (iRet);
}

DWORD
PlaySndThread (LPVOID pData)
{
    TraceEnter (TRACE_VERBS, "PlaySndThread");
    if (SUCCEEDED(CoInitialize (NULL)))
    {
        LPITEMIDLIST pidl = reinterpret_cast<PSDATA*>(pData)->pidl;
        HWND hwnd = reinterpret_cast<PSDATA*>(pData)->hwndOwner;
        DialogBoxParam (GLOBAL_HINSTANCE,
                   MAKEINTRESOURCE(IDD_XFERSOUND),
                   hwnd,
                   PlaySndDlgProc,
                   reinterpret_cast<LPARAM>(pData));
        ILFree (pidl);
        delete reinterpret_cast<PSDATA*>(pData);
        TraceLeave();
        MyCoUninitialize ();
    }
    return 0;
}

HRESULT
DoPlaySndVerb (HWND hwndOwner, LPDATAOBJECT pDataObject)
{
    HRESULT hr = E_FAIL;
    LPIDA pida = NULL;
    TraceEnter (TRACE_VERBS, "DoPlaySndVerb");
    if (SUCCEEDED(GetIDAFromDataObject(pDataObject, &pida)))
    {
        // The image PIDL is always stored before the audio property pidl

        Trace(TEXT("GetIDAFromDataObject succeeded"));
        LPITEMIDLIST pidl = reinterpret_cast<LPITEMIDLIST>(reinterpret_cast<LPBYTE>(pida) + pida->aoffset[1]);
        PSDATA *pData = new PSDATA;
        if (pData)
        {
            HANDLE hThread;
            DWORD dw;
            pData->pidl = ILClone(pidl);
            pData->hwndOwner = hwndOwner;
            hThread = CreateThread (NULL, 0,
                                    PlaySndThread,
                                    reinterpret_cast<LPVOID>(pData),
                                    0, &dw);
            if (hThread)
            {
                hr = S_OK;
                CloseHandle (hThread);
            }
            else
            {
                delete pData;
            }
        }
    }
    else
    {
        Trace(TEXT("GetIDAFromDataObject failed"));
    }
    if (pida)
    {
        LocalFree (pida);
    }
    TraceLeaveResult (hr);
}


/******************************************************************************

    DoAcquireScanVerb

    Launch the handler for the chosen scanner's scan event

******************************************************************************/

static const CLSID CLSID_Manager = {0xD13E3F25,0x1688,0x45A0,{0x97,0x43,0x75,0x9E,0xB3,0x5C,0xDF,0x9A}};
HRESULT
DoAcquireScanVerb (HWND hwndOwner, LPDATAOBJECT pDataObject)
{
    HRESULT hr = E_FAIL;
    LPIDA pida = NULL;
    LPITEMIDLIST pidl;
    bool bUseCallback = true;
    CComPtr<IWiaEventCallback>pec;
    CComPtr<IWiaItem> pItem;
    WIA_EVENT_HANDLER weh = {0};

    TraceEnter (TRACE_VERBS, "DoAcquireScanVerb");
    hr = GetIDAFromDataObject (pDataObject, &pida);
    if (SUCCEEDED(hr))
    {

        TraceAssert (pida->cidl == 1);
        pidl = reinterpret_cast<LPITEMIDLIST>(reinterpret_cast<LPBYTE>(pida) + pida->aoffset[1]);
        hr = IMGetItemFromIDL (pidl, &pItem);
    }
    if (SUCCEEDED(hr))
    {
        if (FAILED(WiaUiUtil::GetDefaultEventHandler(pItem, WIA_EVENT_SCAN_IMAGE, &weh)))
        {
            weh.guid = CLSID_Manager;
        }
        if (weh.bstrCommandline && *(weh.bstrCommandline))
        {
            Trace(TEXT("Got a command line!"));
            bUseCallback = false;
            hr = S_OK;
        }
        else
        {
            // if the user has chosen "Do Nothing" as the default action for this event,
            // use the wizard.
            if (IsEqualGUID (weh.guid, WIA_EVENT_HANDLER_NO_ACTION))
            {
                weh.guid = CLSID_Manager;
            }

            TraceGUID ("Got a GUID:", weh.guid);
            hr = CoCreateInstance (weh.guid,
                                   NULL,
                                   CLSCTX_LOCAL_SERVER,
                                   IID_IWiaEventCallback,
                                   reinterpret_cast<LPVOID*>(&pec));
        }
    }

    if (SUCCEEDED(hr))
    {
        CSimpleStringWide strDeviceId;
        IMGetDeviceIdFromIDL (pidl, strDeviceId);
        if (bUseCallback)
        {

            ULONG  ulEventType;
            CSimpleStringWide strName;
            CSimpleString strEvent(SFVIDS_MH_ACQUIRE, GLOBAL_HINSTANCE);

            IMGetNameFromIDL (pidl, strName);
            ulEventType = WIA_ACTION_EVENT;
            CoAllowSetForegroundWindow (pec, NULL);
            hr = pec->ImageEventCallback(
                                        &GUID_ScanImage,
                                        CComBSTR(CSimpleStringConvert::WideString(strEvent).String()),                      // Event Description
                                        CComBSTR(strDeviceId),
                                        CComBSTR(strName),                      // Device Description
                                        StiDeviceTypeScanner,
                                        NULL,
                                        &ulEventType,
                                        0);
        }
        else
        {
            PROCESS_INFORMATION pi;
            STARTUPINFO si;


            TCHAR szCommand[MAX_PATH*2];
            ZeroMemory (&si, sizeof(si));
            ZeroMemory (&pi, sizeof(pi));
            si.cb = sizeof(si);
            si.wShowWindow = SW_SHOW;

            #ifdef UNICODE
            wcsncpy (szCommand, weh.bstrCommandline, ARRAYSIZE(szCommand));
            #else
            WideCharToMultiByte (CP_ACP, 0,
                                 weh.bstrCommandline, -1,
                                 szCommand, ARRAYSIZE(szCommand),
                                 NULL, NULL);
            #endif

            Trace(TEXT("Command line for STI app is %s"), szCommand);
            if (CreateProcess (NULL,szCommand,NULL, NULL, FALSE, 0, NULL, NULL, &si, &pi))
            {
                CloseHandle (pi.hProcess);
                CloseHandle (pi.hThread);
            }
        }
    }
    if (FAILED(hr))
    {
         // Inform the user
         UIErrors::ReportMessage(hwndOwner,
                                 GLOBAL_HINSTANCE,
                                 NULL,
                                 MAKEINTRESOURCE(IDS_NO_SCAN_CAPTION),
                                 MAKEINTRESOURCE(IDS_NO_SCAN),
                                 MB_OK);
    }
    if (weh.bstrDescription)
    {
        SysFreeString (weh.bstrDescription);
    }
    if (weh.bstrIcon)
    {
        SysFreeString (weh.bstrIcon);
    }
    if (weh.bstrName)
    {
        SysFreeString (weh.bstrName);
    }
    if (weh.bstrCommandline)
    {
        SysFreeString (weh.bstrCommandline);
    }
    if (pida)
    {
        LocalFree (pida);
    }
    TraceLeaveResult (hr);
}

HRESULT
DoWizardVerb(HWND hwndOwner, LPDATAOBJECT pDataObject)
{
    TraceEnter (TRACE_VERBS, "DoWizardVerb");
    LPIDA pida = NULL;
    HRESULT hr = GetIDAFromDataObject(pDataObject, &pida);
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidl = reinterpret_cast<LPITEMIDLIST>(reinterpret_cast<LPBYTE>(pida) + pida->aoffset[1]);

        //
        // Get the device ID
        //
        CSimpleStringWide strDeviceId;
        IMGetDeviceIdFromIDL( pidl, strDeviceId );

        //
        // Make sure this is a valid device ID
        //
        if (strDeviceId.Length())
        {
            //
            // Run the wizard
            //
            RunWizardAsync(strDeviceId);
        }
        else
        {
            hr = E_FAIL;
        }
    }

    if (pida)
    {
        LocalFree (pida);
    }
    TraceLeaveResult (hr);
}


/**************************************
TakePictureDlgProc

Takes the picture then closes the dialog


***************************************/

INT_PTR
TakePictureDlgProc (HWND hwnd, UINT msg, WPARAM wp, LPARAM lp)
{
    BOOL bRet = TRUE;
    BSTR strDeviceId;
    HRESULT hr;

    switch (msg)
    {
        case WM_INITDIALOG:
            SetWindowLongPtr (hwnd, DWLP_USER, lp);
            PostMessage (hwnd, WM_USER+10, 0, 0);
            break;

        case WM_USER+10:
            strDeviceId = reinterpret_cast<BSTR>(GetWindowLongPtr (hwnd, DWLP_USER));
            if (strDeviceId)
            {

                hr = TakeAPicture (strDeviceId);

                if (FAILED(hr))
                {
                    UIErrors::ReportMessage(hwnd,
                                            GLOBAL_HINSTANCE,
                                            NULL,
                                            MAKEINTRESOURCE(IDS_SNAPSHOTCAPTION),
                                            MAKEINTRESOURCE(IDS_SNAPSHOTERR));
                }
                SysFreeString (strDeviceId);
            }

            SetWindowLongPtr (hwnd, DWLP_USER, 0);
            DestroyWindow (hwnd);

            return TRUE;

        default:
            bRet= FALSE;
            break;
    }
    return bRet;
}

HRESULT
DoTakePictureVerb (HWND hwndOwner, LPDATAOBJECT pDataObject)
{
    HRESULT hr = E_FAIL;
    LPIDA pida = NULL;
    LPITEMIDLIST pidl;
    CSimpleStringWide strDeviceId;

    TraceEnter (TRACE_VERBS, "DoWizardVerb");
    hr = GetIDAFromDataObject (pDataObject, &pida);

    if (SUCCEEDED(hr))
    {
        HWND hDlg;
        TraceAssert (pida->cidl == 1);
        pidl = reinterpret_cast<LPITEMIDLIST>(reinterpret_cast<LPBYTE>(pida) + pida->aoffset[1]);
        TraceAssert (IsDeviceIDL(pidl));

        IMGetDeviceIdFromIDL (pidl, strDeviceId);
        hDlg = CreateDialogParam (GLOBAL_HINSTANCE,
                              MAKEINTRESOURCE(IDD_TAKEPICTURE),
                              NULL,
                              TakePictureDlgProc,
                              reinterpret_cast<LPARAM>(SysAllocString(strDeviceId)));
        if (hDlg)
        {
            hr = S_OK;
        }
        else
        {
            DWORD dw = GetLastError();
            hr = HRESULT_FROM_WIN32 (dw);
        }
        LocalFree (pida);
    }
    TraceLeaveResult (hr);
}

HRESULT DoPrintVerb (HWND hwndOwner, LPDATAOBJECT pDataObject )
{
    HRESULT hr;
    TraceEnter(TRACE_VERBS, "DoPrintVerb");

    CComPtr<IDropTarget> pDropTarget;
    hr = CoCreateInstance( CLSID_PrintPhotosDropTarget, NULL, CLSCTX_INPROC_SERVER, IID_IDropTarget, (void**)&pDropTarget );
    if (SUCCEEDED(hr))
    {
        //
        // Perform the drop
        //
        DWORD dwEffect = DROPEFFECT_LINK | DROPEFFECT_MOVE | DROPEFFECT_COPY;
        POINTL pt = { 0, 0 };
        hr = pDropTarget->Drop( pDataObject, 0, pt, &dwEffect );
    }

    TraceLeaveResult(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shimgvwr\imageview.cpp ===
// ImageView.cpp : implementation of the CImageView class
//

#include "stdafx.h"
#include "shimgvwr.h"

#include "ImageDoc.h"
#include "ImageView.h"
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CImageView

IMPLEMENT_DYNCREATE(CImageView, CView)

BEGIN_MESSAGE_MAP(CImageView, CView)
    //{{AFX_MSG_MAP(CImageView)
    ON_WM_CREATE()
    ON_WM_SIZE()
    ON_COMMAND(ID_VIEW_ACTUALSIZE, OnViewActualsize)
    ON_UPDATE_COMMAND_UI(ID_VIEW_ACTUALSIZE, OnUpdateViewMenu)
    ON_COMMAND(ID_VIEW_BESTFIT, OnViewBestfit)
    ON_UPDATE_COMMAND_UI(ID_VIEW_BESTFIT, OnUpdateViewMenu)
    ON_COMMAND(ID_VIEW_SLIDESHOW, OnViewSlideshow)
    ON_UPDATE_COMMAND_UI(ID_VIEW_SLIDESHOW, OnUpdateViewMenu)
    ON_COMMAND(ID_VIEW_ZOOM_IN, OnViewZoomIn)
    ON_UPDATE_COMMAND_UI(ID_VIEW_ZOOM_IN, OnUpdateViewMenu)
    ON_COMMAND(ID_VIEW_ZOOM_OUT, OnViewZoomOut)
    ON_UPDATE_COMMAND_UI(ID_VIEW_ZOOM_OUT, OnUpdateViewMenu)
    ON_UPDATE_COMMAND_UI(ID_ROTATE_90, OnUpdateViewMenu)
    ON_UPDATE_COMMAND_UI(ID_ROTATE_CLOCKWISE, OnUpdateViewMenu)
    ON_UPDATE_COMMAND_UI(ID_ROTATE_COUNTER, OnUpdateViewMenu)
    ON_COMMAND(ID_ROTATE_CLOCKWISE, OnEditRotateClockwise)
    ON_COMMAND(ID_ROTATE_COUNTER, OnEditRotateCounter)
    
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CImageView construction/destruction

CImageView::CImageView()
{
    m_bBestFit = true;

}

CImageView::~CImageView()
{
}

BOOL CImageView::PreCreateWindow(CREATESTRUCT& cs)
{
    // TODO: Modify the Window class or styles here by modifying
    //  the CREATESTRUCT cs

    return CView::PreCreateWindow(cs);
}

/////////////////////////////////////////////////////////////////////////////
// CImageView drawing

void CImageView::OnDraw(CDC* pDC)
{
    CImageDoc* pDoc = GetDocument();
    ASSERT_VALID(pDoc);
    // TODO: add draw code for native data here
}

/////////////////////////////////////////////////////////////////////////////
// CImageView diagnostics

#ifdef _DEBUG
void CImageView::AssertValid() const
{
    CView::AssertValid();
}

void CImageView::Dump(CDumpContext& dc) const
{
    CView::Dump(dc);
}

CImageDoc* CImageView::GetDocument() // non-debug version is inline
{
    ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CImageDoc)));
    return (CImageDoc*)m_pDocument;
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CImageView message handlers

BEGIN_EVENTSINK_MAP(CImageView, CView)
    //{{AFX_EVENTSINK_MAP(CImageView)
    ON_EVENT(CImageView, ID_PREVCTRL, 3 /* OnError */, OnErrorPrevctrl, VTS_NONE)
    ON_EVENT(CImageView, ID_PREVCTRL, 2 /* OnPreviewReady */, OnPreviewReady, VTS_NONE)
    ON_EVENT(CImageView, ID_PREVCTRL, 4 /* OnBestFitPress */, OnBestFitPress, VTS_NONE)
    ON_EVENT(CImageView, ID_PREVCTRL, 5 /* OnActualSizePress */, OnActualSizePress, VTS_NONE)

    //}}AFX_EVENTSINK_MAP
END_EVENTSINK_MAP()

void CImageView::OnErrorPrevctrl() 
{
    // TODO: Add your control notification handler code here
    
}

void CImageView::OnPreviewReady() 
{
    // TODO: Add your control notification handler code here
    
}

void CImageView::OnBestFitPress()
{
    m_bBestFit = true;
}

void CImageView::OnActualSizePress()
{
    m_bBestFit = false;
}



void CImageView::OnInitialUpdate() 
{
    CView::OnInitialUpdate();
    
}

int CImageView::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
    if (CView::OnCreate(lpCreateStruct) == -1)
        return -1;
    DWORD dwToolbarMask = 0x43;
    CMemFile ParamFile(reinterpret_cast<BYTE*>(&dwToolbarMask), sizeof(dwToolbarMask));
    if (!m_PrevCtrl.Create (NULL, WS_CHILD  | WS_VISIBLE,
                       CRect (), this, ID_PREVCTRL, &ParamFile, FALSE))
    {
        return -1;
    }
    m_PrevCtrl.ShowFile (dynamic_cast<CImageDoc*>(m_pDocument)->GetImagePathName(), 1);
    return 0;
}

void CImageView::OnSize(UINT nType, int cx, int cy) 
{
    CView::OnSize(nType, cx, cy);
    
    m_PrevCtrl.MoveWindow (0, 0, cx , cy);
    m_PrevCtrl.UpdateWindow ();
    
}

void CImageView::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint) 
{
    m_PrevCtrl.ShowFile (dynamic_cast<CImageDoc*>(m_pDocument)->GetImagePathName(), 1);
        
}

void CImageView::OnViewActualsize() 
{
    OnActualSizePress();
    m_PrevCtrl.ActualSize();
    
}

void CImageView::OnUpdateViewMenu(CCmdUI* pCmdUI) 
{
    
    switch (pCmdUI->m_nID)
    {
        case ID_ROTATE_90:
        case ID_ROTATE_COUNTER:
        case ID_ROTATE_CLOCKWISE:
            // eventually, ask the control if rotate is valid for this image
            pCmdUI->Enable( m_pDocument->GetPathName().GetLength());
            return;
        case ID_VIEW_BESTFIT:
            pCmdUI->SetCheck(m_bBestFit?1:0);            
            pCmdUI->Enable();
            return;
        case ID_VIEW_ACTUALSIZE:
            pCmdUI->SetCheck(m_bBestFit?0:1);
            pCmdUI->Enable();
            return;

        default:
            // most view menu items are only available for images that have been saved to disk
            pCmdUI->Enable(!(m_pDocument->IsModified()));
            break;
    }
}

void CImageView::OnViewBestfit() 
{
    m_PrevCtrl.BestFit();
    OnBestFitPress();    
}


void CImageView::OnViewSlideshow() 
{
    m_PrevCtrl.SlideShow();
    
}

void CImageView::OnViewZoomIn() 
{
    m_PrevCtrl.Zoom(1);
    
}

void CImageView::OnViewZoomOut() 
{
 
    m_PrevCtrl.Zoom(-1);    
}

void CImageView::OnEditRotateClockwise()
{
    m_PrevCtrl.Rotate (90);
}

void CImageView::OnEditRotateCounter()
{
    m_PrevCtrl.Rotate (270);
}

HRESULT CImageView::SaveImageAs (LPCTSTR lpszPath)
{
    TRY 
    {
        m_PrevCtrl.SaveAs(CComBSTR(lpszPath));
    }
    CATCH (COleDispatchException ,e)
    
    {
        
        return ResultFromScode (e->m_scError);
    } 
    END_CATCH
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shimgvwr\imagedoc.h ===
// ImageDoc.h : interface of the CImageDoc class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_IMAGEDOC_H__7318097E_E558_4694_BB26_89E044E0CE28__INCLUDED_)
#define AFX_IMAGEDOC_H__7318097E_E558_4694_BB26_89E044E0CE28__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


class CImageDoc : public CDocument
{
protected: // create from serialization only
    CImageDoc();
    DECLARE_DYNCREATE(CImageDoc)

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CImageDoc)
    public:
    virtual BOOL OnNewDocument();
    virtual void Serialize(CArchive& ar);
    virtual BOOL OnOpenDocument(LPCTSTR lpszPathName);
    virtual BOOL OnSaveDocument(LPCTSTR lpszPathName);
    
    //}}AFX_VIRTUAL

// Implementation
public:
    const CString& GetImagePathName() const;
    
    virtual ~CImageDoc();
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif
    void SetTempFileName (const CString &strTempFile);
protected:

// Generated message map functions
   

protected:
    //{{AFX_MSG(CImageDoc)
     afx_msg void OnFileScan();
    afx_msg void OnFileProperties ();
    afx_msg void OnFileSaveAs();
    afx_msg void OnFilePaperTile ();
    afx_msg void OnFilePaperCenter ();
    afx_msg void OnUpdateFileScan(CCmdUI* pCmdUI);
    afx_msg void OnUpdateFileMenu (CCmdUI* pCmdUI);
    // NOTE - the ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
private:
    CString m_strTempPath;
    bool m_bUseTempPath;

    CComPtr<IWiaDevMgr> m_pDevMgr; // WIA

    bool bWIADeviceInstalled ();
    void SetWallpaper (bool bTile);

    void DelTempFile ();
    void GetDevMgr ();
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.
CString GetExtension (const TCHAR *szFilePath);
void MySplitPath (const TCHAR *szPath, TCHAR *szDrive, TCHAR *szDir, TCHAR *szName, TCHAR *szExt);
CString StripExtension(const TCHAR* szFilePath);

#endif // !defined(AFX_IMAGEDOC_H__7318097E_E558_4694_BB26_89E044E0CE28__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shimgvwr\imageview.h ===
// ImageView.h : interface of the CImageView class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_IMAGEVIEW_H__D6029136_FBEC_4C9D_A161_35D6A1DF87C1__INCLUDED_)
#define AFX_IMAGEVIEW_H__D6029136_FBEC_4C9D_A161_35D6A1DF87C1__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000


class CImageView : public CView
{
protected: // create from serialization only
    CImageView();
    DECLARE_DYNCREATE(CImageView)

// Attributes
public:
    CImageDoc* GetDocument();

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CImageView)
    public:
    virtual void OnDraw(CDC* pDC);  // overridden to draw this view
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    virtual void OnInitialUpdate();
    protected:
    virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CImageView();
    HRESULT SaveImageAs (LPCTSTR lpszPath);
#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
    //{{AFX_MSG(CImageView)
    afx_msg void OnBestFitPress();
    afx_msg void OnActualSizePress();
    afx_msg void OnErrorPrevctrl();
    afx_msg void OnPreviewReady();
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnSize(UINT nType, int cx, int cy);
    afx_msg void OnViewActualsize();
    afx_msg void OnUpdateViewMenu(CCmdUI* pCmdUI);
    afx_msg void OnViewBestfit();    
    afx_msg void OnViewSlideshow();    
    afx_msg void OnViewZoomIn();    
    afx_msg void OnViewZoomOut();    
    afx_msg void OnEditRotateCounter();
    afx_msg void OnEditRotateClockwise();
    DECLARE_EVENTSINK_MAP()
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    CPreview3 m_PrevCtrl;
    bool m_bBestFit;
};

#ifndef _DEBUG  // debug version in ImageView.cpp
inline CImageDoc* CImageView::GetDocument()
   { return (CImageDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_IMAGEVIEW_H__D6029136_FBEC_4C9D_A161_35D6A1DF87C1__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shimgvwr\mainfrm.h ===
// MainFrm.h : interface of the CMainFrame class
//
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_MAINFRM_H__7D0D3F58_A3DD_48F6_8700_4549F2AD6207__INCLUDED_)
#define AFX_MAINFRM_H__7D0D3F58_A3DD_48F6_8700_4549F2AD6207__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

class CMainFrame : public CFrameWnd
{
    
protected: // create from serialization only
    CMainFrame();
    DECLARE_DYNCREATE(CMainFrame)

// Attributes
public:

// Operations
public:

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CMainFrame)
    virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
    //}}AFX_VIRTUAL

// Implementation
public:
    virtual ~CMainFrame();

#ifdef _DEBUG
    virtual void AssertValid() const;
    virtual void Dump(CDumpContext& dc) const;
#endif

protected:  // control bar embedded members
    CStatusBar  m_wndStatusBar;
    CToolBar    m_wndToolBar;

// Generated message map functions
protected:
    //{{AFX_MSG(CMainFrame)
    afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg LRESULT OnDDEInitiate(WPARAM wp, LPARAM lp);
    afx_msg LRESULT OnDDEExecute(WPARAM wp, LPARAM lp);
    afx_msg LRESULT OnDDETerminate(WPARAM wp, LPARAM lp);
        // NOTE - the ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
private:

    ATOM m_atomApp;
    ATOM m_atomTopic;
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINFRM_H__7D0D3F58_A3DD_48F6_8700_4549F2AD6207__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shimgvwr\mainfrm.cpp ===
// MainFrm.cpp : implementation of the CMainFrame class
//

#include "stdafx.h"
#include "shimgvwr.h"

#include "MainFrm.h"
#include "imagedoc.h"
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
extern CPreviewApp theApp;
static const TCHAR c_szDDEAppName[]= TEXT("ShellImageView");
static const TCHAR c_szDDETopic[] =  TEXT("ViewImage");

/////////////////////////////////////////////////////////////////////////////
// CMainFrame

IMPLEMENT_DYNCREATE(CMainFrame, CFrameWnd)

BEGIN_MESSAGE_MAP(CMainFrame, CFrameWnd)
    //{{AFX_MSG_MAP(CMainFrame)
       
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    ON_WM_CREATE()
    ON_MESSAGE(WM_DDE_INITIATE, OnDDEInitiate)
    ON_MESSAGE(WM_DDE_EXECUTE, OnDDEExecute)
    ON_MESSAGE(WM_DDE_TERMINATE, OnDDETerminate)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

static UINT indicators[] =
{
    ID_SEPARATOR,           // status line indicator
    ID_INDICATOR_CAPS,
    ID_INDICATOR_NUM,
    ID_INDICATOR_SCRL,
};

/////////////////////////////////////////////////////////////////////////////
// CMainFrame construction/destruction

CMainFrame::CMainFrame()
{
    m_atomApp = m_atomTopic = NULL;
    
}

CMainFrame::~CMainFrame()
{
}

int CMainFrame::OnCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
        return -1;
    
/*    if (!m_wndToolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE | CBRS_TOP
        | CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) ||
        !m_wndToolBar.LoadToolBar(IDR_MAINFRAME))
    {
        TRACE0("Failed to create toolbar\n");
        return -1;      // fail to create
    }
*/
    if (!m_wndStatusBar.Create(this) ||
        !m_wndStatusBar.SetIndicators(indicators,
          sizeof(indicators)/sizeof(UINT)))
    {
        TRACE0("Failed to create status bar\n");
        return -1;      // fail to create
    }
   /* m_wndToolBar.EnableDocking(CBRS_ALIGN_ANY);
    EnableDocking(CBRS_ALIGN_ANY);
    DockControlBar(&m_wndToolBar);
*/
    HWND *phwnd = reinterpret_cast<HWND*>(MapViewOfFile (theApp.m_hFileMap, FILE_MAP_WRITE, 0, 0, sizeof(HWND)));
    if (phwnd )
    {
        if (!*phwnd)
        {        
            *phwnd = m_hWnd;
        }
        UnmapViewOfFile (phwnd);
    }
    return 0;
}

BOOL CMainFrame::PreCreateWindow(CREATESTRUCT& cs)
{
    m_atomApp = GlobalAddAtom(c_szDDEAppName);
    m_atomTopic = GlobalAddAtom(c_szDDETopic); 

    if( !CFrameWnd::PreCreateWindow(cs) )
        return FALSE;
    // TODO: Modify the Window class or styles here by modifying
    //  the CREATESTRUCT cs

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers


LRESULT 
CMainFrame::OnDDEInitiate(WPARAM wParam, LPARAM lParam)
{
        // if we care about DDE then we have registered our atoms:
    if (m_atomApp && m_atomTopic)
    { 
        ATOM atomApp = LOWORD(lParam);
        ATOM atomTopic = HIWORD(lParam);

        if (atomApp == m_atomApp)
        {
            if (NULL == atomTopic || atomTopic == m_atomTopic)
            {
                // if (NULL == atomTopic) send an ACK for every topic we know about.
                // if (atomTopic == m_atomTopic) send an ACK for this topic.
                // since we only know about one topic these two code paths are the same.
                ::SendMessage((HWND)wParam, WM_DDE_ACK, (WPARAM)m_hWnd, MAKELONG(m_atomApp,m_atomTopic));
            }
        }
    }
    return 0;

}
    
LRESULT 
CMainFrame::OnDDEExecute(WPARAM wParam, LPARAM lParam)
{
    LPTSTR pszCommand = (LPTSTR)GlobalLock((HGLOBAL)lParam);

    if (pszCommand)
    {
        if (0 == StrCmpNI(pszCommand, TEXT("[open("), 6))
        {
            TCHAR szFilename[MAX_PATH];
            StrCpyN(szFilename, pszCommand+6, ARRAYSIZE(szFilename));

            // find the ending ')' and make it a NULL
            LPTSTR pszEnd = StrRChr(szFilename, NULL, TEXT(')'));
            if (pszEnd)
                *pszEnd = NULL;

    
            theApp.OpenDocumentFile(szFilename);
        
        }
    GlobalUnlock((HGLOBAL)lParam);
    }

    // Post an ACK back to the calling client, 0x8000=fAck
    LPARAM lpOut = ReuseDDElParam(lParam, WM_DDE_EXECUTE, WM_DDE_ACK, 0x00008000, (WPARAM)lParam);
    ::PostMessage((HWND)wParam, WM_DDE_ACK, (WPARAM)m_hWnd, lpOut);

    return 0;

}

LRESULT 
CMainFrame::OnDDETerminate(WPARAM wParam, LPARAM lParam)
{
    ::PostMessage((HWND)wParam, WM_DDE_TERMINATE, (WPARAM)m_hWnd, 0);
    return 0;
}
/////////////////////////////////////////////////////////////////////////////
// CMainFrame diagnostics

#ifdef _DEBUG
void CMainFrame::AssertValid() const
{
    CFrameWnd::AssertValid();
}

void CMainFrame::Dump(CDumpContext& dc) const
{
    CFrameWnd::Dump(dc);
}

#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
// CMainFrame message handlers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shimgvwr\preview.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "preview.h"

/////////////////////////////////////////////////////////////////////////////
// CPreview

IMPLEMENT_DYNCREATE(CPreview, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CPreview properties

/////////////////////////////////////////////////////////////////////////////
// CPreview operations

void CPreview::ShowFile(LPCTSTR bstrFileName, long iSelectCount)
{
	static BYTE parms[] =
		VTS_BSTR VTS_I4;
	InvokeHelper(0x1, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 bstrFileName, iSelectCount);
}

long CPreview::GetPrintable()
{
	long result;
	InvokeHelper(0x2, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CPreview::SetPrintable(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x2, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long CPreview::GetCxImage()
{
	long result;
	InvokeHelper(0x3, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

long CPreview::GetCyImage()
{
	long result;
	InvokeHelper(0x4, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void CPreview::Show(const VARIANT& var)
{
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x5, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 &var);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shimgvwr\ofn.cpp ===
#if      !defined(WINVER) || (WINVER < 0x0500)
#undef   WINVER
#pragma message("Defining WINVER as 0x0500")
#define  WINVER 0x0500
#endif //WINVER

#if      !defined(_WIN32_WINNT) || (_WIN32_WINNT < 0x0500)
#undef   _WIN32_WINNT
#pragma message("Defining _WIN32_WINNT as 0x0500")
#define  _WIN32_WINNT 0x0500
#endif //_WIN32_WINNT

#if      !defined(_WIN32_WINDOWS) || (_WIN32_WINDOWS < 0x0500)
#undef   _WIN32_WINDOWS
#pragma message("Defining _WIN32_WINDOWS as 0x0500")
#define  _WIN32_WINDOWS 0x0500
#endif //_WIN32_WINDOWS

#if      !defined(_WIN32_IE) || (_WIN32_IE < 0x0500)
#undef   _WIN32_IE
#pragma message("Defining _WIN32_IE as 0x0500")
#define  _WIN32_IE 0x0500
#endif //_WIN32_IE

#include <windows.h>
#include <commdlg.h>
#include <cderr.h>

#include "ofn.h"

////////////////////////////////////////////////////////////////////////////
// 

COpenFileName::COpenFileName(BOOL bOpenFileDialog)
{
    m_bOpenFileDialog = bOpenFileDialog;

    m_pofn = new OPENFILENAME;

    if (m_pofn) {

        memset(m_pofn, 0, sizeof(OPENFILENAME));
        m_pofn->lStructSize = sizeof(OPENFILENAME);
    }
}

COpenFileName::~COpenFileName()
{
    delete m_pofn;
}

int COpenFileName::DoModal()
{
    int nResult;

    if (m_bOpenFileDialog)
        nResult = ::GetOpenFileName(m_pofn);
    else
        nResult = ::GetSaveFileName(m_pofn);

    if (!nResult && (CDERR_STRUCTSIZE == CommDlgExtendedError())) {

        // if comdlg32 does not recognize the OPENFILENAME size 
        // retry with the old (ver 4) struct size

        m_pofn->lStructSize = OPENFILENAME_SIZE_VERSION_400;
        
        if (m_bOpenFileDialog)
            nResult = ::GetOpenFileName(m_pofn);
        else
            nResult = ::GetSaveFileName(m_pofn);
    }

    return nResult ? nResult : IDCANCEL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shimgvwr\preview3.cpp ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.


#include "stdafx.h"
#include "preview3.h"

/////////////////////////////////////////////////////////////////////////////
// CPreview3

IMPLEMENT_DYNCREATE(CPreview3, CWnd)

/////////////////////////////////////////////////////////////////////////////
// CPreview3 properties

/////////////////////////////////////////////////////////////////////////////
// CPreview3 operations

void CPreview3::ShowFile(LPCTSTR bstrFileName, long iSelectCount)
{
    static BYTE parms[] =
        VTS_BSTR VTS_I4;
    InvokeHelper(0x1, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
         bstrFileName, iSelectCount);
}

long CPreview3::GetPrintable()
{
    long result;
    InvokeHelper(0x2, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
    return result;
}

void CPreview3::SetPrintable(long nNewValue)
{
    static BYTE parms[] =
        VTS_I4;
    InvokeHelper(0x2, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
         nNewValue);
}

long CPreview3::GetCxImage()
{
    long result;
    InvokeHelper(0x3, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
    return result;
}

long CPreview3::GetCyImage()
{
    long result;
    InvokeHelper(0x4, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
    return result;
}

void CPreview3::Show(const VARIANT& var)
{
    static BYTE parms[] =
        VTS_VARIANT;
    InvokeHelper(0x5, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
         &var);
}

void CPreview3::Zoom(long iSelectCount)
{
    static BYTE parms[] =
        VTS_I4;
    InvokeHelper(0x60030000, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
         iSelectCount);
}

void CPreview3::BestFit()
{
    InvokeHelper(0x60030001, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CPreview3::ActualSize()
{
    InvokeHelper(0x60030002, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CPreview3::SlideShow()
{
    InvokeHelper(0x60030003, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CPreview3::Rotate(unsigned long dwAngle)
{
    static BYTE parms[] =
        VTS_I4;
    InvokeHelper(0x60040000, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
         dwAngle);
}

void CPreview3::IsValidVerb(LPCTSTR bstrVerb)
{
    static BYTE parms[] =
        VTS_BSTR;
    InvokeHelper(0x60040001, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
         bstrVerb);
}

void CPreview3::Commit()
{
    InvokeHelper(0x60040002, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void CPreview3::SaveAs(LPCTSTR bstrPath)
{
    static BYTE parms[] =
        VTS_BSTR;
    
    
        InvokeHelper(0x60040003, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
                     bstrPath);
    
    
    
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shimgvwr\preview.h ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CPreview wrapper class

class CPreview : public CWnd
{
protected:
	DECLARE_DYNCREATE(CPreview)
public:
	CLSID const& GetClsid()
	{
		static CLSID const clsid
			= { 0x50f16b26, 0x467e, 0x11d1, { 0x82, 0x71, 0x0, 0xc0, 0x4f, 0xc3, 0x18, 0x3b } };
		return clsid;
	}
	virtual BOOL Create(LPCTSTR lpszClassName,
		LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect,
		CWnd* pParentWnd, UINT nID,
		CCreateContext* pContext = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
		const RECT& rect, CWnd* pParentWnd, UINT nID,
		CFile* pPersist = NULL, BOOL bStorage = FALSE,
		BSTR bstrLicKey = NULL)
	{ return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
		pPersist, bStorage, bstrLicKey); }

// Attributes
public:

// Operations
public:
	void ShowFile(LPCTSTR bstrFileName, long iSelectCount);
	long GetPrintable();
	void SetPrintable(long nNewValue);
	long GetCxImage();
	long GetCyImage();
	void Show(const VARIANT& var);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shimgvwr\ofn.h ===
#ifndef OFN_H
#define OFN_H

#pragma pack(push, 8)

class COpenFileName
{
public:

    COpenFileName(BOOL bOpenFileDialog);
    ~COpenFileName();

    int DoModal();

    BOOL m_bOpenFileDialog;

    OPENFILENAME *m_pofn;
};

#pragma pack(pop)

#endif //OFN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shimgvwr\preview3.h ===
// Machine generated IDispatch wrapper class(es) created by Microsoft Visual C++

// NOTE: Do not modify the contents of this file.  If this class is regenerated by
//  Microsoft Visual C++, your modifications will be overwritten.

/////////////////////////////////////////////////////////////////////////////
// CPreview3 wrapper class
#ifndef _CPREVIEW3_H_
#define _CPREVIEW3_H_

class CPreview3 : public CWnd
{
protected:
    DECLARE_DYNCREATE(CPreview3)
public:
    CLSID const& GetClsid()
    {
        static CLSID const clsid
            = { 0x50f16b26, 0x467e, 0x11d1, { 0x82, 0x71, 0x0, 0xc0, 0x4f, 0xc3, 0x18, 0x3b } };
        return clsid;
    }
    virtual BOOL Create(LPCTSTR lpszClassName,
        LPCTSTR lpszWindowName, DWORD dwStyle,
        const RECT& rect,
        CWnd* pParentWnd, UINT nID,
        CCreateContext* pContext = NULL)
    { return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID); }

    BOOL Create(LPCTSTR lpszWindowName, DWORD dwStyle,
        const RECT& rect, CWnd* pParentWnd, UINT nID,
        CFile* pPersist = NULL, BOOL bStorage = FALSE,
        BSTR bstrLicKey = NULL)
    { return CreateControl(GetClsid(), lpszWindowName, dwStyle, rect, pParentWnd, nID,
        pPersist, bStorage, bstrLicKey); }

// Attributes
public:

// Operations
public:
    void ShowFile(LPCTSTR bstrFileName, long iSelectCount);
    long GetPrintable();
    void SetPrintable(long nNewValue);
    long GetCxImage();
    long GetCyImage();
    void Show(const VARIANT& var);
    void Zoom(long iSelectCount);
    void BestFit();
    void ActualSize();
    void SlideShow();
    void Rotate(unsigned long dwAngle);
    void IsValidVerb(LPCTSTR bstrVerb);
    void Commit();
    void SaveAs(LPCTSTR bstrPath);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shimgvwr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by shimgvwr.rc
//
#define IDD_ABOUTBOX                    100
#define IDR_MAINFRAME                   128
#define IDR_SHIMGVTYPE                  129
#define ID_PREVCTRL                     200

#define IDS_ALLFILES                    130 

#define ID_FILE_SCAN                    32771
#define ID_FILE_PROPERTIES              32772
#define ID_FILE_PAPER_TILE              32773
#define ID_FILE_PAPER_CENTER            32774
#define ID_VIEW_ZOOM_IN                 32775
#define ID_VIEW_ZOOM_OUT                32776
#define ID_VIEW_BESTFIT                 32777
#define ID_VIEW_ACTUALSIZE              32778
#define ID_VIEW_SLIDESHOW               32779
#define ID_ROTATE_90                    32782
#define ID_ROTATE_CLOCKWISE             32783
#define ID_ROTATE_COUNTER               32784


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_3D_CONTROLS                     1
#define _APS_NEXT_RESOURCE_VALUE        133
#define _APS_NEXT_COMMAND_VALUE         32785
#define _APS_NEXT_CONTROL_VALUE         1003
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shimgvwr\shimgvw.cpp ===
// Machine generated IDispatch wrapper class(es) created with ClassWizard

#include "stdafx.h"
#include "shimgvw.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif



/////////////////////////////////////////////////////////////////////////////
// IPreview properties

/////////////////////////////////////////////////////////////////////////////
// IPreview operations

void IPreview::ShowFile(LPCTSTR bstrFileName, long iSelectCount)
{
	static BYTE parms[] =
		VTS_BSTR VTS_I4;
	InvokeHelper(0x1, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 bstrFileName, iSelectCount);
}

long IPreview::GetPrintable()
{
	long result;
	InvokeHelper(0x2, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void IPreview::SetPrintable(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x2, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long IPreview::GetCxImage()
{
	long result;
	InvokeHelper(0x3, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

long IPreview::GetCyImage()
{
	long result;
	InvokeHelper(0x4, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void IPreview::Show(const VARIANT& var)
{
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x5, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 &var);
}


/////////////////////////////////////////////////////////////////////////////
// IPreview2 properties

/////////////////////////////////////////////////////////////////////////////
// IPreview2 operations

void IPreview2::ShowFile(LPCTSTR bstrFileName, long iSelectCount)
{
	static BYTE parms[] =
		VTS_BSTR VTS_I4;
	InvokeHelper(0x1, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 bstrFileName, iSelectCount);
}

long IPreview2::GetPrintable()
{
	long result;
	InvokeHelper(0x2, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void IPreview2::SetPrintable(long nNewValue)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x2, DISPATCH_PROPERTYPUT, VT_EMPTY, NULL, parms,
		 nNewValue);
}

long IPreview2::GetCxImage()
{
	long result;
	InvokeHelper(0x3, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

long IPreview2::GetCyImage()
{
	long result;
	InvokeHelper(0x4, DISPATCH_PROPERTYGET, VT_I4, (void*)&result, NULL);
	return result;
}

void IPreview2::Show(const VARIANT& var)
{
	static BYTE parms[] =
		VTS_VARIANT;
	InvokeHelper(0x5, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 &var);
}

void IPreview2::Zoom(long iSelectCount)
{
	static BYTE parms[] =
		VTS_I4;
	InvokeHelper(0x60030000, DISPATCH_METHOD, VT_EMPTY, NULL, parms,
		 iSelectCount);
}

void IPreview2::BestFit()
{
	InvokeHelper(0x60030001, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void IPreview2::ActualSize()
{
	InvokeHelper(0x60030002, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}

void IPreview2::SlideShow()
{
	InvokeHelper(0x60030003, DISPATCH_METHOD, VT_EMPTY, NULL, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shimgvwr\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	shimgvwr.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shimgvwr\shimgvwr.h ===
// shimgvwr.h : main header file for the SHIMGVWR application
//

#if !defined(AFX_SHIMGVWR_H__2C976141_B6D5_4641_A0A7_93C149CE4993__INCLUDED_)
#define AFX_SHIMGVWR_H__2C976141_B6D5_4641_A0A7_93C149CE4993__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef __AFXWIN_H__
    #error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CPreviewApp:
// See shimgvwr.cpp for the implementation of this class
//

class CPreviewApp : public CWinApp
{
public:
    CPreviewApp();
    ~CPreviewApp();
    HANDLE m_hFileMap;

    BOOL DoPromptFileName( CString& fileName, UINT nIDSTitle, DWORD lFlags,
                               BOOL bOpenFileDialog );
// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CPreviewApp)
    public:
    virtual BOOL InitInstance();
    
    //}}AFX_VIRTUAL

// Implementation
    //{{AFX_MSG(CPreviewApp)
    afx_msg void OnAppAbout();
    
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    bool PrevInstance (const CString &strFile);
    afx_msg void OnFileOpen ();
    
    
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_SHIMGVWR_H__2C976141_B6D5_4641_A0A7_93C149CE4993__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shimgvwr\sources.inc ===
MAJORCOMP=shell
MINORCOMP=imaging

TARGETNAME=shimgvwr
TARGETPATH=obj
TARGETTYPE=PROGRAM

UMTYPE=windows

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\stdafx.h

USE_NATIVE_EH=1
USE_MFCUNICODE=1
USE_STATIC_ATL=1
ATL_VER=30
USE_RTTI=1

C_DEFINES=$(C_DEFINES) -DUNICODE -D_UNICODE

INCLUDES=..;..\res;$(INCLUDES);$(SDK_INC_PATH)\gdiplus

SOURCES= ..\shimgvwr.rc \
         ..\ImageDoc.cpp \
         ..\ImageView.cpp \
         ..\MainFrm.cpp \
         ..\preview3.cpp \
         ..\shimgvw.cpp\
         ..\shimgvwr.cpp
         

SYNCHRONIZE_DRAIN=1

TARGETLIBS=                          \
        $(TARGETLIBS)                \
        $(SDK_LIB_PATH)\comdlg32.lib \
        $(SDK_LIB_PATH)\ole32.lib    \
        $(SDK_LIB_PATH)\oleaut32.lib \
        $(SDK_LIB_PATH)\winspool.lib \
        $(SDK_LIB_PATH)\uuid.lib     \
        $(SDK_LIB_PATH)\shell32.lib  \
        $(SDK_LIB_PATH)\htmlhelp.lib \
        $(SDK_LIB_PATH)\wiaguid.lib \
        $(SDK_LIB_PATH)\shlwapi.lib \
        $(SDK_LIB_PATH)\gdiplus.lib \
        ..\ofn\$O\ofn.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shimgvwr\shimgvw.h ===
// Machine generated IDispatch wrapper class(es) created with ClassWizard
/////////////////////////////////////////////////////////////////////////////
// IPreview wrapper class

class IPreview : public COleDispatchDriver
{
public:
	IPreview() {}		// Calls COleDispatchDriver default constructor
	IPreview(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	IPreview(const IPreview& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	void ShowFile(LPCTSTR bstrFileName, long iSelectCount);
	long GetPrintable();
	void SetPrintable(long nNewValue);
	long GetCxImage();
	long GetCyImage();
	void Show(const VARIANT& var);
};
/////////////////////////////////////////////////////////////////////////////
// IPreview2 wrapper class

class IPreview2 : public COleDispatchDriver
{
public:
	IPreview2() {}		// Calls COleDispatchDriver default constructor
	IPreview2(LPDISPATCH pDispatch) : COleDispatchDriver(pDispatch) {}
	IPreview2(const IPreview2& dispatchSrc) : COleDispatchDriver(dispatchSrc) {}

// Attributes
public:

// Operations
public:
	void ShowFile(LPCTSTR bstrFileName, long iSelectCount);
	long GetPrintable();
	void SetPrintable(long nNewValue);
	long GetCxImage();
	long GetCyImage();
	void Show(const VARIANT& var);
	void Zoom(long iSelectCount);
	void BestFit();
	void ActualSize();
	void SlideShow();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shimgvwr\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__6EA41FF0_E5F5_4AB4_96F4_BEE7796D8D18__INCLUDED_)
#define AFX_STDAFX_H__6EA41FF0_E5F5_4AB4_96F4_BEE7796D8D18__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000
#define _MFC_VER 0x0600
#define VC_EXTRALEAN        // Exclude rarely-used stuff from Windows headers

#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>       // MFC support for Internet Explorer 4 Common Controls
#include <afxres.h>
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>         // MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT
#include <sti.h>
#include <wia.h>
#include <dde.h>
#ifndef _ATL_STATIC_REGISTRY
#define _ATL_STATIC_REGISTRY
#define _ATL_NO_DEBUG_CRT
#endif
#include <atlbase.h>

#include "preview3.h"
//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.
#ifndef ARRAYSIZE
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))
#endif
#endif // !defined(AFX_STDAFX_H__6EA41FF0_E5F5_4AB4_96F4_BEE7796D8D18__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\shimgvwr\shimgvwr.cpp ===
// shimgvwr.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include "shimgvwr.h"

#include "MainFrm.h"
#include "ImageDoc.h"
#include "ImageView.h"
#include "ofn.h"
#include <gdiplus.h>
#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif
using namespace Gdiplus;
/////////////////////////////////////////////////////////////////////////////
// CPreviewApp

BEGIN_MESSAGE_MAP(CPreviewApp, CWinApp)
    //{{AFX_MSG_MAP(CPreviewApp)
    ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
    //}}AFX_MSG_MAP
    // Standard file based document commands
    ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
    ON_COMMAND(ID_FILE_OPEN, OnFileOpen)
    
    
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPreviewApp construction

CPreviewApp::CPreviewApp()
{
    m_hFileMap = INVALID_HANDLE_VALUE;   
}

CPreviewApp::~CPreviewApp()
{
    if ( m_hFileMap != INVALID_HANDLE_VALUE)
    {
        CloseHandle (m_hFileMap);
    }
}

void CPreviewApp::OnFileOpen ()
{
    CString newName;
    if (! DoPromptFileName( newName, AFX_IDS_OPENFILE,
                                     OFN_HIDEREADONLY | OFN_FILEMUSTEXIST,
                                     TRUE ))
        return; // open cancelled
    if (OpenDocumentFile(newName) == NULL)
    {
        OnFileNew();
    }
}

void MakeFilterFromCodecs (CString &strFilter, UINT nCodecs, ImageCodecInfo *pCodecs)
{
  strFilter+=TEXT('\0');
  for (UINT i=0;i<nCodecs;i++)
  {      
      strFilter+=pCodecs->FormatDescription;
      strFilter+=TEXT('\0');
      strFilter+=pCodecs->FilenameExtension;
      strFilter+=TEXT('\0');
      pCodecs++;
  }

}
void
GetFilterStringForSave (CString &strFilter)
{
    strFilter.LoadString(IDS_ALLFILES);
    strFilter+=TEXT('\0');
    strFilter+=TEXT("*.*");
    UINT nCodecs = 0;
    UINT cbCodecs = 0;    
    BYTE *pData;
    GetImageEncodersSize (&nCodecs, &cbCodecs);
    if (cbCodecs)
    {
        pData = new BYTE[cbCodecs];
        if (pData)
        {
            ImageCodecInfo *pCodecs = reinterpret_cast<ImageCodecInfo*>(pData);
            if (Ok == GetImageEncoders (nCodecs, cbCodecs, pCodecs))
            {
                MakeFilterFromCodecs (strFilter, nCodecs, pCodecs);
            }
            delete [] pData;
        }
    }
    strFilter+=TEXT('\0');
}

void
GetFilterStringForOpen (CString &strFilter)
{
    strFilter.LoadString(IDS_ALLFILES);
    strFilter+=TEXT('\0');
    strFilter+=TEXT("*.*");
    // query GDI+ for supported image decoders
    UINT nCodecs = 0;
    UINT cbCodecs = 0;    
    BYTE *pData;
    GetImageDecodersSize (&nCodecs, &cbCodecs);
    if (cbCodecs)
    {
        pData = new BYTE[cbCodecs];
        if (pData)
        {
            ImageCodecInfo *pCodecs = reinterpret_cast<ImageCodecInfo*>(pData);
            if (Ok == GetImageDecoders (nCodecs, cbCodecs, pCodecs))
            {
                MakeFilterFromCodecs (strFilter, nCodecs, pCodecs);
            }
            delete [] pData;
        }
    }
    strFilter+=TEXT('\0');
}
// Get the extension of a file path.
//
CString GetExtension(const TCHAR* szFilePath)
    {
    TCHAR szExt [_MAX_EXT];
    MySplitPath(szFilePath, NULL, NULL, NULL, szExt);
    return CString(szExt);
    }

BOOL CPreviewApp::DoPromptFileName( CString& fileName, UINT nIDSTitle, DWORD lFlags,
                               BOOL bOpenFileDialog )
{
    COpenFileName dlgFile( bOpenFileDialog );
    if (!dlgFile.m_pofn)
        return FALSE;

    CString title;

    VERIFY( title.LoadString( nIDSTitle ) );

    lFlags |= OFN_EXPLORER;

    if (!bOpenFileDialog)
        lFlags |= OFN_OVERWRITEPROMPT;

    dlgFile.m_pofn->Flags |= lFlags;
    dlgFile.m_pofn->Flags &= ~OFN_SHOWHELP;

    CString strFilter;

    if (bOpenFileDialog)
    {
        GetFilterStringForOpen (strFilter);

    }
    else
    {
        GetFilterStringForSave (strFilter);
    }
    CString strExt = GetExtension(fileName);
    dlgFile.m_pofn->lpstrFilter = strFilter;
    dlgFile.m_pofn->hwndOwner   = AfxGetMainWnd()->GetSafeHwnd();
    dlgFile.m_pofn->hInstance   = AfxGetResourceHandle();
    dlgFile.m_pofn->lpstrTitle  = title;
    dlgFile.m_pofn->lpstrFile   = fileName.GetBuffer(_MAX_PATH);
    dlgFile.m_pofn->nMaxFile    = _MAX_PATH;
    dlgFile.m_pofn->lpstrInitialDir = NULL;
    dlgFile.m_pofn->lpstrDefExt = strExt;

    BOOL bRet = dlgFile.DoModal() == IDOK? TRUE : FALSE;
    fileName.ReleaseBuffer();
    return bRet;
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CPreviewApp object

CPreviewApp theApp;

/////////////////////////////////////////////////////////////////////////////
// CPreviewApp initialization

BOOL CPreviewApp::InitInstance()
{
    CoInitialize (NULL);
    AfxEnableControlContainer();

    // Standard initialization
    // If you are not using these features and wish to reduce the size
    //  of your final executable, you should remove from the following
    //  the specific initialization routines you do not need.

#ifdef _AFXDLL
    Enable3dControls();         // Call this when using MFC in a shared DLL
#else
    Enable3dControlsStatic();   // Call this when linking to MFC statically
#endif

    // Change the registry key under which our settings are stored.
    SetRegistryKey(_T("Shell_Image_Previewer"));

    LoadStdProfileSettings();  // Load standard INI file options (including MRU)


    // Register the application's document templates.  Document templates
    //  serve as the connection between documents, frame windows and views.

    CSingleDocTemplate* pDocTemplate;
    pDocTemplate = new CSingleDocTemplate(
        IDR_MAINFRAME,
        RUNTIME_CLASS(CImageDoc),
        RUNTIME_CLASS(CMainFrame),       // main SDI frame window
        RUNTIME_CLASS(CImageView));
    AddDocTemplate(pDocTemplate);

    // Parse command line for standard shell commands, DDE, file open
    CCommandLineInfo cmdInfo;
    ParseCommandLine(cmdInfo);
    if (cmdInfo.m_nShellCommand == CCommandLineInfo::FileOpen && PrevInstance (cmdInfo.m_strFileName))
    {
        return FALSE;
    }
    // Dispatch commands specified on the command line
    if (!ProcessShellCommand(cmdInfo))
        return FALSE;

    // The one and only window has been initialized, so show and update it.
    m_pMainWnd->ShowWindow(SW_SHOW);
    m_pMainWnd->UpdateWindow();

    return TRUE;
}
#define FILEMAPPINGNAME  TEXT("Shimgvwr")



bool
CPreviewApp::PrevInstance(const CString &strFile)
{
    CString strMapping(FILEMAPPINGNAME);
    bool bRet = false;
    strMapping += strFile;
    OutputDebugString (strMapping);
    OutputDebugString (TEXT("\n"));
    strMapping.Replace (TEXT('\\'), TEXT('/'));
    HANDLE hMap = CreateFileMapping (INVALID_HANDLE_VALUE, 
                                     NULL, 
                                     PAGE_READWRITE, 
                                     0, sizeof(HWND),
                                     strMapping);
    if (hMap )
    {
        DWORD dw = GetLastError();
        HWND *phwnd = reinterpret_cast<HWND*>(MapViewOfFile (hMap, FILE_MAP_WRITE, 0, 0, sizeof(HWND)));    

        if (phwnd)
        {
            CWnd WndPrev;
            CWnd *pWndChild;
            WndPrev.Attach(*phwnd);
            if (ERROR_ALREADY_EXISTS == dw)
            {            
                pWndChild = WndPrev.GetLastActivePopup();
                if (WndPrev.IsIconic())
                {
                    WndPrev.ShowWindow (SW_RESTORE);
                }
                pWndChild->SetForegroundWindow();
                bRet = true;
                CloseHandle (hMap); // we can close the handle before unmapping the view
            }
            else
            {
                *phwnd = 0;
                m_hFileMap = hMap;
            }
            UnmapViewOfFile (phwnd);
        }
        
    }
    return bRet;
}
/////////////////////////////////////////////////////////////////////////////
// CAboutDlg dialog used for App About

class CAboutDlg : public CDialog
{
public:
    CAboutDlg();

// Dialog Data
    //{{AFX_DATA(CAboutDlg)
    enum { IDD = IDD_ABOUTBOX };
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(CAboutDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    //{{AFX_MSG(CAboutDlg)
        // No message handlers
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
    //{{AFX_DATA_INIT(CAboutDlg)
    //}}AFX_DATA_INIT
}

void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAboutDlg)
    //}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
    //{{AFX_MSG_MAP(CAboutDlg)
        // No message handlers
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

// App command to run the dialog
void CPreviewApp::OnAppAbout()
{
    CString sTitle;
    HICON hIcon = LoadIcon(IDR_MAINFRAME);
    sTitle.LoadString(AFX_IDS_APP_TITLE);
    ShellAbout(AfxGetMainWnd()->GetSafeHwnd(), sTitle, NULL, hIcon); 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\ssmypics\sscommon\cfgdlg.h ===
#ifndef _CFGDLG_H_INCLUDED
#define _CFGDLG_H_INCLUDED

#define UWM_CONFIG_CHANGED (WM_USER+1300)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\ssmypics\sscommon\cfgdlg.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORPORATION, 1998, 1999, 2000
*
*  TITLE:       CFGDLG.CPP
*
*  VERSION:     1.0
*
*  AUTHOR:      ShaunIv
*
*  DATE:        1/19/1999
*
*  DESCRIPTION: Screensaver Configuration Dialog
*
*******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include <windows.h>
#include <commctrl.h>
#include <scrnsave.h>
#include "cfgdlg.h"
#include "ssmprsrc.h"
#include "simstr.h"
#include "ssdata.h"
#include "isdbg.h"
#include "simcrack.h"
#include "ssutil.h"
#include "ssconst.h"
#include "simidlst.h"
#include "wiacsh.h"

static const DWORD g_HelpIDs[] =
{
    IDC_MYPICTURES_ICON,        -1,
    IDC_DIALOG_DESCRIPTION,     -1,
    IDC_DIVIDER,                -1,

    IDC_FREQUENCY_STATIC,       IDH_WIA_CHANGE_PICS,
    IDC_FREQUENCY,              IDH_WIA_CHANGE_PICS,
    IDC_MINUTES_AND_SECONDS,    IDH_WIA_CHANGE_PICS,
    IDC_FREQ_LESS,              IDH_WIA_CHANGE_PICS,
    IDC_FREQ_MORE,              IDH_WIA_CHANGE_PICS,

    IDC_MAX_SIZE_STATIC,        IDH_WIA_PIC_SIZE,
    IDC_SIZE_LESS,              IDH_WIA_PIC_SIZE,
    IDC_SIZE_MORE,              IDH_WIA_PIC_SIZE,
    IDC_MAX_SIZE,               IDH_WIA_PIC_SIZE,
    IDC_IMAGE_SIZE_DESC,        IDH_WIA_PIC_SIZE,

    IDC_IMAGEDIR,               IDH_WIA_PICTURE_FOLDER,
    IDC_ALLOWSTRETCHING,        IDH_WIA_STRETCH_PICS,
    IDC_DISPLAYFILENAME,        IDH_WIA_SHOW_FILE_NAMES,
    IDC_ENABLE_TRANSITIONS,     IDH_WIA_TRANSITION_EFFECTS,
    IDC_ALLOW_KEYBOARDCONTROL,  IDH_WIA_ALLOW_SCROLL,

    IDOK,                       IDH_OK,
    IDCANCEL,                   IDH_CANCEL,
    IDC_BROWSE,                 IDH_WIA_BROWSE,

    0, 0
};

static CSimpleString ConstructMinutesAndSecondsString( HINSTANCE hInstance, UINT nTotalSeconds )
{
    CSimpleString strResult;
    UINT nMinutes = nTotalSeconds / 60;
    UINT nSeconds = nTotalSeconds % 60;
    if (0==nMinutes)
    {
        if (1==nSeconds)
        {
            strResult.Format( IDS_SECOND, hInstance, nSeconds );
        }
        else
        {
            strResult.Format( IDS_SECONDS, hInstance, nSeconds );
        }
    }
    else if (0==nSeconds)
    {
        if (1==nMinutes)
        {
            strResult.Format( IDS_MINUTE, hInstance, nMinutes );
        }
        else
        {
            strResult.Format( IDS_MINUTES, hInstance, nMinutes );
        }
    }
    else if (1==nMinutes && 1==nSeconds)
    {
        strResult.Format( IDS_MINUTE_AND_SECOND, hInstance, nMinutes, nSeconds );
    }
    else if (1==nMinutes)
    {
        strResult.Format( IDS_MINUTE_AND_SECONDS, hInstance, nMinutes, nSeconds );
    }
    else if (1==nSeconds)
    {
        strResult.Format( IDS_MINUTES_AND_SECOND, hInstance, nMinutes, nSeconds );
    }
    else
    {
        strResult.Format( IDS_MINUTES_AND_SECONDS, hInstance, nMinutes, nSeconds );
    }
    return strResult;
}


BOOL WINAPI ScreenSaverConfigureDialog(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam )
{
    switch (message)
    {
    case WM_INITDIALOG:
        {
            ScreenSaverUtil::SetIcons( hDlg, (HINSTANCE)GetWindowLongPtr(hDlg,GWLP_HINSTANCE), IDI_MONITOR );

            CMyDocsScreenSaverData MyDocsScreenSaverData( HKEY_CURRENT_USER, REGISTRY_PATH );
            
            //
            // Initialize path
            //
            SendDlgItemMessage( hDlg, IDC_IMAGEDIR, WM_SETTEXT, 0, (LPARAM)MyDocsScreenSaverData.ImageDirectory().String() );
            
            //
            // Initialize change frequency
            //
            SendDlgItemMessage( hDlg, IDC_FREQUENCY, TBM_SETRANGE, 1, MAKELONG(6,180) );
            SendDlgItemMessage( hDlg, IDC_FREQUENCY, TBM_SETPOS, 1, MyDocsScreenSaverData.ChangeInterval() / 1000 );
            CSimpleString strRes = ConstructMinutesAndSecondsString( (HINSTANCE)GetWindowLongPtr(hDlg,GWLP_HINSTANCE), MyDocsScreenSaverData.ChangeInterval() / 1000 );
            SendDlgItemMessage( hDlg, IDC_MINUTES_AND_SECONDS, WM_SETTEXT, 0, (LPARAM)strRes.String() );

            //
            // Initialize maximum screen percentage size
            //
            SendDlgItemMessage( hDlg, IDC_MAX_SIZE, TBM_SETRANGE, 1, MAKELONG(25,100) );
            SendDlgItemMessage( hDlg, IDC_MAX_SIZE, TBM_SETPOS, 1, MyDocsScreenSaverData.MaxScreenPercent() );
            strRes.Format( IDS_PERCENT, (HINSTANCE)GetWindowLongPtr(hDlg,GWLP_HINSTANCE), MyDocsScreenSaverData.MaxScreenPercent() );
            SendDlgItemMessage( hDlg, IDC_IMAGE_SIZE_DESC, WM_SETTEXT, 0, (LPARAM)strRes.String() );

            SendDlgItemMessage( hDlg, IDC_DISPLAYFILENAME, BM_SETCHECK, MyDocsScreenSaverData.DisplayFilename() ? BST_CHECKED : BST_UNCHECKED, 0 );
            SendDlgItemMessage( hDlg, IDC_ENABLE_TRANSITIONS, BM_SETCHECK, MyDocsScreenSaverData.DisableTransitions() ? BST_UNCHECKED : BST_CHECKED, 0 );
            SendDlgItemMessage( hDlg, IDC_ALLOWSTRETCHING, BM_SETCHECK, MyDocsScreenSaverData.AllowStretching() ? BST_CHECKED : BST_UNCHECKED, 0 );
            SendDlgItemMessage( hDlg, IDC_ALLOW_KEYBOARDCONTROL, BM_SETCHECK, MyDocsScreenSaverData.AllowKeyboardControl() ? BST_CHECKED : BST_UNCHECKED, 0 );
        }
        return (TRUE);

    case WM_HSCROLL:
        {
            HWND hWndScroll = (HWND)lParam;
            if (GetDlgItem( hDlg, IDC_FREQUENCY )==hWndScroll)
            {
                UINT nFrequency = (UINT)SendDlgItemMessage( hDlg, IDC_FREQUENCY, TBM_GETPOS, 0, 0 );
                CSimpleString strRes = ConstructMinutesAndSecondsString( (HINSTANCE)GetWindowLongPtr(hDlg,GWLP_HINSTANCE), nFrequency );
                SendDlgItemMessage( hDlg, IDC_MINUTES_AND_SECONDS, WM_SETTEXT, 0, (LPARAM)strRes.String() );
            }
            else if (GetDlgItem( hDlg, IDC_MAX_SIZE )==hWndScroll)
            {
                int nPercent = (int)SendDlgItemMessage( hDlg, IDC_MAX_SIZE, TBM_GETPOS, 0, 0 );
                CSimpleString strRes;
                strRes.Format( IDS_PERCENT, (HINSTANCE)GetWindowLongPtr(hDlg,GWLP_HINSTANCE), nPercent );
                SendDlgItemMessage( hDlg, IDC_IMAGE_SIZE_DESC, WM_SETTEXT, 0, (LPARAM)strRes.String() );
            }
        }
        return TRUE;

    case WM_CONTEXTMENU:
        WiaHelp::HandleWmContextMenu( wParam, lParam, g_HelpIDs );
        return true;

    case WM_HELP:
        WiaHelp::HandleWmHelp( wParam, lParam, g_HelpIDs );
        return true;

    case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
            case IDC_BROWSE:
                {
                    TCHAR szTxt[MAX_PATH];
                    SendDlgItemMessage( hDlg, IDC_IMAGEDIR, WM_GETTEXT, sizeof(szTxt)/sizeof(szTxt[0]), (LPARAM)szTxt );
                    CSimpleString strPrompt( IDS_DIRECTORYPROMPT, (HINSTANCE)GetWindowLongPtr(hDlg,GWLP_HINSTANCE) );
                    if (ScreenSaverUtil::SelectDirectory( hDlg, strPrompt.String(), szTxt ))
                    {
                        SendDlgItemMessage( hDlg, IDC_IMAGEDIR, WM_SETTEXT, 0, (LPARAM)szTxt );
                    }
                }
                return TRUE;

            case IDOK:
                {
                    TCHAR szTxt[MAX_PATH];
                    CMyDocsScreenSaverData MyDocsScreenSaverData( HKEY_CURRENT_USER, REGISTRY_PATH );
                    
                    //
                    // Get the image path
                    //
                    if (SendDlgItemMessage( hDlg, IDC_IMAGEDIR, WM_GETTEXT, sizeof(szTxt)/sizeof(szTxt[0]), (LPARAM)szTxt ))
                    {
                        //
                        // If this is the my pictures folder, delete the path name, so we will use the default next time
                        //
                        if (CSimpleIdList().GetSpecialFolder(hDlg,CSIDL_MYPICTURES).Name() == CSimpleString(szTxt))
                        {
                            MyDocsScreenSaverData.ImageDirectory(TEXT(""));
                        }
                        else
                        {
                            MyDocsScreenSaverData.ImageDirectory(szTxt);
                        }
                    }
                    UINT nFrequency = (UINT)SendDlgItemMessage( hDlg, IDC_FREQUENCY, TBM_GETPOS, 0, 0 );
                    MyDocsScreenSaverData.ChangeInterval(nFrequency * 1000);
                    int nPercent = (int)SendDlgItemMessage( hDlg, IDC_MAX_SIZE, TBM_GETPOS, 0, 0 );
                    MyDocsScreenSaverData.MaxScreenPercent(nPercent);

                    bool bChecked = (BST_CHECKED == SendDlgItemMessage( hDlg, IDC_DISPLAYFILENAME, BM_GETSTATE, 0, 0 ));
                    MyDocsScreenSaverData.DisplayFilename(bChecked);

                    bChecked = (BST_CHECKED == SendDlgItemMessage( hDlg, IDC_ENABLE_TRANSITIONS, BM_GETSTATE, 0, 0 ));
                    MyDocsScreenSaverData.DisableTransitions(!bChecked);

                    bChecked = (BST_CHECKED == SendDlgItemMessage( hDlg, IDC_ALLOWSTRETCHING, BM_GETSTATE, 0, 0 ));
                    MyDocsScreenSaverData.AllowStretching(bChecked);

                    bChecked = (BST_CHECKED == SendDlgItemMessage( hDlg, IDC_ALLOW_KEYBOARDCONTROL, BM_GETSTATE, 0, 0 ));
                    MyDocsScreenSaverData.AllowKeyboardControl(bChecked);

                    MyDocsScreenSaverData.Write();
                    HWND hWndParent = (HWND)GetWindowLongPtr( hDlg, GWLP_HWNDPARENT );

                    if (hWndParent)
                        PostMessage( hWndParent, UWM_CONFIG_CHANGED, 0, 0 );
                    EndDialog(hDlg, IDOK);
                }
                return (TRUE);

            case IDCANCEL:
                {
                    EndDialog(hDlg, IDCANCEL);
                }
                return (TRUE);
            }
        }
        return (FALSE);
    }
    return (FALSE);
}


BOOL WINAPI RegisterDialogClasses(HANDLE hInst)
{
    InitCommonControls();
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\ssmypics\sscommon\extimer.cpp ===
#include "precomp.h"
#pragma hdrstop
#include "extimer.h"

CExclusiveTimer::CExclusiveTimer(void)
: m_nTimerId(0),
  m_hWnd(NULL)
{
}


CExclusiveTimer::~CExclusiveTimer(void)
{
    Kill();
}


void CExclusiveTimer::Kill(void)
{
    if (m_hWnd && m_nTimerId)
    {
        KillTimer( m_hWnd, m_nTimerId );
        m_hWnd = NULL;
        m_nTimerId = 0;
    }
}


void CExclusiveTimer::Set( HWND hWnd, UINT nTimerId, UINT nMilliseconds )
{
    Kill();
    m_hWnd = hWnd;
    m_nTimerId = nTimerId;
    if (m_hWnd && m_nTimerId)
    {
        SetTimer( m_hWnd, m_nTimerId, nMilliseconds, NULL );
    }
}


UINT CExclusiveTimer::TimerId(void) const
{
    return m_nTimerId;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\ssmypics\sscommon\extimer.h ===
#ifndef __EXTIMER_H_INCLUDED
#define __EXTIMER_H_INCLUDED

#include <windows.h>

class CExclusiveTimer
{
private:
    UINT m_nTimerId;
    HWND m_hWnd;

private:
    // No implementation
    CExclusiveTimer( const CExclusiveTimer & );
    CExclusiveTimer &operator=( const CExclusiveTimer & );

public:
    CExclusiveTimer(void);
    ~CExclusiveTimer(void);
    void Kill(void);
    void Set( HWND hWnd, UINT nTimerId, UINT nMilliseconds );
    UINT TimerId(void) const;
};

#endif //__EXTIMER_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\ssmypics\sscommon\findfile.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998, 1999, 2000
 *
 *  TITLE:       FINDFILE.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        1/13/1999
 *
 *  DESCRIPTION: Directory recursing class.  A derived class should be created,
 *               which overrides FoundFile, or you can pass in a callback function
 *               that is called for each file and directory found.  A cancel callback
 *               is also provided.
 *
 *******************************************************************************/
#ifndef __FINDFILE_H_INCLUDED
#define __FINDFILE_H_INCLUDED

#include <windows.h>
#include "simstr.h"

typedef bool (*FindFilesCallback)( bool bIsFile, LPCTSTR pszFilename, const WIN32_FIND_DATA *pFindData, PVOID pvParam );

bool RecursiveFindFiles( CSimpleString strDirectory, const CSimpleString &strMask, FindFilesCallback pfnFindFilesCallback, PVOID pvParam, int nStackLevel=0, const int cnMaxDepth=10 );


#endif // __FINDFILE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\ssmypics\sscommon\findimgs.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998, 1999, 2000
 *
 *  TITLE:       FINDIMGS.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        1/13/1999
 *
 *  DESCRIPTION: Specialization of CFindFiles class that looks for image files and
 *               stores them in a dynamic array which is shuffled on initialization
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "findimgs.h"
#include "ssutil.h"
#include "isdbg.h"

CFindImageFiles::CFindImageFiles(void)
  : m_nCurrentFile(0)
{
}

CFindImageFiles::~CFindImageFiles(void)
{
}


bool CFindImageFiles::NextFile( CSimpleString &strFilename )
{
    bool bResult = false;
    strFilename = TEXT("");
    if (m_ImageFiles.Size())
    {
        if (m_nCurrentFile >= m_ImageFiles.Size())
        {
            m_nCurrentFile = 0;
        }
        strFilename = m_ImageFiles[m_nCurrentFile];
        m_nCurrentFile++;
        bResult = (strFilename.Length() != 0);
    }
    return(bResult);
}

bool CFindImageFiles::PreviousFile( CSimpleString &strFilename )
{
    bool bResult = false;
    strFilename = TEXT("");
    if (m_ImageFiles.Size()==1)
    {
        m_nCurrentFile = 0;
        strFilename = m_ImageFiles[0];
        bResult = (strFilename.Length() != 0);
    }
    else if (m_ImageFiles.Size()>=2)
    {
        m_nCurrentFile--;
        if (m_nCurrentFile < 0)
            m_nCurrentFile = m_ImageFiles.Size()-1;
        int nPrevFile = m_nCurrentFile-1;
        if (nPrevFile < 0)
            nPrevFile = m_ImageFiles.Size()-1;
        strFilename = m_ImageFiles[nPrevFile];
        bResult = (strFilename.Length() != 0);
    }
    return(bResult);
}


void CFindImageFiles::Shuffle(void)
{
    for (int i=0;i<m_ImageFiles.Size();i++)
    {
        ScreenSaverUtil::Swap( m_ImageFiles[i], m_ImageFiles[m_RandomNumberGen.Generate(i,m_ImageFiles.Size())]);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\ssmypics\sscommon\findfile.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998, 1999, 2000
 *
 *  TITLE:       FINDFILE.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        1/13/1999
 *
 *  DESCRIPTION: Directory recursing class.  A derived class should be created,
 *               which overrides FoundFile, or you can pass in a callback function
 *               that is called for each file and directory found.  A cancel callback
 *               is also provided.
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "findfile.h"
#include "simtok.h"

static CSimpleString EnsureTrailingBackslash( const CSimpleString &filename )
{
    if (!filename.Length())
        return (filename + CSimpleString(TEXT("\\")));
    else if (!filename.MatchLastCharacter(TEXT('\\')))
        return (filename + CSimpleString(TEXT("\\")));
    else return filename;
}

bool RecursiveFindFiles( CSimpleString strDirectory, const CSimpleString &strMask, FindFilesCallback pfnFindFilesCallback, PVOID pvParam, int nStackLevel, const int cnMaxDepth )
{
    //
    // Prevent stack overflows
    //
    if (nStackLevel >= cnMaxDepth)
    {
        return true;
    }
    WIA_PUSH_FUNCTION((TEXT("RecursiveFindFiles( %s, %s )"), strDirectory.String(), strMask.String() ));
    bool bFindResult = true;
    bool bContinue = true;
    WIN32_FIND_DATA FindData;
    HANDLE hFind = FindFirstFile( EnsureTrailingBackslash(strDirectory) + TEXT("*"), &FindData );
    if (hFind != INVALID_HANDLE_VALUE)
    {
        while (bFindResult && bContinue)
        {
            if ((FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) && lstrcmp(FindData.cFileName,TEXT("..")) && lstrcmp(FindData.cFileName,TEXT(".")))
            {
                if (pfnFindFilesCallback)
                    bContinue = pfnFindFilesCallback( false, EnsureTrailingBackslash(strDirectory)+FindData.cFileName, &FindData, pvParam );
                if (bContinue)
                    bContinue = RecursiveFindFiles( EnsureTrailingBackslash(strDirectory) + FindData.cFileName, strMask, pfnFindFilesCallback, pvParam, nStackLevel+1 );
            }
            bFindResult = (FindNextFile(hFind,&FindData) != FALSE);
        }
        FindClose(hFind);
    }
    CSimpleStringToken<CSimpleString> strMasks(strMask);
    while (bContinue)
    {
        CSimpleString TempMask = strMasks.Tokenize(TEXT(";"));
        if (!TempMask.Length())
            break;
        TempMask.TrimLeft();
        TempMask.TrimRight();
        if (TempMask.Length())
        {
            hFind = FindFirstFile( EnsureTrailingBackslash(strDirectory)+TempMask, &FindData );
            if (hFind != INVALID_HANDLE_VALUE)
            {
                bFindResult = true;
                while (bFindResult && bContinue)
                {
                    if (pfnFindFilesCallback)
                    {
                        bContinue = pfnFindFilesCallback( true, EnsureTrailingBackslash(strDirectory)+FindData.cFileName, &FindData, pvParam );
                    }
                    bFindResult = (FindNextFile(hFind,&FindData) != FALSE);
                }
                FindClose(hFind);
            }
        }
    }
    return bContinue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\ssmypics\sscommon\findimgs.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998, 1999, 2000, 1999, 2000
 *
 *  TITLE:       FINDIMGS.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        1/13/1999
 *
 *  DESCRIPTION: Specialization of CFindFiles class that looks for image files and
 *               stores them in a dynamic array which is shuffled on initialization
 *
 *******************************************************************************/
#ifndef __FINDIMGS_H_INCLUDED
#define __FINDIMGS_H_INCLUDED

#include <windows.h>
#include "findfile.h"
#include "randgen.h"
#include "simarray.h"

class CFindImageFiles
{
private:
    CSimpleDynamicArray<CSimpleString> m_ImageFiles;
    CRandomNumberGen                   m_RandomNumberGen;
    int                                m_nCurrentFile;

private:
    CFindImageFiles( const CFindImageFiles & );
    CFindImageFiles &operator=( const CFindImageFiles & );

public:
    CFindImageFiles(void);
    virtual ~CFindImageFiles(void);

    bool NextFile( CSimpleString &strFilename );
    bool PreviousFile( CSimpleString &strFilename );
    void Shuffle(void);
    bool FoundFile( LPCTSTR pszFilename )
    {
        if (pszFilename)
            m_ImageFiles.Append(pszFilename);
        return true;
    }


    void Reset(void)
    {
        m_nCurrentFile = 0;
    }
    int Count(void) const
    {
        return(m_ImageFiles.Size());
    }
    CSimpleString operator[](int nIndex)
    {
        return(m_ImageFiles[nIndex]);
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\ssmypics\sscommon\imagescr.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998, 1999, 2000
 *
 *  TITLE:       IMAGESCR.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        1/13/1999
 *
 *  DESCRIPTION: My Pictures Slideshow screen saver class
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "imagescr.h"
#include "isdbg.h"
#include "simreg.h"
#include "waitcurs.h"
#include "ssutil.h"
#include "findthrd.h"
#include "ssmprsrc.h"
#include <shlobj.h>

CImageScreenSaver::CImageScreenSaver( HINSTANCE hInstance, const CSimpleString &strRegistryKey )
: m_pPainter(NULL),
m_hInstance(hInstance),
m_MyDocsScreenSaverData( HKEY_CURRENT_USER, strRegistryKey )
{
    EnumDisplayMonitors( NULL, NULL, MonitorEnumProc, reinterpret_cast<LPARAM>(this) );
}

CImageScreenSaver::~CImageScreenSaver(void)
{
    if (m_pPainter)
        delete m_pPainter;
    m_pPainter = NULL;
}

BOOL CALLBACK CImageScreenSaver::MonitorEnumProc( HMONITOR hMonitor, HDC hdcMonitor, LPRECT prcMonitor, LPARAM lParam )
{
    CImageScreenSaver *pThis = reinterpret_cast<CImageScreenSaver*>(lParam);
    if (pThis)
    {
        if (hMonitor)
        {
            MONITORINFOEX MonitorInfoEx;
            ZeroMemory( &MonitorInfoEx, sizeof(MonitorInfoEx) );
            MonitorInfoEx.cbSize = sizeof(MonitorInfoEx);
            if (GetMonitorInfo( hMonitor, reinterpret_cast<MONITORINFO*>(&MonitorInfoEx)))
            {
                pThis->m_ScreenList.Append( MonitorInfoEx.rcMonitor );
                WIA_TRACE((TEXT("Monitor = [%s], rcMonitor = (%d,%d,%d,%d), rcWork = (%d,%d,%d,%d), dwFlags = %08X\n"),
                           MonitorInfoEx.szDevice,
                           MonitorInfoEx.rcMonitor.left, MonitorInfoEx.rcMonitor.top, MonitorInfoEx.rcMonitor.right, MonitorInfoEx.rcMonitor.bottom,
                           MonitorInfoEx.rcWork.left, MonitorInfoEx.rcWork.top, MonitorInfoEx.rcWork.right, MonitorInfoEx.rcWork.bottom,
                           MonitorInfoEx.dwFlags ));
            }
            else
            {
                WIA_TRACE((TEXT("MonitorEnumProc, GetMonitorInfo failed (%d)\n"), GetLastError()));
            }
        }
        else
        {
            WIA_TRACE((TEXT("MonitorEnumProc, hMonitor == NULL\n")));
        }
    }
    else
    {
        WIA_TRACE((TEXT("MonitorEnumProc, pThis == NULL\n")));
    }
    return TRUE;
}


bool CImageScreenSaver::IsValid(void) const
{
    return(true);
}

HANDLE CImageScreenSaver::Initialize( HWND hwndNotify, UINT nNotifyMessage, HANDLE hEventCancel )
{
    HANDLE hResult = NULL;

    //
    // Get the file extensions for the file types we are able to deal with
    //
    CSimpleString strExtensions;
    m_GdiPlusHelper.ConstructDecoderExtensionSearchStrings(strExtensions);
    WIA_TRACE((TEXT("strExtensions = %s"), strExtensions.String()));

    //
    // Start the image finding thread
    //
    hResult = CFindFilesThread::Find(
                                    m_MyDocsScreenSaverData.ImageDirectory(),
                                    strExtensions,
                                    hwndNotify,
                                    nNotifyMessage,
                                    hEventCancel,
                                    m_MyDocsScreenSaverData.MaxFailedFiles(),
                                    m_MyDocsScreenSaverData.MaxSuccessfulFiles(),
                                    m_MyDocsScreenSaverData.MaxDirectories()
                                    );

    //
    // Return the thread handle
    //
    return hResult;
}

bool CImageScreenSaver::TimerTick( CSimpleDC &ClientDC )
{
    if (m_pPainter && ClientDC.IsValid())
    {
        return m_pPainter->TimerTick( ClientDC );
    }
    return false;
}

void CImageScreenSaver::Paint( CSimpleDC &PaintDC )
{
    if (m_pPainter && PaintDC.IsValid())
    {
        m_pPainter->Paint( PaintDC );
    }
}

int CImageScreenSaver::ChangeTimerInterval(void) const
{
    return(m_MyDocsScreenSaverData.ChangeInterval());
}

int CImageScreenSaver::PaintTimerInterval(void) const
{
    return(m_MyDocsScreenSaverData.PaintInterval());
}


bool CImageScreenSaver::AllowKeyboardControl(void)
{
    return(m_MyDocsScreenSaverData.AllowKeyboardControl());
}

bool CImageScreenSaver::ReplaceImage( bool bForward, bool bNoTransition )
{
    CSimpleString strCurrentFile;
    if (m_pPainter)
    {
        delete m_pPainter;
        m_pPainter = NULL;
    }

    if (!m_VisibleAreaList.Size())
    {
        return false;
    }

    if (m_FindImageFiles.Count())
    {
        //
        // exit the loop when we get a valid image or we've exhausted the list
        //
        int nNumTries = 0;
        while (!m_pPainter && nNumTries < m_FindImageFiles.Count())
        {
            CSimpleString strNextFile;

            bool bNextFile = bForward ? m_FindImageFiles.NextFile(strNextFile) : m_FindImageFiles.PreviousFile(strNextFile);
            if (bNextFile)
            {
                CSimpleDC ClientDC;
                if (ClientDC.GetDC(NULL))
                {
                    CBitmapImage *pBitmapImage = new CBitmapImage;
                    if (pBitmapImage)
                    {
                        int nAreaToUse = CRandomNumberGen().Generate(0,m_VisibleAreaList.Size());
                        RECT rcAreaToUse = m_VisibleAreaList[nAreaToUse];
                        WIA_TRACE((TEXT("Chosen Image Area [%d] = (%d,%d), (%d,%d)"), nAreaToUse, rcAreaToUse.left, rcAreaToUse.top, rcAreaToUse.right, rcAreaToUse.bottom ));
                        if (pBitmapImage->Load( ClientDC, strNextFile, rcAreaToUse, m_MyDocsScreenSaverData.MaxScreenPercent(), m_MyDocsScreenSaverData.AllowStretching(), m_MyDocsScreenSaverData.DisplayFilename() ))
                        {
                            if (m_MyDocsScreenSaverData.DisableTransitions() || bNoTransition)
                            {
                                m_pPainter = new CSimpleTransitionPainter( pBitmapImage, ClientDC, rcAreaToUse, m_rcClient );
                            }
                            else
                            {
                                m_pPainter = GetRandomImagePainter( pBitmapImage, ClientDC, rcAreaToUse, m_rcClient );
                            }

                            //
                            // If we couldn't create a painter, delete the bitmap
                            //
                            if (!m_pPainter)
                            {
                                WIA_TRACE((TEXT("%hs (%d): Unable to create a painter\n"), __FILE__, __LINE__ ));
                                delete pBitmapImage;
                            }
                        }
                        else
                        {
                            WIA_TRACE((TEXT("%hs (%d): pBitmapImage->Load() failed\n"), __FILE__, __LINE__ ));
                            delete pBitmapImage;
                        }
                    }
                    else
                    {
                        WIA_TRACE((TEXT("%hs (%d): CImageScreenSaver::CreateImage() failed\n"), __FILE__, __LINE__ ));
                    }
                }
                else
                {
                    WIA_TRACE((TEXT("%hs (%d): ClientDC.GetDC() failed\n"), __FILE__, __LINE__ ));
                }
            }
            else
            {
                WIA_TRACE((TEXT("%hs (%d): m_FindImageFiles.NextFile() failed\n"), __FILE__, __LINE__ ));
            }
            nNumTries++;
        }
    }
    else
    {
        //
        // Create a new image
        //
        CBitmapImage *pBitmapImage = new CBitmapImage;
        if (pBitmapImage)
        {
            //
            // Get a desktop DC
            //
            CSimpleDC ClientDC;
            if (ClientDC.GetDC(NULL))
            {
                //
                // Figure out which screen to display the message on
                //
                RECT rcAreaToUse = m_VisibleAreaList[CRandomNumberGen().Generate(0,m_VisibleAreaList.Size())];

                //
                // Create the bitmap with an appropriate message
                //
                if (pBitmapImage->CreateFromText( CSimpleString().Format( IDS_NO_FILES_FOUND, g_hInstance, m_MyDocsScreenSaverData.ImageDirectory().String() ), rcAreaToUse, m_MyDocsScreenSaverData.MaxScreenPercent() ))
                {
                    //
                    // Create a simple painter to display it
                    //
                    m_pPainter = new CSimpleTransitionPainter( pBitmapImage, ClientDC, rcAreaToUse, m_rcClient );
                    if (!m_pPainter)
                    {
                        //
                        // If we couldn't get a painter, destroy the bitmap
                        //
                        delete pBitmapImage;
                    }
                }
                else
                {
                    //
                    // If we couldn't create a bitmap, destroy it
                    //
                    delete pBitmapImage;
                }
            }
        }
    }
    return(m_pPainter != NULL);
}

CImagePainter *CImageScreenSaver::GetRandomImagePainter( CBitmapImage *pBitmapImage, CSimpleDC &dc, const RECT &rcAreaToUse, const RECT &rcClient )
{
    CImagePainter *pPainter = NULL;
    int nPainter = CRandomNumberGen().Generate(0,5);
    if (!pPainter)
    {
        switch (nPainter)
        {
        case 0:
            pPainter = new CSimpleTransitionPainter( pBitmapImage, dc, rcAreaToUse, rcClient );
            break;
        case 1:
            pPainter = new CSlidingTransitionPainter( pBitmapImage, dc, rcAreaToUse, rcClient );
            break;
        case 2:
            pPainter = new CRandomBlockPainter( pBitmapImage, dc, rcAreaToUse, rcClient );
            break;
        case 3:
            pPainter = new CAlphaFadePainter( pBitmapImage, dc, rcAreaToUse, rcClient );
            break;
        case 4:
            pPainter = new COpenCurtainPainter( pBitmapImage, dc, rcAreaToUse, rcClient );
            break;
        }
    }
    if (!pPainter)
    {
        WIA_TRACE((TEXT("%hs (%d): pPainter is NULL\n"), __FILE__, __LINE__ ));
        return(NULL);
    }
    if (!pPainter->IsValid())
    {
        WIA_TRACE((TEXT("%hs (%d): pPainter->IsValid() == FALSE\n"), __FILE__, __LINE__ ));
        delete pPainter;
        return(NULL);
    }
    return(pPainter);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\ssmypics\sscommon\findthrd.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998, 1999, 2000
 *
 *  TITLE:       FINDTHRD.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        12/4/1999
 *
 *  DESCRIPTION:
 *
 *******************************************************************************/
#ifndef __FINDTHRD_H_INCLUDED
#define __FINDTHRD_H_INCLUDED

#include <gphelper.h>

class CFoundFileMessageData
{
private:
    CSimpleString m_strFilename;

private:
    CFoundFileMessageData(void);
    CFoundFileMessageData( const CFoundFileMessageData & );
    CFoundFileMessageData &operator=( const CFoundFileMessageData & );

public:
    CFoundFileMessageData( const CSimpleString &strFilename )
      : m_strFilename(strFilename)
    {
    }
    ~CFoundFileMessageData(void)
    {
    }
    CSimpleString Name(void) const
    {
        return m_strFilename;
    }
};

class CFindFilesThread
{
private:
    CSimpleString       m_strDirectory;
    CSimpleString       m_strMask;
    HWND                m_hwndNotify;
    UINT                m_nNotifyMessage;
    HANDLE              m_hEventCancel;
    int                 m_nDirectoryCount;
    int                 m_nFailedFileCount;
    int                 m_nSuccessfulFileCount;
    int                 m_nMaxFailedFiles;
    int                 m_nMaxSuccessfulFiles;
    int                 m_nMaxDirectories;
    CImageFileFormatVerifier m_ImageFileFormatVerifier;

private:
    CFindFilesThread(
        const CSimpleString &strDirectory,
        const CSimpleString &strMask,
        HWND hwndNotify,
        UINT nNotifyMessage,
        HANDLE hEventCancel,
        int nMaxFailedFiles,
        int nMaxSuccessfulFiles,
        int nMaxDirectories
    )
      : m_strDirectory(strDirectory),
        m_strMask(strMask),
        m_hwndNotify(hwndNotify),
        m_nNotifyMessage(nNotifyMessage),
        m_hEventCancel(NULL),
        m_nDirectoryCount(0),
        m_nFailedFileCount(0),
        m_nSuccessfulFileCount(0),
        m_nMaxFailedFiles(nMaxFailedFiles),
        m_nMaxSuccessfulFiles(nMaxSuccessfulFiles),
        m_nMaxDirectories(nMaxDirectories)
    {
        if (!DuplicateHandle( GetCurrentProcess(), hEventCancel, GetCurrentProcess(), &m_hEventCancel, 0, FALSE, DUPLICATE_SAME_ACCESS ))
            m_hEventCancel = NULL;
    }
    ~CFindFilesThread(void)
    {
        if (m_hEventCancel)
        {
            CloseHandle(m_hEventCancel);
            m_hEventCancel = NULL;
        }
    }

private:
    static bool FoundFile( bool bIsFile, LPCTSTR pszFilename, const WIN32_FIND_DATA *, PVOID pvParam )
    {
        CFindFilesThread *pThis = reinterpret_cast<CFindFilesThread*>(pvParam);
        if (pThis)
            return pThis->FoundFile( bIsFile, pszFilename );
        return false;
    }

    bool FoundFile( bool bIsFile, LPCTSTR pszFilename )
    {
        WIA_PUSH_FUNCTION((TEXT("CFindFilesThread::FoundFile( %d, %s )"), bIsFile, pszFilename ));
        // Check to see if we've been cancelled
        if (m_hEventCancel)
        {
            DWORD dwRes = WaitForSingleObject(m_hEventCancel,0);
            if (WAIT_OBJECT_0 == dwRes)
                return false;
        }

        // If this is a file, and it is an image file that we can decode, package up a message and send it off
        if (bIsFile)
        {
            if (m_nNotifyMessage && m_hwndNotify && IsWindow(m_hwndNotify))
            {
                if (m_ImageFileFormatVerifier.IsImageFile(pszFilename))
                {
                    m_nSuccessfulFileCount++;
                    CFoundFileMessageData *pFoundFileMessageData = new CFoundFileMessageData( pszFilename );
                    if (pFoundFileMessageData)
                    {
                        PostMessage( m_hwndNotify, m_nNotifyMessage, true, reinterpret_cast<LPARAM>(pFoundFileMessageData) );
                    }
                }
                else m_nFailedFileCount++;
            }
        }
        else m_nDirectoryCount++;

        // If we've exceeded the number of failures we're allowed, stop searching
        if (m_nMaxFailedFiles && m_nFailedFileCount >= m_nMaxFailedFiles)
        {
            WIA_TRACE((TEXT("FailedFileCount exceeded MaxFailedFiles, bailing out")));
            return false;
        }

        // If we've exceeded the number of files we want to handle, stop searching
        if (m_nMaxSuccessfulFiles && m_nSuccessfulFileCount >= m_nMaxSuccessfulFiles)
        {
            WIA_TRACE((TEXT("m_nSuccessfulFileCount exceeded MaxSuccessfulFiles, bailing out")));
            return false;
        }

        // If we've exceeded the number of directories we're allowed, stop searching
        if (m_nMaxDirectories && m_nDirectoryCount >= m_nMaxDirectories)
        {
            WIA_TRACE((TEXT("DirectoryCount exceeded MaxDirectories, bailing out")));
            return false;
        }

        return true;
    }

    bool Find(void)
    {
        bool bResult = RecursiveFindFiles( m_strDirectory, m_strMask, FoundFile, this );

        // Tell the window we're done
        if (m_nNotifyMessage && m_hwndNotify && IsWindow(m_hwndNotify))
        {
            PostMessage( m_hwndNotify, m_nNotifyMessage, FALSE, FALSE );
        }
        return bResult;
    }

    static DWORD __stdcall ThreadProc( PVOID pVoid )
    {
        CFindFilesThread *pFindFilesThread = reinterpret_cast<CFindFilesThread*>(pVoid);
        if (pFindFilesThread)
        {
            pFindFilesThread->Find();
            delete pFindFilesThread;
        }
        return 0;
    }
public:
    static HANDLE Find(
        const CSimpleString &strDirectory,
        const CSimpleString &strMask,
        HWND hwndNotify,
        UINT nNotifyMessage,
        HANDLE hEventCancel,
        int nMaxFailedFiles,
        int nMaxSuccessfulFiles,
        int nMaxDirectories
    )
    {
        HANDLE hThread = NULL;
        CFindFilesThread *pFindFilesThread = new CFindFilesThread( strDirectory, strMask, hwndNotify, nNotifyMessage, hEventCancel, nMaxFailedFiles, nMaxSuccessfulFiles, nMaxDirectories );
        if (pFindFilesThread)
        {
            DWORD dwThreadId;
            hThread = CreateThread( NULL, 0, ThreadProc, pFindFilesThread, 0, &dwThreadId );
            if (!hThread)
            {
                delete pFindFilesThread;
            }
            else
            {
                SetThreadPriority( hThread, THREAD_PRIORITY_LOWEST );
            }
        }
        return hThread;
    }
};

#endif //__FINDTHRD_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\ssmypics\sscommon\isdbg.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998, 1999, 2000
 *
 *  TITLE:       ISDBG.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        1/13/1999
 *
 *  DESCRIPTION: Simple OutputDebugString wrapper
 *
 *******************************************************************************/
#ifndef __ISDBG_H_INCLUDED
#define __ISDBG_H_INCLUDED

#if defined(_DEBUG) || defined(DBG)

#include <stdarg.h>
#include <stdio.h>

inline void __DebugPrintf( LPCTSTR pszFmt, ... )
{
    TCHAR szMsg[1024];
    va_list ArgPtr;
    va_start(ArgPtr, pszFmt);
    wvsprintf(szMsg, pszFmt, ArgPtr);
    va_end(ArgPtr);
#if 0
    FILE *fp = fopen( "c:\\ss.dbg", "at" );
    fprintf( fp, "%S", szMsg );
    fclose( fp );
#endif
    OutputDebugString(szMsg);
}

#define DEBUG_PRINTF(x) __DebugPrintf x

#else

#define DEBUG_PRINTF(x)

#endif // DBG or _DEBUG

#endif //__ISDBG_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\ssmypics\sscommon\imgs.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998, 1999, 2000
 *
 *  TITLE:       IMGS.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        1/13/1999
 *
 *  DESCRIPTION: Image class
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "imgs.h"
#include <windowsx.h>
#include <atlbase.h>
#include "isdbg.h"
#include "ssutil.h"
#include "gphelper.h"

CBitmapImage::CBitmapImage(void)
  : m_hBitmap(NULL),
    m_hPalette(NULL)
{
    WIA_PUSHFUNCTION(TEXT("CBitmapImage::CBitmapImage"));
}

CBitmapImage::~CBitmapImage(void)
{
    WIA_PUSHFUNCTION(TEXT("CBitmapImage::~CBitmapImage"));
    Destroy();
}

void CBitmapImage::Destroy(void)
{
    WIA_PUSHFUNCTION(TEXT("CBitmapImage::Destroy"));
    if (m_hBitmap)
        DeleteObject(m_hBitmap);
    m_hBitmap = NULL;
    if (m_hPalette)
        DeleteObject(m_hPalette);
    m_hPalette = NULL;
}


bool CBitmapImage::IsValid(void) const
{
    return(m_hBitmap != NULL);
}


HPALETTE CBitmapImage::Palette(void) const
{
    return(m_hPalette);
}


HBITMAP CBitmapImage::GetBitmap(void) const
{
    return(m_hBitmap);
}

// Create a palette for the image
HPALETTE CBitmapImage::PreparePalette( CSimpleDC &dc, HBITMAP hBitmap )
{
    WIA_PUSHFUNCTION(TEXT("CBitmapImage::PreparePalette"));
    HPALETTE hPalette = NULL;
    if (GetDeviceCaps(dc,RASTERCAPS) & RC_PALETTE)
    {
        if (hBitmap)
        {
            DIBSECTION ds = {0};
            GetObject(hBitmap, sizeof (DIBSECTION), &ds);

            int nColors;
            if (ds.dsBmih.biClrUsed != 0)
            {
                nColors = ds.dsBmih.biClrUsed;
            }
            else
            {
                //
                // Handle the special case of an image that claims to be
                // a 32bit DIB as a 24bit DIB
                //
                if (ds.dsBmih.biBitCount == 32)
                {
                    nColors = 1 << 24;
                }
                else
                {
                    nColors = 1 << ds.dsBmih.biBitCount;
                }
            }

            //
            // Create a halftone palette if the DIB section contains more
            // than 256 colors
            //
            if (nColors > 256)
            {
                hPalette = CreateHalftonePalette(dc);
            }

            //
            // Create a custom palette from the DIB section's color table
            // if the number of colors is 256 or less
            //
            else
            {
                RGBQUAD* pRGB = new RGBQUAD[nColors];
                if (pRGB)
                {
                    CSimpleDC MemDC;
                    MemDC.CreateCompatibleDC(dc);
                    SelectObject( MemDC, hBitmap );
                    GetDIBColorTable( MemDC, 0, nColors, pRGB );

                    UINT nSize = sizeof (LOGPALETTE) + (sizeof (PALETTEENTRY) * (nColors - 1));

                    LOGPALETTE* pLP = (LOGPALETTE*) new BYTE[nSize];
                    if (pLP)
                    {
                        pLP->palVersion = 0x300;
                        pLP->palNumEntries = (WORD)nColors;

                        for (int i=0; i<nColors; i++)
                        {
                            pLP->palPalEntry[i].peRed = pRGB[i].rgbRed;
                            pLP->palPalEntry[i].peGreen = pRGB[i].rgbGreen;
                            pLP->palPalEntry[i].peBlue = pRGB[i].rgbBlue;
                            pLP->palPalEntry[i].peFlags = 0;
                        }

                        hPalette = CreatePalette(pLP);
                        delete[] pLP;
                    }
                    delete[] pRGB;
                }
            }
        }
    }
    else
    {
        hPalette = CreateHalftonePalette(dc);
    }
    WIA_TRACE((TEXT("Returning palette %08X"), hPalette ));
    return hPalette;
}



SIZE CBitmapImage::ImageSize(void) const
{
    SIZE sizeImage = {0,0};
    if (IsValid())
    {
        BITMAP bm = {0};
        if (GetObject( m_hBitmap, sizeof(bm), &bm ))
        {
            sizeImage.cx = bm.bmWidth;
            sizeImage.cy = bm.bmHeight;
        }
    }
    return(sizeImage);
}

bool CBitmapImage::CreateFromText( LPCTSTR pszText, const RECT &rcScreen, int nMaxScreenPercent )
{
    Destroy();
    HDC hDesktopDC = GetDC(NULL);
    if (hDesktopDC)
    {
        //
        // Calculate the maximum size of the text rectangle
        //
        RECT rcImage = { 0, 0, WiaUiUtil::MulDivNoRound(rcScreen.right - rcScreen.left,nMaxScreenPercent,100), WiaUiUtil::MulDivNoRound(rcScreen.bottom - rcScreen.top,nMaxScreenPercent,100) };

        //
        // Create a mem dc to hold the bitmap
        //
        CSimpleDC MemDC;
        if (MemDC.CreateCompatibleDC(hDesktopDC))
        {
            //
            // Use the default UI font
            //
            SelectObject( MemDC, GetStockObject( DEFAULT_GUI_FONT ) );

            //
            // Figure out how big the bitmap has to be
            //
            DrawText( MemDC, pszText, lstrlen(pszText), &rcImage, DT_NOPREFIX|DT_WORDBREAK|DT_CALCRECT|DT_RTLREADING );

            //
            // Create the bitmap
            //
            m_hBitmap = CreateCompatibleBitmap( hDesktopDC, rcImage.right, rcImage.bottom );

            if (m_hBitmap)
            {
                //
                // Set the appropriate colors and select the bitmap into the DC
                //
                SetBkColor( MemDC, RGB(0,0,0) );
                SetTextColor( MemDC, RGB(255,255,255) );
                SelectBitmap( MemDC, m_hBitmap );

                //
                // Draw the actual text
                //
                DrawText( MemDC, pszText, lstrlen(pszText), &rcImage, DT_NOPREFIX|DT_WORDBREAK|DT_RTLREADING );
            }

        }

        //
        // Free the desktop DC
        //
        ReleaseDC(NULL,hDesktopDC);
    }
    return m_hBitmap != NULL;
}


bool CBitmapImage::Load( CSimpleDC  &dc,
                         LPCTSTR     pszFilename,
                         const RECT &rcScreen,
                         int         nMaxScreenPercent,
                         bool        bAllowStretching,
                         bool        bDisplayFilename
                       )
{
    //
    // Clean up, if necessary
    //
    Destroy();

    //
    // Validate the arguments
    //
    if (!pszFilename || !lstrlen(pszFilename))
    {
        return false;
    }

    //
    // Try to load and scale the image using GDI plus
    //
    CGdiPlusHelper GdiPlusHelper;
    if (SUCCEEDED(GdiPlusHelper.LoadAndScale( m_hBitmap, pszFilename, WiaUiUtil::MulDivNoRound(rcScreen.right - rcScreen.left,nMaxScreenPercent,100), WiaUiUtil::MulDivNoRound(rcScreen.bottom - rcScreen.top,nMaxScreenPercent,100), bAllowStretching )) && m_hBitmap)
    {
        //
        // Get the size of the image
        //
        SIZE sizeImage = ImageSize();

        //
        // Prepare the image's palette, if it has one
        //
        m_hPalette = PreparePalette( dc, m_hBitmap );

        //
        // Add the image title
        //
        if (bDisplayFilename && *pszFilename)
        {
            CSimpleDC MemoryDC;
            if (MemoryDC.CreateCompatibleDC(dc))
            {
                //
                // Prepare the DC and select the current image into it
                //
                ScreenSaverUtil::SelectPalette( MemoryDC, Palette(), FALSE );
                SelectBitmap( MemoryDC, m_hBitmap );
                SetBkMode( MemoryDC, TRANSPARENT );

                //
                // Create the title DC
                //
                CSimpleDC ImageTitleDC;
                if (ImageTitleDC.CreateCompatibleDC(dc))
                {
                    //
                    // Prepare the title DC
                    //
                    ScreenSaverUtil::SelectPalette( ImageTitleDC, Palette(), FALSE );
                    SelectFont( ImageTitleDC, (HFONT)GetStockObject(DEFAULT_GUI_FONT) );
                    SetBkMode( ImageTitleDC, TRANSPARENT );

                    //
                    // Calculate the rectangle needed to print the filename
                    //
                    RECT rcText;
                    rcText.left = 0;
                    rcText.top = 0;
                    rcText.right = sizeImage.cx;
                    rcText.bottom = sizeImage.cy;

                    //
                    // Make a nice margin
                    //
                    InflateRect( &rcText, -2, -2 );
                    DrawText( ImageTitleDC, pszFilename, lstrlen(pszFilename), &rcText, DT_PATH_ELLIPSIS|DT_SINGLELINE|DT_NOPREFIX|DT_TOP|DT_LEFT|DT_CALCRECT );
                    InflateRect( &rcText, 2, 2 );

                    //
                    // If the text rect is bigger than the scaled image, make it the same size
                    //
                    if (rcText.right > sizeImage.cx)
                        rcText.right = sizeImage.cx;
                    if (rcText.bottom > sizeImage.cy)
                        rcText.bottom = sizeImage.cy;

                    //
                    // Create the bitmap we'll use for the filename
                    //
                    BITMAPINFO bmi;
                    ZeroMemory( &bmi, sizeof(BITMAPINFO) );
                    bmi.bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
                    bmi.bmiHeader.biWidth           = rcText.right - rcText.left;
                    bmi.bmiHeader.biHeight          = rcText.bottom - rcText.top;
                    bmi.bmiHeader.biPlanes          = 1;
                    bmi.bmiHeader.biBitCount        = 24;
                    bmi.bmiHeader.biCompression     = BI_RGB;
                    PBYTE pBitmapData = NULL;
                    HBITMAP hBmpImageTitle = CreateDIBSection( dc, &bmi, DIB_RGB_COLORS, (LPVOID*)&pBitmapData, NULL, 0 );
                    if (hBmpImageTitle)
                    {
                        //
                        // Initialize the Alpha blend stuff
                        //
                        BLENDFUNCTION BlendFunction;
                        ZeroMemory( &BlendFunction, sizeof(BlendFunction) );
                        BlendFunction.BlendOp = AC_SRC_OVER;
                        BlendFunction.SourceConstantAlpha = 128;

                        //
                        // Select our new bitmap into the memory dc
                        //
                        HBITMAP hOldBitmap = SelectBitmap( ImageTitleDC, hBmpImageTitle );

                        //
                        // White background
                        //
                        FillRect( ImageTitleDC, &rcText, (HBRUSH)GetStockObject(WHITE_BRUSH));

                        //
                        // Alpha blend from the stretched bitmap to our text rect
                        //
                        AlphaBlend( ImageTitleDC, 0, 0, rcText.right - rcText.left, rcText.bottom - rcText.top, MemoryDC, rcText.left, rcText.top, rcText.right, rcText.bottom, BlendFunction );

                        //
                        // Draw the actual text
                        //
                        InflateRect( &rcText, -2, -2 );
                        DrawText( ImageTitleDC, pszFilename, lstrlen(pszFilename), &rcText, DT_PATH_ELLIPSIS|DT_SINGLELINE|DT_NOPREFIX|DT_TOP|DT_LEFT );
                        InflateRect( &rcText, 2, 2 );

                        //
                        // Copy back to the current image
                        //
                        BitBlt( MemoryDC, rcText.left, rcText.top, rcText.right - rcText.left, rcText.bottom - rcText.top, ImageTitleDC, 0, 0, SRCCOPY );

                        //
                        // Restore the dc's bitmap, and delete our title background
                        //
                        DeleteObject( SelectObject( ImageTitleDC, hOldBitmap ) );
                    }
                }
            }
        }
    }
    return (m_hBitmap != NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\ssmypics\sscommon\imgs.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998, 1999, 2000
 *
 *  TITLE:       IMGS.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        1/13/1999
 *
 *  DESCRIPTION: Image decoding and scaling wrapper.
 *
 *******************************************************************************/
#ifndef __IMGS_H_INCLUDED
#define __IMGS_H_INCLUDED

#include <windows.h>
#include "simdc.h"
#include "simstr.h"

class CBitmapImage
{
private:
    HBITMAP m_hBitmap;
    HPALETTE m_hPalette;

private:
    operator=( const CBitmapImage & );
    CBitmapImage( const CBitmapImage & );

public:
    CBitmapImage(void);
    virtual ~CBitmapImage(void);
    void Destroy(void);
    bool IsValid(void) const;
    HPALETTE Palette(void) const;
    HBITMAP GetBitmap(void) const;
    SIZE ImageSize(void) const;

    HPALETTE PreparePalette( CSimpleDC &dc, HBITMAP hBitmap );

    bool Load( CSimpleDC  &dc, LPCTSTR pszFilename, const RECT &rcScreen, int nMaxScreenPercent, bool bAllowStretching, bool bDisplayFilename );
    bool CreateFromText( LPCTSTR pszText, const RECT &rcScreen, int nMaxScreenPercent );
};

#endif //__IMGS_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\ssmypics\sscommon\imagescr.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998, 1999, 2000
 *
 *  TITLE:       IMAGESCR.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        1/13/1999
 *
 *  DESCRIPTION: My Pictures Slideshow screen saver class
 *
 *******************************************************************************/
#ifndef __IMAGESCR_H_INCLUDED
#define __IMAGESCR_H_INCLUDED

#include <windows.h>
#include <atlbase.h>
#include "findimgs.h"
#include "painters.h"
#include "ssdata.h"
#include "waitcurs.h"
#include "isdbg.h"
#include "simlist.h"
#include "simarray.h"
#include "gphelper.h"

class CImageScreenSaver
{
private:
    CFindImageFiles           m_FindImageFiles;
    CImagePainter            *m_pPainter;
    HINSTANCE                 m_hInstance;
    RECT                      m_rcClient;
    CMyDocsScreenSaverData    m_MyDocsScreenSaverData;
    CSimpleDynamicArray<RECT> m_ScreenList;
    CSimpleDynamicArray<RECT> m_VisibleAreaList;
    CGdiPlusHelper            m_GdiPlusHelper;

private:
    // No implementation
    CImageScreenSaver(void);
    CImageScreenSaver( const CImageScreenSaver & );
    CImageScreenSaver &operator=( const CImageScreenSaver & );

private:
    static BOOL CALLBACK MonitorEnumProc( HMONITOR hMonitor, HDC hdcMonitor, LPRECT prcMonitor, LPARAM lParam );

public:
    CImageScreenSaver( HINSTANCE hInstance, const CSimpleString &strRegistryKey );
    ~CImageScreenSaver(void);
    bool IsValid(void) const;
    HANDLE Initialize( HWND hwndNotify, UINT nNotifyMessage, HANDLE hEventCancel );
    bool TimerTick( CSimpleDC &ClientDC );
    void Paint( CSimpleDC &PaintDC );
    int ChangeTimerInterval(void) const;
    int PaintTimerInterval(void) const;
    bool ReplaceImage( bool bForward, bool bNoTransition );
    bool AllowKeyboardControl(void);
    int Count(void) const
    {
        return m_FindImageFiles.Count();
    }
    void ResetFileQueue(void)
    {
        m_FindImageFiles.Reset();
        m_FindImageFiles.Shuffle();
    }
    bool FoundFile( LPCTSTR pszFilename )
    {
        return m_FindImageFiles.FoundFile( pszFilename );
    }
    void SetScreenRect( HWND hWnd )
    {
        WIA_PUSHFUNCTION(TEXT("CImageScreenSaver::SetScreenRect"));
        GetClientRect( hWnd, &m_rcClient );
        WIA_TRACE((TEXT("m_rcClient = (%d,%d), (%d,%d)"), m_rcClient.left, m_rcClient.top, m_rcClient.right, m_rcClient.bottom ));
        m_VisibleAreaList.Destroy();
        for (int i=0;i<m_ScreenList.Size();i++)
        {
            WIA_TRACE((TEXT("m_ScreenList[%d] = (%d,%d), (%d,%d)"), i, m_ScreenList[i].left, m_ScreenList[i].top, m_ScreenList[i].right, m_ScreenList[i].bottom ));
            RECT rcScreenInClientCoords = m_ScreenList[i];
            WiaUiUtil::ScreenToClient( hWnd, &rcScreenInClientCoords );
            RECT rcIntersection;
            if (IntersectRect( &rcIntersection, &m_rcClient, &rcScreenInClientCoords ))
            {
                m_VisibleAreaList.Append(rcIntersection);
                WIA_TRACE((TEXT("Adding Visible Area = (%d,%d), (%d,%d)"), rcIntersection.left, rcIntersection.top, rcIntersection.right, rcIntersection.bottom ));
            }
        }
    }
    void ReadConfigData(void)
    {
        m_MyDocsScreenSaverData.Read();
    }
    CBitmapImage *CreateImage( LPCTSTR pszFilename );
    CImagePainter *GetRandomImagePainter( CBitmapImage *pBitmapImage, CSimpleDC &dc, const RECT &rcAreaToUse, const RECT &rcClient );
};

#endif // __IMAGESCR_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\ssmypics\sscommon\painters.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998, 1999, 2000
 *
 *  TITLE:       PAINTERS.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        1/13/1999
 *
 *  DESCRIPTION: Image transition base class and derived classes
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "painters.h"
#include <windowsx.h>
#include "ssutil.h"
#include "isdbg.h"


CImagePainter::CImagePainter( CBitmapImage *pBitmapImage, CSimpleDC &ClientDC, const RECT &rcImageArea, const RECT &rcScreen )
: m_pBitmapImage(pBitmapImage),
  m_dwInitialTickCount(0),
  m_rcScreen(rcScreen),
  m_rcImageArea(rcImageArea),
  m_bFirstFrame(true),
  m_dwDuration(0),
  m_bAlreadyPaintedLastFrame(false)
{
    if (m_pBitmapImage)
    {
        m_rcFinal = m_RandomNumberGen.Generate( m_pBitmapImage->ImageSize().cx, m_pBitmapImage->ImageSize().cy, rcImageArea );
        WIA_TRACE((TEXT("Image size: (%d, %d)"), m_pBitmapImage->ImageSize().cx, m_pBitmapImage->ImageSize().cy ));
        WIA_TRACE((TEXT("Chosen Final Rect = (%d,%d), (%d,%d)"), m_rcFinal.left, m_rcFinal.top, m_rcFinal.right, m_rcFinal.bottom ));
    }
}


CImagePainter::~CImagePainter(void)
{
    if (m_pBitmapImage)
    {
        delete m_pBitmapImage;
    }
    m_pBitmapImage = NULL;
}


DWORD CImagePainter::ElapsedTime(void) const
{
    DWORD dwElapsed = GetTickCount() - m_dwInitialTickCount;
    if (dwElapsed > m_dwDuration)
        dwElapsed = m_dwDuration;
    return(dwElapsed);
}


CBitmapImage *CImagePainter::BitmapImage(void)
{
    return(m_pBitmapImage);
}


void CImagePainter::Paint( CSimpleDC &PaintDC )
{
    if (PaintDC.IsValid() && m_pBitmapImage)
    {
        ScreenSaverUtil::SelectPalette( PaintDC, m_pBitmapImage->Palette(), FALSE );
        CSimpleDC MemoryDC;
        if (MemoryDC.CreateCompatibleDC(PaintDC))
        {
            ScreenSaverUtil::SelectPalette( MemoryDC, m_pBitmapImage->Palette(), FALSE );
            Paint( PaintDC, MemoryDC );
        }
    }
}

void CImagePainter::Paint( CSimpleDC &PaintDC, CSimpleDC &MemoryDC )
{
    SelectBitmap( MemoryDC, BitmapImage()->GetBitmap() );
    BitBlt( PaintDC, m_rcFinal.left, m_rcFinal.top, RECT_WIDTH(m_rcFinal), RECT_HEIGHT(m_rcFinal), MemoryDC, 0, 0, SRCCOPY );
}

bool CImagePainter::TimerTick( CSimpleDC &ClientDC )
{
    bool bStopPainting = false;

    if (m_bFirstFrame)
    {
        m_dwInitialTickCount = GetTickCount();
        Erase( ClientDC, m_rcScreen );
    }

    //
    if (m_bFirstFrame || NeedPainting())
    {
        if (m_pBitmapImage && ClientDC.IsValid())
        {
            ScreenSaverUtil::SelectPalette( ClientDC, m_pBitmapImage->Palette(), FALSE );
            CSimpleDC MemoryDC;
            if (MemoryDC.CreateCompatibleDC(ClientDC))
            {
                ScreenSaverUtil::SelectPalette( MemoryDC, m_pBitmapImage->Palette(), FALSE );
                PaintFrame( ClientDC, MemoryDC );
            }
        }
        if (m_bFirstFrame)
            m_bFirstFrame = false;
    }
    else bStopPainting = true;
    return bStopPainting;
}


void CImagePainter::Erase( CSimpleDC &ClientDC, RECT &rc )
{
    FillRect( ClientDC, &rc, (HBRUSH)GetStockObject(BLACK_BRUSH) );
}


bool CImagePainter::NeedPainting(void)
{
    return(false);
}


bool CImagePainter::IsValid(void)
{
    return(m_pBitmapImage && m_pBitmapImage->GetBitmap());
}

/****************************************************************************
CSimpleTransitionPainter
*****************************************************************************/
CSimpleTransitionPainter::CSimpleTransitionPainter( CBitmapImage *pBitmapImage, CSimpleDC &ClientDC, const RECT &rcImageArea, const RECT &rcScreen )
: CImagePainter( pBitmapImage, ClientDC, rcImageArea, rcScreen )
{
}


CSimpleTransitionPainter::~CSimpleTransitionPainter(void)
{
}

void CSimpleTransitionPainter::PaintFrame( CSimpleDC &ClientDC, CSimpleDC &MemoryDC )
{
    SelectBitmap( MemoryDC, BitmapImage()->GetBitmap() );
    SIZE sizeImage = BitmapImage()->ImageSize();
    BitBlt( ClientDC, m_rcFinal.left, m_rcFinal.top, sizeImage.cx, sizeImage.cy, MemoryDC, 0, 0, SRCCOPY );
}

/****************************************************************************
 CSlidingTransitionPainter
*****************************************************************************/
CSlidingTransitionPainter::CSlidingTransitionPainter( CBitmapImage *pBitmapImage, CSimpleDC &ClientDC, const RECT &rcImageArea, const RECT &rcScreen )
: CImagePainter( pBitmapImage, ClientDC, rcImageArea, rcScreen )
{
    m_dwDuration = 5000;
    ZeroMemory(&m_rcPrevious,sizeof(m_rcPrevious));
    switch (CRandomNumberGen().Generate(8))
    {
    case 0:
        // left, top
        m_rcOriginal.left = rcScreen.left - BitmapImage()->ImageSize().cx;
        m_rcOriginal.top = rcScreen.top - BitmapImage()->ImageSize().cy;
        m_rcOriginal.right = rcScreen.left;
        m_rcOriginal.bottom = rcScreen.top;
        break;
    case 1:
        // top
        m_rcOriginal.left = m_rcFinal.left;
        m_rcOriginal.top = rcScreen.top - BitmapImage()->ImageSize().cy;
        m_rcOriginal.right = m_rcFinal.right;
        m_rcOriginal.bottom = rcScreen.top;
        break;
    case 2:
        // right, top
        m_rcOriginal.left = rcScreen.right;
        m_rcOriginal.top = rcScreen.top - BitmapImage()->ImageSize().cy;
        m_rcOriginal.right = rcScreen.right + BitmapImage()->ImageSize().cx;
        m_rcOriginal.bottom = rcScreen.top;
        break;
    case 3:
        // right
        m_rcOriginal.left = rcScreen.right;
        m_rcOriginal.top = m_rcFinal.top;
        m_rcOriginal.right = rcScreen.right + BitmapImage()->ImageSize().cx;
        m_rcOriginal.bottom = m_rcFinal.bottom;
        break;
    case 4:
        // right, bottom
        m_rcOriginal.left = rcScreen.right;
        m_rcOriginal.top = rcScreen.bottom;
        m_rcOriginal.right = rcScreen.right + BitmapImage()->ImageSize().cx;
        m_rcOriginal.bottom = rcScreen.bottom + BitmapImage()->ImageSize().cy;
        break;
    case 5:
        // bottom
        m_rcOriginal.left = m_rcFinal.left;
        m_rcOriginal.top = rcScreen.bottom;
        m_rcOriginal.right = m_rcFinal.right;
        m_rcOriginal.bottom = rcScreen.bottom + BitmapImage()->ImageSize().cy;
        break;
    case 6:
        // left,bottom
        m_rcOriginal.left = rcScreen.left - BitmapImage()->ImageSize().cx;
        m_rcOriginal.top = rcScreen.bottom;
        m_rcOriginal.right = rcScreen.left;
        m_rcOriginal.bottom = rcScreen.bottom + BitmapImage()->ImageSize().cy;
        break;
    case 7:
        // left
        m_rcOriginal.left = rcScreen.left - BitmapImage()->ImageSize().cx;
        m_rcOriginal.top = m_rcFinal.top;
        m_rcOriginal.right = rcScreen.left;
        m_rcOriginal.bottom = m_rcFinal.bottom;
        break;
    }
}

CSlidingTransitionPainter::~CSlidingTransitionPainter(void)
{
}

bool CSlidingTransitionPainter::NeedPainting(void)
{
    if (!memcmp( &m_rcPrevious, &m_rcFinal, sizeof(RECT)))
        return false;
    return true;
}

void CSlidingTransitionPainter::PaintFrame( CSimpleDC &ClientDC, CSimpleDC &MemoryDC )
{
    SelectBitmap( MemoryDC, BitmapImage()->GetBitmap() );
    SIZE sizeImage = BitmapImage()->ImageSize();
    DWORD dwElapsedTime = ElapsedTime();
    SIZE sizeDelta;
    sizeDelta.cx = m_rcFinal.left - m_rcOriginal.left;
    sizeDelta.cy = m_rcFinal.top - m_rcOriginal.top;
    SIZE sizeOffset;
    sizeOffset.cx = MulDiv(sizeDelta.cx,dwElapsedTime,m_dwDuration);
    sizeOffset.cy = MulDiv(sizeDelta.cy,dwElapsedTime,m_dwDuration);

    // Make sure we don't overshoot the final rect
    if (WiaUiUtil::Absolute(sizeOffset.cx) > WiaUiUtil::Absolute(m_rcFinal.left - m_rcOriginal.left))
        sizeOffset.cx = m_rcFinal.left - m_rcOriginal.left;
    if (WiaUiUtil::Absolute(sizeOffset.cy) > WiaUiUtil::Absolute(m_rcFinal.top - m_rcOriginal.top))
        sizeOffset.cy = m_rcFinal.top - m_rcOriginal.top;

    RECT rcCurr = m_rcOriginal;
    ScreenSaverUtil::NormalizeRect(rcCurr);
    OffsetRect( &rcCurr, sizeOffset.cx, sizeOffset.cy );
    ScreenSaverUtil::EraseDiffRect( ClientDC, m_rcPrevious, rcCurr, (HBRUSH)GetStockObject(BLACK_BRUSH) );
    BitBlt( ClientDC, rcCurr.left, rcCurr.top, sizeImage.cx, sizeImage.cy, MemoryDC, 0, 0, SRCCOPY );
    m_rcPrevious = rcCurr;
}

/****************************************************************************
 CRandomBlockPainter
*****************************************************************************/
CRandomBlockPainter::CRandomBlockPainter( CBitmapImage *pBitmapImage, CSimpleDC &ClientDC, const RECT &rcImageArea, const RECT &rcScreen )
: CImagePainter( pBitmapImage, ClientDC, rcImageArea, rcScreen ),m_pBlockAddresses(NULL),m_nBlockSize(10),m_nStartIndex(0)
{
    m_dwDuration = 2000;
    SIZE sizeImage = BitmapImage()->ImageSize();
    m_sizeBlockCount.cx = WiaUiUtil::Align( sizeImage.cx, m_nBlockSize ) / m_nBlockSize;
    m_sizeBlockCount.cy = WiaUiUtil::Align( sizeImage.cy, m_nBlockSize ) / m_nBlockSize;
    m_pBlockAddresses = new int[m_sizeBlockCount.cx * m_sizeBlockCount.cy];
    if (m_pBlockAddresses)
    {
        int i;
        for (i=0;i<m_sizeBlockCount.cx * m_sizeBlockCount.cy;i++)
        {
            m_pBlockAddresses[i] = i;
        }
        for (i=0;i<m_sizeBlockCount.cx * m_sizeBlockCount.cy;i++)
        {
            ScreenSaverUtil::Swap( m_pBlockAddresses[i], m_pBlockAddresses[m_RandomNumberGen.Generate(i,m_sizeBlockCount.cx * m_sizeBlockCount.cy)]);
        }
    }
}


CRandomBlockPainter::~CRandomBlockPainter(void)
{
    if (m_pBlockAddresses)
        delete[] m_pBlockAddresses;
    m_pBlockAddresses = NULL;
}


bool CRandomBlockPainter::NeedPainting(void)
{
    return(m_nStartIndex < m_sizeBlockCount.cx * m_sizeBlockCount.cy);
}


bool CRandomBlockPainter::IsValid(void)
{
    return (CImagePainter::IsValid() && m_pBlockAddresses != NULL);
}

void CRandomBlockPainter::PaintFrame( CSimpleDC &ClientDC, CSimpleDC &MemoryDC )
{
    if (m_pBlockAddresses)
    {
        SelectBitmap( MemoryDC, BitmapImage()->GetBitmap() );
        int nDoUntilIndex = ((m_sizeBlockCount.cx * m_sizeBlockCount.cy) * ElapsedTime()) / m_dwDuration;
        for (int i=m_nStartIndex;i<nDoUntilIndex && i<m_sizeBlockCount.cx * m_sizeBlockCount.cy;i++)
        {
            int nRow = (m_pBlockAddresses[i] / m_sizeBlockCount.cx) * m_nBlockSize;
            int nCol = (m_pBlockAddresses[i] % m_sizeBlockCount.cx) * m_nBlockSize;
            BitBlt( ClientDC, m_rcFinal.left+nCol, m_rcFinal.top+nRow, m_nBlockSize, m_nBlockSize, MemoryDC, nCol, nRow, SRCCOPY );
        }
        m_nStartIndex = nDoUntilIndex;
    }
}



/****************************************************************************
 CAlphaFadePainter
*****************************************************************************/
CAlphaFadePainter::CAlphaFadePainter( CBitmapImage *pBitmapImage, CSimpleDC &ClientDC, const RECT &rcImageArea, const RECT &rcScreen )
: CImagePainter( pBitmapImage, ClientDC, rcImageArea, rcScreen )
{
    m_dwDuration = 6000;
    if (BitmapImage())
    {
        ZeroMemory(&m_bfBlendFunction,sizeof(m_bfBlendFunction));
        m_bfBlendFunction.BlendOp = AC_SRC_OVER;
        m_bfBlendFunction.SourceConstantAlpha = 0;
        m_hbmpBuffer = CreateCompatibleBitmap( ClientDC, BitmapImage()->ImageSize().cx, BitmapImage()->ImageSize().cy );
        CompatDC.CreateCompatibleDC( ClientDC );
    }
}


bool CAlphaFadePainter::IsValid(void)
{
    return (CImagePainter::IsValid() && m_hbmpBuffer != NULL && CompatDC.IsValid());
}


CAlphaFadePainter::~CAlphaFadePainter(void)
{
    if (m_hbmpBuffer)
        DeleteObject(m_hbmpBuffer);
}


bool CAlphaFadePainter::NeedPainting(void)
{
    return(m_bfBlendFunction.SourceConstantAlpha < 0xFF);
}


void CAlphaFadePainter::PaintFrame( CSimpleDC &ClientDC, CSimpleDC &MemoryDC )
{
    ScreenSaverUtil::SelectPalette( CompatDC, BitmapImage()->Palette(), FALSE );
    SelectBitmap( MemoryDC, BitmapImage()->GetBitmap() );
    HBITMAP hOldBufferBitmap = SelectBitmap( CompatDC, m_hbmpBuffer );
    DWORD dwCurrentIndex = (ElapsedTime() * 0xFF) / m_dwDuration;
    m_bfBlendFunction.SourceConstantAlpha = (BYTE)(dwCurrentIndex > 255 ? 255 : dwCurrentIndex);
    RECT rcImage;
    rcImage.left = rcImage.top = 0;
    rcImage.right = BitmapImage()->ImageSize().cx;
    rcImage.bottom = BitmapImage()->ImageSize().cy;
    FillRect( CompatDC, &rcImage, (HBRUSH)GetStockObject(BLACK_BRUSH) );
    AlphaBlend( CompatDC, 0, 0, RECT_WIDTH(m_rcFinal), RECT_HEIGHT(m_rcFinal), MemoryDC, 0, 0, RECT_WIDTH(m_rcFinal), RECT_HEIGHT(m_rcFinal), m_bfBlendFunction );
    BitBlt( ClientDC, m_rcFinal.left, m_rcFinal.top, RECT_WIDTH(m_rcFinal), RECT_HEIGHT(m_rcFinal), CompatDC, 0, 0, SRCCOPY );
    SelectBitmap( CompatDC, hOldBufferBitmap );
}


/****************************************************************************
 COpenCurtainPainter
*****************************************************************************/
COpenCurtainPainter::COpenCurtainPainter( CBitmapImage *pBitmapImage, CSimpleDC &ClientDC, const RECT &rcImageArea, const RECT &rcScreen )
: CImagePainter( pBitmapImage, ClientDC, rcImageArea, rcScreen ), m_nCurrentWidth(0)
{
    m_dwDuration = 3000;
    m_nFinalWidth = WiaUiUtil::Align(BitmapImage()->ImageSize().cx,2)/2;
}

COpenCurtainPainter::~COpenCurtainPainter(void)
{
}

bool COpenCurtainPainter::NeedPainting(void)
{
    return (m_nCurrentWidth < m_nFinalWidth);
}

void COpenCurtainPainter::PaintFrame( CSimpleDC &ClientDC, CSimpleDC &MemoryDC )
{
    m_nCurrentWidth = WiaUiUtil::MulDivNoRound( m_nFinalWidth, ElapsedTime(), m_dwDuration );
    SelectBitmap( MemoryDC, BitmapImage()->GetBitmap() );
    BitBlt( ClientDC, m_rcFinal.left, m_rcFinal.top, m_nCurrentWidth, m_rcFinal.bottom-m_rcFinal.top, MemoryDC, 0, 0, SRCCOPY );
    BitBlt( ClientDC, m_rcFinal.right-m_nCurrentWidth, m_rcFinal.top, m_nCurrentWidth, RECT_HEIGHT(m_rcFinal), MemoryDC, RECT_WIDTH(m_rcFinal)-m_nCurrentWidth, 0, SRCCOPY );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\ssmypics\sscommon\randgen.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998, 1999, 2000
 *
 *  TITLE:       RANDGEN.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        1/13/1999
 *
 *  DESCRIPTION: Random number generator class
 *
 *******************************************************************************/
#ifndef __RANDGEN_H_INCLUDED
#define __RANDGEN_H_INCLUDED

#include <windows.h>

#ifndef RECT_WIDTH
#define RECT_WIDTH(rc) (rc.right-rc.left)
#endif

#ifndef RECT_HEIGHT
#define RECT_HEIGHT(rc) (rc.bottom-rc.top)
#endif

class CRandomNumberGen
{
private:
    long m_nOldRand;
public:
    CRandomNumberGen( long nSeed = GetTickCount() )
        : m_nOldRand(nSeed)
    {
    }
    int Generate(void)
    {
        return(((m_nOldRand = m_nOldRand * 214013L + 2531011L) >> 16) & 0x7fff);
    }
    int Generate( int nMin, int nMax )
    {
        if (nMax - nMin == 0)
            return nMin;
        return(Generate() % (nMax - nMin)) + nMin;
    }
    int Generate( int nMax )
    {
        return (Generate( 0, nMax ));
    }
    RECT Generate( int nWidth, int nHeight, const RECT &rcRange )
    {
        RECT rcReturn;
        rcReturn.left = rcRange.left + Generate( 0, RECT_WIDTH(rcRange)-nWidth );
        rcReturn.top = rcRange.top + Generate( 0, RECT_HEIGHT(rcRange)-nHeight );
        rcReturn.right = rcReturn.left + nWidth;
        rcReturn.bottom = rcReturn.top + nHeight;
        return rcReturn;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\ssmypics\sscommon\sources.inc ===
#
# Builds the my pictures screensaver common library, SSCOMMON.LIB
#

SYNCHRONIZE_BLOCK=1

!include $(PROJECT_ROOT)\ui\uienv.inc

TARGETPATH=$(PROJECT_ROOT)\ui\lib\$(PLATFORM_SUFFIX)

ATL_VER = 30
USE_STATIC_ATL = 1

TARGETNAME=sscommon
TARGETTYPE=LIBRARY

SOURCES=..\cfgdlg.cpp   \
        ..\findfile.cpp \
        ..\findimgs.cpp \
        ..\imagescr.cpp \
        ..\imgs.cpp     \
        ..\painters.cpp \
        ..\ssdata.cpp   \
        ..\sshndler.cpp \
        ..\extimer.cpp  \
        ..\ssutil.cpp



PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\ssmypics\sscommon\painters.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998, 1999, 2000
 *
 *  TITLE:       PAINTERS.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        1/13/1999
 *
 *  DESCRIPTION: Image transition base class and derived classes
 *
 *******************************************************************************/
#ifndef __PAINTERS_H_INCLUDED
#define __PAINTERS_H_INCLUDED

#include <windows.h>
#include "imgs.h"
#include "randgen.h"
#include "simdc.h"

class CImagePainter
{
private:
    CBitmapImage     *m_pBitmapImage;
    DWORD             m_dwInitialTickCount;
    bool              m_bFirstFrame;
    bool              m_bAlreadyPaintedLastFrame;

protected:
    CRandomNumberGen  m_RandomNumberGen;
    RECT              m_rcScreen;
    RECT              m_rcImageArea;
    RECT              m_rcFinal;
    DWORD             m_dwDuration;

private:
    CImagePainter(void);
    CImagePainter( const CImagePainter & );
    operator=( const CImagePainter & );

public:
    CImagePainter( CBitmapImage *pBitmapImage, CSimpleDC &ClientDC, const RECT &rcImageArea, const RECT &rcScreen );
    virtual ~CImagePainter(void);
    DWORD ElapsedTime(void) const;
    CBitmapImage *BitmapImage(void);
    void Paint( CSimpleDC &PaintDC );
    bool TimerTick( CSimpleDC &ClientDC );
    void Erase( CSimpleDC &ClientDC, RECT &rc );

    virtual void Paint( CSimpleDC &PaintDC, CSimpleDC &MemoryDC );
    virtual bool NeedPainting(void);
    virtual bool IsValid(void);
    virtual void PaintFrame( CSimpleDC &ClientDC, CSimpleDC &MemoryDC ) = 0;
};


class CSimpleTransitionPainter : public CImagePainter
{
public:
    CSimpleTransitionPainter( CBitmapImage *pBitmapImage, CSimpleDC &ClientDC, const RECT &rcImageArea, const RECT &rcScreen );
    virtual ~CSimpleTransitionPainter(void);
    virtual void PaintFrame( CSimpleDC &ClientDC, CSimpleDC &MemoryDC );
};


class CSlidingTransitionPainter : public CImagePainter
{
private:
    RECT m_rcOriginal;
    RECT m_rcPrevious;
public:
    CSlidingTransitionPainter( CBitmapImage *pBitmapImage, CSimpleDC &ClientDC, const RECT &rcImageArea, const RECT &rcScreen );
    virtual ~CSlidingTransitionPainter(void);
    virtual bool NeedPainting(void);
    virtual void PaintFrame( CSimpleDC &ClientDC, CSimpleDC &MemoryDC );
};


class CRandomBlockPainter : public CImagePainter
{
private:
    int *m_pBlockAddresses;
    int  m_nBlockSize;
    int  m_nStartIndex;
    SIZE m_sizeBlockCount;
public:
    CRandomBlockPainter( CBitmapImage *pBitmapImage, CSimpleDC &ClientDC, const RECT &rcImageArea, const RECT &rcScreen );
    virtual ~CRandomBlockPainter(void);
    virtual bool NeedPainting(void);
    virtual bool IsValid(void);
    virtual void PaintFrame( CSimpleDC &ClientDC, CSimpleDC &MemoryDC );
};


class CAlphaFadePainter : public CImagePainter
{
private:
    BLENDFUNCTION m_bfBlendFunction;
    HBITMAP m_hbmpBuffer;
    CSimpleDC CompatDC;
public:
    CAlphaFadePainter( CBitmapImage *pBitmapImage, CSimpleDC &ClientDC, const RECT &rcImageArea, const RECT &rcScreen );
    virtual bool IsValid(void);
    virtual ~CAlphaFadePainter(void);
    virtual bool NeedPainting(void);
    virtual void PaintFrame( CSimpleDC &ClientDC, CSimpleDC &MemoryDC );
};


class COpenCurtainPainter : public CImagePainter
{
private:
    int   m_nCurrentWidth;
    int   m_nFinalWidth;
public:
    COpenCurtainPainter( CBitmapImage *pBitmapImage, CSimpleDC &ClientDC, const RECT &rcImageArea, const RECT &rcScreen );
    virtual ~COpenCurtainPainter(void);
    virtual bool NeedPainting(void);
    virtual void PaintFrame( CSimpleDC &ClientDC, CSimpleDC &MemoryDC );
};


#endif // __PAINTERS_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\ssmypics\sscommon\precomp.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999
 *
 *  TITLE:       precomp.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        5/12/99
 *
 *  DESCRIPTION: Precompiled header file for the preview window
 *
 *****************************************************************************/

#ifndef __PRECOMP_H_INCLUDED
#define __PRECOMP_H_INCLUDED

#include <windows.h>
#include <commctrl.h>
#include <propidl.h>
#include "uicommon.h"
#include "simcrack.h"
#include "wiadebug.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\ssmypics\sscommon\simdc.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORPORATION, 1998, 1999, 2000
*
*  TITLE:       SIMDC.H
*
*  VERSION:     1.0
*
*  AUTHOR:      ShaunIv
*
*  DATE:        1/19/1999
*
*  DESCRIPTION: Simple DC class.  Cleans up DCs in order to simplify code.
*
*******************************************************************************/
#ifndef __SIMDC_H_INCLUDED
#define __SIMDC_H_INCLUDED

#include <windows.h>
#include <uicommon.h>
#include "ssmprsrc.h"

extern HINSTANCE g_hInstance;

class CSimpleDC
{
public:
    // Where'd we get it from?
    enum CContextSource
    {
        FromWindowDC,
        FromClientDC,
        FromPaintDC,
        FromCompatibleDC,
        FromCreateDC,
        FromNullDC
    };

private:
    HDC            m_hDC;
    HWND           m_hWnd;
    CContextSource m_nSource;
    PAINTSTRUCT    m_PaintStruct;

    HBITMAP        m_hOriginalBitmap;
    HBRUSH         m_hOriginalBrush;
    HFONT          m_hOriginalFont;
    HPEN           m_hOriginalPen;
    HPALETTE       m_hOriginalPalette;

private:
    // No implementation
    CSimpleDC &operator=( const CSimpleDC &other );
    CSimpleDC( const CSimpleDC &other );

private:
    void SaveState(void)
    {
        if (m_hDC)
        {
            HBITMAP hTempBitmap = LoadBitmap( g_hInstance, MAKEINTRESOURCE(IDB_1) );
            if (hTempBitmap)
            {
                m_hOriginalBitmap = reinterpret_cast<HBITMAP>(SelectObject(m_hDC,hTempBitmap));
                if (m_hOriginalBitmap)
                {
                    SelectObject( m_hDC, m_hOriginalBitmap );
                }
                DeleteObject(hTempBitmap);
            }
            m_hOriginalBrush = reinterpret_cast<HBRUSH>(SelectObject(m_hDC,GetStockObject(NULL_BRUSH)));
            m_hOriginalFont = reinterpret_cast<HFONT>(SelectObject(m_hDC,GetStockObject(SYSTEM_FONT)));
            m_hOriginalPen = reinterpret_cast<HPEN>(SelectObject(m_hDC,GetStockObject(NULL_PEN)));
            m_hOriginalPalette = reinterpret_cast<HPALETTE>(SelectPalette(m_hDC,reinterpret_cast<HPALETTE>(GetStockObject(DEFAULT_PALETTE)),TRUE));
        }
    }
    void RestoreState(void)
    {
        if (m_hDC)
        {
            if (m_hOriginalBitmap)
                SelectObject( m_hDC, m_hOriginalBitmap );
            if (m_hOriginalBrush)
                SelectObject( m_hDC, m_hOriginalBrush );
            if (m_hOriginalFont)
                SelectObject( m_hDC, m_hOriginalFont );
            if (m_hOriginalPen)
                SelectObject( m_hDC, m_hOriginalPen );
            if (m_hOriginalPalette)
                SelectPalette( m_hDC, m_hOriginalPalette, TRUE );
        }
    }

public:
    CSimpleDC(void)
      : m_hDC(NULL),
        m_hWnd(NULL),
        m_nSource(FromNullDC),
        m_hOriginalBitmap(NULL),
        m_hOriginalBrush(NULL),
        m_hOriginalFont(NULL),
        m_hOriginalPen(NULL),
        m_hOriginalPalette(NULL)
    {
        ::ZeroMemory(&m_PaintStruct,sizeof(m_PaintStruct));
    }
    virtual ~CSimpleDC(void)
    {
        Release();
    }
    void Release(void)
    {
        RestoreState();
        if (m_hDC)
        {
            switch (m_nSource)
            {
            case FromWindowDC:
                if (m_hDC)
                    ReleaseDC( m_hWnd, m_hDC );
                break;

            case FromClientDC:
                if (m_hDC)
                    ReleaseDC( m_hWnd, m_hDC );
                break;

            case FromPaintDC:
                if (m_hDC)
                    EndPaint( m_hWnd, &m_PaintStruct );
                break;

            case FromCompatibleDC:
                if (m_hDC)
                    DeleteDC( m_hDC );
                break;

            case FromCreateDC:
                if (m_hDC)
                    DeleteDC( m_hDC );
                break;

            case FromNullDC:
                break;
            }
        }
        ZeroMemory( &m_PaintStruct, sizeof(m_PaintStruct));
        m_hDC         = NULL;
        m_hWnd        = NULL;
        m_nSource     = FromNullDC;
    }

    bool GetWindowDC( HWND hWnd )
    {
        Release();
        if (m_hDC = ::GetWindowDC(hWnd))
        {
            m_hWnd = hWnd;
            m_nSource = FromWindowDC;
            SaveState();
        }
        return (m_hDC != NULL);
    }

    bool GetDC( HWND hWnd )
    {
        Release();
        if (m_hDC = ::GetDC(hWnd))
        {
            m_hWnd = hWnd;
            m_nSource = FromClientDC;
            SaveState();
        }
        return (m_hDC != NULL);
    }

    bool BeginPaint( HWND hWnd )
    {
        Release();
        m_hDC = ::BeginPaint( hWnd, &m_PaintStruct );
        if (m_hDC)
        {
            m_hWnd = hWnd;
            m_nSource = FromPaintDC;
            SaveState();
        }
        return (m_hDC != NULL);
    }

    bool CreateCompatibleDC( HDC hDC )
    {
        Release();
        m_hDC = ::CreateCompatibleDC( hDC );
        if (m_hDC)
        {
            m_nSource = FromCompatibleDC;
            SaveState();
        }
        return (m_hDC != NULL);
    }

    bool CreateDC( LPCTSTR lpszDriver, LPCTSTR lpszDevice, LPCTSTR lpszOutput, CONST DEVMODE *lpInitData )
    {
        Release();
        m_hDC = ::CreateDC( lpszDriver, lpszDevice, lpszOutput, lpInitData );
        if (m_hDC)
        {
            m_nSource = FromCreateDC;
            SaveState();
        }
        return (m_hDC != NULL);
    }

    bool IsValid(void) const
    {
        return (m_hDC != NULL && m_nSource != FromNullDC);
    }

    operator HDC(void)
    {
        return m_hDC;
    }
};

#endif // __SIMDC_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\ssmypics\sscommon\ssconst.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORPORATION, 1998, 1999, 2000
*
*  TITLE:       SSCONST.H
*
*  VERSION:     1.0
*
*  AUTHOR:      ShaunIv
*
*  DATE:        1/19/1999
*
*  DESCRIPTION: Systemwide constants
*
*******************************************************************************/
#ifndef __SSCONST_H_INCLUDED
#define __SSCONST_H_INCLUDED

#define REGISTRY_PATH TEXT("Control Panel\\Screen Saver.Slideshow")

#endif // __SSCONST_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\ssmypics\ssmypics\precomp.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999
 *
 *  TITLE:       precomp.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        5/12/99
 *
 *  DESCRIPTION: Precompiled header file for the preview window
 *
 *****************************************************************************/

#ifndef __PRECOMP_H_INCLUDED
#define __PRECOMP_H_INCLUDED

#include <windows.h>
#include <commctrl.h>
#include <propidl.h>
#include "uicommon.h"
#include "simcrack.h"
#include "wiadebug.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\ssmypics\sscommon\ssdata.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998, 1999, 2000
 *
 *  TITLE:       SSDATA.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        1/13/1999
 *
 *  DESCRIPTION: Encapsulates reading and writing setting for this screensaver
 *               from the registry
 *
 *******************************************************************************/
#ifndef __SSDATA_H_INCLUDED
#define __SSDATA_H_INCLUDED

#include <windows.h>
#include "simstr.h"

class CMyDocsScreenSaverData
{
private:
    HKEY            m_hKeyRoot;
    CSimpleString   m_strRegistryKeyName;
    CSimpleString   m_strImageDirectory;
    UINT            m_nPaintTimerInterval;
    UINT            m_nChangeTimerInterval;
    bool            m_bDisplayFilename;
    int             m_nMaxScreenPercent;
    bool            m_bDisableTransitions;
    bool            m_bAllowStretching;
    bool            m_bAllowKeyboardControl;
    int             m_nMaxFailedFiles;
    int             m_nMaxSuccessfulFiles;
    int             m_nMaxDirectories;

    LPCTSTR         m_pszImageDirectoryValue;
    LPCTSTR         m_pszPaintIntervalValue;
    LPCTSTR         m_pszChangeIntervalValue;
    LPCTSTR         m_pszDisplayFilename;
    LPCTSTR         m_pszMaxScreenPercent;
    LPCTSTR         m_pszDisableTransitions;
    LPCTSTR         m_pszAllowStretching;
    LPCTSTR         m_pszAllowKeyboardControl;
    LPCTSTR         m_pszMaxFailedFiles;
    LPCTSTR         m_pszMaxSuccessfulFiles;
    LPCTSTR         m_pszMaxDirectories;

    enum
    {
        nDefaultChangeInterval       = 6000,
        nDefaultPaintInterval        = 0,
        bDefaultDisplayFilename      = 0,
        nDefaultScreenPercent        = 90,
        bDefaultDisableTransitions   = 0,
        bDefaultAllowStretching      = 0,
        bDefaultAllowKeyboardControl = 1,
        nDefaultMaxFailedFiles       = 1000,
        nDefaultMaxSuccessfulFiles   = 65536,
        nDefaultMaxDirectories       = 200
    };
    // No implementation
    CMyDocsScreenSaverData(void);
    CMyDocsScreenSaverData &operator=( const CMyDocsScreenSaverData & );
    CMyDocsScreenSaverData( const CMyDocsScreenSaverData & );
public:
    CMyDocsScreenSaverData( HKEY hKeyRoot, const CSimpleString &strRegistryKeyName );
    ~CMyDocsScreenSaverData(void);
    void Read(void);
    void Write(void);
    CSimpleString ImageDirectory(void) const;
    void ImageDirectory( const CSimpleString &str );
    UINT ChangeInterval(void) const;
    void ChangeInterval( UINT nInterval );
    UINT PaintInterval(void) const;
    void PaintInterval( UINT nInterval );
    bool DisplayFilename(void) const;
    void DisplayFilename( bool bDisplayFilename );
    int  MaxScreenPercent(void) const;
    void MaxScreenPercent( int nMaxScreenPercent );
    bool DisableTransitions(void) const;
    void DisableTransitions( bool bDisableTransitions );
    bool AllowStretching(void) const;
    void AllowStretching( bool bAllowStretching );
    bool AllowKeyboardControl(void) const;
    void AllowKeyboardControl( bool bAllowKeyboardControl );
    int  MaxFailedFiles(void) const;
    void MaxFailedFiles( int nMaxFailedFiles );
    int  MaxSuccessfulFiles(void) const;
    void MaxSuccessfulFiles( int nMaxSuccessfulFiles );
    int  MaxDirectories(void) const;
    void MaxDirectories( int nMaxDirectories );
    CSimpleString GetDefaultImageDir(void);
};


#endif // __SSDATA_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\ssmypics\sscommon\ssmprsrc.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ssmprsrc.rc
//
#define IDS_NO_FILES_FOUND              2
#define IDC_FREQUENCY                   1003
#define IDC_IMAGEDIR                    1004
#define IDC_BROWSE                      1005
#define IDC_MINUTES_AND_SECONDS         1006
#define IDC_DISPLAYFILENAME             1008
#define IDC_ENABLE_TRANSITIONS          1009
#define IDC_MAX_SIZE                    1010
#define IDC_IMAGE_SIZE_DESC             1011
#define IDC_ALLOW_KEYBOARDCONTROL       1012
#define IDC_ALLOWSTRETCHING             1013
#define IDC_FREQ_LESS                   1018
#define IDC_FREQ_MORE                   1019
#define IDC_SIZE_LESS                   1020
#define IDC_SIZE_MORE                   1021
#define IDC_MYPICTURES_ICON             1022
#define IDC_DIALOG_DESCRIPTION          1023
#define IDC_FREQUENCY_STATIC            1024
#define IDC_MAX_SIZE_STATIC             1025
#define IDC_DIVIDER                     1026
#define IDS_MINUTES_AND_SECONDS         2000
#define IDS_MINUTE_AND_SECONDS          2001
#define IDS_MINUTES_AND_SECOND          2002
#define IDD_CONFIG_DIALOG               2003
#define IDS_MINUTE_AND_SECOND           2003
#define IDS_SECONDS                     2004
#define IDI_MONITOR                     2005
#define IDS_SECOND                      2005
#define IDS_MINUTES                     2006
#define IDS_MINUTE                      2007
#define IDS_DIRECTORYPROMPT             2008
#define IDS_PERCENT                     2009
#define IDB_1                           2009
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        2011
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1027
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\ssmypics\sscommon\sshndler.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999,2000
 *
 *  TITLE:       SSHNDLER.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        12/4/1999
 *
 *  DESCRIPTION:
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "sshndler.h"
#include "ssutil.h"

CScreenSaverHandler::CScreenSaverHandler( HWND hWnd, UINT nFindNotifyMessage, UINT nPaintTimer, UINT nChangeTimer, UINT nBackupStartTimer, LPCTSTR szRegistryPath, HINSTANCE hInstance )
  : m_hWnd(hWnd),
    m_hInstance(hInstance),
    m_strRegistryPath(szRegistryPath),
    m_nFindNotifyMessage(nFindNotifyMessage),
    m_nPaintTimerId(nPaintTimer),
    m_nChangeTimerId(nChangeTimer),
    m_nBackupStartTimerId(nBackupStartTimer),
    m_nBackupStartTimerPeriod(BACKUP_START_TIMER_PERIOD),
    m_pImageScreenSaver(NULL),
    m_bPaused(false),
    m_hFindThread(NULL),
    m_hFindCancel(NULL),
    m_bScreensaverStarted(false),
    m_nStartImage(0),
    m_nShuffleInterval(SHUFFLE_INTERVAL)
{
    m_nStartImage = m_Random.Generate(MAX_START_IMAGE);
}

void CScreenSaverHandler::Initialize(void)
{
    CWaitCursor wc;

    HDC hDC = GetDC(m_hWnd);
    if (hDC)
    {
        m_pImageScreenSaver = new CImageScreenSaver( m_hInstance, m_strRegistryPath );
        if (m_pImageScreenSaver)
        {
            m_pImageScreenSaver->SetScreenRect(m_hWnd);

            if (m_pImageScreenSaver->IsValid())
            {
                m_hFindCancel = CreateEvent( NULL, TRUE, FALSE, NULL );
                if (m_hFindCancel)
                {
                    m_hFindThread = m_pImageScreenSaver->Initialize( m_hWnd, m_nFindNotifyMessage, m_hFindCancel );
                }

                SetTimer( m_hWnd, m_nBackupStartTimerId, m_nBackupStartTimerPeriod, NULL );
            }
            else
            {
                WIA_TRACE((TEXT("CScreenSaverHandler::CScreenSaverHandler, m_pImageScreenSaver->IsValid() returned failed\n")));
                delete m_pImageScreenSaver;
                m_pImageScreenSaver = NULL;
            }
        }
        else
        {
            WIA_TRACE((TEXT("CScreenSaverHandler::CScreenSaverHandler, unable to create m_pImageScreenSaver\n")));
        }
        ReleaseDC( m_hWnd, hDC );
    }
    else
    {
        WIA_TRACE((TEXT("CScreenSaverHandler::CScreenSaverHandler, GetDC failed\n")));
    }
}


CScreenSaverHandler::~CScreenSaverHandler(void)
{
    if (m_pImageScreenSaver)
    {
        delete m_pImageScreenSaver;
        m_pImageScreenSaver = NULL;
    }
    if (m_hFindCancel)
    {
        SetEvent(m_hFindCancel);
        CloseHandle(m_hFindCancel);
        m_hFindCancel = NULL;
    }
    if (m_hFindThread)
    {
        WaitForSingleObject( m_hFindThread, INFINITE );
        CloseHandle(m_hFindThread);
        m_hFindThread = NULL;
    }
}


bool CScreenSaverHandler::HandleKeyboardMessage( UINT nMessage, WPARAM nVirtkey )
{
    if (m_pImageScreenSaver && m_pImageScreenSaver->AllowKeyboardControl())
    {
        if (nMessage == WM_KEYDOWN)
        {
            switch (nVirtkey)
            {
            case VK_DOWN:
                if (nMessage == WM_KEYDOWN)
                {
                    m_bPaused = !m_bPaused;
                    if (!m_bPaused)
                    {
                        if (m_pImageScreenSaver && m_pImageScreenSaver->ReplaceImage(true,false))
                            m_Timer.Set( m_hWnd, m_nPaintTimerId, m_pImageScreenSaver->PaintTimerInterval() );
                    }
                }
                return true;

            case VK_LEFT:
                if (nMessage == WM_KEYDOWN)
                {
                    if (m_pImageScreenSaver && m_pImageScreenSaver->ReplaceImage(false,true))
                        m_Timer.Set( m_hWnd, m_nPaintTimerId, m_pImageScreenSaver->PaintTimerInterval() );
                }
                return true;

            case VK_RIGHT:
                if (nMessage == WM_KEYDOWN)
                {
                    if (m_pImageScreenSaver && m_pImageScreenSaver->ReplaceImage(true,true))
                        m_Timer.Set( m_hWnd, m_nPaintTimerId, m_pImageScreenSaver->PaintTimerInterval() );
                }
                return true;
            }
        }
    }
    return false;
}


void CScreenSaverHandler::HandleConfigChanged(void)
{
    if (m_pImageScreenSaver)
    {
        m_pImageScreenSaver->SetScreenRect(m_hWnd);
        m_pImageScreenSaver->ReadConfigData();
    }
}


void CScreenSaverHandler::HandleTimer( WPARAM nEvent )
{
    if (nEvent == m_nPaintTimerId)
    {
        if (m_pImageScreenSaver)
        {
            CSimpleDC ClientDC;
            if (ClientDC.GetDC(m_hWnd))
            {
                bool bResult = m_pImageScreenSaver->TimerTick( ClientDC );
                if (bResult)
                {
                    m_Timer.Set( m_hWnd, m_nChangeTimerId, m_pImageScreenSaver->ChangeTimerInterval() );
                }
            }
        }
    }
    else if (nEvent == m_nChangeTimerId)
    {
        m_Timer.Kill();
        if (!m_bPaused && m_pImageScreenSaver && m_pImageScreenSaver->ReplaceImage(true,false))
        {
            m_Timer.Set( m_hWnd, m_nPaintTimerId, m_pImageScreenSaver->PaintTimerInterval() );
            
            //
            // Mark that we've been started
            //
            if (!m_bScreensaverStarted)
            {
                m_bScreensaverStarted = true;
            }
        }
    }
    else if (nEvent == m_nBackupStartTimerId)
    {
        //
        // Make sure we don't get any more of these
        //
        KillTimer( m_hWnd, m_nBackupStartTimerId );

        //
        // If the screensaver hasn't started, start it.
        //
        if (!m_bScreensaverStarted)
        {
            //
            // Shuffle the list
            //
            m_pImageScreenSaver->ResetFileQueue();

            //
            // If we haven't gotten any images, start the timer so we can display the error message
            //
            SendMessage( m_hWnd, WM_TIMER, m_nChangeTimerId, 0 );
        }
    }
}


void CScreenSaverHandler::HandlePaint(void)
{
    if (m_pImageScreenSaver)
    {
        CSimpleDC PaintDC;
        if (PaintDC.BeginPaint(m_hWnd))
        {
            m_pImageScreenSaver->Paint( PaintDC );
        }
    }
}

void CScreenSaverHandler::HandleFindFile( CFoundFileMessageData *pFoundFileMessageData )
{
    WIA_PUSHFUNCTION(TEXT("CScreenSaverHandler::HandleFindFile"));
    //
    // Make sure we have a screensaver object
    //
    if (m_pImageScreenSaver)
    {
        //
        // If this is a found file message
        //
        if (pFoundFileMessageData)
        {
            //
            // Add it to the list, and check for cancel
            //
            bool bResult = m_pImageScreenSaver->FoundFile( pFoundFileMessageData->Name() );

            //
            // If the find operation was cancelled, set the cancel event
            //
            if (!bResult)
            {
                SetEvent( m_hFindCancel );
            }

            //
            // If this is the image on which we should start, start up the screensaver pump
            //
            if (!m_bScreensaverStarted && m_pImageScreenSaver->Count() && m_nStartImage+1 == m_pImageScreenSaver->Count())
            {
                WIA_TRACE((TEXT("Starting after image %d was found"), m_nStartImage ));

                //
                // Shuffle the images
                //
                m_pImageScreenSaver->ResetFileQueue();

                //
                // If this is our first image, start things up
                //
                SendMessage( m_hWnd, WM_TIMER, m_nChangeTimerId, 0 );
            }

            //
            // If we have some images, and the shuffle count interval has been reached, shuffle the images
            //
            if (m_pImageScreenSaver->Count() && (m_pImageScreenSaver->Count() % m_nShuffleInterval) == 0)
            {
                WIA_TRACE((TEXT("Shuffling the image list at %d images"), m_pImageScreenSaver->Count() ));
                //
                // Shuffle the images
                //
                m_pImageScreenSaver->ResetFileQueue();
            }
            delete pFoundFileMessageData;
        }
        else
        {
            //
            // Last message
            //
            m_pImageScreenSaver->ResetFileQueue();

            //
            // If we haven't gotten any images, start the timer so we can display the error message
            //
            if (!m_bScreensaverStarted)
            {
                SendMessage( m_hWnd, WM_TIMER, m_nChangeTimerId, 0 );
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\ssmypics\sscommon\ssutil.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998, 1999, 2000
 *
 *  TITLE:       SSUTIL.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        1/13/1999
 *
 *  DESCRIPTION: Useful utility functions
 *
 *******************************************************************************/
#ifndef __SSUTIL_H_INCLUDED
#define __SSUTIL_H_INCLUDED

#include <windows.h>
#include <uicommon.h>

namespace ScreenSaverUtil
{
    bool SetIcons( HWND hWnd, HINSTANCE hInstance, int nResId );
    bool IsValidRect( RECT &rc );
    void EraseDiffRect( HDC hDC, const RECT &oldRect, const RECT &diffRect, HBRUSH hBrush );
    bool SelectDirectory( HWND hWnd, LPCTSTR pszPrompt, TCHAR szDirectory[] );
    HPALETTE SelectPalette( HDC hDC, HPALETTE hPalette, BOOL bForceBackground );
    void NormalizeRect( RECT &rc );

    template <class T>
    void Swap( T &a, T &b )
    {
        T temp = a;
        a = b;
        b = temp;
    }
} // Namespace

#endif //__SSUTIL_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\ssmypics\sstest\precomp.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999
 *
 *  TITLE:       precomp.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        5/12/99
 *
 *  DESCRIPTION: Precompiled header file for the preview window
 *
 *****************************************************************************/

#ifndef __PRECOMP_H_INCLUDED
#define __PRECOMP_H_INCLUDED

#include <windows.h>
#include <commctrl.h>
#include <propidl.h>
#include "uicommon.h"
#include "simcrack.h"
#include "wiadebug.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\ssmypics\sscommon\ssdata.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998, 1999, 2000
 *
 *  TITLE:       SSDATA.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        1/13/1999
 *
 *  DESCRIPTION: Encapsulates reading and writing setting for this screensaver
 *               from the registry
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "ssdata.h"
#include <shlobj.h>
#include "simreg.h"
#include "ssutil.h"

// These are defined so I can build using vc5 headers
#if !defined(CSIDL_WINDOWS)
#define CSIDL_WINDOWS                   0x0024        // GetWindowsDirectory()
#endif
#if !defined(CSIDL_MYPICTURES)
#define CSIDL_MYPICTURES                0x0027        // C:\Program Files\My Pictures
#endif


CMyDocsScreenSaverData::CMyDocsScreenSaverData( HKEY hKeyRoot, const CSimpleString &strRegistryKeyName )
  : m_hKeyRoot(hKeyRoot),
    m_strRegistryKeyName(strRegistryKeyName),
    m_strImageDirectory(TEXT("")),
    m_nPaintTimerInterval(0),
    m_nChangeTimerInterval(0),
    m_bDisplayFilename(0),
    m_nMaxScreenPercent(0),
    m_bDisableTransitions(0),
    m_bAllowStretching(false),
    m_bAllowKeyboardControl(true),
    m_nMaxFailedFiles(0),
    m_nMaxSuccessfulFiles(0),
    m_nMaxDirectories(0),
    m_pszImageDirectoryValue(TEXT("ImageDirectory")),
    m_pszPaintIntervalValue(TEXT("PaintInterval")),
    m_pszChangeIntervalValue(TEXT("ChangeInterval")),
    m_pszDisplayFilename(TEXT("DisplayFilename")),
    m_pszMaxScreenPercent(TEXT("MaxScreenPercent")),
    m_pszDisableTransitions(TEXT("DisableTransitions")),
    m_pszAllowStretching(TEXT("AllowStretching")),
    m_pszAllowKeyboardControl(TEXT("AllowKeyboardControl")),
    m_pszMaxFailedFiles(TEXT("MaxFailedFiles")),
    m_pszMaxSuccessfulFiles(TEXT("MaxSuccessfulFiles")),
    m_pszMaxDirectories(TEXT("MaxDirectories"))
{
    Read();
}


CMyDocsScreenSaverData::~CMyDocsScreenSaverData(void)
{
}


void CMyDocsScreenSaverData::Read(void)
{
    CSimpleReg reg( m_hKeyRoot, m_strRegistryKeyName, false, KEY_READ );
    m_strImageDirectory = reg.Query( m_pszImageDirectoryValue, GetDefaultImageDir() );
    m_nPaintTimerInterval = reg.Query( m_pszPaintIntervalValue, nDefaultPaintInterval );
    m_nChangeTimerInterval = reg.Query( m_pszChangeIntervalValue, nDefaultChangeInterval );
    m_bDisplayFilename = (reg.Query( m_pszDisplayFilename, bDefaultDisplayFilename ) != 0);
    m_nMaxScreenPercent = reg.Query( m_pszMaxScreenPercent, nDefaultScreenPercent );
    m_bDisableTransitions = (reg.Query( m_pszDisableTransitions, bDefaultDisableTransitions ) != 0);
    m_bAllowStretching = (reg.Query( m_pszAllowStretching, bDefaultAllowStretching ) != 0);
    m_bAllowKeyboardControl = (reg.Query( m_pszAllowKeyboardControl, bDefaultAllowKeyboardControl ) != 0);
    m_nMaxFailedFiles = reg.Query( m_pszMaxFailedFiles, nDefaultMaxFailedFiles );
    m_nMaxSuccessfulFiles = reg.Query( m_pszMaxSuccessfulFiles, nDefaultMaxSuccessfulFiles );
    m_nMaxDirectories = reg.Query( m_pszMaxDirectories, nDefaultMaxDirectories );
}

void CMyDocsScreenSaverData::Write(void)
{
    CSimpleReg reg( m_hKeyRoot, m_strRegistryKeyName, true, KEY_WRITE );
    //
    // If we don't have a directory, we will delete the value to cause the default to be used instead
    //
    if (!m_strImageDirectory.Length())
    {
        reg.Delete( m_pszImageDirectoryValue );
    }
    else
    {
        reg.Set( m_pszImageDirectoryValue, m_strImageDirectory );
    }
    reg.Set( m_pszPaintIntervalValue, m_nPaintTimerInterval );
    reg.Set( m_pszChangeIntervalValue, m_nChangeTimerInterval );
    reg.Set( m_pszDisplayFilename, (DWORD)m_bDisplayFilename );
    reg.Set( m_pszMaxScreenPercent, m_nMaxScreenPercent );
    reg.Set( m_pszDisableTransitions, (DWORD)m_bDisableTransitions );
    reg.Set( m_pszAllowStretching, (DWORD)m_bAllowStretching );
    reg.Set( m_pszAllowKeyboardControl, (DWORD)m_bAllowKeyboardControl );
    reg.Set( m_pszMaxFailedFiles, m_nMaxFailedFiles );
    reg.Set( m_pszMaxSuccessfulFiles, m_nMaxSuccessfulFiles );
    reg.Set( m_pszMaxDirectories, m_nMaxDirectories );
}

CSimpleString CMyDocsScreenSaverData::ImageDirectory(void) const
{
    return(m_strImageDirectory);
}

void CMyDocsScreenSaverData::ImageDirectory( const CSimpleString &str )
{
    m_strImageDirectory = str;
}

UINT CMyDocsScreenSaverData::ChangeInterval(void) const
{
    return(m_nChangeTimerInterval);
}

void CMyDocsScreenSaverData::ChangeInterval( UINT nInterval )
{
    m_nChangeTimerInterval = nInterval;
}

UINT CMyDocsScreenSaverData::PaintInterval(void) const
{
    return(m_nPaintTimerInterval);
}

void CMyDocsScreenSaverData::PaintInterval( UINT nInterval )
{
    m_nPaintTimerInterval = nInterval;
}

bool CMyDocsScreenSaverData::DisplayFilename(void) const
{
    return(m_bDisplayFilename);
}

void CMyDocsScreenSaverData::DisplayFilename( bool bDisplayFilename )
{
    m_bDisplayFilename = bDisplayFilename;
}

int CMyDocsScreenSaverData::MaxScreenPercent(void) const
{
    return m_nMaxScreenPercent;
}

void CMyDocsScreenSaverData::MaxScreenPercent( int nMaxScreenPercent )
{
    m_nMaxScreenPercent = nMaxScreenPercent;
}

bool CMyDocsScreenSaverData::DisableTransitions(void) const
{
    return m_bDisableTransitions;
}

void CMyDocsScreenSaverData::DisableTransitions( bool bDisableTransitions )
{
    m_bDisableTransitions = bDisableTransitions;
}

bool CMyDocsScreenSaverData::AllowStretching(void) const
{
    return m_bAllowStretching;
}

void CMyDocsScreenSaverData::AllowStretching( bool bAllowStretching )
{
    m_bAllowStretching = bAllowStretching;
}


bool CMyDocsScreenSaverData::AllowKeyboardControl(void) const
{
    return m_bAllowKeyboardControl;
}

void CMyDocsScreenSaverData::AllowKeyboardControl( bool bAllowKeyboardControl )
{
    m_bAllowKeyboardControl = bAllowKeyboardControl;
}

int CMyDocsScreenSaverData::MaxFailedFiles(void) const
{
    return m_nMaxFailedFiles;
}

void CMyDocsScreenSaverData::MaxFailedFiles( int nMaxFailedFiles )
{
    m_nMaxFailedFiles = nMaxFailedFiles;
}

int CMyDocsScreenSaverData::MaxSuccessfulFiles(void) const
{
    return m_nMaxSuccessfulFiles;
}

void CMyDocsScreenSaverData::MaxSuccessfulFiles( int nMaxSuccessfulFiles )
{
    m_nMaxSuccessfulFiles = nMaxSuccessfulFiles;
}

int CMyDocsScreenSaverData::MaxDirectories(void) const
{
    return m_nMaxDirectories;
}

void CMyDocsScreenSaverData::MaxDirectories( int nMaxDirectories )
{
    m_nMaxDirectories = nMaxDirectories;
}

CSimpleString CMyDocsScreenSaverData::GetDefaultImageDir(void)
{
    CSimpleString strResult(TEXT(""));
    LPITEMIDLIST pidl;
    TCHAR szPath[MAX_PATH];
    LPMALLOC pMalloc;
    HRESULT hr = SHGetMalloc(&pMalloc);
    if (SUCCEEDED(hr))
    {
        hr = SHGetSpecialFolderLocation( NULL, CSIDL_MYPICTURES, &pidl );
        if (SUCCEEDED(hr))
        {
            if (SHGetPathFromIDList( pidl, szPath ))
            {
                if (lstrlen(szPath))
                    strResult = szPath;
            }
            pMalloc->Free(pidl);
        }
        if (0 == strResult.Length())
        {
            hr = SHGetSpecialFolderLocation( NULL, CSIDL_PERSONAL, &pidl );
            if (SUCCEEDED(hr))
            {
                if (SHGetPathFromIDList( pidl, szPath ))
                {
                    if (lstrlen(szPath))
                        strResult = szPath;
                }
                pMalloc->Free(pidl);
            }
        }
        if (0 == strResult.Length())
        {
            hr = SHGetSpecialFolderLocation( NULL, CSIDL_WINDOWS, &pidl );
            if (SUCCEEDED(hr))
            {
                if (SHGetPathFromIDList( pidl, szPath ))
                {
                    if (lstrlen(szPath))
                        strResult = szPath;
                }
                pMalloc->Free(pidl);
            }
        }
        pMalloc->Release();
    }
    WIA_TRACE((TEXT("CImageScreenSaver::GetDefaultDirectory: returned %s\n"),strResult.String()));
    return(strResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\ssmypics\sscommon\sshndler.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       SSHNDLER.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        12/4/1999
 *
 *  DESCRIPTION:
 *
 *******************************************************************************/
#ifndef __SSHNDLER_H_INCLUDED
#define __SSHNDLER_H_INCLUDED

#include <windows.h>
#include "imagescr.h"
#include "extimer.h"
#include "simstr.h"
#include "findthrd.h"

//
// We will shuffle the list every [SHUFFLE_INTERVAL] images until we are done gathering files.
//
#define SHUFFLE_INTERVAL            50

//
// To decrease the tendency to see the same image first, we will try to vary the image that
// causes the screensaver to be started to a random image index less than this number
//
#define MAX_START_IMAGE             20

//
// Number of ms to wait before starting up the screensaver timers
// in case we don't find an image before this timer runs.
//
#define BACKUP_START_TIMER_PERIOD 5000

class CScreenSaverHandler
{
private:
    CImageScreenSaver        *m_pImageScreenSaver;
    HINSTANCE                 m_hInstance;
    CSimpleString             m_strRegistryPath;
    HWND                      m_hWnd;
    UINT                      m_nPaintTimerId;
    UINT                      m_nChangeTimerId;
    UINT                      m_nBackupStartTimerId;
    UINT                      m_nBackupStartTimerPeriod;
    UINT                      m_nFindNotifyMessage;
    bool                      m_bPaused;
    CExclusiveTimer           m_Timer;
    HANDLE                    m_hFindThread;
    HANDLE                    m_hFindCancel;
    bool                      m_bScreensaverStarted;
    int                       m_nStartImage;
    int                       m_nShuffleInterval;
    CRandomNumberGen          m_Random;

private:
    // No implementation
    CScreenSaverHandler(void);
    CScreenSaverHandler( const CScreenSaverHandler & );
    CScreenSaverHandler &operator=( const CScreenSaverHandler & );

public:
    void Initialize(void);
    CScreenSaverHandler( HWND hWnd, UINT nFindNotifyMessage, UINT nPaintTimer, UINT nChangeTimer, UINT nBackupStartTimer, LPCTSTR szRegistryPath, HINSTANCE hInstance );
    ~CScreenSaverHandler(void);

    // Message handlers
    bool HandleKeyboardMessage( UINT nMessage, WPARAM nVirtkey );
    void HandleConfigChanged(void);
    void HandleTimer( WPARAM nEvent );
    void HandlePaint(void);
    void HandleFindFile( CFoundFileMessageData *pFoundFileMessageData );
};

#endif // __SSHNDLER_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\ssmypics\sscommon\ssutil.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998, 1999, 2000
 *
 *  TITLE:       SSUTIL.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        1/13/1999
 *
 *  DESCRIPTION: Useful functions that are used more than once
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "ssutil.h"
#include <shlobj.h>
#include "isdbg.h"

bool ScreenSaverUtil::SetIcons( HWND hWnd, HINSTANCE hInstance, int nResId )
{
    HICON hIconSmall = (HICON)LoadImage( hInstance, MAKEINTRESOURCE(nResId), IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), 0 );
    HICON hIconLarge = (HICON)LoadImage( hInstance, MAKEINTRESOURCE(nResId), IMAGE_ICON, GetSystemMetrics(SM_CXICON), GetSystemMetrics(SM_CYICON), 0 );
    if (hIconSmall)
    {
        SendMessage( hWnd, WM_SETICON, ICON_SMALL, (LPARAM)hIconSmall );
    }
    if (hIconLarge)
    {
        SendMessage( hWnd, WM_SETICON, ICON_BIG, (LPARAM)hIconLarge );
    }
    return(hIconSmall && hIconLarge);
}

bool ScreenSaverUtil::IsValidRect( RECT &rc )
{
    return(rc.left < rc.right && rc.top < rc.bottom);
}

void ScreenSaverUtil::NormalizeRect( RECT &rc )
{
    if (rc.left > rc.right)
        Swap(rc.left,rc.right);
    if (rc.top > rc.bottom)
        Swap(rc.top,rc.bottom);
}

void ScreenSaverUtil::EraseDiffRect( HDC hDC, const RECT &oldRect, const RECT &newRect, HBRUSH hBrush )
{
    RECT rc;

    // Top
    rc.left = oldRect.left;
    rc.top = oldRect.top;
    rc.bottom = newRect.top;
    rc.right = oldRect.right;
    if (IsValidRect(rc))
    {
        FillRect( hDC, &rc, hBrush );
    }
    // Left
    rc.left = oldRect.left;
    rc.top = newRect.top;
    rc.right = newRect.left;
    rc.bottom = newRect.bottom;
    if (IsValidRect(rc))
    {
        FillRect( hDC, &rc, hBrush );
    }
    // Right
    rc.left = newRect.right;
    rc.top = newRect.top;
    rc.right = oldRect.right;
    rc.bottom = newRect.bottom;
    if (IsValidRect(rc))
    {
        FillRect( hDC, &rc, hBrush );
    }
    // Bottom
    rc.left = oldRect.left;
    rc.top = newRect.bottom;
    rc.right = oldRect.right;
    rc.bottom = oldRect.bottom;
    if (IsValidRect(rc))
    {
        FillRect( hDC, &rc, hBrush );
    }
}

static int CALLBACK ChangeDirectoryCallback( HWND hWnd, UINT uMsg, LPARAM lParam, LPARAM lpData )
{
    if (uMsg == BFFM_INITIALIZED)
    {
        SendMessage( hWnd, BFFM_SETSELECTION, 1, (LPARAM)lpData );
    }
    return 0;
}


bool ScreenSaverUtil::SelectDirectory( HWND hWnd, LPCTSTR pszPrompt, TCHAR szDirectory[] )
{
    bool bResult = false;
    LPMALLOC pMalloc;
    HRESULT hr = SHGetMalloc(&pMalloc);
    if (SUCCEEDED(hr))
    {
        TCHAR szDisplayName[MAX_PATH];

        BROWSEINFO BrowseInfo;
        ::ZeroMemory( &BrowseInfo, sizeof(BrowseInfo) );
        BrowseInfo.hwndOwner = hWnd;
        BrowseInfo.pszDisplayName = szDisplayName;
        BrowseInfo.lpszTitle = pszPrompt;
        BrowseInfo.ulFlags = BIF_RETURNONLYFSDIRS;
        BrowseInfo.lpfn = ChangeDirectoryCallback;
        BrowseInfo.lParam = (LPARAM)szDirectory;
        BrowseInfo.iImage = 0;

        LPITEMIDLIST pidl = SHBrowseForFolder(&BrowseInfo);

        if (pidl != NULL)
        {
            TCHAR szResult[MAX_PATH];
            if (SHGetPathFromIDList(pidl,szResult))
            {
                lstrcpy( szDirectory, szResult );
                bResult = true;
            }
            pMalloc->Free(pidl);
        }
        pMalloc->Release();
    }
    return bResult;
}

HPALETTE ScreenSaverUtil::SelectPalette( HDC hDC, HPALETTE hPalette, BOOL bForceBackground )
{
    HPALETTE hOldPalette = NULL;
    if (hDC && hPalette)
    {
        hOldPalette = ::SelectPalette( hDC, hPalette, bForceBackground );
        RealizePalette( hDC );
        SetBrushOrgEx( hDC, 0,0, NULL );
    }
    return hOldPalette;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\ssmypics\ssmypics\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by ssmypics.rc
//
#define IDC_FREQUENCY                   1003
#define IDC_IMAGEDIR                    1004
#define IDC_BROWSE                      1005
#define IDC_MINUTES_AND_SECONDS         1006
#define IDC_DISPLAYFILENAME             1008
#define IDS_MINUTES_AND_SECONDS         2000
#define IDS_MINUTE_AND_SECONDS          2001
#define IDS_MINUTES_AND_SECOND          2002
#define IDD_CONFIG_DIALOG               2003
#define IDS_MINUTE_AND_SECOND           2003
#define IDS_SECONDS                     2004
#define IDI_MONITOR                     2005
#define IDS_SECOND                      2005
#define IDS_MINUTES                     2006
#define IDS_MINUTE                      2007
#define IDS_DIRECTORYPROMPT             2008
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        2007
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1009
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\ssmypics\ssmypics\sources.inc ===
SYNCHRONIZE_DRAIN=1

!include $(PROJECT_ROOT)\ui\uienv.inc
SOURCES_USED  = $(SOURCES_USED) $(PROJECT_ROOT)\ui\uienv.inc

MAJORCOMP=imagein
MINORCOMP=ssmypics

TARGETNAME=ssmypics
TARGETPATH=obj
TARGETTYPE=UMAPPL_NOLIB
TARGETLIBS=

ATL_VER = 30
USE_STATIC_ATL = 1

UMTYPE=windows
UMAPPL=ssmypics
UMAPPLEXT=.scr
UMLIBS=$(_OBJ_DIR)\*\ssmypics.res

INCLUDES=$(INCLUDES)                          \
         $(PROJECT_ROOT)\ui\ssmypics\sscommon;

LINKLIBS=\
        $(BASEDIR)\public\sdk\lib\*\$(SCRNSAVE_LIB_NAME).lib       \
        $(BASEDIR)\public\sdk\lib\*\shell32.lib                    \
        $(BASEDIR)\public\sdk\lib\*\msimg32.lib                    \
        $(BASEDIR)\public\sdk\lib\*\oleaut32.lib                   \
        $(BASEDIR)\public\sdk\lib\*\ole32.lib                      \
        $(BASEDIR)\public\sdk\lib\*\uuid.lib                       \
        $(BASEDIR)\public\sdk\lib\*\gdiplus.lib                    \
        $(BASEDIR)\public\sdk\lib\*\shlwapi.lib                    \
        $(BASEDIR)\public\sdk\lib\*\comctl32.lib                   \
        $(BASEDIR)\public\sdk\lib\$(PLATFORM_SUFFIX)\*\wiaguid.lib \
        $(PROJECT_ROOT)\lib\$(PLATFORM_SUFFIX)\*\psutil.lib        \
        $(PROJECT_ROOT)\ui\lib\$(PLATFORM_SUFFIX)\*\uicommon.lib   \
        $(PROJECT_ROOT)\ui\lib\$(PLATFORM_SUFFIX)\*\sscommon.lib

SOURCES=\
        ..\ssmypics.cpp \
        ..\ssmypics.rc


PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

SXS_ASSEMBLY_NAME=Microsoft.Windows.PrintingAndImaging.ssmypics
SXS_ASSEMBLY_VERSION=1.0 
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=1
SXS_MANIFEST=ssmypics.Manifest
SXS_MANIFEST_IN_RESOURCES=1
SXS_NO_BINPLACE=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\ssmypics\sstest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sstest.rc
//
#define IDC_FREQUENCY                   1003
#define IDC_IMAGEDIR                    1004
#define IDC_BROWSE                      1005
#define IDC_MINUTES_AND_SECONDS         1006
#define IDC_DISPLAYFILENAME             1008
#define IDS_MINUTES_AND_SECONDS         2000
#define IDS_MINUTE_AND_SECONDS          2001
#define IDS_MINUTES_AND_SECOND          2002
#define IDD_CONFIG_DIALOG               2003
#define IDS_MINUTE_AND_SECOND           2003
#define IDS_SECONDS                     2004
#define IDI_MONITOR                     2005
#define IDS_SECOND                      2005
#define IDS_MINUTES                     2006
#define IDS_MINUTE                      2007
#define IDS_DIRECTORYPROMPT             2008
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        2007
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1009
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\ssmypics\sstest\sstest.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
*
*  TITLE:       SSTEST.CPP
*
*  VERSION:     1.0
*
*  AUTHOR:      ShaunIv
*
*  DATE:        1/19/1999
*
*  DESCRIPTION: Test driver for My Pictures Screensaver
*
*******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include <windows.h>
#include <uicommon.h>
#include <initguid.h>
#include <gdiplus.h>
#include "cfgdlg.h"
#include "imagescr.h"
#include "simcrack.h"
#include "scrnsave.h"
#include "ssconst.h"
#include "resource.h"
#include "sshndler.h"
#include "ssmprsrc.h"
#include "findthrd.h"

#define MAIN_WINDOW_CLASSNAME      TEXT("TestScreenSaverWindow")

#define ID_PAINTTIMER              1
#define ID_CHANGETIMER             2
#define ID_STARTTIMER              3
#define UWM_FINDFILE               (WM_USER+1301)

HINSTANCE g_hInstance;

class CMainWindow
{
private:
    HWND m_hWnd;
    CScreenSaverHandler *m_pScreenSaverHandler;
public:
    CMainWindow( HWND hWnd )
        : m_hWnd(hWnd),m_pScreenSaverHandler(NULL)
    {
    }
    virtual ~CMainWindow(void)
    {
    }
    static HWND Create( DWORD dwExStyle, LPCTSTR lpWindowName, DWORD dwStyle, int x, int y, int nWidth, int nHeight, HWND hWndParent, HMENU hMenu, HINSTANCE hInstance )
    {
        RegisterClass( hInstance );
        return CreateWindowEx( dwExStyle, MAIN_WINDOW_CLASSNAME, lpWindowName, dwStyle, x, y, nWidth, nHeight, hWndParent, hMenu, hInstance, NULL );
    }
    static bool RegisterClass( HINSTANCE hInstance )
    {
        WNDCLASSEX wcex;
        ZeroMemory( &wcex, sizeof(wcex) );
        wcex.cbSize = sizeof(wcex);
        wcex.style = CS_DBLCLKS;
        wcex.lpfnWndProc = WndProc;
        wcex.hInstance = hInstance;
        wcex.hIcon = LoadIcon( NULL, IDI_APPLICATION );
        wcex.hIconSm = LoadIcon( NULL, IDI_APPLICATION );
        wcex.hCursor = LoadCursor( NULL, IDC_ARROW );
        wcex.hbrBackground = (HBRUSH)GetStockObject(BLACK_BRUSH);
        wcex.lpszClassName = MAIN_WINDOW_CLASSNAME;
        BOOL res = (::RegisterClassEx(&wcex) != 0);
        return (res != 0);
    }
    LRESULT OnDestroy( WPARAM, LPARAM )
    {
        if (m_pScreenSaverHandler)
            delete m_pScreenSaverHandler;
        m_pScreenSaverHandler = NULL;
        PostQuitMessage(0);
        return 0;
    }

    LRESULT OnTimer( WPARAM wParam, LPARAM )
    {
        if (m_pScreenSaverHandler)
            m_pScreenSaverHandler->HandleTimer(wParam);
        return 0;
    }


    LRESULT OnPaint( WPARAM, LPARAM )
    {
        if (m_pScreenSaverHandler)
            m_pScreenSaverHandler->HandlePaint();
        return 0;
    }

    LRESULT OnShowWindow( WPARAM, LPARAM )
    {
        if (!m_pScreenSaverHandler)
        {
            m_pScreenSaverHandler = new CScreenSaverHandler( m_hWnd, UWM_FINDFILE, ID_PAINTTIMER, ID_CHANGETIMER, ID_STARTTIMER, REGISTRY_PATH, g_hInstance );
            if (m_pScreenSaverHandler)
                m_pScreenSaverHandler->Initialize();
        }
        return 0;
    }

    LRESULT OnLButtonDblClk( WPARAM, LPARAM )
    {
        RegisterDialogClasses(g_hInstance);
        DialogBox( g_hInstance, MAKEINTRESOURCE(IDD_CONFIG_DIALOG), m_hWnd, (DLGPROC)ScreenSaverConfigureDialog );
        return 0;
    }

    LRESULT OnConfigChanged( WPARAM, LPARAM )
    {
        if (m_pScreenSaverHandler)
            m_pScreenSaverHandler->HandleConfigChanged();
        return 0;
    }

    LRESULT OnSize( WPARAM, LPARAM )
    {
        if (m_pScreenSaverHandler)
            m_pScreenSaverHandler->HandleConfigChanged();
        return 0;
    }

    LRESULT OnKeydown( WPARAM wParam, LPARAM )
    {
        if (m_pScreenSaverHandler)
            m_pScreenSaverHandler->HandleKeyboardMessage( WM_KEYDOWN, static_cast<int>(wParam) );
        return 0;
    }

    LRESULT OnKeyup( WPARAM wParam, LPARAM )
    {
        if (m_pScreenSaverHandler)
            m_pScreenSaverHandler->HandleKeyboardMessage( WM_KEYUP, static_cast<int>(wParam) );
        return 0;
    }

    LRESULT OnChar( WPARAM wParam, LPARAM )
    {
        if (m_pScreenSaverHandler)
            m_pScreenSaverHandler->HandleKeyboardMessage( WM_CHAR, static_cast<int>(wParam) );
        return 0;
    }

    LRESULT OnFindFile( WPARAM wParam, LPARAM lParam )
    {
        if (m_pScreenSaverHandler)
            m_pScreenSaverHandler->HandleFindFile( reinterpret_cast<CFoundFileMessageData*>(lParam) );
        return 0;
    }

    static LRESULT CALLBACK WndProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
    {
        SC_BEGIN_MESSAGE_HANDLERS(CMainWindow)
        {
            SC_HANDLE_MESSAGE( WM_SHOWWINDOW, OnShowWindow );
            SC_HANDLE_MESSAGE( WM_DESTROY, OnDestroy );
            SC_HANDLE_MESSAGE( WM_TIMER, OnTimer );
            SC_HANDLE_MESSAGE( WM_PAINT, OnPaint );
            SC_HANDLE_MESSAGE( WM_SIZE, OnSize );
            SC_HANDLE_MESSAGE( WM_KEYDOWN, OnKeydown );
            SC_HANDLE_MESSAGE( WM_KEYUP, OnKeyup );
            SC_HANDLE_MESSAGE( WM_CHAR, OnChar );
            SC_HANDLE_MESSAGE( WM_LBUTTONDBLCLK, OnLButtonDblClk );
            SC_HANDLE_MESSAGE( UWM_CONFIG_CHANGED, OnConfigChanged );
            SC_HANDLE_MESSAGE( UWM_FINDFILE, OnFindFile );
        }
        SC_END_MESSAGE_HANDLERS();
    }
};


int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE, LPSTR, int nCmdShow )
{
    WIA_DEBUG_CREATE( hInstance );
    HRESULT hr = CoInitialize(NULL);
    if (SUCCEEDED(hr))
    {
        g_hInstance = hInstance;

        HWND hwndMain = CMainWindow::Create( 0, TEXT("My Pictures Screen Saver Test"), WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, hInstance );
        if (hwndMain)
        {
            ShowWindow( hwndMain, nCmdShow );
            UpdateWindow( hwndMain );

            MSG msg;
            while (GetMessage(&msg, 0, 0, 0))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
        CoUninitialize();
    }
    WIA_DEBUG_DESTROY();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\ssmypics\ssmypics\ssmypics.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       SSMYPICS.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        1/13/1999
 *
 *  DESCRIPTION: Main screen saver wndproc
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include <windows.h>
#include <uicommon.h>
#include <commctrl.h>
#include <scrnsave.h>
#include <initguid.h>
#include <gdiplus.h>
#include "resource.h"
#include "imagescr.h"
#include "ssdata.h"
#include "isdbg.h"
#include "simcrack.h"
#include "waitcurs.h"
#include "ssutil.h"
#include "ssconst.h"
#include "sshndler.h"
#include "findthrd.h"

#define ID_PAINTTIMER   1
#define ID_CHANGETIMER  2
#define ID_STARTTIMER   3
#define UWM_FINDFILE    (WM_USER+1301)

HINSTANCE g_hInstance = NULL;

LRESULT WINAPI ScreenSaverProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    CScreenSaverHandler *pScreenSaverHandler = (CScreenSaverHandler*)GetWindowLongPtr(hWnd,GWLP_USERDATA);
    switch (uMsg)
    {
    case WM_CREATE:
        if (FAILED(CoInitialize(NULL)))
            return -1;
        g_hInstance = ((LPCREATESTRUCT)lParam)->hInstance;
        SetErrorMode(SEM_FAILCRITICALERRORS);
        break;

    case WM_ERASEBKGND:
        if (!pScreenSaverHandler)
        {
            pScreenSaverHandler = new CScreenSaverHandler( hWnd, UWM_FINDFILE, ID_PAINTTIMER, ID_CHANGETIMER, ID_STARTTIMER, REGISTRY_PATH, g_hInstance );
            if (pScreenSaverHandler)
                pScreenSaverHandler->Initialize();
        }
        SetWindowLongPtr( hWnd, GWLP_USERDATA, reinterpret_cast<LONG_PTR>(pScreenSaverHandler) );
        break;

    case WM_TIMER:
        if (pScreenSaverHandler)
            pScreenSaverHandler->HandleTimer(wParam);
        break;

    case WM_KEYDOWN:
    case WM_CHAR:
    case WM_KEYUP:
        if (pScreenSaverHandler)
            if (pScreenSaverHandler->HandleKeyboardMessage( uMsg, wParam ))
                return 0;
        break;

    case WM_PAINT:
        if (pScreenSaverHandler)
            pScreenSaverHandler->HandlePaint();
        break;

    case UWM_FINDFILE:
        if (pScreenSaverHandler)
            pScreenSaverHandler->HandleFindFile( reinterpret_cast<CFoundFileMessageData*>(lParam) );
        break;

    case WM_DESTROY:
        if (pScreenSaverHandler)
            delete pScreenSaverHandler;
        CoUninitialize();
        SetWindowLongPtr( hWnd, GWLP_USERDATA, (LONG_PTR)0 );
        break;
    }
    return (DefScreenSaverProc(hWnd, uMsg, wParam, lParam));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\32bitdib.cpp ===
// 32BitDibWrapper.cpp: implementation of the C32BitDibWrapper class.
//
//////////////////////////////////////////////////////////////////////

#include "precomp.h"
#pragma hdrstop

#include "32BitDib.h"

// helper functions

// sum of RGB vals
inline ULONG Intensity(ULONG value)
{
    return(value&0xff)+((value&0xff00)>>8)+((value&0xff0000)>>16);
}


// we should make a Difference Template to clean up this code

inline UCHAR Difference(UCHAR a, UCHAR b)
{
    if (a>b) return(a-b);
    else return(b-a);
}

inline ULONG Difference(ULONG a, ULONG b)
{
    if (a>b) return(a-b);
    else return(b-a);
}

inline LONG Difference(LONG a, LONG b)
{
    if (a>b) return(a-b);
    else return(b-a);
}

int inline MAX(int a, int b)
{
    if (a>b) return(a);
    return(b);
}

int inline MIN(int a, int b)
{
    if (a<b) return(a);
    return(b);
}

// shadows are gray... if you aint gray... you aint a shadow
// this function hasn't yet been optimized
inline ULONG DifferenceFromGray(ULONG value)
{
    UCHAR g,b;//,r;
//  r=(UCHAR)(value& 0x0000ff);
    g=(UCHAR)((value& 0x00ff00)>>8);
    b=(UCHAR)((value& 0xff0000)>>16);
    // use this instead of the complete formula (uncomment the commented out code for the complete formula)
    // allow yellow scanner backgrounds
    return(ULONG)(Difference(b,g));//+Difference(r,g)+Difference(g,b));
}

// sets up a C32BitDibWrapper where each pixel (x,y) is the difference bettween the value of the pixel (x,y) on
// bitmap1 and the pixel (x,y) on bitmap2
int C32BitDibWrapper::CreateDifferenceBitmap(C32BitDibWrapper *pBitmap1, C32BitDibWrapper *pBitmap2)  // constructs a new dib that is the difference of the two other dibs
{                                                // image - blur(image) = detect edges.
    //
    // Destroy the old bitmap
    //
    if (m_pBits)
    {
        delete[] m_pBits;
        m_pBits = NULL;
    }
    m_nBitmapWidth=-1;
    m_nBitmapHeight=-1;

    //
    // Validate arguments
    //
    if (pBitmap1==NULL || pBitmap2==NULL)
    {
        return(FALSE);
    }

    if (pBitmap1->m_nBitmapWidth != pBitmap2->m_nBitmapWidth)
    {
        return(FALSE);
    }

    if (pBitmap1->m_nBitmapHeight != pBitmap2->m_nBitmapHeight)
    {
        return(FALSE);
    }

    if (pBitmap1->m_pBits==NULL || pBitmap2->m_pBits==NULL)
    {
        return(FALSE);
    }

    //
    // How many bytes do we need?
    //
    int nNumBytes = pBitmap1->m_nBitmapWidth * pBitmap1->m_nBitmapHeight * sizeof(ULONG);

    //
    // Allocate the bytes, return false if we weren't successful
    //
    m_pBits = new BYTE[nNumBytes];
    if (m_pBits==NULL)
    {
        return(FALSE);
    }

    //
    // Save the dimensions
    //
    m_nBitmapWidth=pBitmap1->m_nBitmapWidth;
    m_nBitmapHeight=pBitmap1->m_nBitmapHeight;

    //
    // Compute the difference
    //
    for (int i=0;i<nNumBytes;i++)
    {
        m_pBits[i]=Difference(pBitmap1->m_pBits[i],pBitmap2->m_pBits[i]);
    }
    return(TRUE);
}

// creates a C32BitDibWrapper which is identical to the C32BitDibWrapper passed as *bitmap
C32BitDibWrapper::C32BitDibWrapper(C32BitDibWrapper *pBitmap) // copy constructor
  : m_pBits(NULL),
    m_nBitmapWidth(-1),
    m_nBitmapHeight(-1)
{
    if (pBitmap && pBitmap->IsValid())
    {
        int nNumWords=pBitmap->m_nBitmapWidth*pBitmap->m_nBitmapHeight;
        ULONG* pBitmapCopy = new ULONG[nNumWords];
        ULONG* pSourceBitmap = (ULONG*)pBitmap->m_pBits;
        if (pBitmapCopy && pSourceBitmap)
        {
            CopyMemory( pBitmapCopy, pSourceBitmap, nNumWords*sizeof(ULONG) );
            m_pBits=(BYTE *)pBitmapCopy;
            m_nBitmapHeight=pBitmap->m_nBitmapHeight;
            m_nBitmapWidth=pBitmap->m_nBitmapWidth;
        }
    }
}

// creates a blank dib wrapper w pixels wide and h pixels high
C32BitDibWrapper::C32BitDibWrapper(int w, int h)
  : m_pBits(NULL),
    m_nBitmapWidth(-1),
    m_nBitmapHeight(-1)
{
    int nNumWords=w*h;
    ULONG *pBitmapCopy = new ULONG[nNumWords];
    if (pBitmapCopy)
    {
        ZeroMemory(pBitmapCopy,nNumWords*sizeof(ULONG));
        m_pBits=(BYTE*)pBitmapCopy;
        m_nBitmapHeight=h;
        m_nBitmapWidth=w;
    }
}

// creates a C32BitDibWrapper given the bitmap refered to by pBitmap
C32BitDibWrapper::C32BitDibWrapper(BITMAP bm)
  : m_pBits(NULL),
    m_nBitmapWidth(-1),
    m_nBitmapHeight(-1)
{
    BYTE* pDibBits=(BYTE*)(bm.bmBits);
    if (pDibBits!=NULL && bm.bmWidth>0 && bm.bmHeight>0 && bm.bmBitsPixel>0 && bm.bmBitsPixel<=32) // is it a valid bitmap?
    {
        int nDepth = bm.bmBitsPixel;

        m_nBitmapWidth = bm.bmWidth;
        m_nBitmapHeight = bm.bmHeight;

        //
        // convert to a 32 bit bitmap
        //
        m_pBits=ConvertBitmap(pDibBits,nDepth,32);
        if (!m_pBits)
        {
            m_nBitmapWidth=-1;
            m_nBitmapHeight=-1;
        }
    }
}

// constructor from a memory mapped file bitmap
C32BitDibWrapper::C32BitDibWrapper(BYTE* pDib)
  : m_pBits(NULL),
    m_nBitmapWidth(-1),
    m_nBitmapHeight(-1)
{
    if (pDib)
    {
        //
        // get pointer to just the image bits:
        //
        PBITMAPINFO pBitmapInfo=(PBITMAPINFO)(pDib + sizeof(BITMAPFILEHEADER));

        BYTE* pDibBits = NULL;
        switch (pBitmapInfo->bmiHeader.biBitCount)
        {
        case 24:
            pDibBits=pDib+GetBmiSize((PBITMAPINFO)(pDib + sizeof(BITMAPFILEHEADER)))+ sizeof(BITMAPFILEHEADER);
            break;
        case 8:
            pDibBits=pDib+GetBmiSize((PBITMAPINFO)(pDib + sizeof(BITMAPFILEHEADER)))+ sizeof(BITMAPFILEHEADER)-256*4+4;
            break;
        case 1:
            pDibBits=pDib+GetBmiSize((PBITMAPINFO)(pDib + sizeof(BITMAPFILEHEADER)))+ sizeof(BITMAPFILEHEADER)-4;
            break;
        }

        if (pDibBits)
        {
            m_pBits=ConvertBitmap(pDibBits,pBitmapInfo->bmiHeader.biBitCount,32);// convert to a 32 bit bitmap
            if (m_pBits)
            {
                m_nBitmapWidth=pBitmapInfo->bmiHeader.biWidth;
                m_nBitmapHeight=pBitmapInfo->bmiHeader.biHeight;
            }
        }
    }
}

// create an empty wrapper
// we later expect to fill the wrapper using CreateDifferenceBitmap
C32BitDibWrapper::C32BitDibWrapper(void)
  : m_pBits(NULL),
    m_nBitmapWidth(-1),
    m_nBitmapHeight(-1)
{
}

C32BitDibWrapper::~C32BitDibWrapper(void)
{
    Destroy();
}


void C32BitDibWrapper::Destroy(void)
{
    if (m_pBits)
    {
        delete[] m_pBits;
        m_pBits = NULL;
    }
    m_nBitmapWidth=-1;
    m_nBitmapHeight=-1;
}

//
//  helper function which converts between 32 bit and other less worthy formats
//  32 bit dibs are stored in the following format
//  xxxxxxxxRRRRRRRRGGGGGGGGBBBBBBBB 8 blank bits followed by 8 bits for each RGB channel
//
//  not optimized for speed
//
// if we are being handed a large number of 300 dpi bitmaps, this could become an important function to
// optimize... otherwise its fine in its current form
//
BYTE* C32BitDibWrapper::ConvertBitmap( BYTE* pSource, int bitsPerSource, int bitsPerDest )
{
    BYTE* pDest = NULL;
    long x, y, nSourceLocation=0, nTargetLocation=0;
    int i, nDWordAlign;

    //
    // Compute the dword align space for each line
    //
    if (m_nBitmapWidth%4!=0)
        nDWordAlign=4-(m_nBitmapWidth*3)%4;
    else nDWordAlign=0;

    //
    // Convert from a 24 bit bitmap to a 32 bit bitmap
    // Pretty straight forward except that we have to watch out for
    // DWORD align stuff with 24 bit bitmaps
    //
    if (bitsPerSource==24 && bitsPerDest==32)
    {
        pDest = new BYTE[m_nBitmapWidth*m_nBitmapHeight*sizeof(ULONG)];

        //
        // with fancy bit twiddling, we can get things done with one operation per 32
        // bit pixel instead of 3 without much trouble if this routine becomes a
        // performance bottlekneck, we should modify this code
        //
        // loop through all pixels adding 8 bits of zeroed out data at the end of
        // each pSource line.  00000000RRRRRRRRGGGGGGGGBBBBBBBB
        //
        if (pDest)
        {
            for (y=0;y<m_nBitmapHeight;y++)
            {
                for (x=0;x<m_nBitmapWidth;x++)
                {
                    pDest[nTargetLocation++]=pSource[nSourceLocation++];
                    pDest[nTargetLocation++]=pSource[nSourceLocation++];
                    pDest[nTargetLocation++]=pSource[nSourceLocation++];
                    pDest[nTargetLocation++]=0;
                }
                nSourceLocation+=nDWordAlign; // skip nDWordAlign pixels... 24 bit bitmaps are DWORD alligned
            }
        }
        return(pDest);
    }

    //
    // Convert from an 8 bit bitmap to a 32 bit bitmap
    //
    else if (bitsPerSource==8 && bitsPerDest==32)
    {
        pDest = new BYTE[m_nBitmapWidth*m_nBitmapHeight*sizeof(ULONG)];
        if (pDest)
        {
            for (y=0;y<m_nBitmapHeight;y++) // loop through all pixels (x,y)
            {
                for (x=0;x<m_nBitmapWidth;x++)
                {
                    pDest[nTargetLocation++]=pSource[nSourceLocation];
                    pDest[nTargetLocation++]=pSource[nSourceLocation];
                    pDest[nTargetLocation++]=pSource[nSourceLocation];
                    pDest[nTargetLocation++]=0;
                    nSourceLocation++;
                }
                if (m_nBitmapWidth%4!=0)
                {
                    //
                    // handle dword alignment issues for 8 bit dibs
                    //
                    nSourceLocation+=4-(m_nBitmapWidth)%4;
                }
            }
        }
        return(pDest);
    }

    //
    // Convert from a 1 bit B&W bitmap to a 32 bit bitmap
    //
    if (bitsPerSource==1 && bitsPerDest==32)
    {
        BYTE mask[8];
        BYTE convert[255];
        BYTE nCurrent;
        int nByte = 0,nBit = 0;
        int nLineWidth;

        //
        // mask[i] = 2^i
        //
        for (i=0;i<8;i++)
        {
            mask[i]=1<<i;
        }

        //
        // all values of convert other than convert[0] are set to 0
        //
        convert[0]=0;
        for (i=1;i<256;i++)
        {
            convert[i]=255;
        }

        nLineWidth=((m_nBitmapWidth+31)/32)*4;

        //
        // loop through all bitmap pixels keeping track of
        // byte which indicates the byte position of the pixel (x,y) in the pSource bitmap
        // bit which indicates the bit position of the pixel (x,y) within the byte
        // desLocation which represents the byte position of the 32 bit dib wrapper
        //
        // loop through all bitmap pixels keeping track of byte which indicates the
        // byte position of the pixel (x,y) in the pSource bitmap bit which indicates
        // the bit position of the pixel (x,y) within the byte desLocation which
        // represents the byte position of the 32 bit dib wrapper
        //

        pDest = new BYTE[m_nBitmapWidth*m_nBitmapHeight*sizeof(ULONG)];
        if (pDest)
        {
            for (y=0;y<m_nBitmapHeight;y++)
            {
                nBit=0;
                nByte=y*nLineWidth;
                for (x=0;x<m_nBitmapWidth;x++)
                {
                    if (nBit==8)
                    {
                        nBit=0;
                        nByte++;
                    }

                    nCurrent=pSource[nByte]&mask[nBit];
                    nCurrent=convert[nCurrent];
                    pDest[nTargetLocation++]=static_cast<BYTE>(nCurrent);
                    pDest[nTargetLocation++]=static_cast<BYTE>(nCurrent);
                    //
                    // hack to prevent shadow detection for 1 nBit dibs.
                    // set the blue channel to 150 so that shadow detection doesn't kick in
                    //
                    pDest[nTargetLocation++]=nCurrent&150;
                    pDest[nTargetLocation++]=0;
                    nBit++;
                }
            }
        }
        return(pDest);
    }


    //
    // Only used for debugging purposes
    // Converts a 32 bit bitmap down to 24 bits so that we can quickly display it
    //
    if (bitsPerSource==32 && bitsPerDest==24) // pretty straight forward except that we have to watch out for DWORD align stuff with 24 bit bitmaps
    {
        pDest = new BYTE[(m_nBitmapWidth*3+nDWordAlign)*m_nBitmapHeight];
        if (pDest)
        {
            for (y=0;y<m_nBitmapHeight;y++)
            {
                for (x=0;x<m_nBitmapWidth;x++)
                {
                    pDest[nTargetLocation++]=pSource[nSourceLocation++];
                    pDest[nTargetLocation++]=pSource[nSourceLocation++];
                    pDest[nTargetLocation++]=pSource[nSourceLocation++];
                    //
                    // pSource is 32 bits... ignore the first 8 bits
                    //
                    nSourceLocation++;
                }
                //
                // handle dword alignment issues for 24 bit dibs
                //
                for (i=0;i<nDWordAlign;i++)
                {
                    pDest[nTargetLocation++]=255;
                }
            }
        }
        return(pDest);
    }
    return(pDest);
}

// blurs the bitmap both horizontally and vertically
int C32BitDibWrapper::Blur(void)
{
    BYTE *pBits=pointerToBlur();
    if (m_pBits)
    {
        delete[] m_pBits;
    }
    m_pBits = pBits;
    return(TRUE);
}

// this function should only be used if the current dib wrapper is blank
int C32BitDibWrapper::CreateBlurBitmap(C32BitDibWrapper * pSource)
{
    if (pSource!=NULL && pSource->m_pBits!=NULL)
    {
        Destroy();

        m_pBits=pSource->pointerToBlur();
        //
        // the blurred bitmap will have the same dimensions as the pSource bitmap
        //
        m_nBitmapWidth=pSource->m_nBitmapWidth;
        m_nBitmapHeight=pSource->m_nBitmapHeight;
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}

// identical to the previous function, except that we use a horizontal blur instead of blur
int C32BitDibWrapper::CreateHorizontalBlurBitmap(C32BitDibWrapper * pSource)
{
    if (pSource!=NULL && pSource->IsValid())
    {
        Destroy();

        m_pBits=pSource->pointerToHorizontalBlur();
        if (m_pBits)
        {
            m_nBitmapWidth=pSource->m_nBitmapWidth;
            m_nBitmapHeight=pSource->m_nBitmapHeight;
        }
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}

int C32BitDibWrapper::CreateVerticalBlurBitmap(C32BitDibWrapper * pSource)
{
    //
    // Nuke the old bitmap
    //
    Destroy();

    if (pSource!=NULL && pSource->IsValid())
    {
        m_pBits=pSource->pointerToVerticalBlur();
        m_nBitmapWidth=pSource->m_nBitmapWidth;
        m_nBitmapHeight=pSource->m_nBitmapHeight;
        return(TRUE);
    }
    return(FALSE);
}


// blur the bitmap
BYTE* C32BitDibWrapper::pointerToBlur(void)
{
    if (m_pBits!=NULL)
    {
        int x,y;
        int position; // position in old bitmap
        ULONG* pBlurredBitmap;
        ULONG* pSource;
        int numPixels;
        numPixels=m_nBitmapWidth*m_nBitmapHeight; // calculate the total number of pixels in the bitmap
        pSource = (ULONG *)m_pBits; // we want to deal with data in 32 bit chunks
        pBlurredBitmap = new ULONG[numPixels]; // create an array to hold the blurred bitmap

        if (pBlurredBitmap==NULL) return(NULL); // unable to alloc memory

        // handle edge pixels
        // we do not blur edge pixels
        // if needed, edge pixels could be blurred here

        // blur top and bottom edge pixels
        for (x=0;x<m_nBitmapWidth;x++)
        {
            pBlurredBitmap[x] = pSource[x]; // top row
            pBlurredBitmap[numPixels-x-1] = pSource[numPixels-x-1]; // bottom row
        }

        // vertical sides
        for (position=m_nBitmapWidth;position+m_nBitmapWidth<numPixels;position+=m_nBitmapWidth)
        {
            pBlurredBitmap[position] = pSource[position]; // left edge
            pBlurredBitmap[position+m_nBitmapWidth-1] = pSource[position+m_nBitmapWidth-1]; // right edge
        }

        // now blur the bitmap
        // position indicates the location of the pixel (x,y) in the array
        position=m_nBitmapWidth-1;
        for (y=1;y<m_nBitmapHeight-1;y++) // loop through all pixels except for 1 pixel wide outside edge
        {
            position++;
            for (x=1;x<m_nBitmapWidth-1;x++)
            {
                position++;
                // we wish to take the average of the pixel directly below the pixel, the pixel directly below the pixel
                // the pixel directly to the right of the pixel and the pixel directly to the left of the pixel
                // we can do this 1 dword at a time and without any bit shifting by the following algorithm

                // problem.  we cannot simply add the values of all four pixels and then divide by four
                // because or bit overflow from one RGB channel to another.  to avoid this overflow, we start by
                // eliminating the two low order bits in each of the 3 color channels
                // we use the filter 0xfafafa to remove the 2 low order bits from each of the 3 color channels
                // e.g. RRRRRRRRGGGGGGGGBBBBBBBB goes to RRRRRR00GGGGGG00BBBBBB00
                // next shift each pixel over two bits so RRRRRR00GGGGGG00BBBBBB00 --> 00RRRRRR00GGGGGG00BBBBBB
                // note: we save 3 bit shifts by adding all four filtered pixels and then bitshifting which comes out to the same thing
                // we can now add the four pixel values without channels overflowing.  the value we get is off by an error factor
                // because we eliminated the two lowest bits from each value
                // we compensate for this error factor by applying the filter 0x030303 which translates
                // RRRRRRRRGGGGGGGGBBBBBBBB to 000000RR000000GG000000BB
                // giving us the two lowest order bits for each pixel.  we can then safely add the two lowest order
                // bits for each pixel.  we then divide the result by 4 and add it
                // to the value we got by ignoring the two lowest order bits.


                pBlurredBitmap[position] =
                (((pSource[position-1]&16579836) +   // 0xfafafa
                  (pSource[position+1]&16579836) +
                  (pSource[position-m_nBitmapWidth]&16579836) +
                  (pSource[position+m_nBitmapWidth]&16579836))>>2)+

                // compensate for error factor:
                ((((pSource[position-1]&197379) + // 0x030303
                   (pSource[position+1]&197379) +
                   (pSource[position-m_nBitmapWidth]&197379) +
                   (pSource[position+m_nBitmapWidth]&197379))>>2)&197379);

            }
            position++;
        }
        return(BYTE *)pBlurredBitmap;
    }
    else
    {
        return(NULL);
    }
}


//
// identical to pointerToBlur bitmap except that we only use the pixel to
// the left and the pixel to the right of the bitmap for detailed comments,
// see pointerToBlur
//
BYTE* C32BitDibWrapper::pointerToHorizontalBlur(void)
{
    if (m_pBits!=NULL)
    {
        int x,y;
        int position; // position in old bitmap
        ULONG* pBlurredBitmap;
        ULONG* pSource;
        int numPixels;

        numPixels=m_nBitmapWidth*m_nBitmapHeight;
        pSource = (ULONG *)m_pBits;
        pBlurredBitmap = new ULONG[numPixels];
        if (pBlurredBitmap == NULL) return(NULL);

        // handle edge pixels
        // for edge pixels we simply copy the pixel into the pSource to the destination
        for (x=0;x<m_nBitmapWidth;x++)
        {
            pBlurredBitmap[x] = pSource[x]; // top row
            pBlurredBitmap[numPixels-x-1] = pSource[numPixels-x-1]; // bottom row
        }

        // vertical sides
        for (position=m_nBitmapWidth;position+m_nBitmapWidth<numPixels;position+=m_nBitmapWidth)
        {
            pBlurredBitmap[position] = pSource[position]; // left edge
            pBlurredBitmap[position+m_nBitmapWidth-1] = pSource[position+m_nBitmapWidth-1]; // right edge
        }

        // now blur the bitmap
        position=m_nBitmapWidth-1;
        for (y=1;y<m_nBitmapHeight-1;y++) // for all pixels, pSource[position] is the pixel at (x,y)
        {
            position++;
            for (x=1;x<m_nBitmapWidth-1;x++)
            {
                position++;
                pBlurredBitmap[position] =
                (((pSource[position-1]&0xfefefe) +
                  (pSource[position+1]&0xfefefe))>>1)+
                ((((pSource[position-1]&0x010101) +
                   (pSource[position+1]&0x010101))>>1)&0x010101);

            }
            position++;
        }
        return(BYTE *)pBlurredBitmap;
    }
    else
    {
        return(NULL);
    }
}

// blur vertically
// same exact method as pointerToHorizontalBlur
// useful for detecting vertical edges, etc.
BYTE* C32BitDibWrapper::pointerToVerticalBlur(void)
{
    if (m_pBits)
    {
        int x,y;
        int position; // position in old bitmap
        ULONG* pBlurredBitmap;
        ULONG* pSource;
        int numPixels;
        numPixels=m_nBitmapWidth*m_nBitmapHeight;
        pSource = (ULONG *)m_pBits;

        pBlurredBitmap = new ULONG[numPixels];
        if (pBlurredBitmap == NULL) return(NULL);

        // handle edge pixels
        for (x=0;x<m_nBitmapWidth;x++)
        {
            pBlurredBitmap[x] = pSource[x]; // top row
            pBlurredBitmap[numPixels-x-1] = pSource[numPixels-x-1]; // bottom row
        }

        // vertical sides
        for (position=m_nBitmapWidth;position+m_nBitmapWidth<numPixels;position+=m_nBitmapWidth)
        {
            pBlurredBitmap[position] = pSource[position]; // left edge
            pBlurredBitmap[position+m_nBitmapWidth-1] = pSource[position+m_nBitmapWidth-1]; // right edge
        }

        // now blur the bitmap
        position=m_nBitmapWidth-1;
        for (y=1;y<m_nBitmapHeight-1;y++) // pSource[position] is the pixel at (x,y)
        {
            position++;
            for (x=1;x<m_nBitmapWidth-1;x++)
            {
                position++;
                pBlurredBitmap[position] =
                (((pSource[position-m_nBitmapWidth]&0xfefefe) +
                  (pSource[position+m_nBitmapWidth]&0xfefefe))>>1)+
                ((((pSource[position-m_nBitmapWidth]&0x010101) +
                   (pSource[position+m_nBitmapWidth]&0x010101))>>1)&0x010101);

            }
            position++;
        }
        return(BYTE *)pBlurredBitmap;
    }
    else
    {
        return(NULL);
    }
}

// cuts the intensity of each pixel in half
// useful for certain graphics effects
int C32BitDibWrapper::HalfIntensity(void)
{
    if (m_pBits)
    {
        int numPixels;
        int i;
        ULONG* pBitmapPixels;
        pBitmapPixels=(ULONG*)m_pBits;
        numPixels=m_nBitmapWidth*m_nBitmapHeight;
        // loop through all pixels
        for (i=0;i<numPixels;i++)
            pBitmapPixels[i]=(pBitmapPixels[i]&0xfefefe)>>1; // half intensity by first eliminating the lowest order bit from each pixel and then shifting all pixels by 1
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}

// used repeatedly if the user hands us a 300 dpi image, etc.
// HalfSize compacts a h x w bitmap down to a h/2 x w/2 bitmap
int C32BitDibWrapper::HalfSize(void)
{
    if (m_pBits)
    {
        int x,y;
        ULONG position; // position in old bitmap
        ULONG halfposition; // position in half (1/4 area) sized bitmap
        int oldWidth,oldHeight;
        ULONG* pOldBitmap;
        ULONG* pNewBitmap;
        pOldBitmap=(ULONG *)m_pBits; // we speed things up by dealing with 32 bit chunks instead of 8 bit chunks

        pNewBitmap = new ULONG[(m_nBitmapWidth/2)*(m_nBitmapHeight/2)]; // create an array to store a bitmap 1/4th the size of the origional bitmap

        if (pNewBitmap == NULL) return(FALSE); // out of memory

        position=0;
        halfposition=0;

        // loop through pixels 2 pixels at a time in each direction
        // at all times we insure that pOldBitmap[position] is the pixel at (x,y)
        // and pNewBitmap[halfposition] is the pixel at (x/2,y/2)
        for (y=0;y<m_nBitmapHeight-1;y+=2)
        {
            position=m_nBitmapWidth*y;
            for (x=0;x<m_nBitmapWidth-1;x+=2)
            {
                pNewBitmap[halfposition] =  // we use the same algorithm for finding the average of four pixel values as used in pointerToBlur
                                            // see pointerToBlur for a detailed explaination
                                            (((pOldBitmap[position]&16579836) +
                                              (pOldBitmap[position+1]&16579836) +
                                              (pOldBitmap[position+m_nBitmapWidth]&16579836) +
                                              (pOldBitmap[position+m_nBitmapWidth+1]&16579836))>>2)+
                                            ((((pOldBitmap[position]&197379) +
                                               (pOldBitmap[position+1]&197379) +
                                               (pOldBitmap[position+m_nBitmapWidth]&197379) +
                                               (pOldBitmap[position+m_nBitmapWidth+1]&197379))>>2)&197379);
                position+=2;
                halfposition++;
            }
        }

        delete[] m_pBits; // destroy the old bitmap array

        m_nBitmapWidth=m_nBitmapWidth/2;
        m_nBitmapHeight=m_nBitmapHeight/2;

        m_pBits=(BYTE *)pNewBitmap;
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}

// this function destorys regions where the edgeBitmapPixels
// edgeBitmap holds edge informat, start defines the maximum color value for a pixel to start a shadow elimination search
// maxPixel defines the maximum edge value allowed for a shadow pixel
// differenceFromGrey defines the maximum difference from grey for a shadow pixel
// enhanceEdges deals with edge enhancement

int C32BitDibWrapper::KillShadows(C32BitDibWrapper * edgeBitmap, ULONG start, ULONG maxPixel, ULONG differenceFromGrey, ULONG min_guaranteed_not_shadow, bool enhanceEdges)
{
    if (IsValid() && edgeBitmap && edgeBitmap->m_pBits)
    {
        int x,y,position, searchPosition, newPosition;
        ULONG searchEdge;
        ULONG * pEdgePixels;
        ULONG * pBitmapPixels;
        ULONG maxEdge;

        int numPixels=m_nBitmapWidth*m_nBitmapHeight;
        int *pShadowStack = new int[MAXSTACK];
        if (!pShadowStack)
        {
            //
            // we probably ran out of memory.  die gracefully.
            //
            return(FALSE);
        }
        int stackHeight = 0;

        // we first mark all the border pixels so we don't go off the edge
        // this is much faster than other ways of doing bounds checking
        pEdgePixels=(ULONG *)edgeBitmap->m_pBits;
        pBitmapPixels=(ULONG *)m_pBits;

        for (x=0;x<m_nBitmapWidth;x++)
        {
            pEdgePixels[x] = BORDER_EDGE; // top row
            pEdgePixels[numPixels-x-1] = BORDER_EDGE; // bottom row
        }

        // vertical sides
        for (position=m_nBitmapWidth;position+m_nBitmapWidth<numPixels;position+=m_nBitmapWidth)
        {
            pEdgePixels[position] = BORDER_EDGE; // left edge
            pEdgePixels[position+m_nBitmapWidth-1] = BORDER_EDGE; // right edge
        }


        position=m_nBitmapWidth;
        maxEdge=maxPixel;


        for (y=1;y<m_nBitmapHeight-1;y++)
        {
            position++; // because we start at y=1 instead of y=0
            for (x=1;x<m_nBitmapWidth-1;x++)
            {

                if (pBitmapPixels[position]!=DEAD_PIXEL) // we ignore DEAD_PIXEL pixels completelly
                {

                    // check for pixels to mark as not shadows
                    if (pEdgePixels[position]!=BORDER_EDGE
                        && Intensity(pEdgePixels[position])>min_guaranteed_not_shadow
                        && enhanceEdges) // we only mark pixels as NOT_SHADOW if we are in enhanceEdges mode
                    {
                        pBitmapPixels[position]=NOT_SHADOW;
                    }
                    else             // maybe this is a shadow pixel...
                        if (pBitmapPixels[position]!=NOT_SHADOW
                            && pBitmapPixels[position]!=DEAD_PIXEL
                            && Intensity(pBitmapPixels[position])<=start
                            && Intensity(pEdgePixels[position])<=maxEdge
                            && pBitmapPixels[position]!=ERASEDSHADOW
                            && DifferenceFromGray(pBitmapPixels[position])<=differenceFromGrey)
                    { // pixel is a shadow pixel
                        stackHeight=1;
                        pShadowStack[0]=position;
                        pBitmapPixels[position]=ERASEDSHADOW; // when we have decided a pixel is a shadow pixel, set it to zero

                        // fighitng edges add extra complexity but potentially allow us greater accuracy
                        // the concept is to mark pixels which cannot possibly be shadow pixels as such
                        // fighting edges only come into effect if FIGHTING_EDGES is set to true and enhanceEdges is set to false
                        // for the current KillShadows pass

                        if (FIGHTING_EDGES)
                            if (!enhanceEdges
                                && Intensity(pEdgePixels[position])<=FIGHTING_EDGE_MAX_EDGE
                                && DifferenceFromGray(pBitmapPixels[position])<=FIGHTING_EDGES_DIFF_FROM_GREY
                                && Intensity(pBitmapPixels[position])>=FIGHTING_EDGE_MIN_MARK_PIXEL
                                && Intensity(pBitmapPixels[position])<=FIGHTING_EDGE_MAX_MARK_PIXEL
                               )
                                pBitmapPixels[position]=DEAD_PIXEL;

                        while (stackHeight>0)
                        {
                            searchPosition=pShadowStack[--stackHeight];
                            searchEdge=Intensity(pEdgePixels[searchPosition]); // key idea: we are on a search and destroy mission for smooth gradients
                            // make sure our current edge value is similar to our last edge value

                            newPosition=searchPosition-1;

                            if ((pBitmapPixels[newPosition]!=NOT_SHADOW)
                                && pBitmapPixels[newPosition]!=DEAD_PIXEL
                                && Intensity(pEdgePixels[newPosition])<=maxPixel
                                && pBitmapPixels[newPosition]!=ERASEDSHADOW
                                && DifferenceFromGray(pBitmapPixels[newPosition])<=differenceFromGrey)
                            {
                                pBitmapPixels[newPosition]=ERASEDSHADOW;

                                if (FIGHTING_EDGES)
                                    if (!enhanceEdges
                                        && Intensity(pEdgePixels[newPosition])<=FIGHTING_EDGE_MAX_EDGE
                                        && DifferenceFromGray(pBitmapPixels[position])<=FIGHTING_EDGES_DIFF_FROM_GREY
                                        &&Intensity(pBitmapPixels[newPosition])>=FIGHTING_EDGE_MIN_MARK_PIXEL
                                       )
                                        pBitmapPixels[newPosition]=DEAD_PIXEL;

                                pShadowStack[stackHeight++]=newPosition;
                            }

                            newPosition=searchPosition+1;

                            if (pBitmapPixels[newPosition]!=NOT_SHADOW
                                && pBitmapPixels[newPosition]!=DEAD_PIXEL
                                && Intensity(pEdgePixels[newPosition])<=maxPixel
                                && pBitmapPixels[newPosition]!=ERASEDSHADOW
                                && DifferenceFromGray(pBitmapPixels[newPosition])<=differenceFromGrey)
                            {
                                pBitmapPixels[newPosition]=ERASEDSHADOW;

                                if (FIGHTING_EDGES)
                                    if (!enhanceEdges
                                        && Intensity(pEdgePixels[newPosition])<=FIGHTING_EDGE_MAX_EDGE
                                        && DifferenceFromGray(pBitmapPixels[position])<=FIGHTING_EDGES_DIFF_FROM_GREY
                                        &&Intensity(pBitmapPixels[position])<=FIGHTING_EDGE_MAX_MARK_PIXEL
                                        &&Intensity(pBitmapPixels[position])>=FIGHTING_EDGE_MIN_MARK_PIXEL
                                       )
                                        pBitmapPixels[newPosition]=DEAD_PIXEL;

                                pShadowStack[stackHeight++]=newPosition;
                            }

                            newPosition=searchPosition-m_nBitmapWidth;

                            if (pBitmapPixels[newPosition]!=NOT_SHADOW
                                && pBitmapPixels[newPosition]!=DEAD_PIXEL
                                && Intensity(pEdgePixels[newPosition])<=maxPixel
                                && pBitmapPixels[newPosition]!=ERASEDSHADOW
                                && DifferenceFromGray(pBitmapPixels[newPosition])<=differenceFromGrey)
                            {
                                pBitmapPixels[newPosition]=ERASEDSHADOW;

                                if (FIGHTING_EDGES)
                                    if (!enhanceEdges
                                        && Intensity(pEdgePixels[newPosition])<=FIGHTING_EDGE_MAX_EDGE
                                        && DifferenceFromGray(pBitmapPixels[position])<=FIGHTING_EDGES_DIFF_FROM_GREY
                                        &&Intensity(pBitmapPixels[newPosition])>=FIGHTING_EDGE_MIN_MARK_PIXEL
                                        &&Intensity(pBitmapPixels[position])>=FIGHTING_EDGE_MIN_MARK_PIXEL
                                       )
                                        pBitmapPixels[newPosition]=DEAD_PIXEL;

                                pShadowStack[stackHeight++]=newPosition;
                            }

                            newPosition=searchPosition+m_nBitmapWidth;

                            if (pBitmapPixels[newPosition]!=NOT_SHADOW
                                && pBitmapPixels[newPosition]!=DEAD_PIXEL
                                && Intensity(pEdgePixels[newPosition])<=maxPixel
                                && pBitmapPixels[newPosition]!=ERASEDSHADOW
                                && DifferenceFromGray(pBitmapPixels[newPosition])<=differenceFromGrey)
                            {
                                pBitmapPixels[newPosition]=ERASEDSHADOW;

                                if (FIGHTING_EDGES)
                                    if (!enhanceEdges
                                        && Intensity(pEdgePixels[newPosition])<=FIGHTING_EDGE_MAX_EDGE
                                        &&Intensity(pBitmapPixels[newPosition])>=FIGHTING_EDGE_MIN_MARK_PIXEL
                                        && DifferenceFromGray(pBitmapPixels[position])<=FIGHTING_EDGES_DIFF_FROM_GREY
                                        &&Intensity(pBitmapPixels[position])>=FIGHTING_EDGE_MIN_MARK_PIXEL
                                       )
                                        pBitmapPixels[newPosition]=DEAD_PIXEL;

                                pShadowStack[stackHeight++]=newPosition;
                            }
                        }
                    }
                }
                position++;
            }
            position++;
        }

        delete[] pShadowStack;
        return(TRUE);
    }
    else
    {
        return(FALSE);
    }
}


// older simpler version... that includes comments:
/*int C32BitDibWrapper::KillShadows(C32BitDibWrapper * edgeBitmap, UINT start, UINT maxPixel, UINT differenceFromGrey)
{
    int x,y,position, searchPosition, newPosition;
    ULONG searchEdge;
    ULONG * pEdgePixels;
    ULONG * pBitmapPixels;
    int * pShadowStack;
    int stackHeight;
    int numPixels;
    UINT maxEdge;

    numPixels=m_nBitmapWidth*m_nBitmapHeight;
    pShadowStack = new int[MAXSTACK]; // we use a stack as part of a depth first search for potential shadow pixels next to a shadow pixel we have found
    if (pShadowStack==NULL) return(FALSE); // we probably ran out of memory.  die gracefully.
    stackHeight=0;

    // we first change all the border edge pixels to white so we don't go off the edge
    // KillShadows avoids pixels with high shadow values so this should keep us from going off
    // the edge of the bitmap... if maxPixel were set to 0xffffff, this would crash
    // but in such a case, KillShadows would kill the whole bitmap.
    // this is much faster than other ways of doing bounds checking
    // we set all edge pixels to values such that we are gauranteed to reject them
    pEdgePixels=(ULONG *)edgeBitmap->m_pBits;
    pBitmapPixels=(ULONG *)m_pBits;

    // horizontal sides
    for (x=0;x<m_nBitmapWidth;x++)
    {
        pEdgePixels[x] = 0xffffff; // top row
        pEdgePixels[numPixels-x-1] = 0xffffff; // bottom row
    }

    // vertical sides
    for (position=m_nBitmapWidth;position+m_nBitmapWidth<numPixels;position+=m_nBitmapWidth)
    {
        pEdgePixels[position] = 0xffffff; // left edge
        pEdgePixels[position+m_nBitmapWidth-1] = 0xffffff; // right edge
    }

    position=m_nBitmapWidth;
    maxEdge=maxPixel;

    for (y=1;y<m_nBitmapHeight-1;y++)
    {
        position++; // because we start at y=1 instead of y=0
        for (x=1;x<m_nBitmapWidth-1;x++)
        {

            // we only start a shadow kill search if

            if (Intensity(pBitmapPixels[position])<=start && Intensity(pEdgePixels[position])<=maxEdge && pBitmapPixels[position]!=ERASEDSHADOW && DifferenceFromGray(pBitmapPixels[position])<=differenceFromGrey)
            {
                // initialize the stack to do a DFS without recursion to find shadows
                stackHeight=1; // we are going to place the current position on the stack
                pShadowStack[0]=position;
                pBitmapPixels[position]=ERASEDSHADOW; // when we have decided a pixel is a shadow pixel, set it to zero
                while (stackHeight>0)
                {
                    searchPosition=pShadowStack[--stackHeight];
                    searchEdge=Intensity(pEdgePixels[searchPosition]); // key idea: we are on a search and destroy mission for smooth gradients
                                                                      // make sure our current edge value is similar to our last edge value

                    newPosition=searchPosition-1; // try the pixel to the left of the current pixel

                    if (Intensity(pEdgePixels[newPosition])<=maxPixel
                        && pBitmapPixels[newPosition]!=ERASEDSHADOW
                        && DifferenceFromGray(pBitmapPixels[newPosition])<=differenceFromGrey) // requirements for classifying a pixel as a shadow pixel if we have classified an adjacent pixel as a shadow pixel
                    {
                        pBitmapPixels[newPosition]=ERASEDSHADOW; // delete the pixel and mark it as an erased pixel so that our search doesn't go into an infinite loop
                        pShadowStack[stackHeight++]=newPosition;
                    }

                    newPosition=searchPosition+1; // try the pixel to the right of the current pixel

                    if (Intensity(pEdgePixels[newPosition])<=maxPixel
                        && pBitmapPixels[newPosition]!=ERASEDSHADOW
                        && DifferenceFromGray(pBitmapPixels[newPosition])<=differenceFromGrey)
                    {
                        pBitmapPixels[newPosition]=ERASEDSHADOW;
                        pShadowStack[stackHeight++]=newPosition;
                    }

                    newPosition=searchPosition-m_nBitmapWidth; // try the pixel directly above the current pixel

                    if (Intensity(pEdgePixels[newPosition])<=maxPixel
                        && pBitmapPixels[newPosition]!=ERASEDSHADOW
                        && DifferenceFromGray(pBitmapPixels[newPosition])<=differenceFromGrey)
                    {
                        pBitmapPixels[newPosition]=ERASEDSHADOW;
                        pShadowStack[stackHeight++]=newPosition;
                    }

                    newPosition=searchPosition+m_nBitmapWidth; // try the pixel directly below the current pixel

                    if (Intensity(pEdgePixels[newPosition])<=maxPixel
                        && pBitmapPixels[newPosition]!=ERASEDSHADOW
                        && DifferenceFromGray(pBitmapPixels[newPosition])<=differenceFromGrey)
                    {
                        pBitmapPixels[newPosition]=ERASEDSHADOW;
                        pShadowStack[stackHeight++]=newPosition;
                    }

                }
            }
            position++;
        }
        position++;
    }

    if (pShadowStack!=NULL) delete pShadowStack;
    return(TRUE);
}
*/


// finds clumps of pixels above the minimum image threshold
// pMap is an array which indicates which chunk each pixel in the bitmap is part of
// pMap values:
// 0 indicates that a pixel is not part of a chunk
// VERTICAL_EDGE indicates that a pixel is not part of a chunk and that the pixel is very close to the vertical edge of the image
// HORIZONTAL_EDGE is the same as vertical edge, just for horizontal edges
//
int C32BitDibWrapper::FindChunks(int * pMap) // return number of chunks... color the chunks on pMap
{
    if (pMap && m_pBits)
    {
        int x,y,position, searchPosition;
        ULONG * pBitmapPixels;
        int * pChunkStack;
        int stackHeight;
        int numChunks;
        int chunkSize;
        int deltax, deltay;
        int newPosition;

        // prepare pMap
        // indicate which pixels are edge pixels
        // position represents the location of pixel (x,y)
        // we indicate which pixels are edge pixels to prevent the search routines
        // that follow from running off the edge of the bitmap
        // to save time, the search routines will not keep track of x and y coordinates
        // so it is neccessary to provide another and faster way of determining the bounds of the bitmap

        position=0;
        for (y=0;y<EDGEWIDTH;y++)
        {
            for (x=0;x<m_nBitmapWidth;x++)
                pMap[position++]=VERTICAL_EDGE;
        }

        for (;y<m_nBitmapHeight-EDGEWIDTH;y++)
        {
            for (x=0;x<EDGEWIDTH;x++)
                pMap[position++]=HORIZONTAL_EDGE;

            for (;x<m_nBitmapWidth-EDGEWIDTH;x++)  // for pixels that are not edge pixels, we set pMap to 0 to indicate
                pMap[position++]=0;               // that the pixel in question is ready to be set as part of a chunk

            for (;x<m_nBitmapWidth;x++)
                pMap[position++]=HORIZONTAL_EDGE;
        }

        for (;y<m_nBitmapHeight;y++)
        {
            for (x=0;x<m_nBitmapWidth;x++)
                pMap[position++]=VERTICAL_EDGE;
        }


        // we are now ready to search for chunks

        pChunkStack = NULL;
        pChunkStack = new int[MAXSTACK];
        if (pChunkStack == NULL) return(NULL);
        stackHeight=0;
        numChunks=0;

        pBitmapPixels=(ULONG *)m_pBits; // its more convenient for this function to deal with pixels in 32 bit chunks instead of bytes .

        // at all times we keep position set so that pBitmapPixels[position] represents the pixel at coordinates (x,y)
        position=m_nBitmapWidth*EDGEWIDTH;
        for (y=EDGEWIDTH;y<m_nBitmapHeight-EDGEWIDTH;y++) // check if we should start a floodfill search
        // at each pixel (x,y) such that we are > EDGWIDTH from the edge
        {
            position+=EDGEWIDTH;
            for (x=EDGEWIDTH;x<m_nBitmapWidth-EDGEWIDTH;x++)
            {
                // check if the pixel in question is not part of an existing chunk and that its intensity
                // is greater than the minimum intensity required to be part of chunk

                if (pMap[position]==0 && Intensity(pBitmapPixels[position])>MIN_CHUNK_INTENSITY)
                {
                    // initialize stack used for doing a DFS of adjacent pixels
                    stackHeight=1;
                    pChunkStack[0]=position;
                    numChunks++;
                    chunkSize=0; // compute how many pixels are in the chunk. not used at the moment, but useful if we want
                                 // to eliminate chunks which are too small at this stage instead of at some later point

                    pMap[position]=numChunks; // place this pixel in a chunk like it belongs

                    // continue searching for pixels while the stack is not empty

                    while (stackHeight>0)
                    {
                        searchPosition=pChunkStack[--stackHeight]; // pop the next pixel off the stack
                        chunkSize++; // increment the number of pixels in the chyunk by 1

                        // we check if we should add all pixels within EDGEWIDTH of the searchPosition pixel to the current chunk
                        // we then add any such pixels which are not edge pixels to the stack
                        for (deltay=-EDGEWIDTH*m_nBitmapWidth;deltay<=EDGEWIDTH*m_nBitmapWidth;deltay+=m_nBitmapWidth)
                            for (deltax=-EDGEWIDTH;deltax<=EDGEWIDTH;deltax++)
                            {
                                newPosition=searchPosition+deltay+deltax;
                                if (Intensity(pBitmapPixels[newPosition])>MIN_CHUNK_INTENSITY && pMap[newPosition]<=0)
                                {
                                    if (pMap[newPosition]==0) // not an edge pixel
                                    {
                                        pChunkStack[stackHeight++]=newPosition;
                                        pMap[newPosition]=numChunks; // mark the pixel as part of the chunk so that we do not go into an infinite loop
                                    }
                                    else // if a pixel is an edge pixel, we do not want to add that pixel to the stack
                                    {
                                        // (because of problems with scanners with black borders)
                                        // furthermore... we only want to add an edge pixel if the current pixel is
                                        // in a vertical or horizontal line with the edge pixel under consideration
                                        // as this further minimizes problems related to black scanner edges
                                        if (pMap[newPosition]==VERTICAL_EDGE)
                                        {
                                            if (deltax==0) // to minimize distortion due to black outside edge
                                                pMap[newPosition]=numChunks;
                                        }
                                        else // HORIZONTAL_EDGE
                                        {
                                            if (deltay==0) // to minimize distortion due to black outside edge
                                                pMap[newPosition]=numChunks;
                                        }
                                    }
                                }

                            }
                    }
                }
                position++;
            }
            position+=EDGEWIDTH;
        }
        delete[] pChunkStack;
        return(numChunks);
    }
    else
    {
        return(0);
    }
}

// for debugging purposes only
// displays where the chunks denoted by pMap are on the C32BitDibWrapper
// pMap must have the same dimensions as the current bitmap or this function will fail

void C32BitDibWrapper::ColorChunks(int *pMap)
{   // color in the bitmap given the region map... for debugging purposes;
    if (m_pBits && pMap)
    {
        ULONG* pBitmapPixels;
        ULONG mapColor;
        int x,y;
        int position;
        position=0;
        pBitmapPixels=(ULONG *)m_pBits;

        // loop through all pixels
        for (y=0;y<m_nBitmapHeight;y++)
            for (x=0;x<m_nBitmapWidth;x++)
            {
                if (pMap[position]>0) // are we part of a region?
                {
                    mapColor=(((ULONG)pMap[position])*431234894)&0xffffff; // a poor man's random number generator
                    // if we cared about speed... we should make a lookup table instead
                    // but this function is only for debugging purposes
                    pBitmapPixels[position]=((pBitmapPixels[position] & 0xfefefe)>>1)+((mapColor& 0xfefefe)>>1); // average with slight loss
                }
                if (pMap[position]<0) pBitmapPixels[position]=0xffffff; // color in vertical and horizontal edges
                position++;
            }
    }
}

// designed mainly for debugging purposes... this is a painfully slow way to draw a 32 bit dib
// because of the slow conversion step from 32 bits back to 24 bits
int C32BitDibWrapper::Draw(HDC hdc, int x, int y)
{
    if (hdc && m_pBits)
    {
        BITMAPINFO BitmapInfo;
        SetBMI(&BitmapInfo,m_nBitmapWidth, m_nBitmapHeight, 24);

        BYTE* pDibData = ConvertBitmap(m_pBits,32,24);
        if (pDibData)
        {
            StretchDIBits(hdc,
                          x,y,m_nBitmapWidth,m_nBitmapHeight,
                          0,0,m_nBitmapWidth,m_nBitmapHeight,
                          pDibData,
                          &BitmapInfo,BI_RGB,SRCCOPY);

            //
            // destroy the temp 24 bit dib
            //
            delete[] pDibData;
            return(TRUE);
        }
    }
    return(FALSE);
}

// set pixel and get pixel are completelly unoptimized
// If you wish to make them faster, create a table of values storing y*m_nBitmapWidth for all values of y
// as GetPixel is used by the line drawing functions, this could result in a signifigant speed up as
// the line drawing functions are used for region collision detection

void inline C32BitDibWrapper::SetPixel(int x, int y, ULONG color)
{
    if (m_pBits)
    {
        ULONG* pBitmapPixels=(ULONG*)m_pBits;
        pBitmapPixels[y*m_nBitmapWidth+x]=color;
    }
}

ULONG inline C32BitDibWrapper::GetPixel(int x, int y)
{
    if (m_pBits)
    {
        ULONG* pBitmapPixels=(ULONG*)m_pBits;
        return(pBitmapPixels[y*m_nBitmapWidth+x]);
    }
    return 0;
}

//
// calculates the total intensity along a line
//
// Line drawing code modified from VGA line drawing code from Michael
// Abrash's Graphics Programming Black Book
//
// this is the one function which I did not create from scratch so any bug
// questions should be directed to Michael Abrash =) why reinvent the wheel
// when Bresenham line drawing is kindof hard to beat.  particularly in this
// case when we are using lines as tracers so we couldn't care less about if
// they are antialiased or otherwise made to look less jagged.
//
// t-jacobr
//
ULONG C32BitDibWrapper::Line(int X0, int Y0,int X1, int Y1)
{
    if (m_pBits)
    {
        if (X0<0) X0=0;
        if (Y0<0) Y0=0;
        if (X1<0) X1=0;
        if (Y1<0) Y1=0;

        if (X0>=m_nBitmapWidth) X0=m_nBitmapWidth;
        if (Y0>=m_nBitmapHeight) Y0=m_nBitmapHeight;
        if (X1>=m_nBitmapWidth) X1=m_nBitmapWidth;
        if (Y1>=m_nBitmapHeight) Y1=m_nBitmapHeight;

        int DeltaX, DeltaY;
        int Temp;
        if (Y0>Y1)
        {
            Temp=Y0;
            Y0=Y1;
            Y1=Temp;
            Temp = X0;
            X0=X1;
            X1=Temp;
        }
        DeltaX=X1-X0;
        DeltaY=Y1-Y0;
        if (DeltaX>0)
        {
            if (DeltaX>DeltaY)
            {
                return(Octant0(X0,Y0,DeltaX,DeltaY,1));
            }
            else
            {
                return(Octant1(X0,Y0,DeltaX,DeltaY,1));
            }
        }
        else
        {
            DeltaX = -DeltaX;
            if (DeltaX>DeltaY)
            {
                return(Octant0(X0,Y0,DeltaX,DeltaY,-1));
            }
            else
            {
                return(Octant1(X0,Y0,DeltaX,DeltaY,-1));
            }
        }
    }
    else
    {
        return(0); // invalid bitmap
    }
}


// helper functions for line drawing
// these aint no normal nine drawing functions
// what we do is we calculate the total intensity of all of the above threshold pixels along the line

ULONG C32BitDibWrapper::Octant0(int X0, int Y0,int DeltaX,int DeltaY,int XDirection)
{
    if (IsValid())
    {
        int DeltaYx2;
        int DeltaYx2MinusDeltaXx2;
        int ErrorTerm;
        ULONG totalIntensity;
        ULONG pixelIntensity;
        totalIntensity=0;
        DeltaYx2=DeltaY*2;
        DeltaYx2MinusDeltaXx2=DeltaYx2 - (DeltaX*2);
        ErrorTerm = DeltaYx2 - DeltaX;

        // SetPixel(X0,Y0,0x0000ff);
        while (2<DeltaX--) // skip the last pixel
        {
            if (ErrorTerm >=0)
            {
                Y0++;
                ErrorTerm +=DeltaYx2MinusDeltaXx2;
            }
            else
            {
                ErrorTerm +=DeltaYx2;
            }
            X0+=XDirection;
            //SetPixel(X0,Y0,0x0000ff);
            pixelIntensity=Intensity(GetPixel(X0,Y0));
            if (pixelIntensity>MIN_CHUNK_INTENSITY && pixelIntensity<COLLISION_DETECTION_HIGHPASS_VALUE) totalIntensity+=512;//pixelIntensity;
        }
        return(totalIntensity);
    }
    return 0;
}

ULONG C32BitDibWrapper::Octant1(int X0, int Y0, int DeltaX, int DeltaY, int XDirection)
{
    if (IsValid())
    {
        int DeltaXx2;
        int DeltaXx2MinusDeltaYx2;
        int ErrorTerm;
        ULONG totalIntensity;
        ULONG pixelIntensity;
        totalIntensity=0;

        DeltaXx2 = DeltaX * 2;
        DeltaXx2MinusDeltaYx2 = DeltaXx2 - (DeltaY*2);
        ErrorTerm = DeltaXx2 - DeltaY;

        //SetPixel(X0,Y0,0x0000ff);
        while (2<DeltaY--)
        { // skip last pixel
            if (ErrorTerm >=0)
            {
                X0 +=XDirection;
                ErrorTerm +=DeltaXx2MinusDeltaYx2;
            }
            else
            {
                ErrorTerm +=DeltaXx2;
            }
            Y0++;
            pixelIntensity=Intensity(GetPixel(X0,Y0));
            if (pixelIntensity>MIN_CHUNK_INTENSITY && pixelIntensity<COLLISION_DETECTION_HIGHPASS_VALUE) totalIntensity+=512;//pixelIntensity;
        }
        return(totalIntensity);
    }
    return 0;
}


//
// Compensate for Background Color could be made more than 3 times as fast if needed by caculating each pixel
// using 1 cycle instead of 3.

void C32BitDibWrapper::CompensateForBackgroundColor(int r, int g, int b)
{
    if (IsValid())
    {
        int nNumBits=m_nBitmapWidth*m_nBitmapHeight*4;
        for (int position=0;position<nNumBits;position+=4)
        {
            if (r<m_pBits[position]) m_pBits[position]=m_pBits[position]-r;
            else m_pBits[position]=0;
            if (g<m_pBits[position+1]) m_pBits[position+1]=m_pBits[position+1]-g;
            else m_pBits[position+1]=0;
            if (b<m_pBits[position+2]) m_pBits[position+2]=m_pBits[position+2]-b;
            else m_pBits[position+2]=0;
        }
    }
}

// invert the bitmap
void C32BitDibWrapper::Invert(void)
{
    if (IsValid())
    {
        int numPixels;
        int i;
        ULONG* pBitmapPixels;
        pBitmapPixels=(ULONG*)m_pBits; // operate in 32 bit chunks instead of 8 bit chunks
        numPixels=m_nBitmapWidth*m_nBitmapHeight;

        // loop through all pixels in the bitmap
        for (i=0;i<numPixels;i++)
            pBitmapPixels[i]^=0xffffff; // flipping all bits inverts the pixel
    }
}

// note: we could get some wierd effects because despeckle edits the bitmap its examining
// but this shouldn't be a signifigant problem and often, the self referential aspect only acts to slightly increase accuracy
// this function is not the same as the standard photoshop despeckle filter.
// we only care about a small category of stray dots.
// stray dots which are surrounded by white pixels (or pixels which have been eliminated by remove shadow filters)

void C32BitDibWrapper::Despeckle(void)
{
    if (IsValid())
    {
        ULONG* pBitmapPixels;
        int numPixels;
        int position;
        int x,y;
        pBitmapPixels=(ULONG*)m_pBits;
        numPixels=m_nBitmapWidth*m_nBitmapHeight;

        position=4*m_nBitmapWidth;

        // loop through all pixels which are not border pixels
        // pBitmapPixels[position] should be the pixel at (x,y) in all cases
        for (y=4;y<m_nBitmapHeight-4;y++)
        {
            position+=4;
            for (x=4;x<m_nBitmapWidth-4;x++)
            {
                DespecklePixel(pBitmapPixels, position,false);
                position++;
            }
            position+=4;
        }
    }
}

// we may want to despeckle the edges of an image more often than the rest of the image
// as image edges are often trouble spots...
// because of this, we should recommend that users place images in the center of the scanner
// when doing region detection to increase accuracy.
// the concept we are applying is that when we have to make sacrifices we make sacrifices in areas where we hurt cases that would have been very very hard anyway.

void C32BitDibWrapper::EdgeDespeckle(void)
{
    if (IsValid())
    {
        ULONG* pBitmapPixels;
        int x,y,position;
        pBitmapPixels=(ULONG*)m_pBits;

        position=m_nBitmapWidth*4;

        // top edge
        // as always, at all times we insure that pBitmapPixels[position] is the pixel at (x,y)
        for (y=4;y<DESPECKLE_BORDER_WIDTH+4;y++)
        {
            position+=4;
            for (x=4;x<m_nBitmapWidth-4;x++)
            {
                DespecklePixel(pBitmapPixels, position,true);
                position++;
            }
            position+=4;
        }

        // side edges
        for (;y<m_nBitmapHeight-DESPECKLE_BORDER_WIDTH-4;y++)
        {
            position+=4;
            for (x=4;x<DESPECKLE_BORDER_WIDTH+4;x++)
            {
                DespecklePixel(pBitmapPixels, position,true); // left edge
                DespecklePixel(pBitmapPixels, position+m_nBitmapWidth-DESPECKLE_BORDER_WIDTH-8,true); // right edge
                position++;
            }
            position+=m_nBitmapWidth-DESPECKLE_BORDER_WIDTH-4;
        }

        // bottom edge
        for (;y<m_nBitmapHeight-4;y++)
        {
            position+=4;
            for (x=4;x<m_nBitmapWidth-4;x++)
            {
                DespecklePixel(pBitmapPixels, position,true);
                position++;
            }
            position+=4;
        }
    }
}

// given the pixel at position i, figure out if it meets any of the requirements for eliminating the pixel
// if it does, eliminate the pixel.  edgePixel specifies if the pixel is an edgePixel (in which case we may want
// to apply more strict requirements).
void C32BitDibWrapper::DespecklePixel(ULONG* pBitmapPixels, int i, bool edgePixel)
{
    if (IsValid())
    {
        if (Intensity(pBitmapPixels[i])>MIN_CHUNK_INTENSITY)
        {
            //  deletes:
            //
            //    xx
            //    xx
            //
            if (
               Intensity(pBitmapPixels[i-1-m_nBitmapWidth])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i-1])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i-1+m_nBitmapWidth])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i-1+m_nBitmapWidth*2])<MIN_CHUNK_INTENSITY

               && Intensity(pBitmapPixels[i+2-m_nBitmapWidth])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+2])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+2+m_nBitmapWidth])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+2+m_nBitmapWidth*2])<MIN_CHUNK_INTENSITY

               && Intensity(pBitmapPixels[i-m_nBitmapWidth])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+1-m_nBitmapWidth])<MIN_CHUNK_INTENSITY

               && Intensity(pBitmapPixels[i+m_nBitmapWidth*2])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+1+m_nBitmapWidth*2])<MIN_CHUNK_INTENSITY
               )
            {
                pBitmapPixels[i]=0;
                pBitmapPixels[i+1]=0;
                pBitmapPixels[i+m_nBitmapWidth]=0;
                pBitmapPixels[i+1+m_nBitmapWidth]=0;
            }



            if (edgePixel==true)
            {

                // radius one speckle
                // horizontal despeckle
                if (Intensity(pBitmapPixels[i-1])<MIN_CHUNK_INTENSITY
                    && Intensity(pBitmapPixels[i-2])<MIN_CHUNK_INTENSITY
                    && Intensity(pBitmapPixels[i+2])<MIN_CHUNK_INTENSITY
                    && Intensity(pBitmapPixels[i+1])<MIN_CHUNK_INTENSITY)
                    pBitmapPixels[i]=0; // despeckle the speckle
                // vertical despeckle
                if (Intensity(pBitmapPixels[i-m_nBitmapWidth])<MIN_CHUNK_INTENSITY
                    && Intensity(pBitmapPixels[i-m_nBitmapWidth*2])<MIN_CHUNK_INTENSITY
                    && Intensity(pBitmapPixels[i+m_nBitmapWidth*2])<MIN_CHUNK_INTENSITY
                    && Intensity(pBitmapPixels[i+m_nBitmapWidth])<MIN_CHUNK_INTENSITY)
                    pBitmapPixels[i]=0; // despeckle the speckle

                // radius two despeckle
                if (Intensity(pBitmapPixels[i-2])<MIN_CHUNK_INTENSITY
                    && Intensity(pBitmapPixels[i-3])<MIN_CHUNK_INTENSITY
                    && Intensity(pBitmapPixels[i+2])<MIN_CHUNK_INTENSITY
                    && Intensity(pBitmapPixels[i+3])<MIN_CHUNK_INTENSITY)
                    pBitmapPixels[i]=0; // despeckle the speckle
                // vertical despeckle
                if (Intensity(pBitmapPixels[i-m_nBitmapWidth*2])<MIN_CHUNK_INTENSITY
                    && Intensity(pBitmapPixels[i-m_nBitmapWidth*3])<MIN_CHUNK_INTENSITY
                    && Intensity(pBitmapPixels[i+m_nBitmapWidth*2])<MIN_CHUNK_INTENSITY
                    && Intensity(pBitmapPixels[i+m_nBitmapWidth*3])<MIN_CHUNK_INTENSITY)
                    pBitmapPixels[i]=0; // despeckle the speckle
                // despeckle to eliminate clumps like this:

                // clump:               ? ?
                //                       x
                //                      ? ?

                if (Intensity(pBitmapPixels[i-1-m_nBitmapWidth])<MIN_CHUNK_INTENSITY
                    && Intensity(pBitmapPixels[i+1-m_nBitmapWidth])<MIN_CHUNK_INTENSITY
                    && Intensity(pBitmapPixels[i-1+m_nBitmapWidth])<MIN_CHUNK_INTENSITY
                    && Intensity(pBitmapPixels[i+1+m_nBitmapWidth])<MIN_CHUNK_INTENSITY)
                    pBitmapPixels[i]=0; // despeckle the speckle

            }

            // to eliminate this clump:
            //                      ?
            //                     ?x?
            //                      ?
            //

            if (Intensity(pBitmapPixels[i-m_nBitmapWidth])<MIN_CHUNK_INTENSITY
                && Intensity(pBitmapPixels[i+m_nBitmapWidth])<MIN_CHUNK_INTENSITY
                && Intensity(pBitmapPixels[i-1])<MIN_CHUNK_INTENSITY
                && Intensity(pBitmapPixels[i+1])<MIN_CHUNK_INTENSITY)
                pBitmapPixels[i]=0; // despeckle the speckle

            // these functions are insanely slow... if they become a major speed bottlekneck, they can be made
            // 10x faster
            // radius one speckle 3 pixel search depth
            // horizontal despeckle
            if (
               Intensity(pBitmapPixels[i-1])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i-2])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i-3])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i-4])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+4])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+3])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+2])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+1])<MIN_CHUNK_INTENSITY

               && Intensity(pBitmapPixels[i-1+m_nBitmapWidth])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i-2+m_nBitmapWidth])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i-3+m_nBitmapWidth])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i-4+m_nBitmapWidth])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+4+m_nBitmapWidth])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+3+m_nBitmapWidth])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+2+m_nBitmapWidth])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+1+m_nBitmapWidth])<MIN_CHUNK_INTENSITY

               && Intensity(pBitmapPixels[i-1-m_nBitmapWidth])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i-2-m_nBitmapWidth])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i-3-m_nBitmapWidth])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i-4-m_nBitmapWidth])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+4-m_nBitmapWidth])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+3-m_nBitmapWidth])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+2-m_nBitmapWidth])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+1-m_nBitmapWidth])<MIN_CHUNK_INTENSITY
               )
                pBitmapPixels[i]=0; // despeckle the speckle
            // vertical despeckle
            if (
               Intensity(pBitmapPixels[i-m_nBitmapWidth])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i-m_nBitmapWidth*2])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+m_nBitmapWidth*2])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i-m_nBitmapWidth*3])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+m_nBitmapWidth*3])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i-m_nBitmapWidth*4])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+m_nBitmapWidth*4])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+m_nBitmapWidth])<MIN_CHUNK_INTENSITY

               && Intensity(pBitmapPixels[i-m_nBitmapWidth+1])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i-m_nBitmapWidth*2+1])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+m_nBitmapWidth*2+1])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i-m_nBitmapWidth*3+1])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+m_nBitmapWidth*3+1])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i-m_nBitmapWidth*4+1])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+m_nBitmapWidth*4+1])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+m_nBitmapWidth+1])<MIN_CHUNK_INTENSITY

               && Intensity(pBitmapPixels[i-m_nBitmapWidth-1])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i-m_nBitmapWidth*2-1])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+m_nBitmapWidth*2-1])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i-m_nBitmapWidth*3-1])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+m_nBitmapWidth*3-1])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i-m_nBitmapWidth*4-1])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+m_nBitmapWidth*4-1])<MIN_CHUNK_INTENSITY
               && Intensity(pBitmapPixels[i+m_nBitmapWidth-1])<MIN_CHUNK_INTENSITY
               )
                pBitmapPixels[i]=0; // despeckle the speckle
        }
    }
}

// its easy to correct for if the user adjusted brightness contrast
// or worse... if the scanners gamma settings are off
// not unlikely if they have a really old or really cheap scanner
void C32BitDibWrapper::CorrectBrightness(void)
{
    if (IsValid())
    {
        int r,g,b;
        int position;
        int nNumBits;
        r=255;
        g=255;
        b=255;
        nNumBits=m_nBitmapWidth*(m_nBitmapHeight-4)*4;
        // find the minimum, r, g, and b values;
        for (position=m_nBitmapWidth*4;position<nNumBits;position+=4)
        {
            if (r>m_pBits[position]) r=m_pBits[position];
            if (g>m_pBits[position+1]) g=m_pBits[position+1];
            if (b>m_pBits[position+2]) b=m_pBits[position+2];
        }

        if (r!=0 || g!=0 || b!=0) // if the r, g, or b vals are off, correct them
            CompensateForBackgroundColor(r,g,b);
    }
}

//
// stretch out the color spectrum if the darn user adjusted brightness so that no parts of the image are black anymore
// otherwise we can get embarassing failures if the user simply tweaks brightness and contrast too much
//
// stretches upwards... if you need to compensate downwards, call correctBrightness first
void C32BitDibWrapper::MaxContrast(UINT numPixelsRequired)
{
    if (IsValid())
    {
        int position;
        int nNumBits;
        int max;
        int i;
        int temp;
        BYTE pConversionTable[256];
        ULONG pNum[256];

        for (i=0;i<256;i++)
            pNum[i]=0;

        nNumBits=m_nBitmapWidth*m_nBitmapHeight*4;

        // compute the number of pixels of each intensity level
        for (position=0;position<nNumBits;position+=4)
        {
            pNum[m_pBits[position]]++;
            pNum[m_pBits[position+1]]++;
            pNum[m_pBits[position+2]]++;
        }

        max=1;
        // find max intensity which has at least numPixelsRequired of that intensity
        for (i=1;i<256;i++)
            if (pNum[i]>numPixelsRequired) max=i;

            // create conversion table
        for (i=0;i<256;i++)
        {
            temp=(255*i)/max;
            if (temp>255) temp=255; // high pass
            pConversionTable[i]=(BYTE)temp;
        }

        // now apply the conversion table to all pixels in the image
        for (position=0;position<nNumBits;position+=4)
        {
            m_pBits[position]=pConversionTable[m_pBits[position]];
            m_pBits[position+1]=pConversionTable[m_pBits[position+1]];
            m_pBits[position+2]=pConversionTable[m_pBits[position+2]];
        }
    }
}







/// we don't want to use intensity here
// because this is a function used for detecting text regions
// and text regions are more likely to have grey background than yellow backgrounds
// hence doing a chan by chan test is more effective
// IMPORTANT NOTE: this function is designed for use with a non-inverted bitmap unlike most of the other functions in this library
int C32BitDibWrapper::PixelsBelowThreshold(C32BitDibWrapper* pProccessedBitmap, C32BitDibWrapper * pEdgesBitmap, RECT region)
{
    if (IsValid() && pProccessedBitmap && pEdgesBitmap && pProccessedBitmap->IsValid() && pEdgesBitmap->IsValid())
    {
        int x,y;
        int position;
        int numPixels;
        ULONG* pBitmapPixels;
        ULONG* pEdgePixels;
        ULONG* pProccessedPixels; // bitmap with shadows removed, etc
        // we assume that the edge bitmap has the same width and height as this bitmap to shave a couple of 1/1000ths of a second... and cause we are lazy
        numPixels=0;
        pBitmapPixels=(ULONG *)m_pBits;
        pEdgePixels=(ULONG *)(pEdgesBitmap->m_pBits);
        pProccessedPixels=(ULONG *)(pProccessedBitmap->m_pBits);
        position=region.top*m_nBitmapWidth;
        // search through all pixels in the region
        // at all times, pBitmapPixels[position] is the pixel at point (x,y)
        for (y=region.top;y<=region.bottom;y++)
        {
            position+=region.left;
            for (x=region.left;x<=region.right;x++)
            {
                if ((
                    (pBitmapPixels[position]&0xff)    > TEXT_REGION_BACKGROUND_THRESHOLD
                    && (pBitmapPixels[position]&0xff00)  > (TEXT_REGION_BACKGROUND_THRESHOLD<<8)
                    && (pBitmapPixels[position]&0xff0000)> (TEXT_REGION_BACKGROUND_THRESHOLD<<16) // below threshold
                    && Intensity(pEdgePixels[position])  > MIN_TEXT_REGION_BACKGROUND_EDGE)             // does it have the requisite edge val?
                    || (pProccessedPixels[position]==0
                        && Intensity(pEdgePixels[position])>MIN_TEXT_REGION_BACKGROUND_EDGE_CLIPPED_PIXEL
                        && (pBitmapPixels[position]&0xff)    > CLIPPED_TEXT_REGION_BACKGROUND_THRESHOLD
                        && (pBitmapPixels[position]&0xff00)  > (CLIPPED_TEXT_REGION_BACKGROUND_THRESHOLD<<8)
                        && (pBitmapPixels[position]&0xff0000)> (CLIPPED_TEXT_REGION_BACKGROUND_THRESHOLD<<16) // below threshold
                       ))     // we coulda been a dead shadow pixel too.. this is risky because depending on the settings, we may have culled plenty of deserving pixels
                {
                    // we hold pixels to much higher standards if they are clipped pixels... to avoid too much stray clipping
                    numPixels++;
                }
                position++;
            }
            position+=m_nBitmapWidth-region.right-1;
        }
        return(numPixels);
    }
    else
    {
        return(0); // invalid bitmap
    }
}

// the name of the game here is whatever works
// this function may be ugly, but its the easiest way to get rid of
// black borders without hurting overly many innocent pixels

void C32BitDibWrapper::RemoveBlackBorder(int minBlackBorderPixel, C32BitDibWrapper * outputBitmap, C32BitDibWrapper * debugBitmap)
{
    if (IsValid() && m_nBitmapWidth>100 && m_nBitmapHeight>100 && outputBitmap) // these tests are designed for reasonably large bitmaps
    {
        // bottom border
        KillBlackBorder(minBlackBorderPixel,m_nBitmapWidth*m_nBitmapHeight-m_nBitmapWidth,m_nBitmapWidth,m_nBitmapHeight,1,-m_nBitmapWidth, outputBitmap, debugBitmap);
        // top border
        KillBlackBorder(minBlackBorderPixel,0,m_nBitmapWidth,m_nBitmapHeight,1,m_nBitmapWidth, outputBitmap, debugBitmap);
        // left side
        KillBlackBorder(minBlackBorderPixel,0,m_nBitmapHeight,m_nBitmapWidth, m_nBitmapWidth,1, outputBitmap, debugBitmap);
        // right side
        KillBlackBorder(minBlackBorderPixel,m_nBitmapWidth-1,m_nBitmapHeight,m_nBitmapWidth, m_nBitmapWidth,-1, outputBitmap, debugBitmap);
    }

}

// this function encapsulates the single purpose algorithm used to
// remove particularly troublesome shadows from the sides of images
// this function is poorly tweaked and it iss very likely that we could either
// greatly improve the number of errors detected
// or the number of false errors that are unfairly zapped
// debugBitmap is edited to give a graphical representation of which shadows have been eliminated
// debugBitmap is only edited if the VISUAL_DEBUG flag is set
// as shown in RemoveBlackBorder, KillBlackBorder is called with different startPosition, width, height, dx, and dy values
// depending on whether we are working on the top border, the left border, the right border, or the bottom border.
// from the perspective of KillBlackBorder, it is working on eliminating shadows from a bitmap which is width pixels wide
// height pixels high and the location of pixel (0,0) is startPosition.  Where to move one pixel in the x direction
// you increment startPosition by dx and to move one pixel in the y direction, you increment dy by 1.

void C32BitDibWrapper::KillBlackBorder(int minBlackBorderPixel, int startPosition, int width, int height, int dx, int dy, C32BitDibWrapper *pOutputBitmap, C32BitDibWrapper * pDebugBitmap)
{
    if (IsValid() && pOutputBitmap && pOutputBitmap->IsValid() && width>100 && height>100)
    {
        int x,y,position, searchPosition, newPosition;
        ULONG * pBitmapPixels;
        int endPoint;
        int r,g,b;
        int dr,dg,db;
        int i;
        int sourceR,sourceG, sourceB;
        int errors;
        int step;
        int* pShadowDepths;
        int* pTempShadowDepths;
        int longestBackgroundPixelString;
        int borderPixels;
        int nonBackgroundPixels;
        int backgroundPixels;
        BYTE* pBlurredBits = m_pBits;
        ULONG* pDebugPixels;
        BYTE* pOutputBits;

        pOutputBits=pOutputBitmap->m_pBits;

        pShadowDepths=new int[width]; // we keep an array of how many pixels we think the black border is for each scan line
        if (pShadowDepths==NULL) return;

        pTempShadowDepths=NULL;
        pTempShadowDepths=new int[width];

        if (pTempShadowDepths==NULL)
        {
            delete[] pShadowDepths;
            return;
        }

        int numPixels=height*width; // total pixels in the image

        pBitmapPixels=(ULONG *)(pOutputBitmap->m_pBits);
        if (pBitmapPixels)
        {
            pDebugPixels=(ULONG *)(pDebugBitmap->m_pBits);

            step=dy*4; // when dealing with data in 8 bit chunks instead of 32 bit chunks, we need to multiply the dy step by 4


            // reset all vals to 0
            for (i=0;i<width;i++)
            {
                pShadowDepths[i]=0;
                pTempShadowDepths[i]=0;
            }

            position=startPosition*4;
            for (x=0;x<width;x++) // loop through all pixels on the top row of the image
            {
                r=pBlurredBits[position];
                g=pBlurredBits[position+1];
                b=pBlurredBits[position+2];


                if (r>minBlackBorderPixel&&g>minBlackBorderPixel&&b>minBlackBorderPixel) // if the pixel is dark enough
                {
                    // start a kill shadows search
                    searchPosition=position+step;
                    errors=0;
                    borderPixels=0;
                    for (y=1;y<SHADOW_HEIGHT;y++)  // we don't expect a shadow to be more than SHADOW_HEIGHT pixels high
                    {
                        dr=(int)pBlurredBits[searchPosition]-r;
                        dg=(int)pBlurredBits[searchPosition+1]-g;
                        db=(int)pBlurredBits[searchPosition+2]-b;

                        r=(int)pBlurredBits[searchPosition];
                        g=(int)pBlurredBits[searchPosition+1];
                        b=(int)pBlurredBits[searchPosition+2];

                        if (dr<MAX_BLACK_BORDER_DELTA && dg<MAX_BLACK_BORDER_DELTA &&db<MAX_BLACK_BORDER_DELTA)
                        // only requirement is the intensity in each pixel must be less than the intensity of the previous pixel
                        // a shadow should be darkest at the edge of the image, not hte other way round
                        {
                            borderPixels++;
                            if (borderPixels>5)
                                break;   // if we have found five pixels which meet the borderPixel specs, break;
                        }

                        else
                        {
                            errors++;
                            if (errors>3)
                                break;          // if we recieve more than 3 errors, break
                        }

                        searchPosition+=step;
                    }
                    endPoint=y+5; // because of edge enhancement, we set the shadow width to be a bit more than it actually is
                    searchPosition+=2*step; // skip a couple of pixels because we may have missed the last couple of pixels of the shadow

                    nonBackgroundPixels=0;
                    backgroundPixels=0;

                    for (;y<20;y++) // we expect the next few pixels to be background pixels
                    {
                        r=(int)pOutputBits[searchPosition];
                        g=(int)pOutputBits[searchPosition+1];
                        b=(int)pOutputBits[searchPosition+2];

                        sourceR=(int)pBlurredBits[searchPosition];
                        sourceG=(int)pBlurredBits[searchPosition+1];
                        sourceB=(int)pBlurredBits[searchPosition+2];


                        if (r < MAX_KILL_SHADOW_BACKGROUND_APROXIMATION
                            && g < MAX_KILL_SHADOW_BACKGROUND_APROXIMATION
                            && b < MAX_KILL_SHADOW_BACKGROUND_APROXIMATION
                            // WARNING: commenting out the following 3 lines may greatly increases the number of innocent pixels that are deleted
                            && sourceR < MAX_KILL_SHADOW_BACKGROUND_UNEDITED
                            && sourceG < MAX_KILL_SHADOW_BACKGROUND_UNEDITED
                            && sourceB < MAX_KILL_SHADOW_BACKGROUND_UNEDITED
                           )
                            backgroundPixels++;
                        else
                        {
                            nonBackgroundPixels++;
                        }

                        if ((nonBackgroundPixels)>(backgroundPixels+4))
                        {  // no way this is actually a shadow we are deleting
                            y=0;
                            break;
                        }
                        if (backgroundPixels>7) break;

                        searchPosition+=step;
                    }

                    // we only have a shadow if we get a number of dark pixels followed by a number light pixels
                    if (nonBackgroundPixels<3 && backgroundPixels>5 && borderPixels>errors && y!=0)
                    {
                        pShadowDepths[x]=MAX(pShadowDepths[x],endPoint);
                    }
                }






                // this is designed to kill a different kind of shadow, a light shadow far from any objects
                // this code can be safely eliminated
                //

                r=pBlurredBits[position];
                g=pBlurredBits[position+1];
                b=pBlurredBits[position+2];


                if (r>(minBlackBorderPixel/6)&&g>(minBlackBorderPixel/6)&&b>(minBlackBorderPixel/6))
                {
                    searchPosition=position+step;
                    errors=0;
                    borderPixels=0;
                    for (y=1;y<11;y++)
                    {
                        dr=(int)pBlurredBits[searchPosition]-r;
                        dg=(int)pBlurredBits[searchPosition+1]-g;
                        db=(int)pBlurredBits[searchPosition+2]-b;

                        r=(int)pBlurredBits[searchPosition];
                        g=(int)pBlurredBits[searchPosition+1];
                        b=(int)pBlurredBits[searchPosition+2];

                        // much looser requirements for being a shadow
                        if (r>minBlackBorderPixel/7&&g>minBlackBorderPixel/7&&b>minBlackBorderPixel/7)
                        {
                            borderPixels++;
                        }

                        else
                        {
                            errors++;
                        }

                        searchPosition+=step;
                    }
                    endPoint=y-3;
                    searchPosition+=5*step;

                    nonBackgroundPixels=0;
                    backgroundPixels=0;

                    for (;y<35;y++)
                    {
                        r=(int)pOutputBits[searchPosition];
                        g=(int)pOutputBits[searchPosition+1];
                        b=(int)pOutputBits[searchPosition+2];

                        sourceR=(int)pBlurredBits[searchPosition];
                        sourceG=(int)pBlurredBits[searchPosition+1];
                        sourceB=(int)pBlurredBits[searchPosition+2];

                        // much stricter requirements for being a background pixel
                        // with these stricter requirements, we are almost guaranteed not to eliminate any
                        // valid pixels while searching for black borders
                        // the idea is balancing looser requirements in one area with stricter requirements in another
                        if (r < MAX_KILL_SHADOW_BACKGROUND_APROXIMATION/29
                            && g < MAX_KILL_SHADOW_BACKGROUND_APROXIMATION/29
                            && b < MAX_KILL_SHADOW_BACKGROUND_APROXIMATION/29
                            && sourceR < MAX_KILL_SHADOW_BACKGROUND_UNEDITED/39
                            && sourceG < MAX_KILL_SHADOW_BACKGROUND_UNEDITED/39
                            && sourceB < MAX_KILL_SHADOW_BACKGROUND_UNEDITED/39
                           )
                            backgroundPixels++;
                        else
                        {
                            nonBackgroundPixels++;
                            break;
                        }
                        searchPosition+=step;
                    }

                    if (nonBackgroundPixels==0) // the pixel isn't a shadow pixel unless all of the backgroundPixels tested were background pixels
                    {
                        pShadowDepths[x]=MAX(pShadowDepths[x],endPoint); // update the shadowDepth for the pixel
                        // corners can be very problematic
                        // because this algorithm will by definition fail on any corner line
                        // so we cheat...

                        if (x<CORNER_WIDTH)
                        {
                            for (i=0;i<CORNER_WIDTH;i++)
                            {
                                pShadowDepths[i]=MAX(pShadowDepths[i],endPoint);
                            }
                        }

                        if (x+CORNER_WIDTH>width)
                        {
                            for (i=width-CORNER_WIDTH;i<width;i++)
                            {
                                pShadowDepths[i]=MAX(pShadowDepths[i],endPoint);
                            }
                        }

                    }
                }






                // this is designed to kill a different kind of shadow, a small light shadow close to objects
                // this code can be safely eliminated
                // it was mainly written simply to explore the problem space of border elimination
                //
                // if this code is saved beyond a couple of test runs, we will need to turn some of its constants into real constants
                // it seems from prelim tests that this code may be preferable to the previous test function

                {
                    searchPosition=position+step;
                    errors=0;
                    borderPixels=0;
                    nonBackgroundPixels=0;
                    backgroundPixels=0;
                    longestBackgroundPixelString=0;
                    endPoint=0;

                    // we don't bother with looking for a string of black pixels in this case
                    // which is probably more intelegent than the previous code blocks
                    // instead we simply look for long strings of background pixels
                    // while at the same time, terminating the search of we come across too many non-background pixels

                    for (y=0;y<16;y++)
                    {
                        r=(int)pOutputBits[searchPosition];
                        g=(int)pOutputBits[searchPosition+1];
                        b=(int)pOutputBits[searchPosition+2];

                        sourceR=(int)pBlurredBits[searchPosition];
                        sourceG=(int)pBlurredBits[searchPosition+1];
                        sourceB=(int)pBlurredBits[searchPosition+2];


                        if (r < 24
                            && g < 24
                            && b < 24
                            && sourceR < 12
                            && sourceG < 12
                            && sourceB < 12
                           )
                            backgroundPixels++;
                        else
                        {
                            if (y>5) nonBackgroundPixels++;
                            if (backgroundPixels>longestBackgroundPixelString)
                            {
                                endPoint=y;
                                longestBackgroundPixelString=backgroundPixels;
                            }
                            backgroundPixels=0;
                            if (nonBackgroundPixels>1) break;
                        }
                        searchPosition+=step;
                    }

                    if (backgroundPixels>longestBackgroundPixelString)  // was the longestBackgroundPixelString the last?
                    {
                        longestBackgroundPixelString=backgroundPixels;
                        endPoint=16;
                    }

                    if (longestBackgroundPixelString>6)
                    {
                        pShadowDepths[x]=MAX(pShadowDepths[x],endPoint-4);
                        // corners can be problematic
                        // because this algorithm will by definition fail on a black corner
                        // so we cheat...

                        if (x<CORNER_WIDTH)
                        {
                            for (i=0;i<CORNER_WIDTH;i++)
                            {
                                pShadowDepths[i]=MAX(pShadowDepths[i],endPoint);
                            }
                        }

                        if (x+CORNER_WIDTH>width)
                        {
                            for (i=width-CORNER_WIDTH;i<width;i++)
                            {
                                pShadowDepths[i]=MAX(pShadowDepths[i],endPoint);
                            }
                        }
                    }
                }


                position+=dx*4; // increment the position by 1 unit to go to the next row
            }

            for (x=0;x<width;x++)
            {
                pTempShadowDepths[x]=pShadowDepths[x];
            }

            if (SMOOTH_BORDER) // shadows don't just come out of nowhere, if row x has a depth 20 shadow, its likely that we made a mistake and pixel x-1 also has a depth 20 shadow
            {
                for (x=2;x<width-2;x++)
                {
                    pTempShadowDepths[x]=MAX(pTempShadowDepths[x],pShadowDepths[x-1]);
                    pTempShadowDepths[x]=MAX(pTempShadowDepths[x],pShadowDepths[x+1]);
                    pTempShadowDepths[x]=MAX(pTempShadowDepths[x],pShadowDepths[x-2]);
                    pTempShadowDepths[x]=MAX(pTempShadowDepths[x],pShadowDepths[x+2]);
                }
            }

            // now remove the black border
            // we loop through all rows x and then eliminate the first pTempShadowDepths[x] pixels in that row
            position=startPosition;
            step=dy;
            for (x=0;x<width;x++)
            {
                newPosition=position;
                for (y=0;y<pTempShadowDepths[x];y++)
                {
                    pBitmapPixels[newPosition]=DEAD_PIXEL; // set each shadow to be a dead pixel
                    // dead pixels are the only pixels not vulnerable to edge enhancements...
                    // important if we do any KillShadows edge enhancement passes after calling kill black border

                    if (VISUAL_DEBUG)
                        pDebugPixels[newPosition]=((pDebugPixels[newPosition] & 0xfefefe)>>1)+((DEBUGCOLOR& 0xfefefe)>>1);

                    newPosition+=step;
                }
                position+=dx;
            }
        }

        // clean up our memory
        delete[] pTempShadowDepths;
        delete[] pShadowDepths;
    }
}


// dib manipulation functions
// the following are dib wrapper functions stolen and then modified... from utils.cpp
// these functions are now obsolete and only used in region debug mode
// where we need to load bitmaps from files
/*******************************************************************************
*
*  SetBMI
*
*  DESCRIPTION:
*   Setup bitmap info.
*
*  PARAMETERS:
*
*******************************************************************************/


void SetBMI( PBITMAPINFO pbmi, LONG width, LONG height, LONG depth)
{
    pbmi->bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
    pbmi->bmiHeader.biWidth           = width;
    pbmi->bmiHeader.biHeight          = height;
    pbmi->bmiHeader.biPlanes          = 1;
    pbmi->bmiHeader.biBitCount        = (WORD) depth;
    pbmi->bmiHeader.biCompression     = BI_RGB;
    pbmi->bmiHeader.biSizeImage       = 0;
    pbmi->bmiHeader.biXPelsPerMeter   = 0;
    pbmi->bmiHeader.biYPelsPerMeter   = 0;
    pbmi->bmiHeader.biClrUsed         = 0;
    pbmi->bmiHeader.biClrImportant    = 0;
}

/*******************************************************************************
*
*  AllocDibFileFromBits
*
*  DESCRIPTION:
*   Given an unaligned bits buffer, allocate a buffer lager enough to hold the
*   DWORD aligned DIB file and fill it in.
*
*  PARAMETERS:
*
*******************************************************************************/

PBYTE AllocDibFileFromBits( PBYTE pBits, UINT width, UINT height, UINT depth)
{
    PBYTE pdib;
    UINT  uiScanLineWidth, uiSrcScanLineWidth, cbDibSize;
    int bitsSize;
    // Align scanline to ULONG boundary
    uiSrcScanLineWidth = (width * depth) / 8;
    uiScanLineWidth    = (uiSrcScanLineWidth + 3) & 0xfffffffc;

    // DEBUG:
//   uiSrcScanLineWidth=uiScanLineWidth;
    // Calculate DIB size and allocate memory for the DIB.
    bitsSize=height * uiScanLineWidth;
    cbDibSize = bitsSize+sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFO);
    pdib = (PBYTE) LocalAlloc(LMEM_FIXED, cbDibSize);
    if (pdib)
    {
        PBITMAPFILEHEADER pbmfh = (PBITMAPFILEHEADER)pdib;
        PBITMAPINFO       pbmi  = (PBITMAPINFO)(pdib + sizeof(BITMAPFILEHEADER));
        PBYTE             pb    = (PBYTE)pbmi+ sizeof(BITMAPINFO);

        // Setup bitmap file header.
        pbmfh->bfType = 'MB';
        pbmfh->bfSize = cbDibSize;
        pbmfh->bfOffBits = static_cast<DWORD>(pb - pdib);

        // Setup bitmap info.
        SetBMI(pbmi,width, height, depth);

//      WIA_TRACE(("AllocDibFileFromBits, uiScanLineWidth: %d, pdib: 0x%08X, pbmi: 0x%08X, pbits: 0x%08X", uiScanLineWidth, pdib, pbmi, pb));

        // Copy the bits.
        pb-=3;
        pBits-=3; // BUG FIX BECAUSE THE PERSON WHO WROTE THIS COULDN'T KEEP THEIR BITS STRAIGHT
        memcpy(pb, pBits, bitsSize);
    }
    else
    {
        //    WIA_ERROR(("AllocDibFileFromBits, LocalAlloc of %d bytes failed", cbDibSize));
    }
    return(pdib);
}

/*******************************************************************************
*
*  DIBBufferToBMP
*
*  DESCRIPTION:
*   Make a BMP object from a DWORD aligned DIB file memory buffer
*
*  PARAMETERS:
*
*******************************************************************************/

HBITMAP DIBBufferToBMP(HDC hDC, PBYTE pDib, BOOLEAN bFlip)
{
    HBITMAP     hBmp  = NULL;
    PBITMAPINFO pbmi  = (BITMAPINFO*)(pDib);
    PBYTE       pBits = pDib + GetBmiSize(pbmi);

    if (bFlip)
    {
        pbmi->bmiHeader.biHeight = -pbmi->bmiHeader.biHeight;
    }
    hBmp = CreateDIBitmap(hDC, &pbmi->bmiHeader, CBM_INIT, pBits, pbmi, DIB_RGB_COLORS);
    if (!hBmp)
    {
        ;//WIA_ERROR(("DIBBufferToBMP, CreateDIBitmap failed %d", GetLastError(void)));
    }
    return(hBmp);
}

/*******************************************************************************
*
*  ReadDIBFile
*
*  DESCRIPTION:
*
*  PARAMETERS:
*
*******************************************************************************/

HRESULT ReadDIBFile(LPTSTR pszFileName, PBYTE *ppDib)
{
    HRESULT  hr = S_FALSE;
    HANDLE   hFile, hMap;
    PBYTE    pFile, pBits;

    *ppDib = NULL;
    hFile = CreateFile(pszFileName,
                       GENERIC_WRITE | GENERIC_READ,
                       FILE_SHARE_WRITE,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        //WIA_ERROR(("ReadDIBFile, unable to open %s", pszFileName));
        return(hr);
    }

    hMap = CreateFileMapping(hFile,
                             NULL,
                             PAGE_READWRITE,
                             0,
                             0,
                             NULL);
    if (!hMap)
    {
        //WIA_ERROR(("ReadDIBFile, CreateFileMapping failed"));
        goto close_hfile_exit;
    }

    pFile = (PBYTE)MapViewOfFileEx(hMap,
                                   FILE_MAP_READ | FILE_MAP_WRITE,
                                   0,
                                   0,
                                   0,
                                   NULL);
    if (pFile)
    {
        PBITMAPFILEHEADER pbmFile  = (PBITMAPFILEHEADER)pFile;
        PBITMAPINFO       pbmi     = (PBITMAPINFO)(pFile + sizeof(BITMAPFILEHEADER));

        // validate bitmap
        if (pbmFile->bfType == 'MB')
        {
            // Calculate color table size.
            LONG bmiSize, ColorMapSize = 0;

            if (pbmi->bmiHeader.biBitCount == 1)
            {
                ColorMapSize = 2 - 1;
            }
            else if (pbmi->bmiHeader.biBitCount == 4)
            {
                ColorMapSize = 16 - 1;
            }
            else if (pbmi->bmiHeader.biBitCount == 8)
            {
                ColorMapSize = 256 - 1;
            }
            bmiSize = sizeof(BITMAPINFO) + sizeof(RGBQUAD) * ColorMapSize;
            pBits = pFile + sizeof(BITMAPFILEHEADER) + bmiSize;

            *ppDib = AllocDibFileFromBits(pBits,
                                          pbmi->bmiHeader.biWidth,
                                          pbmi->bmiHeader.biHeight,
                                          pbmi->bmiHeader.biBitCount);
            if (*ppDib)
            {
                hr = S_OK;
            }
        }
        else
        {
            //WIA_ERROR(("ReadDIBFile, %s is not a valid bitmap file", pszFileName));
        }
    }
    else
    {
        //WIA_ERROR(("ReadDIBFile, MapViewOfFileEx failed"));
        goto close_hmap_exit;
    }

    UnmapViewOfFile(pFile);
    close_hmap_exit:
    CloseHandle(hMap);
    close_hfile_exit:
    CloseHandle(hFile);
    return(hr);
}

/*******************************************************************************
*
*  GetBmiSize
*
*  DESCRIPTION:
*   Should never get biCompression == BI_RLE.
*
*  PARAMETERS:
*
*******************************************************************************/

LONG GetBmiSize(PBITMAPINFO pbmi)
{
    // determine the size of bitmapinfo
    LONG lSize = pbmi->bmiHeader.biSize;

    // no color table cases
    if (
       (pbmi->bmiHeader.biBitCount == 24) ||
       ((pbmi->bmiHeader.biBitCount == 32) &&
        (pbmi->bmiHeader.biCompression == BI_RGB)))
    {

        // no colors unless stated
        lSize += sizeof(RGBQUAD) * pbmi->bmiHeader.biClrUsed;
        return(lSize);
    }

    // bitfields cases
    if (((pbmi->bmiHeader.biBitCount == 32) &&
         (pbmi->bmiHeader.biCompression == BI_BITFIELDS)) ||
        (pbmi->bmiHeader.biBitCount == 16))
    {

        lSize += 3 * sizeof(RGBQUAD);
        return(lSize);
    }

    // palette cases
    if (pbmi->bmiHeader.biBitCount == 1)
    {

        LONG lPal = pbmi->bmiHeader.biClrUsed;

        if ((lPal == 0) || (lPal > 2))
        {
            lPal = 2;
        }

        lSize += lPal * sizeof(RGBQUAD);
        return(lSize);
    }

    // palette cases
    if (pbmi->bmiHeader.biBitCount == 4)
    {

        LONG lPal = pbmi->bmiHeader.biClrUsed;

        if ((lPal == 0) || (lPal > 16))
        {
            lPal = 16;
        }

        lSize += lPal * sizeof(RGBQUAD);
        return(lSize);
    }

    // palette cases
    if (pbmi->bmiHeader.biBitCount == 8)
    {

        LONG lPal = pbmi->bmiHeader.biClrUsed;

        if ((lPal == 0) || (lPal > 256))
        {
            lPal = 256;
        }

        lSize += lPal * sizeof(RGBQUAD);
        return(lSize);
    }

    // error
    return(0);
}

INT GetColorTableSize (UINT uBitCount, UINT uCompression)
{
    INT nSize;


    switch (uBitCount)
    {
    case 32:
        if (uCompression != BI_BITFIELDS)
        {
            nSize = 0;
            break;
        }
        // fall through
    case 16:
        nSize = 3 * sizeof(DWORD);
        break;

    case 24:
        nSize = 0;
        break;

    default:
        nSize = ((UINT)1 << uBitCount) * sizeof(RGBQUAD);
        break;
    }

    return(nSize);
}

DWORD CalcBitsSize (UINT uWidth, UINT uHeight, UINT uBitCount, UINT uPlanes, int nAlign)
{
    int    nAWidth,nHeight,nABits;
    DWORD  dwSize;


    nABits  = (nAlign << 3);
    nAWidth = nABits-1;


    //
    // Determine the size of the bitmap based on the (nAlign) size.  Convert
    // this to size-in-bytes.
    //
    nHeight = uHeight * uPlanes;
    dwSize  = (DWORD)(((uWidth * uBitCount) + nAWidth) / nABits) * nHeight;
    dwSize  = dwSize * nAlign;

    return(dwSize);
}

//
// Converts hBitmap to a DIB
//
HGLOBAL BitmapToDIB (HDC hdc, HBITMAP hBitmap)
{
    BITMAP bm = {0};
    HANDLE hDib;
    PBYTE  lpDib,lpBits;
    DWORD  dwLength;
    DWORD  dwBits;
    UINT   uColorTable;
    INT    iNeedMore;
    BOOL   bDone;
    INT    nBitCount;
    //
    // Get the size of the bitmap.  These values are used to setup the memory
    // requirements for the DIB.
    //
    if (GetObject(hBitmap,sizeof(BITMAP),reinterpret_cast<PVOID>(&bm)))
    {
        nBitCount = bm.bmBitsPixel * bm.bmPlanes;
        uColorTable  = GetColorTableSize((UINT)nBitCount, BI_RGB);
        dwBits       = CalcBitsSize(bm.bmWidth,bm.bmHeight,nBitCount,1,sizeof(DWORD));

        do
        {
            bDone = TRUE;

            dwLength     = dwBits + sizeof(BITMAPINFOHEADER) + uColorTable;


            // Create the DIB.  First, to the size of the bitmap.
            //
            if (hDib = GlobalAlloc(GHND,dwLength))
            {
                if (lpDib = reinterpret_cast<PBYTE>(GlobalLock(hDib)))
                {
                    ((LPBITMAPINFOHEADER)lpDib)->biSize          = sizeof(BITMAPINFOHEADER);
                    ((LPBITMAPINFOHEADER)lpDib)->biWidth         = (DWORD)bm.bmWidth;
                    ((LPBITMAPINFOHEADER)lpDib)->biHeight        = (DWORD)bm.bmHeight;
                    ((LPBITMAPINFOHEADER)lpDib)->biPlanes        = 1;
                    ((LPBITMAPINFOHEADER)lpDib)->biBitCount      = (WORD)nBitCount;
                    ((LPBITMAPINFOHEADER)lpDib)->biCompression   = 0;
                    ((LPBITMAPINFOHEADER)lpDib)->biSizeImage     = 0;
                    ((LPBITMAPINFOHEADER)lpDib)->biXPelsPerMeter = 0;
                    ((LPBITMAPINFOHEADER)lpDib)->biYPelsPerMeter = 0;
                    ((LPBITMAPINFOHEADER)lpDib)->biClrUsed       = 0;
                    ((LPBITMAPINFOHEADER)lpDib)->biClrImportant  = 0;


                    // Get the size of the bitmap.
                    // The biSizeImage contains the bytes
                    // necessary to store the DIB.
                    //
                    GetDIBits(hdc,hBitmap,0,bm.bmHeight,NULL,(LPBITMAPINFO)lpDib,DIB_RGB_COLORS);

                    iNeedMore = ((LPBITMAPINFOHEADER)lpDib)->biSizeImage - dwBits;

                    if (iNeedMore > 0)
                    {
                        dwBits = dwBits + (((iNeedMore + 3) / 4)*4);
                        bDone = FALSE;
                    }
                    else
                    {
                        lpBits = lpDib+sizeof(BITMAPINFOHEADER)+uColorTable;
                        GetDIBits(hdc,hBitmap,0,bm.bmHeight,lpBits,(LPBITMAPINFO)lpDib,DIB_RGB_COLORS);

                        GlobalUnlock(hDib);

                        return(hDib);
                    }

                    GlobalUnlock(hDib);
                }

                GlobalFree(hDib);
            }
        }
        while (!bDone);
    }
    return(NULL);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\bkthread.h ===
#ifndef __BKTHREAD_H_INCLUDED
#define __BKTHREAD_H_INCLUDED

#include "tspqueue.h"
#include "modlock.h"

// Base class for all messages
class CThreadMessage
{
private:
    int m_nMessage;

private:
    //
    // No implementation
    //
    CThreadMessage(void);
    CThreadMessage( const CThreadMessage & );
    CThreadMessage &operator=( const CThreadMessage & );
public:
    CThreadMessage( int nMessage )
      : m_nMessage(nMessage)
    {
    }

    virtual ~CThreadMessage(void)
    {
    }

    int Message(void) const
    {
        return(m_nMessage);
    }
    int Message( int nMessage )
    {
        return(m_nMessage = nMessage);
    }
};

typedef CThreadSafePriorityQueue<CThreadMessage> CThreadMessageQueue;

class CNotifyThreadMessage : public CThreadMessage
{
private:
    //
    // No implementation
    //
    CNotifyThreadMessage(void);
    CNotifyThreadMessage( const CNotifyThreadMessage & );
    CNotifyThreadMessage &operator=( const CNotifyThreadMessage & );

private:
    HWND m_hWndNotify;

public:
    CNotifyThreadMessage( int nMessage, HWND hWndNotify )
      : CThreadMessage(nMessage),
    m_hWndNotify(hWndNotify)
    {
    }
    virtual ~CNotifyThreadMessage(void)
    {
        m_hWndNotify = NULL;
    }
    HWND NotifyWindow(void) const
    {
        return(m_hWndNotify);
    }
};

typedef BOOL (WINAPI *ThreadMessageHandler)( CThreadMessage *pMsg );

struct CThreadMessageMap
{
    int nMessage;
    ThreadMessageHandler pfnHandler;
};

class CBackgroundThread
{
private:
    HANDLE               m_hThread;
    DWORD                m_dwThreadId;
    CThreadMessageQueue *m_pMessageQueue;
    CThreadMessageMap   *m_pThreadMessageMap;
    CSimpleEvent         m_CancelEvent;
    HINSTANCE            m_hInstanceUnlock;

private:
    //
    // No implementation
    //
    CBackgroundThread(void);
    CBackgroundThread &operator=( const CBackgroundThread & );
    CBackgroundThread( const CBackgroundThread & );

private:
    //
    // Private constructor.  This is the only constructor.  It is only called from Create.
    //
    CBackgroundThread( CThreadMessageQueue *pMessageQueue, CThreadMessageMap *pThreadMessageMap, HANDLE hCancelEvent )
      : m_pMessageQueue(pMessageQueue),
        m_pThreadMessageMap(pThreadMessageMap),
        m_CancelEvent(hCancelEvent),
        m_hInstanceUnlock(NULL)
    {
    }

    bool HandleMessage( CThreadMessage *pMsg )
    {
        for (int i=0;pMsg && m_pThreadMessageMap && m_pThreadMessageMap[i].nMessage;i++)
        {
            if (m_pThreadMessageMap[i].nMessage == pMsg->Message())
            {
                //
                // reset the cancel event
                //
                m_CancelEvent.Reset();
                return (m_pThreadMessageMap[i].pfnHandler(pMsg) != FALSE);
            }
        }
        return(true);
    }

    HRESULT Run()
    {
        //
        // Make sure we got a good message queue
        //
        if (!m_pMessageQueue)
        {
            return E_POINTER;
        }

        //
        // Make sure the event handle is good
        //
        if (!m_pMessageQueue->QueueEvent())
        {
            return E_INVALIDARG;
        }

        //
        // Make sure we have a message queue
        //
        PostThreadMessage( GetCurrentThreadId(), WM_NULL, 0, 0 );

        //
        // Initialize COM on this thread.  As a single threaded apartment.
        //
        HRESULT hr = CoInitialize(NULL);
        if (SUCCEEDED(hr))
        {
            //
            // We will loop until we get a WM_QUIT message
            //
            while (true)
            {
                //
                // Wait for a message to be place in the priority queue, or a message to be placed in the thread's queue
                //
                HANDLE Handles[1] = {m_pMessageQueue->QueueEvent()};
                DWORD dwRes = MsgWaitForMultipleObjects(1,Handles,FALSE,INFINITE,QS_ALLINPUT|QS_ALLPOSTMESSAGE);

                //
                // If the event is signalled, there is a message in the queue
                //
                if (WAIT_OBJECT_0==dwRes)
                {
                    //
                    // Pull the message out of the queue
                    //
                    CThreadMessage *pMsg = m_pMessageQueue->Dequeue();
                    if (pMsg)
                    {
                        //
                        // Call the message handler.
                        //
                        BOOL bResult = HandleMessage(pMsg);
                        
                        //
                        // Delete the message
                        //
                        delete pMsg;

                        //
                        // If the handler returns false, exit the thread.
                        //
                        if (!bResult)
                        {
                            break;
                        }
                    }
                }
                else if (WAIT_OBJECT_0+1==dwRes)
                {
                    //
                    // pull all of the messages out of the queue and process them
                    //
                    MSG msg;
                    while (PeekMessage( &msg, 0, 0, 0, PM_REMOVE ))
                    {
                        //
                        // Break out of the loop
                        //
                        if (msg.message == WM_QUIT)
                        {
                            break;
                        }
                        TranslateMessage(&msg);
                        DispatchMessage(&msg);
                    }
                }
            }
            //
            // Shut down COM
            //
            CoUninitialize();
        }

        return(hr);
    }

    static DWORD ThreadProc(PVOID pData)
    {
        HRESULT hr = E_FAIL;
        HINSTANCE hInstUnlock = NULL;
        CBackgroundThread *pThread = (CBackgroundThread *)pData;
        if (pData)
        {
            hr = pThread->Run();
            hInstUnlock = pThread->m_hInstanceUnlock;
            delete pThread;
        }
        if (hInstUnlock)
        {
            FreeLibraryAndExitThread( hInstUnlock, static_cast<DWORD>(hr) );
        }
        else
        {
            ExitThread( static_cast<DWORD>(hr) );
        }
    }
public:
    ~CBackgroundThread(void)
    {
        //
        // Delete the thread handle
        //
        if (m_hThread)
        {
            CloseHandle(m_hThread);
            m_hThread = 0;
        }

        //
        // Nuke the message queue
        //
        delete m_pMessageQueue;
    }
    static HANDLE Create( CThreadMessageQueue *pMessageQueue, CThreadMessageMap *pThreadMessageMap, HANDLE hCancelEvent, HINSTANCE hInstLock )
    {
        //
        // Make sure we have valid arguments
        //
        if (!pMessageQueue || !pThreadMessageMap)
        {
            WIA_ERROR((TEXT("!pMessageQueue || !pThreadMessageMap")));
            return NULL;
        }
        
        //
        // The duplicated handle we will be returning
        //
        HANDLE hReturnHandle = NULL;

        //
        // Create the thread class
        //
        CBackgroundThread *pThread = new CBackgroundThread( pMessageQueue, pThreadMessageMap, hCancelEvent );
        if (pThread)
        {
            //
            // Lock up before we create the thread
            //
            HINSTANCE hInstanceUnlock = NULL;
            if (hInstLock)
            {
                //
                // Get the module name
                //
                TCHAR szModule[MAX_PATH];
                if (GetModuleFileName( hInstLock, szModule, ARRAYSIZE(szModule)))
                {
                    //
                    // Increment the reference count
                    //
                    pThread->m_hInstanceUnlock = LoadLibrary( szModule );
                }
            }


            pThread->m_hThread = CreateThread( NULL, 0, (LPTHREAD_START_ROUTINE)ThreadProc, pThread, 0, &pThread->m_dwThreadId );
            if (pThread->m_hThread)
            {
                //
                // Copy the handle to return to the caller
                //
                DuplicateHandle( GetCurrentProcess(), pThread->m_hThread, GetCurrentProcess(), &hReturnHandle, 0, FALSE, DUPLICATE_SAME_ACCESS );
            }
            else
            {
                //
                // Unlock the module
                //
                if (pThread->m_hInstanceUnlock)
                {
                    FreeLibrary( hInstanceUnlock );
                    hInstanceUnlock;
                }

                //
                // Since we can't start the thread, we have to delete the thread info to prevent a leak
                //
                delete pThread;

                WIA_ERROR((TEXT("CreateThread failed")));
            }
        }
        else
        {
            //
            // Since the background thread isn't going to free it, we have to.
            //
            delete pMessageQueue;

            WIA_ERROR((TEXT("new CBackgroundThread failed")));
        }

        return hReturnHandle;
    }
};

#endif //__BKTHREAD_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\ssmypics\sstest\sources.inc ===
!include $(PROJECT_ROOT)\ui\uienv.inc
SOURCES_USED  = $(SOURCES_USED) $(PROJECT_ROOT)\ui\uienv.inc

MAJORCOMP=imagein
MINORCOMP=ssmypics

TARGETNAME=sstest
TARGETPATH=obj
TARGETTYPE=UMAPPL_NOLIB
TARGETLIBS=

ATL_VER = 30
USE_STATIC_ATL = 1

# These are needed for gdi+
C_DEFINES=$(C_DEFINES) -DUSE_NEW_APIS -DUSE_NEW_APIS2 -DUSE_NEW_APIS3

UMTYPE=windows
UMAPPL=sstest
UMAPPLEXT=.exe
UMENTRY=winmain
UMLIBS=$(_OBJ_DIR)\*\sstest.res

USE_MSVCRT=1

INCLUDES=\
        $(INCLUDES) \
        $(PROJECT_ROOT)\ui\ssmypics\sscommon;

LINKLIBS=\
        $(BASEDIR)\public\sdk\lib\*\shell32.lib                    \
        $(BASEDIR)\public\sdk\lib\*\msimg32.lib                    \
        $(BASEDIR)\public\sdk\lib\*\oleaut32.lib                   \
        $(BASEDIR)\public\sdk\lib\*\ole32.lib                      \
        $(BASEDIR)\public\sdk\lib\*\uuid.lib                       \
        $(BASEDIR)\public\sdk\lib\*\gdiplus.lib                    \
        $(BASEDIR)\public\sdk\lib\*\shlwapi.lib                    \
        $(BASEDIR)\public\sdk\lib\*\comctl32.lib                   \
        $(BASEDIR)\public\sdk\lib\$(PLATFORM_SUFFIX)\*\wiaguid.lib \
        $(PROJECT_ROOT)\lib\$(PLATFORM_SUFFIX)\*\psutil.lib        \
        $(PROJECT_ROOT)\ui\lib\$(PLATFORM_SUFFIX)\*\uicommon.lib   \
        $(PROJECT_ROOT)\ui\lib\$(PLATFORM_SUFFIX)\*\sscommon.lib

SOURCES=\
        ..\sstest.cpp \
        ..\sstest.rc

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\32bitdib.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       32BITDIB.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      t-JacobR
 *
 *  DATE:        1/11/2000
 *
 *  DESCRIPTION:
 *
 *  C32BitDibWrapper provides support for a number of common graphics special
 *  effects for this class, 32 bit dibs are stored in the following format: 8
 *  ignored high order bits followed by 8 bits per RGB chan.  warning: many
 *  functions in this class will reset the 8 high order bits so it is not
 *  practical to add additional functions which use an 8 bit alpha chan
 *
 *  Notes:
 *
 *  The blur function is designed so that it can be combined with the
 *  difference function to create an edge detection filter More specifically,
 *  the blur function takes the average of only the four pixels around the
 *  current pixel instead of including the current pixel in the average.
 *
 *******************************************************************************/

#ifndef __32BITDIB_H_INCLUDED
#define __32BITDIB_H_INCLUDED

//
// Constants used for Region Detection
//
#define MERGE_REGIONS            TRUE
#define MAXREGIONS               10000
#define PHOTOGRAPH_REGION        1
#define TEXT_REGION              2

//
// We don't want lowlife text regions which are probably stray dots merging with
// photograph regions this id certifies that a text region is big enough to merge
// with a photograph
//
#define MERGABLE_WITH_PHOTOGRAPH 16

//
// how many pixels before you are too big to even imagine that you are a stray blot
//
#define LARGEREGION_THRESHOLD 10000

//
// pixels
//
#define MINREGIONSIZE 10

//
// how far down should we sample the the image?
// goal to sample down the image to
//
#define GOALX 300
#define GOALY 400

//
// borderline in function between text regions and photo regions
//
#define MIN_BORDERLINE_TEXTPHOTO 10

//
// If in borderline, we apply extra functions to determine if its really
// a text region or not
//
#define TEXTPHOTO_THRESHOLD        15
#define MAX_BORDERLINE_TEXTPHOTO   1500


//
// Note... we won't consider merging two photo regions if both regions
// are greater than MAX_MERGABLE_PHOTOGRAPH_SIZE
//
#define MAX_MERGE_PHOTO_REGIONS                  2
#define MAX_NO_EDGE_PIXEL_REGION_PENALTY         16


//
// Maximum merge radius for regions where one region is text and one is a photo region
//
#define MAX_MERGE_DIFFERENT_REGIONS              13

//
// If you are close to the edge after this long you very well might be a stray blot
//
#define BORDER_EXTREME_EDGE_PIXEL_REGION_PENALTY 45

//
// maximum merging radius for text regions merged with text regions
// note: no merging takes place between photo regions and photo regions
//
#define MAXBORDER 65

//
// maximum border width where we can look the other way when it comes to
// collision detection collsion detection is somewhat expensive so only use
// it when we are dealing with signifigant spacings.  we only want to use
// collision detection to make sure that we don't create regions through
// previously deleted shadows, etc.  constants for deciding if a region is a
// valid region
//
// NOTE: we never do collision detection for merging photo regions...  for
// obvious reasons...  we only want to merge photo regions which are part of
// the same region...  hence we would actually only want to merge photograph
// regions where there was a pretty high collision factor
//
#define MERGABLE_WITHOUT_COLLISIONDETECTION 668

//
// minimum region width
//
#define MINWIDTH 5
#define MINPHOTOWIDTH 5

//
// maximum ratio between height and width
//
#define MAXREGIONRATIO 81
#define MAXPHOTORATIO 81
#define MINSIZE 30

//
// if you are more than 6 pixels wide, you are ok.  we don't care what your aspect ratio is
//
#define IGNORE_RATIO_WIDTH 6

//
// number of pixels required before we throw a region out as being just a
// stray dot (10 x 10 so it isn't a huge requirement)
//
#define MINREGIONPIXELS 20

//
// very conservative
//
#define MINPPHOTOSELECTEDFACTOR 5

//
// conservative.. its unlikely that many regions will have edge factors this low
//
#define MINEDGEFACTOR 5

//
// allow a couple of black pixels without going crazy
//
#define MAX_RESISTANCE_ALLOWED_TO_UNION 1024

#define DONE_WITH_BORDER_CHECKING -1
#define MIN_FINAL_REGION_SIZE 38

#define CLOSE_TO_EDGE_PENALTY_WIDTH 3

//
// the following are designed to weed out speckles.  these are only applied
// after we have increased the border past MAX_MERGE_DIFFERENT_REGIONS.  so
// all that should be left is small text regions and long and narrow
// speckles.
//

//
// no close to edge penalty factor
//
#define CLOSE_TO_EDGE_PENALTY_FACTOR 1

#define UNKNOWN -1

#define EDGE_PENALTY_WIDTH 2

//
// 2x all requirements if region is within EDGE_PENALTY_WIDTH from the edge
// of the image.  some requirements may be multiplied by EDGE_PENALTY_FACTOR
// squared...  i.e.  for 2D requirments like num of pixels
//
#define EDGE_PENALTY_FACTOR 1

#define COMPARISON_ERROR_RADIUS 2

//
// constants used for findchunk filters so that we aren't lead astray by the
// possible black ring around the image
//
#define VERTICAL_EDGE -1
#define HORIZONTAL_EDGE -2

//
// a nice massive stack which is large enough that we are gauranteed never to exceed it
//
#define MAXSTACK (GOALX*GOALY)

//
// we do two remove shadow passes.
// one pass is intended to only remove shadows
// the other is designed to handle scanners which have yellow lids, etc.
//

//
// maximum intensity allowed for first pixel of a shadow..  we used to
// think that we should only let shadows start at 0...  that was before we
// saw the light
//
#define MAXSHADOWSTART 800

//
// maximum edge value permitted for a shadow pixel
//
#define MAXSHADOWPIXEL 3

//
// if we are near the edge, we want to kill anything that is remotely like a shadow
//
#define MAXEDGESHADOWPIXEL 20

#define MAX_DIFFERENCE_FROM_GRAY 690

//
// border where we do tougher despeckle & edge filters...
//
#define DESPECKLE_BORDER_WIDTH 6

//
// the background color remove shadows algorithm pass is at the moment the
// same as the first pass.  we may later want to optumize it to better do its
// specific task..  for example...  for this filter, we could care less about
// if a pixel isn't grey
//

//
// accept all pixels
//
#define FIX_BACKGROUND_MAXSHADOWSTART 800
#define FIX_BACKGROUND_MAXSHADOWPIXEL 2

//
// maximum intensity to be considered a bonified text region background pixel
//
#define TEXT_REGION_BACKGROUND_THRESHOLD 31

//
// this if for use with Pixels below Threshold which should be called using
// the origional image...  not an inverted image
//

//
// minimum edge value to earn the distinguished title of being a text region edge pixel
//
#define MIN_TEXT_REGION_BACKGROUND_EDGE 32

//
// minimum edge value to earn the distinguished title of being a text region edge pixel
//
#define MIN_TEXT_REGION_BACKGROUND_EDGE_CLIPPED_PIXEL 120

#define CLIPPED_TEXT_REGION_BACKGROUND_THRESHOLD 180

//
// not implemented yet
//
#define TEXT_REGION_BACKGROUND_PIXEL_MAX_CLIPPED_DIFFERENCE_FROM_GREY 32

//
// minimum intensity to select a pixel
//
#define MIN_CHUNK_INTENSITY 48

//
// should be 0, but different values are useful for debugging...  although
// extreme values will potentially mess up region detection its the color we
// set erased shadow bits
//
#define ERASEDSHADOW 0

// beta constants:
//
// idea: inverted images... and constant color image potential problems
//
#define COLLISION_DETECTION_HIGHPASS_VALUE 600

//
// if a photograph gets fragmented we will see a bunch of closely spaced and
// relatively small regions only one of the two regions has to be bellow this
// size requirement to merge them as part way through the merge proccess we
// will be definition have a larger region than this const or the const isn't
// fullfilling its purpose
//
#define MAX_MERGABLE_PHOTOGRAPH_SIZE 30000

#define NOT_SHADOW 0x800ff09

//
// a pixel which we are sure is bad and that we will no
// rejuvinate no matter that edge val it may have
//
#define DEAD_PIXEL  0x8000002

//
// minimum edge intensity to classify a pixel as NOT_SHADOW
//
#define NOT_SHADOW_INTENSITY 28

#define MIN_WALL_INTENSITY 200

#define MIN_BLACK_SCANNER_EDGE_CHAN_VALUE 110

#define MAX_BLACK_BORDER_DELTA 12

#define MAX_KILL_SHADOW_BACKGROUND_APROXIMATION 64
#define MAX_KILL_SHADOW_BACKGROUND_UNEDITED 200

//
// further ideas: to eliminate the possibility of embarassing errors: count
// the number of background pixels if the num of background pixels is above a
// threshold use weaker shadow and edge filters as we probably have a good
// scanner something like if half the page is defined as background pixels
// dangers: white page on a horrible scanner
//


//
// MORE IMPORTANTLY: also the select region search radius TIP: if you are
// running multiple region selection, an EDGEWIDTH of 3 or more could limit
// your options considerably as nearby regions may get merged together
// particularly when using edge enhancement and when GOALX is set at 300 or
// less
//
#define EDGEWIDTH 2

//
// color used to highlight clipped pixels while debugging the code for eliminating black borders
//
#define DEBUGCOLOR  0xff0000

#define FIGHTING_EDGES FALSE

//
// you better be darn close to grey to get marked as NOT_SHADOW fighting
// edges involve pixeled being marked as not possibly being edges as well as
// pixels
//
#define FIGHTING_EDGES_DIFF_FROM_GREY 10

//
// being marked as definite edges
//
#define FIGHTING_EDGE_MIN_MARK_PIXEL 10
#define FIGHTING_EDGE_MAX_MARK_PIXEL 210

#define FIGHTING_EDGE_MAX_EDGE 1

#define BORDER_EDGE 0xfffffff

//
// used for killing the black border around the page
//
#define CORNER_WIDTH 5

//
// used for black border removal
//
#define SHADOW_HEIGHT 10
#define VISUAL_DEBUG FALSE
#define SMOOTH_BORDER FALSE

//
// amount to increase border while unioning together regions for single region
// region detection
//
#define SINGLE_REGION_BORDER_INCREMENT 4


class C32BitDibWrapper
{
private:
    //
    // No implementation
    //
    C32BitDibWrapper &operator=( const C32BitDibWrapper & );
    C32BitDibWrapper( const C32BitDibWrapper & );

public:
    explicit C32BitDibWrapper(BITMAP pBitmap);

    //
    // Copy constructor... create a new dib wrapper with a copy of all the data in the other dib wrapper
    //
    explicit C32BitDibWrapper(C32BitDibWrapper *pBitmap);

    //
    // construct wrapper from a dib
    //
    explicit C32BitDibWrapper(BYTE* pDib);

    //
    // creates an uninitialized dib wrapper
    //
    C32BitDibWrapper(void);

    //
    // creates a blank dib
    //
    C32BitDibWrapper(int w, int h);

    virtual ~C32BitDibWrapper(void);

    void Destroy(void);

    //
    // functions for common graphics effects
    //
    int Blur(void);
    BYTE* pointerToBlur(void);
    BYTE* pointerToHorizontalBlur(void);
    BYTE* pointerToVerticalBlur(void);
    int CreateBlurBitmap(C32BitDibWrapper * pSource);
    int CreateHorizontalBlurBitmap(C32BitDibWrapper * pSource);
    int CreateVerticalBlurBitmap(C32BitDibWrapper * pSource);

    //
    // Creates a new dib where each pixel is equal to the difference
    // of the pixel values for the other two dibs
    //
    int CreateDifferenceBitmap (C32BitDibWrapper *pBitmap1, C32BitDibWrapper *pBitmap2);

    int KillShadows(C32BitDibWrapper * pEdgeBitmap, ULONG start, ULONG maxPixel, ULONG differenceFromGrey, ULONG min_guaranteed_not_shadow, bool enhanceEdges);
    void RemoveBlackBorder(int minBlackBorderPixel, C32BitDibWrapper * outputBitmap,C32BitDibWrapper * debugBitmap);

    //
    // resample image down to half size
    //
    int HalfSize(void);

    //
    // resample image down to half intensity
    //
    int HalfIntensity(void);
    void Invert(void);

    //
    // less common graphics filters:
    //
    void Despeckle(void);

    //
    // only despeckle the outer edge of pixels in the image
    //
    void EdgeDespeckle(void);

    //
    // despeckles the ith pixel in a bitmap
    //
    void DespecklePixel(ULONG* bitmapPixels, int i, bool edgePixel);

    void CorrectBrightness(void);
    void MaxContrast(UINT numPixelsRequired);

    void AdjustForBadScannerBedColor(C32BitDibWrapper * edgeBitmap);

    //
    // Similar to a photoshop magic wand.. just we try to run our magic wand starting from ever possible pixel
    //
    int FindChunks(int * pMap);

    //
    // display selected chunks... for debugging purposes mostly
    //
    void ColorChunks(int * pMap);

    int PixelsBelowThreshold(C32BitDibWrapper* pProccessed, C32BitDibWrapper * pEdges, RECT region);

    BYTE* ConvertBitmap(BYTE* pSource, int bitsPerSource, int bitsPerDest);

    //
    // for debugging purposes only
    // MyBitBlt is horribly slow as we manually convert the
    // bitmap to a 24 bit dib before displaying
    //
    int Draw(HDC hdc, int x, int y);

    inline void SetPixel(int x, int y, ULONG color);
    inline ULONG GetPixel(int x, int y);

    //
    // calculates the total color intensity of a line
    //
    ULONG Line(int x1, int y1, int x2, int y2);

private:
    //
    // line drawing helper functions
    //
    ULONG Octant0(int X0, int Y0,int DeltaX,int DeltaY,int XDirection);
    ULONG Octant1(int X0, int Y0,int DeltaX,int DeltaY,int XDirection);

    //
    // kill borders helper function:
    //
    void KillBlackBorder(int minBlackBorderPixel, int startPosition, int width, int height, int dx, int dy, C32BitDibWrapper *pOutputBitmap, C32BitDibWrapper * pDebugBitmap);

public:
    void CompensateForBackgroundColor(int r, int g, int b);
    ULONG CalculateBackgroundColor(void);

    bool IsValid(void)
    {
        return (m_pBits && m_nBitmapWidth != -1 && m_nBitmapHeight != -1);
    }

public:
    BYTE *m_pBits;
    int m_nBitmapWidth;
    int m_nBitmapHeight;
};

//
// dib manipulation functions
//
void    SetBMI( PBITMAPINFO pbmi, LONG width, LONG height, LONG depth );
PBYTE   AllocDibFileFromBits( PBYTE pBits, UINT width, UINT height, UINT depth );
HBITMAP DIBBufferToBMP( HDC hDC, PBYTE pDib, BOOLEAN bFlip );
HRESULT ReadDIBFile( LPTSTR pszFileName, PBYTE *ppDib );
LONG    GetBmiSize( PBITMAPINFO pbmi );
INT     GetColorTableSize( UINT uBitCount, UINT uCompression );
DWORD   CalcBitsSize( UINT uWidth, UINT uHeight, UINT uBitCount, UINT uPlanes, int nAlign );
HGLOBAL BitmapToDIB( HDC hdc, HBITMAP hBitmap );

#endif // __32BITDIB_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\createtb.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       CREATETB.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        12/22/2000
 *
 *  DESCRIPTION: Toolbar helpers
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "createtb.h"
#include <windowsx.h>
#include <simstr.h>
#include <psutil.h>
#include <simrect.h>

namespace ToolbarHelper
{
    //
    // This is a replacement for CreateToolbarEx (in comctl32.dll) that uses CreateMappedBitmap
    // so we can get the benefit of having buttons that work ok in high contrast mode.
    //
    HWND CreateToolbar(
        HWND hwndParent, 
        DWORD dwStyle, 
        UINT_PTR nID,
        CToolbarBitmapInfo &ToolbarBitmapInfo,
        LPCTBBUTTON pButtons,
        int nButtonCount,
        int nButtonWidth, 
        int nButtonHeight,
        int nBitmapWidth, 
        int nBitmapHeight, 
        UINT nButtonStructSize )
    {
        HWND hwndToolbar = CreateWindow( TOOLBARCLASSNAME, NULL, WS_CHILD | dwStyle, 0, 0, 100, 30, hwndParent, reinterpret_cast<HMENU>(nID), NULL, NULL );
        if (hwndToolbar)
        {
            ToolbarBitmapInfo.Toolbar(hwndToolbar);
            SendMessage( hwndToolbar, TB_BUTTONSTRUCTSIZE, nButtonStructSize, 0 );
            if (nBitmapWidth && nBitmapHeight)
            {
                SendMessage( hwndToolbar, TB_SETBITMAPSIZE, 0, MAKELONG(nBitmapWidth,nBitmapHeight) );
            }
            if (nButtonWidth && nButtonHeight)
            {
                SendMessage( hwndToolbar, TB_SETBUTTONSIZE, 0, MAKELONG(nButtonWidth,nButtonHeight) );
            }
            HBITMAP hBitmap = CreateMappedBitmap( ToolbarBitmapInfo.ToolbarInstance(), ToolbarBitmapInfo.BitmapResId(), 0, NULL, 0 );
            if (hBitmap)
            {
                TBADDBITMAP TbAddBitmap = {0};
                TbAddBitmap.hInst = NULL;
                TbAddBitmap.nID = reinterpret_cast<UINT_PTR>(hBitmap);
                if (-1 != SendMessage( hwndToolbar, TB_ADDBITMAP, ToolbarBitmapInfo.ButtonCount(), reinterpret_cast<LPARAM>(&TbAddBitmap) ) )
                {
                    ToolbarBitmapInfo.Bitmap(hBitmap);
                }
            }
            SendMessage( hwndToolbar, TB_ADDBUTTONS, nButtonCount, reinterpret_cast<LPARAM>(pButtons) );
        }
        return hwndToolbar;
    }
        
    HWND CreateToolbar( 
        HWND hWndParent, 
        HWND hWndPrevious,
        HWND hWndAlign,
        int Alignment,
        UINT nToolbarId,
        CToolbarBitmapInfo &ToolbarBitmapInfo,
        CButtonDescriptor *pButtonDescriptors, 
        UINT nDescriptorCount )
    {
        HWND hWndToolbar = NULL;
    
        //
        // Make sure we have valid data
        //
        if (!hWndParent || !ToolbarBitmapInfo.ToolbarInstance() || !ToolbarBitmapInfo.BitmapResId() || !pButtonDescriptors || !nDescriptorCount)
        {
            return NULL;
        }
        //
        // Load the bitmap, so we can figure out how many buttons are in the supplied bitmap,
        // and their size.  We assume that the buttons are the same height and width.
        //
        HBITMAP hBitmap = reinterpret_cast<HBITMAP>(LoadImage( ToolbarBitmapInfo.ToolbarInstance(), MAKEINTRESOURCE(ToolbarBitmapInfo.BitmapResId()), IMAGE_BITMAP, 0, 0, LR_DEFAULTCOLOR|LR_CREATEDIBSECTION ));
        if (hBitmap)
        {
            //
            // Get the size of the bitmap
            //
            SIZE sizeBitmap = {0};
            PrintScanUtil::GetBitmapSize(hBitmap,sizeBitmap);
    
            //
            // If the sizes are valid, continue
            //
            if (sizeBitmap.cx && sizeBitmap.cy)
            {
                //
                // Figure out the count and dimensions of the buttons
                // Note the ridiculous size supplied for nButtonSizeX.  This is a 
                // workaround for a BTNS_AUTOSIZE bug
                //
                int nToolbarButtonCount = sizeBitmap.cx / sizeBitmap.cy;
                int nButtonBitmapSizeX = sizeBitmap.cy;
                int nButtonBitmapSizeY = sizeBitmap.cy;
                int nButtonSizeX = 1000;
                int nButtonSizeY = sizeBitmap.cy;
                
                //
                // Figure out which buttons to actually add
                //
                CSimpleDynamicArray<TBBUTTON> aActualButtons;
                for (UINT i=0;i<nDescriptorCount;i++)
                {
                    //
                    // If there is no controlling variable, or if it is true, add the button
                    //
                    if (!pButtonDescriptors[i].pbControllingVariable || *(pButtonDescriptors[i].pbControllingVariable))
                    {
                        TBBUTTON ToolbarButton = {0};
                        ToolbarButton.iBitmap = pButtonDescriptors[i].iBitmap >= 0 ? pButtonDescriptors[i].iBitmap : I_IMAGENONE;
                        ToolbarButton.idCommand = pButtonDescriptors[i].idCommand;
                        ToolbarButton.fsState = pButtonDescriptors[i].fsState;
                        ToolbarButton.fsStyle = pButtonDescriptors[i].fsStyle | BTNS_AUTOSIZE;
                        aActualButtons.Append(ToolbarButton);
                        
                        //
                        // Add the separator, if requested
                        //
                        if (pButtonDescriptors[i].bFollowingSeparator)
                        {
                            TBBUTTON ToolbarButtonSeparator = {0};
                            ToolbarButton.fsStyle = BTNS_SEP;
                            aActualButtons.Append(ToolbarButton);
                        }
                    }
                }
    
                //
                // Make sure we have at least one button
                //
                ToolbarBitmapInfo.ButtonCount(nToolbarButtonCount);
                if (aActualButtons.Size())
                {
                    //
                    // Create the toolbar
                    //
                    hWndToolbar = CreateToolbar( 
                        hWndParent, 
                        WS_CHILD|WS_GROUP|WS_VISIBLE|TBSTYLE_FLAT|WS_TABSTOP|CCS_NODIVIDER|TBSTYLE_LIST|CCS_NORESIZE|TBSTYLE_TOOLTIPS, 
                        nToolbarId, 
                        ToolbarBitmapInfo, 
                        aActualButtons.Array(), 
                        aActualButtons.Size(), 
                        nButtonSizeX, 
                        nButtonSizeY, 
                        nButtonBitmapSizeX, 
                        nButtonBitmapSizeY, 
                        sizeof(TBBUTTON) );
                    if (hWndToolbar)
                    {
                        //
                        // Set the font for the toolbar to be the same as the font for its parent
                        //
                        LRESULT lFontResult = SendMessage( hWndParent, WM_GETFONT, 0, 0 );
                        if (lFontResult)
                        {
                            SendMessage( hWndToolbar, WM_SETFONT, lFontResult, 0 );
                        }

                        //
                        // Loop through all of the actual buttons, to find their string resource ID
                        //
                        for (int i=0;i<aActualButtons.Size();i++)
                        {
                            //
                            // Look for the matching record, to find the string resource ID
                            //
                            for (UINT j=0;j<nDescriptorCount;j++)
                            {
                                //
                                // If this is the original record
                                //
                                if (aActualButtons[i].idCommand == pButtonDescriptors[j].idCommand)
                                {
                                    //
                                    // If this button has a resource ID
                                    //
                                    if (pButtonDescriptors[j].nStringResId)
                                    {
                                        //
                                        // Load the string resource and check to make sure it has a length
                                        //
                                        CSimpleString strText( pButtonDescriptors[j].nStringResId, ToolbarBitmapInfo.ToolbarInstance() );
                                        if (strText.Length())
                                        {
                                            //
                                            // Add the text
                                            //
                                            TBBUTTONINFO ToolBarButtonInfo = {0};
                                            ToolBarButtonInfo.cbSize = sizeof(ToolBarButtonInfo);
                                            ToolBarButtonInfo.dwMask = TBIF_TEXT;
                                            ToolBarButtonInfo.pszText = const_cast<LPTSTR>(strText.String());
                                            SendMessage( hWndToolbar, TB_SETBUTTONINFO, pButtonDescriptors[j].idCommand, reinterpret_cast<LPARAM>(&ToolBarButtonInfo) );
                                        }
                                    }
    
                                    //
                                    // Exit the inner loop, since we've found a match
                                    //
                                    break;
                                }
                            }
                        }

                        //
                        // Tell the toolbar to resize itself
                        //
                        SendMessage( hWndToolbar, TB_AUTOSIZE, 0, 0 );
                    }
                }
            }
    
            //
            // Free the bitmap
            //
            DeleteBitmap(hBitmap);
        }
    
        //
        // Resize and place the toolbar as needed
        //
        if (hWndToolbar && hWndAlign)
        {
            //
            // Get the size of the toolbar
            //
            SIZE sizeToolbar = {0};
            if (SendMessage( hWndToolbar, TB_GETMAXSIZE, 0, reinterpret_cast<LPARAM>(&sizeToolbar)))
            {
                //
                // Get the size of the placement window
                //
                CSimpleRect rcFrameWnd = CSimpleRect( hWndAlign, CSimpleRect::WindowRect ).ScreenToClient(hWndParent);
    
                //
                // Determine how to align horizontally
                //
                int nOriginX = rcFrameWnd.left;
                if (Alignment & AlignHCenter)
                {
                    nOriginX = rcFrameWnd.left + (rcFrameWnd.Width() - sizeToolbar.cx) / 2;
                }
                else if (Alignment & AlignRight)
                {
                    nOriginX = rcFrameWnd.right - sizeToolbar.cx;
                }
    
                int nOriginY = rcFrameWnd.top;
                if (Alignment & AlignVCenter)
                {
                    nOriginY = rcFrameWnd.top + (rcFrameWnd.Height() - sizeToolbar.cy) / 2;
                }
                else if (Alignment & AlignBottom)
                {
                    nOriginY = rcFrameWnd.bottom - sizeToolbar.cy;
                }
                
                //
                // Move and size the toolbar
                //
                SetWindowPos( hWndToolbar, NULL, nOriginX, nOriginY, sizeToolbar.cx, sizeToolbar.cy, SWP_NOZORDER|SWP_NOACTIVATE );
            }
        }
    
        if (hWndToolbar && hWndPrevious)
        {
            SetWindowPos( hWndToolbar, hWndPrevious, 0, 0, 0, 0, SWP_NOSIZE|SWP_NOMOVE|SWP_NOACTIVATE );
        }
    
        return hWndToolbar;
    }
    
    void SetToolbarButtonState( HWND hWndToolbar, int nButtonId, int nState )
    {
        int nCurrentState = static_cast<int>(SendMessage(hWndToolbar,TB_GETSTATE,nButtonId,0));
        if (nCurrentState != -1)
        {
            if (nCurrentState ^ nState)
            {
                SendMessage(hWndToolbar,TB_SETSTATE,nButtonId,MAKELONG(nState,0));
            }
        }
    }
    
    void EnableToolbarButton( HWND hWndToolbar, int nButtonId, bool bEnable )
    {
        WIA_PUSH_FUNCTION((TEXT("EnableToolbarButton")));
        int nCurrentState = static_cast<int>(SendMessage(hWndToolbar,TB_GETSTATE,nButtonId,0));
        if (nCurrentState != -1)
        {
            if (bEnable)
            {
                nCurrentState |= TBSTATE_ENABLED;
            }
            else
            {
                nCurrentState &= ~TBSTATE_ENABLED;
            }
            SetToolbarButtonState( hWndToolbar, nButtonId, nCurrentState );
        }

        //
        // If there are no enabled buttons, remove the WS_TABSTOP bit.  If there are,
        // make sure we add it back in.
        //

        //
        // Assume we don't need the WS_TABSTOP style
        //
        bool bTabStop = false;

        //
        // Loop through all of the buttons in the control
        //
        for (int i=0;i<SendMessage(hWndToolbar,TB_BUTTONCOUNT,0,0);++i)
        {
            //
            // Get the button info for each button
            //
            TBBUTTON TbButton = {0};
            if (SendMessage(hWndToolbar,TB_GETBUTTON,i,reinterpret_cast<LPARAM>(&TbButton)))
            {
                WIA_TRACE((TEXT("TbButton: %d, %d, %04X, %04X, %08X, %p"), TbButton.iBitmap, TbButton.idCommand, TbButton.fsState, TbButton.fsStyle, TbButton.dwData, TbButton.iString ));
                //
                // If this button is enabled, set bTabStop to true and pop out of the loop
                if (!(TbButton.fsStyle & BTNS_SEP) && TbButton.fsState & TBSTATE_ENABLED)
                {
                    bTabStop = true;
                    break;
                }
            }
        }

        //
        // Get the current window style and save a copy, so we don't
        // call SetWindowLong for no reason.
        //
        LONG nStyle = GetWindowLong( hWndToolbar, GWL_STYLE );
        LONG nCurrent = nStyle;

        //
        // Calculate the new style
        //
        if (bTabStop)
        {
            nStyle |= WS_TABSTOP;
        }
        else
        {
            nStyle &= ~WS_TABSTOP;
        }

        //
        // If the new style doesn't match the old one, set the style
        //
        if (nStyle != nCurrent)
        {
            SetWindowLong( hWndToolbar, GWL_STYLE, nStyle );
        }
    }

    bool GetAccelerator( LPCTSTR pszString, TCHAR &chAccel )
    {
        //
        // & marks an accelerator
        //
        const TCHAR c_chAccelFlag = TEXT('&');
        
        //
        // Assume we won't find an accelerator
        //
        chAccel = 0;

        //
        // Loop through the string
        //
        LPCTSTR pszCurr = pszString; 
        while (pszString && *pszString)
        {
            //
            // If this is the marker character
            //
            if (c_chAccelFlag == *pszCurr)
            {
                //
                // Get the next character.
                //
                pszCurr = CharNext(pszCurr);

                //
                // Make sure this isn't a && situation.  If it isn't, save the accelerator and break out.
                //
                if (c_chAccelFlag != *pszCurr)
                {
                    chAccel = reinterpret_cast<TCHAR>(CharUpper(reinterpret_cast<LPTSTR>(*pszCurr)));
                    break;
                }
            }

            //
            // It is OK to call this even if we are on the end of the string already
            //
            pszCurr = CharNext(pszCurr);
        }

        return (0 != chAccel);
    }

    UINT GetButtonBarAccelerators( HWND hWndToolbar, ACCEL *pAccelerators, UINT nMaxCount )
    {
        WIA_PUSH_FUNCTION((TEXT("GetButtonBarAccelerators")));
        
        //
        // We can't exceed the maximum number of buttons
        //
        UINT nCurrAccel=0;
        
        //
        // Loop through all of the buttons in the control
        //
        for (LRESULT i=0;i<SendMessage(hWndToolbar,TB_BUTTONCOUNT,0,0) && nCurrAccel < nMaxCount;++i)
        {
            //
            // Get the button info for each button, so we can get the ID
            //
            TBBUTTON TbButton = {0};
            if (SendMessage(hWndToolbar,TB_GETBUTTON,i,reinterpret_cast<LPARAM>(&TbButton)))
            {
                WIA_TRACE((TEXT("TbButton: %d, %d, %04X, %04X, %08X, %p"), TbButton.iBitmap, TbButton.idCommand, TbButton.fsState, TbButton.fsStyle, TbButton.dwData, TbButton.iString ));
                
                //
                // Ignore separators
                //
                if (!(TbButton.fsStyle & BTNS_SEP))
                {
                    //
                    // Get the button text.
                    //
                    TCHAR szButtonText[MAX_PATH]={0};
                    if (-1 != SendMessage(hWndToolbar,TB_GETBUTTONTEXT,TbButton.idCommand,reinterpret_cast<LPARAM>(szButtonText)))
                    {
                        //
                        // Get the accelerator (if any)
                        //
                        TCHAR chAccel = 0;
                        if (GetAccelerator( szButtonText, chAccel ))
                        {
                            //
                            // Create an ACCEL record
                            //
                            pAccelerators[nCurrAccel].cmd = static_cast<WORD>(TbButton.idCommand);
                            pAccelerators[nCurrAccel].fVirt = FALT|FVIRTKEY;
                            pAccelerators[nCurrAccel].key = chAccel;

                            //
                            // One more accelerator
                            //
                            nCurrAccel++;
                        }
                    }
                }
            }
        }

#if defined(DBG)
        for (UINT i=0;i<nCurrAccel;i++)
        {
            WIA_TRACE((TEXT("pAccelerators[%d].fVirt = 0x%02X, 0x%04X (%c), 0x%04X"), i, pAccelerators[i].fVirt, pAccelerators[i].key, pAccelerators[i].key, pAccelerators[i].cmd ));
        }
#endif
        return nCurrAccel;
    }
    
    void CheckToolbarButton( HWND hWndToolbar, int nButtonId, bool bChecked )
    {
        int nCurrentState = static_cast<int>(SendMessage(hWndToolbar,TB_GETSTATE,nButtonId,0));
        if (nCurrentState != -1)
        {
            if (bChecked)
            {
                nCurrentState |= TBSTATE_CHECKED;
            }
            else
            {
                nCurrentState &= ~TBSTATE_CHECKED;
            }
            SetToolbarButtonState( hWndToolbar, nButtonId, nCurrentState );
        }
    }
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\dbgtimer.h ===
#ifndef __DBGTIMER_H_INCLUDED
#define __DBGTIMER_H_INCLUDED

class CDebugTimer
{
private:
    FILETIME m_ftBeginTime;
    TCHAR    m_szTitle[MAX_PATH];
public:
    CDebugTimer( LPCTSTR pszTimerName=NULL )
    {
        Start( pszTimerName );
    }
    virtual ~CDebugTimer(void)
    {
        End();
    }
    void GetSystemTimeAsFileTime( FILETIME &ft )
    {
        SYSTEMTIME st;
        GetSystemTime( &st );
        SystemTimeToFileTime( &st, &ft );
    }
    void Start( LPCTSTR pszName )
    {
        lstrcpy( m_szTitle, TEXT("") );
        if (pszName && *pszName)
        {
            GetSystemTimeAsFileTime(m_ftBeginTime);
            lstrcpy( m_szTitle, pszName );
        }
    }
    void WriteToFile( LPCTSTR szMessage )
    {
        TCHAR szFilename[MAX_PATH];
        if (GetEnvironmentVariable(TEXT("WIADEBUGFILE"),szFilename,sizeof(szFilename)/sizeof(TCHAR)))
        {
            HANDLE m_hMutex = CreateMutex( NULL, FALSE, TEXT("CDebugTimerFileMutex") );
            if (m_hMutex)
            {
                DWORD dwResult = WaitForSingleObject( m_hMutex, 1000 );
                if (WAIT_OBJECT_0==dwResult)
                {
                    HANDLE hFile = CreateFile( szFilename, GENERIC_WRITE, FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
                    if (INVALID_HANDLE_VALUE == hFile)
                    {
                        DWORD dwBytesWritten;
                        SetFilePointer( hFile, 0, NULL, FILE_END );
                        WriteFile( hFile, szMessage, lstrlen(szMessage) * sizeof(TCHAR), &dwBytesWritten, NULL );
                        CloseHandle(hFile);
                    }
                    else
                    {
                        OutputDebugString(TEXT("CDebugTimer::WriteToFile: Unable to open log file\n"));
                    }
                    ReleaseMutex(m_hMutex);
                }
                else
                {
                    OutputDebugString(TEXT("WaitForSingleObject failed\n"));
                }
                CloseHandle(m_hMutex);
            }
            else
            {
                OutputDebugString(TEXT("CDebugTimer::WriteToFile: Unable to create mutex\n"));
            }
        }
    }
    void Elapsed(void)
    {
        if (lstrlen(m_szTitle))
        {
            FILETIME ft;
            GetSystemTimeAsFileTime(ft);
            LARGE_INTEGER liStart, liEnd;
            liStart.LowPart = m_ftBeginTime.dwLowDateTime;
            liStart.HighPart = m_ftBeginTime.dwHighDateTime;
            liEnd.LowPart = ft.dwLowDateTime;
            liEnd.HighPart = ft.dwHighDateTime;
            LONGLONG nElapsedTime = liEnd.QuadPart - liStart.QuadPart;
            nElapsedTime /= 10000;
            int nMilliseconds = (int)(nElapsedTime % 1000);
            nElapsedTime /= 1000;
            int nSeconds = (int)(nElapsedTime);
            TCHAR szMessage[MAX_PATH];
            wsprintf(szMessage, TEXT("*TIMER* Elapsed time for [%s]: %d.%04d\n"), m_szTitle, nSeconds, nMilliseconds );
            OutputDebugString( szMessage );
            WriteToFile( szMessage );
        }
    }
    void End(void)
    {
        Elapsed();
        lstrcpy( m_szTitle, TEXT("") );
    }
};

#if defined(DBG) || defined(_DEBUG) || defined(DEBUG)
#define WIA_TIMEFUNCTION(x)          CDebugTimer _debugFunctionDebugTimer(TEXT(x))
#define WIA_TIMERSTART(n,x)          CDebugTimer _debugTimer##n(TEXT(x))
#define WIA_TIMEREND(n)              _debugTimer##n.End()
#else
#define WIA_TIMEFUNCTION(x)
#define WIA_TIMERSTART(n,x)
#define WIA_TIMEREND(n)
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\citemlst.h ===
#ifndef __CITEMLST_H_INCLUDED
#define __CITEMLST_H_INCLUDED

#include <windows.h>
#include "wia.h"
#include "uicommon.h"
#include "simevent.h"

class CCameraItem
{
public:
    enum CDeleteState
    {
        Delete_Visible,
        Delete_Pending,
        Delete_Deleted
    };

private:
    CSimpleString           m_strPreviewFileName;
    CComPtr<IWiaItem>       m_pIWiaItem;
    CSimpleStringWide       m_strwFullItemName;
    CCameraItem            *m_pNext;
    CCameraItem            *m_pChildren;
    CCameraItem            *m_pParent;
    int                     m_nImageListIndex;
    int                     m_nCurrentPreviewPercentage;
    DWORD                   m_dwGlobalInterfaceTableCookie;
    CSimpleEvent            m_CancelQueueEvent;
    CDeleteState            m_DeleteState;
    LONG                    m_nItemType;
    LONG                    m_nItemRights;

private:
    //
    // No implementation
    //
    CCameraItem(void);
    CCameraItem(const CCameraItem &);
    CCameraItem &operator=( const CCameraItem & );

public:
    explicit CCameraItem( IWiaItem *pIWiaItem )
      : m_pIWiaItem(pIWiaItem),
        m_pNext(NULL),
        m_pChildren(NULL),
        m_pParent(NULL),
        m_nImageListIndex(-1),
        m_nCurrentPreviewPercentage(0),
        m_dwGlobalInterfaceTableCookie(0),
        m_CancelQueueEvent(true),
        m_DeleteState(Delete_Visible),
        m_nItemType(0),
        m_nItemRights(0)
    {
        WIA_PUSHFUNCTION(TEXT("CCameraItem::CCameraItem"));

        AddItemToGlobalInterfaceTable();
        WIA_TRACE((TEXT("Created CCameraItem(0x%08X)"),m_pIWiaItem.p));

        PropStorageHelpers::GetProperty( m_pIWiaItem, WIA_IPA_FULL_ITEM_NAME, m_strwFullItemName );

        PropStorageHelpers::GetProperty( m_pIWiaItem, WIA_IPA_ACCESS_RIGHTS, m_nItemRights );

    }

    HRESULT AddItemToGlobalInterfaceTable(void)
    {
        HRESULT hr = E_FAIL;
        if (Item())
        {
            CComPtr<IGlobalInterfaceTable> pGlobalInterfaceTable;
            hr = CoCreateInstance( CLSID_StdGlobalInterfaceTable,
                                   NULL,
                                   CLSCTX_INPROC_SERVER,
                                   IID_IGlobalInterfaceTable,
                                   (void **)&pGlobalInterfaceTable);
            if (SUCCEEDED(hr))
            {
                hr = pGlobalInterfaceTable->RegisterInterfaceInGlobal( Item(), IID_IWiaItem, &m_dwGlobalInterfaceTableCookie );
                if (SUCCEEDED(hr))
                {
                    hr = S_OK;
                }
            }
        }
        return (hr);
    }

    HRESULT RemoveItemFromGlobalInterfaceTable(void)
    {
        HRESULT hr = E_FAIL;
        if (Item())
        {
            CComPtr<IGlobalInterfaceTable> pGlobalInterfaceTable;
            hr = CoCreateInstance( CLSID_StdGlobalInterfaceTable,
                                   NULL,
                                   CLSCTX_INPROC_SERVER,
                                   IID_IGlobalInterfaceTable,
                                   (void **)&pGlobalInterfaceTable);
            if (SUCCEEDED(hr))
            {
                hr = pGlobalInterfaceTable->RevokeInterfaceFromGlobal( m_dwGlobalInterfaceTableCookie );
                if (SUCCEEDED(hr))
                {
                    hr = S_OK;
                }
            }
        }
        return (hr);
    }
    DWORD GlobalInterfaceTableCookie(void) const
    {
        return m_dwGlobalInterfaceTableCookie;
    }
    ~CCameraItem(void)
    {
        WIA_PUSHFUNCTION(TEXT("CCameraItem::~CCameraItem"));
        WIA_TRACE((TEXT("Destroyed CCameraItem(0x%08X)"),m_pIWiaItem.p));
        RemoveItemFromGlobalInterfaceTable();
        m_pIWiaItem.Release();
        if (m_strPreviewFileName.Length())
        {
            DeleteFile( m_strPreviewFileName.String() );
            m_strPreviewFileName = TEXT("");
        }
        m_pNext = m_pChildren = m_pParent = NULL;
        m_nImageListIndex = 0;
        m_CancelQueueEvent.Signal();
        m_CancelQueueEvent.Close();
    }
    IWiaItem *Item(void)
    {
        return(m_pIWiaItem);
    }
    const IWiaItem *Item(void) const
    {
        return(m_pIWiaItem.p);
    }
    IWiaItem *Item(IWiaItem *pIWiaItem)
    {
        return(m_pIWiaItem = pIWiaItem);
    }

    CDeleteState DeleteState(void) const
    {
        return m_DeleteState;
    }
    void DeleteState( CDeleteState DeleteState )
    {
        m_DeleteState = DeleteState;
    }

    int CurrentPreviewPercentage(void) const
    {
        return m_nCurrentPreviewPercentage;
    }
    int CurrentPreviewPercentage( int nCurrentPreviewPercentage )
    {
        return (m_nCurrentPreviewPercentage = nCurrentPreviewPercentage);
    }

    bool CreateCancelEvent(void)
    {
        m_nCurrentPreviewPercentage = 0;
        return m_CancelQueueEvent.Create();
    }
    bool CloseCancelEvent(void)
    {
        m_nCurrentPreviewPercentage = 0;
        return m_CancelQueueEvent.Close();
    }
    void SetCancelEvent(void)
    {
        m_CancelQueueEvent.Signal();
    }
    void ResetCancelEvent(void)
    {
        m_CancelQueueEvent.Reset();
    }
    CSimpleEvent &CancelQueueEvent(void)
    {
        return m_CancelQueueEvent;
    }

    bool PreviewRequestPending(void) const
    {
        return (m_CancelQueueEvent.Event() != NULL);
    }

    CSimpleString PreviewFileName(void) const
    {
        return m_strPreviewFileName;
    }
    const CSimpleString &PreviewFileName( const CSimpleString &strPreviewFileName )
    {
        return (m_strPreviewFileName = strPreviewFileName);
    }

    int ImageListIndex(void) const
    {
        return(m_nImageListIndex);
    }

    int ImageListIndex( int nImageListIndex )
    {
        return (m_nImageListIndex = nImageListIndex);
    }

    LONG ItemType(void)
    {
        if (!Item())
        {
            return 0;
        }
        if (!m_nItemType)
        {
            Item()->GetItemType(&m_nItemType);
        }
        return m_nItemType;
    }

    LONG ItemRights() const
    {
        return m_nItemRights;
    }

    bool IsFolder(void)
    {
        return ((ItemType() & WiaItemTypeFolder) != 0);
    }

    bool IsImage(void)
    {
        return ((ItemType() & WiaItemTypeImage) != 0);
    }

    CSimpleStringWide FullItemName(void) const
    {
        return m_strwFullItemName;
    }

    bool operator==( const CCameraItem &other )
    {
        return(Item() == other.Item());
    }

    const CCameraItem *Next(void) const
    {
        return(m_pNext);
    }
    CCameraItem *Next(void)
    {
        return(m_pNext);
    }
    CCameraItem *Next( CCameraItem *pNext )
    {
        return(m_pNext = pNext);
    }

    const CCameraItem *Children(void) const
    {
        return(m_pChildren);
    }
    CCameraItem *Children(void)
    {
        return(m_pChildren);
    }
    CCameraItem *Children( CCameraItem *pChildren )
    {
        return(m_pChildren = pChildren);
    }

    const CCameraItem *Parent(void) const
    {
        return(m_pParent);
    }
    CCameraItem *Parent(void)
    {
        return(m_pParent);
    }
    CCameraItem *Parent( CCameraItem *pParent )
    {
        return(m_pParent = pParent);
    }
};

class CCameraItemList
{
private:
    CCameraItem *m_pRoot;
public:
    CCameraItemList(void)
    : m_pRoot(NULL)
    {
    }
    ~CCameraItemList(void)
    {
        Destroy(m_pRoot);
        m_pRoot = NULL;
    }
    void Destroy( CCameraItem *pRoot )
    {
        while (pRoot)
        {
            Destroy(pRoot->Children());
            CCameraItem *pCurr = pRoot;
            pRoot = pRoot->Next();
            delete pCurr;
        }
    }
    const CCameraItem *Root(void) const
    {
        return(m_pRoot);
    }
    CCameraItem *Root(void)
    {
        return(m_pRoot);
    }
    CCameraItem *Root( CCameraItem *pRoot )
    {
        return(m_pRoot = pRoot);
    }
    static CCameraItem *Find( CCameraItem *pRoot, const CCameraItem *pNode )
    {
        for (CCameraItem *pCurr = pRoot;pCurr;pCurr = pCurr->Next())
        {
            if (pCurr->DeleteState() != CCameraItem::Delete_Deleted)
            {
                if (*pCurr == *pNode)
                    return(pCurr);
                if (pCurr->Children())
                {
                    CCameraItem *pFind = Find( pCurr->Children(), pNode );
                    if (pFind)
                        return pFind;
                }
            }
        }
        return(NULL);
    }
    CCameraItem *Find( CCameraItem *pNode )
    {
        return(Find( m_pRoot, pNode ));
    }
    static CCameraItem *Find( CCameraItem *pRoot, IWiaItem *pItem )
    {
        for (CCameraItem *pCurr = pRoot;pCurr;pCurr = pCurr->Next())
        {
            if (pCurr->DeleteState() != CCameraItem::Delete_Deleted)
            {
                if (pCurr->Item() == pItem)
                    return(pCurr);
                if (pCurr->Children())
                {
                    CCameraItem *pFind = Find( pCurr->Children(), pItem );
                    if (pFind)
                        return pFind;
                }
            }
        }
        return(NULL);
    }
    CCameraItem *Find( IWiaItem *pItem )
    {
        return(Find( m_pRoot, pItem ));
    }
    static CCameraItem *Find( CCameraItem *pRoot, DWORD dwGlobalInterfaceTableCookie )
    {
        for (CCameraItem *pCurr = pRoot;pCurr;pCurr = pCurr->Next())
        {
            if (pCurr->DeleteState() != CCameraItem::Delete_Deleted)
            {
                if (pCurr->GlobalInterfaceTableCookie() == dwGlobalInterfaceTableCookie)
                    return(pCurr);
                if (pCurr->Children())
                {
                    CCameraItem *pFind = Find( pCurr->Children(), dwGlobalInterfaceTableCookie );
                    if (pFind)
                        return pFind;
                }
            }
        }
        return(NULL);
    }
    CCameraItem *Find( DWORD dwGlobalInterfaceTableCookie )
    {
        return(Find( m_pRoot, dwGlobalInterfaceTableCookie ));
    }
    CCameraItem *Find( CCameraItem *pRoot, const CSimpleBStr &bstrFullItemName )
    {
        CSimpleStringWide strwTemp;

        for (CCameraItem *pCurr = pRoot;pCurr && bstrFullItemName.BString();pCurr = pCurr->Next())
        {
            if (pCurr->DeleteState() != CCameraItem::Delete_Deleted)
            {
                strwTemp = pCurr->FullItemName();

                if (wcscmp(strwTemp, bstrFullItemName) == 0)
                {
                    return pCurr;
                }
                if (pCurr->Children())
                {
                    CCameraItem *pFind = Find( pCurr->Children(), bstrFullItemName );
                    if (pFind)
                        return pFind;
                }
            }
        }
        return NULL;
    }
    CCameraItem *Find( const CSimpleBStr &bstrFullItemName )
    {
        return Find( m_pRoot, bstrFullItemName );
    }
    void Add( CCameraItem *pParent, CCameraItem *pNewCameraItemNode )
    {
        WIA_PUSHFUNCTION(TEXT("CCameraItemList::Add"));
        WIA_TRACE((TEXT("Root(): 0x%08X"), Root()));
        if (pNewCameraItemNode)
        {
            if (!Root())
            {
                Root(pNewCameraItemNode);
                pNewCameraItemNode->Parent(NULL);
                pNewCameraItemNode->Children(NULL);
                pNewCameraItemNode->Next(NULL);
            }
            else
            {
                if (!pParent)
                {
                    CCameraItem *pCurr=Root();
                    while (pCurr && pCurr->Next())
                        pCurr=pCurr->Next();
                    pCurr->Next(pNewCameraItemNode);
                    pNewCameraItemNode->Next(NULL);
                    pNewCameraItemNode->Children(NULL);
                    pNewCameraItemNode->Parent(NULL);
                }
                else if (!pParent->Children())
                {
                    pParent->Children(pNewCameraItemNode);
                    pNewCameraItemNode->Next(NULL);
                    pNewCameraItemNode->Children(NULL);
                    pNewCameraItemNode->Parent(pParent);
                }
                else
                {
                    CCameraItem *pCurr=pParent->Children();
                    while (pCurr && pCurr->Next())
                        pCurr=pCurr->Next();
                    pCurr->Next(pNewCameraItemNode);
                    pNewCameraItemNode->Next(NULL);
                    pNewCameraItemNode->Children(NULL);
                    pNewCameraItemNode->Parent(pParent);
                }
            }
        }
    }
};

#endif //__CITEMLST_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\delimstr.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       DELIMSTR.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        5/4/1999
 *
 *  DESCRIPTION: Simple string tokenizer class.  Stores the strings parsed from
 *               another string as an array of strings.  Pass the legal delimiters
 *               as the second argument to the second constructor.  Whitespace is
 *               preserved.  To eliminate whitespace, use CSimpleStringBase::Trim()
 *
 *******************************************************************************/
#ifndef __DELIMSTR_H_INCLUDED
#define __DELIMSTR_H_INCLUDED

#include "simarray.h"
#include "simstr.h"
#include "simtok.h"

template <class T>
class CDelimitedStringBase : public CSimpleDynamicArray<T>
{
private:
    T m_strOriginal;
    T m_strDelimiters;
public:
    CDelimitedStringBase(void)
    {
    }
    CDelimitedStringBase( const T &strOriginal, const T &strDelimiters )
    : m_strOriginal(strOriginal),m_strDelimiters(strDelimiters)
    {
        Parse();
    }
    CDelimitedStringBase( const CDelimitedStringBase &other )
    : m_strOriginal(other.Original()),m_strDelimiters(other.Delimiters())
    {
        Parse();
    }
    CDelimitedStringBase &operator=( const CDelimitedStringBase &other )
    {
        if (this != &other)
        {
            m_strOriginal = other.Original();
            m_strDelimiters = other.Delimiters();
            Parse();
        }
        return *this;
    }
    T Original(void) const
    {
        return m_strOriginal;
    }
    T Delimiters(void) const
    {
        return m_strDelimiters;
    }
    void Parse(void)
    {
        Destroy();
        CSimpleStringToken<T> Token( m_strOriginal );
        while (true)
        {
            T strCurrToken = Token.Tokenize(m_strDelimiters);
            if (!strCurrToken.Length())
                break;
            Append(strCurrToken);
        }
    }
};

typedef CDelimitedStringBase<CSimpleStringWide> CDelimitedStringWide;
typedef CDelimitedStringBase<CSimpleStringAnsi> CDelimitedStringAnsi;
typedef CDelimitedStringBase<CSimpleString> CDelimitedString;

#endif //__DELIMSTR_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\devlist.h ===
#ifndef __DEVLIST_H_INCLUDED
#define __DEVLIST_H_INCLUDED

#include <windows.h>
#include <sti.h>
#include "proparry.h"
#include "pshelper.h"

typedef CComPtr<IWiaPropertyStorage> CDeviceListType;

class CDeviceList : public CSimpleDynamicArray<CDeviceListType>
{
public:
    CDeviceList( IWiaDevMgr *pIWiaDevMgr=NULL, LONG nDeviceTypes=StiDeviceTypeDefault, LONG nFlags=0 )
    {
        Initialize( pIWiaDevMgr, nDeviceTypes, nFlags );
    }
    CDeviceList( const CDeviceList &other )
    {
        Append(other);
    }
    const CDeviceList &operator=( const CDeviceList &other )
    {
        Destroy();
        Append(other);
        return *this;
    }
    virtual ~CDeviceList(void)
    {
    }
    bool Initialize( IWiaDevMgr *pIWiaDevMgr, LONG nDeviceTypes, LONG nFlags=0 )
    {
        Destroy();
        if (!pIWiaDevMgr)
            return false;

        CComPtr<IEnumWIA_DEV_INFO> pIEnumWIA_DEV_INFO;
        HRESULT hr = pIWiaDevMgr->EnumDeviceInfo( nFlags, &pIEnumWIA_DEV_INFO );
        if (SUCCEEDED(hr))
        {
            ULONG ulFetched;
            CComPtr<IWiaPropertyStorage> pIWiaPropertyStorage;
            while ((hr = pIEnumWIA_DEV_INFO->Next(1,&pIWiaPropertyStorage,&ulFetched)) == S_OK)
            {
                LONG nDeviceType;
                if (!PropStorageHelpers::GetProperty( pIWiaPropertyStorage, WIA_DIP_DEV_TYPE, nDeviceType ))
                {
                    // An error occurred
                    return false;
                }
                if (nDeviceTypes == StiDeviceTypeDefault || (nDeviceTypes == GET_STIDEVICE_TYPE(nDeviceType)))
                {
                    Append(pIWiaPropertyStorage);
                }
                pIWiaPropertyStorage.Release();
            }
        }
        else
        {
           return false;
        }
        return true;
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\createtb.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       CREATETB.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        12/22/2000
 *
 *  DESCRIPTION: Toolbar helpers
 *
 *******************************************************************************/
#ifndef __CREATETB_H_INCLUDED
#define __CREATETB_H_INCLUDED

#include <windows.h>
#include <commctrl.h>

namespace ToolbarHelper
{
    class CToolbarBitmapInfo
    {
    private:
        HBITMAP   m_hBitmap;
        HWND      m_hWndToolbar;
        HINSTANCE m_hToolbarInstance;
        UINT_PTR  m_nBitmapResId;
        int       m_nButtonCount;

    private:
        CToolbarBitmapInfo();

    public:
        CToolbarBitmapInfo( HINSTANCE hToolbarInstance, UINT_PTR nBitmapResId )
          : m_hToolbarInstance(hToolbarInstance),
            m_nBitmapResId(nBitmapResId),
            m_nButtonCount(0),
            m_hBitmap(NULL),
            m_hWndToolbar(NULL)
        {
        }
        CToolbarBitmapInfo( const CToolbarBitmapInfo &other )
          : m_hToolbarInstance(other.ToolbarInstance()),
            m_nBitmapResId(other.BitmapResId()),
            m_nButtonCount(other.ButtonCount()),
            m_hBitmap(other.Bitmap()),
            m_hWndToolbar(other.Toolbar())
        {
        }
        CToolbarBitmapInfo &operator=( const CToolbarBitmapInfo &other )
        {
            if (this != &other)
            {
                m_hToolbarInstance = other.ToolbarInstance();
                m_nBitmapResId = other.BitmapResId();
                m_nButtonCount = other.ButtonCount();
                m_hBitmap = other.Bitmap();
                m_hWndToolbar = other.Toolbar();
            }
            return *this;
        }
        HBITMAP Bitmap() const
        {
            return m_hBitmap;
        }
        void Bitmap( HBITMAP hBitmap )
        {
            WIA_PUSH_FUNCTION((TEXT("CToolbarBitmapInfo::Bitmap: 0x%p"), hBitmap ));
            m_hBitmap = hBitmap;
        }
        HWND Toolbar() const
        {
            return m_hWndToolbar;
        }
        void Toolbar( HWND hWndToolbar )
        {
            m_hWndToolbar = hWndToolbar;
        }
        HINSTANCE ToolbarInstance() const
        {
            return m_hToolbarInstance;
        }
        UINT_PTR BitmapResId() const
        {
            return m_nBitmapResId;
        }
        int ButtonCount() const
        {
            return m_nButtonCount;
        }
        void ButtonCount( int nButtonCount )
        {
            m_nButtonCount = nButtonCount;
        }
        bool ReloadAndReplaceBitmap()
        {
            WIA_PUSH_FUNCTION((TEXT("CToolbarBitmapInfoReloadAndReplaceBitmap( m_hWndToolbar: 0x%p, m_hBitmap: 0x%p, m_hToolbarInstance: 0x%p, m_nBitmapResId: %d )"), m_hWndToolbar, m_hBitmap, m_hToolbarInstance, m_nBitmapResId ));
            bool bResult = false;
            if (m_hWndToolbar && m_hBitmap && m_hToolbarInstance && m_nBitmapResId)
            {
                HBITMAP hNewBitmap = CreateMappedBitmap( m_hToolbarInstance, m_nBitmapResId, 0, NULL, 0 );
                if (hNewBitmap)
                {
                    TBREPLACEBITMAP TbReplaceBitmap = {0};
                    TbReplaceBitmap.nIDOld = reinterpret_cast<UINT_PTR>(m_hBitmap);
                    TbReplaceBitmap.nIDNew = reinterpret_cast<UINT_PTR>(hNewBitmap);
                    TbReplaceBitmap.nButtons = m_nButtonCount;
                    if (SendMessage( m_hWndToolbar, TB_REPLACEBITMAP,0,reinterpret_cast<LPARAM>(&TbReplaceBitmap)))
                    {
                        m_hBitmap = hNewBitmap;
                        bResult = true;

                        //
                        // Ensure that we don't free this bitmap
                        //
                        hNewBitmap = NULL;
                    }
                    else
                    {
                        WIA_TRACE((TEXT("TB_REPLACEBITMAP failed!")));
                    }
                }
                else
                {
                    WIA_TRACE((TEXT("Unable to load bitmap!")));
                }

                //
                // Prevent GDI leak
                //
                if (hNewBitmap)
                {
                    DeleteObject( hNewBitmap );
                }
            }
            else
            {
                WIA_TRACE((TEXT("Validation error: m_hWndToolbar: 0x%p, m_hBitmap: 0x%p, m_hToolbarInstance: 0x%p, m_nBitmapResId: %d"), m_hWndToolbar, m_hBitmap, m_hToolbarInstance, m_nBitmapResId ));
            }
            return bResult;
        }
    };

    struct CButtonDescriptor
    {
        int   iBitmap;
        int   idCommand;
        BYTE  fsState;
        BYTE  fsStyle;
        bool  bFollowingSeparator;
        bool *pbControllingVariable;
        int   nStringResId;
    };
    
    enum
    {
        AlignLeft     = 0x00000000,
        AlignHCenter  = 0x00000001,
        AlignRight    = 0x00000002,
        AlignTop      = 0x00000000,
        AlignVCenter  = 0x00000004,
        AlignBottom   = 0x00000008
    };
    
    HWND CreateToolbar( 
        HWND hWndParent, 
        HWND hWndPrevious,
        HWND hWndAlign,
        int Alignment,
        UINT nToolbarId,
        CToolbarBitmapInfo &ToolbarBitmapInfo,
        CButtonDescriptor *pButtonDescriptors, 
        UINT nDescriptorCount );
    void SetToolbarButtonState( HWND hWndToolbar, int nButtonId, int nState );
    void EnableToolbarButton( HWND hWndToolbar, int nButtonId, bool bEnable );
    void CheckToolbarButton( HWND hWndToolbar, int nButtonId, bool bChecked );
    UINT GetButtonBarAccelerators( HWND hWndToolbar, ACCEL *pAccelerators, UINT nMaxCount );
}

#endif // __CREATETB_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\devprop.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       DEVPROP.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        8/31/2000
 *
 *  DESCRIPTION: Identify a scanner's characteristics
 *
 *******************************************************************************/
#include <wia.h>
#include <uicommon.h>

namespace ScannerProperties
{
    enum
    {
        HasFlatBed             = 0x00000001,
        HasDocumentFeeder      = 0x00000002,
        SupportsPreview        = 0x00000008,
        SupportsPageSize       = 0x00000010,
    };

    LONG GetDeviceProps( IWiaItem *pWiaRootItem )
    {
        WIA_PUSHFUNCTION(TEXT("ScannerProperties::GetDeviceProps()"));
        LONG lResult = 0;

        //
        // If the scanner has document handling and supports FEEDER, it has an ADF.
        //
        LONG nDocumentHandlingSelect = 0;
        if (PropStorageHelpers::GetPropertyFlags( pWiaRootItem, WIA_DPS_DOCUMENT_HANDLING_SELECT, nDocumentHandlingSelect) && (nDocumentHandlingSelect & FEEDER))
        {
            //
            // If the device has a feeder with no maximum length, it is a sheet feeder.
            //
            LONG nVerticalFeederSize = 0;
            if (PropStorageHelpers::GetProperty( pWiaRootItem, WIA_DPS_VERTICAL_SHEET_FEED_SIZE, nVerticalFeederSize ) && (nVerticalFeederSize != 0))
            {
                lResult |= HasDocumentFeeder;
                lResult |= SupportsPageSize;
            }
            else
            {
                lResult |= HasDocumentFeeder;
            }
        }

        //
        // If the scanner has a vertical bed size, it has a flatbed
        //
        LONG nVerticalBedSize = 0;
        if (PropStorageHelpers::GetProperty( pWiaRootItem, WIA_DPS_VERTICAL_BED_SIZE, nVerticalBedSize ) && (nVerticalBedSize != 0))
        {
            lResult |= HasFlatBed;
            lResult |= SupportsPreview;
        }

        //
        // If the driver specifically tells us it doesn't support previewing, turn it off
        //
        LONG nShowPreview = 0;
        if (PropStorageHelpers::GetProperty( pWiaRootItem, WIA_DPS_SHOW_PREVIEW_CONTROL, nShowPreview ) && (WIA_DONT_SHOW_PREVIEW_CONTROL == nShowPreview))
        {
            lResult &= ~SupportsPreview;
        }

        //
        // debug print an English string describing the properties
        //
#if defined(DBG)

#define ENTRY(x) { x, #x }

        static struct
        {
            LONG  nFlag;
            CHAR *strName;
        } dbgFlags[] =
        {
            ENTRY(HasFlatBed),
            ENTRY(HasDocumentFeeder),
            ENTRY(SupportsPreview),
            ENTRY(SupportsPageSize)
        };
        CSimpleStringAnsi strProps;
        for (int i=0;i<ARRAYSIZE(dbgFlags);i++)
        {
            if (lResult & dbgFlags[i].nFlag)
            {
                if (strProps.Length())
                {
                    strProps.Concat("|");
                }
                strProps.Concat(dbgFlags[i].strName);
            }
        }
        WIA_TRACE((TEXT("Device Properties: %hs"), strProps.String() ));
#endif

        return lResult;
    }
    inline IsAScrollFedScanner( IWiaItem *pWiaRootItem )
    {
        LONG nDeviceProps = GetDeviceProps(pWiaRootItem);
        return ((nDeviceProps & HasDocumentFeeder) && !(nDeviceProps & SupportsPageSize));
    }

    inline IsAFlatbedScanner( IWiaItem *pWiaRootItem )
    {
        LONG nDeviceProps = GetDeviceProps(pWiaRootItem);
        return ((nDeviceProps & HasFlatBed) && (nDeviceProps & SupportsPreview));
    }

    inline IsAnADFAndFlatbed( IWiaItem *pWiaRootItem )
    {
        LONG nDeviceProps = GetDeviceProps(pWiaRootItem);
        return ((nDeviceProps & HasFlatBed) && (nDeviceProps & HasDocumentFeeder));
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\dbllbox.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       DBLLBOX.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        3/25/1999
 *
 *  DESCRIPTION: Owner drawn listbox and combobox that do an icon plus a title and subtitle
 *
 *******************************************************************************/
#ifndef __DBLLBOX_H_INCLUDED
#define __DBLLBOX_H_INCLUDED

#include "simstr.h"

template <class T>
class CDoubleLineListBoxItem
{
private:
    CSimpleString m_strTitle;
    CSimpleString m_strSubTitle;
    HICON         m_hIcon;
    T             m_Data;
public:
    CDoubleLineListBoxItem( const T &data, LPCTSTR pszTitle = NULL, LPCTSTR pszSubTitle = NULL, HICON hIcon = NULL );
    CDoubleLineListBoxItem( const CDoubleLineListBoxItem &other );
    CDoubleLineListBoxItem &operator=( const CDoubleLineListBoxItem &other );
    CDoubleLineListBoxItem &Assign( const CSimpleString &strTitle, const CSimpleString &strSubTitle, HICON hIcon, const T &data );
    ~CDoubleLineListBoxItem(void);
    CSimpleString Title(void) const;
    CSimpleString SubTitle(void) const;
    T Data(void) const;
    HICON Icon(void) const;
    HICON CopyIcon(void) const;
};

template <class T>
CDoubleLineListBoxItem<T>::CDoubleLineListBoxItem( const T &data, LPCTSTR pszTitle, LPCTSTR pszSubTitle, HICON hIcon )
: m_strTitle(),
  m_strSubTitle(),
  m_hIcon(NULL)
{
    Assign( pszTitle, pszSubTitle, hIcon, data );
}

template <class T>
CDoubleLineListBoxItem<T>::CDoubleLineListBoxItem( const CDoubleLineListBoxItem &other )
 : m_strTitle(),
   m_strSubTitle(),
   m_hIcon(NULL)
{
    Assign( other.Title(), other.SubTitle(), other.CopyIcon(), other.Data() );
}


template <class T>
CDoubleLineListBoxItem<T> &CDoubleLineListBoxItem<T>::operator=( const CDoubleLineListBoxItem &other )
{
    return( Assign( other.Title(), other.SubTitle(), other.CopyIcon(), other.Data() ));
}


template <class T>
CDoubleLineListBoxItem<T> &CDoubleLineListBoxItem<T>::Assign( const CSimpleString &strTitle, const CSimpleString &strSubTitle, HICON hIcon, const T &Data )
{
    if (m_hIcon)
    {
        DestroyIcon( m_hIcon );
    }
    m_hIcon = hIcon;
    m_strTitle = strTitle;
    m_strSubTitle = strSubTitle;
    m_Data = Data;
    return(*this);
}


template <class T>
CDoubleLineListBoxItem<T>::~CDoubleLineListBoxItem(void)
{
    if (m_hIcon)
    {
        DestroyIcon( m_hIcon );
        m_hIcon = NULL;
        m_strTitle = m_strSubTitle = TEXT("");
    }
}

template <class T>
CSimpleString CDoubleLineListBoxItem<T>::Title(void) const
{
    return(m_strTitle);
}

template <class T>
CSimpleString CDoubleLineListBoxItem<T>::SubTitle(void) const
{
    return(m_strSubTitle);
}


template <class T>
T CDoubleLineListBoxItem<T>::Data(void) const
{
    return(m_Data);
}

template <class T>
HICON CDoubleLineListBoxItem<T>::Icon(void) const
{
    return(m_hIcon);
}


template <class T>
HICON CDoubleLineListBoxItem<T>::CopyIcon(void) const
{
    return(m_hIcon ? ::CopyIcon(m_hIcon) : NULL );
}


template <class T>
class CDoubleLineListBox
{
private:
    HWND  m_hWnd;
    HFONT m_hFontTitle;
    HFONT m_hFontSubTitle;
    SIZE  m_sizeIcon;
    BOOL  m_bIsComboBox;
    int   m_nTitleTextHeight;
    int   m_nSubTitleTextHeight;

    enum
    {
        c_AdditionalIconBorder = 3 // Additional border around icons
    };

private:
    // No implementation
    CDoubleLineListBox( const CDoubleLineListBox & );
    CDoubleLineListBox &operator=( const CDoubleLineListBox & );

public:
    CDoubleLineListBox(void);
    ~CDoubleLineListBox(void);
    void Destroy(void);
    void AssignFonts( HFONT hFontTitle, HFONT hFontSubTitle );
    void CreateDefaultFonts(void);
    CDoubleLineListBox &Assign( HWND hWnd );
    HWND Handle(void) const;
    void Handle( HWND hWnd );
    CDoubleLineListBox &operator=( HWND hWnd );
    LRESULT AddItem( CDoubleLineListBoxItem<T> *pNewItem );
    CDoubleLineListBoxItem<T> *GetItem( int nIndex );
    void HandleDeleteItem( LPDELETEITEMSTRUCT pDeleteItem );
    void HandleMeasureItem( LPMEASUREITEMSTRUCT pMeasureItem );
    void HandleDrawItem( LPDRAWITEMSTRUCT pDrawItem );
    int SetHorizontalExtent(void);
    SIZE MeasureItem( int nIndex );
};


template <class T>
CDoubleLineListBox<T>::CDoubleLineListBox(void)
: m_hWnd(NULL),
  m_hFontTitle(NULL),
  m_hFontSubTitle(NULL),
  m_bIsComboBox(false),
  m_nTitleTextHeight(0),
  m_nSubTitleTextHeight(0)
{
}


template <class T>
CDoubleLineListBox<T>::~CDoubleLineListBox(void)
{
    Destroy();
}


template <class T>
void CDoubleLineListBox<T>::Destroy(void)
{
    m_hWnd = NULL;
    if (m_hFontTitle)
    {
        DeleteObject(m_hFontTitle);
        m_hFontTitle = NULL;
    }
    if (m_hFontSubTitle)
    {
        DeleteObject(m_hFontSubTitle);
        m_hFontSubTitle = NULL;
    }
}


template <class T>
void CDoubleLineListBox<T>::AssignFonts( HFONT hFontTitle, HFONT hFontSubTitle )
{
    if (m_hFontTitle)
    {
        DeleteObject(m_hFontTitle);
        m_hFontTitle = NULL;
    }
    if (m_hFontSubTitle)
    {
        DeleteObject(m_hFontSubTitle);
        m_hFontSubTitle = NULL;
    }

    m_hFontTitle = hFontTitle;
    m_hFontSubTitle = hFontSubTitle;

    HDC hDC = GetDC(NULL);
    if (hDC)
    {
        HFONT hOldFont = reinterpret_cast<HFONT>(SelectObject(hDC,m_hFontTitle));

        TEXTMETRIC TextMetric;
        GetTextMetrics( hDC, &TextMetric );
        m_nTitleTextHeight = TextMetric.tmHeight + TextMetric.tmExternalLeading;

        SelectObject(hDC,m_hFontSubTitle);
        GetTextMetrics( hDC, &TextMetric );
        m_nSubTitleTextHeight = TextMetric.tmHeight + TextMetric.tmExternalLeading;

        SelectObject( hDC, hOldFont );
        ReleaseDC( NULL, hDC );
    }
}


template <class T>
void CDoubleLineListBox<T>::CreateDefaultFonts(void)
{
    HFONT hCurrFont = NULL, hFontTitle = NULL, hFontSubTitle = NULL;
    if (m_hWnd && IsWindow(m_hWnd))
    {
        hCurrFont = reinterpret_cast<HFONT>(SendMessage(m_hWnd,WM_GETFONT,0,0));
    }
    if (!hCurrFont)
    {
        hCurrFont = reinterpret_cast<HFONT>(GetStockObject(ANSI_VAR_FONT));
    }
    if (hCurrFont)
    {
        LOGFONT lf;
        if (GetObject( hCurrFont, sizeof(lf), &lf ))
        {
            lf.lfWeight = FW_BOLD;
            hFontTitle = CreateFontIndirect(&lf);
            lf.lfWeight = FW_NORMAL;
            hFontSubTitle = CreateFontIndirect(&lf);
        }
    }
    AssignFonts( hFontTitle, hFontSubTitle );
}


template <class T>
CDoubleLineListBox<T> &CDoubleLineListBox<T>::Assign( HWND hWnd )
{
    Destroy();
    m_hWnd = hWnd;
    CreateDefaultFonts();
    if (m_hWnd && IsWindow(m_hWnd))
    {
        TCHAR szClassName[MAX_PATH];
        if (GetClassName( m_hWnd, szClassName, sizeof(szClassName)/sizeof(szClassName[0])))
        {
            m_bIsComboBox = (lstrcmpi( szClassName, TEXT("combobox") ) == 0);
        }
    }
    return(*this);
}


template <class T>
HWND CDoubleLineListBox<T>::Handle(void) const
{
    return(m_hWnd);
}


template <class T>
void CDoubleLineListBox<T>::Handle( HWND hWnd )
{
    Assign(hWnd);
}


template <class T>
CDoubleLineListBox<T> &CDoubleLineListBox<T>::operator=( HWND hWnd )
{
    return(Assign(hWnd));
}


template <class T>
LRESULT CDoubleLineListBox<T>::AddItem( CDoubleLineListBoxItem<T> *pNewItem )
{
    LRESULT lResult = -1;
    if (IsWindow(m_hWnd) && pNewItem)
    {
        lResult = SendMessage( m_hWnd, m_bIsComboBox ? CB_ADDSTRING : LB_ADDSTRING, 0, reinterpret_cast<LPARAM>(pNewItem->Title().String()) );
        if (lResult >= 0)
        {
            SendMessage( m_hWnd, m_bIsComboBox ? CB_SETITEMDATA : LB_SETITEMDATA, lResult, reinterpret_cast<LPARAM>(pNewItem) );
        }
        SetHorizontalExtent();
    }
    return(lResult);
}


template <class T>
CDoubleLineListBoxItem<T> *CDoubleLineListBox<T>::GetItem( int nIndex )
{
    LRESULT lResult = 0;
    if (IsWindow(m_hWnd))
    {
        lResult = SendMessage( m_hWnd, m_bIsComboBox ? CB_GETITEMDATA : LB_GETITEMDATA, nIndex, 0 );
        if (lResult == CB_ERR || lResult == LB_ERR)
            lResult = 0;
    }
    return(reinterpret_cast<CDoubleLineListBoxItem<T> *>(lResult));
}


// This must be called in response to WM_DELETEITEM
template <class T>
void CDoubleLineListBox<T>::HandleDeleteItem( LPDELETEITEMSTRUCT pDeleteItem )
{
    if (pDeleteItem && IsWindow(m_hWnd) && pDeleteItem->hwndItem == m_hWnd)
    {
        CDoubleLineListBoxItem *pItem = reinterpret_cast<CDoubleLineListBoxItem *>(pDeleteItem->itemData);
        if (pItem)
            delete pItem;
    }
}

// This must be called in response to WM_MEASUREITEM
template <class T>
void CDoubleLineListBox<T>::HandleMeasureItem( LPMEASUREITEMSTRUCT pMeasureItem )
{
    if (pMeasureItem)
    {
        SIZE sizeItem = MeasureItem( pMeasureItem->itemID );
        pMeasureItem->itemHeight = sizeItem.cy;
    }
}

template <class T>
int CDoubleLineListBox<T>::SetHorizontalExtent(void)
{
    if (IsWindow(m_hWnd))
    {
        int nMaxLength = 0;
        LRESULT lCount = SendMessage( m_hWnd, m_bIsComboBox ? CB_GETCOUNT : LB_GETCOUNT, 0, 0 );
        for (int i=0;i<(int)lCount;i++)
        {
            SIZE sizeItem = MeasureItem(i);
            nMaxLength = (sizeItem.cx > nMaxLength) ? sizeItem.cx : nMaxLength;
        }
        SendMessage( m_hWnd, m_bIsComboBox ? CB_SETHORIZONTALEXTENT : LB_SETHORIZONTALEXTENT, nMaxLength, 0 );
        return nMaxLength;
    }
    return 0;
}

// Return the width and height, in pixels, of an item
template <class T>
SIZE CDoubleLineListBox<T>::MeasureItem( int nIndex )
{
    SIZE sizeItem =
    {
        GetSystemMetrics(SM_CXICON) + c_AdditionalIconBorder * 3 + 2,
        GetSystemMetrics(SM_CYICON) + c_AdditionalIconBorder * 2 + 2
    };
    if (IsWindow(m_hWnd))
    {
        // Make sure we have valid fonts
        if (!m_hFontTitle || !m_hFontSubTitle)
            CreateDefaultFonts();
        CDoubleLineListBoxItem<T> *pItem = GetItem(nIndex);
        if (pItem)
        {
            HDC hDC = GetDC(m_hWnd);
            if (hDC)
            {
                HFONT hOldFont = reinterpret_cast<HFONT>(SelectObject(hDC,m_hFontTitle));

                // Calculate the size of the text rectangle for the title
                RECT rcText;
                ZeroMemory(&rcText,sizeof(rcText));
                DrawTextEx( hDC, const_cast<LPTSTR>(pItem->Title().String()), -1, &rcText, DT_SINGLELINE|DT_LEFT|DT_TOP|DT_NOPREFIX|DT_CALCRECT, NULL );
                int nTitleWidth = rcText.right - rcText.left;

                // Calculate the size of the text rectangle for the sub title
                ZeroMemory(&rcText,sizeof(rcText));
                SelectObject(hDC,m_hFontSubTitle);
                DrawTextEx( hDC, const_cast<LPTSTR>(pItem->SubTitle().String()), -1, &rcText, DT_SINGLELINE|DT_LEFT|DT_TOP|DT_NOPREFIX|DT_CALCRECT, NULL );
                int nSubTitleWidth = rcText.right - rcText.left;

                sizeItem.cx += (nTitleWidth > nSubTitleWidth) ? nTitleWidth : nSubTitleWidth;

                SelectObject( hDC, hOldFont );
                ReleaseDC( m_hWnd, hDC );
            }
        }
    }
    return(sizeItem);
}

// This must be called in response to WM_DRAWITEM
template <class T>
void CDoubleLineListBox<T>::HandleDrawItem( LPDRAWITEMSTRUCT pDrawItem )
{
    if (pDrawItem && IsWindow(m_hWnd) && pDrawItem->hwndItem == m_hWnd)
    {
        // Make sure we have valid fonts
        if (!m_hFontTitle || !m_hFontSubTitle)
            CreateDefaultFonts();

        RECT rcItem = pDrawItem->rcItem;
        // Paint the background
        if (ODS_SELECTED & pDrawItem->itemState)
        {
            if (IsWindowEnabled(pDrawItem->hwndItem))
            {
                FillRect( pDrawItem->hDC, &rcItem, GetSysColorBrush(COLOR_HIGHLIGHT));
            }
            else
            {
                FillRect( pDrawItem->hDC, &rcItem, GetSysColorBrush(COLOR_INACTIVECAPTION));
            }
        }
        else
        {
            FillRect( pDrawItem->hDC, &rcItem, GetSysColorBrush(COLOR_WINDOW));
        }

        // Paint the focus rectangle
        if (ODS_FOCUS & pDrawItem->itemState)
        {
            DrawFocusRect( pDrawItem->hDC, &rcItem );
        }

        // Shrink by one pixel, so we don't overwrite the focus rect
        InflateRect( &rcItem, -1, -1 );

        if (pDrawItem->itemData != -1)
        {
            CDoubleLineListBoxItem<T> *pItem = reinterpret_cast<CDoubleLineListBoxItem<T> *>(pDrawItem->itemData);
            if (pItem)
            {
                // Draw the icon
                DrawIconEx( pDrawItem->hDC, pDrawItem->rcItem.left+c_AdditionalIconBorder, pDrawItem->rcItem.top+c_AdditionalIconBorder, pItem->Icon(), GetSystemMetrics(SM_CXICON), GetSystemMetrics(SM_CYICON), 0, NULL, DI_NORMAL );

                // Move the left margin over to make room for the text
                rcItem.left += GetSystemMetrics(SM_CXICON) + c_AdditionalIconBorder * 2;

                // Set up the dc
                COLORREF crOldTextColor;
                if (IsWindowEnabled(pDrawItem->hwndItem))
                {
                    if (ODS_SELECTED & pDrawItem->itemState)
                        crOldTextColor = SetTextColor( pDrawItem->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT) );
                    else crOldTextColor = SetTextColor( pDrawItem->hDC, GetSysColor(COLOR_WINDOWTEXT) );
                }
                else
                {
                    if (ODS_SELECTED & pDrawItem->itemState)
                        crOldTextColor = SetTextColor( pDrawItem->hDC, GetSysColor(COLOR_INACTIVECAPTIONTEXT) );
                    else crOldTextColor = SetTextColor( pDrawItem->hDC, GetSysColor(COLOR_GRAYTEXT) );
                }

                int nOldBkMode = SetBkMode( pDrawItem->hDC, TRANSPARENT );
                HFONT hOldFont = reinterpret_cast<HFONT>(SelectObject(pDrawItem->hDC,m_hFontTitle));

                // Calculate the text rectangle
                RECT rcText = rcItem;
                rcText.top += (((rcText.bottom - rcText.top)) - (m_nTitleTextHeight + m_nSubTitleTextHeight)) / 2;
                rcText.bottom = rcText.top + m_nTitleTextHeight + m_nSubTitleTextHeight;

                DrawTextEx( pDrawItem->hDC, const_cast<LPTSTR>(pItem->Title().String()), -1, &rcText, DT_SINGLELINE|DT_LEFT|DT_TOP|DT_NOPREFIX, NULL );

                // Get ready for the sub-title
                SelectObject(pDrawItem->hDC,m_hFontSubTitle);

                // Get the coords for the bottom text rect
                rcText.top += m_nTitleTextHeight;

                // Draw the text
                DrawTextEx( pDrawItem->hDC, const_cast<LPTSTR>(pItem->SubTitle().String()), -1, &rcText, DT_SINGLELINE|DT_LEFT|DT_TOP|DT_NOPREFIX, NULL );

                // Restore the dc
                SelectObject(pDrawItem->hDC,hOldFont);
                SetBkMode( pDrawItem->hDC, nOldBkMode );
                SetTextColor( pDrawItem->hDC, crOldTextColor );
            }
        }
    }
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\dlgunits.h ===
#ifndef __DLGUNITS_H_INCLUDED
#define __DLGUNITS_H_INCLUDED

#include <windows.h>

class CDialogUnits
{
private:
    HWND m_hWnd;

private:
    CDialogUnits(void);
    CDialogUnits( const CDialogUnits &other );
    CDialogUnits &operator=( const CDialogUnits & );

public:
    CDialogUnits( HWND hWnd )
    : m_hWnd(hWnd)
    {
    }
    int X( INT nDialogUnits )
    {
        RECT rc;
        ZeroMemory( &rc, sizeof(rc) );
        rc.left = nDialogUnits;
        MapDialogRect( m_hWnd, &rc );
        return(rc.left);
    }
    int Y( INT nDialogUnits )
    {
        RECT rc;
        ZeroMemory( &rc, sizeof(rc) );
        rc.bottom = nDialogUnits;
        MapDialogRect( m_hWnd, &rc );
        return(rc.bottom);
    }
    POINT DialogUnitsToPixels( const POINT &ptDialogUnits )
    {
        RECT rc;
        ZeroMemory( &rc, sizeof(rc) );
        rc.left = ptDialogUnits.x;
        rc.top = ptDialogUnits.y;
        MapDialogRect( m_hWnd, &rc );
        POINT ptReturnValue;
        ptReturnValue.x = rc.left;
        ptReturnValue.y = rc.top;
        return(ptReturnValue);
    }
    SIZE DialogUnitsToPixels( const SIZE &sizeDialogUnits )
    {
        RECT rc;
        ZeroMemory( &rc, sizeof(rc) );
        rc.left = sizeDialogUnits.cx;
        rc.top = sizeDialogUnits.cy;
        MapDialogRect( m_hWnd, &rc );
        SIZE sizeReturnValue;
        sizeReturnValue.cx = rc.left;
        sizeReturnValue.cy = rc.top;
        return(sizeReturnValue);
    }
    RECT DialogUnitsToPixels( const RECT &rcDialogUnits )
    {
        RECT rc;
        ZeroMemory( &rc, sizeof(rc) );
        rc.left = rcDialogUnits.left;
        rc.top = rcDialogUnits.top;
        rc.right = rcDialogUnits.right;
        rc.bottom = rcDialogUnits.bottom;
        MapDialogRect( m_hWnd, &rc );
        return(rc);
    }
    SIZE StandardButtonSize(void)
    {
        SIZE sizeRes = { 50, 14 };
        return DialogUnitsToPixels( sizeRes );
    }
    SIZE StandardMargin(void)
    {
        SIZE sizeRes = { 7, 7 };
        return DialogUnitsToPixels( sizeRes );
    }
    SIZE StandardButtonMargin(void)
    {
        SIZE sizeRes = { 4, 7 };
        return DialogUnitsToPixels( sizeRes );
    }
};

#endif __DLGUNITS_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\errors.cpp ===
#include "precomp.h"
#pragma hdrstop

namespace UIErrors
{
     /**************************************
         UIErrors::ReportResult

         Given an HRESULT, map it to a user friendly message (when possible).
         If we don't have a mapping, defer to FormatMessage (ugh!)
         This function should be a last resort.

     ***************************************/

     VOID
     ReportResult (HWND hwndParent, HINSTANCE hInst, HRESULT hr)
     {
        switch (hr)
        {
            case RPC_E_CALL_REJECTED:
            case RPC_E_RETRY:
            case RPC_E_TIMEOUT:
                ReportError (hwndParent, hInst, ErrStiBusy);
                break;

            case RPC_E_SERVER_DIED:
            case RPC_E_SERVER_DIED_DNE:
            case RPC_E_DISCONNECTED:
                ReportError (hwndParent, hInst, ErrStiCrashed);
                break;

            default:
                LPTSTR szErrMsg = NULL;
                FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                               NULL,
                               hr,
                               MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
                               reinterpret_cast<LPTSTR>(&szErrMsg),
                               0,
                               NULL
                              );
                if (szErrMsg)
                {
                    CSimpleString strTitle;
                    strTitle.LoadString (IDS_ERRTITLE_HRESULT, hInst);
                    ReportMessage (hwndParent, hInst, NULL, strTitle, szErrMsg);
                }
                else
                {
                    ReportMessage (hwndParent, hInst, NULL, MAKEINTRESOURCE(IDS_ERRTITLE_UNKNOWNERR), MAKEINTRESOURCE(IDS_ERROR_UNKNOWNERR));
                }
                break;
        }
     }

     /**************************************
         UIErrors::ReportMessage

         These functions wrap MessageBoxIndirect to
         display given strings.

     ***************************************/



     VOID
     ReportMessage (HWND hwndParent,
                    HINSTANCE hInst,
                    LPCTSTR idIcon,
                    LPCTSTR idTitle,
                    LPCTSTR idMessage,
                    DWORD   dwStyle)
     {
         MSGBOXPARAMS mbp = {0};

         mbp.cbSize = sizeof(MSGBOXPARAMS);
         mbp.hwndOwner = hwndParent;
         mbp.hInstance = hInst;
         mbp.lpszText = idMessage;
         mbp.lpszCaption = idTitle;
         mbp.dwStyle = MB_OK | dwStyle;
         if (idIcon)
         {
             mbp.dwStyle |= MB_USERICON;
             mbp.lpszIcon = idIcon;
         }
         else
         {
             mbp.lpszIcon = NULL;
         }
         mbp.dwContextHelpId = 0;
         mbp.lpfnMsgBoxCallback = 0;
         mbp.dwLanguageId = MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT);
         MessageBoxIndirect (&mbp);
     }

     // build an array of message ids indexed by the WiaError enum

     struct MsgMap
     {
         INT      idTitle;
         INT      idMessage;
     } ErrorCodes [] =
     {
        {IDS_ERRTITLE_DISCONNECTED, IDS_ERROR_DISCONNECTED},
        {IDS_ERRTITLE_COMMFAILURE, IDS_ERROR_COMMFAILURE},
        {IDS_ERRTITLE_STICRASH, IDS_ERROR_STICRASH},
        {IDS_ERRTITLE_STIBUSY, IDS_ERROR_STIBUSY},
        {IDS_ERRTITLE_SCANFAIL, IDS_ERROR_SCANFAIL},
     };


     VOID
     ReportError (HWND hwndParent,
                  HINSTANCE hInst,
                  WiaError err)
     {


         ReportMessage (hwndParent, hInst, NULL, MAKEINTRESOURCE(ErrorCodes[err].idTitle), MAKEINTRESOURCE(ErrorCodes[err].idMessage));
     }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\errors.h ===
#ifndef _ERRORS_H_
#define _ERRORS_H_

namespace UIErrors
{
    // If you add to this list you must update the ErrorCodes[] array in errors.cpp
    enum WiaError
    {
        ErrDisconnected=0,
        ErrCommunicationsFailure,
        ErrStiCrashed,
        ErrStiBusy,
        ErrScanFailed
    };


    VOID ReportResult (HWND hwndParent, HINSTANCE hInst, HRESULT hr);
    VOID ReportMessage (HWND hwndParent, HINSTANCE hInst, LPCTSTR idIcon, LPCTSTR idTitle,  LPCTSTR idMessage, DWORD dwStyle = 0);
    VOID ReportError (HWND hwndParent, HINSTANCE hInst, WiaError err);


};

// string resource identifiers
// If you include this file, make sure these don't collide with your resource IDs

#define UI_ERROR_MIN_ID                          23000

#define IDS_ERRTITLE_DISCONNECTED                UI_ERROR_MIN_ID
#define IDS_ERROR_DISCONNECTED                   UI_ERROR_MIN_ID+1
#define IDS_ERRTITLE_COMMFAILURE                 UI_ERROR_MIN_ID+2
#define IDS_ERROR_COMMFAILURE                    UI_ERROR_MIN_ID+3
#define IDS_ERRTITLE_STICRASH                    UI_ERROR_MIN_ID+4
#define IDS_ERROR_STICRASH                       UI_ERROR_MIN_ID+5
#define IDS_ERRTITLE_STIBUSY                     UI_ERROR_MIN_ID+6
#define IDS_ERROR_STIBUSY                        UI_ERROR_MIN_ID+7
#define IDS_ERRTITLE_SCANFAIL                    UI_ERROR_MIN_ID+8
#define IDS_ERROR_SCANFAIL                       UI_ERROR_MIN_ID+9
#define IDS_ERRTITLE_HRESULT                     UI_ERROR_MIN_ID+10
#define IDS_ERRTITLE_UNKNOWNERR                  UI_ERROR_MIN_ID+11
#define IDS_ERROR_UNKNOWNERR                     UI_ERROR_MIN_ID+12

//
// Straight mapping between WIA errors and strings
//
#define IDS_WIA_ERROR_GENERAL_ERROR              UI_ERROR_MIN_ID+32
#define IDS_WIA_ERROR_PAPER_JAM                  UI_ERROR_MIN_ID+33
#define IDS_WIA_ERROR_PAPER_EMPTY                UI_ERROR_MIN_ID+34
#define IDS_WIA_ERROR_PAPER_PROBLEM              UI_ERROR_MIN_ID+35
#define IDS_WIA_ERROR_OFFLINE                    UI_ERROR_MIN_ID+36
#define IDS_WIA_ERROR_BUSY                       UI_ERROR_MIN_ID+37
#define IDS_WIA_ERROR_WARMING_UP                 UI_ERROR_MIN_ID+38
#define IDS_WIA_ERROR_USER_INTERVENTION          UI_ERROR_MIN_ID+39
#define IDS_WIA_ERROR_ITEM_DELETED               UI_ERROR_MIN_ID+40
#define IDS_WIA_ERROR_DEVICE_COMMUNICATION       UI_ERROR_MIN_ID+41
#define IDS_WIA_ERROR_INVALID_COMMAND            UI_ERROR_MIN_ID+42
#define IDS_WIA_ERROR_INCORRECT_HARDWARE_SETTING UI_ERROR_MIN_ID+43
#define IDS_WIA_ERROR_DEVICE_LOCKED              UI_ERROR_MIN_ID+44

#define UI_ERROR_MAX_ID                          UI_ERROR_MIN_ID+44

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\dumpprop.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
         *  TITLE:       DUMPPROP.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        9/27/2000
 *
 *  DESCRIPTION: Display the properties associated with a IWiaItem, either to the
 *               debugger, or to a log file.
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "dumpprop.h"

//
// Change this to limit the width of individual strings (for avoiding ugliness)
//
#define MAX_DUMP_STRING 160

CWiaDebugDump::CWiaDebugDump(void)
{
}

CWiaDebugDump::~CWiaDebugDump(void)
{
}

CWiaDebugDumpToFileHandle::CWiaDebugDumpToFileHandle( HANDLE hFile )
  : m_hFile(hFile)
{
}

CWiaDebugDumpToFileHandle::~CWiaDebugDumpToFileHandle(void)
{
}

void CWiaDebugDumpToFileHandle::Print( LPCTSTR pszString )
{
    if (m_hFile && pszString)
    {
        DWORD dwWritten;
        WriteFile( m_hFile, pszString, lstrlen(pszString)*sizeof(TCHAR), &dwWritten, NULL );
        WriteFile( m_hFile, TEXT("\r\n"), 2*sizeof(TCHAR), &dwWritten, NULL );
    }
}


CWiaDebugDumpToFile::CWiaDebugDumpToFile( LPCTSTR pszFilename, bool bOverwrite )
  : m_hFile(INVALID_HANDLE_VALUE)
{
    if (pszFilename && lstrlen(pszFilename))
    {
        m_hFile = CreateFile( pszFilename, GENERIC_READ|GENERIC_WRITE, FILE_SHARE_READ, NULL, bOverwrite ? CREATE_ALWAYS : OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
        if (!bOverwrite && m_hFile)
        {
            SetFilePointer( m_hFile, 0, NULL, FILE_END );
        }
    }
}

CWiaDebugDumpToFile::~CWiaDebugDumpToFile(void)
{
    if (INVALID_HANDLE_VALUE != m_hFile)
    {
        CloseHandle(m_hFile);
        m_hFile = INVALID_HANDLE_VALUE;
    }
}

void CWiaDebugDumpToFile::Print( LPCTSTR pszString )
{
    if (m_hFile && pszString)
    {
        DWORD dwWritten;
        WriteFile( m_hFile, pszString, lstrlen(pszString)*sizeof(TCHAR), &dwWritten, NULL );
        WriteFile( m_hFile, TEXT("\r\n"), 2*sizeof(TCHAR), &dwWritten, NULL );
    }
}


CSimpleString CWiaDebugDump::GetTymedString( LONG tymed )
{
    switch (tymed)
    {
    case TYMED_CALLBACK:
        return TEXT("TYMED_CALLBACK");

    case TYMED_FILE:
        return TEXT("TYMED_FILE");

    case TYMED_MULTIPAGE_CALLBACK:
        return TEXT("TYMED_MULTIPAGE_CALLBACK");

    case TYMED_MULTIPAGE_FILE:
        return TEXT("TYMED_MULTIPAGE_FILE");
    }
    return CSimpleString().Format( TEXT("0x%08X"), tymed );
}

CSimpleString CWiaDebugDump::GetPropVariantTypeString( VARTYPE vt )
{
    CSimpleString strResult;

    static const struct
    {
        VARTYPE vt;
        LPCTSTR pszName;
    }
    s_VarTypes[] =
    {
        { VT_I2, TEXT("VT_I2") },
        { VT_I4, TEXT("VT_I4") },
        { VT_R4, TEXT("VT_R4") },
        { VT_R8, TEXT("VT_R8") },
        { VT_CY, TEXT("VT_CY") },
        { VT_DATE, TEXT("VT_DATE") },
        { VT_BSTR, TEXT("VT_BSTR") },
        { VT_DISPATCH, TEXT("VT_DISPATCH") },
        { VT_ERROR, TEXT("VT_ERROR") },
        { VT_BOOL, TEXT("VT_BOOL") },
        { VT_VARIANT, TEXT("VT_VARIANT") },
        { VT_UNKNOWN, TEXT("VT_UNKNOWN") },
        { VT_DECIMAL, TEXT("VT_DECIMAL") },
        { VT_I1, TEXT("VT_I1") },
        { VT_UI1, TEXT("VT_UI1") },
        { VT_UI2, TEXT("VT_UI2") },
        { VT_UI4, TEXT("VT_UI4") },
        { VT_I8, TEXT("VT_I8") },
        { VT_UI8, TEXT("VT_UI8") },
        { VT_INT, TEXT("VT_INT") },
        { VT_UINT, TEXT("VT_UINT") },
        { VT_VOID, TEXT("VT_VOID") },
        { VT_HRESULT, TEXT("VT_HRESULT") },
        { VT_PTR, TEXT("VT_PTR") },
        { VT_SAFEARRAY, TEXT("VT_SAFEARRAY") },
        { VT_CARRAY, TEXT("VT_CARRAY") },
        { VT_USERDEFINED, TEXT("VT_USERDEFINED") },
        { VT_LPSTR, TEXT("VT_LPSTR") },
        { VT_LPWSTR, TEXT("VT_LPWSTR") },
        { VT_RECORD, TEXT("VT_RECORD") },
        { VT_INT_PTR, TEXT("VT_INT_PTR") },
        { VT_UINT_PTR, TEXT("VT_UINT_PTR") },
        { VT_FILETIME, TEXT("VT_FILETIME") },
        { VT_BLOB, TEXT("VT_BLOB") },
        { VT_STREAM, TEXT("VT_STREAM") },
        { VT_STORAGE, TEXT("VT_STORAGE") },
        { VT_STREAMED_OBJECT, TEXT("VT_STREAMED_OBJECT") },
        { VT_STORED_OBJECT, TEXT("VT_STORED_OBJECT") },
        { VT_BLOB_OBJECT, TEXT("VT_BLOB_OBJECT") },
        { VT_CF, TEXT("VT_CF") },
        { VT_CLSID, TEXT("VT_CLSID") },
        { VT_VERSIONED_STREAM, TEXT("VT_VERSIONED_STREAM") }
    },
    s_ExtendedTypes[] =
    {
        { VT_VECTOR, TEXT("VT_VECTOR") },
        { VT_ARRAY, TEXT("VT_ARRAY") },
        { VT_BYREF, TEXT("VT_BYREF") },
        { VT_RESERVED, TEXT("VT_RESERVED") }
    };
    for (int i=0;i<ARRAYSIZE(s_ExtendedTypes);i++)
    {
        if (vt & s_ExtendedTypes[i].vt)
        {
            if (strResult.Length())
            {
                strResult += TEXT(" | ");
            }
            strResult += s_ExtendedTypes[i].pszName;
        }
    }
    for (int i=0;i<ARRAYSIZE(s_VarTypes);i++)
    {
        if ((vt & VT_TYPEMASK) == s_VarTypes[i].vt)
        {
            if (strResult.Length())
            {
                strResult += TEXT(" | ");
            }
            strResult += s_VarTypes[i].pszName;
        }
    }
    if (!strResult.Length())
    {
        strResult.Format( TEXT("Unknown variant type: 0x%04X"), vt );
    }
    return strResult;
}


CSimpleString CWiaDebugDump::GetPrintableValue( PROPVARIANT &PropVariant )
{
    TCHAR szValue[1024] = TEXT("");
    switch (PropVariant.vt)
    {
    case VT_I1:
        wsprintf(szValue,TEXT("%d, (0x%08X)"),PropVariant.cVal,PropVariant.cVal);
        break;

    case VT_UI1:
        wsprintf(szValue,TEXT("%u, (0x%08X)"),PropVariant.bVal,PropVariant.bVal);
        break;

    case VT_I2:
        wsprintf(szValue,TEXT("%d, (0x%08X)"),PropVariant.iVal,PropVariant.iVal);
        break;

    case VT_UI2:
        wsprintf(szValue,TEXT("%u, (0x%08X)"),PropVariant.uiVal,PropVariant.uiVal);
        break;

    case VT_I4:
        wsprintf(szValue,TEXT("%ld, (0x%08X)"),PropVariant.lVal,PropVariant.lVal);
        break;

    case VT_UI4:
        wsprintf(szValue,TEXT("%lu, (0x%08X)"),PropVariant.ulVal,PropVariant.ulVal);
        break;

    case VT_BSTR:
        wsprintf(szValue,TEXT("%ws"),PropVariant.bstrVal);
        break;

    case VT_LPWSTR:
        wsprintf(szValue,TEXT("%ws"),PropVariant.pwszVal );
        break;

    case VT_CLSID:
        wsprintf(szValue,TEXT("%s"), GetStringFromGuid(*PropVariant.puuid).String());
        break;

    case VT_VECTOR|VT_I1:
        {
            wsprintf(szValue+lstrlen(szValue), TEXT("Length: [%d] "), PropVariant.cac.cElems );
            for (int i=0;i<(int)PropVariant.cac.cElems;i++)
            {
                if (lstrlen(szValue) >= MAX_DUMP_STRING)
                {
                    lstrcat( szValue, TEXT("...") );
                    break;
                }
                wsprintf(szValue+lstrlen(szValue), TEXT("%02X"), (ULONG)PropVariant.cac.pElems[i] );
                if (i < (int)PropVariant.cal.cElems-1 && i % 4 == 3)
                {
                    wsprintf(szValue+lstrlen(szValue),TEXT(" "));
                }
            }
        }
        break;

    case VT_VECTOR|VT_UI1:
        {
            wsprintf(szValue+lstrlen(szValue), TEXT("Length: [%d] "), PropVariant.caub.cElems );
            for (int i=0;i<(int)PropVariant.caub.cElems;i++)
            {
                if (lstrlen(szValue) >= MAX_DUMP_STRING)
                {
                    lstrcat( szValue, TEXT("...") );
                    break;
                }

                wsprintf(szValue+lstrlen(szValue), TEXT("%02X"), (ULONG)PropVariant.caub.pElems[i] );
                if (i < (int)PropVariant.cal.cElems-1 && i % 4 == 3)
                {
                    wsprintf(szValue+lstrlen(szValue),TEXT(" "));
                }
            }
        }
        break;

    case VT_VECTOR|VT_I2:
        {
            wsprintf(szValue+lstrlen(szValue), TEXT("Length: [%d] "), PropVariant.cai.cElems );
            for (int i=0;i<(int)PropVariant.cai.cElems;i++)
            {
                if (lstrlen(szValue) >= MAX_DUMP_STRING)
                {
                    lstrcat( szValue, TEXT("...") );
                    break;
                }

                wsprintf(szValue+lstrlen(szValue),TEXT("%04X"),(ULONG)PropVariant.cai.pElems[i]);
                if (i < (int)PropVariant.cal.cElems-1)
                {
                    wsprintf(szValue+lstrlen(szValue),TEXT(" "));
                }
            }
        }
        break;

    case VT_VECTOR|VT_UI2:
        {
            wsprintf(szValue+lstrlen(szValue), TEXT("Length: [%d] "), PropVariant.caui.cElems );
            for (int i=0;i<(int)PropVariant.caui.cElems;i++)
            {
                if (lstrlen(szValue) >= MAX_DUMP_STRING)
                {
                    lstrcat( szValue, TEXT("...") );
                    break;
                }

                wsprintf(szValue+lstrlen(szValue),TEXT("%04X"),(ULONG)PropVariant.caui.pElems[i]);
                if (i < (int)PropVariant.cal.cElems-1)
                {
                    wsprintf(szValue+lstrlen(szValue),TEXT(" "));
                }
            }
        }
        break;

    case VT_VECTOR|VT_I4:
        {
            wsprintf(szValue+lstrlen(szValue), TEXT("Length: [%d] "), PropVariant.cal.cElems );
            for (int i=0;i<(int)PropVariant.cal.cElems;i++)
            {
                if (lstrlen(szValue) >= MAX_DUMP_STRING)
                {
                    lstrcat( szValue, TEXT("...") );
                    break;
                }

                wsprintf(szValue+lstrlen(szValue),TEXT("%08X"),(ULONG)PropVariant.cal.pElems[i]);
                if (i < (int)PropVariant.cal.cElems-1)
                {
                    wsprintf(szValue+lstrlen(szValue),TEXT(" "));
                }
            }
        }
        break;

    case VT_VECTOR|VT_UI4:
        {
            wsprintf(szValue+lstrlen(szValue), TEXT("Length: [%d] "), PropVariant.caul.cElems );
            for (int i=0;i<(int)PropVariant.caul.cElems;i++)
            {
                if (lstrlen(szValue) >= MAX_DUMP_STRING)
                {
                    lstrcat( szValue, TEXT("...") );
                    break;
                }

                wsprintf(szValue+lstrlen(szValue),TEXT("%08X"),(ULONG)PropVariant.caul.pElems[i]);
                if (i < (int)PropVariant.cal.cElems-1)
                {
                    wsprintf(szValue+lstrlen(szValue),TEXT(" "));
                }
            }
        }
        break;

    default:
        wsprintf(szValue,TEXT("Unknown Type %d (0x%08X)"),PropVariant.vt,PropVariant.vt);
    }

    return szValue;
}

CSimpleString CWiaDebugDump::GetPrintableValue( VARIANT &Variant )
{
    TCHAR szValue[1024] = TEXT("");
    switch (Variant.vt)
    {
    case VT_I1:
        wsprintf(szValue,TEXT("%d, (0x%08X)"),Variant.cVal,Variant.cVal);
        break;

    case VT_UI1:
        wsprintf(szValue,TEXT("%u, (0x%08X)"),Variant.bVal,Variant.bVal);
        break;

    case VT_I2:
        wsprintf(szValue,TEXT("%d, (0x%08X)"),Variant.iVal,Variant.iVal);
        break;

    case VT_UI2:
        wsprintf(szValue,TEXT("%u, (0x%08X)"),Variant.uiVal,Variant.uiVal);
        break;

    case VT_I4:
        wsprintf(szValue,TEXT("%ld, (0x%08X)"),Variant.lVal,Variant.lVal);
        break;

    case VT_UI4:
        wsprintf(szValue,TEXT("%lu, (0x%08X)"),Variant.ulVal,Variant.ulVal);
        break;

    case VT_BSTR:
        wsprintf(szValue,TEXT("%ws"),Variant.bstrVal);
        break;


    default:
        wsprintf(szValue,TEXT("Unknown Type %d (0x%08X)"),Variant.vt,Variant.vt);
    }

    return szValue;
}


CSimpleString CWiaDebugDump::GetPrintableName( const STATPROPSTG &StatPropStg )
{
    CSimpleString strResult;

    //
    // Get the name
    //
    strResult += TEXT("[");
    if (StatPropStg.lpwstrName)
    {
        strResult += CSimpleStringConvert::NaturalString(CSimpleStringWide(StatPropStg.lpwstrName));
    }
    else
    {
        strResult += TEXT("*No Property Name*");
    }

    //
    // Get the propid
    //
    strResult += CSimpleString().Format( TEXT("], propid: %d"), StatPropStg.propid );
    return strResult;
}

CSimpleString CWiaDebugDump::GetPrintableAccessFlags( ULONG nAccessFlags )
{
    CSimpleString strResult;
    static const struct
    {
        ULONG nFlag;
        LPCTSTR pszName;
    }
    s_Flags[] =
    {
        { WIA_PROP_READ, TEXT("WIA_PROP_READ") },
        { WIA_PROP_WRITE, TEXT("WIA_PROP_WRITE") },
        { WIA_PROP_SYNC_REQUIRED, TEXT("WIA_PROP_SYNC_REQUIRED") },
        { WIA_PROP_NONE, TEXT("WIA_PROP_NONE") },
        { WIA_PROP_RANGE, TEXT("WIA_PROP_RANGE") },
        { WIA_PROP_LIST, TEXT("WIA_PROP_LIST") },
        { WIA_PROP_FLAG, TEXT("WIA_PROP_FLAG") },
        { WIA_PROP_CACHEABLE, TEXT("WIA_PROP_CACHEABLE") }
    };
    for (int i=0;i<ARRAYSIZE(s_Flags);i++)
    {
        if (nAccessFlags & s_Flags[i].nFlag)
        {
            if (strResult.Length())
            {
                strResult += TEXT(" | ");
            }
            strResult += s_Flags[i].pszName;
        }
    }
    if (!strResult.Length())
    {
        strResult = TEXT("*none*");
    }
    return strResult;
}

CSimpleString CWiaDebugDump::GetPrintableLegalValues( ULONG nAccessFlags, const PROPVARIANT &PropVariantAttributes )
{
    CSimpleString strResult;
    if ((nAccessFlags & WIA_PROP_RANGE) && (PropVariantAttributes.vt & VT_VECTOR))
    {
        CSimpleString strMin, strMax, strStep;
        switch (PropVariantAttributes.vt & VT_TYPEMASK)
        {
        case VT_I1:
            strMin.Format(TEXT("%d"), PropVariantAttributes.cac.pElems[WIA_RANGE_MIN] );
            strMax.Format(TEXT("%d"), PropVariantAttributes.cac.pElems[WIA_RANGE_MAX] );
            strStep.Format(TEXT("%d"), PropVariantAttributes.cac.pElems[WIA_RANGE_STEP] );
            break;

        case VT_UI1:
            strMin.Format(TEXT("%u"), PropVariantAttributes.caub.pElems[WIA_RANGE_MIN] );
            strMax.Format(TEXT("%u"), PropVariantAttributes.caub.pElems[WIA_RANGE_MAX] );
            strStep.Format(TEXT("%u"), PropVariantAttributes.caub.pElems[WIA_RANGE_STEP] );
            break;

        case VT_I2:
            strMin.Format(TEXT("%d"), PropVariantAttributes.cai.pElems[WIA_RANGE_MIN] );
            strMax.Format(TEXT("%d"), PropVariantAttributes.cai.pElems[WIA_RANGE_MAX] );
            strStep.Format(TEXT("%d"), PropVariantAttributes.cai.pElems[WIA_RANGE_STEP] );
            break;

        case VT_UI2:
            strMin.Format(TEXT("%u"), PropVariantAttributes.caui.pElems[WIA_RANGE_MIN] );
            strMax.Format(TEXT("%u"), PropVariantAttributes.caui.pElems[WIA_RANGE_MAX] );
            strStep.Format(TEXT("%u"), PropVariantAttributes.caui.pElems[WIA_RANGE_STEP] );
            break;

        case VT_I4:
            strMin.Format(TEXT("%d"), PropVariantAttributes.cal.pElems[WIA_RANGE_MIN] );
            strMax.Format(TEXT("%d"), PropVariantAttributes.cal.pElems[WIA_RANGE_MAX] );
            strStep.Format(TEXT("%d"), PropVariantAttributes.cal.pElems[WIA_RANGE_STEP] );
            break;

        case VT_UI4:
            strMin.Format(TEXT("%u"), PropVariantAttributes.caul.pElems[WIA_RANGE_MIN] );
            strMax.Format(TEXT("%u"), PropVariantAttributes.caul.pElems[WIA_RANGE_MAX] );
            strStep.Format(TEXT("%u"), PropVariantAttributes.caul.pElems[WIA_RANGE_STEP] );
            break;

        case VT_I8:
            strMin.Format(TEXT("%d"), PropVariantAttributes.cah.pElems[WIA_RANGE_MIN].LowPart );
            strMax.Format(TEXT("%d"), PropVariantAttributes.cah.pElems[WIA_RANGE_MAX].LowPart );
            strStep.Format(TEXT("%d"), PropVariantAttributes.cah.pElems[WIA_RANGE_STEP].LowPart );
            break;

        case VT_UI8:
            strMin.Format(TEXT("%u"), PropVariantAttributes.cauh.pElems[WIA_RANGE_MIN].LowPart );
            strMax.Format(TEXT("%u"), PropVariantAttributes.cauh.pElems[WIA_RANGE_MAX].LowPart );
            strStep.Format(TEXT("%u"), PropVariantAttributes.cauh.pElems[WIA_RANGE_STEP].LowPart );
            break;
        }
        strResult.Format( TEXT("%s...%s, Step: %s"), strMin.String(), strMax.String(), strStep.String() );
    }
    else if (nAccessFlags & WIA_PROP_LIST && (PropVariantAttributes.vt & VT_VECTOR))
    {
        if (((PropVariantAttributes.vt & VT_TYPEMASK) == VT_I4) || ((PropVariantAttributes.vt & VT_TYPEMASK) == VT_UI4))
        {
            for (ULONG i=0;i<PropVariantAttributes.cal.cElems - WIA_LIST_VALUES;i++)
            {
                if (strResult.Length())
                {
                    strResult += TEXT(",");
                }
                if (strResult.Length() >= MAX_DUMP_STRING)
                {
                    strResult += TEXT("...");
                    break;
                }
                strResult += CSimpleString().Format( TEXT("%d"), PropVariantAttributes.cal.pElems[WIA_LIST_VALUES + i] );
            }
        }
        else if ((PropVariantAttributes.vt & VT_TYPEMASK) == VT_CLSID)
        {
            for (ULONG i=0;i<PropVariantAttributes.cauuid.cElems - WIA_LIST_VALUES;i++)
            {
                if (strResult.Length())
                {
                    strResult += TEXT(",");
                }
                if (strResult.Length() >= MAX_DUMP_STRING)
                {
                    strResult += TEXT("...");
                    break;
                }
                strResult += CSimpleString().Format( TEXT("%s"), GetStringFromGuid(PropVariantAttributes.cauuid.pElems[WIA_LIST_VALUES + i]).String() );
            }
        }
    }
    else if (nAccessFlags & WIA_PROP_FLAG)
    {
        strResult.Format( TEXT("0x%08X"), PropVariantAttributes.caul.pElems[WIA_FLAG_VALUES] );
    }
    return strResult;
}

CSimpleString CWiaDebugDump::GetWiaItemTypeFlags( IUnknown *pUnknown )
{
    CSimpleString strResult;
    if (pUnknown)
    {
        CComPtr<IWiaItem> pWiaItem;
        HRESULT hr = pUnknown->QueryInterface( IID_IWiaItem, (void**)&pWiaItem );
        if (SUCCEEDED(hr))
        {
            LONG nItemType = 0;
            hr = pWiaItem->GetItemType(&nItemType);
            if (SUCCEEDED(hr))
            {
                static const struct
                {
                    ULONG nFlag;
                    LPCTSTR pszName;
                }
                s_Flags[] =
                {
                    { WiaItemTypeFree, TEXT("WiaItemTypeFree") },
                    { WiaItemTypeImage, TEXT("WiaItemTypeImage") },
                    { WiaItemTypeFile, TEXT("WiaItemTypeFile") },
                    { WiaItemTypeFolder, TEXT("WiaItemTypeFolder") },
                    { WiaItemTypeRoot, TEXT("WiaItemTypeRoot") },
                    { WiaItemTypeAnalyze, TEXT("WiaItemTypeAnalyze") },
                    { WiaItemTypeAudio, TEXT("WiaItemTypeAudio") },
                    { WiaItemTypeDevice, TEXT("WiaItemTypeDevice") },
                    { WiaItemTypeDeleted, TEXT("WiaItemTypeDeleted") },
                    { WiaItemTypeDisconnected, TEXT("WiaItemTypeDisconnected") },
                    { WiaItemTypeHPanorama, TEXT("WiaItemTypeHPanorama") },
                    { WiaItemTypeVPanorama, TEXT("WiaItemTypeVPanorama") },
                    { WiaItemTypeBurst, TEXT("WiaItemTypeBurst") },
                    { WiaItemTypeStorage, TEXT("WiaItemTypeStorage") },
                    { WiaItemTypeTransfer, TEXT("WiaItemTypeTransfer") },
                    { WiaItemTypeGenerated, TEXT("WiaItemTypeGenerated") },
                    { WiaItemTypeHasAttachments, TEXT("WiaItemTypeHasAttachments") },
                    { WiaItemTypeVideo, TEXT("WiaItemTypeVideo") }
                };
                for (int i=0;i<ARRAYSIZE(s_Flags);i++)
                {
                    if (nItemType & s_Flags[i].nFlag)
                    {
                        if (strResult.Length())
                        {
                            strResult += TEXT(" | ");
                        }
                        strResult += s_Flags[i].pszName;
                    }
                }
            }
        }
    }
    return strResult;
}

CSimpleString CWiaDebugDump::GetStringFromGuid( const GUID &guid )
{
    static HINSTANCE s_WiaDebugInstance = NULL;
    static GetStringFromGuidProc s_pfnGetStringFromGuid = NULL;

    if (!s_pfnGetStringFromGuid)
    {
        if (!s_WiaDebugInstance)
        {
            s_WiaDebugInstance = LoadLibrary(TEXT("wiadebug.dll"));
        }

        if (s_WiaDebugInstance)
        {
            s_pfnGetStringFromGuid = reinterpret_cast<GetStringFromGuidProc>(GetProcAddress( s_WiaDebugInstance, GET_STRING_FROM_GUID_NAME ));
        }
    }

    if (s_pfnGetStringFromGuid)
    {
        TCHAR szString[MAX_PATH];
        s_pfnGetStringFromGuid( &guid, szString, ARRAYSIZE(szString) );
        return szString;
    }
    else
    {
        CSimpleString strResult;

        LPOLESTR pszGuid = NULL;
        HRESULT hr = StringFromCLSID( guid, &pszGuid );
        if (SUCCEEDED(hr) && pszGuid)
        {
            strResult = CSimpleStringConvert::NaturalString(CSimpleStringWide(pszGuid));
            CoTaskMemFree(pszGuid);
        }
        return strResult;
    }
}

void CWiaDebugDump::DumpWiaPropertyStorage( IUnknown *pUnknown )
{
    if (OK())
    {
        //
        // Make sure we have a non-NULL interface pointer
        //
        if (pUnknown)
        {
            //
            // Get the proper interface
            //
            CComPtr<IWiaPropertyStorage> pWiaPropertyStorage;
            HRESULT hr = pUnknown->QueryInterface( IID_IWiaPropertyStorage, (void**)&pWiaPropertyStorage );
            if (SUCCEEDED(hr))
            {
                //
                // Get information about this property storage
                //
                CComPtr<IEnumSTATPROPSTG> pEnumStatPropStorage;
                hr = pWiaPropertyStorage->Enum(&pEnumStatPropStorage);
                if (SUCCEEDED(hr))
                {
                    //
                    // Enumerate the properties
                    //
                    STATPROPSTG StatPropStg = {0};
                    while ((hr = pEnumStatPropStorage->Next(1,&StatPropStg,NULL)) == S_OK)
                    {
                        //
                        // Prepare the propspec
                        //
                        PROPSPEC PropSpec = {0};
                        PropSpec.ulKind = PRSPEC_PROPID;
                        PropSpec.propid = StatPropStg.propid;

                        //
                        // Prepare the propvariant
                        //
                        PROPVARIANT PropVariant = {0};

                        //
                        // Get the property
                        //
                        hr = pWiaPropertyStorage->ReadMultiple( 1, &PropSpec, &PropVariant );
                        if (SUCCEEDED(hr))
                        {
                            //
                            // Get the property attributes
                            //
                            ULONG nAccessFlags = 0;
                            PROPVARIANT PropVariantAttributes = {0};
                            hr = pWiaPropertyStorage->GetPropertyAttributes( 1, &PropSpec, &nAccessFlags, &PropVariantAttributes );
                            if (SUCCEEDED(hr))
                            {
                                //
                                // Print out the properties
                                //
                                CSimpleString strName = GetPrintableName( StatPropStg );
                                Print( CSimpleString().Format(TEXT("  %s"), strName.String() ));

                                CSimpleString strType = GetPropVariantTypeString( PropVariant.vt );
                                Print( CSimpleString().Format(TEXT("    Type:   %s"), strType.String()) );

                                CSimpleString strAccess = GetPrintableAccessFlags( nAccessFlags );
                                Print( CSimpleString().Format(TEXT("    Access: %s"), strAccess.String()) );

                                CSimpleString strValue = GetPrintableValue( PropVariant );
                                Print( CSimpleString().Format(TEXT("    Curr:   %s"), strValue.String()) );

                                CSimpleString strLegalValues = GetPrintableLegalValues( nAccessFlags, PropVariantAttributes );
                                if (strLegalValues.Length())
                                {
                                    Print( CSimpleString().Format(TEXT("    Legal:  %s"), strLegalValues.String()) );
                                }

                                //
                                // Free the attributes
                                //
                                PropVariantClear(&PropVariantAttributes);
                            }

                            //
                            // Free the property
                            //
                            PropVariantClear(&PropVariant);
                        }


                        //
                        // Clean up the STATPROPSTG
                        //
                        if (StatPropStg.lpwstrName)
                        {
                            CoTaskMemFree(StatPropStg.lpwstrName);
                        }
                        ZeroMemory(&StatPropStg,sizeof(StatPropStg));
                    }
                }
            }
        }
    }
}

void CWiaDebugDump::Print( LPCTSTR pszString )
{
    WIA_TRACE((TEXT("%s"), pszString ));
}

void CWiaDebugDump::PrintAndDestroyWiaDevCap( WIA_DEV_CAP &WiaDevCap, LPCTSTR pszType )
{
    if (OK())
    {
        Print( CSimpleString().Format(TEXT("  %s: %s"), pszType, GetStringFromGuid( WiaDevCap.guid ).String()));
        Print( CSimpleString().Format(TEXT("    Flags: %08X"), WiaDevCap.ulFlags) );
        if (WiaDevCap.bstrName)
        {
            Print( CSimpleString().Format(TEXT("    Name: %ws"), WiaDevCap.bstrName) );
            SysFreeString(WiaDevCap.bstrName);
            WiaDevCap.bstrName = NULL;
        }
        if (WiaDevCap.bstrDescription)
        {
            Print( CSimpleString().Format(TEXT("    Description: %ws"), WiaDevCap.bstrDescription) );
            SysFreeString(WiaDevCap.bstrDescription);
            WiaDevCap.bstrDescription = NULL;
        }
        if (WiaDevCap.bstrIcon)
        {
            Print( CSimpleString().Format(TEXT("    Icon: %ws"), WiaDevCap.bstrIcon));
            SysFreeString(WiaDevCap.bstrIcon);
            WiaDevCap.bstrIcon = NULL;
        }
        if (WiaDevCap.bstrCommandline)
        {
            Print( CSimpleString().Format(TEXT("    bstrCommandline: %ws"), WiaDevCap.bstrCommandline));
            SysFreeString(WiaDevCap.bstrCommandline);
            WiaDevCap.bstrCommandline = NULL;
        }
    }
}

void CWiaDebugDump::DumpCaps( IUnknown *pUnknown )
{
    if (pUnknown)
    {
        //
        // Get the item
        //
        CComPtr<IWiaItem> pWiaItem;
        HRESULT hr = pUnknown->QueryInterface( IID_IWiaItem, (void**)&pWiaItem );
        if (SUCCEEDED(hr))
        {
            //
            // Get the format enumerator
            //
            CComPtr<IEnumWIA_DEV_CAPS> pEnumWIA_DEV_CAPS;
            hr = pWiaItem->EnumDeviceCapabilities(WIA_DEVICE_COMMANDS,&pEnumWIA_DEV_CAPS);
            if (SUCCEEDED(hr))
            {
                //
                // Start at the beginning
                //
                hr = pEnumWIA_DEV_CAPS->Reset();
                while (hr == S_OK)
                {
                    //
                    // Get the next item
                    //
                    WIA_DEV_CAP WiaDevCap = {0};
                    hr = pEnumWIA_DEV_CAPS->Next(1, &WiaDevCap, NULL);
                    if (hr == S_OK)
                    {
                        PrintAndDestroyWiaDevCap( WiaDevCap, TEXT("Capability") );
                    }
                }
            }
        }
    }
}

void CWiaDebugDump::DumpEvents( IUnknown *pUnknown )
{
    if (pUnknown)
    {
        //
        // Get the item
        //
        CComPtr<IWiaItem> pWiaItem;
        HRESULT hr = pUnknown->QueryInterface( IID_IWiaItem, (void**)&pWiaItem );
        if (SUCCEEDED(hr))
        {
            //
            // Get the format enumerator
            //
            CComPtr<IEnumWIA_DEV_CAPS> pEnumWIA_DEV_CAPS;
            hr = pWiaItem->EnumDeviceCapabilities(WIA_DEVICE_EVENTS,&pEnumWIA_DEV_CAPS);
            if (SUCCEEDED(hr))
            {
                //
                // Start at the beginning
                //
                hr = pEnumWIA_DEV_CAPS->Reset();
                while (hr == S_OK)
                {
                    //
                    // Get the next item
                    //
                    WIA_DEV_CAP WiaDevCap = {0};
                    hr = pEnumWIA_DEV_CAPS->Next(1, &WiaDevCap, NULL);
                    if (hr == S_OK)
                    {
                        PrintAndDestroyWiaDevCap( WiaDevCap, TEXT("Event") );
                    }
                }
            }
        }
    }
}

void CWiaDebugDump::DumpFormatInfo( IUnknown *pUnknown )
{
    if (OK())
    {
        if (pUnknown)
        {
            //
            // Get the data transfer interface
            //
            CComPtr<IWiaDataTransfer> pWiaDataTransfer;
            HRESULT hr = pUnknown->QueryInterface( IID_IWiaDataTransfer, (void**)&pWiaDataTransfer );
            if (SUCCEEDED(hr))
            {
                //
                // Get the format enumerator
                //
                CComPtr<IEnumWIA_FORMAT_INFO> pEnumWIA_FORMAT_INFO;
                hr = pWiaDataTransfer->idtEnumWIA_FORMAT_INFO(&pEnumWIA_FORMAT_INFO);
                if (SUCCEEDED(hr))
                {
                    //
                    // Start at the beginning
                    //
                    hr = pEnumWIA_FORMAT_INFO->Reset();
                    while (hr == S_OK)
                    {
                        //
                        // Get the next item
                        //
                        WIA_FORMAT_INFO WiaFormatInfo = {0};
                        hr = pEnumWIA_FORMAT_INFO->Next(1, &WiaFormatInfo, NULL);
                        if (hr == S_OK)
                        {
                            Print(CSimpleString().Format( TEXT("  Supported format: %s, TYMED: %s"), GetStringFromGuid( WiaFormatInfo.guidFormatID ).String(), GetTymedString( WiaFormatInfo.lTymed ).String() ));
                        }
                    }

                }
            }
        }
    }
}

void CWiaDebugDump::DumpWiaItem( IUnknown *pUnknown )
{
    if (OK() && pUnknown)
    {
        CSimpleStringWide strFullItemName;
        PropStorageHelpers::GetProperty( pUnknown, WIA_IPA_FULL_ITEM_NAME, strFullItemName );
        Print( CSimpleString().Format( TEXT("[Dumping %ws]"), strFullItemName.String() ) );
        CSimpleString strItemType = GetWiaItemTypeFlags( pUnknown );
        Print( CSimpleString().Format(TEXT("  Item Type: %s"), strItemType.String()) );
        DumpFormatInfo( pUnknown );
        DumpCaps( pUnknown );
        DumpEvents( pUnknown );
        DumpWiaPropertyStorage( pUnknown );
        Print( TEXT("") );
    }
}

void CWiaDebugDump::DumpRecursive( IUnknown *pUnknown )
{
    if (OK() && pUnknown)
    {
        //
        // Get an item pointer
        //
        CComPtr<IWiaItem> pWiaItem;
        HRESULT hr = pUnknown->QueryInterface( IID_IWiaItem, (void**)&pWiaItem );
        if (SUCCEEDED(hr))
        {
            //
            // Dump this one
            //
            DumpWiaItem(pWiaItem);

            //
            // Recurse into this item's children
            //
            CComPtr <IEnumWiaItem> pEnumChildItem;
            hr = pWiaItem->EnumChildItems(&pEnumChildItem);
            if (SUCCEEDED(hr))
            {
                //
                // Start at the beginning
                //
                hr = pEnumChildItem->Reset();
                while (hr == S_OK)
                {
                    //
                    // Get the next item
                    //
                    CComPtr<IWiaItem> pChildItem;
                    hr = pEnumChildItem->Next(1, &pChildItem, NULL);
                    if (hr == S_OK)
                    {
                        DumpRecursive( pChildItem );
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\dumpprop.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       DUMPPROP.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        9/25/2000
 *
 *  DESCRIPTION: Display the properties associated with a IWiaItem, either to the
 *               debugger, or to a log file.
 *
 *******************************************************************************/
#ifndef __DUMPPROP_H_INCLUDED
#define __DUMPPROP_H_INCLUDED

#include <simstr.h>
#include <wia.h>
#include <wiadebug.h>

class CWiaDebugDump
{
private:
    //
    // No implementation
    //
    CWiaDebugDump( const CWiaDebugDump & );
    CWiaDebugDump &operator=( const CWiaDebugDump & );

public:
    //
    // Static helper functions
    //
    static CSimpleString GetPropVariantTypeString( VARTYPE vt );
    static CSimpleString GetPrintableValue( PROPVARIANT &PropVariant );
    static CSimpleString GetPrintableValue( VARIANT &Variant );
    static CSimpleString GetPrintableName( const STATPROPSTG &StatPropStg );
    static CSimpleString GetPrintableAccessFlags( ULONG nAccessFlags );
    static CSimpleString GetPrintableLegalValues( ULONG nAccessFlags, const PROPVARIANT &PropVariantAttributes );
    static CSimpleString GetWiaItemTypeFlags( IUnknown *pUnknown );
    static CSimpleString GetStringFromGuid( const GUID &guid );
    static CSimpleString GetTymedString( LONG tymed );
    virtual void Print( LPCTSTR pszString );

protected:
    void PrintAndDestroyWiaDevCap( WIA_DEV_CAP &WiaDevCap, LPCTSTR pszType );

public:
    //
    // Constructor and destructor
    //
    CWiaDebugDump(void);
    virtual ~CWiaDebugDump(void);

    //
    // Helpers
    //
    void DumpFormatInfo( IUnknown *pUnknown );
    void DumpCaps( IUnknown *pUnknown );
    void DumpEvents( IUnknown *pUnknown );

    virtual bool OK(void) { return true; }

    //
    // These are the most generally useful functions
    //
    void DumpWiaPropertyStorage( IUnknown *pUnknown );
    void DumpWiaItem( IUnknown *pUnknown );
    void DumpRecursive( IUnknown *pUnknown );
};

class CWiaDebugDumpToFile : public CWiaDebugDump
{
private:
    HANDLE m_hFile;

private:
    CWiaDebugDumpToFile(void);
    CWiaDebugDumpToFile( const CWiaDebugDumpToFile & );
    CWiaDebugDumpToFile &operator=( const CWiaDebugDumpToFile & );

public:
    //
    // Constructor and destructor
    //
    CWiaDebugDumpToFile( LPCTSTR pszFilename, bool bOverwrite );
    virtual ~CWiaDebugDumpToFile(void);

    virtual bool OK(void) { return (m_hFile != INVALID_HANDLE_VALUE); }
    virtual void Print( LPCTSTR pszString );
};

class CWiaDebugDumpToFileHandle : public CWiaDebugDump
{
private:
    HANDLE m_hFile;

private:
    CWiaDebugDumpToFileHandle(void);
    CWiaDebugDumpToFileHandle( const CWiaDebugDumpToFileHandle & );
    CWiaDebugDumpToFileHandle &operator=( const CWiaDebugDumpToFileHandle & );

public:
    //
    // Constructor and destructor
    //
    CWiaDebugDumpToFileHandle( HANDLE hFile );
    virtual ~CWiaDebugDumpToFileHandle(void);

    virtual bool OK(void) { return (m_hFile != INVALID_HANDLE_VALUE); }
    virtual void Print( LPCTSTR pszString );
};

//
// This small helper function checks a registry entry, and saves the item or tree to the log file stored in that entry.  If
// one is not stored in that registry entry, nothing will be saved
//
inline void SaveItemTreeLog( HKEY hKey, LPCTSTR pszRegKey, LPCTSTR pszRegValue, bool bOverwrite, IWiaItem *pWiaItem, bool bRecurse )
{
    CSimpleString strFilename = CSimpleReg(hKey,pszRegKey,false,KEY_READ).Query(pszRegValue,TEXT(""));
    if (strFilename.Length())
    {
        if (bRecurse)
        {
            CWiaDebugDumpToFile(strFilename,bOverwrite).DumpRecursive(pWiaItem);
        }
        else
        {
            CWiaDebugDumpToFile(strFilename,bOverwrite).DumpWiaItem(pWiaItem);
        }
    }
}


//
// Debug-only macros
//
#if defined(DBG) || defined(DEBUG) || defined(_DEBUG)

//
// Save the whole tree to a log file, from this item down
//
#define WIA_SAVEITEMTREELOG(hKey,pszRegKey,pszRegValue,bOverwrite,pWiaItem) SaveItemTreeLog( hKey, pszRegKey, pszRegValue, bOverwrite, pWiaItem, true )

//
// Save this item to a log file
//
#define WIA_SAVEITEMLOG(hKey,pszRegKey,pszRegValue,bOverwrite,pWiaItem)     SaveItemTreeLog( hKey, pszRegKey, pszRegValue, bOverwrite, pWiaItem, false )

//
// Print this item in the debugger
//
#define WIA_DUMPWIAITEM(pWiaItem)                                           CWiaDebugDump().DumpWiaItem(pWiaItem);

#else

#define WIA_SAVEITEMTREELOG(hKey,pszRegKey,pszRegValue,bOverwrite,pWiaItem)
#define WIA_SAVEITEMLOG(hKey,pszRegKey,pszRegValue,bOverwrite,pWiaItem)
#define WIA_DUMPWIAITEM(pWiaItem)

#endif


#endif // __DUMPPROP_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\gwiaevnt.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       GWIAEVNT.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        12/29/1999
 *
 *  DESCRIPTION: Generic reusable WIA event handler that posts the specified
 *  message to the specified window.
 *
 *  The message will be sent with the following arguments:
 *
 *
 *  WPARAM = NULL
 *  LPARAM = CGenericWiaEventHandler::CEventMessage *pEventMessage
 *
 *  pEventMessage MUST be freed in the message handler using delete
 *
 *  pEventMessage is allocated using an overloaded new operator, to ensure that
 *  the same allocator and de-allocator are used.
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "gwiaevnt.h"

CGenericWiaEventHandler::CGenericWiaEventHandler(void)
  : m_hWnd(NULL),
    m_nWiaEventMessage(0),
    m_cRef(0)
{
}

STDMETHODIMP CGenericWiaEventHandler::Initialize( HWND hWnd, UINT nWiaEventMessage )
{
    m_hWnd = hWnd;
    m_nWiaEventMessage = nWiaEventMessage;
    return S_OK;
}

STDMETHODIMP CGenericWiaEventHandler::QueryInterface( REFIID riid, LPVOID *ppvObject )
{
    WIA_PUSHFUNCTION(TEXT("CWiaDefaultUI::QueryInterface"));
    if (IsEqualIID( riid, IID_IUnknown ))
    {
        *ppvObject = static_cast<IWiaEventCallback*>(this);
    }
    else if (IsEqualIID( riid, IID_IWiaEventCallback ))
    {
        *ppvObject = static_cast<IWiaEventCallback*>(this);
    }
    else
    {
        *ppvObject = NULL;
        return(E_NOINTERFACE);
    }
    reinterpret_cast<IUnknown*>(*ppvObject)->AddRef();
    return(S_OK);
}


STDMETHODIMP_(ULONG) CGenericWiaEventHandler::AddRef(void)
{
    DllAddRef();
    return(InterlockedIncrement(&m_cRef));
}

STDMETHODIMP_(ULONG) CGenericWiaEventHandler::Release(void)
{
    DllRelease();
    LONG nRefCount = InterlockedDecrement(&m_cRef);
    if (!nRefCount)
    {
        delete this;
    }
    return(nRefCount);
}

STDMETHODIMP CGenericWiaEventHandler::ImageEventCallback( const GUID *pEventGUID, BSTR bstrEventDescription, BSTR bstrDeviceID, BSTR bstrDeviceDescription, DWORD dwDeviceType, BSTR bstrFullItemName, ULONG *pulEventType, ULONG ulReserved )
{
    WIA_PUSHFUNCTION(TEXT("CGenericWiaEventHandler::ImageEventCallback"));

    //
    // Make sure (as best we can) that everything is OK before we allocate any memory
    //
    if (m_hWnd && m_nWiaEventMessage && IsWindow(m_hWnd))
    {
        //
        // Allocate the new message
        //
        CEventMessage *pEventMessage = new CEventMessage( *pEventGUID, bstrEventDescription, bstrDeviceID, bstrDeviceDescription, dwDeviceType, bstrFullItemName );
        if (pEventMessage)
        {
            //
            // Send the message to the notify window
            //
            LRESULT lRes = SendMessage( m_hWnd, m_nWiaEventMessage, NULL, reinterpret_cast<LPARAM>(pEventMessage) );

            //
            // If the callee didn't handle the message, delete it
            //
            if (HANDLED_EVENT_MESSAGE != lRes)
            {
                delete pEventMessage;
            }
        }
    }
    return S_OK;
}

HRESULT CGenericWiaEventHandler::RegisterForWiaEvent( LPCWSTR pwszDeviceId, const GUID &guidEvent, IUnknown **ppUnknown, HWND hWnd, UINT nMsg )
{
    WIA_PUSHFUNCTION(TEXT("CGenericWiaEventHandler::RegisterForWiaEvent"));

    //
    // Create the device manager
    //
    CComPtr<IWiaDevMgr> pWiaDevMgr;
    HRESULT hr = CoCreateInstance( CLSID_WiaDevMgr, NULL, CLSCTX_LOCAL_SERVER, IID_IWiaDevMgr, (void**)&pWiaDevMgr );
    if (SUCCEEDED(hr) && pWiaDevMgr)
    {
        //
        // Create our event handler
        //
        CGenericWiaEventHandler *pEventHandler = new CGenericWiaEventHandler();
        if (pEventHandler)
        {
            //
            // Initialize it with the window handle and message we will be sending
            //
            hr = pEventHandler->Initialize( hWnd, nMsg );
            if (SUCCEEDED(hr))
            {
                //
                // Get the callback interface pointer
                //
                CComPtr<IWiaEventCallback> pWiaEventCallback;
                hr = pEventHandler->QueryInterface( IID_IWiaEventCallback, (void**)&pWiaEventCallback );
                if (SUCCEEDED(hr) && pWiaEventCallback)
                {
                    //
                    // Register for the event
                    //
                    hr = pWiaDevMgr->RegisterEventCallbackInterface( 0, pwszDeviceId ? CSimpleBStr(pwszDeviceId).BString() : NULL, &guidEvent, pWiaEventCallback, ppUnknown );
                    if (!SUCCEEDED(hr))
                    {
                        WIA_PRINTHRESULT((hr,TEXT("pWiaDevMgr->RegisterEventCallbackInterface failed")));
                    }
                }
                else
                {
                    WIA_PRINTHRESULT((hr,TEXT("pEventHandler->QueryInterface( IID_IWiaEventCallback, ... ) failed")));
                }
            }
            else
            {
                WIA_PRINTHRESULT((hr,TEXT("pEventHandler->Initialize failed")));
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
            WIA_PRINTHRESULT((hr,TEXT("Unable to allocate pEventHandler")));
        }
    }
    else
    {
        WIA_PRINTHRESULT((hr,TEXT("CoCreateInstance of dev mgr failed")));
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\isuppfmt.h ===
#ifndef __ISUPPFMT_H_INCLUDED
#define __ISUPPFMT_H_INCLUDED

#include <windows.h>
#include <objbase.h>
#include <wia.h>

#undef  INTERFACE
#define INTERFACE IWiaSupportedFormats
DECLARE_INTERFACE_(IWiaSupportedFormats, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IWiaSupportedFormats methods ***
    STDMETHOD(Initialize)( THIS_
                    IWiaItem *pWiaItem,
                    LONG nMediaType
                    ) PURE;
    STDMETHOD(GetFormatCount)( THIS_
                    OUT LONG    *pnCount
                    ) PURE;
    STDMETHOD(GetFormatType)( THIS_
                    IN  LONG       nFormat,
                    OUT GUID *pcfClipFormat
                    ) PURE;
    STDMETHOD(GetFormatExtension)( THIS_
                    IN  LONG    nFormat,
                    OUT LPWSTR  pszExtension,
                    IN  int     nMaxLen
                    ) PURE;
    STDMETHOD(GetFormatDescription)( THIS_
                    IN  LONG   nFormat,
                    OUT LPWSTR pszDescription,
                    IN  int    nMaxLen
                    ) PURE;
    STDMETHOD(GetDefaultClipboardFileFormat)( THIS_
                    OUT GUID   *pcfFormat
                    ) PURE;
    STDMETHOD(GetDefaultClipboardFileFormatIndex)( THIS_
                    OUT LONG    *pnFormat
                    ) PURE;
    STDMETHOD(GetClipboardFileExtension)( THIS_
                    IN  GUID cfFormat,
                    OUT LPWSTR pszExt,
                    IN  DWORD nMaxLen
                    ) PURE;
    STDMETHOD(ChangeClipboardFileExtension)( THIS_
                    IN GUID cfFormat,         // IN.       File type
                    IN OUT LPWSTR pszFilename,          // IN, OUT.  Filename, with or without extension.  It will be corrected to have the proper extension
                    IN DWORD nMaxLen                // IN.       Maximum buffer length
                    ) PURE;
    STDMETHOD(ConstructFileOpenDialogStyleString)( THIS_
                    OUT BSTR   *pbstrString
                    ) PURE;

};

// {57F5D4A3-41D8-4BD3-9452-6E3026E63D1E}
DEFINE_GUID(IID_IWiaSupportedFormats, 0x57F5D4A3, 0x41D8, 0x4BD3, 0x94, 0x52, 0x6E, 0x30, 0x26, 0xE6, 0x3D, 0x1E);

#endif //__ISUPPFMT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\gwiaevnt.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       GWIAEVNT.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        12/29/1999
 *
 *  DESCRIPTION: Generic reusable WIA event handler that posts the specified
 *  message to the specified window.
 *
 *  The message will be sent with the following arguments:
 *
 *
 *  WPARAM = NULL
 *  LPARAM = CGenericWiaEventHandler::CEventMessage *pEventMessage
 *
 *  pEventMessage MUST be freed in the message handler using delete
 *
 *  pEventMessage is allocated using an overloaded new operator, to ensure that
 *  the same allocator and de-allocator are used.
 *
 *******************************************************************************/
#ifndef __GWIAEVNT_H_INCLUDED
#define __GWIAEVNT_H_INCLUDED

#include <windows.h>
#include "wia.h"
#include "simstr.h"
#include "wiadebug.h"
#include "modlock.h"

//
// If the callee doesn't return this value, we delete the message data ourselves.
//
#define HANDLED_EVENT_MESSAGE 1002

class CGenericWiaEventHandler : public IWiaEventCallback
{
public:

    class CEventMessage
    {
    private:
        GUID              m_guidEventId;
        CSimpleStringWide m_wstrEventDescription;
        CSimpleStringWide m_wstrDeviceId;
        CSimpleStringWide m_wstrDeviceDescription;
        DWORD             m_dwDeviceType;
        CSimpleStringWide m_wstrFullItemName;

    private:
        // No implementation
        CEventMessage(void);
        CEventMessage( const CEventMessage & );
        CEventMessage &operator=( const CEventMessage & );

    public:
        CEventMessage( const GUID &guidEventId, LPCWSTR pwszEventDescription, LPCWSTR pwszDeviceId, LPCWSTR pwszDeviceDescription, DWORD dwDeviceType, LPCWSTR pwszFullItemName )
          : m_guidEventId(guidEventId),
            m_wstrEventDescription(pwszEventDescription),
            m_wstrDeviceId(pwszDeviceId),
            m_wstrDeviceDescription(pwszDeviceDescription),
            m_dwDeviceType(dwDeviceType),
            m_wstrFullItemName(pwszFullItemName)
        {
        }
        GUID EventId(void) const
        {
            return m_guidEventId;
        }
        CSimpleStringWide EventDescription(void) const
        {
            return m_wstrEventDescription;
        }
        CSimpleStringWide DeviceId(void) const
        {
            return m_wstrDeviceId;
        }
        CSimpleStringWide DeviceDescription(void) const
        {
            return m_wstrDeviceDescription;
        }
        DWORD DeviceType(void) const
        {
            return m_dwDeviceType;
        }
        CSimpleStringWide FullItemName(void) const
        {
            return m_wstrFullItemName;
        }
        void *operator new( size_t nSize )
        {
            if (nSize)
            {
                return reinterpret_cast<void*>(LocalAlloc(LPTR,nSize));
            }
            return NULL;
        }
        void operator delete( void *pVoid )
        {
            if (pVoid)
            {
                LocalFree( pVoid );
            }
        }
    };

private:
   HWND m_hWnd;
   UINT m_nWiaEventMessage;
   LONG m_cRef;

public:
    CGenericWiaEventHandler(void);
    ~CGenericWiaEventHandler(void) {}

    STDMETHODIMP Initialize( HWND hWnd, UINT nWiaEventMessage );

    // IUnknown
    STDMETHODIMP QueryInterface( REFIID riid, LPVOID *ppvObject );
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //IWiaEventCallback
    STDMETHODIMP ImageEventCallback( const GUID *pEventGUID, BSTR bstrEventDescription, BSTR bstrDeviceID, BSTR bstrDeviceDescription, DWORD dwDeviceType, BSTR bstrFullItemName, ULONG *pulEventType, ULONG ulReserved );

public:
    static HRESULT RegisterForWiaEvent( LPCWSTR pwszDeviceId, const GUID &guidEvent, IUnknown **ppUnknown, HWND hWnd, UINT nMsg );
};

#endif //__GWIAEVNT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\gdbgdata.cpp ===
#include "precomp.h"
#pragma hdrstop
#include "wiadebug.h"

CSystemGlobalData *CGlobalDebugState::Lock(void)
{
    CSystemGlobalData *pSystemGlobalData = NULL;
    if (IsValid())
    {
        DWORD dwWait = WaitForSingleObject(m_hSystemDataMutex,10000);
        if (WAIT_OBJECT_0 == dwWait)
        {
            pSystemGlobalData = m_pSystemGlobalData;
        }
    }
    return pSystemGlobalData;
}

void CGlobalDebugState::Release(void)
{
    ReleaseMutex(m_hSystemDataMutex);
}

CGlobalDebugState::CGlobalDebugState(void)
  : m_hSystemDataMutex(NULL),
    m_hMemoryMappedFile(NULL),
    m_pSystemGlobalData(NULL)
{
    //
    // Create the mutex that protects the system global data
    //
    m_hSystemDataMutex = CreateMutex( NULL, FALSE, WIADEBUG_MEMORYMAPPED_MUTEXNAME );
    if (m_hSystemDataMutex)
    {
        //
        // Grab the mutex that protects the system global data
        //
        DWORD dwWait = WaitForSingleObject( m_hSystemDataMutex, 10000 );
        if (WAIT_OBJECT_0 == dwWait)
        {
            //
            // First try to open the memory mapped file.
            //
            m_hMemoryMappedFile = OpenFileMapping( FILE_MAP_WRITE, FALSE, WIADEBUG_MEMORYMAPPED_FILENAME );
            if (m_hMemoryMappedFile)
            {
                m_pSystemGlobalData = reinterpret_cast<CSystemGlobalData*>(MapViewOfFile( m_hMemoryMappedFile, FILE_MAP_ALL_ACCESS, 0, 0, 0 ));
            }
            else
            {
                //
                // We need to create this file mapping with access to everyone.
                // Since it is debug-only code, this doesn't represent a security risk.
                //
                SECURITY_INFORMATION SecurityInformation = DACL_SECURITY_INFORMATION;
                SECURITY_DESCRIPTOR  SecurityDescriptor = {0};
                SECURITY_ATTRIBUTES  SecurityAttributes = {0};

                SecurityAttributes.nLength = sizeof(SecurityAttributes);
                SecurityAttributes.lpSecurityDescriptor = &SecurityDescriptor;
                SecurityAttributes.bInheritHandle = FALSE;

                //
                // Give access to everybody
                //
                InitializeSecurityDescriptor(&SecurityDescriptor, SECURITY_DESCRIPTOR_REVISION);
                SetSecurityDescriptorDacl(&SecurityDescriptor, TRUE, (PACL)NULL, FALSE);

                //
                // Create the memory mapped file
                //
                m_hMemoryMappedFile = CreateFileMapping( INVALID_HANDLE_VALUE, &SecurityAttributes, PAGE_READWRITE, 0, sizeof(CSystemGlobalData), WIADEBUG_MEMORYMAPPED_FILENAME );
                if (m_hMemoryMappedFile)
                {
                    m_pSystemGlobalData = reinterpret_cast<CSystemGlobalData*>(MapViewOfFile( m_hMemoryMappedFile, FILE_MAP_ALL_ACCESS, 0, 0, 0 ));
                    if (m_pSystemGlobalData)
                    {
                        //
                        // Start off with everything zeroed out.
                        //
                        ZeroMemory( m_pSystemGlobalData, sizeof( CSystemGlobalData ) );

                        //
                        // Get the initial global debug settings from the registry
                        //
                        m_pSystemGlobalData->nAllowDebugMessages = CSimpleReg( HKEY_CLASSES_ROOT, DEBUG_REGISTRY_PATH, false, KEY_READ ).Query( DEBUG_REGISTRY_ENABLE_DBG, 0 );

                        //
                        // No window is registered initially
                        //
                        m_pSystemGlobalData->hwndDebug = NULL;

                        //
                        // Initialize color table data
                        //
                        static const COLORREF crColors[NUMBER_OF_DEBUG_COLORS] =
                        {
                            RGB(0x00,0x00,0x00),
                            RGB(0x00,0x00,0x7F),
                            RGB(0x00,0x7F,0x00),
                            RGB(0x00,0x7F,0x7F),
                            RGB(0x7F,0x00,0x00),
                            RGB(0x7F,0x00,0x7F),
                            RGB(0x7F,0x00,0x7F),
                            RGB(0x7F,0x7F,0x7F)
                        };
                        for (int i=0;i<NUMBER_OF_DEBUG_COLORS;i++)
                        {
                            m_pSystemGlobalData->crDebugColors[i] = crColors[i];
                        }
                        m_pSystemGlobalData->nCurrentColor = 0;
                    }
                }
            }
            ReleaseMutex(m_hSystemDataMutex);
        }
    }

    //
    // If everything didn't work out, destroy the object completely
    //
    if (!IsValid())
    {
        Destroy();
    }
}

void CGlobalDebugState::Destroy(void)
{
    if (m_pSystemGlobalData)
    {
        UnmapViewOfFile(m_pSystemGlobalData);
        m_pSystemGlobalData = NULL;
    }
    if (m_hMemoryMappedFile)
    {
        CloseHandle(m_hMemoryMappedFile);
        m_hMemoryMappedFile = NULL;
    }
    if (m_hSystemDataMutex)
    {
        CloseHandle(m_hSystemDataMutex);
        m_hSystemDataMutex = NULL;
    }
}

CGlobalDebugState::~CGlobalDebugState(void)
{
    Destroy();
}

bool CGlobalDebugState::IsValid(void) const
{
    return (m_hSystemDataMutex && m_hMemoryMappedFile && m_pSystemGlobalData);
}

DWORD CGlobalDebugState::AllowDebugMessages(void)
{
    DWORD nResult = 0;
    CSystemGlobalData *pSystemGlobalData = Lock();
    if (pSystemGlobalData)
    {
        nResult = m_pSystemGlobalData->nAllowDebugMessages;
        Release();
    }
    return nResult;
}


DWORD CGlobalDebugState::AllowDebugMessages( DWORD nAllowDebugMessages )
{
    DWORD nResult = 0;
    CSystemGlobalData *pSystemGlobalData = Lock();
    if (pSystemGlobalData)
    {
        nResult = m_pSystemGlobalData->nAllowDebugMessages;
        m_pSystemGlobalData->nAllowDebugMessages = nAllowDebugMessages;
        Release();
    }
    return nResult;
}

DWORD CGlobalDebugState::AllocateNextColorIndex(void)
{
    DWORD nResult = 0;
    CSystemGlobalData *pSystemGlobalData = Lock();
    if (pSystemGlobalData)
    {
        nResult = m_pSystemGlobalData->nCurrentColor++;
        Release();
    }
    return nResult;
}

COLORREF CGlobalDebugState::GetColorFromIndex( DWORD nIndex )
{
    COLORREF crResult = RGB(0,0,0);
    CSystemGlobalData *pSystemGlobalData = Lock();
    if (pSystemGlobalData)
    {
        crResult = m_pSystemGlobalData->crDebugColors[nIndex % NUMBER_OF_DEBUG_COLORS];
        Release();
    }
    return crResult;
}

bool CGlobalDebugState::DebugWindow( HWND hWnd )
{
    bool bResult = false;
    CSystemGlobalData *pSystemGlobalData = Lock();
    if (pSystemGlobalData)
    {
        m_pSystemGlobalData->hwndDebug = static_cast<DWORD>(reinterpret_cast<UINT_PTR>(hWnd));
        bResult = true;
        Release();
    }
    return bResult;
}

HWND CGlobalDebugState::DebugWindow(void)
{
    HWND hWndResult = NULL;
    CSystemGlobalData *pSystemGlobalData = Lock();
    if (pSystemGlobalData)
    {
        hWndResult = reinterpret_cast<HWND>(static_cast<UINT_PTR>(m_pSystemGlobalData->hwndDebug));
        Release();
    }
    return hWndResult;
}

bool CGlobalDebugState::SendDebugWindowMessage( UINT nMsg, WPARAM wParam, LPARAM lParam )
{
    bool bResult = false;
    CSystemGlobalData *pSystemGlobalData = Lock();
    if (pSystemGlobalData)
    {
        HWND hWndDebug = reinterpret_cast<HWND>(static_cast<UINT_PTR>(m_pSystemGlobalData->hwndDebug));
        if (IsWindow(hWndDebug))
        {
            SendMessage( hWndDebug, nMsg, wParam, lParam );
            bResult = true;
        }
        Release();
    }
    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\itranhlp.h ===
#ifndef __ITRANHLP_H_INCLUDED
#define __ITRANHLP_H_INCLUDED

#include <windows.h>
#include <objbase.h>
#include <wia.h>

#if defined(__cplusplus)
extern "C" {
#endif

#include <pshpack8.h>


#define WIA_TRANSFERHELPER_NOPROGRESS         0x00000001  // Don't show progress dialog
#define WIA_TRANSFERHELPER_NOCANCEL           0x00000002  // Don't allow the user to cancel using the system provided progress dialog
#define WIA_TRANSFERHELPER_PRESERVEFAILEDFILE 0x00000004  // If the transfer results in a valid file, even if there is an error, preserve it.  Otherwise, it will be deleted.

#undef  INTERFACE
#define INTERFACE IWiaTransferHelper
DECLARE_INTERFACE_(IWiaTransferHelper, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IWiaTransferHelper methods ***
    STDMETHOD(TransferItemFile)( THIS_
                        IWiaItem *pWiaItem,          // IN.       Transfer Item
                        HWND hwndParent,             // IN.       Parent window for status dialog.  NULL ok.
                        DWORD dwFlags,               // IN.       Flags
                        GUID cfFormat,               // IN.       WiaImgFmt_BMP, etc.  Pass 0 for the default file type
                        LPCWSTR pszFilename,         // IN.       File to which this data will be stored.
                        IWiaDataCallback *pCallback, // IN.       Optional callback.  May specify NULL
                        LONG nMediaType              // IN.       Either TYMED_FILE or TYMED_MULTIPAGE_FILE
                        ) PURE;
    STDMETHOD(TransferItemBanded)( THIS_
                        IWiaItem *pWiaItem,          // IN.       Transfer Item
                        HWND hwndParent,             // IN.       Parent window for status dialog.  NULL ok.
                        DWORD dwFlags,               // IN.       Flags
                        GUID cfFormat,               // IN.       WiaImgFmt_BMP, etc.  Pass 0 for the default file type
                        ULONG ulBufferSize,          // IN.       Size of transfer buffer.  Pass 0 to use the minimum.
                        IWiaDataCallback *pCallback  // IN.       Required callback
                        ) PURE;
};

// {74569BD2-877A-4677-A1E5-ADDA5A09BDBF}
DEFINE_GUID(IID_IWiaTransferHelper, 0x74569BD2, 0x877A, 0x4677, 0xA1, 0xE5, 0xAD, 0xDA, 0x5A, 0x09, 0xBD, 0xBF);

#undef  INTERFACE
#define INTERFACE IWiaMiscellaneousHelpers
DECLARE_INTERFACE_(IWiaMiscellaneousHelpers, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IWiaMiscellaneousHelper methods ***
    STDMETHOD(GetDeviceIcon)( THIS_
                        LONG nDeviceType,
                        HICON *phIcon,
                        int nSize
                        ) PURE;
};

// {DFF1EE6C-9A4F-4652-990B-315775D42A96}
DEFINE_GUID(IID_IWiaMiscellaneousHelpers, 0xDFF1EE6C, 0x9A4F, 0x4652, 0x99, 0xB, 0x31, 0x57, 0x75, 0xD4, 0x2A, 0x96);

enum CAnnotationType
{
    AnnotationNone     = 0x00000000,
    AnnotationUnknown  = 0x00000001,
    AnnotationAudio    = 0x00000002
};

#undef  INTERFACE
#define INTERFACE IWiaAnnotationHelpers
DECLARE_INTERFACE_(IWiaAnnotationHelpers, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IWiaAnnotationHelpers methods ***
    STDMETHOD(GetAnnotationOverlayIcon)( THIS_
                        CAnnotationType AnnotationType,
                        HICON *phIcon,
                        int nSize
                        ) PURE;
    STDMETHOD(GetAnnotationType)( THIS_
                        IUnknown *pUnknown,
                        CAnnotationType &AnnotationType
                        ) PURE;
    STDMETHOD(GetAnnotationFormat)( THIS_
                        IUnknown *pUnknown,
                        GUID &guidFormat
                        ) PURE;
    STDMETHOD(GetAnnotationSize)( THIS_
                        IUnknown *pUnknown,
                        LONG &nSize,
                        LONG nMediaType
                        ) PURE;
    STDMETHOD(TransferAttachmentToMemory)( THIS_
                        IUnknown *pUnknown,
                        GUID &guidFormat,
                        HWND hWndProgressParent,
                        PBYTE *pBuffer,
                        DWORD *pdwSize
                        ) PURE;

};

// {30F6E8E8-850C-4241-8440-561EBC221A5E}
DEFINE_GUID( IID_IWiaAnnotationHelpers, 0x30f6e8e8, 0x850c, 0x4241, 0x84, 0x40, 0x56, 0x1e, 0xbc, 0x22, 0x1a, 0x5e );


struct CWiaPaperSize
{
    LPWSTR  pszName;
    ULONG   nWidth;
    ULONG   nHeight;
};

#undef  INTERFACE
#define INTERFACE IWiaScannerPaperSizes
DECLARE_INTERFACE_(IWiaScannerPaperSizes, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IWiaScannerPaperSizes methods ***
    STDMETHOD(GetPaperSizes)( THIS_
                        CWiaPaperSize **ppPaperSizes,
                        UINT *pnCount
                        ) PURE;
    STDMETHOD(FreePaperSizes)( THIS_
                        CWiaPaperSize **ppPaperSizes,
                        UINT *pnCount
                        ) PURE;
};

// {E3F1175E-BA5D-445c-8E44-F1D9BD29580D}
DEFINE_GUID(IID_IWiaScannerPaperSizes, 0xe3f1175e, 0xba5d, 0x445c, 0x8e, 0x44, 0xf1, 0xd9, 0xbd, 0x29, 0x58, 0xd);



#include <poppack.h>

#if defined(__cplusplus)
};
#endif

#endif //__ITRANHLP_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\itranspl.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       ITRANSPL.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        3/1/2000
 *
 *  DESCRIPTION: Image transfer plugin declarations for the scanner and camera wizard
 *
 *  1.  Implemented as an inproc, apartment-threaded COM component.
 *
 *  2.  Component to display UI *only* during IImageTransferPlugin::OpenConnection.
 *
 *  3.  UI displayed during IImageTransferPlugin::OpenConnection should be a modal dialog
 *      using hwndParent as the parent window.  This window may be NULL.
 *
 *  4.  The icon returned from IImageTransferPlugin::GetPluginIcon must be
 *      copied to a new icon using CopyIcon.
 *
 *******************************************************************************/

#ifndef __ITRANSPL_H_INCLUDED
#define __ITRANSPL_H_INCLUDED

#undef  INTERFACE
#define INTERFACE IImageTransferPluginProgressCallback
DECLARE_INTERFACE_(IImageTransferPluginProgressCallback, IUnknown)
{
    //
    // *** IUnknown methods ***
    //
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    //
    // *** IImageTransferPluginProgressCallback methods ***
    //
    STDMETHOD(SetProgressMessage)( THIS_ BSTR bstrMessage );
    STDMETHOD(SetCurrentFile)( THIS_ UINT nIndex );
    STDMETHOD(SetOverallPercent)( THIS_ UINT nPercent );
    STDMETHOD(SetFilePercent)( THIS_ UINT nPercent );
    STDMETHOD(Cancelled)( THIS_ UINT *bCancelled );
};

//
// {EC749A35-CE66-483a-B661-A22269F2B375}
//
DEFINE_GUID(IID_IImageTransferPluginProgressCallback, 0xEC749A35, 0xCE66, 0x483A, 0xB6, 0x61, 0xA2, 0x22, 0x69, 0xF2, 0xB3, 0x75);


#undef  INTERFACE
#define INTERFACE IImageTransferPlugin
DECLARE_INTERFACE_(IImageTransferPlugin, IUnknown)
{
    //
    // *** IUnknown methods ***
    //
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    //
    // *** IImageTransferPlugin methods ***
    //
    STDMETHOD(GetPluginCount)( THIS_ ULONG *pnCount );
    STDMETHOD(GetPluginName)( THIS_ ULONG nPluginId, BSTR *pbstrName );
    STDMETHOD(GetPluginDescription)( THIS_ ULONG nPluginId, BSTR *pbstrDescription );
    STDMETHOD(GetPluginIcon)( THIS_ ULONG nPluginId, HICON *phIcon, int nWidth, int nHeight );
    STDMETHOD(OpenConnection)( THIS_ HWND hwndParent, ULONG nPluginId, IImageTransferPluginProgressCallback *pImageTransferPluginProgressCallback );
    STDMETHOD(AddFile)( THIS_ BSTR bstrFilename, BSTR bstrDescription, const GUID &guidImageFormat, BOOL bDelete );
    STDMETHOD(TransferFiles)( THIS_ BSTR bstrGlobalDescription );
    STDMETHOD(OpenDestination)( THIS_ );
    STDMETHOD(CloseConnection)( THIS_ );
};

//
// {2AC44F64-7156-46ef-B9BF-2A6D70ABC4BC}
//
DEFINE_GUID(IID_IImageTransferPlugin, 0x2AC44F64, 0x7156, 0x46EF, 0xB9, 0xBF, 0x2A, 0x6D, 0x70, 0xAB, 0xC4, 0xBC);

#endif __ITRANSPL_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\mboxex.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       MBOXEX.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        7/13/2000
 *
 *  DESCRIPTION: Super duper message box
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include <simcrack.h>
#include <movewnd.h>
#include <dlgunits.h>
#include <simrect.h>
#include <shlwapi.h>
#include "mboxex.rh"
#include "mboxex.h"

extern HINSTANCE g_hInstance;

CMessageBoxEx::CMessageBoxEx( HWND hWnd )
  : m_hWnd(hWnd),
    m_pData(NULL)
{
}


LRESULT CMessageBoxEx::OnInitDialog( WPARAM, LPARAM lParam )
{
    WIA_PUSHFUNCTION(TEXT("CMessageBoxEx::OnInitDialog"));
    //
    // Actual button ids
    //
    const UINT nButtonIds[MaxButtons] = { IDC_MESSAGEBOX_BUTTON_1, IDC_MESSAGEBOX_BUTTON_2, IDC_MESSAGEBOX_BUTTON_3, IDC_MESSAGEBOX_BUTTON_4 };

    //
    // Get the data, and return and error if it is invalid
    //
    m_pData = reinterpret_cast<CData*>(lParam);
    if (!m_pData)
    {
        EndDialog( m_hWnd, -1 );
        return 0;
    }

    //
    // Set the button text for the used buttons
    //
    for (UINT i=0,nStart=MaxButtons-m_pData->m_nButtonCount;i<m_pData->m_nButtonCount;i++)
    {
        SetWindowLongPtr( GetDlgItem( m_hWnd, nButtonIds[nStart+i] ), GWLP_USERDATA, nButtonIds[nStart+i] );
    }

    //
    // Set the default for the "Hide future messages" button
    //
    if (m_pData->m_bHideMessageInFuture)
    {
        SendDlgItemMessage( m_hWnd, IDC_MESSAGEBOX_HIDEINFUTURE, BM_SETCHECK, BST_CHECKED, 0 );
    }

    int nDeltaY = 0;

    HDC hDC = GetDC( GetDlgItem( m_hWnd, IDC_MESSAGEBOX_MESSAGE ) );
    if (hDC)
    {
        //
        // Get the window rect of the message control
        //
        CSimpleRect rcMessage( GetDlgItem( m_hWnd, IDC_MESSAGEBOX_MESSAGE ), CSimpleRect::WindowRect );
        rcMessage.ScreenToClient(m_hWnd);

        //
        // Get the correct font
        //
        HFONT hFont = reinterpret_cast<HFONT>(SendDlgItemMessage( m_hWnd, IDC_MESSAGEBOX_MESSAGE, WM_GETFONT, 0, 0 ));
        if (!hFont)
        {
            hFont = reinterpret_cast<HFONT>(GetStockObject(SYSTEM_FONT));
        }

        if (hFont)
        {
            //
            // Calculate the height of the text
            //
            CSimpleRect rcText = rcMessage;
            HFONT hOldFont = reinterpret_cast<HFONT>(SelectObject( hDC, hFont ));
            int nHeight = DrawText( hDC, m_pData->m_strMessage, m_pData->m_strMessage.Length(), &rcText, DT_CALCRECT|DT_EXPANDTABS|DT_NOPREFIX|DT_WORDBREAK );

            //
            // Only resize the control if it needs to be larger.  Don't do it if the control needs to be smaller.
            //
            if (nHeight > rcMessage.Height())
            {
                nDeltaY += (rcMessage.Height() - nHeight);
                CMoveWindow().Size( GetDlgItem( m_hWnd, IDC_MESSAGEBOX_MESSAGE ), 0, nHeight, CMoveWindow::NO_SIZEX );
            }

            SelectObject( hDC, hOldFont );
        }
        ReleaseDC( GetDlgItem( m_hWnd, IDC_MESSAGEBOX_MESSAGE ), hDC );
    }

    //
    // If we are not supposed to show the "Hide future messages" button, hide it
    // and move all of the controls up by its height and vertical margin.
    //
    if ((m_pData->m_nFlags & MBEX_HIDEFUTUREMESSAGES) == 0)
    {
        EnableWindow( GetDlgItem( m_hWnd, IDC_MESSAGEBOX_HIDEINFUTURE ), FALSE );
        ShowWindow( GetDlgItem( m_hWnd, IDC_MESSAGEBOX_HIDEINFUTURE ), SW_HIDE );

        //
        // Figure out how much to move the controls up
        //
        nDeltaY += CSimpleRect( GetDlgItem( m_hWnd, IDC_MESSAGEBOX_HIDEINFUTURE ), CSimpleRect::WindowRect ).Height() + CDialogUnits(m_hWnd).Y(7);
    }

    if (nDeltaY)
    {
        CMoveWindow mw;

        //
        // Move the "Hide future messages" button
        //
        mw.Move( GetDlgItem( m_hWnd, IDC_MESSAGEBOX_HIDEINFUTURE ), 0, CSimpleRect( GetDlgItem( m_hWnd, IDC_MESSAGEBOX_HIDEINFUTURE ), CSimpleRect::WindowRect ).ScreenToClient(m_hWnd).top - nDeltaY, CMoveWindow::NO_MOVEX );

        //
        // Figure out what the top row is
        //
        int nButtonTopRow = CSimpleRect( GetDlgItem( m_hWnd, IDC_MESSAGEBOX_BUTTON_4 ), CSimpleRect::WindowRect ).ScreenToClient(m_hWnd).top - nDeltaY;

        //
        // Move all of the buttons
        //
        mw.Move( GetDlgItem( m_hWnd, IDC_MESSAGEBOX_BUTTON_1 ), 0, nButtonTopRow, CMoveWindow::NO_MOVEX );
        mw.Move( GetDlgItem( m_hWnd, IDC_MESSAGEBOX_BUTTON_2 ), 0, nButtonTopRow, CMoveWindow::NO_MOVEX );
        mw.Move( GetDlgItem( m_hWnd, IDC_MESSAGEBOX_BUTTON_3 ), 0, nButtonTopRow, CMoveWindow::NO_MOVEX );
        mw.Move( GetDlgItem( m_hWnd, IDC_MESSAGEBOX_BUTTON_4 ), 0, nButtonTopRow, CMoveWindow::NO_MOVEX );
        mw.Apply();

        //
        // Resize the dialog
        //
        CSimpleRect rcDialog( m_hWnd, CSimpleRect::WindowRect );
        SetWindowPos( m_hWnd, NULL, 0, 0, rcDialog.Width(), rcDialog.Height()-nDeltaY, SWP_NOMOVE|SWP_NOZORDER|SWP_NOACTIVATE );
    }

    //
    // Hide and disable the unused buttons
    //
    for (i=0;i<MaxButtons-m_pData->m_nButtonCount;i++)
    {
        EnableWindow( GetDlgItem( m_hWnd, nButtonIds[i] ), FALSE );
        ShowWindow( GetDlgItem( m_hWnd, nButtonIds[i] ), SW_HIDE );
    }


    //
    // Set the button IDs.  Do this last, so we can use constants until then
    //
    for (UINT i=0,nStart=MaxButtons-m_pData->m_nButtonCount;i<m_pData->m_nButtonCount;i++)
    {
        WIA_TRACE((TEXT("SetWindowLongPtr( GetDlgItem( m_hWnd, %d ), GWLP_ID, %d );"), nButtonIds[nStart+i], m_pData->m_Buttons[i] ));
        SetWindowLongPtr( GetDlgItem( m_hWnd, nButtonIds[nStart+i] ), GWLP_ID, m_pData->m_Buttons[i] );
    }

    //
    // Set the focus and default button
    //
    if (m_pData->m_nDefault)
    {
        SetFocus( GetDlgItem( m_hWnd,  m_pData->m_nDefault) );
        SendDlgItemMessage( GetParent(m_hWnd), m_pData->m_nDefault, BM_SETSTYLE, BS_PUSHBUTTON, MAKELPARAM(TRUE,0) );
        SendMessage( m_hWnd, DM_SETDEFID, m_pData->m_nDefault, 0 );
    }

    //
    // Set the icon
    //
    SendDlgItemMessage( m_hWnd, IDC_MESSAGEBOX_ICON, STM_SETICON, reinterpret_cast<WPARAM>(m_pData->m_hIcon), 0 );

    //
    // Set the message text
    //
    m_pData->m_strMessage.SetWindowText( GetDlgItem( m_hWnd, IDC_MESSAGEBOX_MESSAGE ) );

    //
    // Set the window text
    //
    m_pData->m_strTitle.SetWindowText( m_hWnd );

    SetForegroundWindow( m_hWnd );

    return TRUE;
}


LRESULT CMessageBoxEx::OnCommand( WPARAM wParam, LPARAM lParam )
{
    //
    // First, check to see if this message pertains to one of our buttons
    //
    for (UINT i=0;i<m_pData->m_nButtonCount;i++)
    {
        if ((LOWORD(wParam) == m_pData->m_Buttons[i]) == (HIWORD(wParam) == BN_CLICKED))
        {
            //
            // Store the "Hide this message in the future" value
            //
            m_pData->m_bHideMessageInFuture = (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_MESSAGEBOX_HIDEINFUTURE, BM_GETCHECK, 0, 0 ));

            //
            // Close the dialog
            //
            EndDialog( m_hWnd, LOWORD(wParam) );
            return 0;
        }
    }
    if (LOWORD(wParam) == IDCANCEL)
    {
        EndDialog( m_hWnd, IDCANCEL );
        return 0;
    }
    SC_BEGIN_COMMAND_HANDLERS()
    {
    }
    SC_END_COMMAND_HANDLERS();
}



INT_PTR CALLBACK CMessageBoxEx::DialogProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    SC_BEGIN_DIALOG_MESSAGE_HANDLERS(CMessageBoxEx)
    {
        SC_HANDLE_DIALOG_MESSAGE( WM_INITDIALOG, OnInitDialog );
        SC_HANDLE_DIALOG_MESSAGE( WM_COMMAND, OnCommand );
    }
    SC_END_DIALOG_MESSAGE_HANDLERS();
}



UINT CMessageBoxEx::MessageBox( HWND hWndParent, LPCTSTR pszMessage, LPCTSTR pszTitle, UINT nFlags, bool *pbHideFutureMessages )
{
    CData Data;
    Data.m_nFlags = nFlags;
    Data.m_strMessage = pszMessage;
    Data.m_strTitle = pszTitle;

    //
    // Figure out which set of buttons to use
    //
    int nDialogResource = 0;
    if (nFlags & MBEX_OKCANCEL)
    {
        nDialogResource = IDD_MESSAGEBOX_OKCANCEL;
        Data.m_Buttons[0] = IDMBEX_OK;
        Data.m_Buttons[1] = IDMBEX_CANCEL;
        Data.m_nButtonCount = 2;
    }
    else if (nFlags & MBEX_YESNO)
    {
        nDialogResource = IDD_MESSAGEBOX_YESNO;
        Data.m_Buttons[0] = IDMBEX_YES;
        Data.m_Buttons[1] = IDMBEX_NO;
        Data.m_nButtonCount = 2;
    }
    else if (nFlags & MBEX_CANCELRETRYSKIPSKIPALL)
    {
        nDialogResource = IDD_MESSAGEBOX_CANCELRETRYSKIPSKIPALL;
        Data.m_Buttons[0] = IDMBEX_CANCEL;
        Data.m_Buttons[1] = IDMBEX_RETRY;
        Data.m_Buttons[2] = IDMBEX_SKIP;
        Data.m_Buttons[3] = IDMBEX_SKIPALL;
        Data.m_nButtonCount = 4;
    }
    else if (nFlags & MBEX_CANCELRETRY)
    {
        nDialogResource = IDD_MESSAGEBOX_CANCELRETRY;
        Data.m_Buttons[0] = IDMBEX_CANCEL;
        Data.m_Buttons[1] = IDMBEX_RETRY;
        Data.m_nButtonCount = 2;
    }
    else if (nFlags & MBEX_YESYESTOALLNONOTOALL)
    {
        nDialogResource = IDD_MESSAGEBOX_YESYESTOALLNONOTOALL;
        Data.m_Buttons[0] = IDMBEX_YES;
        Data.m_Buttons[1] = IDMBEX_YESTOALL;
        Data.m_Buttons[2] = IDMBEX_NO;
        Data.m_Buttons[3] = IDMBEX_NOTOALL;
        Data.m_nButtonCount = 4;
    }
    else
    {
        nDialogResource = IDD_MESSAGEBOX_OK;
        Data.m_Buttons[0] = IDMBEX_OK;
        Data.m_nButtonCount = 1;
    }

    //
    // Figure out which icon to use
    //
    if (nFlags & MBEX_ICONWARNING)
    {
        Data.m_hIcon = LoadIcon( NULL, IDI_WARNING );
        MessageBeep( MB_ICONWARNING );
    }
    else if (nFlags & MBEX_ICONERROR)
    {
        Data.m_hIcon = LoadIcon( NULL, IDI_ERROR );
        MessageBeep( MB_ICONERROR );
    }
    else if (nFlags & MBEX_ICONQUESTION)
    {
        Data.m_hIcon = LoadIcon( NULL, IDI_QUESTION );
        MessageBeep( MB_ICONQUESTION );
    }
    else
    {
        Data.m_hIcon = LoadIcon( NULL, IDI_INFORMATION );
        MessageBeep( MB_ICONINFORMATION );
    }

    //
    // Figure out which button should be the default
    //
    if (nFlags & MBEX_DEFBUTTON2)
    {
        Data.m_nDefault = Data.m_Buttons[1];
    }
    else if (nFlags & MBEX_DEFBUTTON3)
    {
        Data.m_nDefault = Data.m_Buttons[2];
    }
    else if (nFlags & MBEX_DEFBUTTON4)
    {
        Data.m_nDefault = Data.m_Buttons[3];
    }
    else
    {
        Data.m_nDefault = Data.m_Buttons[0];
    }

    if (pbHideFutureMessages)
    {
        Data.m_bHideMessageInFuture = *pbHideFutureMessages;
    }

    INT_PTR nResult = DialogBoxParam( g_hInstance, MAKEINTRESOURCE(nDialogResource), hWndParent, DialogProc, reinterpret_cast<LPARAM>(&Data) );

    if (pbHideFutureMessages)
    {
        *pbHideFutureMessages = Data.m_bHideMessageInFuture;
    }

    return static_cast<UINT>(nResult);
}


UINT CMessageBoxEx::MessageBox( HWND hWndParent, LPCTSTR pszMessage, LPCTSTR pszTitle, UINT nFlags, bool &bHideFutureMessages )
{
    return MessageBox( hWndParent, pszMessage, pszTitle, nFlags|MBEX_HIDEFUTUREMESSAGES, &bHideFutureMessages );
}


UINT CMessageBoxEx::MessageBox( HWND hWndParent, LPCTSTR pszMessage, LPCTSTR pszTitle, UINT nFlags )
{
    return MessageBox( hWndParent, pszMessage, pszTitle, nFlags, NULL );
}


UINT CMessageBoxEx::MessageBox( LPCTSTR pszMessage, LPCTSTR pszTitle, UINT nFlags )
{
    return MessageBox( NULL, pszMessage, pszTitle, nFlags, NULL );
}


UINT CMessageBoxEx::MessageBox( HWND hWndParent, HINSTANCE hInstance, UINT nMessageId, UINT nTitleId, UINT nFlags, bool &bHideFutureMessages )
{
    return MessageBox( hWndParent, CSimpleString(nMessageId,hInstance), CSimpleString(nTitleId,hInstance), nFlags|MBEX_HIDEFUTUREMESSAGES, &bHideFutureMessages );
}


UINT CMessageBoxEx::MessageBox( HWND hWndParent, LPCTSTR pszTitle, UINT nFlags, LPCTSTR pszFormat, ... )
{
    TCHAR szMessage[1024] = {0};
    va_list arglist;

    va_start( arglist, pszFormat );
    wvnsprintf( szMessage, ARRAYSIZE(szMessage), pszFormat, arglist );
    va_end( arglist );

    return MessageBox( hWndParent, szMessage, pszTitle, nFlags, NULL );
}


UINT CMessageBoxEx::MessageBox( HWND hWndParent, LPCTSTR pszTitle, UINT nFlags, bool &bHideFutureMessages, LPCTSTR pszFormat, ... )
{
    TCHAR szMessage[1024] = {0};
    va_list arglist;

    va_start( arglist, pszFormat );
    wvnsprintf( szMessage, ARRAYSIZE(szMessage), pszFormat, arglist );
    va_end( arglist );

    return MessageBox( hWndParent, szMessage, pszTitle, nFlags, &bHideFutureMessages );
}


UINT CMessageBoxEx::MessageBox( HWND hWndParent, HINSTANCE hInstance, UINT nTitleId, UINT nFlags, UINT nFormatId, ... )
{
    TCHAR szMessage[1024] = {0};
    va_list arglist;

    va_start( arglist, nFormatId );
    wvnsprintf( szMessage, ARRAYSIZE(szMessage), CSimpleString(nFormatId,hInstance), arglist );
    va_end( arglist );

    return MessageBox( hWndParent, szMessage, CSimpleString(nTitleId,hInstance), nFlags, NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\memdib.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       MEMDIB.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        7/14/1998
 *
 *  DESCRIPTION: This class allows you to construct a bitmap from raw bitmap data.
 *               IMPORTANT: All source data is assumed to be TOP-DOWN!!!!!!
 *
 *******************************************************************************/
#ifndef __MEMDIB_H_INCLUDED
#define __MEMDIB_H_INCLUDED

#include <windows.h>
#include "miscutil.h"
#include "wiadebug.h"

class CMemoryDib
{
private:
    PBYTE      m_pBitmapBits;
    HBITMAP    m_hBitmap;
    UINT       m_nHeaderLength;

private:
    // No implementation
    int operator=( const CMemoryDib & );
    CMemoryDib( const CMemoryDib & );

public:
    CMemoryDib(void)
    :   m_hBitmap(NULL),
        m_pBitmapBits(NULL),
        m_nHeaderLength(0)
    {
    }
    virtual ~CMemoryDib(void)
    {
        Destroy();
    }

    void Destroy(void)
    {
        if (m_hBitmap)
        {
            DeleteObject(m_hBitmap);
            m_hBitmap = NULL;
        }
        m_nHeaderLength = 0;
        m_pBitmapBits = NULL;
    }
    bool IsValid(void) const
    {
        bool bResult = (m_hBitmap && m_pBitmapBits && m_nHeaderLength);
        return bResult;
    }
    PBYTE GetBitmapBits(void)
    {
        if (!IsValid())
        {
            return NULL;
        }
        return (m_pBitmapBits);
    }
    bool GetDibSection( DIBSECTION &ds )
    {
        if (IsValid() && GetObject( m_hBitmap, sizeof(DIBSECTION), &ds ))
        {
            return true;
        }
        return false;
    }
    LONG GetBitsPerPixel(void)
    {
        if (!IsValid())
        {
            return 0;
        }
        DIBSECTION ds;
        if (GetDibSection(ds))
        {
            return ds.dsBmih.biBitCount;
        }
        return 0;
    }
    LONG GetWidthInPixels(void)
    {
        if (!IsValid())
        {
            return 0;
        }
        DIBSECTION ds;
        if (GetDibSection(ds))
        {
            return ds.dsBmih.biWidth;
        }
        return 0;
    }
    LONG GetPackedWidthInBytes(void)
    {
        if (!IsValid())
        {
            return 0;
        }
        return (GetWidthInPixels() * GetBitsPerPixel()) / 8;
    }

    LONG GetUnpackedWidthInBytes(void)
    {
        if (!IsValid())
        {
            return 0;
        }
        return (WiaUiUtil::Align(GetWidthInPixels() * GetBitsPerPixel(), sizeof(DWORD)*8)/8);
    }
    LONG GetHeight(void)
    {
        if (!IsValid())
        {
            return 0;
        }
        DIBSECTION ds;
        if (GetDibSection(ds))
        {
            return ds.dsBmih.biHeight;
        }
        return 0;
    }
    UINT GetHeaderLength(void) const
    {
        if (!IsValid())
        {
            return 0;
        }
        return m_nHeaderLength;
    }
    LONG GetUnpackedBitmapDataSize(void)
    {
        if (!IsValid())
        {
            return 0;
        }
        return (GetUnpackedWidthInBytes() * GetHeight());
    }
    LONG GetPackedBitmapDataSize(void)
    {
        if (!IsValid())
        {
            return 0;
        }
        return (GetPackedWidthInBytes() * GetHeight());
    }
    HBITMAP Bitmap(void)
    {
        if (!IsValid())
        {
            return NULL;
        }
        return m_hBitmap;
    }
    HBITMAP DetachBitmap(void)
    {
        HBITMAP hBitmap = m_hBitmap;
        m_hBitmap = NULL;
        m_pBitmapBits = NULL;
        return hBitmap;
    }
    static void DumpBitmap( PBITMAPINFO pBitmapInfo )
    {
        WIA_TRACE((TEXT("pBitmapInfo: %08X"), pBitmapInfo ));
        WIA_TRACE((TEXT("biSize: %d\nbiWidth: %d\nbiHeight: %d\nbiPlanes: %d\nbiBitCount: %d\nbiCompression: %d\nbiSizeImage: %d\nbiXPelsPerMeter: %d\nbiYPelsPerMeter: %d\nbiClrUsed: %d\nbiClrImportant: %d"),
                   pBitmapInfo->bmiHeader.biSize,
                   pBitmapInfo->bmiHeader.biWidth,
                   pBitmapInfo->bmiHeader.biHeight,
                   pBitmapInfo->bmiHeader.biPlanes,
                   pBitmapInfo->bmiHeader.biBitCount,
                   pBitmapInfo->bmiHeader.biCompression,
                   pBitmapInfo->bmiHeader.biSizeImage,
                   pBitmapInfo->bmiHeader.biXPelsPerMeter,
                   pBitmapInfo->bmiHeader.biYPelsPerMeter,
                   pBitmapInfo->bmiHeader.biClrUsed,
                   pBitmapInfo->bmiHeader.biClrImportant));
    }
    bool Initialize( PBITMAPINFO pBitmapInfo )
    {
        //
        // Clear everything
        //
        Destroy();

        if (pBitmapInfo)
        {
            //
            // What kind of bitmap is this?
            //
            DumpBitmap(pBitmapInfo);

            //
            // Get the header size.  We'll need it later
            //
            m_nHeaderLength = WiaUiUtil::GetBmiSize(pBitmapInfo);
            if (m_nHeaderLength)
            {
                //
                // Allocate a new BITMAPINFOHEADER + palette
                //
                BITMAPINFO *pNewBitmapInfo = reinterpret_cast<BITMAPINFO*>( new BYTE[m_nHeaderLength] );
                if (pNewBitmapInfo)
                {
                    //
                    // Copy the header and palette
                    //
                    CopyMemory( pNewBitmapInfo, pBitmapInfo, m_nHeaderLength );

                    //
                    // Make sure we have a positive height
                    //
                    pNewBitmapInfo->bmiHeader.biHeight = WiaUiUtil::Absolute( pNewBitmapInfo->bmiHeader.biHeight );

                    //
                    // If this is one of those "unknown length" bitmaps, normalize it to be 8.5 x 11
                    //
                    if (!pNewBitmapInfo->bmiHeader.biHeight)
                    {
                        pNewBitmapInfo->bmiHeader.biHeight = WiaUiUtil::MulDivNoRound(pNewBitmapInfo->bmiHeader.biWidth,1100,850);
                    }

                    m_hBitmap = CreateDIBSection( NULL, pNewBitmapInfo, DIB_RGB_COLORS, (void**)&m_pBitmapBits, 0, 0 );

                    if (m_hBitmap)
                    {
                        //
                        // Initialize it to white.  We hope.  It will depend on the palette.
                        //
                        FillMemory( m_pBitmapBits, GetUnpackedBitmapDataSize(), 0xFF );
                    }
                    else
                    {
                        WIA_PRINTHRESULT((HRESULT_FROM_WIN32(GetLastError()),TEXT("CreateDIBSection FAILED")));
                    }

                    //
                    // Free up our temporary header
                    //
                    delete[] reinterpret_cast<BYTE*>(pNewBitmapInfo);
                }
                else
                {
                    WIA_ERROR((TEXT("pNewBitmapInfo is NULL")));
                }

            }
            else
            {
                WIA_ERROR((TEXT("m_nHeaderLength was 0")));
            }

            //
            // Make sure there are no turds left over
            //
            if (!IsValid())
            {
                WIA_ERROR((TEXT("IsValid() was FALSE")));
                Destroy();
            }

        }
        else
        {
            WIA_ERROR((TEXT("pBitmapInfo is NULL")));
        }
        return IsValid();

    }
    bool SetPackedData( PBYTE pData, int nStartLine, int nLineCount )
    {
        if (!IsValid())
        {
            return false;
        }
        nStartLine = WiaUiUtil::Absolute(nStartLine);
        nLineCount = WiaUiUtil::Absolute(nLineCount);
        for (int i=0;i<nLineCount;i++)
        {
            if (nStartLine + i >= 0 && nStartLine + i < GetHeight())
            {
                PBYTE pDest = GetBitmapBits() + (GetHeight()-nStartLine-i-1) * GetUnpackedWidthInBytes();
                CopyMemory( pDest, pData + GetPackedWidthInBytes() * i, GetPackedWidthInBytes() );
            }
            else
            {
                WIA_ERROR((TEXT("CMemoryDib::SetPackedData: Ignoring out-of-range data: nStartLine: %d, nLineCount: %d"), nStartLine, nLineCount ));
            }
        }
        return true;
    }
    bool ScrollDataUp( int nScrollCount )
    {
        if (!IsValid())
        {
            return false;
        }
        if (nScrollCount > GetHeight())
        {
            nScrollCount = GetHeight();
        }
        PBYTE pSourceLine = GetBitmapBits() + (GetHeight() - nScrollCount - 1) * GetUnpackedWidthInBytes();
        PBYTE pTargetLine = GetBitmapBits() + (GetHeight() - 1) * GetUnpackedWidthInBytes();
        for (int i=0;i < GetHeight() - nScrollCount;i++)
        {
            CopyMemory(pTargetLine,pSourceLine,GetUnpackedWidthInBytes());
            pSourceLine -= GetUnpackedWidthInBytes();
            pTargetLine -= GetUnpackedWidthInBytes();
        }
        return true;
    }
    bool SetUnpackedData( PBYTE pData, int nStartLine, int nLineCount )
    {
        if (!IsValid())
        {
            return false;
        }
        nStartLine = WiaUiUtil::Absolute(nStartLine);
        nLineCount = WiaUiUtil::Absolute(nLineCount);
        for (int i=0;i<nLineCount;i++)
        {
            if (nStartLine + i >= 0 && nStartLine + i < GetHeight())
            {
                PBYTE pDest = GetBitmapBits() + (GetHeight()-nStartLine-i-1) * GetUnpackedWidthInBytes();
                CopyMemory( pDest, pData + GetUnpackedWidthInBytes() * i, GetUnpackedWidthInBytes() );
            }
            else
            {
                WIA_ERROR((TEXT("CMemoryDib::SetPackedData: Ignoring out-of-range data: nStartLine: %d, nLineCount: %d"), nStartLine, nLineCount ));
            }
        }
        return true;
    }
};

#endif // __MEMDIB_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\mboxex.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       MBOXEX.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        7/13/2000
 *
 *  DESCRIPTION: Super duper message box
 *
 *******************************************************************************/
#ifndef __MBOXEX_H_INCLUDED
#define __MBOXEX_H_INCLUDED

#include <windows.h>
#include <simstr.h>

class CMessageBoxEx
{
public:

    enum
    {
        //
        // Greatest number of buttons allowed
        //
        MaxButtons = 4
    };

    enum
    {
        //
        // Button formats
        //
        MBEX_OK                      = 0x00000000,
        MBEX_OKCANCEL                = 0x00000001,
        MBEX_YESNO                   = 0x00000002,
        MBEX_CANCELRETRY             = 0x00000010,
        MBEX_CANCELRETRYSKIPSKIPALL  = 0x00000020,
        MBEX_YESYESTOALLNONOTOALL    = 0x00000040,

        //
        // Default button flags
        //
        MBEX_DEFBUTTON1              = 0x00000000,
        MBEX_DEFBUTTON2              = 0x00100000,
        MBEX_DEFBUTTON3              = 0x00200000,
        MBEX_DEFBUTTON4              = 0x00400000,

        //
        // Icons
        //
        MBEX_ICONWARNING             = 0x00000100,
        MBEX_ICONINFORMATION         = 0x00000000,
        MBEX_ICONQUESTION            = 0x00000400,
        MBEX_ICONERROR               = 0x00000800,

        //
        // Advanced flags
        //
        MBEX_HIDEFUTUREMESSAGES      = 0x00010000,

        //
        // Return values
        //
        IDMBEX_OK                    = 0x00000001,
        IDMBEX_CANCEL                = 0x00000002,
        IDMBEX_RETRY                 = 0x00000004,
        IDMBEX_SKIP                  = 0x00000005,
        IDMBEX_YES                   = 0x00000006,
        IDMBEX_NO                    = 0x00000007,
        IDMBEX_SKIPALL               = 0x00000012,
        IDMBEX_YESTOALL              = 0x00000013,
        IDMBEX_NOTOALL               = 0x00000014
    };

public:
    class CData
    {
    public:
        UINT          m_Buttons[MaxButtons];
        CSimpleString m_strTitle;
        CSimpleString m_strMessage;
        UINT          m_nButtonCount;
        UINT          m_nFlags;
        HICON         m_hIcon;
        LPARAM        m_lParam;
        UINT          m_nDefault;
        bool          m_bHideMessageInFuture;

    private:
        CData( const CData & );
        CData &operator=( const CData & );

    public:
        CData(void)
          : m_strTitle(TEXT("")),
            m_strMessage(TEXT("")),
            m_nButtonCount(0),
            m_nFlags(0),
            m_hIcon(NULL),
            m_lParam(0),
            m_nDefault(0),
            m_bHideMessageInFuture(FALSE)
        {
            ZeroMemory( m_Buttons, ARRAYSIZE(m_Buttons) );
        }
    };

private:
    HWND   m_hWnd;
    CData *m_pData;

private:
    CMessageBoxEx(void);
    CMessageBoxEx( const CMessageBoxEx & );
    CMessageBoxEx &operator=( const CMessageBoxEx & );

private:
    explicit CMessageBoxEx( HWND hWnd );
    LRESULT OnInitDialog( WPARAM, LPARAM lParam );
    LRESULT OnCommand( WPARAM wParam, LPARAM lParam );

public:
    static INT_PTR CALLBACK DialogProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );

public:
    static UINT MessageBox( HWND hWndParent, LPCTSTR pszMessage, LPCTSTR pszTitle, UINT nFlags, bool *pbHideFutureMessages );
    static UINT MessageBox( HWND hWndParent, LPCTSTR pszMessage, LPCTSTR pszTitle, UINT nFlags, bool &bHideFutureMessages );
    static UINT MessageBox( HWND hWndParent, LPCTSTR pszMessage, LPCTSTR pszTitle, UINT nFlags );
    static UINT MessageBox( LPCTSTR pszMessage, LPCTSTR pszTitle, UINT nFlags );
    static UINT MessageBox( HWND hWndParent, HINSTANCE hInstance, UINT nMessageId, UINT nTitleId, UINT nFlags, bool &bHideFutureMessages );
    static UINT MessageBox( HWND hWndParent, LPCTSTR pszTitle, UINT nFlags, LPCTSTR pszFormat, ... );
    static UINT MessageBox( HWND hWndParent, LPCTSTR pszTitle, UINT nFlags, bool &bHideFutureMessages, LPCTSTR pszFormat, ... );
    static UINT MessageBox( HWND hWndParent, HINSTANCE hInstance, UINT nTitleId, UINT nFlags, UINT nFormatId, ... );
};

#endif // __MBOXEX_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\miscutil.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       MISCUTIL.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        5/28/1998
 *
 *  DESCRIPTION: Various utility functions we use in more than one place
 *
 *******************************************************************************/
#ifndef __MISCUTIL_H_INCLUDED
#define __MISCUTIL_H_INCLUDED

#include <windows.h>
#include "simstr.h"
#include "wia.h"
#include "resid.h"

#if !defined(ARRAYSIZE)
#define ARRAYSIZE(x)  (sizeof((x))/sizeof((x)[0]))
#endif

#if !defined(SETFormatEtc)
#define SETFormatEtc(fe, cf, asp, td, med, li)   \
    {\
    (fe).cfFormat=cf;\
    (fe).dwAspect=asp;\
    (fe).ptd=td;\
    (fe).tymed=med;\
    (fe).lindex=li;\
    };
#endif

#if !defined(SETDefFormatEtc)
#define SETDefFormatEtc(fe, cf, med)   \
    {\
    (fe).cfFormat=cf;\
    (fe).dwAspect=DVASPECT_CONTENT;\
    (fe).ptd=NULL;\
    (fe).tymed=med;\
    (fe).lindex=-1;\
    };
#endif


#define PROP_SHEET_ERROR_NO_PAGES MAKE_HRESULT(SEVERITY_ERROR,FACILITY_NULL,1)

namespace WiaUiUtil
{
    template <class T>
    T Absolute( const T &m )
    {
        return((m < 0) ? -m : m);
    }

    template <class T>
    T Max( const T &m, const T &n )
    {
        return((m > n) ? m : n);
    }

    template <class T>
    T Min( const T &m, const T &n )
    {
        return((m < n) ? m : n);
    }

    template <class T>
    T GetMinimum( const T& nDesired, const T& nMin, const T& nStep )
    {
        T nResult = Max<T>( nMin, nDesired );
        if (nStep)
            nResult = nResult + (nResult - nMin) % nStep;
        return nResult;
    }

    inline bool ScreenToClient( HWND hwnd, RECT *prc )
    {
        return (::MapWindowPoints( NULL, hwnd, reinterpret_cast<POINT*>(prc), 2 ) != 0);
    }

    inline bool ClientToScreen( HWND hwnd, RECT *prc )
    {
        return (::MapWindowPoints( hwnd, NULL, reinterpret_cast<POINT*>(prc), 2 ) != 0);
    }

    inline bool ScreenToClient( HWND hwnd, RECT &rc )
    {
        return ScreenToClient( hwnd, &rc );
    }

    inline bool ClientToScreen( HWND hwnd, RECT &rc )
    {
        return ClientToScreen( hwnd, &rc );
    }

    inline int RectWidth( const RECT &rc )
    {
        return (rc.right - rc.left);
    }

    inline int RectHeight( const RECT &rc )
    {
        return (rc.bottom - rc.top);
    }

    inline LONGLONG PowerOfTwo( int nCount )
    {
        return(LONGLONG)1 << nCount;
    }

    inline int MulDivNoRound( int nNumber, int nNumerator, int nDenominator )
    {
        return(int)(((LONGLONG)nNumber * nNumerator) / nDenominator);
    }

    inline SIZE ScalePreserveAspectRatio( int nAvailX, int nAvailY, int nItemX, int nItemY )
    {
        SIZE sizeResult = { nAvailX, nAvailY };
        if (nItemX && nItemY)
        {
            //
            // Width is greater than height.  X is the constraining factor
            //
            if (nAvailY*nItemX > nAvailX*nItemY)
            {
                sizeResult.cy = MulDivNoRound(nItemY,nAvailX,nItemX);
            }

            //
            // Height is greater than width.  Y is the constraining factor
            //
            else
            {
                sizeResult.cx = MulDivNoRound(nItemX,nAvailY,nItemY);
            }
        }
        return sizeResult;
    }

    inline void Enable( HWND hWnd, bool bEnable )
    {
        if (hWnd && IsWindow(hWnd))
        {
            if (!IsWindowEnabled(hWnd) && bEnable)
            {
                ::EnableWindow( hWnd, TRUE );
            }
            else if (IsWindowEnabled(hWnd) && !bEnable)
            {
                ::EnableWindow( hWnd, FALSE );
            }

        }
    }

    inline void Enable( HWND hWnd, int nChildId, bool bEnable )
    {
        if (hWnd && IsWindow(hWnd))
        {
            Enable(GetDlgItem(hWnd,nChildId),bEnable);
        }
    }

    inline UINT GetDisplayColorDepth()
    {
        UINT nColorDepth = 0;
        HDC hDC = GetDC( NULL );
        if (hDC)
        {
            nColorDepth = GetDeviceCaps( hDC, BITSPIXEL ) * GetDeviceCaps( hDC, PLANES );
            ReleaseDC( NULL, hDC );
        }
        return nColorDepth;
    }

    LONG          Align( LONG n , LONG m );
    LONG          StringToLong( LPCTSTR pszStr );
    SIZE          MapDialogSize( HWND hwnd, const SIZE &size );
    LONG          GetBmiSize(PBITMAPINFO pbmi);
    bool          MsgWaitForSingleObject( HANDLE hHandle, DWORD dwMilliseconds = INFINITE );
    void          CenterWindow( HWND hWnd, HWND hWndParent=NULL );
    bool          FlipImage( PBYTE pBits, LONG nWidth, LONG nHeight, LONG nBitDepth );
    HRESULT       InstallInfFromResource( HINSTANCE hInstance, LPCSTR pszSectionName );
    HRESULT       DeleteItemAndChildren (IWiaItem *pItem);
    LONG          ItemAndChildrenCount(IWiaItem *pItem );
    HRESULT       WriteDIBToFile( HBITMAP hDib, HANDLE hFile );
    HFONT         CreateFontWithPointSizeFromWindow( HWND hWnd, int nPointSize, bool bBold, bool bItalic );
    HFONT         ChangeFontFromWindow( HWND hWnd, int nPointSizeDelta );
    HFONT         GetFontFromWindow( HWND hWnd );
    HRESULT       SystemPropertySheet( HINSTANCE hInstance, HWND hwndParent, IWiaItem *pWiaItem, LPCTSTR pszCaption );
    int           FindLowestNumberedFile( LPCTSTR pszFileAndPathnameMask, int nCount=1, int nMax=65545 );
    int           FindLowestNumberedFile( LPCTSTR pszFileAndPathnameMaskPrefix, LPCTSTR pszFormatString, LPCTSTR pszFileAndPathnameMaskSuffix, int nCount=1, int nMax=65535 );
    HRESULT       GetDeviceTypeFromId( LPCWSTR pwszDeviceId, LONG *pnDeviceType );
    HRESULT       GetDeviceInfoFromId( LPCWSTR pwszDeviceId, IWiaPropertyStorage **ppWiaPropertyStorage );
    HRESULT       GetDefaultEventHandler (IWiaItem *pItem, const GUID &guidEvent, WIA_EVENT_HANDLER *pwehHandler);
    CSimpleString FitTextInStaticWithEllipsis( LPCTSTR pszString, HWND hWndStatic, UINT nDrawTextStyle );
    CSimpleString TruncateTextToFitInRect( HWND hFontWnd, LPCTSTR pszString, RECT rectTarget, UINT nDrawTextFormat );
    SIZE          GetTextExtentFromWindow( HWND hFontWnd, LPCTSTR pszString );
    bool          GetIconSize( HICON hIcon, SIZE &sizeIcon );
    HBITMAP       CreateIconThumbnail( HWND hWnd, int nWidth, int nHeight, HICON hIcon, LPCTSTR pszText );
    HBITMAP       CreateIconThumbnail( HWND hWnd, int nWidth, int nHeight, HINSTANCE hIconInstance, const CResId &resIconId, LPCTSTR pszText );
    HRESULT       MoveOrCopyFile( LPCTSTR pszSrc, LPCTSTR pszTgt );
    CSimpleString CreateTempFileName( UINT nId = 0 );
    HRESULT       StampItemTimeOnFile( IWiaItem *pWiaItem, LPCTSTR pszFilename );
    HRESULT       SaveWiaItemAudio( IWiaItem *pWiaItem, LPCTSTR pszBaseFilename, CSimpleString &strAudioFilename );
    bool          IsDeviceCommandSupported( IWiaItem *pWiaItem, const GUID &guidCommand );
    void          PreparePropertyPageForFusion( PROPSHEETPAGE *pPropSheetPage );
    bool          CanWiaImageBeSafelyRotated( const GUID &guidFormat, LONG nImageWidth, LONG nImageHeight );
    HRESULT       ExploreWiaDevice( LPCWSTR pszDeviceId );
    BOOL          ModifyComboBoxDropWidth( HWND hwndControl );
    void          SubclassComboBoxEx( HWND hWnd );
    HRESULT       IssueWiaCancelIO( IUnknown *pUnknown );
    HRESULT       VerifyScannerProperties( IUnknown *pUnknown );
    CSimpleString GetErrorTextFromHResult( HRESULT hr );
//
// End namespace WiaUiUtil
//
}


#endif // __MISCUTIL_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\miscutil.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       MISCUTIL.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        5/28/1998
 *
 *  DESCRIPTION: Various utility functions we use in more than one place
 *
 *******************************************************************************/

#include "precomp.h"
#pragma hdrstop
#include <advpub.h>  // For RegInstall and related data structures
#include <windowsx.h>  // For RegInstall and related data structures
#include "wiaffmt.h"
#include "shellext.h"

namespace WiaUiUtil
{

    LONG Align( LONG n , LONG m )
    {
        return(n % m) ? (((n/m)+1)*m) : (n);
    }

    /*
     * StringToLong: Convert a string to a long. ASCII Arabic numerals only
     */
    LONG StringToLong( LPCTSTR pszStr )
    {
        LPTSTR pstr = (LPTSTR)pszStr;
        bool bNeg = (*pstr == TEXT('-'));
        if (bNeg)
            pstr++;
        LONG nTotal = 0;
        while (*pstr && *pstr >= TEXT('0') && *pstr <= TEXT('9'))
        {
            nTotal *= 10;
            nTotal += *pstr - TEXT('0');
            ++pstr;
        }
        return(bNeg ? -nTotal : nTotal);
    }

    SIZE MapDialogSize( HWND hwnd, const SIZE &size )
    {
        RECT rcTmp;
        rcTmp.left = rcTmp.top = 0;
        rcTmp.right = size.cx;
        rcTmp.bottom = size.cy;
        MapDialogRect( hwnd, &rcTmp );
        SIZE sizeTmp;
        sizeTmp.cx = rcTmp.right;
        sizeTmp.cy = rcTmp.bottom;
        return (sizeTmp);
    }

    /*******************************************************************************
    *
    *  GetBmiSize
    *
    *  DESCRIPTION:
    *   Should never get biCompression == BI_RLE.
    *
    *  PARAMETERS:
    *
    *******************************************************************************/
    LONG GetBmiSize(PBITMAPINFO pbmi)
    {
        WIA_PUSH_FUNCTION((TEXT("WiaUiUtil::GetBmiSize(0x%p)"), pbmi ));
        // determine the size of bitmapinfo
        LONG lSize = pbmi->bmiHeader.biSize;

        // no color table cases
        if (
           (pbmi->bmiHeader.biBitCount == 24) ||
           ((pbmi->bmiHeader.biBitCount == 32) &&
            (pbmi->bmiHeader.biCompression == BI_RGB)))
        {

            // no colors unless stated
            lSize += sizeof(RGBQUAD) * pbmi->bmiHeader.biClrUsed;
            return(lSize);
        }

        // bitfields cases
        if (((pbmi->bmiHeader.biBitCount == 32) &&
             (pbmi->bmiHeader.biCompression == BI_BITFIELDS)) ||
            (pbmi->bmiHeader.biBitCount == 16))
        {

            lSize += 3 * sizeof(RGBQUAD);
            return(lSize);
        }

        // palette cases
        if (pbmi->bmiHeader.biBitCount == 1)
        {

            LONG lPal = pbmi->bmiHeader.biClrUsed;

            if ((lPal == 0) || (lPal > 2))
            {
                lPal = 2;
            }

            lSize += lPal * sizeof(RGBQUAD);
            return(lSize);
        }

        // palette cases
        if (pbmi->bmiHeader.biBitCount == 4)
        {

            LONG lPal = pbmi->bmiHeader.biClrUsed;

            if ((lPal == 0) || (lPal > 16))
            {
                lPal = 16;
            }

            lSize += lPal * sizeof(RGBQUAD);
            return(lSize);
        }

        // palette cases
        if (pbmi->bmiHeader.biBitCount == 8)
        {

            LONG lPal = pbmi->bmiHeader.biClrUsed;

            if ((lPal == 0) || (lPal > 256))
            {
                lPal = 256;
            }

            lSize += lPal * sizeof(RGBQUAD);
            return(lSize);
        }

        // error
        return(0);
    }

    // Simple wrapper for MsgWaitForMultipleObjects
    bool MsgWaitForSingleObject( HANDLE hHandle, DWORD dwMilliseconds )
    {
        bool bEventOccurred = false;
        const int nCount = 1;
        while (true)
        {
            DWORD dwRes = MsgWaitForMultipleObjects(nCount,&hHandle,FALSE,dwMilliseconds,QS_ALLINPUT|QS_ALLPOSTMESSAGE);
            if (WAIT_OBJECT_0==dwRes)
            {
                // The handle was signalled, so we can break out of our loop, returning true
                bEventOccurred = true;
                break;
            }
            else if (WAIT_OBJECT_0+nCount==dwRes)
            {
                // pull all of the messages out of the queue and process them
                MSG msg;
                while (PeekMessage( &msg, 0, 0, 0, PM_REMOVE ))
                {
                    if (msg.message == WM_QUIT)
                        break;
                    TranslateMessage(&msg);
                    DispatchMessage(&msg);
                }
            }
            else
            {
                // The handle either timed out, or the mutex was abandoned, so we can break out of our loop, returning false
                break;
            }
        }
        return bEventOccurred;
    }

    void CenterWindow( HWND hWnd, HWND hWndParent )
    {
        if (IsWindow(hWnd))
        {

            if (!hWndParent)
            {
                //
                // If the window to be centered on is NULL, use the desktop window
                //
                hWndParent = GetDesktopWindow();
            }
            else
            {
                //
                // If the window to be centered on is minimized, use the desktop window
                //
                DWORD dwStyle = GetWindowLong(hWndParent, GWL_STYLE);
                if (dwStyle & WS_MINIMIZE)
                {
                    hWndParent = GetDesktopWindow();
                }
            }

            //
            // Get the window rects
            //
            RECT rcParent, rcCurrent;
            GetWindowRect( hWndParent, &rcParent );
            GetWindowRect( hWnd, &rcCurrent );

            //
            // Get the desired coordinates for the upper-left hand corner
            //
            RECT rcFinal;
            rcFinal.left = rcParent.left + (RectWidth(rcParent) - RectWidth(rcCurrent))/2;
            rcFinal.top = rcParent.top + (RectHeight(rcParent) - RectHeight(rcCurrent))/2;
            rcFinal.right = rcFinal.left + RectWidth(rcCurrent);
            rcFinal.bottom = rcFinal.top + RectHeight(rcCurrent);

            //
            // Make sure we're not off the screen
            //
            HMONITOR hMonitor = MonitorFromRect( &rcFinal, MONITOR_DEFAULTTONEAREST );
            if (hMonitor)
            {
                MONITORINFO MonitorInfo;
                ZeroMemory( &MonitorInfo, sizeof(MonitorInfo) );
                MonitorInfo.cbSize = sizeof(MonitorInfo);
                //
                // Get the screen coordinates of this monitor
                //
                if (GetMonitorInfo(hMonitor, &MonitorInfo))
                {
                    //
                    // Ensure the window is in the working area's region
                    //
                    rcFinal.left = Max<int>(MonitorInfo.rcWork.left, Min<int>( MonitorInfo.rcWork.right - RectWidth(rcCurrent), rcFinal.left ));
                    rcFinal.top = Max<int>(MonitorInfo.rcWork.top, Min<int>( MonitorInfo.rcWork.bottom - RectHeight(rcCurrent), rcFinal.top ));
                }
            }

            // Move it
            SetWindowPos( hWnd, NULL, rcFinal.left, rcFinal.top, 0, 0, SWP_NOSIZE|SWP_NOACTIVATE|SWP_NOZORDER );
        }
    }


    // Flip an image horizontally
    bool FlipImage( PBYTE pBits, LONG nWidth, LONG nHeight, LONG nBitDepth )
    {
        bool bResult = false;
        if (pBits && nWidth>=0 && nHeight>=0 && nBitDepth>=0)
        {
            LONG nLineWidthInBytes = WiaUiUtil::Align(nWidth*nBitDepth,sizeof(DWORD)*8)/8;
            PBYTE pTempLine = new BYTE[nLineWidthInBytes];
            if (pTempLine)
            {
                for (int i=0;i<nHeight/2;i++)
                {
                    PBYTE pSrc = pBits + (i * nLineWidthInBytes);
                    PBYTE pDst = pBits + ((nHeight-i-1) * nLineWidthInBytes);
                    CopyMemory( pTempLine, pSrc, nLineWidthInBytes );
                    CopyMemory( pSrc, pDst, nLineWidthInBytes );
                    CopyMemory( pDst, pTempLine, nLineWidthInBytes );
                }
                bResult = true;
            }
            delete[] pTempLine;
        }
        return bResult;
    }

    HRESULT InstallInfFromResource( HINSTANCE hInstance, LPCSTR pszSectionName )
    {
        HRESULT hr;
        HINSTANCE hInstAdvPackDll = LoadLibrary(TEXT("ADVPACK.DLL"));
        if (hInstAdvPackDll)
        {
            REGINSTALL pfnRegInstall = reinterpret_cast<REGINSTALL>(GetProcAddress( hInstAdvPackDll, "RegInstall" ));
            if (pfnRegInstall)
            {
#if defined(WINNT)
                STRENTRY astrEntry[] =
                {
                    { "25", "%SystemRoot%"           },
                    { "11", "%SystemRoot%\\system32" }
                };
                STRTABLE strTable = { sizeof(astrEntry)/sizeof(astrEntry[0]), astrEntry };
                hr = pfnRegInstall(hInstance, pszSectionName, &strTable);
#else
                hr = pfnRegInstall(hInstance, pszSectionName, NULL);
#endif
            } else hr = HRESULT_FROM_WIN32(GetLastError());
            FreeLibrary(hInstAdvPackDll);
        } else hr = HRESULT_FROM_WIN32(GetLastError());
        return hr;
    }


    /******************************************************************************

    WriteDIBToFile

    Writes a DIB to a file.

    ******************************************************************************/
    HRESULT
    WriteDIBToFile( HBITMAP hDib, HANDLE hFile )
    {
        if (!hDib)
        {
            return E_INVALIDARG;
        }

        // Make sure this is a valid DIB and get this useful info.
        DIBSECTION ds;
        if (!GetObject( hDib, sizeof(DIBSECTION), &ds ))
        {
            return E_INVALIDARG;
        }

        // We only deal with DIBs
        if (ds.dsBm.bmPlanes != 1)
        {
            return E_INVALIDARG;
        }

        // Calculate some color table sizes
        int nColors = ds.dsBmih.biBitCount <= 8 ? 1 << ds.dsBmih.biBitCount : 0;
        int nBitfields = ds.dsBmih.biCompression == BI_BITFIELDS ? 3 : 0;

        // Calculate the data size
        int nImageDataSize = ds.dsBmih.biSizeImage ? ds.dsBmih.biSizeImage : ds.dsBm.bmWidthBytes * ds.dsBm.bmHeight;

        // Get the color table (if needed)
        RGBQUAD rgbqaColorTable[256] = {0};
        if (nColors)
        {
            HDC hDC = CreateCompatibleDC(NULL);
            if (hDC)
            {
                HBITMAP hOldBitmap = reinterpret_cast<HBITMAP>(SelectObject(hDC,hDib));
                GetDIBColorTable( hDC, 0, nColors, rgbqaColorTable );
                SelectObject(hDC,hOldBitmap);
                DeleteDC( hDC );
            }
        }

        // Create the file header
        BITMAPFILEHEADER bmfh;
        bmfh.bfType = 'MB';
        bmfh.bfSize = 0;
        bmfh.bfReserved1 = 0;
        bmfh.bfReserved2 = 0;
        bmfh.bfOffBits = sizeof(bmfh) + sizeof(ds.dsBmih) + nBitfields*sizeof(DWORD) + nColors*sizeof(RGBQUAD);

        // Start writing!  Note that we write out the bitfields and the color table.  Only one,
        // at most, will actually result in data being written
        DWORD dwBytesWritten;
        if (!WriteFile( hFile, &bmfh, sizeof(bmfh), &dwBytesWritten, NULL ))
            return HRESULT_FROM_WIN32(GetLastError());
        if (!WriteFile( hFile, &ds.dsBmih, sizeof(ds.dsBmih), &dwBytesWritten, NULL ))
            return HRESULT_FROM_WIN32(GetLastError());
        if (!WriteFile( hFile, &ds.dsBitfields, nBitfields*sizeof(DWORD), &dwBytesWritten, NULL ))
            return HRESULT_FROM_WIN32(GetLastError());
        if (!WriteFile( hFile, rgbqaColorTable, nColors*sizeof(RGBQUAD), &dwBytesWritten, NULL ))
            return HRESULT_FROM_WIN32(GetLastError());
        if (!WriteFile( hFile, ds.dsBm.bmBits, nImageDataSize, &dwBytesWritten, NULL ))
            return HRESULT_FROM_WIN32(GetLastError());
        return S_OK;
    }


    HFONT ChangeFontFromWindow( HWND hWnd, int nPointSizeDelta )
    {
        HFONT hFontResult = NULL;

        //
        // Get the window's font
        //
        HFONT hFont = GetFontFromWindow(hWnd);
        if (hFont)
        {
            LOGFONT LogFont = {0};
            if (GetObject( hFont, sizeof(LogFont), &LogFont ))
            {
                HDC hDC = GetDC(hWnd);
                if (hDC)
                {
                    HFONT hOldFont = SelectFont(hDC,hFont);
                    TEXTMETRIC TextMetric = {0};
                    if (GetTextMetrics( hDC, &TextMetric ))
                    {
                        //
                        // Get the current font's point size
                        //
                        int nPointSize = MulDiv( TextMetric.tmHeight-TextMetric.tmInternalLeading, 72, GetDeviceCaps(hDC, LOGPIXELSY) ) + nPointSizeDelta;

                        //
                        // Calculate the height of the new font
                        //
                        LogFont.lfHeight = -MulDiv(nPointSize, GetDeviceCaps(hDC, LOGPIXELSY), 72);

                        //
                        // Create the font
                        //
                        hFontResult = CreateFontIndirect( &LogFont );
                    }

                    if (hOldFont)
                    {
                        SelectFont( hDC, hOldFont );
                    }

                    ReleaseDC( hWnd, hDC );
                }
            }
        }
        return hFontResult;
    }

    HFONT GetFontFromWindow( HWND hWnd )
    {
        //
        // Get the window's font
        //
        HFONT hFontResult = reinterpret_cast<HFONT>(SendMessage(hWnd,WM_GETFONT,0,0));
        if (!hFontResult)
        {
            hFontResult = reinterpret_cast<HFONT>(GetStockObject(DEFAULT_GUI_FONT));
        }
        return hFontResult;
    }



    HFONT CreateFontWithPointSizeFromWindow( HWND hWnd, int nPointSize, bool bBold, bool bItalic )
    {
        HFONT hFontResult = NULL;
        HFONT hFont = GetFontFromWindow(hWnd);
        if (hFont)
        {
            LOGFONT LogFont = {0};
            if (GetObject( hFont, sizeof(LogFont), &LogFont ))
            {
                HDC hDC = GetDC(NULL);
                if (hDC)
                {
                    if (nPointSize)
                    {
                        LogFont.lfHeight = -MulDiv(nPointSize, GetDeviceCaps(hDC, LOGPIXELSY), 72);
                    }
                    if (bBold)
                    {
                        LogFont.lfWeight = FW_BOLD;
                    }
                    if (bItalic)
                    {
                        LogFont.lfItalic = TRUE;
                    }
                    hFontResult = CreateFontIndirect( &LogFont );
                    ReleaseDC( NULL, hDC );
                }
            }
        }
        return hFontResult;
    }

     /*******************************************************************************
     * FindLowestNumberedFile
     *
     * Returns lowest numbered file that can contain the requested series of file
     * name, or zero if it can't find such a range.
     *
     * pszFileAndPathnameMask should be a printf-style format string containing the
     * full path name to a file:
     *
     *  Example:  "C:\foo\bar\filename %03d.ext"
     *
     * It would check for the existence of:
     *
     *  "C:\foo\bar\filename 001.ext", "C:\foo\bar\filename 002.ext", etc...
     *
     * until it found a block large enough to hold nCount files.
     *
     *******************************************************************************/
    int FindLowestNumberedFile( LPCTSTR pszFileAndPathnameMask, int nCount, int nMax )
    {
        // Start at one (users never start counting at 0)
        int i=1;
        while (i<=nMax-nCount+1)
        {
            // Assume we'll be able to store the sequence
            bool bEnoughRoom = true;
            for (int j=0;j<nCount && bEnoughRoom;j++)
            {
                // Add a few bytes to the max len, just in case
                TCHAR szFile[MAX_PATH + 10];

                // Create the potential filename
                wsprintf( szFile, pszFileAndPathnameMask, i + j );

                // Look for this file
                WIN32_FIND_DATA FindFileData;
                ZeroMemory( &FindFileData, sizeof(FindFileData));
                HANDLE hFindFiles = FindFirstFile( szFile, &FindFileData );
                if (hFindFiles != INVALID_HANDLE_VALUE)
                {
                    FindClose(hFindFiles);

                    // Didn't make it
                    bEnoughRoom = false;

                    // Skip this series.  No need to start at the bottom.
                    i += j;
                }
            }
            // If we made it through, return the base number, otherwise increment by one
            if (bEnoughRoom)
                return i;
            else i++;
        }
        // We never found room...
        return -1;
    }

    /*******************************************************************************
     * FindLowestNumberedFile
     *
     * Returns lowest numbered file that can contain the requested series of file
     * name, or zero if it can't find such a range.
     *
     * pszFileAndPathnameMask should be a printf-style format string containing the
     * full path name to a file:
     *
     *  Example:  "C:\foo\bar\filename %03d.ext"
     *
     * It would check for the existence of:
     *
     *  "C:\foo\bar\filename 001.ext", "C:\foo\bar\filename 002.ext", etc...
     *
     * until it found a block large enough to hold nCount files.
     *
     *******************************************************************************/
    int FindLowestNumberedFile( LPCTSTR pszFileAndPathnameMaskPrefix, LPCTSTR pszFormatString, LPCTSTR pszFileAndPathnameMaskSuffix, int nCount, int nMax )
    {
        TCHAR szFilename[MAX_PATH];
        if (nCount == 1)
        {
            lstrcpyn( szFilename, pszFileAndPathnameMaskPrefix, ARRAYSIZE(szFilename) );
            lstrcpyn( szFilename+lstrlen(szFilename), pszFileAndPathnameMaskSuffix, ARRAYSIZE(szFilename)-lstrlen(szFilename) );
            if (GetFileAttributes(szFilename) == 0xFFFFFFFF)
                return 0;
        }

        // Use the normal method of calculating the lowest numbered file
        lstrcpyn( szFilename, pszFileAndPathnameMaskPrefix, ARRAYSIZE(szFilename) );
        lstrcpyn( szFilename+lstrlen(szFilename), pszFormatString, ARRAYSIZE(szFilename)-lstrlen(szFilename) );
        lstrcpyn( szFilename+lstrlen(szFilename), pszFileAndPathnameMaskSuffix, ARRAYSIZE(szFilename)-lstrlen(szFilename) );
        return FindLowestNumberedFile( szFilename, nCount, nMax );
    }


    SIZE GetTextExtentFromWindow( HWND hFontWnd, LPCTSTR pszString )
    {
        SIZE sizeResult = {0,0};
        HDC hDC = GetDC( hFontWnd );
        if (hDC)
        {
            HFONT hFont = GetFontFromWindow(hFontWnd);
            if (hFont)
            {
                HFONT hOldFont = SelectFont( hDC, hFont );

                SIZE sizeExtent = {0,0};
                if (GetTextExtentPoint32( hDC, pszString, lstrlen(pszString), &sizeExtent ))
                {
                    sizeResult = sizeExtent;
                }
                //
                // Restore the DC
                //
                if (hOldFont)
                {
                    SelectFont( hDC, hOldFont );
                }
            }
            ReleaseDC( hFontWnd, hDC );
        }
        return sizeResult;
    }

    CSimpleString TruncateTextToFitInRect( HWND hFontWnd, LPCTSTR pszString, RECT rectTarget, UINT nDrawTextFormat )
    {
        WIA_PUSH_FUNCTION((TEXT("WiaUiUtil::TruncateTextToFitInRect( 0x%p, %s, (%d,%d,%d,%d), 0x%08X"), hFontWnd, pszString, rectTarget.left, rectTarget.top, rectTarget.right, rectTarget.bottom, nDrawTextFormat ));
        CSimpleString strResult = pszString;

        //
        // Make sure we have valid parameters
        //
        if (IsWindow(hFontWnd) && hFontWnd && pszString && lstrlen(pszString))
        {
            //
            // Make a copy of the string.  If it fails, we will just return the original string.
            //
            LPTSTR pszTemp = new TCHAR[lstrlen(pszString)+1];
            if (pszTemp)
            {
                lstrcpy( pszTemp, pszString );

                //
                // Get a client DC for the window
                //
                HDC hDC = GetDC( hFontWnd );
                if (hDC)
                {
                    //
                    // Create a memory DC
                    //
                    HDC hMemDC = CreateCompatibleDC( hDC );
                    if (hMemDC)
                    {
                        //
                        // Get the font the window is using and select it into our client dc
                        //
                        HFONT hFont = GetFontFromWindow(hFontWnd);
                        if (hFont)
                        {
                            //
                            // Select the font
                            //
                            HFONT hOldFont = SelectFont( hMemDC, hFont );

                            //
                            // Modify the string using DrawText
                            //
                            if (DrawText( hMemDC, pszTemp, lstrlen(pszTemp), &rectTarget, nDrawTextFormat|DT_MODIFYSTRING|DT_SINGLELINE ))
                            {
                                strResult = pszTemp;
                            }
                            else
                            {
                                WIA_ERROR((TEXT("DrawText failed")));
                            }
                            //
                            // Restore the DC
                            //
                            if (hOldFont)
                            {
                                SelectFont( hMemDC, hOldFont );
                            }

                        }

                        //
                        // Clean up the memory DC
                        //
                        DeleteDC( hMemDC );
                    }
                    else
                    {
                        WIA_ERROR((TEXT("Unable to create the compatible DC")));
                    }

                    //
                    // Release the DC
                    //
                    ReleaseDC( hFontWnd, hDC );
                }
                else
                {
                    WIA_ERROR((TEXT("Unable to get the DC")));
                }

                //
                // Clean up our temp buffer
                //
                delete[] pszTemp;
            }
            else
            {
                WIA_ERROR((TEXT("Unable to allocate the temp buffer")));
            }
        }
        else
        {
            WIA_ERROR((TEXT("Argument validation failed")));
        }
        return strResult;
    }


    CSimpleString FitTextInStaticWithEllipsis( LPCTSTR pszString, HWND hWndStatic, UINT nDrawTextStyle )
    {
        //
        // Make sure we have valid parameters
        //
        if (!hWndStatic || !pszString || !IsWindow(hWndStatic))
        {
            return pszString;
        }

        //
        // Hide prefix characters?
        //
        if (GetWindowLong( hWndStatic, GWL_STYLE ) & SS_NOPREFIX)
        {
            nDrawTextStyle |= DT_NOPREFIX;
        }

        //
        // How big is the area we are trying to fit this in?
        //
        RECT rcClient;
        GetClientRect( hWndStatic, &rcClient );

        //
        // Calculate the result and return it
        //
        return TruncateTextToFitInRect( hWndStatic, pszString, rcClient, nDrawTextStyle );
    }

    //
    // Get the size of an icon
    //
    bool GetIconSize( HICON hIcon, SIZE &sizeIcon )
    {
        //
        // Assume failure
        //
        bool bSuccess = false;

        //
        // Get the icon information
        //
        ICONINFO IconInfo = {0};
        if (GetIconInfo( hIcon, &IconInfo ))
        {
            //
            // Get one of the bitmaps
            //
            BITMAP bm;
            if (GetObject( IconInfo.hbmColor, sizeof(bm), &bm ))
            {
                //
                // Save the size of the icon
                //
                sizeIcon.cx = bm.bmWidth;
                sizeIcon.cy = bm.bmHeight;

                //
                // Everything worked
                //
                bSuccess = true;
            }

            //
            // Free the bitmaps
            //
            DeleteObject(IconInfo.hbmMask);
            DeleteObject(IconInfo.hbmColor);
        }
        else
        {
            WIA_PRINTHRESULT((HRESULT_FROM_WIN32(GetLastError()),TEXT("GetIconInfo failed")));
        }

        return bSuccess;
    }

    HBITMAP CreateIconThumbnail( HWND hWnd, int nWidth, int nHeight, HICON hIcon, LPCTSTR pszText )
    {
        WIA_PUSH_FUNCTION((TEXT("CreateIconThumbnail( hWnd: 0x%p, nWidth: %d, nHeight: %d, hIcon: 0x%p, pszText: \"%s\" )"), hWnd, nWidth, nHeight, hIcon, pszText ? pszText : TEXT("") ));

        //
        // Initialize return value to NULL
        //
        HBITMAP hBmp = NULL;

        //
        // This will be set to true if all steps succeed.
        //
        bool bSuccess = false;

        //
        // The minimum whitespace around the icon and the text border
        //
        const int nIconBorder = 2;

        //
        // Get the DC to the window
        //
        HDC hDC = GetDC(hWnd);
        if (hDC)
        {
            //
            // Get a halftone palette
            //
            HPALETTE hHalftonePalette = CreateHalftonePalette(hDC);
            if (hHalftonePalette)
            {
                //
                // Initialize the bitmap information
                //
                BITMAPINFO BitmapInfo;
                ZeroMemory( &BitmapInfo, sizeof(BITMAPINFO) );
                BitmapInfo.bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
                BitmapInfo.bmiHeader.biWidth           = nWidth;
                BitmapInfo.bmiHeader.biHeight          = nHeight;
                BitmapInfo.bmiHeader.biPlanes          = 1;
                BitmapInfo.bmiHeader.biBitCount        = 24;
                BitmapInfo.bmiHeader.biCompression     = BI_RGB;

                //
                // Create the DIB section
                //
                PBYTE pBitmapData = NULL;
                hBmp = CreateDIBSection( hDC, &BitmapInfo, DIB_RGB_COLORS, (LPVOID*)&pBitmapData, NULL, 0 );
                if (hBmp)
                {
                    //
                    // Create the source dc
                    //
                    HDC hMemoryDC = CreateCompatibleDC( hDC );
                    if (hMemoryDC)
                    {
                        //
                        // Set up the palette
                        //
                        HPALETTE hOldPalette = SelectPalette( hMemoryDC, hHalftonePalette , 0 );
                        RealizePalette( hMemoryDC );
                        SetBrushOrgEx( hMemoryDC, 0,0, NULL );

                        //
                        // Set up the DC
                        //
                        int nOldBkMode = SetBkMode( hMemoryDC, TRANSPARENT );
                        COLORREF crOldTextColor = SetTextColor( hMemoryDC, GetSysColor(COLOR_WINDOWTEXT) );
                        DWORD dwOldLayout = SetLayout( hMemoryDC, LAYOUT_BITMAPORIENTATIONPRESERVED );

                        //
                        // Select the bitmap into the memory DC
                        //
                        HBITMAP hOldBitmap = reinterpret_cast<HBITMAP>(SelectObject( hMemoryDC, hBmp ));

                        //
                        // Get the font to use
                        //
                        HFONT hFont = GetFontFromWindow(hWnd);

                        //
                        // Select the font
                        //
                        HFONT hOldFont = reinterpret_cast<HFONT>(SelectObject( hMemoryDC, hFont ) );

                        //
                        // Ensure we have a valid icon
                        //
                        if (hIcon)
                        {
                            //
                            // Try to get the size of the icon
                            //
                            SIZE sizeIcon;
                            if (GetIconSize( hIcon, sizeIcon ))
                            {
                                //
                                // Fill the bitmap with the window color
                                //
                                RECT rc = { 0, 0, nWidth, nHeight };
                                FillRect( hMemoryDC, &rc, GetSysColorBrush( COLOR_WINDOW ) );

                                //
                                // Get the text height for one line of text
                                //
                                SIZE sizeText = {0};
                                if (pszText)
                                {
                                    GetTextExtentPoint32( hMemoryDC, TEXT("X"), 1, &sizeText );
                                }

                                //
                                // Center the icon + 1 line of text + margin in the thumbnail
                                // We are assuming this bitmap can actually hold an icon + text
                                //
                                int nIconTop = rc.top + (RectHeight(rc) - ( sizeIcon.cy + sizeText.cy + nIconBorder )) / 2;

                                //
                                // Draw the icon
                                //
                                DrawIconEx( hMemoryDC, (nWidth - sizeIcon.cx)/2, nIconTop, hIcon, sizeIcon.cx, sizeIcon.cy, 0, NULL, DI_NORMAL );

                                //
                                // Only compute text things if there's text to draw
                                //
                                if (pszText && *pszText)
                                {
                                    //
                                    // Decrease the rectangle's width by the icon border
                                    //
                                    InflateRect( &rc, -nIconBorder, 0 );

                                    //
                                    // Set the top of the text to the bottom of icon + the icon border
                                    //
                                    rc.top = nIconTop + sizeIcon.cy + nIconBorder;

                                    //
                                    // Draw the text
                                    //
                                    DrawTextEx( hMemoryDC, const_cast<LPTSTR>(pszText), -1, &rc, DT_CENTER|DT_END_ELLIPSIS|DT_NOPREFIX|DT_WORDBREAK, NULL );
                                }

                                //
                                // Everything worked OK
                                //
                                bSuccess = true;
                            }
                            else
                            {
                                WIA_ERROR((TEXT("Couldn't get an icon size")));
                            }

                        }
                        else
                        {
                            WIA_ERROR((TEXT("Didn't have a valid icon")));
                        }

                        //
                        // Restore the dc's state
                        //
                        SelectObject( hMemoryDC, hOldFont );
                        SelectObject( hMemoryDC, hOldBitmap );
                        SelectPalette( hMemoryDC, hOldPalette , 0 );
                        SetBkMode( hMemoryDC, nOldBkMode );
                        SetTextColor( hMemoryDC, crOldTextColor );
                        SetLayout( hMemoryDC, dwOldLayout );

                        //
                        // Delete the compatible DC
                        //
                        DeleteDC( hMemoryDC );

                    }
                    else
                    {
                        WIA_ERROR((TEXT("Unable to create a memory DC")));
                    }
                }
                else
                {
                    WIA_ERROR((TEXT("Unable to create a DIB section")));
                }

                //
                // Delete the halftone palette
                //
                if (hHalftonePalette)
                {
                    DeleteObject( hHalftonePalette );
                }
            }
            else
            {
                WIA_ERROR((TEXT("Unable to get a halftone palette")));
            }

            //
            // Release the client DC
            //
            ReleaseDC( hWnd, hDC );
        }
        else
        {
            WIA_ERROR((TEXT("Unable to get a DC")));
        }

        //
        // Clean up in the event of failure
        //
        if (!bSuccess)
        {
            if (hBmp)
            {
                DeleteObject(hBmp);
                hBmp = NULL;
            }
        }
        return hBmp;
    }
    //
    // Create a bitmap with an icon and optional text
    //
    HBITMAP CreateIconThumbnail( HWND hWnd, int nWidth, int nHeight, HINSTANCE hIconInstance, const CResId &resIconId, LPCTSTR pszText )
    {
        //
        // Assume failure
        //
        HBITMAP hBmp = NULL;

        //
        // Load the specified icon
        //
        HICON hIcon = (HICON)LoadImage( hIconInstance, resIconId.ResourceName(), IMAGE_ICON, 0, 0, LR_DEFAULTCOLOR );
        if (hIcon)
        {
            //
            // Create the thumbnail
            //
            hBmp = CreateIconThumbnail( hWnd, nWidth, nHeight, hIcon, pszText );

            //
            // Free the icon (even though MSDN doesn't mention this, it will result in a leak if you don't)
            //
            DestroyIcon(hIcon);
        }

        return hBmp;
    }

    HRESULT SaveWiaItemAudio( IWiaItem *pWiaItem, LPCTSTR pszBaseFilename, CSimpleString &strAudioFilename )
    {
        //
        // Check the arguments
        //
        if (!pWiaItem || !pszBaseFilename || !lstrlen(pszBaseFilename))
        {
            return E_INVALIDARG;
        }

        //
        // Get the audio data property, if present
        //
        CComPtr<IWiaPropertyStorage> pWiaPropertyStorage;
        HRESULT hr = pWiaItem->QueryInterface( IID_IWiaPropertyStorage, (void**)(&pWiaPropertyStorage) );
        if (SUCCEEDED(hr))
        {
            PROPVARIANT PropVar[3];
            PROPSPEC    PropSpec[3];

            PropSpec[0].ulKind = PRSPEC_PROPID;
            PropSpec[0].propid = WIA_IPC_AUDIO_DATA;

            PropSpec[1].ulKind = PRSPEC_PROPID;
            PropSpec[1].propid = WIA_IPC_AUDIO_AVAILABLE;

            PropSpec[2].ulKind = PRSPEC_PROPID;
            PropSpec[2].propid = WIA_IPC_AUDIO_DATA_FORMAT;

            hr = pWiaPropertyStorage->ReadMultiple( ARRAYSIZE(PropSpec), PropSpec, PropVar );
            if (SUCCEEDED(hr))
            {
                if (PropVar[1].lVal && PropVar[0].caub.cElems)
                {
                    TCHAR szFile[MAX_PATH + 4];
                    lstrcpyn( szFile, pszBaseFilename, ARRAYSIZE(szFile) );

                    //
                    // Figure out where the extension should go.
                    //
                    LPTSTR pszExtensionPoint = PathFindExtension(szFile);

                    //
                    // Replace the extension.  If the item specifies the clsid, use it.  Otherwise assume WAV
                    //
                    if (PropVar[2].vt == VT_CLSID && PropVar[2].puuid)
                    {
                        lstrcpy( pszExtensionPoint, TEXT(".") );
                        lstrcat( pszExtensionPoint, CWiaFileFormat::GetExtension(*PropVar[2].puuid) );
                    }
                    else
                    {
                        lstrcpy( pszExtensionPoint, TEXT(".") );
                        lstrcat( pszExtensionPoint, TEXT("wav") );
                    }

                    //
                    // Save the filename for the caller
                    //
                    strAudioFilename = szFile;

                    //
                    // Open the file and save the data to the file
                    //
                    HANDLE hFile = CreateFile( szFile, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
                    if (INVALID_HANDLE_VALUE != hFile)
                    {
                        DWORD dwBytesWritten;
                        if (WriteFile( hFile, PropVar[0].caub.pElems, PropVar[0].caub.cElems, &dwBytesWritten, NULL ))
                        {
                            // Success
                        }
                        else
                        {
                            hr = HRESULT_FROM_WIN32(GetLastError());
                        }
                        CloseHandle(hFile);
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                }
                else
                {
                    hr = E_FAIL;
                    WIA_PRINTHRESULT((hr,TEXT("There is no audio data")));
                }
                FreePropVariantArray( ARRAYSIZE(PropVar), PropVar );
            }
        }
        return hr;
    }

    bool IsDeviceCommandSupported( IWiaItem *pWiaItem, const GUID &guidCommand )
    {
        //
        // Assume failure
        //
        bool bResult = false;

        //
        // Make sure we have a valid item
        //
        if (pWiaItem)
        {
            //
            // Get the device capabilities enumerator
            //
            CComPtr<IEnumWIA_DEV_CAPS> pDeviceCapabilities;
            HRESULT hr = pWiaItem->EnumDeviceCapabilities( WIA_DEVICE_COMMANDS, &pDeviceCapabilities );
            if (SUCCEEDED(hr))
            {
                //
                // Enumerate the capabilities
                //
                WIA_DEV_CAP WiaDeviceCapability;
                while (!bResult && S_OK == pDeviceCapabilities->Next(1, &WiaDeviceCapability, NULL))
                {
                    //
                    // If we have a match, set the return value to true
                    //
                    if (guidCommand == WiaDeviceCapability.guid)
                    {
                        bResult = true;
                    }

                    //
                    // Clean up the allocated data in the dev caps structure
                    //
                    if (WiaDeviceCapability.bstrName)
                    {
                        SysFreeString(WiaDeviceCapability.bstrName);
                    }
                    if (WiaDeviceCapability.bstrDescription)
                    {
                        SysFreeString(WiaDeviceCapability.bstrDescription);
                    }
                    if (WiaDeviceCapability.bstrIcon)
                    {
                        SysFreeString(WiaDeviceCapability.bstrIcon);
                    }
                    if (WiaDeviceCapability.bstrCommandline)
                    {
                        SysFreeString(WiaDeviceCapability.bstrCommandline);
                    }
                }
            }
        }

        return bResult;
    }

    HRESULT StampItemTimeOnFile( IWiaItem *pWiaItem, LPCTSTR pszFilename )
    {
        if (!pWiaItem || !pszFilename || !lstrlen(pszFilename))
        {
            return E_INVALIDARG;
        }
        //
        // All this, just to set the stinking file time...
        // Allows for the possibility of using a VT_FILETIME
        // just in case we ever make the intelligent decision
        // to support VT_FILETIME
        //
        CComPtr<IWiaPropertyStorage> pWiaPropertyStorage;
        HRESULT hr = pWiaItem->QueryInterface( IID_IWiaPropertyStorage, (void **)&pWiaPropertyStorage );
        if (SUCCEEDED(hr))
        {
            //
            // Get the file time
            //
            PROPSPEC PropSpec[1] = {0};
            PROPVARIANT PropVar[1] = {0};

            PropSpec[0].ulKind = PRSPEC_PROPID;
            PropSpec[0].propid = WIA_IPA_ITEM_TIME;
            hr = pWiaPropertyStorage->ReadMultiple( ARRAYSIZE(PropSpec), PropSpec, PropVar );
            if (SUCCEEDED(hr))
            {
                //
                // Check to see if we are using a SYSTEMTIME structure
                //
                if (PropVar[0].vt > VT_NULL &&  PropVar[0].caub.pElems && PropVar[0].caub.cElems >= (sizeof(SYSTEMTIME)>>1))
                {
                    //
                    // Convert the systemtime to a local filetime
                    //
                    FILETIME FileTimeLocal;
                    if (SystemTimeToFileTime( reinterpret_cast<SYSTEMTIME*>(PropVar[0].caub.pElems), &FileTimeLocal ))
                    {
                        //
                        // Convert the local filetime to a UTC filetime
                        //
                        FILETIME FileTimeUTC;
                        if (LocalFileTimeToFileTime( &FileTimeLocal, &FileTimeUTC ))
                        {
                            //
                            // Open the file handle
                            //
                            HANDLE hFile = CreateFile( pszFilename, GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
                            if (INVALID_HANDLE_VALUE != hFile)
                            {
                                //
                                // Set the file creation time
                                //
                                if (!SetFileTime( hFile, &FileTimeUTC, NULL, NULL ))
                                {
                                    hr = HRESULT_FROM_WIN32(GetLastError());
                                    WIA_PRINTHRESULT((hr,TEXT("SetFileTime failed")));
                                }
                                CloseHandle( hFile );
                            }
                            else
                            {
                                hr = HRESULT_FROM_WIN32(GetLastError());
                                WIA_PRINTHRESULT((hr,TEXT("CreateFile failed")));
                            }
                        }
                        else
                        {
                            hr = HRESULT_FROM_WIN32(GetLastError());
                            WIA_PRINTHRESULT((hr,TEXT("FileTimeToLocalFileTime failed")));
                        }
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        WIA_PRINTHRESULT((hr,TEXT("SystemTimeToFileTime failed")));
                    }
                }
                else if (VT_FILETIME == PropVar[0].vt)
                {
                    //
                    // Convert the local filetime to a UTC filetime
                    //
                    FILETIME FileTimeUTC;
                    if (LocalFileTimeToFileTime( &PropVar[0].filetime, &FileTimeUTC ))
                    {
                        //
                        // Open the file handle
                        //
                        HANDLE hFile = CreateFile( pszFilename, GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
                        if (INVALID_HANDLE_VALUE != hFile)
                        {
                            //
                            // Set the file creation time
                            //
                            if (!SetFileTime( hFile, &FileTimeUTC, NULL, NULL ))
                            {
                                hr = HRESULT_FROM_WIN32(GetLastError());
                                WIA_PRINTHRESULT((hr,TEXT("SetFileTime failed")));
                            }
                            CloseHandle( hFile );
                        }
                        else
                        {
                            hr = HRESULT_FROM_WIN32(GetLastError());
                            WIA_PRINTHRESULT((hr,TEXT("CreateFile failed")));
                        }
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                        WIA_PRINTHRESULT((hr,TEXT("FileTimeToLocalFileTime failed")));
                    }
                }
                else
                {
                    hr = E_FAIL;
                    WIA_PRINTHRESULT((hr,TEXT("The time property is invalid")));
                }
            }
            else
            {
                WIA_ERROR((TEXT("ReadMultiple on WIA_IPA_ITEM_TIME failed")));
            }
        }
        else
        {
            WIA_ERROR((TEXT("QueryInterface on IWiaPropertyStorage failed")));
        }
        return hr;
    }


    HRESULT MoveOrCopyFile( LPCTSTR pszSrc, LPCTSTR pszTgt )
    {
        WIA_PUSH_FUNCTION((TEXT("CDownloadImagesThreadMessage::MoveOrCopyFile( %s, %s )"), pszSrc, pszTgt ));
        //
        // Verify the arguments
        //
        if (!pszSrc || !pszTgt || !lstrlen(pszSrc) || !lstrlen(pszTgt))
        {
            return E_INVALIDARG;
        }

        //
        // Assume everything worked ok
        //
        HRESULT hr = S_OK;

        //
        // First try to move the file, since that will be lots faster
        //
        if (!MoveFile( pszSrc, pszTgt ))
        {
            //
            // If moving the file failed, try to copy it and the delete it
            //
            if (CopyFile( pszSrc, pszTgt, FALSE ))
            {
                //
                // We are going to ignore failures from DeleteFile.  It is possible the file is legitimately in
                // use, and there is probably no need to fail the entire operation because of this.
                //
                if (!DeleteFile( pszSrc ))
                {
                    WIA_PRINTHRESULT((HRESULT_FROM_WIN32(GetLastError()),TEXT("DeleteFile failed.  Ignoring failure.")));
                }
                //
                // Everything worked OK
                //
                hr = S_OK;
            }
            else
            {
                //
                // This is where we catch the main errors
                //
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }
        return hr;
    }

    CSimpleString CreateTempFileName( UINT nId )
    {
        //
        // Initialize the return value to an empty string
        //
        CSimpleString strResult(TEXT(""));

        //
        // Get the temp folder path
        //
        TCHAR szTempDirectory[MAX_PATH] = {0};
        DWORD dwResult = GetTempPath( ARRAYSIZE(szTempDirectory), szTempDirectory );
        if (dwResult)
        {
            //
            // Make sure the path length didn't exceed the buffer we allocated on the stack
            //
            if (ARRAYSIZE(szTempDirectory) >= dwResult)
            {
                //
                // Get the temp file name
                //
                TCHAR szFileName[MAX_PATH] = {0};
                if (GetTempFileName( szTempDirectory, TEXT("scw"), nId, szFileName ))
                {
                    //
                    // Save the filename
                    //
                    strResult = szFileName;
                }
            }
        }

        //
        // Return the result.  An e mpty string denotes an error.
        //
        return strResult;
    }

    bool CanWiaImageBeSafelyRotated( const GUID &guidFormat, LONG nImageWidth, LONG nImageHeight )
    {
        WIA_PUSH_FUNCTION((TEXT("WiaUiUtil::CanWiaImageBeSafelyRotated( guidFormat, %d, %d )"), nImageWidth, nImageHeight ));
        WIA_PRINTGUID((guidFormat,TEXT("guidFormat")));

        //
        // These are the image types we can possibly rotate (there may be exceptions below)
        //
        static const GUID *guidSafeFormats[] = { &WiaImgFmt_BMP, &WiaImgFmt_JPEG, &WiaImgFmt_PNG, &WiaImgFmt_GIF };

        //
        // Search for this image type
        //
        for (int i=0;i<ARRAYSIZE(guidSafeFormats);i++)
        {
            //
            // If we've found it
            //
            if (*guidSafeFormats[i] == guidFormat)
            {
                //
                // Handle exceptions to the rule
                //
                if (guidFormat == WiaImgFmt_JPEG)
                {
                    //
                    // We can't do lossless rotation on JPG images that are not even multiples of 16 in size
                    //
                    if ((nImageWidth % 16) || (nImageHeight % 16))
                    {
                        WIA_TRACE((TEXT("This image is not valid for rotation because it is not an even multiple of 16")));
                        return false;
                    }
                }

                //
                // If none of the exceptions applied, return TRUE
                //
                WIA_TRACE((TEXT("Returning true")));
                return true;
            }
        }

        //
        // If it is not known that we CAN rotate, we report false
        //
        WIA_TRACE((TEXT("Format type not found in safe list")));
        return false;
    }

    HRESULT ExploreWiaDevice( LPCWSTR pszDeviceId )
    {
        HRESULT hr;

        //
        // Make sure we have a valid device id
        //
        if (!pszDeviceId || !lstrlenW(pszDeviceId))
        {
            return E_INVALIDARG;
        }

        //
        // Load the shell extension's dll
        //
        HINSTANCE hInstWiaShellDll = LoadLibrary(TEXT("WIASHEXT.DLL"));
        if (hInstWiaShellDll)
        {
            //
            // Get the function that creates pidls
            //
            WIAMAKEFULLPIDLFORDEVICE pfnMakeFullPidlForDevice = reinterpret_cast<WIAMAKEFULLPIDLFORDEVICE>(GetProcAddress(hInstWiaShellDll, "MakeFullPidlForDevice"));
            if (pfnMakeFullPidlForDevice)
            {
                //
                // Get the device PIDL
                //
                LPITEMIDLIST pidlDevice = NULL;
                hr = pfnMakeFullPidlForDevice( const_cast<LPWSTR>(pszDeviceId), &pidlDevice );
                if (SUCCEEDED(hr))
                {
                    //
                    // First, ask the shell to refresh any active views
                    //
                    SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_IDLIST, pidlDevice, 0);

                    //
                    // Now show the folder
                    //
                    SHELLEXECUTEINFO ShellExecuteInfo = {0};
                    ShellExecuteInfo.cbSize   = sizeof(ShellExecuteInfo);
                    ShellExecuteInfo.fMask    = SEE_MASK_IDLIST;
                    ShellExecuteInfo.nShow    = SW_SHOW;
                    ShellExecuteInfo.lpIDList = pidlDevice;
                    if (ShellExecuteEx( &ShellExecuteInfo ))
                    {
                        hr = S_OK;
                    }

                    //
                    // Free the pidl
                    //
                    LPMALLOC pMalloc = NULL;
                    if (SUCCEEDED(SHGetMalloc(&pMalloc)) && pMalloc)
                    {
                        pMalloc->Free(pidlDevice);
                        pMalloc->Release();
                    }
                }
            }
            else
            {
                hr = E_FAIL;
            }

            //
            // Unload the DLL
            //
            FreeLibrary( hInstWiaShellDll );
        }
        else
        {
            //
            // Can't load the DLL
            //
            hr = E_FAIL;
        }

        return hr;
    }

    //
    // Modify a combo box's drop down list so that it is
    // long enough to store the longest string in the list
    // Taken from TaoYuan's code in photowiz.dll and modified
    // to handle ComboBoxEx32 controls
    //
    BOOL ModifyComboBoxDropWidth( HWND hWndCombobox )
    {
        //
        // Make sure we have a valid window
        //
        if (!hWndCombobox)
        {
            return FALSE;
        }

        //
        // Find out how many items are in the combobox.  If there are none, don't bother resizing.
        //
        LRESULT lRes = SendMessage( hWndCombobox, CB_GETCOUNT, 0, 0 );
        if (lRes <= 0)
        {
            return FALSE;
        }
        UINT nCount = static_cast<UINT>(lRes);

        //
        // We only work with fixed-height comboboxes
        //
        lRes = SendMessage( hWndCombobox, CB_GETITEMHEIGHT, 0, 0 );
        if (lRes < 0)
        {
            return FALSE;
        }
        UINT nItemHeight = static_cast<UINT>(lRes);

        //
        // We will be going through to figure out the desired size of the drop down list
        //
        UINT nDesiredWidth = 0;

        //
        // Add the size of the scrollbar to the desired witdth, of there is one
        //
        RECT rcDropped = {0};
        SendMessage( hWndCombobox, CB_GETDROPPEDCONTROLRECT, 0, reinterpret_cast<LPARAM>(&rcDropped) );

        //
        // Get the size of the control's window
        //
        RECT rcWnd = {0};
        GetWindowRect( hWndCombobox, &rcWnd );


        //
        // If not all of the items will fit in the dropped list,
        // we have to account for a vertical scrollbar
        //
        if (((WiaUiUtil::RectHeight(rcDropped) - GetSystemMetrics(SM_CYEDGE)*2) / nItemHeight) < nCount)
        {
            nDesiredWidth += GetSystemMetrics(SM_CXEDGE)*2 + GetSystemMetrics( SM_CXVSCROLL );
        }

        //
        // Find the widest string
        //
        LONG nMaxStringLen = 0;
        HDC hDC = GetDC( hWndCombobox );
        if (hDC)
        {
            //
            // Use the control's font
            //
            HFONT hOldFont = NULL, hFont = reinterpret_cast<HFONT>(SendMessage(hWndCombobox,WM_GETFONT,0,0));
            if (hFont)
            {
                hOldFont = SelectFont( hDC, hFont );
            }

            for (UINT i = 0; i < nCount; i++ )
            {
                //
                // Get the length of this item's text
                //
                LRESULT nLen = SendMessage( hWndCombobox, CB_GETLBTEXTLEN, i, 0 );
                if (nLen > 0)
                {
                    //
                    // Allocate a buffer for the string
                    //
                    LPTSTR pszItem = new TCHAR[nLen+1];
                    if (pszItem)
                    {
                        //
                        // Get the string
                        //
                        pszItem[0] = TEXT('\0');
                        if (SendMessage( hWndCombobox, CB_GETLBTEXT, i, reinterpret_cast<LPARAM>(pszItem) ) > 0)
                        {
                            //
                            // Measure it
                            //
                            SIZE sizeText = {0};
                            if (GetTextExtentPoint32( hDC, pszItem, lstrlen( pszItem ), &sizeText ))
                            {
                                //
                                // If this is the longest one, save its length
                                //
                                if (sizeText.cx > nMaxStringLen)
                                {
                                    nMaxStringLen = sizeText.cx;
                                }
                            }
                        }

                        //
                        // Free the string
                        //
                        delete[] pszItem;
                    }
                }
            }

            //
            // Restore and release the DC
            //
            if (hOldFont)
            {
                SelectFont( hDC, hOldFont );
            }
            ReleaseDC( hWndCombobox, hDC );
        }
        //
        // Add in the longest string's length
        //
        nDesiredWidth += nMaxStringLen;


        //
        // If this is a ComboBoxEx32, add in the width of the icon
        //
        TCHAR szClassName[MAX_PATH] = {0};
        if (GetClassName( hWndCombobox, szClassName, ARRAYSIZE(szClassName)))
        {
            //
            // Compare the classname with ComboBoxEx32
            //
            if (!lstrcmp(szClassName,WC_COMBOBOXEX))
            {
                //
                // Get the image list from the control
                //
                HIMAGELIST hImageList = reinterpret_cast<HIMAGELIST>(SendMessage( hWndCombobox, CBEM_GETIMAGELIST, 0, 0 ));
                if (hImageList)
                {
                    //
                    // Get the width and add it to the desired size
                    //
                    INT nWidth=0, nHeight=0;
                    if (ImageList_GetIconSize( hImageList, &nWidth, &nHeight ))
                    {
                        //
                        // I don't know what the margin should be, but nWidth*2
                        // should account for the width of icon and its margin
                        //
                        nDesiredWidth += nWidth * 2;
                    }
                }
            }
        }

        //
        // Add in the border of the control
        //
        nDesiredWidth += GetSystemMetrics(SM_CXFIXEDFRAME)*2;

        //
        // Make sure our drop down is no wider than the current monitor
        //
        HMONITOR hMonitor = MonitorFromWindow( hWndCombobox, MONITOR_DEFAULTTONEAREST );
        if (hMonitor)
        {
            MONITORINFO MonitorInfo = {0};
            MonitorInfo.cbSize = sizeof(MonitorInfo);
            //
            // Get the screen coordinates of this monitor
            //
            if (GetMonitorInfo(hMonitor, &MonitorInfo))
            {
                //
                // If the desired width is larger than the monitor, shorten it
                //
                if (nDesiredWidth > static_cast<UINT>(WiaUiUtil::RectWidth(MonitorInfo.rcMonitor)))
                {
                    nDesiredWidth = RectWidth(MonitorInfo.rcMonitor);
                }
            }
        }


        //
        // If our size is smaller than the control's current size, grow it
        //
        if (static_cast<UINT>(WiaUiUtil::RectWidth(rcDropped)) < nDesiredWidth)
        {
            //
            // Disable redrawing
            //
            SendMessage( hWndCombobox, WM_SETREDRAW, FALSE, 0 );


            SendMessage( hWndCombobox, CB_SETDROPPEDWIDTH, static_cast<WPARAM>(nDesiredWidth), 0 );

            //
            // Allow redrawing
            //
            SendMessage( hWndCombobox, WM_SETREDRAW, TRUE, 0 );

            //
            // Force a repaint
            //
            InvalidateRect( hWndCombobox, NULL, FALSE );
            UpdateWindow( hWndCombobox );

            //
            // TRUE means we actually changed it
            //
            return TRUE;
        }

        return FALSE;
    }

    static LPCTSTR s_pszComboBoxExWndProcPropName = TEXT("WiaComboBoxExWndProcPropName");

    static LRESULT WINAPI ComboBoxExWndProc( HWND hWnd, UINT nMsg, WPARAM wParam, LPARAM lParam )
    {
        static WNDPROC s_pfnDefProc = NULL;

        WNDPROC pfnWndProc = reinterpret_cast<WNDPROC>(GetProp( hWnd, s_pszComboBoxExWndProcPropName ));

        if (!s_pfnDefProc)
        {
            WNDCLASS wc = {0};
            GetClassInfo( GetModuleHandle(TEXT("user32.dll")), TEXT("ComboBox"), &wc );
            s_pfnDefProc = wc.lpfnWndProc;
        }
        if (nMsg == WM_LBUTTONDOWN || nMsg == WM_RBUTTONDOWN)
        {
            if (s_pfnDefProc)
            {
                return CallWindowProc( s_pfnDefProc, hWnd, nMsg, wParam, lParam );
            }
        }
        if (nMsg == WM_DESTROY)
        {
            RemoveProp( hWnd, s_pszComboBoxExWndProcPropName );
        }
        if (pfnWndProc)
        {
            return CallWindowProc( pfnWndProc, hWnd, nMsg, wParam, lParam );
        }
        else
        {
            return CallWindowProc( DefWindowProc, hWnd, nMsg, wParam, lParam );
        }
    }

    //
    // This subclasses the ComboBoxEx32 to work around a bug
    // that causes the list to drop down at bad times.
    // Uses a window property to store the previous wndproc.
    // Taken from DavidShi's code in wiashext.dll
    //
    void SubclassComboBoxEx( HWND hWnd )
    {
        HWND hComboBox = FindWindowEx( hWnd, NULL, TEXT("ComboBox"), NULL );
        if (hComboBox)
        {
            LONG_PTR pfnOldWndProc = SetWindowLongPtr( hComboBox, GWLP_WNDPROC, reinterpret_cast<LONG_PTR>(ComboBoxExWndProc));
            SetProp( hComboBox, s_pszComboBoxExWndProcPropName, reinterpret_cast<HANDLE>(pfnOldWndProc) );
        }
    }

    HRESULT IssueWiaCancelIO( IUnknown *pUnknown )
    {
        if (!pUnknown)
        {
            return E_POINTER;
        }

        CComPtr<IWiaItemExtras> pWiaItemExtras;
        HRESULT hr = pUnknown->QueryInterface( IID_IWiaItemExtras, (void**)&pWiaItemExtras );
        if (SUCCEEDED(hr))
        {
            hr = pWiaItemExtras->CancelPendingIO();
        }
        return hr;
    }


    HRESULT VerifyScannerProperties( IUnknown *pUnknown )
    {
        HRESULT hr = E_FAIL;

        //
        // Table of required properties
        //
        static const PROPID s_RequiredProperties[] =
        {
            WIA_IPS_CUR_INTENT
        };

        //
        // Make sure we have a valid item
        //
        if (pUnknown)
        {
            //
            // Assume success at this point
            //
            hr = S_OK;

            //
            // Get the IWiaPropertyStorage interface
            //
            CComPtr<IWiaPropertyStorage> pWiaPropertyStorage;
            hr = pUnknown->QueryInterface(IID_IWiaPropertyStorage, (void**)&pWiaPropertyStorage);
            if (SUCCEEDED(hr))
            {
                //
                // Loop through each property and make sure it exists
                // Break out if hr != S_OK
                //
                for (int i=0;i<ARRAYSIZE(s_RequiredProperties) && S_OK==hr;i++)
                {
                    //
                    // Prepare the propspec
                    //
                    PROPSPEC PropSpec = {0};
                    PropSpec.ulKind = PRSPEC_PROPID;
                    PropSpec.propid = s_RequiredProperties[i];

                    //
                    // Attempt to get the property attributes
                    //
                    ULONG nAccessFlags = 0;
                    PROPVARIANT PropVariant = {0};
                    hr = pWiaPropertyStorage->GetPropertyAttributes( 1, &PropSpec, &nAccessFlags, &PropVariant );
                    if (SUCCEEDED(hr))
                    {
                        //
                        // Prevent a leak
                        //
                        PropVariantClear(&PropVariant);

                        //
                        // If everything is OK so far
                        //
                        if (S_OK == hr)
                        {
                            //
                            // Zero out the structure
                            //
                            PropVariantInit(&PropVariant);

                            //
                            // Attempt to read the actual value
                            //
                            hr = pWiaPropertyStorage->ReadMultiple( 1, &PropSpec, &PropVariant );
                            if (SUCCEEDED(hr))
                            {
                                //
                                // Free the actual value
                                //
                                PropVariantClear(&PropVariant);
                            }
                        }
                    }
                }
            }
        }

        //
        // S_FALSE means a property doesn't exist, so change this to an error
        //
        if (S_FALSE == hr)
        {
            hr = E_FAIL;
        }

        //
        // All done
        //
        return hr;
    }

    CSimpleString GetErrorTextFromHResult( HRESULT hr )
    {
        CSimpleString strResult;
        LPTSTR szErrMsg = NULL;
        FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,
                       NULL,
                       hr,
                       MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                       reinterpret_cast<LPTSTR>(&szErrMsg),
                       0,
                       NULL
                      );
        if (szErrMsg)
        {
            strResult = szErrMsg;
            LocalFree( szErrMsg );
        }
        return strResult;
    }

} // End namespace WiaUiUtil
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\movewnd.h ===
#ifndef __MOVEWND_H_INCLUDED
#define __MOVEWND_H_INCLUDED

/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       MOVEWND.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        7/31/1999
 *
 *  DESCRIPTION: Simplified Wrapper for DeferWindowPos, plus a couple helpers
 *
 *  To use:
 *
 *  CMoveWindow mw;
 *  mw.MoveWindow( hWnd1, x1, y1, w1, h1, flags1 );
 *  mw.MoveWindow( hWnd2, x2, y2, w2, h2, flags2 );
 *  mw.Apply();  // Optional, the destructor will do this if necessary.
 *
 *******************************************************************************/

#include <windows.h>

class CMoveWindow
{
public:

    // Move/Size Flags
    enum
    {
        NO_MOVEX = 0x00000001,
        NO_MOVEY = 0x00000002,
        NO_MOVE  = (NO_MOVEX|NO_MOVEY),
        NO_SIZEX = 0x00000004,
        NO_SIZEY = 0x00000008,
        NO_SIZE  = (NO_SIZEX|NO_SIZEY)
    };

private:
    // Not implemented
    CMoveWindow( const CMoveWindow & );
    CMoveWindow &operator=( const CMoveWindow & );

private:
    HDWP m_hDeferWindowPos;
    bool m_bNeedApply;

public:
    CMoveWindow( int nNumWindows = 10 )
    : m_bNeedApply(false)
    {
        Initialize(nNumWindows);
    }
    bool Initialize( int nNumWindows = 10 )
    {
        m_hDeferWindowPos = BeginDeferWindowPos(nNumWindows);
        return(m_hDeferWindowPos != NULL);
    }
    static bool ScreenToClient( HWND hwnd, RECT &rc )
    {
        return (MapWindowPoints( NULL, hwnd, reinterpret_cast<POINT*>(&rc), 2 ) != 0);
    }
    void Move( HWND hWnd, int x, int y, DWORD nFlags = 0 )
    {
        SizeMove( hWnd, x, y, 0, 0, NO_SIZE|nFlags );
    }
    void Size( HWND hWnd, int w, int h, DWORD nFlags = 0 )
    {
        SizeMove( hWnd, 0, 0, w, h, NO_MOVE|nFlags );
    }
    void SizeMove( HWND hWnd, int x, int y, int w, int h, DWORD nFlags = 0 )
    {
        m_bNeedApply = true;

        RECT rcWndInScreenCoords, rcWndInParentCoords;
        GetWindowRect( hWnd, &rcWndInScreenCoords );

        rcWndInParentCoords = rcWndInScreenCoords;
        HWND hWndParent = GetParent(hWnd);
        if (hWndParent)
        {
            ScreenToClient( hWndParent, rcWndInParentCoords );
        }

        if (m_hDeferWindowPos)
        {
            DeferWindowPos( m_hDeferWindowPos, hWnd, NULL,
                            nFlags&NO_MOVEX ? rcWndInParentCoords.left : x,
                            nFlags&NO_MOVEY ? rcWndInParentCoords.top : y,
                            nFlags&NO_SIZEX ? rcWndInParentCoords.right - rcWndInParentCoords.left : w,
                            nFlags&NO_SIZEY ? rcWndInParentCoords.bottom - rcWndInParentCoords.top : h,
                            SWP_NOACTIVATE|SWP_NOZORDER
                          );
        }
    }
    void Hide( HWND hWnd )
    {
        if (IsWindowVisible(hWnd))
        {
            ShowWindow( hWnd, SW_HIDE );
        }
    }
    void Show( HWND hWnd )
    {
        if (!IsWindowVisible(hWnd))
        {
            ShowWindow( hWnd, SW_SHOW );
        }
    }
    void Enable( HWND hWnd )
    {
        if (!IsWindowEnabled(hWnd))
        {
            ShowWindow( hWnd, TRUE );
        }
    }
    void Disable( HWND hWnd )
    {
        if (IsWindowEnabled(hWnd))
        {
            ShowWindow( hWnd, FALSE );
        }
    }
    void Apply(void)
    {
        if (m_bNeedApply && m_hDeferWindowPos)
        {
            EndDeferWindowPos(m_hDeferWindowPos);
            m_hDeferWindowPos = NULL;
        }
    }
    ~CMoveWindow(void)
    {
        Apply();
    }
};


#endif // __MOVEWND_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\precomp.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999
 *
 *  TITLE:       precomp.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        5/12/99
 *
 *  DESCRIPTION: Precompiled header file for common UI library
 *
 *****************************************************************************/

#ifndef _pch_h
#define _pch_h


#include <windows.h>
#include <sti.h>
#include <commctrl.h>
#include <atlbase.h>
#include <propidl.h>
#include "wia.h"
#include "uicommon.h"
#include "simcrack.h"
#include "simarray.h"
#include "simreg.h"
#include "wiadebug.h"
#include "miscutil.h"
#include "proparry.h"
#include "pshelper.h"
#include "rescale.h"
#include "resid.h"
#include <shfusion.h>

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\modlock.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999, 2000
 *
 *  TITLE:       MODLOCK.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        12/9/1999
 *
 *  DESCRIPTION: Helpers to allow passing lock functions around
 *
 *******************************************************************************/
#ifndef __MODLOCK_H_INCLUDED
#define __MODLOCK_H_INCLUDED

typedef void (__stdcall *ModuleLockFunction)(void);
typedef void (__stdcall *ModuleUnlockFunction)(void);

extern void DllAddRef(void);
extern void DllRelease(void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\multistr.h ===
#ifndef __MULTISTR_H
#define __MULTISTR_H

#include "simarray.h"
#include "simstr.h"

// Must be instantiated with an instance of CSimpleStringBase
template <class T, class M>
class CMultiStringBase : public CSimpleDynamicArray<M>
{
public:
    CMultiStringBase( const CMultiStringBase &other )
    {
        Append(other);
    }
    CMultiStringBase( const T *pstrMultiString = NULL )
    {
        for (T *pstrCurrent = const_cast<T*>(pstrMultiString); pstrCurrent && *pstrCurrent; pstrCurrent += M(pstrCurrent).Length() + 1)
            Append(pstrCurrent);
    }
    virtual ~CMultiStringBase(void)
    {
    }
    CMultiStringBase &operator=( const CMultiStringBase &other )
    {
        Destroy();
        Append(other);
        return (*this);
    }
};

typedef CMultiStringBase<TCHAR,CSimpleString> CMultiString;
typedef CMultiStringBase<WCHAR,CSimpleStringWide> CMultiStringWide;
typedef CMultiStringBase<CHAR,CSimpleStringAnsi> CMultiStringAnsi;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\proparry.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       PROPARRY.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        5/4/1999
 *
 *  DESCRIPTION: IWiaPropertyStorage cache declarations
 *
 *******************************************************************************/
#ifndef __PROPARRY_H_INCLUDED
#define __PROPARRY_H_INCLUDED

#include <windows.h>
#include <objbase.h>
#include "wia.h"
#include "simstr.h"

class CPropertyStorageArray
{
private:
    int          m_nCount;
    PROPSPEC    *m_ppsPropSpecs;
    LPWSTR      *m_pstrPropNames;
    PROPVARIANT *m_ppvPropVariants;
public:
    CPropertyStorageArray( const CPropertyStorageArray &other );
    CPropertyStorageArray(IUnknown *pIUnknown = NULL);
    ~CPropertyStorageArray(void);
    bool IsValid(void) const;
    HRESULT Copy( const CPropertyStorageArray &other );
    void ClearPropVariantArray(void);
    void Destroy(void);
    bool AllocateData(void);
    CPropertyStorageArray &operator=( const CPropertyStorageArray &other );
    static int GetPropertyCount( IWiaPropertyStorage *pIWiaPropertyStorage );
    HRESULT GetPropertyNames( IWiaPropertyStorage *pIWiaPropertyStorage );
    HRESULT Initialize( IUnknown *pIUnknown );
    HRESULT Read( IUnknown *pIUnknown );
    HRESULT Write( IUnknown *pIUnknown );
    HRESULT Write( IUnknown *pIUnknown, PROPID propId );
    int GetIndexFromPropId( PROPID propId );
    PROPVARIANT *GetProperty( PROPID propId );
    bool GetProperty( PROPID propId, LONG &nProp );
    bool GetProperty( PROPID propId, CSimpleStringWide &strProp );
    bool SetProperty( PROPID propId, PROPVARIANT *pPropVar );
    bool SetProperty( PROPID propId, LONG nProp );
    int Count(void) const;
    PROPVARIANT *PropVariants(void) const;
    PROPSPEC *PropSpecs(void) const;
    LPWSTR *PropNames(void) const;
    void Dump( int nIndex = -1 );
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\propstrm.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       PROPSTRM.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        10/7/1999
 *
 *  DESCRIPTION: Property Stream Wrapper
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "propstrm.h"
#include "simreg.h"

CPropertyStream::CPropertyStream(void)
{
    WIA_PUSHFUNCTION(TEXT("CPropertyStream::CPropertyStream(void)"));
}


CPropertyStream::CPropertyStream( IStream *pIStream )
{
    WIA_PUSHFUNCTION(TEXT("CPropertyStream::CPropertyStream( IStream *pIStream )"));
    CopyFromStream( pIStream );
}


CPropertyStream::CPropertyStream( IWiaItem *pIWiaItem )
{
    WIA_PUSHFUNCTION(TEXT("CPropertyStream::CPropertyStream( IWiaItem *pIWiaItem )"));
    AssignFromWiaItem( pIWiaItem );
}


CPropertyStream::CPropertyStream( const CPropertyStream &other )
{
    WIA_PUSHFUNCTION(TEXT("CPropertyStream::CPropertyStream( const CPropertyStream &other )"));
    CopyFromStream( other.Stream() );
}

CPropertyStream::~CPropertyStream()
{
    WIA_PUSHFUNCTION(TEXT("CPropertyStream::~CPropertyStream"));
    Destroy();
}


CPropertyStream &CPropertyStream::operator=( const CPropertyStream &other )
{
    WIA_PUSHFUNCTION(TEXT("CPropertyStream::operator="));
    if (this != &other)
    {
        CopyFromStream( other.Stream() );
    }
    return (*this);
}

bool CPropertyStream::IsValid(void) const
{
    WIA_PUSHFUNCTION(TEXT("CPropertyStream::IsValid"));
    return (m_pIStreamPropertyStream.p != NULL);
}


void CPropertyStream::Destroy(void)
{
    WIA_PUSHFUNCTION(TEXT("CPropertyStream::Destroy"));
    m_pIStreamPropertyStream = NULL;
}


HRESULT CPropertyStream::CopyFromMemoryBlock( PBYTE pbSource, UINT_PTR nSize )
{
    WIA_PUSHFUNCTION(TEXT("CPropertyStream::CopyFromMemoryBlock"));
    Destroy();
    HRESULT hr = S_OK;

    if (pbSource)
    {
        if (nSize)
        {
            // Allocate memory to back the new stream.
            HGLOBAL hTarget = GlobalAlloc(GMEM_MOVEABLE, nSize);
            if (hTarget)
            {
                PBYTE pbTarget = (PBYTE)GlobalLock(hTarget);
                if (pbTarget)
                {
                    CopyMemory( pbTarget, pbSource, nSize );
                    GlobalUnlock( hTarget );
                    hr = CreateStreamOnHGlobal(hTarget, TRUE, &m_pIStreamPropertyStream );
                }
                else
                {
                    WIA_ERROR(("CPropertyStream::CopyFromMemoryBlock, GlobalLock failed"));
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
            }
            else
            {
                WIA_ERROR(("CPropertyStream::CopyFromMemoryBlock, GlobalAlloc failed, size: %d", nSize));
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }
        else
        {
            WIA_ERROR(("CPropertyStream::CopyFromMemoryBlock, nSize == 0"));
            hr = E_INVALIDARG;
        }
    }
    else
    {
        WIA_ERROR(("CPropertyStream::CopyFromMemoryBlock, Invalid source buffer"));
        hr = E_INVALIDARG;
    }
    return(hr);
}

HRESULT CPropertyStream::CopyFromStream( IStream *pIStream )
{
    WIA_PUSHFUNCTION(TEXT("CPropertyStream::CopyFromStream"));
    Destroy();
    HRESULT hr = S_OK;

    if (pIStream)
    {
        HGLOBAL hSource;
        hr = GetHGlobalFromStream(pIStream, &hSource);
        if (SUCCEEDED(hr))
        {
            // Get the size of the stream.
            UINT_PTR nSize = GlobalSize(hSource);
            if (nSize)
            {
                PBYTE pbSource = (PBYTE)GlobalLock(hSource);
                if (pbSource)
                {
                    hr = CopyFromMemoryBlock( pbSource, nSize );
                    GlobalUnlock(hSource);
                }
                else
                {
                    WIA_ERROR(("CPropertyStream::CopyFromStream, GlobalLock failed"));
                    hr = HRESULT_FROM_WIN32(GetLastError());
                }
            }
            else
            {
                WIA_ERROR(("CPropertyStream::CopyFromStream, GlobalSize failed"));
                hr = HRESULT_FROM_WIN32(GetLastError());
            }
        }
        else
        {
            WIA_ERROR(("CPropertyStream::CopyFromStream, GetHGlobalFromStream failed"));
        }
    }
    else
    {
        WIA_ERROR(("CPropertyStream::CopyFromStream, Invalid source stream"));
        hr = E_INVALIDARG;
    }
    if (FAILED(hr))
    {
        WIA_PRINTHRESULT((hr,TEXT("CPropertyStream::CopyFromStream failed")));
    }
    return(hr);
}


HRESULT CPropertyStream::AssignFromWiaItem( IWiaItem *pIWiaItem )
{
    WIA_PUSHFUNCTION(TEXT("CPropertyStream::AssignFromWiaItem"));
    Destroy();
    
    HRESULT hr;
    if (pIWiaItem)
    {
        IWiaPropertyStorage *pIWiaPropertyStorage;
        hr = pIWiaItem->QueryInterface(IID_IWiaPropertyStorage, (void**) &pIWiaPropertyStorage);
        if (SUCCEEDED(hr))
        {
            GUID    guidCompatibilityId;
            hr = pIWiaPropertyStorage->GetPropertyStream(&guidCompatibilityId, &m_pIStreamPropertyStream);
            if (FAILED(hr))
            {
                WIA_PRINTHRESULT((hr,TEXT("CPropertyStream::AssignFromWiaItem, GetPropertyStream failed")));
            }

            pIWiaPropertyStorage->Release();
        }
        else
        {
            WIA_PRINTHRESULT((hr,TEXT("CPropertyStream::AssignFromWiaItem, QI of IID_IWiaPropertyStorage failed")));
        }
    }
    else
    {
        hr = E_INVALIDARG;
        WIA_ERROR(("CPropertyStream::AssignFromWiaItem, Invalid IWiaItem *"));
    }

    if (!SUCCEEDED(hr))
    {
        WIA_PRINTHRESULT((hr,"CPropertyStream::AssignFromWiaItem failed"));
    }
    return(hr);
}


HRESULT CPropertyStream::ApplyToWiaItem( IWiaItem *pIWiaItem )
{
    WIA_PUSHFUNCTION(TEXT("CPropertyStream::ApplyToWiaItem"));
    HRESULT hr;
    if (pIWiaItem && m_pIStreamPropertyStream)
    {
        IWiaPropertyStorage *pIWiaPropertyStorage;
        hr = pIWiaItem->QueryInterface(IID_IWiaPropertyStorage, (void**) &pIWiaPropertyStorage);
        if (SUCCEEDED(hr))
        {
            hr = pIWiaPropertyStorage->SetPropertyStream((GUID*) &GUID_NULL, m_pIStreamPropertyStream);
            if (FAILED(hr))
            {
                WIA_PRINTHRESULT((hr,TEXT("CPropertyStream::ApplyToWiaItem, SetPropertyStream failed")));
            }

            pIWiaPropertyStorage->Release();
        }
        else
        {
            WIA_PRINTHRESULT((hr,TEXT("CPropertyStream::ApplyToWiaItem, QI of IID_IWiaPropertyStorage failed")));
        }
    }
    else
    {
        hr = E_INVALIDARG;
        WIA_ERROR(("CPropertyStream::ApplyToWiaItem, Invalid IWiaItem *"));
    }
    if (!SUCCEEDED(hr))
    {
        WIA_PRINTHRESULT((hr,"CPropertyStream::ApplyToWiaItem failed"));
    }
    return(hr);
}


IStream *CPropertyStream::Stream(void)
{
    WIA_PUSHFUNCTION(TEXT("*CPropertyStream::Stream(void)"));
    return(m_pIStreamPropertyStream);
}


IStream *CPropertyStream::Stream(void) const
{
    WIA_PUSHFUNCTION(TEXT("*CPropertyStream::Stream(void) const"));
    return(m_pIStreamPropertyStream);
}


UINT_PTR CPropertyStream::Size(void) const
{
    WIA_PUSHFUNCTION(TEXT("CPropertyStream::Size"));
    UINT_PTR nSize = 0;

    if (m_pIStreamPropertyStream)
    {
        STATSTG StatStg;
        if (SUCCEEDED(m_pIStreamPropertyStream->Stat(&StatStg,STATFLAG_NONAME)))
            nSize = StatStg.cbSize.LowPart;
    }
    return(nSize);
}


PBYTE CPropertyStream::Lock(void)
{
    WIA_PUSHFUNCTION(TEXT("CPropertyStream::Lock"));
    PBYTE pBytes = NULL;

    if (m_pIStreamPropertyStream)
    {
        HGLOBAL hSource;
        HRESULT hr = GetHGlobalFromStream(m_pIStreamPropertyStream, &hSource);
        if (SUCCEEDED(hr))
        {
            pBytes = reinterpret_cast<PBYTE>(GlobalLock( hSource ));
        }
    }
    return(pBytes);
}


void CPropertyStream::Unlock(void)
{
    WIA_PUSHFUNCTION(TEXT("CPropertyStream::Unlock"));
    PBYTE pBytes = NULL;

    if (m_pIStreamPropertyStream)
    {
        HGLOBAL hSource;
        HRESULT hr = GetHGlobalFromStream(m_pIStreamPropertyStream, &hSource);
        if (SUCCEEDED(hr))
        {
            GlobalUnlock( hSource );
        }
    }
}

bool ConstructRegistryPath( IWiaItem *pWiaItem, LPCTSTR pszSubKey, CSimpleString &strKeyName )
{
    if (pWiaItem)
    {
        strKeyName = pszSubKey;
        if (strKeyName.Length())
        {
            // Append a backslash
            if (strKeyName[(int)(strKeyName.Length())] != TEXT('\\'))
                strKeyName += TEXT("\\");

            CSimpleStringWide strwItemName;
            if (PropStorageHelpers::GetProperty( pWiaItem, WIA_IPA_FULL_ITEM_NAME, strwItemName ))
            {
                strKeyName += CSimpleStringConvert::NaturalString( strwItemName );
                return true;
            }
        }
    }
    return false;
}

bool CPropertyStream::GetBytes( PBYTE &pByte, UINT_PTR &nSize )
{
    bool bSuccess = false;
    if (m_pIStreamPropertyStream)
    {
        nSize = Size();
        if (nSize)
        {
            pByte = new BYTE[nSize];
            if (pByte)
            {
                LARGE_INTEGER li = {0,0};
                if (SUCCEEDED(m_pIStreamPropertyStream->Seek(li,STREAM_SEEK_SET,NULL)))
                {
                    DWORD dwBytesRead = 0;
                    if (SUCCEEDED(m_pIStreamPropertyStream->Read( pByte, static_cast<DWORD>(nSize), &dwBytesRead )))
                    {
                        if (static_cast<DWORD>(dwBytesRead) == nSize)
                        {
                            bSuccess = true;
                        }
                    }
                }
                if (!bSuccess)
                {
                    delete[] pByte;
                    pByte = NULL;
                    nSize = 0;
                }
            }
        }
    }
    return bSuccess;
}

bool CPropertyStream::WriteToRegistry( IWiaItem *pWiaItem, HKEY hKeyRoot, LPCTSTR pszSubKey, LPCTSTR pszValueName )
{
    bool bResult = false;
    CSimpleString strKeyName;
    if (ConstructRegistryPath( pWiaItem, pszSubKey, strKeyName ))
    {
        CSimpleReg reg( hKeyRoot, strKeyName, true, KEY_WRITE );
        if (reg.OK())
        {
            UINT_PTR nSize = 0;
            PBYTE pData = NULL;
            if (GetBytes(pData,nSize) && nSize && pData)
            {
                bResult = reg.SetBin( pszValueName, pData, static_cast<DWORD>(nSize), REG_BINARY );
                delete[] pData;
            }
            else
            {
                reg.Delete( pszValueName );
            }
        }
    }
    return bResult;
}


bool CPropertyStream::ReadFromRegistry( IWiaItem *pWiaItem, HKEY hKeyRoot, LPCTSTR pszSubKey, LPCTSTR pszValueName )
{
    bool bResult = false;
    Destroy();
    CSimpleString strKeyName;
    if (ConstructRegistryPath( pWiaItem, pszSubKey, strKeyName ))
    {
        CSimpleReg reg( hKeyRoot, strKeyName, false, KEY_READ );
        if (reg.OK())
        {
            UINT_PTR nStreamSize = reg.Size(pszValueName);
            if (nStreamSize)
            {
                BYTE *pData = new BYTE[nStreamSize];
                if (pData)
                {
                    if (reg.QueryBin( pszValueName, pData, static_cast<DWORD>(nStreamSize) ))
                    {
                        if (SUCCEEDED(CopyFromMemoryBlock( pData, nStreamSize )))
                        {
                            bResult = true;
                        }
                    }
                    delete[] pData;
                }
            }
        }
    }
    return bResult;
}

CAutoRestorePropertyStream::CAutoRestorePropertyStream( IWiaItem *pItem )
{
    m_hr = m_PropertyStream.AssignFromWiaItem(pItem);
    m_pWiaItem = pItem;
}

CAutoRestorePropertyStream::~CAutoRestorePropertyStream()
{
    if (SUCCEEDED(m_hr))
    {
        m_PropertyStream.ApplyToWiaItem(m_pWiaItem);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\propstrm.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       PROPSTRM.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        10/7/1999
 *
 *  DESCRIPTION: Property stream wrapper
 *
 *******************************************************************************/
#ifndef __PROPSTRM_H_INCLUDED
#define __PROPSTRM_H_INCLUDED

#include <windows.h>
#include <objbase.h>
#include "simreg.h"
#include "simstr.h"

class CPropertyStream
{
private:
    CComPtr<IStream> m_pIStreamPropertyStream;

public:
    CPropertyStream(void);
    CPropertyStream( IStream *pIStream );
    CPropertyStream( IWiaItem *pIWiaItem );
    CPropertyStream( const CPropertyStream &other );
    ~CPropertyStream();
    CPropertyStream &operator=( const CPropertyStream &other );
    bool IsValid(void) const;
    void Destroy(void);
    HRESULT CopyFromStream( IStream *pIStream );
    HRESULT CopyFromMemoryBlock( PBYTE pbSource, UINT_PTR nSize );
    HRESULT AssignFromWiaItem( IWiaItem *pIWiaItem );
    HRESULT ApplyToWiaItem( IWiaItem *pIWiaItem );
    IStream *Stream(void);
    IStream *Stream(void) const;
    UINT_PTR Size(void) const;
    PBYTE Lock(void);
    void Unlock(void);
    bool GetBytes( PBYTE &pByte, UINT_PTR &nSize );
    bool WriteToRegistry( IWiaItem *pWiaItem, HKEY hKeyRoot, LPCTSTR pszSubKey, LPCTSTR pszValueName );
    bool ReadFromRegistry( IWiaItem *pWiaItem, HKEY hKeyRoot, LPCTSTR pszSubKey, LPCTSTR pszValueName );
};

class CAutoRestorePropertyStream
{
private:
    CPropertyStream m_PropertyStream;
    HRESULT m_hr;
    CComPtr<IWiaItem> m_pWiaItem;

public:
    CAutoRestorePropertyStream( IWiaItem *pWiaItem );
    ~CAutoRestorePropertyStream(void);
};

#endif //__PROPSTRM_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\proparry.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       PROPARRY.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        5/4/1999
 *
 *  DESCRIPTION: IWiaPropertyStorage cache definitions
 *
 *******************************************************************************/

#include "precomp.h"
#pragma hdrstop

CPropertyStorageArray::CPropertyStorageArray( const CPropertyStorageArray &other )
: m_nCount(0),
  m_ppvPropVariants(NULL),
  m_ppsPropSpecs(NULL),
  m_pstrPropNames(NULL)
{
    Copy(other);
}


CPropertyStorageArray::CPropertyStorageArray(IUnknown *pIUnknown)
: m_nCount(0),
  m_ppvPropVariants(NULL),
  m_ppsPropSpecs(NULL),
  m_pstrPropNames(NULL)
{
    Initialize(pIUnknown);
}


CPropertyStorageArray::~CPropertyStorageArray(void)
{
    Destroy();
}


bool CPropertyStorageArray::IsValid(void) const
{
    // It's OK to have an empty list, but it isn't considered valid
    return (m_nCount && m_ppvPropVariants && m_ppsPropSpecs && m_pstrPropNames);
}


HRESULT CPropertyStorageArray::Copy( const CPropertyStorageArray &other )
{
    Destroy();
    HRESULT hr = S_OK;
    if (this != &other)
    {
        if (other.IsValid())
        {
            m_nCount = other.Count();
            if (m_nCount)
            {
                if (AllocateData())
                {
                    for (int i=0;i<m_nCount && SUCCEEDED(hr);i++)
                    {
                        // Copy propvariant
                        if (!SUCCEEDED(PropVariantCopy( &m_ppvPropVariants[i], &other.PropVariants()[i])))
                        {
                            hr = E_FAIL;
                            break;
                        }

                        // Copy property name
                        if (other.PropNames() && other.PropNames()[i])
                        {
                            m_pstrPropNames[i] = new WCHAR[lstrlenW(other.PropNames()[i])+1];
                            if (!m_pstrPropNames[i])
                            {
                                hr = E_FAIL;
                                break;
                            }
                            lstrcpyW( m_pstrPropNames[i], other.PropNames()[i] );
                        }

                        // Copy propspec (propid)
                        m_ppsPropSpecs[i].propid = other.PropSpecs()[i].propid;
                        m_ppsPropSpecs[i].ulKind = PRSPEC_PROPID;
                    }
                }
                else
                {
                    hr = E_FAIL;
                }
            }
        }
        else
        {
            hr = E_FAIL;
        }
    }
    if (!SUCCEEDED(hr))
        Destroy();
    return hr;
}


void CPropertyStorageArray::ClearPropVariantArray(void)
{
    if (!m_ppvPropVariants || !m_nCount)
        return;
    for (int i=0;i<m_nCount;i++)
    {
        PropVariantClear(m_ppvPropVariants+i);
        m_ppvPropVariants[i].vt = VT_EMPTY;
    }
}


void CPropertyStorageArray::Destroy(void)
{
    ClearPropVariantArray();
    for (int i=0;i<m_nCount;i++)
    {
        if (m_pstrPropNames && m_pstrPropNames[i])
            delete[] m_pstrPropNames[i];
    }
    if (m_ppvPropVariants)
        delete[] m_ppvPropVariants;
    if (m_ppsPropSpecs)
        delete[] m_ppsPropSpecs;
    if (m_pstrPropNames)
        delete[] m_pstrPropNames;
    m_ppvPropVariants = NULL;
    m_ppsPropSpecs = NULL;
    m_pstrPropNames = NULL;
    m_nCount = 0;
}


bool CPropertyStorageArray::AllocateData(void)
{
    m_ppsPropSpecs = new PROPSPEC[m_nCount];
    if (m_ppsPropSpecs)
    {
        ZeroMemory(m_ppsPropSpecs,m_nCount*sizeof(m_ppsPropSpecs[0]));
    }
    m_ppvPropVariants  = new PROPVARIANT[m_nCount];
    if (m_ppvPropVariants)
    {
        ZeroMemory(m_ppvPropVariants,m_nCount*sizeof(m_ppvPropVariants[0]));
    }
    m_pstrPropNames = new LPWSTR[m_nCount];
    if (m_pstrPropNames)
    {
        ZeroMemory(m_pstrPropNames,m_nCount*sizeof(m_pstrPropNames[0]));
    }
    return(m_ppsPropSpecs && m_ppvPropVariants && m_pstrPropNames);
}


CPropertyStorageArray &CPropertyStorageArray::operator=( const CPropertyStorageArray &other )
{
    Copy(other);
    return(*this);
}


int CPropertyStorageArray::GetPropertyCount( IWiaPropertyStorage *pIWiaPropertyStorage )
{
    IEnumSTATPROPSTG  *pIEnum = NULL;
    HRESULT           hr;
    int               nCount=0;

    hr = pIWiaPropertyStorage->Enum(&pIEnum);
    if (SUCCEEDED(hr))
    {
        STATPROPSTG StatPropStg;
        ZeroMemory(&StatPropStg,sizeof(StatPropStg));
        while ((hr = pIEnum->Next(1,&StatPropStg, NULL)) == S_OK)
        {
            nCount++;
            if (StatPropStg.lpwstrName)
            {
                CoTaskMemFree(StatPropStg.lpwstrName);
            }
            ZeroMemory(&StatPropStg,sizeof(StatPropStg));
        }
    }
    return(nCount);
}


HRESULT CPropertyStorageArray::GetPropertyNames( IWiaPropertyStorage *pIWiaPropertyStorage )
{
    IEnumSTATPROPSTG  *pIEnum = NULL;
    HRESULT           hr;
    int               nCurrentIndex=0;

    hr = pIWiaPropertyStorage->Enum(&pIEnum);
    if (SUCCEEDED(hr))
    {
        STATPROPSTG StatPropStg;
        ZeroMemory(&StatPropStg,sizeof(StatPropStg));
        while ((hr = pIEnum->Next(1,&StatPropStg, NULL)) == S_OK)
        {
            m_ppsPropSpecs[nCurrentIndex].propid = StatPropStg.propid;
            m_ppsPropSpecs[nCurrentIndex].ulKind = PRSPEC_PROPID;
            if (StatPropStg.lpwstrName)
            {
                m_pstrPropNames[nCurrentIndex] = new WCHAR[lstrlenW(StatPropStg.lpwstrName)+1];
                if (m_pstrPropNames[nCurrentIndex])
                {
                    lstrcpyW( m_pstrPropNames[nCurrentIndex], StatPropStg.lpwstrName );
                    CoTaskMemFree(StatPropStg.lpwstrName);
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                    CoTaskMemFree(StatPropStg.lpwstrName);
                    break;
                }
            }
            nCurrentIndex++;
        }
    }
    return(hr);
}


HRESULT CPropertyStorageArray::Initialize( IUnknown *pIUnknown )
{
    Destroy();
    HRESULT hr = E_INVALIDARG;
    if (pIUnknown)
    {
        CComPtr<IWiaPropertyStorage> pIWiaPropertyStorage;
        hr = pIUnknown->QueryInterface(IID_IWiaPropertyStorage, (void**)&pIWiaPropertyStorage);
        if (SUCCEEDED(hr))
        {
            m_nCount = GetPropertyCount( pIWiaPropertyStorage );
            if (m_nCount)
            {
                if (AllocateData())
                {
                    hr = GetPropertyNames( pIWiaPropertyStorage );
                    if (SUCCEEDED(hr))
                    {
                        hr = pIWiaPropertyStorage->ReadMultiple( m_nCount, m_ppsPropSpecs, m_ppvPropVariants );
                    }
                }
            }
        }
    }
    if (!SUCCEEDED(hr))
    {
        Destroy();
    }
    return(hr);
}


HRESULT CPropertyStorageArray::Read( IUnknown *pIUnknown )
{
    HRESULT hr = E_FAIL;
    if (IsValid())
    {
        ClearPropVariantArray();
        CComPtr<IWiaPropertyStorage> pIWiaPropertyStorage;
        hr = pIUnknown->QueryInterface(IID_IWiaPropertyStorage, (void**)&pIWiaPropertyStorage);
        if (SUCCEEDED(hr))
        {
            hr = pIWiaPropertyStorage->ReadMultiple( m_nCount, m_ppsPropSpecs, m_ppvPropVariants );
        }
    }
    return(hr);
}


HRESULT CPropertyStorageArray::Write( IUnknown *pIUnknown )
{
    HRESULT hr = E_FAIL;
    if (IsValid())
    {
        CComPtr<IWiaPropertyStorage> pIWiaPropertyStorage;
        hr = pIUnknown->QueryInterface(IID_IWiaPropertyStorage, (void**)&pIWiaPropertyStorage);
        if (SUCCEEDED(hr))
        {
            hr = pIWiaPropertyStorage->WriteMultiple( m_nCount, m_ppsPropSpecs, m_ppvPropVariants, WIA_IPA_FIRST);
        }
    }
    return(hr);
}


HRESULT CPropertyStorageArray::Write( IUnknown *pIUnknown, PROPID propId )
{
    HRESULT hr = E_FAIL;
    if (IsValid())
    {
        int nIndex = GetIndexFromPropId( propId );
        if (nIndex >= 0)
        {
            CComPtr<IWiaPropertyStorage> pIWiaPropertyStorage;
            hr = pIUnknown->QueryInterface(IID_IWiaPropertyStorage, (void**)&pIWiaPropertyStorage);
            if (SUCCEEDED(hr))
            {
                hr = pIWiaPropertyStorage->WriteMultiple( 1, m_ppsPropSpecs+nIndex, m_ppvPropVariants+nIndex, WIA_IPA_FIRST );
            }
        }
    }
    return(hr);
}


int CPropertyStorageArray::GetIndexFromPropId( PROPID propId )
{
    if (!IsValid())
        return -1;
    for (int i=0;i<m_nCount;i++)
    {
        if (m_ppsPropSpecs[i].propid == propId)
            return(i);
    }
    return(-1);
}


PROPVARIANT *CPropertyStorageArray::GetProperty( PROPID propId )
{
    int nIndex = GetIndexFromPropId( propId );
    if (nIndex < 0)
        return(NULL);
    return(m_ppvPropVariants+nIndex);
}


bool CPropertyStorageArray::GetProperty( PROPID propId, LONG &nProp )
{
    PROPVARIANT *ppvPropValue = GetProperty( propId );
    if (!ppvPropValue)
        return(false);
    if (VT_I4 != ppvPropValue->vt)
        return(false);
    nProp = ppvPropValue->lVal;
    return(TRUE);
}



bool CPropertyStorageArray::GetProperty( PROPID propId, CSimpleStringWide &strProp )
{
    PROPVARIANT *ppvPropValue = GetProperty( propId );
    if (!ppvPropValue)
        return(false);
    if (VT_LPWSTR != ppvPropValue->vt && VT_BSTR != ppvPropValue->vt)
        return(false);
    strProp = ppvPropValue->pwszVal;
    return(true);
}



bool CPropertyStorageArray::SetProperty( PROPID propId, PROPVARIANT *pPropVar )
{
    PROPVARIANT *ppvPropValue = GetProperty( propId );
    if (ppvPropValue)
    {
        PropVariantClear(ppvPropValue);
        return(SUCCEEDED(PropVariantCopy(ppvPropValue,pPropVar)));
    }
    return(false);
}

bool CPropertyStorageArray::SetProperty( PROPID propId, LONG nProp )
{
    PROPVARIANT *ppvPropValue = GetProperty( propId );
    if (ppvPropValue)
    {
        ppvPropValue->vt = VT_I4;
        ppvPropValue->lVal = nProp;
        return(true);
    }
    return(false);
}


int CPropertyStorageArray::Count(void) const
{
    return(m_nCount);
}


PROPVARIANT *CPropertyStorageArray::PropVariants(void) const
{
    return(m_ppvPropVariants);
}


PROPSPEC *CPropertyStorageArray::PropSpecs(void) const
{
    return(m_ppsPropSpecs);
}


LPWSTR *CPropertyStorageArray::PropNames(void) const
{
    return(m_pstrPropNames);
}


void CPropertyStorageArray::Dump( int nIndex )
{
#if defined(WIA_DEBUG)
    WIA_TRACE((TEXT("Dumping IWiaPropertyStorage:")));
    int nStart = nIndex < 0 ? 0 : nIndex;
    int nCount = nIndex < 0 ? Count() : 1;
    for (int i=nStart;i<nCount;i++)
    {
        PROPVARIANT *pPropVar = GetProperty( m_ppsPropSpecs[i].propid );
        if (pPropVar)
        {
            TCHAR szValue[512] = TEXT("");
            switch (m_ppvPropVariants[i].vt)
            {
            case VT_I4:
                wsprintf(szValue,TEXT("%d"),(LONG)m_ppvPropVariants[i].lVal);
                break;

            case VT_BSTR:
                wsprintf(szValue,TEXT("%ws"),m_ppvPropVariants[i].bstrVal);
                break;

            case VT_VECTOR|VT_I4:
                {
                    for (int j=0;j<(int)m_ppvPropVariants[i].cal.cElems;j++)
                    {
                        wsprintf(szValue+lstrlen(szValue),TEXT("%08X"),(LONG)m_ppvPropVariants[i].cal.pElems[j]);
                        if (j < (int)m_ppvPropVariants[i].cal.cElems-1)
                            wsprintf(szValue+lstrlen(szValue),TEXT(" "));
                    }
                }
                break;

            case VT_VECTOR|VT_UI1:
                {
                    for (int j=0;j<(int)m_ppvPropVariants[i].cal.cElems;j++)
                    {
                        wsprintf(szValue+lstrlen(szValue),TEXT("%02X"),(LONG)m_ppvPropVariants[i].caub.pElems[j]);
                        if (j < (int)m_ppvPropVariants[i].cal.cElems-1 && j % 4 == 3)
                            wsprintf(szValue+lstrlen(szValue),TEXT(" "));
                    }
                }
                break;

            case VT_LPWSTR:
                wsprintf(szValue,TEXT("%ws"),m_ppvPropVariants[i].pwszVal );
                break;

            default:
                wsprintf(szValue,TEXT("Unknown Type %d (08X)"),m_ppvPropVariants[i].vt);
            }
            WIA_TRACE((TEXT("  [%-3d  %ws] = [%s]"), m_ppsPropSpecs[i].propid, m_pstrPropNames[i], szValue));
        }
    }
#endif // defined(II_DEBUG)
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\regionde.h ===
// RegionDetector.h: interface for the CRegionDetector class.
//
//////////////////////////////////////////////////////////////////////

#include "32BitDib.h"

struct CRegionList
{
    private:
        CRegionList( const CRegionList & );
        CRegionList &operator=( const CRegionList & );
    public:
    CRegionList(int num);
    virtual ~CRegionList()
    {
        delete m_pRects;
        delete m_pixelsFilled;
        delete m_valid;
        delete m_type;
        delete m_totalColored;
        delete m_totalIntensity;
        delete m_totalEdge;
        delete m_backgroundColorPixels;
    }

    // public... number of valid rects
    int Size(int r)
    {
        return (m_pRects[r].right-m_pRects[r].left)*(m_pRects[r].bottom-m_pRects[r].top);
    }


    // public
    RECT operator[](int num)
    {
        return nthRegion(num);
    }

    // public

    int UnionIntersectingRegions();

    // public
    RECT unionAll();

    // private
    RECT nthRegion(int num);

    int RegionType(int region);

    bool largeRegion(int region);

    double ClassifyRegion(int region); // determine if the region is a text or a graphics region

    bool checkIfValidRegion(int region, int border = 0); // syncs whether a region is valid or not

    bool ValidRegion(int region, int border = 0); // determines if a region is likely a worthless speck of dust or shadow or if we should care about the region

    bool InsideRegion(int region, int x, int y, int border=0); // border is the amount of border space to place around the outside of the region

    void AddPixel(int region, ULONG pixel,ULONG edge, int x, int y);
    // unions two regions together... region b is invalidated
    bool UnionRegions(int a, int b);
    RECT UnionRects(RECT a, RECT b);
    bool MergerIntersectsPhoto(int a, int b); // if we merge these two regions, will we also be merging with a photo region (a taboo)
    // see InsideRegion for an explaination of what border is
    bool CheckIntersect(int a, int b, int border=0); // do regions a and b intersect?
    bool CheckIntersect(RECT r1, RECT r2, int border=0); // do regions a and b intersect?

    static RECT Intersect(RECT r1, RECT r2);

    static bool InsideRegion(RECT region, int x, int y, int border=0); // border is the amount of border space to place around the outside of the region

    // compact down ignores all other info aside from rect location
    // leads to faster access
    void CompactDown(int size);

    // dibs are stored upside down from normal screen coords
    // so apps will often want to flip the bitmap first
    void FlipVertically();


    int m_numRects;
    int m_validRects;
    int m_nBitmapWidth;
    int m_nBitmapHeight;
    RECT * m_pRects;
    bool * m_valid; // is the rectangle a valid rectangle or has it been sent to the region graveyard in the sky
    int * m_type; // is this region a text region or a photograph? PHOTOGRAPH_REGION TEXT_REGION

    // the following indicators are used to determine if a region is a valid region

    ULONG * m_pixelsFilled;  // how many of the pixels in the region were actually selected?
    ULONG * m_totalColored; // accumulated color difference indicator
    ULONG * m_totalIntensity; // accumulated intensity indicator
    ULONG * m_totalEdge; // accumulated edge values
    int *m_backgroundColorPixels; // number of pixels which are very close to the background color (used for determining text region status... particularly useful in cases where part of a text region may have a shadow which could lead the program to think it was a photo region
    int m_maxRects;
};

class CRegionDetector
{
private:
    // Not implemented
    CRegionDetector( const CRegionDetector & );
    CRegionDetector &operator=( const CRegionDetector & );

public: // will be made private when we are done debugging
    C32BitDibWrapper * m_pScan;
    C32BitDibWrapper * m_pScanBlurred;
    C32BitDibWrapper * m_pScanDoubleBlurred;
    C32BitDibWrapper * m_pScanTripleBlurred;

    C32BitDibWrapper * m_pScanHorizontalBlurred;
    C32BitDibWrapper * m_pScanVerticalBlurred;
    C32BitDibWrapper * m_pScanDoubleHorizontalBlurred;
    C32BitDibWrapper * m_pScanDoubleVerticalBlurred;

    C32BitDibWrapper * m_pScanEdges;
    C32BitDibWrapper * m_pScanDoubleEdges;
    C32BitDibWrapper * m_pScanTripleEdges;
    C32BitDibWrapper * m_pScanHorizontalEdges;
    C32BitDibWrapper * m_pScanDoubleHorizontalEdges;
    C32BitDibWrapper * m_pScanVerticalEdges;
    C32BitDibWrapper * m_pScanDoubleVerticalEdges;
    C32BitDibWrapper * m_pScanWithShadows;

    CRegionList * m_pRegions;
    int m_resampleFactor; // ratio between imageDimensions and origional image dimensions
    int m_intent; // either try to avoid deciding stray dots are images or try to avoid deciding real images aren't images
    // not used as yet


public:
    CRegionDetector(BYTE* dib)
    {
        m_pScan = new C32BitDibWrapper(dib);
        m_pScanBlurred = new C32BitDibWrapper(); // create an empty wrapper
        m_pScanDoubleBlurred = new C32BitDibWrapper();
        m_pScanTripleBlurred = new C32BitDibWrapper();

        m_pScanHorizontalBlurred = new C32BitDibWrapper();
        m_pScanVerticalBlurred = new C32BitDibWrapper();

        m_pScanDoubleHorizontalBlurred = new C32BitDibWrapper();
        m_pScanDoubleVerticalBlurred = new C32BitDibWrapper();

        m_pScanEdges = new C32BitDibWrapper();
        m_pScanDoubleEdges = new C32BitDibWrapper();
        m_pScanTripleEdges = new C32BitDibWrapper();

        m_pScanHorizontalEdges = new C32BitDibWrapper();
        m_pScanVerticalEdges = new C32BitDibWrapper();

        m_pScanDoubleHorizontalEdges = new C32BitDibWrapper();
        m_pScanDoubleVerticalEdges = new C32BitDibWrapper();

        m_resampleFactor=1;
        m_pScanWithShadows = NULL;
        m_pRegions=NULL;
        m_intent=TRUE; // m_intent isn't yet implemented
    }

    CRegionDetector(BITMAP pBitmap)
    {
        m_pScan = new C32BitDibWrapper(pBitmap);
        m_pScanBlurred = new C32BitDibWrapper(); // create an empty wrapper
        m_pScanDoubleBlurred = new C32BitDibWrapper();
        m_pScanTripleBlurred = new C32BitDibWrapper();

        m_pScanHorizontalBlurred = new C32BitDibWrapper();
        m_pScanVerticalBlurred = new C32BitDibWrapper();

        m_pScanDoubleHorizontalBlurred = new C32BitDibWrapper();
        m_pScanDoubleVerticalBlurred = new C32BitDibWrapper();

        m_pScanEdges = new C32BitDibWrapper();
        m_pScanDoubleEdges = new C32BitDibWrapper();
        m_pScanTripleEdges = new C32BitDibWrapper();

        m_pScanHorizontalEdges = new C32BitDibWrapper();
        m_pScanVerticalEdges = new C32BitDibWrapper();

        m_pScanDoubleHorizontalEdges = new C32BitDibWrapper();
        m_pScanDoubleVerticalEdges = new C32BitDibWrapper();

        m_resampleFactor=1;
        m_pScanWithShadows = NULL;
        m_pRegions=NULL;
        m_intent=TRUE; // m_intent isn't yet implemented
    }

    virtual ~CRegionDetector()
    {
        if (m_pScan) delete m_pScan;
        if (m_pScanBlurred) delete m_pScanBlurred;
        if (m_pScanDoubleBlurred) delete m_pScanDoubleBlurred;
        if (m_pScanTripleBlurred) delete m_pScanTripleBlurred;

        if (m_pScanHorizontalBlurred) delete m_pScanHorizontalBlurred;
        if (m_pScanVerticalBlurred) delete m_pScanVerticalBlurred;

        if (m_pScanDoubleHorizontalBlurred) delete m_pScanDoubleHorizontalBlurred;
        if (m_pScanDoubleVerticalBlurred) delete m_pScanDoubleVerticalBlurred;

        if (m_pScanEdges) delete m_pScanEdges;
        if (m_pScanDoubleEdges) delete m_pScanDoubleEdges;
        if (m_pScanTripleEdges) delete m_pScanTripleEdges;

        if (m_pScanHorizontalEdges) delete m_pScanHorizontalEdges;
        if (m_pScanVerticalEdges) delete m_pScanVerticalEdges;

        if (m_pScanDoubleHorizontalEdges) delete m_pScanDoubleHorizontalEdges;
        if (m_pScanDoubleVerticalEdges) delete m_pScanDoubleVerticalEdges;

        if (m_pScanWithShadows) delete m_pScanWithShadows;
        if(m_pRegions!=NULL) delete m_pRegions;
    }
public:
    int FindRegions();
    bool FindSingleRegion();
    bool CollisionDetection(RECT r1, RECT r2, C32BitDibWrapper* pImage);
    bool ConvertToOrigionalCoordinates();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\regionde.cpp ===
// RegionDetector.cpp: implementation of the CRegionDetector class.
//
//////////////////////////////////////////////////////////////////////
#include "precomp.h"
#pragma hdrstop

#include "regionde.h"


inline ULONG Intensity(ULONG value);
inline ULONG DifferenceFromGray(ULONG value);
inline UCHAR Difference(UCHAR a, UCHAR b);
inline ULONG Difference(ULONG a, ULONG b);
int inline MAX(int a, int b);
int inline MIN(int a, int b);

// helper functions

// sum of RGB vals
inline ULONG Intensity(ULONG value)
{
    return(value&0xff)+((value&0xff00)>>8)+((value&0xff0000)>>16);
}

// shadows are gray... if you aint gray... you aint a shadow
inline ULONG DifferenceFromGray(ULONG value)
{
    UCHAR g,b;//,b;
    //  r=(UCHAR)(value& 0x0000ff);
    g=(UCHAR)((value& 0x00ff00)>>8);
    b=(UCHAR)((value& 0xff0000)>>16);
    // use this instead of the complete formula (uncomment the commented out code for the complete formula)
    // allow yellow scanner backgrounds
    return(ULONG)(Difference(b,g));//+Difference(r,g)+Difference(g,b));
}

// we should make a Difference Template to clean up this code

inline UCHAR Difference(UCHAR a, UCHAR b)
{
    if (a>b) return(a-b);
    else return(b-a);
}

inline ULONG Difference(ULONG a, ULONG b)
{
    if (a>b) return(a-b);
    else return(b-a);
}

inline LONG Difference(LONG a, LONG b)
{
    if (a>b) return(a-b);
    else return(b-a);
}

int inline MAX(int a, int b)
{
    if (a>b) return(a);
    return(b);
}

int inline MIN(int a, int b)
{
    if (a<b) return(a);
    return(b);
}

// if we have resampled the image, we may want to convert back to the origional coordinate system
bool CRegionDetector::ConvertToOrigionalCoordinates()
{
    if (m_pRegions!=NULL)
    {
        int i;
        for (i=0;i<m_pRegions->m_numRects;i++)
        {
            m_pRegions->m_pRects[i].left=m_pRegions->m_pRects[i].left*m_resampleFactor+m_resampleFactor/2;
            m_pRegions->m_pRects[i].right=m_pRegions->m_pRects[i].right*m_resampleFactor+m_resampleFactor/2;
            m_pRegions->m_pRects[i].top=m_pRegions->m_pRects[i].top*m_resampleFactor+m_resampleFactor/2;
            m_pRegions->m_pRects[i].bottom=m_pRegions->m_pRects[i].bottom*m_resampleFactor+m_resampleFactor/2;
        }
        return(true);
    }
    return(false);
}

// simplified Region detection code for single region detection
// Faster and about as accurate
// FindSingleRegion encapsulates a subset of FindRegions.  at the moment, for code documentation of FindSingleRegion, see FindRegions
bool CRegionDetector::FindSingleRegion()
{
    // cast the pointers
    // S = Scan, B = blank background, V = virtual screen... new image
    int x,y;
    int a,b; // loop vars used for merging regions
    int border; // for aggregation on a rectangle by rectangle basis
    ULONG position;
    int numChunks;
    bool unionOperationInLastPass;
    ULONG* pImagePixels;
    ULONG* pEdgePixels;
    int requiredPixels;

    // if the bitmap is too large we can use halfsize to resample it down to a more reasonable size...
    // on a fast proccessor, current performance tests show that for most preview images this won't be needed
    // but if the user scans an image at 300 dpi, this will come in handy.

    //    m_pScanBlurred->Despeckle(); // two despeckles has a greater effect than one

    // for FingSingleRegion we plan on doing one resample before image proccessing
    // with an expected image size of 200x300 pixels which greatly reduces the proccessor load
    m_resampleFactor=1;
    while (m_pScan->m_nBitmapWidth>GOALX || m_pScan->m_nBitmapHeight>GOALY)
    {
        m_pScan->HalfSize();
        m_resampleFactor*=2;
    }

    m_pScan->Invert(); // filters operate on inverted images

    m_pScan->CorrectBrightness();

    requiredPixels=m_pScan->m_nBitmapWidth*m_pScan->m_nBitmapHeight/256/10;
    if (requiredPixels==0) requiredPixels=1; // special case for a particularly small preview scan

    m_pScan->MaxContrast(requiredPixels); // spread the images color spectrum out... concept: balance color spectra between different scans

    m_pScanBlurred->CreateBlurBitmap(m_pScan);  // sets scanBlurred to be equal to a blurred version of m_pScan
    m_pScanDoubleBlurred->CreateBlurBitmap(m_pScanBlurred);
    m_pScanTripleBlurred->CreateBlurBitmap(m_pScanDoubleBlurred);  // sets scanBlurred to be equal to a blurred version of m_pScan
    m_pScanHorizontalBlurred->CreateHorizontalBlurBitmap(m_pScan);
    m_pScanVerticalBlurred->CreateVerticalBlurBitmap(m_pScan);

    m_pScanEdges->CreateDifferenceBitmap(m_pScan,m_pScanBlurred); // think about how you create an edge bitmap and you will understand
    m_pScanDoubleEdges->CreateDifferenceBitmap(m_pScanBlurred,m_pScanDoubleBlurred); // we will get a huge accuracy boost from this simple step
    m_pScanTripleEdges->CreateDifferenceBitmap(m_pScanDoubleBlurred,m_pScanTripleBlurred); // we will get a huge accuracy boost from this simple step

    m_pScanHorizontalEdges->CreateDifferenceBitmap(m_pScan,m_pScanHorizontalBlurred); // assuming the user was kind enough to place the image right side up
    m_pScanVerticalEdges->CreateDifferenceBitmap(m_pScan,m_pScanVerticalBlurred); // we will get a huge accuracy boost from this simple step

    // free memory as soon as it isn't needed
    if (m_pScanVerticalBlurred!=NULL)
    {
        delete m_pScanVerticalBlurred;
        m_pScanVerticalBlurred=NULL;
    }
    if (m_pScanHorizontalBlurred!=NULL)
    {
        delete m_pScanHorizontalBlurred;
        m_pScanHorizontalBlurred=NULL;
    }

    if (m_pScanDoubleBlurred!=NULL)
    {
        delete m_pScanDoubleBlurred;
        m_pScanDoubleBlurred=NULL;
    }

    if (m_pScanTripleBlurred!=NULL)
    {
        delete m_pScanTripleBlurred;
        m_pScanTripleBlurred=NULL;
    }

    // these 5 calls to killShadows make up the real meat of the region detection work done by the program.
    // KillShadows now performs more tasks than simply killing shadows. Killshadows also enhances edges
    // and removes background colors
    // the doubleBlur and tripleBlur edge maps are needed so that we can distinguish between an uneven background scanner color and a real image.
    // see KillShadows for more documentation.
    // m_pScanBlurred is the bitmap we will use to determine where regions are
    // these calls to KillShadows act to enhance pixels which are part of regions and inhibit pixels which are not part of regions

    m_pScanBlurred->KillShadows(m_pScanVerticalEdges, MAXSHADOWSTART,MAXSHADOWPIXEL+1,MAX_DIFFERENCE_FROM_GRAY,NOT_SHADOW_INTENSITY,false);
    m_pScanBlurred->KillShadows(m_pScanHorizontalEdges, MAXSHADOWSTART,MAXSHADOWPIXEL+1,MAX_DIFFERENCE_FROM_GRAY,NOT_SHADOW_INTENSITY,false);

    m_pScanBlurred->KillShadows(m_pScanEdges, MAXSHADOWSTART,MAXSHADOWPIXEL-1,MAX_DIFFERENCE_FROM_GRAY,NOT_SHADOW_INTENSITY,true);

    m_pScanBlurred->KillShadows(m_pScanDoubleEdges,MAXSHADOWSTART,MAXSHADOWPIXEL+2,MAX_DIFFERENCE_FROM_GRAY,NOT_SHADOW_INTENSITY,true);
    m_pScanBlurred->KillShadows(m_pScanTripleEdges, MAXSHADOWSTART,MAXSHADOWPIXEL+1,MAX_DIFFERENCE_FROM_GRAY,NOT_SHADOW_INTENSITY,true);

    // RemoveBlackBorder removes questionable pixels around the outside edge of an image.
    // RemoveBlackBorder has only very limited utility for region detection on images that were not aquired from a scanner
    m_pScan->RemoveBlackBorder(MIN_BLACK_SCANNER_EDGE_CHAN_VALUE,m_pScanBlurred,m_pScan);

    // despeckle removes small clumps of pixels which are probably stray static
    m_pScanBlurred->Despeckle(); // two despeckles has a greater effect than one
    m_pScanBlurred->Despeckle(); // two despeckles has a greater effect than one

    // pMap will hold information on which region each pixel on the screen is part of
    int *pMap=new int[m_pScanBlurred->m_nBitmapHeight*m_pScanBlurred->m_nBitmapWidth];
    if (pMap)
    {
        numChunks=m_pScanBlurred->FindChunks(pMap); // maps chunks on m_pScanBlurred to pMap

        if (m_pRegions!=NULL) delete m_pRegions;
        m_pRegions = new CRegionList(numChunks); // create a CRegionList to map the chunks onto.

        if (m_pRegions)
        {

            m_pRegions->m_nBitmapWidth=m_pScan->m_nBitmapWidth;
            m_pRegions->m_nBitmapHeight=m_pScan->m_nBitmapHeight;
            // now turn region map into region rectangles
            // it could be argued that this routine should be placed in C32BitDibWrapper
            // but we don't want to make C32BitDibWrapper encompas too much functionality which
            // would only be useful for imagedetection

            pImagePixels=(ULONG *)(m_pScanBlurred->m_pBits); // we want to use 32 bit chunks instead of 8 bit chunks
            pEdgePixels=(ULONG *)(m_pScanEdges->m_pBits);

            // add all the bitmap pixels to the m_pRegions list
            position=0;
            for (y=0;y<m_pScan->m_nBitmapHeight;y++)
            {
                for (x=0;x<m_pScan->m_nBitmapWidth;x++)
                {
                    if (pMap[position]>0)
                    {
                        m_pRegions->AddPixel(pMap[position]-1, pImagePixels[position],pEdgePixels[position], x, y); // pMap values start at 1, let region values start at 0
                    }                                                // we start pMap at 1 so that 0 can indicate a pixel that is not assigned to any region
                    position++;                                      // we may want to make pMap start at 0 at some later date
                }
            }

            m_pRegions->m_numRects=numChunks;
            m_pRegions->m_validRects=numChunks;

            // free bitmaps as soon as they will no longer be used
            if (m_pScanHorizontalEdges!=NULL)
            {
                delete m_pScanHorizontalEdges;
                m_pScanHorizontalEdges=NULL;
            }
            if (m_pScanVerticalEdges!=NULL)
            {
                delete m_pScanVerticalEdges;
                m_pScanVerticalEdges=NULL;
            }

            // merge together regions
            // this routine is pretty much a waste when performing single region detection
            // the only advantage of it over simply calling unionRegions is that
            // we can merge together small close together regions, but kill small regions that are far from other regions (probably static)

            for (border=0;border<MAXBORDER;border+=SINGLE_REGION_BORDER_INCREMENT) // when detecting a single region detection,
            {
                // we don't need to inch along one border pixel width increment at a time
                // as we know we want to compact down to a single region in the end
                unionOperationInLastPass=true;

                for (a=0;a<m_pRegions->m_numRects;a++) // overkill, we could be cleverer about when we check for valid regions
                {
                    m_pRegions->checkIfValidRegion(a, border); // sets m_valid params
                }

                m_pRegions->CompactDown(m_pRegions->m_validRects); // remove all invalid rects to save search time


                while (unionOperationInLastPass==true)
                {
                    unionOperationInLastPass=false;
                    for (a=0;a<m_pRegions->m_numRects;a++)
                    {
                        if (m_pRegions->m_valid[a]==true)
                        {
                            for (b=a+1;b<m_pRegions->m_numRects;b++)
                            {
                                if (m_pRegions->m_valid[b]==true)
                                {
                                    if (m_pRegions->CheckIntersect(a,b,border)==true)
                                    {
                                        m_pRegions->UnionRegions(a,b);
                                        m_pRegions->checkIfValidRegion(a, border); // in this context, checkvalid should have the effect of culling regions which are probably only stray dots
                                        unionOperationInLastPass=true;
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // m_pScanBlurred->ColorChunks(pMap); // for debugging purposes... so we know where exactly chunks are


            m_pRegions->CompactDown(m_pRegions->m_validRects); // remove all invalid rects to save search time
        }
        delete[] pMap;
    }

    return(TRUE);
}


// detect regions
// makes heavy use of C32BitWrapper helper functions
// WARNING: this function has not been updated to include the latest changes
// to compensate for poor image quality
//
int CRegionDetector::FindRegions()
{
    // cast the pointers
    // S = Scan, B = blank background, V = virtual screen... new image
    int x,y;
    int a,b;
    int i;
    bool done, weird;
    char* pWall; // 2d array keeping track of which regions have walls between them and other regions
    // wall vals... TRUE, FALSE, UNKNOWN
    int border; // for aggregation on a rectangle by rectangle basis
    ULONG position;
    int numChunks;
    bool unionOperationInLastPass;
    ULONG* pImagePixels;
    ULONG* pEdgePixels;
    int requiredPixels;

    // if the bitmap is too large we can use halfsize to resample it down to a more reasonable size...
    // on a fast proccessor, current performance tests show that for most preview images this won't be needed
    // but if the user scans an image at 300 dpi, this will come in handy.
    while (m_pScan->m_nBitmapWidth>GOALX || m_pScan->m_nBitmapHeight>GOALY)
    {
        m_pScan->HalfSize();
    }

    m_pScanBlurred->CreateBlurBitmap(m_pScan);  // sets scanBlurred to be equal to a blurred version of m_pScan
    m_pScanDoubleBlurred->CreateBlurBitmap(m_pScanBlurred);  // sets scanBlurred to be equal to a blurred version of m_pScan
    m_pScanTripleBlurred->CreateBlurBitmap(m_pScanDoubleBlurred);  // sets scanBlurred to be equal to a blurred version of m_pScan
    m_pScanHorizontalBlurred->CreateHorizontalBlurBitmap(m_pScan);
    m_pScanVerticalBlurred->CreateVerticalBlurBitmap(m_pScan);

    m_pScanDoubleHorizontalBlurred->CreateHorizontalBlurBitmap(m_pScanHorizontalBlurred);
    m_pScanDoubleVerticalBlurred->CreateVerticalBlurBitmap(m_pScanVerticalBlurred);


    m_pScanEdges->CreateDifferenceBitmap(m_pScan,m_pScanBlurred); // think about how you create an edge bitmap and you will understand
    m_pScanDoubleEdges->CreateDifferenceBitmap(m_pScanBlurred,m_pScanDoubleBlurred); // we will get a huge accuracy boost from this simple step
    m_pScanTripleEdges->CreateDifferenceBitmap(m_pScanDoubleBlurred,m_pScanTripleBlurred); // we will get a huge accuracy boost from this simple step

    m_pScanHorizontalEdges->CreateDifferenceBitmap(m_pScan,m_pScanHorizontalBlurred); // assuming the user was kind enough to place the image right side up
    m_pScanVerticalEdges->CreateDifferenceBitmap(m_pScan,m_pScanVerticalBlurred); // we will get a huge accuracy boost from this simple step

    m_pScanDoubleHorizontalEdges->CreateDifferenceBitmap(m_pScanHorizontalBlurred,m_pScanDoubleHorizontalBlurred); // assuming the user was kind enough to place the image right side up
    m_pScanDoubleVerticalEdges->CreateDifferenceBitmap(m_pScanVerticalBlurred,m_pScanDoubleVerticalBlurred); // we will get a huge accuracy boost from this simple step

    m_pScanBlurred->Invert(); // filters operate on inverted images

    requiredPixels=m_pScanBlurred->m_nBitmapWidth*m_pScanBlurred->m_nBitmapHeight/256/10;
    if (requiredPixels==0) requiredPixels=1; // special case for a particularly small preview scan

    m_pScanBlurred->CorrectBrightness();
    m_pScanBlurred->MaxContrast(requiredPixels);


    // free memory as soon as it isn't needed
    if (m_pScanVerticalBlurred!=NULL)
    {
        delete m_pScanVerticalBlurred;
        m_pScanVerticalBlurred=NULL;
    }
    if (m_pScanHorizontalBlurred!=NULL)
    {
        delete m_pScanHorizontalBlurred;
        m_pScanHorizontalBlurred=NULL;
    }

    if (m_pScanDoubleBlurred!=NULL)
    {
        delete m_pScanDoubleBlurred;
        m_pScanDoubleBlurred=NULL;
    }

    if (m_pScanTripleBlurred!=NULL)
    {
        delete m_pScanTripleBlurred;
        m_pScanTripleBlurred=NULL;
    }


    m_pScanWithShadows = new C32BitDibWrapper(m_pScanBlurred); // copy scanBlurred

    // eliminate shadows
    m_pScanBlurred->KillShadows(m_pScanTripleEdges, MAXSHADOWSTART,MAXSHADOWPIXEL-2,MAX_DIFFERENCE_FROM_GRAY,NOT_SHADOW_INTENSITY,false);
    m_pScanBlurred->KillShadows(m_pScanDoubleEdges,MAXSHADOWSTART,MAXSHADOWPIXEL-1,MAX_DIFFERENCE_FROM_GRAY,NOT_SHADOW_INTENSITY,false);
    m_pScanBlurred->KillShadows(m_pScanEdges, MAXSHADOWSTART,MAXSHADOWPIXEL+1,MAX_DIFFERENCE_FROM_GRAY,NOT_SHADOW_INTENSITY,false);
    m_pScanBlurred->KillShadows(m_pScanHorizontalEdges, MAXSHADOWSTART,MAXSHADOWPIXEL,MAX_DIFFERENCE_FROM_GRAY,NOT_SHADOW_INTENSITY,false);
    m_pScanBlurred->KillShadows(m_pScanVerticalEdges, MAXSHADOWSTART,MAXSHADOWPIXEL,MAX_DIFFERENCE_FROM_GRAY,NOT_SHADOW_INTENSITY,false);

    // compensate for background color
    // the average background color pixel will probably have a smaller edge factor than the average shadow,
    // but will have a larger difference from grey
    // hence to eliminate background color we ignore difference from grey... as accomplished by the (256*3) term

    m_pScanBlurred->KillShadows(m_pScanTripleEdges, 256*3,MAXSHADOWPIXEL-2,256*3,NOT_SHADOW_INTENSITY,false);
    m_pScanBlurred->KillShadows(m_pScanDoubleEdges,256*3,MAXSHADOWPIXEL-2,256*3,NOT_SHADOW_INTENSITY,false);
    m_pScanBlurred->KillShadows(m_pScanEdges, 256*3,MAXSHADOWPIXEL-2,256*3,NOT_SHADOW_INTENSITY,false);
    m_pScanBlurred->KillShadows(m_pScanHorizontalEdges, 256*3,MAXSHADOWPIXEL-2,256*3,NOT_SHADOW_INTENSITY,false);
    m_pScanBlurred->KillShadows(m_pScanVerticalEdges, 256*3,MAXSHADOWPIXEL-2,256*3,NOT_SHADOW_INTENSITY,false);

    // pure economics... edge pixels are much more likely to be junk
    // so economically, its worth it to risk
    // killing good edge pixels to get rid of the bad
    m_pScanBlurred->EdgeDespeckle();
    m_pScanBlurred->Despeckle(); // two despeckles has a greater effect than one
    m_pScanBlurred->Despeckle(); // two despeckles has a greater effect than one

    // prepare to find chunks

    int *pMap=new int[m_pScanBlurred->m_nBitmapHeight*m_pScanBlurred->m_nBitmapWidth];
    if (pMap)
    {
        done=false;
        weird=false;
        while (done==false) // we may have to repeat FindChunks if we find that we did not eliminate enough pixels and ended up with all pixels being determined to be part of the same region
        {
            done=true;
            numChunks=m_pScanBlurred->FindChunks(pMap); // fills the pMap array with chunks

            if (m_pRegions!=NULL) delete m_pRegions;
            m_pRegions = new CRegionList(numChunks);

            if (m_pRegions)
            {
                m_pRegions->m_nBitmapWidth=m_pScan->m_nBitmapWidth;
                m_pRegions->m_nBitmapHeight=m_pScan->m_nBitmapHeight;

                // now turn the pMap region map into region rectangles
                // it could be argued that this routine should be placed in C32BitDibWrapper
                // but we don't want to make C32BitDibWrapper encompas too much functionality which
                // clearly is directly connected with imagedetection

                pImagePixels=(ULONG *)(m_pScanBlurred->m_pBits); // we want to use 32 bit chunks instead of 8 bit chunks
                pEdgePixels=(ULONG *)(m_pScanEdges->m_pBits);


                position=0;
                for (y=0;y<m_pScan->m_nBitmapHeight;y++)
                {
                    for (x=0;x<m_pScan->m_nBitmapWidth;x++)
                    {
                        if (pMap[position]>0)
                        {
                            m_pRegions->AddPixel(pMap[position]-1, pImagePixels[position],pEdgePixels[position], x, y); // pMap values start at 1, let region values start at 0
                        }                                                // we start pMap at 1 so that 0 can indicate a pixel that is not assigned to any region
                        position++;                                      // we may want to make pMap start at 0 at some later date
                    }
                }

                m_pRegions->m_numRects=numChunks;
                m_pRegions->m_validRects=numChunks;
                // check for invalid regions
                for (a=0;a<m_pRegions->m_numRects;a++)
                {
                    m_pRegions->checkIfValidRegion(a); // sets m_valid params
                    m_pRegions->m_backgroundColorPixels[a]=m_pScan->PixelsBelowThreshold(m_pScanBlurred,m_pScanEdges,m_pRegions->m_pRects[a]);
                    m_pRegions->RegionType(a); // clasify regions... text or photo
                }


                m_pRegions->CompactDown(m_pRegions->m_validRects);
                if (m_pRegions->m_validRects==0) break; // if there aren't any regions, no sense in proceeding

                unionOperationInLastPass=true;
                while (unionOperationInLastPass==true)
                {
                    unionOperationInLastPass=false;
                    for (a=0;a<m_pRegions->m_numRects;a++)
                    {
                        if (m_pRegions->m_valid[a]==true)
                        {
                            for (b=a+1;b<m_pRegions->m_numRects;b++)
                            {
                                if (m_pRegions->m_valid[b]==true)
                                {
                                    // we are paranoid... we repeatedly check if two regions intersect each other.
                                    if (m_pRegions->CheckIntersect(a,b,0)==true)
                                    {
                                        m_pRegions->UnionRegions(a,b);
                                        m_pRegions->checkIfValidRegion(a, 0); // in this context, checkvalid should have the effect of culling regions which are probably only stray dots
                                        m_pRegions->RegionType(a); // figure out what type of region the combined region should be

                                        unionOperationInLastPass=true;
                                    }

                                }
                            }
                        }
                    }
                }

                if (weird==false &&
                    ((m_pRegions->m_pRects[0].right-m_pRegions->m_pRects[0].left)
                     *(m_pRegions->m_pRects[0].bottom-m_pRegions->m_pRects[0].top))
                    >
                    ((m_pScanBlurred->m_nBitmapWidth-DESPECKLE_BORDER_WIDTH*2)*(m_pScanBlurred->m_nBitmapWidth-DESPECKLE_BORDER_WIDTH*2)))
                {
                    weird=true;
                    done=false;

                    // you better not be grey or you are in trouble
                    // some seriously nasty shadow elimination
                    // we will probably eliminate too many good pixels
                    // but at least the poor user will get something more than just finding that the whole screen was selected
                    m_pScanBlurred->KillShadows(m_pScanTripleEdges, 256,MAXSHADOWPIXEL+4,MAX_DIFFERENCE_FROM_GRAY,NOT_SHADOW_INTENSITY,false);
                    m_pScanBlurred->KillShadows(m_pScanDoubleEdges,256,MAXSHADOWPIXEL+4,MAX_DIFFERENCE_FROM_GRAY,NOT_SHADOW_INTENSITY,false);
                    m_pScanBlurred->KillShadows(m_pScanEdges, 256,MAXSHADOWPIXEL+5,MAX_DIFFERENCE_FROM_GRAY,NOT_SHADOW_INTENSITY,false);
                    m_pScanBlurred->KillShadows(m_pScanHorizontalEdges, 256,MAXSHADOWPIXEL+4,MAX_DIFFERENCE_FROM_GRAY,NOT_SHADOW_INTENSITY,false);
                    m_pScanBlurred->KillShadows(m_pScanVerticalEdges, 256,MAXSHADOWPIXEL+4,MAX_DIFFERENCE_FROM_GRAY,NOT_SHADOW_INTENSITY,false);


                    m_pScanBlurred->KillShadows(m_pScanDoubleHorizontalEdges, MAXSHADOWSTART,MAXSHADOWPIXEL+4,MAX_DIFFERENCE_FROM_GRAY,NOT_SHADOW_INTENSITY,false);
                    m_pScanBlurred->KillShadows(m_pScanDoubleVerticalEdges, MAXSHADOWSTART,MAXSHADOWPIXEL+4,MAX_DIFFERENCE_FROM_GRAY,NOT_SHADOW_INTENSITY,false);


                    m_pScanBlurred->EdgeDespeckle();
                    m_pScanBlurred->Despeckle(); // two despeckles has a greater effect than one
                    //          m_pScanBlurred->EdgeDespeckle();
                    m_pScanBlurred->Despeckle(); // two despeckles has a greater effect than one

                }
            }
        }

        if (m_pRegions)
        {
            m_pRegions->CompactDown(m_pRegions->m_validRects); // compact down the CRegionList so that it nolonger includes invalidated regions

            // we store an array indicating which pairs of regions have walls between them
            // used for unioning together large text regions... for example, scanning
            // in two pages with a shadow between them

            pWall=new char[m_pRegions->m_numRects*m_pRegions->m_numRects];
            if (pWall)
            {
                for (a=0;a<m_pRegions->m_numRects;a++)
                {
                    if (m_pRegions->m_valid[a]==true)
                    {
                        for (b=a+1;b<m_pRegions->m_numRects;b++)
                        {
                            if (m_pRegions->m_valid[b]==true)
                            {
                                pWall[a*m_pRegions->m_numRects+b]=UNKNOWN;
                            }
                        }
                    }
                }

                // key ideas.  we need to (potentially) merge a large number of fragmented text regions and we need to avoid merging large photo regions
                // we also want to keep memory usage within reason...so we should delete stuff after we know we will nolonger use it.
                if (m_pScanHorizontalEdges!=NULL)
                {
                    delete m_pScanHorizontalEdges;
                    m_pScanHorizontalEdges=NULL;
                }
                if (m_pScanVerticalEdges!=NULL)
                {
                    delete m_pScanVerticalEdges;
                    m_pScanVerticalEdges=NULL;
                }

                for (border=0;border<MAXBORDER;border++) // loop through each possible border with consecutivelly
                {
                    unionOperationInLastPass=true;
                    while (unionOperationInLastPass==true)
                    {
                        unionOperationInLastPass=false;
                        for (a=0;a<m_pRegions->m_numRects;a++)
                        {
                            if (m_pRegions->m_valid[a]==true)
                            {
                                for (b=a+1;b<m_pRegions->m_numRects;b++)
                                {
                                    if (m_pRegions->m_valid[b]==true)
                                    {
                                        // we are paranoid... we repeatedly check if two regions intersect each other.
                                        if (m_pRegions->CheckIntersect(a,b,0)==true)
                                        {
                                            m_pRegions->UnionRegions(a,b);
                                            m_pRegions->checkIfValidRegion(a, 0); // in this context, checkvalid should have the effect of culling regions which are probably only stray dots
                                            m_pRegions->RegionType(a); // figure out what type of region the combined region should be

                                            for (i=a+1;i<m_pRegions->m_numRects;i++)
                                                if (m_pRegions->m_valid[i]==TRUE)
                                                    pWall[a*m_pRegions->m_numRects+i]=UNKNOWN;

                                            for (i=0;i<a;i++)
                                                if (m_pRegions->m_valid[i]==TRUE)
                                                    pWall[i*m_pRegions->m_numRects+a]=UNKNOWN;


                                            unionOperationInLastPass=true;
                                        }

                                        // now the complex part.  check for intersections after growing borders around regions
                                        // but only if we don't have two photo regions
                                        if (MERGE_REGIONS)
                                        {
                                            if ((m_pRegions->m_type[a]&TEXT_REGION && m_pRegions->m_type[b]&TEXT_REGION)
                                                ||(((m_pRegions->m_type[a]|m_pRegions->m_type[b])&MERGABLE_WITH_PHOTOGRAPH)&&border<MERGABLE_WITH_PHOTOGRAPH)
                                                ||(border<MAX_MERGE_PHOTO_REGIONS && (m_pRegions->Size(a)<MAX_MERGABLE_PHOTOGRAPH_SIZE || m_pRegions->Size(b)<MAX_MERGABLE_PHOTOGRAPH_SIZE)))
                                            {
                                                if (m_pRegions->CheckIntersect(a,b,border)==true)
                                                {
                                                    if (border<MERGABLE_WITHOUT_COLLISIONDETECTION)
                                                    {
                                                        m_pRegions->UnionRegions(a,b);
                                                        m_pRegions->checkIfValidRegion(a, border); // in this context, checkvalid should have the effect of culling regions which are probably only stray dots
                                                        m_pRegions->RegionType(a); // figure out what type of region the combined region should be

                                                        for (i=a+1;i<m_pRegions->m_numRects;i++)
                                                            if (m_pRegions->m_valid[i]==TRUE)
                                                                pWall[a*m_pRegions->m_numRects+i]=UNKNOWN;

                                                        for (i=0;i<a;i++)
                                                            if (m_pRegions->m_valid[i]==TRUE)
                                                                pWall[i*m_pRegions->m_numRects+a]=UNKNOWN;


                                                        unionOperationInLastPass=true;
                                                    }

                                                    else
                                                    {
                                                        if (pWall[a*m_pRegions->m_numRects+b]==UNKNOWN)
                                                            pWall[a*m_pRegions->m_numRects+b]=CollisionDetection(m_pRegions->m_pRects[a],m_pRegions->m_pRects[b],m_pScanWithShadows);

                                                        if (pWall[a*m_pRegions->m_numRects+b]==TRUE || (m_pRegions->m_type[a]&PHOTOGRAPH_REGION) || (m_pRegions->m_type[b]&PHOTOGRAPH_REGION))
                                                        {
                                                            if (!m_pRegions->MergerIntersectsPhoto(a,b))
                                                            {
                                                                m_pRegions->UnionRegions(a,b);
                                                                m_pRegions->checkIfValidRegion(a, border); // in this context, checkvalid should have the effect of culling regions which are probably only stray dots
                                                                m_pRegions->RegionType(a); // figure out what type of region the combined region should be
                                                                unionOperationInLastPass=true;
                                                                // region a has changed so reset collision flags

                                                                for (i=a+1;i<m_pRegions->m_numRects;i++)
                                                                    if (m_pRegions->m_valid[i]==TRUE)
                                                                        pWall[a*m_pRegions->m_numRects+i]=UNKNOWN;

                                                                for (i=0;i<a;i++)
                                                                    if (m_pRegions->m_valid[i]==TRUE)
                                                                        pWall[i*m_pRegions->m_numRects+a]=UNKNOWN;

                                                                if (border>=MERGABLE_WITHOUT_COLLISIONDETECTION) border=MERGABLE_WITHOUT_COLLISIONDETECTION-2;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }

                // we have stricter requirements for region validity after we have done the border search.
                for (a=0;a<m_pRegions->m_numRects;a++)
                {
                    m_pRegions->checkIfValidRegion(a,DONE_WITH_BORDER_CHECKING);
                }

                //  m_pScanBlurred->ColorChunks(pMap); // for debugging purposes... so we know where exactly chunks are
                m_pRegions->CompactDown(m_pRegions->m_validRects+10); // we don't want to hand the user a list which includes invalidated regions

                //
                // free pWall
                //
                delete[] pWall;
            }
        }
        delete[] pMap;
    }
    return(TRUE);
}

bool CRegionDetector::CollisionDetection(RECT r1, RECT r2, C32BitDibWrapper* pImage)
{
    // use tracer lines to determine if there is an obstical between the two regions... be it possibly a photograph region or a speckle which we were wise enough to delete
    // we should cache collision results, but we are lazy and compared with the time taken by all of the filters which edited every single bitmap pixel, time spent here is trivial
    // first we need to determine how the regions are located with respect to each other
    // we do three tracer rays (top edge to top edge, median to median, and bottom to bottom)
    // throw out the edge with the highest collsion value... maybe we were unlucky and hit a stray speckle
    //
    // Diagram
    //  .____ 253
    //  ._
    //  . \*
    //   \  \ 43531 <-- hit speckle, throw out value
    //    \
    //     \ 215
    //  average intensity value: aprox 230 so its safe to merge the two regions
    ULONG resistance[3];
    //  ULONG totalResistance;
    ULONG maxResistance,minResistance,i;

    if (r1.right < r2.left)  // region 1 is to the left of region 2
    {
        resistance[0]=pImage->Line(r1.right,r1.top,r2.left,r2.top);
        resistance[1]=pImage->Line(r1.right,r1.bottom,r2.left,r2.bottom);
        resistance[2]=pImage->Line(r1.right,(r1.bottom+r1.top)/2,r2.left,(r2.bottom+r2.top)/2);
    }
    else
        if (r2.right < r1.left)  //region 2 is to the left of region 1
    {
        resistance[0]=pImage->Line(r2.right,r2.top,r1.left,r1.top);
        resistance[1]=pImage->Line(r2.right,r2.bottom,r1.left,r1.bottom);
        resistance[2]=pImage->Line(r2.right,(r2.bottom+r2.top)/2,r1.left,(r1.bottom+r1.top)/2);
    }
    else
        if (r1.bottom < r2.top)  // region 1 is above region 2
    {
        resistance[0]=pImage->Line(r1.right,r1.bottom,r2.right,r2.top);
        resistance[1]=pImage->Line(r1.left,r1.bottom,r2.left,r2.top);
        resistance[2]=pImage->Line((r1.left+r1.right)/2,r1.bottom,(r2.left+r2.right)/2,r2.top);
    }
    else
        if (r2.bottom < r1.top)  // region 2 is above region 1
    {
        resistance[0]=pImage->Line(r2.right,r2.bottom,r1.right,r1.top);
        resistance[1]=pImage->Line(r2.left,r2.bottom,r1.left,r1.top);
        resistance[2]=pImage->Line((r2.left+r2.right)/2,r2.bottom,(r1.left+r1.right)/2,r1.top);
    }

    // we used to have a more complex scheme where we took the average of the lower two values
    // hence some of the following code is legacy code from that experiment
    maxResistance=0;
    minResistance=MAX_RESISTANCE_ALLOWED_TO_UNION+1;
    for (i=0;i<3;i++)
    {
        if (resistance[i]>maxResistance) maxResistance=resistance[i];
        if (resistance[i]<minResistance) minResistance=resistance[i];
    }

    //totalResistance=resistance[0]+resistance[1]+resistance[2]-maxResistance;
    if (minResistance>MAX_RESISTANCE_ALLOWED_TO_UNION)
    {
        return(false);
    }
    else
    {
        return(true);
    }
}




// CRegionList member functions:

CRegionList::CRegionList(int num)
{
    int i;
    m_numRects=0;
    m_maxRects=num;
    m_nBitmapWidth=0;
    m_nBitmapHeight=0;
    m_pRects = new RECT[num];
    m_pixelsFilled = new ULONG[num];
    m_valid= new bool[num];
    m_type = new int[num];
    m_totalColored= new ULONG[num];
    m_totalIntensity= new ULONG[num];
    m_totalEdge= new ULONG[num];
    m_backgroundColorPixels = new int[num];
    //
    // Make sure all of the memory allocations succeeded
    //
    if (m_pRects && m_pixelsFilled && m_valid && m_type && m_totalColored && m_totalIntensity && m_totalEdge && m_backgroundColorPixels)
    {
        for (i=0;i<num;i++)
        {
            m_pixelsFilled[i]=0;
            m_totalColored[i]=0;
            m_totalIntensity[i]=0;
            m_totalEdge[i]=0;
            m_valid[i]=true;
            m_backgroundColorPixels[i] = -1;
            m_type[i]=PHOTOGRAPH_REGION;
        }
    }
    else
    {
        //
        // If all of the memory allocations didn't succeed, free all allocated memory
        //
        delete[] m_pRects;
        delete[] m_pixelsFilled;
        delete[] m_valid;
        delete[] m_type;
        delete[] m_totalColored;
        delete[] m_totalIntensity;
        delete[] m_totalEdge;
        delete[] m_backgroundColorPixels;
        m_pRects = NULL;
        m_pixelsFilled = NULL;
        m_valid = NULL;
        m_type = NULL;
        m_totalColored = NULL;
        m_totalIntensity = NULL;
        m_totalEdge = NULL;
        m_backgroundColorPixels = NULL;
    }
}


int CRegionList::UnionIntersectingRegions()
{
    bool unionOperationInLastPass;
    int numUnionOperations;
    int a,b;
    numUnionOperations=0;
    unionOperationInLastPass=true;
    while (unionOperationInLastPass==true)
    {
        unionOperationInLastPass=false;
        for (a=0;a<m_numRects;a++)
        {
            if (m_valid[a]==true)
                for (b=a+1;b<m_numRects;b++)
                    if (m_valid[b]==true)
                    {
                        // we are paranoid... we repeatedly check if two regions intersect each other.
                        if (CheckIntersect(a,b,0)==true)
                        {
                            UnionRegions(a,b);
                            unionOperationInLastPass=true;
                            numUnionOperations++;
                        }

                    }
        }
    }
    return(numUnionOperations);
}


RECT CRegionList::unionAll()
{
    int i,j;

    for (i=0;i<m_numRects;i++)
    {
        if (m_valid[i]==true)
        {
            for (j=i+1;j<m_numRects;j++)
            {
                if (m_valid[j]==true)
                {
                    UnionRegions(i,j);
                }

            }
            return(m_pRects[i]);
        }
    }
    RECT invalidRect;
    invalidRect.left=0;invalidRect.top=0;invalidRect.right=0;invalidRect.bottom=0;
    return(invalidRect);
}

RECT CRegionList::nthRegion(int num)
{
    int i;
    int n;

    for (i=0,n=0;i<m_maxRects;i++)
    {
        if (m_valid[i]==true)
        {
            if (num==n) return(m_pRects[i]);
            n++;
        }
    }
    RECT invalidRect;
    invalidRect.left=0;invalidRect.top=0;invalidRect.right=0;invalidRect.bottom=0;
    return(invalidRect);
}

int CRegionList::RegionType(int region)
{

    if (ClassifyRegion(region)>TEXTPHOTO_THRESHOLD)
    {
        m_type[region]=PHOTOGRAPH_REGION; // regions which we are very confident with
    }
    else
    {
        m_type[region]=TEXT_REGION; /// regions we don't have a darn clue about
        if (largeRegion(region)==true) m_type[region]=TEXT_REGION|MERGABLE_WITH_PHOTOGRAPH;
    }
    return(m_type[region]);
}


bool CRegionList::largeRegion(int region)
{
    int width, height, size;
    width=(m_pRects[region].right-m_pRects[region].left);
    height=(m_pRects[region].bottom-m_pRects[region].top);
    size=width*height;
    if (size>LARGEREGION_THRESHOLD) return(true);
    return(false);
}

double CRegionList::ClassifyRegion(int region) // determine if the region is a text or a graphics region
{   // higher numbers are photo regions
    // low numbers are text regions
    // this function is not been written for speed
    // its been written so that it is still almost understandable
    // concept: use a bunch of tests that are accurate about 75% of the time
    // to get a test that is accurate 99.9% of the time
    double edgeFactor; // shadows and stray smudges should have real low edge factors... but
    // dots should have high edge factors
    double intensityFactor; // if a region has a very high intensity factor, forget about worrying if it is valid or not
    double colorFactor; // a region with a lot of color is unlikely to be a stray speckle
    double aspectRatioFactor;
    double width,height;
    double size;
    double textRegionStylePixelsFactor;
    double classificationValue;
    width=(double)(m_pRects[region].right-m_pRects[region].left)+.01; // avoid divide by zero
    height=(double)(m_pRects[region].bottom-m_pRects[region].top)+.01; // avoid divide by zero
    size=width*height;
    if (width>height) aspectRatioFactor=height/width;
    else aspectRatioFactor=width/height;
    //if(m_pixelsFilled<MINREGIONPIXELS) sizeFactor=-100;
    edgeFactor = (double)m_totalEdge[region]/(double)m_pixelsFilled[region]+.01; // avoid divide by zero
    colorFactor= ((double)m_totalColored[region]/(double)m_pixelsFilled[region]);
    colorFactor=(colorFactor+110)/2; // otherwise we kill all black and white photos
    intensityFactor = (double)m_totalIntensity[region]/(double)m_pixelsFilled[region];

    textRegionStylePixelsFactor=(double)m_backgroundColorPixels[region]/size*100;
    if (textRegionStylePixelsFactor<2) textRegionStylePixelsFactor=2;

    classificationValue=colorFactor/intensityFactor/edgeFactor*aspectRatioFactor/textRegionStylePixelsFactor/textRegionStylePixelsFactor*30000;  // square text region factor because its the most accurate test we have so we don't want some other tests distorting its results

    // get rid of annoying stray speckles which the computer thinks are photographs
    /*      if(classificationValue>=MIN_BORDERLINE_TEXTPHOTO && classificationValue <=MAX_BORDERLINE_TEXTPHOTO)
            {
                classificationValue*=size/REASONABLE_PHOTO_SIZE; // big images are usually pictures.. and big images which are text blocks should have had very low color vals
                // add more tests here
                // potentially add more time intensive tests such as count num colors
            }*/

    //          classificationValue=textRegionStylePixelsFactor; // debug
    return(classificationValue);
}

bool CRegionList::checkIfValidRegion(int region, int border) // syncs whether a region is valid or not
{
    if (m_valid[region]==true) // ignore already invalidated regions
    {
        m_valid[region]=ValidRegion(region, border);
        if (m_valid[region]==false) m_validRects--;
    }
    return(m_valid[region]);
}

bool CRegionList::ValidRegion(int region, int border) // determines if a region is likely a worthless speck of dust or shadow or if we should care about the region
{
    double aspectRatioFactor;
    double width,height;
    double size;
    int edgePenaltyFactor;
    // check if the region crosses the EDGE_PENALTY_WIDTH outer pixels of the image
    width=(double)(m_pRects[region].right-m_pRects[region].left)+.01; // just to be safe to avoid divide by zero
    height=(double)(m_pRects[region].bottom-m_pRects[region].top)+.01; // just to be safe to avoid divide by zero

    edgePenaltyFactor=1;
    // disable penalty factor calculations
    /*        if(    m_pRects[region].left<EDGE_PENALTY_WIDTH
                || m_pRects[region].top<EDGE_PENALTY_WIDTH
                || m_nBitmapHeight-m_pRects[region].bottom<EDGE_PENALTY_WIDTH
                || m_nBitmapWidth-m_pRects[region].right<EDGE_PENALTY_WIDTH)
            {
                if(border>MAX_MERGE_DIFFERENT_REGIONS) edgePenaltyFactor=EDGE_PENALTY_FACTOR;
                else edgePenaltyFactor=CLOSE_TO_EDGE_PENALTY_FACTOR;
            }
            else
            if(    m_pRects[region].left<CLOSE_TO_EDGE_PENALTY_WIDTH
                || m_pRects[region].top<CLOSE_TO_EDGE_PENALTY_WIDTH
                || m_nBitmapHeight-m_pRects[region].bottom<CLOSE_TO_EDGE_PENALTY_WIDTH
                || m_nBitmapWidth-m_pRects[region].right<CLOSE_TO_EDGE_PENALTY_WIDTH)
            {
                edgePenaltyFactor=CLOSE_TO_EDGE_PENALTY_FACTOR;
            }*/

    if (border<MAX_NO_EDGE_PIXEL_REGION_PENALTY) edgePenaltyFactor=1;
    if (border>MAX_MERGE_DIFFERENT_REGIONS) edgePenaltyFactor=edgePenaltyFactor*2;
    //        if(border>BORDER_EXTREME_EDGE_PIXEL_REGION_PENALTY) edgePenaltyFactor=edgePenaltyFactor*2;



    size=width*height; // the problem child text regions are small ones... so we use the size of the image as a factor
    if (width>height) aspectRatioFactor=height/width;
    else aspectRatioFactor=width/height;

    // its too small
    if ((int)m_pixelsFilled[region]<MINREGIONPIXELS*edgePenaltyFactor) return(false);
    if (size<MINSIZE*edgePenaltyFactor) return(false);

    if (border == DONE_WITH_BORDER_CHECKING)
    {
        if (size<MIN_FINAL_REGION_SIZE*edgePenaltyFactor) return(false);
    }

    // its too narrow
    if (width<MINWIDTH*edgePenaltyFactor || height<MINWIDTH*edgePenaltyFactor) return(false);

    if ((1/aspectRatioFactor)*edgePenaltyFactor>MAXREGIONRATIO && (width*edgePenaltyFactor<IGNORE_RATIO_WIDTH || height<IGNORE_RATIO_WIDTH)) return(false);

    return(true);
}

bool CRegionList::InsideRegion(int region, int x, int y, int border) // border is the amount of border space to place around the outside of the region
{
    if (x>=(m_pRects[region].left-border)
        &&  x<=(m_pRects[region].right+border)
        &&  y>=(m_pRects[region].top-border)
        &&  y<=(m_pRects[region].bottom+border))
        return(true);
    return(false);
}

void CRegionList::AddPixel(int region, ULONG pixel,ULONG edge, int x, int y)
{
    if (m_pixelsFilled[region]!=0)
    {
        if (x<m_pRects[region].left) m_pRects[region].left=x;
        if (x>m_pRects[region].right) m_pRects[region].right=x;
        if (y<m_pRects[region].top) m_pRects[region].top=y;
        if (y>m_pRects[region].bottom) m_pRects[region].bottom=y;
    }
    else // init region
    {
        m_pixelsFilled[region]=0;
        m_totalColored[region]=0;
        m_totalIntensity[region]=0;
        m_pRects[region].left=x;
        m_pRects[region].right=x;
        m_pRects[region].top=y;
        m_pRects[region].bottom=y;
        m_numRects++;
        m_validRects++;
    }
    m_pixelsFilled[region]++;
    m_totalColored[region]+=DifferenceFromGray(pixel);
    m_totalIntensity[region]+=Intensity(pixel);
    m_totalEdge[region]+=Intensity(edge);

}

// unions two regions together... region b is invalidated
bool CRegionList::UnionRegions(int a, int b)
{
    if (m_valid[a]!=true || m_valid[b]!=true) return(false); // the user tried to union an invalidated region
    m_valid[b]=false;
    m_pRects[a].left=MIN(m_pRects[a].left,m_pRects[b].left);
    m_pRects[a].top=MIN(m_pRects[a].top,m_pRects[b].top);
    m_pRects[a].right=MAX(m_pRects[a].right,m_pRects[b].right);
    m_pRects[a].bottom=MAX(m_pRects[a].bottom,m_pRects[b].bottom);
    m_pixelsFilled[a]+=m_pixelsFilled[b];
    m_totalColored[a]+=m_totalColored[b];
    m_totalIntensity[a]+=m_totalIntensity[b];
    m_totalEdge[a]+=m_totalEdge[b];
    m_backgroundColorPixels[a]+=m_backgroundColorPixels[b];

    m_validRects--;
    return(true);
}

RECT CRegionList::UnionRects(RECT a, RECT b)
{
    RECT result;
    result.left=MIN(a.left,b.left);
    result.top=MIN(a.top,b.top);
    result.right=MAX(a.right,b.right);
    result.bottom=MAX(a.bottom,b.bottom);
    return(result);
}

bool CRegionList::MergerIntersectsPhoto(int a, int b) // if we merge these two regions, will we also be merging with a photo region (a taboo)
{
    RECT mergedRect;
    int i;
    mergedRect=UnionRects(m_pRects[a],m_pRects[b]);
    for (i=0;i<m_numRects;i++)
        if (m_valid[i]==true && (m_type[i]&PHOTOGRAPH_REGION) && a!=i && b!=i)
        {
            if (CheckIntersect(mergedRect,m_pRects[i])) return(true);
        }
    return(false);
}

// see InsideRegion for an explaination of what border is
bool CRegionList::CheckIntersect(int a, int b, int border) // do regions a and b intersect?
{
    return(CheckIntersect(m_pRects[a],m_pRects[b],border));
}

bool CRegionList::CheckIntersect(RECT r1, RECT r2, int border) // do regions a and b intersect?
{
    RECT intersect;
    // grow r1 by border
    // note: it shouldn't make any difference which rectangle we choose to grow
    r1.left-=border;
    r1.right+=border;
    r1.top-=border;
    r1.bottom+=border;

    intersect = Intersect(r1,r2);
    if (intersect.left<intersect.right && intersect.bottom>intersect.top)
        return(true);
    else
        return(false);
    /* // old buggy code for checking if two regions intersected

            if(InsideRegion(r1,r2.left,r2.top,border)    ||  // check if any of the four corner pixels are inside the other region
               InsideRegion(r1,r2.left,r2.bottom,border) ||
               InsideRegion(r1,r2.right,r2.top,border)   ||  // b inside a
               InsideRegion(r1,r2.right,r2.bottom,border)||

               InsideRegion(r2,r1.left,r1.top,border)    ||  // a inside b
               InsideRegion(r2,r1.left,r1.bottom,border) ||
               InsideRegion(r2,r1.right,r1.top,border)   ||
               InsideRegion(r2,r1.right,r1.bottom,border)
               )
                return true;
            else
                return false;*/
}

RECT CRegionList::Intersect(RECT r1, RECT r2)
{
    RECT intersect;
    intersect.left=MAX(r1.left,r2.left);
    intersect.right=MIN(r1.right,r2.right);
    intersect.top=MAX(r1.top,r2.top);
    intersect.bottom=MIN(r1.bottom,r2.bottom);
    if (intersect.left<=intersect.right && intersect.top<=intersect.bottom)
        return(intersect);
    else
    {
        intersect.left=-1;
        intersect.right=-1;
        intersect.top=-1;
        intersect.bottom=-1;
        return(intersect);
    }
}

bool CRegionList::InsideRegion(RECT region, int x, int y, int border) // border is the amount of border space to place around the outside of the region
{
    if (x>=(region.left-border)
        &&  x<=(region.right+border)
        &&  y>=(region.top-border)
        &&  y<=(region.bottom+border))
        return(true);
    return(false);
}

// compact down ignores all other info aside from rect location
// leads to faster access
void CRegionList::CompactDown(int size)
{
    int i;
    int j = 0;
    RECT * compactedRects = new RECT[size];
    bool * compactedValid = new bool[size];
    int * compactedType = new int[size];
    int * compactedBackgroundColorPixels = new int[size];
    ULONG * compactedPixelsFilled = new ULONG[size]; // how many of the pixels in the region were actually selected?
    ULONG * compactedTotalColored = new ULONG[size]; // accumulated color difference indicator
    ULONG * compactedTotalIntensity = new ULONG[size]; // accumulated intensity indicator
    ULONG * compactedTotalEdge = new ULONG[size]; // accumulated edge values

    //
    // Make sure all of the memory allocations succeeded
    //
    if (compactedRects && compactedValid && compactedType && compactedBackgroundColorPixels && compactedPixelsFilled && compactedTotalColored && compactedTotalIntensity && compactedTotalEdge)
    {
        for (i=0;i<m_numRects;i++)
        {
            if (m_valid[i])
            {
                compactedRects[j]=m_pRects[i];
                compactedValid[j]=true;
                compactedType[j]=m_type[i];
                compactedPixelsFilled[j]=m_pixelsFilled[i];
                compactedTotalColored[j]=m_totalColored[i];
                compactedTotalIntensity[j]=m_totalIntensity[i];
                compactedTotalEdge[j]=m_totalEdge[i];
                compactedBackgroundColorPixels[j]=m_backgroundColorPixels[i];
                j++;
            }
        }

        // fill out the rest of the list
        for (i=m_validRects;i<size;i++)
        {
            compactedValid[i]=false;
        }

        delete m_pRects;
        delete m_valid;
        delete m_type;
        delete m_pixelsFilled;
        delete m_totalColored;
        delete m_totalIntensity;
        delete m_totalEdge;
        delete m_backgroundColorPixels;

        m_pRects=compactedRects;
        m_valid=compactedValid;
        m_type=compactedType;
        m_pixelsFilled=compactedPixelsFilled;
        m_totalColored=compactedTotalColored;
        m_totalIntensity=compactedTotalIntensity;
        m_totalEdge=compactedTotalEdge;
        m_backgroundColorPixels=compactedBackgroundColorPixels;

        m_numRects=size;
    }
    else
    {
        //
        // Otherwise, just release all of the memory we allocated
        //
        delete[] compactedRects;
        delete[] compactedValid;
        delete[] compactedType;
        delete[] compactedBackgroundColorPixels;
        delete[] compactedPixelsFilled;
        delete[] compactedTotalColored;
        delete[] compactedTotalIntensity;
        delete[] compactedTotalEdge;
    }
    // we could delete all of the other region list info right here
}

// dibs are stored upside down from normal screen coords
// so apps will often want to flip the bitmap first
void CRegionList::FlipVertically()
{
    int i;
    int temp;
    for (i=0;i<m_numRects;i++)
    {
        temp=m_nBitmapHeight-m_pRects[i].top-1;
        m_pRects[i].top=m_nBitmapHeight-m_pRects[i].bottom-1;
        m_pRects[i].bottom=temp;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\pshelper.h ===
#ifndef __PSHELPER_H_INCLUDED
#define __PSHELPER_H_INCLUDED

#include <windows.h>
#include "simstr.h"
#include "simarray.h"

namespace PropStorageHelpers
{
    struct CPropertyRange
    {
        LONG nMin;
        LONG nMax;
        LONG nStep;
    };

    class CPropertyId
    {
    private:
        CSimpleStringWide m_strPropId;
        PROPID m_nPropId;
        bool m_bIsStringPropId;
    public:
        CPropertyId(void);
        CPropertyId( const CSimpleStringWide &strPropId );
        CPropertyId( PROPID propId );
        CPropertyId( const CPropertyId &other );
        ~CPropertyId(void);
        CPropertyId &operator=( const CPropertyId &other );
        CSimpleStringWide PropIdString(void) const;
        PROPID PropIdNumber(void) const;
        bool IsString(void) const;
    };

    bool GetProperty( IUnknown *pIUnknown, const CPropertyId &propertyName, PROPVARIANT &pPropVar );
    bool GetProperty( IUnknown *pIUnknown, const CPropertyId &propertyName, CSimpleStringWide &strPropertyValue );
    bool GetProperty( IUnknown *pIUnknown, const CPropertyId &propertyName, GUID &guidValue );
    bool GetProperty( IUnknown *pIUnknown, const CPropertyId &propertyName, LONG &nValue );

    bool SetProperty( IUnknown *pIUnknown, const CPropertyId &propertyName, PROPVARIANT &pPropVar, PROPID nNameFirst=2 );
    bool SetProperty( IUnknown *pIUnknown, const CPropertyId &propertyName, LONG nValue, PROPID nNameFirst=2 );
    bool SetProperty( IUnknown *pIUnknown, const CPropertyId &propertyName, const GUID &guidValue, PROPID nNameFirst=2 );

    bool GetPropertyAttributes( IUnknown *pIUnknown, const CPropertyId &propertyName, ULONG &nAccessFlags, PROPVARIANT &pvAttributes );
    bool GetPropertyAttributes( IUnknown *pIUnknown, const CPropertyId &propertyName, PROPVARIANT &pvAttributes );
    bool GetPropertyAccessFlags( IUnknown *pIUnknown, const CPropertyId &propertyName, ULONG &nAccessFlags );
    bool GetPropertyRange( IUnknown *pIUnknown, const CPropertyId &propertyName, CPropertyRange &propertyRange );
    bool GetPropertyList( IUnknown *pIUnknown, const CPropertyId &propertyName, CSimpleDynamicArray<LONG> &aProp );
    bool GetPropertyList( IUnknown *pIUnknown, const CPropertyId &propertyName, CSimpleDynamicArray<GUID> &aProp );
    bool GetPropertyFlags( IUnknown *pIUnknown, const CPropertyId &propertyName, LONG &nFlags );
    bool IsReadOnlyProperty( IUnknown *pIUnknown, const CPropertyId &propertyName );
}

#endif //__PSHELPER_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\pshelper.cpp ===
#include "precomp.h"
#pragma hdrstop

#if defined(DBG)

WIA_PROPID_TO_NAME g_wiaPropIdToName[] =
{
    { WIA_DIP_DEV_ID, WIA_DIP_DEV_ID_STR },
    { WIA_DIP_VEND_DESC, WIA_DIP_VEND_DESC_STR },
    { WIA_DIP_DEV_DESC, WIA_DIP_DEV_DESC_STR },
    { WIA_DIP_DEV_TYPE, WIA_DIP_DEV_TYPE_STR },
    { WIA_DIP_PORT_NAME, WIA_DIP_PORT_NAME_STR },
    { WIA_DIP_DEV_NAME, WIA_DIP_DEV_NAME_STR },
    { WIA_DIP_SERVER_NAME, WIA_DIP_SERVER_NAME_STR },
    { WIA_DIP_REMOTE_DEV_ID, WIA_DIP_REMOTE_DEV_ID_STR },
    { WIA_DIP_UI_CLSID, WIA_DIP_UI_CLSID_STR },
    { WIA_DIP_HW_CONFIG, WIA_DIP_HW_CONFIG_STR },
    { WIA_DIP_BAUDRATE, WIA_DIP_BAUDRATE_STR },
    { WIA_DIP_STI_GEN_CAPABILITIES, WIA_DIP_STI_GEN_CAPABILITIES_STR },
    { WIA_DPA_FIRMWARE_VERSION, WIA_DPA_FIRMWARE_VERSION_STR },
    { WIA_DPA_CONNECT_STATUS, WIA_DPA_CONNECT_STATUS_STR },
    { WIA_DPA_DEVICE_TIME, WIA_DPA_DEVICE_TIME_STR },
    { WIA_DPC_PICTURES_TAKEN, WIA_DPC_PICTURES_TAKEN_STR },
    { WIA_DPC_PICTURES_REMAINING, WIA_DPC_PICTURES_REMAINING_STR },
    { WIA_DPC_EXPOSURE_MODE, WIA_DPC_EXPOSURE_MODE_STR },
    { WIA_DPC_EXPOSURE_COMP, WIA_DPC_EXPOSURE_COMP_STR },
    { WIA_DPC_EXPOSURE_TIME, WIA_DPC_EXPOSURE_TIME_STR },
    { WIA_DPC_FNUMBER, WIA_DPC_FNUMBER_STR },
    { WIA_DPC_FLASH_MODE, WIA_DPC_FLASH_MODE_STR },
    { WIA_DPC_FOCUS_MODE, WIA_DPC_FOCUS_MODE_STR },
    { WIA_DPC_FOCUS_MANUAL_DIST, WIA_DPC_FOCUS_MANUAL_DIST_STR },
    { WIA_DPC_ZOOM_POSITION, WIA_DPC_ZOOM_POSITION_STR },
    { WIA_DPC_PAN_POSITION, WIA_DPC_PAN_POSITION_STR },
    { WIA_DPC_TILT_POSITION, WIA_DPC_TILT_POSITION_STR },
    { WIA_DPC_TIMER_MODE, WIA_DPC_TIMER_MODE_STR },
    { WIA_DPC_TIMER_VALUE, WIA_DPC_TIMER_VALUE_STR },
    { WIA_DPC_POWER_MODE, WIA_DPC_POWER_MODE_STR },
    { WIA_DPC_BATTERY_STATUS, WIA_DPC_BATTERY_STATUS_STR },
    { WIA_DPC_THUMB_WIDTH, WIA_DPC_THUMB_WIDTH_STR },
    { WIA_DPC_THUMB_HEIGHT, WIA_DPC_THUMB_HEIGHT_STR },
    { WIA_DPC_PICT_WIDTH, WIA_DPC_PICT_WIDTH_STR },
    { WIA_DPC_PICT_HEIGHT, WIA_DPC_PICT_HEIGHT_STR },
    { WIA_DPC_DIMENSION, WIA_DPC_DIMENSION_STR },
    { WIA_DPC_COMPRESSION_SETTING, WIA_DPC_COMPRESSION_SETTING_STR },
    { WIA_DPC_FOCUS_METERING_MODE, WIA_DPC_FOCUS_METERING_MODE_STR },
    { WIA_DPC_TIMELAPSE_INTERVAL, WIA_DPC_TIMELAPSE_INTERVAL_STR },
    { WIA_DPC_TIMELAPSE_NUMBER, WIA_DPC_TIMELAPSE_NUMBER_STR },
    { WIA_DPC_BURST_INTERVAL, WIA_DPC_BURST_INTERVAL_STR },
    { WIA_DPC_BURST_NUMBER, WIA_DPC_BURST_NUMBER_STR },
    { WIA_DPC_EFFECT_MODE, WIA_DPC_EFFECT_MODE_STR },
    { WIA_DPC_DIGITAL_ZOOM, WIA_DPC_DIGITAL_ZOOM_STR },
    { WIA_DPC_SHARPNESS, WIA_DPC_SHARPNESS_STR },
    { WIA_DPC_CONTRAST, WIA_DPC_CONTRAST_STR },
    { WIA_DPC_CAPTURE_MODE, WIA_DPC_CAPTURE_MODE_STR },
    { WIA_DPC_CAPTURE_DELAY, WIA_DPC_CAPTURE_DELAY_STR },
    { WIA_DPC_EXPOSURE_INDEX, WIA_DPC_EXPOSURE_INDEX_STR },
    { WIA_DPC_EXPOSURE_METERING_MODE, WIA_DPC_EXPOSURE_METERING_MODE_STR },
    { WIA_DPC_FOCUS_DISTANCE, WIA_DPC_FOCUS_DISTANCE_STR },
    { WIA_DPC_FOCAL_LENGTH, WIA_DPC_FOCAL_LENGTH_STR },
    { WIA_DPC_RGB_GAIN, WIA_DPC_RGB_GAIN_STR },
    { WIA_DPC_WHITE_BALANCE, WIA_DPC_WHITE_BALANCE_STR },
    { WIA_DPC_UPLOAD_URL, WIA_DPC_UPLOAD_URL_STR },
    { WIA_DPC_ARTIST, WIA_DPC_ARTIST_STR },
    { WIA_DPC_COPYRIGHT_INFO, WIA_DPC_COPYRIGHT_INFO_STR },
    { WIA_DPS_HORIZONTAL_BED_SIZE, WIA_DPS_HORIZONTAL_BED_SIZE_STR },
    { WIA_DPS_VERTICAL_BED_SIZE, WIA_DPS_VERTICAL_BED_SIZE_STR },
    { WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE, WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE_STR },
    { WIA_DPS_VERTICAL_SHEET_FEED_SIZE, WIA_DPS_VERTICAL_SHEET_FEED_SIZE_STR },
    { WIA_DPS_SHEET_FEEDER_REGISTRATION, WIA_DPS_SHEET_FEEDER_REGISTRATION_STR },
    { WIA_DPS_HORIZONTAL_BED_REGISTRATION, WIA_DPS_HORIZONTAL_BED_REGISTRATION_STR },
    { WIA_DPS_VERTICAL_BED_REGISTRATION, WIA_DPS_VERTICAL_BED_REGISTRATION_STR },
    { WIA_DPS_PLATEN_COLOR, WIA_DPS_PLATEN_COLOR_STR },
    { WIA_DPS_PAD_COLOR, WIA_DPS_PAD_COLOR_STR },
    { WIA_DPS_FILTER_SELECT, WIA_DPS_FILTER_SELECT_STR },
    { WIA_DPS_DITHER_SELECT, WIA_DPS_DITHER_SELECT_STR },
    { WIA_DPS_DITHER_PATTERN_DATA, WIA_DPS_DITHER_PATTERN_DATA_STR },
    { WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES, WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES_STR },
    { WIA_DPS_DOCUMENT_HANDLING_STATUS, WIA_DPS_DOCUMENT_HANDLING_STATUS_STR },
    { WIA_DPS_DOCUMENT_HANDLING_SELECT, WIA_DPS_DOCUMENT_HANDLING_SELECT_STR },
    { WIA_DPS_DOCUMENT_HANDLING_CAPACITY, WIA_DPS_DOCUMENT_HANDLING_CAPACITY_STR },
    { WIA_DPS_OPTICAL_XRES, WIA_DPS_OPTICAL_XRES_STR },
    { WIA_DPS_OPTICAL_YRES, WIA_DPS_OPTICAL_YRES_STR },
    { WIA_DPS_ENDORSER_CHARACTERS, WIA_DPS_ENDORSER_CHARACTERS_STR },
    { WIA_DPS_ENDORSER_STRING, WIA_DPS_ENDORSER_STRING_STR },
    { WIA_DPS_SCAN_AHEAD_PAGES, WIA_DPS_SCAN_AHEAD_PAGES_STR },
    { WIA_DPS_MAX_SCAN_TIME, WIA_DPS_MAX_SCAN_TIME_STR },
    { WIA_DPS_PAGES, WIA_DPS_PAGES_STR },
    { WIA_DPS_PAGE_SIZE, WIA_DPS_PAGE_SIZE_STR },
    { WIA_DPS_PAGE_WIDTH, WIA_DPS_PAGE_WIDTH_STR },
    { WIA_DPS_PAGE_HEIGHT, WIA_DPS_PAGE_HEIGHT_STR },
    { WIA_DPS_PREVIEW, WIA_DPS_PREVIEW_STR },
    { WIA_DPS_TRANSPARENCY, WIA_DPS_TRANSPARENCY_STR },
    { WIA_DPS_TRANSPARENCY_SELECT, WIA_DPS_TRANSPARENCY_SELECT_STR },
    { WIA_DPS_SHOW_PREVIEW_CONTROL, WIA_DPS_SHOW_PREVIEW_CONTROL_STR },
    { WIA_DPS_MIN_HORIZONTAL_SHEET_FEED_SIZE, WIA_DPS_MIN_HORIZONTAL_SHEET_FEED_SIZE_STR },
    { WIA_DPS_MIN_VERTICAL_SHEET_FEED_SIZE, WIA_DPS_MIN_VERTICAL_SHEET_FEED_SIZE_STR },
    { WIA_DPF_MOUNT_POINT, WIA_DPF_MOUNT_POINT_STR },
    { WIA_DPV_LAST_PICTURE_TAKEN, WIA_DPV_LAST_PICTURE_TAKEN_STR },
    { WIA_DPV_IMAGES_DIRECTORY, WIA_DPV_IMAGES_DIRECTORY_STR },
    { WIA_DPV_DSHOW_DEVICE_PATH, WIA_DPV_DSHOW_DEVICE_PATH_STR },
    { WIA_IPA_ITEM_NAME, WIA_IPA_ITEM_NAME_STR },
    { WIA_IPA_FULL_ITEM_NAME, WIA_IPA_FULL_ITEM_NAME_STR },
    { WIA_IPA_ITEM_TIME, WIA_IPA_ITEM_TIME_STR },
    { WIA_IPA_ITEM_FLAGS, WIA_IPA_ITEM_FLAGS_STR },
    { WIA_IPA_ACCESS_RIGHTS, WIA_IPA_ACCESS_RIGHTS_STR },
    { WIA_IPA_DATATYPE, WIA_IPA_DATATYPE_STR },
    { WIA_IPA_DEPTH, WIA_IPA_DEPTH_STR },
    { WIA_IPA_PREFERRED_FORMAT, WIA_IPA_PREFERRED_FORMAT_STR },
    { WIA_IPA_FORMAT, WIA_IPA_FORMAT_STR },
    { WIA_IPA_COMPRESSION, WIA_IPA_COMPRESSION_STR },
    { WIA_IPA_TYMED, WIA_IPA_TYMED_STR },
    { WIA_IPA_CHANNELS_PER_PIXEL, WIA_IPA_CHANNELS_PER_PIXEL_STR },
    { WIA_IPA_BITS_PER_CHANNEL, WIA_IPA_BITS_PER_CHANNEL_STR },
    { WIA_IPA_PLANAR, WIA_IPA_PLANAR_STR },
    { WIA_IPA_PIXELS_PER_LINE, WIA_IPA_PIXELS_PER_LINE_STR },
    { WIA_IPA_BYTES_PER_LINE, WIA_IPA_BYTES_PER_LINE_STR },
    { WIA_IPA_NUMBER_OF_LINES, WIA_IPA_NUMBER_OF_LINES_STR },
    { WIA_IPA_GAMMA_CURVES, WIA_IPA_GAMMA_CURVES_STR },
    { WIA_IPA_ITEM_SIZE, WIA_IPA_ITEM_SIZE_STR },
    { WIA_IPA_COLOR_PROFILE, WIA_IPA_COLOR_PROFILE_STR },
    { WIA_IPA_MIN_BUFFER_SIZE, WIA_IPA_MIN_BUFFER_SIZE_STR },
    { WIA_IPA_REGION_TYPE, WIA_IPA_REGION_TYPE_STR },
    { WIA_IPA_ICM_PROFILE_NAME, WIA_IPA_ICM_PROFILE_NAME_STR },
    { WIA_IPA_APP_COLOR_MAPPING, WIA_IPA_APP_COLOR_MAPPING_STR },
    { WIA_IPA_PROP_STREAM_COMPAT_ID, WIA_IPA_PROP_STREAM_COMPAT_ID_STR },
    { WIA_IPA_FILENAME_EXTENSION, WIA_IPA_FILENAME_EXTENSION_STR },
    { WIA_IPA_SUPPRESS_PROPERTY_PAGE, WIA_IPA_SUPPRESS_PROPERTY_PAGE_STR },
    { WIA_IPC_THUMBNAIL, WIA_IPC_THUMBNAIL_STR },
    { WIA_IPC_THUMB_WIDTH, WIA_IPC_THUMB_WIDTH_STR },
    { WIA_IPC_THUMB_HEIGHT, WIA_IPC_THUMB_HEIGHT_STR },
    { WIA_IPC_AUDIO_AVAILABLE, WIA_IPC_AUDIO_AVAILABLE_STR },
    { WIA_IPC_AUDIO_DATA_FORMAT, WIA_IPC_AUDIO_DATA_FORMAT_STR },
    { WIA_IPC_AUDIO_DATA, WIA_IPC_AUDIO_DATA_STR },
    { WIA_IPC_NUM_PICT_PER_ROW, WIA_IPC_NUM_PICT_PER_ROW_STR },
    { WIA_IPC_SEQUENCE, WIA_IPC_SEQUENCE_STR },
    { WIA_IPC_TIMEDELAY, WIA_IPC_TIMEDELAY_STR },
    { WIA_IPS_CUR_INTENT, WIA_IPS_CUR_INTENT_STR },
    { WIA_IPS_XRES, WIA_IPS_XRES_STR },
    { WIA_IPS_YRES, WIA_IPS_YRES_STR },
    { WIA_IPS_XPOS, WIA_IPS_XPOS_STR },
    { WIA_IPS_YPOS, WIA_IPS_YPOS_STR },
    { WIA_IPS_XEXTENT, WIA_IPS_XEXTENT_STR },
    { WIA_IPS_YEXTENT, WIA_IPS_YEXTENT_STR },
    { WIA_IPS_PHOTOMETRIC_INTERP, WIA_IPS_PHOTOMETRIC_INTERP_STR },
    { WIA_IPS_BRIGHTNESS, WIA_IPS_BRIGHTNESS_STR },
    { WIA_IPS_CONTRAST, WIA_IPS_CONTRAST_STR },
    { WIA_IPS_ORIENTATION, WIA_IPS_ORIENTATION_STR },
    { WIA_IPS_ROTATION, WIA_IPS_ROTATION_STR },
    { WIA_IPS_MIRROR, WIA_IPS_MIRROR_STR },
    { WIA_IPS_THRESHOLD, WIA_IPS_THRESHOLD_STR },
    { WIA_IPS_INVERT, WIA_IPS_INVERT_STR },
    { WIA_IPS_WARM_UP_TIME, WIA_IPS_WARM_UP_TIME_STR },
    {0,                                       L"Not a WIA property"}
};

#endif

namespace PropStorageHelpers
{
    CPropertyId::CPropertyId(void)
    : m_strPropId(L""), m_nPropId(0), m_bIsStringPropId(false)
    {
    }

    CPropertyId::CPropertyId( const CSimpleStringWide &strPropId )
    : m_strPropId(strPropId), m_nPropId(0), m_bIsStringPropId(true)
    {
    }


    CPropertyId::CPropertyId( PROPID propId )
    : m_strPropId(L""), m_nPropId(propId), m_bIsStringPropId(false)
    {
    }


    CPropertyId::CPropertyId( const CPropertyId &other )
    : m_strPropId(other.PropIdString()), m_nPropId(other.PropIdNumber()), m_bIsStringPropId(other.IsString())
    {
    }

    CPropertyId::~CPropertyId(void)
    {
    }


    CPropertyId &CPropertyId::operator=( const CPropertyId &other )
    {
        if (this != &other)
        {
            m_strPropId = other.PropIdString();
            m_nPropId = other.PropIdNumber();
            m_bIsStringPropId = other.IsString();
        }
        return(*this);
    }


    CSimpleStringWide CPropertyId::PropIdString(void) const
    {
        return(m_strPropId);
    }

    PROPID CPropertyId::PropIdNumber(void) const
    {
        return(m_nPropId);
    }

    bool CPropertyId::IsString(void) const
    {
        return(m_bIsStringPropId);
    }

    CSimpleString PropertyName( const CPropertyId &propertyName )
    {
#if defined(DBG)
        if (propertyName.IsString())
        {
            return CSimpleStringConvert::NaturalString(propertyName.PropIdString());
        }
        for (int i=0;g_wiaPropIdToName[i].propid;i++)
        {
            if (propertyName.PropIdNumber() == g_wiaPropIdToName[i].propid)
            {
                return CSimpleStringConvert::NaturalString(CSimpleStringWide(g_wiaPropIdToName[i].pszName));
            }
        }
        return CSimpleString().Format( TEXT("Unknown property %d"), propertyName.PropIdNumber() );
#endif
        return TEXT("");
    }


    bool SetProperty( IUnknown *pIUnknown, const CPropertyId &propertyName, PROPVARIANT &pv, PROPID nNameFirst )
    {
        WIA_PUSH_FUNCTION((TEXT("PropStorageHelpers::SetProperty(\"%s\")"), PropertyName(propertyName).String() ));
        PROPSPEC ps = {0};
        if (propertyName.IsString())
        {
            ps.ulKind = PRSPEC_LPWSTR;
            ps.lpwstr = const_cast<LPWSTR>(propertyName.PropIdString().String());
        }
        else
        {
            ps.ulKind = PRSPEC_PROPID;
            ps.propid = propertyName.PropIdNumber();
        }
        CComPtr<IWiaPropertyStorage> pIWiaPropertyStorage;
        HRESULT hr = pIUnknown->QueryInterface(IID_IWiaPropertyStorage, (void**)&pIWiaPropertyStorage);
        if (FAILED(hr))
        {
            return(false);
        }
        hr = pIWiaPropertyStorage->WriteMultiple( 1, &ps, &pv, nNameFirst );
        return(SUCCEEDED(hr));
    }

    bool SetProperty( IUnknown *pIUnknown, const CPropertyId &propertyName, LONG nValue, PROPID nNameFirst )
    {
        PROPVARIANT pv = {0};
        pv.vt = VT_I4;
        pv.lVal = nValue;
        return(SetProperty( pIUnknown, propertyName, pv, nNameFirst ));
    }

    bool SetProperty( IUnknown *pIUnknown, const CPropertyId &propertyName, const GUID &guidValue, PROPID nNameFirst )
    {
        PROPVARIANT pv = {0};
        pv.vt = VT_CLSID;
        pv.puuid = const_cast<GUID*>(&guidValue);
        return(SetProperty( pIUnknown, propertyName, pv, nNameFirst ));
    }

    bool GetProperty( IUnknown *pIUnknown, const CPropertyId &propertyName, PROPVARIANT &pPropVar )
    {
        WIA_PUSH_FUNCTION((TEXT("PropStorageHelpers::GetProperty(\"%s\")"), PropertyName(propertyName).String() ));
        ZeroMemory(&pPropVar,sizeof(pPropVar));
        if (pIUnknown)
        {
            PROPSPEC ps = {0};
            if (propertyName.IsString())
            {
                ps.ulKind = PRSPEC_LPWSTR;
                ps.lpwstr = const_cast<LPWSTR>(propertyName.PropIdString().String());
            }
            else
            {
                ps.ulKind = PRSPEC_PROPID;
                ps.propid = propertyName.PropIdNumber();
            }
            CComPtr<IWiaPropertyStorage> pIWiaPropertyStorage;
            HRESULT hr = pIUnknown->QueryInterface(IID_IWiaPropertyStorage, (void**)&pIWiaPropertyStorage);
            if (FAILED(hr))
            {
                WIA_PRINTHRESULT((hr,TEXT("GetProperty: pIUnknown->QueryInterface failed:")));
                return(false);
            }
            hr = pIWiaPropertyStorage->ReadMultiple( 1, &ps, &pPropVar );
            if (FAILED(hr) || S_FALSE==hr)
            {
                WIA_PRINTHRESULT((hr,TEXT("GetProperty: pIUnknown->ReadMultiple failed:")));
                return(false);
            }
            return(SUCCEEDED(hr));
        }
        else
        {
            WIA_ERROR((TEXT("GetProperty: pIUnknown is NULL")));
            return(false);
        }
    }


    bool GetProperty( IUnknown *pIUnknown, const CPropertyId &propertyName, CSimpleStringWide &strPropertyValue )
    {
        strPropertyValue = L"";
        PROPVARIANT pvPropValue;
        if (!GetProperty( pIUnknown, propertyName, pvPropValue ))
        {
            PropVariantClear(&pvPropValue);
            return(false);
        }
        if (VT_LPWSTR != pvPropValue.vt && VT_BSTR != pvPropValue.vt)
        {
            PropVariantClear(&pvPropValue);
            return(false);
        }
        strPropertyValue = pvPropValue.pwszVal;
        PropVariantClear(&pvPropValue);
        return(true);
    }


    bool GetProperty( IUnknown *pIUnknown, const CPropertyId &propertyName, LONG &nValue )
    {
        nValue = 0;
        PROPVARIANT pvPropValue;
        if (!GetProperty( pIUnknown, propertyName, pvPropValue ))
        {
            PropVariantClear(&pvPropValue);
            return(false);
        }
        if (VT_I4 != pvPropValue.vt && VT_UI4 != pvPropValue.vt)
        {
            WIA_ERROR((TEXT("GetProperty: Property value type must be VT_I4 or VT_UI4 and it was 0x%08X (%d)"),pvPropValue.vt,pvPropValue.vt));
            PropVariantClear(&pvPropValue);
            return(false);
        }
        nValue = pvPropValue.lVal;
        PropVariantClear(&pvPropValue);
        return(true);
    }

    bool GetProperty( IUnknown *pIUnknown, const CPropertyId &propertyName, GUID &guidValue )
    {
        guidValue = IID_NULL;
        PROPVARIANT pvPropValue;
        if (!GetProperty( pIUnknown, propertyName, pvPropValue ))
        {
            PropVariantClear(&pvPropValue);
            return(false);
        }
        if (VT_CLSID != pvPropValue.vt)
        {
            WIA_ERROR((TEXT("GetProperty: Property value type must be VT_I4 or VT_UI4 and it was 0x%08X (%d)"),pvPropValue.vt,pvPropValue.vt));
            PropVariantClear(&pvPropValue);
            return(false);
        }
        if (!pvPropValue.puuid)
        {
            WIA_ERROR((TEXT("GetProperty: NULL pvPropValue.puuid")));
            PropVariantClear(&pvPropValue);
            return(false);
        }
        guidValue = *(pvPropValue.puuid);
        PropVariantClear(&pvPropValue);
        return(true);
    }

    bool GetPropertyAttributes( IUnknown *pIUnknown, const CPropertyId &propertyName, ULONG &nAccessFlags, PROPVARIANT &pvAttributes )
    {
        WIA_PUSH_FUNCTION((TEXT("PropStorageHelpers::GetPropertyAttributes(\"%s\")"), PropertyName(propertyName).String() ));
        ZeroMemory( &pvAttributes, sizeof(pvAttributes) );
        if (!pIUnknown)
        {
            WIA_ERROR((TEXT("pIUnknown is NULL")));
            return false;
        }

        CComPtr<IWiaPropertyStorage> pIWiaPropertyStorage;
        HRESULT hr = pIUnknown->QueryInterface(IID_IWiaPropertyStorage, (void**)&pIWiaPropertyStorage);
        if (SUCCEEDED(hr))
        {
            PROPSPEC ps;
            if (propertyName.IsString())
            {
                ps.ulKind = PRSPEC_LPWSTR;
                ps.lpwstr = const_cast<LPWSTR>(propertyName.PropIdString().String());
            }
            else
            {
                ps.ulKind = PRSPEC_PROPID;
                ps.propid = propertyName.PropIdNumber();
            }

            hr = pIWiaPropertyStorage->GetPropertyAttributes( 1, &ps, &nAccessFlags, &pvAttributes );

            if (SUCCEEDED(hr))
            {
                hr = S_OK;
            }
            else
            {
                WIA_PRINTHRESULT((hr,TEXT("pIWiaPropertyStorage->GetPropertyAttributes failed")));
            }
        }
        else
        {
            WIA_PRINTHRESULT((hr,TEXT("pIUnknown->QueryInterface failed")));
        }
        WIA_PRINTHRESULT((hr,TEXT("PropStorageHelpers::GetPropertyAttributes is returning")));
        return (SUCCEEDED(hr) != FALSE);
    }

    bool GetPropertyAttributes( IUnknown *pIUnknown, const CPropertyId &propertyName, PROPVARIANT &pvAttributes )
    {
        ULONG nAccessFlags;
        bool bResult = GetPropertyAttributes( pIUnknown, propertyName, nAccessFlags, pvAttributes );
        return (bResult);
    }

    bool GetPropertyAccessFlags( IUnknown *pIUnknown, const CPropertyId &propertyName, ULONG &nAccessFlags )
    {
        PROPVARIANT pvAttributes;
        bool bResult = GetPropertyAttributes( pIUnknown, propertyName, nAccessFlags, pvAttributes );
        if (bResult)
            PropVariantClear(&pvAttributes);
        return (bResult);
    }

    bool IsReadOnlyProperty( IUnknown *pIUnknown, const CPropertyId &propertyName )
    {
        WIA_PUSH_FUNCTION((TEXT("PropStorageHelpers::IsReadOnlyProperty")));
        bool bResult = true;
        ULONG nAccessFlags = 0;
        if (GetPropertyAccessFlags(pIUnknown,propertyName,nAccessFlags))
        {
            WIA_TRACE((TEXT("nAccessFlags = %08X"),nAccessFlags));
            bResult = ((nAccessFlags & WIA_PROP_WRITE) == 0);
            WIA_TRACE((TEXT("bResult = %d"),bResult));
        }
        return bResult;
    }

    bool GetPropertyRange( IUnknown *pIUnknown, const CPropertyId &propertyName, CPropertyRange &propertyRange )
    {
        ZeroMemory( &propertyRange, sizeof(propertyRange) );
        PROPVARIANT pvAttributes;
        ULONG nAccessFlags;
        bool bResult = false;
        if (GetPropertyAttributes( pIUnknown, propertyName, nAccessFlags, pvAttributes ))
        {
            if ((WIA_PROP_RANGE & nAccessFlags) &&
                (pvAttributes.vt & VT_VECTOR) &&
                ((pvAttributes.vt & VT_I4) || (pvAttributes.vt & VT_UI4)))
            {
                propertyRange.nMin = (LONG)pvAttributes.caul.pElems[WIA_RANGE_MIN];
                propertyRange.nMax = (LONG)pvAttributes.caul.pElems[WIA_RANGE_MAX];
                propertyRange.nStep = (LONG)pvAttributes.caul.pElems[WIA_RANGE_STEP];
                bResult = true;
            }
            else
            {
                WIA_ERROR((TEXT("\"%s\" is not a WIA_PROP_RANGE value"), PropertyName(propertyName).String() ));
            }
            PropVariantClear(&pvAttributes);
        }
        return bResult;
    }

    bool GetPropertyList( IUnknown *pIUnknown, const CPropertyId &propertyName, CSimpleDynamicArray<LONG> &aProp )
    {
        aProp.Destroy();
        PROPVARIANT pvAttributes;
        ULONG nAccessFlags;
        bool bResult = false;
        if (GetPropertyAttributes( pIUnknown, propertyName, nAccessFlags, pvAttributes ))
        {
            if ((WIA_PROP_LIST & nAccessFlags) &&
                (pvAttributes.vt & VT_VECTOR) &&
                ((pvAttributes.vt & VT_I4) || (pvAttributes.vt & VT_UI4)))
            {
                for (ULONG i=0;i<pvAttributes.cal.cElems - WIA_LIST_VALUES;i++)
                    aProp.Append((LONG)pvAttributes.cal.pElems[WIA_LIST_VALUES + i]);
                bResult = true;
            }
            else
            {
                WIA_ERROR((TEXT("\"%s\" is not a WIA_PROP_LIST value"), PropertyName(propertyName).String() ));
            }
            PropVariantClear(&pvAttributes);
        }
        return bResult;
    }

    bool GetPropertyList( IUnknown *pIUnknown, const CPropertyId &propertyName, CSimpleDynamicArray<GUID> &aProp )
    {
        aProp.Destroy();
        PROPVARIANT pvAttributes;
        ULONG nAccessFlags;
        bool bResult = false;
        if (GetPropertyAttributes( pIUnknown, propertyName, nAccessFlags, pvAttributes ))
        {
            if ((WIA_PROP_LIST & nAccessFlags) &&
                (pvAttributes.vt & VT_VECTOR) &&
                (pvAttributes.vt & VT_CLSID))
            {
                for (ULONG i=0;i<pvAttributes.cal.cElems - WIA_LIST_VALUES;i++)
                    aProp.Append(pvAttributes.cauuid.pElems[WIA_LIST_VALUES + i]);
                bResult = true;
            }
            else
            {
                WIA_ERROR((TEXT("\"%s\" is not a WIA_PROP_LIST value"), PropertyName(propertyName).String() ));
            }
            PropVariantClear(&pvAttributes);
        }
        return bResult;
    }

    bool GetPropertyFlags( IUnknown *pIUnknown, const CPropertyId &propertyName, LONG &nFlags )
    {
        WIA_PUSH_FUNCTION((TEXT("PropStorageHelpers::GetPropertyFlags(\"%s\")"), PropertyName(propertyName).String() ));
        nFlags = 0;
        PROPVARIANT pvAttributes;
        ULONG nAccessFlags;
        bool bResult = false;
        if (GetPropertyAttributes( pIUnknown, propertyName, nAccessFlags, pvAttributes ))
        {
            if (WIA_PROP_FLAG & nAccessFlags)
            {
                nFlags = pvAttributes.caul.pElems[WIA_FLAG_VALUES];
                WIA_TRACE((TEXT("nFlags = %08X"), nFlags ));
                bResult = true;
            }
            else
            {
                WIA_ERROR((TEXT("\"%s\" is not a WIA_PROP_FLAG value"), PropertyName(propertyName).String() ));
            }
            PropVariantClear(&pvAttributes);
        }
        else
        {
            WIA_ERROR((TEXT("GetPropertyAttributes failed")));
        }
        return bResult;
    }
} // Namespace PropStorageHelpers
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\rescale.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       RESCALE.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        10/15/1998
 *
 *  DESCRIPTION: Scale HBITMAPs using StretchBlt
 *
 *******************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*
 * ScaleImage: Scale hBmpSrc and store the scaled dib in hBmpTgt
 */
HRESULT ScaleImage( HDC hDC, HBITMAP hBmpSrc, HBITMAP &hBmpTgt, const SIZE &sizeTgt )
{
    WIA_PUSH_FUNCTION((TEXT("ScaleImage( sizeTgt = [%d,%d] )"), sizeTgt.cx, sizeTgt.cy ));
    BITMAPINFO bmi;
    BITMAP bm;
    HRESULT hr = E_FAIL;
    HBITMAP hBmp = NULL;

    hBmpTgt = NULL;

    GetObject( hBmpSrc, sizeof(BITMAP), &bm );

    ZeroMemory( &bmi, sizeof(BITMAPINFO) );
    bmi.bmiHeader.biSize            = sizeof(BITMAPINFOHEADER);
    bmi.bmiHeader.biWidth           = sizeTgt.cx;
    bmi.bmiHeader.biHeight          = sizeTgt.cy;
    bmi.bmiHeader.biPlanes          = 1;
    bmi.bmiHeader.biBitCount        = 24;
    bmi.bmiHeader.biCompression     = BI_RGB;

    HPALETTE hHalftonePalette = CreateHalftonePalette(hDC);
    if (hHalftonePalette)
    {
        PBYTE pBitmapData = NULL;
        hBmp = CreateDIBSection( hDC, &bmi, DIB_RGB_COLORS, (LPVOID*)&pBitmapData, NULL, 0 );
        if (hBmp)
        {
            // Create the source dc
            HDC hMemoryDC = CreateCompatibleDC( hDC );
            if (hMemoryDC)
            {
                HPALETTE hOldMemDCPalette = SelectPalette( hMemoryDC, hHalftonePalette , 0 );
                RealizePalette( hMemoryDC );
                SetBrushOrgEx( hMemoryDC, 0,0, NULL );
                HBITMAP hOldMemDCBitmap = (HBITMAP)SelectObject( hMemoryDC, hBmpSrc );

                // Create the target dc
                HDC hStretchDC = CreateCompatibleDC( hDC );
                if (hStretchDC)
                {
                    HPALETTE hOldStretchDCPalette = SelectPalette( hStretchDC, hHalftonePalette , 0 );
                    RealizePalette( hStretchDC );
                    SetBrushOrgEx( hStretchDC, 0,0, NULL );
                    HBITMAP hOldStretchDCBitmap = (HBITMAP)SelectObject( hStretchDC, hBmp );
                    INT nOldStretchMode = SetStretchBltMode( hStretchDC, STRETCH_HALFTONE );

                    SIZE sizeScaled;
                    // Width is constraining factor
                    if (sizeTgt.cy*bm.bmWidth > sizeTgt.cx*bm.bmHeight)
                    {
                        sizeScaled.cx = sizeTgt.cx;
                        sizeScaled.cy = WiaUiUtil::MulDivNoRound(bm.bmHeight,sizeTgt.cx,bm.bmWidth);
                    }
                    // Height is constraining factor
                    else
                    {
                        sizeScaled.cx = WiaUiUtil::MulDivNoRound(bm.bmWidth,sizeTgt.cy,bm.bmHeight);
                        sizeScaled.cy = sizeTgt.cy;
                    }
                    // Fill the background
                    RECT rc;
                    rc.left = rc.top = 0;
                    rc.right = sizeTgt.cx;
                    rc.bottom = sizeTgt.cy;
                    FillRect( hStretchDC, &rc, GetSysColorBrush(COLOR_WINDOW) );

                    // Paint the image
                    StretchBlt( hStretchDC, (sizeTgt.cx - sizeScaled.cx) / 2, (sizeTgt.cy - sizeScaled.cy) / 2, sizeScaled.cx, sizeScaled.cy, hMemoryDC, 0, 0, bm.bmWidth, bm.bmHeight, SRCCOPY );

                    // Everything is OK
                    hBmpTgt = hBmp;
                    hr = S_OK;

                    // Restore the dc's state and delete it
                    SetStretchBltMode( hStretchDC, nOldStretchMode );
                    SelectObject( hStretchDC, hOldStretchDCBitmap );
                    SelectPalette( hStretchDC, hOldStretchDCPalette , 0 );
                    DeleteDC( hStretchDC );
                }
                // Restore the dc's state
                SelectObject( hMemoryDC, hOldMemDCBitmap );
                SelectPalette( hMemoryDC, hOldMemDCPalette , 0 );
                DeleteDC( hMemoryDC );
            }
        }
        if (hHalftonePalette)
        {
            DeleteObject( hHalftonePalette );
        }
    }
    // Clean up the new bitmap if there was an error
    if (!SUCCEEDED(hr) && hBmp)
        DeleteObject( hBmp );

    WIA_TRACE((TEXT("hBmpTgt = %p")));
    return (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\runnpwiz.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       RUNNPWIZ.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        6/15/2000
 *
 *  DESCRIPTION:
 *
 *******************************************************************************/
#ifndef __RUNNPWIZ_H_INCLUDED
#define __RUNNPWIZ_H_INCLUDED

#include <windows.h>
#include <simstr.h>
#include <simarray.h>

namespace NetPublishingWizard
{
    HRESULT GetClassIdOfPublishingWizard( CLSID &clsidWizard );
    HRESULT RunNetPublishingWizard( const CSimpleDynamicArray<CSimpleString> &strFiles );
    HRESULT CreateDataObjectFromFileList( const CSimpleDynamicArray<CSimpleString> &strFiles, IDataObject **ppDataObject );
}

#endif // __RUNNPWIZ_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\resid.h ===
#ifndef __RESID_H_INCLUDED
#define __RESID_H_INCLUDED

#include <windows.h>

class CResId
{
private:
    LPTSTR m_pszRes;
    int m_nRes;
    bool m_bIsString;
public:
    CResId( LPTSTR pszRes = NULL );
    CResId( int nRes );
    CResId( const CResId &other );
    virtual ~CResId(void);
    const CResId &operator=( const CResId &other );
    LPCTSTR ResourceName(void) const;
    LPCTSTR StringRes(void) const;
    LPCTSTR StringRes( LPCTSTR pszRes );
    int NumberRes(void) const;
    int NumberRes( int nRes );
    bool IsString(void) const;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\resid.cpp ===
#include "precomp.h"
#pragma hdrstop

CResId::CResId( LPTSTR pszRes )
    : m_pszRes(NULL), m_nRes(0), m_bIsString(false)
{
    StringRes(pszRes);
}

CResId::CResId( int nRes )
    : m_pszRes(NULL), m_nRes(0), m_bIsString(false)
{
    NumberRes(nRes);
}

CResId::CResId( const CResId &other )
    : m_pszRes(NULL), m_nRes(0), m_bIsString(false)
{
    if (other.IsString())
        StringRes(other.StringRes());
    else NumberRes(other.NumberRes());
}

CResId::~CResId(void)
{
    if (m_pszRes)
    {
        delete[] m_pszRes;
        m_pszRes = NULL;
    }
}

const CResId &CResId::operator=( const CResId &other )
{
    if (other.IsString())
        StringRes(other.StringRes());
    else NumberRes(other.NumberRes());
    return *this;
}

LPCTSTR CResId::ResourceName(void) const
{
    if (IsString())
        return StringRes();
    else return MAKEINTRESOURCE(NumberRes());
}

LPCTSTR CResId::StringRes(void) const
{
    return m_pszRes;
}

int CResId::NumberRes(void) const
{
    return m_nRes;
}

bool CResId::IsString(void) const
{
    return m_bIsString;
}

LPCTSTR CResId::StringRes( LPCTSTR pszRes )
{
    if (m_pszRes)
    {
        delete[] m_pszRes;
        m_pszRes = NULL;
    }
    if (pszRes)
    {
        m_pszRes = new TCHAR[lstrlen(pszRes)+1];
        if (m_pszRes)
        {
            lstrcpy( m_pszRes, pszRes );
        }
    }
    m_bIsString = true;
    return m_pszRes;
}

int CResId::NumberRes( int nRes )
{
    m_nRes = nRes;
    m_bIsString = false;
    return m_nRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\rescale.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       RESCALE.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        10/15/1998
 *
 *  DESCRIPTION: Scale HBITMAPs using StretchBlt
 *
 *******************************************************************************/
#ifndef _RESCALE_H_INCLUDED
#define _RESCALE_H_INCLUDED

#include <windows.h>

HRESULT ScaleImage( HDC hDC, HBITMAP hBmpSrc, HBITMAP &hBmpTgt, const SIZE &sizeTgt );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\runwiz.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       RUNWIZ.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        6/14/2000
 *
 *  DESCRIPTION: Present the device selection dialog and allow the user to select
 *               a device, then cocreate the server and generate the connection
 *               event.
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "simstr.h"
#include "simbstr.h"
#include "runwiz.h"
#include "shmemsec.h"


namespace RunWiaWizard
{
    static const GUID CLSID_AcquisitionManager = { 0xD13E3F25,0x1688,0x45A0,{ 0x97,0x43,0x75,0x9E,0xB3, 0x5C,0xDF,0x9A} };

    HRESULT RunWizard( LPCTSTR pszDeviceId, HWND hWndParent, LPCTSTR pszUniqueIdentifier )
    {
        //
        // Assume failure
        //
        HRESULT hr = E_FAIL;

        //
        // Get the device ID if one was not provided
        //
        CSimpleStringWide strwDeviceId;
        if (!pszDeviceId || !lstrlen(pszDeviceId))
        {
            //
            // Assume we will be asking for the device
            //
            bool bAskForDevice = true;

            //
            // This will automatically be cleaned up when we exit this scope
            //
            CSharedMemorySection<HWND> SelectionDialogSharedMemory;

            //
            // We only want to enforce uniqueness if we have a unique ID for this instance of the UI
            //
            if (pszUniqueIdentifier && *pszUniqueIdentifier)
            {
                //
                // First, try to open it.  If it exists, that means there is another instance running already.
                //
                CSharedMemorySection<HWND>::COpenResult OpenResult = SelectionDialogSharedMemory.Open( pszUniqueIdentifier, true );
                if (CSharedMemorySection<HWND>::SmsOpened == OpenResult)
                {
                    //
                    // We don't want to display the selection dialog
                    //
                    bAskForDevice = false;

                    //
                    // Tell the caller we cancelled
                    //
                    hr = S_FALSE;

                    //
                    // If we were able to open the shared memory section, there is already one running.
                    // so get a mutex'ed pointer to the shared memory.
                    //
                    HWND *pHwnd = SelectionDialogSharedMemory.Lock();
                    if (pHwnd)
                    {
                        //
                        // If we were able to get the pointer, get the window handle stored in it.
                        // Set bRun to false, so we don't start up a new wizard
                        //
                        if (*pHwnd && IsWindow(*pHwnd))
                        {
                            //
                            // Try to get any active windows
                            //
                            HWND hWndPopup = GetLastActivePopup(*pHwnd);

                            //
                            // If it is a valid window, bring it to the foreground.
                            //
                            SetForegroundWindow(hWndPopup);

                        }
                        //
                        // Release the mutex
                        //
                        SelectionDialogSharedMemory.Release();
                    }
                }
                else if (CSharedMemorySection<HWND>::SmsCreated == OpenResult)
                {
                    //
                    // If we couldn't open it, we are the first instance, so store the parent window handle
                    //
                    HWND *phWnd = SelectionDialogSharedMemory.Lock();
                    if (phWnd)
                    {
                        *phWnd = hWndParent;
                        SelectionDialogSharedMemory.Release();
                    }
                }
            }

            if (bAskForDevice)
            {
                //
                // Create the device manager
                //
                CComPtr<IWiaDevMgr> pWiaDevMgr;
                hr = CoCreateInstance( CLSID_WiaDevMgr, NULL, CLSCTX_LOCAL_SERVER, IID_IWiaDevMgr, (void**)&pWiaDevMgr );
                if (SUCCEEDED(hr))
                {
                    //
                    // Get the device ID
                    //
                    BSTR bstrDeviceId = NULL;
                    hr = pWiaDevMgr->SelectDeviceDlgID( hWndParent, 0, 0, &bstrDeviceId );
                    if (hr == S_OK && bstrDeviceId != NULL)
                    {
                        //
                        // Save the device ID and free the bstring
                        //
                        strwDeviceId = bstrDeviceId;
                        SysFreeString(bstrDeviceId);
                    }
                }
            }
        }
        else
        {
            //
            // Save the provided device ID
            //
            strwDeviceId = CSimpleStringConvert::WideString(CSimpleString(pszDeviceId));
        }

        //
        // If we have a valid device ID, continue
        //
        if (strwDeviceId.Length())
        {
            //
            // Create the wizard
            //
            CComPtr<IWiaEventCallback> pWiaEventCallback;
            hr = CoCreateInstance( CLSID_AcquisitionManager, NULL, CLSCTX_LOCAL_SERVER, IID_IWiaEventCallback, (void**)&pWiaEventCallback );
            if (SUCCEEDED(hr))
            {
                //
                // Convert the parent window handle to a string, which we will pass as the event description
                // The wizard will only use it this way if the event GUID is IID_NULL
                //
                CSimpleBStr bstrParentWindow( CSimpleString().Format( TEXT("%d"), hWndParent ) );

                //
                // Allow this process to set the foreground window
                //
                CoAllowSetForegroundWindow( pWiaEventCallback, NULL );

                //
                // Call the callback function
                //
                ULONG ulEventType = 0;
                hr = pWiaEventCallback->ImageEventCallback( &IID_NULL,
                                                            bstrParentWindow.BString(),
                                                            CSimpleBStr(strwDeviceId),
                                                            NULL,
                                                            0,
                                                            NULL,
                                                            &ulEventType,
                                                            0);
            }
        }
        return hr;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\runwiz.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       RUNWIZ.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        6/14/2000
 *
 *  DESCRIPTION: Present the device selection dialog and allow the user to select
 *               a device, then cocreate the server and generate the connection
 *               event.
 *
 *******************************************************************************/

#include <windows.h>

namespace RunWiaWizard
{
    HRESULT RunWizard( LPCTSTR pszDeviceId=NULL, HWND hWndParent=NULL, LPCTSTR pszUniqueIdentifier=NULL );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\runnpwiz.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       RUNNPWIZ.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        6/15/2000
 *
 *  DESCRIPTION: Runs the Web Publishing Wizard
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include <windows.h>
#include <atlbase.h>
#include "runnpwiz.h"
#include <simidlst.h>
#include <shellext.h>
#include <shlobj.h>
#include <shlguid.h>
#include <shlwapi.h>
#include <wiadebug.h>
#include <simreg.h>

namespace NetPublishingWizard
{
    static const TCHAR *c_pszPublishWizardSuffix = TEXT(".publishwizard");
    static const TCHAR *c_pszClassIdPrefix       = TEXT("CLSID\\");

    HRESULT GetClassIdOfPublishingWizard( CLSID &clsidWizard )
    {
        WIA_PUSH_FUNCTION((TEXT("GetClassIdOfPublishingWizard")));
        //
        // Assume failure
        //
        HRESULT hr = E_FAIL;

        //
        // Try to get the class id from the registry
        //
        CSimpleString strWizardClsid = CSimpleReg( HKEY_CLASSES_ROOT, c_pszPublishWizardSuffix, false, KEY_READ ).Query( TEXT(""), TEXT("") );
        WIA_TRACE((TEXT("strWizardClsid = %s"), strWizardClsid.String()));

        //
        // Make sure we have a string, and make sure the CLSID\ prefix is there
        //
        if (strWizardClsid.Length() && strWizardClsid.Left(lstrlen(c_pszClassIdPrefix)).ToUpper() == CSimpleString(c_pszClassIdPrefix))
        {
            //
            // Convert the string, minus the CLSID\, to a CLSID
            //
            hr = CLSIDFromString( const_cast<LPOLESTR>(CSimpleStringConvert::WideString(strWizardClsid.Right(strWizardClsid.Length()-6)).String()), &clsidWizard );
        }
        return hr;
    }


    HRESULT RunNetPublishingWizard( const CSimpleDynamicArray<CSimpleString> &strFiles )
    {
        WIA_PUSH_FUNCTION((TEXT("RunNetPublishingWizard")));

        HRESULT hr;

        //
        // Make sure there are some files in the list
        //
        if (strFiles.Size())
        {
            //
            // Get the CLSID of the publishing wizard from the registry
            //
            CLSID clsidWizard = IID_NULL;
            hr = GetClassIdOfPublishingWizard(clsidWizard);
            if (SUCCEEDED(hr))
            {
                WIA_PRINTGUID((clsidWizard,TEXT("Wizard class ID")));
                //
                // Get the data object for this list of files
                //
                CComPtr<IDataObject> pDataObject;
                hr = CreateDataObjectFromFileList( strFiles, &pDataObject );
                if (SUCCEEDED(hr))
                {
                    //
                    // Create the wizard
                    //
                    CComPtr<IDropTarget> pDropTarget;
                    hr = CoCreateInstance( clsidWizard, NULL, CLSCTX_INPROC_SERVER, IID_IDropTarget, (void**)&pDropTarget );
                    if (SUCCEEDED(hr))
                    {
                        //
                        // Perform the drop
                        //
                        DWORD dwEffect = DROPEFFECT_LINK | DROPEFFECT_MOVE | DROPEFFECT_COPY;
                        POINTL pt = { 0, 0 };
                        hr = pDropTarget->Drop( pDataObject, 0, pt, &dwEffect );
                    }
                }
            }
        }
        else
        {
            hr = E_INVALIDARG;
        }

        if (FAILED(hr))
        {
            WIA_PRINTHRESULT((hr,TEXT("RunNetPublishingWizard is returning")));
        }
        return hr;
    }

    HRESULT CreateDataObjectFromFileList( const CSimpleDynamicArray<CSimpleString> &strFiles, IDataObject **ppDataObject )
    {
        WIA_PUSH_FUNCTION((TEXT("CreateDataObjectFromFileList")));

        HRESULT hr;

        //
        // Make sure there are some files in the list
        //
        if (strFiles.Size())
        {
            //
            // Get the desktop folder
            //
            CComPtr<IShellFolder> pDesktopFolder;
            hr = SHGetDesktopFolder( &pDesktopFolder );
            if (SUCCEEDED(hr) && pDesktopFolder.p)
            {
                //
                // Allocate memory to hold the source folder name
                //
                LPTSTR pszPath = new TCHAR[strFiles[0].Length()+1];
                if (pszPath)
                {
                    //
                    // Copy the first filename to the folder name, and remove all but the directory
                    //
                    lstrcpy( pszPath, strFiles[0] );
                    if (PathRemoveFileSpec(pszPath))
                    {
                        //
                        // Get the pidl for the source folder
                        //
                        LPITEMIDLIST pidlFolder;
                        hr = pDesktopFolder->ParseDisplayName( NULL, NULL, const_cast<LPWSTR>(CSimpleStringConvert::WideString(CSimpleString(pszPath)).String()), NULL, &pidlFolder, NULL );
                        if (SUCCEEDED(hr))
                        {
                            WIA_TRACE((TEXT("pidlFolder: %s"), CSimpleIdList(pidlFolder).Name().String()));

                            //
                            // Get an IShellFolder for the source folder
                            //
                            CComPtr<IShellFolder> pSourceFolder;
                            hr = pDesktopFolder->BindToObject( pidlFolder, NULL, IID_IShellFolder, (void**)&pSourceFolder );
                            ILFree(pidlFolder);
                            if (SUCCEEDED(hr) && pSourceFolder.p)
                            {                               
                                //
                                // Create an array of pidls to hold the files
                                //
                                LPITEMIDLIST *pidlItems = new LPITEMIDLIST[strFiles.Size()];
                                if (pidlItems)
                                {
                                    //
                                    // Make sure we start out with NULL pidls
                                    //
                                    ZeroMemory( pidlItems, sizeof(LPITEMIDLIST)*strFiles.Size() );

                                    //
                                    // Get the pidls for the files
                                    //
                                    for (int i=0;i<strFiles.Size();i++)
                                    {
                                        //
                                        // Get the filename alone.  We want relative pidls.
                                        //
                                        CSimpleString strFilename = PathFindFileName(strFiles[i]);
                                        WIA_TRACE((TEXT("strFilename = %s"), strFilename.String()));

                                        //
                                        // Create the relative pidl
                                        //
                                        hr = pSourceFolder->ParseDisplayName( NULL, NULL, const_cast<LPWSTR>(CSimpleStringConvert::WideString(strFilename).String()), NULL, pidlItems+i, NULL );
                                        if (FAILED(hr))
                                        {
                                            WIA_PRINTHRESULT((hr,TEXT("pSourceFolder->ParseDisplayName returned")));
                                            break;
                                        }
                                    }

                                    //
                                    // Make sure everything is still going OK
                                    //
                                    if (SUCCEEDED(hr))
                                    {
                                        //
                                        // Get the IDataObject for the source folder, and give it the list of file pidls
                                        //
                                        hr = pSourceFolder->GetUIObjectOf( NULL, strFiles.Size(), const_cast<LPCITEMIDLIST*>(pidlItems), IID_IDataObject, NULL, reinterpret_cast<LPVOID*>(ppDataObject) );
                                    }
                                    for (int i=0;i<strFiles.Size();i++)
                                    {
                                        if (pidlItems[i])
                                        {
                                            ILFree(pidlItems[i]);
                                        }
                                    }
                                    delete [] pidlItems;
                                }
                                else
                                {
                                    hr = E_OUTOFMEMORY;
                                }
                            }
                            
                        }
                    }
                    else
                    {
                        hr = E_FAIL;
                    }
                    //
                    // Free the folder name
                    //
                    delete[] pszPath;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }

            }
        }
        else
        {
            hr = E_INVALIDARG;
        }

        if (FAILED(hr))
        {
            WIA_PRINTHRESULT((hr,TEXT("CreateDataObjectFromFileList is returning")));
        }
        return hr;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\simidlst.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       SIMIDLST.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        7/28/1999
 *
 *  DESCRIPTION: Simple PIDL Wrapper Class
 *
 *******************************************************************************/
#ifndef __SIMIDLST_H_INCLUDED
#define __SIMIDLST_H_INCLUDED

#include <windows.h>
#include <objbase.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <simstr.h>

class CSimpleIdList
{
private:
    LPITEMIDLIST m_pIdl;
public:
    CSimpleIdList(void)
    : m_pIdl(NULL)
    {
    }
    CSimpleIdList( PBYTE pData, UINT nSize )
    : m_pIdl(NULL)
    {
        m_pIdl = NULL;
        IMalloc *pMalloc = NULL;
        if (SUCCEEDED(SHGetMalloc(&pMalloc)))
        {
            m_pIdl = reinterpret_cast<LPITEMIDLIST>(pMalloc->Alloc( nSize ));
            if (m_pIdl)
            {
                CopyMemory( m_pIdl, pData, nSize );
            }
            pMalloc->Release();
        }
    }
    CSimpleIdList( LPCITEMIDLIST pIdl )
    : m_pIdl(NULL)
    {
        Assign(pIdl);
    }
    CSimpleIdList( const CSimpleIdList &other )
    : m_pIdl(NULL)
    {
        Assign(other.IdList());
    }
    CSimpleIdList( HWND hWnd, int nFolder )
    : m_pIdl(NULL)
    {
        GetSpecialFolder( hWnd, nFolder );
    }
    ~CSimpleIdList(void)
    {
        Destroy();
    }
    bool IsValid(void) const
    {
        return (m_pIdl != NULL);
    }
    CSimpleIdList &operator=( const CSimpleIdList &other )
    {
        if (this != &other)
        {
            Destroy();
            Assign(other.IdList());
        }
        return *this;
    }
    LPITEMIDLIST IdList(void)
    {
        return m_pIdl;
    }
    LPCITEMIDLIST IdList(void) const
    {
        return m_pIdl;
    }
    UINT Size(void) const
    {
        if (!IsValid())
            return 0;
        return ILGetSize(m_pIdl);
    }
    void Release(void)
    {
        m_pIdl = NULL;
    }
    CSimpleIdList &Assign( LPCITEMIDLIST pIdl )
    {
        if (pIdl != m_pIdl)
        {
            Destroy();
            if (pIdl)
            {
                m_pIdl = ILClone(pIdl);
            }
        }
        return *this;
    }
    void Destroy(void)
    {
        if (m_pIdl)
        {
            IMalloc *pMalloc = NULL;
            if (SUCCEEDED(SHGetMalloc(&pMalloc)))
            {
                pMalloc->Free( m_pIdl );
                pMalloc->Release();
            }
            m_pIdl = NULL;
        }
    }
    CSimpleIdList &GetSpecialFolder( HWND hWnd, int nFolder )
    {
        Destroy();
        if (S_OK!=SHGetSpecialFolderLocation(hWnd,nFolder,&m_pIdl))
        {
            // Make sure it is nuked
            Destroy();
        }
        return *this;
    }
    CSimpleString Name(void) const
    {
        CSimpleString strRet;
        if (IsValid())
        {
            TCHAR szPath[MAX_PATH];
            SHGetPathFromIDList( m_pIdl, szPath );
            strRet = szPath;
        }
        return strRet;
    }
    bool operator==( const CSimpleIdList &other )
    {
        return (Name() == other.Name());
    }
    bool operator!=( const CSimpleIdList &other )
    {
        return (Name() != other.Name());
    }
};

#endif // __SIMIDLST_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\simevent.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       SIMEVENT.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        5/4/1999
 *
 *  DESCRIPTION: Simple win32 event wrapper class
 *
 *******************************************************************************/
#ifndef __SIMEVENT_H_INCLUDED
#define __SIMEVENT_H_INCLUDED

#include "simstr.h"

class CSimpleEvent
{
private:
    CSimpleString m_strEventName;
    HANDLE m_hEvent;
public:
    CSimpleEvent( bool bNoCreate = false )
    :  m_hEvent(NULL)
    {
        if (!bNoCreate)
            Assign( CSimpleString(TEXT("")), NULL );
    }
    explicit CSimpleEvent( LPCTSTR pszEventName )
    :  m_hEvent(NULL)
    {
        Assign( pszEventName, NULL );
    }
    explicit CSimpleEvent( const CSimpleString &strEventName )
    :  m_hEvent(NULL)
    {
        Assign( strEventName, NULL );
    }
    CSimpleEvent( HANDLE hEvent )
    :  m_hEvent(NULL)
    {
        Assign( CSimpleString(TEXT("")), hEvent );
    }
    CSimpleEvent( const CSimpleEvent &other )
    :  m_hEvent(NULL)
    {
        Assign( other.EventName(), other.Event() );
    }
    CSimpleEvent &operator=( const CSimpleEvent &other )
    {
        return Assign( other.EventName(), other.Event() );
    }
    CSimpleEvent &operator=( HANDLE hEvent )
    {
        return Assign( TEXT(""), hEvent );
    }
    virtual ~CSimpleEvent(void)
    {
        Close();
    }
    bool Create( const CSimpleString &strEventName = TEXT("") )
    {
        Assign( strEventName, NULL );
        return (m_hEvent != NULL);
    }
    CSimpleEvent &Assign( const CSimpleString &strEventName, const HANDLE hEvent )
    {
        Close();
        if (!strEventName.Length() && !hEvent)
        {
            m_hEvent = CreateEvent( NULL, TRUE, FALSE, NULL );
        }
        else if (strEventName.Length())
        {
            m_strEventName = strEventName;
            m_hEvent = CreateEvent( NULL, TRUE, FALSE, m_strEventName.String() );
        }
        else if (hEvent)
        {
            if (!DuplicateHandle( GetCurrentProcess(), hEvent, GetCurrentProcess(), &m_hEvent, 0, FALSE, DUPLICATE_SAME_ACCESS ))
                m_hEvent = NULL;
        }
        return *this;
    }
    bool Close(void)
    {
        if (m_hEvent)
        {
            CloseHandle(m_hEvent);
            m_hEvent = NULL;
        }
        m_strEventName = TEXT("");
        return true;
    }
    void Reset(void)
    {
        if (!m_hEvent)
            return;
        ResetEvent(m_hEvent);
    }
    bool Signalled(void) const
    {
        if (!m_hEvent)
            return (false);
        DWORD dwRes = WaitForSingleObject(m_hEvent,0);
        return(WAIT_OBJECT_0 == dwRes);
    }
    void Signal(void) const
    {
        if (!m_hEvent)
            return;
        SetEvent(m_hEvent);
    }
    CSimpleString EventName(void) const
    {
        return (m_strEventName);
    }
    HANDLE Event(void) const
    {
        return (m_hEvent);
    }
};

#endif // #ifndef __SIMEVENT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\sources.inc ===
#
# Builds the ImageIn common ui library, COMMON.LIB
#

!include $(PROJECT_ROOT)\ui\uienv.inc


TARGETPATH=$(UI_DIR)\lib\$(PLATFORM_SUFFIX)

ATL_VER         = 30
USE_STATIC_ATL  = 1

TARGETNAME=uicommon
TARGETTYPE=LIBRARY

SOURCES=\
        ..\uiexthlp.cpp   \
        ..\miscutil.cpp   \
        ..\createtb.cpp   \
        ..\pshelper.cpp   \
        ..\rescale.cpp    \
        ..\dumpprop.cpp   \
        ..\resid.cpp      \
        ..\proparry.cpp   \
        ..\errors.cpp     \
        ..\32BitDib.cpp   \
        ..\sysprops.cpp   \
        ..\gdbgdata.cpp   \
        ..\propstrm.cpp   \
        ..\svselfil.cpp   \
        ..\gwiaevnt.cpp   \
        ..\wiacsh.cpp     \
        ..\runwiz.cpp     \
        ..\runnpwiz.cpp   \
        ..\regionde.cpp   \
        ..\mboxex.cpp     \
        ..\wiacrc32.cpp   \
        ..\wiafusion.cpp

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\simtok.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
*
*  TITLE:       SIMTOK.H
*
*  VERSION:     1.0
*
*  AUTHOR:      ShaunIv
*
*  DATE:        5/12/1998
*
*  DESCRIPTION: String tokenizer template class
*
*******************************************************************************/
#ifndef _SIMTOK_H_INCLUDED
#define _SIMTOK_H_INCLUDED

#include "simstr.h"

template <class T>
class CSimpleStringToken
{
private:
    T m_strStr;
    int m_nIndex;
public:
    CSimpleStringToken(void);
    CSimpleStringToken( const T &str );
    CSimpleStringToken( const CSimpleStringToken &other );
    CSimpleStringToken &operator=( const CSimpleStringToken &other );
    virtual ~CSimpleStringToken(void);
    void Reset(void);
    T Tokenize( const T &strDelim );
    T String(void) const;
    int Index(void) const;
};

template <class T>
CSimpleStringToken<T>::CSimpleStringToken(void)
:m_nIndex(0)
{
}

template <class T>
CSimpleStringToken<T>::CSimpleStringToken( const T &str )
: m_strStr(str), m_nIndex(0)
{
}

template <class T>
CSimpleStringToken<T>::CSimpleStringToken( const CSimpleStringToken &other )
: m_strStr(other.String()), m_nIndex(other.Index())
{
}

template <class T>
CSimpleStringToken<T> &CSimpleStringToken<T>::operator=( const CSimpleStringToken &other )
{
    m_strStr = other.String();
    m_nIndex = other.Index();
    return *this;
}

template <class T>
CSimpleStringToken<T>::~CSimpleStringToken(void)
{
}

template <class T>
void CSimpleStringToken<T>::Reset(void)
{
    m_nIndex = 0;
}

template <class T>
T CSimpleStringToken<T>::Tokenize( const T &strDelim )
{
    T strToken(TEXT(""));
    // Throw away the leading delimiters
    while (m_nIndex < (int)m_strStr.Length())
    {
        if (strDelim.Find(m_strStr[m_nIndex]) < 0)
            break;
        ++m_nIndex;
    }
    // Copy the string until we reach a delimiter
    while (m_nIndex < (int)m_strStr.Length())
    {
        if (strDelim.Find(m_strStr[m_nIndex]) >= 0)
            break;
        strToken += m_strStr[m_nIndex];
        ++m_nIndex;
    }
    // Throw away the trailing delimiters
    while (m_nIndex < (int)m_strStr.Length())
    {
        if (strDelim.Find(m_strStr[m_nIndex]) < 0)
            break;
        ++m_nIndex;
    }
    return strToken;
}

template <class T>
T CSimpleStringToken<T>::String(void) const
{
    return m_strStr;
}

template <class T>
int CSimpleStringToken<T>::Index(void) const
{
    return m_nIndex;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\shmemsec.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       SHMEMSEC.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        9/30/1999
 *
 *  DESCRIPTION: Simple shared memory section template.  Don't use it for classes!
 *               Basically, simple objects only.  structs are ok.  Nothing with a
 *               vtable.
 *
 *******************************************************************************/
#ifndef __SHMEMSEC_H_INCLUDED
#define __SHMEMSEC_H_INCLUDED

#include <windows.h>
#include <simstr.h>
#include <miscutil.h>

template <class T>
class CSharedMemorySection
{
public:
    enum COpenResult
    {
        SmsFailed,
        SmsCreated,
        SmsOpened
    };

private:
    HANDLE  m_hMutex;
    HANDLE  m_hFileMapping;
    T      *m_pMappedSection;

private:
    //
    // Not implemented
    //
    CSharedMemorySection( const CSharedMemorySection & );
    CSharedMemorySection &operator=( const CSharedMemorySection & );

public:
    CSharedMemorySection( LPCTSTR pszName=NULL, bool bAllowCreate=true )
      : m_hFileMapping(NULL),
        m_pMappedSection(NULL),
        m_hMutex(NULL)
    {
        WIA_PUSHFUNCTION(TEXT("CSharedMemorySection::CSharedMemorySection"));
        Open(pszName,bAllowCreate);
    }
    ~CSharedMemorySection(void)
    {
        WIA_PUSHFUNCTION(TEXT("CSharedMemorySection::~CSharedMemorySection"));
        Close();
    }
    bool OK(void)
    {
        return(m_pMappedSection != NULL);
    }
    T *Lock(void)
    {
        T *pResult = NULL;
        if (OK())
        {
            if (WiaUiUtil::MsgWaitForSingleObject( m_hMutex, INFINITE ))
            {
                pResult = m_pMappedSection;
            }
        }
        return pResult;
    }
    void Release(void)
    {
        if (OK())
        {
            ReleaseMutex(m_hMutex);
        }
    }
    COpenResult Open( LPCTSTR pszName, bool bAllowCreate=true )
    {
        //
        // Close any previous instances
        //
        Close();

        //
        // Assume failure
        //
        COpenResult orResult = SmsFailed;

        //
        // Make sure we have a valid name
        //
        if (pszName && *pszName)
        {
            //
            // Save the name
            //
            CSimpleString strSectionName = pszName;

            //
            // Replace any invalid characters
            //
            for (int i=0;i<(int)strSectionName.Length();i++)
            {
                if (strSectionName[i] == TEXT('\\'))
                {
                    strSectionName[i] = TEXT('-');
                }
            }

            //
            // Create the mutex name
            //
            CSimpleString strMutex(strSectionName);
            strMutex += TEXT("-Mutex");

            //
            // Try to create the mutex
            //
            m_hMutex = CreateMutex( NULL, FALSE, strMutex );
            if (m_hMutex)
            {
                //
                // Take ownership of the mutex
                //
                if (WiaUiUtil::MsgWaitForSingleObject( m_hMutex, INFINITE ))
                {
                    //
                    // If this file mapping already exists, open it.
                    //
                    m_hFileMapping = OpenFileMapping( FILE_MAP_ALL_ACCESS, FALSE, strSectionName );
                    if (m_hFileMapping)
                    {
                        m_pMappedSection = reinterpret_cast<T*>(MapViewOfFile( m_hFileMapping, FILE_MAP_ALL_ACCESS, 0, 0, sizeof(T) ));
                        orResult = SmsOpened;
                    }
                    else if (bAllowCreate)
                    {
                        //
                        // Create the file mapping
                        //
                        m_hFileMapping = CreateFileMapping( INVALID_HANDLE_VALUE, NULL, PAGE_READWRITE, 0, sizeof(T), strSectionName );
                        if (m_hFileMapping)
                        {
                            //
                            // Try to acquire the file mapping
                            //
                            m_pMappedSection = reinterpret_cast<T*>(MapViewOfFile( m_hFileMapping, FILE_MAP_ALL_ACCESS, 0, 0, sizeof(T) ));
                            if (m_pMappedSection)
                            {
                                //
                                // Initialize the data
                                //
                                ZeroMemory( m_pMappedSection, sizeof(T) );
                                orResult = SmsCreated;
                            }
                        }
                    }
                    //
                    // Release the mutex
                    //
                    ReleaseMutex(m_hMutex);
                }
            }
        }
        //
        // If we weren't able to map the file mapping section, we need to clean up
        //
        if (!m_pMappedSection)
        {
            Close();
        }
        return(orResult);
    }
    void Close(void)
    {
        //
        // First, try to delete it safely.
        //
        if (m_hMutex)
        {
            if (WiaUiUtil::MsgWaitForSingleObject( m_hMutex, INFINITE ))
            {
                if (m_pMappedSection)
                {
                    UnmapViewOfFile(m_pMappedSection);
                    m_pMappedSection = NULL;
                }
                if (m_hFileMapping)
                {
                    CloseHandle(m_hFileMapping);
                    m_hFileMapping = NULL;
                }
                ReleaseMutex(m_hMutex);
            }
        }

        //
        // Then, just clean up
        //
        if (m_pMappedSection)
        {
            UnmapViewOfFile(m_pMappedSection);
            m_pMappedSection = NULL;
        }
        if (m_hFileMapping)
        {
            CloseHandle(m_hFileMapping);
            m_hFileMapping = NULL;
        }
        if (m_hMutex)
        {
            CloseHandle(m_hMutex);
            m_hMutex = NULL;
        }
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\simrect.h ===
#ifndef __SIMRECT_H_INCLUDED
#define __SIMRECT_H_INCLUDED

/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       SIMRECT.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        7/31/1999
 *
 *  DESCRIPTION: Simple rect derived class.  Especially handy for window coords.
 *
 *******************************************************************************/

#include <windows.h>

class CSimpleRect : public RECT
{
public:
    enum CWndRectType
    {
        ClientRect,
        WindowRect
    };

    CSimpleRect(void)
    {
        Assign(0,0,0,0);
    }

    CSimpleRect( const CSimpleRect &other )
    {
        Assign(other);
    }

    CSimpleRect( HWND hWnd, CWndRectType type = ClientRect )
    {
        Assign(0,0,0,0);
        if (ClientRect == type)
            GetClientRect(hWnd);
        else GetWindowRect(hWnd);
    }
    CSimpleRect( int nLeft, int nTop, int nRight, int nBottom )
    {
        Assign(nLeft,nTop,nRight,nBottom);
    }
    CSimpleRect &Assign( const CSimpleRect &other )
    {
        return(Assign(other.left,other.top,other.right,other.bottom));
    }
    CSimpleRect &Assign( int nLeft, int nTop, int nRight, int nBottom )
    {
        left = nLeft;
        top = nTop;
        right = nRight;
        bottom = nBottom;
        return(*this);
    }
    CSimpleRect &operator=( const CSimpleRect &other )
    {
        if (this == &other)
            return(*this);
        return(Assign(other));
    }
    static bool ScreenToClient( HWND hwnd, RECT &rc )
    {
        return (::MapWindowPoints( NULL, hwnd, reinterpret_cast<POINT*>(&rc), 2 ) != 0);
    }
    static bool ClientToScreen( HWND hwnd, RECT &rc )
    {
        return (::MapWindowPoints( hwnd, NULL, reinterpret_cast<POINT*>(&rc), 2 ) != 0);
    }
    CSimpleRect ScreenToClient( HWND hWnd ) const
    {
        CSimpleRect rc(*this);
        ScreenToClient( hWnd, rc );
        return(rc);
    }
    CSimpleRect ClientToScreen( HWND hWnd ) const
    {
        CSimpleRect rc(*this);
        ClientToScreen( hWnd, rc );
        return(rc);
    }
    CSimpleRect &GetWindowRect( HWND hWnd )
    {
        ::GetWindowRect( hWnd, this );
        return(*this);
    }
    CSimpleRect &GetClientRect( HWND hWnd )
    {
        ::GetClientRect( hWnd, this );
        return(*this);
    }
    int Width(void) const
    {
        return(right - left);
    }
    int Height(void) const
    {
        return(bottom - top);
    }
    CSimpleRect &Inflate( int cx, int cy )
    {
        InflateRect( this, cx, cy );
        return *this;
    }
    CSimpleRect &Offset( int cx, int cy )
    {
        OffsetRect( this, cx, cy );
        return *this;
    }
};

#endif //__SIMRECT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\spawnthr.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       SPAWNTHR.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        7/24/1998
 *
 *  DESCRIPTION: Spawn an app with an argument.  Wait for it to close, then delete
 *               the file.
 *
 *******************************************************************************/
#ifndef __SPAWNTHR_H_INCLUDED
#define __SPAWNTHR_H_INCLUDED

class CTempImageOpenThread
{
private:
    TCHAR m_szApp[MAX_PATH];
    TCHAR m_szFile[MAX_PATH];
private:
    // Hidden, can't use
    CTempImageOpenThread(void);
    CTempImageOpenThread( const CTempImageOpenThread & );
    CTempImageOpenThread &operator=( const CTempImageOpenThread & );
private:
    CTempImageOpenThread( LPCTSTR pszApp, LPCTSTR pszFile )
    {
        if (pszApp)
            lstrcpy(m_szApp,pszApp);
        if (pszFile)
            lstrcpy(m_szFile,pszFile);
    }
    virtual ~CTempImageOpenThread(void)
    {
    }
    static DWORD ThreadProc( LPVOID pParam )
    {
        DWORD dwResult = 0;
        CTempImageOpenThread *This = (CTempImageOpenThread *)pParam;
        if (This)
        {
            dwResult = (DWORD)This->Spawn();
            delete This;
        }
        return dwResult;
    }
    bool Spawn(void)
    {
        SHELLEXECUTEINFO sei;
        ZeroMemory( &sei,  sizeof(sei) );
        sei.cbSize = sizeof(sei);
        sei.lpFile = m_szApp;
        sei.lpParameters = m_szFile;
        sei.nShow = SW_NORMAL;
        sei.fMask = SEE_MASK_NOCLOSEPROCESS|SEE_MASK_DOENVSUBST;
        if (ShellExecuteEx( &sei ) && sei.hProcess)
            WaitForSingleObject( sei.hProcess, INFINITE );
        if (lstrlen(m_szFile))
            DeleteFile(m_szFile);
        return true;
    }
public:
    static HANDLE Spawn( LPCTSTR pszApp, LPCTSTR pszFile )
    {
        CTempImageOpenThread *pTempImageOpenThread = new CTempImageOpenThread(pszApp, pszFile);
        if (pTempImageOpenThread)
        {
            DWORD dwThreadId;
            return ::CreateThread( NULL, 0, (LPTHREAD_START_ROUTINE)ThreadProc, pTempImageOpenThread, 0, &dwThreadId );
        }
        return NULL;
    }
};

#endif // __SPAWNTHR_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\svselfil.cpp ===
#include "precomp.h"
#pragma hdrstop
#include "svselfil.h"
#include <windows.h>
#include <shlobj.h>
#include <shlobjp.h>


HRESULT OpenShellFolder::OpenShellFolderAndSelectFile( HWND hWnd, const CSimpleDynamicArray<CSimpleString> &Filenames )
{
    //
    // Assume failure
    //
    HRESULT hr = E_FAIL;

    //
    // Make sure we have some files
    //
    if (Filenames.Size())
    {
        //
        // Save the path name from the first file
        //
        TCHAR szPath[MAX_PATH];
        StrCpyN( szPath, Filenames[0], ARRAYSIZE(szPath));

        //
        // Remove the filename and extension
        //
        if (PathRemoveFileSpec( szPath ))
        {
            //
            // Create the path's IDLIST
            //
            LPITEMIDLIST pidlFolder = NULL;
            if (SUCCEEDED(SHParseDisplayName( szPath, NULL, &pidlFolder, NULL, NULL )) && pidlFolder)
            if (pidlFolder)
            {
                //
                // Create an array to contain the list of filenames
                //
                LPCITEMIDLIST *ppidlFullyQualified = new LPCITEMIDLIST[Filenames.Size()];
                if (ppidlFullyQualified)
                {
                    //
                    // Make sure the array doesn't contain any wild pointers
                    //
                    ZeroMemory(ppidlFullyQualified,sizeof(LPCITEMIDLIST) * Filenames.Size() );

                    //
                    // Create the list of relative pidls
                    //
                    LPCITEMIDLIST *ppidlRelative = new LPCITEMIDLIST[Filenames.Size()];
                    if (ppidlRelative)
                    {
                        //
                        // Make sure the array doesn't contain any wild pointers
                        //
                        ZeroMemory(ppidlRelative,sizeof(LPCITEMIDLIST) * Filenames.Size() );

                        //
                        // Create the list of fully qualified pidls
                        //
                        int nFileCount = 0;
                        for (int i=0;i<Filenames.Size();i++)
                        {
                            //
                            // Get the fully qualified PIDL for this file
                            //
                            LPITEMIDLIST pidlFullyQualified = NULL;
                            if (SUCCEEDED(SHParseDisplayName( Filenames[i], NULL, &pidlFullyQualified, NULL, NULL )) && pidlFullyQualified)
                            {
                                //
                                // Get the last part of the PIDL
                                //
                                LPITEMIDLIST pidlRelative = ILFindLastID(pidlFullyQualified);
                                if (pidlRelative)
                                {
                                    //
                                    // Save the pidl in our list of fully qualified PIDLs and relative PIDLs
                                    //
                                    ppidlFullyQualified[nFileCount] = pidlFullyQualified;
                                    ppidlRelative[nFileCount] = pidlRelative;

                                    //
                                    // Increment the file count
                                    //
                                    nFileCount++;

                                    //
                                    // Set the fully qualified PIDL to NULL so we don't free it
                                    //
                                    pidlFullyQualified = NULL;
                                }

                                //
                                // If the PIDL is non-NULL here, free it.  Otherwise, it will get freed below.
                                //
                                if (pidlFullyQualified)
                                {
                                    ILFree(pidlFullyQualified);
                                }
                            }
                        }

                        //
                        // If we have a file count, open the folder and select the items
                        //
                        if (nFileCount)
                        {
                            hr = SHOpenFolderAndSelectItems( pidlFolder, nFileCount, ppidlRelative, 0 );
                        }

                        //
                        // Free all of the fully qualified PIDLs
                        //
                        for (int i=0;i<Filenames.Size();i++)
                        {
                            if (ppidlFullyQualified[i])
                            {
                                ILFree(const_cast<LPITEMIDLIST>(ppidlFullyQualified[i]));
                            }
                        }

                        //
                        // Free the PIDL array containing the relative pidls
                        //
                        delete[] ppidlRelative;
                    }

                    //
                    // Free the PIDL array containing the fully qualified pidls
                    //
                    delete[] ppidlFullyQualified;
                }

                //
                // Free the folder PIDL
                //
                ILFree(pidlFolder);
            }
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\svselfil.h ===
#ifndef __SVSELFIL_H_INCLUDED
#define __SVSELFIL_H_INCLUDED

#include <windows.h>
#include "simarray.h"

namespace OpenShellFolder
{
    HRESULT OpenShellFolderAndSelectFile( HWND hWnd, const CSimpleDynamicArray<CSimpleString> &Filenames );
}

#endif // __SVSELFIL_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\uicommon.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       UICOMMON.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        4/19/1999
 *
 *  DESCRIPTION: Common include file for the UI library
 *
 *******************************************************************************/
#ifndef __UICOMMON_H_INCLUDED
#define __UICOMMON_H_INCLUDED

// Global new, delete handlers.  Use LocalAlloc.
#include "wianew.h"

// Various macros and helper functions that are in the WiaUiUtil namespace
#include "miscutil.h"

// Quick and dirty way to get a single string or long property from an IUnknown *
#include "pshelper.h"

// Function to create a scaled DIB (good for thumbnails)
#include "rescale.h"

// A handy class for passing around resource ids that can be either numeric or string
#include "resid.h"

// Dynamically sized array class
#include "simarray.h"

// BSTR wrapper
#include "simbstr.h"

// Simple critical section wrapper with extremely handy auto critical sections
#include "simcrit.h"

// Dynamic singly linked list template class, and derivatives: queue and stack
#include "simlist.h"

// A class for setting and getting registry variables
#include "simreg.h"

// String classes
#include "simstr.h"

// String tokenizer
#include "simtok.h"

#include "waitcurs.h"
#include "errors.h"


// Delimited string tokenizer class
#include "delimstr.h"

#endif // __UICOMMON_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\uiexthlp.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       UIEXTHLP.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        7/8/1999
 *
 *  DESCRIPTION: Helper functions for loading UI extensions for WIA devices
 *
 *******************************************************************************/
#ifndef __UIEXTHLP_H_INCLUDED
#define __UIEXTHLP_H_INCLUDED

#include <windows.h>
#include <objbase.h>
#include <wia.h>

namespace WiaUiExtensionHelper
{
    HRESULT GetDeviceExtensionClassID(
        LPCWSTR pszID,
        LPCTSTR pszCategory,
        IID &iidClassID
        );
    HRESULT CreateDeviceExtension(
        LPCWSTR pszID,
        LPCTSTR pszCategory,
        const IID &iid,
        void **ppvObject
        );
    HRESULT GetUiGuidFromWiaItem(
        IWiaItem *pWiaItem,
        LPWSTR pszGuid
        );
    HRESULT GetDeviceExtensionClassID(
        IWiaItem *pWiaItem,
        LPCTSTR pszCategory,
        IID &iidClassID
        );
    HRESULT CreateDeviceExtension(
        IWiaItem *pWiaItem,
        LPCTSTR pszCategory,
        const IID &iid,
        void **ppvObject
        );
    HRESULT GetDeviceIcons(
        BSTR bstrDeviceId,
        LONG nDeviceType,
        HICON *phIconSmall,
        HICON *phIconLarge,
        UINT nIconSize = 0 // 0 means default sizes
        );
    CSimpleString GetExtensionFromGuid(
        IWiaItem *pWiaItem,
        const GUID &guidFormat
        );
}

#endif //__UIEXTHLP_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\tspqueue.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       TSPQUEUE.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        5/4/1999
 *
 *  DESCRIPTION: Thread Safe Priority Queue template class
 *
 *******************************************************************************/
#ifndef __TSPQUEUE_H_INCLUDED
#define __TSPQUEUE_H_INCLUDED

#include "simevent.h"
#include "simcrit.h"
#include "miscutil.h"

template <class T>
class CThreadSafePriorityQueue
{
public:
    enum
    {
        PriorityLow    = 1,
        PriorityNormal = 2,
        PriorityHigh   = 3,
        PriorityUrgent = 4
    };

private:
    class CQueueNode
    {
    private:
        T          *m_pData;
        int         m_nPriority;
        CQueueNode *m_pNext;
    public:
        CQueueNode( T *pData, int nPriority=PriorityNormal )
            : m_pData(NULL), m_nPriority(nPriority), m_pNext(NULL)
        {
            m_pData = pData;
        }
        virtual ~CQueueNode(void)
        {
            if (m_pData)
            {
                delete m_pData;
                m_pData = NULL;
            }
            m_pNext = NULL;
        }
        const CQueueNode *Next(void) const
        {
            return m_pNext;
        }
        CQueueNode *Next(void)
        {
            return m_pNext;
        }
        CQueueNode *Next( CQueueNode *pNext )
        {
            return (m_pNext=pNext);
        }

        T *DetachData()
        {
            T *pResult = m_pData;
            m_pData = NULL;
            return pResult;
        }

        const T *Data(void) const
        {
            return m_pData;
        }
        T *Data(void)
        {
            return m_pData;
        }

        int Priority(void) const
        {
            return m_nPriority;
        }
        int Priority( int nPriority )
        {
            return (m_nPriority=nPriority);
        }
    };

private:
    CQueueNode *m_pHead;
    mutable CSimpleCriticalSection m_CriticalSection;
    CSimpleEvent m_QueueEvent;
    CSimpleEvent m_PauseEvent;

private:
    // No implementation
    CThreadSafePriorityQueue( const CThreadSafePriorityQueue & );
    CThreadSafePriorityQueue &operator=( const CThreadSafePriorityQueue & );

public:
    CThreadSafePriorityQueue(void)
      : m_pHead(NULL)
    {
        m_QueueEvent.Reset();
        m_PauseEvent.Signal();
    }
    ~CThreadSafePriorityQueue(void)
    {
        CAutoCriticalSection cs(m_CriticalSection);
        while (m_pHead)
        {
            CQueueNode *pCurr = m_pHead;
            m_pHead = m_pHead->Next();
            delete pCurr;
        }
    }

    bool Empty( void ) const
    {
        CAutoCriticalSection cs(m_CriticalSection);
        return (NULL == m_pHead);
    }

    CQueueNode *Enqueue( T *pData, int nPriority=PriorityNormal )
    {
        //
        // Grab the critical section
        //
        CAutoCriticalSection cs(m_CriticalSection);

        //
        // Assume we will not be able to add a new item to the queue
        //
        CQueueNode *pResult = NULL;

        //
        // Make sure we have a valid data item
        //
        if (pData)
        {

            //
            // Try to allocate a new queue node
            //
            pResult  = new CQueueNode(pData,nPriority);
            if (pResult)
            {
                //
                // This might be the first item in the queue
                //
                bool bMaybeSignal = Empty();

                //
                // If this is an empty queue or we need to do it right away, put it at the head of the queue
                //
                if (!m_pHead || pResult->Priority() >= PriorityUrgent)
                {
                    pResult->Next(m_pHead);
                    m_pHead = pResult;
                }
                else
                {
                    //
                    // Find the right place to put it
                    //
                    CQueueNode *pCurr = m_pHead;
                    CQueueNode *pPrev = NULL;
                    while (pCurr && pCurr->Priority() >= pResult->Priority())
                    {
                        pPrev = pCurr;
                        pCurr = pCurr->Next();
                    }

                    //
                    // Insert it in the proper place
                    //
                    if (pPrev)
                    {
                        pResult->Next(pCurr);
                        pPrev->Next(pResult);
                    }
                    else
                    {
                        pResult->Next(m_pHead);
                        m_pHead = pResult;
                    }
                }

                //
                // If we were able to allocate the item, and the list isn't empty, signal the queue
                //
                if (bMaybeSignal && !Empty())
                {
                    //
                    // Got one!
                    //
                    Signal();

                    //
                    // Force a yield if this is a high priority message
                    //
                    if (pResult->Priority() >= PriorityHigh)
                    {
                        Sleep(0);
                    }
                }
            }

        }
        return pResult;
    }

    T *Dequeue(void)
    {
        //
        // Grab the critical section
        //
        CAutoCriticalSection cs(m_CriticalSection);

        //
        // Wait until we are not paused
        //
        WiaUiUtil::MsgWaitForSingleObject( m_PauseEvent.Event(), INFINITE );

        //
        // If there are no items, return
        //
        if (Empty())
        {
            return NULL;
        }

        //
        // Grab the first item
        //
        CQueueNode *pFront = m_pHead;

        //
        // Advance to the next item
        //
        m_pHead = m_pHead->Next();

        //
        // Get the data
        //
        T *pResult = pFront->DetachData();

        //
        // Delete the queue item
        //
        delete pFront;

        //
        // If the queue is now empty, reset the event
        //
        if (Empty())
        {
            m_QueueEvent.Reset();
        }

        //
        // Return any data we got
        //
        return pResult;
    }

    void Pause(void)
    {
        m_PauseEvent.Reset();
    }
    void Resume(void)
    {                               
        m_PauseEvent.Signal();
    }


    void Signal(void)
    {
        m_QueueEvent.Signal();
    }

    HANDLE QueueEvent(void)
    {
        return m_QueueEvent.Event();
    }
};

#endif //__TSPQUEUE_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\sysprops.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       sysprops.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        9/24/1999
 *
 *  DESCRIPTION: Implementation of property sheet helpers.  Removed from miscutil,
 *               because it required clients to link to comctl32.dll
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include <shellext.h> // for property page functions
#include "devlist.h" // for property page functions
#include <initguid.h>
#include "wiapropui.h"
DEFINE_GUID (CLSID_WiaPropHelp, 0x83bbcbf3,0xb28a,0x4919,0xa5, 0xaa, 0x73, 0x02, 0x74, 0x45, 0xd6, 0x72);

DEFINE_GUID (IID_IWiaPropUI,  /* 7eed2e9b-acda-11d2-8080-00805f6596d2 */
    0x7eed2e9b,
    0xacda,
    0x11d2,
    0x80, 0x80, 0x00, 0x80, 0x5f, 0x65, 0x96, 0xd2
  );

namespace WiaUiUtil
{
    HRESULT SystemPropertySheet( HINSTANCE hInstance, HWND hwndParent, IWiaItem *pWiaItem, LPCTSTR pszCaption )
    {
        CWaitCursor wc;

        CComPtr<IWiaPropUI> pWiaPropUI;
        HRESULT hr = CoCreateInstance (CLSID_WiaPropHelp, NULL, CLSCTX_INPROC_SERVER, IID_IWiaPropUI, reinterpret_cast<LPVOID*>(&pWiaPropUI));
        if (SUCCEEDED(hr))
        {
            PROPSHEETHEADER PropSheetHeader = {0};
            PropSheetHeader.dwSize = sizeof(PropSheetHeader);
            PropSheetHeader.hwndParent = hwndParent;
            PropSheetHeader.hInstance = hInstance;
            PropSheetHeader.pszCaption = pszCaption;
            hr = pWiaPropUI->GetItemPropertyPages( pWiaItem, &PropSheetHeader );
            if (SUCCEEDED(hr))
            {
                if (PropSheetHeader.nPages)
                {
                    //
                    // Modal property sheets really don't need an apply button...
                    //
                    PropSheetHeader.dwFlags |= PSH_NOAPPLYNOW;

                    INT_PTR nResult = PropertySheet(&PropSheetHeader);

                    if (PropSheetHeader.phpage)
                    {
                        LocalFree(PropSheetHeader.phpage);
                    }

                    if (nResult < 0)
                    {
                        hr = E_FAIL;
                    }
                    else if (IDOK == nResult)
                    {
                        hr = S_OK;
                    }
                    else hr = S_FALSE;
                }
                else
                {
                    hr = PROP_SHEET_ERROR_NO_PAGES;
                }
            }
        }
        return hr;
    }

    // Be careful calling this function.  It is hideously slow...
    HRESULT GetDeviceInfoFromId( LPCWSTR pwszDeviceId, IWiaPropertyStorage **ppWiaPropertyStorage )
    {
        // Check parameters
        if (!pwszDeviceId || !*pwszDeviceId)
        {
            return E_INVALIDARG;
        }
        if (!ppWiaPropertyStorage)
        {
            return E_POINTER;
        }

        // Initialize the return value
        *ppWiaPropertyStorage = NULL;

        CSimpleString strDeviceId = CSimpleStringConvert::NaturalString(CSimpleStringWide(pwszDeviceId));

        CComPtr<IWiaDevMgr> pWiaDevMgr;
        HRESULT hr = CoCreateInstance(CLSID_WiaDevMgr, NULL, CLSCTX_INPROC_SERVER|CLSCTX_LOCAL_SERVER, IID_IWiaDevMgr, (void**)&pWiaDevMgr );
        if (SUCCEEDED(hr))
        {
            // Assume we are going to fail.  This will also cover the case where there are no devices.
            hr = E_FAIL;
            CDeviceList deviceList( pWiaDevMgr );
            for (int i=0;i<deviceList.Size();i++)
            {
                CSimpleStringWide strwCurrDeviceId;
                if (PropStorageHelpers::GetProperty(deviceList[i],WIA_DIP_DEV_ID,strwCurrDeviceId))
                {
                    CSimpleString strCurrDeviceId = CSimpleStringConvert::NaturalString(strwCurrDeviceId);
                    if (strCurrDeviceId == strDeviceId)
                    {
                        *ppWiaPropertyStorage = deviceList[i];
                        if (*ppWiaPropertyStorage)
                            (*ppWiaPropertyStorage)->AddRef();
                        hr = S_OK;
                        break;
                    }
                }
            }
        }
        return hr;
    }

    // Be careful calling this function.  It is hideously slow...
    HRESULT GetDeviceTypeFromId( LPCWSTR pwszDeviceId, LONG *pnDeviceType )
    {
        // Check parameters
        if (!pwszDeviceId || !*pwszDeviceId)
        {
            return E_INVALIDARG;
        }
        if (!pnDeviceType)
        {
            return E_POINTER;
        }

        CComPtr<IWiaPropertyStorage> pWiaPropertyStorage;
        HRESULT hr = GetDeviceInfoFromId( pwszDeviceId, &pWiaPropertyStorage );
        if (SUCCEEDED(hr))
        {
            LONG nDeviceType;
            if (PropStorageHelpers::GetProperty(pWiaPropertyStorage,WIA_DIP_DEV_TYPE,nDeviceType))
            {
                *pnDeviceType = nDeviceType;
                hr = S_OK;
            }
            else
            {
                hr = E_FAIL;
            }
        }
        return hr;
    }

    // Ask WIA for the default event handler for the device
    HRESULT GetDefaultEventHandler (IWiaItem *pItem, const GUID &guidEvent, WIA_EVENT_HANDLER *pwehHandler)
    {
        HRESULT hr;
        IEnumWIA_DEV_CAPS *pEnum;
        WIA_EVENT_HANDLER weh;
        ZeroMemory (pwehHandler, sizeof(WIA_EVENT_HANDLER));
        hr = pItem->EnumRegisterEventInfo (0,
                                           &guidEvent,
                                           &pEnum);
        if (SUCCEEDED(hr))
        {
            ULONG ul;
            bool bFound = false;
            while (!bFound && NOERROR == pEnum->Next (1, &weh, &ul))
            {
                if (weh.ulFlags & WIA_IS_DEFAULT_HANDLER)
                {
                    bFound = true;
                    CopyMemory (pwehHandler, &weh, sizeof(weh));
                }
                else
                {
                    if (weh.bstrDescription)
                    {
                        SysFreeString (weh.bstrDescription);
                    }
                    if (weh.bstrIcon)
                    {
                        SysFreeString (weh.bstrIcon);
                    }
                    if (weh.bstrName)
                    {
                        SysFreeString (weh.bstrName);
                    }
                }

            }
            if (!bFound)
            {
                hr = E_FAIL;
            }
            pEnum->Release ();
        }
        return hr;
    }


    /******************************************************************************

    ItemAndChildrenCount

    Returns the number of items, including root + children

    ******************************************************************************/

    LONG
    ItemAndChildrenCount (IWiaItem *pRoot)
    {
        LONG count = 0;
        HRESULT hr = S_OK;
        IEnumWiaItem *pEnum;
        LONG lType;

        if (pRoot)
        {

            if (SUCCEEDED(pRoot->EnumChildItems(&pEnum)))
            {
                IWiaItem *pChild;

                while (NOERROR == pEnum->Next(1, &pChild, NULL))
                {
                    count++;
                    pChild->Release ();
                }
                pEnum->Release ();

            }

            //
            // See if we should count the root item
            //

            pRoot->GetItemType(&lType);
            if (!(lType & WiaItemTypeRoot))
            {
                count++;
            }


        }

        return count;
    }


    /******************************************************************************

    DeleteItemAndChildren

    Deletes all items in the tree under pRoot

    ******************************************************************************/

    HRESULT
    DeleteItemAndChildren (IWiaItem *pRoot)
    {
        HRESULT hr = S_OK;
        IEnumWiaItem *pEnum;

        if (pRoot)
        {
            // Recurse down til we reach a leaf item
            if (SUCCEEDED(pRoot->EnumChildItems(&pEnum)))
            {
                IWiaItem *pChild;

                while (SUCCEEDED(hr) && NOERROR == pEnum->Next(1, &pChild, NULL))
                {
                    hr = DeleteItemAndChildren (pChild);
                    pChild->Release ();
                }
                pEnum->Release ();
            }
            // now delete the item itself
            // if a delete on a child item failed, stop trying
            // to delete because chances are any subsequent delete
            // is going to fail as well.
            if (SUCCEEDED(hr))
            {
                // don't delete the very root item
                LONG lType;
                pRoot->GetItemType(&lType);
                if (!(lType & WiaItemTypeRoot))
                {
                    hr = pRoot->DeleteItem(0);

                }
            }
        }
        return hr;
    }

} // End namespace WiaUiUtil
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\uiexthlp.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       UIEXTHLP.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        7/8/1999
 *
 *  DESCRIPTION: Helper functions for loading UI extensions for WIA devices
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include <initguid.h>
#include "uiexthlp.h"
#include "wiadevd.h"
#include "wiadevdp.h"
#include "itranhlp.h"
#include "isuppfmt.h"
#include "wiaffmt.h"

namespace WiaUiExtensionHelper
{
    /*
     * Get the clsid of the DLL that implements the interface in the given category
     * Example: GetDeviceExtensionClassID( L"{5d8ef5a3-ac13-11d2-a093-00c04f72dc3c}", TEXT("WiaDialogExtensionHandlers"), iid );
     * where:
     *     L"{5d8ef5a3-ac13-11d2-a093-00c04f72dc3c}" is the GUID stored in the WIA property WIA_DIP_UI_CLSID
     *     TEXT("WiaDialogExtensionHandlers") is the category of extension
     *     iid is a reference to the CLSID of the in process COM object
     */
    HRESULT GetDeviceExtensionClassID( LPCWSTR pwszUiClassId, LPCTSTR pszCategory, IID &iidClassID )
    {
        TCHAR szRootKeyName[1024];
        HRESULT hr = E_FAIL;
        // Make sure all of the parameters are valid
        if (pwszUiClassId && pszCategory && lstrlenW(pwszUiClassId) && lstrlen(pszCategory))
        {
            // construct the key name
            wsprintf( szRootKeyName, TEXT("CLSID\\%ws\\shellex\\%s"), pwszUiClassId, pszCategory );
            HKEY hKeyRoot;
            // open the reg key
            DWORD dwResult = RegOpenKeyEx( HKEY_CLASSES_ROOT, szRootKeyName, 0, KEY_READ, &hKeyRoot );
            if (ERROR_SUCCESS == dwResult)
            {
                TCHAR szClassID[MAX_PATH];
                DWORD dwLength = ARRAYSIZE(szClassID);
                // Note that we only take the first one
                dwResult = RegEnumKeyEx( hKeyRoot, 0, szClassID, &dwLength, NULL, NULL, NULL, NULL );
                if (ERROR_SUCCESS == dwResult)
                {
#if defined(UNICODE)
                    hr = CLSIDFromString(szClassID, &iidClassID);
#else
                    WCHAR wszClassID[MAX_PATH];
                    MultiByteToWideChar (CP_ACP, 0, szClassID, -1, wszClassID, MAX_PATH );
                    hr = CLSIDFromString (wszClassID, &iidClassID);
#endif
                }
                else hr = HRESULT_FROM_WIN32(dwResult);
                RegCloseKey(hKeyRoot);
            }
            else hr = HRESULT_FROM_WIN32(dwResult);
        }
        else hr = E_INVALIDARG;
        return hr;
    }

    HRESULT CreateDeviceExtension( LPCWSTR pwszUiClassId, LPCTSTR pszCategory, const IID &iid, void **ppvObject )
    {
        IID iidClassID;
        HRESULT hr = GetDeviceExtensionClassID( pwszUiClassId, pszCategory, iidClassID );
        if (SUCCEEDED(hr))
        {
            WIA_PRINTGUID((iidClassID,TEXT("Calling CoCreateInstance on")));
            WIA_PRINTGUID((iid,TEXT("Attempting to get an interface pointer for")));
            hr = CoCreateInstance( iidClassID, NULL, CLSCTX_INPROC_SERVER, iid, ppvObject );
        }
        return hr;
    }

    HRESULT GetUiGuidFromWiaItem( IWiaItem *pWiaItem, LPWSTR pwszGuid )
    {
        IWiaPropertyStorage *pPropertyStorage = NULL;
        HRESULT hr;
        if (pWiaItem && pwszGuid)
        {
            hr = pWiaItem->QueryInterface( IID_IWiaPropertyStorage, (void**)&pPropertyStorage );
            if (SUCCEEDED(hr))
            {
                PROPSPEC ps[1];
                PROPVARIANT  pv[1];
                ps[0].ulKind = PRSPEC_PROPID;
                ps[0].propid = WIA_DIP_UI_CLSID;
                hr = pPropertyStorage->ReadMultiple(sizeof(ps)/sizeof(ps[0]), ps, pv);
                if (SUCCEEDED(hr))
                {
                    if (VT_LPWSTR == pv[0].vt || VT_BSTR == pv[0].vt)
                    {
                        lstrcpyW( pwszGuid, pv[0].bstrVal );
                        hr = S_OK;
                    }
                    FreePropVariantArray( sizeof(pv)/sizeof(pv[0]), pv );
                }
                pPropertyStorage->Release();
            }
        }
        else hr = E_INVALIDARG;
        return hr;
    }

    HRESULT GetDeviceExtensionClassID( IWiaItem *pWiaItem, LPCTSTR pszCategory, IID &iidClassID )
    {
        WCHAR wszGuid[MAX_PATH];
        HRESULT hr = GetUiGuidFromWiaItem(pWiaItem,wszGuid);
        if (SUCCEEDED(hr))
        {
            hr = GetDeviceExtensionClassID( wszGuid, pszCategory, iidClassID );
        }
        return hr;
    }

    HRESULT CreateDeviceExtension( IWiaItem *pWiaItem, LPCTSTR pszCategory, const IID &iid, void **ppvObject )
    {

        WCHAR wszGuid[MAX_PATH];
        HRESULT hr = GetUiGuidFromWiaItem(pWiaItem,wszGuid);
        if (SUCCEEDED(hr))
        {
            hr = CreateDeviceExtension( wszGuid, pszCategory, iid, ppvObject );
        }
        return hr;
    }

    HRESULT GetDeviceIcons( IWiaUIExtension *pWiaUIExtension, BSTR bstrDeviceId, HICON *phIconSmall, HICON *phIconLarge, UINT nIconSize )
    {
        if (!pWiaUIExtension || !bstrDeviceId || !lstrlenW(bstrDeviceId))
            return E_INVALIDARG;

        // Assume success
        HRESULT hr = S_OK;

        // Get the small icon, if requested.  Return on failure
        if (phIconSmall)
        {
            hr = pWiaUIExtension->GetDeviceIcon(bstrDeviceId,phIconSmall,HIWORD(nIconSize));
            if (FAILED(hr))
            {
                return hr;
            }
        }

        // Get the large icon, if requested.  Return on failure
        if (phIconLarge)
        {
            hr = pWiaUIExtension->GetDeviceIcon(bstrDeviceId,phIconLarge,LOWORD(nIconSize));
            if (FAILED(hr))
            {
                return hr;
            }
        }
        return hr;
    }

    HRESULT GetDeviceIcons( BSTR bstrDeviceId, LONG nDeviceType, HICON *phIconSmall, HICON *phIconLarge, UINT nIconSize )
    {
        WIA_PUSH_FUNCTION((TEXT("GetDeviceIcons( %ws, %08X, %p, %p, %d )"), bstrDeviceId, nDeviceType, phIconSmall, phIconLarge, nIconSize ));

        // Check args
        if (!bstrDeviceId || !lstrlenW(bstrDeviceId))
        {
            return E_INVALIDARG;
        }

        // Initialize the icons, if necessary
        if (phIconSmall)
        {
            *phIconSmall = NULL;
        }
        if (phIconLarge)
        {
            *phIconLarge = NULL;
        }

        if (!nIconSize)
        {
            int iLarge = GetSystemMetrics(SM_CXICON);
            int iSmall = GetSystemMetrics(SM_CXSMICON);
            nIconSize = (UINT)MAKELONG(iLarge, iSmall);
        }

        // Assume we'll use our own icons
        bool bUseDefaultUI = true;

        // Try to load device ui extension
        CComPtr<IWiaUIExtension> pWiaUIExtension;
        HRESULT hr = WiaUiExtensionHelper::CreateDeviceExtension( bstrDeviceId, SHELLEX_WIAUIEXTENSION_NAME, IID_IWiaUIExtension, (void **)&pWiaUIExtension );
        if (SUCCEEDED(hr))
        {
            hr = GetDeviceIcons( pWiaUIExtension, bstrDeviceId, phIconSmall, phIconLarge, nIconSize );
            if (SUCCEEDED(hr) || hr != E_NOTIMPL)
            {
                bUseDefaultUI = false;
            }
            WIA_PRINTHRESULT((hr,TEXT("GetDeviceIcons returned")));
        }
        else
        {
            WIA_PRINTHRESULT((hr,TEXT("WiaUiExtensionHelper::CreateDeviceExtension failed")));
        }

        WIA_TRACE((TEXT("bUseDefaultUI: %d"), bUseDefaultUI ));
        // Use our own extensions (the default UI).   We use IWiaMiscellaneousHelpers::GetDeviceIcon, because
        // finding the device type given only a device id is horribly slow, since we have to create a device
        // manager AND enumerate devices until we find a match.  Ugh.
        if (bUseDefaultUI)
        {
            CComPtr<IWiaMiscellaneousHelpers> pWiaMiscellaneousHelpers;
            hr = CoCreateInstance( CLSID_WiaDefaultUi, NULL, CLSCTX_INPROC_SERVER, IID_IWiaMiscellaneousHelpers, (void**)(&pWiaMiscellaneousHelpers) );
            if (SUCCEEDED(hr) && phIconSmall)
            {
                hr = pWiaMiscellaneousHelpers->GetDeviceIcon( nDeviceType, phIconSmall, HIWORD(nIconSize));
            }
            if (SUCCEEDED(hr) && phIconLarge)
            {
                hr = pWiaMiscellaneousHelpers->GetDeviceIcon( nDeviceType, phIconLarge, LOWORD(nIconSize) );
            }
            if (FAILED(hr))
            {
                if (phIconSmall && *phIconSmall)
                {
                    DestroyIcon(*phIconSmall);
                }
                if (phIconLarge && *phIconLarge)
                {
                    DestroyIcon(*phIconLarge);
                }
            }
        }
        return hr;
    }

    CSimpleString GetExtensionFromGuid( IWiaItem *pWiaItem, const GUID &guidFormat )
    {
        //
        // Use the supplied format to get the extension
        //
        GUID guidFormatToUse = guidFormat;

        //
        // If we don't have a supplied format, get the default format and use that
        //
        if (IID_NULL == guidFormatToUse)
        {
            //
            // Get the IWiaSupportedFormats interface
            //
            CComPtr<IWiaSupportedFormats> pWiaSupportedFormats;
            HRESULT hr = CoCreateInstance( CLSID_WiaDefaultUi, NULL, CLSCTX_INPROC_SERVER, IID_IWiaSupportedFormats, (void**)&pWiaSupportedFormats );
            if (SUCCEEDED(hr))
            {
                //
                // Tell it we want file information for pWiaItem
                //
                hr = pWiaSupportedFormats->Initialize( pWiaItem, TYMED_FILE );
                if (SUCCEEDED(hr))
                {
                    //
                    // Get the default format
                    //
                    GUID guidDefFormat;
                    hr = pWiaSupportedFormats->GetDefaultClipboardFileFormat( &guidDefFormat );
                    if (SUCCEEDED(hr))
                    {
                        //
                        // Save this format and use it.
                        //
                        guidFormatToUse = guidDefFormat;
                    }
                }
            }
        }
        
        return CWiaFileFormat::GetExtension( guidFormatToUse, TYMED_FILE, pWiaItem );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\vwiaset.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       VWIASET.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        1/10/2000
 *
 *  DESCRIPTION: Encapsulate the differences between LIST and RANGE properties
 *
 *******************************************************************************/

#ifndef __VWIASET_H_INCLUDED
#define __VWIASET_H_INCLUDED

#include <windows.h>
#include "pshelper.h"

class CValidWiaSettings
{
private:
    //
    // Indices into array for range values
    //
    enum
    {
        MinValue = 0,
        MaxValue = 1,
        StepValue = 2
    };

private:
    CSimpleDynamicArray<LONG> m_ValueList;
    LONG                      m_nInitialValue;
    LONG                      m_nType;

public:
    CValidWiaSettings(void)
      : m_nType(0),
        m_nInitialValue(0)
    {
    }
    CValidWiaSettings( IUnknown *pUnknown, const PropStorageHelpers::CPropertyId &propertyName )
      : m_nType(0),
        m_nInitialValue(0)
    {
        Read( pUnknown, propertyName );
    }
    CValidWiaSettings( const CValidWiaSettings &other )
      : m_nType(0),
        m_nInitialValue(0)
    {
        Assign(other);
    }
    CValidWiaSettings &operator=( const CValidWiaSettings &other )
    {
        if (&other != this)
        {
            Assign(other);
        }
        return *this;
    }
    CValidWiaSettings &Assign( const CValidWiaSettings &other )
    {
        Destroy();
        m_nType = other.Type();
        m_ValueList = other.ValueList();
        m_nInitialValue = other.InitialValue();
        if (!IsValid())
        {
            Destroy();
        }
        return *this;
    }
    LONG Type(void) const
    {
        return m_nType;
    }
    LONG InitialValue(void) const
    {
        return m_nInitialValue;
    }
    const CSimpleDynamicArray<LONG> &ValueList(void) const
    {
        return m_ValueList;
    }
    CSimpleDynamicArray<LONG> &ValueList(void)
    {
        return m_ValueList;
    }
    void Destroy(void)
    {
        m_nType = 0;
        m_nInitialValue = 0;
        m_ValueList.Destroy();
    }
    bool IsValid(void) const
    {
        if (IsList())
        {
            return (m_ValueList.Size() != 0);
        }
        else if (IsRange())
        {
            return (m_ValueList.Size() == 3);
        }
        else return false;
    }
    bool Read( IUnknown *pUnknown, const PropStorageHelpers::CPropertyId &propertyName )
    {
        bool bSuccess = false;
        Destroy();
        m_nType = 0;

        //
        // If we can't read this value, we're done
        //
        if (!PropStorageHelpers::GetProperty( pUnknown, propertyName, m_nInitialValue ))
        {
            return false;
        }

        ULONG nAccessFlags;
        if (PropStorageHelpers::GetPropertyAccessFlags( pUnknown, propertyName, nAccessFlags ))
        {
            if (nAccessFlags & WIA_PROP_LIST)
            {
                if (PropStorageHelpers::GetPropertyList( pUnknown, propertyName, m_ValueList ))
                {
                    m_nType = WIA_PROP_LIST;
                    bSuccess = (m_ValueList.Size() != 0);
                }
            }
            else if (nAccessFlags & WIA_PROP_RANGE)
            {
                PropStorageHelpers::CPropertyRange PropertyRange;
                if (PropStorageHelpers::GetPropertyRange( pUnknown, propertyName, PropertyRange ))
                {
                    m_nType = WIA_PROP_RANGE;
                    m_ValueList.Append( PropertyRange.nMin );
                    m_ValueList.Append( PropertyRange.nMax );
                    m_ValueList.Append( PropertyRange.nStep );
                    bSuccess = (m_ValueList.Size() == 3);
                }
            }
        }
        if (!bSuccess)
        {
            Destroy();
        }
        return bSuccess;
    }
    bool FindClosestValueByRoundingDown( LONG &nValue ) const
    {
        //
        // Make sure we have a valid item
        //
        if (!IsValid())
        {
            return false;
        }

        if (IsRange())
        {
            //
            // Make sure we are in the legal range
            //
            nValue = WiaUiUtil::Min( WiaUiUtil::Max( m_ValueList[MinValue], nValue ), m_ValueList[MaxValue] );

            //
            // Divide the difference between nValue and min by nStep, then multiply by nStep to
            // get rid of the remainder to round down to the nearest value
            //
            nValue = m_ValueList[MinValue] + (((nValue - m_ValueList[MinValue]) / m_ValueList[StepValue]) * m_ValueList[StepValue]);
            return true;
        }
        else if (IsList() && m_ValueList.Size())
        {
            //
            // Assume the list is sorted, so we can take the first item and assume it is the minimum value
            //
            LONG nResult = m_ValueList[0];
            for (int i=0;i<m_ValueList.Size();i++)
            {
                if (m_ValueList[i] > nValue)
                {
                    break;
                }
                nResult = m_ValueList[i];
            }
            nValue = nResult;
            return true;
        }
        return false;
    }
    bool FindClosestValue( LONG &nValue ) const
    {
        LONG nFloor=nValue;
        if (FindClosestValueByRoundingDown(nFloor))
        {
            LONG nCeiling=nFloor;
            if (Increment(nCeiling))
            {
                if (nValue - nFloor < nCeiling - nValue)
                {
                    nValue = nFloor;
                    return true;
                }
                else
                {
                    nValue = nCeiling;
                    return true;
                }
            }
        }
        return false;
    }
    bool IsLegalValue( LONG nValue ) const
    {
        LONG nTestValue = nValue;
        if (FindClosestValueByRoundingDown(nTestValue))
        {
            return (nTestValue == nValue);
        }
        return false;
    }
    int FindIndexOfItem( LONG nCurrentValue ) const
    {
        if (IsRange())
        {
            //
            // Make sure we are in the legal range
            //
            nCurrentValue = WiaUiUtil::Min( WiaUiUtil::Max( m_ValueList[MinValue], nCurrentValue ), m_ValueList[MaxValue] );

            return (nCurrentValue - m_ValueList[MinValue]) / m_ValueList[StepValue];
        }
        else if (IsList() && m_ValueList.Size())
        {
            //
            // Assume the list is sorted, so we can take the first item and assume it is the minimum value
            //
            for (int i=0;i<m_ValueList.Size();i++)
            {
                if (m_ValueList[i] == nCurrentValue)
                {
                    return i;
                }
            }
        }
        //
        // returns -1 to indicate failure
        //
        return -1;
    }
    bool Increment( LONG &nCurrentValue ) const
    {
        //
        // Round us off.  This will also take care of validation.
        //
        if (!FindClosestValueByRoundingDown( nCurrentValue ))
        {
            return false;
        }

        if (IsRange())
        {
            //
            // Let FindClosestValueByRoundingDown take care of making sure that we don't exceed the maximum
            //
            nCurrentValue += m_ValueList[StepValue];
            return FindClosestValueByRoundingDown( nCurrentValue );
        }
        else if (IsList() && m_ValueList.Size())
        {
            int nIndex = FindIndexOfItem( nCurrentValue );

            //
            // Make sure we are in the list
            //
            if (nIndex < 0)
            {
                return false;
            }

            //
            // Get the next value
            //
            nIndex++;

            //
            // Make sure we aren't off the end of the list
            //
            if (nIndex >= m_ValueList.Size())
            {
                nIndex = m_ValueList.Size() - 1;
            }

            //
            // Return it
            //
            nCurrentValue = m_ValueList[nIndex];

            //
            // Everything is OK
            //
            return true;
        }
        return false;
    }
    bool Decrement( LONG &nCurrentValue ) const
    {
        //
        // Round us off.  This will also take care of validation.
        //
        if (!FindClosestValueByRoundingDown( nCurrentValue ))
        {
            return false;
        }

        if (IsRange())
        {
            //
            // Let FindClosestValueByRoundingDown take care of making sure that we don't go under the minimum
            //
            nCurrentValue -= m_ValueList[StepValue];
            return FindClosestValueByRoundingDown( nCurrentValue );
        }
        else if (IsList() && m_ValueList.Size())
        {
            int nIndex = FindIndexOfItem( nCurrentValue );

            //
            // Make sure we are in the list
            //
            if (nIndex < 0)
            {
                return false;
            }

            //
            // Get the previous value
            //
            nIndex--;

            //
            // Make sure we aren't before the beginning of the list
            //
            if (nIndex < 0)
            {
                nIndex = 0;
            }

            //
            // Return it
            //
            nCurrentValue = m_ValueList[nIndex];

            //
            // Everything is OK
            //
            return true;
        }
        return false;
    }
    LONG GetItemCount(void) const
    {
        if (IsList())
        {
            return m_ValueList.Size();
        }
        else if (IsRange())
        {
            //
            // Calculate the number of steps between the minimum and maximum
            //
            return ((m_ValueList[MaxValue] - m_ValueList[MinValue]) / m_ValueList[StepValue]) + 1;
        }
        return 0;
    }
    bool GetItemAtIndex( int nIndex, LONG &nItem ) const
    {
        if (!IsValid())
        {
            return false;
        }
        if (IsList() && nIndex >= 0 && nIndex < m_ValueList.Size())
        {
            nItem = m_ValueList[nIndex];
            return true;
        }
        else if (IsRange() && nIndex < GetItemCount())
        {
            //
            // Return the minimum + nIndex * stepvalue
            //
            nItem = m_ValueList[MinValue] + (m_ValueList[StepValue] * nIndex);
            return true;
        }
        return false;
    }
    bool FindIntersection( const CValidWiaSettings &Set1, const CValidWiaSettings &Set2 )
    {
        //
        // We are modifying ourselves, so clear all of our data
        //
        Destroy();

        //
        // If either set is invalid, no intersection
        //
        if (!Set1.IsValid() || !Set2.IsValid())
        {
            return false;
        }

        //
        // If either a or b is a set (or both), just add all of the items
        // that are legal in both to ourself and set the type to a LIST
        //
        if (Set1.IsList())
        {
            m_nType = WIA_PROP_LIST;
            for (int i=0;i<Set1.GetItemCount();i++)
            {
                LONG nItem;
                if (Set1.GetItemAtIndex(i,nItem))
                {
                    if (Set2.IsLegalValue(nItem))
                    {
                        m_ValueList.Append(nItem);
                    }
                }
            }

            //
            // Figure out where to get the initial value from
            //
            if (IsLegalValue(Set1.InitialValue()))
            {
                m_nInitialValue = Set1.InitialValue();
            }
            else if (IsLegalValue(Set2.InitialValue()))
            {
                m_nInitialValue = Set2.InitialValue();
            }
            else
            {
                if (!FindClosestValueByRoundingDown( m_nInitialValue ))
                {
                    //
                    // As a last resort, use the first value
                    //
                    GetItemAtIndex(0,m_nInitialValue);
                }
            }

            return (m_ValueList.Size() != 0);
        }
        else if (Set2.IsList())
        {
            m_nType = WIA_PROP_LIST;
            for (int i=0;i<Set2.GetItemCount();i++)
            {
                LONG nItem;
                if (Set2.GetItemAtIndex(i,nItem))
                {
                    if (Set1.IsLegalValue(nItem))
                    {
                        m_ValueList.Append(nItem);
                    }
                }
            }

            //
            // Figure out where to get the initial value from
            //
            if (IsLegalValue(Set2.InitialValue()))
            {
                m_nInitialValue = Set2.InitialValue();
            }
            else if (IsLegalValue(Set1.InitialValue()))
            {
                m_nInitialValue = Set1.InitialValue();
            }
            else
            {
                if (!FindClosestValueByRoundingDown( m_nInitialValue ))
                {
                    //
                    // As a last resort, use the first value
                    //
                    GetItemAtIndex(0,m_nInitialValue);
                }
            }

            return (m_ValueList.Size() != 0);
        }
        //
        // Both are ranges.
        // BUGBUG: I may have to actually figure out how to do this in a more sophisticated
        // way.  Basically, I am taking the minimum of the two maximums and the maximum of the
        // two minimums if and only if the at least one of the minimums is in the set of the
        // other items and they have the same step value
        //
        else if (Set1.IsLegalValue(Set2.Min()) || Set2.IsLegalValue(Set1.Min()) && Set1.Step() == Set2.Step())
        {
            m_nType = WIA_PROP_RANGE;

            //
            //  Minimum, Maximum, Step
            //
            m_ValueList.Append(WiaUiUtil::Max(Set1.Min(),Set2.Min()));
            m_ValueList.Append(WiaUiUtil::Min(Set1.Max(),Set2.Max()));
            m_ValueList.Append(Set1.Step());

            //
            // Figure out where to get the initial value from
            //
            if (IsLegalValue(Set2.InitialValue()))
            {
                m_nInitialValue = Set2.InitialValue();
            }
            else if (IsLegalValue(Set1.InitialValue()))
            {
                m_nInitialValue = Set1.InitialValue();
            }
            else
            {
                if (!FindClosestValueByRoundingDown( m_nInitialValue ))
                {
                    //
                    // As a last resort, use the first value
                    //
                    GetItemAtIndex(0,m_nInitialValue);
                }
            }

            return (m_ValueList.Size() == 3);
        }
        return true;
    }
    LONG Min(void) const
    {
        if (!IsValid())
        {
            return 0;
        }
        if (IsList())
        {
            return (m_ValueList[0]);
        }
        else if (IsRange())
        {
            return (m_ValueList[MinValue]);
        }
        return 0;
    }
    LONG Max(void) const
    {
        if (!IsValid())
        {
            return 0;
        }
        if (IsList())
        {
            return (m_ValueList[m_ValueList.Size()-1]);
        }
        else if (IsRange())
        {
            return (m_ValueList[MaxValue]);
        }
        return 0;
    }
    LONG Step(void) const
    {
        if (IsRange())
        {
            return (m_ValueList[StepValue]);
        }
        return 0;
    }
    bool IsRange(void) const
    {
        return (m_nType == WIA_PROP_RANGE);
    }
    bool IsList(void) const
    {
        return (m_nType == WIA_PROP_LIST);
    }
    
    static bool SetNumericPropertyOnBoundary( IUnknown *pUnknown, const PropStorageHelpers::CPropertyId &propertyName, LONG nValue )
    {
        CValidWiaSettings ValidWiaSettings;
        if (!ValidWiaSettings.Read( pUnknown, propertyName ))
        {
            return false;
        }
        if (!ValidWiaSettings.FindClosestValueByRoundingDown(nValue))
        {
            return false;
        }
        if (!PropStorageHelpers::SetProperty( pUnknown, propertyName, nValue ))
        {
            return false;
        }
        return true;
    }
    
    
};

#endif //__VWIASET_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\wiacrc32.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       WIACRC32.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        7/7/2000
 *
 *  DESCRIPTION: Generate a 32bit CRC.
 *
 *               This code was taken from \nt\base\ntos\rtl\checksum.c and modified.
 *
 *               A verified test case for this algorithm is that "123456789"
 *               should return 0xCBF43926.
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "wiacrc32.h"

namespace WiaCrc32
{
    /*
    This is the precomputed data table for the CRC32 algorithm as specified in
    IS0 3309.  See RFC-1662 and RFC-1952 for implementation details and
    references.

    To calculate this table, use the following function:

    void PrintCrcTable (void)
    {
        DWORD Val;
        ULONG i, k;

        for (i = 0; i < 256; i++)
        {
            Val = (ULONG) i;
            for (k = 0; k < 8; k++)
            {
                if (Val & 1)
                {
                    Val = 0xedb88320L ^ (Val >> 1);
                }
                else
                {
                    Val = Val >> 1;
                }
            }

            printf( "0x%08X, ", Val);

            if ((i+1) % 6 == 0)
            {
                printf("\n");
            }
        }
    }
    */


    static const DWORD s_CrcTable[256] =
    {
        0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F,
        0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988,
        0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2,
        0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7,
        0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9,
        0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172,
        0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C,
        0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59,
        0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423,
        0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924,
        0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106,
        0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433,
        0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D,
        0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E,
        0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950,
        0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65,
        0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7,
        0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0,
        0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA,
        0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F,
        0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81,
        0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A,
        0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84,
        0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1,
        0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB,
        0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC,
        0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E,
        0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B,
        0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55,
        0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236,
        0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28,
        0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D,
        0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F,
        0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38,
        0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242,
        0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777,
        0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69,
        0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2,
        0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC,
        0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9,
        0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693,
        0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94,
        0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D
    };


    DWORD GenerateCrc32( DWORD cbBuffer, PVOID pvBuffer )
    {
        DWORD dwResult = 0xFFFFFFFF;
        PBYTE pbBuffer = reinterpret_cast<PBYTE>(pvBuffer);
        if (pbBuffer)
        {
            for (DWORD i=0;i<cbBuffer;i++)
            {
                dwResult = (dwResult >> 8) ^ s_CrcTable[static_cast<BYTE>(dwResult ^ static_cast<DWORD>(pbBuffer[i]))];
            }
        }
        return dwResult ^ 0xFFFFFFFF;
    }

    DWORD GenerateCrc32Handle( HANDLE hFile )
    {
        DWORD dwResult = 0;
        DWORD dwSize = GetFileSize( hFile, NULL );
        if (dwSize != static_cast<DWORD>(-1))
        {
            HANDLE hFileMapping = CreateFileMapping( hFile, NULL, PAGE_READONLY, 0, dwSize, NULL );
            if (hFileMapping)
            {
                PBYTE pData = reinterpret_cast<PBYTE>(MapViewOfFile( hFileMapping, FILE_MAP_READ, 0, 0, dwSize ));
                if (pData)
                {
                    dwResult = GenerateCrc32( dwSize, pData );
                    UnmapViewOfFile( pData );
                }
                CloseHandle(hFileMapping);
            }
        }
        return dwResult;
    }

    DWORD GenerateCrc32File( LPCTSTR pszFilename )
    {
        DWORD dwResult = 0;
        HANDLE hFile = CreateFile( pszFilename, GENERIC_READ, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );
        if (INVALID_HANDLE_VALUE != hFile)
        {
            dwResult = GenerateCrc32Handle( hFile );
            CloseHandle(hFile);
        }
        return dwResult;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\wiacrc32.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       CRC32.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        7/7/2000
 *
 *  DESCRIPTION: Generate a 32bit CRC.
 *
 *               This code was taken from \nt\base\ntos\rtl\checksum.c and modified.
 *
 *               A verified test case for this algorithm is that "123456789"
 *               should return 0xCBF43926.
 *
 *******************************************************************************/
#ifndef __WIACRC32_H_INCLUDED
#define __WIACRC32_H_INCLUDED

#include <windows.h>

namespace WiaCrc32
{
    DWORD GenerateCrc32( DWORD cbBuffer, PVOID pvBuffer );
    DWORD GenerateCrc32Handle( HANDLE hFile );
    DWORD GenerateCrc32File( LPCTSTR pszFilename );
}


#endif // __WIACRC32_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\wiacsh.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       WIACSH.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        1/20/2000
 *
 *  DESCRIPTION: Helper functions for context sensitive help
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include "wiacsh.h"

//
// If the help ID is >= this number, it must be an item that lives in windows.hlp,
// otherwise, it lives in whatever the WIA help file is called (currently camera.hlp)
//
#define MAX_WIA_HELP_ID 20000

namespace WiaHelp
{
    static LPCTSTR DetermineHelpFileName( HWND hWnd, const DWORD *pdwContextIds )
    {
        //
        // Can't happen, but still...
        //
        if (!pdwContextIds)
        {
            return WIA_SPECIFIC_HELP_FILE;
        }

        //
        // If it isn't a window, it isn't a standard id
        //
        if (!hWnd || !IsWindow(hWnd))
        {
            return WIA_SPECIFIC_HELP_FILE;
        }

        //
        // If it doesn't have a window id, it isn't a standard id either
        //
        LONG nWindowId = GetWindowLong( hWnd, GWL_ID );
        if (!nWindowId)
        {
            return WIA_SPECIFIC_HELP_FILE;
        }

        for (const DWORD *pdwCurr = pdwContextIds;*pdwCurr;pdwCurr+=2)
        {
            //
            // If this is the window ID we are looking for...
            //
            if (nWindowId == static_cast<LONG>(pdwCurr[0]))
            {
                //
                // return true if its help id is greater than or equal to the max legal id number for wia
                //
                return (pdwCurr[1] >= MAX_WIA_HELP_ID ? WIA_STANDARD_HELP_FILE : WIA_SPECIFIC_HELP_FILE);
            }
        }

        //
        // Not found
        //
        return WIA_SPECIFIC_HELP_FILE;
    }

    LRESULT HandleWmHelp( WPARAM wParam, LPARAM lParam, const DWORD *pdwContextIds )
    {
        if (pdwContextIds)
        {
            LPHELPINFO pHelpInfo = reinterpret_cast<LPHELPINFO>(lParam);
            if (pHelpInfo && pHelpInfo->iContextType == HELPINFO_WINDOW)
            {
                //
                // Call WinHelp
                //
                WinHelp(
                    reinterpret_cast<HWND>(pHelpInfo->hItemHandle),
                    DetermineHelpFileName( reinterpret_cast<HWND>(pHelpInfo->hItemHandle), pdwContextIds ),
                    HELP_WM_HELP,
                    reinterpret_cast<ULONG_PTR>(pdwContextIds)
                );
            }
        }
        return 0;
    }

    LRESULT HandleWmContextMenu( WPARAM wParam, LPARAM lParam, const DWORD *pdwContextIds )
    {
        if (pdwContextIds)
        {
            HWND hWnd = reinterpret_cast<HWND>(wParam);
            if (hWnd)
            {
                //
                // Call WinHelp
                //
                WinHelp(
                    hWnd,
                    DetermineHelpFileName( hWnd, pdwContextIds ),
                    HELP_CONTEXTMENU,
                    reinterpret_cast<ULONG_PTR>(pdwContextIds)
                );
            }
        }
        return 0;
    }

} // End namespace WiaHelp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\wiaffmt.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       WIAFFMT.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        8/24/2000
 *
 *  DESCRIPTION: Helper class which encapsulates WIA image file formats
 *
 *******************************************************************************/
#ifndef __WIAFFMT_H_INCLUDED
#define __WIAFFMT_H_INCLUDED

#include <windows.h>
#include <simstr.h>
#include <wia.h>
#include <pshelper.h>

class CWiaFileFormat
{
private:
    GUID          m_guidFormat;
    CSimpleString m_strExtension;
    CSimpleString m_strDescription;
    HICON         m_hIcon;

public:
    CWiaFileFormat( const GUID &guidFormat=IID_NULL, const CSimpleString &strExtension=TEXT(""), const CSimpleString &strDescription=TEXT(""), const HICON hIcon=NULL )
      : m_guidFormat(guidFormat),
        m_strExtension(strExtension),
        m_strDescription(strDescription),
        m_hIcon(NULL)
    {
        if (hIcon)
        {
            m_hIcon = CopyIcon(hIcon);
        }
    }
    CWiaFileFormat( const CWiaFileFormat &other )
      : m_guidFormat(other.Format()),
        m_strExtension(other.Extension()),
        m_strDescription(other.Description()),
        m_hIcon(NULL)
    {
        if (other.Icon())
        {
            m_hIcon = CopyIcon(other.Icon());
        }
    }
    CWiaFileFormat( const GUID &guidFormat, const HICON hDefaultIcon )
      : m_guidFormat(guidFormat),
        m_strExtension(GetExtension(guidFormat)),
        m_strDescription(TEXT("")),
        m_hIcon(NULL)
    {
        if (m_strExtension.Length())
        {
            AcquireDescription();
            AcquireIcon(hDefaultIcon);
        }
    }
    ~CWiaFileFormat(void)
    {
        Destroy();
    }
    CWiaFileFormat &operator=( const CWiaFileFormat &other )
    {
        if (this != &other)
        {
            m_guidFormat = other.Format();
            m_strExtension = other.Extension();
            m_strDescription = other.Description();
            if (other.Icon())
            {
                m_hIcon = CopyIcon(other.Icon());
            }
        }
        return *this;
    }
    void Destroy(void)
    {
        m_guidFormat = IID_NULL;
        m_strExtension = TEXT("");
        m_strDescription = TEXT("");
        if (m_hIcon)
        {
            DestroyIcon(m_hIcon);
            m_hIcon = NULL;
        }
    }
    bool IsValid(void) const
    {
        return (m_guidFormat != IID_NULL && m_strExtension.Length());
    }
    HICON AcquireIcon( const HICON hDefaultIcon, bool bSmall=true )
    {
        if (!IsValid())
        {
            return false;
        }

        //
        // If we've already gotten the icon, return it
        //
        if (m_hIcon)
        {
            return m_hIcon;
        }

        //
        // Use the extension to get the icon
        //
        CSimpleString strExtension(m_strExtension.ToUpper());
        SHFILEINFO SHFileInfo = {0};
        if (SHGetFileInfo( CSimpleString(TEXT(".")) + strExtension, 0, &SHFileInfo, sizeof(SHFileInfo), bSmall ? SHGFI_SMALLICON|SHGFI_ICON|SHGFI_USEFILEATTRIBUTES : SHGFI_ICON|SHGFI_USEFILEATTRIBUTES ))
        {
            //
            // We will take ownership of this icon
            //
            if (SHFileInfo.hIcon)
            {
                m_hIcon = SHFileInfo.hIcon;
            }
        }

        //
        // If we haven't gotten the icon, use the default icon
        //
        if (!m_hIcon && hDefaultIcon)
        {
            m_hIcon = CopyIcon(hDefaultIcon);
        }

        return m_hIcon;
    }
    CSimpleString AcquireDescription(void)
    {
        if (!IsValid())
        {
            return TEXT("");
        }

        //
        // If we've already gotten the description, return it
        //
        if (m_strDescription.Length())
        {
            return m_strDescription;
        }

        //
        // Use the extension to get the description
        //
        CSimpleString strExtension(m_strExtension.ToUpper());
        SHFILEINFO SHFileInfo = {0};
        if (SHGetFileInfo( CSimpleString(TEXT(".")) + strExtension, 0, &SHFileInfo, sizeof(SHFileInfo), SHGFI_USEFILEATTRIBUTES|SHGFI_TYPENAME ))
        {
            //
            // We will take ownership of this icon
            //
            if (lstrlen(SHFileInfo.szTypeName))
            {
                m_strDescription = SHFileInfo.szTypeName;
            }
        }
        return m_strDescription;
    }
    static CSimpleString GetExtension( const GUID &guidFormat )
    {
        static const struct
        {
            const GUID *guidFormat;
            LPCTSTR pszExtension;
        }
        cs_WiaFormatExtensions[] =
        {
            { &WiaImgFmt_BMP,          TEXT("bmp")},
            { &WiaImgFmt_MEMORYBMP,    TEXT("bmp")},
            { &WiaImgFmt_JPEG,         TEXT("jpg")},
            { &WiaImgFmt_TIFF,         TEXT("tif")},
            { &WiaImgFmt_FLASHPIX,     TEXT("fpx")},
            { &WiaImgFmt_GIF,          TEXT("gif")},
            { &WiaImgFmt_EXIF,         TEXT("jpg")},
            { &WiaImgFmt_WMF,          TEXT("wmf")},
            { &WiaImgFmt_PNG,          TEXT("png")},
            { &WiaImgFmt_PHOTOCD,      TEXT("pcd")},
            { &WiaImgFmt_EMF,          TEXT("emf")},
            { &WiaImgFmt_ICO,          TEXT("ico")},

            { &WiaAudFmt_WAV,          TEXT("wav")},
            { &WiaAudFmt_MP3,          TEXT("mp3")},
            { &WiaAudFmt_AIFF,         TEXT("aif")},
            { &WiaAudFmt_WMA,          TEXT("wma")},

            { &WiaImgFmt_RTF,          TEXT("rtf")},
            { &WiaImgFmt_XML,          TEXT("xml")},
            { &WiaImgFmt_HTML,         TEXT("htm")},
            { &WiaImgFmt_TXT,          TEXT("txt")},
            { &WiaImgFmt_MPG,          TEXT("mpg")},
            { &WiaImgFmt_AVI,          TEXT("avi")}
        };
        for (int i=0;i<ARRAYSIZE(cs_WiaFormatExtensions);i++)
        {
            if (*cs_WiaFormatExtensions[i].guidFormat == guidFormat)
            {
                return cs_WiaFormatExtensions[i].pszExtension;
            }
        }
        return TEXT("");
    }
    static CSimpleString GetExtension( const GUID &guidFormat, LONG nMediaType, IUnknown *pUnknown )
    {
        //
        // First, try to get the extension from the static table above
        //
        CSimpleString strResult = GetExtension( guidFormat );
        if (!strResult.Length())
        {
            //
            // Save the current media type and format, because (unfortunately), there is no way to
            // get the preferred extension for a given format without setting it.
            //
            LONG nOldMediaType = 0;
            if (PropStorageHelpers::GetProperty( pUnknown, WIA_IPA_TYMED, nOldMediaType ))
            {
                //
                // Save the current format
                //
                GUID guidOldFormat = IID_NULL;
                if (PropStorageHelpers::GetProperty( pUnknown, WIA_IPA_FORMAT, guidOldFormat ))
                {
                    //
                    // Set the format and media type to the ones chosen
                    //
                    if (PropStorageHelpers::SetProperty( pUnknown, WIA_IPA_FORMAT, guidFormat ) &&
                        PropStorageHelpers::SetProperty( pUnknown, WIA_IPA_TYMED, nMediaType ))
                    {
                        //
                        // Try to read the extension property
                        //
                        CSimpleStringWide strwExtension;
                        if (PropStorageHelpers::GetProperty( pUnknown, WIA_IPA_FILENAME_EXTENSION, strwExtension ))
                        {
                            //
                            // If we got an extension, save it as the result
                            //
                            strResult = CSimpleStringConvert::NaturalString(strwExtension);
                        }
                    }
                    
                    //
                    // Restore the original format property
                    //
                    PropStorageHelpers::SetProperty( pUnknown, WIA_IPA_FORMAT, guidOldFormat );
                }
                
                //
                // Restore the original media type property
                //
                PropStorageHelpers::SetProperty( pUnknown, WIA_IPA_TYMED, nOldMediaType );
            }
        }
        return strResult;
    }
    static bool IsKnownAudioFormat( const GUID &guidFormat )
    {
        static const GUID *cs_WiaAudioFormats[] =
        {
            &WiaAudFmt_WAV,
            &WiaAudFmt_MP3,
            &WiaAudFmt_AIFF,
            &WiaAudFmt_WMA
        };
        for (int i=0;i<ARRAYSIZE(cs_WiaAudioFormats);i++)
        {
            if (*cs_WiaAudioFormats[i] == guidFormat)
            {
                return true;
            }
        }
        return false;
    }
    GUID Format(void) const
    {
        return m_guidFormat;
    }
    CSimpleString Extension(void) const
    {
        return m_strExtension;
    }
    CSimpleString Description(void) const
    {
        return m_strDescription;
    }
    HICON Icon(void) const
    {
        return m_hIcon;
    }
    void Format( const GUID &guidFormat )
    {
        m_guidFormat = guidFormat;
    }
    void Extension( const CSimpleString &strExtension )
    {
        m_strExtension = strExtension;
    }
    void Description( const CSimpleString &strDescription )
    {
        m_strDescription = strDescription;
    }
    void Icon( const HICON hIcon )
    {
        if (m_hIcon)
        {
            DestroyIcon(m_hIcon);
            m_hIcon = NULL;
        }
        if (hIcon)
        {
            m_hIcon = CopyIcon(m_hIcon);
        }
    }
    bool operator==( const CWiaFileFormat &other )
    {
        return ((other.Format() == Format()) != 0);
    }
    bool operator==( const GUID &guidFormat )
    {
        return ((guidFormat == Format()) != 0);
    }
    void Dump(void)
    {
        WIA_PUSHFUNCTION(TEXT("CWiaFileFormat::Dump()"));
        WIA_PRINTGUID((m_guidFormat,TEXT("  m_guidFormat")));
        WIA_TRACE((TEXT("  m_strExtension: %s"), m_strExtension.String()));
        WIA_TRACE((TEXT("  m_strDescription: %s"), m_strDescription.String()));
        WIA_TRACE((TEXT("  m_strDescription: %p"), m_hIcon));
    }
};


class CWiaFileFormatList
{
private:
    CSimpleDynamicArray<CWiaFileFormat> m_FormatList;

private:
    CWiaFileFormatList( const CWiaFileFormatList & );
    CWiaFileFormatList &operator=( const CWiaFileFormatList & );

public:
    CWiaFileFormatList(void);
    CWiaFileFormatList( const GUID **pguidFormats, UINT nFormatCount, HICON hDefaultIcon )
    {
        if (pguidFormats)
        {
            for (UINT i=0;i<nFormatCount;i++)
            {
                m_FormatList.Append( CWiaFileFormat( *pguidFormats[i], hDefaultIcon ) );
            }
        }
    }
    CWiaFileFormatList( IWiaItem *pWiaItem, HICON hDefaultIcon )
    {
        //
        // Get the data transfer interface
        //
        CComPtr<IWiaDataTransfer> pWiaDataTransfer;
        HRESULT hr = pWiaItem->QueryInterface( IID_IWiaDataTransfer, (void**)&pWiaDataTransfer );
        if (SUCCEEDED(hr))
        {
            //
            // Get the format info enumerator
            //
            CComPtr<IEnumWIA_FORMAT_INFO> pEnumWIA_FORMAT_INFO;
            hr = pWiaDataTransfer->idtEnumWIA_FORMAT_INFO(&pEnumWIA_FORMAT_INFO);
            if (SUCCEEDED(hr))
            {
                //
                // Enumerate the formats
                //
                ULONG ulFetched = 0;
                WIA_FORMAT_INFO WiaFormatInfo;
                while (pEnumWIA_FORMAT_INFO->Next(1,&WiaFormatInfo,&ulFetched) == S_OK)
                {
                    if (WiaFormatInfo.lTymed == TYMED_FILE)
                    {
                        CWiaFileFormat newFormat(WiaFormatInfo.guidFormatID,hDefaultIcon);
                        if (newFormat.IsValid())
                        {
                            m_FormatList.Append(newFormat);
                        }
                    }
                }
            }
        }
    }

    const CSimpleDynamicArray<CWiaFileFormat> &FormatList(void) const
    {
        return m_FormatList;
    }

    CWiaFileFormatList &Union( const CWiaFileFormatList &other )
    {
        for (int nSource=0;nSource<other.FormatList().Size();nSource++)
        {
            int nFindResult = m_FormatList.Find(other.FormatList()[nSource]);
            if (nFindResult < 0)
            {
                m_FormatList.Append(other.FormatList()[nSource]);
            }
        }
        return *this;
    }
    void Dump(void)
    {
        for (int i=0;i<m_FormatList.Size();i++)
        {
            m_FormatList[i].Dump();
        }
    }
};

#endif // __WIAFFMT_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\wianew.h ===
#ifndef __IINEW_H_INCLUDED
#define __IINEW_H_INCLUDED

#if defined(__cplusplus)

#include "wiadebug.h"

inline void * __cdecl operator new(size_t size)
{
    if (0 == size)
    {
        return NULL;
    }

    PBYTE pBuf = size ? (PBYTE)LocalAlloc(LPTR, size) : NULL;

    #if !defined(WIA_DONT_DO_LEAK_CHECKS)
    WIA_RECORD_ALLOC(pBuf,size);
    #endif

    return (void *)pBuf;
}

inline void __cdecl operator delete(void *ptr)
{
    if (ptr)
    {
        #if !defined(WIA_DONT_DO_LEAK_CHECKS)
        WIA_RECORD_FREE(ptr);
        #endif

        LocalFree(ptr);
    }
}

extern "C" inline __cdecl _purecall(void)
{
    return 0;
}



#endif  // __cplusplus


#endif // __IINEW_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\wiacsh.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       WIACSH.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        1/20/2000
 *
 *  DESCRIPTION: Context-sensitive help for dialogs
 *
 *******************************************************************************/
#ifndef __WIACSH_H_INCLUDED
#define __WIACSH_H_INCLUDED

//
// Context sensitive help helper functions
// They are meant to be called from WM_HELP and WM_CONTEXTMENU handlers, respectively
//
namespace WiaHelp
{
    LRESULT HandleWmHelp( WPARAM wParam, LPARAM lParam, const DWORD *pdwContextIds );
    LRESULT HandleWmContextMenu( WPARAM wParam, LPARAM lParam, const DWORD *pdwContextIds );
}

//
// Help file names
//
#define WIA_SPECIFIC_HELP_FILE TEXT("camera.hlp")
#define WIA_STANDARD_HELP_FILE TEXT("windows.hlp")


//
// WIA Help IDs found in camera.hlp
//

//
// Select dialog
//
#define IDH_WIA_MAKER              1000
#define IDH_WIA_DESCRIBE           1001
#define IDH_WIA_DEVICE_LIST        1002
#define IDH_WIA_BUTTON_PROP        1004

//
// Camera device property page
//
#define IDH_WIA_CONNECTED          1010
#define IDH_WIA_PICS_TAKEN         1011
#define IDH_WIA_PICS_LEFT          1012
#define IDH_WIA_BATTERY_STATUS     1013
#define IDH_WIA_IMAGE_SETTINGS     1014
#define IDH_WIA_TEST_BUTTON        1015
#define IDH_WIA_PORT_NAME          1016

//
// Events property page
//
#define IDH_WIA_EVENT_LIST         1020
#define IDH_WIA_APP_LIST           1021
#define IDH_WIA_START_PROG         1022
#define IDH_WIA_PROMPT_PROG        1023
#define IDH_WIA_NO_ACTION          1024
#define IDH_WIA_DELETE_IMAGES      1026
#define IDH_WIA_SAVE_TO            1027  //(radio button)
#define IDH_WIA_SAVE_TO_FOLDER     1028  //(Folder text box)
#define IDH_WIA_CREATE_SUBFLDR     1029  //(Create subfolder check box)
//
// Color management property page
//
#define IDH_WIA_COLOR_PROFILES     1030
#define IDH_WIA_ADD_PROFILE        1031
#define IDH_WIA_REMOVE_PROFILE     1032

//
// Scanner device property page
//
#define IDH_WIA_FRIENDLY           1040
#define IDH_WIA_STATUS             1041

//
// Scanner and camera wizard
//
#define IDH_WIA_PUT_SUBFOLD        1050
#define IDH_WIA_SUBFOLD_DATE       1051
#define IDH_WIA_SUBFOLD_NAME       1052
#define IDH_WIA_CLOSE_WIZARD       1053

//
// Screensaver
//
#define IDH_WIA_CHANGE_PICS        1060
#define IDH_WIA_PIC_SIZE           1061
#define IDH_WIA_PICTURE_FOLDER     1062
#define IDH_WIA_STRETCH_PICS       1063
#define IDH_WIA_SHOW_FILE_NAMES    1064
#define IDH_WIA_TRANSITION_EFFECTS 1065
#define IDH_WIA_ALLOW_SCROLL       1066
#define IDH_WIA_BROWSE             1067

//
// Scanner item property page
//
#define IDH_WIA_BRIGHTNESS         1070
#define IDH_WIA_CONTRAST           1071
#define IDH_WIA_PIC_RESOLUTION     1072
#define IDH_WIA_CUSTOM_PREVIEW     1073
#define IDH_WIA_RESTORE_DEFAULT    1074
#define IDH_WIA_IMAGE_TYPE         1075

//
// Camera item property page
//
#define IDH_WIA_PIC_NAME           1080
#define IDH_WIA_DATE_TAKEN         1081
#define IDH_WIA_TIME_TAKEN         1082
#define IDH_WIA_IMAGE_FORMAT       1083
#define IDH_WIA_PICTURE_SIZE       1084

//
// Scan dialog
//
#define IDH_WIA_PIC_TYPE           1090
#define IDH_WIA_PAPER_SOURCE       1091
#define IDH_WIA_PAGE_SIZE          1092
#define IDH_WIA_CUSTOM_SETTINGS    1093
#define IDH_WIA_PREVIEW_BUTTON     1094
#define IDH_WIA_SCAN_BUTTON        1095
#define IDH_WIA_IMAGE_PREVIEW      1096

//
// Camera common dialog
//
#define IDH_WIA_BUTTONS            1100
#define IDH_WIA_GET_PICS           1101
#define IDH_WIA_PIC_LIST           1102
#define IDH_WIA_VIEW_PIC_INFO      1103
#define IDH_WIA_PREVIEW_DETAIL     1104

//
// Video common dialog
//
#define IDH_WIA_VIDEO               1110
#define IDH_WIA_CAPTURED_IMAGES     1111
#define IDH_WIA_CAPTURE             1112
#define IDH_WIA_VIDEO_GET_PICTURE   1113

//Prompt to start dialog
//When you select Prompt to Start for a specific event (on Events tab)
//and then initiate the Event
#define IDH_WIA_EVENT_OCCURRED      1120
#define IDH_WIA_PROGRAM_LIST        1121
#define IDH_WIA_ALWAYS_USE          1122

#define IDH_WIA_BAUD_RATE           1130
#define IDH_WIA_CAMERA_TIME_STATIC  1133
#define IDH_WIA_FLASH_MODE          1134
#define IDH_WIA_FLASH_MODE_LIST     1135
#define IDH_WIA_IMAGE_SIZE_SLIDER   1136
#define IDH_WIA_CAMERA_TIME_BUTTON  1137
#define IDH_WIA_PORT_SPEED          1138
#define IDH_WIA_IMAGE_SIZE_STATIC   1140

//
// Standard help IDs, found in windows.hlp
//
#define IDH_OK                     28443
#define IDH_CANCEL                 28444
#define IDH_BROWSE                 28496

#endif // __WIACSH_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\wiafusion.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       WIAFUSION.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        5/28/1998
 *
 *  DESCRIPTION: Various utility functions we use in more than one place
 *
 *******************************************************************************/

#include "precomp.h"
#pragma hdrstop
#include <commctrl.h>

namespace WiaUiUtil
{
    void PreparePropertyPageForFusion( PROPSHEETPAGE *pPropSheetPage )
    {
#if defined(PSP_USEFUSIONCONTEXT)
        if (pPropSheetPage)
        {
            pPropSheetPage->hActCtx  = g_hActCtx;
            pPropSheetPage->dwFlags |= PSP_USEFUSIONCONTEXT;
        }
#endif
    }
} // End namespace WiaUiUtil
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\unittest\clvtest\chklistv.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       CHKLISTV.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        11/13/2000
 *
 *  DESCRIPTION: Listview with checkmarks
 *
 *******************************************************************************/
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <simarray.h>
#include <psutil.h>
#include <wiadebug.h>
#include "chklistv.h"

CCheckedListviewHandler::CCheckedListviewHandler(void)
  : m_bFullImageHit(false),
    m_hImageList(NULL),
    m_nCheckedImageIndex(-1),
    m_nUncheckedImageIndex(-1)
{
    ZeroMemory(&m_sizeCheck,sizeof(m_sizeCheck));
    CreateDefaultCheckBitmaps();
}


CCheckedListviewHandler::~CCheckedListviewHandler(void)
{
    //
    // Free all allocated memory
    //
    DestroyImageList();
}

HBITMAP CCheckedListviewHandler::CreateBitmap( int nWidth, int nHeight )
{
    //
    // Create a 24bit RGB DIB section of a given size
    //
    HBITMAP hBitmap = NULL;
    HDC hDC = GetDC( NULL );
    if (hDC)
    {
        BITMAPINFO BitmapInfo = {0};
        BitmapInfo.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
        BitmapInfo.bmiHeader.biWidth = nWidth;
        BitmapInfo.bmiHeader.biHeight = nHeight;
        BitmapInfo.bmiHeader.biPlanes = 1;
        BitmapInfo.bmiHeader.biBitCount = 24;
        BitmapInfo.bmiHeader.biCompression = BI_RGB;

        PBYTE *pBits = NULL;
        hBitmap = CreateDIBSection( hDC, &BitmapInfo, DIB_RGB_COLORS, (void**)&pBits, NULL, 0 );
        ReleaseDC( NULL, hDC );
    }
    return hBitmap;
}

void CCheckedListviewHandler::DestroyImageList(void)
{
    //
    // Destroy the image list and initialize related variables
    //
    if (m_hImageList)
    {
        ImageList_Destroy( m_hImageList );
        m_hImageList = NULL;
    }
    m_nCheckedImageIndex = m_nUncheckedImageIndex = -1;
    m_sizeCheck.cx = m_sizeCheck.cy = 0;
}


bool CCheckedListviewHandler::ImagesValid(void)
{
    //
    // Make sure the images in the image list are valid
    //
    return (m_hImageList && m_nCheckedImageIndex >= 0 && m_nUncheckedImageIndex >= 0 && m_sizeCheck.cx && m_sizeCheck.cy);
}

void CCheckedListviewHandler::Attach( HWND hWnd )
{
    if (m_WindowList.Find(hWnd) < 0)
    {
        m_WindowList.Append(hWnd);
    }
}

void CCheckedListviewHandler::Detach( HWND hWnd )
{
    int nIndex = m_WindowList.Find(hWnd);
    if (nIndex >= 0)
    {
        m_WindowList.Delete( nIndex );
    }
}

bool CCheckedListviewHandler::WindowInList( HWND hWnd )
{
    return (m_WindowList.Find(hWnd) >= 0);
}

//
// Private helpers
//
BOOL CCheckedListviewHandler::InCheckBox( HWND hwndList, int nItem, const POINT &pt )
{
    BOOL bResult = FALSE;
    if (WindowInList(hwndList))
    {
#if defined(DBG)
        WIA_TRACE((TEXT("nItem: %d"), nItem ));
        LVHITTESTINFO LvHitTestInfo = {0};
        LvHitTestInfo.pt = pt;
        ListView_SubItemHitTest( hwndList, &LvHitTestInfo );
        WIA_TRACE((TEXT("LvHitTestInfo.iItem: %d"), LvHitTestInfo.iItem ));
#endif
        RECT rcItem = {0};
        if (ListView_GetItemRect( hwndList, nItem, &rcItem, LVIR_ICON ))
        {
            WIA_TRACE((TEXT("pt: (%d, %d)"), pt.x, pt.y ));
            WIA_TRACE((TEXT("rcItem: (%d, %d), (%d, %d)"), rcItem.left, rcItem.top, rcItem.right, rcItem.bottom ));
            rcItem.right -= c_sizeCheckMarginX;
            rcItem.top += c_sizeCheckMarginY;
            rcItem.left = rcItem.right - m_sizeCheck.cx;
            rcItem.bottom = rcItem.top + m_sizeCheck.cy;
            
            bResult = PtInRect( &rcItem, pt );
        }
    }
    return bResult;
}


UINT CCheckedListviewHandler::GetItemCheckState( HWND hwndList, int nIndex )
{
    UINT nResult = LVCHECKSTATE_NOCHECK;
    
    NMGETCHECKSTATE NmGetCheckState = {0};
    NmGetCheckState.hdr.hwndFrom = hwndList;
    NmGetCheckState.hdr.idFrom = GetWindowLong( hwndList, GWL_ID );
    NmGetCheckState.hdr.code = NM_GETCHECKSTATE;
    NmGetCheckState.nItem = nIndex;

    nResult = static_cast<UINT>(SendMessage( reinterpret_cast<HWND>(GetWindowLongPtr(hwndList,GWLP_HWNDPARENT)), WM_NOTIFY, GetWindowLong( hwndList, GWL_ID ), reinterpret_cast<LPARAM>(&NmGetCheckState) ) );
    return nResult;
}


UINT CCheckedListviewHandler::SetItemCheckState( HWND hwndList, int nIndex, UINT nCheck )
{
    UINT nResult = GetItemCheckState( hwndList, nIndex );
    
    NMSETCHECKSTATE NmSetCheckState = {0};
    NmSetCheckState.hdr.hwndFrom = hwndList;
    NmSetCheckState.hdr.idFrom = GetWindowLong( hwndList, GWL_ID );
    NmSetCheckState.hdr.code = NM_SETCHECKSTATE;
    NmSetCheckState.nItem = nIndex;
    NmSetCheckState.nCheck = nCheck;

    SendMessage( reinterpret_cast<HWND>(GetWindowLongPtr(hwndList,GWLP_HWNDPARENT)), WM_NOTIFY, GetWindowLong( hwndList, GWL_ID ), reinterpret_cast<LPARAM>(&NmSetCheckState) );
    return nResult;
}


int CCheckedListviewHandler::GetItemCheckBitmap( HWND hwndList, int nIndex )
{
    int nResult = -1;
    if (WindowInList(hwndList))
    {
        UINT nCheck = GetItemCheckState( hwndList, nIndex );
        switch (nCheck)
        {
        case LVCHECKSTATE_CHECKED:
            nResult = m_nCheckedImageIndex;
            break;

        case LVCHECKSTATE_UNCHECKED:
            nResult = m_nUncheckedImageIndex;
            break;
        }
    }
    return nResult;
}


BOOL CCheckedListviewHandler::RealHandleListClick( WPARAM wParam, LPARAM lParam, bool bIgnoreHitArea )
{
    BOOL bResult = FALSE;
    NMITEMACTIVATE *pNmItemActivate = reinterpret_cast<NMITEMACTIVATE*>(lParam);
    if (pNmItemActivate)
    {
        if (WindowInList(pNmItemActivate->hdr.hwndFrom))
        {
            if (bIgnoreHitArea || InCheckBox(pNmItemActivate->hdr.hwndFrom,pNmItemActivate->iItem,pNmItemActivate->ptAction))
            {
                UINT nCheck = GetItemCheckState( pNmItemActivate->hdr.hwndFrom, pNmItemActivate->iItem );
                switch (nCheck)
                {
                case LVCHECKSTATE_UNCHECKED:
                    SetItemCheckState( pNmItemActivate->hdr.hwndFrom, pNmItemActivate->iItem, LVCHECKSTATE_CHECKED );
                    break;

                case LVCHECKSTATE_CHECKED:
                    SetItemCheckState( pNmItemActivate->hdr.hwndFrom, pNmItemActivate->iItem, LVCHECKSTATE_UNCHECKED );
                    break;
                }
            }
            bResult = TRUE;
        }
    }
    return 0;
}


//
// Message handlers
//
BOOL CCheckedListviewHandler::HandleListClick( WPARAM wParam, LPARAM lParam )
{
    return RealHandleListClick( wParam, lParam, m_bFullImageHit );
}

BOOL CCheckedListviewHandler::HandleListDblClk( WPARAM wParam, LPARAM lParam )
{
    return RealHandleListClick( wParam, lParam, true );
}

BOOL CCheckedListviewHandler::HandleListKeyDown( WPARAM wParam, LPARAM lParam, LRESULT &lResult )
{
    BOOL bHandled = FALSE;
    NMLVKEYDOWN *pNmLvKeyDown = reinterpret_cast<NMLVKEYDOWN*>(lParam);
    if (WindowInList(pNmLvKeyDown->hdr.hwndFrom))
    {
        lResult = 0;
        bool bControl = (GetKeyState(VK_CONTROL) & 0x8000) != 0;
        bool bShift = (GetKeyState(VK_SHIFT) & 0x8000) != 0;
        bool bAlt = (GetKeyState(VK_MENU) & 0x8000) != 0;
        if (pNmLvKeyDown->wVKey == VK_SPACE && !bControl && !bShift && !bAlt)
        {
            int nFocusedItem = ListView_GetNextItem( pNmLvKeyDown->hdr.hwndFrom, -1, LVNI_FOCUSED );
            if (nFocusedItem >= 0)
            {
                UINT nCheckState = GetItemCheckState( pNmLvKeyDown->hdr.hwndFrom, nFocusedItem );
                if (LVCHECKSTATE_CHECKED == nCheckState)
                {
                    nCheckState = LVCHECKSTATE_UNCHECKED;
                }
                else if (LVCHECKSTATE_UNCHECKED == nCheckState)
                {
                    nCheckState = LVCHECKSTATE_CHECKED;
                }
                if (nCheckState != LVCHECKSTATE_NOCHECK)
                {
                    int nCurrItem = -1;
                    while (true)
                    {
                        nCurrItem = ListView_GetNextItem( pNmLvKeyDown->hdr.hwndFrom, nCurrItem, LVNI_SELECTED );
                        if (nCurrItem < 0)
                        {
                            break;
                        }
                        SetItemCheckState( pNmLvKeyDown->hdr.hwndFrom, nCurrItem, nCheckState );
                    }
                }
            }
            lResult = TRUE;
            bHandled = TRUE;
            InvalidateRect( pNmLvKeyDown->hdr.hwndFrom, NULL, FALSE );
            UpdateWindow( pNmLvKeyDown->hdr.hwndFrom );
        }
    }
    return bHandled;
}


BOOL CCheckedListviewHandler::HandleListCustomDraw( WPARAM wParam, LPARAM lParam, LRESULT &lResult )
{
    BOOL bHandled = FALSE; 
    NMLVCUSTOMDRAW *pNmCustomDraw = reinterpret_cast<NMLVCUSTOMDRAW*>(lParam);
    if (pNmCustomDraw)
    {
        if (WindowInList(pNmCustomDraw->nmcd.hdr.hwndFrom))
        {
            lResult = CDRF_DODEFAULT;
#if defined(DUMP_NM_CUSTOMDRAW_MESSAGES)
            DumpCustomDraw(lParam,TEXT("SysListView32"),CDDS_ITEMPOSTPAINT);
#endif
            if (CDDS_PREPAINT == pNmCustomDraw->nmcd.dwDrawStage)
            {
                lResult = CDRF_NOTIFYITEMDRAW;
            }
            else if (CDDS_ITEMPREPAINT == pNmCustomDraw->nmcd.dwDrawStage)
            {
                lResult = CDRF_NOTIFYPOSTPAINT|CDRF_NOTIFYSUBITEMDRAW;
            }
            else if (CDDS_ITEMPOSTPAINT == pNmCustomDraw->nmcd.dwDrawStage)
            {
                int nImageListIndex = GetItemCheckBitmap( pNmCustomDraw->nmcd.hdr.hwndFrom, static_cast<int>(pNmCustomDraw->nmcd.dwItemSpec) );
                if (nImageListIndex >= 0)
                {
                    RECT rcItem = {0};
                    if (ListView_GetItemRect( pNmCustomDraw->nmcd.hdr.hwndFrom, pNmCustomDraw->nmcd.dwItemSpec, &rcItem, LVIR_ICON ))
                    {
                        ImageList_Draw( m_hImageList, nImageListIndex, pNmCustomDraw->nmcd.hdc, rcItem.right - m_sizeCheck.cx - c_sizeCheckMarginX, rcItem.top + c_sizeCheckMarginY, ILD_NORMAL );
                        lResult = CDRF_SKIPDEFAULT;
                    }
                }
            }
            bHandled = TRUE;
        }
    }
    return bHandled;
}

void CCheckedListviewHandler::Select( HWND hwndList, int nIndex, UINT nSelect )
{
    if (WindowInList(hwndList))
    {
        //
        // -1 means all images
        //
        if (nIndex < 0)
        {
            for (int i=0;i<ListView_GetItemCount(hwndList);i++)
            {
                SetItemCheckState(hwndList,i,nSelect);
            }
        }
        else
        {
            SetItemCheckState(hwndList,nIndex,nSelect);
        }
    }
}


bool CCheckedListviewHandler::FullImageHit(void) const
{
    return m_bFullImageHit;
}

void CCheckedListviewHandler::FullImageHit( bool bFullImageHit )
{
    m_bFullImageHit = bFullImageHit;
}


bool CCheckedListviewHandler::CreateDefaultCheckBitmaps(void)
{
    bool bResult = false;
    
    //
    // Get the proper size for the checkmarks
    //
    int nWidth = GetSystemMetrics( SM_CXMENUCHECK );
    int nHeight = GetSystemMetrics( SM_CXMENUCHECK );

    //
    // Make sure they are valid sizes
    //
    if (nWidth && nHeight)
    {
        //
        // Create the bitmaps and make sure they are valid
        //
        HBITMAP hBitmapChecked = CreateBitmap( nWidth+c_nCheckmarkBorder*2, nHeight+c_nCheckmarkBorder*2 );
        HBITMAP hBitmapUnchecked = CreateBitmap( nWidth+c_nCheckmarkBorder*2, nHeight+c_nCheckmarkBorder*2 );
        if (hBitmapChecked && hBitmapUnchecked)
        {
            //
            // Get the desktop DC
            //
            HDC hDC = GetDC( NULL );
            if (hDC)
            {
                //
                // Create a memory DC
                //
                HDC hMemDC = CreateCompatibleDC( hDC );
                if (hMemDC)
                {
                    //
                    // This is the rect that contains the image + the margin
                    //
                    RECT rcEntireBitmap = {0,0,nWidth+c_nCheckmarkBorder*2, nHeight+c_nCheckmarkBorder*2};
                    
                    //
                    // This is the rect that contains only the image
                    //
                    RECT rcControlBitmap = {c_nCheckmarkBorder,c_nCheckmarkBorder,nWidth+c_nCheckmarkBorder, nHeight+c_nCheckmarkBorder};
                    
                    //
                    // Paint the checked bitmap
                    //
                    HBITMAP hOldBitmap = SelectBitmap( hMemDC, hBitmapChecked );
                    FillRect( hMemDC, &rcEntireBitmap, GetSysColorBrush( COLOR_WINDOW ) );
                    DrawFrameControl( hMemDC, &rcControlBitmap, DFC_BUTTON, DFCS_BUTTONCHECK|DFCS_CHECKED|DFCS_FLAT );

                    //
                    // Paint the unchecked bitmap
                    //
                    SelectBitmap( hMemDC, hBitmapUnchecked );
                    FillRect( hMemDC, &rcEntireBitmap, GetSysColorBrush( COLOR_WINDOW ) );
                    DrawFrameControl( hMemDC, &rcControlBitmap, DFC_BUTTON, DFCS_BUTTONCHECK|DFCS_FLAT );

                    //
                    // Restore and delete the memory DC
                    //
                    SelectBitmap( hMemDC, hOldBitmap );
                    DeleteDC( hMemDC );

                    //
                    // Save the images
                    //
                    bResult = SetCheckboxImages( hBitmapChecked, hBitmapUnchecked );

                    //
                    // The images are in the image list now, so discard them
                    //
                    DeleteBitmap(hBitmapChecked);
                    DeleteBitmap(hBitmapUnchecked);
                }
                ReleaseDC( NULL, hDC );
            }
        }
    }
    return bResult;
}


bool CCheckedListviewHandler::SetCheckboxImages( HBITMAP hChecked, HBITMAP hUnchecked )
{
    DestroyImageList();

    //
    // Find out the size of the bitmaps and make sure they are the same.
    //
    SIZE sizeChecked = {0};
    if (PrintScanUtil::GetBitmapSize( hChecked, sizeChecked ))
    {
        SIZE sizeUnchecked = {0};
        if (PrintScanUtil::GetBitmapSize( hUnchecked, sizeUnchecked ))
        {
            if (sizeChecked.cx == sizeUnchecked.cx && sizeChecked.cy == sizeUnchecked.cy)
            {
                //
                // Save the size
                //
                m_sizeCheck.cx = sizeChecked.cx;
                m_sizeCheck.cy = sizeChecked.cy;
                
                //
                // Create the image list to hold the checkboxes
                //
                m_hImageList = ImageList_Create( m_sizeCheck.cx, m_sizeCheck.cy, ILC_COLOR24, 2, 2 );
                if (m_hImageList)
                {
                    //
                    // Save the indices of the images
                    //
                    m_nCheckedImageIndex = ImageList_Add( m_hImageList, hChecked, NULL );
                    m_nUncheckedImageIndex = ImageList_Add( m_hImageList, hUnchecked, NULL );
                }
            }
        }
    }
    
    //
    // If the images aren't valid, clean up
    //
    bool bResult = ImagesValid();
    if (!bResult)
    {
        DestroyImageList();
    }
    return bResult;
}

bool CCheckedListviewHandler::SetCheckboxImages( HICON hChecked, HICON hUnchecked )
{
    DestroyImageList();

    //
    // Find out the size of the icons and make sure they are the same.
    //
    SIZE sizeChecked = {0};
    if (PrintScanUtil::GetIconSize( hChecked, sizeChecked ))
    {
        SIZE sizeUnchecked = {0};
        if (PrintScanUtil::GetIconSize( hUnchecked, sizeUnchecked ))
        {
            if (sizeChecked.cx == sizeUnchecked.cx && sizeChecked.cy == sizeUnchecked.cy)
            {
                //
                // Save the size
                //
                m_sizeCheck.cx = sizeChecked.cx;
                m_sizeCheck.cy = sizeChecked.cy;

                //
                // Create the image list to hold the checkboxes
                //
                m_hImageList = ImageList_Create( m_sizeCheck.cx, m_sizeCheck.cy, ILC_COLOR24|ILC_MASK, 2, 2 );
                if (m_hImageList)
                {
                    //
                    // Save the indices of the images
                    //
                    m_nCheckedImageIndex = ImageList_AddIcon( m_hImageList, hChecked );
                    m_nUncheckedImageIndex = ImageList_AddIcon( m_hImageList, hUnchecked );
                }
            }
        }
    }
    
    //
    // If the images aren't valid, clean up
    //
    bool bResult = ImagesValid();
    if (!bResult)
    {
        DestroyImageList();
    }
    return bResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\uicommon\wiatextc.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       WIATEXTC.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        7/30/1999
 *
 *  DESCRIPTION: Highlighted static control.  Like a static, but acts like a
 *               hyperlink
 *
 *
 * Use the following values in the dialog resource editor to put it in a dialog:
 *
 *     Style:
 *        Hyperlink:  0x50010000     (WS_CHILD|WS_VISIBLE|WS_TABSTOP)
 *        IconStatic: 0x50010008     (WS_CHILD|WS_VISIBLE|0x00000008)
 *     Class:   WiaTextControl
 *     ExStyle: 0x00000000
 *
 * Register before use using:
 *     CWiaTextControl::RegisterClass(g_hInstance);
 *
 *******************************************************************************/

#ifndef __WIATEXTC_H_INCLUDED
#define __WIATEXTC_H_INCLUDED

#include <windows.h>
#include <windowsx.h>
#include "simcrack.h"
#include "miscutil.h"

#define WIATEXT_STATIC_CLASSNAMEW L"WiaTextControl"
#define WIATEXT_STATIC_CLASSNAMEA  "WiaTextControl"

#ifdef UNICODE
#define WIATEXT_STATIC_CLASSNAME  WIATEXT_STATIC_CLASSNAMEW
#else
#define WIATEXT_STATIC_CLASSNAME  WIATEXT_STATIC_CLASSNAMEA
#endif

// Styles
#define WTS_SINGLELINE   0x00000001 // Single line
#define WTS_PATHELLIPSIS 0x00000002 // Use to truncate string in the middle
#define WTS_ENDELLIPSIS  0x00000004 // Use to truncate string at the end
#define WTS_ICONSTATIC   0x00000008 // Static control with an icon
#define WTS_RIGHT        0x00000010 // Right aligned

// Undefined in VC6 SDK
#ifndef COLOR_HOTLIGHT
#define COLOR_HOTLIGHT 26
#endif

// Undefined in VC6 SDK
#ifndef IDC_HAND
#define IDC_HAND MAKEINTRESOURCE(32649)
#endif

#define DEFAULT_ICON_STATIC_BACKGROUND_COLOR GetSysColor(COLOR_3DFACE)
#define DEFAULT_ICON_STATIC_FOREGROUND_COLOR GetSysColor(COLOR_WINDOWTEXT)

#define WM_WIA_STATIC_SETICON (WM_USER+1)

class CWiaTextControl
{
private:
    enum
    {
        StateNormal   = 0,
        StateHover    = 1,
        StateFocus    = 2,
        StateDisabled = 4
    };

    // Timer IDs
    enum
    {
        IDT_MOUSEPOS = 1
    };

    enum
    {
        IconMargin = 0
    };

private:
    HWND         m_hWnd;
    COLORREF     m_crColorNormal;
    COLORREF     m_crColorHover;
    COLORREF     m_crColorFocus;
    COLORREF     m_crColorDisabled;
    COLORREF     m_crForegroundColor;
    RECT         m_rcTextWidth;
    HFONT        m_hFont;
    int          m_CurrentState;
    RECT         m_rcHighlight;
    HCURSOR      m_hHandCursor;
    HBITMAP      m_hBitmap;
    SIZE         m_sizeWindow;
    bool         m_bIconStaticMode;
    HBRUSH       m_hBackgroundBrush;
    HICON        m_hIcon;

private:
    CWiaTextControl(void);
    CWiaTextControl( const CWiaTextControl & );
    CWiaTextControl &operator=( const CWiaTextControl & );

private:
    CWiaTextControl( HWND hWnd )
    : m_hWnd(hWnd),
      m_crColorNormal(GetSysColor(COLOR_HOTLIGHT)),
      m_crColorHover(RGB(255,0,0)),
      m_crColorFocus(GetSysColor(COLOR_HOTLIGHT)),
      m_crColorDisabled(GetSysColor(COLOR_GRAYTEXT)),
      m_crForegroundColor(DEFAULT_ICON_STATIC_FOREGROUND_COLOR),
      m_hFont(NULL),
      m_hHandCursor(NULL),
      m_hBitmap(NULL),
      m_hBackgroundBrush(NULL),
      m_hIcon(NULL),
      m_CurrentState(StateNormal),
      m_bIconStaticMode(false)
    {
        CreateNewFont(reinterpret_cast<HFONT>(GetStockObject(SYSTEM_FONT)));
    }
    ~CWiaTextControl(void)
    {
        m_hWnd = NULL;
        if (m_hIcon)
        {
            DestroyIcon(m_hIcon);
            m_hIcon = NULL;
        }
        if (m_hHandCursor)
        {
            m_hHandCursor = NULL;
        }
        if (m_hFont)
        {
            DeleteObject(m_hFont);
            m_hFont = NULL;
        }
        if (m_hBitmap)
        {
            DeleteObject(m_hBitmap);
            m_hBitmap = NULL;
        }
        if (m_hBackgroundBrush)
        {
            DeleteObject(m_hBackgroundBrush);
            m_hBackgroundBrush = NULL;
        }
    }

    COLORREF GetCurrentColor(void)
    {
        if (StateDisabled & m_CurrentState)
            return m_crColorDisabled;
        if (StateHover & m_CurrentState)
            return m_crColorHover;
        if (StateFocus & m_CurrentState)
            return m_crColorFocus;
        else return m_crColorNormal;
    }
    void CreateNewFont( HFONT hFont )
    {
        if (m_hFont)
        {
            DeleteObject(m_hFont);
            m_hFont = NULL;
        }
        if (hFont)
        {
            LOGFONT lf;
            if (GetObject( hFont, sizeof(LOGFONT), &lf ))
            {
                lf.lfUnderline = TRUE;
                m_hFont = CreateFontIndirect( &lf );
            }
        }
    }

private:
    LRESULT OnEraseBkgnd( WPARAM wParam, LPARAM lParam )
    {
        RedrawBitmap(false);
        return TRUE;
    }

    LRESULT OnSetIcon( WPARAM, LPARAM lParam )
    {
        if (m_hIcon)
        {
            DestroyIcon(m_hIcon);
            m_hIcon = NULL;
        }
        m_hIcon = reinterpret_cast<HICON>(lParam);
        RedrawBitmap(true);
        return 0;
    }

    LRESULT OnSetFocus( WPARAM, LPARAM )
    {
        m_CurrentState |= StateFocus;
        RedrawBitmap(true);
        return 0;
    }

    LRESULT OnKillFocus( WPARAM, LPARAM )
    {
        m_CurrentState &= ~StateFocus;
        RedrawBitmap(true);
        return 0;
    }

    void DrawHyperlinkControl( HDC hDC )
    {
        RECT rcClient;
        GetClientRect(m_hWnd,&rcClient);


        // Make sure we start with a fresh rect
        ZeroMemory( &m_rcHighlight, sizeof(m_rcHighlight) );
        HBRUSH hbrBackground = NULL;

        HWND hWndParent = GetParent(m_hWnd);
        if (hWndParent)
            hbrBackground = reinterpret_cast<HBRUSH>(SendMessage(hWndParent,WM_CTLCOLORSTATIC,reinterpret_cast<WPARAM>(hDC),reinterpret_cast<LPARAM>(m_hWnd)));

        if (!hbrBackground)
            hbrBackground = reinterpret_cast<HBRUSH>(GetSysColorBrush(COLOR_WINDOW));

        FillRect( hDC, &rcClient, hbrBackground );

        LRESULT nWindowTextLength = SendMessage(m_hWnd,WM_GETTEXTLENGTH,0,0);

        LPTSTR pszWindowText = new TCHAR[nWindowTextLength+1];
        if (pszWindowText)
        {
            if (SendMessage( m_hWnd, WM_GETTEXT, nWindowTextLength+1, reinterpret_cast<LPARAM>(pszWindowText) ) )
            {
                int nDrawTextFlags = DT_WORDBREAK|DT_TOP|DT_NOPREFIX;

                INT_PTR nStyle = GetWindowLongPtr( m_hWnd, GWL_STYLE );
                if (nStyle & WTS_SINGLELINE)
                    nDrawTextFlags |= DT_SINGLELINE;

                if (nStyle & WTS_RIGHT)
                    nDrawTextFlags |= DT_RIGHT;
                else nDrawTextFlags |= DT_LEFT;

                if (nStyle & WTS_PATHELLIPSIS)
                    nDrawTextFlags |= DT_PATH_ELLIPSIS | DT_SINGLELINE;

                if (nStyle & WTS_ENDELLIPSIS)
                    nDrawTextFlags |= DT_END_ELLIPSIS | DT_SINGLELINE;

                m_rcHighlight = rcClient;

                int nOldBkMode = SetBkMode( hDC, TRANSPARENT );
                HFONT hOldFont = NULL;
                if (m_hFont)
                   hOldFont = reinterpret_cast<HFONT>(SelectObject( hDC, m_hFont ));
                COLORREF crOldColor = SetTextColor( hDC, GetCurrentColor() );

                InflateRect(&m_rcHighlight,-1,-1);
                DrawTextEx( hDC, pszWindowText, -1, &m_rcHighlight, nDrawTextFlags, NULL );

                SetTextColor( hDC, crOldColor );
                SetBkMode( hDC, nOldBkMode );

                DrawTextEx( hDC, pszWindowText, -1, &m_rcHighlight, DT_CALCRECT|nDrawTextFlags , NULL );
                InflateRect(&m_rcHighlight,1,1);

                if (nStyle & WTS_RIGHT)
                {
                    m_rcHighlight.left = rcClient.right - WiaUiUtil::Min<int>(rcClient.right,m_rcHighlight.right);
                    m_rcHighlight.right = rcClient.right;
                    m_rcHighlight.bottom = WiaUiUtil::Min<int>(rcClient.bottom,m_rcHighlight.bottom);
                }
                else
                {
                    m_rcHighlight.right = WiaUiUtil::Min<int>(rcClient.right,m_rcHighlight.right);
                    m_rcHighlight.bottom = WiaUiUtil::Min<int>(rcClient.bottom,m_rcHighlight.bottom);
                }

                if (m_CurrentState & StateFocus)
                    DrawFocusRect( hDC, &m_rcHighlight );

                if (m_hFont)
                    SelectObject( hDC, hOldFont );
            }
            delete[] pszWindowText;
        }
    }

    void DrawIconStatic( HDC hDC )
    {
        RECT rcClient;
        GetClientRect( m_hWnd, &rcClient );

        FrameRect( hDC, &rcClient, GetSysColorBrush( COLOR_WINDOWFRAME ) );

        InflateRect( &rcClient, -1, -1 );
        FillRect( hDC, &rcClient, m_hBackgroundBrush );
        InflateRect( &rcClient, -1, -1 );

        CSimpleString str;
        str.GetWindowText(m_hWnd);
        if (str.Length())
        {
            int nDrawTextFlags = DT_WORDBREAK|DT_TOP|DT_LEFT|DT_NOPREFIX;

            INT_PTR nStyle = GetWindowLongPtr( m_hWnd, GWL_STYLE );
            if (nStyle & WTS_SINGLELINE)
                nDrawTextFlags |= DT_SINGLELINE | DT_VCENTER;

            if (nStyle & WTS_PATHELLIPSIS)
                nDrawTextFlags |= DT_PATH_ELLIPSIS | DT_SINGLELINE;

            if (nStyle & WTS_ENDELLIPSIS)
                nDrawTextFlags |= DT_END_ELLIPSIS | DT_SINGLELINE;

            if (m_hIcon)
            {
                int nIconMargin;
                // Center the icon vertically
                if (nStyle & WTS_SINGLELINE)
                {
                    nIconMargin = (WiaUiUtil::RectHeight(rcClient) - GetSystemMetrics(SM_CYSMICON)) / 2;
                }
                else
                {
                    nIconMargin = IconMargin;
                }
                DrawIconEx( hDC, rcClient.left+nIconMargin, rcClient.top+nIconMargin, m_hIcon, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), 0, NULL, DI_NORMAL );
                rcClient.left += rcClient.left + GetSystemMetrics(SM_CXSMICON) + nIconMargin*2;
            }

            int nOldBkMode = SetBkMode( hDC, TRANSPARENT );
            HFONT hOldFont = NULL, hFont = (HFONT)SendMessage( m_hWnd, WM_GETFONT, 0, 0 );
            if (!hFont)
                hFont = (HFONT)SendMessage( GetParent(m_hWnd), WM_GETFONT, 0, 0 );
            if (hFont)
                hOldFont = SelectFont( hDC, hFont );

            COLORREF crOldColor = SetTextColor( hDC, m_crForegroundColor );
            DrawTextEx( hDC, const_cast<LPTSTR>(str.String()), str.Length(), &rcClient, nDrawTextFlags, NULL );
            SetTextColor( hDC, crOldColor );
            if (hOldFont)
                SelectFont( hDC, hOldFont );
            SetBkMode( hDC, nOldBkMode );
        }
    }

    void RedrawBitmap( bool bRedraw )
    {
        if (m_hBitmap)
        {
            HDC hDC = GetDC(m_hWnd);
            if (hDC)
            {
                HDC hMemDC = CreateCompatibleDC(hDC);
                if (hMemDC)
                {
                    HBITMAP hOldBitmap = SelectBitmap( hMemDC, m_hBitmap );

                    if (!m_bIconStaticMode)
                        DrawHyperlinkControl( hMemDC );
                    else DrawIconStatic( hMemDC );
                    SelectBitmap( hMemDC, hOldBitmap );
                    DeleteDC(hMemDC);
                }
                ReleaseDC(m_hWnd, hDC);
            }
        }
        if (bRedraw)
        {
            InvalidateRect( m_hWnd, NULL, FALSE );
            UpdateWindow( m_hWnd );
        }
    }
    void CheckMousePos(void)
    {
        POINT pt;
        GetCursorPos(&pt);
        MapWindowPoints( NULL, m_hWnd, &pt, 1 );
        if (PtInRect( &m_rcHighlight, pt ))
        {
            if ((m_CurrentState & StateHover)==0)
            {
                m_CurrentState |= StateHover;
                RedrawBitmap(true);
            }
        }
        else
        {
            if (m_CurrentState & StateHover)
            {
                m_CurrentState &= ~StateHover;
                RedrawBitmap(true);
            }
        }
    }

    LRESULT OnTimer( WPARAM wParam, LPARAM lParam )
    {
        if (wParam == IDT_MOUSEPOS)
        {
            CheckMousePos();
            return 0;
        }
        return DefWindowProc( m_hWnd, WM_TIMER, wParam, lParam );
    }

    LRESULT OnMove( WPARAM wParam, LPARAM lParam )
    {
        CheckMousePos();
        return 0;
    }

    LRESULT OnSize( WPARAM wParam, LPARAM lParam )
    {
        if (SIZE_RESTORED == wParam || SIZE_MAXIMIZED == wParam)
        {
            if (m_hBitmap)
            {
                DeleteBitmap(m_hBitmap);
                m_hBitmap = NULL;
            }
            HDC hDC = GetDC(m_hWnd);
            if (hDC)
            {
                m_sizeWindow.cx = LOWORD(lParam);
                m_sizeWindow.cy = HIWORD(lParam);
                m_hBitmap = CreateCompatibleBitmap( hDC, LOWORD(lParam), HIWORD(lParam) );
                ReleaseDC(m_hWnd,hDC);
            }
        }
        RedrawBitmap(true);
        CheckMousePos();
        return 0;
    }

    LRESULT OnCreate( WPARAM, LPARAM )
    {
        if (!IsWindowEnabled(m_hWnd))
            m_CurrentState |= StateDisabled;
        INT_PTR nStyle = GetWindowLongPtr( m_hWnd, GWL_STYLE );
        if (nStyle & WTS_ICONSTATIC)
            m_bIconStaticMode = true;

        SetTimer( m_hWnd, IDT_MOUSEPOS, 56, NULL );

        m_hHandCursor = LoadCursor( NULL, IDC_HAND );

        m_hBackgroundBrush = CreateSolidBrush(DEFAULT_ICON_STATIC_BACKGROUND_COLOR);

        return 0;
    }

    LRESULT OnSetFont( WPARAM wParam, LPARAM lParam )
    {
        LRESULT lRes = DefWindowProc( m_hWnd, WM_SETFONT, wParam, lParam );
        CreateNewFont(reinterpret_cast<HFONT>(wParam));
        RedrawBitmap(LOWORD(lParam) != 0);
        return lRes;
    }

    LRESULT OnSetText( WPARAM wParam, LPARAM lParam )
    {
        LRESULT lRes = DefWindowProc( m_hWnd, WM_SETTEXT, wParam, lParam );
        RedrawBitmap(true);
        return lRes;
    }

    LRESULT OnGetDlgCode( WPARAM, LPARAM )
    {
        if (!m_bIconStaticMode)
            return DLGC_BUTTON;
        return  DLGC_STATIC;
    }

    void FireNotification( int nCode )
    {
        HWND hwndParent = GetParent(m_hWnd);
        if (hwndParent)
        {
            SendNotifyMessage( hwndParent, WM_COMMAND, MAKEWPARAM(GetWindowLongPtr(m_hWnd,GWLP_ID),nCode), reinterpret_cast<LPARAM>(m_hWnd) );
        }
    }

    LRESULT OnKeyDown( WPARAM wParam, LPARAM lParam )
    {
        if (!m_bIconStaticMode)
        {
            if (wParam == VK_SPACE)
                FireNotification(BN_CLICKED);
            else if (wParam == VK_RETURN)
                FireNotification(BN_CLICKED);
        }
        return 0;
    }

    LRESULT OnNcHitTest( WPARAM, LPARAM lParam )
    {
        if (!m_bIconStaticMode)
        {
            POINT pt = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
            MapWindowPoints( NULL, m_hWnd, &pt, 1 );
            if (PtInRect( &m_rcHighlight, pt ))
            {
                return HTCLIENT;
            }
        }
        return HTTRANSPARENT;
    }

    LRESULT OnEnable( WPARAM wParam, LPARAM lParam )
    {
        if (wParam)
        {
            m_CurrentState &= ~StateDisabled;
        }
        else
        {
            m_CurrentState |= StateDisabled;
        }
        RedrawBitmap(true);
        return 0;
    }

    LRESULT OnLButtonDown( WPARAM wParam, LPARAM lParam )
    {
        if (!m_bIconStaticMode)
        {
            POINT pt = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
            if (PtInRect(&m_rcHighlight,pt))
            {
                SetFocus(m_hWnd);
                SetCapture(m_hWnd);
            }
        }
        return 0;
    }

    LRESULT OnLButtonUp( WPARAM wParam, LPARAM lParam )
    {
        if (!m_bIconStaticMode)
        {
            if (GetCapture() == m_hWnd)
            {
                ReleaseCapture();
                POINT pt = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
                if (PtInRect(&m_rcHighlight,pt))
                {
                    FireNotification(BN_CLICKED);
                }
            }
        }
        return 0;
    }

    LRESULT OnSetCursor( WPARAM wParam, LPARAM lParam )
    {
        if (!m_bIconStaticMode)
        {
            POINT pt;
            GetCursorPos(&pt);
            MapWindowPoints( NULL, m_hWnd, &pt, 1 );
            if (PtInRect( &m_rcHighlight, pt ))
            {
                SetCursor( m_hHandCursor );
                return 0;
            }
        }
        return DefWindowProc( m_hWnd, WM_SETCURSOR, wParam, lParam );
    }

    LRESULT OnStyleChanged( WPARAM wParam, LPARAM lParam )
    {
        RedrawBitmap(true);
        return 0;
    }

    LRESULT OnSysColorChange( WPARAM wParam, LPARAM lParam )
    {
        m_crColorNormal = GetSysColor(COLOR_HOTLIGHT);
        m_crColorHover = RGB(255,0,0);
        m_crColorFocus = GetSysColor(COLOR_HOTLIGHT);
        m_crColorDisabled = GetSysColor(COLOR_GRAYTEXT);
        RedrawBitmap(true);
        return 0;
    }

    LRESULT OnPaint( WPARAM wParam, LPARAM lParam )
    {
        PAINTSTRUCT ps;
        HDC hDC = BeginPaint( m_hWnd, &ps );
        if (hDC)
        {
            if (ps.fErase)
            {
                RedrawBitmap(false);
            }
            if (m_hBitmap)
            {
                HDC hMemDC = CreateCompatibleDC(hDC);
                if (hMemDC)
                {
                    HBITMAP hOldBitmap = SelectBitmap(hMemDC,m_hBitmap);
                    BitBlt( hDC, ps.rcPaint.left, ps.rcPaint.top, ps.rcPaint.right-ps.rcPaint.left, ps.rcPaint.bottom-ps.rcPaint.top, hMemDC, ps.rcPaint.left, ps.rcPaint.top, SRCCOPY );
                    SelectBitmap(hMemDC,hOldBitmap);
                    DeleteDC(hMemDC);
                }
            }
            EndPaint( m_hWnd, &ps );
        }
        return 0;
    }


public:
    static LRESULT CALLBACK WndProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
    {
        SC_BEGIN_MESSAGE_HANDLERS(CWiaTextControl)
        {
            SC_HANDLE_MESSAGE( WM_CREATE, OnCreate );
            SC_HANDLE_MESSAGE( WM_SETFONT, OnSetFont );
            SC_HANDLE_MESSAGE( WM_PAINT, OnPaint );
            SC_HANDLE_MESSAGE( WM_SETFOCUS, OnSetFocus );
            SC_HANDLE_MESSAGE( WM_KILLFOCUS, OnKillFocus );
            SC_HANDLE_MESSAGE( WM_SETTEXT, OnSetText );
            SC_HANDLE_MESSAGE( WM_GETDLGCODE, OnGetDlgCode );
            SC_HANDLE_MESSAGE( WM_ERASEBKGND, OnEraseBkgnd );
            SC_HANDLE_MESSAGE( WM_TIMER, OnTimer );
            SC_HANDLE_MESSAGE( WM_SIZE, OnSize );
            SC_HANDLE_MESSAGE( WM_MOVE, OnMove );
            SC_HANDLE_MESSAGE( WM_KEYDOWN, OnKeyDown );
            SC_HANDLE_MESSAGE( WM_LBUTTONDOWN, OnLButtonDown );
            SC_HANDLE_MESSAGE( WM_LBUTTONUP, OnLButtonUp );
            SC_HANDLE_MESSAGE( WM_SETCURSOR, OnSetCursor );
            SC_HANDLE_MESSAGE( WM_ENABLE, OnEnable );
            SC_HANDLE_MESSAGE( WM_NCHITTEST, OnNcHitTest );
            SC_HANDLE_MESSAGE( WM_STYLECHANGED, OnStyleChanged );
            SC_HANDLE_MESSAGE( WM_SYSCOLORCHANGE, OnSysColorChange );
            SC_HANDLE_MESSAGE( WM_WIA_STATIC_SETICON, OnSetIcon );
        }
        SC_END_MESSAGE_HANDLERS();
    }
    static BOOL RegisterClass( HINSTANCE hInstance )
    {
        WNDCLASSEX wcex;
        ZeroMemory(&wcex,sizeof(wcex));
        wcex.cbSize = sizeof(wcex);
        wcex.style = CS_DBLCLKS;
        wcex.lpfnWndProc = WndProc;
        wcex.hInstance = hInstance;
        wcex.lpszClassName = WIATEXT_STATIC_CLASSNAME;
        return ::RegisterClassEx( &wcex );
    }
};

#endif //__WIATEXTC_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\unittest\clvtest\chklistv.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       CHKLISTV.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        11/13/2000
 *
 *  DESCRIPTION: Listview with checkmarks
 *
 *******************************************************************************/
#ifndef __CHKLISTV_H_INCLUDED
#define __CHKLISTV_H_INCLUDED

#include <windows.h>
#include <commctrl.h>
#include <simarray.h>

//
// The WM_NOTIFY messages are sent to get and set the check state, which is maintained by the application
//
#define NM_GETCHECKSTATE (WM_USER+1)
#define NM_SETCHECKSTATE (WM_USER+2)

//
// These are the valid check states
//
#define LVCHECKSTATE_NOCHECK    0
#define LVCHECKSTATE_UNCHECKED  1
#define LVCHECKSTATE_CHECKED    2

//
// These are the WM_NOTIFY structs sent with NM_SETCHECKSTATE and NM_GETCHECKSTATE
//
struct NMGETCHECKSTATE
{
    NMHDR  hdr;
    int    nItem;
};

struct NMSETCHECKSTATE
{
    NMHDR  hdr;
    int    nItem;
    UINT   nCheck;
};


class CCheckedListviewHandler
{
private:
    
    //
    // Private constants
    //
    enum
    {
        c_nCheckmarkBorder = 1,
        c_sizeCheckMarginX = 5,
        c_sizeCheckMarginY = 5
    };

private:
    CSimpleDynamicArray<HWND> m_WindowList;            // The list of windows we are registered to handle
    bool                      m_bFullImageHit;         // If 'true', activating the image toggles the selection
    HIMAGELIST                m_hImageList;            // Image list for holding the checkmarks
    int                       m_nCheckedImageIndex;    // Index of the checked image
    int                       m_nUncheckedImageIndex;  // Index of the unchecked image
    SIZE                      m_sizeCheck;             // Size of the images in the image list

private:
    //
    // No implementation
    //
    CCheckedListviewHandler( const CCheckedListviewHandler & );
    CCheckedListviewHandler &operator=( const CCheckedListviewHandler & );

public:
    //
    // Sole constructor and destructor
    //
    CCheckedListviewHandler(void);
    ~CCheckedListviewHandler(void);

private:
    
    //
    // Private helpers
    //
    HBITMAP CreateBitmap( int nWidth, int nHeight );
    BOOL InCheckBox( HWND hwndList, int nItem, const POINT &pt );
    UINT GetItemCheckState( HWND hwndList, int nIndex );
    UINT SetItemCheckState( HWND hwndList, int nIndex, UINT nCheck );
    int GetItemCheckBitmap( HWND hwndList, int nIndex );
    BOOL RealHandleListClick( WPARAM wParam, LPARAM lParam, bool bIgnoreHitArea );
    void DestroyImageList(void);
    bool WindowInList( HWND hWnd );

public:
    //
    // Message handlers.  They return true if the message is handled.
    //
    BOOL HandleListClick( WPARAM wParam, LPARAM lParam );
    BOOL HandleListDblClk( WPARAM wParam, LPARAM lParam );
    BOOL HandleListKeyDown( WPARAM wParam, LPARAM lParam, LRESULT &lResult );
    BOOL HandleListCustomDraw( WPARAM wParam, LPARAM lParam, LRESULT &lResult );

    //
    // Public helper functions
    //
    void Select( HWND hwndList, int nIndex, UINT nSelect );
    bool FullImageHit(void) const;
    void FullImageHit( bool bFullImageHit );
    bool CreateDefaultCheckBitmaps(void);
    bool SetCheckboxImages( HBITMAP hChecked, HBITMAP hUnchecked );
    bool SetCheckboxImages( HICON hChecked, HICON hUnchecked );
    bool ImagesValid(void);
    void Attach( HWND hWnd );
    void Detach( HWND hWnd );
};

#endif // __CHKLISTV_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\unittest\clvtest\lvprops.h ===
#ifndef __LVPROPS_H_INCLUDED
#define __LVPROPS_H_INCLUDED

#include <windows.h>

class CListviewPropsDialog
{
public:
    class CData
    {
    public:
        bool bFullItemSelect;
        bool bCustomIcon;
        SIZE sizeItemSpacing;
    };

private:
    HWND   m_hWnd;
    CData *m_pData;

private:
    CListviewPropsDialog(void);
    CListviewPropsDialog( const CListviewPropsDialog & );
    CListviewPropsDialog &operator=( const CListviewPropsDialog & );

private:
    
    explicit CListviewPropsDialog( HWND hWnd )
      : m_hWnd(hWnd),
        m_pData(NULL)
    {
    }
    ~CListviewPropsDialog(void)
    {
    }

    LRESULT OnInitDialog( WPARAM, LPARAM lParam )
    {
        m_pData = reinterpret_cast<CData*>(lParam);
        if (!m_pData)
        {
            EndDialog(m_hWnd,IDCANCEL);
            return 0;
        }
        if (m_pData->bFullItemSelect)
        {
            SendDlgItemMessage( m_hWnd, IDC_FULLSELECT, BM_SETCHECK, BST_CHECKED, 0 );
        }
        SendDlgItemMessage( m_hWnd, IDC_ICONSPACING_X_SPIN, UDM_SETRANGE, 0, MAKELONG(50,4) );
        SendDlgItemMessage( m_hWnd, IDC_ICONSPACING_X_SPIN, UDM_SETPOS, 0, m_pData->sizeItemSpacing.cx );
        SendDlgItemMessage( m_hWnd, IDC_ICONSPACING_Y_SPIN, UDM_SETRANGE, 0, MAKELONG(50,4) );
        SendDlgItemMessage( m_hWnd, IDC_ICONSPACING_Y_SPIN, UDM_SETPOS, 0, m_pData->sizeItemSpacing.cy );
        return 0;
    }

    void OnOK( WPARAM wParam, LPARAM )
    {
        m_pData->sizeItemSpacing.cx = static_cast<LONG>(SendDlgItemMessage( m_hWnd, IDC_ICONSPACING_X_SPIN, UDM_GETPOS, 0, 0 ));
        m_pData->sizeItemSpacing.cy = static_cast<LONG>(SendDlgItemMessage( m_hWnd, IDC_ICONSPACING_Y_SPIN, UDM_GETPOS, 0, 0 ));
        m_pData->bFullItemSelect = (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_FULLSELECT, BM_GETCHECK, 0, 0 ) );
        m_pData->bCustomIcon = (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_CUSTOMICON, BM_GETCHECK, 0, 0 ) );
        EndDialog(m_hWnd,IDOK);
    }

    void OnCancel( WPARAM wParam, LPARAM )
    {
        EndDialog(m_hWnd,LOWORD(wParam));
    }

    LRESULT OnNotify( WPARAM wParam, LPARAM lParam )
    {
       SC_BEGIN_NOTIFY_MESSAGE_HANDLERS()
       {
       }
       SC_END_NOTIFY_MESSAGE_HANDLERS();
    }
    
    LRESULT OnCommand( WPARAM wParam, LPARAM lParam )
    {
       SC_BEGIN_COMMAND_HANDLERS()
       {
           SC_HANDLE_COMMAND(IDOK,OnOK);
           SC_HANDLE_COMMAND(IDCANCEL,OnCancel);
       }
       SC_END_COMMAND_HANDLERS();
    }

public:
    static INT_PTR CALLBACK DialogProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
    {
        SC_BEGIN_DIALOG_MESSAGE_HANDLERS(CListviewPropsDialog)
        {
            SC_HANDLE_DIALOG_MESSAGE( WM_INITDIALOG, OnInitDialog );
            SC_HANDLE_DIALOG_MESSAGE( WM_COMMAND, OnCommand );
            SC_HANDLE_DIALOG_MESSAGE( WM_NOTIFY, OnNotify );
        }
        SC_END_DIALOG_MESSAGE_HANDLERS();
    }
    
};

#endif // __LVPROPS_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\unittest\clvtest\clvtest.cpp ===
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <comctrlp.h>
#include <objbase.h>
#include <wiadebug.h>
#include <simcrack.h>
#include "resource.h"
#include "dbgcdraw.h"
#include "chklistv.h"
#include "lvprops.h"

static HINSTANCE g_hInstance;

static const int c_nMaxImages         = 20;

static const int c_nAdditionalMarginX = 10;
static const int c_nAdditionalMarginY = 10;

class CListviewTestDialog
{
private:
    HWND                    m_hWnd;
    CCheckedListviewHandler m_CheckedListviewHandler;
    SIZE                    m_sizeImage;
    SIZE                    m_sizeMargin;

private:
    CListviewTestDialog(void);
    CListviewTestDialog( const CListviewTestDialog & );
    CListviewTestDialog &operator=( const CListviewTestDialog & );

private:
    
    explicit CListviewTestDialog( HWND hWnd )
      : m_hWnd(hWnd)
    {
        ZeroMemory(&m_sizeImage,sizeof(SIZE));
        m_sizeMargin.cx = c_nAdditionalMarginX;
        m_sizeMargin.cy = c_nAdditionalMarginY;
    }
    ~CListviewTestDialog(void)
    {
    }

    LRESULT OnListClick( WPARAM wParam, LPARAM lParam )
    {
        m_CheckedListviewHandler.HandleListClick( wParam, lParam );
        return 0;
    }

    LRESULT OnListDblClk( WPARAM wParam, LPARAM lParam )
    {
        m_CheckedListviewHandler.HandleListDblClk( wParam, lParam );
        return 0;
    }

    LRESULT OnGetCheckState( WPARAM wParam, LPARAM lParam )
    {
        LRESULT lResult = 0;
        NMGETCHECKSTATE *pNmGetCheckState = reinterpret_cast<NMGETCHECKSTATE*>(lParam);
        if (pNmGetCheckState)
        {
            LVITEM LvItem = {0};
            LvItem.iItem = pNmGetCheckState->nItem;
            LvItem.mask = LVIF_PARAM;
            if (ListView_GetItem( pNmGetCheckState->hdr.hwndFrom, &LvItem ))
            {
                if (LvItem.lParam)
                {
                    lResult = LVCHECKSTATE_CHECKED;
                }
                else
                {
                    lResult = LVCHECKSTATE_UNCHECKED;
                }
            }
        }
        return lResult;
    }

    LRESULT OnSetCheckState( WPARAM wParam, LPARAM lParam )
    {
        LRESULT lResult = 0;
        NMSETCHECKSTATE *pNmSetCheckState = reinterpret_cast<NMSETCHECKSTATE*>(lParam);
        if (pNmSetCheckState)
        {
            LVITEM LvItem = {0};
            LvItem.mask = LVIF_PARAM;
            LvItem.iItem = pNmSetCheckState->nItem;
            LvItem.lParam = (pNmSetCheckState->nCheck == LVCHECKSTATE_CHECKED) ? 1 : 0;
            ListView_SetItem( pNmSetCheckState->hdr.hwndFrom, &LvItem );
        }
        return 0;
    }

    LRESULT OnListCustomDraw( WPARAM wParam, LPARAM lParam )
    {
        LRESULT lResult = CDRF_DODEFAULT;
        m_CheckedListviewHandler.HandleListCustomDraw( wParam, lParam, lResult );
        return lResult;
    }

    LRESULT OnListKeyDown( WPARAM wParam, LPARAM lParam )
    {
        LRESULT lResult = FALSE;
        m_CheckedListviewHandler.HandleListKeyDown( wParam, lParam, lResult );
        return lResult;
    }


    LRESULT OnInitDialog( WPARAM, LPARAM )
    {
        HWND hwndList = GetDlgItem( m_hWnd, IDC_LIST );
        if (hwndList)
        {
            //
            // Attach this control to the checkbox handler
            //
            m_CheckedListviewHandler.Attach(hwndList);

            //
            // Load an image for the image list
            //
            struct
            {
                UINT    nResId;
                HBITMAP hBitmap;
                int     nImageIndex;
            } Images[] =
            {
                { IDB_IMAGE1, NULL, 0 },
                { IDB_IMAGE2, NULL, 0 },
                { IDB_IMAGE3, NULL, 0 },
                { IDB_IMAGE4, NULL, 0 },
                { IDB_IMAGE5, NULL, 0 }
            };

            WIA_TRACE((TEXT("line: %d"), __LINE__ ));
            bool bSuccess = true;
            for (int i=0;i<ARRAYSIZE(Images) && bSuccess;i++)
            {
                Images[i].hBitmap = reinterpret_cast<HBITMAP>(LoadImage(g_hInstance,MAKEINTRESOURCE(Images[i].nResId), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION ));
                if (!Images[i].hBitmap)
                {
                    bSuccess = false;
                }
            }
            
            if (bSuccess)
            {
                //
                // Get the image's dimensions
                //
                BITMAP bm = {0};
                if (GetObject( Images[0].hBitmap, sizeof(BITMAP), &bm ))
                {
                    m_sizeImage.cx = bm.bmWidth;
                    m_sizeImage.cy = bm.bmHeight;
                    //
                    // Create the image list
                    //
                    HIMAGELIST hImageList = ImageList_Create( m_sizeImage.cx, m_sizeImage.cy, ILC_COLOR24, 1, 1 );
                    if (hImageList)
                    {
                        //
                        // Set the image list
                        //
                        ListView_SetImageList( hwndList, hImageList, LVSIL_NORMAL );
                        
                        //
                        // Add the image to the image list
                        //
                        bSuccess = true;
                        for (int i=0;i<ARRAYSIZE(Images) && bSuccess;i++)
                        {
                            WIA_TRACE((TEXT("line: %d"), __LINE__ ));
                            Images[i].nImageIndex = ImageList_Add( hImageList, Images[i].hBitmap, NULL );
                            if (-1 == Images[i].nImageIndex)
                            {
                                bSuccess = false;
                            }
                        }
                        
                        if (bSuccess)
                        {
                            WIA_TRACE((TEXT("line: %d"), __LINE__ ));
                            //
                            // Tell the listview we don't want labels, and want border selection
                            //
                            
                            ListView_SetExtendedListViewStyleEx( hwndList, LVS_EX_DOUBLEBUFFER|LVS_EX_BORDERSELECT|LVS_EX_HIDELABELS|0x00100000|LVS_EX_CHECKBOXES, LVS_EX_DOUBLEBUFFER|LVS_EX_BORDERSELECT|LVS_EX_HIDELABELS|0x00100000|LVS_EX_CHECKBOXES );
                            ListView_SetIconSpacing( hwndList, m_sizeImage.cx + m_sizeMargin.cx, m_sizeImage.cy + m_sizeMargin.cy );
                            
                            //
                            // Insert a few items
                            //
                            for (int i=0;i<c_nMaxImages;i++)
                            {
                                LVITEM LvItem = {0};
                                LvItem.mask = LVIF_IMAGE;
                                LvItem.iImage = Images[i%ARRAYSIZE(Images)].nImageIndex;
                                LvItem.iItem = i;
                                ListView_InsertItem( hwndList, &LvItem );
                            }

                            //
                            // Select the first item
                            //
                            ListView_SetItemState( hwndList, 0, LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED );
                        }
                    }
                }
            }
        }
        return 0;
    }

    void OnOK( WPARAM wParam, LPARAM )
    {
        EndDialog(m_hWnd,LOWORD(wParam));
    }

    void OnCancel( WPARAM wParam, LPARAM )
    {
        EndDialog(m_hWnd,LOWORD(wParam));
    }

    void OnSelectCurr( WPARAM, LPARAM )
    {
        int nCurrItem = -1;
        while (true)
        {
            nCurrItem = ListView_GetNextItem( GetDlgItem(m_hWnd,IDC_LIST), nCurrItem, LVNI_SELECTED );
            if (nCurrItem < 0)
            {
                break;
            }
            m_CheckedListviewHandler.Select( GetDlgItem(m_hWnd,IDC_LIST), nCurrItem, LVCHECKSTATE_CHECKED );
        }
    }
    void OnSelectAll( WPARAM, LPARAM )
    {
        m_CheckedListviewHandler.Select( GetDlgItem(m_hWnd,IDC_LIST), -1, LVCHECKSTATE_CHECKED );
    }
    void OnSelectNone( WPARAM, LPARAM )
    {
        m_CheckedListviewHandler.Select( GetDlgItem(m_hWnd,IDC_LIST), -1, LVCHECKSTATE_UNCHECKED );
    }

    void OnProperties( WPARAM, LPARAM )
    {
        CListviewPropsDialog::CData Data;
        Data.bFullItemSelect = m_CheckedListviewHandler.FullImageHit();
        Data.sizeItemSpacing.cx = m_sizeMargin.cx;
        Data.sizeItemSpacing.cy = m_sizeMargin.cy;
        INT_PTR nRes = DialogBoxParam(g_hInstance,MAKEINTRESOURCE(IDD_LISTVIEW_PROPS_DIALOG), NULL, CListviewPropsDialog::DialogProc, reinterpret_cast<LPARAM>(&Data) );
        if (IDOK == nRes)
        {
            m_CheckedListviewHandler.FullImageHit(Data.bFullItemSelect);
            m_sizeMargin.cx = Data.sizeItemSpacing.cx;
            m_sizeMargin.cy = Data.sizeItemSpacing.cy;
            if (Data.bCustomIcon)
            {
                m_CheckedListviewHandler.SetCheckboxImages( (HICON)LoadImage( g_hInstance, MAKEINTRESOURCE(IDI_CHECKED), IMAGE_ICON, 0, 0, LR_DEFAULTCOLOR ), (HICON)LoadImage( g_hInstance, MAKEINTRESOURCE(IDI_UNCHECKED), IMAGE_ICON, 0, 0, LR_DEFAULTCOLOR ) );
            }
            else
            {
                m_CheckedListviewHandler.CreateDefaultCheckBitmaps();
            }
            ListView_SetIconSpacing( GetDlgItem(m_hWnd,IDC_LIST), m_sizeImage.cx + m_sizeMargin.cx, m_sizeImage.cy + m_sizeMargin.cy );
            InvalidateRect( GetDlgItem(m_hWnd,IDC_LIST), NULL, TRUE );
            UpdateWindow( GetDlgItem(m_hWnd,IDC_LIST) );
        }
    }

    LRESULT OnNotify( WPARAM wParam, LPARAM lParam )
    {
       SC_BEGIN_NOTIFY_MESSAGE_HANDLERS()
       {
       }
       SC_END_NOTIFY_MESSAGE_HANDLERS();
    }
    
    LRESULT OnCommand( WPARAM wParam, LPARAM lParam )
    {
       SC_BEGIN_COMMAND_HANDLERS()
       {
           SC_HANDLE_COMMAND(IDOK,OnOK);
           SC_HANDLE_COMMAND(IDCANCEL,OnCancel);
           SC_HANDLE_COMMAND(IDC_SELECTCURR,OnSelectCurr);
           SC_HANDLE_COMMAND(IDC_SELECTALL,OnSelectAll);
           SC_HANDLE_COMMAND(IDC_SELECTNONE,OnSelectNone);
           SC_HANDLE_COMMAND(IDC_PROPERTIES,OnProperties);
       }
       SC_END_COMMAND_HANDLERS();
    }

public:
    static INT_PTR CALLBACK DialogProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
    {
        SC_BEGIN_DIALOG_MESSAGE_HANDLERS(CListviewTestDialog)
        {
            SC_HANDLE_DIALOG_MESSAGE( WM_INITDIALOG, OnInitDialog );
            SC_HANDLE_DIALOG_MESSAGE( WM_COMMAND, OnCommand );
            SC_HANDLE_DIALOG_MESSAGE( WM_NOTIFY, OnNotify );
        }
        SC_END_DIALOG_MESSAGE_HANDLERS();
    }
    
};

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE, LPSTR, int )
{
    WIA_DEBUG_CREATE( hInstance );
    g_hInstance = hInstance;
    InitCommonControls();
    DialogBox(hInstance,MAKEINTRESOURCE(IDD_LISTVIEW_TEST_DIALOG), NULL, CListviewTestDialog::DialogProc );
    WIA_DEBUG_DESTROY();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\unittest\clvtest\dbgcdraw.h ===
#ifndef __DBGCDRAW_H_INCLUDED
#define __DBGCDRAW_H_INCLUDED

#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof(x)/sizeof(x[0]))
#endif

#define MKFLAG(x) { (x), TEXT(#x) }

struct FlagString
{
    DWORD dwFlag;
    LPCTSTR pszString;
};

inline LPCTSTR GetString( LPTSTR szString, FlagString *pFlagStrings, size_t nSize, DWORD dwValue, bool bFlag )
{
    TCHAR szFlag[200] = TEXT("");
    wsprintf( szFlag, TEXT("(0x%08X)"), dwValue );

    TCHAR szText[256] = TEXT("");

    lstrcpy( szString, TEXT("") );

    if (bFlag)
    {
        
        for (size_t i=0;i<nSize;i++)
        {
            if (dwValue & pFlagStrings[i].dwFlag)
            {
                if (lstrlen(szText))
                {
                    lstrcat(szText,TEXT("|"));
                }
                lstrcat( szText, pFlagStrings[i].pszString );
            }
        }
    }
    else
    {
        for (size_t i=0;i<nSize;i++)
        {
            if (dwValue == pFlagStrings[i].dwFlag)
            {
                lstrcpy( szText, pFlagStrings[i].pszString );
                break;
            }
        }
    }
    lstrcpy( szString, szText );
    if (lstrlen(szString))
    {
        lstrcat( szString, TEXT(" ") );
    }
    lstrcat( szString, szFlag );
    return szString;
}

inline void DumpCustomDraw( LPARAM lParam, LPCTSTR pszControlType=NULL, DWORD dwDrawStage=0 )
{
    FlagString DrawStages[] =
    {
        MKFLAG(CDDS_PREPAINT),
        MKFLAG(CDDS_POSTPAINT),
        MKFLAG(CDDS_PREERASE),
        MKFLAG(CDDS_POSTERASE),
        MKFLAG(CDDS_ITEMPREPAINT),
        MKFLAG(CDDS_ITEMPOSTPAINT),
        MKFLAG(CDDS_ITEMPREERASE),
        MKFLAG(CDDS_ITEMPOSTERASE)
    };
    FlagString ItemStates[] =
    {
        MKFLAG(CDIS_CHECKED),
        MKFLAG(CDIS_DEFAULT),
        MKFLAG(CDIS_DISABLED),
        MKFLAG(CDIS_FOCUS),
        MKFLAG(CDIS_GRAYED),
        MKFLAG(CDIS_HOT),
        MKFLAG(CDIS_INDETERMINATE),
        MKFLAG(CDIS_MARKED),
        MKFLAG(CDIS_SELECTED),
        MKFLAG(CDIS_SHOWKEYBOARDCUES)
    };
    TCHAR szClassName[MAX_PATH];

    if (GetClassName( reinterpret_cast<NMHDR*>(lParam)->hwndFrom, szClassName, sizeof(szClassName)/sizeof(szClassName[0]) ))
    {
        if (!pszControlType || !lstrcmp(pszControlType,szClassName))
        {
            if (!dwDrawStage || dwDrawStage == reinterpret_cast<NMCUSTOMDRAW*>(lParam)->dwDrawStage)
            {
                TCHAR szBuffer[MAX_PATH];
                WIA_TRACE((TEXT("Dumping Custom Draw for control: [%s]"), szClassName ));
#if 0
                WIA_TRACE((TEXT("   hwndFrom: 0x%p"),reinterpret_cast<NMHDR*>(lParam)->hwndFrom ));
                WIA_TRACE((TEXT("   idFrom: %d"),reinterpret_cast<NMHDR*>(lParam)->idFrom ));
                WIA_TRACE((TEXT("   code: %d"),reinterpret_cast<NMHDR*>(lParam)->code ));
#endif
                WIA_TRACE((TEXT("   dwDrawStage: %s"),GetString(szBuffer,DrawStages,ARRAYSIZE(DrawStages),reinterpret_cast<NMCUSTOMDRAW*>(lParam)->dwDrawStage,false)));
                WIA_TRACE((TEXT("   hdc: %p"),reinterpret_cast<NMCUSTOMDRAW*>(lParam)->hdc ));
                WIA_TRACE((TEXT("   rc: (%d,%d), (%d,%d)"),reinterpret_cast<NMCUSTOMDRAW*>(lParam)->rc.left, reinterpret_cast<NMCUSTOMDRAW*>(lParam)->rc.top,reinterpret_cast<NMCUSTOMDRAW*>(lParam)->rc.right,reinterpret_cast<NMCUSTOMDRAW*>(lParam)->rc.bottom ));
                WIA_TRACE((TEXT("   dwItemSpec: %d"),reinterpret_cast<NMCUSTOMDRAW*>(lParam)->dwItemSpec ));
                WIA_TRACE((TEXT("   uItemState: %s"),GetString(szBuffer,ItemStates,ARRAYSIZE(ItemStates),reinterpret_cast<NMCUSTOMDRAW*>(lParam)->uItemState,true)));
                WIA_TRACE((TEXT("   lItemlParam: 0x%p"),reinterpret_cast<NMCUSTOMDRAW*>(lParam)->lItemlParam ));
                if (!lstrcmp(TEXT("SysListView32"),szClassName))
                {
                    WIA_TRACE((TEXT("   clrText: RGB(0x%02X,0x%02X,0x%02X)"),GetRValue(reinterpret_cast<NMLVCUSTOMDRAW*>(lParam)->clrText),GetGValue(reinterpret_cast<NMLVCUSTOMDRAW*>(lParam)->clrText),GetBValue(reinterpret_cast<NMLVCUSTOMDRAW*>(lParam)->clrText) ));
                    WIA_TRACE((TEXT("   clrTextBk: RGB(0x%02X,0x%02X,0x%02X)"),GetRValue(reinterpret_cast<NMLVCUSTOMDRAW*>(lParam)->clrTextBk),GetGValue(reinterpret_cast<NMLVCUSTOMDRAW*>(lParam)->clrTextBk),GetBValue(reinterpret_cast<NMLVCUSTOMDRAW*>(lParam)->clrTextBk) ));
                    WIA_TRACE((TEXT("   iSubItem: %d"),reinterpret_cast<NMLVCUSTOMDRAW*>(lParam)->iSubItem ));
                }
                WIA_TRACE((TEXT("")));
            }
        }
    }
}

#endif //__DBGCDRAW_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\unittest\clvtest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by clvtest.rc
//
#define IDD_LISTVIEW_TEST_DIALOG        101
#define IDB_IMAGE                       103
#define IDB_IMAGE1                      103
#define IDD_LISTVIEW_PROPS_DIALOG       106
#define IDB_IMAGE4                      107
#define IDB_IMAGE3                      108
#define IDB_IMAGE2                      109
#define IDB_IMAGE5                      110
#define IDI_CHECKED                     111
#define IDI_UNCHECKED                   112
#define IDC_LIST                        1000
#define IDC_SELECTALL                   1003
#define IDC_SELECTNONE                  1004
#define IDC_FULLSELECT                  1004
#define IDC_SELECTCURR                  1005
#define IDC_ICONSPACING_X_EDIT          1005
#define IDC_ICONSPACING_X_SPIN          1006
#define IDC_ICONSPACING_Y_EDIT          1007
#define IDC_PROPERTIES                  1007
#define IDC_ICONSPACING_Y_SPIN          1008
#define IDC_CUSTOMICON                  1009

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        111
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1010
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\unittest\clvtest2\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by clvtest2.rc
//
#define IDD_LISTVIEW_TEST_DIALOG        101
#define IDB_IMAGE1                      103
#define IDB_IMAGE4                      107
#define IDB_IMAGE3                      108
#define IDB_IMAGE2                      109
#define IDB_IMAGE5                      110
#define IDC_LIST                        1000
#define IDC_SELECTALL                   1003
#define IDC_SELECTNONE                  1004
#define IDC_SELECTCURR                  1005
#define IDC_PROPERTIES                  1007

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        111
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1010
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\unittest\dbgtest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dbgtest.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\unittest\dbgtest\dbgtest.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       MAIN.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        9/6/1999
 *
 *  DESCRIPTION: Test program for the debugging classes
 *
 *******************************************************************************/
#include <windows.h>
#define INITGUID
#include "wianew.h"
#include "wiadebug.h"
#include "simcrit.h"


void Function( int n )
{
    WIA_PUSH_FUNCTION((TEXT("Function( %d )"), n ));
}

DWORD WINAPI ThreadProc( LPVOID pVoid )
{
    WIA_PUSH_FUNCTION_MASK(( 0x00000001, TEXT("ThreadProc( %d )"), (int)(INT_PTR)pVoid ));
    //WIA_PRINTGUID((IID_IUnknown,TEXT("I am printing IID_MYTEST")));
    Function( (int)(INT_PTR)pVoid );

    for (int i=0;i<5;i++)
    {
        WIA_TRACE((TEXT("This is a test (incrementing %d)"), i));
        WIA_WARNING((TEXT("This is a warning (%d)"), i));
        WIA_ERROR((TEXT("This is an error (%d)"), i));
        WIA_PRINTHRESULT((E_NOTIMPL,TEXT("This is an HRESULT error (%d)"), i));
        Sleep(0);
    }
    return 0;
}

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR pszCommandLine, int nCmdShow )
{
    WIA_DEBUG_CREATE( hInstance );
    WIA_PUSH_FUNCTION((TEXT("WinMain( %08X, %08X, \"%hs\", %d )"), hInstance, hPrevInstance, pszCommandLine, nCmdShow ));
    const int nHandles = MAXIMUM_WAIT_OBJECTS-10;
    HANDLE Handles[nHandles];
    for (int i=0;i<nHandles;i++)
    {
        DWORD dwThreadId;
        Handles[i] = CreateThread( NULL, 0, ThreadProc, (PVOID)i, 0, &dwThreadId );
    }
    WaitForMultipleObjects( nHandles, Handles, TRUE, INFINITE );
    for (i=0;i<nHandles;i++)
    {
        CloseHandle( Handles[i] );
    }

    WIA_REPORT_LEAKS();
    WIA_DEBUG_DESTROY();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\unittest\clvtest2\clvtest2.cpp ===
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <comctrlp.h>
#include "resource.h"

#ifndef ARRAYSIZE
#define ARRAYSIZE(x) (sizeof(x)/sizeof(x[0]))
#endif

static HINSTANCE g_hInstance;

static const int c_nMaxImages         = 20;

static const int c_nAdditionalMarginX = 10;
static const int c_nAdditionalMarginY = 10;

class CListviewTestDialog
{
private:
    HWND                    m_hWnd;
    SIZE                    m_sizeImage;
    SIZE                    m_sizeMargin;

private:
    CListviewTestDialog(void);
    CListviewTestDialog( const CListviewTestDialog & );
    CListviewTestDialog &operator=( const CListviewTestDialog & );

private:
    
    explicit CListviewTestDialog( HWND hWnd )
      : m_hWnd(hWnd)
    {
        ZeroMemory(&m_sizeImage,sizeof(SIZE));
        m_sizeMargin.cx = c_nAdditionalMarginX;
        m_sizeMargin.cy = c_nAdditionalMarginY;
    }
    ~CListviewTestDialog(void)
    {
    }


    LRESULT OnInitDialog( WPARAM, LPARAM )
    {
        HWND hwndList = GetDlgItem( m_hWnd, IDC_LIST );
        if (hwndList)
        {
            //
            // Load some images for the image list
            //
            struct
            {
                UINT    nResId;
                HBITMAP hBitmap;
                int     nImageIndex;
            } Images[] =
            {
                { IDB_IMAGE1, NULL, 0 },
                { IDB_IMAGE2, NULL, 0 },
                { IDB_IMAGE3, NULL, 0 },
                { IDB_IMAGE4, NULL, 0 },
                { IDB_IMAGE5, NULL, 0 }
            };

            bool bSuccess = true;
            for (int i=0;i<ARRAYSIZE(Images) && bSuccess;i++)
            {
                Images[i].hBitmap = reinterpret_cast<HBITMAP>(LoadImage(g_hInstance,MAKEINTRESOURCE(Images[i].nResId), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION ));
                if (!Images[i].hBitmap)
                {
                    bSuccess = false;
                }
            }

            
            if (bSuccess)
            {
                //
                // Tell the listview we don't want labels, and want border selection
                //
                ListView_SetExtendedListViewStyleEx( hwndList, LVS_EX_DOUBLEBUFFER|LVS_EX_BORDERSELECT|LVS_EX_HIDELABELS|0x00100000|LVS_EX_CHECKBOXES, LVS_EX_DOUBLEBUFFER|LVS_EX_BORDERSELECT|LVS_EX_HIDELABELS|0x00100000|LVS_EX_CHECKBOXES );
                
                BITMAP bm = {0};
                if (GetObject( Images[0].hBitmap, sizeof(BITMAP), &bm ))
                {
                    m_sizeImage.cx = bm.bmWidth;
                    m_sizeImage.cy = bm.bmHeight;
                }
                ListView_SetIconSpacing( hwndList, m_sizeImage.cx + m_sizeMargin.cx, m_sizeImage.cy + m_sizeMargin.cy );
                
                //
                // Create the image list
                //
                HIMAGELIST hImageList = ImageList_Create( m_sizeImage.cx, m_sizeImage.cy, ILC_COLOR24|ILC_MASK, 1, 1 );
                if (hImageList)
                {
                    //
                    // Add the image to the image list
                    //
                    bSuccess = true;
                    for (int i=0;i<ARRAYSIZE(Images) && bSuccess;i++)
                    {
                        Images[i].nImageIndex = ImageList_Add( hImageList, Images[i].hBitmap, NULL );
                        if (-1 == Images[i].nImageIndex)
                        {
                            bSuccess = false;
                        }
                    }

                    //
                    // Set the image list
                    //
                    ListView_SetImageList( hwndList, hImageList, LVSIL_NORMAL );
                    
                    //
                    // Insert a few items
                    //
                    int nGroupId = 0;
                    for (int i=0;i<c_nMaxImages;i++)
                    {
                        if (i % 5 == 0)
                        {
                            WCHAR szGroupName[MAX_PATH];
                            wsprintfW( szGroupName, L"This is group %d", (i/5)+1 );
                            LVGROUP LvGroup = {0};
                            LvGroup.cbSize = sizeof(LvGroup);
                            LvGroup.pszHeader = szGroupName;
                            LvGroup.mask = LVGF_HEADER | LVGF_ALIGN | LVGF_GROUPID | LVGF_STATE;
                            LvGroup.uAlign = LVGA_HEADER_LEFT;
                            LvGroup.iGroupId = i/5;
                            LvGroup.state = LVGS_NORMAL;
                            nGroupId = static_cast<int>(ListView_InsertGroup( hwndList, i/5, &LvGroup ));
                        }
                        LVITEM LvItem = {0};
                        LvItem.mask = LVIF_IMAGE|LVIF_GROUPID;
                        LvItem.iImage = Images[i%ARRAYSIZE(Images)].nImageIndex;
                        LvItem.iItem = i;
                        LvItem.iGroupId = nGroupId;
                        ListView_InsertItem( hwndList, &LvItem );
                    }
    
                    //
                    // Select the first item
                    //
                    ListView_SetItemState( hwndList, 0, LVIS_SELECTED|LVIS_FOCUSED, LVIS_SELECTED|LVIS_FOCUSED );
                    ListView_EnableGroupView( hwndList, TRUE );
                }
            }
        }
        return 0;
    }

    void OnOK( WPARAM wParam, LPARAM )
    {
        EndDialog(m_hWnd,LOWORD(wParam));
    }

    void OnCancel( WPARAM wParam, LPARAM )
    {
        EndDialog(m_hWnd,LOWORD(wParam));
    }

    void OnSelectAll( WPARAM, LPARAM )
    {
        ListView_SetCheckState( GetDlgItem( m_hWnd, IDC_LIST ), -1, TRUE );
    }
    void OnSelectNone( WPARAM, LPARAM )
    {
        ListView_SetCheckState( GetDlgItem( m_hWnd, IDC_LIST ), -1, FALSE );
    }

    LRESULT OnNotify( WPARAM wParam, LPARAM lParam )
    {
        return 0;
    }
    
    LRESULT OnCommand( WPARAM wParam, LPARAM lParam )
    {
        switch (LOWORD(wParam))
        {
        case IDOK:
            OnOK(wParam,lParam);
            break;

        case IDCANCEL:
            OnCancel(wParam,lParam);
            break;

        case IDC_SELECTALL:
            OnSelectAll(wParam,lParam);
            break;

        case IDC_SELECTNONE:
            OnSelectNone(wParam,lParam);
            break;
        }
        return 0;
    }

public:
    static INT_PTR CALLBACK DialogProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
    {
        INT_PTR bResult = FALSE;
        switch (uMsg)
        {
        case WM_INITDIALOG:
            {
                CListviewTestDialog *pListviewTestDialog = new CListviewTestDialog(hWnd);
                if (pListviewTestDialog)
                {
                    SetWindowLongPtr( hWnd, DWLP_USER, reinterpret_cast<LONG_PTR>(pListviewTestDialog) );
                    bResult = pListviewTestDialog->OnInitDialog( wParam, lParam );
                }
            }
            break;

        case WM_COMMAND:
            {
                CListviewTestDialog *pListviewTestDialog = reinterpret_cast<CListviewTestDialog*>(GetWindowLongPtr( hWnd, DWLP_USER ));
                if (pListviewTestDialog)
                {
                    SetWindowLongPtr( hWnd, DWLP_MSGRESULT, pListviewTestDialog->OnCommand( wParam, lParam ) );
                }
                bResult = TRUE;
            }
            break;
        
        case WM_NOTIFY:
            {
                CListviewTestDialog *pListviewTestDialog = reinterpret_cast<CListviewTestDialog*>(GetWindowLongPtr( hWnd, DWLP_USER ));
                if (pListviewTestDialog)
                {
                    SetWindowLongPtr( hWnd, DWLP_MSGRESULT, pListviewTestDialog->OnNotify( wParam, lParam ) );
                }
                bResult = TRUE;
            }
            break;
        }
        return bResult;
    }
    
};

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE, LPSTR, int )
{
    g_hInstance = hInstance;
    InitCommonControls();
    DialogBox(hInstance,MAKEINTRESOURCE(IDD_LISTVIEW_TEST_DIALOG), NULL, CListviewTestDialog::DialogProc );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\unittest\dbgtest\sources.inc ===
!IF 0

Copyright (c) 1989-1991 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

#
# include the WIA global build settings
#

!include $(PROJECT_ROOT)\ui\uienv.inc
SOURCES_USED = $(PROJECT_ROOT)\ui\uienv.inc

#
# Our specific build settings
#

TARGETNAME=dbgtest
TARGETTYPE=PROGRAM
TARGETPATH=obj

SOURCES= \
          ..\dbgtest.cpp     \
          ..\dbgtest.rc

TARGETLIBS=$(TARGETLIBS)\
        $(SHELL_LIB_PATH)\shfusion.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\unittest\dumpdevs\dumpdevs.cpp ===
#include <windows.h>
#include <objbase.h>
#include <atlbase.h>
#include <wianew.h>
#include <simreg.h>
#include <dumpprop.h>
#include <devlist.h>
#include <simbstr.h>
#include <stdio.h>

void DumpDevice( IWiaDevMgr *pWiaDevMgr, HANDLE hFile, const CSimpleStringWide &strDeviceID )
{
    //
    // Create the device manager
    //
    fprintf( stderr, "Creating [%ls]\n", strDeviceID.String() );
    CComPtr<IWiaItem> pWiaItem;
    HRESULT hr = pWiaDevMgr->CreateDevice( CSimpleBStr(strDeviceID), &pWiaItem );
    if (SUCCEEDED(hr))
    {
        CSimpleStringWide strDeviceName;
        PropStorageHelpers::GetProperty( pWiaItem, WIA_DIP_DEV_NAME, strDeviceName );
        CWiaDebugDumpToFileHandle DebugDump( hFile );
        DebugDump.Print( TEXT("") );
        DebugDump.Print( CSimpleString().Format( TEXT("Device: %ws"), strDeviceName.String() ) );
        DebugDump.Print( TEXT("===============================================") );
        DebugDump.DumpRecursive(pWiaItem);
    }
}

bool GetStringArgument( int argc, wchar_t *argv[], CSimpleString &strArgument, int &nCurrArg )
{
    bool bResult = true;
    if (lstrlenW(argv[nCurrArg]) > 2)
    {
        if (argv[nCurrArg][2] == L':')
        {
            strArgument = argv[nCurrArg] + 3;
        }
        else
        {
            strArgument = argv[nCurrArg] + 2;
        }
    }
    else if (nCurrArg < argc-1)
    {
        strArgument = argv[++nCurrArg];
    }
    else bResult = false;
    return bResult;
}

bool ParseArguments( int argc, wchar_t *argv[], CSimpleDynamicArray<CSimpleString> &DeviceIDs, CSimpleString &strOutputFile, bool &bHidden )
{
    int nCurrArg = 1;
    while (nCurrArg < argc)
    {
        if (argv[nCurrArg][0] == L'-')
        {
            switch (argv[nCurrArg][1])
            {
            case 'd':
                {
                    CSimpleString strArg;
                    if (GetStringArgument( argc, argv, strArg, nCurrArg ))
                    {
                        DeviceIDs.Append(strArg);
                    }
                }
                break;

            case 'o':
                {
                    CSimpleString strArg;
                    if (GetStringArgument( argc, argv, strArg, nCurrArg ))
                    {
                        strOutputFile = strArg;
                    }
                }
                break;

            case 'h':
                {
                    bHidden = true;
                }
                break;
            }
        }
        nCurrArg++;
    }

    return true;
}

class CCoInitialize
{
private:
    HRESULT m_hr;

private:
    CCoInitialize( const CCoInitialize & );
    CCoInitialize &operator=( const CCoInitialize & );

public:
    CCoInitialize()
    {
        m_hr = CoInitialize(NULL);
    }
    ~CCoInitialize()
    {
        if (SUCCEEDED(m_hr))
        {
            CoUninitialize();
        }
    }
    HRESULT Result(void) const
    {
        return m_hr;
    }
};

int __cdecl wmain( int argc, wchar_t *argv[] )
{
    CSimpleDynamicArray<CSimpleString> DeviceIDs;
    CSimpleString strOutputFile;
    bool bHidden = false;

    if (ParseArguments(argc,argv,DeviceIDs,strOutputFile,bHidden))
    {
        HANDLE hFile = INVALID_HANDLE_VALUE;
        if (strOutputFile.Length())
        {
            hFile = CreateFile( strOutputFile, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );
        }
        else
        {
            hFile = GetStdHandle(STD_OUTPUT_HANDLE);
        }

        if (INVALID_HANDLE_VALUE != hFile)
        {
            //
            // Initialize COM
            //
            CCoInitialize coinit;
            if (SUCCEEDED(coinit.Result()))
            {
                //
                // Create the device manager
                //
                CComPtr<IWiaDevMgr> pWiaDevMgr;
                HRESULT hr = CoCreateInstance( CLSID_WiaDevMgr, NULL, CLSCTX_LOCAL_SERVER, IID_IWiaDevMgr, (void**)&pWiaDevMgr );
                if (SUCCEEDED(hr))
                {
                    if (DeviceIDs.Size())
                    {
                        for (int i=0;i<DeviceIDs.Size();i++)
                        {
                            DumpDevice( pWiaDevMgr, hFile, CSimpleStringConvert::WideString(DeviceIDs[i]) );
                        }
                    }
                    else
                    {
                        CDeviceList DeviceList(pWiaDevMgr,StiDeviceTypeDefault,bHidden ? 0xFFFFFFFF : 0);
                        for (int i=0;i<DeviceList.Size();i++)
                        {
                            CSimpleStringWide strDeviceID;
                            if (PropStorageHelpers::GetProperty( DeviceList[i], WIA_DIP_DEV_ID, strDeviceID ))
                            {
                                DumpDevice( pWiaDevMgr, hFile, CSimpleStringConvert::WideString(strDeviceID) );
                            }
                            else
                            {
                                fprintf( stderr, "Unable to get the device ID\n" );
                            }
                        }
                    }
                }
            }
        }
        else
        {
            fprintf( stderr, "Unable to open %ls for writing\n", strOutputFile.String() );
        }
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\unittest\forceerr\forceerr.cpp ===
#include <windows.h>
#include <commctrl.h>
#include <uicommon.h>
#include "errdlg.h"
#include "resource.h"

//
// Global HINSTANCE
//
HINSTANCE g_hInstance = NULL;


int __stdcall WinMain( HINSTANCE hInstance, HINSTANCE, LPSTR, int )
{
    WIA_DEBUG_CREATE(hInstance);
    g_hInstance = hInstance;
    InitCommonControls();
    DialogBoxParam( hInstance, MAKEINTRESOURCE(IDD_ERROR_DIALOG), NULL, CErrorMessageDialog::DialogProc, NULL );
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\unittest\forceerr\errdlg.h ===
#ifndef __ERRDLG_H_INCLUDED
#define __ERRDLG_H_INCLUDED

#include <windows.h>
#include <simstr.h>

//
// String constants
//
#define INI_FILE_NAME    TEXT("forceerr.ini")
#define GENERAL_SECTION  TEXT("ForceError")
#define PROGRAMS_SECTION TEXT("Programs")
#define LAST_PROGRAM     TEXT("LastProgram")

class CErrorMessageDialog
{
private:
    HWND           m_hWnd;
    bool           m_bErrorStringProvided;
    CSimpleString  m_strIniFileName;

private:
    CErrorMessageDialog();
    CErrorMessageDialog( const CErrorMessageDialog & );
    CErrorMessageDialog &operator=( const CErrorMessageDialog & );

private:
    explicit CErrorMessageDialog( HWND hWnd );
    ~CErrorMessageDialog();

private:    
    void SelectError( HRESULT hrSelect );
    void SelectErrorPoint( int nErrorPoint );
    
    LRESULT GetComboBoxItemData( HWND hWnd, LRESULT nIndex, LRESULT nDefault=0 );
    CSimpleString GetComboBoxString( HWND hWnd, LRESULT nIndex );
    CSimpleString GetCurrentlySelectedComboBoxString( HWND hWnd );
    LRESULT GetCurrentComboBoxSelection( HWND hWnd );
    LRESULT GetCurrentComboBoxSelectionData( HWND hWnd, LRESULT nDefault = 0 );
    CSimpleString GetCurrentlySelectedProgram();
    
    CSimpleString GetIniString( LPCTSTR pszSection, LPCTSTR pszKey, LPCTSTR pszDefault=TEXT("") );
    UINT GetIniInt( LPCTSTR pszSection, LPCTSTR pszKey, UINT nDefault=0 );
    
    void HandleErrorSelectionChange();
    void HandleProgramsSelectionChange();
    void HandlePointSelectionChange();
    
    void PopulateProgramComboBox();
    void PopulateErrorPointComboBox();
    void PopulateErrorsComboBox();
    void InitializeAllFields();
    
    void OnSetError( WPARAM, LPARAM );
    void OnRefresh( WPARAM, LPARAM );
    void OnCancel( WPARAM, LPARAM );
    void OnErrorsSelChange( WPARAM, LPARAM );
    void OnPointSelChange( WPARAM, LPARAM );
    void OnProgramsSelChange( WPARAM, LPARAM );
    void OnClearAll( WPARAM, LPARAM );
    
    LRESULT OnInitDialog( WPARAM, LPARAM );
    LRESULT OnDestroy( WPARAM, LPARAM );
    LRESULT OnCtlColorStatic( WPARAM wParam, LPARAM lParam );
    LRESULT OnCommand( WPARAM wParam, LPARAM lParam );

public:
    static INT_PTR __stdcall DialogProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );
};


#endif // __ERRDLG_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\unittest\forceerr\errdlg.cpp ===
#include <windows.h>
#include <uicommon.h>
#include <commctrl.h>
#include <shellext.h>
#include <simcrack.h>
#include <shlwapi.h>
#include "errdlg.h"
#include "rawerror.h"
#include "resource.h"

extern HINSTANCE g_hInstance;

//
// String constants
//
#define INI_FILE_NAME    TEXT("forceerr.ini")
#define GENERAL_SECTION  TEXT("ForceError")
#define PROGRAMS_SECTION TEXT("Programs")
#define LAST_PROGRAM     TEXT("LastProgram")

CErrorMessageDialog::CErrorMessageDialog( HWND hWnd )
  : m_hWnd(hWnd),
    m_strIniFileName(INI_FILE_NAME)
{
    //
    // Create an absolute pathname for the default INI file,
    // so it points to the same directory as the EXE
    //
    TCHAR szCurrFile[MAX_PATH];
    if (GetModuleFileName( NULL, szCurrFile, ARRAYSIZE(szCurrFile)))
    {
        if (PathRemoveFileSpec( szCurrFile ))
        {
            m_strIniFileName = CSimpleString(szCurrFile);
            if (!m_strIniFileName.MatchLastCharacter(TEXT('\\')))
            {
                m_strIniFileName += TEXT("\\");
            }
            m_strIniFileName += CSimpleString(INI_FILE_NAME);
        }
    }

    //
    // If the default INI file location has been overridden in the registry, use it instead
    //
    CSimpleString strIniFile = CSimpleReg( HKEY_FORCEERROR, REGSTR_FORCEERR_KEY ).Query( INI_FILE_NAME, TEXT("") );
    if (strIniFile.Length())
    {
        m_strIniFileName = strIniFile;
    }
}

CErrorMessageDialog::~CErrorMessageDialog()
{
}

void CErrorMessageDialog::SelectError( HRESULT hrSelect )
{
    LRESULT nSel = 0;
    for (LRESULT i=0;i<SendDlgItemMessage( m_hWnd, IDC_ERROR_VALUE, CB_GETCOUNT, 0, 0 );i++)
    {
        HRESULT hr = static_cast<HRESULT>(SendDlgItemMessage( m_hWnd, IDC_ERROR_VALUE, CB_GETITEMDATA, i, 0 ));
        if (hrSelect == hr)
        {
            nSel = i;
            break;
        }
    }
    SendDlgItemMessage( m_hWnd, IDC_ERROR_VALUE, CB_SETCURSEL, nSel, 0 );
}

void CErrorMessageDialog::SelectErrorPoint( int nErrorPoint )
{
    for (LRESULT i=0;i<SendDlgItemMessage( m_hWnd, IDC_ERROR_POINT, CB_GETCOUNT, 0, 0 );i++)
    {
        int nCurrErrorPoint = GetComboBoxItemData( GetDlgItem( m_hWnd, IDC_ERROR_POINT ), i );
        if (nErrorPoint == nCurrErrorPoint)
        {
            SendDlgItemMessage( m_hWnd, IDC_ERROR_POINT, CB_SETCURSEL, i, 0 );
            break;
        }
    }
}


LRESULT CErrorMessageDialog::GetComboBoxItemData( HWND hWnd, LRESULT nIndex, LRESULT nDefault )
{
    LRESULT lResult = SendMessage( hWnd, CB_GETITEMDATA, nIndex, 0 );
    if (CB_ERR == lResult)
    {
        lResult = nDefault;
    }
    return lResult;
}

CSimpleString CErrorMessageDialog::GetComboBoxString( HWND hWnd, LRESULT nIndex )
{
    CSimpleString strResult;
    LRESULT nTextLen = SendMessage( hWnd, CB_GETLBTEXTLEN, nIndex, 0 );
    if (nTextLen)
    {
        LPTSTR pszText = new TCHAR[nTextLen+1];
        if (pszText)
        {
            if (SendMessage( hWnd, CB_GETLBTEXT, nIndex, reinterpret_cast<LPARAM>(pszText)))
            {
                strResult = pszText;
            }
            delete[] pszText;
        }
    }
    return strResult;
}

CSimpleString CErrorMessageDialog::GetCurrentlySelectedComboBoxString( HWND hWnd )
{
    CSimpleString strResult;
    LRESULT nIndex = SendMessage( hWnd, CB_GETCURSEL, 0, 0 );
    if (CB_ERR != nIndex)
    {
        strResult = GetComboBoxString( hWnd, nIndex );
    }
    return strResult;
}

LRESULT CErrorMessageDialog::GetCurrentComboBoxSelection( HWND hWnd )
{
    return SendMessage( hWnd, CB_GETCURSEL, 0, 0 );
}

LRESULT CErrorMessageDialog::GetCurrentComboBoxSelectionData( HWND hWnd, LRESULT nDefault )
{
    LRESULT lResult = nDefault;

    LRESULT nCurIndex = GetCurrentComboBoxSelection( hWnd );
    if (CB_ERR != nCurIndex)
    {
        lResult = GetComboBoxItemData( hWnd, nCurIndex, nDefault );
    }
    return lResult;
}

CSimpleString CErrorMessageDialog::GetIniString( LPCTSTR pszSection, LPCTSTR pszKey, LPCTSTR pszDefault )
{
    CSimpleString strResult(pszDefault);

    TCHAR szString[1024];

    if (GetPrivateProfileString( pszSection, pszKey, pszDefault, szString, ARRAYSIZE(szString), m_strIniFileName ))
    {
        strResult = szString;
    }

    return strResult;
}

UINT CErrorMessageDialog::GetIniInt( LPCTSTR pszSection, LPCTSTR pszKey, UINT nDefault )
{
    return GetPrivateProfileInt( pszSection, pszKey, nDefault, m_strIniFileName );
}

void CErrorMessageDialog::PopulateProgramComboBox()
{
    WIA_PUSH_FUNCTION((TEXT("PopulateProgramComboBox")));
    SendDlgItemMessage( m_hWnd, IDC_ERROR_PROGRAMS, CB_RESETCONTENT, 0, 0 );

    const int c_nSize = 24000;
    LPTSTR pszSections = new TCHAR[c_nSize];
    if (pszSections)
    {
        if (GetPrivateProfileString( PROGRAMS_SECTION, NULL, TEXT(""), pszSections, c_nSize, m_strIniFileName ))
        {
            for (LPTSTR pszCurr=pszSections;pszCurr && *pszCurr;pszCurr += lstrlen(pszCurr)+1 )
            {
                TCHAR szAppName[MAX_PATH] = {0};
                if (GetPrivateProfileString( PROGRAMS_SECTION, pszCurr, TEXT(""), szAppName, ARRAYSIZE(szAppName), m_strIniFileName ))
                {
                    if (lstrlen(szAppName))
                    {
                        SendDlgItemMessage( m_hWnd, IDC_ERROR_PROGRAMS, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(szAppName) );
                    }
                }
            }
        }
        delete[] pszSections;
    }
    
    LRESULT nSelectedItem = 0;
    CSimpleString strLastSelectedProgram = GetIniString( GENERAL_SECTION, LAST_PROGRAM );
    if (strLastSelectedProgram.Length())
    {
        nSelectedItem = SendDlgItemMessage( m_hWnd, IDC_ERROR_PROGRAMS, CB_FINDSTRINGEXACT, -1, reinterpret_cast<LPARAM>(strLastSelectedProgram.String()));
        if (nSelectedItem < 0)
        {
            nSelectedItem = 0;
        }
    }
    WiaUiUtil::ModifyComboBoxDropWidth( GetDlgItem( m_hWnd, IDC_ERROR_PROGRAMS ) );
    SendDlgItemMessage( m_hWnd, IDC_ERROR_PROGRAMS, CB_SETCURSEL, nSelectedItem, 0 );
}


CSimpleString CErrorMessageDialog::GetCurrentlySelectedProgram()
{
    return GetCurrentlySelectedComboBoxString( GetDlgItem( m_hWnd, IDC_ERROR_PROGRAMS ) );
}

void CErrorMessageDialog::PopulateErrorPointComboBox()
{
    WIA_PUSH_FUNCTION((TEXT("PopulateProgramComboBox")));
    SendDlgItemMessage( m_hWnd, IDC_ERROR_POINT, CB_RESETCONTENT, 0, 0 );
    
    if (CB_ERR != SendDlgItemMessage( m_hWnd, IDC_ERROR_POINT, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(CSimpleString( IDS_NO_ERROR, g_hInstance ).String() ) ) )
    {
        CSimpleString strCurrentProgram = GetCurrentlySelectedProgram();
        if (strCurrentProgram.Length())
        {
            const int c_nSize = 24000;
            LPTSTR pszErrors = new TCHAR[c_nSize];
            if (pszErrors)
            {
                if (GetPrivateProfileString( strCurrentProgram, NULL, TEXT(""), pszErrors, c_nSize, m_strIniFileName ))
                {
                    for (LPTSTR pszCurr=pszErrors;pszCurr && *pszCurr;pszCurr += lstrlen(pszCurr)+1 )
                    {
                        if (lstrlen(pszCurr))
                        {
                            UINT nFlag = GetIniInt( strCurrentProgram, pszCurr);
                            if (nFlag)
                            {
                                LRESULT nIndex = SendDlgItemMessage( m_hWnd, IDC_ERROR_POINT, CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(pszCurr) );
                                if (CB_ERR != nIndex)
                                {
                                    SendDlgItemMessage( m_hWnd, IDC_ERROR_POINT, CB_SETITEMDATA, nIndex, nFlag );
                                }
                            }
                        }
                    }
                }
                delete[] pszErrors;
            }
        }
        SelectErrorPoint( CWiaDebugClient::GetForceFailurePoint(strCurrentProgram) );
    }
    WiaUiUtil::ModifyComboBoxDropWidth( GetDlgItem( m_hWnd, IDC_ERROR_POINT ) );
}

void CErrorMessageDialog::PopulateErrorsComboBox()
{
    SendDlgItemMessage( m_hWnd, IDC_ERROR_VALUE, CB_RESETCONTENT, 0, 0 );
    for (int i=0;i<g_ErrorMessageCount;i++)
    {
        LRESULT nIndex = SendMessage( GetDlgItem( m_hWnd, IDC_ERROR_VALUE ), CB_ADDSTRING, 0, reinterpret_cast<LPARAM>(g_ErrorMessages[i].pszName));
        if (nIndex != CB_ERR)
        {
            SendMessage( GetDlgItem( m_hWnd, IDC_ERROR_VALUE ), CB_SETITEMDATA, nIndex, g_ErrorMessages[i].hr );
        }
    }
    WiaUiUtil::ModifyComboBoxDropWidth( GetDlgItem( m_hWnd, IDC_ERROR_VALUE ) );
}

void CErrorMessageDialog::InitializeAllFields()
{
    PopulateErrorsComboBox();
    HandleErrorSelectionChange();
    PopulateProgramComboBox();
    HandleProgramsSelectionChange();
}

void CErrorMessageDialog::HandleErrorSelectionChange()
{
    CSimpleString strErrorDescription;
    LRESULT nCurIndex = SendDlgItemMessage( m_hWnd, IDC_ERROR_VALUE, CB_GETCURSEL, 0, 0 );
    if (CB_ERR != nCurIndex)
    {
        HRESULT hr = static_cast<HRESULT>(SendDlgItemMessage( m_hWnd, IDC_ERROR_VALUE, CB_GETITEMDATA, nCurIndex, 0 ));
        strErrorDescription = WiaUiUtil::GetErrorTextFromHResult( hr );
    }
    if (!strErrorDescription.Length())
    {
        m_bErrorStringProvided = false;
        strErrorDescription.LoadString( IDS_NO_SYSTEM_ERROR_MESSAGE, g_hInstance );
    }
    else
    {
        m_bErrorStringProvided = true;
    }
    strErrorDescription.SetWindowText( GetDlgItem( m_hWnd, IDC_ERROR_DESCRIPTION ) );
}


void CErrorMessageDialog::HandleProgramsSelectionChange()
{
    PopulateErrorPointComboBox();
    HandlePointSelectionChange();
    SelectError( CWiaDebugClient::GetForceFailureValue(GetCurrentlySelectedProgram() ) );
    HandleErrorSelectionChange();
}


void CErrorMessageDialog::HandlePointSelectionChange()
{
    BOOL bEnable = (0 != GetCurrentComboBoxSelectionData( GetDlgItem( m_hWnd, IDC_ERROR_POINT ) ) );
    EnableWindow( GetDlgItem( m_hWnd, IDC_ERROR_VALUE ), bEnable );
    EnableWindow( GetDlgItem( m_hWnd, IDC_ERROR_VALUE_PROMPT ), bEnable );
}


void CErrorMessageDialog::OnSetError( WPARAM, LPARAM )
{
    CSimpleString strCurrentProgram = GetCurrentlySelectedProgram();
    if (strCurrentProgram.Length())
    {
        LRESULT nErrorPoint = GetCurrentComboBoxSelectionData( GetDlgItem( m_hWnd, IDC_ERROR_POINT ) );

        CWiaDebugClient::SetForceFailurePoint(strCurrentProgram,nErrorPoint);
        if (nErrorPoint)
        {
            LRESULT nErrorValue = GetCurrentComboBoxSelectionData( GetDlgItem( m_hWnd, IDC_ERROR_VALUE ) );
            CWiaDebugClient::SetForceFailureValue(strCurrentProgram,nErrorValue);
        }
        
    }
}


void CErrorMessageDialog::OnCancel( WPARAM, LPARAM )
{
    CSimpleString strCurrentProgram = GetCurrentlySelectedProgram();
    WritePrivateProfileString( GENERAL_SECTION, LAST_PROGRAM, strCurrentProgram, m_strIniFileName );
    EndDialog( m_hWnd, IDCANCEL );
}


void CErrorMessageDialog::OnErrorsSelChange( WPARAM, LPARAM )
{
    HandleErrorSelectionChange();
}


void CErrorMessageDialog::OnPointSelChange( WPARAM, LPARAM )
{
    HandlePointSelectionChange();
}


void CErrorMessageDialog::OnProgramsSelChange( WPARAM, LPARAM )
{
    HandleProgramsSelectionChange();

}


void CErrorMessageDialog::OnClearAll( WPARAM, LPARAM )
{
    for (LRESULT i=0;i<SendDlgItemMessage( m_hWnd, IDC_ERROR_PROGRAMS, CB_GETCOUNT, 0, 0 );i++)
    {
        CSimpleString strCurrProgram = GetComboBoxString( GetDlgItem( m_hWnd, IDC_ERROR_PROGRAMS ), i );
        if (strCurrProgram.Length())
        {
            CWiaDebugClient::SetForceFailurePoint(strCurrProgram,0);
            CWiaDebugClient::SetForceFailureValue(strCurrProgram,0);
        }
    }
    InitializeAllFields();
}


void CErrorMessageDialog::OnRefresh( WPARAM, LPARAM )
{
    InitializeAllFields();
}


LRESULT CErrorMessageDialog::OnInitDialog( WPARAM, LPARAM )
{
    SendMessage( m_hWnd, WM_SETICON, ICON_SMALL, reinterpret_cast<LPARAM>(LoadImage(g_hInstance,MAKEINTRESOURCE(IDI_FORCEERR), IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), LR_DEFAULTCOLOR) ));
    SendMessage( m_hWnd, WM_SETICON, ICON_BIG, reinterpret_cast<LPARAM>(LoadImage(g_hInstance,MAKEINTRESOURCE(IDI_FORCEERR), IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), LR_DEFAULTCOLOR) ));
    InitializeAllFields();
    return TRUE;
}

LRESULT CErrorMessageDialog::OnDestroy( WPARAM, LPARAM )
{
    return 0;
}

LRESULT CErrorMessageDialog::OnCtlColorStatic( WPARAM wParam, LPARAM lParam )
{
    LRESULT lRes = DefWindowProc( m_hWnd, WM_CTLCOLORSTATIC, wParam, lParam );
    if (reinterpret_cast<HWND>(lParam) == GetDlgItem( m_hWnd, IDC_ERROR_DESCRIPTION ))
    {
        if (!m_bErrorStringProvided)
        {
            SetTextColor( reinterpret_cast<HDC>(wParam), RGB(255,0,0) );
        }
    }
    return lRes;
}


LRESULT CErrorMessageDialog::OnCommand( WPARAM wParam, LPARAM lParam )
{
    SC_BEGIN_COMMAND_HANDLERS()
    {
        SC_HANDLE_COMMAND(IDCANCEL,OnCancel);
        SC_HANDLE_COMMAND(IDC_SET_ERROR,OnSetError);
        SC_HANDLE_COMMAND(IDC_REFRESH,OnRefresh);
        SC_HANDLE_COMMAND(IDC_CLEAR_ALL,OnClearAll);
        SC_HANDLE_COMMAND_NOTIFY(CBN_SELCHANGE,IDC_ERROR_POINT,OnPointSelChange);
        SC_HANDLE_COMMAND_NOTIFY(CBN_SELCHANGE,IDC_ERROR_VALUE,OnErrorsSelChange);
        SC_HANDLE_COMMAND_NOTIFY(CBN_SELCHANGE,IDC_ERROR_PROGRAMS,OnProgramsSelChange);
    }
    SC_END_COMMAND_HANDLERS();
}


INT_PTR __stdcall CErrorMessageDialog::DialogProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    SC_BEGIN_DIALOG_MESSAGE_HANDLERS(CErrorMessageDialog)
    {
        SC_HANDLE_DIALOG_MESSAGE( WM_INITDIALOG, OnInitDialog );
        SC_HANDLE_DIALOG_MESSAGE( WM_CTLCOLORSTATIC, OnCtlColorStatic );
        SC_HANDLE_DIALOG_MESSAGE( WM_DESTROY, OnDestroy );
        SC_HANDLE_DIALOG_MESSAGE( WM_COMMAND, OnCommand );
    }
    SC_END_DIALOG_MESSAGE_HANDLERS();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\unittest\forceerr\rawerror.h ===
#ifndef __RAWERROR_H_INCLUDED
#define __RAWERROR_H_INCLUDED

#include <windows.h>

struct CRawError
{
    HRESULT hr;
    LPCTSTR pszName;
};

extern const CRawError g_ErrorMessages[];
extern const int       g_ErrorMessageCount;

#endif // __RAWERROR_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\unittest\forceerr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by forceerr.rc
//
#define IDS_NO_SYSTEM_ERROR_MESSAGE     1
#define IDS_NO_ERROR                    2
#define IDD_ERROR_DIALOG                101
#define IDI_FORCEERR                    102
#define IDC_ERROR_VALUE                 1000
#define IDC_ERROR_DESCRIPTION           1001
#define IDC_SET_ERROR                   1002
#define IDC_CLEAR_ALL                   1003
#define IDC_ERROR_POINT                 1004
#define IDC_ERROR_PROGRAMS              1005
#define IDC_ERROR_VALUE_PROMPT          1006
#define IDC_REFRESH                     1007

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        103
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1007
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\unittest\prevtest\sources.inc ===
!IF 0

Copyright (c) 1989-1991 Microsoft Corporation

Module Name:

    sources.

Abstract:

    This file specifies the target component being built and the list of
    sources files needed to build that component.  Also specifies optional
    compiler switches and libraries that are unique for the component being
    built.

NOTE:   Commented description of this file is in \nt\public\oak\bin\sources.tpl

!ENDIF

#
# include the WIA global build settings
#


USE_SHFUSION = 1

!include $(PROJECT_ROOT)\ui\uienv.inc
SOURCES_USED = $(SOURCES_USED) $(PROJECT_ROOT)\ui\uienv.inc

#
# Our specific build settings
#

TARGETNAME=prevtest
TARGETTYPE=PROGRAM
TARGETPATH=obj

USE_MSVCRT = 1

INCLUDES=\
        $(INCLUDES);                                                    \
        $(PROJECT_ROOT)\ui\prevwnd

SOURCES=\
        ..\prevtest.cpp                                                 \
        ..\prevtest.rc                                                  \


TARGETLIBS=$(TARGETLIBS)\
        $(SHELL_LIB_PATH)\shfusion.lib                                  \
        $(PROJECT_ROOT)\ui\lib\$(PLATFORM_SUFFIX)\*\prevwnd.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\unittest\rotimg\rotimg.cpp ===
#include <windows.h>
#include <stdio.h>
#include <objbase.h>
#include "gdiplus.h"
#include <shlwapi.h>
#include <initguid.h>
//#include <shlwapip.h>
using namespace Gdiplus;
DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

UINT FindInDecoderList(ImageCodecInfo *pici, UINT cDecoders, LPCTSTR pszFile)
{
    LPCTSTR pszExt = PathFindExtension(pszFile);    // speed up PathMatchSpec calls
        
    // look at the list of decoders to see if this format is there
    for (UINT i = 0; i < cDecoders; i++)
    {
        if (PathMatchSpec(pszExt, pici[i].FilenameExtension))
            return i;
    }
    return (UINT)-1;    // not found!
}

class CEncoderInfo
{
public:
    Status GetDataFormatFromPath(LPCWSTR pszPath, GUID *pguidFmt);
    Status GetEncoderList();
    Status GetEncoderFromFormat(const GUID *pfmt, CLSID *pclsidEncoder);
    CEncoderInfo();
    ~CEncoderInfo();

private:
    UINT _cEncoders;                    // number of encoders discovered
    ImageCodecInfo *_pici;              // array of image encoder classes
};


CEncoderInfo::CEncoderInfo()
{
    _cEncoders = 0;
    _pici = NULL;
}

CEncoderInfo::~CEncoderInfo()
{
    LocalFree (_pici);
}
Status CEncoderInfo::GetDataFormatFromPath(LPCWSTR pszPath, GUID *pguidFmt)
{
    *pguidFmt = GUID_NULL;

    Status s = GetEncoderList();
    if (Ok == s)
    {
        UINT i = FindInDecoderList(_pici, _cEncoders, pszPath);
        if (-1 != i)
        {
            *pguidFmt = _pici[i].FormatID;            
        }
        else
        {
            s = GenericError;
        }
    }
    return s;
}

Status CEncoderInfo::GetEncoderList()
{
    Status s = Ok;
    if (!_pici)
    {
        // lets pick up the list of encoders, first we get the encoder size which
        // gives us the CB and the number of encoders that are installed on the
        // machine.

        UINT cb;
        s = GetImageEncodersSize(&_cEncoders, &cb);
        if (Ok == s)
        {
            // allocate the buffer for the encoders and then fill it
            // with the encoder list.

            _pici = (ImageCodecInfo*)LocalAlloc(LPTR, cb);
            if (_pici)
            {
                s = GetImageEncoders(_cEncoders, cb, _pici);
                if (Ok != s)
                {
                    LocalFree(_pici);
                    _pici = NULL;
                }
            }
            else
            {
                s = OutOfMemory;
            }
        }
    }
    return s;
}


Status CEncoderInfo::GetEncoderFromFormat(const GUID *pfmt, CLSID *pclsidEncoder)
{
    Status s = GetEncoderList();
    if (Ok == s)
    {
        s = GenericError;
        for (UINT i = 0; i != _cEncoders; i++)
        {
            if (_pici[i].FormatID == *pfmt)
            {
                if (pclsidEncoder)
                {
                    *pclsidEncoder = _pici[i].Clsid; // return the CLSID of the encoder so we can create again
                }
                s = Ok;
                break;
            }
        }
    }
    return s;
}

void AddEncParameter(EncoderParameters *pep, GUID guidProperty, ULONG type, void *pv)
{
    pep->Parameter[pep->Count].Guid = guidProperty;
    pep->Parameter[pep->Count].Type = type;
    pep->Parameter[pep->Count].NumberOfValues = 1;
    pep->Parameter[pep->Count].Value = pv;
    pep->Count++;
}

class CGraphicsInit
{
    ULONG_PTR _token;
public:
    CGraphicsInit()
    {
        GdiplusStartupInput gsi;
        GdiplusStartupOutput gso;
        GdiplusStartup(&_token, &gsi, &gso);
    };
    ~CGraphicsInit()
    {
        GdiplusShutdown(_token);
    };

};



int __cdecl wmain(int argc, LPCWSTR argv[])
{
    if (argc < 2)
    {
        printf("Usage: rotimg <filename> <targetfile>\n");       
    }
    else
    {
        CGraphicsInit cgi;
        LPCWSTR szSrc = argv[1];
        LPCWSTR szSave = argc > 2 ? argv[2] : argv[1];
        Status s;
        printf("Source image: %ls, Target image: %ls\n", szSrc, szSave);
        Image *pimg = new Image(szSrc, TRUE);
        s = pimg->GetLastStatus();
        if (Ok != s)
        {
            printf("Error %d constructing Image\n", s);
        }
        UINT nPages = pimg->GetFrameCount(&FrameDimensionPage);
        Image *pimgWork = pimg->Clone();
        
        
        s = pimgWork->RotateFlip(Rotate90FlipNone);
        if (Ok != s)
        {
            printf("RotateFlip returned %d\n", s);
        }
        else
        {
            IStream *pstrm;
            SHCreateStreamOnFileEx(szSave, STGM_WRITE | STGM_CREATE, 0, TRUE, NULL, &pstrm);

            CEncoderInfo cei;
            GUID guidFmt;
            CLSID clsidEncoder;
            cei.GetDataFormatFromPath(szSave, &guidFmt);
            cei.GetEncoderFromFormat(&guidFmt, &clsidEncoder);
            EncoderParameters ep[1] = {0};
            ULONG flagValueMulti = nPages > 1 ? EncoderValueMultiFrame : EncoderValueLastFrame;
            AddEncParameter(ep, EncoderSaveFlag, EncoderParameterValueTypeLong, &flagValueMulti);
            pimgWork->SelectActiveFrame(&FrameDimensionPage, 0);
            s = pimgWork->Save(pstrm,&clsidEncoder, ep);
            printf("first Save returned %d\n", s);
            if (Ok == s && nPages > 1)
            {
                EncoderParameters ep[2] = {0};
                ULONG flagValueDim = EncoderValueFrameDimensionPage;
                ULONG flagValueLastFrame = EncoderValueLastFrame;
                pimg->SelectActiveFrame(&FrameDimensionPage, 1);
                AddEncParameter(ep, EncoderSaveFlag, EncoderParameterValueTypeLong, &flagValueDim);
                AddEncParameter(ep, EncoderSaveFlag, EncoderParameterValueTypeLong, &flagValueLastFrame);
                s = pimgWork->SaveAdd(pimg, ep);
                printf("SaveAdd returned %d\n", s);
            }
            pstrm->Release();
        }
        delete pimg;
        delete pimgWork;
    }
    printf("Rotimg complete\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\unittest\prevtest\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by prevtest.rc
//
#define IDB_COLOR                       1
#define IDD_TESTDLG                     102
#define IDB_GRAY                        103
#define IDB_BW                          104
#define IDD_GETXYDLG                    105
#define IDC_PREVIEW                     1000
#define IDC_BW                          1001
#define IDC_GRAY                        1002
#define IDC_COLOR                       1003
#define IDC_BORDER                      1004
#define IDC_SIZINGHANDLESTEXT           1005
#define IDC_SIZINGHANDLES               1006
#define IDC_ALPHAVALUE                  1007
#define IDC_ALPHAVALUETEXT              1008
#define IDC_BORDERTEXT                  1009
#define IDC_DISABLED                    1010
#define IDC_ROUNDHANDLES                1011
#define IDC_ORIGIN                      1012
#define IDC_EXTENT                      1013
#define IDC_NOIMAGE                     1014
#define IDC_PREVIEWMODE                 1015
#define IDC_NULLSELECTION               1016
#define IDC_DISABLESELECTION            1017
#define IDC_INNERCOLOR                  1019
#define IDC_OUTERCOLOR                  1020
#define IDC_SOLIDSELECTION              1021
#define IDC_SELECTEDBORDERCOLOR         1022
#define IDC_UNSELECTEDBORDERCOLOR       1023
#define IDC_DISABLEBORDERCOLOR          1024
#define IDC_HOLLOWHANDLE                1025
#define IDC_SELECTEDHANDLECOLOR         1026
#define IDC_UNSELECTEDHANDLECOLOR       1027
#define IDC_DISABLEHANDLECOLOR          1028
#define IDC_DOUBLEWIDTH                 1029
#define IDC_SETORIGIN                   1030
#define IDC_SETEXTENT                   1031
#define IDC_X                           1031
#define IDC_Y                           1032
#define IDC_SETPROGRESS                 1032
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        107
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1034
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\unittest\forceerr\rawerror.cpp ===
#include <windows.h>
#include <wia.h>
#include "rawerror.h"

#define MAKE_ERROR(x) { x, TEXT(#x) }

const CRawError g_ErrorMessages[] =
{
    MAKE_ERROR(CACHE_E_NOCACHE_UPDATED),
    MAKE_ERROR(CACHE_S_FORMATETC_NOTSUPPORTED),
    MAKE_ERROR(CACHE_S_SAMECACHE),
    MAKE_ERROR(CACHE_S_SOMECACHES_NOTUPDATED),
    MAKE_ERROR(CAT_E_CATIDNOEXIST),
    MAKE_ERROR(CAT_E_NODESCRIPTION),
    MAKE_ERROR(CERTSRV_E_BAD_REQUESTSTATUS),
    MAKE_ERROR(CERTSRV_E_BAD_REQUESTSUBJECT),
    MAKE_ERROR(CERTSRV_E_NO_REQUEST),
    MAKE_ERROR(CERTSRV_E_PROPERTY_EMPTY),
    MAKE_ERROR(CERT_E_CHAINING),
    MAKE_ERROR(CERT_E_CN_NO_MATCH),
    MAKE_ERROR(CERT_E_CRITICAL),
    MAKE_ERROR(CERT_E_EXPIRED),
    MAKE_ERROR(CERT_E_ISSUERCHAINING),
    MAKE_ERROR(CERT_E_MALFORMED),
    MAKE_ERROR(CERT_E_PATHLENCONST),
    MAKE_ERROR(CERT_E_PURPOSE),
    MAKE_ERROR(CERT_E_REVOCATION_FAILURE),
    MAKE_ERROR(CERT_E_REVOKED),
    MAKE_ERROR(CERT_E_ROLE),
    MAKE_ERROR(CERT_E_UNTRUSTEDROOT),
    MAKE_ERROR(CERT_E_UNTRUSTEDTESTROOT),
    MAKE_ERROR(CERT_E_VALIDITYPERIODNESTING),
    MAKE_ERROR(CERT_E_WRONG_USAGE),
    MAKE_ERROR(CLASS_E_CLASSNOTAVAILABLE),
    MAKE_ERROR(CLASS_E_NOAGGREGATION),
    MAKE_ERROR(CLASS_E_NOTLICENSED),
    MAKE_ERROR(CLIPBRD_E_BAD_DATA),
    MAKE_ERROR(CLIPBRD_E_CANT_CLOSE),
    MAKE_ERROR(CLIPBRD_E_CANT_EMPTY),
    MAKE_ERROR(CLIPBRD_E_CANT_OPEN),
    MAKE_ERROR(CLIPBRD_E_CANT_SET),
    MAKE_ERROR(CONVERT10_E_OLESTREAM_BITMAP_TO_DIB),
    MAKE_ERROR(CONVERT10_E_OLESTREAM_FMT),
    MAKE_ERROR(CONVERT10_E_OLESTREAM_GET),
    MAKE_ERROR(CONVERT10_E_OLESTREAM_PUT),
    MAKE_ERROR(CONVERT10_E_STG_DIB_TO_BITMAP),
    MAKE_ERROR(CONVERT10_E_STG_FMT),
    MAKE_ERROR(CONVERT10_E_STG_NO_STD_STREAM),
    MAKE_ERROR(CONVERT10_S_NO_PRESENTATION),
    MAKE_ERROR(CO_E_ACCESSCHECKFAILED),
    MAKE_ERROR(CO_E_ACESINWRONGORDER),
    MAKE_ERROR(CO_E_ACNOTINITIALIZED),
    MAKE_ERROR(CO_E_ALREADYINITIALIZED),
    MAKE_ERROR(CO_E_APPDIDNTREG),
    MAKE_ERROR(CO_E_APPNOTFOUND),
    MAKE_ERROR(CO_E_APPSINGLEUSE),
    MAKE_ERROR(CO_E_BAD_PATH),
    MAKE_ERROR(CO_E_BAD_SERVER_NAME),
    MAKE_ERROR(CO_E_CANTDETERMINECLASS),
    MAKE_ERROR(CO_E_CANT_REMOTE),
    MAKE_ERROR(CO_E_CLASSSTRING),
    MAKE_ERROR(CO_E_CLASS_CREATE_FAILED),
    MAKE_ERROR(CO_E_CLSREG_INCONSISTENT),
    MAKE_ERROR(CO_E_CONVERSIONFAILED),
    MAKE_ERROR(CO_E_CREATEPROCESS_FAILURE),
    MAKE_ERROR(CO_E_DECODEFAILED),
    MAKE_ERROR(CO_E_DLLNOTFOUND),
    MAKE_ERROR(CO_E_ERRORINAPP),
    MAKE_ERROR(CO_E_ERRORINDLL),
    MAKE_ERROR(CO_E_EXCEEDSYSACLLIMIT),
    MAKE_ERROR(CO_E_FAILEDTOCLOSEHANDLE),
    MAKE_ERROR(CO_E_FAILEDTOCREATEFILE),
    MAKE_ERROR(CO_E_FAILEDTOGENUUID),
    MAKE_ERROR(CO_E_FAILEDTOGETSECCTX),
    MAKE_ERROR(CO_E_FAILEDTOGETTOKENINFO),
    MAKE_ERROR(CO_E_FAILEDTOGETWINDIR),
    MAKE_ERROR(CO_E_FAILEDTOIMPERSONATE),
    MAKE_ERROR(CO_E_FAILEDTOOPENPROCESSTOKEN),
    MAKE_ERROR(CO_E_FAILEDTOOPENTHREADTOKEN),
    MAKE_ERROR(CO_E_FAILEDTOQUERYCLIENTBLANKET),
    MAKE_ERROR(CO_E_FAILEDTOSETDACL),
    MAKE_ERROR(CO_E_IIDREG_INCONSISTENT),
    MAKE_ERROR(CO_E_IIDSTRING),
    MAKE_ERROR(CO_E_INCOMPATIBLESTREAMVERSION),
    MAKE_ERROR(CO_E_INIT_CLASS_CACHE),
    MAKE_ERROR(CO_E_INIT_MEMORY_ALLOCATOR),
    MAKE_ERROR(CO_E_INIT_ONLY_SINGLE_THREADED),
    MAKE_ERROR(CO_E_INIT_RPC_CHANNEL),
    MAKE_ERROR(CO_E_INIT_SCM_EXEC_FAILURE),
    MAKE_ERROR(CO_E_INIT_SCM_FILE_MAPPING_EXISTS),
    MAKE_ERROR(CO_E_INIT_SCM_MAP_VIEW_OF_FILE),
    MAKE_ERROR(CO_E_INIT_SCM_MUTEX_EXISTS),
    MAKE_ERROR(CO_E_INIT_SHARED_ALLOCATOR),
    MAKE_ERROR(CO_E_INIT_TLS),
    MAKE_ERROR(CO_E_INIT_TLS_CHANNEL_CONTROL),
    MAKE_ERROR(CO_E_INIT_TLS_SET_CHANNEL_CONTROL),
    MAKE_ERROR(CO_E_INIT_UNACCEPTED_USER_ALLOCATOR),
    MAKE_ERROR(CO_E_INVALIDSID),
    MAKE_ERROR(CO_E_LAUNCH_PERMSSION_DENIED),
    MAKE_ERROR(CO_E_LOOKUPACCNAMEFAILED),
    MAKE_ERROR(CO_E_LOOKUPACCSIDFAILED),
    MAKE_ERROR(CO_E_MSI_ERROR),
    MAKE_ERROR(CO_E_NETACCESSAPIFAILED),
    MAKE_ERROR(CO_E_NOMATCHINGNAMEFOUND),
    MAKE_ERROR(CO_E_NOMATCHINGSIDFOUND),
    MAKE_ERROR(CO_E_NOTINITIALIZED),
    MAKE_ERROR(CO_E_NOT_SUPPORTED),
    MAKE_ERROR(CO_E_OBJISREG),
    MAKE_ERROR(CO_E_OBJNOTCONNECTED),
    MAKE_ERROR(CO_E_OBJNOTREG),
    MAKE_ERROR(CO_E_OBJSRV_RPC_FAILURE),
    MAKE_ERROR(CO_E_OLE1DDE_DISABLED),
    MAKE_ERROR(CO_E_PATHTOOLONG),
    MAKE_ERROR(CO_E_RELEASED),
    MAKE_ERROR(CO_E_RELOAD_DLL),
    MAKE_ERROR(CO_E_REMOTE_COMMUNICATION_FAILURE),
    MAKE_ERROR(CO_E_RUNAS_CREATEPROCESS_FAILURE),
    MAKE_ERROR(CO_E_RUNAS_LOGON_FAILURE),
    MAKE_ERROR(CO_E_RUNAS_SYNTAX),
    MAKE_ERROR(CO_E_SCM_ERROR),
    MAKE_ERROR(CO_E_SCM_RPC_FAILURE),
    MAKE_ERROR(CO_E_SERVER_EXEC_FAILURE),
    MAKE_ERROR(CO_E_SERVER_START_TIMEOUT),
    MAKE_ERROR(CO_E_SERVER_STOPPING),
    MAKE_ERROR(CO_E_SETSERLHNDLFAILED),
    MAKE_ERROR(CO_E_START_SERVICE_FAILURE),
    MAKE_ERROR(CO_E_TRUSTEEDOESNTMATCHCLIENT),
    MAKE_ERROR(CO_E_WRONGOSFORAPP),
    MAKE_ERROR(CO_E_WRONGTRUSTEENAMESYNTAX),
    MAKE_ERROR(CO_E_WRONG_SERVER_IDENTITY),
    MAKE_ERROR(CO_S_NOTALLINTERFACES),
    MAKE_ERROR(CRYPT_E_ALREADY_DECRYPTED),
    MAKE_ERROR(CRYPT_E_ATTRIBUTES_MISSING),
    MAKE_ERROR(CRYPT_E_AUTH_ATTR_MISSING),
    MAKE_ERROR(CRYPT_E_BAD_ENCODE),
    MAKE_ERROR(CRYPT_E_BAD_LEN),
    MAKE_ERROR(CRYPT_E_BAD_MSG),
    MAKE_ERROR(CRYPT_E_CONTROL_TYPE),
    MAKE_ERROR(CRYPT_E_DELETED_PREV),
    MAKE_ERROR(CRYPT_E_EXISTS),
    MAKE_ERROR(CRYPT_E_FILERESIZED),
    MAKE_ERROR(CRYPT_E_FILE_ERROR),
    MAKE_ERROR(CRYPT_E_HASH_VALUE),
    MAKE_ERROR(CRYPT_E_INVALID_IA5_STRING),
    MAKE_ERROR(CRYPT_E_INVALID_INDEX),
    MAKE_ERROR(CRYPT_E_INVALID_MSG_TYPE),
    MAKE_ERROR(CRYPT_E_INVALID_NUMERIC_STRING),
    MAKE_ERROR(CRYPT_E_INVALID_PRINTABLE_STRING),
    MAKE_ERROR(CRYPT_E_INVALID_X500_STRING),
    MAKE_ERROR(CRYPT_E_ISSUER_SERIALNUMBER),
    MAKE_ERROR(CRYPT_E_MSG_ERROR),
    MAKE_ERROR(CRYPT_E_NOT_CHAR_STRING),
    MAKE_ERROR(CRYPT_E_NOT_DECRYPTED),
    MAKE_ERROR(CRYPT_E_NOT_FOUND),
    MAKE_ERROR(CRYPT_E_NOT_IN_CTL),
    MAKE_ERROR(CRYPT_E_NOT_IN_REVOCATION_DATABASE),
    MAKE_ERROR(CRYPT_E_NO_DECRYPT_CERT),
    MAKE_ERROR(CRYPT_E_NO_KEY_PROPERTY),
    MAKE_ERROR(CRYPT_E_NO_MATCH),
    MAKE_ERROR(CRYPT_E_NO_PROVIDER),
    MAKE_ERROR(CRYPT_E_NO_REVOCATION_CHECK),
    MAKE_ERROR(CRYPT_E_NO_REVOCATION_DLL),
    MAKE_ERROR(CRYPT_E_NO_SIGNER),
    MAKE_ERROR(CRYPT_E_NO_TRUSTED_SIGNER),
    MAKE_ERROR(CRYPT_E_NO_VERIFY_USAGE_CHECK),
    MAKE_ERROR(CRYPT_E_NO_VERIFY_USAGE_DLL),
    MAKE_ERROR(CRYPT_E_OID_FORMAT),
    MAKE_ERROR(CRYPT_E_OSS_ERROR),
    MAKE_ERROR(CRYPT_E_PENDING_CLOSE),
    MAKE_ERROR(CRYPT_E_RECIPIENT_NOT_FOUND),
    MAKE_ERROR(CRYPT_E_REVOCATION_OFFLINE),
    MAKE_ERROR(CRYPT_E_REVOKED),
    MAKE_ERROR(CRYPT_E_SECURITY_SETTINGS),
    MAKE_ERROR(CRYPT_E_SELF_SIGNED),
    MAKE_ERROR(CRYPT_E_SIGNER_NOT_FOUND),
    MAKE_ERROR(CRYPT_E_STREAM_INSUFFICIENT_DATA),
    MAKE_ERROR(CRYPT_E_STREAM_MSG_NOT_READY),
    MAKE_ERROR(CRYPT_E_UNEXPECTED_ENCODING),
    MAKE_ERROR(CRYPT_E_UNEXPECTED_MSG_TYPE),
    MAKE_ERROR(CRYPT_E_UNKNOWN_ALGO),
    MAKE_ERROR(CRYPT_E_VERIFY_USAGE_OFFLINE),
    MAKE_ERROR(CS_E_CLASS_NOTFOUND),
    MAKE_ERROR(CS_E_INVALID_VERSION),
    MAKE_ERROR(CS_E_NOT_DELETABLE),
    MAKE_ERROR(CS_E_NO_CLASSSTORE),
    MAKE_ERROR(CS_E_PACKAGE_NOTFOUND),
    MAKE_ERROR(DATA_S_SAMEFORMATETC),
    MAKE_ERROR(DIGSIG_E_CRYPTO),
    MAKE_ERROR(DIGSIG_E_DECODE),
    MAKE_ERROR(DIGSIG_E_ENCODE),
    MAKE_ERROR(DIGSIG_E_EXTENSIBILITY),
    MAKE_ERROR(DISP_E_ARRAYISLOCKED),
    MAKE_ERROR(DISP_E_BADCALLEE),
    MAKE_ERROR(DISP_E_BADINDEX),
    MAKE_ERROR(DISP_E_BADPARAMCOUNT),
    MAKE_ERROR(DISP_E_BADVARTYPE),
    MAKE_ERROR(DISP_E_DIVBYZERO),
    MAKE_ERROR(DISP_E_EXCEPTION),
    MAKE_ERROR(DISP_E_MEMBERNOTFOUND),
    MAKE_ERROR(DISP_E_NONAMEDARGS),
    MAKE_ERROR(DISP_E_NOTACOLLECTION),
    MAKE_ERROR(DISP_E_OVERFLOW),
    MAKE_ERROR(DISP_E_PARAMNOTFOUND),
    MAKE_ERROR(DISP_E_PARAMNOTOPTIONAL),
    MAKE_ERROR(DISP_E_TYPEMISMATCH),
    MAKE_ERROR(DISP_E_UNKNOWNINTERFACE),
    MAKE_ERROR(DISP_E_UNKNOWNLCID),
    MAKE_ERROR(DISP_E_UNKNOWNNAME),
    MAKE_ERROR(DRAGDROP_E_ALREADYREGISTERED),
    MAKE_ERROR(DRAGDROP_E_INVALIDHWND),
    MAKE_ERROR(DRAGDROP_E_NOTREGISTERED),
    MAKE_ERROR(DRAGDROP_S_CANCEL),
    MAKE_ERROR(DRAGDROP_S_DROP),
    MAKE_ERROR(DRAGDROP_S_USEDEFAULTCURSORS),
    MAKE_ERROR(DV_E_CLIPFORMAT),
    MAKE_ERROR(DV_E_DVASPECT),
    MAKE_ERROR(DV_E_DVTARGETDEVICE),
    MAKE_ERROR(DV_E_DVTARGETDEVICE_SIZE),
    MAKE_ERROR(DV_E_FORMATETC),
    MAKE_ERROR(DV_E_LINDEX),
    MAKE_ERROR(DV_E_NOIVIEWOBJECT),
    MAKE_ERROR(DV_E_STATDATA),
    MAKE_ERROR(DV_E_STGMEDIUM),
    MAKE_ERROR(DV_E_TYMED),
    MAKE_ERROR(EPT_S_CANT_CREATE),
    MAKE_ERROR(EPT_S_CANT_PERFORM_OP),
    MAKE_ERROR(EPT_S_INVALID_ENTRY),
    MAKE_ERROR(EPT_S_NOT_REGISTERED),
    MAKE_ERROR(ERROR_ACCESS_DENIED),
    MAKE_ERROR(ERROR_ACCOUNT_DISABLED),
    MAKE_ERROR(ERROR_ACCOUNT_EXPIRED),
    MAKE_ERROR(ERROR_ACCOUNT_LOCKED_OUT),
    MAKE_ERROR(ERROR_ACCOUNT_RESTRICTION),
    MAKE_ERROR(ERROR_ACTIVE_CONNECTIONS),
    MAKE_ERROR(ERROR_ADAP_HDW_ERR),
    MAKE_ERROR(ERROR_ADDRESS_ALREADY_ASSOCIATED),
    MAKE_ERROR(ERROR_ADDRESS_NOT_ASSOCIATED),
    MAKE_ERROR(ERROR_ALIAS_EXISTS),
    MAKE_ERROR(ERROR_ALLOTTED_SPACE_EXCEEDED),
    MAKE_ERROR(ERROR_ALREADY_ASSIGNED),
    MAKE_ERROR(ERROR_ALREADY_EXISTS),
    MAKE_ERROR(ERROR_ALREADY_INITIALIZED),
    MAKE_ERROR(ERROR_ALREADY_REGISTERED),
    MAKE_ERROR(ERROR_ALREADY_RUNNING_LKG),
    MAKE_ERROR(ERROR_ALREADY_WAITING),
    MAKE_ERROR(ERROR_APP_WRONG_OS),
    MAKE_ERROR(ERROR_ARENA_TRASHED),
    MAKE_ERROR(ERROR_ARITHMETIC_OVERFLOW),
    MAKE_ERROR(ERROR_ATOMIC_LOCKS_NOT_SUPPORTED),
    MAKE_ERROR(ERROR_AUTODATASEG_EXCEEDS_64k),
    MAKE_ERROR(ERROR_BADDB),
    MAKE_ERROR(ERROR_BADKEY),
    MAKE_ERROR(ERROR_BAD_ARGUMENTS),
    MAKE_ERROR(ERROR_BAD_COMMAND),
    MAKE_ERROR(ERROR_BAD_CONFIGURATION),
    MAKE_ERROR(ERROR_BAD_DESCRIPTOR_FORMAT),
    MAKE_ERROR(ERROR_BAD_DEVICE),
    MAKE_ERROR(ERROR_BAD_DEV_TYPE),
    MAKE_ERROR(ERROR_BAD_DRIVER),
    MAKE_ERROR(ERROR_BAD_DRIVER_LEVEL),
    MAKE_ERROR(ERROR_BAD_ENVIRONMENT),
    MAKE_ERROR(ERROR_BAD_EXE_FORMAT),
    MAKE_ERROR(ERROR_BAD_FORMAT),
    MAKE_ERROR(ERROR_BAD_IMPERSONATION_LEVEL),
    MAKE_ERROR(ERROR_BAD_INHERITANCE_ACL),
    MAKE_ERROR(ERROR_BAD_LENGTH),
    MAKE_ERROR(ERROR_BAD_LOGON_SESSION_STATE),
    MAKE_ERROR(ERROR_BAD_NETPATH),
    MAKE_ERROR(ERROR_BAD_NET_NAME),
    MAKE_ERROR(ERROR_BAD_NET_RESP),
    MAKE_ERROR(ERROR_BAD_PATHNAME),
    MAKE_ERROR(ERROR_BAD_PIPE),
    MAKE_ERROR(ERROR_BAD_PROFILE),
    MAKE_ERROR(ERROR_BAD_PROVIDER),
    MAKE_ERROR(ERROR_BAD_QUERY_SYNTAX),
    MAKE_ERROR(ERROR_BAD_REM_ADAP),
    MAKE_ERROR(ERROR_BAD_THREADID_ADDR),
    MAKE_ERROR(ERROR_BAD_TOKEN_TYPE),
    MAKE_ERROR(ERROR_BAD_UNIT),
    MAKE_ERROR(ERROR_BAD_USERNAME),
    MAKE_ERROR(ERROR_BAD_VALIDATION_CLASS),
    MAKE_ERROR(ERROR_BEGINNING_OF_MEDIA),
    MAKE_ERROR(ERROR_BOOT_ALREADY_ACCEPTED),
    MAKE_ERROR(ERROR_BROKEN_PIPE),
    MAKE_ERROR(ERROR_BUFFER_OVERFLOW),
    MAKE_ERROR(ERROR_BUSY),
    MAKE_ERROR(ERROR_BUSY_DRIVE),
    MAKE_ERROR(ERROR_BUS_RESET),
    MAKE_ERROR(ERROR_CALL_NOT_IMPLEMENTED),
    MAKE_ERROR(ERROR_CANCELLED),
    MAKE_ERROR(ERROR_CANCEL_VIOLATION),
    MAKE_ERROR(ERROR_CANNOT_COPY),
    MAKE_ERROR(ERROR_CANNOT_DETECT_DRIVER_FAILURE),
    MAKE_ERROR(ERROR_CANNOT_DETECT_PROCESS_ABORT),
    MAKE_ERROR(ERROR_CANNOT_FIND_WND_CLASS),
    MAKE_ERROR(ERROR_CANNOT_IMPERSONATE),
    MAKE_ERROR(ERROR_CANNOT_MAKE),
    MAKE_ERROR(ERROR_CANNOT_OPEN_PROFILE),
    MAKE_ERROR(ERROR_CANTOPEN),
    MAKE_ERROR(ERROR_CANTREAD),
    MAKE_ERROR(ERROR_CANTWRITE),
    MAKE_ERROR(ERROR_CANT_ACCESS_DOMAIN_INFO),
    MAKE_ERROR(ERROR_CANT_ACCESS_FILE),
    MAKE_ERROR(ERROR_CANT_DISABLE_MANDATORY),
    MAKE_ERROR(ERROR_CANT_EVICT_ACTIVE_NODE),
    MAKE_ERROR(ERROR_CANT_OPEN_ANONYMOUS),
    MAKE_ERROR(ERROR_CANT_RESOLVE_FILENAME),
    MAKE_ERROR(ERROR_CAN_NOT_COMPLETE),
    MAKE_ERROR(ERROR_CAN_NOT_DEL_LOCAL_WINS),
    MAKE_ERROR(ERROR_CHILD_MUST_BE_VOLATILE),
    MAKE_ERROR(ERROR_CHILD_NOT_COMPLETE),
    MAKE_ERROR(ERROR_CHILD_WINDOW_MENU),
    MAKE_ERROR(ERROR_CIRCULAR_DEPENDENCY),
    MAKE_ERROR(ERROR_CLASS_ALREADY_EXISTS),
    MAKE_ERROR(ERROR_CLASS_DOES_NOT_EXIST),
    MAKE_ERROR(ERROR_CLASS_HAS_WINDOWS),
    MAKE_ERROR(ERROR_CLIPBOARD_NOT_OPEN),
    MAKE_ERROR(ERROR_CLIPPING_NOT_SUPPORTED),
    MAKE_ERROR(ERROR_CLUSTERLOG_CHKPOINT_NOT_FOUND),
    MAKE_ERROR(ERROR_CLUSTERLOG_CORRUPT),
    MAKE_ERROR(ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE),
    MAKE_ERROR(ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE),
    MAKE_ERROR(ERROR_CLUSTERLOG_RECORD_EXCEEDS_MAXSIZE),
    MAKE_ERROR(ERROR_CLUSTER_SHUTTING_DOWN),
    MAKE_ERROR(ERROR_COMMITMENT_LIMIT),
    MAKE_ERROR(ERROR_CONNECTED_OTHER_PASSWORD),
    MAKE_ERROR(ERROR_CONNECTION_ABORTED),
    MAKE_ERROR(ERROR_CONNECTION_ACTIVE),
    MAKE_ERROR(ERROR_CONNECTION_COUNT_LIMIT),
    MAKE_ERROR(ERROR_CONNECTION_INVALID),
    MAKE_ERROR(ERROR_CONNECTION_REFUSED),
    MAKE_ERROR(ERROR_CONNECTION_UNAVAIL),
    MAKE_ERROR(ERROR_CONTINUE),
    MAKE_ERROR(ERROR_CONTROL_ID_NOT_FOUND),
    MAKE_ERROR(ERROR_CORE_RESOURCE),
    MAKE_ERROR(ERROR_COUNTER_TIMEOUT),
    MAKE_ERROR(ERROR_CRC),
    MAKE_ERROR(ERROR_CURRENT_DIRECTORY),
    MAKE_ERROR(ERROR_DATABASE_DOES_NOT_EXIST),
    MAKE_ERROR(ERROR_DATABASE_FAILURE),
    MAKE_ERROR(ERROR_DATABASE_FULL),
    MAKE_ERROR(ERROR_DC_NOT_FOUND),
    MAKE_ERROR(ERROR_DDE_FAIL),
    MAKE_ERROR(ERROR_DECRYPTION_FAILED),
    MAKE_ERROR(ERROR_DELETING_ICM_XFORM),
    MAKE_ERROR(ERROR_DEPENDENCY_ALREADY_EXISTS),
    MAKE_ERROR(ERROR_DEPENDENCY_NOT_FOUND),
    MAKE_ERROR(ERROR_DEPENDENT_RESOURCE_EXISTS),
    MAKE_ERROR(ERROR_DEPENDENT_SERVICES_RUNNING),
    MAKE_ERROR(ERROR_DESTINATION_ELEMENT_FULL),
    MAKE_ERROR(ERROR_DESTROY_OBJECT_OF_OTHER_THREAD),
    MAKE_ERROR(ERROR_DEVICE_ALREADY_REMEMBERED),
    MAKE_ERROR(ERROR_DEVICE_DOOR_OPEN),
    MAKE_ERROR(ERROR_DEVICE_IN_USE),
    MAKE_ERROR(ERROR_DEVICE_NOT_AVAILABLE),
    MAKE_ERROR(ERROR_DEVICE_NOT_CONNECTED),
    MAKE_ERROR(ERROR_DEVICE_NOT_PARTITIONED),
    MAKE_ERROR(ERROR_DEVICE_REINITIALIZATION_NEEDED),
    MAKE_ERROR(ERROR_DEVICE_REQUIRES_CLEANING),
    MAKE_ERROR(ERROR_DEV_NOT_EXIST),
    MAKE_ERROR(ERROR_DHCP_ADDRESS_CONFLICT),
    MAKE_ERROR(ERROR_DIFFERENT_SERVICE_ACCOUNT),
    MAKE_ERROR(ERROR_DIRECTORY),
    MAKE_ERROR(ERROR_DIRECT_ACCESS_HANDLE),
    MAKE_ERROR(ERROR_DIR_NOT_EMPTY),
    MAKE_ERROR(ERROR_DIR_NOT_ROOT),
    MAKE_ERROR(ERROR_DISCARDED),
    MAKE_ERROR(ERROR_DISK_CHANGE),
    MAKE_ERROR(ERROR_DISK_CORRUPT),
    MAKE_ERROR(ERROR_DISK_FULL),
    MAKE_ERROR(ERROR_DISK_OPERATION_FAILED),
    MAKE_ERROR(ERROR_DISK_RECALIBRATE_FAILED),
    MAKE_ERROR(ERROR_DISK_RESET_FAILED),
    MAKE_ERROR(ERROR_DLL_INIT_FAILED),
    MAKE_ERROR(ERROR_DLL_NOT_FOUND),
    MAKE_ERROR(ERROR_DOMAIN_CONTROLLER_EXISTS),
    MAKE_ERROR(ERROR_DOMAIN_CONTROLLER_NOT_FOUND),
    MAKE_ERROR(ERROR_DOMAIN_EXISTS),
    MAKE_ERROR(ERROR_DOMAIN_LIMIT_EXCEEDED),
    MAKE_ERROR(ERROR_DOMAIN_TRUST_INCONSISTENT),
    MAKE_ERROR(ERROR_DRIVE_LOCKED),
    MAKE_ERROR(ERROR_DRIVE_MEDIA_MISMATCH),
    MAKE_ERROR(ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS),
    MAKE_ERROR(ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED),
    MAKE_ERROR(ERROR_DS_BUSY),
    MAKE_ERROR(ERROR_DS_CANT_MOD_OBJ_CLASS),
    MAKE_ERROR(ERROR_DS_CANT_ON_NON_LEAF),
    MAKE_ERROR(ERROR_DS_CANT_ON_RDN),
    MAKE_ERROR(ERROR_DS_CROSS_DOM_MOVE_ERROR),
    MAKE_ERROR(ERROR_DS_GC_NOT_AVAILABLE),
    MAKE_ERROR(ERROR_DS_INCORRECT_ROLE_OWNER),
    MAKE_ERROR(ERROR_DS_INVALID_ATTRIBUTE_SYNTAX),
    MAKE_ERROR(ERROR_DS_MEMBERSHIP_EVALUATED_LOCALLY),
    MAKE_ERROR(ERROR_DS_NOT_INSTALLED),
    MAKE_ERROR(ERROR_DS_NO_ATTRIBUTE_OR_VALUE),
    MAKE_ERROR(ERROR_DS_NO_MORE_RIDS),
    MAKE_ERROR(ERROR_DS_NO_RIDS_ALLOCATED),
    MAKE_ERROR(ERROR_DS_OBJ_CLASS_VIOLATION),
    MAKE_ERROR(ERROR_DS_RIDMGR_INIT_ERROR),
    MAKE_ERROR(ERROR_DS_UNAVAILABLE),
    MAKE_ERROR(ERROR_DUPLICATE_SERVICE_NAME),
    MAKE_ERROR(ERROR_DUPLICATE_TAG),
    MAKE_ERROR(ERROR_DUP_DOMAINNAME),
    MAKE_ERROR(ERROR_DUP_NAME),
    MAKE_ERROR(ERROR_DYNLINK_FROM_INVALID_RING),
    MAKE_ERROR(ERROR_EAS_DIDNT_FIT),
    MAKE_ERROR(ERROR_EAS_NOT_SUPPORTED),
    MAKE_ERROR(ERROR_EA_ACCESS_DENIED),
    MAKE_ERROR(ERROR_EA_FILE_CORRUPT),
    MAKE_ERROR(ERROR_EA_LIST_INCONSISTENT),
    MAKE_ERROR(ERROR_EA_TABLE_FULL),
    MAKE_ERROR(ERROR_EMPTY),
    MAKE_ERROR(ERROR_ENCRYPTION_FAILED),
    MAKE_ERROR(ERROR_END_OF_MEDIA),
    MAKE_ERROR(ERROR_ENVVAR_NOT_FOUND),
    MAKE_ERROR(ERROR_EOM_OVERFLOW),
    MAKE_ERROR(ERROR_EVENTLOG_CANT_START),
    MAKE_ERROR(ERROR_EVENTLOG_FILE_CHANGED),
    MAKE_ERROR(ERROR_EVENTLOG_FILE_CORRUPT),
    MAKE_ERROR(ERROR_EXCEPTION_IN_SERVICE),
    MAKE_ERROR(ERROR_EXCL_SEM_ALREADY_OWNED),
    MAKE_ERROR(ERROR_EXE_MACHINE_TYPE_MISMATCH),
    MAKE_ERROR(ERROR_EXE_MARKED_INVALID),
    MAKE_ERROR(ERROR_EXTENDED_ERROR),
    MAKE_ERROR(ERROR_FAILED_SERVICE_CONTROLLER_CONNECT),
    MAKE_ERROR(ERROR_FAIL_I24),
    MAKE_ERROR(ERROR_FILEMARK_DETECTED),
    MAKE_ERROR(ERROR_FILENAME_EXCED_RANGE),
    MAKE_ERROR(ERROR_FILE_CORRUPT),
    MAKE_ERROR(ERROR_FILE_ENCRYPTED),
    MAKE_ERROR(ERROR_FILE_EXISTS),
    MAKE_ERROR(ERROR_FILE_INVALID),
    MAKE_ERROR(ERROR_FILE_NOT_ENCRYPTED),
    MAKE_ERROR(ERROR_FILE_NOT_FOUND),
    MAKE_ERROR(ERROR_FILE_OFFLINE),
    MAKE_ERROR(ERROR_FLOPPY_BAD_REGISTERS),
    MAKE_ERROR(ERROR_FLOPPY_ID_MARK_NOT_FOUND),
    MAKE_ERROR(ERROR_FLOPPY_UNKNOWN_ERROR),
    MAKE_ERROR(ERROR_FLOPPY_WRONG_CYLINDER),
    MAKE_ERROR(ERROR_FULLSCREEN_MODE),
    MAKE_ERROR(ERROR_FULL_BACKUP),
    MAKE_ERROR(ERROR_GENERIC_NOT_MAPPED),
    MAKE_ERROR(ERROR_GEN_FAILURE),
    MAKE_ERROR(ERROR_GLOBAL_ONLY_HOOK),
    MAKE_ERROR(ERROR_GRACEFUL_DISCONNECT),
    MAKE_ERROR(ERROR_GROUP_EXISTS),
    MAKE_ERROR(ERROR_GROUP_NOT_AVAILABLE),
    MAKE_ERROR(ERROR_GROUP_NOT_FOUND),
    MAKE_ERROR(ERROR_GROUP_NOT_ONLINE),
    MAKE_ERROR(ERROR_HANDLE_DISK_FULL),
    MAKE_ERROR(ERROR_HANDLE_EOF),
    MAKE_ERROR(ERROR_HOOK_NEEDS_HMOD),
    MAKE_ERROR(ERROR_HOOK_NOT_INSTALLED),
    MAKE_ERROR(ERROR_HOOK_TYPE_NOT_ALLOWED),
    MAKE_ERROR(ERROR_HOST_NODE_NOT_AVAILABLE),
    MAKE_ERROR(ERROR_HOST_NODE_NOT_GROUP_OWNER),
    MAKE_ERROR(ERROR_HOST_NODE_NOT_RESOURCE_OWNER),
    MAKE_ERROR(ERROR_HOST_UNREACHABLE),
    MAKE_ERROR(ERROR_HOTKEY_ALREADY_REGISTERED),
    MAKE_ERROR(ERROR_HOTKEY_NOT_REGISTERED),
    MAKE_ERROR(ERROR_HWNDS_HAVE_DIFF_PARENT),
    MAKE_ERROR(ERROR_ICM_NOT_ENABLED),
    MAKE_ERROR(ERROR_ILLEGAL_ELEMENT_ADDRESS),
    MAKE_ERROR(ERROR_ILL_FORMED_PASSWORD),
    MAKE_ERROR(ERROR_INCORRECT_ADDRESS),
    MAKE_ERROR(ERROR_INC_BACKUP),
    MAKE_ERROR(ERROR_INDEX_ABSENT),
    MAKE_ERROR(ERROR_INFLOOP_IN_RELOC_CHAIN),
    MAKE_ERROR(ERROR_INSTALL_FAILURE),
    MAKE_ERROR(ERROR_INSTALL_SOURCE_ABSENT),
    MAKE_ERROR(ERROR_INSTALL_SUSPEND),
    MAKE_ERROR(ERROR_INSTALL_USEREXIT),
    MAKE_ERROR(ERROR_INSUFFICIENT_BUFFER),
    MAKE_ERROR(ERROR_INTERNAL_DB_CORRUPTION),
    MAKE_ERROR(ERROR_INTERNAL_DB_ERROR),
    MAKE_ERROR(ERROR_INTERNAL_ERROR),
    MAKE_ERROR(ERROR_INVALID_ACCEL_HANDLE),
    MAKE_ERROR(ERROR_INVALID_ACCESS),
    MAKE_ERROR(ERROR_INVALID_ACCOUNT_NAME),
    MAKE_ERROR(ERROR_INVALID_ACL),
    MAKE_ERROR(ERROR_INVALID_ADDRESS),
    MAKE_ERROR(ERROR_INVALID_AT_INTERRUPT_TIME),
    MAKE_ERROR(ERROR_INVALID_BLOCK),
    MAKE_ERROR(ERROR_INVALID_BLOCK_LENGTH),
    MAKE_ERROR(ERROR_INVALID_CATEGORY),
    MAKE_ERROR(ERROR_INVALID_CLEANER),
    MAKE_ERROR(ERROR_INVALID_CMM),
    MAKE_ERROR(ERROR_INVALID_COLORSPACE),
    MAKE_ERROR(ERROR_INVALID_COMBOBOX_MESSAGE),
    MAKE_ERROR(ERROR_INVALID_COMPUTERNAME),
    MAKE_ERROR(ERROR_INVALID_CURSOR_HANDLE),
    MAKE_ERROR(ERROR_INVALID_DATA),
    MAKE_ERROR(ERROR_INVALID_DATATYPE),
    MAKE_ERROR(ERROR_INVALID_DLL),
    MAKE_ERROR(ERROR_INVALID_DOMAINNAME),
    MAKE_ERROR(ERROR_INVALID_DOMAIN_ROLE),
    MAKE_ERROR(ERROR_INVALID_DOMAIN_STATE),
    MAKE_ERROR(ERROR_INVALID_DRIVE),
    MAKE_ERROR(ERROR_INVALID_DWP_HANDLE),
    MAKE_ERROR(ERROR_INVALID_EA_HANDLE),
    MAKE_ERROR(ERROR_INVALID_EA_NAME),
    MAKE_ERROR(ERROR_INVALID_EDIT_HEIGHT),
    MAKE_ERROR(ERROR_INVALID_ENVIRONMENT),
    MAKE_ERROR(ERROR_INVALID_EVENTNAME),
    MAKE_ERROR(ERROR_INVALID_EVENT_COUNT),
    MAKE_ERROR(ERROR_INVALID_EXE_SIGNATURE),
    MAKE_ERROR(ERROR_INVALID_FIELD),
    MAKE_ERROR(ERROR_INVALID_FILTER_PROC),
    MAKE_ERROR(ERROR_INVALID_FLAGS),
    MAKE_ERROR(ERROR_INVALID_FLAG_NUMBER),
    MAKE_ERROR(ERROR_INVALID_FORM_NAME),
    MAKE_ERROR(ERROR_INVALID_FORM_SIZE),
    MAKE_ERROR(ERROR_INVALID_FUNCTION),
    MAKE_ERROR(ERROR_INVALID_GROUPNAME),
    MAKE_ERROR(ERROR_INVALID_GROUP_ATTRIBUTES),
    MAKE_ERROR(ERROR_INVALID_GW_COMMAND),
    MAKE_ERROR(ERROR_INVALID_HANDLE),
    MAKE_ERROR(ERROR_INVALID_HANDLE_STATE),
    MAKE_ERROR(ERROR_INVALID_HOOK_FILTER),
    MAKE_ERROR(ERROR_INVALID_HOOK_HANDLE),
    MAKE_ERROR(ERROR_INVALID_ICON_HANDLE),
    MAKE_ERROR(ERROR_INVALID_ID_AUTHORITY),
    MAKE_ERROR(ERROR_INVALID_INDEX),
    MAKE_ERROR(ERROR_INVALID_KEYBOARD_HANDLE),
    MAKE_ERROR(ERROR_INVALID_LB_MESSAGE),
    MAKE_ERROR(ERROR_INVALID_LEVEL),
    MAKE_ERROR(ERROR_INVALID_LIBRARY),
    MAKE_ERROR(ERROR_INVALID_LIST_FORMAT),
    MAKE_ERROR(ERROR_INVALID_LOGON_HOURS),
    MAKE_ERROR(ERROR_INVALID_LOGON_TYPE),
    MAKE_ERROR(ERROR_INVALID_MEDIA),
    MAKE_ERROR(ERROR_INVALID_MEDIA_POOL),
    MAKE_ERROR(ERROR_INVALID_MEMBER),
    MAKE_ERROR(ERROR_INVALID_MENU_HANDLE),
    MAKE_ERROR(ERROR_INVALID_MESSAGE),
    MAKE_ERROR(ERROR_INVALID_MESSAGEDEST),
    MAKE_ERROR(ERROR_INVALID_MESSAGENAME),
    MAKE_ERROR(ERROR_INVALID_MINALLOCSIZE),
    MAKE_ERROR(ERROR_INVALID_MODULETYPE),
    MAKE_ERROR(ERROR_INVALID_MONITOR_HANDLE),
    MAKE_ERROR(ERROR_INVALID_MSGBOX_STYLE),
    MAKE_ERROR(ERROR_INVALID_NAME),
    MAKE_ERROR(ERROR_INVALID_NETNAME),
    MAKE_ERROR(ERROR_INVALID_OPERATION),
    MAKE_ERROR(ERROR_INVALID_OPLOCK_PROTOCOL),
    MAKE_ERROR(ERROR_INVALID_ORDINAL),
    MAKE_ERROR(ERROR_INVALID_OWNER),
    MAKE_ERROR(ERROR_INVALID_PARAMETER),
    MAKE_ERROR(ERROR_INVALID_PASSWORD),
    MAKE_ERROR(ERROR_INVALID_PASSWORDNAME),
    MAKE_ERROR(ERROR_INVALID_PIXEL_FORMAT),
    MAKE_ERROR(ERROR_INVALID_PRIMARY_GROUP),
    MAKE_ERROR(ERROR_INVALID_PRINTER_COMMAND),
    MAKE_ERROR(ERROR_INVALID_PRINTER_NAME),
    MAKE_ERROR(ERROR_INVALID_PRINTER_STATE),
    MAKE_ERROR(ERROR_INVALID_PRINT_MONITOR),
    MAKE_ERROR(ERROR_INVALID_PRIORITY),
    MAKE_ERROR(ERROR_INVALID_PROFILE),
    MAKE_ERROR(ERROR_INVALID_SCROLLBAR_RANGE),
    MAKE_ERROR(ERROR_INVALID_SECURITY_DESCR),
    MAKE_ERROR(ERROR_INVALID_SEGDPL),
    MAKE_ERROR(ERROR_INVALID_SEGMENT_NUMBER),
    MAKE_ERROR(ERROR_INVALID_SEPARATOR_FILE),
    MAKE_ERROR(ERROR_INVALID_SERVER_STATE),
    MAKE_ERROR(ERROR_INVALID_SERVICENAME),
    MAKE_ERROR(ERROR_INVALID_SERVICE_ACCOUNT),
    MAKE_ERROR(ERROR_INVALID_SERVICE_CONTROL),
    MAKE_ERROR(ERROR_INVALID_SERVICE_LOCK),
    MAKE_ERROR(ERROR_INVALID_SHARENAME),
    MAKE_ERROR(ERROR_INVALID_SHOWWIN_COMMAND),
    MAKE_ERROR(ERROR_INVALID_SID),
    MAKE_ERROR(ERROR_INVALID_SIGNAL_NUMBER),
    MAKE_ERROR(ERROR_INVALID_SPI_VALUE),
    MAKE_ERROR(ERROR_INVALID_STACKSEG),
    MAKE_ERROR(ERROR_INVALID_STARTING_CODESEG),
    MAKE_ERROR(ERROR_INVALID_STATE),
    MAKE_ERROR(ERROR_INVALID_SUB_AUTHORITY),
    MAKE_ERROR(ERROR_INVALID_TARGET_HANDLE),
    MAKE_ERROR(ERROR_INVALID_THREAD_ID),
    MAKE_ERROR(ERROR_INVALID_TIME),
    MAKE_ERROR(ERROR_INVALID_TRANSFORM),
    MAKE_ERROR(ERROR_INVALID_USER_BUFFER),
    MAKE_ERROR(ERROR_INVALID_VERIFY_SWITCH),
    MAKE_ERROR(ERROR_INVALID_WINDOW_HANDLE),
    MAKE_ERROR(ERROR_INVALID_WINDOW_STYLE),
    MAKE_ERROR(ERROR_INVALID_WORKSTATION),
    MAKE_ERROR(ERROR_IOPL_NOT_ENABLED),
    MAKE_ERROR(ERROR_IO_DEVICE),
    MAKE_ERROR(ERROR_IO_INCOMPLETE),
    MAKE_ERROR(ERROR_IO_PENDING),
    MAKE_ERROR(ERROR_IRQ_BUSY),
    MAKE_ERROR(ERROR_IS_JOINED),
    MAKE_ERROR(ERROR_IS_JOIN_PATH),
    MAKE_ERROR(ERROR_IS_JOIN_TARGET),
    MAKE_ERROR(ERROR_IS_SUBSTED),
    MAKE_ERROR(ERROR_IS_SUBST_PATH),
    MAKE_ERROR(ERROR_IS_SUBST_TARGET),
    MAKE_ERROR(ERROR_ITERATED_DATA_EXCEEDS_64k),
    MAKE_ERROR(ERROR_JOIN_TO_JOIN),
    MAKE_ERROR(ERROR_JOIN_TO_SUBST),
    MAKE_ERROR(ERROR_JOURNAL_HOOK_SET),
    MAKE_ERROR(ERROR_KEY_DELETED),
    MAKE_ERROR(ERROR_KEY_HAS_CHILDREN),
    MAKE_ERROR(ERROR_LABEL_TOO_LONG),
    MAKE_ERROR(ERROR_LAST_ADMIN),
    MAKE_ERROR(ERROR_LB_WITHOUT_TABSTOPS),
    MAKE_ERROR(ERROR_LIBRARY_OFFLINE),
    MAKE_ERROR(ERROR_LICENSE_QUOTA_EXCEEDED),
    MAKE_ERROR(ERROR_LISTBOX_ID_NOT_FOUND),
    MAKE_ERROR(ERROR_LM_CROSS_ENCRYPTION_REQUIRED),
    MAKE_ERROR(ERROR_LOCAL_USER_SESSION_KEY),
    MAKE_ERROR(ERROR_LOCKED),
    MAKE_ERROR(ERROR_LOCK_FAILED),
    MAKE_ERROR(ERROR_LOCK_VIOLATION),
    MAKE_ERROR(ERROR_LOGIN_TIME_RESTRICTION),
    MAKE_ERROR(ERROR_LOGIN_WKSTA_RESTRICTION),
    MAKE_ERROR(ERROR_LOGON_FAILURE),
    MAKE_ERROR(ERROR_LOGON_NOT_GRANTED),
    MAKE_ERROR(ERROR_LOGON_SESSION_COLLISION),
    MAKE_ERROR(ERROR_LOGON_SESSION_EXISTS),
    MAKE_ERROR(ERROR_LOGON_TYPE_NOT_GRANTED),
    MAKE_ERROR(ERROR_LOG_FILE_FULL),
    MAKE_ERROR(ERROR_LUIDS_EXHAUSTED),
    MAKE_ERROR(ERROR_MAGAZINE_NOT_PRESENT),
    MAKE_ERROR(ERROR_MAPPED_ALIGNMENT),
    MAKE_ERROR(ERROR_MAX_THRDS_REACHED),
    MAKE_ERROR(ERROR_MEDIA_CHANGED),
    MAKE_ERROR(ERROR_MEDIA_INCOMPATIBLE),
    MAKE_ERROR(ERROR_MEDIA_NOT_AVAILABLE),
    MAKE_ERROR(ERROR_MEDIA_OFFLINE),
    MAKE_ERROR(ERROR_MEDIA_UNAVAILABLE),
    MAKE_ERROR(ERROR_MEMBERS_PRIMARY_GROUP),
    MAKE_ERROR(ERROR_MEMBER_IN_ALIAS),
    MAKE_ERROR(ERROR_MEMBER_IN_GROUP),
    MAKE_ERROR(ERROR_MEMBER_NOT_IN_ALIAS),
    MAKE_ERROR(ERROR_MEMBER_NOT_IN_GROUP),
    MAKE_ERROR(ERROR_MENU_ITEM_NOT_FOUND),
    MAKE_ERROR(ERROR_MESSAGE_SYNC_ONLY),
    MAKE_ERROR(ERROR_METAFILE_NOT_SUPPORTED),
    MAKE_ERROR(ERROR_META_EXPANSION_TOO_LONG),
    MAKE_ERROR(ERROR_MOD_NOT_FOUND),
    MAKE_ERROR(ERROR_MORE_DATA),
    MAKE_ERROR(ERROR_MORE_WRITES),
    MAKE_ERROR(ERROR_MR_MID_NOT_FOUND),
    MAKE_ERROR(ERROR_NEGATIVE_SEEK),
    MAKE_ERROR(ERROR_NESTING_NOT_ALLOWED),
    MAKE_ERROR(ERROR_NETLOGON_NOT_STARTED),
    MAKE_ERROR(ERROR_NETNAME_DELETED),
    MAKE_ERROR(ERROR_NETWORK_ACCESS_DENIED),
    MAKE_ERROR(ERROR_NETWORK_BUSY),
    MAKE_ERROR(ERROR_NETWORK_UNREACHABLE),
    MAKE_ERROR(ERROR_NET_WRITE_FAULT),
    MAKE_ERROR(ERROR_NOACCESS),
    MAKE_ERROR(ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT),
    MAKE_ERROR(ERROR_NOLOGON_SERVER_TRUST_ACCOUNT),
    MAKE_ERROR(ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT),
    MAKE_ERROR(ERROR_NONE_MAPPED),
    MAKE_ERROR(ERROR_NONPAGED_SYSTEM_RESOURCES),
    MAKE_ERROR(ERROR_NON_MDICHILD_WINDOW),
    MAKE_ERROR(ERROR_NOTIFY_ENUM_DIR),
    MAKE_ERROR(ERROR_NOT_ALL_ASSIGNED),
    MAKE_ERROR(ERROR_NOT_AUTHENTICATED),
    MAKE_ERROR(ERROR_NOT_A_REPARSE_POINT),
    MAKE_ERROR(ERROR_NOT_CHILD_WINDOW),
    MAKE_ERROR(ERROR_NOT_CONNECTED),
    MAKE_ERROR(ERROR_NOT_CONTAINER),
    MAKE_ERROR(ERROR_NOT_DOS_DISK),
    MAKE_ERROR(ERROR_NOT_EMPTY),
    MAKE_ERROR(ERROR_NOT_ENOUGH_MEMORY),
    MAKE_ERROR(ERROR_NOT_ENOUGH_QUOTA),
    MAKE_ERROR(ERROR_NOT_ENOUGH_SERVER_MEMORY),
    MAKE_ERROR(ERROR_NOT_EXPORT_FORMAT),
    MAKE_ERROR(ERROR_NOT_FOUND),
    MAKE_ERROR(ERROR_NOT_JOINED),
    MAKE_ERROR(ERROR_NOT_LOCKED),
    MAKE_ERROR(ERROR_NOT_LOGGED_ON),
    MAKE_ERROR(ERROR_NOT_LOGON_PROCESS),
    MAKE_ERROR(ERROR_NOT_OWNER),
    MAKE_ERROR(ERROR_NOT_QUORUM_CAPABLE),
    MAKE_ERROR(ERROR_NOT_QUORUM_CLASS),
    MAKE_ERROR(ERROR_NOT_READY),
    MAKE_ERROR(ERROR_NOT_REGISTRY_FILE),
    MAKE_ERROR(ERROR_NOT_SAME_DEVICE),
    MAKE_ERROR(ERROR_NOT_SUBSTED),
    MAKE_ERROR(ERROR_NOT_SUPPORTED),
    MAKE_ERROR(ERROR_NO_ASSOCIATION),
    MAKE_ERROR(ERROR_NO_BROWSER_SERVERS_FOUND),
    MAKE_ERROR(ERROR_NO_DATA),
    MAKE_ERROR(ERROR_NO_DATA_DETECTED),
    MAKE_ERROR(ERROR_NO_EFS),
    MAKE_ERROR(ERROR_NO_IMPERSONATION_TOKEN),
    MAKE_ERROR(ERROR_NO_INHERITANCE),
    MAKE_ERROR(ERROR_NO_LOGON_SERVERS),
    MAKE_ERROR(ERROR_NO_LOG_SPACE),
    MAKE_ERROR(ERROR_NO_MATCH),
    MAKE_ERROR(ERROR_NO_MEDIA_IN_DRIVE),
    MAKE_ERROR(ERROR_NO_MORE_DEVICES),
    MAKE_ERROR(ERROR_NO_MORE_FILES),
    MAKE_ERROR(ERROR_NO_MORE_ITEMS),
    MAKE_ERROR(ERROR_NO_MORE_SEARCH_HANDLES),
    MAKE_ERROR(ERROR_NO_MORE_USER_HANDLES),
    MAKE_ERROR(ERROR_NO_NETWORK),
    MAKE_ERROR(ERROR_NO_NET_OR_BAD_PATH),
    MAKE_ERROR(ERROR_NO_PROC_SLOTS),
    MAKE_ERROR(ERROR_NO_QUOTAS_FOR_ACCOUNT),
    MAKE_ERROR(ERROR_NO_RECOVERY_POLICY),
    MAKE_ERROR(ERROR_NO_RECOVERY_PROGRAM),
    MAKE_ERROR(ERROR_NO_SCROLLBARS),
    MAKE_ERROR(ERROR_NO_SECURITY_ON_OBJECT),
    MAKE_ERROR(ERROR_NO_SHUTDOWN_IN_PROGRESS),
    MAKE_ERROR(ERROR_NO_SIGNAL_SENT),
    MAKE_ERROR(ERROR_NO_SITENAME),
    MAKE_ERROR(ERROR_NO_SPOOL_SPACE),
    MAKE_ERROR(ERROR_NO_SUCH_ALIAS),
    MAKE_ERROR(ERROR_NO_SUCH_DOMAIN),
    MAKE_ERROR(ERROR_NO_SUCH_GROUP),
    MAKE_ERROR(ERROR_NO_SUCH_LOGON_SESSION),
    MAKE_ERROR(ERROR_NO_SUCH_MEMBER),
    MAKE_ERROR(ERROR_NO_SUCH_PACKAGE),
    MAKE_ERROR(ERROR_NO_SUCH_PRIVILEGE),
    MAKE_ERROR(ERROR_NO_SUCH_SITE),
    MAKE_ERROR(ERROR_NO_SUCH_USER),
    MAKE_ERROR(ERROR_NO_SYSTEM_MENU),
    MAKE_ERROR(ERROR_NO_SYSTEM_RESOURCES),
    MAKE_ERROR(ERROR_NO_TOKEN),
    MAKE_ERROR(ERROR_NO_TRACKING_SERVICE),
    MAKE_ERROR(ERROR_NO_TRUST_LSA_SECRET),
    MAKE_ERROR(ERROR_NO_TRUST_SAM_ACCOUNT),
    MAKE_ERROR(ERROR_NO_UNICODE_TRANSLATION),
    MAKE_ERROR(ERROR_NO_USER_KEYS),
    MAKE_ERROR(ERROR_NO_USER_SESSION_KEY),
    MAKE_ERROR(ERROR_NO_VOLUME_ID),
    MAKE_ERROR(ERROR_NO_VOLUME_LABEL),
    MAKE_ERROR(ERROR_NO_WILDCARD_CHARACTERS),
    MAKE_ERROR(ERROR_NT_CROSS_ENCRYPTION_REQUIRED),
    MAKE_ERROR(ERROR_NULL_LM_PASSWORD),
    MAKE_ERROR(ERROR_OBJECT_ALREADY_EXISTS),
    MAKE_ERROR(ERROR_OBJECT_IN_LIST),
    MAKE_ERROR(ERROR_OBJECT_NOT_FOUND),
    MAKE_ERROR(ERROR_OLD_WIN_VERSION),
    MAKE_ERROR(ERROR_OPEN_FAILED),
    MAKE_ERROR(ERROR_OPEN_FILES),
    MAKE_ERROR(ERROR_OPERATION_ABORTED),
    MAKE_ERROR(ERROR_OPLOCK_NOT_GRANTED),
    MAKE_ERROR(ERROR_OUTOFMEMORY),
    MAKE_ERROR(ERROR_OUT_OF_PAPER),
    MAKE_ERROR(ERROR_OUT_OF_STRUCTURES),
    MAKE_ERROR(ERROR_PAGED_SYSTEM_RESOURCES),
    MAKE_ERROR(ERROR_PAGEFILE_QUOTA),
    MAKE_ERROR(ERROR_PARTIAL_COPY),
    MAKE_ERROR(ERROR_PARTITION_FAILURE),
    MAKE_ERROR(ERROR_PASSWORD_EXPIRED),
    MAKE_ERROR(ERROR_PASSWORD_MUST_CHANGE),
    MAKE_ERROR(ERROR_PASSWORD_RESTRICTION),
    MAKE_ERROR(ERROR_PATH_BUSY),
    MAKE_ERROR(ERROR_PATH_NOT_FOUND),
    MAKE_ERROR(ERROR_PIPE_BUSY),
    MAKE_ERROR(ERROR_PIPE_CONNECTED),
    MAKE_ERROR(ERROR_PIPE_LISTENING),
    MAKE_ERROR(ERROR_PIPE_NOT_CONNECTED),
    MAKE_ERROR(ERROR_POINT_NOT_FOUND),
    MAKE_ERROR(ERROR_POPUP_ALREADY_ACTIVE),
    MAKE_ERROR(ERROR_PORT_UNREACHABLE),
    MAKE_ERROR(ERROR_POSSIBLE_DEADLOCK),
    MAKE_ERROR(ERROR_PRINTER_ALREADY_EXISTS),
    MAKE_ERROR(ERROR_PRINTER_DELETED),
    MAKE_ERROR(ERROR_PRINTER_DRIVER_ALREADY_INSTALLED),
    MAKE_ERROR(ERROR_PRINTER_DRIVER_IN_USE),
    MAKE_ERROR(ERROR_PRINTER_HAS_JOBS_QUEUED),
    MAKE_ERROR(ERROR_PRINTQ_FULL),
    MAKE_ERROR(ERROR_PRINT_CANCELLED),
    MAKE_ERROR(ERROR_PRINT_MONITOR_ALREADY_INSTALLED),
    MAKE_ERROR(ERROR_PRINT_MONITOR_IN_USE),
    MAKE_ERROR(ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED),
    MAKE_ERROR(ERROR_PRIVATE_DIALOG_INDEX),
    MAKE_ERROR(ERROR_PRIVILEGE_NOT_HELD),
    MAKE_ERROR(ERROR_PROCESS_ABORTED),
    MAKE_ERROR(ERROR_PROC_NOT_FOUND),
    MAKE_ERROR(ERROR_PRODUCT_UNINSTALLED),
    MAKE_ERROR(ERROR_PROFILE_NOT_ASSOCIATED_WITH_DEVICE),
    MAKE_ERROR(ERROR_PROFILE_NOT_FOUND),
    MAKE_ERROR(ERROR_PROTOCOL_UNREACHABLE),
    MAKE_ERROR(ERROR_QUORUMLOG_OPEN_FAILED),
    MAKE_ERROR(ERROR_QUORUM_RESOURCE),
    MAKE_ERROR(ERROR_QUORUM_RESOURCE_ONLINE_FAILED),
    MAKE_ERROR(ERROR_READ_FAULT),
    MAKE_ERROR(ERROR_REC_NON_EXISTENT),
    MAKE_ERROR(ERROR_REDIRECTOR_HAS_OPEN_HANDLES),
    MAKE_ERROR(ERROR_REDIR_PAUSED),
    MAKE_ERROR(ERROR_REGISTRY_CORRUPT),
    MAKE_ERROR(ERROR_REGISTRY_IO_FAILED),
    MAKE_ERROR(ERROR_REGISTRY_RECOVERED),
    MAKE_ERROR(ERROR_RELOC_CHAIN_XEEDS_SEGLIM),
    MAKE_ERROR(ERROR_REMOTE_SESSION_LIMIT_EXCEEDED),
    MAKE_ERROR(ERROR_REMOTE_STORAGE_MEDIA_ERROR),
    MAKE_ERROR(ERROR_REMOTE_STORAGE_NOT_ACTIVE),
    MAKE_ERROR(ERROR_REM_NOT_LIST),
    MAKE_ERROR(ERROR_REPARSE_ATTRIBUTE_CONFLICT),
    MAKE_ERROR(ERROR_REQUEST_ABORTED),
    MAKE_ERROR(ERROR_REQUEST_REFUSED),
    MAKE_ERROR(ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION),
    MAKE_ERROR(ERROR_REQ_NOT_ACCEP),
    MAKE_ERROR(ERROR_RESMON_CREATE_FAILED),
    MAKE_ERROR(ERROR_RESMON_ONLINE_FAILED),
    MAKE_ERROR(ERROR_RESOURCE_DATA_NOT_FOUND),
    MAKE_ERROR(ERROR_RESOURCE_DISABLED),
    MAKE_ERROR(ERROR_RESOURCE_LANG_NOT_FOUND),
    MAKE_ERROR(ERROR_RESOURCE_NAME_NOT_FOUND),
    MAKE_ERROR(ERROR_RESOURCE_NOT_AVAILABLE),
    MAKE_ERROR(ERROR_RESOURCE_NOT_FOUND),
    MAKE_ERROR(ERROR_RESOURCE_NOT_ONLINE),
    MAKE_ERROR(ERROR_RESOURCE_NOT_PRESENT),
    MAKE_ERROR(ERROR_RESOURCE_ONLINE),
    MAKE_ERROR(ERROR_RESOURCE_PROPERTIES_STORED),
    MAKE_ERROR(ERROR_RESOURCE_TYPE_NOT_FOUND),
    MAKE_ERROR(ERROR_RETRY),
    MAKE_ERROR(ERROR_REVISION_MISMATCH),
    MAKE_ERROR(ERROR_RING2SEG_MUST_BE_MOVABLE),
    MAKE_ERROR(ERROR_RING2_STACK_IN_USE),
    MAKE_ERROR(ERROR_RMODE_APP),
    MAKE_ERROR(ERROR_RPL_NOT_ALLOWED),
    MAKE_ERROR(ERROR_RXACT_COMMIT_FAILURE),
    MAKE_ERROR(ERROR_RXACT_INVALID_STATE),
    MAKE_ERROR(ERROR_SAME_DRIVE),
    MAKE_ERROR(ERROR_SCREEN_ALREADY_LOCKED),
    MAKE_ERROR(ERROR_SECRET_TOO_LONG),
    MAKE_ERROR(ERROR_SECTOR_NOT_FOUND),
    MAKE_ERROR(ERROR_SEEK),
    MAKE_ERROR(ERROR_SEEK_ON_DEVICE),
    MAKE_ERROR(ERROR_SEM_IS_SET),
    MAKE_ERROR(ERROR_SEM_NOT_FOUND),
    MAKE_ERROR(ERROR_SEM_OWNER_DIED),
    MAKE_ERROR(ERROR_SEM_TIMEOUT),
    MAKE_ERROR(ERROR_SEM_USER_LIMIT),
    MAKE_ERROR(ERROR_SERIAL_NO_DEVICE),
    MAKE_ERROR(ERROR_SERVER_DISABLED),
    MAKE_ERROR(ERROR_SERVER_HAS_OPEN_HANDLES),
    MAKE_ERROR(ERROR_SERVER_NOT_DISABLED),
    MAKE_ERROR(ERROR_SERVICE_ALREADY_RUNNING),
    MAKE_ERROR(ERROR_SERVICE_CANNOT_ACCEPT_CTRL),
    MAKE_ERROR(ERROR_SERVICE_DATABASE_LOCKED),
    MAKE_ERROR(ERROR_SERVICE_DEPENDENCY_DELETED),
    MAKE_ERROR(ERROR_SERVICE_DEPENDENCY_FAIL),
    MAKE_ERROR(ERROR_SERVICE_DISABLED),
    MAKE_ERROR(ERROR_SERVICE_DOES_NOT_EXIST),
    MAKE_ERROR(ERROR_SERVICE_EXISTS),
    MAKE_ERROR(ERROR_SERVICE_LOGON_FAILED),
    MAKE_ERROR(ERROR_SERVICE_MARKED_FOR_DELETE),
    MAKE_ERROR(ERROR_SERVICE_NEVER_STARTED),
    MAKE_ERROR(ERROR_SERVICE_NOT_ACTIVE),
    MAKE_ERROR(ERROR_SERVICE_NOT_FOUND),
    MAKE_ERROR(ERROR_SERVICE_NO_THREAD),
    MAKE_ERROR(ERROR_SERVICE_REQUEST_TIMEOUT),
    MAKE_ERROR(ERROR_SERVICE_SPECIFIC_ERROR),
    MAKE_ERROR(ERROR_SERVICE_START_HANG),
    MAKE_ERROR(ERROR_SESSION_CREDENTIAL_CONFLICT),
    MAKE_ERROR(ERROR_SETCOUNT_ON_BAD_LB),
    MAKE_ERROR(ERROR_SETMARK_DETECTED),
    MAKE_ERROR(ERROR_SET_NOT_FOUND),
    MAKE_ERROR(ERROR_SET_POWER_STATE_FAILED),
    MAKE_ERROR(ERROR_SET_POWER_STATE_VETOED),
    MAKE_ERROR(ERROR_SHARING_BUFFER_EXCEEDED),
    MAKE_ERROR(ERROR_SHARING_PAUSED),
    MAKE_ERROR(ERROR_SHARING_VIOLATION),
    MAKE_ERROR(ERROR_SHUTDOWN_CLUSTER),
    MAKE_ERROR(ERROR_SHUTDOWN_IN_PROGRESS),
    MAKE_ERROR(ERROR_SIGNAL_PENDING),
    MAKE_ERROR(ERROR_SIGNAL_REFUSED),
    MAKE_ERROR(ERROR_SINGLE_INSTANCE_APP),
    MAKE_ERROR(ERROR_SOME_NOT_MAPPED),
    MAKE_ERROR(ERROR_SOURCE_ELEMENT_EMPTY),
    MAKE_ERROR(ERROR_SPECIAL_ACCOUNT),
    MAKE_ERROR(ERROR_SPECIAL_GROUP),
    MAKE_ERROR(ERROR_SPECIAL_USER),
    MAKE_ERROR(ERROR_SPL_NO_ADDJOB),
    MAKE_ERROR(ERROR_SPL_NO_STARTDOC),
    MAKE_ERROR(ERROR_SPOOL_FILE_NOT_FOUND),
    MAKE_ERROR(ERROR_STACK_OVERFLOW),
    MAKE_ERROR(ERROR_STATIC_INIT),
    MAKE_ERROR(ERROR_SUBST_TO_JOIN),
    MAKE_ERROR(ERROR_SUBST_TO_SUBST),
    MAKE_ERROR(ERROR_SUCCESS),
    MAKE_ERROR(ERROR_SUCCESS_REBOOT_REQUIRED),
    MAKE_ERROR(ERROR_SUCCESS_RESTART_REQUIRED),
    MAKE_ERROR(ERROR_SWAPERROR),
    MAKE_ERROR(ERROR_SYSTEM_TRACE),
    MAKE_ERROR(ERROR_TAG_NOT_FOUND),
    MAKE_ERROR(ERROR_TAG_NOT_PRESENT),
    MAKE_ERROR(ERROR_THREAD_1_INACTIVE),
    MAKE_ERROR(ERROR_TIMEOUT),
    MAKE_ERROR(ERROR_TLW_WITH_WSCHILD),
    MAKE_ERROR(ERROR_TOKEN_ALREADY_IN_USE),
    MAKE_ERROR(ERROR_TOO_MANY_CMDS),
    MAKE_ERROR(ERROR_TOO_MANY_CONTEXT_IDS),
    MAKE_ERROR(ERROR_TOO_MANY_LINKS),
    MAKE_ERROR(ERROR_TOO_MANY_LUIDS_REQUESTED),
    MAKE_ERROR(ERROR_TOO_MANY_MODULES),
    MAKE_ERROR(ERROR_TOO_MANY_MUXWAITERS),
    MAKE_ERROR(ERROR_TOO_MANY_NAMES),
    MAKE_ERROR(ERROR_TOO_MANY_OPEN_FILES),
    MAKE_ERROR(ERROR_TOO_MANY_POSTS),
    MAKE_ERROR(ERROR_TOO_MANY_SECRETS),
    MAKE_ERROR(ERROR_TOO_MANY_SEMAPHORES),
    MAKE_ERROR(ERROR_TOO_MANY_SEM_REQUESTS),
    MAKE_ERROR(ERROR_TOO_MANY_SESS),
    MAKE_ERROR(ERROR_TOO_MANY_SIDS),
    MAKE_ERROR(ERROR_TOO_MANY_TCBS),
    MAKE_ERROR(ERROR_TRANSFORM_NOT_SUPPORTED),
    MAKE_ERROR(ERROR_TRUSTED_DOMAIN_FAILURE),
    MAKE_ERROR(ERROR_TRUSTED_RELATIONSHIP_FAILURE),
    MAKE_ERROR(ERROR_TRUST_FAILURE),
    MAKE_ERROR(ERROR_UNABLE_TO_CLEAN),
    MAKE_ERROR(ERROR_UNABLE_TO_LOCK_MEDIA),
    MAKE_ERROR(ERROR_UNABLE_TO_UNLOAD_MEDIA),
    MAKE_ERROR(ERROR_UNEXP_NET_ERR),
    MAKE_ERROR(ERROR_UNKNOWN_COMPONENT),
    MAKE_ERROR(ERROR_UNKNOWN_FEATURE),
    MAKE_ERROR(ERROR_UNKNOWN_PORT),
    MAKE_ERROR(ERROR_UNKNOWN_PRINTER_DRIVER),
    MAKE_ERROR(ERROR_UNKNOWN_PRINTPROCESSOR),
    MAKE_ERROR(ERROR_UNKNOWN_PRINT_MONITOR),
    MAKE_ERROR(ERROR_UNKNOWN_PRODUCT),
    MAKE_ERROR(ERROR_UNKNOWN_PROPERTY),
    MAKE_ERROR(ERROR_UNKNOWN_REVISION),
    MAKE_ERROR(ERROR_UNRECOGNIZED_MEDIA),
    MAKE_ERROR(ERROR_UNRECOGNIZED_VOLUME),
    MAKE_ERROR(ERROR_USER_EXISTS),
    MAKE_ERROR(ERROR_USER_MAPPED_FILE),
    MAKE_ERROR(ERROR_VC_DISCONNECTED),
    MAKE_ERROR(ERROR_WAIT_NO_CHILDREN),
    MAKE_ERROR(ERROR_WINDOW_NOT_COMBOBOX),
    MAKE_ERROR(ERROR_WINDOW_NOT_DIALOG),
    MAKE_ERROR(ERROR_WINDOW_OF_OTHER_THREAD),
    MAKE_ERROR(ERROR_WINS_INTERNAL),
    MAKE_ERROR(ERROR_WMI_ALREADY_ENABLED),
    MAKE_ERROR(ERROR_WMI_DP_FAILED),
    MAKE_ERROR(ERROR_WMI_DP_NOT_FOUND),
    MAKE_ERROR(ERROR_WMI_GUID_DISCONNECTED),
    MAKE_ERROR(ERROR_WMI_GUID_NOT_FOUND),
    MAKE_ERROR(ERROR_WMI_INSTANCE_NOT_FOUND),
    MAKE_ERROR(ERROR_WMI_INVALID_MOF),
    MAKE_ERROR(ERROR_WMI_INVALID_REGINFO),
    MAKE_ERROR(ERROR_WMI_ITEMID_NOT_FOUND),
    MAKE_ERROR(ERROR_WMI_SERVER_UNAVAILABLE),
    MAKE_ERROR(ERROR_WMI_TRY_AGAIN),
    MAKE_ERROR(ERROR_WMI_UNRESOLVED_INSTANCE_REF),
    MAKE_ERROR(ERROR_WORKING_SET_QUOTA),
    MAKE_ERROR(ERROR_WRITE_FAULT),
    MAKE_ERROR(ERROR_WRITE_PROTECT),
    MAKE_ERROR(ERROR_WRONG_DISK),
    MAKE_ERROR(ERROR_WRONG_EFS),
    MAKE_ERROR(ERROR_WRONG_PASSWORD),
    MAKE_ERROR(E_ABORT),
    MAKE_ERROR(E_ACCESSDENIED),
    MAKE_ERROR(E_FAIL),
    MAKE_ERROR(E_HANDLE),
    MAKE_ERROR(E_INVALIDARG),
    MAKE_ERROR(E_NOINTERFACE),
    MAKE_ERROR(E_NOTIMPL),
    MAKE_ERROR(E_OUTOFMEMORY),
    MAKE_ERROR(E_PENDING),
    MAKE_ERROR(E_POINTER),
    MAKE_ERROR(E_UNEXPECTED),
    MAKE_ERROR(INPLACE_E_NOTOOLSPACE),
    MAKE_ERROR(INPLACE_E_NOTUNDOABLE),
    MAKE_ERROR(INPLACE_S_TRUNCATED),
    MAKE_ERROR(MEM_E_INVALID_LINK),
    MAKE_ERROR(MEM_E_INVALID_ROOT),
    MAKE_ERROR(MEM_E_INVALID_SIZE),
    MAKE_ERROR(MK_E_CANTOPENFILE),
    MAKE_ERROR(MK_E_CONNECTMANUALLY),
    MAKE_ERROR(MK_E_ENUMERATION_FAILED),
    MAKE_ERROR(MK_E_EXCEEDEDDEADLINE),
    MAKE_ERROR(MK_E_INTERMEDIATEINTERFACENOTSUPPORTED),
    MAKE_ERROR(MK_E_INVALIDEXTENSION),
    MAKE_ERROR(MK_E_MUSTBOTHERUSER),
    MAKE_ERROR(MK_E_NEEDGENERIC),
    MAKE_ERROR(MK_E_NOINVERSE),
    MAKE_ERROR(MK_E_NOOBJECT),
    MAKE_ERROR(MK_E_NOPREFIX),
    MAKE_ERROR(MK_E_NOSTORAGE),
    MAKE_ERROR(MK_E_NOTBINDABLE),
    MAKE_ERROR(MK_E_NOTBOUND),
    MAKE_ERROR(MK_E_NO_NORMALIZED),
    MAKE_ERROR(MK_E_SYNTAX),
    MAKE_ERROR(MK_E_UNAVAILABLE),
    MAKE_ERROR(MK_S_HIM),
    MAKE_ERROR(MK_S_ME),
    MAKE_ERROR(MK_S_MONIKERALREADYREGISTERED),
    MAKE_ERROR(MK_S_REDUCED_TO_SELF),
    MAKE_ERROR(MK_S_US),
    MAKE_ERROR(NOERROR),
    MAKE_ERROR(NO_ERROR),
    MAKE_ERROR(NTE_BAD_ALGID),
    MAKE_ERROR(NTE_BAD_DATA),
    MAKE_ERROR(NTE_BAD_FLAGS),
    MAKE_ERROR(NTE_BAD_HASH),
    MAKE_ERROR(NTE_BAD_HASH_STATE),
    MAKE_ERROR(NTE_BAD_KEY),
    MAKE_ERROR(NTE_BAD_KEYSET),
    MAKE_ERROR(NTE_BAD_KEYSET_PARAM),
    MAKE_ERROR(NTE_BAD_KEY_STATE),
    MAKE_ERROR(NTE_BAD_LEN),
    MAKE_ERROR(NTE_BAD_PROVIDER),
    MAKE_ERROR(NTE_BAD_PROV_TYPE),
    MAKE_ERROR(NTE_BAD_PUBLIC_KEY),
    MAKE_ERROR(NTE_BAD_SIGNATURE),
    MAKE_ERROR(NTE_BAD_TYPE),
    MAKE_ERROR(NTE_BAD_UID),
    MAKE_ERROR(NTE_BAD_VER),
    MAKE_ERROR(NTE_DOUBLE_ENCRYPT),
    MAKE_ERROR(NTE_EXISTS),
    MAKE_ERROR(NTE_FAIL),
    MAKE_ERROR(NTE_KEYSET_ENTRY_BAD),
    MAKE_ERROR(NTE_KEYSET_NOT_DEF),
    MAKE_ERROR(NTE_NOT_FOUND),
    MAKE_ERROR(NTE_NO_KEY),
    MAKE_ERROR(NTE_NO_MEMORY),
    MAKE_ERROR(NTE_OP_OK),
    MAKE_ERROR(NTE_PERM),
    MAKE_ERROR(NTE_PROVIDER_DLL_FAIL),
    MAKE_ERROR(NTE_PROV_DLL_NOT_FOUND),
    MAKE_ERROR(NTE_PROV_TYPE_ENTRY_BAD),
    MAKE_ERROR(NTE_PROV_TYPE_NOT_DEF),
    MAKE_ERROR(NTE_PROV_TYPE_NO_MATCH),
    MAKE_ERROR(NTE_SIGNATURE_FILE_BAD),
    MAKE_ERROR(NTE_SYS_ERR),
    MAKE_ERROR(OLEOBJ_E_INVALIDVERB),
    MAKE_ERROR(OLEOBJ_E_NOVERBS),
    MAKE_ERROR(OLEOBJ_S_CANNOT_DOVERB_NOW),
    MAKE_ERROR(OLEOBJ_S_INVALIDHWND),
    MAKE_ERROR(OLEOBJ_S_INVALIDVERB),
    MAKE_ERROR(OLE_E_ADVF),
    MAKE_ERROR(OLE_E_ADVISENOTSUPPORTED),
    MAKE_ERROR(OLE_E_BLANK),
    MAKE_ERROR(OLE_E_CANTCONVERT),
    MAKE_ERROR(OLE_E_CANT_BINDTOSOURCE),
    MAKE_ERROR(OLE_E_CANT_GETMONIKER),
    MAKE_ERROR(OLE_E_CLASSDIFF),
    MAKE_ERROR(OLE_E_ENUM_NOMORE),
    MAKE_ERROR(OLE_E_INVALIDHWND),
    MAKE_ERROR(OLE_E_INVALIDRECT),
    MAKE_ERROR(OLE_E_NOCACHE),
    MAKE_ERROR(OLE_E_NOCONNECTION),
    MAKE_ERROR(OLE_E_NOSTORAGE),
    MAKE_ERROR(OLE_E_NOTRUNNING),
    MAKE_ERROR(OLE_E_NOT_INPLACEACTIVE),
    MAKE_ERROR(OLE_E_OLEVERB),
    MAKE_ERROR(OLE_E_PROMPTSAVECANCELLED),
    MAKE_ERROR(OLE_E_STATIC),
    MAKE_ERROR(OLE_E_WRONGCOMPOBJ),
    MAKE_ERROR(OLE_S_MAC_CLIPFORMAT),
    MAKE_ERROR(OLE_S_STATIC),
    MAKE_ERROR(OLE_S_USEREG),
    MAKE_ERROR(OR_INVALID_OID),
    MAKE_ERROR(OR_INVALID_OXID),
    MAKE_ERROR(OR_INVALID_SET),
    MAKE_ERROR(PERSIST_E_NOTSELFSIZING),
    MAKE_ERROR(PERSIST_E_SIZEDEFINITE),
    MAKE_ERROR(PERSIST_E_SIZEINDEFINITE),
    MAKE_ERROR(REGDB_E_CLASSNOTREG),
    MAKE_ERROR(REGDB_E_IIDNOTREG),
    MAKE_ERROR(REGDB_E_INVALIDVALUE),
    MAKE_ERROR(REGDB_E_KEYMISSING),
    MAKE_ERROR(REGDB_E_READREGDB),
    MAKE_ERROR(REGDB_E_WRITEREGDB),
    MAKE_ERROR(RPC_E_ACCESS_DENIED),
    MAKE_ERROR(RPC_E_ATTEMPTED_MULTITHREAD),
    MAKE_ERROR(RPC_E_CALL_CANCELED),
    MAKE_ERROR(RPC_E_CALL_COMPLETE),
    MAKE_ERROR(RPC_E_CALL_REJECTED),
    MAKE_ERROR(RPC_E_CANTCALLOUT_AGAIN),
    MAKE_ERROR(RPC_E_CANTCALLOUT_INASYNCCALL),
    MAKE_ERROR(RPC_E_CANTCALLOUT_INEXTERNALCALL),
    MAKE_ERROR(RPC_E_CANTCALLOUT_ININPUTSYNCCALL),
    MAKE_ERROR(RPC_E_CANTPOST_INSENDCALL),
    MAKE_ERROR(RPC_E_CANTTRANSMIT_CALL),
    MAKE_ERROR(RPC_E_CHANGED_MODE),
    MAKE_ERROR(RPC_E_CLIENT_CANTMARSHAL_DATA),
    MAKE_ERROR(RPC_E_CLIENT_CANTUNMARSHAL_DATA),
    MAKE_ERROR(RPC_E_CLIENT_DIED),
    MAKE_ERROR(RPC_E_CONNECTION_TERMINATED),
    MAKE_ERROR(RPC_E_DISCONNECTED),
    MAKE_ERROR(RPC_E_FAULT),
    MAKE_ERROR(RPC_E_INVALIDMETHOD),
    MAKE_ERROR(RPC_E_INVALID_CALLDATA),
    MAKE_ERROR(RPC_E_INVALID_DATA),
    MAKE_ERROR(RPC_E_INVALID_DATAPACKET),
    MAKE_ERROR(RPC_E_INVALID_EXTENSION),
    MAKE_ERROR(RPC_E_INVALID_HEADER),
    MAKE_ERROR(RPC_E_INVALID_IPID),
    MAKE_ERROR(RPC_E_INVALID_OBJECT),
    MAKE_ERROR(RPC_E_INVALID_OBJREF),
    MAKE_ERROR(RPC_E_INVALID_PARAMETER),
    MAKE_ERROR(RPC_E_NOT_REGISTERED),
    MAKE_ERROR(RPC_E_NO_CONTEXT),
    MAKE_ERROR(RPC_E_NO_GOOD_SECURITY_PACKAGES),
    MAKE_ERROR(RPC_E_NO_SYNC),
    MAKE_ERROR(RPC_E_OUT_OF_RESOURCES),
    MAKE_ERROR(RPC_E_REMOTE_DISABLED),
    MAKE_ERROR(RPC_E_RETRY),
    MAKE_ERROR(RPC_E_SERVERCALL_REJECTED),
    MAKE_ERROR(RPC_E_SERVERCALL_RETRYLATER),
    MAKE_ERROR(RPC_E_SERVERFAULT),
    MAKE_ERROR(RPC_E_SERVER_CANTMARSHAL_DATA),
    MAKE_ERROR(RPC_E_SERVER_CANTUNMARSHAL_DATA),
    MAKE_ERROR(RPC_E_SERVER_DIED),
    MAKE_ERROR(RPC_E_SERVER_DIED_DNE),
    MAKE_ERROR(RPC_E_SYS_CALL_FAILED),
    MAKE_ERROR(RPC_E_THREAD_NOT_INIT),
    MAKE_ERROR(RPC_E_TIMEOUT),
    MAKE_ERROR(RPC_E_TOO_LATE),
    MAKE_ERROR(RPC_E_UNEXPECTED),
    MAKE_ERROR(RPC_E_UNSECURE_CALL),
    MAKE_ERROR(RPC_E_VERSION_MISMATCH),
    MAKE_ERROR(RPC_E_WRONG_THREAD),
    MAKE_ERROR(RPC_S_ADDRESS_ERROR),
    MAKE_ERROR(RPC_S_ALREADY_LISTENING),
    MAKE_ERROR(RPC_S_ALREADY_REGISTERED),
    MAKE_ERROR(RPC_S_BINDING_HAS_NO_AUTH),
    MAKE_ERROR(RPC_S_BINDING_INCOMPLETE),
    MAKE_ERROR(RPC_S_CALLPENDING),
    MAKE_ERROR(RPC_S_CALL_CANCELLED),
    MAKE_ERROR(RPC_S_CALL_FAILED),
    MAKE_ERROR(RPC_S_CALL_FAILED_DNE),
    MAKE_ERROR(RPC_S_CALL_IN_PROGRESS),
    MAKE_ERROR(RPC_S_CANNOT_SUPPORT),
    MAKE_ERROR(RPC_S_CANT_CREATE_ENDPOINT),
    MAKE_ERROR(RPC_S_COMM_FAILURE),
    MAKE_ERROR(RPC_S_DUPLICATE_ENDPOINT),
    MAKE_ERROR(RPC_S_ENTRY_ALREADY_EXISTS),
    MAKE_ERROR(RPC_S_ENTRY_NOT_FOUND),
    MAKE_ERROR(RPC_S_FP_DIV_ZERO),
    MAKE_ERROR(RPC_S_FP_OVERFLOW),
    MAKE_ERROR(RPC_S_FP_UNDERFLOW),
    MAKE_ERROR(RPC_S_GROUP_MEMBER_NOT_FOUND),
    MAKE_ERROR(RPC_S_INCOMPLETE_NAME),
    MAKE_ERROR(RPC_S_INTERFACE_NOT_FOUND),
    MAKE_ERROR(RPC_S_INTERNAL_ERROR),
    MAKE_ERROR(RPC_S_INVALID_ASYNC_CALL),
    MAKE_ERROR(RPC_S_INVALID_ASYNC_HANDLE),
    MAKE_ERROR(RPC_S_INVALID_AUTH_IDENTITY),
    MAKE_ERROR(RPC_S_INVALID_BINDING),
    MAKE_ERROR(RPC_S_INVALID_BOUND),
    MAKE_ERROR(RPC_S_INVALID_ENDPOINT_FORMAT),
    MAKE_ERROR(RPC_S_INVALID_NAF_ID),
    MAKE_ERROR(RPC_S_INVALID_NAME_SYNTAX),
    MAKE_ERROR(RPC_S_INVALID_NETWORK_OPTIONS),
    MAKE_ERROR(RPC_S_INVALID_NET_ADDR),
    MAKE_ERROR(RPC_S_INVALID_OBJECT),
    MAKE_ERROR(RPC_S_INVALID_RPC_PROTSEQ),
    MAKE_ERROR(RPC_S_INVALID_STRING_BINDING),
    MAKE_ERROR(RPC_S_INVALID_STRING_UUID),
    MAKE_ERROR(RPC_S_INVALID_TAG),
    MAKE_ERROR(RPC_S_INVALID_TIMEOUT),
    MAKE_ERROR(RPC_S_INVALID_VERS_OPTION),
    MAKE_ERROR(RPC_S_MAX_CALLS_TOO_SMALL),
    MAKE_ERROR(RPC_S_NAME_SERVICE_UNAVAILABLE),
    MAKE_ERROR(RPC_S_NOTHING_TO_EXPORT),
    MAKE_ERROR(RPC_S_NOT_ALL_OBJS_UNEXPORTED),
    MAKE_ERROR(RPC_S_NOT_CANCELLED),
    MAKE_ERROR(RPC_S_NOT_LISTENING),
    MAKE_ERROR(RPC_S_NOT_RPC_ERROR),
    MAKE_ERROR(RPC_S_NO_BINDINGS),
    MAKE_ERROR(RPC_S_NO_CALL_ACTIVE),
    MAKE_ERROR(RPC_S_NO_CONTEXT_AVAILABLE),
    MAKE_ERROR(RPC_S_NO_ENDPOINT_FOUND),
    MAKE_ERROR(RPC_S_NO_ENTRY_NAME),
    MAKE_ERROR(RPC_S_NO_INTERFACES),
    MAKE_ERROR(RPC_S_NO_MORE_BINDINGS),
    MAKE_ERROR(RPC_S_NO_MORE_MEMBERS),
    MAKE_ERROR(RPC_S_NO_PRINC_NAME),
    MAKE_ERROR(RPC_S_NO_PROTSEQS),
    MAKE_ERROR(RPC_S_NO_PROTSEQS_REGISTERED),
    MAKE_ERROR(RPC_S_OBJECT_NOT_FOUND),
    MAKE_ERROR(RPC_S_OUT_OF_RESOURCES),
    MAKE_ERROR(RPC_S_PROCNUM_OUT_OF_RANGE),
    MAKE_ERROR(RPC_S_PROTOCOL_ERROR),
    MAKE_ERROR(RPC_S_PROTSEQ_NOT_FOUND),
    MAKE_ERROR(RPC_S_PROTSEQ_NOT_SUPPORTED),
    MAKE_ERROR(RPC_S_SEC_PKG_ERROR),
    MAKE_ERROR(RPC_S_SEND_INCOMPLETE),
    MAKE_ERROR(RPC_S_SERVER_TOO_BUSY),
    MAKE_ERROR(RPC_S_SERVER_UNAVAILABLE),
    MAKE_ERROR(RPC_S_STRING_TOO_LONG),
    MAKE_ERROR(RPC_S_TYPE_ALREADY_REGISTERED),
    MAKE_ERROR(RPC_S_UNKNOWN_AUTHN_LEVEL),
    MAKE_ERROR(RPC_S_UNKNOWN_AUTHN_SERVICE),
    MAKE_ERROR(RPC_S_UNKNOWN_AUTHN_TYPE),
    MAKE_ERROR(RPC_S_UNKNOWN_AUTHZ_SERVICE),
    MAKE_ERROR(RPC_S_UNKNOWN_IF),
    MAKE_ERROR(RPC_S_UNKNOWN_MGR_TYPE),
    MAKE_ERROR(RPC_S_UNSUPPORTED_AUTHN_LEVEL),
    MAKE_ERROR(RPC_S_UNSUPPORTED_NAME_SYNTAX),
    MAKE_ERROR(RPC_S_UNSUPPORTED_TRANS_SYN),
    MAKE_ERROR(RPC_S_UNSUPPORTED_TYPE),
    MAKE_ERROR(RPC_S_UUID_LOCAL_ONLY),
    MAKE_ERROR(RPC_S_UUID_NO_ADDRESS),
    MAKE_ERROR(RPC_S_WAITONTIMER),
    MAKE_ERROR(RPC_S_WRONG_KIND_OF_BINDING),
    MAKE_ERROR(RPC_S_ZERO_DIVIDE),
    MAKE_ERROR(RPC_X_BAD_STUB_DATA),
    MAKE_ERROR(RPC_X_BYTE_COUNT_TOO_SMALL),
    MAKE_ERROR(RPC_X_ENUM_VALUE_OUT_OF_RANGE),
    MAKE_ERROR(RPC_X_INVALID_ES_ACTION),
    MAKE_ERROR(RPC_X_INVALID_PIPE_OBJECT),
    MAKE_ERROR(RPC_X_NO_MORE_ENTRIES),
    MAKE_ERROR(RPC_X_NULL_REF_POINTER),
    MAKE_ERROR(RPC_X_PIPE_CLOSED),
    MAKE_ERROR(RPC_X_PIPE_DISCIPLINE_ERROR),
    MAKE_ERROR(RPC_X_PIPE_EMPTY),
    MAKE_ERROR(RPC_X_SS_CANNOT_GET_CALL_HANDLE),
    MAKE_ERROR(RPC_X_SS_CHAR_TRANS_OPEN_FAIL),
    MAKE_ERROR(RPC_X_SS_CHAR_TRANS_SHORT_FILE),
    MAKE_ERROR(RPC_X_SS_CONTEXT_DAMAGED),
    MAKE_ERROR(RPC_X_SS_HANDLES_MISMATCH),
    MAKE_ERROR(RPC_X_SS_IN_NULL_CONTEXT),
    MAKE_ERROR(RPC_X_WRONG_ES_VERSION),
    MAKE_ERROR(RPC_X_WRONG_PIPE_ORDER),
    MAKE_ERROR(RPC_X_WRONG_PIPE_VERSION),
    MAKE_ERROR(RPC_X_WRONG_STUB_VERSION),
    MAKE_ERROR(SPAPI_E_BAD_INTERFACE_INSTALLSECT),
    MAKE_ERROR(SPAPI_E_BAD_SECTION_NAME_LINE),
    MAKE_ERROR(SPAPI_E_BAD_SERVICE_INSTALLSECT),
    MAKE_ERROR(SPAPI_E_CANT_LOAD_CLASS_ICON),
    MAKE_ERROR(SPAPI_E_CLASS_MISMATCH),
    MAKE_ERROR(SPAPI_E_DEVICE_INTERFACE_ACTIVE),
    MAKE_ERROR(SPAPI_E_DEVICE_INTERFACE_REMOVED),
    MAKE_ERROR(SPAPI_E_DEVINFO_DATA_LOCKED),
    MAKE_ERROR(SPAPI_E_DEVINFO_LIST_LOCKED),
    MAKE_ERROR(SPAPI_E_DEVINFO_NOT_REGISTERED),
    MAKE_ERROR(SPAPI_E_DEVINST_ALREADY_EXISTS),
    MAKE_ERROR(SPAPI_E_DI_BAD_PATH),
    MAKE_ERROR(SPAPI_E_DI_DONT_INSTALL),
    MAKE_ERROR(SPAPI_E_DI_DO_DEFAULT),
    MAKE_ERROR(SPAPI_E_DI_NOFILECOPY),
    MAKE_ERROR(SPAPI_E_DI_POSTPROCESSING_REQUIRED),
    MAKE_ERROR(SPAPI_E_DUPLICATE_FOUND),
    MAKE_ERROR(SPAPI_E_ERROR_NOT_INSTALLED),
    MAKE_ERROR(SPAPI_E_EXPECTED_SECTION_NAME),
    MAKE_ERROR(SPAPI_E_FILEQUEUE_LOCKED),
    MAKE_ERROR(SPAPI_E_GENERAL_SYNTAX),
    MAKE_ERROR(SPAPI_E_INVALID_CLASS),
    MAKE_ERROR(SPAPI_E_INVALID_CLASS_INSTALLER),
    MAKE_ERROR(SPAPI_E_INVALID_COINSTALLER),
    MAKE_ERROR(SPAPI_E_INVALID_DEVINST_NAME),
    MAKE_ERROR(SPAPI_E_INVALID_FILTER_DRIVER),
    MAKE_ERROR(SPAPI_E_INVALID_HWPROFILE),
    MAKE_ERROR(SPAPI_E_INVALID_INF_LOGCONFIG),
    MAKE_ERROR(SPAPI_E_INVALID_MACHINENAME),
    MAKE_ERROR(SPAPI_E_INVALID_PROPPAGE_PROVIDER),
    MAKE_ERROR(SPAPI_E_INVALID_REFERENCE_STRING),
    MAKE_ERROR(SPAPI_E_INVALID_REG_PROPERTY),
    MAKE_ERROR(SPAPI_E_KEY_DOES_NOT_EXIST),
    MAKE_ERROR(SPAPI_E_LINE_NOT_FOUND),
    MAKE_ERROR(SPAPI_E_MACHINE_UNAVAILABLE),
    MAKE_ERROR(SPAPI_E_NO_ASSOCIATED_CLASS),
    MAKE_ERROR(SPAPI_E_NO_ASSOCIATED_SERVICE),
    MAKE_ERROR(SPAPI_E_NO_CLASSINSTALL_PARAMS),
    MAKE_ERROR(SPAPI_E_NO_CLASS_DRIVER_LIST),
    MAKE_ERROR(SPAPI_E_NO_COMPAT_DRIVERS),
    MAKE_ERROR(SPAPI_E_NO_CONFIGMGR_SERVICES),
    MAKE_ERROR(SPAPI_E_NO_DEFAULT_DEVICE_INTERFACE),
    MAKE_ERROR(SPAPI_E_NO_DEVICE_ICON),
    MAKE_ERROR(SPAPI_E_NO_DEVICE_SELECTED),
    MAKE_ERROR(SPAPI_E_NO_DRIVER_SELECTED),
    MAKE_ERROR(SPAPI_E_NO_INF),
    MAKE_ERROR(SPAPI_E_NO_SUCH_DEVICE_INTERFACE),
    MAKE_ERROR(SPAPI_E_NO_SUCH_DEVINST),
    MAKE_ERROR(SPAPI_E_NO_SUCH_INTERFACE_CLASS),
    MAKE_ERROR(SPAPI_E_REMOTE_COMM_FAILURE),
    MAKE_ERROR(SPAPI_E_SECTION_NAME_TOO_LONG),
    MAKE_ERROR(SPAPI_E_SECTION_NOT_FOUND),
    MAKE_ERROR(SPAPI_E_WRONG_INF_STYLE),
    MAKE_ERROR(STG_E_ABNORMALAPIEXIT),
    MAKE_ERROR(STG_E_ACCESSDENIED),
    MAKE_ERROR(STG_E_BADBASEADDRESS),
    MAKE_ERROR(STG_E_CANTSAVE),
    MAKE_ERROR(STG_E_DISKISWRITEPROTECTED),
    MAKE_ERROR(STG_E_DOCFILECORRUPT),
    MAKE_ERROR(STG_E_EXTANTMARSHALLINGS),
    MAKE_ERROR(STG_E_FILEALREADYEXISTS),
    MAKE_ERROR(STG_E_FILENOTFOUND),
    MAKE_ERROR(STG_E_INCOMPLETE),
    MAKE_ERROR(STG_E_INSUFFICIENTMEMORY),
    MAKE_ERROR(STG_E_INUSE),
    MAKE_ERROR(STG_E_INVALIDFLAG),
    MAKE_ERROR(STG_E_INVALIDFUNCTION),
    MAKE_ERROR(STG_E_INVALIDHANDLE),
    MAKE_ERROR(STG_E_INVALIDHEADER),
    MAKE_ERROR(STG_E_INVALIDNAME),
    MAKE_ERROR(STG_E_INVALIDPARAMETER),
    MAKE_ERROR(STG_E_INVALIDPOINTER),
    MAKE_ERROR(STG_E_LOCKVIOLATION),
    MAKE_ERROR(STG_E_MEDIUMFULL),
    MAKE_ERROR(STG_E_NOMOREFILES),
    MAKE_ERROR(STG_E_NOTCURRENT),
    MAKE_ERROR(STG_E_NOTFILEBASEDSTORAGE),
    MAKE_ERROR(STG_E_OLDDLL),
    MAKE_ERROR(STG_E_OLDFORMAT),
    MAKE_ERROR(STG_E_PATHNOTFOUND),
    MAKE_ERROR(STG_E_PROPSETMISMATCHED),
    MAKE_ERROR(STG_E_READFAULT),
    MAKE_ERROR(STG_E_REVERTED),
    MAKE_ERROR(STG_E_SEEKERROR),
    MAKE_ERROR(STG_E_SHAREREQUIRED),
    MAKE_ERROR(STG_E_SHAREVIOLATION),
    MAKE_ERROR(STG_E_TERMINATED),
    MAKE_ERROR(STG_E_TOOMANYOPENFILES),
    MAKE_ERROR(STG_E_UNIMPLEMENTEDFUNCTION),
    MAKE_ERROR(STG_E_UNKNOWN),
    MAKE_ERROR(STG_E_WRITEFAULT),
    MAKE_ERROR(STG_S_BLOCK),
    MAKE_ERROR(STG_S_CANNOTCONSOLIDATE),
    MAKE_ERROR(STG_S_CONSOLIDATIONFAILED),
    MAKE_ERROR(STG_S_CONVERTED),
    MAKE_ERROR(STG_S_MONITORING),
    MAKE_ERROR(STG_S_MULTIPLEOPENS),
    MAKE_ERROR(STG_S_RETRYNOW),
    MAKE_ERROR(S_FALSE),
    MAKE_ERROR(S_OK),
    MAKE_ERROR(TRUST_E_ACTION_UNKNOWN),
    MAKE_ERROR(TRUST_E_BAD_DIGEST),
    MAKE_ERROR(TRUST_E_BASIC_CONSTRAINTS),
    MAKE_ERROR(TRUST_E_CERT_SIGNATURE),
    MAKE_ERROR(TRUST_E_COUNTER_SIGNER),
    MAKE_ERROR(TRUST_E_FAIL),
    MAKE_ERROR(TRUST_E_FINANCIAL_CRITERIA),
    MAKE_ERROR(TRUST_E_NOSIGNATURE),
    MAKE_ERROR(TRUST_E_NO_SIGNER_CERT),
    MAKE_ERROR(TRUST_E_PROVIDER_UNKNOWN),
    MAKE_ERROR(TRUST_E_SUBJECT_FORM_UNKNOWN),
    MAKE_ERROR(TRUST_E_SUBJECT_NOT_TRUSTED),
    MAKE_ERROR(TRUST_E_SYSTEM_ERROR),
    MAKE_ERROR(TRUST_E_TIME_STAMP),
    MAKE_ERROR(TYPE_E_AMBIGUOUSNAME),
    MAKE_ERROR(TYPE_E_BADMODULEKIND),
    MAKE_ERROR(TYPE_E_BUFFERTOOSMALL),
    MAKE_ERROR(TYPE_E_CANTCREATETMPFILE),
    MAKE_ERROR(TYPE_E_CANTLOADLIBRARY),
    MAKE_ERROR(TYPE_E_CIRCULARTYPE),
    MAKE_ERROR(TYPE_E_DLLFUNCTIONNOTFOUND),
    MAKE_ERROR(TYPE_E_DUPLICATEID),
    MAKE_ERROR(TYPE_E_ELEMENTNOTFOUND),
    MAKE_ERROR(TYPE_E_FIELDNOTFOUND),
    MAKE_ERROR(TYPE_E_INCONSISTENTPROPFUNCS),
    MAKE_ERROR(TYPE_E_INVALIDID),
    MAKE_ERROR(TYPE_E_INVALIDSTATE),
    MAKE_ERROR(TYPE_E_INVDATAREAD),
    MAKE_ERROR(TYPE_E_IOERROR),
    MAKE_ERROR(TYPE_E_LIBNOTREGISTERED),
    MAKE_ERROR(TYPE_E_NAMECONFLICT),
    MAKE_ERROR(TYPE_E_OUTOFBOUNDS),
    MAKE_ERROR(TYPE_E_QUALIFIEDNAMEDISALLOWED),
    MAKE_ERROR(TYPE_E_REGISTRYACCESS),
    MAKE_ERROR(TYPE_E_SIZETOOBIG),
    MAKE_ERROR(TYPE_E_TYPEMISMATCH),
    MAKE_ERROR(TYPE_E_UNDEFINEDTYPE),
    MAKE_ERROR(TYPE_E_UNKNOWNLCID),
    MAKE_ERROR(TYPE_E_UNSUPFORMAT),
    MAKE_ERROR(TYPE_E_WRONGTYPEKIND),
    MAKE_ERROR(VIEW_E_DRAW),
    MAKE_ERROR(WIA_ERROR_GENERAL_ERROR),
    MAKE_ERROR(WIA_ERROR_PAPER_JAM),
    MAKE_ERROR(WIA_ERROR_PAPER_EMPTY),
    MAKE_ERROR(WIA_ERROR_PAPER_PROBLEM),
    MAKE_ERROR(WIA_ERROR_OFFLINE),
    MAKE_ERROR(WIA_ERROR_BUSY),
    MAKE_ERROR(WIA_ERROR_WARMING_UP),
    MAKE_ERROR(WIA_ERROR_USER_INTERVENTION),
    MAKE_ERROR(WIA_ERROR_ITEM_DELETED),
    MAKE_ERROR(WIA_ERROR_DEVICE_COMMUNICATION),
    MAKE_ERROR(WIA_ERROR_INVALID_COMMAND),
    MAKE_ERROR(WIA_ERROR_INCORRECT_HARDWARE_SETTING),
    MAKE_ERROR(WIA_ERROR_DEVICE_LOCKED),
    MAKE_ERROR(WIA_ERROR_EXCEPTION_IN_DRIVER),
    MAKE_ERROR(WIA_ERROR_INVALID_DRIVER_RESPONSE),
    MAKE_ERROR(WIA_STATUS_END_OF_MEDIA),
    MAKE_ERROR(WIA_S_NO_DEVICE_AVAILABLE),
};
const int g_ErrorMessageCount = sizeof(g_ErrorMessages)/sizeof(g_ErrorMessages[0]);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\unittest\tagdump\tagdump.cpp ===
#include <windows.h>
#include <stdio.h>
#include <objbase.h>
#include <gdiplus.h>

struct CStringEntry
{
    ULONG       nId;
    const wchar_t *pszString;
};

#define MKFLAG(x) { (x), L#x }

const wchar_t *GetStringFromTable( const CStringEntry *pStrings, UINT nSize, ULONG nId, wchar_t *pszUnknownBuffer )
{
    for (UINT i=0;i<nSize;i++)
    {
        if (pStrings[i].nId == nId)
        {
            return pStrings[i].pszString;
        }
    }
    wsprintfW( pszUnknownBuffer, L"Unknown value: %d (0x%X)", nId, nId );
    return pszUnknownBuffer;
}

void DumpImageProperty( Gdiplus::PropertyItem* pPropertyItem )
{
    static CStringEntry s_PropertyTypes[] =
    {
        MKFLAG(PropertyTagTypeByte),
        MKFLAG(PropertyTagTypeASCII),
        MKFLAG(PropertyTagTypeShort),
        MKFLAG(PropertyTagTypeLong),
        MKFLAG(PropertyTagTypeRational),
        MKFLAG(PropertyTagTypeUndefined),
        MKFLAG(PropertyTagTypeSLONG),
        MKFLAG(PropertyTagTypeSRational)
    };
    
    static CStringEntry s_PropertyIds[] =
    {
        MKFLAG(PropertyTagArtist),
        MKFLAG(PropertyTagBitsPerSample),
        MKFLAG(PropertyTagCellHeight),
        MKFLAG(PropertyTagCellWidth),
        MKFLAG(PropertyTagChrominanceTable),
        MKFLAG(PropertyTagColorMap),
        MKFLAG(PropertyTagColorTransferFunction),
        MKFLAG(PropertyTagCompression),
        MKFLAG(PropertyTagCopyright),
        MKFLAG(PropertyTagDateTime),
        MKFLAG(PropertyTagDocumentName),
        MKFLAG(PropertyTagDotRange),
        MKFLAG(PropertyTagEquipMake),
        MKFLAG(PropertyTagEquipModel),
        MKFLAG(PropertyTagExifAperture),
        MKFLAG(PropertyTagExifBrightness),
        MKFLAG(PropertyTagExifCfaPattern),
        MKFLAG(PropertyTagExifColorSpace),
        MKFLAG(PropertyTagExifCompBPP),
        MKFLAG(PropertyTagExifCompConfig),
        MKFLAG(PropertyTagExifDTDigSS),
        MKFLAG(PropertyTagExifDTDigitized),
        MKFLAG(PropertyTagExifDTOrig),
        MKFLAG(PropertyTagExifDTOrigSS),
        MKFLAG(PropertyTagExifDTSubsec),
        MKFLAG(PropertyTagExifExposureBias),
        MKFLAG(PropertyTagExifExposureIndex),
        MKFLAG(PropertyTagExifExposureProg),
        MKFLAG(PropertyTagExifExposureTime),
        MKFLAG(PropertyTagExifFNumber),
        MKFLAG(PropertyTagExifFPXVer),
        MKFLAG(PropertyTagExifFileSource),
        MKFLAG(PropertyTagExifFlash),
        MKFLAG(PropertyTagExifFlashEnergy),
        MKFLAG(PropertyTagExifFocalLength),
        MKFLAG(PropertyTagExifFocalResUnit),
        MKFLAG(PropertyTagExifFocalXRes),
        MKFLAG(PropertyTagExifFocalYRes),
        MKFLAG(PropertyTagExifIFD),
        MKFLAG(PropertyTagExifISOSpeed),
        MKFLAG(PropertyTagExifInterop),
        MKFLAG(PropertyTagExifLightSource),
        MKFLAG(PropertyTagExifMakerNote),
        MKFLAG(PropertyTagExifMaxAperture),
        MKFLAG(PropertyTagExifMeteringMode),
        MKFLAG(PropertyTagExifOECF),
        MKFLAG(PropertyTagExifPixXDim),
        MKFLAG(PropertyTagExifPixYDim),
        MKFLAG(PropertyTagExifRelatedWav),
        MKFLAG(PropertyTagExifSceneType),
        MKFLAG(PropertyTagExifSensingMethod),
        MKFLAG(PropertyTagExifShutterSpeed),
        MKFLAG(PropertyTagExifSpatialFR),
        MKFLAG(PropertyTagExifSpectralSense),
        MKFLAG(PropertyTagExifSubjectDist),
        MKFLAG(PropertyTagExifSubjectLoc),
        MKFLAG(PropertyTagExifUserComment),
        MKFLAG(PropertyTagExifVer),
        MKFLAG(PropertyTagExtraSamples),
        MKFLAG(PropertyTagFillOrder),
        MKFLAG(PropertyTagFrameDelay),
        MKFLAG(PropertyTagFreeByteCounts),
        MKFLAG(PropertyTagFreeOffset),
        MKFLAG(PropertyTagGamma),
        MKFLAG(PropertyTagGpsAltitude),
        MKFLAG(PropertyTagGpsAltitudeRef),
        MKFLAG(PropertyTagGpsDestBear),
        MKFLAG(PropertyTagGpsDestBearRef),
        MKFLAG(PropertyTagGpsDestDist),
        MKFLAG(PropertyTagGpsDestDistRef),
        MKFLAG(PropertyTagGpsDestLat),
        MKFLAG(PropertyTagGpsDestLatRef),
        MKFLAG(PropertyTagGpsDestLong),
        MKFLAG(PropertyTagGpsDestLongRef),
        MKFLAG(PropertyTagGpsGpsDop),
        MKFLAG(PropertyTagGpsGpsMeasureMode),
        MKFLAG(PropertyTagGpsGpsSatellites),
        MKFLAG(PropertyTagGpsGpsStatus),
        MKFLAG(PropertyTagGpsGpsTime),
        MKFLAG(PropertyTagGpsIFD),
        MKFLAG(PropertyTagGpsImgDir),
        MKFLAG(PropertyTagGpsImgDirRef),
        MKFLAG(PropertyTagGpsLatitude),
        MKFLAG(PropertyTagGpsLatitudeRef),
        MKFLAG(PropertyTagGpsLongitude),
        MKFLAG(PropertyTagGpsLongitudeRef),
        MKFLAG(PropertyTagGpsMapDatum),
        MKFLAG(PropertyTagGpsSpeed),
        MKFLAG(PropertyTagGpsSpeedRef),
        MKFLAG(PropertyTagGpsTrack),
        MKFLAG(PropertyTagGpsTrackRef),
        MKFLAG(PropertyTagGpsVer),
        MKFLAG(PropertyTagGrayResponseCurve),
        MKFLAG(PropertyTagGrayResponseUnit),
        MKFLAG(PropertyTagGridSize),
        MKFLAG(PropertyTagHalftoneDegree),
        MKFLAG(PropertyTagHalftoneHints),
        MKFLAG(PropertyTagHalftoneLPI),
        MKFLAG(PropertyTagHalftoneLPIUnit),
        MKFLAG(PropertyTagHalftoneMisc),
        MKFLAG(PropertyTagHalftoneScreen),
        MKFLAG(PropertyTagHalftoneShape),
        MKFLAG(PropertyTagHostComputer),
        MKFLAG(PropertyTagICCProfile),
        MKFLAG(PropertyTagICCProfileDescriptor),
        MKFLAG(PropertyTagImageDescription),
        MKFLAG(PropertyTagImageHeight),
        MKFLAG(PropertyTagImageTitle),
        MKFLAG(PropertyTagImageWidth),
        MKFLAG(PropertyTagInkNames),
        MKFLAG(PropertyTagInkSet),
        MKFLAG(PropertyTagJPEGACTables),
        MKFLAG(PropertyTagJPEGDCTables),
        MKFLAG(PropertyTagJPEGInterFormat),
        MKFLAG(PropertyTagJPEGInterLength),
        MKFLAG(PropertyTagJPEGLosslessPredictors),
        MKFLAG(PropertyTagJPEGPointTransforms),
        MKFLAG(PropertyTagJPEGProc),
        MKFLAG(PropertyTagJPEGQTables),
        MKFLAG(PropertyTagJPEGQuality),
        MKFLAG(PropertyTagJPEGRestartInterval),
        MKFLAG(PropertyTagLoopCount),
        MKFLAG(PropertyTagLuminanceTable),
        MKFLAG(PropertyTagMaxSampleValue),
        MKFLAG(PropertyTagMinSampleValue),
        MKFLAG(PropertyTagNewSubfileType),
        MKFLAG(PropertyTagNumberOfInks),
        MKFLAG(PropertyTagOrientation),
        MKFLAG(PropertyTagPageName),
        MKFLAG(PropertyTagPageNumber),
        MKFLAG(PropertyTagPaletteHistogram),
        MKFLAG(PropertyTagPhotometricInterp),
        MKFLAG(PropertyTagPixelPerUnitX),
        MKFLAG(PropertyTagPixelPerUnitY),
        MKFLAG(PropertyTagPixelUnit),
        MKFLAG(PropertyTagPlanarConfig),
        MKFLAG(PropertyTagPredictor),
        MKFLAG(PropertyTagPrimaryChromaticities),
        MKFLAG(PropertyTagPrintFlags),
        MKFLAG(PropertyTagPrintFlagsBleedWidth),
        MKFLAG(PropertyTagPrintFlagsBleedWidthScale),
        MKFLAG(PropertyTagPrintFlagsCrop),
        MKFLAG(PropertyTagPrintFlagsVersion),
        MKFLAG(PropertyTagREFBlackWhite),
        MKFLAG(PropertyTagResolutionUnit),
        MKFLAG(PropertyTagResolutionXLengthUnit),
        MKFLAG(PropertyTagResolutionXUnit),
        MKFLAG(PropertyTagResolutionYLengthUnit),
        MKFLAG(PropertyTagResolutionYUnit),
        MKFLAG(PropertyTagRowsPerStrip),
        MKFLAG(PropertyTagSMaxSampleValue),
        MKFLAG(PropertyTagSMinSampleValue),
        MKFLAG(PropertyTagSRGBRenderingIntent),
        MKFLAG(PropertyTagSampleFormat),
        MKFLAG(PropertyTagSamplesPerPixel),
        MKFLAG(PropertyTagSoftwareUsed),
        MKFLAG(PropertyTagStripBytesCount),
        MKFLAG(PropertyTagStripOffsets),
        MKFLAG(PropertyTagSubfileType),
        MKFLAG(PropertyTagT4Option),
        MKFLAG(PropertyTagT6Option),
        MKFLAG(PropertyTagTargetPrinter),
        MKFLAG(PropertyTagThreshHolding),
        MKFLAG(PropertyTagThumbnailArtist),
        MKFLAG(PropertyTagThumbnailBitsPerSample),
        MKFLAG(PropertyTagThumbnailColorDepth),
        MKFLAG(PropertyTagThumbnailCompressedSize),
        MKFLAG(PropertyTagThumbnailCompression),
        MKFLAG(PropertyTagThumbnailCopyRight),
        MKFLAG(PropertyTagThumbnailData),
        MKFLAG(PropertyTagThumbnailDateTime),
        MKFLAG(PropertyTagThumbnailEquipMake),
        MKFLAG(PropertyTagThumbnailEquipModel),
        MKFLAG(PropertyTagThumbnailFormat),
        MKFLAG(PropertyTagThumbnailHeight),
        MKFLAG(PropertyTagThumbnailImageDescription),
        MKFLAG(PropertyTagThumbnailImageHeight),
        MKFLAG(PropertyTagThumbnailImageWidth),
        MKFLAG(PropertyTagThumbnailOrientation),
        MKFLAG(PropertyTagThumbnailPhotometricInterp),
        MKFLAG(PropertyTagThumbnailPlanarConfig),
        MKFLAG(PropertyTagThumbnailPlanes),
        MKFLAG(PropertyTagThumbnailPrimaryChromaticities),
        MKFLAG(PropertyTagThumbnailRawBytes),
        MKFLAG(PropertyTagThumbnailRefBlackWhite),
        MKFLAG(PropertyTagThumbnailResolutionUnit),
        MKFLAG(PropertyTagThumbnailResolutionX),
        MKFLAG(PropertyTagThumbnailResolutionY),
        MKFLAG(PropertyTagThumbnailRowsPerStrip),
        MKFLAG(PropertyTagThumbnailSamplesPerPixel),
        MKFLAG(PropertyTagThumbnailSize),
        MKFLAG(PropertyTagThumbnailSoftwareUsed),
        MKFLAG(PropertyTagThumbnailStripBytesCount),
        MKFLAG(PropertyTagThumbnailStripOffsets),
        MKFLAG(PropertyTagThumbnailTransferFunction),
        MKFLAG(PropertyTagThumbnailWhitePoint),
        MKFLAG(PropertyTagThumbnailWidth),
        MKFLAG(PropertyTagThumbnailYCbCrCoefficients),
        MKFLAG(PropertyTagThumbnailYCbCrPositioning),
        MKFLAG(PropertyTagThumbnailYCbCrSubsampling),
        MKFLAG(PropertyTagTileByteCounts),
        MKFLAG(PropertyTagTileLength),
        MKFLAG(PropertyTagTileOffset),
        MKFLAG(PropertyTagTileWidth),
        MKFLAG(PropertyTagTransferFuncition),
        MKFLAG(PropertyTagTransferRange),
        MKFLAG(PropertyTagWhitePoint),
        MKFLAG(PropertyTagXPosition),
        MKFLAG(PropertyTagXResolution),
        MKFLAG(PropertyTagYCbCrCoefficients),
        MKFLAG(PropertyTagYCbCrPositioning),
        MKFLAG(PropertyTagYCbCrSubsampling),
        MKFLAG(PropertyTagYPosition),
        MKFLAG(PropertyTagYResolution)
    };

    wchar_t szUnknownBuffer[256];
    wprintf( L"Property: %ws, ", GetStringFromTable( s_PropertyIds, sizeof(s_PropertyIds)/sizeof(s_PropertyIds[0]), pPropertyItem->id, szUnknownBuffer ) );
    wprintf( L"%ws, ", GetStringFromTable( s_PropertyTypes, sizeof(s_PropertyTypes)/sizeof(s_PropertyTypes[0]), pPropertyItem->type, szUnknownBuffer ) );
    wprintf( L"%d\n", pPropertyItem->length );

    switch (pPropertyItem->type)
    {
        //
        // ASCII text
        //
    case PropertyTagTypeASCII:
        {
            wprintf( L"%S\n", pPropertyItem->value );
        }
        break;

        //
        // Unsigned 16 bit integer
        //
    case PropertyTagTypeShort:
        {
            for (UINT i=0;i<pPropertyItem->length/sizeof(USHORT);i++)
            {
                if (i)
                {
                    if (!(i%14))
                    {
                        wprintf( L"\n" );
                    }
                    else
                    {
                        wprintf( L" " );
                    }
                }
                wprintf( L"%04X", reinterpret_cast<PUSHORT>(pPropertyItem->value)[i] );
            }
            wprintf( L"\n" );
        }
        break;

        //
        // Two unsigned 32 bit integers.  The first is the numerator, the second the denominator
        //
    case PropertyTagTypeRational:
        {
            for (UINT i=0;i<pPropertyItem->length/(sizeof(ULONG)*2);i++)
            {
                wprintf( L"%08X/%08X = %0.8f\n", 
                         reinterpret_cast<PULONG>(pPropertyItem->value)[i], 
                         reinterpret_cast<PULONG>(pPropertyItem->value)[i+1], 
                         static_cast<double>(reinterpret_cast<PULONG>(pPropertyItem->value)[i])/static_cast<double>(reinterpret_cast<PULONG>(pPropertyItem->value)[i+1]));
            }
        }
        break;

        //
        // Two signed 32 bit integers.  The first is the numerator, the second the denominator
        //
    case PropertyTagTypeSRational:
        {
            for (UINT i=0;i<pPropertyItem->length/(sizeof(LONG)*2);i++)
            {
                wprintf( L"%08X/%08X = %0.8f\n", 
                         reinterpret_cast<PLONG>(pPropertyItem->value)[i], 
                         reinterpret_cast<PLONG>(pPropertyItem->value)[i+1], 
                         static_cast<double>(reinterpret_cast<PLONG>(pPropertyItem->value)[i])/static_cast<double>(reinterpret_cast<PLONG>(pPropertyItem->value)[i+1]));
            }
        }
        break;

        //
        // 32 bit unsigned integers
        //
    case PropertyTagTypeLong:
        {
            for (UINT i=0;i<pPropertyItem->length/sizeof(ULONG);i++)
            {
                if (i)
                {
                    if (!(i%8))
                    {
                        wprintf( L"\n" );
                    }
                    else
                    {
                        wprintf( L" " );
                    }
                }
                wprintf( L"%08X", reinterpret_cast<PULONG>(pPropertyItem->value)[i] );
            }
            wprintf( L"\n" );
        }
        break;
    
        //
        // 32 bit signed integers
        //
    case PropertyTagTypeSLONG:
        {
            for (UINT i=0;i<pPropertyItem->length/sizeof(LONG);i++)
            {
                if (i)
                {
                    if (!(i%8))
                    {
                        wprintf( L"\n" );
                    }
                    else
                    {
                        wprintf( L" " );
                    }
                }
                wprintf( L"%08X", reinterpret_cast<PLONG>(pPropertyItem->value)[i] );
            }
            wprintf( L"\n" );
        }
        break;

        //
        // Buncha bytes and everything else
        //
    default:
    case PropertyTagTypeByte:
    case PropertyTagTypeUndefined:
        {
            for (UINT i=0;i<pPropertyItem->length;i++)
            {
                if (i && !(i%4))
                {
                    if (!(i%32))
                    {
                        wprintf( L"\n" );
                    }
                    else
                    {
                        wprintf( L" " );
                    }
                }
                wprintf( L"%02X", reinterpret_cast<PBYTE>(pPropertyItem->value)[i] );
            }
            wprintf( L"\n" );
        }
        break;

    }
    wprintf( L"\n" );
}


void DumpImageProperties( LPCWSTR pwszImage )
{
    Gdiplus::Image Image(pwszImage);
    if (Gdiplus::Ok == Image.GetLastStatus())
    {
        UINT nPropertyCount = Image.GetPropertyCount();
        if (nPropertyCount)
        {
            PROPID* pPropIdList = new PROPID[nPropertyCount];
            if (pPropIdList)
            {
                if (Gdiplus::Ok == Image.GetPropertyIdList(nPropertyCount, pPropIdList))
                {
                    UINT nItemSize = 0;
                    if (Gdiplus::Ok == Image.GetPropertySize(&nItemSize, &nPropertyCount))
                    {
                        Gdiplus::PropertyItem *pPropertyItems = reinterpret_cast<Gdiplus::PropertyItem*>(LocalAlloc(LPTR,nItemSize));
                        if (pPropertyItems)
                        {
                            if (Gdiplus::Ok == Image.GetAllPropertyItems( nItemSize, nPropertyCount, pPropertyItems ))
                            {
                                wprintf( L"--------------------------------------------------------------------------------\n" );
                                wprintf( L"Dumping properties for %s\n", pwszImage );
                                wprintf( L"--------------------------------------------------------------------------------\n" );
                                Gdiplus::PropertyItem *pCurr = pPropertyItems;
                                for (UINT i=0;i<nPropertyCount;i++)
                                {
                                    DumpImageProperty(pCurr++);
                                }
                            }
                            LocalFree(pPropertyItems);
                        }
                    }
                }
                delete[] pPropIdList;
            }
        }
    }
}

int __cdecl wmain( int argc, wchar_t *argv[] )
{
    ULONG_PTR pGdiplusToken=0;
    Gdiplus::GdiplusStartupInput StartupInput;
    if (Gdiplus::Ok == Gdiplus::GdiplusStartup(&pGdiplusToken,&StartupInput,NULL))
    {
        for (int i=1;i<argc;i++)
        {
            DumpImageProperties(argv[i]);
        }
        Gdiplus::GdiplusShutdown(pGdiplusToken);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\unittest\taggen\taggen.cpp ===
#include <windows.h>
#include <stdio.h>
#include <objbase.h>
#include <gdiplus.h>

struct CStringEntry
{
    ULONG       nId;
    const wchar_t *pszString;
};

#define MKFLAG(x) { (x), L#x }

const wchar_t *GetStringFromTable( const CStringEntry *pStrings, UINT nSize, ULONG nId, wchar_t *pszUnknownBuffer )
{
    for (UINT i=0;i<nSize;i++)
    {
        if (pStrings[i].nId == nId)
        {
            return pStrings[i].pszString;
        }
    }
    wsprintfW( pszUnknownBuffer, L"Unknown value: %d (0x%X)", nId, nId );
    return pszUnknownBuffer;
}

void DumpImageProperty( Gdiplus::PropertyItem* pPropertyItem )
{
    static CStringEntry s_PropertyTypes[] =
    {
        MKFLAG(PropertyTagTypeByte),
        MKFLAG(PropertyTagTypeASCII),
        MKFLAG(PropertyTagTypeShort),
        MKFLAG(PropertyTagTypeLong),
        MKFLAG(PropertyTagTypeRational),
        MKFLAG(PropertyTagTypeUndefined),
        MKFLAG(PropertyTagTypeSLONG),
        MKFLAG(PropertyTagTypeSRational)


    };
    
    static CStringEntry s_PropertyIds[] =
    {
        MKFLAG(PropertyTagArtist),
        MKFLAG(PropertyTagBitsPerSample),
        MKFLAG(PropertyTagCellHeight),
        MKFLAG(PropertyTagCellWidth),
        MKFLAG(PropertyTagChrominanceTable),
        MKFLAG(PropertyTagColorMap),
        MKFLAG(PropertyTagColorTransferFunction),
        MKFLAG(PropertyTagCompression),
        MKFLAG(PropertyTagCopyright),
        MKFLAG(PropertyTagDateTime),
        MKFLAG(PropertyTagDocumentName),
        MKFLAG(PropertyTagDotRange),
        MKFLAG(PropertyTagEquipMake),
        MKFLAG(PropertyTagEquipModel),
        MKFLAG(PropertyTagExifAperture),
        MKFLAG(PropertyTagExifBrightness),
        MKFLAG(PropertyTagExifCfaPattern),
        MKFLAG(PropertyTagExifColorSpace),
        MKFLAG(PropertyTagExifCompBPP),
        MKFLAG(PropertyTagExifCompConfig),
        MKFLAG(PropertyTagExifDTDigSS),
        MKFLAG(PropertyTagExifDTDigitized),
        MKFLAG(PropertyTagExifDTOrig),
        MKFLAG(PropertyTagExifDTOrigSS),
        MKFLAG(PropertyTagExifDTSubsec),
        MKFLAG(PropertyTagExifExposureBias),
        MKFLAG(PropertyTagExifExposureIndex),
        MKFLAG(PropertyTagExifExposureProg),
        MKFLAG(PropertyTagExifExposureTime),
        MKFLAG(PropertyTagExifFNumber),
        MKFLAG(PropertyTagExifFPXVer),
        MKFLAG(PropertyTagExifFileSource),
        MKFLAG(PropertyTagExifFlash),
        MKFLAG(PropertyTagExifFlashEnergy),
        MKFLAG(PropertyTagExifFocalLength),
        MKFLAG(PropertyTagExifFocalResUnit),
        MKFLAG(PropertyTagExifFocalXRes),
        MKFLAG(PropertyTagExifFocalYRes),
        MKFLAG(PropertyTagExifIFD),
        MKFLAG(PropertyTagExifISOSpeed),
        MKFLAG(PropertyTagExifInterop),
        MKFLAG(PropertyTagExifLightSource),
        MKFLAG(PropertyTagExifMakerNote),
        MKFLAG(PropertyTagExifMaxAperture),
        MKFLAG(PropertyTagExifMeteringMode),
        MKFLAG(PropertyTagExifOECF),
        MKFLAG(PropertyTagExifPixXDim),
        MKFLAG(PropertyTagExifPixYDim),
        MKFLAG(PropertyTagExifRelatedWav),
        MKFLAG(PropertyTagExifSceneType),
        MKFLAG(PropertyTagExifSensingMethod),
        MKFLAG(PropertyTagExifShutterSpeed),
        MKFLAG(PropertyTagExifSpatialFR),
        MKFLAG(PropertyTagExifSpectralSense),
        MKFLAG(PropertyTagExifSubjectDist),
        MKFLAG(PropertyTagExifSubjectLoc),
        MKFLAG(PropertyTagExifUserComment),
        MKFLAG(PropertyTagExifVer),
        MKFLAG(PropertyTagExtraSamples),
        MKFLAG(PropertyTagFillOrder),
        MKFLAG(PropertyTagFrameDelay),
        MKFLAG(PropertyTagFreeByteCounts),
        MKFLAG(PropertyTagFreeOffset),
        MKFLAG(PropertyTagGamma),
        MKFLAG(PropertyTagGpsAltitude),
        MKFLAG(PropertyTagGpsAltitudeRef),
        MKFLAG(PropertyTagGpsDestBear),
        MKFLAG(PropertyTagGpsDestBearRef),
        MKFLAG(PropertyTagGpsDestDist),
        MKFLAG(PropertyTagGpsDestDistRef),
        MKFLAG(PropertyTagGpsDestLat),
        MKFLAG(PropertyTagGpsDestLatRef),
        MKFLAG(PropertyTagGpsDestLong),
        MKFLAG(PropertyTagGpsDestLongRef),
        MKFLAG(PropertyTagGpsGpsDop),
        MKFLAG(PropertyTagGpsGpsMeasureMode),
        MKFLAG(PropertyTagGpsGpsSatellites),
        MKFLAG(PropertyTagGpsGpsStatus),
        MKFLAG(PropertyTagGpsGpsTime),
        MKFLAG(PropertyTagGpsIFD),
        MKFLAG(PropertyTagGpsImgDir),
        MKFLAG(PropertyTagGpsImgDirRef),
        MKFLAG(PropertyTagGpsLatitude),
        MKFLAG(PropertyTagGpsLatitudeRef),
        MKFLAG(PropertyTagGpsLongitude),
        MKFLAG(PropertyTagGpsLongitudeRef),
        MKFLAG(PropertyTagGpsMapDatum),
        MKFLAG(PropertyTagGpsSpeed),
        MKFLAG(PropertyTagGpsSpeedRef),
        MKFLAG(PropertyTagGpsTrack),
        MKFLAG(PropertyTagGpsTrackRef),
        MKFLAG(PropertyTagGpsVer),
        MKFLAG(PropertyTagGrayResponseCurve),
        MKFLAG(PropertyTagGrayResponseUnit),
        MKFLAG(PropertyTagGridSize),
        MKFLAG(PropertyTagHalftoneDegree),
        MKFLAG(PropertyTagHalftoneHints),
        MKFLAG(PropertyTagHalftoneLPI),
        MKFLAG(PropertyTagHalftoneLPIUnit),
        MKFLAG(PropertyTagHalftoneMisc),
        MKFLAG(PropertyTagHalftoneScreen),
        MKFLAG(PropertyTagHalftoneShape),
        MKFLAG(PropertyTagHostComputer),
        MKFLAG(PropertyTagICCProfile),
        MKFLAG(PropertyTagICCProfileDescriptor),
        MKFLAG(PropertyTagImageDescription),
        MKFLAG(PropertyTagImageHeight),
        MKFLAG(PropertyTagImageTitle),
        MKFLAG(PropertyTagImageWidth),
        MKFLAG(PropertyTagInkNames),
        MKFLAG(PropertyTagInkSet),
        MKFLAG(PropertyTagJPEGACTables),
        MKFLAG(PropertyTagJPEGDCTables),
        MKFLAG(PropertyTagJPEGInterFormat),
        MKFLAG(PropertyTagJPEGInterLength),
        MKFLAG(PropertyTagJPEGLosslessPredictors),
        MKFLAG(PropertyTagJPEGPointTransforms),
        MKFLAG(PropertyTagJPEGProc),
        MKFLAG(PropertyTagJPEGQTables),
        MKFLAG(PropertyTagJPEGQuality),
        MKFLAG(PropertyTagJPEGRestartInterval),
        MKFLAG(PropertyTagLoopCount),
        MKFLAG(PropertyTagLuminanceTable),
        MKFLAG(PropertyTagMaxSampleValue),
        MKFLAG(PropertyTagMinSampleValue),
        MKFLAG(PropertyTagNewSubfileType),
        MKFLAG(PropertyTagNumberOfInks),
        MKFLAG(PropertyTagOrientation),
        MKFLAG(PropertyTagPageName),
        MKFLAG(PropertyTagPageNumber),
        MKFLAG(PropertyTagPaletteHistogram),
        MKFLAG(PropertyTagPhotometricInterp),
        MKFLAG(PropertyTagPixelPerUnitX),
        MKFLAG(PropertyTagPixelPerUnitY),
        MKFLAG(PropertyTagPixelUnit),
        MKFLAG(PropertyTagPlanarConfig),
        MKFLAG(PropertyTagPredictor),
        MKFLAG(PropertyTagPrimaryChromaticities),
        MKFLAG(PropertyTagPrintFlags),
        MKFLAG(PropertyTagPrintFlagsBleedWidth),
        MKFLAG(PropertyTagPrintFlagsBleedWidthScale),
        MKFLAG(PropertyTagPrintFlagsCrop),
        MKFLAG(PropertyTagPrintFlagsVersion),
        MKFLAG(PropertyTagREFBlackWhite),
        MKFLAG(PropertyTagResolutionUnit),
        MKFLAG(PropertyTagResolutionXLengthUnit),
        MKFLAG(PropertyTagResolutionXUnit),
        MKFLAG(PropertyTagResolutionYLengthUnit),
        MKFLAG(PropertyTagResolutionYUnit),
        MKFLAG(PropertyTagRowsPerStrip),
        MKFLAG(PropertyTagSMaxSampleValue),
        MKFLAG(PropertyTagSMinSampleValue),
        MKFLAG(PropertyTagSRGBRenderingIntent),
        MKFLAG(PropertyTagSampleFormat),
        MKFLAG(PropertyTagSamplesPerPixel),
        MKFLAG(PropertyTagSoftwareUsed),
        MKFLAG(PropertyTagStripBytesCount),
        MKFLAG(PropertyTagStripOffsets),
        MKFLAG(PropertyTagSubfileType),
        MKFLAG(PropertyTagT4Option),
        MKFLAG(PropertyTagT6Option),
        MKFLAG(PropertyTagTargetPrinter),
        MKFLAG(PropertyTagThreshHolding),
        MKFLAG(PropertyTagThumbnailArtist),
        MKFLAG(PropertyTagThumbnailBitsPerSample),
        MKFLAG(PropertyTagThumbnailColorDepth),
        MKFLAG(PropertyTagThumbnailCompressedSize),
        MKFLAG(PropertyTagThumbnailCompression),
        MKFLAG(PropertyTagThumbnailCopyRight),
        MKFLAG(PropertyTagThumbnailData),
        MKFLAG(PropertyTagThumbnailDateTime),
        MKFLAG(PropertyTagThumbnailEquipMake),
        MKFLAG(PropertyTagThumbnailEquipModel),
        MKFLAG(PropertyTagThumbnailFormat),
        MKFLAG(PropertyTagThumbnailHeight),
        MKFLAG(PropertyTagThumbnailImageDescription),
        MKFLAG(PropertyTagThumbnailImageHeight),
        MKFLAG(PropertyTagThumbnailImageWidth),
        MKFLAG(PropertyTagThumbnailOrientation),
        MKFLAG(PropertyTagThumbnailPhotometricInterp),
        MKFLAG(PropertyTagThumbnailPlanarConfig),
        MKFLAG(PropertyTagThumbnailPlanes),
        MKFLAG(PropertyTagThumbnailPrimaryChromaticities),
        MKFLAG(PropertyTagThumbnailRawBytes),
        MKFLAG(PropertyTagThumbnailRefBlackWhite),
        MKFLAG(PropertyTagThumbnailResolutionUnit),
        MKFLAG(PropertyTagThumbnailResolutionX),
        MKFLAG(PropertyTagThumbnailResolutionY),
        MKFLAG(PropertyTagThumbnailRowsPerStrip),
        MKFLAG(PropertyTagThumbnailSamplesPerPixel),
        MKFLAG(PropertyTagThumbnailSize),
        MKFLAG(PropertyTagThumbnailSoftwareUsed),
        MKFLAG(PropertyTagThumbnailStripBytesCount),
        MKFLAG(PropertyTagThumbnailStripOffsets),
        MKFLAG(PropertyTagThumbnailTransferFunction),
        MKFLAG(PropertyTagThumbnailWhitePoint),
        MKFLAG(PropertyTagThumbnailWidth),
        MKFLAG(PropertyTagThumbnailYCbCrCoefficients),
        MKFLAG(PropertyTagThumbnailYCbCrPositioning),
        MKFLAG(PropertyTagThumbnailYCbCrSubsampling),
        MKFLAG(PropertyTagTileByteCounts),
        MKFLAG(PropertyTagTileLength),
        MKFLAG(PropertyTagTileOffset),
        MKFLAG(PropertyTagTileWidth),
        MKFLAG(PropertyTagTransferFuncition),
        MKFLAG(PropertyTagTransferRange),
        MKFLAG(PropertyTagWhitePoint),
        MKFLAG(PropertyTagXPosition),
        MKFLAG(PropertyTagXResolution),
        MKFLAG(PropertyTagYCbCrCoefficients),
        MKFLAG(PropertyTagYCbCrPositioning),
        MKFLAG(PropertyTagYCbCrSubsampling),
        MKFLAG(PropertyTagYPosition),
        MKFLAG(PropertyTagYResolution)
    };

    wchar_t szUnknownBuffer[256];
    wprintf( L"Property: %ws, ", GetStringFromTable( s_PropertyIds, sizeof(s_PropertyIds)/sizeof(s_PropertyIds[0]), pPropertyItem->id, szUnknownBuffer ) );
    wprintf( L"%ws, ", GetStringFromTable( s_PropertyTypes, sizeof(s_PropertyTypes)/sizeof(s_PropertyTypes[0]), pPropertyItem->type, szUnknownBuffer ) );
    wprintf( L"%d\n", pPropertyItem->length );

    switch (pPropertyItem->type)
    {
        //
        // ASCII text
        //
    case PropertyTagTypeASCII:
        {
            wprintf( L"%S\n", pPropertyItem->value );
        }
        break;

        //
        // Unsigned 16 bit integer
        //
    case PropertyTagTypeShort:
        {
            for (UINT i=0;i<pPropertyItem->length/sizeof(USHORT);i++)
            {
                if (i)
                {
                    if (!(i%14))
                    {
                        wprintf( L"\n" );
                    }
                    else
                    {
                        wprintf( L" " );
                    }
                }
                wprintf( L"%04X", reinterpret_cast<PUSHORT>(pPropertyItem->value)[i] );
            }
            wprintf( L"\n" );
        }
        break;

        //
        // Two unsigned 32 bit integers.  The first is the numerator, the second the denominator
        //
    case PropertyTagTypeRational:
        {
            for (UINT i=0;i<pPropertyItem->length/(sizeof(ULONG)*2);i++)
            {
                wprintf( L"%08X/%08X = %0.8f\n", 
                         reinterpret_cast<PULONG>(pPropertyItem->value)[i], 
                         reinterpret_cast<PULONG>(pPropertyItem->value)[i+1], 
                         static_cast<double>(reinterpret_cast<PULONG>(pPropertyItem->value)[i])/static_cast<double>(reinterpret_cast<PULONG>(pPropertyItem->value)[i+1]));
            }
        }
        break;

        //
        // Two signed 32 bit integers.  The first is the numerator, the second the denominator
        //
    case PropertyTagTypeSRational:
        {
            for (UINT i=0;i<pPropertyItem->length/(sizeof(LONG)*2);i++)
            {
                wprintf( L"%08X/%08X = %0.8f\n", 
                         reinterpret_cast<PLONG>(pPropertyItem->value)[i], 
                         reinterpret_cast<PLONG>(pPropertyItem->value)[i+1], 
                         static_cast<double>(reinterpret_cast<PLONG>(pPropertyItem->value)[i])/static_cast<double>(reinterpret_cast<PLONG>(pPropertyItem->value)[i+1]));
            }
        }
        break;

        //
        // 32 bit unsigned integers
        //
    case PropertyTagTypeLong:
        {
            for (UINT i=0;i<pPropertyItem->length/sizeof(ULONG);i++)
            {
                if (i)
                {
                    if (!(i%8))
                    {
                        wprintf( L"\n" );
                    }
                    else
                    {
                        wprintf( L" " );
                    }
                }
                wprintf( L"%08X", reinterpret_cast<PULONG>(pPropertyItem->value)[i] );
            }
            wprintf( L"\n" );
        }
        break;
    
        //
        // 32 bit signed integers
        //
    case PropertyTagTypeSLONG:
        {
            for (UINT i=0;i<pPropertyItem->length/sizeof(LONG);i++)
            {
                if (i)
                {
                    if (!(i%8))
                    {
                        wprintf( L"\n" );
                    }
                    else
                    {
                        wprintf( L" " );
                    }
                }
                wprintf( L"%08X", reinterpret_cast<PLONG>(pPropertyItem->value)[i] );
            }
            wprintf( L"\n" );
        }
        break;

        //
        // Buncha bytes and everything else
        //
    default:
    case PropertyTagTypeByte:
    case PropertyTagTypeUndefined:
        {
            for (UINT i=0;i<pPropertyItem->length;i++)
            {
                if (i && !(i%4))
                {
                    if (!(i%32))
                    {
                        wprintf( L"\n" );
                    }
                    else
                    {
                        wprintf( L" " );
                    }
                }
                wprintf( L"%02X", reinterpret_cast<PBYTE>(pPropertyItem->value)[i] );
            }
            wprintf( L"\n" );
        }
        break;

    }
    wprintf( L"\n" );
}


void DumpImageProperties( LPCWSTR pwszImage )
{
    Gdiplus::Image Image(pwszImage);
    if (Gdiplus::Ok == Image.GetLastStatus())
    {
        UINT nPropertyCount = Image.GetPropertyCount();
        if (nPropertyCount)
        {
            PROPID* pPropIdList = new PROPID[nPropertyCount];
            if (pPropIdList)
            {
                if (Gdiplus::Ok == Image.GetPropertyIdList(nPropertyCount, pPropIdList))
                {
                    UINT nItemSize = 0;
                    if (Gdiplus::Ok == Image.GetPropertySize(&nItemSize, &nPropertyCount))
                    {
                        Gdiplus::PropertyItem *pPropertyItems = reinterpret_cast<Gdiplus::PropertyItem*>(LocalAlloc(LPTR,nItemSize));
                        if (pPropertyItems)
                        {
                            if (Gdiplus::Ok == Image.GetAllPropertyItems( nItemSize, nPropertyCount, pPropertyItems ))
                            {
                                wprintf( L"--------------------------------------------------------------------------------\n" );
                                wprintf( L"Dumping properties for %s\n", pwszImage );
                                wprintf( L"--------------------------------------------------------------------------------\n" );
                                Gdiplus::PropertyItem *pCurr = pPropertyItems;
                                for (UINT i=0;i<nPropertyCount;i++)
                                {
                                    DumpImageProperty(pCurr++);
                                }
                            }
                            LocalFree(pPropertyItems);
                        }
                    }
                }
                delete[] pPropIdList;
            }
        }
    }
}

BOOL GetEncoderList(Gdiplus::ImageCodecInfo** pEncoders, UINT* pcEncoders)
{
    if (pEncoders == NULL || pcEncoders == NULL)
        return FALSE;
    
    // lets pick up the list of encoders, first we get the encoder size which
    // gives us the CB and the number of encoders that are installed on the
    // machine.

    UINT cb;
    if (Gdiplus::Ok == Gdiplus::GetImageEncodersSize(pcEncoders, &cb))
    {
        // allocate the buffer for the encoders and then fill it
        // with the encoder list.

        *pEncoders = (Gdiplus::ImageCodecInfo*)LocalAlloc(LPTR, cb);
        if (*pEncoders != NULL)
        {
            if (Gdiplus::Ok != Gdiplus::GetImageEncoders(*pcEncoders, cb, *pEncoders))
            {
                LocalFree(*pEncoders);
                *pEncoders = NULL;
                return FALSE;
            }
        }
        else
        {
            return FALSE;
        }
    }
    return TRUE;
}

BOOL GetEncoderFromFormat(const GUID *pfmt, CLSID *pclsidEncoder)
{
    UINT cEncoders;
    BOOL bResult = FALSE;
    Gdiplus::ImageCodecInfo* pEncoders = NULL;
    if (GetEncoderList(&pEncoders, &cEncoders))
    {
        for (UINT i = 0; i != cEncoders; i++)
        {
            if (pEncoders[i].FormatID == *pfmt)
            {
                if (pclsidEncoder)
                {
                    *pclsidEncoder = pEncoders[i].Clsid; // return the CLSID of the encoder so we can create again
                }
                bResult = TRUE;
                break;
            }
        }
    }
    
    if (pEncoders != NULL)
        LocalFree(pEncoders);
    
    return bResult;
}

void AddEncParameter(Gdiplus::EncoderParameters *pep, GUID guidProperty, ULONG type, void *pv)
{
    pep->Parameter[pep->Count].Guid = guidProperty;
    pep->Parameter[pep->Count].Type = type;
    pep->Parameter[pep->Count].NumberOfValues = 1;
    pep->Parameter[pep->Count].Value = pv;
    pep->Count++;
}

void WriteProperty(LPCWSTR pwszSrcImage, LPCWSTR pwszDestImage, LPCWSTR pwszDesc, PROPID propid, WORD proptype, VOID* pValue, ULONG cbValue)
{
    CLSID clsidEncoder;
    int iQuality = 100;
    Gdiplus::EncoderParameters ep[2] = { 0 };
    GUID guidFmt = Gdiplus::ImageFormatJPEG;
    
    Gdiplus::Image Image(pwszSrcImage);
    if (Gdiplus::Ok == Image.GetLastStatus())
    {
        Gdiplus::PropertyItem pi;

        pi.id = propid;
        pi.length = cbValue;
        pi.type = proptype;
        pi.value = pValue;

        if (Gdiplus::Ok == Image.SetPropertyItem(&pi))
        {
            Gdiplus::Graphics* pGraphics = Gdiplus::Graphics::FromImage(&Image);
            if (pGraphics != NULL && Gdiplus::Ok == pGraphics->GetLastStatus())
            {
                Gdiplus::Font fnt(L"Arial", 15);
                Gdiplus::Color clr(0xff, 0xff, 0xff);
                Gdiplus::SolidBrush brsh(clr);
            
                Gdiplus::RectF rect(0,0,300,300);
                Gdiplus::GpStatus nResult = pGraphics->DrawString(pwszDesc, -1, &fnt, rect, NULL, &brsh);
                if (Gdiplus::Ok == nResult)
                {
                    AddEncParameter(ep, Gdiplus::EncoderQuality, Gdiplus::EncoderParameterValueTypeLong, &iQuality);
                    if (GetEncoderFromFormat(&guidFmt, &clsidEncoder))
                    {
                        Image.Save(pwszDestImage, &clsidEncoder, ep);
                    }
                }
                delete pGraphics;
            }
        }
    }
}

BOOL CreateTempJPG(LPCWSTR pwszImage)
{
    CLSID clsidEncoder;
    int iQuality = 100;
    Gdiplus::EncoderParameters ep[2] = { 0 };
    GUID guidFmt = Gdiplus::ImageFormatJPEG;
    
    HDC hdc = GetDC(NULL);
    if (hdc == NULL)
        return FALSE;
    
    Gdiplus::Graphics* pGraphics = Gdiplus::Graphics::FromHDC(hdc);
    if (pGraphics == NULL || Gdiplus::Ok != pGraphics->GetLastStatus())
        return FALSE;

    Gdiplus::Bitmap Bitmap(300, 300, pGraphics);
    if (Gdiplus::Ok != Bitmap.GetLastStatus())
        goto Cleanup;

    AddEncParameter(ep, Gdiplus::EncoderQuality, Gdiplus::EncoderParameterValueTypeLong, &iQuality);

    if (!GetEncoderFromFormat(&guidFmt, &clsidEncoder))
        goto Cleanup;

    if (Gdiplus::Ok != Bitmap.Save(pwszImage, &clsidEncoder, ep))
        goto Cleanup;

    delete pGraphics;
    
    return TRUE;
Cleanup:
    if (pGraphics)
        delete pGraphics;
    return FALSE;
}

void CreateExposureTimeTests(LPCWSTR lpTemp)
{
    ULONG Rational[2];

    Rational[0] = 30; Rational[1] = 1;
    WriteProperty(lpTemp, L"et30sec.jpg", L"ExposureTime\n30 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 20; Rational[1] = 1;
    WriteProperty(lpTemp, L"et20sec.jpg", L"ExposureTime\n20 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 15; Rational[1] = 1;
    WriteProperty(lpTemp, L"et15sec.jpg", L"ExposureTime\n15 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 10; Rational[1] = 1;
    WriteProperty(lpTemp, L"et10sec.jpg", L"ExposureTime\n10 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 8; Rational[1] = 1;
    WriteProperty(lpTemp, L"et08sec.jpg", L"ExposureTime\n8 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 6; Rational[1] = 1;
    WriteProperty(lpTemp, L"et06sec.jpg", L"ExposureTime\n6 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 4; Rational[1] = 2;
    WriteProperty(lpTemp, L"et04sec.jpg", L"ExposureTime\n4 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 3; Rational[1] = 1;
    WriteProperty(lpTemp, L"et03sec.jpg", L"ExposureTime\n3 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 2; Rational[1] = 1;
    WriteProperty(lpTemp, L"et02sec.jpg", L"ExposureTime\n2 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 3; Rational[1] = 2;
    WriteProperty(lpTemp, L"et3_2ndssec.jpg", L"ExposureTime\n3/2 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 1;
    WriteProperty(lpTemp, L"et1sec.jpg", L"ExposureTime\n1 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 7; Rational[1] = 10;
    WriteProperty(lpTemp, L"et7_10thssec.jpg", L"ExposureTime\n7/10 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 2;
    WriteProperty(lpTemp, L"et1_2ndsec.jpg", L"ExposureTime\n1/2 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 3;
    WriteProperty(lpTemp, L"et1_3rdsec.jpg", L"ExposureTime\n1/3 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 4;
    WriteProperty(lpTemp, L"et1_4thsec.jpg", L"ExposureTime\n1/4 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 6;
    WriteProperty(lpTemp, L"et1_6thsec.jpg", L"ExposureTime\n1/6 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 8;
    WriteProperty(lpTemp, L"et1_8thsec.jpg", L"ExposureTime\n1/8 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 10;
    WriteProperty(lpTemp, L"et1_10thsec.jpg", L"ExposureTime\n1/10 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 15;
    WriteProperty(lpTemp, L"et1_15thsec.jpg", L"ExposureTime\n1/15 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 20;
    WriteProperty(lpTemp, L"et1_20thsec.jpg", L"ExposureTime\n1/20 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 30;
    WriteProperty(lpTemp, L"et1_30thsec.jpg", L"ExposureTime\n1/30 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 45;
    WriteProperty(lpTemp, L"et1_45thsec.jpg", L"ExposureTime\n1/45 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 60;
    WriteProperty(lpTemp, L"et1_60thsec.jpg", L"ExposureTime\n1/60 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 90;
    WriteProperty(lpTemp, L"et1_90thsec.jpg", L"ExposureTime\n1/90 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 125;
    WriteProperty(lpTemp, L"et1_125thsec.jpg", L"ExposureTime\n1/125 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 180;
    WriteProperty(lpTemp, L"et1_180thsec.jpg", L"ExposureTime\n1/180 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 250;
    WriteProperty(lpTemp, L"et1_250thsec.jpg", L"ExposureTime\n1/250 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 350;
    WriteProperty(lpTemp, L"et1_350thsec.jpg", L"ExposureTime\n1/350 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 500;
    WriteProperty(lpTemp, L"et1_500thsec.jpg", L"ExposureTime\n1/500 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 750;
    WriteProperty(lpTemp, L"et1_750thsec.jpg", L"ExposureTime\n1/750 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 1000;
    WriteProperty(lpTemp, L"et1_1000thsec.jpg", L"ExposureTime\n1/1000 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 1500;
    WriteProperty(lpTemp, L"et1_1500thsec.jpg", L"ExposureTime\n1/1500 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 2000;
    WriteProperty(lpTemp, L"et1_2000thsec.jpg", L"ExposureTime\n1/2000 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 3000;
    WriteProperty(lpTemp, L"et1_3000thsec.jpg", L"ExposureTime\n1/3000 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 4000;
    WriteProperty(lpTemp, L"et1_4000thsec.jpg", L"ExposureTime\n1/4000 sec.", PropertyTagExifExposureTime, PropertyTagTypeRational, Rational, sizeof(Rational));
}

void CreateShutterSpeed(LPCWSTR lpTemp)
{
    LONG Rational[2];

    Rational[0] = -4907; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss30sec.jpg", L"ShutterSpeed\n-4.907 APEX =~ 30 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = -4322; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss20sec.jpg", L"ShutterSpeed\n-4.322 APEX =~ 20 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = -3907; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss15sec.jpg", L"ShutterSpeed\n-3.907 APEX =~ 15 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = -3322; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss10sec.jpg", L"ShutterSpeed\n-3.322 APEX =~ 10 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = -3000; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss08sec.jpg", L"ShutterSpeed\n-3.000 APEX =~ 8 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = -2585; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss06sec.jpg", L"ShutterSpeed\n-2.585 APEX =~ 6 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = -2000; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss04sec.jpg", L"ShutterSpeed\n-2.000 APEX =~ 4 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = -1585; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss03sec.jpg", L"ShutterSpeed\n-1.585 APEX =~ 3 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = -1000; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss02sec.jpg", L"ShutterSpeed\n-1.000 APEX =~ 2 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = -585; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss3_2ndssec.jpg", L"ShutterSpeed\n-0.585 APEX =~ 3/2 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 0; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1sec.jpg", L"ShutterSpeed\n0 APEX =~ 1 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 515; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss7_10thssec.jpg", L"ShutterSpeed\n0.515 APEX =~ 7/10 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 1000; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_2ndsec.jpg", L"ShutterSpeed\n1.000 APEX =~ 1/2 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 1585; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_3rdsec.jpg", L"ShutterSpeed\n1.585 APEX =~ 1/3 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 2000; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_4thsec.jpg", L"ShutterSpeed\n2.000 APEX =~ 1/4 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 2585; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_6thsec.jpg", L"ShutterSpeed\n2.585 APEX =~ 1/6 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 3000; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_8thsec.jpg", L"ShutterSpeed\n3.000 APEX =~ 1/8 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 3322; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_10thsec.jpg", L"ShutterSpeed\n3.322 APEX =~ 1/10 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 3907; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_15thsec.jpg", L"ShutterSpeed\n3.907 APEX =~ 1/15 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 4322; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_20thsec.jpg", L"ShutterSpeed\n4.322 APEX =~ 1/20 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 4907; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_30thsec.jpg", L"ShutterSpeed\n4.907 APEX =~ 1/30 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 5492; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_45thsec.jpg", L"ShutterSpeed\n5.492 APEX =~ 1/45 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 5907; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_60thsec.jpg", L"ShutterSpeed\n5.907 APEX =~ 1/60 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 6492; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_90thsec.jpg", L"ShutterSpeed\n6.492 APEX =~ 1/90 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 6966; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_125thsec.jpg", L"ShutterSpeed\n6.966 APEX =~ 1/125 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 7492; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_180thsec.jpg", L"ShutterSpeed\n7.492 APEX =~ 1/180 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 7966; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_250thsec.jpg", L"ShutterSpeed\n7.966 APEX =~ 1/250 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 8452; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_350thsec.jpg", L"ShutterSpeed\n8.452 APEX =~ 1/350 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 8966; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_500thsec.jpg", L"ShutterSpeed\n8.966 APEX =~ 1/500 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 9551; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_750thsec.jpg", L"ShutterSpeed\n9.551 APEX =~ 1/750 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 9966; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_1000thsec.jpg", L"ShutterSpeed\n9.966 APEX =~ 1/1000 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 10551; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_1500thsec.jpg", L"ShutterSpeed\n10.551 APEX =~ 1/1500 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 10966; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_2000thsec.jpg", L"ShutterSpeed\n10.966 APEX =~ 1/2000 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 11551; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_3000thsec.jpg", L"ShutterSpeed\n11.551 APEX =~ 1/3000 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 11966; Rational[1] = 1000;
    WriteProperty(lpTemp, L"ss1_4000thsec.jpg", L"ShutterSpeed\n11.966 APEX =~ 1/4000 sec.", PropertyTagExifShutterSpeed, PropertyTagTypeSRational, Rational, sizeof(Rational));
}

void CreateFStop(LPCWSTR lpTemp)
{
    ULONG Rational[2];

    Rational[0] = 10; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF1.jpg", L"FNumber\nF/1", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 12; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF12_10ths.jpg", L"FNumber\nF/1.2", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 14; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF14_10ths.jpg", L"FNumber\nF/1.4", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 18; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF18_10ths.jpg", L"FNumber\nF/1.8", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 20; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF2.jpg", L"FNumber\nF/2", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 25; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF25_10ths.jpg", L"FNumber\nF/2.5", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 28; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF28_10ths.jpg", L"FNumber\nF/2.8", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 35; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF35_10ths.jpg", L"FNumber\nF/3.5", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 40; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF4.jpg", L"FNumber\nF/4", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 45; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF45_10ths.jpg", L"FNumber\nF/4.5", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 56; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF56_10ths.jpg", L"FNumber\nF/5.6", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 67; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF67_10ths.jpg", L"FNumber\nF/6.7", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 80; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF8.jpg", L"FNumber\nF/8", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 95; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF95_10ths.jpg", L"FNumber\nF/9.5", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 110; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF11.jpg", L"FNumber\nF/11", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 130; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF13.jpg", L"FNumber\nF/13", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 160; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF16.jpg", L"FNumber\nF/16", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 190; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF19.jpg", L"FNumber\nF/19", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 220; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF22.jpg", L"FNumber\nF/22", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 270; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF27.jpg", L"FNumber\nF/27", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 320; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF32.jpg", L"FNumber\nF/32", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 380; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF38.jpg", L"FNumber\nF/38", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 450; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF45.jpg", L"FNumber\nF/45", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 540; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF54.jpg", L"FNumber\nF/54", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 640; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF64.jpg", L"FNumber\nF/64", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 760; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF76.jpg", L"FNumber\nF/76", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 910; Rational[1] = 10;
    WriteProperty(lpTemp, L"fnF91.jpg", L"FNumber\nF/91", PropertyTagExifFNumber, PropertyTagTypeRational, Rational, sizeof(Rational));
}

void CreateAperture(LPCWSTR lpTemp)
{
    ULONG Rational[2];
    Rational[0] = 0; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF1.jpg", L"Aperture\n0 APEX =~ F/1", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 526; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF12_10ths.jpg", L"Aperture\n0.526 APEX =~ F/1.2", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 971; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF14_10ths.jpg", L"Aperture\n0.971 APEX =~ F/1.4", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1696; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF18_10ths.jpg", L"Aperture\n1.696 APEX =~ F/1.8", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 2000; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF2.jpg", L"Aperture\n2.000 APEX =~ F/2", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 2644; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF25_10ths.jpg", L"Aperture\n2.644 APEX =~ F/2.5", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 2971; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF28_10ths.jpg", L"Aperture\n2.971 APEX =~ F/2.8", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 3615; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF35_10ths.jpg", L"Aperture\n3.615 APEX =~ F/3.5", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 4000; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF4.jpg", L"Aperture\n4.000 APEX =~ F/4", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 4340; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF45_10ths.jpg", L"Aperture\n4.340 APEX =~ F/4.5", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 4971; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF56_10ths.jpg", L"Aperture\n4.971 APEX =~ F/5.6", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 5488; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF67_10ths.jpg", L"Aperture\n5.488 APEX =~ F/6.7", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 6000; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF8.jpg", L"Aperture\n6.000 APEX =~ F/8", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 6496; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF95_10ths.jpg", L"Aperture\n6.496 APEX =~ F/9.5", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 6919; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF11.jpg", L"Aperture\n6.919 APEX =~ F/11", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 7401; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF13.jpg", L"Aperture\n7.401 APEX =~ F/13", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 8000; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF16.jpg", L"Aperture\n8.000 APEX =~ F/16", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 8496; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF19.jpg", L"Aperture\n8.496 APEX =~ F/19", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 8919; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF22.jpg", L"Aperture\n8.919 APEX =~ F/22", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 9510; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF27.jpg", L"Aperture\n9.510 APEX =~ F/27", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 10000; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF32.jpg", L"Aperture\n10.000 APEX =~ F/32", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 10496; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF38.jpg", L"Aperture\n10.496 APEX =~ F/38", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 10984; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF45.jpg", L"Aperture\n10.984 APEX =~ F/45", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 11510; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF54.jpg", L"Aperture\n11.510 APEX =~ F/54", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 12000; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF64.jpg", L"Aperture\n12.000 APEX =~ F/64", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 12496; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF76.jpg", L"Aperture\n12.496 APEX =~ F/76", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 13016; Rational[1] = 10;
    WriteProperty(lpTemp, L"apF91.jpg", L"Aperture\n13.016 APEX =~ F/91", PropertyTagExifAperture, PropertyTagTypeRational, Rational, sizeof(Rational));
}

void CreateExposureBias(LPCWSTR lpTemp)
{
    LONG Rational[2];

    Rational[0] = -2; Rational[1] = 1;
    WriteProperty(lpTemp, L"eb-2.jpg", L"ExposureBias\n-2", PropertyTagExifExposureBias, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = -5; Rational[1] = 3;
    WriteProperty(lpTemp, L"eb-5_3rds.jpg", L"ExposureBias\n-5/3", PropertyTagExifExposureBias, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = -3; Rational[1] = 2;
    WriteProperty(lpTemp, L"eb-3_2nds.jpg", L"ExposureBias\n-3/2", PropertyTagExifExposureBias, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = -4; Rational[1] = 3;
    WriteProperty(lpTemp, L"eb-4_3rds.jpg", L"ExposureBias\n-4/3", PropertyTagExifExposureBias, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = -1; Rational[1] = 1;
    WriteProperty(lpTemp, L"eb-1.jpg", L"ExposureBias\n-1", PropertyTagExifExposureBias, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = -2; Rational[1] = 3;
    WriteProperty(lpTemp, L"eb-2_3rds.jpg", L"ExposureBias\n-2/3", PropertyTagExifExposureBias, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = -1; Rational[1] = 2;
    WriteProperty(lpTemp, L"eb-1_2nd.jpg", L"ExposureBias\n-1/2", PropertyTagExifExposureBias, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = -1; Rational[1] = 3;
    WriteProperty(lpTemp, L"eb-1_3rd.jpg", L"ExposureBias\n-1/3", PropertyTagExifExposureBias, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 0; Rational[1] = 1;
    WriteProperty(lpTemp, L"eb0.jpg", L"ExposureBias\n0", PropertyTagExifExposureBias, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 3;
    WriteProperty(lpTemp, L"eb1_3rd.jpg", L"ExposureBias\n1/3", PropertyTagExifExposureBias, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 2;
    WriteProperty(lpTemp, L"eb1_2nd.jpg", L"ExposureBias\n1/2", PropertyTagExifExposureBias, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 2; Rational[1] = 3;
    WriteProperty(lpTemp, L"eb2_3rds.jpg", L"ExposureBias\n2/3", PropertyTagExifExposureBias, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 1;
    WriteProperty(lpTemp, L"eb1.jpg", L"ExposureBias\n1", PropertyTagExifExposureBias, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 4; Rational[1] = 3;
    WriteProperty(lpTemp, L"eb4_3rds.jpg", L"ExposureBias\n4/3", PropertyTagExifExposureBias, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 3; Rational[1] = 2;
    WriteProperty(lpTemp, L"eb3_2nds.jpg", L"ExposureBias\n3/2", PropertyTagExifExposureBias, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 5; Rational[1] = 3;
    WriteProperty(lpTemp, L"eb5_3rds.jpg", L"ExposureBias\n5/3", PropertyTagExifExposureBias, PropertyTagTypeSRational, Rational, sizeof(Rational));
    Rational[0] = 2; Rational[1] = 1;
    WriteProperty(lpTemp, L"eb2.jpg", L"ExposureBias\n2", PropertyTagExifExposureBias, PropertyTagTypeSRational, Rational, sizeof(Rational));
}

void CreateSubjectDist(LPCWSTR lpTemp)
{
    ULONG Rational[2];
    Rational[0] = 1; Rational[1] = 3;
    WriteProperty(lpTemp, L"sd1_3rd.jpg", L"SubjectDistance\n1/3 meter", PropertyTagExifSubjectDist, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 2;
    WriteProperty(lpTemp, L"sd1_2nd.jpg", L"SubjectDistance\n1/2 meter", PropertyTagExifSubjectDist, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 2; Rational[1] = 3;
    WriteProperty(lpTemp, L"sd2_3rds.jpg", L"SubjectDistance\n2/3 meter", PropertyTagExifSubjectDist, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 1; Rational[1] = 1;
    WriteProperty(lpTemp, L"sd1.jpg", L"SubjectDistance\n1 meter", PropertyTagExifSubjectDist, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 2; Rational[1] = 1;
    WriteProperty(lpTemp, L"sd2.jpg", L"SubjectDistance\n2 meters", PropertyTagExifSubjectDist, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 5; Rational[1] = 1;
    WriteProperty(lpTemp, L"sd5.jpg", L"SubjectDistance\n5 meters", PropertyTagExifSubjectDist, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 10; Rational[1] = 1;
    WriteProperty(lpTemp, L"sd10.jpg", L"SubjectDistance\n01 meters", PropertyTagExifSubjectDist, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 20; Rational[1] = 1;
    WriteProperty(lpTemp, L"sd20.jpg", L"SubjectDistance\n20 meters", PropertyTagExifSubjectDist, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 30; Rational[1] = 1;
    WriteProperty(lpTemp, L"sd30.jpg", L"SubjectDistance\n30 meters", PropertyTagExifSubjectDist, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 40; Rational[1] = 1;
    WriteProperty(lpTemp, L"sd40.jpg", L"SubjectDistance\n40 meters", PropertyTagExifSubjectDist, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 50; Rational[1] = 1;
    WriteProperty(lpTemp, L"sd50.jpg", L"SubjectDistance\n50 meters", PropertyTagExifSubjectDist, PropertyTagTypeRational, Rational, sizeof(Rational));
}

void CreateMeteringMode(LPCWSTR lpTemp)
{
    USHORT Short;
    Short = 0;
    WriteProperty(lpTemp, L"mm0.jpg", L"MeteringMode\n0 = Unknown", PropertyTagExifMeteringMode, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 1;
    WriteProperty(lpTemp, L"mm1.jpg", L"MeteringMode\n1 = Average", PropertyTagExifMeteringMode, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 2;
    WriteProperty(lpTemp, L"mm2.jpg", L"MeteringMode\n2 = CenterWeightedAverage", PropertyTagExifMeteringMode, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 3;
    WriteProperty(lpTemp, L"mm3.jpg", L"MeteringMode\n3 = Spot", PropertyTagExifMeteringMode, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 4;
    WriteProperty(lpTemp, L"mm4.jpg", L"MeteringMode\n4 = MultiSpot", PropertyTagExifMeteringMode, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 5;
    WriteProperty(lpTemp, L"mm5.jpg", L"MeteringMode\n5 = Pattern", PropertyTagExifMeteringMode, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 6;
    WriteProperty(lpTemp, L"mm6.jpg", L"MeteringMode\n6 = Partial", PropertyTagExifMeteringMode, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 7;
    WriteProperty(lpTemp, L"mm7.jpg", L"MeteringMode\n7 = reserved", PropertyTagExifMeteringMode, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 255;
    WriteProperty(lpTemp, L"mm255.jpg", L"MeteringMode\n255 = other", PropertyTagExifMeteringMode, PropertyTagTypeShort, &Short, sizeof(Short));
}

void CreateLightSource(LPCWSTR lpTemp)
{
    USHORT Short;
    Short = 0;
    WriteProperty(lpTemp, L"ls0.jpg", L"LightSource\n0 = Unknown", PropertyTagExifLightSource, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 1;
    WriteProperty(lpTemp, L"ls1.jpg", L"LightSource\n1 = Daylight", PropertyTagExifLightSource, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 2;
    WriteProperty(lpTemp, L"ls2.jpg", L"LightSource\n2 = Fluorescent", PropertyTagExifLightSource, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 3;
    WriteProperty(lpTemp, L"ls3.jpg", L"LightSource\n3 = Tungsten", PropertyTagExifLightSource, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 17;
    WriteProperty(lpTemp, L"ls17.jpg", L"LightSource\n17 = Standard light A", PropertyTagExifLightSource, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 18;
    WriteProperty(lpTemp, L"ls18.jpg", L"LightSource\n18 = Standard light B", PropertyTagExifLightSource, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 19;
    WriteProperty(lpTemp, L"ls19.jpg", L"LightSource\n19 = Standard light C", PropertyTagExifLightSource, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 20;
    WriteProperty(lpTemp, L"ls20.jpg", L"LightSource\n20 = D55", PropertyTagExifLightSource, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 21;
    WriteProperty(lpTemp, L"ls21.jpg", L"LightSource\n21 = D55", PropertyTagExifLightSource, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 22;
    WriteProperty(lpTemp, L"ls22.jpg", L"LightSource\n22 = D55", PropertyTagExifLightSource, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 23;
    WriteProperty(lpTemp, L"ls23.jpg", L"LightSource\n23 = Reserved", PropertyTagExifLightSource, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 255;
    WriteProperty(lpTemp, L"ls255.jpg", L"LightSource\n255 = Other", PropertyTagExifLightSource, PropertyTagTypeShort, &Short, sizeof(Short));
}

void CreateFlash(LPCWSTR lpTemp)
{
    USHORT Short;
    Short = 0;
    WriteProperty(lpTemp, L"f0.jpg", L"Flash\n0 = Flash did not fire", PropertyTagExifFlash, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 1;
    WriteProperty(lpTemp, L"f1.jpg", L"Flash\n1 = Flash fired (No strobe return detection function)", PropertyTagExifFlash, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 3;
    WriteProperty(lpTemp, L"f3.jpg", L"Flash\n3 = Flash fired (reserved)", PropertyTagExifFlash, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 5;
    WriteProperty(lpTemp, L"f5.jpg", L"Flash\n5 = Flash fired (Strobe return light not detected)", PropertyTagExifFlash, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 7;
    WriteProperty(lpTemp, L"f7.jpg", L"Flash\n7 = Flash fired (Strobe return light detected)", PropertyTagExifFlash, PropertyTagTypeShort, &Short, sizeof(Short));
}

void CreateFocalLength(LPCWSTR lpTemp)
{
    ULONG Rational[2];
    Rational[0] = 15; Rational[1] = 1;
    WriteProperty(lpTemp, L"fl15.jpg", L"FocalLength\n15 mm", PropertyTagExifFocalLength, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 35; Rational[1] = 1;
    WriteProperty(lpTemp, L"fl35.jpg", L"FocalLength\n35 mm", PropertyTagExifFocalLength, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 50; Rational[1] = 1;
    WriteProperty(lpTemp, L"fl50.jpg", L"FocalLength\n50 mm", PropertyTagExifFocalLength, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 100; Rational[1] = 1;
    WriteProperty(lpTemp, L"fl100.jpg", L"FocalLength\n100 mm", PropertyTagExifFocalLength, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 135; Rational[1] = 1;
    WriteProperty(lpTemp, L"fl135.jpg", L"FocalLength\n135 mm", PropertyTagExifFocalLength, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 200; Rational[1] = 1;
    WriteProperty(lpTemp, L"fl200.jpg", L"FocalLength\n200 mm", PropertyTagExifFocalLength, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 300; Rational[1] = 1;
    WriteProperty(lpTemp, L"fl300.jpg", L"FocalLength\n300 mm", PropertyTagExifFocalLength, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 400; Rational[1] = 1;
    WriteProperty(lpTemp, L"fl400.jpg", L"FocalLength\n400 mm", PropertyTagExifFocalLength, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 500; Rational[1] = 1;
    WriteProperty(lpTemp, L"fl500.jpg", L"FocalLength\n500 mm", PropertyTagExifFocalLength, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational[0] = 600; Rational[1] = 1;
    WriteProperty(lpTemp, L"fl600.jpg", L"FocalLength\n600 mm", PropertyTagExifFocalLength, PropertyTagTypeRational, Rational, sizeof(Rational));
}

void CreateExposureProgram(LPCWSTR lpTemp)
{
    USHORT Short;
    Short = 0;
    WriteProperty(lpTemp, L"ep0.jpg", L"ExposureProg\n0 = Not Defined", PropertyTagExifExposureProg, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 1;
    WriteProperty(lpTemp, L"ep1.jpg", L"ExposureProg\n1 = Manual", PropertyTagExifExposureProg, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 2;
    WriteProperty(lpTemp, L"ep2.jpg", L"ExposureProg\n2 = Normal Program", PropertyTagExifExposureProg, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 3;
    WriteProperty(lpTemp, L"ep3.jpg", L"ExposureProg\n3 = Aperture Priority", PropertyTagExifExposureProg, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 4;
    WriteProperty(lpTemp, L"ep4.jpg", L"ExposureProg\n4 = Shutter Priority", PropertyTagExifExposureProg, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 5;
    WriteProperty(lpTemp, L"ep5.jpg", L"ExposureProg\n5 = Creative Program", PropertyTagExifExposureProg, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 6;
    WriteProperty(lpTemp, L"ep6.jpg", L"ExposureProg\n6 = Action Program", PropertyTagExifExposureProg, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 7;
    WriteProperty(lpTemp, L"ep7.jpg", L"ExposureProg\n7 = Prtrait Mode", PropertyTagExifExposureProg, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 8;
    WriteProperty(lpTemp, L"ep8.jpg", L"ExposureProg\n8 = Landscape Mode", PropertyTagExifExposureProg, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 9;
    WriteProperty(lpTemp, L"ep9.jpg", L"ExposureProg\n9 = Reserved", PropertyTagExifExposureProg, PropertyTagTypeShort, &Short, sizeof(Short));
}

void CreateISOSpeed(LPCWSTR lpTemp)
{
    USHORT Short;
    Short = 50;
    WriteProperty(lpTemp, L"is50.jpg", L"ISOSpeed\nISO50", PropertyTagExifISOSpeed, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 100;
    WriteProperty(lpTemp, L"is100.jpg", L"ISOSpeed\nISO100", PropertyTagExifISOSpeed, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 200;
    WriteProperty(lpTemp, L"is200.jpg", L"ISOSpeed\nISO200", PropertyTagExifISOSpeed, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 400;
    WriteProperty(lpTemp, L"is400.jpg", L"ISOSpeed\nISO400", PropertyTagExifISOSpeed, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 800;
    WriteProperty(lpTemp, L"is800.jpg", L"ISOSpeed\nISO800", PropertyTagExifISOSpeed, PropertyTagTypeShort, &Short, sizeof(Short));
    Short = 1600;
    WriteProperty(lpTemp, L"is1600.jpg", L"ISOSpeed\nISO1600", PropertyTagExifISOSpeed, PropertyTagTypeShort, &Short, sizeof(Short));
}

void CreateFlashEnergy(LPCWSTR lpTemp)
{
    ULONG Rational[2];
    Rational [0] = 100; Rational[1] = 1;
    WriteProperty(lpTemp, L"fe100.jpg", L"FlashEnergy\n100 BCPS", PropertyTagExifFlashEnergy, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational [0] = 1000; Rational[1] = 1;
    WriteProperty(lpTemp, L"fe1000.jpg", L"FlashEnergy\n1,000 BCPS", PropertyTagExifFlashEnergy, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational [0] = 10000; Rational[1] = 1;
    WriteProperty(lpTemp, L"fe10000.jpg", L"FlashEnergy\n10,000 BCPS", PropertyTagExifFlashEnergy, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational [0] = 100000; Rational[1] = 1;
    WriteProperty(lpTemp, L"fe100000.jpg", L"FlashEnergy\n100,000 BCPS", PropertyTagExifFlashEnergy, PropertyTagTypeRational, Rational, sizeof(Rational));
    Rational [0] = 1000000; Rational[1] = 1;
    WriteProperty(lpTemp, L"fe1000000.jpg", L"FlashEnergy\n1,000,000 BCPS", PropertyTagExifFlashEnergy, PropertyTagTypeRational, Rational, sizeof(Rational));
}

int __cdecl wmain( int argc, wchar_t *argv[] )
{
    ULONG_PTR pGdiplusToken=0;
    Gdiplus::GdiplusStartupInput StartupInput;
    if (Gdiplus::Ok == Gdiplus::GdiplusStartup(&pGdiplusToken,&StartupInput,NULL))
    {
        if (CreateTempJPG(L"temp.jpg"))
        {
            CreateExposureTimeTests(L"temp.jpg");
            CreateShutterSpeed(L"temp.jpg");
            CreateFStop(L"temp.jpg");
            CreateAperture(L"temp.jpg");
            CreateExposureBias(L"temp.jpg");
            CreateSubjectDist(L"temp.jpg");
            CreateMeteringMode(L"temp.jpg");
            CreateLightSource(L"temp.jpg");
            CreateFlash(L"temp.jpg");
            CreateFocalLength(L"temp.jpg");
            CreateExposureProgram(L"temp.jpg");
            CreateISOSpeed(L"temp.jpg");
            CreateFlashEnergy(L"temp.jpg");
        }

        Gdiplus::GdiplusShutdown(pGdiplusToken);
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\unittest\prevtest\prevtest.cpp ===
#include <windows.h>
#include <commctrl.h>
#include <shfusion.h>
#include <commdlg.h>
#include "uicommon.h"
#include "simcrack.h"
#include "pviewids.h"
#include "resource.h"

HINSTANCE g_hInstance;

class CGetXYDlg
{
public:
    class CData
    {
    private:
        TCHAR m_szTitle[MAX_PATH];
        int m_nX, m_nY;

    private:
        CData( const CData & );
        CData &operator=( const CData & );

    public:
        CData(void)
        : m_nX(0), m_nY(0)
        {
            m_szTitle[0] = TEXT('\0');
        }
        void Title( LPCTSTR pszTitle )
        {
            if (pszTitle)
                lstrcpyn( m_szTitle, pszTitle, ARRAYSIZE(m_szTitle) );
        }
        LPCTSTR Title(void) const
        {
            return m_szTitle;
        }
        void X( int nX )
        {
            m_nX = nX;
        }
        void Y( int nY )
        {
            m_nY = nY;
        }
        int X( void ) const
        {
            return m_nX;
        }
        int Y( void ) const
        {
            return m_nY;
        }
    };
private:
    HWND m_hWnd;
    CData *m_pData;

private:
    CGetXYDlg(void);
    CGetXYDlg( const CGetXYDlg & );
    CGetXYDlg &operator=( const CGetXYDlg & );
private:
    explicit CGetXYDlg( HWND hWnd )
    : m_hWnd(hWnd),
      m_pData(NULL)
    {
    }
    LRESULT OnInitDialog( WPARAM, LPARAM lParam )
    {
        m_pData = reinterpret_cast<CData*>(lParam);
        if (!m_pData)
        {
            EndDialog( m_hWnd, IDCANCEL );
            return 0;
        }
        if (lstrlen(m_pData->Title()))
            SetWindowText(m_hWnd,m_pData->Title());
        SetDlgItemInt( m_hWnd, IDC_X, m_pData->X(), TRUE );
        SetDlgItemInt( m_hWnd, IDC_Y, m_pData->Y(), TRUE );
        return 0;
    }
    void OnCancel( WPARAM, LPARAM )
    {
        EndDialog( m_hWnd, IDCANCEL );
    }
    void OnOK( WPARAM, LPARAM )
    {
        m_pData->X(GetDlgItemInt( m_hWnd, IDC_X, NULL, TRUE ));
        m_pData->Y(GetDlgItemInt( m_hWnd, IDC_Y, NULL, TRUE ));
        EndDialog( m_hWnd, IDOK );
    }
    LRESULT OnCommand( WPARAM wParam, LPARAM lParam )
    {
       SC_BEGIN_COMMAND_HANDLERS()
       {
           SC_HANDLE_COMMAND(IDOK,OnOK);
           SC_HANDLE_COMMAND(IDCANCEL,OnCancel);
       }
       SC_END_COMMAND_HANDLERS();
    }
public:
    static INT_PTR CALLBACK DialogProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
    {
        SC_BEGIN_DIALOG_MESSAGE_HANDLERS(CGetXYDlg)
        {
            SC_HANDLE_DIALOG_MESSAGE( WM_INITDIALOG, OnInitDialog );
            SC_HANDLE_DIALOG_MESSAGE( WM_COMMAND, OnCommand );
        }
        SC_END_DIALOG_MESSAGE_HANDLERS();
    }
};

class CPreviewDlg
{
private:
    HWND m_hWnd;
    HWND m_hWndPreview;
    SIZE m_sizeResolution;
public:
    CPreviewDlg( HWND hWnd )
    : m_hWnd(hWnd),m_hWndPreview(NULL)
    {
        m_sizeResolution.cx = 1000;
        m_sizeResolution.cy = 1000;
    }
    ~CPreviewDlg(void)
    {
    }
    void OnPreviewSelChange( WPARAM, LPARAM )
    {
        POINT ptOriginLogical, ptOriginPhysical;
        SIZE  sizeExtentLogical, sizeExtentPhysical;
        WiaPreviewControl_GetSelOrigin( m_hWndPreview, 0, 0, &ptOriginLogical );
        WiaPreviewControl_GetSelOrigin( m_hWndPreview, 0, 1, &ptOriginPhysical );
        WiaPreviewControl_GetSelExtent( m_hWndPreview, 0, 0, &sizeExtentLogical );
        WiaPreviewControl_GetSelExtent( m_hWndPreview, 0, 1, &sizeExtentPhysical );
        SetWindowText( m_hWndPreview, TEXT("This is the window caption") );

        TCHAR szStr[MAX_PATH];
        wsprintf( szStr, TEXT("Log: (%d,%d), Phys: (%d,%d)"), sizeExtentLogical.cx, sizeExtentLogical.cy, sizeExtentPhysical.cx, sizeExtentPhysical.cy );
        SendDlgItemMessage( m_hWnd, IDC_EXTENT, WM_SETTEXT, 0, (LPARAM)szStr );
        wsprintf( szStr, TEXT("Log: (%d,%d), Phys: (%d,%d)"), ptOriginLogical.x, ptOriginLogical.y, ptOriginPhysical.x, ptOriginPhysical.y );
        SendDlgItemMessage( m_hWnd, IDC_ORIGIN, WM_SETTEXT, 0, (LPARAM)szStr );

    }
    LRESULT OnSize( WPARAM, LPARAM lParam )
    {
        RECT rcPreview;
        GetWindowRect( m_hWndPreview, &rcPreview );
        WiaUiUtil::ScreenToClient( m_hWnd, &rcPreview );
        MoveWindow( m_hWndPreview, rcPreview.left, rcPreview.top, LOWORD(lParam)-rcPreview.left-rcPreview.top, HIWORD(lParam)-rcPreview.top-rcPreview.top, TRUE );
        return 0;
    }
    void Update(void)
    {
        TCHAR szMsg[256];
        wsprintf( szMsg, TEXT("%d"), WiaPreviewControl_GetBorderSize( m_hWndPreview, FALSE ) );
        SendDlgItemMessage( m_hWnd, IDC_BORDERTEXT, WM_SETTEXT, 0, (LPARAM)szMsg );

        wsprintf( szMsg, TEXT("%d"), WiaPreviewControl_GetHandleSize( m_hWndPreview ) );
        SendDlgItemMessage( m_hWnd, IDC_SIZINGHANDLESTEXT, WM_SETTEXT, 0, (LPARAM)szMsg );

        wsprintf( szMsg, TEXT("%d"), WiaPreviewControl_GetBgAlpha( m_hWndPreview ) );
        SendDlgItemMessage( m_hWnd, IDC_ALPHAVALUETEXT, WM_SETTEXT, 0, (LPARAM)szMsg );
    }
    LRESULT OnInitDialog( WPARAM, LPARAM )
    {
        m_hWndPreview = GetDlgItem( m_hWnd, IDC_PREVIEW );
        SendDlgItemMessage( m_hWnd, IDC_BORDER, TBM_SETRANGE, TRUE, MAKELPARAM(0,25) );
        SendDlgItemMessage( m_hWnd, IDC_SIZINGHANDLES, TBM_SETRANGE, TRUE, MAKELPARAM(0,25) );
        SendDlgItemMessage( m_hWnd, IDC_ALPHAVALUE, TBM_SETRANGE, TRUE, MAKELPARAM(0,255) );
        SendDlgItemMessage( m_hWnd, IDC_BORDER, TBM_SETPOS, TRUE, WiaPreviewControl_GetBorderSize( m_hWndPreview, FALSE ) );
        SendDlgItemMessage( m_hWnd, IDC_SIZINGHANDLES, TBM_SETPOS, TRUE, WiaPreviewControl_GetHandleSize( m_hWndPreview ) );
        SendDlgItemMessage( m_hWnd, IDC_ALPHAVALUE, TBM_SETPOS, TRUE, WiaPreviewControl_GetBgAlpha( m_hWndPreview ) );
        SendDlgItemMessage( m_hWnd, IDC_NOIMAGE, BM_SETCHECK, BST_CHECKED, 0 );

        WiaPreviewControl_SetResolution( m_hWndPreview, &m_sizeResolution );

        PostMessage( m_hWnd, WM_COMMAND, MAKEWPARAM( IDC_PREVIEW, PWN_SELCHANGE ), 0 );

        Update();

        return 0;
    }
    void OnCancel( WPARAM, LPARAM )
    {
        EndDialog( m_hWnd, 0 );
    }

    void OnBitmapChange( WPARAM wParam, LPARAM )
    {
        HBITMAP hBitmap = NULL;
        switch (LOWORD(wParam))
        {
        case IDC_BW:
            hBitmap = (HBITMAP)LoadImage( g_hInstance, MAKEINTRESOURCE(IDB_BW), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION );
            break;
        case IDC_GRAY:
            hBitmap = (HBITMAP)LoadImage( g_hInstance, MAKEINTRESOURCE(IDB_GRAY), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION );
            break;
        case IDC_COLOR:
            hBitmap = (HBITMAP)LoadImage( g_hInstance, MAKEINTRESOURCE(IDB_COLOR), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION );
            break;
        }
        WiaPreviewControl_SetBitmap( m_hWndPreview, TRUE, FALSE, hBitmap );
    }

    LRESULT OnScroll( WPARAM, LPARAM lParam )
    {
        if (GetDlgItem(m_hWnd,IDC_BORDER)==(HWND)lParam)
        {
            int nSetting = static_cast<int>(SendDlgItemMessage( m_hWnd, IDC_BORDER, TBM_GETPOS, 0, 0 ));
            WiaPreviewControl_SetBorderSize( m_hWndPreview, TRUE, FALSE, nSetting );
            WiaPreviewControl_ClearSelection( m_hWndPreview );
        }
        if (GetDlgItem(m_hWnd,IDC_SIZINGHANDLES)==(HWND)lParam)
        {
            int nSetting = static_cast<int>(SendDlgItemMessage( m_hWnd, IDC_SIZINGHANDLES, TBM_GETPOS, 0, 0 ));
            WiaPreviewControl_SetHandleSize( m_hWndPreview, TRUE, nSetting );
        }
        if (GetDlgItem(m_hWnd,IDC_ALPHAVALUE)==(HWND)lParam)
        {
            int nSetting = static_cast<int>(SendDlgItemMessage( m_hWnd, IDC_ALPHAVALUE, TBM_GETPOS, 0, 0 ));
            WiaPreviewControl_SetBgAlpha( m_hWndPreview, TRUE, static_cast<BYTE>(nSetting) );
        }
        Update();
        return 0;
    }
    void OnDisabled( WPARAM, LPARAM )
    {
        EnableWindow( m_hWndPreview, BST_CHECKED!=SendDlgItemMessage( m_hWnd, IDC_DISABLED, BM_GETCHECK, 0, 0 ) );
    }
    void OnHandleStyle( WPARAM, LPARAM )
    {
        bool bRoundButtons = (BST_CHECKED==SendDlgItemMessage( m_hWnd, IDC_ROUNDHANDLES, BM_GETCHECK, 0, 0 ));
        bool bHollowHandle = (BST_CHECKED==SendDlgItemMessage( m_hWnd, IDC_HOLLOWHANDLE, BM_GETCHECK, 0, 0 ));

        UINT nStyle = 0;
        if (bRoundButtons)
            nStyle |= PREVIEW_WINDOW_ROUNDHANDLES;
        else nStyle |= PREVIEW_WINDOW_SQUAREHANDLES;

        if (bHollowHandle)
            nStyle |= PREVIEW_WINDOW_HOLLOWHANDLES;
        else nStyle |= PREVIEW_WINDOW_FILLEDHANDLES;

        WiaPreviewControl_SetHandleType( m_hWndPreview, TRUE, nStyle );
    }
    void OnPreviewMode( WPARAM, LPARAM )
    {
        bool bPreviewMode = (BST_CHECKED==SendDlgItemMessage( m_hWnd, IDC_PREVIEWMODE, BM_GETCHECK, 0, 0 ));
        WiaPreviewControl_SetPreviewMode( m_hWndPreview, bPreviewMode != FALSE );
    }
    void OnNullSelection( WPARAM, LPARAM )
    {
        bool bNullSelection = (BST_CHECKED==SendDlgItemMessage( m_hWnd, IDC_NULLSELECTION, BM_GETCHECK, 0, 0 ));
        WiaPreviewControl_AllowNullSelection( m_hWndPreview, bNullSelection != FALSE );
    }
    void OnDisableSelection( WPARAM, LPARAM )
    {
        bool bDisableSelection = (BST_CHECKED==SendDlgItemMessage( m_hWnd, IDC_DISABLESELECTION, BM_GETCHECK, 0, 0 ));
        WiaPreviewControl_DisableSelection( m_hWndPreview, bDisableSelection != FALSE );
    }
    void OnSolidSelection( WPARAM, LPARAM )
    {
        bool bSolidSelection = (BST_CHECKED==SendDlgItemMessage( m_hWnd, IDC_SOLIDSELECTION, BM_GETCHECK, 0, 0 ));
        bool bDoubleWidth = (BST_CHECKED==SendDlgItemMessage( m_hWnd, IDC_DOUBLEWIDTH, BM_GETCHECK, 0, 0 ));
        WiaPreviewControl_SetBorderStyle( m_hWndPreview, TRUE, bSolidSelection ? PS_SOLID : PS_DOT, bDoubleWidth ? 2 : 0 );
    }
    BOOL GetColor( COLORREF &cr )
    {
        static COLORREF crCustom[16];
        CHOOSECOLOR cc;
        ZeroMemory(&cc,sizeof(cc));
        ZeroMemory(&crCustom,sizeof(crCustom));
        cc.lStructSize = sizeof(cc);
        cc.hwndOwner = m_hWnd;
        cc.rgbResult = cr;
        cc.lpCustColors = crCustom;
        cc.Flags = CC_ANYCOLOR|CC_RGBINIT;
        if (ChooseColor(&cc))
        {
            cr = cc.rgbResult;
            return TRUE;
        }
        return FALSE;
    }
    void OnSelectedBorderColor( WPARAM, LPARAM )
    {
        COLORREF cr = 0;
        if (GetColor(cr))
        {
            WiaPreviewControl_SetBorderColor( m_hWndPreview, TRUE, PREVIEW_WINDOW_SELECTED, cr );
        }
    }
    void OnUnselectedBorderColor( WPARAM, LPARAM )
    {
        COLORREF cr = 0;
        if (GetColor(cr))
        {
            WiaPreviewControl_SetBorderColor( m_hWndPreview, TRUE, PREVIEW_WINDOW_UNSELECTED, cr );
        }
    }
    void OnDisableBorderColor( WPARAM, LPARAM )
    {
        COLORREF cr = 0;
        if (GetColor(cr))
        {
            WiaPreviewControl_SetBorderColor( m_hWndPreview, TRUE, PREVIEW_WINDOW_DISABLED, cr );
        }
    }
    void OnSelectedHandleColor( WPARAM, LPARAM )
    {
        COLORREF cr = 0;
        if (GetColor(cr))
        {
            WiaPreviewControl_SetHandleColor( m_hWndPreview, TRUE, PREVIEW_WINDOW_SELECTED, cr );
        }
    }
    void OnUnselectedHandleColor( WPARAM, LPARAM )
    {
        COLORREF cr = 0;
        if (GetColor(cr))
        {
            WiaPreviewControl_SetHandleColor( m_hWndPreview, TRUE, PREVIEW_WINDOW_UNSELECTED, cr );
        }
    }
    void OnDisableHandleColor( WPARAM, LPARAM )
    {
        COLORREF cr = 0;
        if (GetColor(cr))
        {
            WiaPreviewControl_SetHandleColor( m_hWndPreview, TRUE, PREVIEW_WINDOW_DISABLED, cr );
        }
    }
    void OnInnerColor( WPARAM, LPARAM )
    {
        COLORREF cr = 0;
        if (GetColor(cr))
        {
            WiaPreviewControl_SetBkColor( m_hWndPreview, TRUE, FALSE, cr );
        }
    }
    void OnOuterColor( WPARAM, LPARAM )
    {
        COLORREF cr = 0;
        if (GetColor(cr))
        {
            WiaPreviewControl_SetBkColor( m_hWndPreview, TRUE, TRUE, cr );
        }
    }
    void OnSetOrigin( WPARAM, LPARAM )
    {
        CSimpleString strTitle;
        POINT ptOrigin;
        WiaPreviewControl_GetSelOrigin( m_hWndPreview, 0, 0, &ptOrigin );
        strTitle.Format( TEXT("Enter Origin - Current Res: (%d,%d):"), m_sizeResolution.cx, m_sizeResolution.cy );
        CGetXYDlg::CData data;
        data.Title(strTitle);
        data.X( ptOrigin.x );
        data.Y( ptOrigin.y );
        INT_PTR nResult = DialogBoxParam( g_hInstance, MAKEINTRESOURCE(IDD_GETXYDLG), m_hWnd, CGetXYDlg::DialogProc, reinterpret_cast<LPARAM>(&data) );
        if (IDOK == nResult)
        {
            ptOrigin.x = data.X();
            ptOrigin.y = data.Y();
            WiaPreviewControl_SetResolution( m_hWndPreview, &m_sizeResolution );
            WiaPreviewControl_SetSelOrigin( m_hWndPreview, 0, 0, &ptOrigin );
        }
    }
    void OnSetExtent( WPARAM, LPARAM )
    {
        CSimpleString strTitle;
        SIZE sizeExtent;
        WiaPreviewControl_GetSelExtent( m_hWndPreview, 0, 0, &sizeExtent );
        strTitle.Format( TEXT("Enter Extent - Current Res: (%d,%d):"), m_sizeResolution.cx, m_sizeResolution.cy );
        CGetXYDlg::CData data;
        data.Title(strTitle);
        data.X( sizeExtent.cx );
        data.Y( sizeExtent.cy );
        INT_PTR nResult = DialogBoxParam( g_hInstance, MAKEINTRESOURCE(IDD_GETXYDLG), m_hWnd, CGetXYDlg::DialogProc, reinterpret_cast<LPARAM>(&data) );
        if (IDOK == nResult)
        {
            sizeExtent.cx = data.X();
            sizeExtent.cy = data.Y();
            WiaPreviewControl_SetResolution( m_hWndPreview, &m_sizeResolution );
            WiaPreviewControl_SetSelExtent( m_hWndPreview, 0, 0, &sizeExtent );
        }
    }
    void OnSetProgress( WPARAM, LPARAM )
    {
        WiaPreviewControl_SetProgress(m_hWndPreview,!WiaPreviewControl_GetProgress(m_hWndPreview));
    }
    LRESULT OnCommand( WPARAM wParam, LPARAM lParam )
    {
        SC_BEGIN_COMMAND_HANDLERS()
        {
            SC_HANDLE_COMMAND( IDC_PREVIEW, OnPreviewSelChange );
            SC_HANDLE_COMMAND( IDCANCEL, OnCancel );
            SC_HANDLE_COMMAND( IDC_BW, OnBitmapChange );
            SC_HANDLE_COMMAND( IDC_GRAY, OnBitmapChange );
            SC_HANDLE_COMMAND( IDC_COLOR, OnBitmapChange );
            SC_HANDLE_COMMAND( IDC_NOIMAGE, OnBitmapChange );
            SC_HANDLE_COMMAND( IDC_DISABLED, OnDisabled );
            SC_HANDLE_COMMAND( IDC_ROUNDHANDLES, OnHandleStyle );
            SC_HANDLE_COMMAND( IDC_HOLLOWHANDLE, OnHandleStyle );
            SC_HANDLE_COMMAND( IDC_PREVIEWMODE, OnPreviewMode );
            SC_HANDLE_COMMAND( IDC_NULLSELECTION, OnNullSelection );
            SC_HANDLE_COMMAND( IDC_DISABLESELECTION, OnDisableSelection );
            SC_HANDLE_COMMAND( IDC_INNERCOLOR, OnInnerColor );
            SC_HANDLE_COMMAND( IDC_OUTERCOLOR, OnOuterColor );
            SC_HANDLE_COMMAND( IDC_SOLIDSELECTION, OnSolidSelection );
            SC_HANDLE_COMMAND( IDC_DOUBLEWIDTH, OnSolidSelection );
            SC_HANDLE_COMMAND( IDC_SELECTEDBORDERCOLOR, OnSelectedBorderColor );
            SC_HANDLE_COMMAND( IDC_UNSELECTEDBORDERCOLOR, OnUnselectedBorderColor );
            SC_HANDLE_COMMAND( IDC_DISABLEBORDERCOLOR, OnDisableBorderColor );
            SC_HANDLE_COMMAND( IDC_SELECTEDHANDLECOLOR, OnSelectedHandleColor );
            SC_HANDLE_COMMAND( IDC_UNSELECTEDHANDLECOLOR, OnUnselectedHandleColor );
            SC_HANDLE_COMMAND( IDC_DISABLEHANDLECOLOR, OnDisableHandleColor );
            SC_HANDLE_COMMAND( IDC_SETORIGIN, OnSetOrigin );
            SC_HANDLE_COMMAND( IDC_SETEXTENT, OnSetExtent );
            SC_HANDLE_COMMAND( IDC_SETPROGRESS, OnSetProgress );
        }
        SC_END_COMMAND_HANDLERS();
    }

    LRESULT OnEnterSizeMove( WPARAM, LPARAM )
    {
        SendDlgItemMessage( m_hWnd, IDC_PREVIEW, WM_ENTERSIZEMOVE, 0, 0 );
        return 0;
    }

    LRESULT OnExitSizeMove( WPARAM, LPARAM )
    {
        SendDlgItemMessage( m_hWnd, IDC_PREVIEW, WM_EXITSIZEMOVE, 0, 0 );
        return 0;
    }

    static INT_PTR CALLBACK DialogProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
    {
        SC_BEGIN_DIALOG_MESSAGE_HANDLERS(CPreviewDlg)
        {
            SC_HANDLE_DIALOG_MESSAGE( WM_INITDIALOG, OnInitDialog );
            SC_HANDLE_DIALOG_MESSAGE( WM_COMMAND, OnCommand );
            SC_HANDLE_DIALOG_MESSAGE( WM_SIZE, OnSize );
            SC_HANDLE_DIALOG_MESSAGE( WM_HSCROLL, OnScroll );
            SC_HANDLE_DIALOG_MESSAGE( WM_ENTERSIZEMOVE, OnEnterSizeMove );
            SC_HANDLE_DIALOG_MESSAGE( WM_EXITSIZEMOVE, OnExitSizeMove );
        }
        SC_END_DIALOG_MESSAGE_HANDLERS();
    }
};

int WINAPI WinMain( HINSTANCE hInstance, HINSTANCE, LPSTR, int )
{
    WIA_DEBUG_CREATE( hInstance );
    g_hInstance = hInstance;
    SHFusionInitialize(NULL);
    InitCommonControls();
    RegisterWiaPreviewClasses( g_hInstance );
    if (-1==DialogBoxParam( hInstance, MAKEINTRESOURCE(IDD_TESTDLG), NULL, CPreviewDlg::DialogProc, NULL ))
    {
        DWORD dwError = GetLastError();
    }
    SHFusionUninitialize();
    WIA_DEBUG_DESTROY();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\unittest\remall\remall.cpp ===
#include <windows.h>
#include <objbase.h>
#include <atlbase.h>
#include <wianew.h>
#include <simreg.h>
#include <dumpprop.h>
#include <devlist.h>
#include <simbstr.h>
#include <stdio.h>


typedef HANDLE (WINAPI *WiaAddDeviceProc)();
typedef BOOL (WINAPI *WiaRemoveDeviceProc)(STI_DEVICE_INFORMATION *);

HINSTANCE g_hInstance;

bool RemoveDevice( LPCWSTR pszDeviceId )
{
    bool bResult = false;
    CComPtr<IStillImage> pStillImage;
    if (SUCCEEDED(StiCreateInstance( g_hInstance, STI_VERSION, &pStillImage, NULL)) && pStillImage)
    {
        HINSTANCE hClassInstaller = LoadLibrary(TEXT("sti_ci.dll"));
        if (hClassInstaller)
        {
            WiaRemoveDeviceProc pfnWiaRemoveDeviceProc = reinterpret_cast<WiaRemoveDeviceProc>(GetProcAddress(hClassInstaller, "WiaRemoveDevice"));
            if (pfnWiaRemoveDeviceProc)
            {
                STI_DEVICE_INFORMATION *pStiDeviceInformation = NULL;
                if (SUCCEEDED(pStillImage->GetDeviceInfo( const_cast<LPWSTR>(pszDeviceId), reinterpret_cast<LPVOID*>(&pStiDeviceInformation))) && pStiDeviceInformation )
                {
                    bResult = (pfnWiaRemoveDeviceProc( pStiDeviceInformation ) != FALSE);
                    if (!bResult)
                    {
                        wprintf( L"WiaRemoveDeviceProc failed\n"); 
                    }

                    LocalFree(pStiDeviceInformation);
                }
                else
                {
                    wprintf( L"GetDeviceInfo on %ws failed\n", pszDeviceId ); 
                }
            }
            else
            {
                wprintf( L"GetProcAddress on WiaRemoveDeviceProc failed\n"); 
            }
            FreeLibrary( hClassInstaller );
        }
        else
        {
            wprintf( L"LoadLibrary failed\n"); 
        }
    }
    else
    {
        wprintf( L"StiCreateInstance failed\n"); 
    }
    return bResult;
}


void RemoveAllDevices()
{
    HRESULT hr = CoInitialize(NULL);
    if (SUCCEEDED(hr))
    {
        CComPtr<IWiaDevMgr> pWiaDevMgr;
        if (SUCCEEDED(CoCreateInstance( CLSID_WiaDevMgr, NULL, CLSCTX_LOCAL_SERVER, IID_IWiaDevMgr, (void**)&pWiaDevMgr )))
        {
            CDeviceList DeviceList( pWiaDevMgr );
            for (int i=0;i<DeviceList.Size();++i)
            {
                CSimpleStringWide strwDeviceId;
                if (PropStorageHelpers::GetProperty( DeviceList[i], WIA_DIP_DEV_ID, strwDeviceId ))
                {
                    CSimpleStringWide strwDeviceName;
                    PropStorageHelpers::GetProperty( DeviceList[i], WIA_DIP_DEV_NAME, strwDeviceName );
                    wprintf( L"Removing %ws -- %ws\n", strwDeviceId.String(), strwDeviceName.String() );
                    wprintf( L"%ws\n", RemoveDevice( strwDeviceId ) ? L"succeeded" : L"failed" );
                }
            }
        }
    }
    CoUninitialize();
}

int __cdecl wmain( int argc, wchar_t *argv[] )
{
    g_hInstance = GetModuleHandle(NULL);
    WIA_DEBUG_CREATE(g_hInstance);
    
    bool bRemove = false;
    for (int i=1;i<argc;i++)
    {
        if (L'/' == argv[i][0] || L'-' == argv[i][0])
        {
            switch (argv[i][1])
            {
            case L'y':
            case L'Y':
                bRemove = true;
                break;
            }
        }
    }

    if (!bRemove)
    {
        wprintf( L"Do you want to remove all of your WIA devices? (y/n): " );
        int chResponse = getchar();
        if (L'y' == chResponse || L'Y' == chResponse)
        {
            bRemove = true;
        }
    }

    if (bRemove)
    {
        RemoveAllDevices();
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\upnp\msprjctr\server\precomp.h ===
#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

// included for debug library
#include "cplusinc.h"
#include "sticomm.h"

#include "coredbg.h"

#endif //_PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\upnp\msprjctr\server\precomp.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  PrjctrUI.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\unittest\testacqd\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by testacqd.rc
//
#define IDS_MESSAGEBOXTESTMESSAGE       1
#define IDS_MESSAGEBOXTESTTITLE         2
#define IDS_MESSAGEBOXTESTFORMAT        3
#define IDI_TESTACQD                    101
#define IDB_TESTIMAGE                   101
#define IDD_PROGRESS_DIALOG_SETTINGS    102
#define IDR_TESTACQDMENU                102
#define IDD_MBOXFLAGS                   103
#define IDR_TESTACQDACCEL               104
#define IDC_PROGDLG_TITLE               1000
#define IDC_PROGDLG_ANIM                1001
#define IDC_PROGDLG_PROGRESS            1002
#define IDC_PROGDLG_CANCEL              1003
#define IDC_PROGDLG_SCAN_CONNECT        1004
#define IDC_PROGDLG_CAMERA_CONNECT      1005
#define IDC_PROGDLG_VIDEO_CONNECT       1006
#define IDC_PROGDLG_SCAN_ACQUIRE        1007
#define IDC_PROGDLG_CAMERA_ACQUIRE      1008
#define IDC_PROGDLG_VIDEO_ACQUIRE       1009
#define IDC_PROGDLG_DEFAULT_CONNECT     1010
#define IDC_MBEX_DEFBUTTON2             1021
#define IDC_MBEX_DEFBUTTON3             1022
#define IDC_MBEX_DEFBUTTON4             1023
#define IDC_MBEX_DEFBUTTON5             1024
#define IDC_MBEX_ICONWARNING            1025
#define IDC_MBEX_ICONINFORMATION        1026
#define IDC_MBEX_ICONQUESTION           1027
#define IDC_MBEX_ICONERROR              1028
#define IDC_MBEX_OK                     1029
#define IDC_MBEX_OKCANCEL               1030
#define IDC_MBEX_YESNO                  1031
#define IDC_MBEX_YESNOCANCEL            1032
#define IDC_MBEX_CANCELRETRYSKIPSKIP    1033
#define IDC_MBEX_CANCELRETRYSKIPSKIPALL 1034
#define IDC_MBEX_DEFBUTTON1             1035
#define IDC_MBEX_YESYESTOALLNONOTOALL   1036
#define ID_PROGRAM_EXIT                 40003
#define ID_PROGRESS_TESTPROGRESS        40007
#define ID_WIA_DEVICEDLG                40008
#define ID_PROGRESS_SETFLAGS            40009
#define ID_GDI_ROTATEFILENONJPEG        40010
#define ID_GDI_ROTATEFILEJPEG           40011
#define ID_GDI_LOADANDSCALEIMAGE        40012
#define ID_GDI_CONVERTFILE              40013
#define ID_GDI_DISPLAYDECODEREXTENSIONS 40014
#define ID_GDI_ROTATEHBITMAP            40015
#define ID_WIZARD_ACQUIRE_WIZARD        40016
#define ID_WIZARD_PUBLISH_WIZARD        40017
#define ID_WIA_SELECTDEVICEID           40018
#define ID_MBOX_FORM1                   40019
#define ID_MBOX_FORM2                   40020
#define ID_MBOX_FORM3                   40021
#define ID_MBOX_FORM4                   40022
#define ID_MBOX_FORM5                   40023
#define ID_MBOX_FORM6                   40024
#define ID_MBOX_FORM7                   40025
#define ID_GDI_DISPLAYENCODEREXTENSIONS 40026
#define ID_MBOX_SETFLAGS                40027
#define ID_GDI_SAVEMULTIPLEIMAGESASMULTIPAGE 40028
#define ID_WIZARD_EXPLOREWIADEVICE      40029
#define ID_GDI_SETCONTRAST              40030
#define ID_GDI_SETBRIGHTNESS            40031
#define ID_GDI_SETTHRESHOLD             40032
#define ID_GDI_INCREASETHRESHOLD        40033
#define ID_GDI_DECREASETHRESHOLD        40034
#define ID_GDI_DECREASECONTRAST         40035
#define ID_GDI_INCREASECONTRAST         40036
#define ID_GDI_INCREASEBRIGHTNESS       40037
#define ID_GDI_DECREASEBRIGHTNESS       40038
#define ID_GDI_LOADANDSCALESTREAM       40039
#define ID_UPNP_FINDSERVERANDREGISTER   40040
#define ID_UPNP_STOP                    40041
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         40042
#define _APS_NEXT_CONTROL_VALUE         1016
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\unittest\testacqd\sources.inc ===
#
# include the WIA global build settings
#

USE_SHFUSION = 1


!include          $(PROJECT_ROOT)\ui\uienv.inc
SOURCES_USED    = $(SOURCES_USED) $(PROJECT_ROOT)\ui\uienv.inc

#
# Our specific build settings
#

NO_BROWSER_FILE = 1

ATL_VER         = 30
USE_STATIC_ATL  = 1

TARGETNAME=testacqd
TARGETTYPE=PROGRAM
TARGETPATH=obj

USE_MSVCRT = 1

C_DEFINES=$(C_DEFINES)


INCLUDES= $(INCLUDES); \
          $(BASEDIR)\private\inc;

SOURCES= \
        ..\main.cpp \
        ..\testacqd.rc

TARGETLIBS=$(TARGETLIBS)\
        $(LIBRARY_PATH)\urlmon.lib \
        $(SHELL_LIB_PATH)\shfusion.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\upnp\msprjctr\server\cfgdlg.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// File:            cfgDlg.cpp
//
// Description:     
//
// Copyright (c) 2000 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////////////

// App Includes
#include "precomp.h"
#include "resource.h"
#include "main.h"
#include "msprjctr.h"
#include "msprjctr_i.c"

#include <atlconv.h>
#include <commctrl.h>
#include <shlobj.h>
#include <shlwapi.h>

///////////////////////////////
// ErrorState_Enum
//
typedef enum
{
    ErrorState_NONE                         = 0,
    ErrorState_IMAGE_DIR_DOESNT_EXIST       = 1,
    ErrorState_DEVICE_DIR_DOESNT_EXIST      = 2,
    ErrorState_SLIDESHOW_SERVER_NOT_FOUND   = 3,
    ErrorState_FAILED_TO_START_SLIDESHOW    = 4
} ErrorState_Enum;


///////////////////////////
// GVAR_LOCAL
//
// Global Variable
//
static struct GVAR_LOCAL
{
    HINSTANCE           hInstance;
    HWND                hwndMain;
    ErrorState_Enum     ErrorState;
    TCHAR               szImagePath[MAX_PATH];
} GVAR_LOCAL = 
{
    NULL,
    NULL, 
    ErrorState_NONE
};

///////////////////////////////
// GVAR_pSlideshowProjector
//
CComPtr<IUPnPDeviceProvider> GVAR_pProjector;


// Custom user message
#define WM_USER_TASKBAR     WM_USER + 100


////////////////////////// Function Prototypes ////////////////////////////////

INT_PTR CALLBACK DlgProc(HWND   hwndDlg,
                         UINT   uiMsg,
                         WPARAM wParam,
                         LPARAM lParam);

static int InitDlg(HWND hwndDlg);

static int ProcessWMCommand(HWND   hwndDlg,
                            UINT   uiMsg,
                            WPARAM wParam,
                            LPARAM lParam);

static int ProcessTaskbarMsg(HWND    hwnd,
                             UINT    uiMessage,
                             WPARAM  wParam, 
                             LPARAM  lParam);

static int ProcessScroll(HWND    hwndDlg,
                         HWND    hwndScroll);

static HRESULT LoadCurrentSettings();
static HRESULT SaveCurrentSettings();
static HRESULT ShowConfigWindow();
static BOOL IsChecked(INT iResID);

static void ProcessError(ErrorState_Enum     ErrorState);
static HRESULT SetImageFreqTrackbar(DWORD   dwImageFreq);
static HRESULT SetImageScaleTrackbar(DWORD   dwImageScaleFactor);
static void EnableApplyButton(BOOL bEnable);

static HRESULT GetFirstSlideshowService(ISlideshowService   **ppSlideshowService,
                                        ISlideshowAlbum     **ppSlideshowAlbum);


//////////////////////////////
// CfgDlg::Init
//
HRESULT CfgDlg::Init(HINSTANCE hInstance)
{
    HRESULT hr = S_OK;
    TCHAR   szImageDir[_MAX_PATH + 1]   = {0};
    TCHAR   szDeviceDir[_MAX_PATH + 1]  = {0};

    GVAR_LOCAL.hInstance = hInstance;

    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(CLSID_Projector,
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_IUPnPDeviceProvider,
                              (void**) &GVAR_pProjector);

        if (FAILED(hr))
        {
            DBG_ERR(("Failed to CoCreate CLSID_SlideshowDevice.  Is the "
                     "server DLL registered?, hr = 0x%08lx",
                     hr));

            GVAR_LOCAL.ErrorState = ErrorState_SLIDESHOW_SERVER_NOT_FOUND;
        }
    }

    ASSERT(GVAR_pProjector != NULL);

    return hr;
}

//////////////////////////////
// CfgDlg::Term
//
HRESULT CfgDlg::Term()
{
    HRESULT hr = S_OK;

    return hr;
}

//////////////////////////////
// CfgDlg::Create
//
HWND CfgDlg::Create(int nCmdShow)
{
    HWND hwnd = CreateDialog(GVAR_LOCAL.hInstance, 
                                     MAKEINTRESOURCE(IDD_CONFIG_DIALOG), 
                                     NULL, 
                                     DlgProc);

    // this is set in InitDlg
    if (GVAR_LOCAL.hwndMain != NULL)
    {
        Tray::Init(GVAR_LOCAL.hInstance,
                   GVAR_LOCAL.hwndMain,
                   WM_USER_TASKBAR);

        ::ShowWindow(GVAR_LOCAL.hwndMain, nCmdShow);
    }

    return GVAR_LOCAL.hwndMain;
}

//////////////////////////////
// ProcessError
//
static void ProcessError(ErrorState_Enum     ErrorState)
{
    HRESULT hr                          = S_OK;
    TCHAR   szErrMsg[255 + 1]           = {0};
    TCHAR   szCaption[63 + 1]           = {0};

    if (ErrorState == ErrorState_NONE)
    {
        return;
    }

    Util::GetString(GVAR_LOCAL.hInstance,
                    IDS_ERR_CAPTION,
                    szCaption,
                    sizeof(szCaption) / sizeof(TCHAR));

    if (ErrorState == ErrorState_SLIDESHOW_SERVER_NOT_FOUND)
    {
        Util::GetString(GVAR_LOCAL.hInstance,
                        IDS_ERR_SLIDESHOW_SERVER_NOT_FOUND,
                        szErrMsg,
                        sizeof(szErrMsg) / sizeof(TCHAR));
    }
    else if (ErrorState == ErrorState_FAILED_TO_START_SLIDESHOW)
    {
        Util::GetString(GVAR_LOCAL.hInstance,
                        IDS_ERR_FAILED_TO_START_SLIDESHOW,
                        szErrMsg,
                        sizeof(szErrMsg) / sizeof(TCHAR));
    }
    else
    {
        Util::GetString(GVAR_LOCAL.hInstance,
                        IDS_ERR_SERVER_ERROR,
                        szErrMsg,
                        sizeof(szErrMsg) / sizeof(TCHAR));
    }

    MessageBox(GVAR_LOCAL.hwndMain, 
               szErrMsg,
               szCaption,
               MB_ICONERROR | MB_OK);

    return;
}

//////////////////////////////
// InitDlg
//
static int InitDlg(HWND hwndDlg)
{
    HRESULT hr = S_OK;

    GVAR_LOCAL.hwndMain = hwndDlg;

    //
    // set the image frequency trackbar range.
    //
    SendDlgItemMessage(hwndDlg,
                       IDC_FREQUENCY,
                       TBM_SETRANGE,
                       (WPARAM) TRUE, 
                       (LPARAM) MAKELONG(MIN_IMAGE_FREQ_IN_SEC, MAX_IMAGE_FREQ_IN_SEC));

    //
    // set the image scale factor range.
    //
    SendDlgItemMessage(hwndDlg,
                       IDC_MAX_SIZE,
                       TBM_SETRANGE,
                       (WPARAM) TRUE, 
                       (LPARAM) MAKELONG(MIN_IMAGE_SCALE_FACTOR, MAX_IMAGE_SCALE_FACTOR));

    // these are just initial settings in case we fail to load the last
    // saved settings.
    //
    SetImageFreqTrackbar(MIN_IMAGE_FREQ_IN_SEC);
    SetImageScaleTrackbar(MAX_IMAGE_SCALE_FACTOR);

    if (GVAR_LOCAL.ErrorState == ErrorState_NONE)
    {
        if (GVAR_pProjector)
        {
            BSTR bstrInitString = SysAllocString(L"");

            // Start the Projector!
            hr = GVAR_pProjector->Start(bstrInitString);
            
            if (bstrInitString)
            {
                ::SysFreeString(bstrInitString);
                bstrInitString = NULL;
            }

            if (FAILED(hr))
            {
                GVAR_LOCAL.ErrorState = ErrorState_FAILED_TO_START_SLIDESHOW;
            }
        }
    
        if (SUCCEEDED(hr))
        {
            LoadCurrentSettings();
        }
    }
        
    ProcessError(GVAR_LOCAL.ErrorState);

    return 0;
}

//////////////////////////////
// TermDlg
//
static bool TermDlg()
{
    HRESULT hr = S_OK;

    if (GVAR_pProjector)
    {
        // Stop the projector
        //
        GVAR_pProjector->Stop();
    }

    Tray::Term(GVAR_LOCAL.hwndMain);
    DestroyWindow(GVAR_LOCAL.hwndMain);

    return true;
}

//////////////////////////////
// DlgProc
//
INT_PTR CALLBACK DlgProc(HWND   hwndDlg,
                         UINT   uiMsg,
                         WPARAM wParam,
                         LPARAM lParam)
{
    int iReturn = 0;

    switch(uiMsg)
    {
        case WM_INITDIALOG:

            // intialize the controls on the dialog.
            InitDlg(hwndDlg);

            iReturn = TRUE;
        break;

        case WM_CLOSE:

            // rather than closing the window when the user hits the
            // X, we hide it, thereby keeping the taskbar icon.
            ShowWindow(hwndDlg, SW_HIDE);
        break;

        case WM_DESTROY:

            // if we are destroying the window, then lets 
            // exit the app.
            ::PostQuitMessage(0);
        break;

        case WM_COMMAND:
            iReturn = ProcessWMCommand(hwndDlg,
                                       uiMsg,
                                       wParam,
                                       lParam);
        break;

        case WM_USER_TASKBAR:
            iReturn = ProcessTaskbarMsg(hwndDlg,
                                        uiMsg,
                                        wParam,
                                        lParam);
        break;

        case WM_HSCROLL:
            ProcessScroll(hwndDlg, (HWND) lParam);
        break;

        default:
            iReturn = 0;
        break;
    }
    
    return iReturn;
}

///////////////////////////////
// ProcessWMCommand
//
static int ProcessWMCommand(HWND   hwndDlg,
                            UINT   uiMsg,
                            WPARAM wParam,
                            LPARAM lParam)
{
    int iReturn = 0;
    int iControlID  = LOWORD(wParam);
    int iNotifyCode = HIWORD(wParam);

    switch (iControlID)
    {
        case IDOK:

            // the user hit the OK button, save the setting changes
            // they made, and hide the window.
            SaveCurrentSettings();
            ShowWindow(hwndDlg, SW_HIDE);
        break;

        case IDCANCEL:

            // abandoning changes made by the user.
            ShowWindow(hwndDlg, SW_HIDE);
            EnableApplyButton(FALSE);
        break;

        case IDC_APPLY:

            // the user hit the APPLY button, save the setting changes
            // they made, but don't hide the window
            SaveCurrentSettings();
        break;

        case IDC_ALLOWSTRETCHING:
        case IDC_DISPLAYFILENAME:
        case IDC_ALLOW_KEYBOARDCONTROL:
            EnableApplyButton(TRUE);
        break;

        case IDM_POPUP_OPEN:
            ShowConfigWindow();
        break;

        case IDM_POPUP_EXIT:
            TermDlg();
        break;

        case IDC_BROWSE:
        {
            TCHAR szTitle[127 + 1] = {0};
            bool  bNewDirSelected = false;

            LoadString(GVAR_LOCAL.hInstance, 
                       IDS_PLEASE_SELECT_IMAGE_DIR,
                       szTitle,
                       sizeof(szTitle) / sizeof(TCHAR));

            // popup the browse for directories dialog.
            // On return this dialog returns the directory selected
            // by the user.
            bNewDirSelected = Util::BrowseForDirectory(hwndDlg,
                                                      szTitle,
                                                      GVAR_LOCAL.szImagePath,
                                                      sizeof(GVAR_LOCAL.szImagePath) / sizeof(TCHAR));

            if (bNewDirSelected)
            {
                HDC   hDC          = NULL;
                TCHAR szImageDir[MAX_PATH + 1] = {0};
                RECT  rc           = {0};

                _tcsncpy(szImageDir, 
                         GVAR_LOCAL.szImagePath, 
                         sizeof(szImageDir) / sizeof(TCHAR));

                hDC = GetDC(GetDlgItem(GVAR_LOCAL.hwndMain, IDC_IMAGEDIR));
                GetClientRect(GetDlgItem(GVAR_LOCAL.hwndMain, IDC_IMAGEDIR), &rc);

                PathCompactPath(hDC, szImageDir, rc.right - rc.left);

                SetDlgItemText(GVAR_LOCAL.hwndMain,
                               IDC_IMAGEDIR,
                               szImageDir);

                if (hDC)
                {
                    ReleaseDC(GetDlgItem(GVAR_LOCAL.hwndMain, IDC_IMAGEDIR), hDC);
                    hDC = NULL;
                }

                EnableApplyButton(TRUE);
            }
        }
        break;

        default:
        break;
    }

    return iReturn;
}

//////////////////////////////////////////////////////////////////////
// ProcessTaskbarMsg
//
// Desc:       Function is called when there is an event at the taskbar
//             
//
// Params:     - hwnd, handle of main window.
//             - uiMessage, message sent.
static int ProcessTaskbarMsg(HWND    hwnd,
                             UINT    uiMessage,
                             WPARAM  wParam, 
                             LPARAM  lParam) 
{ 
    int  iReturn = 0;
    UINT uID; 
    UINT uMouseMsg; 
 
    uID       = (UINT) wParam; 
    uMouseMsg = (UINT) lParam; 

    // remove unref param warning
    uiMessage = uiMessage;
 
    switch (uMouseMsg)
    {
        case WM_LBUTTONDBLCLK:

            ShowConfigWindow();

        break;

        case WM_LBUTTONDOWN:

        break;

        case WM_RBUTTONDOWN:
            Tray::PopupMenu(hwnd);
        break;
    }

    return iReturn; 
} 

///////////////////////////////
// ShowConfigWindow
//
static int ProcessScroll(HWND hwndDlg,
                         HWND hwndScroll)
{
    ASSERT(hwndScroll != NULL);

    int     iReturn             = 0;
    HRESULT hr                  = S_OK;
    TCHAR   szString[255 + 1]   = {0};

    if (hwndScroll == NULL)
    {
        return E_INVALIDARG;
    }

    if (GetDlgItem(hwndDlg, IDC_FREQUENCY) == hwndScroll)
    {
        UINT nFrequency = (UINT)SendDlgItemMessage(hwndDlg, 
                                                   IDC_FREQUENCY, 
                                                   TBM_GETPOS, 
                                                   0, 0 );

        SetImageFreqTrackbar(nFrequency);

        hr = Util::FormatTime(GVAR_LOCAL.hInstance, 
                             nFrequency,
                             szString,
                             sizeof(szString) / sizeof(TCHAR));

        SendDlgItemMessage(hwndDlg, 
                           IDC_MINUTES_AND_SECONDS, 
                           WM_SETTEXT, 
                           0, 
                           (LPARAM) szString);
    }
    else if (GetDlgItem(hwndDlg, IDC_MAX_SIZE) == hwndScroll)
    {
        UINT nScaleFactor = (UINT)SendDlgItemMessage(hwndDlg, 
                                                     IDC_MAX_SIZE, 
                                                     TBM_GETPOS, 
                                                     0, 0 );

        SetImageScaleTrackbar(nScaleFactor);
    }

    EnableApplyButton(TRUE);

    return iReturn;
}


///////////////////////////////
// ShowConfigWindow
//
static HRESULT ShowConfigWindow()
{
    HRESULT hr = S_OK;

    // reload our settings from the DLL to ensure that
    // we are reflecting the real state of the settings.

    LoadCurrentSettings();

    // popup the window on double click.  
    ShowWindow(GVAR_LOCAL.hwndMain,
               SW_SHOW);

    // make sure we are the foreground window.
    SetForegroundWindow(GVAR_LOCAL.hwndMain);

    return hr;
}

///////////////////////////////
// IsChecked
//
static BOOL IsChecked(INT iResID)
{
    LRESULT    lState   = 0;
    BOOL       bChecked = TRUE;

    // Get the Display File Name 
    lState = SendDlgItemMessage(GVAR_LOCAL.hwndMain,
                                iResID,
                                BM_GETCHECK,
                                0, 
                                0);
    if (lState == BST_CHECKED)
    {
        bChecked = TRUE;
    }
    else
    {
        bChecked = FALSE;
    }

    return bChecked;
}


///////////////////////////////
// SetImageFreqTrackbar
//
static HRESULT SetImageFreqTrackbar(DWORD   dwImageFreq)
{
    HRESULT hr = S_OK;

    if (SUCCEEDED(hr))
    {
        TCHAR   szTime[255 + 1] = {0};

        // set the trackbar's current position.
        SendDlgItemMessage(GVAR_LOCAL.hwndMain,
                           IDC_FREQUENCY,
                           TBM_SETPOS,
                           (WPARAM) TRUE,
                           (LPARAM) dwImageFreq);

        hr = Util::FormatTime(GVAR_LOCAL.hInstance, 
                             dwImageFreq,
                             szTime,
                             sizeof(szTime) / sizeof(TCHAR));

        SendDlgItemMessage(GVAR_LOCAL.hwndMain, 
                           IDC_MINUTES_AND_SECONDS, 
                           WM_SETTEXT, 
                           0, 
                           (LPARAM) szTime);
    }

    return hr;
}

///////////////////////////////
// SetImageScaleTrackbar
//
static HRESULT SetImageScaleTrackbar(DWORD   dwImageScaleFactor)
{
    HRESULT hr = S_OK;

    // 
    // Set Image Scale Factor Trackbar
    //
    if (SUCCEEDED(hr))
    {
        TCHAR   szScale[255 + 1] = {0};

        // set the trackbar's current position.
        SendDlgItemMessage(GVAR_LOCAL.hwndMain,
                           IDC_MAX_SIZE,
                           TBM_SETPOS,
                           (WPARAM) TRUE,
                           (LPARAM) dwImageScaleFactor);

        hr = Util::FormatScale(GVAR_LOCAL.hInstance, 
                               dwImageScaleFactor,
                               szScale,
                               sizeof(szScale) / sizeof(TCHAR));

        SendDlgItemMessage(GVAR_LOCAL.hwndMain, 
                           IDC_IMAGE_SIZE_DESC, 
                           WM_SETTEXT, 
                           0, 
                           (LPARAM) szScale);
    }

    return hr;
}

///////////////////////////////
// EnableApplyButton
//
static void EnableApplyButton(BOOL bEnable)
{
    EnableWindow(GetDlgItem(GVAR_LOCAL.hwndMain, IDC_APPLY), bEnable);
}

///////////////////////////////
// GetFirstSlideshowService
//
static HRESULT GetFirstSlideshowService(ISlideshowService   **ppSlideshowService,
                                        ISlideshowAlbum     **ppSlideshowAlbum)
{
    ASSERT(ppSlideshowService != NULL);

    HRESULT         hr             = S_OK;
    IEnumAlbums     *pEnum         = NULL;
    IAlbumManager   *pAlbumManager = NULL;

    if (GVAR_pProjector == NULL)
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("GetFirstSlideshowService received a NULL pointer"));
        return hr;
    }

    if (hr == S_OK)
    {
        hr = GVAR_pProjector->QueryInterface(IID_IAlbumManager, (void**)&pAlbumManager);
    }

    if (hr == S_OK)
    {
        hr = pAlbumManager->EnumAlbums(&pEnum);
    }

    if (hr == S_OK)
    {
        hr = pEnum->Reset();
    }

    if (hr == S_OK)
    {
        ISlideshowAlbum *pSlideshowAlbum = NULL;

        DWORD dwFetched = 0;

        hr = pEnum->Next(1, &pSlideshowAlbum, &dwFetched);

        if (hr == S_OK)
        {
            if (ppSlideshowService)
            {
                hr = pSlideshowAlbum->QueryInterface(IID_ISlideshowService,
                                                     (void**) ppSlideshowService);
            }

            if (ppSlideshowAlbum)
            {
                hr = pSlideshowAlbum->QueryInterface(IID_ISlideshowAlbum,
                                                     (void**) ppSlideshowAlbum);
            }

            if (pSlideshowAlbum)
            {
                pSlideshowAlbum->Release();
                pSlideshowAlbum = NULL;
            }
        }
    }

    if (pEnum)
    {
        pEnum->Release();
        pEnum = NULL;
    }

    if (pAlbumManager)
    {
        pAlbumManager->Release();
        pAlbumManager = NULL;
    }

    return hr;
}


///////////////////////////////
// LoadCurrentSettings
//
static HRESULT LoadCurrentSettings()
{
    USES_CONVERSION;

    HRESULT hr                        = S_OK;
    long    lImageFreq                = 0;
    long    lImageScaleFactor         = 0;
    TCHAR   szImageDir[_MAX_PATH + 1] = {0};
    BOOL    bShowFileName             = FALSE;
    BOOL    bAllowKeyControl          = FALSE;
    BOOL    bStretchSmallImages       = FALSE;
    BSTR    bstrImageDir              = NULL;
    ISlideshowService       *pSlideshowService      = NULL;
    ISlideshowAlbum         *pSlideshowAlbum        = NULL;

    ASSERT(GVAR_pProjector != NULL);

    if (GVAR_pProjector == NULL)
    {
        DBG_ERR(("InitDlg, failed to get Image Frequency, slide show "
                 "projector object doesn't exist"));

        return 0;
    }

    hr = GetFirstSlideshowService(&pSlideshowService, &pSlideshowAlbum);

    if (hr != S_OK)
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("LoadCurrentSettings, failed to get first Slideshow Service"));
        return hr;
    }
    
    // 
    // Get the Image Frequency
    //
    hr = pSlideshowService->get_ImageFrequency(&lImageFreq);

    if (SUCCEEDED(hr))
    {
        if (lImageFreq < MIN_IMAGE_FREQ_IN_SEC)
        {
            lImageFreq = MIN_IMAGE_FREQ_IN_SEC;
            hr = pSlideshowService->put_ImageFrequency(lImageFreq);
        }
        else if (lImageFreq > MAX_IMAGE_FREQ_IN_SEC)
        {
            lImageFreq = MAX_IMAGE_FREQ_IN_SEC;
            hr = pSlideshowService->put_ImageFrequency(lImageFreq);        
        }
    }

    // 
    // Set Image Frequency Trackbar
    //
    if (SUCCEEDED(hr))
    {
        SetImageFreqTrackbar((DWORD) lImageFreq);
    }

    // 
    // Get the Image Scale Factor
    //
    hr = pSlideshowService->get_ImageScaleFactor(&lImageScaleFactor);

    if (SUCCEEDED(hr))
    {
        if (lImageScaleFactor < MIN_IMAGE_SCALE_FACTOR)
        {
            lImageScaleFactor = MIN_IMAGE_SCALE_FACTOR;
            hr = pSlideshowService->put_ImageScaleFactor(lImageScaleFactor);
        }
        else if (lImageScaleFactor > MAX_IMAGE_SCALE_FACTOR)
        {
            lImageScaleFactor = MAX_IMAGE_SCALE_FACTOR;
            hr = pSlideshowService->put_ImageScaleFactor(lImageScaleFactor);        
        }
    }

    // 
    // Set Image Scale Factor Trackbar
    //
    if (SUCCEEDED(hr))
    {
        SetImageScaleTrackbar((DWORD)lImageScaleFactor);
    }

    //
    // Get the current Image Directory
    //
    hr = pSlideshowAlbum->get_ImagePath(&bstrImageDir);

    // set the edit control's image directory to reflect the current
    // image directory.
    if (SUCCEEDED(hr))
    {
        HDC   hDC          = NULL;
        TCHAR szImageDir[MAX_PATH + 1] = {0};
        RECT  rc           = {0};

        _tcsncpy(szImageDir, 
                 OLE2T(bstrImageDir), 
                 sizeof(szImageDir) / sizeof(TCHAR));

        _tcsncpy(GVAR_LOCAL.szImagePath, 
                 OLE2T(bstrImageDir), 
                 sizeof(GVAR_LOCAL.szImagePath) / sizeof(TCHAR));

        hDC = GetDC(GetDlgItem(GVAR_LOCAL.hwndMain, IDC_IMAGEDIR));
        GetClientRect(GetDlgItem(GVAR_LOCAL.hwndMain, IDC_IMAGEDIR), &rc);

        PathCompactPath(hDC, szImageDir, rc.right - rc.left);

        SetDlgItemText(GVAR_LOCAL.hwndMain,
                       IDC_IMAGEDIR,
                       szImageDir);

        if (hDC)
        {
            ReleaseDC(GetDlgItem(GVAR_LOCAL.hwndMain, IDC_IMAGEDIR), hDC);
            hDC = NULL;
        }
    }

    if (bstrImageDir)
    {
        ::SysFreeString(bstrImageDir);
        bstrImageDir = NULL;
    }

    //
    // get the "ShowFilename" attribute
    //
    hr = pSlideshowService->get_ShowFileName(&bShowFileName);

    // set the ShowFileName checkbox
    if (SUCCEEDED(hr))
    {
        if (bShowFileName)
        {
            SendDlgItemMessage(GVAR_LOCAL.hwndMain,
                               IDC_DISPLAYFILENAME,
                               BM_SETCHECK,
                               BST_CHECKED,
                               0);
        }
        else
        {
            SendDlgItemMessage(GVAR_LOCAL.hwndMain,
                               IDC_DISPLAYFILENAME,
                               BM_SETCHECK,
                               BST_UNCHECKED,
                               0);
        }
    }

    //
    // get the "AllowKeyControl" attribute
    //
    hr = pSlideshowService->get_AllowKeyControl(&bAllowKeyControl);

    // set the Allow Keyboard Control checkbox
    if (SUCCEEDED(hr))
    {
        if (bAllowKeyControl)
        {
            SendDlgItemMessage(GVAR_LOCAL.hwndMain,
                               IDC_ALLOW_KEYBOARDCONTROL,
                               BM_SETCHECK,
                               BST_CHECKED,
                               0);
        }
        else
        {
            SendDlgItemMessage(GVAR_LOCAL.hwndMain,
                               IDC_ALLOW_KEYBOARDCONTROL,
                               BM_SETCHECK,
                               BST_UNCHECKED,
                               0);
        }
    }

    //
    // get the "StretchSmallImages" attribute
    //
    hr = pSlideshowService->get_StretchSmallImages(&bStretchSmallImages);

    // set the Stretch Small Images Control checkbox
    if (SUCCEEDED(hr))
    {
        if (bStretchSmallImages)
        {
            SendDlgItemMessage(GVAR_LOCAL.hwndMain,
                               IDC_ALLOWSTRETCHING,
                               BM_SETCHECK,
                               BST_CHECKED,
                               0);
        }
        else
        {
            SendDlgItemMessage(GVAR_LOCAL.hwndMain,
                               IDC_ALLOWSTRETCHING,
                               BM_SETCHECK,
                               BST_UNCHECKED,
                               0);
        }
    }

    if (pSlideshowService)
    {
        pSlideshowService->Release();
        pSlideshowService = NULL;
    }

    if (pSlideshowAlbum)
    {
        pSlideshowAlbum->Release();
        pSlideshowAlbum = NULL;
    }

    return hr;
}

///////////////////////////////
// SaveCurrentSettings
//
static HRESULT SaveCurrentSettings()
{
    HRESULT     hr                                   = S_OK;
    DWORD_PTR   dwImageFreq                          = 0;
    DWORD_PTR   dwImageScaleFactor                   = 0;
    BOOL        bShowFileName                        = FALSE;
    BOOL        bAllowKeyControl                     = FALSE;
    BOOL        bStretchSmallImages                  = FALSE;
    LONG        lState                               = 0;
    ISlideshowService       *pSlideshowService       = NULL;
    ISlideshowAlbum         *pSlideshowAlbum         = NULL;


    ASSERT(GVAR_pProjector != NULL);

    hr = GetFirstSlideshowService(&pSlideshowService, &pSlideshowAlbum);

    if (hr != S_OK)
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("LoadCurrentSettings, failed to get first Slideshow Service"));
        return hr;
    }

    //
    // get the image frequency trackbar value
    //
    dwImageFreq = (DWORD_PTR) SendDlgItemMessage(GVAR_LOCAL.hwndMain,
                                                 IDC_FREQUENCY,
                                                 TBM_GETPOS,
                                                 0,
                                                 0);

    //
    // get the image scale factor trackbar value
    //
    dwImageScaleFactor = (DWORD_PTR) SendDlgItemMessage(GVAR_LOCAL.hwndMain,
                                                        IDC_MAX_SIZE,
                                                        TBM_GETPOS,
                                                        0,
                                                        0);

    // Get the Display File Name 
    bShowFileName       = IsChecked(IDC_DISPLAYFILENAME);

    // Get the Allow Key Control
    bAllowKeyControl    = IsChecked(IDC_ALLOW_KEYBOARDCONTROL);

    // Get the Stretch Small Images
    bStretchSmallImages = IsChecked(IDC_ALLOWSTRETCHING);

    //
    // set the image frequency 
    //
    hr = pSlideshowService->put_ImageFrequency((DWORD) dwImageFreq);

    if (FAILED(hr))
    {
        DBG_ERR(("SaveCurrentSettings, failed to set image frequency"));
    }

    //
    // set the image scale factor
    //
    hr = pSlideshowService->put_ImageScaleFactor((DWORD) dwImageScaleFactor);

    if (FAILED(hr))
    {
        DBG_ERR(("SaveCurrentSettings, failed to set image scale factor"));
    }

    //
    // put the show file name attribute
    //
    hr = pSlideshowService->put_ShowFileName(bShowFileName);

    if (FAILED(hr))
    {
        DBG_ERR(("SaveCurrentSettings, failed to set show filename property"));
    }

    //
    // put the allow key control attribute
    //
    hr = pSlideshowService->put_AllowKeyControl(bAllowKeyControl);

    if (FAILED(hr))
    {
        DBG_ERR(("SaveCurrentSettings, failed to set Allow Key Control property"));
    }

    //
    // put the Stretch Small Images control attribute
    //
    hr = pSlideshowService->put_StretchSmallImages(bStretchSmallImages);

    if (FAILED(hr))
    {
        DBG_ERR(("SaveCurrentSettings, failed to set StretchSmallImages property"));
    }

    
    //
    // set the control's image directory
    // Notice we store the image directory rather than the Projector
    // server control because it is not something that can be 
    // set remotely.  Only items that can be configured by the client
    // are stored by the COM Projector Server
    //
    hr = pSlideshowAlbum->put_ImagePath(GVAR_LOCAL.szImagePath);

    EnableApplyButton(FALSE);

    if (pSlideshowService)
    {
        pSlideshowService->Release();
        pSlideshowService = NULL;
    }

    if (pSlideshowAlbum)
    {
        pSlideshowAlbum->Release();
        pSlideshowAlbum = NULL;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\upnp\msprjctr\server\main.h ===
//////////////////////////////////////////////////////////////////////////////
//
// File:            main.h
//
// Description:     Declares all the functions within the individual
//                  files.
//
// Copyright (c) 2000 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////////////

#ifndef _MAIN_H_
#define _MAIN_H_

#define DEFAULT_INSTALL_PATH        _T("MSProjector")
#define REG_KEY_PROJECTOR           _T("Software\\Microsoft\\MSProjector")
#define REG_VAL_IMAGE_DIR           _T("ImagesDirectory")
#define REG_VAL_DEVICE_DIR          _T("DeviceDirectory")
#define REG_VAL_ALLOW_KEY_CONTROL   _T("AllowKeyboardControl")
#define REG_VAL_SHOW_IMAGEURL       _T("ShowImageUrl")
#define MSPRJCTR_TASKBAR_ID     100

#define MIN_IMAGE_FREQ_IN_SEC   6
#define MAX_IMAGE_FREQ_IN_SEC   3 * 60

#define MIN_IMAGE_SCALE_FACTOR  25
#define MAX_IMAGE_SCALE_FACTOR  100

// CfgDlg Functions
namespace CfgDlg
{
    HRESULT Init(HINSTANCE hInstance);

    HRESULT Term();

    HWND Create(int nCmdShow);
}

// Tray Functions
namespace Tray
{
    HRESULT Init(HINSTANCE hInstance,
                 HWND      hwndDlg,
                 UINT      uiWindowsUserMsgId);

    HRESULT Term(HWND    hwndDlg);

    HRESULT PopupMenu(HWND    hwndOwner);

}

// Util Functions
namespace Util
{
    HRESULT Init(HINSTANCE hInstance);

    HRESULT Term(void);

    HRESULT GetAppDirs(TCHAR   *pszDeviceDir,
                       DWORD   cchDeviceDir,  
                       TCHAR   *pszImageDir,
                       DWORD   cchImageDir);

    HRESULT GetRegString(const TCHAR   *pszValueName,
                         TCHAR         *pszDir,
                         DWORD         cchDir,
                         BOOL          bSetIfNotExist);

    HRESULT SetRegString(const TCHAR   *pszValueName,
                         TCHAR         *pszDir,
                         DWORD         cchDir);

    HRESULT GetRegDWORD(const TCHAR   *pszValueName,
                        DWORD         *pdwValue,
                        BOOL          bSetIfNotExist);

    HRESULT SetRegDWORD(const TCHAR   *pszValueName,
                        DWORD         dwValue);

    bool BrowseForDirectory(HWND        hWnd, 
                            const TCHAR *pszPrompt, 
                            TCHAR       *pszDirectory,
                            DWORD       cchDirectory);

    HRESULT FormatTime(HINSTANCE hInstance, 
                       UINT nTotalSeconds,
                       TCHAR     *pszTime,
                       DWORD     cchTime);

    HRESULT FormatScale(HINSTANCE hInstance, 
                        DWORD     dwImageScaleFactor,
                        TCHAR     *pszScale,
                        DWORD     cchScale);

    BOOL DoesDirExist(LPCTSTR pszPath);

    BOOL GetString(HINSTANCE  hInstance,
                   INT        iStrResID,
                   TCHAR      *pszString,
                   DWORD      cchString,
                   ...);

    HRESULT GetMyPicturesFolder(TCHAR *pszFolder,
                                DWORD cchFolder);

    HRESULT GetProgramFilesFolder(TCHAR *pszFolder,
                                  DWORD cchFolder);


}

#endif //_MAIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\upnp\msprjctr\server\main.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// File:            main.cpp
//
// Description:     
//
// Copyright (c) 2000 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////////////

// App Includes
#include "precomp.h"
#include "main.h"
#include "msprjctr.h"

#include <commctrl.h>

///////////////////////////
// GVAR_LOCAL
//
// Global Variable
//
static struct GVAR_LOCAL
{
    HINSTANCE hInstance;
} GVAR_LOCAL = 
{
    NULL
};


////////////////////////// Function Prototypes ////////////////////////////////

static bool InitApp(HINSTANCE hInstance);
static bool TermApp();

//////////////////////////////
// WinMain
//
int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
    HWND    hwndCfgDlg      = NULL;
    bool    bSuccess        = false;
    bool    bDone           = false;
    int     iReturnValue    = 0;
    MSG     msg;

    // initialize our application
    bSuccess = InitApp(hInstance);

    if (bSuccess)
    {
        // create our config dialog, which is our main dialog
        hwndCfgDlg = CfgDlg::Create(nCmdShow);

        if (hwndCfgDlg == NULL)
        {
            iReturnValue = -1;
            bSuccess = false;
        }
    }

    if (bSuccess)
    {
        while (::GetMessage(&msg, NULL, 0, 0))
        {
            ::TranslateMessage(&msg);
            ::DispatchMessage(&msg);
        }
    }

    TermApp();

    return iReturnValue;
}


//////////////////////////////
// InitApp
//
static bool InitApp(HINSTANCE hInstance)
{
    HRESULT                 hr             = S_OK;
    bool                    bReturn        = true;
    INITCOMMONCONTROLSEX    CommonControls = {0};
    BOOL                    bSuccess       = FALSE;

    //
    // initialize the common control library
    //
    CommonControls.dwSize = sizeof(CommonControls);
    CommonControls.dwICC  = ICC_BAR_CLASSES | ICC_WIN95_CLASSES;

    bSuccess = InitCommonControlsEx(&CommonControls);

    if (bSuccess)
    {
        DBG_TRC(("Successfully initialized Common Controls"));
    }
    else
    {
        DBG_TRC(("Failed to Init Common Controls, LastError = %lu",
                GetLastError()));
    }

    //
    // Initialize COM
    //
    if (SUCCEEDED(hr))
    {
        // we are apartment threaded because the UPnP device host API
        // claims it has some problems in a free threaded model.
        //
        hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);
    }

    //
    // Initialize our Util Library
    //
    if (SUCCEEDED(hr))
    {
        hr = Util::Init(hInstance);
    }

    //
    // Initialize our Config Dialog module
    //
    if (SUCCEEDED(hr))
    {
        hr = CfgDlg::Init(hInstance);
    }

    return bReturn;
}

//////////////////////////////
// TermApp
//
static bool TermApp()
{
    // shutdown the Config Dialog Module
    CfgDlg::Term();

    // shutdown the Util Module.
    Util::Term();

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\unittest\testacqd\main.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 2000
 *
 *  TITLE:       MAIN.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        5/3/2000
 *
 *  DESCRIPTION: Random unit testing program for various UI components
 *
 *******************************************************************************/
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <initguid.h>
#include <atlbase.h>
#include <objbase.h>
#include <wia.h>
#include <sti.h>
#include <simstr.h>
#include <shellext.h>
#include <upnp.h>
#include <simbstr.h>
#include <simreg.h>
#include <dumpprop.h>
#include <simrect.h>
#include "uicommon.h"
#include "wiadebug.h"
#include "resource.h"
#include "simcrack.h"
#include "wiadevdp.h"
#include "isuppfmt.h"
#include "itranhlp.h"
#include "gphelper.h"
#include "runwiz.h"
#include "runnpwiz.h"
#include "multistr.h"
#include "mboxex.h"

#define SELECT_DEVICE_TYPE StiDeviceTypeDefault

HINSTANCE g_hInstance;

#define PWM_DISPLAYNEWIMAGE (WM_USER+122)

class CWiaDataCallbackBase : public IWiaDataCallback
{
private:
    LONG    m_cRef;

public:
    CWiaDataCallbackBase()
    : m_cRef(1)
    {
    }

    ~CWiaDataCallbackBase()
    {
    }

    STDMETHODIMP QueryInterface(const IID& iid, void** ppvObject)
    {
        if ((iid==IID_IUnknown) || (iid==IID_IWiaDataCallback))
        {
            *ppvObject = static_cast<LPVOID>(this);
        }
        else
        {
            *ppvObject = NULL;
            return(E_NOINTERFACE);
        }
        reinterpret_cast<IUnknown*>(*ppvObject)->AddRef();
        return(S_OK);
    }

    STDMETHODIMP_(ULONG) AddRef()
    {
        return(InterlockedIncrement(&m_cRef));
    }

    STDMETHODIMP_(ULONG) Release()
    {
        if (InterlockedDecrement(&m_cRef)==0)
        {
            delete this;
            return 0;
        }
        return(m_cRef);
    }


    STDMETHODIMP BandedDataCallback(
        LONG                            lReason,
        LONG                            lStatus,
        LONG                            lPercentComplete,
        LONG                            lOffset,
        LONG                            lLength,
        LONG                            lReserved,
        LONG                            lResLength,
        PBYTE                           pbBuffer)
    {
        if (lReason == IT_MSG_STATUS)
        {
            TCHAR szMessage[MAX_PATH];
            wsprintf( szMessage, TEXT("IT_MSG_STATUS: Percent Done (in client callback): %d\n"), lPercentComplete );
            OutputDebugString( szMessage );
        }
        else if (lReason == IT_MSG_DATA)
        {
            TCHAR szMessage[MAX_PATH];
            wsprintf( szMessage, TEXT("IT_MSG_DATA: Percent Done (in client callback): %d\n"), lPercentComplete );
            OutputDebugString( szMessage );
        }
        return S_OK;
    }

    static IWiaDataCallback *CreateInstance(void)
    {
        IWiaDataCallback *pWiaDataCallback = NULL;
        CWiaDataCallbackBase *pWiaDataCallbackBase = new CWiaDataCallbackBase;
        if (pWiaDataCallbackBase)
        {
            HRESULT hr = pWiaDataCallbackBase->QueryInterface( IID_IWiaDataCallback, (void**)&pWiaDataCallback );
            pWiaDataCallbackBase->Release();
        }
        return pWiaDataCallback;
    }
};



class CProgressDialogFlagsDialog
{
public:
    struct CData
    {
        LONG lFlags;
    };

private:
    HWND m_hWnd;
    CData *m_pData;

private:
    //
    // Not implemented
    //
    CProgressDialogFlagsDialog( const CProgressDialogFlagsDialog & );
    CProgressDialogFlagsDialog(void);
    CProgressDialogFlagsDialog &operator=( const CProgressDialogFlagsDialog & );

private:
    //
    // Sole constructor
    //
    explicit CProgressDialogFlagsDialog( HWND hWnd )
      : m_hWnd(hWnd),
        m_pData(NULL)
    {
    }

    ~CProgressDialogFlagsDialog(void)
    {
        m_hWnd = NULL;
    }

    LRESULT OnInitDialog( WPARAM, LPARAM lParam )
    {
        m_pData = reinterpret_cast<CData*>(lParam);
        if (m_pData)
        {
            if ((m_pData->lFlags & WIA_PROGRESSDLG_NO_PROGRESS)==0)
            {
                SendDlgItemMessage( m_hWnd, IDC_PROGDLG_PROGRESS, BM_SETCHECK, BST_CHECKED, 0 );
            }
            if ((m_pData->lFlags & WIA_PROGRESSDLG_NO_CANCEL)==0)
            {
                SendDlgItemMessage( m_hWnd, IDC_PROGDLG_CANCEL, BM_SETCHECK, BST_CHECKED, 0 );
            }
            if ((m_pData->lFlags & WIA_PROGRESSDLG_NO_ANIM)==0)
            {
                SendDlgItemMessage( m_hWnd, IDC_PROGDLG_ANIM, BM_SETCHECK, BST_CHECKED, 0 );
            }
            if ((m_pData->lFlags & WIA_PROGRESSDLG_NO_TITLE)==0)
            {
                SendDlgItemMessage( m_hWnd, IDC_PROGDLG_TITLE, BM_SETCHECK, BST_CHECKED, 0 );
            }

            if (m_pData->lFlags & WIA_PROGRESSDLG_ANIM_SCANNER_COMMUNICATE)
            {
                SendDlgItemMessage( m_hWnd, IDC_PROGDLG_SCAN_CONNECT, BM_SETCHECK, BST_CHECKED, 0 );
            }
            else if (m_pData->lFlags & WIA_PROGRESSDLG_ANIM_CAMERA_COMMUNICATE)
            {
                SendDlgItemMessage( m_hWnd, IDC_PROGDLG_CAMERA_CONNECT, BM_SETCHECK, BST_CHECKED, 0 );
            }
            else if (m_pData->lFlags & WIA_PROGRESSDLG_ANIM_VIDEO_COMMUNICATE)
            {
                SendDlgItemMessage( m_hWnd, IDC_PROGDLG_VIDEO_CONNECT, BM_SETCHECK, BST_CHECKED, 0 );
            }
            else if (m_pData->lFlags & WIA_PROGRESSDLG_ANIM_SCANNER_ACQUIRE)
            {
                SendDlgItemMessage( m_hWnd, IDC_PROGDLG_SCAN_ACQUIRE, BM_SETCHECK, BST_CHECKED, 0 );
            }
            else if (m_pData->lFlags & WIA_PROGRESSDLG_ANIM_CAMERA_ACQUIRE)
            {
                SendDlgItemMessage( m_hWnd, IDC_PROGDLG_CAMERA_ACQUIRE, BM_SETCHECK, BST_CHECKED, 0 );
            }
            else if (m_pData->lFlags & WIA_PROGRESSDLG_ANIM_VIDEO_ACQUIRE)
            {
                SendDlgItemMessage( m_hWnd, IDC_PROGDLG_VIDEO_ACQUIRE, BM_SETCHECK, BST_CHECKED, 0 );
            }
            else if (m_pData->lFlags & WIA_PROGRESSDLG_ANIM_DEFAULT_COMMUNICATE)
            {
                SendDlgItemMessage( m_hWnd, IDC_PROGDLG_DEFAULT_CONNECT, BM_SETCHECK, BST_CHECKED, 0 );
            }
            HandleAnimSettingsChange();
        }
        else
        {
            EndDialog( m_hWnd, IDCANCEL );
        }
        return 0;
    }

    void HandleAnimSettingsChange(void)
    {
        BOOL bEnable = (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_PROGDLG_ANIM, BM_GETCHECK, 0, 0 ));
        EnableWindow( GetDlgItem( m_hWnd, IDC_PROGDLG_SCAN_CONNECT ), bEnable );
        EnableWindow( GetDlgItem( m_hWnd, IDC_PROGDLG_CAMERA_CONNECT ), bEnable );
        EnableWindow( GetDlgItem( m_hWnd, IDC_PROGDLG_VIDEO_CONNECT ), bEnable );
        EnableWindow( GetDlgItem( m_hWnd, IDC_PROGDLG_SCAN_ACQUIRE ), bEnable );
        EnableWindow( GetDlgItem( m_hWnd, IDC_PROGDLG_CAMERA_ACQUIRE ), bEnable );
        EnableWindow( GetDlgItem( m_hWnd, IDC_PROGDLG_VIDEO_ACQUIRE ), bEnable );
        EnableWindow( GetDlgItem( m_hWnd, IDC_PROGDLG_DEFAULT_CONNECT ), bEnable );
    }

    void OnAnimClicked( WPARAM, LPARAM )
    {
        HandleAnimSettingsChange();
    }

    void OnCancel( WPARAM, LPARAM )
    {
        EndDialog( m_hWnd, IDCANCEL );
    }
    void OnOK( WPARAM, LPARAM )
    {
        if (m_pData)
        {
            m_pData->lFlags = 0;

            if (BST_CHECKED != SendDlgItemMessage( m_hWnd, IDC_PROGDLG_PROGRESS, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= WIA_PROGRESSDLG_NO_PROGRESS;
            }
            if (BST_CHECKED != SendDlgItemMessage( m_hWnd, IDC_PROGDLG_CANCEL, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= WIA_PROGRESSDLG_NO_CANCEL;
            }
            if (BST_CHECKED != SendDlgItemMessage( m_hWnd, IDC_PROGDLG_ANIM, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= WIA_PROGRESSDLG_NO_ANIM;
            }
            if (BST_CHECKED != SendDlgItemMessage( m_hWnd, IDC_PROGDLG_TITLE, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= WIA_PROGRESSDLG_NO_TITLE;
            }

            if (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_PROGDLG_SCAN_CONNECT, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= WIA_PROGRESSDLG_ANIM_SCANNER_COMMUNICATE;
            }
            if (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_PROGDLG_CAMERA_CONNECT, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= WIA_PROGRESSDLG_ANIM_CAMERA_COMMUNICATE;
            }
            if (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_PROGDLG_VIDEO_CONNECT, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= WIA_PROGRESSDLG_ANIM_VIDEO_COMMUNICATE;
            }
            if (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_PROGDLG_SCAN_ACQUIRE, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= WIA_PROGRESSDLG_ANIM_SCANNER_ACQUIRE;
            }
            if (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_PROGDLG_CAMERA_ACQUIRE, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= WIA_PROGRESSDLG_ANIM_CAMERA_ACQUIRE;
            }
            if (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_PROGDLG_VIDEO_ACQUIRE, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= WIA_PROGRESSDLG_ANIM_VIDEO_ACQUIRE;
            }
            if (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_PROGDLG_DEFAULT_CONNECT, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= WIA_PROGRESSDLG_ANIM_DEFAULT_COMMUNICATE;
            }
        }
        EndDialog( m_hWnd, IDOK );
    }

    LRESULT OnCommand( WPARAM wParam, LPARAM lParam )
    {
        SC_BEGIN_COMMAND_HANDLERS()
        {
            SC_HANDLE_COMMAND(IDCANCEL,OnCancel);
            SC_HANDLE_COMMAND(IDOK,OnOK);
            SC_HANDLE_COMMAND(IDC_PROGDLG_ANIM,OnAnimClicked);
        }
        SC_END_COMMAND_HANDLERS();
    }

public:
    static INT_PTR DialogProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
    {
        SC_BEGIN_DIALOG_MESSAGE_HANDLERS(CProgressDialogFlagsDialog)
        {
            SC_HANDLE_DIALOG_MESSAGE( WM_INITDIALOG, OnInitDialog );
            SC_HANDLE_DIALOG_MESSAGE( WM_COMMAND, OnCommand );
        }
        SC_END_DIALOG_MESSAGE_HANDLERS();
    }
};


class CMessageBoxExFlagsDialog
{
public:
    struct CData
    {
        LONG lFlags;
    };

private:
    HWND m_hWnd;
    CData *m_pData;

private:
    //
    // Not implemented
    //
    CMessageBoxExFlagsDialog( const CMessageBoxExFlagsDialog & );
    CMessageBoxExFlagsDialog(void);
    CMessageBoxExFlagsDialog &operator=( const CMessageBoxExFlagsDialog & );

private:
    //
    // Sole constructor
    //
    explicit CMessageBoxExFlagsDialog( HWND hWnd )
      : m_hWnd(hWnd),
        m_pData(NULL)
    {
    }

    ~CMessageBoxExFlagsDialog(void)
    {
        m_hWnd = NULL;
    }

    LRESULT OnInitDialog( WPARAM, LPARAM lParam )
    {
        m_pData = reinterpret_cast<CData*>(lParam);
        if (m_pData)
        {
            if ((m_pData->lFlags & CMessageBoxEx::MBEX_OKCANCEL) != 0)
            {
                SendDlgItemMessage( m_hWnd, IDC_MBEX_OKCANCEL, BM_SETCHECK, BST_CHECKED, 0 );
            }
            else if ((m_pData->lFlags & CMessageBoxEx::MBEX_YESNO) != 0)
            {
                SendDlgItemMessage( m_hWnd, IDC_MBEX_YESNO, BM_SETCHECK, BST_CHECKED, 0 );
            }
            else if ((m_pData->lFlags & CMessageBoxEx::MBEX_CANCELRETRYSKIPSKIPALL) != 0)
            {
                SendDlgItemMessage( m_hWnd, IDC_MBEX_CANCELRETRYSKIPSKIPALL, BM_SETCHECK, BST_CHECKED, 0 );
            }
            else if ((m_pData->lFlags & CMessageBoxEx::MBEX_CANCELRETRYSKIPSKIPALL) != 0)
            {
                SendDlgItemMessage( m_hWnd, IDC_MBEX_YESYESTOALLNONOTOALL, BM_SETCHECK, BST_CHECKED, 0 );
            }
            else
            {
                SendDlgItemMessage( m_hWnd, IDC_MBEX_OK, BM_SETCHECK, BST_CHECKED, 0 );
            }

            if ((m_pData->lFlags & CMessageBoxEx::MBEX_DEFBUTTON2) != 0)
            {
                SendDlgItemMessage( m_hWnd, IDC_MBEX_DEFBUTTON2, BM_SETCHECK, BST_CHECKED, 0 );
            }
            else if ((m_pData->lFlags & CMessageBoxEx::MBEX_DEFBUTTON3) != 0)
            {
                SendDlgItemMessage( m_hWnd, IDC_MBEX_DEFBUTTON3, BM_SETCHECK, BST_CHECKED, 0 );
            }
            else if ((m_pData->lFlags & CMessageBoxEx::MBEX_DEFBUTTON4) != 0)
            {
                SendDlgItemMessage( m_hWnd, IDC_MBEX_DEFBUTTON4, BM_SETCHECK, BST_CHECKED, 0 );
            }
            else
            {
                SendDlgItemMessage( m_hWnd, IDC_MBEX_DEFBUTTON1, BM_SETCHECK, BST_CHECKED, 0 );
            }

            if ((m_pData->lFlags & CMessageBoxEx::MBEX_ICONERROR) != 0)
            {
                SendDlgItemMessage( m_hWnd, IDC_MBEX_ICONERROR, BM_SETCHECK, BST_CHECKED, 0 );
            }
            else if ((m_pData->lFlags & CMessageBoxEx::MBEX_ICONWARNING) != 0)
            {
                SendDlgItemMessage( m_hWnd, IDC_MBEX_ICONWARNING, BM_SETCHECK, BST_CHECKED, 0 );
            }
            else if ((m_pData->lFlags & CMessageBoxEx::MBEX_ICONQUESTION) != 0)
            {
                SendDlgItemMessage( m_hWnd, IDC_MBEX_ICONQUESTION, BM_SETCHECK, BST_CHECKED, 0 );
            }
            else
            {
                SendDlgItemMessage( m_hWnd, IDC_MBEX_ICONINFORMATION, BM_SETCHECK, BST_CHECKED, 0 );
            }
        }
        else
        {
            EndDialog( m_hWnd, IDCANCEL );
        }
        return 0;
    }

    void OnCancel( WPARAM, LPARAM )
    {
        EndDialog( m_hWnd, IDCANCEL );
    }
    void OnOK( WPARAM, LPARAM )
    {
        if (m_pData)
        {
            m_pData->lFlags = 0;

            if (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_MBEX_OKCANCEL, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= CMessageBoxEx::MBEX_OKCANCEL;
            }
            if (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_MBEX_YESNO, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= CMessageBoxEx::MBEX_YESNO;
            }
            if (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_MBEX_CANCELRETRYSKIPSKIPALL, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= CMessageBoxEx::MBEX_CANCELRETRYSKIPSKIPALL;
            }
            if (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_MBEX_YESYESTOALLNONOTOALL, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= CMessageBoxEx::MBEX_YESYESTOALLNONOTOALL;
            }
            if (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_MBEX_OK, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= CMessageBoxEx::MBEX_OK;
            }
            if (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_MBEX_DEFBUTTON2, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= CMessageBoxEx::MBEX_DEFBUTTON2;
            }
            if (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_MBEX_DEFBUTTON3, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= CMessageBoxEx::MBEX_DEFBUTTON3;
            }
            if (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_MBEX_DEFBUTTON4, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= CMessageBoxEx::MBEX_DEFBUTTON4;
            }
            if (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_MBEX_DEFBUTTON1, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= CMessageBoxEx::MBEX_DEFBUTTON1;
            }
            if (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_MBEX_ICONINFORMATION, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= CMessageBoxEx::MBEX_ICONINFORMATION;
            }
            if (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_MBEX_ICONWARNING, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= CMessageBoxEx::MBEX_ICONWARNING;
            }
            if (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_MBEX_ICONQUESTION, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= CMessageBoxEx::MBEX_ICONQUESTION;
            }
            if (BST_CHECKED == SendDlgItemMessage( m_hWnd, IDC_MBEX_ICONERROR, BM_GETCHECK, 0, 0 ))
            {
                m_pData->lFlags |= CMessageBoxEx::MBEX_ICONERROR;
            }
        }
        EndDialog( m_hWnd, IDOK );
    }

    LRESULT OnCommand( WPARAM wParam, LPARAM lParam )
    {
        SC_BEGIN_COMMAND_HANDLERS()
        {
            SC_HANDLE_COMMAND(IDCANCEL,OnCancel);
            SC_HANDLE_COMMAND(IDOK,OnOK);
        }
        SC_END_COMMAND_HANDLERS();
    }

public:
    static INT_PTR DialogProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
    {
        SC_BEGIN_DIALOG_MESSAGE_HANDLERS(CMessageBoxExFlagsDialog)
        {
            SC_HANDLE_DIALOG_MESSAGE( WM_INITDIALOG, OnInitDialog );
            SC_HANDLE_DIALOG_MESSAGE( WM_COMMAND, OnCommand );
        }
        SC_END_DIALOG_MESSAGE_HANDLERS();
    }
};


class CMiscUnitTestWindow : public IUPnPServiceCallback
{
private:
    HWND    m_hWnd;
    LONG    m_nProgressDialogFlags;
    LONG    m_nMessageBoxExFlags;
    HBITMAP m_hOriginalBitmap;
    HBITMAP m_hTransformedBitmap;
    BYTE    m_nThreshold;
    BYTE    m_nContrast;
    BYTE    m_nBrightness;
    CComPtr<IUPnPService> m_pUPnPService;

private:
    CMiscUnitTestWindow(void);
    CMiscUnitTestWindow( const CMiscUnitTestWindow & );
    CMiscUnitTestWindow &operator=( const CMiscUnitTestWindow & );

private:
    explicit CMiscUnitTestWindow( HWND hWnd )
      : m_hWnd(hWnd),
        m_nProgressDialogFlags(WIA_PROGRESSDLG_ANIM_SCANNER_COMMUNICATE),
        m_hOriginalBitmap(NULL),
        m_nMessageBoxExFlags(0),
        m_hTransformedBitmap(NULL),
        m_nThreshold(50),
        m_nContrast(50),
        m_nBrightness(50)
    {
    }
    ~CMiscUnitTestWindow(void)
    {
        if (m_hOriginalBitmap)
        {
            DeleteObject(m_hOriginalBitmap);
            m_hOriginalBitmap = NULL;
        }
        if (m_hTransformedBitmap)
        {
            DeleteObject(m_hTransformedBitmap);
            m_hTransformedBitmap = NULL;
        }
    }
    void DestroyBitmap( bool bRepaint=true )
    {
        if (m_hOriginalBitmap)
        {
            DeleteObject(m_hOriginalBitmap);
            m_hOriginalBitmap = NULL;
        }
        if (m_hTransformedBitmap)
        {
            DeleteObject(m_hTransformedBitmap);
            m_hTransformedBitmap = NULL;
        }
        if (bRepaint)
        {
            InvalidateRect( m_hWnd, NULL, TRUE );
            UpdateWindow( m_hWnd );
        }
    }
    LRESULT OnDestroy( WPARAM, LPARAM )
    {
        m_pUPnPService = NULL;
        PostQuitMessage(0);
        return(0);
    }
    LRESULT OnCreate( WPARAM, LPARAM )
    {
        SendMessage( m_hWnd, WM_SETICON, ICON_BIG, reinterpret_cast<LPARAM>(LoadImage( g_hInstance, MAKEINTRESOURCE(IDI_TESTACQD), IMAGE_ICON, GetSystemMetrics(SM_CXICON), GetSystemMetrics(SM_CYICON), LR_DEFAULTCOLOR )));
        SendMessage( m_hWnd, WM_SETICON, ICON_SMALL, reinterpret_cast<LPARAM>(LoadImage( g_hInstance, MAKEINTRESOURCE(IDI_TESTACQD), IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), LR_DEFAULTCOLOR )));
        m_hOriginalBitmap = reinterpret_cast<HBITMAP>(LoadImage( g_hInstance, MAKEINTRESOURCE(IDB_TESTIMAGE), IMAGE_BITMAP, 0, 0, LR_CREATEDIBSECTION ));

        HWND hWnd = CreateWindow( WC_LINK, TEXT("<a>This is a link that will only show up if this application is fusionized</a>"), WS_CHILD|WS_VISIBLE, 0, 0, 200, 20, m_hWnd, reinterpret_cast<HMENU>(1), g_hInstance, NULL );
        if (!hWnd)
        {
            WIA_PRINTHRESULT((HRESULT_FROM_WIN32(GetLastError()),TEXT("CreateWindow returned")));
        }

        return(0);
    }
    void OnFileExit( WPARAM, LPARAM )
    {
        DestroyWindow(m_hWnd);
    }
    void OnProgressTestProgress( WPARAM, LPARAM )
    {
        WIA_PUSH_FUNCTION((TEXT("OnProgressTestProgress")));
        CComPtr<IWiaProgressDialog> pWiaProgressDialog;
        HRESULT hr = CoCreateInstance( CLSID_WiaDefaultUi, NULL, CLSCTX_INPROC_SERVER, IID_IWiaProgressDialog, (void**)&pWiaProgressDialog );
        if (SUCCEEDED(hr))
        {
            pWiaProgressDialog->Create( m_hWnd, m_nProgressDialogFlags );
            pWiaProgressDialog->SetTitle( L"This is the title" );
            pWiaProgressDialog->Show();
            for (int i=0;i<100;i++)
            {
                pWiaProgressDialog->SetMessage( CSimpleStringWide().Format( L"%d percent complete!", i ).String() );
                pWiaProgressDialog->SetPercentComplete(i);
                BOOL bCancelled = FALSE;
                pWiaProgressDialog->Cancelled(&bCancelled);
                if (bCancelled)
                {
                    Sleep(1000);
                    break;
                }
                Sleep(100);
            }
            pWiaProgressDialog->Destroy();
        }
        WIA_PRINTHRESULT((hr,TEXT("OnProgressTestProgress returning")));
    }
    void OnProgressSetFlags( WPARAM, LPARAM )
    {
        CProgressDialogFlagsDialog::CData Data;
        Data.lFlags = m_nProgressDialogFlags;
        if (IDOK == DialogBoxParam( g_hInstance, MAKEINTRESOURCE(IDD_PROGRESS_DIALOG_SETTINGS), m_hWnd, CProgressDialogFlagsDialog::DialogProc, reinterpret_cast<LPARAM>(&Data)))
        {
            m_nProgressDialogFlags = Data.lFlags;
        }
    }
    void OnMBoxSetFlags( WPARAM, LPARAM )
    {
        CMessageBoxExFlagsDialog::CData Data;
        Data.lFlags = m_nMessageBoxExFlags;
        if (IDOK == DialogBoxParam( g_hInstance, MAKEINTRESOURCE(IDD_MBOXFLAGS), m_hWnd, CMessageBoxExFlagsDialog::DialogProc, reinterpret_cast<LPARAM>(&Data)))
        {
            m_nMessageBoxExFlags = Data.lFlags;
        }
    }

    void OnWiaDeviceDlg( WPARAM, LPARAM )
    {
        CComPtr<IWiaDevMgr> pIWiaDevMgr;
        HRESULT hr = CoCreateInstance( CLSID_WiaDevMgr, NULL, CLSCTX_LOCAL_SERVER, IID_IWiaDevMgr, (void**)&pIWiaDevMgr );
        if (SUCCEEDED(hr))
        {
            CComPtr<IWiaItem> pWiaItemRoot;
            hr = pIWiaDevMgr->SelectDeviceDlg( m_hWnd, SELECT_DEVICE_TYPE, 0, NULL, &pWiaItemRoot );
            if (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                LONG nItemCount;
                IWiaItem **ppIWiaItems;
                hr = pWiaItemRoot->DeviceDlg( m_hWnd, 0, WIA_INTENT_MAXIMIZE_QUALITY, &nItemCount, &ppIWiaItems );
                if (SUCCEEDED(hr) && hr != S_FALSE)
                {
                    if (ppIWiaItems)
                    {
                        CComPtr<IWiaTransferHelper> pWiaTransferHelper;
                        hr = CoCreateInstance( CLSID_WiaDefaultUi, NULL, CLSCTX_INPROC_SERVER, IID_IWiaTransferHelper, (void**)&pWiaTransferHelper );
                        if (SUCCEEDED(hr))
                        {
                            for (int i=0;i<nItemCount && SUCCEEDED(hr) && hr != S_FALSE;i++)
                            {
                                IWiaDataCallback *pWiaDataCallback = CWiaDataCallbackBase::CreateInstance();
                                if (pWiaDataCallback)
                                {
                                    TCHAR szTempPath[MAX_PATH], szFilename[MAX_PATH] = TEXT("");
                                    GetTempPath( ARRAYSIZE(szTempPath), szTempPath );
                                    GetTempFileName( szTempPath, TEXT("acq"), 0, szFilename );

                                    CComPtr<IWiaSupportedFormats> pWiaSupportedFormats;
                                    hr = pWiaTransferHelper->QueryInterface( IID_IWiaSupportedFormats, (void**)&pWiaSupportedFormats );
                                    if (SUCCEEDED(hr))
                                    {
                                        hr = pWiaSupportedFormats->Initialize( ppIWiaItems[i], TYMED_FILE );
                                        if (SUCCEEDED(hr))
                                        {
                                            GUID cf;
                                            hr = pWiaSupportedFormats->GetDefaultClipboardFileFormat( &cf );
                                            if (SUCCEEDED(hr))
                                            {
                                                CSimpleStringWide strTemp(CSimpleStringConvert::WideString(CSimpleString(szFilename)));
                                                WCHAR szTemp[MAX_PATH];
                                                lstrcpyW( szTemp, strTemp.String() );
                                                hr = pWiaSupportedFormats->ChangeClipboardFileExtension( cf, szTemp, ARRAYSIZE(szTemp) );
                                                if (SUCCEEDED(hr))
                                                {
                                                    lstrcpy( szFilename, CSimpleStringConvert::NaturalString(CSimpleStringWide(szTemp)));
                                                    hr = pWiaTransferHelper->TransferItemFile( ppIWiaItems[i], m_hWnd, 0, cf, CSimpleStringConvert::WideString(CSimpleString(szFilename)).String(), pWiaDataCallback, TYMED_FILE );
                                                    if (S_OK == hr)
                                                    {
                                                        CSimpleString strNaturalFilename = CSimpleStringConvert::NaturalString(CSimpleString(szFilename));
                                                        
                                                        DestroyBitmap();
                                                        CGdiPlusHelper().LoadAndScale( m_hOriginalBitmap, strNaturalFilename );
                                                        InvalidateRect( m_hWnd, NULL, TRUE );
                                                        UpdateWindow( m_hWnd );

                                                        MessageBox( m_hWnd, CSimpleString().Format( TEXT("File transfer appeared to work: %s"), strNaturalFilename.String() ), TEXT("Debug"), 0 );
                                                        DeleteFile( strNaturalFilename );

                                                        hr = pWiaSupportedFormats->Initialize( ppIWiaItems[i], TYMED_CALLBACK );
                                                        if (SUCCEEDED(hr))
                                                        {
                                                            hr = pWiaSupportedFormats->GetDefaultClipboardFileFormat( &cf );
                                                            if (SUCCEEDED(hr))
                                                            {
                                                                hr = pWiaTransferHelper->TransferItemBanded( ppIWiaItems[i], m_hWnd, 0, cf, 0, pWiaDataCallback );
                                                                if (S_OK == hr)
                                                                {
                                                                    MessageBox( m_hWnd, TEXT("Banded transfer appeared to work"), TEXT("Debug"), 0 );
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                ppIWiaItems[i]->Release();
                            }
                        }
                        LocalFree( ppIWiaItems );
                    }
                }
            }
        }
        if (FAILED(hr))
        {
            TCHAR szMessage[MAX_PATH];
            wsprintf( szMessage, TEXT("HRESULT: 0x%08X"), hr );
            MessageBox( NULL, szMessage, TEXT("Some kinda error happened"), 0 );
            WIA_PRINTHRESULT((hr,TEXT("ScannerAcquireDialog failed")));
        }
    }

    bool LoadAndScale( LPCTSTR pszImageName )
    {
        const int cnScaleX = 800;
        const int cnScaleY = 600;
        const int bScaleSmallImages = true;
        bool bResult = false;
        CGdiPlusHelper GdiPlusHelper;
        HRESULT hr = GdiPlusHelper.LoadAndScale( m_hOriginalBitmap, pszImageName, cnScaleX, cnScaleY, bScaleSmallImages );
        if (SUCCEEDED(hr))
        {
            if (m_hOriginalBitmap)
            {
                InvalidateRect( m_hWnd, NULL, TRUE );
                UpdateWindow(m_hWnd);
                MessageBox( m_hWnd, CSimpleString().Format( TEXT("GdiPlusHelper.LoadAndScale(\n   m_hOriginalBitmap = %p, \n   szSourceImage = %s, \n   cnScaleX = %d, \n   cnScaleY = %d, \n   bScaleSmallImages = %d\n) succeeded"), m_hOriginalBitmap, pszImageName, cnScaleX, cnScaleY, bScaleSmallImages ), TEXT("OnGdiLoadAndScaleImage"), MB_ICONINFORMATION );
                bResult = true;
            }
            else
            {
                MessageBox( m_hWnd, CSimpleString().Format( TEXT("GdiPlusHelper.LoadAndScale(\n   m_hOriginalBitmap = %p, \n   szSourceImage = %s, \n   cnScaleX = %d, \n   cnScaleY = %d, \n   bScaleSmallImages = %d\n) failed with a NULL HBITMAP"), m_hOriginalBitmap, pszImageName, cnScaleX, cnScaleY, bScaleSmallImages ), TEXT("OnGdiLoadAndScaleImage"), MB_ICONHAND );
            }
        }
        else
        {
            MessageBox( m_hWnd, CSimpleString().Format( TEXT("GdiPlusHelper.LoadAndScale(\n   m_hOriginalBitmap = %p, \n   szSourceImage = %s, \n   cnScaleX = %d, \n   cnScaleY = %d, \n   bScaleSmallImages = %d\n) failed with an HRESULT of %08X"), m_hOriginalBitmap, pszImageName, cnScaleX, cnScaleY, bScaleSmallImages, hr ), TEXT("OnGdiLoadAndScaleImage"), MB_ICONHAND );
        }
        return bResult;
    }

    void RotateFile( bool bJpeg )
    {
        const int cnDegrees = 90;
        const int bScaleSmallImages = true;
        TCHAR szSourceImage[MAX_PATH] = {0};
        OPENFILENAME OpenFileName = {0};
        OpenFileName.lStructSize = sizeof(OpenFileName);
        OpenFileName.lpstrFilter = bJpeg ? TEXT("JPEG Files\0*.jpg;*.jpe;*.jpeg\0") : TEXT("All files\0*.*\0");
        OpenFileName.lpstrFile = szSourceImage;
        OpenFileName.nMaxFile = ARRAYSIZE(szSourceImage);
        if (GetOpenFileName(&OpenFileName))
        {
            TCHAR szTempDir[MAX_PATH];
            if (GetTempPath(ARRAYSIZE(szTempDir),szTempDir))
            {
                TCHAR szTempTargetFile[MAX_PATH];
                if (GetTempFileName(szTempDir,TEXT("taq"), 0, szTempTargetFile ))
                {
                    CGdiPlusHelper GdiPlusHelper;
                    HRESULT hr = GdiPlusHelper.Rotate( CSimpleStringConvert::WideString(CSimpleString(szSourceImage)), CSimpleStringConvert::WideString(CSimpleString(szTempTargetFile)), cnDegrees, IID_NULL );
                    if (SUCCEEDED(hr))
                    {
                        if (LoadAndScale(szTempTargetFile))
                        {
                            MessageBox( m_hWnd, CSimpleString().Format( TEXT("GdiPlusHelper.Rotate(\n   szSourceImage = %s, \n   szTempTargetFile = %s, \n   cnDegrees = %d\n) succeeded"), szSourceImage, szTempTargetFile, cnDegrees ), TEXT("RotateFile"), MB_ICONINFORMATION );
                        }
                    }
                    else
                    {
                        MessageBox( m_hWnd, CSimpleString().Format( TEXT("GdiPlusHelper.Rotate(\n   szSourceImage = %s, \n   szTempTargetFile = %s, \n   cnDegrees = %d\n) failed with HRESULT %08X"), szSourceImage, szTempTargetFile, cnDegrees, hr ), TEXT("RotateFile"), MB_ICONHAND );
                    }
                }
            }
        }
    }

    void OnGdiRotateFileNonJpeg( WPARAM, LPARAM )
    {
        RotateFile(false);
    }
    void OnGdiRotateFileJpeg( WPARAM, LPARAM )
    {
        RotateFile(true);
    }
    void OnGdiLoadAndScaleImage( WPARAM, LPARAM )
    {
        const int cnScaleX = 800;
        const int cnScaleY = 600;
        const int bScaleSmallImages = true;
        DestroyBitmap();
        TCHAR szSourceImage[MAX_PATH] = {0};
        OPENFILENAME OpenFileName = {0};
        OpenFileName.lStructSize = sizeof(OpenFileName);
        OpenFileName.lpstrFilter = TEXT("All files\0*.*\0");
        OpenFileName.lpstrFile = szSourceImage;
        OpenFileName.nMaxFile = ARRAYSIZE(szSourceImage);
        if (GetOpenFileName(&OpenFileName))
        {
            CGdiPlusHelper GdiPlusHelper;
            HRESULT hr = GdiPlusHelper.LoadAndScale( m_hOriginalBitmap, szSourceImage, cnScaleX, cnScaleY, bScaleSmallImages );
            if (SUCCEEDED(hr))
            {
                if (m_hOriginalBitmap)
                {
                    InvalidateRect( m_hWnd, NULL, TRUE );
                    UpdateWindow(m_hWnd);
                    MessageBox( m_hWnd, CSimpleString().Format( TEXT("GdiPlusHelper.LoadAndScale(\n   m_hOriginalBitmap = %p, \n   szSourceImage = %s, \n   cnScaleX = %d, \n   cnScaleY = %d, \n   bScaleSmallImages = %d\n) succeeded"), m_hOriginalBitmap, szSourceImage, cnScaleX, cnScaleY, bScaleSmallImages ), TEXT("OnGdiLoadAndScaleImage"), MB_ICONINFORMATION );
                }
                else
                {
                    MessageBox( m_hWnd, CSimpleString().Format( TEXT("GdiPlusHelper.LoadAndScale(\n   m_hOriginalBitmap = %p, \n   szSourceImage = %s, \n   cnScaleX = %d, \n   cnScaleY = %d, \n   bScaleSmallImages = %d\n) failed with a NULL HBITMAP"), m_hOriginalBitmap, szSourceImage, cnScaleX, cnScaleY, bScaleSmallImages ), TEXT("OnGdiLoadAndScaleImage"), MB_ICONHAND );
                }
            }
            else
            {
                MessageBox( m_hWnd, CSimpleString().Format( TEXT("GdiPlusHelper.LoadAndScale(\n   m_hOriginalBitmap = %p, \n   szSourceImage = %s, \n   cnScaleX = %d, \n   cnScaleY = %d, \n   bScaleSmallImages = %d\n) failed with an HRESULT of %08X"), m_hOriginalBitmap, szSourceImage, cnScaleX, cnScaleY, bScaleSmallImages, hr ), TEXT("OnGdiLoadAndScaleImage"), MB_ICONHAND );
            }
        }
    }
    void OnGdiLoadAndScaleStream( WPARAM, LPARAM )
    {
        const int cnScaleX = 800;
        const int cnScaleY = 600;
        const int bScaleSmallImages = true;
        DestroyBitmap();

        CComPtr<IStream> pStream;
        
        //HRESULT hr = URLOpenBlockingStream( NULL, TEXT("http://www.ivory.org/spiders/araneus.diadematus-4.jpg"), &pStream, 0, NULL );
        HRESULT hr = URLOpenBlockingStream( NULL, TEXT("http://orenr04:2869/upnphost/ssisapi.dll?ImageFile=nature3.jpg"), &pStream, 0, NULL );
        if (SUCCEEDED(hr))
        {
            CGdiPlusHelper GdiPlusHelper;
            hr = GdiPlusHelper.LoadAndScale( m_hOriginalBitmap, pStream, cnScaleX, cnScaleY, bScaleSmallImages );
            if (SUCCEEDED(hr))
            {
                if (m_hOriginalBitmap)
                {
                    InvalidateRect( m_hWnd, NULL, TRUE );
                    UpdateWindow(m_hWnd);
                    MessageBox( m_hWnd, CSimpleString().Format( TEXT("GdiPlusHelper.LoadAndScale(\n   m_hOriginalBitmap = %p, \n   pStream = %p, \n   cnScaleX = %d, \n   cnScaleY = %d, \n   bScaleSmallImages = %d\n) succeeded"), m_hOriginalBitmap, pStream, cnScaleX, cnScaleY, bScaleSmallImages ), TEXT("OnGdiLoadAndScaleImage"), MB_ICONINFORMATION );
                }
                else
                {
                    MessageBox( m_hWnd, CSimpleString().Format( TEXT("GdiPlusHelper.LoadAndScale(\n   m_hOriginalBitmap = %p, \n   pStream = %p, \n   cnScaleX = %d, \n   cnScaleY = %d, \n   bScaleSmallImages = %d\n) failed with a NULL HBITMAP"), m_hOriginalBitmap, pStream, cnScaleX, cnScaleY, bScaleSmallImages ), TEXT("OnGdiLoadAndScaleImage"), MB_ICONHAND );
                }
            }
            else
            {
                MessageBox( m_hWnd, CSimpleString().Format( TEXT("GdiPlusHelper.LoadAndScale(\n   m_hOriginalBitmap = %p, \n   pStream = %p, \n   cnScaleX = %d, \n   cnScaleY = %d, \n   bScaleSmallImages = %d\n) failed with an HRESULT of %08X"), m_hOriginalBitmap, pStream, cnScaleX, cnScaleY, bScaleSmallImages, hr ), TEXT("OnGdiLoadAndScaleImage"), MB_ICONHAND );
            }
        }
        else
        {
            MessageBox( m_hWnd, CSimpleString().Format( TEXT("URLOpenBlockingStream failed: %08X" ), hr ), TEXT("OnGdiLoadAndScaleImage"), MB_ICONHAND );
        }
    }
    void OnGdiConvertFile( WPARAM, LPARAM )
    {
#if 0
        TCHAR szInputFilename[MAX_PATH];
        OPENFILENAME OpenFileName = {0};
        OpenFileName.lStructSize = sizeof(OPENFILENAME);
        OpenFileName.hwndOwner = m_hWnd;
        OpenFileName.hInstance = g_hInstance;
        OpenFileName.lpstrFilter = TEXT("All Files (*.*)\0*.*\0");
        OpenFileName.lpstrFile = szInputFilename;
        OpenFileName.nMaxFile = ARRAYSIZE(szInputFilename);
        OpenFileName.lpstrTitle = TEXT("Choose File to Convert");
        OpenFileName.Flags = OFN_ENABLESIZING|OFN_FILEMUSTEXIST|OFN_HIDEREADONLY|OFN_EXPLORER;
        if (GetOpenFileName(&OpenFileName))
        {
            TCHAR szOutputFilename[MAX_PATH] = {0};
            OPENFILENAME SaveFileName = {0};
            SaveFileName.lStructSize = sizeof(OPENFILENAME);
            SaveFileName.hwndOwner = m_hWnd;
            SaveFileName.hInstance = g_hInstance;
            SaveFileName.lpstrFilter = TEXT("All Files (*.*)\0*.*\0");
            SaveFileName.lpstrFile = szOutputFilename;
            SaveFileName.nMaxFile = ARRAYSIZE(szOutputFilename);
            SaveFileName.lpstrTitle = TEXT("Choose output file and type");
            SaveFileName.Flags = OFN_ENABLESIZING|OFN_HIDEREADONLY|OFN_EXPLORER|OFN_OVERWRITEPROMPT|OFN_PATHMUSTEXIST;
            if (GetSaveFileName(&SaveFileName))
            {
            }
        }
#else
        CMessageBoxEx::MessageBox( m_hWnd, TEXT("Not implemented"), TEXT("testacqd"), CMessageBoxEx::MBEX_OK|CMessageBoxEx::MBEX_ICONWARNING );
#endif
    }

    void OnExploreWiaDevice( WPARAM, LPARAM )
    {
        CWaitCursor wc;
        CComPtr<IWiaDevMgr> pIWiaDevMgr;
        HRESULT hr = CoCreateInstance( CLSID_WiaDevMgr, NULL, CLSCTX_LOCAL_SERVER, IID_IWiaDevMgr, (void**)&pIWiaDevMgr );
        if (SUCCEEDED(hr))
        {
            CComPtr<IWiaItem> pWiaItemRoot;
            BSTR bstrDeviceId = NULL;
            hr = pIWiaDevMgr->SelectDeviceDlgID( m_hWnd, SELECT_DEVICE_TYPE, 0, &bstrDeviceId );
            if (S_OK == hr)
            {
                hr = WiaUiUtil::ExploreWiaDevice( bstrDeviceId );
            }
        }
        if (!SUCCEEDED(hr))
        {
            CMessageBoxEx::MessageBox( m_hWnd, CSimpleString().Format(TEXT("Result: %08X"),hr), TEXT("testacqd"), CMessageBoxEx::MBEX_OK|CMessageBoxEx::MBEX_ICONINFORMATION );
        }
    }

    void OnGdiRotateHBITMAP( WPARAM, LPARAM )
    {
        if (m_hOriginalBitmap)
        {
            HBITMAP hNewBitmap;
            CGdiPlusHelper GdiPlusHelper;
            GdiPlusHelper.Rotate( m_hOriginalBitmap, hNewBitmap, 90 );
            DestroyBitmap();
            m_hOriginalBitmap = hNewBitmap;
            InvalidateRect( m_hWnd, NULL, TRUE );
            UpdateWindow(m_hWnd);
        }
    }
    void OnGdiDisplayDecoderExtensions( WPARAM, LPARAM )
    {
        CSimpleString strExtensions;
        HRESULT hr = CGdiPlusHelper().ConstructDecoderExtensionSearchStrings( strExtensions );
        if (SUCCEEDED(hr))
        {
            MessageBox( m_hWnd, CSimpleString().Format( TEXT("GdiPlusHelper.ConstructDecoderExtensionSearchStrings() succeeded and returned strExtensions = %s"), strExtensions.String() ), TEXT("OnGdiDisplayDecoderExtensions"), MB_ICONINFORMATION );
        }
        else
        {
            MessageBox( m_hWnd, CSimpleString().Format( TEXT("GdiPlusHelper.ConstructDecoderExtensionSearchStrings() returned HRESULT = %08X"), hr ), TEXT("OnGdiDisplayDecoderExtensions"), MB_ICONINFORMATION );
        }
    }
    void OnGdiDisplayEncoderExtensions( WPARAM, LPARAM )
    {
        CSimpleString strExtensions;
        HRESULT hr = CGdiPlusHelper().ConstructEncoderExtensionSearchStrings( strExtensions );
        if (SUCCEEDED(hr))
        {
            MessageBox( m_hWnd, CSimpleString().Format( TEXT("GdiPlusHelper.ConstructEncoderExtensionSearchStrings() succeeded and returned strExtensions = %s"), strExtensions.String() ), TEXT("OnGdiDisplayEncoderExtensions"), MB_ICONINFORMATION );
        }
        else
        {
            MessageBox( m_hWnd, CSimpleString().Format( TEXT("GdiPlusHelper.ConstructEncoderExtensionSearchStrings() returned HRESULT = %08X"), hr ), TEXT("OnGdiDisplayEncoderExtensions"), MB_ICONINFORMATION );
        }
    }

    void OnGdiSaveMultipleImagesAsMultiPage( WPARAM, LPARAM )
    {
        LPTSTR pszFiles = new TCHAR[0xFFFF];
        if (pszFiles)
        {
            OPENFILENAME OpenFileName = {0};
            OpenFileName.lStructSize = sizeof(OPENFILENAME);
            OpenFileName.hwndOwner = m_hWnd;
            OpenFileName.hInstance = g_hInstance;
            OpenFileName.lpstrFilter = TEXT("All Files (*.*)\0*.*\0");
            OpenFileName.lpstrFile = pszFiles;
            OpenFileName.nMaxFile = 0xFFFF;
            OpenFileName.lpstrTitle = TEXT("Choose Files to Convert to a multi-page TIFF");
            OpenFileName.Flags = OFN_ALLOWMULTISELECT|OFN_ENABLESIZING|OFN_FILEMUSTEXIST|OFN_HIDEREADONLY|OFN_EXPLORER;
            if (GetOpenFileName(&OpenFileName))
            {
                CMultiString strItems(pszFiles);

                if (strItems.Size())
                {
                    CSimpleDynamicArray<CSimpleStringWide> strFiles;
                    if (strItems.Size() == 1)
                    {
                        strFiles.Append(CSimpleStringConvert::WideString(CSimpleString(strItems[0])));
                    }
                    else
                    {
                        CSimpleString strDirectory = strItems[0];
                        if (!strDirectory.MatchLastCharacter(TEXT('\\')))
                        {
                            strDirectory += TEXT("\\");
                        }
                        for (int i=1;i<strItems.Size();i++)
                        {
                            strFiles.Append(CSimpleStringConvert::WideString(CSimpleString(strDirectory + strItems[i])));
                        }
                    }
                    for (int i=0;i<strFiles.Size();i++)
                    {
                        WIA_TRACE((TEXT("strFiles[i] = %ws"), strFiles[i].String()));
                    }
                    TCHAR szOutputFilename[MAX_PATH] = {0};
                    OPENFILENAME SaveFileName = {0};
                    SaveFileName.lStructSize = sizeof(OPENFILENAME);
                    SaveFileName.hwndOwner = m_hWnd;
                    SaveFileName.hInstance = g_hInstance;
                    SaveFileName.lpstrFilter = TEXT("All Files (*.*)\0*.*\0");
                    SaveFileName.lpstrFile = szOutputFilename;
                    SaveFileName.nMaxFile = ARRAYSIZE(szOutputFilename);
                    SaveFileName.lpstrTitle = TEXT("Select a name for your multi-page TIFF");
                    SaveFileName.Flags = OFN_ENABLESIZING|OFN_HIDEREADONLY|OFN_EXPLORER|OFN_OVERWRITEPROMPT|OFN_PATHMUSTEXIST;
                    if (GetSaveFileName(&SaveFileName))
                    {
                        HRESULT hr = CGdiPlusHelper().SaveMultipleImagesAsMultiPage( strFiles, CSimpleStringConvert::WideString(CSimpleString(szOutputFilename)), Gdiplus::ImageFormatTIFF );
                        if (SUCCEEDED(hr))
                        {
                            MessageBox( m_hWnd, TEXT("CGdiPlusHelper().SaveMultipleImagesAsMultiPage() succeeded"), TEXT("OnGdiDisplayDecoderExtensions"), MB_ICONINFORMATION );
                        }
                        else
                        {
                            MessageBox( m_hWnd, CSimpleString().Format( TEXT("CGdiPlusHelper().SaveMultipleImagesAsMultiPage() returned HRESULT = %08X"), hr ), TEXT("OnGdiDisplayDecoderExtensions"), MB_ICONINFORMATION );
                        }
                    }
                }
            }
            delete[] pszFiles;
        }
    }

    void OnGdiIncreaseThreshold( WPARAM, LPARAM )
    {
        if (m_nThreshold != 100)
        {
            m_nThreshold++;
            if (m_hTransformedBitmap)
            {
                DeleteObject(m_hTransformedBitmap);
                m_hTransformedBitmap = NULL;
            }
            CGdiPlusHelper().SetThreshold( m_hOriginalBitmap, m_hTransformedBitmap, m_nThreshold );
            InvalidateRect( m_hWnd, NULL, FALSE );
            UpdateWindow( m_hWnd );
        }
    }

    void OnGdiDecreaseThreshold( WPARAM, LPARAM )
    {
        if (m_nThreshold != 0)
        {
            m_nThreshold--;
            if (m_hTransformedBitmap)
            {
                DeleteObject(m_hTransformedBitmap);
                m_hTransformedBitmap = NULL;
            }
            CGdiPlusHelper().SetThreshold( m_hOriginalBitmap, m_hTransformedBitmap, m_nThreshold );
            InvalidateRect( m_hWnd, NULL, FALSE );
            UpdateWindow( m_hWnd );
        }
    }

    void OnGdiIncreaseContrast( WPARAM, LPARAM )
    {
        if (m_nContrast != 100)
        {
            m_nContrast++;
            if (m_hTransformedBitmap)
            {
                DeleteObject(m_hTransformedBitmap);
                m_hTransformedBitmap = NULL;
            }
            CGdiPlusHelper().SetBrightnessAndContrast( m_hOriginalBitmap, m_hTransformedBitmap, m_nBrightness, m_nContrast );
            InvalidateRect( m_hWnd, NULL, FALSE );
            UpdateWindow( m_hWnd );
        }
    }


    void OnGdiDecreaseContrast( WPARAM, LPARAM )
    {
        if (m_nContrast != 0)
        {
            m_nContrast--;
            if (m_hTransformedBitmap)
            {
                DeleteObject(m_hTransformedBitmap);
                m_hTransformedBitmap = NULL;
            }
            CGdiPlusHelper().SetBrightnessAndContrast( m_hOriginalBitmap, m_hTransformedBitmap, m_nBrightness, m_nContrast );
            InvalidateRect( m_hWnd, NULL, FALSE );
            UpdateWindow( m_hWnd );
        }
    }
    
    void OnGdiDecreaseBrightness( WPARAM, LPARAM )
    {
        if (m_nBrightness != 0)
        {
            m_nBrightness--;
            if (m_hTransformedBitmap)
            {
                DeleteObject(m_hTransformedBitmap);
                m_hTransformedBitmap = NULL;
            }
            CGdiPlusHelper().SetBrightnessAndContrast( m_hOriginalBitmap, m_hTransformedBitmap, m_nBrightness, m_nContrast );
            InvalidateRect( m_hWnd, NULL, FALSE );
            UpdateWindow( m_hWnd );
        }
    }


    void OnGdiIncreaseBrightness( WPARAM, LPARAM )
    {
        if (m_nBrightness != 255)
        {
            m_nBrightness++;
            if (m_hTransformedBitmap)
            {
                DeleteObject(m_hTransformedBitmap);
                m_hTransformedBitmap = NULL;
            }
            CGdiPlusHelper().SetBrightnessAndContrast( m_hOriginalBitmap, m_hTransformedBitmap, m_nBrightness, m_nContrast );
            InvalidateRect( m_hWnd, NULL, FALSE );
            UpdateWindow( m_hWnd );
        }
    }

    void OnTestUniversalPnpSlideshowClient( WPARAM, LPARAM )
    {
        CComPtr<IUPnPDeviceFinder> pUPnPDeviceFinder;
        HRESULT hr = CoCreateInstance( CLSID_UPnPDeviceFinder, NULL, CLSCTX_INPROC_SERVER, IID_IUPnPDeviceFinder, (void**)&pUPnPDeviceFinder ); 
        if (SUCCEEDED(hr))
        {
            CComPtr<IUPnPDevices> pUPnPDevices;
            hr = pUPnPDeviceFinder->FindByType(CSimpleBStr(CSimpleString(TEXT("urn:schemas-upnp-org:device:SlideshowProjector:1"))),0,&pUPnPDevices);
            if (S_OK == hr)
            {
                LONG nDeviceCount=0;
                hr = pUPnPDevices->get_Count(&nDeviceCount);
                if (S_OK == hr)
                {
                    CComPtr<IUnknown> pUnknown;
                    hr = pUPnPDevices->get__NewEnum(&pUnknown);
                    if (S_OK == hr)
                    {
                        CComPtr<IEnumUnknown> pEnumUnknown;
                        hr = pUnknown->QueryInterface( IID_IEnumUnknown, (VOID **)&pEnumUnknown);
                        if (S_OK == hr)
                        {
                            ULONG nDevicesReturned=0;
                            CComPtr<IUnknown> pDeviceUnknown;
                            hr = pEnumUnknown->Next( 1, &pDeviceUnknown, &nDevicesReturned );
                            if (S_OK == hr)
                            {
                                CComPtr<IUPnPDevice> pUPnPDevice;
                                hr = pDeviceUnknown->QueryInterface( IID_IUPnPDevice, (void**)&pUPnPDevice);
                                if (S_OK == hr)
                                {
                                    CComPtr<IUPnPServices> pUPnPServices;
                                    hr= pUPnPDevice->get_Services(&pUPnPServices);
                                    if (S_OK == hr)
                                    {
                                        CComPtr<IUnknown> pUnknown;
                                        hr = pUPnPServices->get__NewEnum(&pUnknown);
                                        if (S_OK == hr)
                                        {
                                            CComPtr<IEnumUnknown> pEnumUnknown;
                                            hr = pUnknown->QueryInterface( IID_IEnumUnknown, (void**)&pEnumUnknown );
                                            if (S_OK == hr)
                                            {
                                                hr = pEnumUnknown->Reset();
                                                while (S_OK == hr)
                                                {
                                                    ULONG nNumFetched = 0;
                                                    CComPtr<IUnknown> pUnknown;
                                                    hr = pEnumUnknown->Next( 1, &pUnknown, &nNumFetched );
                                                    if (S_OK == hr)
                                                    {
                                                        CComPtr<IUPnPService> pUPnPService;
                                                        hr = pUnknown->QueryInterface(IID_IUPnPService, (void**)&pUPnPService);
                                                        if (S_OK == hr)
                                                        {
                                                        }
                                                        else
                                                        {
                                                            MessageBox( m_hWnd, CSimpleString(TEXT("pUnknown->QueryInterface on IID_IUPnPService failed\n\n")) + WiaUiUtil::GetErrorTextFromHResult(hr), TEXT("OnTestUniversalPnpSlideshowClient"), MB_ICONINFORMATION );
                                                        }
                                                        //
                                                        // Release it
                                                        //
                                                        pUnknown = NULL;
                                                    }
                                                    else if (FAILED(hr))
                                                    {
                                                        MessageBox( m_hWnd, CSimpleString(TEXT("pEnumUnknown->Next() failed\n\n")) + WiaUiUtil::GetErrorTextFromHResult(hr), TEXT("OnTestUniversalPnpSlideshowClient"), MB_ICONINFORMATION );
                                                    }
                                                }
                                                
                                                if (FAILED(hr))
                                                {
                                                    MessageBox( m_hWnd, CSimpleString(TEXT("pEnumUnknown->Reset() failed\n\n")) + WiaUiUtil::GetErrorTextFromHResult(hr), TEXT("OnTestUniversalPnpSlideshowClient"), MB_ICONINFORMATION );
                                                }
                                            }
                                            else
                                            {
                                                MessageBox( m_hWnd, CSimpleString(TEXT("pUnknown->QueryInterface on IID_IEnumUnknown failed\n\n")) + WiaUiUtil::GetErrorTextFromHResult(hr), TEXT("OnTestUniversalPnpSlideshowClient"), MB_ICONINFORMATION );
                                            }
                                        }
                                        else
                                        {
                                            MessageBox( m_hWnd, CSimpleString(TEXT("pUPnPDevice->get_Services() failed\n\n")) + WiaUiUtil::GetErrorTextFromHResult(hr), TEXT("OnTestUniversalPnpSlideshowClient"), MB_ICONINFORMATION );
                                        }
                                        
                                        m_pUPnPService = NULL;
                                        hr = pUPnPServices->get_Item(CSimpleBStr(TEXT("upnp:id:SlideshowService")),&m_pUPnPService);
                                        if (S_OK == hr)
                                        {
                                            hr = m_pUPnPService->AddCallback( this );
                                            if (S_OK == hr)
                                            {
                                                WIA_TRACE((TEXT("m_pUPnPService->AddCallback SUCCEEDED!")));
                                                MessageBeep(-1);
                                            }
                                            else
                                            {
                                                MessageBox( m_hWnd, CSimpleString(TEXT("m_pUPnPService->AddCallback() failed\n\n")) + WiaUiUtil::GetErrorTextFromHResult(hr), TEXT("OnTestUniversalPnpSlideshowClient"), MB_ICONINFORMATION );
                                            }
                                        }
                                        else
                                        {
                                            MessageBox( m_hWnd, CSimpleString(TEXT("pUPnPServices->get_Item() failed\n\n")) + WiaUiUtil::GetErrorTextFromHResult(hr), TEXT("OnTestUniversalPnpSlideshowClient"), MB_ICONINFORMATION );
                                        }
                                    }
                                    else
                                    {
                                        MessageBox( m_hWnd, CSimpleString(TEXT("pUPnPDevice->get_Services() failed\n\n")) + WiaUiUtil::GetErrorTextFromHResult(hr), TEXT("OnTestUniversalPnpSlideshowClient"), MB_ICONINFORMATION );
                                    }
                                }
                                else
                                {
                                    MessageBox( m_hWnd, CSimpleString(TEXT("pDeviceUnknown->QueryInterface() failed on IID_IUPnPDevice\n\n")) + WiaUiUtil::GetErrorTextFromHResult(hr), TEXT("OnTestUniversalPnpSlideshowClient"), MB_ICONINFORMATION );
                                }
                            }
                            else
                            {
                                MessageBox( m_hWnd, CSimpleString(TEXT("pEnumUnknown->Next() failed\n\n")) + WiaUiUtil::GetErrorTextFromHResult(hr), TEXT("OnTestUniversalPnpSlideshowClient"), MB_ICONINFORMATION );
                            }
                        }
                        else
                        {
                            MessageBox( m_hWnd, CSimpleString(TEXT("pUnknown->QueryInterface() failed on IID_IEnumUnknown\n\n")) + WiaUiUtil::GetErrorTextFromHResult(hr), TEXT("OnTestUniversalPnpSlideshowClient"), MB_ICONINFORMATION );
                        }
                    }
                    else
                    {
                        MessageBox( m_hWnd, CSimpleString(TEXT("pUPnPDevices->get__NewEnum() failed\n\n")) + WiaUiUtil::GetErrorTextFromHResult(hr), TEXT("OnTestUniversalPnpSlideshowClient"), MB_ICONINFORMATION );
                    }
                }
                else
                {
                    MessageBox( m_hWnd, CSimpleString(TEXT("pUPnPDevices->get_Count() failed\n\n")) + WiaUiUtil::GetErrorTextFromHResult(hr), TEXT("OnTestUniversalPnpSlideshowClient"), MB_ICONINFORMATION );
                }
            }
            else
            {
                MessageBox( m_hWnd, CSimpleString(TEXT("pUPnPDeviceFinder->FindByType() failed\n\n")) + WiaUiUtil::GetErrorTextFromHResult(hr), TEXT("OnTestUniversalPnpSlideshowClient"), MB_ICONINFORMATION );
            }
        }
        else
        {
            MessageBox( m_hWnd, CSimpleString(TEXT("CoCreateInstance failed on CLSID_UPnPDeviceFinder\n\n")) + WiaUiUtil::GetErrorTextFromHResult(hr), TEXT("OnTestUniversalPnpSlideshowClient"), MB_ICONINFORMATION );
        }

    }

    void OnTestUniversalPnpSlideshowClientStop( WPARAM, LPARAM )
    {
        m_pUPnPService = NULL;
    }

    void OnPublishWizard( WPARAM, LPARAM )
    {
        LPTSTR pszFiles = new TCHAR[0xFFFF];
        if (pszFiles)
        {
            OPENFILENAME OpenFileName = {0};
            OpenFileName.lStructSize = sizeof(OPENFILENAME);
            OpenFileName.hwndOwner = m_hWnd;
            OpenFileName.hInstance = g_hInstance;
            OpenFileName.lpstrFilter = TEXT("All Files (*.*)\0*.*\0");
            OpenFileName.lpstrFile = pszFiles;
            OpenFileName.nMaxFile = 0xFFFF;
            OpenFileName.lpstrTitle = TEXT("Choose Files to Upload");
            OpenFileName.Flags = OFN_ALLOWMULTISELECT|OFN_ENABLESIZING|OFN_FILEMUSTEXIST|OFN_HIDEREADONLY|OFN_EXPLORER;
            if (GetOpenFileName(&OpenFileName))
            {
                CMultiString strItems(pszFiles);

                if (strItems.Size())
                {
                    CSimpleDynamicArray<CSimpleString> strFiles;
                    if (strItems.Size() == 1)
                    {
                        strFiles.Append(strItems[0]);
                    }
                    else
                    {
                        CSimpleString strDirectory = strItems[0];
                        if (!strDirectory.MatchLastCharacter(TEXT('\\')))
                        {
                            strDirectory += TEXT("\\");
                        }
                        for (int i=1;i<strItems.Size();i++)
                        {
                            strFiles.Append(strDirectory + strItems[i]);
                        }
                    }
                    for (int i=0;i<strFiles.Size();i++)
                    {
                        WIA_TRACE((TEXT("strFiles[i] = %s"), strFiles[i].String()));
                    }
                    HRESULT hr = NetPublishingWizard::RunNetPublishingWizard( strFiles );
                    if (FAILED(hr))
                    {
                        WIA_PRINTHRESULT((hr,TEXT("NetPublishingWizard::RunNetPublishingWizard returned")));
                    }
                }
            }
            delete[] pszFiles;
        }
    }

    void OnWiaSelectDeviceDlgId( WPARAM, LPARAM )
    {
        CComPtr<IWiaDevMgr> pIWiaDevMgr;
        HRESULT hr = CoCreateInstance( CLSID_WiaDevMgr, NULL, CLSCTX_LOCAL_SERVER, IID_IWiaDevMgr, (void**)&pIWiaDevMgr );
        if (SUCCEEDED(hr))
        {
            CComPtr<IWiaItem> pWiaItemRoot;
            BSTR bstrDeviceId = NULL;
            hr = pIWiaDevMgr->SelectDeviceDlgID( m_hWnd, SELECT_DEVICE_TYPE, 0, &bstrDeviceId );
            if (SUCCEEDED(hr) && (S_FALSE != hr))
            {
                MessageBox( m_hWnd, CSimpleStringConvert::NaturalString(CSimpleStringWide(bstrDeviceId)), TEXT("Device ID:"), MB_ICONINFORMATION );
            }
        }
        if (FAILED(hr))
        {
            WIA_PRINTHRESULT((hr,TEXT("OnSelectDeviceDlgId returned")));
        }
    }

    void OnWiaWizard( WPARAM, LPARAM )
    {
        HRESULT hr = RunWiaWizard::RunWizard( NULL, m_hWnd );
        if (FAILED(hr))
        {
            WIA_PRINTHRESULT((hr,TEXT("RunWiaWizard::RunWizard returned")));
        }
    }
    void OnMbox( WPARAM wParam, LPARAM )
    {
        LPCTSTR pszTitle = TEXT("Message Box Test Title");
        LPCTSTR pszMessage = TEXT("Message Box Test Message\nMessage Box Test Message\nMessage Box Test Message\nMessage Box Test Message\nMessage Box Test Message\nMessage Box Test Message\nMessage Box Test Message\nMessage Box Test Message\nMessage Box Test Message\nMessage Box Test Message\n(LAST) Message Box Test Message");
        LPCTSTR pszFormat = TEXT("This is a formatted string: \"%s\", and this is a formatted number: %d");
        UINT nTitleId = IDS_MESSAGEBOXTESTTITLE;
        UINT nMessageId = IDS_MESSAGEBOXTESTMESSAGE;
        UINT nFormatId = IDS_MESSAGEBOXTESTFORMAT;
        UINT nFlags = m_nMessageBoxExFlags;
        bool bHideFutureMessages = true;
        HINSTANCE hInstance = g_hInstance;
        HWND hWndParent = m_hWnd;
        LPCTSTR pszTestString = TEXT("This is a test string");
        int nTestNumber = 1234567890;
        INT_PTR nResult = 0;
        switch (LOWORD(wParam))
        {
        case ID_MBOX_FORM1:
            nResult = CMessageBoxEx::MessageBox( hWndParent, pszMessage, pszTitle, nFlags, bHideFutureMessages );
            break;
        case ID_MBOX_FORM2:
            nResult = CMessageBoxEx::MessageBox( hWndParent, pszMessage, pszTitle, nFlags );
            break;
        case ID_MBOX_FORM3:
            nResult = CMessageBoxEx::MessageBox( pszMessage, pszTitle, nFlags );
            break;
        case ID_MBOX_FORM4:
            nResult = CMessageBoxEx::MessageBox( hWndParent, hInstance, nMessageId, nTitleId, nFlags, bHideFutureMessages );
            break;
        case ID_MBOX_FORM5:
            nResult = CMessageBoxEx::MessageBox( hWndParent, pszTitle, nFlags, pszFormat, pszTestString, nTestNumber );
            break;
        case ID_MBOX_FORM6:
            nResult = CMessageBoxEx::MessageBox( hWndParent, pszTitle, nFlags, bHideFutureMessages, pszFormat, pszTestString, nTestNumber );
            break;
        case ID_MBOX_FORM7:
            nResult = CMessageBoxEx::MessageBox( hWndParent, hInstance, nTitleId, nFlags, nFormatId, pszTestString, nTestNumber );
            break;
        }
        MessageBox( m_hWnd, CSimpleString().Format( TEXT("CMessageBoxEx::MessageBox returned %d, and the value of bHideFutureMessages is %d"), nResult, bHideFutureMessages ), TEXT("Result"), MB_ICONINFORMATION );
    }


    LRESULT OnCommand( WPARAM wParam, LPARAM lParam )
    {
        SC_BEGIN_COMMAND_HANDLERS()
        {
            SC_HANDLE_COMMAND(ID_PROGRAM_EXIT,OnFileExit);

            SC_HANDLE_COMMAND(ID_WIA_DEVICEDLG,OnWiaDeviceDlg);
            SC_HANDLE_COMMAND(ID_WIA_SELECTDEVICEID,OnWiaSelectDeviceDlgId);

            SC_HANDLE_COMMAND(ID_PROGRESS_TESTPROGRESS,OnProgressTestProgress);
            SC_HANDLE_COMMAND(ID_PROGRESS_SETFLAGS,OnProgressSetFlags);

            SC_HANDLE_COMMAND(ID_GDI_ROTATEFILENONJPEG,OnGdiRotateFileNonJpeg);
            SC_HANDLE_COMMAND(ID_GDI_ROTATEFILEJPEG,OnGdiRotateFileJpeg);
            SC_HANDLE_COMMAND(ID_GDI_ROTATEHBITMAP,OnGdiRotateHBITMAP);
            SC_HANDLE_COMMAND(ID_GDI_LOADANDSCALEIMAGE,OnGdiLoadAndScaleImage);
            SC_HANDLE_COMMAND(ID_GDI_LOADANDSCALESTREAM,OnGdiLoadAndScaleStream);

            SC_HANDLE_COMMAND(ID_GDI_CONVERTFILE,OnGdiConvertFile);
            SC_HANDLE_COMMAND(ID_GDI_DISPLAYDECODEREXTENSIONS,OnGdiDisplayDecoderExtensions);
            SC_HANDLE_COMMAND(ID_GDI_DISPLAYENCODEREXTENSIONS,OnGdiDisplayEncoderExtensions);
            SC_HANDLE_COMMAND(ID_GDI_SAVEMULTIPLEIMAGESASMULTIPAGE, OnGdiSaveMultipleImagesAsMultiPage);

            SC_HANDLE_COMMAND(ID_GDI_INCREASETHRESHOLD,OnGdiIncreaseThreshold);
            SC_HANDLE_COMMAND(ID_GDI_DECREASETHRESHOLD,OnGdiDecreaseThreshold);
            
            SC_HANDLE_COMMAND(ID_GDI_INCREASECONTRAST,OnGdiIncreaseContrast);
            SC_HANDLE_COMMAND(ID_GDI_DECREASECONTRAST,OnGdiDecreaseContrast);

            SC_HANDLE_COMMAND(ID_GDI_INCREASEBRIGHTNESS,OnGdiIncreaseBrightness);
            SC_HANDLE_COMMAND(ID_GDI_DECREASEBRIGHTNESS,OnGdiDecreaseBrightness);

            SC_HANDLE_COMMAND(ID_WIZARD_PUBLISH_WIZARD,OnPublishWizard);
            SC_HANDLE_COMMAND(ID_WIZARD_ACQUIRE_WIZARD,OnWiaWizard);
            SC_HANDLE_COMMAND(ID_WIZARD_EXPLOREWIADEVICE,OnExploreWiaDevice);

            SC_HANDLE_COMMAND(ID_MBOX_FORM1,OnMbox);
            SC_HANDLE_COMMAND(ID_MBOX_FORM2,OnMbox);
            SC_HANDLE_COMMAND(ID_MBOX_FORM3,OnMbox);
            SC_HANDLE_COMMAND(ID_MBOX_FORM4,OnMbox);
            SC_HANDLE_COMMAND(ID_MBOX_FORM5,OnMbox);
            SC_HANDLE_COMMAND(ID_MBOX_FORM6,OnMbox);
            SC_HANDLE_COMMAND(ID_MBOX_FORM7,OnMbox);
            SC_HANDLE_COMMAND(ID_MBOX_SETFLAGS,OnMBoxSetFlags);

            SC_HANDLE_COMMAND(ID_UPNP_FINDSERVERANDREGISTER,OnTestUniversalPnpSlideshowClient);
            SC_HANDLE_COMMAND(ID_UPNP_STOP,OnTestUniversalPnpSlideshowClientStop);
        }
        SC_END_COMMAND_HANDLERS();
    }

    void FillRect( HDC hDC, int nLeft, int nTop, int nRight, int nBottom, HBRUSH hBrush )
    {
        RECT rcFill = {nLeft,nTop,nRight,nBottom};
        if (nLeft < nRight && nTop < nBottom)
        {
            ::FillRect( hDC, &rcFill, hBrush );
        }
    }

    void FillRectDifference( HDC hDC, const RECT &rcMain, const RECT &rcDiff, HBRUSH hBrush )
    {
        //
        // Top
        //
        FillRect( hDC, rcMain.left, rcMain.top, rcMain.right, rcDiff.top, hBrush );
        //
        // Bottom
        //
        FillRect( hDC, rcMain.left, rcDiff.bottom, rcMain.right, rcMain.bottom, hBrush );

        //
        // Left
        //
        FillRect( hDC, rcMain.left, rcDiff.top, rcDiff.left, rcDiff.bottom, hBrush );

        //
        // Right
        //
        FillRect( hDC, rcDiff.right, rcDiff.top, rcMain.right, rcMain.bottom, hBrush );
    }

    LRESULT OnEraseBkGnd( WPARAM, LPARAM )
    {
        return TRUE;
    }

    LRESULT OnSize( WPARAM, LPARAM )
    {
        InvalidateRect( m_hWnd, NULL, FALSE );
        UpdateWindow( m_hWnd );
        return 0;
    }

    LRESULT OnPaint( WPARAM, LPARAM )
    {
        PAINTSTRUCT ps;
        HDC hDC = BeginPaint( m_hWnd, &ps );
        if (hDC)
        {
            HBITMAP hBitmap = m_hOriginalBitmap;
            if (m_hTransformedBitmap)
            {
                hBitmap = m_hTransformedBitmap;
            }
            if (hBitmap)
            {
                BITMAP bm = {0};
                if (GetObject(hBitmap,sizeof(BITMAP),&bm))
                {
                    HDC hCompatDC = CreateCompatibleDC(hDC);
                    if (hCompatDC)
                    {
                        RECT rcClient;
                        GetClientRect( m_hWnd, &rcClient );

                        RECT rcImage;
                        rcImage.left = rcClient.left + (WiaUiUtil::RectWidth(rcClient)-bm.bmWidth)/2;
                        rcImage.top = rcClient.left + (WiaUiUtil::RectHeight(rcClient)-bm.bmHeight)/2;
                        rcImage.right = rcImage.left + bm.bmWidth;
                        rcImage.bottom = rcImage.top + bm.bmHeight;

                        HBITMAP hOldBitmap = reinterpret_cast<HBITMAP>(SelectObject(hCompatDC,hBitmap));

                        BitBlt( hDC, rcImage.left, rcImage.top, bm.bmWidth, bm.bmHeight, hCompatDC, 0, 0, SRCCOPY );

                        FillRectDifference( hDC, rcClient, rcImage, GetStockBrush(BLACK_BRUSH) );

                        SelectObject(hCompatDC,hOldBitmap);

                        DeleteDC(hCompatDC);
                    }
                }
            }
            EndPaint( m_hWnd, &ps );
        }
        return 0;
    }

    LRESULT OnInitMenu( WPARAM wParam, LPARAM )
    {
        HMENU hMenu = reinterpret_cast<HMENU>(wParam);
        if (hMenu)
        {
            EnableMenuItem( hMenu, ID_UPNP_FINDSERVERANDREGISTER, m_pUPnPService ? MF_GRAYED|MF_BYCOMMAND : MF_ENABLED|MF_BYCOMMAND );
            EnableMenuItem( hMenu, ID_UPNP_STOP, m_pUPnPService ? MF_ENABLED|MF_BYCOMMAND : MF_GRAYED|MF_BYCOMMAND );
        }
        return 0;
    }

    static LRESULT CALLBACK WndProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam )
    {
        SC_BEGIN_MESSAGE_HANDLERS(CMiscUnitTestWindow)
        {
            SC_HANDLE_MESSAGE( WM_DESTROY, OnDestroy );
            SC_HANDLE_MESSAGE( WM_CREATE, OnCreate );
            SC_HANDLE_MESSAGE( WM_COMMAND, OnCommand );
            SC_HANDLE_MESSAGE( WM_PAINT, OnPaint );
            SC_HANDLE_MESSAGE( WM_ERASEBKGND, OnEraseBkGnd );
            SC_HANDLE_MESSAGE( WM_SIZE, OnSize );
            SC_HANDLE_MESSAGE( WM_INITMENU, OnInitMenu );
            SC_HANDLE_MESSAGE( PWM_DISPLAYNEWIMAGE, OnDisplayNewImage );
        }
        SC_END_MESSAGE_HANDLERS();
    }

public:
    static bool RegisterClass( HINSTANCE hInstance, LPCTSTR pszClassName )
    {
        WNDCLASSEX wcex;
        ZeroMemory(&wcex,sizeof(wcex));
        wcex.cbSize = sizeof(wcex);
        if (!GetClassInfoEx( hInstance, pszClassName, &wcex ))
        {
            ZeroMemory(&wcex,sizeof(wcex));
            wcex.cbSize = sizeof(wcex);
            wcex.style = 0;
            wcex.lpfnWndProc = (WNDPROC)WndProc;
            wcex.cbClsExtra = 0;
            wcex.cbWndExtra = 0;
            wcex.hInstance = hInstance;
            wcex.hIcon = 0;
            wcex.hCursor = ::LoadCursor(NULL, IDC_ARROW);
            wcex.hbrBackground = NULL;
            wcex.lpszMenuName = NULL;
            wcex.lpszClassName = pszClassName;
            wcex.hIconSm = 0;
            if (!::RegisterClassEx(&wcex))
            {
                ::MessageBox( NULL, TEXT("Unable to register Main Window"), TEXT("PLUGTEST"), 0 );
                return(false);
            }
            return(true);
        }
        return(true);
    }
    static HWND Create( DWORD dwExStyle,
                        LPCTSTR lpWindowName,
                        DWORD dwStyle,
                        int x,
                        int y,
                        int nWidth,
                        int nHeight,
                        HWND hWndParent,
                        HMENU hMenu,
                        HINSTANCE hInstance )
    {
        if (RegisterClass( hInstance, TEXT("TestAcqdWindow") ))
            return(CreateWindowEx( dwExStyle, TEXT("TestAcqdWindow"), lpWindowName, dwStyle, x, y, nWidth, nHeight, hWndParent, hMenu, hInstance, NULL ));
        return(NULL);
    }

    LRESULT OnDisplayNewImage( WPARAM, LPARAM lParam )
    {
        LPWSTR pszNewImage = reinterpret_cast<LPWSTR>(lParam);
        if (pszNewImage)
        {
            WIA_TRACE((TEXT("pszNewImage: %ws"), pszNewImage ));

            CComPtr<IStream> pStream;
            HRESULT hr = URLOpenBlockingStream( NULL, pszNewImage, &pStream, 0, NULL );
            if (SUCCEEDED(hr))
            {
                HBITMAP hNewBitmap = NULL;
                hr = CGdiPlusHelper().LoadAndScale( hNewBitmap, pStream, 800, 600, false );
                if (SUCCEEDED(hr))
                {
                    DestroyBitmap(false);
                    m_hOriginalBitmap = hNewBitmap;
                    InvalidateRect( m_hWnd, NULL, FALSE );
                    UpdateWindow(m_hWnd);
                }
                else
                {
                    WIA_PRINTHRESULT((hr,TEXT("GdiPlusHelper.LoadAndScale failed")));
                }
            }
            else
            {
                WIA_PRINTHRESULT((hr,TEXT("URLOpenBlockingStream failed")));
            }
            delete[] pszNewImage;
        }
        return 0;
    }

    STDMETHODIMP StateVariableChanged( IUPnPService * pus, LPCWSTR pcwszStateVarName, VARIANT vaValue )
    {
        WIA_TRACE((TEXT("StateVariableChanged( %p, %ws, %ws )"), pus, pcwszStateVarName, CWiaDebugDump::GetPrintableValue(vaValue).String() ));

        if (!lstrcmpW(pcwszStateVarName,L"CurrentImageURL"))
        {
            if (VT_BSTR == vaValue.vt)
            {
                if (vaValue.bstrVal)
                {
                    LPWSTR pszNewImage = new WCHAR[lstrlenW(vaValue.bstrVal)+1];
                    if (pszNewImage)
                    {
                        lstrcpyW( pszNewImage, vaValue.bstrVal );
                        WIA_TRACE((TEXT("pszNewImage: %ws"), pszNewImage ));
                        PostMessage( m_hWnd, PWM_DISPLAYNEWIMAGE, 0, reinterpret_cast<LPARAM>(pszNewImage) );
                    }
                }
            }
        }
        return S_OK;
    }

    STDMETHODIMP ServiceInstanceDied( IUPnPService* pus )
    {
        return S_OK;
    }



    STDMETHODIMP QueryInterface(const IID& iid, void** ppvObject)
    {
        if ((iid==IID_IUnknown) || (iid==IID_IUPnPServiceCallback))
        {
            *ppvObject = static_cast<LPVOID>(this);
        }
        else
        {
            *ppvObject = NULL;
            return(E_NOINTERFACE);
        }
        reinterpret_cast<IUnknown*>(*ppvObject)->AddRef();
        return(S_OK);
    }

    STDMETHODIMP_(ULONG) AddRef()
    {
        return 1;
    }

    STDMETHODIMP_(ULONG) Release()
    {
        return 1;
    }

};


int PASCAL WinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow )
{
    WIA_DEBUG_CREATE( hInstance );
    g_hInstance = hInstance;
    HRESULT hr = CoInitialize(NULL);
    INITCOMMONCONTROLSEX icc;
    icc.dwSize = sizeof(icc);
    icc.dwICC = ICC_LISTVIEW_CLASSES | ICC_WIN95_CLASSES |ICC_BAR_CLASSES | ICC_LINK_CLASS;
    InitCommonControlsEx(&icc);
    if (SUCCEEDED(hr))
    {
        HWND hwndMain = CMiscUnitTestWindow::Create( 0,
                                             TEXT("Random Unit Test Program"),
                                             WS_OVERLAPPEDWINDOW,
                                             CW_USEDEFAULT, CW_USEDEFAULT,
                                             CW_USEDEFAULT, CW_USEDEFAULT,
                                             NULL,
                                             LoadMenu( hInstance, MAKEINTRESOURCE(IDR_TESTACQDMENU) ),
                                             hInstance );
        if (!hwndMain)
        {
            MessageBox(NULL, TEXT("Unable to create plugin test window"), TEXT("TESTACQD"), MB_OK);
            return(FALSE);
        }
        ShowWindow(hwndMain, SW_SHOW);
        UpdateWindow(hwndMain);

        HACCEL hAccel = LoadAccelerators( hInstance, MAKEINTRESOURCE(IDR_TESTACQDACCEL) );
        MSG msg;
        while (GetMessage(&msg, 0, 0, 0))
        {
            if (!TranslateAccelerator( hwndMain, hAccel, &msg ))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
        CoUninitialize();
    }
    WIA_DEBUG_DESTROY();
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\upnp\prjctr\server\main.h ===
//////////////////////////////////////////////////////////////////////////////
//
// File:            main.h
//
// Description:     Declares all the functions within the individual
//                  files.
//
// Copyright (c) 2000 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////////////

#ifndef _MAIN_H_
#define _MAIN_H_

#define DEFAULT_INSTALL_PATH        _T("MSProjector")
#define REG_KEY_PROJECTOR           _T("Software\\Microsoft\\MSProjector")
#define REG_VAL_IMAGE_DIR           _T("ImagesDirectory")
#define REG_VAL_DEVICE_DIR          _T("DeviceDirectory")
#define REG_VAL_ALLOW_KEY_CONTROL   _T("AllowKeyboardControl")
#define REG_VAL_SHOW_IMAGEURL       _T("ShowImageUrl")
#define MSPRJCTR_TASKBAR_ID     100

#define MIN_IMAGE_FREQ_IN_SEC   6
#define MAX_IMAGE_FREQ_IN_SEC   3 * 60

#define MIN_IMAGE_SCALE_FACTOR  25
#define MAX_IMAGE_SCALE_FACTOR  100

// CfgDlg Functions
namespace CfgDlg
{
    HRESULT Init(HINSTANCE hInstance);

    HRESULT Term();

    HWND Create(int nCmdShow);
}

// Tray Functions
namespace Tray
{
    HRESULT Init(HINSTANCE hInstance,
                 HWND      hwndDlg,
                 UINT      uiWindowsUserMsgId);

    HRESULT Term(HWND    hwndDlg);

    HRESULT PopupMenu(HWND    hwndOwner);

}

// Util Functions
namespace Util
{
    HRESULT Init(HINSTANCE hInstance);

    HRESULT Term(void);

    HRESULT GetAppDirs(TCHAR   *pszDeviceDir,
                       DWORD   cchDeviceDir,  
                       TCHAR   *pszImageDir,
                       DWORD   cchImageDir);

    HRESULT GetRegString(const TCHAR   *pszValueName,
                         TCHAR         *pszDir,
                         DWORD         cchDir,
                         BOOL          bSetIfNotExist);

    HRESULT SetRegString(const TCHAR   *pszValueName,
                         TCHAR         *pszDir,
                         DWORD         cchDir);

    HRESULT GetRegDWORD(const TCHAR   *pszValueName,
                        DWORD         *pdwValue,
                        BOOL          bSetIfNotExist);

    HRESULT SetRegDWORD(const TCHAR   *pszValueName,
                        DWORD         dwValue);

    bool BrowseForDirectory(HWND        hWnd, 
                            const TCHAR *pszPrompt, 
                            TCHAR       *pszDirectory,
                            DWORD       cchDirectory);

    HRESULT FormatTime(HINSTANCE hInstance, 
                       UINT nTotalSeconds,
                       TCHAR     *pszTime,
                       DWORD     cchTime);

    HRESULT FormatScale(HINSTANCE hInstance, 
                        DWORD     dwImageScaleFactor,
                        TCHAR     *pszScale,
                        DWORD     cchScale);

    BOOL DoesDirExist(LPCTSTR pszPath);

    BOOL GetString(HINSTANCE  hInstance,
                   INT        iStrResID,
                   TCHAR      *pszString,
                   DWORD      cchString,
                   ...);

    HRESULT GetMyPicturesFolder(TCHAR *pszFolder,
                                DWORD cchFolder);

    HRESULT GetProgramFilesFolder(TCHAR *pszFolder,
                                  DWORD cchFolder);


}

#endif //_MAIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\upnp\prjctr\server\precomp.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  PrjctrUI.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\upnp\prjctr\server\precomp.h ===
#ifndef _PRECOMP_H_
#define _PRECOMP_H_

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

// included for debug library
#include "cplusinc.h"
#include "sticomm.h"

#include "coredbg.h"

#endif //_PRECOMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\upnp\msprjctr\server\sources.inc ===
# ############################################################
#
#Copyright (c) 2000  Microsoft Corporation
#
#Author:
#   orenr
#
#Date:
#   10-Aug-2000
#
#Module Name:
#    sources.inc
#
#Abstract:
#    This file specifies the target component being built and the list of
#    sources files needed to build that component.  Also specifies optional
#    compiler switches and libraries that are unique for the component being
#    built.
#
#  This directory builds
#     msprjctr.dll    - Microsoft UPnP Slideshow Projector DLL
#
# ############################################################

!include $(PROJECT_ROOT)\ui\uienv.inc

TARGETNAME=wiaprjctr
TARGETPATH=obj
TARGETTYPE=PROGRAM

#
# Compiler environment
#

USE_STATIC_ATL=1

C_DEFINES=$(C_DEFINES)

INCLUDES= \
        $(INCLUDES); \
        $(PROJECT_ROOT)\wia\common\stirt;\
	$(PROJECT_ROOT)\wia\core\upnp\msprjctr\inc\$(O); \
	$(PROJECT_ROOT)\wia\inc\$(O);

TARGETLIBS= \
        $(SDK_LIB_PATH)\kernel32.lib \
        $(SDK_LIB_PATH)\advapi32.lib \
        $(SDK_LIB_PATH)\user32.lib \
        $(SDK_LIB_PATH)\gdi32.lib \
        $(SDK_LIB_PATH)\ole32.lib \
        $(SDK_LIB_PATH)\oleaut32.lib \
        $(SDK_LIB_PATH)\shell32.lib \
        $(SDK_LIB_PATH)\comctl32.lib \
        $(SDK_LIB_PATH)\uuid.lib \
        $(SDK_LIB_PATH)\shlwapi.lib \
        $(PROJECT_ROOT)\wia\lib\$(O)\stirt.lib       

SOURCES= \
        main.cpp        \
        cfgdlg.cpp      \
        tray.cpp        \
        util.cpp        \
        ServUI.rc

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

SXS_ASSEMBLY_NAME=Microsoft.Windows.PrintingAndImaging.wiaprjctr
SXS_ASSEMBLY_VERSION=1.0 
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=1
SXS_MANIFEST=wiaprjctr.Manifest
SXS_MANIFEST_IN_RESOURCES=1
SXS_NO_BINPLACE=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\upnp\prjctr\server\main.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// File:            main.cpp
//
// Description:     
//
// Copyright (c) 2000 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////////////

// App Includes
#include "precomp.h"
#include "main.h"

#include <commctrl.h>

///////////////////////////
// GVAR_LOCAL
//
// Global Variable
//
static struct GVAR_LOCAL
{
    HINSTANCE hInstance;
} GVAR_LOCAL = 
{
    NULL
};

////////////////////////// Function Prototypes ////////////////////////////////

static bool InitApp(HINSTANCE hInstance);
static bool TermApp();

//////////////////////////////
// WinMain
//
int APIENTRY WinMain(HINSTANCE hInstance,
                     HINSTANCE hPrevInstance,
                     LPSTR     lpCmdLine,
                     int       nCmdShow)
{
    HWND    hwndCfgDlg      = NULL;
    bool    bSuccess        = false;
    bool    bDone           = false;
    int     iReturnValue    = 0;
    MSG     msg;

    // initialize our application
    bSuccess = InitApp(hInstance);

    if (bSuccess)
    {
        // create our config dialog, which is our main dialog
        hwndCfgDlg = CfgDlg::Create(nCmdShow);

        if (hwndCfgDlg == NULL)
        {
            iReturnValue = -1;
            bSuccess = false;
        }
    }

    if (bSuccess)
    {
        while (::GetMessage(&msg, NULL, 0, 0))
        {
            ::TranslateMessage(&msg);
            ::DispatchMessage(&msg);
        }
    }

    TermApp();

    return iReturnValue;
}


//////////////////////////////
// InitApp
//
static bool InitApp(HINSTANCE hInstance)
{
    HRESULT                 hr             = S_OK;
    bool                    bReturn        = true;
    INITCOMMONCONTROLSEX    CommonControls = {0};
    BOOL                    bSuccess       = FALSE;

    //
    // initialize the common control library
    //
    CommonControls.dwSize = sizeof(CommonControls);
    CommonControls.dwICC  = ICC_BAR_CLASSES | ICC_WIN95_CLASSES;

    bSuccess = InitCommonControlsEx(&CommonControls);

    if (bSuccess)
    {
        DBG_TRC(("Successfully initialized Common Controls"));
    }
    else
    {
        DBG_TRC(("Failed to Init Common Controls, LastError = %lu",
                GetLastError()));
    }

    //
    // Initialize COM
    //
    if (SUCCEEDED(hr))
    {
        // we are apartment threaded because the UPnP device host API
        // claims it has some problems in a free threaded model.
        //
        hr = CoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
    }

    //
    // Initialize our Util Library
    //
    if (SUCCEEDED(hr))
    {
        hr = Util::Init(hInstance);
    }

    //
    // Initialize our Config Dialog module
    //
    if (SUCCEEDED(hr))
    {
        hr = CfgDlg::Init(hInstance);
    }

    return bReturn;
}

//////////////////////////////
// TermApp
//
static bool TermApp()
{
    // shutdown the Config Dialog Module
    CfgDlg::Term();

    // shutdown the Util Module.
    Util::Term();

    return true;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\upnp\msprjctr\server\resource.h ===
//////////////////////////////////////////////////////////////////////////////
//
// File:            Resource.h
//
// Description:     
//
// Copyright (c) 2000 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////////////

#define IDC_STATIC                              -1
#define IDD_CONFIG_DIALOG                       101
#define IDI_MONITOR                             102
#define IDC_DIVIDER                             103
#define IDC_FREQ_LESS                           104
#define IDC_FREQ_MORE                           105
#define IDC_FREQUENCY_STATIC                    106
#define IDC_FREQUENCY                           107
#define IDC_IMAGEDIR                            108
#define IDC_BROWSE                              109
#define IDC_DISPLAYFILENAME                     110
#define IDC_ALLOW_KEYBOARDCONTROL               111
#define IDM_POPUP_OPEN                          112
#define IDM_POPUP_EXIT                          113
#define IDC_MYPICTURES_ICON                     114
#define IDC_DIALOG_DESCRIPTION                  115
#define IDC_MINUTES_AND_SECONDS                 116
#define IDM_TRAY_POPUP_MENU                     117
#define IDC_SIZE_LESS                           118
#define IDC_SIZE_MORE                           119
#define IDC_MAX_SIZE                            120
#define IDC_IMAGE_SIZE_DESC                     121
#define IDC_ALLOWSTRETCHING                     122
#define IDC_MAX_SIZE_STATIC                     123

// string resources
#define IDS_MINUTES_AND_SECONDS                 1000
#define IDS_MINUTE_AND_SECONDS                  1001
#define IDS_MINUTES_AND_SECOND                  1002
#define IDS_MINUTE_AND_SECOND                   1003
#define IDS_SECONDS                             1004
#define IDS_SECOND                              1005
#define IDS_MINUTES                             1006
#define IDS_MINUTE                              1007
#define IDS_PERCENT                             1008
#define IDS_ERR_INVALID_DEVICE_DIR              1009  
#define IDS_ERR_INVALID_IMAGE_DIR               1010  
#define IDS_ERR_SLIDESHOW_SERVER_NOT_FOUND      1011
#define IDS_ERR_SERVER_ERROR                    1012
#define IDS_ERR_CAPTION                         1013
#define IDS_ERR_FAILED_TO_START_SLIDESHOW       1014
#define IDC_APPLY                               1015
#define IDS_PLEASE_SELECT_IMAGE_DIR             1016
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\upnp\msprjctr\server\tray.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// File:            tray.cpp
//
// Description:     
//
// Copyright (c) 2000 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////////////

// App Includes
#include "precomp.h"
#include "main.h"
#include "resource.h"

///////////////////////////
// GVAR_LOCAL
//
// Global Variable
//
static struct GVAR_LOCAL
{
    HINSTANCE hInstance;
    HMENU     hMenu;
} GVAR_LOCAL = 
{
    NULL,
    NULL
};

////////////////////////// Function Prototypes ////////////////////////////////

static HRESULT AddTaskBarIcon(HWND    hwnd, 
                              UINT    uiIconID, 
                              UINT    uiCallBackMsg,
                              ULONG   ulStrID);

static HRESULT ModifyTaskBarIcon(HWND     hwnd, 
                                 UINT     uiNewIconID,
                                 ULONG    ulStrID);

static HRESULT DeleteTaskBarIcon(HWND     hwnd);

//////////////////////////////////////////////////////////////////////
// Tray::Init
//
HRESULT Tray::Init(HINSTANCE hInstance,
                   HWND      hwndDlg,
                   UINT      uiWindowsUserMsgId)
{ 
    HRESULT hr = S_OK;

    GVAR_LOCAL.hInstance = hInstance;

    // delete the taskbar notification area icon.
    DeleteTaskBarIcon(hwndDlg);

    // Place the icon in the taskbar notification area.
    AddTaskBarIcon(hwndDlg,
                   IDI_MONITOR,
                   uiWindowsUserMsgId,
                   0);

    // load our popup menu
    GVAR_LOCAL.hMenu = ::LoadMenu(GVAR_LOCAL.hInstance,
                                  MAKEINTRESOURCE(IDM_TRAY_POPUP_MENU));
    return hr;
}

//////////////////////////////////////////////////////////////////////
// Tray::Term
//
// Desc:       
//
HRESULT Tray::Term(HWND    hwndDlg)
{ 
    HRESULT hr = S_OK;

    // unload the popup menu

    ::DestroyMenu(GVAR_LOCAL.hMenu);
    GVAR_LOCAL.hMenu = NULL;

    // delete the tray icon.
    DeleteTaskBarIcon(hwndDlg);

    return hr;
}

//////////////////////////////////////////////////////////////////
// Tray::PopupMenu
//
//
HRESULT Tray::PopupMenu(HWND    hwndOwner)
{
    HRESULT hr              = S_OK;
    POINT   pt              = {0};   // stores mouse click
    HMENU   hmenuTrackPopup = NULL;  // pop-up menu 

    // needed to correct a bug with TrackPopupMenu in Win32
    SetForegroundWindow(hwndOwner);

    // TrackPopupMenu cannot display the top-level menu, so get 
    // the handle of the first pop-up menu. 
 
    hmenuTrackPopup = GetSubMenu(GVAR_LOCAL.hMenu, 0); 
    GetCursorPos(&pt);

    // Display the floating pop-up menu. Track the left mouse 
    // button on the assumption that this function is called 
    // during WM_CONTEXTMENU processing. 
 
    TrackPopupMenu(hmenuTrackPopup, 
                   TPM_RIGHTALIGN | TPM_LEFTBUTTON, 
                   pt.x, 
                   pt.y, 
                   0, 
                   hwndOwner, 
                   NULL); 

    // needed to correct a bug with TrackPopupMenu in Win32
    PostMessage(hwndOwner, WM_USER, 0, 0);

    return S_OK;
} 

//////////////////////////////////////////////////////////////////////
// AddTaskBarIcon
//
// Desc:       Adds an icon to the task bar.
//
// Params:     - hwnd, handle of main window.
//             - uiID,  id of icon.
//             - uiCallBackMsg, WM_USER message to send to hwnd when
//               event occurs on icon.
//             - ulStrID, string table text of tool tip to display for 
//               this icon.
//
static HRESULT AddTaskBarIcon(HWND    hwnd, 
                              UINT    uiIconID, 
                              UINT    uiCallBackMsg,
                              ULONG   ulStrID) 
{ 
    HRESULT             hr          = S_OK;
    BOOL                bRes; 
    NOTIFYICONDATA      tnid; 
    HICON               hIconHandle = NULL;
    TCHAR               szToolTip[255 + 1] = {0};

    if (ulStrID != 0)
    {
        ::LoadString(GVAR_LOCAL.hInstance,
                     ulStrID,
                     szToolTip,
                     sizeof(szToolTip) / sizeof(TCHAR));
    }

    if (SUCCEEDED(hr))
    {
        // load the specified icon.
        hIconHandle = (HICON) ::LoadImage(GVAR_LOCAL.hInstance,
                                          MAKEINTRESOURCE(uiIconID),
                                          IMAGE_ICON,
                                          16,
                                          16,
                                          LR_DEFAULTCOLOR);

        if (hIconHandle == NULL)
        {
            hr = E_FAIL;

            DBG_ERR(("AddTaskBarIcon, failed ot load icon, hr = 0x%08lx",
                     hr));
        }
    }

    if (SUCCEEDED(hr))
    {
        // add the icon to the notification tray
        tnid.cbSize           = sizeof(NOTIFYICONDATA); 
        tnid.hWnd             = hwnd; 
        tnid.uID              = MSPRJCTR_TASKBAR_ID; 
        tnid.uFlags           = NIF_MESSAGE | NIF_ICON | NIF_TIP; 
        tnid.uCallbackMessage = uiCallBackMsg; 
        tnid.hIcon            = hIconHandle; 

        if (szToolTip[0] != '\0') 
        {
            _tcsncpy(tnid.szTip, szToolTip, sizeof(tnid.szTip) / sizeof(TCHAR)); 
        }
        else 
        {
            tnid.szTip[0] = '\0'; 
        }

        bRes = Shell_NotifyIcon(NIM_ADD, &tnid); 

        if (!bRes)
        {
            hr = E_FAIL;
            DBG_ERR(("Failed to set TaskBar Icon, hr = 0x%08lx",
                    hr));
        }
    }

    if (hIconHandle) 
    {
        // destroy the icon
        DestroyIcon(hIconHandle); 
    }

    return hr; 
}

//////////////////////////////////////////////////////////////////////
// ModifyTaskBarIcon
//
// Desc:       Modifies a taskbar icon/tooltip (or both) to a new
//             one.  Note, if ulStrID is 0, then the tool tip is NOT
//             modified.  If uiNewIconID is 0, then the icon is not 
//             modified.  If both are 0, then actually nothing changes.
//             
//
// Params:     - hwnd, handle of main window.
//             - uiNewIconID, resource ID of icon to display.
//             - ulStrID, string resource ID of string to use for tooltip.
//               Note your string will be prefixed with "InterLYNX - "
//
static HRESULT ModifyTaskBarIcon(HWND     hwnd, 
                                 UINT     uiNewIconID,
                                 ULONG    ulStrID) 
{ 
    HRESULT             hr                      = S_OK;
    BOOL                bRes                    = TRUE; 
    NOTIFYICONDATA      tnid                    = {0}; 
    HICON               hIconHandle             = NULL;
    TCHAR               szToolTip[255 + 1]      = {0};
    BOOL                bContinue               = TRUE;

    if ((uiNewIconID == 0) && (ulStrID == 0))
    {
        bContinue = FALSE;
    }
    else
    {
        bContinue = TRUE;
    }

    if (bContinue)
    {
        // if we are instructed to modify the tool tip.
        if (ulStrID != 0)
        {
            ::LoadString(GVAR_LOCAL.hInstance,
                         ulStrID,
                         szToolTip,
                         sizeof(szToolTip) / sizeof(TCHAR));
        }

        // if a new icon was specified.
        if (uiNewIconID != 0)
        {
            // load the specified icon.
            hIconHandle = (HICON) ::LoadImage(GVAR_LOCAL.hInstance,
                                              MAKEINTRESOURCE(uiNewIconID),
                                              IMAGE_ICON,
                                              16,
                                              16,
                                              LR_DEFAULTCOLOR);

        }

        // add the icon to the notification tray
        tnid.cbSize = sizeof(NOTIFYICONDATA); 
        tnid.hWnd   = hwnd; 
        tnid.uID    = MSPRJCTR_TASKBAR_ID; 
        tnid.uFlags = 0; 
        tnid.hIcon  = 0; 

        if (ulStrID != 0) 
        {
            _tcsncpy(tnid.szTip, szToolTip, sizeof(tnid.szTip) / sizeof(TCHAR)); 
            tnid.uFlags = tnid.uFlags | NIF_TIP; 
        }

        if (uiNewIconID != 0)
        {
            tnid.hIcon = hIconHandle;
            tnid.uFlags = tnid.uFlags | NIF_ICON;
        }

        bRes = Shell_NotifyIcon(NIM_MODIFY, &tnid); 

        if (!bRes)
        {
            hr = E_FAIL;
            DBG_ERR(("Failed to modify taskbar icon, hr = 0x%08lx",
                    hr));
        }
    }

    if (hIconHandle) 
    {
        // destroy the icon
        DestroyIcon(hIconHandle); 
    }                  

    return hr; 
}


//////////////////////////////////////////////////////////////////////
// DeleteTaskBarIcon
//
// Desc:       Deletes a taskbar icon 
//             
//
// Params:     - hwnd, handle of main window.
//             - uiID,  id of icon.
//
static HRESULT DeleteTaskBarIcon(HWND     hwnd)
{ 
    HRESULT             hr          = S_OK;
    BOOL                bRes        = TRUE; 
    NOTIFYICONDATA      tnid        = {0}; 
    HICON               hIconHandle = NULL;

    if (SUCCEEDED(hr))
    {
        tnid.cbSize = sizeof(NOTIFYICONDATA); 
        tnid.hWnd   = hwnd; 
        tnid.uID    = MSPRJCTR_TASKBAR_ID; 
         
        bRes = Shell_NotifyIcon(NIM_DELETE, &tnid); 

        // this is not such a big deal.
        if (!bRes)
        {
            hr = E_FAIL;
        }
    }
    return hr; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\upnp\msprjctr\server\util.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// File:            util.cpp
//
// Description:     
//
// Copyright (c) 2000 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////////////

// App Includes
#include "precomp.h"
#include "main.h"
#include "resource.h"

#include <shlobj.h>
#include <shfolder.h>

////////////////////////// Function Prototypes ////////////////////////////////

int CALLBACK ChangeDirectoryCallback(HWND    hWnd, 
                                     UINT    uMsg, 
                                     LPARAM  lParam, 
                                     LPARAM  lpData);

///////////////////////////
// GVAR_LOCAL
//
// Global Variable
//
static struct GVAR_LOCAL
{
    HKEY    hRootKey;
} GVAR_LOCAL = 
{
    NULL
};

///////////////////////////////
// Util::Init
//
HRESULT Util::Init(HINSTANCE hInstance)
{
    HRESULT hr = S_OK;

    if (SUCCEEDED(hr))
    {
        LRESULT lr            = NOERROR;
        DWORD   dwDisposition = 0;

        lr = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                            REG_KEY_PROJECTOR,
                            NULL,
                            NULL,
                            0,
                            KEY_ALL_ACCESS,
                            NULL,
                            &GVAR_LOCAL.hRootKey,
                            &dwDisposition);

        if (lr != NOERROR)
        {
            DBG_ERR(("InitApp, failed to open registry key"));

            hr = E_FAIL;
        }
    }

    return hr;
}

///////////////////////////////
// Util::Term
//
HRESULT Util::Term(void)
{
    RegCloseKey(GVAR_LOCAL.hRootKey);
    GVAR_LOCAL.hRootKey = NULL;

    return S_OK;
}

///////////////////////////////
// GetMyPicturesFolder
//
HRESULT Util::GetMyPicturesFolder(TCHAR *pszFolder,
                                  DWORD cchFolder)
{
    HRESULT hr = S_OK;

    // set the directory of the images.
    hr = SHGetFolderPath(NULL,
                         CSIDL_MYPICTURES,
                         NULL,
                         0,
                         pszFolder);

    return hr;
}

///////////////////////////////
// GetProgramFilesFolder
//

HRESULT Util::GetProgramFilesFolder(TCHAR *pszFolder,
                                    DWORD cchFolder)
{
    HRESULT hr = S_OK;

    // set the directory of the images.
    hr = SHGetFolderPath(NULL,
                         CSIDL_PROGRAM_FILES,
                         NULL,
                         0,
                         pszFolder);

    return hr;
}

///////////////////////////////
// Util::GetAppDirs
//
HRESULT Util::GetAppDirs(TCHAR   *pszDeviceDir,
                         DWORD   cchDeviceDir,  
                         TCHAR   *pszImageDir,
                         DWORD   cchImageDir)
{
    HRESULT hr = S_OK;

    ASSERT(pszDeviceDir != NULL);
    ASSERT(pszImageDir  != NULL);
    ASSERT(cchDeviceDir > 0);
    ASSERT(cchImageDir  > 0);

    if ((pszDeviceDir == NULL) ||
        (pszImageDir  == NULL) ||
        (cchDeviceDir == 0)    ||
        (cchImageDir  == 0))
    {
        return E_INVALIDARG;
    }

    // preload the image dir buffer with the "My Pictures" path
    // so that it is set as the default directory if we don't
    // have an overriding one in the registry.

    if (SUCCEEDED(hr))
    {
        hr = GetMyPicturesFolder(pszImageDir, 
                                 cchImageDir);
    }

    // preload the device dir buffer with the "Program Files\MSProjector"
    // install path so that it is set as the default directory if we don't
    // have an overriding one in the registry.

    if (SUCCEEDED(hr))
    {
        hr = GetProgramFilesFolder(pszDeviceDir,
                                   cchDeviceDir);
    }

    if (SUCCEEDED(hr))
    {
        if (pszDeviceDir[_tcslen(pszDeviceDir) - 1] != '\\')
        {
            _tcscat(pszDeviceDir, _T("\\"));
        }

        _tcscat(pszDeviceDir, DEFAULT_INSTALL_PATH);
    }

    if (SUCCEEDED(hr))
    {
        // get the image dir.
        hr = GetRegString(REG_VAL_IMAGE_DIR,
                    pszImageDir,
                    cchImageDir,
                    TRUE);

        if (FAILED(hr))
        {
            DBG_ERR(("GetAppDirs, failed to get/set image directory.  "
                    "This should never happen"));

            ASSERT(FALSE);
        }

        // get the device dir
        hr = GetRegString(REG_VAL_DEVICE_DIR,
                    pszDeviceDir,
                    cchDeviceDir,
                    TRUE);

        if (FAILED(hr))
        {
            DBG_ERR(("GetAppDirs, failed to get/set image directory.  "
                     "This should never happen"));

            ASSERT(FALSE);
        }
    }

    return hr;
}

///////////////////////////////
// Util::GetRegString
//
HRESULT Util::GetRegString(const TCHAR   *pszValueName,
                           TCHAR         *pszDir,
                           DWORD         cchDir,
                           BOOL          bSetIfNotExist)
{
    HRESULT hr = S_OK;

    ASSERT(pszValueName != NULL);
    ASSERT(pszDir       != NULL);
    ASSERT(cchDir > 0);

    if ((pszValueName == NULL) ||
        (pszDir       == NULL) ||
        (cchDir       <= 0))
    {
        return E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        LRESULT lr = NOERROR;
        DWORD   dwType = REG_SZ;

        lr = RegQueryValueEx(GVAR_LOCAL.hRootKey,
                             pszValueName,
                             NULL,
                             &dwType,
                             (BYTE*) pszDir,
                             &cchDir);

        if (lr != NOERROR)
        {
            if (bSetIfNotExist)
            {
                // we need the number of bytes we are writing to the registry.
                DWORD dwLength = _tcslen(pszDir) * sizeof(TCHAR) + 1;

                lr = RegSetValueEx(GVAR_LOCAL.hRootKey,
                                   pszValueName,
                                   NULL,
                                   REG_SZ,
                                   (BYTE*) pszDir,
                                   dwLength);
            }
            else
            {
                hr = E_FAIL;
                DBG_ERR(("GetRegString, failed to get '%ls' from registry, hr = 0x%08lx",
                         pszValueName,
                         hr));
            }
        }
    }

    return hr;
}

///////////////////////////////
// Util::SetRegString
//
HRESULT Util::SetRegString(const TCHAR   *pszValueName,
                           TCHAR         *pszDir,
                           DWORD         cchDir)
{
    HRESULT hr = S_OK;

    ASSERT(pszValueName != NULL);
    ASSERT(pszDir       != NULL);
    ASSERT(cchDir       > 0);

    if ((pszValueName == NULL) ||
        (pszDir       == NULL) ||
        (cchDir       <= 0))
    {
        return E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        LRESULT     lr       = NOERROR;
        DWORD       dwLength = _tcslen(pszDir) * sizeof(TCHAR) + 1;

        // we need the number of bytes we are writing to the registry.

        lr = RegSetValueEx(GVAR_LOCAL.hRootKey,
                           pszValueName,
                           NULL,
                           REG_SZ,
                           (BYTE*) pszDir,
                           dwLength);

        if (lr != NOERROR)
        {
            hr = E_FAIL;
            DBG_ERR(("SetRegString, failed to set '%ls' to registry, hr = 0x%08lx",
                    pszValueName,
                    hr));
        }
    }

    return hr;
}

///////////////////////////////
// Util::GetRegDWORD
//
HRESULT Util::GetRegDWORD(const TCHAR   *pszValueName,
                          DWORD         *pdwValue,
                          BOOL          bSetIfNotExist)
{
    HRESULT hr = S_OK;

    ASSERT(pszValueName != NULL);
    ASSERT(pdwValue     != NULL);

    if ((pszValueName == NULL) ||
        (pdwValue     == NULL))
    {
        return E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        LRESULT lr = NOERROR;
        DWORD   dwType = REG_DWORD;
        DWORD   dwSize = sizeof(DWORD);

        lr = RegQueryValueEx(GVAR_LOCAL.hRootKey,
                             pszValueName,
                             NULL,
                             &dwType,
                             (BYTE*) pdwValue,
                             &dwSize);

        if (lr != NOERROR)
        {
            if (bSetIfNotExist)
            {
                // we need the number of bytes we are writing to the registry.

                lr = RegSetValueEx(GVAR_LOCAL.hRootKey,
                                   pszValueName,
                                   NULL,
                                   REG_SZ,
                                   (BYTE*) pdwValue,
                                   dwSize);
            }
            else
            {
                hr = E_FAIL;
                DBG_ERR(("GetRegDWORD, failed to get '%ls' from registry, hr = 0x%08lx",
                        pszValueName,
                        hr));
            }
        }
    }

    return hr;
}

///////////////////////////////
// Util::SetRegDWORD
//
HRESULT Util::SetRegDWORD(const TCHAR   *pszValueName,
                          DWORD         dwValue)
{
    HRESULT hr = S_OK;

    ASSERT(pszValueName != NULL);

    if (pszValueName == NULL)
    {
        return E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        LRESULT     lr       = NOERROR;

        // we need the number of bytes we are writing to the registry.

        lr = RegSetValueEx(GVAR_LOCAL.hRootKey,
                           pszValueName,
                           NULL,
                           REG_DWORD,
                           (BYTE*) &dwValue,
                           sizeof(DWORD));

        if (lr != NOERROR)
        {
            hr = E_FAIL;
            DBG_ERR(("SetRegDWORD, failed to set '%ls' to registry, hr = 0x%08lx",
                     pszValueName,
                     hr));
        }
    }

    return hr;
}


///////////////////////////////
// Util::BrowseForDirectory
//
bool Util::BrowseForDirectory(HWND        hWnd, 
                              const TCHAR *pszPrompt, 
                              TCHAR       *pszDirectory,
                              DWORD       cchDirectory)
{
    bool bResult = false;

    LPMALLOC     pMalloc            = NULL;
    LPITEMIDLIST pidlSharedPictures = NULL;

    HRESULT hr = SHGetMalloc(&pMalloc);

    if (SUCCEEDED(hr))
    {
        hr = SHGetFolderLocation(NULL, 
                                 CSIDL_COMMON_PICTURES, 
                                 NULL, 
                                 0, 
                                 &pidlSharedPictures);
    }

    if (SUCCEEDED(hr))
    {
        TCHAR szDisplayName[_MAX_PATH + 1] = {0};
        TCHAR szDirectory[_MAX_PATH + 1]   = {0};

        BROWSEINFO BrowseInfo = {0};

        BrowseInfo.hwndOwner       = hWnd;
        BrowseInfo.pidlRoot        = pidlSharedPictures;
        BrowseInfo.pszDisplayName  = szDisplayName;
        BrowseInfo.lpszTitle       = pszPrompt;
        BrowseInfo.ulFlags         = BIF_RETURNONLYFSDIRS;
        BrowseInfo.lpfn            = ChangeDirectoryCallback;
        BrowseInfo.lParam          = (LPARAM)szDirectory;
        BrowseInfo.iImage          = 0;

        LPITEMIDLIST pidl = SHBrowseForFolder(&BrowseInfo);

        if (pidl != NULL)
        {
            TCHAR szResult[MAX_PATH + 1] = {0};

            if (SHGetPathFromIDList(pidl, szResult))
            {
                _tcsncpy(pszDirectory, szResult, cchDirectory);

                bResult = true;
            }

            pMalloc->Free(pidl);
            pidl = NULL;
        }
    }

    if (pidlSharedPictures)
    {
        pMalloc->Free(pidlSharedPictures);
        pidlSharedPictures = NULL;
    }

    if (pMalloc)
    {
        pMalloc->Release();
        pMalloc = NULL;
    }

    return bResult;
}

///////////////////////////////
// ChangeDirectoryCallback
//
int CALLBACK ChangeDirectoryCallback(HWND    hWnd, 
                                     UINT    uMsg, 
                                     LPARAM  lParam, 
                                     LPARAM  lpData )
{
    if (uMsg == BFFM_INITIALIZED)
    {
        SendMessage(hWnd, BFFM_SETSELECTION, 1, (LPARAM)lpData );
    }

    return 0;
}


///////////////////////////////
// Util::FormatTime
//
HRESULT Util::FormatTime(HINSTANCE hInstance, 
                         UINT nTotalSeconds,
                         TCHAR     *pszTime,
                         DWORD     cchTime)
{
    ASSERT(pszTime != NULL);

    HRESULT hr                = S_OK;
    int     iResult           = 0;
    TCHAR   szString[255 + 1] = {0};
    UINT    nMinutes          = nTotalSeconds / 60;
    UINT    nSeconds          = nTotalSeconds % 60;
    UINT    uiStrResID        = 0;

    if (pszTime == NULL)
    {
        return E_INVALIDARG;
    }

    if (nMinutes == 0)
    {
        if (nSeconds == 1)
        {
            uiStrResID = IDS_SECOND;
        }
        else
        {
            uiStrResID = IDS_SECONDS;
        }
    }
    else if (nSeconds == 0)
    {
        if (nMinutes == 1)
        {
            uiStrResID = IDS_MINUTE;
        }
        else
        {
            uiStrResID = IDS_MINUTES;
        }
    }
    else if ((nMinutes == 1) && (nSeconds == 1))
    {
        uiStrResID = IDS_MINUTE_AND_SECOND;
    }
    else if (nMinutes == 1)
    {
        uiStrResID = IDS_MINUTE_AND_SECONDS;
    }
    else if (nSeconds == 1)
    {
        uiStrResID = IDS_MINUTES_AND_SECOND;
    }
    else 
    {
        uiStrResID = IDS_MINUTES_AND_SECONDS;
    }

    if (uiStrResID != 0)
    {
        iResult = ::LoadString(hInstance,
                               uiStrResID,
                               szString,
                               sizeof(szString) / sizeof(TCHAR));
    }

    if (iResult != 0)
    {
        if (nMinutes == 0)
        {
            _sntprintf(pszTime, cchTime, szString, nSeconds);
        }
        else if (nSeconds == 0)
        {
            _sntprintf(pszTime, cchTime, szString, nMinutes);
        }
        else
        {
            _sntprintf(pszTime, cchTime, szString, nMinutes, nSeconds);
        }
    }

    return hr;
}


///////////////////////////////
// Util::FormatScale
//
HRESULT Util::FormatScale(HINSTANCE hInstance, 
                          DWORD     dwImageScaleFactor,
                          TCHAR     *pszScale,
                          DWORD     cchScale)
{
    ASSERT(pszScale != NULL);

    HRESULT hr                = S_OK;
    int     iResult           = 0;
    TCHAR   szString[255 + 1] = {0};
    UINT    uiStrResID        = IDS_PERCENT;

    if (pszScale == NULL)
    {
        return E_INVALIDARG;
    }

    if (uiStrResID != 0)
    {
        iResult = ::LoadString(hInstance,
                               uiStrResID,
                               szString,
                               sizeof(szString) / sizeof(TCHAR));
    }

    if (iResult != 0)
    {
        _sntprintf(pszScale, cchScale, szString, dwImageScaleFactor);
    }

    return hr;
}

///////////////////////////////
// EndsWithChar
//
static BOOL EndsWithChar( LPCTSTR psz, TCHAR c )
{
    TCHAR* pszLast = _tcsrchr( (TCHAR*)psz, c );    // find last occurence of char in psz

    return(( NULL != pszLast ) && ( *_tcsinc( pszLast ) == _T('\0') ) );
}

///////////////////////////////
// StripTrailingChar
//
static void StripTrailingChar(TCHAR* input, TCHAR c)
{
    while (EndsWithChar(input, c))
    {
        TCHAR* p = input + _tcsclen(input) - 1;
        *p = _T('\0');
    }

    return;
}

///////////////////////////////
// GetString
//
BOOL Util::GetString(HINSTANCE  hInstance,
                     INT        iStrResID,
                     TCHAR      *pszString,
                     DWORD      cchString,
                     ...) 
{
    TCHAR   szFmtString[255 + 1] = {0};
    INT     iResult           = 0;
    va_list vaList;
    BOOL    bSuccess          = FALSE;

    iResult = ::LoadString(hInstance,
                           iStrResID,
                           szFmtString,
                           sizeof(szFmtString) / sizeof(TCHAR));

    if (iResult != 0)
    {
        va_start(vaList, cchString);
        _vsntprintf(pszString, cchString - 1, szFmtString, vaList);
        va_end(vaList);

        bSuccess = TRUE;
    }
    else
    {
        bSuccess = FALSE;
    }

    return bSuccess;
}

///////////////////////////////
// DoesDirExist
//
BOOL Util::DoesDirExist( LPCTSTR pszPath ) 
{
    TCHAR szTemp[MAX_PATH] = {0};

    _tcscpy( szTemp, pszPath );
    StripTrailingChar( szTemp, _T('\\') );
    DWORD dw = GetFileAttributes( szTemp );

    return((dw != 0xFFFFFFFF) && (dw & FILE_ATTRIBUTE_DIRECTORY) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\upnp\prjctr\server\cfgdlg.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// File:            cfgDlg.cpp
//
// Description:     
//
// Copyright (c) 2000 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////////////

// App Includes
#include "precomp.h"
#include "resource.h"
#include "main.h"
#include "SlideshowDevice.h"
#include "SlideshowDevice_i.c"

#include <commctrl.h>
#include <shlobj.h>

///////////////////////////////
// ErrorState_Enum
//
typedef enum
{
    ErrorState_NONE                         = 0,
    ErrorState_IMAGE_DIR_DOESNT_EXIST       = 1,
    ErrorState_DEVICE_DIR_DOESNT_EXIST      = 2,
    ErrorState_SLIDESHOW_SERVER_NOT_FOUND   = 3,
    ErrorState_FAILED_TO_START_SLIDESHOW    = 4
} ErrorState_Enum;

///////////////////////////////
// GVAR_pSlideshowProjector
//
CComPtr<ISlideshowProjector> GVAR_pSlideshowProjector;

///////////////////////////
// GVAR_LOCAL
//
// Global Variable
//
static struct GVAR_LOCAL
{
    HINSTANCE           hInstance;
    HWND                hwndMain;
    ErrorState_Enum     ErrorState;
} GVAR_LOCAL = 
{
    NULL,
    NULL, 
    ErrorState_NONE
};

// Custom user message
#define WM_USER_TASKBAR     WM_USER + 100


////////////////////////// Function Prototypes ////////////////////////////////

INT_PTR CALLBACK DlgProc(HWND   hwndDlg,
                         UINT   uiMsg,
                         WPARAM wParam,
                         LPARAM lParam);

static int InitDlg(HWND hwndDlg);

static int ProcessWMCommand(HWND   hwndDlg,
                            UINT   uiMsg,
                            WPARAM wParam,
                            LPARAM lParam);

static int ProcessTaskbarMsg(HWND    hwnd,
                             UINT    uiMessage,
                             WPARAM  wParam, 
                             LPARAM  lParam);

static int ProcessScroll(HWND    hwndDlg,
                         HWND    hwndScroll);

static HRESULT LoadCurrentSettings();
static HRESULT SaveCurrentSettings();
static HRESULT ShowConfigWindow();
static BOOL IsChecked(INT iResID);

static void ProcessError(ErrorState_Enum     ErrorState);
static HRESULT SetImageFreqTrackbar(DWORD   dwImageFreq);
static HRESULT SetImageScaleTrackbar(DWORD   dwImageScaleFactor);
static void EnableApplyButton(BOOL bEnable);

//////////////////////////////
// CfgDlg::Init
//
HRESULT CfgDlg::Init(HINSTANCE hInstance)
{
    HRESULT hr = S_OK;
    TCHAR   szImageDir[_MAX_PATH + 1]   = {0};
    TCHAR   szDeviceDir[_MAX_PATH + 1]  = {0};

    GVAR_LOCAL.hInstance = hInstance;

    if (SUCCEEDED(hr))
    {
        hr = CoCreateInstance(CLSID_SlideshowProjector, 
                              NULL,
                              CLSCTX_INPROC_SERVER,
                              IID_ISlideshowProjector,
                              (void**) &GVAR_pSlideshowProjector);

        if (FAILED(hr))
        {
            DBG_ERR(("Failed to CoCreate CLSID_SlideshowProjector.  Is the "
                     "server DLL registered?, hr = 0x%08lx",
                     hr));

            GVAR_LOCAL.ErrorState = ErrorState_SLIDESHOW_SERVER_NOT_FOUND;
        }
    }

    ASSERT(GVAR_pSlideshowProjector != NULL);

    if (SUCCEEDED(hr))
    {
        hr = Util::GetAppDirs(szDeviceDir, 
                              sizeof(szDeviceDir) / sizeof(TCHAR),
                              szImageDir,
                              sizeof(szImageDir) / sizeof(TCHAR));
    }

    if (SUCCEEDED(hr))
    {
        BOOL bDirExists = FALSE;

        bDirExists = Util::DoesDirExist(szDeviceDir);

        if (!bDirExists)
        {
            GVAR_LOCAL.ErrorState = ErrorState_DEVICE_DIR_DOESNT_EXIST;
            hr = E_FAIL;
        }
        else
        {
            bDirExists = Util::DoesDirExist(szImageDir);
        }

        // couldn't find images directory, default to My Pictures directory
        if (!bDirExists)
        {
            Util::GetMyPicturesFolder(szImageDir,
                                sizeof(szImageDir) / sizeof(TCHAR));
        }
    }

    // start up the slideshow projector.
    if (SUCCEEDED(hr))
    {
        hr = GVAR_pSlideshowProjector->Init(szDeviceDir, szImageDir);
    }

    return hr;
}

//////////////////////////////
// CfgDlg::Term
//
HRESULT CfgDlg::Term()
{
    HRESULT hr = S_OK;

    GVAR_pSlideshowProjector->Term();

    return hr;
}

//////////////////////////////
// CfgDlg::Create
//
HWND CfgDlg::Create(int nCmdShow)
{
    HWND hwnd = CreateDialog(GVAR_LOCAL.hInstance, 
                                     MAKEINTRESOURCE(IDD_CONFIG_DIALOG), 
                                     NULL, 
                                     DlgProc);

    // this is set in InitDlg
    if (GVAR_LOCAL.hwndMain != NULL)
    {
        Tray::Init(GVAR_LOCAL.hInstance,
                   GVAR_LOCAL.hwndMain,
                   WM_USER_TASKBAR);

        ::ShowWindow(GVAR_LOCAL.hwndMain, nCmdShow);
    }

    return GVAR_LOCAL.hwndMain;
}

//////////////////////////////
// ProcessError
//
static void ProcessError(ErrorState_Enum     ErrorState)
{
    HRESULT hr                          = S_OK;
    TCHAR   szErrMsg[255 + 1]           = {0};
    TCHAR   szCaption[63 + 1]           = {0};
    TCHAR   szDeviceDir[_MAX_PATH + 1]  = {0};
    TCHAR   szImageDir[_MAX_PATH + 1]   = {0};

    if (ErrorState == ErrorState_NONE)
    {
        return;
    }

    Util::GetString(GVAR_LOCAL.hInstance,
                    IDS_ERR_CAPTION,
                    szCaption,
                    sizeof(szCaption) / sizeof(TCHAR));

    hr = Util::GetAppDirs(szDeviceDir, 
                          sizeof(szDeviceDir) / sizeof(TCHAR),
                          szImageDir,
                          sizeof(szImageDir) / sizeof(TCHAR));


    if (ErrorState == ErrorState_DEVICE_DIR_DOESNT_EXIST)
    {
        Util::GetString(GVAR_LOCAL.hInstance,
                        IDS_ERR_INVALID_DEVICE_DIR,
                        szErrMsg,
                        sizeof(szErrMsg) / sizeof(TCHAR),
                        szDeviceDir);
                        
    }
    else if (ErrorState == ErrorState_IMAGE_DIR_DOESNT_EXIST)
    {
        Util::GetString(GVAR_LOCAL.hInstance,
                        IDS_ERR_INVALID_IMAGE_DIR,
                        szErrMsg,
                        sizeof(szErrMsg) / sizeof(TCHAR),
                        szImageDir);
    }
    else if (ErrorState == ErrorState_SLIDESHOW_SERVER_NOT_FOUND)
    {
        Util::GetString(GVAR_LOCAL.hInstance,
                        IDS_ERR_SLIDESHOW_SERVER_NOT_FOUND,
                        szErrMsg,
                        sizeof(szErrMsg) / sizeof(TCHAR));
    }
    else if (ErrorState == ErrorState_FAILED_TO_START_SLIDESHOW)
    {
        Util::GetString(GVAR_LOCAL.hInstance,
                        IDS_ERR_FAILED_TO_START_SLIDESHOW,
                        szErrMsg,
                        sizeof(szErrMsg) / sizeof(TCHAR));
    }
    else
    {
        Util::GetString(GVAR_LOCAL.hInstance,
                        IDS_ERR_SERVER_ERROR,
                        szErrMsg,
                        sizeof(szErrMsg) / sizeof(TCHAR));
    }

    MessageBox(GVAR_LOCAL.hwndMain, 
               szErrMsg,
               szCaption,
               MB_ICONERROR | MB_OK);

    return;
}

//////////////////////////////
// InitDlg
//
static int InitDlg(HWND hwndDlg)
{
    HRESULT hr = S_OK;

    GVAR_LOCAL.hwndMain = hwndDlg;

    //
    // set the image frequency trackbar range.
    //
    SendDlgItemMessage(hwndDlg,
                       IDC_FREQUENCY,
                       TBM_SETRANGE,
                       (WPARAM) TRUE, 
                       (LPARAM) MAKELONG(MIN_IMAGE_FREQ_IN_SEC, MAX_IMAGE_FREQ_IN_SEC));

    //
    // set the image scale factor range.
    //
    SendDlgItemMessage(hwndDlg,
                       IDC_MAX_SIZE,
                       TBM_SETRANGE,
                       (WPARAM) TRUE, 
                       (LPARAM) MAKELONG(MIN_IMAGE_SCALE_FACTOR, MAX_IMAGE_SCALE_FACTOR));

    // these are just initial settings in case we fail to load the last
    // saved settings.
    //
    SetImageFreqTrackbar(MIN_IMAGE_FREQ_IN_SEC);
    SetImageScaleTrackbar(MAX_IMAGE_SCALE_FACTOR);

    if (GVAR_LOCAL.ErrorState == ErrorState_NONE)
    {
        if (GVAR_pSlideshowProjector)
        {
            hr = GVAR_pSlideshowProjector->StartProjector();

            if (FAILED(hr))
            {
                GVAR_LOCAL.ErrorState = ErrorState_FAILED_TO_START_SLIDESHOW;
            }
        }
    
        if (SUCCEEDED(hr))
        {
            LoadCurrentSettings();
        }
    }
        
    ProcessError(GVAR_LOCAL.ErrorState);

    return 0;
}

//////////////////////////////
// TermDlg
//
static bool TermDlg()
{
    HRESULT hr = S_OK;

    if (GVAR_pSlideshowProjector)
    {
        hr = GVAR_pSlideshowProjector->StopProjector();
    }

    Tray::Term(GVAR_LOCAL.hwndMain);
    DestroyWindow(GVAR_LOCAL.hwndMain);

    return true;
}

//////////////////////////////
// DlgProc
//
INT_PTR CALLBACK DlgProc(HWND   hwndDlg,
                         UINT   uiMsg,
                         WPARAM wParam,
                         LPARAM lParam)
{
    int iReturn = 0;

    switch(uiMsg)
    {
        case WM_INITDIALOG:

            // intialize the controls on the dialog.
            InitDlg(hwndDlg);

            iReturn = TRUE;
        break;

        case WM_CLOSE:

            // rather than closing the window when the user hits the
            // X, we hide it, thereby keeping the taskbar icon.
            ShowWindow(hwndDlg, SW_HIDE);
        break;

        case WM_DESTROY:

            // if we are destroying the window, then lets 
            // exit the app.
            ::PostQuitMessage(0);
        break;

        case WM_COMMAND:
            iReturn = ProcessWMCommand(hwndDlg,
                                       uiMsg,
                                       wParam,
                                       lParam);
        break;

        case WM_USER_TASKBAR:
            iReturn = ProcessTaskbarMsg(hwndDlg,
                                        uiMsg,
                                        wParam,
                                        lParam);
        break;

        case WM_HSCROLL:
            ProcessScroll(hwndDlg, (HWND) lParam);
        break;

        default:
            iReturn = 0;
        break;
    }
    
    return iReturn;
}

///////////////////////////////
// ProcessWMCommand
//
static int ProcessWMCommand(HWND   hwndDlg,
                            UINT   uiMsg,
                            WPARAM wParam,
                            LPARAM lParam)
{
    int iReturn = 0;
    int iControlID  = LOWORD(wParam);
    int iNotifyCode = HIWORD(wParam);

    switch (iControlID)
    {
        case IDOK:

            // the user hit the OK button, save the setting changes
            // they made, and hide the window.
            SaveCurrentSettings();
            ShowWindow(hwndDlg, SW_HIDE);
        break;

        case IDCANCEL:

            // abandoning changes made by the user.
            ShowWindow(hwndDlg, SW_HIDE);
            EnableApplyButton(FALSE);
        break;

        case IDC_APPLY:

            // the user hit the APPLY button, save the setting changes
            // they made, but don't hide the window
            SaveCurrentSettings();
        break;

        case IDC_ALLOWSTRETCHING:
        case IDC_DISPLAYFILENAME:
        case IDC_ALLOW_KEYBOARDCONTROL:
            EnableApplyButton(TRUE);
        break;

        case IDM_POPUP_OPEN:
            ShowConfigWindow();
        break;

        case IDM_POPUP_EXIT:
            TermDlg();
        break;

        case IDC_BROWSE:
        {
            bool  bNewDirSelected = false;
            TCHAR szDir[_MAX_PATH + 1] = {0};

            // popup the browse for directories dialog.
            // On return this dialog returns the directory selected
            // by the user.
            bNewDirSelected = Util::BrowseForDirectory(hwndDlg,
                                                      NULL,
                                                      szDir,
                                                      sizeof(szDir) / sizeof(TCHAR));

            if (bNewDirSelected)
            {
                // set the directory in the edit text control.
                SetDlgItemText(hwndDlg,
                               IDC_IMAGEDIR,
                               szDir); 

                EnableApplyButton(TRUE);
            }
        }
        break;

        default:
        break;
    }

    return iReturn;
}

//////////////////////////////////////////////////////////////////////
// ProcessTaskbarMsg
//
// Desc:       Function is called when there is an event at the taskbar
//             
//
// Params:     - hwnd, handle of main window.
//             - uiMessage, message sent.
static int ProcessTaskbarMsg(HWND    hwnd,
                             UINT    uiMessage,
                             WPARAM  wParam, 
                             LPARAM  lParam) 
{ 
    int  iReturn = 0;
    UINT uID; 
    UINT uMouseMsg; 
 
    uID       = (UINT) wParam; 
    uMouseMsg = (UINT) lParam; 

    // remove unref param warning
    uiMessage = uiMessage;
 
    switch (uMouseMsg)
    {
        case WM_LBUTTONDBLCLK:

            ShowConfigWindow();

        break;

        case WM_LBUTTONDOWN:

        break;

        case WM_RBUTTONDOWN:
            Tray::PopupMenu(hwnd);
        break;
    }

    return iReturn; 
} 

///////////////////////////////
// ShowConfigWindow
//
static int ProcessScroll(HWND hwndDlg,
                         HWND hwndScroll)
{
    ASSERT(hwndScroll != NULL);

    int     iReturn             = 0;
    HRESULT hr                  = S_OK;
    TCHAR   szString[255 + 1]   = {0};

    if (hwndScroll == NULL)
    {
        return E_INVALIDARG;
    }

    if (GetDlgItem(hwndDlg, IDC_FREQUENCY) == hwndScroll)
    {
        UINT nFrequency = (UINT)SendDlgItemMessage(hwndDlg, 
                                                   IDC_FREQUENCY, 
                                                   TBM_GETPOS, 
                                                   0, 0 );

        SetImageFreqTrackbar(nFrequency);

        hr = Util::FormatTime(GVAR_LOCAL.hInstance, 
                             nFrequency,
                             szString,
                             sizeof(szString) / sizeof(TCHAR));

        SendDlgItemMessage(hwndDlg, 
                           IDC_MINUTES_AND_SECONDS, 
                           WM_SETTEXT, 
                           0, 
                           (LPARAM) szString);
    }
    else if (GetDlgItem(hwndDlg, IDC_MAX_SIZE) == hwndScroll)
    {
        UINT nScaleFactor = (UINT)SendDlgItemMessage(hwndDlg, 
                                                     IDC_MAX_SIZE, 
                                                     TBM_GETPOS, 
                                                     0, 0 );

        SetImageScaleTrackbar(nScaleFactor);
    }

    EnableApplyButton(TRUE);

    return iReturn;
}


///////////////////////////////
// ShowConfigWindow
//
static HRESULT ShowConfigWindow()
{
    HRESULT hr = S_OK;

    // reload our settings from the DLL to ensure that
    // we are reflecting the real state of the settings.

    LoadCurrentSettings();

    // popup the window on double click.  
    ShowWindow(GVAR_LOCAL.hwndMain,
               SW_SHOW);

    // make sure we are the foreground window.
    SetForegroundWindow(GVAR_LOCAL.hwndMain);

    return hr;
}

///////////////////////////////
// IsChecked
//
static BOOL IsChecked(INT iResID)
{
    LRESULT    lState   = 0;
    BOOL       bChecked = TRUE;

    // Get the Display File Name 
    lState = SendDlgItemMessage(GVAR_LOCAL.hwndMain,
                                iResID,
                                BM_GETCHECK,
                                0, 
                                0);
    if (lState == BST_CHECKED)
    {
        bChecked = TRUE;
    }
    else
    {
        bChecked = FALSE;
    }

    return bChecked;
}


///////////////////////////////
// SetImageFreqTrackbar
//
static HRESULT SetImageFreqTrackbar(DWORD   dwImageFreq)
{
    HRESULT hr = S_OK;

    if (SUCCEEDED(hr))
    {
        TCHAR   szTime[255 + 1] = {0};

        // set the trackbar's current position.
        SendDlgItemMessage(GVAR_LOCAL.hwndMain,
                           IDC_FREQUENCY,
                           TBM_SETPOS,
                           (WPARAM) TRUE,
                           (LPARAM) dwImageFreq);

        hr = Util::FormatTime(GVAR_LOCAL.hInstance, 
                             dwImageFreq,
                             szTime,
                             sizeof(szTime) / sizeof(TCHAR));

        SendDlgItemMessage(GVAR_LOCAL.hwndMain, 
                           IDC_MINUTES_AND_SECONDS, 
                           WM_SETTEXT, 
                           0, 
                           (LPARAM) szTime);
    }

    return hr;
}

///////////////////////////////
// SetImageScaleTrackbar
//
static HRESULT SetImageScaleTrackbar(DWORD   dwImageScaleFactor)
{
    HRESULT hr = S_OK;

    // 
    // Set Image Scale Factor Trackbar
    //
    if (SUCCEEDED(hr))
    {
        TCHAR   szScale[255 + 1] = {0};

        // set the trackbar's current position.
        SendDlgItemMessage(GVAR_LOCAL.hwndMain,
                           IDC_MAX_SIZE,
                           TBM_SETPOS,
                           (WPARAM) TRUE,
                           (LPARAM) dwImageScaleFactor);

        hr = Util::FormatScale(GVAR_LOCAL.hInstance, 
                               dwImageScaleFactor,
                               szScale,
                               sizeof(szScale) / sizeof(TCHAR));

        SendDlgItemMessage(GVAR_LOCAL.hwndMain, 
                           IDC_IMAGE_SIZE_DESC, 
                           WM_SETTEXT, 
                           0, 
                           (LPARAM) szScale);
    }

    return hr;
}

///////////////////////////////
// EnableApplyButton
//
static void EnableApplyButton(BOOL bEnable)
{
    EnableWindow(GetDlgItem(GVAR_LOCAL.hwndMain, IDC_APPLY), bEnable);
}

///////////////////////////////
// LoadCurrentSettings
//
static HRESULT LoadCurrentSettings()
{
    HRESULT hr                        = S_OK;
    DWORD   dwImageFreq               = 0;
    DWORD   dwImageScaleFactor        = 0;
    TCHAR   szImageDir[_MAX_PATH + 1] = {0};
    BOOL    bShowFileName             = FALSE;
    BOOL    bAllowKeyControl          = FALSE;
    BOOL    bStretchSmallImages       = FALSE;

    ASSERT(GVAR_pSlideshowProjector != NULL);

    if (GVAR_pSlideshowProjector == NULL)
    {
        DBG_ERR(("InitDlg, failed to get Image Frequency, slide show "
                 "projector object doesn't exist"));

        return 0;
    }
    
    // 
    // Get the Image Frequency
    //
    hr = GVAR_pSlideshowProjector->get_ImageFrequency(&dwImageFreq);

    if (SUCCEEDED(hr))
    {
        if (dwImageFreq < MIN_IMAGE_FREQ_IN_SEC)
        {
            dwImageFreq = MIN_IMAGE_FREQ_IN_SEC;
            hr = GVAR_pSlideshowProjector->put_ImageFrequency(dwImageFreq);
        }
        else if (dwImageFreq > MAX_IMAGE_FREQ_IN_SEC)
        {
            dwImageFreq = MAX_IMAGE_FREQ_IN_SEC;
            hr = GVAR_pSlideshowProjector->put_ImageFrequency(dwImageFreq);        
        }
    }

    // 
    // Set Image Frequency Trackbar
    //
    if (SUCCEEDED(hr))
    {
        SetImageFreqTrackbar(dwImageFreq);
    }

    // 
    // Get the Image Scale Factor
    //
    hr = GVAR_pSlideshowProjector->get_ImageScaleFactor(&dwImageScaleFactor);

    if (SUCCEEDED(hr))
    {
        if (dwImageScaleFactor < MIN_IMAGE_SCALE_FACTOR)
        {
            dwImageScaleFactor = MIN_IMAGE_SCALE_FACTOR;
            hr = GVAR_pSlideshowProjector->put_ImageScaleFactor(dwImageScaleFactor);
        }
        else if (dwImageScaleFactor > MAX_IMAGE_SCALE_FACTOR)
        {
            dwImageScaleFactor = MAX_IMAGE_SCALE_FACTOR;
            hr = GVAR_pSlideshowProjector->put_ImageScaleFactor(dwImageScaleFactor);        
        }
    }

    // 
    // Set Image Scale Factor Trackbar
    //
    if (SUCCEEDED(hr))
    {
        SetImageScaleTrackbar(dwImageScaleFactor);
    }

    //
    // Get the current Image Directory
    //
    hr = GVAR_pSlideshowProjector->get_ImageDirectory(szImageDir,
                                                      sizeof(szImageDir) / sizeof(TCHAR));

    // set the edit control's image directory to reflect the current
    // image directory.
    if (SUCCEEDED(hr))
    {
        SetDlgItemText(GVAR_LOCAL.hwndMain,
                       IDC_IMAGEDIR,
                       szImageDir);
    }

    //
    // get the "ShowFilename" attribute
    //
    hr = GVAR_pSlideshowProjector->get_ShowFilename(&bShowFileName);

    // set the ShowFileName checkbox
    if (SUCCEEDED(hr))
    {
        if (bShowFileName)
        {
            SendDlgItemMessage(GVAR_LOCAL.hwndMain,
                               IDC_DISPLAYFILENAME,
                               BM_SETCHECK,
                               BST_CHECKED,
                               0);
        }
        else
        {
            SendDlgItemMessage(GVAR_LOCAL.hwndMain,
                               IDC_DISPLAYFILENAME,
                               BM_SETCHECK,
                               BST_UNCHECKED,
                               0);
        }
    }

    //
    // get the "AllowKeyControl" attribute
    //
    hr = GVAR_pSlideshowProjector->get_AllowKeyControl(&bAllowKeyControl);

    // set the Allow Keyboard Control checkbox
    if (SUCCEEDED(hr))
    {
        if (bAllowKeyControl)
        {
            SendDlgItemMessage(GVAR_LOCAL.hwndMain,
                               IDC_ALLOW_KEYBOARDCONTROL,
                               BM_SETCHECK,
                               BST_CHECKED,
                               0);
        }
        else
        {
            SendDlgItemMessage(GVAR_LOCAL.hwndMain,
                               IDC_ALLOW_KEYBOARDCONTROL,
                               BM_SETCHECK,
                               BST_UNCHECKED,
                               0);
        }
    }

    //
    // get the "StretchSmallImages" attribute
    //
    hr = GVAR_pSlideshowProjector->get_StretchSmallImages(&bStretchSmallImages);

    // set the Stretch Small Images Control checkbox
    if (SUCCEEDED(hr))
    {
        if (bStretchSmallImages)
        {
            SendDlgItemMessage(GVAR_LOCAL.hwndMain,
                               IDC_ALLOWSTRETCHING,
                               BM_SETCHECK,
                               BST_CHECKED,
                               0);
        }
        else
        {
            SendDlgItemMessage(GVAR_LOCAL.hwndMain,
                               IDC_ALLOWSTRETCHING,
                               BM_SETCHECK,
                               BST_UNCHECKED,
                               0);
        }
    }


    return hr;
}

///////////////////////////////
// SaveCurrentSettings
//
static HRESULT SaveCurrentSettings()
{
    HRESULT     hr                        = S_OK;
    DWORD_PTR   dwImageFreq               = 0;
    DWORD_PTR   dwImageScaleFactor        = 0;
    TCHAR       szImageDir[_MAX_PATH + 1] = {0};
    BOOL        bShowFileName             = FALSE;
    BOOL        bAllowKeyControl          = FALSE;
    BOOL        bStretchSmallImages       = FALSE;
    LONG        lState                    = 0;

    ASSERT(GVAR_pSlideshowProjector != NULL);

    //
    // get the image frequency trackbar value
    //
    dwImageFreq = (DWORD_PTR) SendDlgItemMessage(GVAR_LOCAL.hwndMain,
                                                 IDC_FREQUENCY,
                                                 TBM_GETPOS,
                                                 0,
                                                 0);

    //
    // get the image scale factor trackbar value
    //
    dwImageScaleFactor = (DWORD_PTR) SendDlgItemMessage(GVAR_LOCAL.hwndMain,
                                                        IDC_MAX_SIZE,
                                                        TBM_GETPOS,
                                                        0,
                                                        0);

    //
    // get the image directory
    //
    GetDlgItemText(GVAR_LOCAL.hwndMain,
                   IDC_IMAGEDIR,
                   szImageDir,
                   sizeof(szImageDir) / sizeof(TCHAR));


    // Get the Display File Name 
    bShowFileName       = IsChecked(IDC_DISPLAYFILENAME);

    // Get the Allow Key Control
    bAllowKeyControl    = IsChecked(IDC_ALLOW_KEYBOARDCONTROL);

    // Get the Stretch Small Images
    bStretchSmallImages = IsChecked(IDC_ALLOWSTRETCHING);

    //
    // set the image frequency 
    //
    hr = GVAR_pSlideshowProjector->put_ImageFrequency((DWORD) dwImageFreq);

    if (FAILED(hr))
    {
        DBG_ERR(("SaveCurrentSettings, failed to set image frequency"));
    }

    //
    // set the image scale factor
    //
    hr = GVAR_pSlideshowProjector->put_ImageScaleFactor((DWORD) dwImageScaleFactor);

    if (FAILED(hr))
    {
        DBG_ERR(("SaveCurrentSettings, failed to set image scale factor"));
    }

    //
    // put the show file name attribute
    //
    hr = GVAR_pSlideshowProjector->put_ShowFilename(bShowFileName);

    if (FAILED(hr))
    {
        DBG_ERR(("SaveCurrentSettings, failed to set show filename property"));
    }

    //
    // put the allow key control attribute
    //
    hr = GVAR_pSlideshowProjector->put_AllowKeyControl(bAllowKeyControl);

    if (FAILED(hr))
    {
        DBG_ERR(("SaveCurrentSettings, failed to set Allow Key Control property"));
    }

    //
    // put the Stretch Small Images control attribute
    //
    hr = GVAR_pSlideshowProjector->put_StretchSmallImages(bStretchSmallImages);

    if (FAILED(hr))
    {
        DBG_ERR(("SaveCurrentSettings, failed to set StretchSmallImages property"));
    }

    
    //
    // set the control's image directory
    // Notice we store the image directory rather than the Projector
    // server control because it is not something that can be 
    // set remotely.  Only items that can be configured by the client
    // are stored by the COM Projector Server
    //
    hr = GVAR_pSlideshowProjector->put_ImageDirectory(szImageDir);

    if (SUCCEEDED(hr))
    {
        // save to the registry
        Util::SetRegString(REG_VAL_IMAGE_DIR,
                           szImageDir,
                           sizeof(szImageDir) / sizeof(TCHAR));
    }
    else 
    {
        DBG_ERR(("SaveCurrentSettings, failed to set image directory"));
    }

    EnableApplyButton(FALSE);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\webview\camocx\camocx.inc ===
!include $(CCSHELL_DIR)\common.inc

SOURCES_USED = $(SOURCES_USED) $(CCSHELL_DIR)\common.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\upnp\prjctr\server\util.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// File:            util.cpp
//
// Description:     
//
// Copyright (c) 2000 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////////////

// App Includes
#include "precomp.h"
#include "main.h"
#include "resource.h"

#include <shlobj.h>
#include <shfolder.h>

////////////////////////// Function Prototypes ////////////////////////////////

int CALLBACK ChangeDirectoryCallback(HWND    hWnd, 
                                     UINT    uMsg, 
                                     LPARAM  lParam, 
                                     LPARAM  lpData);

///////////////////////////
// GVAR_LOCAL
//
// Global Variable
//
static struct GVAR_LOCAL
{
    HKEY    hRootKey;
} GVAR_LOCAL = 
{
    NULL
};

///////////////////////////////
// Util::Init
//
HRESULT Util::Init(HINSTANCE hInstance)
{
    HRESULT hr = S_OK;

    if (SUCCEEDED(hr))
    {
        LRESULT lr            = NOERROR;
        DWORD   dwDisposition = 0;

        lr = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                            REG_KEY_PROJECTOR,
                            NULL,
                            NULL,
                            0,
                            KEY_ALL_ACCESS,
                            NULL,
                            &GVAR_LOCAL.hRootKey,
                            &dwDisposition);

        if (lr != NOERROR)
        {
            DBG_ERR(("InitApp, failed to open registry key"));

            hr = E_FAIL;
        }
    }

    return hr;
}

///////////////////////////////
// Util::Term
//
HRESULT Util::Term(void)
{
    RegCloseKey(GVAR_LOCAL.hRootKey);
    GVAR_LOCAL.hRootKey = NULL;

    return S_OK;
}

///////////////////////////////
// GetMyPicturesFolder
//
HRESULT Util::GetMyPicturesFolder(TCHAR *pszFolder,
                                  DWORD cchFolder)
{
    HRESULT hr = S_OK;

    // set the directory of the images.
    hr = SHGetFolderPath(NULL,
                         CSIDL_MYPICTURES,
                         NULL,
                         0,
                         pszFolder);

    return hr;
}

///////////////////////////////
// GetProgramFilesFolder
//

HRESULT Util::GetProgramFilesFolder(TCHAR *pszFolder,
                                    DWORD cchFolder)
{
    HRESULT hr = S_OK;

    // set the directory of the images.
    hr = SHGetFolderPath(NULL,
                         CSIDL_PROGRAM_FILES,
                         NULL,
                         0,
                         pszFolder);

    return hr;
}

///////////////////////////////
// Util::GetAppDirs
//
HRESULT Util::GetAppDirs(TCHAR   *pszDeviceDir,
                         DWORD   cchDeviceDir,  
                         TCHAR   *pszImageDir,
                         DWORD   cchImageDir)
{
    HRESULT hr = S_OK;

    ASSERT(pszDeviceDir != NULL);
    ASSERT(pszImageDir  != NULL);
    ASSERT(cchDeviceDir > 0);
    ASSERT(cchImageDir  > 0);

    if ((pszDeviceDir == NULL) ||
        (pszImageDir  == NULL) ||
        (cchDeviceDir == 0)    ||
        (cchImageDir  == 0))
    {
        return E_INVALIDARG;
    }

    // preload the image dir buffer with the "My Pictures" path
    // so that it is set as the default directory if we don't
    // have an overriding one in the registry.

    if (SUCCEEDED(hr))
    {
        hr = GetMyPicturesFolder(pszImageDir, 
                                 cchImageDir);
    }

    // preload the device dir buffer with the "Program Files\MSProjector"
    // install path so that it is set as the default directory if we don't
    // have an overriding one in the registry.

    if (SUCCEEDED(hr))
    {
        hr = GetProgramFilesFolder(pszDeviceDir,
                                   cchDeviceDir);
    }

    if (SUCCEEDED(hr))
    {
        if (pszDeviceDir[_tcslen(pszDeviceDir) - 1] != '\\')
        {
            _tcscat(pszDeviceDir, _T("\\"));
        }

        _tcscat(pszDeviceDir, DEFAULT_INSTALL_PATH);
    }

    if (SUCCEEDED(hr))
    {
        // get the image dir.
        hr = GetRegString(REG_VAL_IMAGE_DIR,
                    pszImageDir,
                    cchImageDir,
                    TRUE);

        if (FAILED(hr))
        {
            DBG_ERR(("GetAppDirs, failed to get/set image directory.  "
                    "This should never happen"));

            ASSERT(FALSE);
        }

        // get the device dir
        hr = GetRegString(REG_VAL_DEVICE_DIR,
                    pszDeviceDir,
                    cchDeviceDir,
                    TRUE);

        if (FAILED(hr))
        {
            DBG_ERR(("GetAppDirs, failed to get/set image directory.  "
                     "This should never happen"));

            ASSERT(FALSE);
        }
    }

    return hr;
}

///////////////////////////////
// Util::GetRegString
//
HRESULT Util::GetRegString(const TCHAR   *pszValueName,
                           TCHAR         *pszDir,
                           DWORD         cchDir,
                           BOOL          bSetIfNotExist)
{
    HRESULT hr = S_OK;

    ASSERT(pszValueName != NULL);
    ASSERT(pszDir       != NULL);
    ASSERT(cchDir > 0);

    if ((pszValueName == NULL) ||
        (pszDir       == NULL) ||
        (cchDir       <= 0))
    {
        return E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        LRESULT lr = NOERROR;
        DWORD   dwType = REG_SZ;

        lr = RegQueryValueEx(GVAR_LOCAL.hRootKey,
                             pszValueName,
                             NULL,
                             &dwType,
                             (BYTE*) pszDir,
                             &cchDir);

        if (lr != NOERROR)
        {
            if (bSetIfNotExist)
            {
                // we need the number of bytes we are writing to the registry.
                DWORD dwLength = _tcslen(pszDir) * sizeof(TCHAR) + 1;

                lr = RegSetValueEx(GVAR_LOCAL.hRootKey,
                                   pszValueName,
                                   NULL,
                                   REG_SZ,
                                   (BYTE*) pszDir,
                                   dwLength);
            }
            else
            {
                hr = E_FAIL;
                DBG_ERR(("GetRegString, failed to get '%ls' from registry, hr = 0x%08lx",
                         pszValueName,
                         hr));
            }
        }
    }

    return hr;
}

///////////////////////////////
// Util::SetRegString
//
HRESULT Util::SetRegString(const TCHAR   *pszValueName,
                           TCHAR         *pszDir,
                           DWORD         cchDir)
{
    HRESULT hr = S_OK;

    ASSERT(pszValueName != NULL);
    ASSERT(pszDir       != NULL);
    ASSERT(cchDir       > 0);

    if ((pszValueName == NULL) ||
        (pszDir       == NULL) ||
        (cchDir       <= 0))
    {
        return E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        LRESULT     lr       = NOERROR;
        DWORD       dwLength = _tcslen(pszDir) * sizeof(TCHAR) + 1;

        // we need the number of bytes we are writing to the registry.

        lr = RegSetValueEx(GVAR_LOCAL.hRootKey,
                           pszValueName,
                           NULL,
                           REG_SZ,
                           (BYTE*) pszDir,
                           dwLength);

        if (lr != NOERROR)
        {
            hr = E_FAIL;
            DBG_ERR(("SetRegString, failed to set '%ls' to registry, hr = 0x%08lx",
                    pszValueName,
                    hr));
        }
    }

    return hr;
}

///////////////////////////////
// Util::GetRegDWORD
//
HRESULT Util::GetRegDWORD(const TCHAR   *pszValueName,
                          DWORD         *pdwValue,
                          BOOL          bSetIfNotExist)
{
    HRESULT hr = S_OK;

    ASSERT(pszValueName != NULL);
    ASSERT(pdwValue     != NULL);

    if ((pszValueName == NULL) ||
        (pdwValue     == NULL))
    {
        return E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        LRESULT lr = NOERROR;
        DWORD   dwType = REG_DWORD;
        DWORD   dwSize = sizeof(DWORD);

        lr = RegQueryValueEx(GVAR_LOCAL.hRootKey,
                             pszValueName,
                             NULL,
                             &dwType,
                             (BYTE*) pdwValue,
                             &dwSize);

        if (lr != NOERROR)
        {
            if (bSetIfNotExist)
            {
                // we need the number of bytes we are writing to the registry.

                lr = RegSetValueEx(GVAR_LOCAL.hRootKey,
                                   pszValueName,
                                   NULL,
                                   REG_SZ,
                                   (BYTE*) pdwValue,
                                   dwSize);
            }
            else
            {
                hr = E_FAIL;
                DBG_ERR(("GetRegDWORD, failed to get '%ls' from registry, hr = 0x%08lx",
                        pszValueName,
                        hr));
            }
        }
    }

    return hr;
}

///////////////////////////////
// Util::SetRegDWORD
//
HRESULT Util::SetRegDWORD(const TCHAR   *pszValueName,
                          DWORD         dwValue)
{
    HRESULT hr = S_OK;

    ASSERT(pszValueName != NULL);

    if (pszValueName == NULL)
    {
        return E_INVALIDARG;
    }

    if (SUCCEEDED(hr))
    {
        LRESULT     lr       = NOERROR;

        // we need the number of bytes we are writing to the registry.

        lr = RegSetValueEx(GVAR_LOCAL.hRootKey,
                           pszValueName,
                           NULL,
                           REG_DWORD,
                           (BYTE*) &dwValue,
                           sizeof(DWORD));

        if (lr != NOERROR)
        {
            hr = E_FAIL;
            DBG_ERR(("SetRegDWORD, failed to set '%ls' to registry, hr = 0x%08lx",
                     pszValueName,
                     hr));
        }
    }

    return hr;
}


///////////////////////////////
// Util::BrowseForDirectory
//
bool Util::BrowseForDirectory(HWND        hWnd, 
                              const TCHAR *pszPrompt, 
                              TCHAR       *pszDirectory,
                              DWORD       cchDirectory )
{
    bool bResult = false;

    LPMALLOC pMalloc;

    HRESULT hr = SHGetMalloc(&pMalloc);

    if (SUCCEEDED(hr))
    {
        TCHAR szDisplayName[_MAX_PATH + 1] = {0};
        TCHAR szDirectory[_MAX_PATH + 1]   = {0};

        BROWSEINFO BrowseInfo = {0};

        BrowseInfo.hwndOwner       = hWnd;
        BrowseInfo.pszDisplayName  = szDisplayName;
        BrowseInfo.lpszTitle       = pszPrompt;
        BrowseInfo.ulFlags         = BIF_RETURNONLYFSDIRS;
        BrowseInfo.lpfn            = ChangeDirectoryCallback;
        BrowseInfo.lParam          = (LPARAM)szDirectory;
        BrowseInfo.iImage          = 0;

        LPITEMIDLIST pidl = SHBrowseForFolder(&BrowseInfo);

        if (pidl != NULL)
        {
            TCHAR szResult[MAX_PATH + 1] = {0};

            if (SHGetPathFromIDList(pidl, szResult))
            {
                _tcsncpy(pszDirectory, szResult, cchDirectory);

                bResult = true;
            }

            pMalloc->Free(pidl);
        }

        pMalloc->Release();
    }

    return bResult;
}

///////////////////////////////
// ChangeDirectoryCallback
//
int CALLBACK ChangeDirectoryCallback(HWND    hWnd, 
                                     UINT    uMsg, 
                                     LPARAM  lParam, 
                                     LPARAM  lpData )
{
    if (uMsg == BFFM_INITIALIZED)
    {
        SendMessage(hWnd, BFFM_SETSELECTION, 1, (LPARAM)lpData );
    }

    return 0;
}


///////////////////////////////
// Util::FormatTime
//
HRESULT Util::FormatTime(HINSTANCE hInstance, 
                         UINT nTotalSeconds,
                         TCHAR     *pszTime,
                         DWORD     cchTime)
{
    ASSERT(pszTime != NULL);

    HRESULT hr                = S_OK;
    int     iResult           = 0;
    TCHAR   szString[255 + 1] = {0};
    UINT    nMinutes          = nTotalSeconds / 60;
    UINT    nSeconds          = nTotalSeconds % 60;
    UINT    uiStrResID        = 0;

    if (pszTime == NULL)
    {
        return E_INVALIDARG;
    }

    if (nMinutes == 0)
    {
        if (nSeconds == 1)
        {
            uiStrResID = IDS_SECOND;
        }
        else
        {
            uiStrResID = IDS_SECONDS;
        }
    }
    else if (nSeconds == 0)
    {
        if (nMinutes == 1)
        {
            uiStrResID = IDS_MINUTE;
        }
        else
        {
            uiStrResID = IDS_MINUTES;
        }
    }
    else if ((nMinutes == 1) && (nSeconds == 1))
    {
        uiStrResID = IDS_MINUTE_AND_SECOND;
    }
    else if (nMinutes == 1)
    {
        uiStrResID = IDS_MINUTE_AND_SECONDS;
    }
    else if (nSeconds == 1)
    {
        uiStrResID = IDS_MINUTES_AND_SECOND;
    }
    else 
    {
        uiStrResID = IDS_MINUTES_AND_SECONDS;
    }

    if (uiStrResID != 0)
    {
        iResult = ::LoadString(hInstance,
                               uiStrResID,
                               szString,
                               sizeof(szString) / sizeof(TCHAR));
    }

    if (iResult != 0)
    {
        if (nMinutes == 0)
        {
            _sntprintf(pszTime, cchTime, szString, nSeconds);
        }
        else if (nSeconds == 0)
        {
            _sntprintf(pszTime, cchTime, szString, nMinutes);
        }
        else
        {
            _sntprintf(pszTime, cchTime, szString, nMinutes, nSeconds);
        }
    }

    return hr;
}


///////////////////////////////
// Util::FormatScale
//
HRESULT Util::FormatScale(HINSTANCE hInstance, 
                          DWORD     dwImageScaleFactor,
                          TCHAR     *pszScale,
                          DWORD     cchScale)
{
    ASSERT(pszScale != NULL);

    HRESULT hr                = S_OK;
    int     iResult           = 0;
    TCHAR   szString[255 + 1] = {0};
    UINT    uiStrResID        = IDS_PERCENT;

    if (pszScale == NULL)
    {
        return E_INVALIDARG;
    }

    if (uiStrResID != 0)
    {
        iResult = ::LoadString(hInstance,
                               uiStrResID,
                               szString,
                               sizeof(szString) / sizeof(TCHAR));
    }

    if (iResult != 0)
    {
        _sntprintf(pszScale, cchScale, szString, dwImageScaleFactor);
    }

    return hr;
}

///////////////////////////////
// EndsWithChar
//
static BOOL EndsWithChar( LPCTSTR psz, TCHAR c )
{
    TCHAR* pszLast = _tcsrchr( (TCHAR*)psz, c );    // find last occurence of char in psz

    return(( NULL != pszLast ) && ( *_tcsinc( pszLast ) == _T('\0') ) );
}

///////////////////////////////
// StripTrailingChar
//
static void StripTrailingChar(TCHAR* input, TCHAR c)
{
    while (EndsWithChar(input, c))
    {
        TCHAR* p = input + _tcsclen(input) - 1;
        *p = _T('\0');
    }

    return;
}

///////////////////////////////
// GetString
//
BOOL Util::GetString(HINSTANCE  hInstance,
                     INT        iStrResID,
                     TCHAR      *pszString,
                     DWORD      cchString,
                     ...) 
{
    TCHAR   szFmtString[255 + 1] = {0};
    INT     iResult           = 0;
    va_list vaList;
    BOOL    bSuccess          = FALSE;

    iResult = ::LoadString(hInstance,
                           iStrResID,
                           szFmtString,
                           sizeof(szFmtString) / sizeof(TCHAR));

    if (iResult != 0)
    {
        va_start(vaList, cchString);
        _vsntprintf(pszString, cchString - 1, szFmtString, vaList);
        va_end(vaList);

        bSuccess = TRUE;
    }
    else
    {
        bSuccess = FALSE;
    }

    return bSuccess;
}

///////////////////////////////
// DoesDirExist
//
BOOL Util::DoesDirExist( LPCTSTR pszPath ) 
{
    TCHAR szTemp[MAX_PATH] = {0};

    _tcscpy( szTemp, pszPath );
    StripTrailingChar( szTemp, _T('\\') );
    DWORD dw = GetFileAttributes( szTemp );

    return((dw != 0xFFFFFFFF) && (dw & FILE_ATTRIBUTE_DIRECTORY) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\upnp\prjctr\server\resource.h ===
//////////////////////////////////////////////////////////////////////////////
//
// File:            Resource.h
//
// Description:     
//
// Copyright (c) 2000 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////////////

#define IDC_STATIC                              -1
#define IDD_CONFIG_DIALOG                       101
#define IDI_MONITOR                             102
#define IDC_DIVIDER                             103
#define IDC_FREQ_LESS                           104
#define IDC_FREQ_MORE                           105
#define IDC_FREQUENCY_STATIC                    106
#define IDC_FREQUENCY                           107
#define IDC_IMAGEDIR                            108
#define IDC_BROWSE                              109
#define IDC_DISPLAYFILENAME                     110
#define IDC_ALLOW_KEYBOARDCONTROL               111
#define IDM_POPUP_OPEN                          112
#define IDM_POPUP_EXIT                          113
#define IDC_MYPICTURES_ICON                     114
#define IDC_DIALOG_DESCRIPTION                  115
#define IDC_MINUTES_AND_SECONDS                 116
#define IDM_TRAY_POPUP_MENU                     117
#define IDC_SIZE_LESS                           118
#define IDC_SIZE_MORE                           119
#define IDC_MAX_SIZE                            120
#define IDC_IMAGE_SIZE_DESC                     121
#define IDC_ALLOWSTRETCHING                     122
#define IDC_MAX_SIZE_STATIC                     123

// string resources
#define IDS_MINUTES_AND_SECONDS                 1000
#define IDS_MINUTE_AND_SECONDS                  1001
#define IDS_MINUTES_AND_SECOND                  1002
#define IDS_MINUTE_AND_SECOND                   1003
#define IDS_SECONDS                             1004
#define IDS_SECOND                              1005
#define IDS_MINUTES                             1006
#define IDS_MINUTE                              1007
#define IDS_PERCENT                             1008
#define IDS_ERR_INVALID_DEVICE_DIR              1009  
#define IDS_ERR_INVALID_IMAGE_DIR               1010  
#define IDS_ERR_SLIDESHOW_SERVER_NOT_FOUND      1011
#define IDS_ERR_SERVER_ERROR                    1012
#define IDS_ERR_CAPTION                         1013
#define IDS_ERR_FAILED_TO_START_SLIDESHOW       1014
#define IDC_APPLY                               1015
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\upnp\prjctr\server\sources.inc ===
# ############################################################
#
#Copyright (c) 2000  Microsoft Corporation
#
#Author:
#   orenr
#
#Date:
#   10-Aug-2000
#
#Module Name:
#    sources.inc
#
#Abstract:
#    This file specifies the target component being built and the list of
#    sources files needed to build that component.  Also specifies optional
#    compiler switches and libraries that are unique for the component being
#    built.
#
#  This directory builds
#     msprjctr.dll    - Microsoft UPnP Slideshow Projector DLL
#
# ############################################################

!include $(PROJECT_ROOT)\ui\uienv.inc

TARGETNAME=wiaprjctr
TARGETPATH=obj
TARGETTYPE=PROGRAM

#
# Compiler environment
#

USE_STATIC_ATL=1

C_DEFINES=$(C_DEFINES)

INCLUDES= \
        $(INCLUDES); \
        $(PROJECT_ROOT)\wia\common\stirt;\
	$(PROJECT_ROOT)\wia\core\upnp\prjctr\inc\$(O); \
	$(PROJECT_ROOT)\wia\inc\$(O);

TARGETLIBS= \
        $(SDK_LIB_PATH)\kernel32.lib \
        $(SDK_LIB_PATH)\advapi32.lib \
        $(SDK_LIB_PATH)\user32.lib \
        $(SDK_LIB_PATH)\gdi32.lib \
        $(SDK_LIB_PATH)\ole32.lib \
        $(SDK_LIB_PATH)\oleaut32.lib \
        $(SDK_LIB_PATH)\shell32.lib \
        $(SDK_LIB_PATH)\comctl32.lib \
        $(SDK_LIB_PATH)\uuid.lib \
        $(PROJECT_ROOT)\wia\lib\$(O)\stirt.lib       

SOURCES= \
        main.cpp        \
        cfgdlg.cpp      \
        tray.cpp        \
        util.cpp        \
        ServUI.rc

PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

SXS_ASSEMBLY_NAME=Microsoft.Windows.PrintingAndImaging.wiaprjctr
SXS_ASSEMBLY_VERSION=1.0 
SXS_ASSEMBLY_LANGUAGE_INDEPENDENT=1
SXS_MANIFEST=wiaprjctr.Manifest
SXS_MANIFEST_IN_RESOURCES=1
SXS_NO_BINPLACE=1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\webview\camocx\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__36E3DC01_8876_11D2_8067_00805F6596D2__INCLUDED_)
#define AFX_DLLDATAX_H__36E3DC01_8876_11D2_8067_00805F6596D2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__36E3DC01_8876_11D2_8067_00805F6596D2__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\webview\camocx\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400     //for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY      //defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain                         PrxDllMain
#define DllRegisterServer       PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "wiaview_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\webview\camocx\camocx.cpp ===
// camocx.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file
//      dlldatax.c to the project.  Make sure precompiled headers
//      are turned off for this file, and add _MERGE_PROXYSTUB to the
//      defines for the project.
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for camocx.idl by adding the following
//      files to the Outputs.
//          camocx_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL,
//      run nmake -f camocxps.mk in the project directory.

#include "precomp.h"
#pragma hdrstop

#include "wiaview_i.c"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;
HINSTANCE g_hInstance;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_VideoPreview, CVideoPreview)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        SHFusionInitializeFromModuleID( hInstance, 123 );
        _Module.Init(ObjectMap, hInstance /* &LIBID_WIAVIEWLib*/);
        WIA_DEBUG_CREATE( hInstance );
        DisableThreadLibraryCalls(hInstance);
        g_hInstance = hInstance;
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        SHFusionUninitialize();
        WIA_DEBUG_DESTROY();
        _Module.Term();
    }

    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    HRESULT hr;
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    hr = (_Module.GetLockCount()==0) ? S_OK : S_FALSE;

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif

    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\upnp\prjctr\server\tray.cpp ===
//////////////////////////////////////////////////////////////////////////////
//
// File:            tray.cpp
//
// Description:     
//
// Copyright (c) 2000 Microsoft Corp.
//
//////////////////////////////////////////////////////////////////////////////

// App Includes
#include "precomp.h"
#include "main.h"
#include "resource.h"

///////////////////////////
// GVAR_LOCAL
//
// Global Variable
//
static struct GVAR_LOCAL
{
    HINSTANCE hInstance;
    HMENU     hMenu;
} GVAR_LOCAL = 
{
    NULL,
    NULL
};

////////////////////////// Function Prototypes ////////////////////////////////

static HRESULT AddTaskBarIcon(HWND    hwnd, 
                              UINT    uiIconID, 
                              UINT    uiCallBackMsg,
                              ULONG   ulStrID);

static HRESULT ModifyTaskBarIcon(HWND     hwnd, 
                                 UINT     uiNewIconID,
                                 ULONG    ulStrID);

static HRESULT DeleteTaskBarIcon(HWND     hwnd);

//////////////////////////////////////////////////////////////////////
// Tray::Init
//
HRESULT Tray::Init(HINSTANCE hInstance,
                   HWND      hwndDlg,
                   UINT      uiWindowsUserMsgId)
{ 
    HRESULT hr = S_OK;

    GVAR_LOCAL.hInstance = hInstance;

    // delete the taskbar notification area icon.
    DeleteTaskBarIcon(hwndDlg);

    // Place the icon in the taskbar notification area.
    AddTaskBarIcon(hwndDlg,
                   IDI_MONITOR,
                   uiWindowsUserMsgId,
                   0);

    // load our popup menu
    GVAR_LOCAL.hMenu = ::LoadMenu(GVAR_LOCAL.hInstance,
                                  MAKEINTRESOURCE(IDM_TRAY_POPUP_MENU));
    return hr;
}

//////////////////////////////////////////////////////////////////////
// Tray::Term
//
// Desc:       
//
HRESULT Tray::Term(HWND    hwndDlg)
{ 
    HRESULT hr = S_OK;

    // unload the popup menu

    ::DestroyMenu(GVAR_LOCAL.hMenu);
    GVAR_LOCAL.hMenu = NULL;

    // delete the tray icon.
    DeleteTaskBarIcon(hwndDlg);

    return hr;
}

//////////////////////////////////////////////////////////////////
// Tray::PopupMenu
//
//
HRESULT Tray::PopupMenu(HWND    hwndOwner)
{
    HRESULT hr              = S_OK;
    POINT   pt              = {0};   // stores mouse click
    HMENU   hmenuTrackPopup = NULL;  // pop-up menu 

    // needed to correct a bug with TrackPopupMenu in Win32
    SetForegroundWindow(hwndOwner);

    // TrackPopupMenu cannot display the top-level menu, so get 
    // the handle of the first pop-up menu. 
 
    hmenuTrackPopup = GetSubMenu(GVAR_LOCAL.hMenu, 0); 
    GetCursorPos(&pt);

    // Display the floating pop-up menu. Track the left mouse 
    // button on the assumption that this function is called 
    // during WM_CONTEXTMENU processing. 
 
    TrackPopupMenu(hmenuTrackPopup, 
                   TPM_RIGHTALIGN | TPM_LEFTBUTTON, 
                   pt.x, 
                   pt.y, 
                   0, 
                   hwndOwner, 
                   NULL); 

    // needed to correct a bug with TrackPopupMenu in Win32
    PostMessage(hwndOwner, WM_USER, 0, 0);

    return S_OK;
} 

//////////////////////////////////////////////////////////////////////
// AddTaskBarIcon
//
// Desc:       Adds an icon to the task bar.
//
// Params:     - hwnd, handle of main window.
//             - uiID,  id of icon.
//             - uiCallBackMsg, WM_USER message to send to hwnd when
//               event occurs on icon.
//             - ulStrID, string table text of tool tip to display for 
//               this icon.
//
static HRESULT AddTaskBarIcon(HWND    hwnd, 
                              UINT    uiIconID, 
                              UINT    uiCallBackMsg,
                              ULONG   ulStrID) 
{ 
    HRESULT             hr          = S_OK;
    BOOL                bRes; 
    NOTIFYICONDATA      tnid; 
    HICON               hIconHandle = NULL;
    TCHAR               szToolTip[255 + 1] = {0};

    if (ulStrID != 0)
    {
        ::LoadString(GVAR_LOCAL.hInstance,
                     ulStrID,
                     szToolTip,
                     sizeof(szToolTip) / sizeof(TCHAR));
    }

    if (SUCCEEDED(hr))
    {
        // load the specified icon.
        hIconHandle = (HICON) ::LoadImage(GVAR_LOCAL.hInstance,
                                          MAKEINTRESOURCE(uiIconID),
                                          IMAGE_ICON,
                                          16,
                                          16,
                                          LR_DEFAULTCOLOR);

        if (hIconHandle == NULL)
        {
            hr = E_FAIL;

            DBG_ERR(("AddTaskBarIcon, failed ot load icon, hr = 0x%08lx",
                     hr));
        }
    }

    if (SUCCEEDED(hr))
    {
        // add the icon to the notification tray
        tnid.cbSize           = sizeof(NOTIFYICONDATA); 
        tnid.hWnd             = hwnd; 
        tnid.uID              = MSPRJCTR_TASKBAR_ID; 
        tnid.uFlags           = NIF_MESSAGE | NIF_ICON | NIF_TIP; 
        tnid.uCallbackMessage = uiCallBackMsg; 
        tnid.hIcon            = hIconHandle; 

        if (szToolTip[0] != '\0') 
        {
            _tcsncpy(tnid.szTip, szToolTip, sizeof(tnid.szTip) / sizeof(TCHAR)); 
        }
        else 
        {
            tnid.szTip[0] = '\0'; 
        }

        bRes = Shell_NotifyIcon(NIM_ADD, &tnid); 

        if (!bRes)
        {
            hr = E_FAIL;
            DBG_ERR(("Failed to set TaskBar Icon, hr = 0x%08lx",
                    hr));
        }
    }

    if (hIconHandle) 
    {
        // destroy the icon
        DestroyIcon(hIconHandle); 
    }

    return hr; 
}

//////////////////////////////////////////////////////////////////////
// ModifyTaskBarIcon
//
// Desc:       Modifies a taskbar icon/tooltip (or both) to a new
//             one.  Note, if ulStrID is 0, then the tool tip is NOT
//             modified.  If uiNewIconID is 0, then the icon is not 
//             modified.  If both are 0, then actually nothing changes.
//             
//
// Params:     - hwnd, handle of main window.
//             - uiNewIconID, resource ID of icon to display.
//             - ulStrID, string resource ID of string to use for tooltip.
//               Note your string will be prefixed with "InterLYNX - "
//
static HRESULT ModifyTaskBarIcon(HWND     hwnd, 
                                 UINT     uiNewIconID,
                                 ULONG    ulStrID) 
{ 
    HRESULT             hr                      = S_OK;
    BOOL                bRes                    = TRUE; 
    NOTIFYICONDATA      tnid                    = {0}; 
    HICON               hIconHandle             = NULL;
    TCHAR               szToolTip[255 + 1]      = {0};
    BOOL                bContinue               = TRUE;

    if ((uiNewIconID == 0) && (ulStrID == 0))
    {
        bContinue = FALSE;
    }
    else
    {
        bContinue = TRUE;
    }

    if (bContinue)
    {
        // if we are instructed to modify the tool tip.
        if (ulStrID != 0)
        {
            ::LoadString(GVAR_LOCAL.hInstance,
                         ulStrID,
                         szToolTip,
                         sizeof(szToolTip) / sizeof(TCHAR));
        }

        // if a new icon was specified.
        if (uiNewIconID != 0)
        {
            // load the specified icon.
            hIconHandle = (HICON) ::LoadImage(GVAR_LOCAL.hInstance,
                                              MAKEINTRESOURCE(uiNewIconID),
                                              IMAGE_ICON,
                                              16,
                                              16,
                                              LR_DEFAULTCOLOR);

        }

        // add the icon to the notification tray
        tnid.cbSize = sizeof(NOTIFYICONDATA); 
        tnid.hWnd   = hwnd; 
        tnid.uID    = MSPRJCTR_TASKBAR_ID; 
        tnid.uFlags = 0; 
        tnid.hIcon  = 0; 

        if (ulStrID != 0) 
        {
            _tcsncpy(tnid.szTip, szToolTip, sizeof(tnid.szTip) / sizeof(TCHAR)); 
            tnid.uFlags = tnid.uFlags | NIF_TIP; 
        }

        if (uiNewIconID != 0)
        {
            tnid.hIcon = hIconHandle;
            tnid.uFlags = tnid.uFlags | NIF_ICON;
        }

        bRes = Shell_NotifyIcon(NIM_MODIFY, &tnid); 

        if (!bRes)
        {
            hr = E_FAIL;
            DBG_ERR(("Failed to modify taskbar icon, hr = 0x%08lx",
                    hr));
        }
    }

    if (hIconHandle) 
    {
        // destroy the icon
        DestroyIcon(hIconHandle); 
    }                  

    return hr; 
}


//////////////////////////////////////////////////////////////////////
// DeleteTaskBarIcon
//
// Desc:       Deletes a taskbar icon 
//             
//
// Params:     - hwnd, handle of main window.
//             - uiID,  id of icon.
//
static HRESULT DeleteTaskBarIcon(HWND     hwnd)
{ 
    HRESULT             hr          = S_OK;
    BOOL                bRes        = TRUE; 
    NOTIFYICONDATA      tnid        = {0}; 
    HICON               hIconHandle = NULL;

    if (SUCCEEDED(hr))
    {
        tnid.cbSize = sizeof(NOTIFYICONDATA); 
        tnid.hWnd   = hwnd; 
        tnid.uID    = MSPRJCTR_TASKBAR_ID; 
         
        bRes = Shell_NotifyIcon(NIM_DELETE, &tnid); 

        // this is not such a big deal.
        if (!bRes)
        {
            hr = E_FAIL;
        }
    }
    return hr; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\webview\camocx\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "precomp.h"
#pragma hdrstop

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\webview\camocx\precomp.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999-2001
 *
 *  TITLE:       precomp.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        5/12/99
 *
 *  DESCRIPTION: Precompiled header file for preview control
 *
 *****************************************************************************/

#ifndef _pch_h
#define _pch_h


#ifdef DBG
#ifndef DEBUG
#define DEBUG
#endif
#endif


#include <windows.h>
#include <shellapi.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <initguid.h>
#include <shlguidp.h>
#include <sti.h>
#include <mshtml.h>
#include <commctrl.h>
#include <shfusion.h>


extern HINSTANCE g_hInstance;


#include "uicommon.h"
#include "stdafx.h"
#include "wiapropui.h"
#include "shellext.h"
#include "wianew.h"
#include "pviewids.h"
#include "wia.h"
#include "wiavideo.h"
#include "wiaview.h"
#include "wiadevd.h"
#include "preview.h"
#include "cunknown.h"
#include "wiadebug.h"

#include "idlist.h"
#include "util.h"
#include "resource.h"
#include "vcamprop.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\webview\camocx\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by camocx.rc
//
#define IDS_PROJNAME                    100
#define IDB_WIACAMUI                    101
#define IDR_WIACAMUI                    102
#define IDR_PREVIEW                     109



// Video strings
#define IDS_VIDEO_BUSY_TEXT             430
#define IDS_VIDEO_BUSY_TITLE            431

// dialogs
#define IDD_INIT_DEVICE                 510
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\webview\camocx\sources.inc ===
#
# Include common build settings for WIA project
#


!include          $(PROJECT_ROOT)\ui\uienv.inc
NO_BROWSER_FILE = 1
SOURCES_USED    = $(SOURCES_USED) $(PROJECT_ROOT)\ui\uienv.inc
VIEW_DIR        = $(PROJECT_ROOT)\ui\webview
TARGETNAME      = camocx
TARGETTYPE      = DYNLINK
TARGETPATH      = obj
TARGETEXT       = dll
DLLDEF          = ..\camocx.def
DLLENTRY        = _DllMainCRTStartup
DLLBASE         = 0x10040000
USE_MSVCRT      = 1

!IF $(ALPHA)
USE_NTDLL=1
!ELSE
USE_NOLIBS=1
!ENDIF


PASS0_HEADERDIR=$(O)
PASS0_SOURCEDIR=$(O)
MIDL_UUIDDIR=$(O)
MIDL_TLBDIR=$(O)

PASS0_PUBLISH={$(O)\wiaview.h=$(PRINTSCAN_INC_PATH)\wiaview.h}

ATL_VER=30
USE_STATIC_ATL=1


INCLUDES=$(INCLUDES); \
        $(PROJECT_ROOT)\ui\shellext\inc; \
        $(BASEDIR)\public\sdk\inc\mfc42; \
        $(PROJECT_ROOT)\ui\prevwnd; \
        $(PROJECT_ROOT)\ui\uicommon; \
        $(VIEW_DIR)\inc;\
        $(VIEW_DIR)\uuid;\
        $(VIEW_DIR)\idl;\
        $(VIEW_DIR)\proxy;\
        $(PROJECT_ROOT)\ui\shellext\src;\
        $(O)


SOURCES=  ..\wiaview.idl\
          ..\camocx.cpp \
          ..\StdAfx.cpp\
          ..\preview.cpp\
          ..\camocx.rc



TARGETLIBS=$(TARGETLIBS)\
        $(SHELL_LIB_PATH)\shfusion.lib                           \
        $(PROJECT_ROOT)\ui\lib\$(PLATFORM_SUFFIX)\*\wiashext.lib \
        $(PROJECT_ROOT)\ui\shellext\lib\$(PLATFORM_SUFFIX)\*\common.lib



PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj

#
#
# Fusion manifest
#
SXS_MANIFEST_RESOURCE_ID=123
SXS_APPLICATION_MANIFEST=camocx.Manifest
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\webview\camocx\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__36E3DBF9_8876_11D2_8067_00805F6596D2__INCLUDED_)
#define AFX_STDAFX_H__36E3DBF9_8876_11D2_8067_00805F6596D2__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef STRICT
#define STRICT
#endif

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED
#ifndef _ATL_STATIC_REGISTRY
#define _ATL_STATIC_REGISTRY
#endif
#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>


//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__36E3DBF9_8876_11D2_8067_00805F6596D2__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\wiaacmgr\acqmgr.cpp ===
// acqmgr.cpp : Implementation of CAcquisitionManager
#include "precomp.h"
#include "Wiaacmgr.h"
#include "acqmgr.h"

/////////////////////////////////////////////////////////////////////////////
// CAcquisitionManager
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\webview\camocx\preview.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999 - 2001
 *
 *  TITLE:       preview.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        10/30/99
 *
 *  DESCRIPTION: Implements preview class for directshow devices in WIA
 *
 *****************************************************************************/

#include "precomp.h"
#pragma hdrstop


VOID CALLBACK PreviewTimerProc( HWND hDlg, UINT uMsg, UINT_PTR idEvent, DWORD dwTime )
{

    switch (idEvent)
    {
    case TIMER_CLOSE_DIALOG:
        WIA_TRACE((TEXT("PreviewTimerProc -- got TIMER_CLOSE_DIALOG")));
        EndDialog( hDlg, -2 );
        break;
    }
}


/*****************************************************************************

   PreviewDialogProc

   Dialog proc for preview dialog.

 *****************************************************************************/

INT_PTR CALLBACK PreviewDialogProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam )
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        {
            WIA_TRACE((TEXT("PreviewDialogProc -- WM_INITDIALOG")));
            SetTimer( hDlg, TIMER_CLOSE_DIALOG, 30000, PreviewTimerProc );

            PREVIEW_INFO_STRUCT * ppis = reinterpret_cast<PREVIEW_INFO_STRUCT *>(lParam);

            if (ppis)
            {
                ppis->hDlg = hDlg;

                if (ppis->hEvent)
                {
                    SetEvent( ppis->hEvent );
                }

            }
        }
        return TRUE;

    case PM_GOAWAY:
        WIA_TRACE((TEXT("PreviewDialogProc -- PM_GOAWAY")));
        EndDialog( hDlg, 0 );
        return TRUE;


    }

    return FALSE;
}


/*****************************************************************************

   PreviewThreadProc

   We spin a thread to put up the status dialog

 *****************************************************************************/

DWORD WINAPI PreviewThreadProc( LPVOID lpv )
{
    INT_PTR iRes;

    WIA_TRACE((TEXT("PreviewThreadProc enter")));

    iRes = DialogBoxParam( _Module.m_hInst,
                           MAKEINTRESOURCE(IDD_INIT_DEVICE),
                           NULL,
                           PreviewDialogProc,
                           reinterpret_cast<LPARAM>(lpv)
                          );

    WIA_TRACE((TEXT("IDD_INIT_DEVICE dialog returned %d"),iRes));

#ifdef DEBUG
    if (iRes==-1)
    {
        WIA_ERROR((TEXT("DialogBoxParam failed w/GLE = %d"),GetLastError()));
    }
#endif

    if (iRes < 0)
    {
        PREVIEW_INFO_STRUCT * ppis = reinterpret_cast<PREVIEW_INFO_STRUCT *>(lpv);

        if (ppis && ppis->hEvent)
        {
            SetEvent( ppis->hEvent );
        }
    }

    WIA_TRACE((TEXT("PreviewThreadProc exit")));

    return 0;

}


/*****************************************************************************

   CVideoPreview::Device

   Hand us a device pointer for the camera (or DS device) we're connected to.

 *****************************************************************************/

STDMETHODIMP
CVideoPreview::Device(IUnknown * pDevice)
{
    HRESULT hr = S_OK;

    WIA_PUSHFUNCTION((TEXT("CVideoPreview::Device")));

    // Create the WiaVideo object
     hr = CoCreateInstance(CLSID_WiaVideo, NULL, CLSCTX_INPROC_SERVER, 
                           IID_IWiaVideo, (LPVOID *)&m_pWiaVideo);

    WIA_CHECK_HR(hr,"CoCreateInstance( WiaVideo )");
    
    m_pDevice = pDevice;
    // if we've already been created, redo everything
    if (m_bCreated)
    {
        BOOL bDummy;
        OnCreate(WM_CREATE, 0, 0, bDummy);
    }
    return hr;
}


/*****************************************************************************

   CVideoPreview::InPlaceDeactivate

   Trap in place deactivate so we can unhook the dshow preview window from
   ours before both are destroyed.

 *****************************************************************************/

STDMETHODIMP
CVideoPreview::InPlaceDeactivate()
{
    HRESULT hr = E_FAIL;

    WIA_PUSHFUNCTION((TEXT("CVideoPreview::InPlaceDeactivate")));

    //
    // Make sure we have a pointer to the device...
    //

    if (m_pWiaVideo.p)
    {
        //
        // Tell the device to close the graph
        //
        m_pWiaVideo->DestroyVideo();        
        m_pWiaVideo = NULL;
    }
    else
    {
        WIA_ERROR((TEXT("m_pWiaVideo is NULL")));
    }

    //
    // Always return S_OK so that InPlaceDeactivate happens.
    //

    return S_OK;

}


/*****************************************************************************

   CVideoPreview::OnSize

   Called when our window is resized.  We want to let the streaming
   preview know we've been resized so it can reposition itself accordingly.

 *****************************************************************************/

LRESULT
CVideoPreview::OnSize(UINT , WPARAM , LPARAM lParam, BOOL& )
{
    WIA_PUSHFUNCTION((TEXT("CVideoPreview::OnSize")));

    if (m_pWiaVideo)
    {
        m_pWiaVideo->ResizeVideo(FALSE);
    }
    else
    {
        WIA_ERROR((TEXT("m_pWiaVideo is NULL!")));
    }

    return 0;
}




LRESULT
CVideoPreview::OnCreate(UINT uMsg, WPARAM wp, LPARAM lp, BOOL &bHandled)
{
    HRESULT hr = S_OK;
    WIA_PUSHFUNCTION(TEXT("CVideoPreview::OnCreate"));
    WIA_ASSERT(::IsWindow(m_hWnd));
    if (m_pDevice.p && m_pWiaVideo.p)
    {

        HANDLE hThread = NULL;
        DWORD  dwId    = 0;
        PREVIEW_INFO_STRUCT pis;

        //
        // Creating the graph can be quite time consuming, so put up
        // a dialog if it takes more than a couple of seconds.  We start
        // a thread so that the UI doesn't hang, and that thread
        // puts up UI saying the device may take a while to initialize.
        //

        pis.hDlg   = NULL;
        pis.hEvent = CreateEvent( NULL, FALSE, FALSE, NULL );

        hThread = CreateThread( NULL, 0, PreviewThreadProc, reinterpret_cast<LPVOID>(&pis), 0, &dwId );


        //
        // Tell the device to build the DShow graph
        //

        BOOL            bSuccess  = TRUE;
        HWND            hwndFore  = ::GetForegroundWindow();
        HWND            hwndFocus = ::GetFocus();
        CSimpleString   strDeviceID;
        CSimpleString   strImagesDirectory;
        CComQIPtr<IWiaItem, &IID_IWiaItem> pRootDevice(m_pDevice);

        if (pRootDevice == NULL)
        {
            hr = E_FAIL;
            bSuccess = FALSE;
        }

        //
        // Get the WIA Device ID
        //

        if (bSuccess)
        {
            bSuccess = PropStorageHelpers::GetProperty(pRootDevice, 
                                                       WIA_DIP_DEV_ID, 
                                                       strDeviceID);
        }

        //
        // Get the directory the images will be stored in.
        //
        if (bSuccess)
        {
            bSuccess = PropStorageHelpers::GetProperty(pRootDevice, 
                                                       WIA_DPV_IMAGES_DIRECTORY, 
                                                       strImagesDirectory);
        }

        //
        // Create the Video if it isn't already created.
        if (bSuccess)
        {
            if (hr == S_OK)
            {
                WIAVIDEO_STATE VideoState = WIAVIDEO_NO_VIDEO;

                //
                // Get the current state of the WiaVideo object.  If we 
                // just created it then the state will be NO_VIDEO, 
                // otherwise, it could already be previewing video,
                // in which case we shouldn't do anything.
                //
                hr = m_pWiaVideo->GetCurrentState(&VideoState);

                if (VideoState == WIAVIDEO_NO_VIDEO)
                {
                    //
                    // Set the directory we want to save our images to.  
                    // We got the image directory from the Wia Video Driver 
                    // IMAGES_DIRECTORY property
                    //
                    if (hr == S_OK)
                    {
                        hr = m_pWiaVideo->put_ImagesDirectory(CSimpleBStr(strImagesDirectory));
                    }

                    //
                    // Create the video preview as a child of the hwnd 
                    // and automatically begin playback after creating the preview.
                    //
                    if (hr == S_OK)
                    {
                        hr = m_pWiaVideo->CreateVideoByWiaDevID(CSimpleBStr(strDeviceID),
                                                                m_hWnd,
                                                                FALSE,
                                                                TRUE);
                    }
                }
            }
        }

        if (!bSuccess)
        {
            hr = E_FAIL;
        }

        if (FAILED(hr))
        {
            //
            // Let the user know that the graph is most likely already
            // in use...
            //

            ::MessageBox( NULL,
                          CSimpleString(IDS_VIDEO_BUSY_TEXT,  _Module.m_hInst),
                          CSimpleString(IDS_VIDEO_BUSY_TITLE, _Module.m_hInst ),
                          MB_OK | MB_ICONWARNING | MB_TOPMOST | MB_SETFOREGROUND
                         );


        }

        //
        // Restore foreground window & focus, as it seems the
        // active movie window does not preserve these things...
        //

        if (hwndFore)
        {
            ::SetForegroundWindow( hwndFore );
        }

        if (hwndFocus)
        {
            ::SetFocus(hwndFocus);
        }

        //
        // Tell the dialog to go away
        //

        if (hThread)
        {
            if (pis.hEvent)
            {
                //
                // Wait for 45 seconds
                //

                WaitForSingleObject( pis.hEvent, 45 * 1000 );
                if (pis.hDlg)
                {
                    ::PostMessage( pis.hDlg, PM_GOAWAY, 0, 0 );
                }

                CloseHandle( pis.hEvent );
                pis.hEvent = NULL;

            }

            CloseHandle( hThread );
            hThread = NULL;
        }
    }
    bHandled = TRUE;
    m_bCreated = TRUE;
    return 0;
}

LRESULT
CVideoPreview::OnEraseBkgnd(UINT uMsg, WPARAM wp, LPARAM lp, BOOL &bHandled)
{
    HDC hdc = (HDC)wp;
    RECT rc;
    GetClientRect(&rc);
    SetBkColor(hdc, GetSysColor(COLOR_WINDOW));
    ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rc, NULL, 0, NULL);
    bHandled = TRUE;
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\webview\camocx\preview.h ===
// Preview.h : Declaration of the CVideoPreview

#ifndef __VIDEOPREVIEW_H_
#define __VIDEOPREVIEW_H_

#include "resource.h"       // main symbols
#include <atlctl.h>


#define PM_CREATEGRAPH      (WM_USER+1)
#define PM_GOAWAY           (WM_USER+2)

#define TIMER_SHOW_DIALOG   1
#define TIMER_CLOSE_DIALOG  2

typedef struct {
    HWND   hDlg;
    HANDLE hEvent;
} PREVIEW_INFO_STRUCT;


/////////////////////////////////////////////////////////////////////////////
// CVideoPreview
class ATL_NO_VTABLE CVideoPreview :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CStockPropImpl<CVideoPreview, IVideoPreview, &IID_IVideoPreview, &LIBID_WIAVIEWLib>,
    public CComControl<CVideoPreview>,
    public IPersistStreamInitImpl<CVideoPreview>,
    public IOleControlImpl<CVideoPreview>,
    public IOleObjectImpl<CVideoPreview>,
    public IOleInPlaceActiveObjectImpl<CVideoPreview>,
    public IViewObjectExImpl<CVideoPreview>,
    public IOleInPlaceObjectWindowlessImpl<CVideoPreview>,
    public IPersistStorageImpl<CVideoPreview>,
    public ISpecifyPropertyPagesImpl<CVideoPreview>,
    public IQuickActivateImpl<CVideoPreview>,
    public IDataObjectImpl<CVideoPreview>,
    public IProvideClassInfo2Impl<&CLSID_VideoPreview, NULL, &LIBID_WIAVIEWLib>,
    public CComCoClass<CVideoPreview, &CLSID_VideoPreview>

{
public:
    CVideoPreview()
    {
        m_bWindowOnly = TRUE;
        m_bAutoSize = FALSE;
        //m_bUsingWindowRegion = TRUE;
        m_bCreated = FALSE;
        WIA_PUSHFUNCTION((TEXT("CVideoPreview::CVideoPreview")));
    }

    ~CVideoPreview()
    {
        WIA_PUSHFUNCTION((TEXT("CVideoPreview::~CVideoPreview")));
    }

DECLARE_REGISTRY_RESOURCEID(IDR_PREVIEW)

DECLARE_PROTECT_FINAL_CONSTRUCT()

// Mark this interface as safe
BEGIN_CATEGORY_MAP(CVideoPreview)
    IMPLEMENTED_CATEGORY(CATID_SafeForScripting)
    IMPLEMENTED_CATEGORY(CATID_SafeForInitializing)
END_CATEGORY_MAP()


BEGIN_COM_MAP(CVideoPreview)
    COM_INTERFACE_ENTRY(IVideoPreview)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IViewObjectEx)
    COM_INTERFACE_ENTRY(IViewObject2)
    COM_INTERFACE_ENTRY(IViewObject)
    COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceObject)
    COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY(IOleControl)
    COM_INTERFACE_ENTRY(IOleObject)
    COM_INTERFACE_ENTRY(IPersistStreamInit)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
    COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
    COM_INTERFACE_ENTRY(IQuickActivate)
    COM_INTERFACE_ENTRY(IPersistStorage)
    COM_INTERFACE_ENTRY(IDataObject)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
END_COM_MAP()

BEGIN_PROP_MAP(CVideoPreview)
    PROP_ENTRY("HWND", DISPID_HWND, CLSID_NULL)
    // Example entries
    // PROP_ENTRY("Property Description", dispid, clsid)
    // PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_MSG_MAP(CVideoPreview)
    CHAIN_MSG_MAP(CComControl<CVideoPreview>)
    MESSAGE_HANDLER(WM_SIZE, OnSize)
    MESSAGE_HANDLER(WM_CREATE,OnCreate)
    MESSAGE_HANDLER(WM_ERASEBKGND, OnEraseBkgnd)
    DEFAULT_REFLECTION_HANDLER()
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);



// IViewObjectEx
//    DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

// IOleInPlaceObject
    STDMETHOD(InPlaceDeactivate)();



// IVideoPreview
public:
    STDMETHOD(Device)(IUnknown * pDevice);
    LRESULT OnSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT OnEraseBkgnd(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

    HRESULT OnDraw(ATL_DRAWINFO& di)
    {
        return S_OK;
    }

private:
    CComPtr<IUnknown>  m_pDevice;
    CComPtr<IWiaVideo> m_pWiaVideo;
    BOOL               m_bCreated;

};

#endif //__PREVIEW_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\wiaacmgr\acqmgr.h ===
// acqmgr.h : Declaration of the CAcquisitionManager

#ifndef __AcquisitionManager_H_INCLUDED
#define __AcquisitionManager_H_INCLUDED

#include "resource.h"       // main symbols
#include "acqthrd.h"
#include "shmemsec.h"
#include "mintrans.h"
#include "stievent.h"

//
// Number of times we will spin before giving up on
// getting the window of the previous wizard's instance
//
const int c_nMaxActivationRetryCount = 40;

//
// Amount of time to wait between efforts to obtain the previous
// wizard's instance
//
const DWORD c_nActivationRetryWait   = 500;

/////////////////////////////////////////////////////////////////////////////
// CAcquisitionManager
class ATL_NO_VTABLE CAcquisitionManager :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CAcquisitionManager, &CLSID_AcquisitionManager>,
    public IWiaEventCallback
{
public:
    CAcquisitionManager()
    {
    }

    ~CAcquisitionManager()
    {
    }

DECLARE_REGISTRY_RESOURCEID(IDR_ACQUISITIONMANAGER)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CAcquisitionManager)
    COM_INTERFACE_ENTRY(IWiaEventCallback)
END_COM_MAP()

public:
    // IManager
    HRESULT STDMETHODCALLTYPE ImageEventCallback( const GUID *pEventGUID,
                                                  BSTR  bstrEventDescription,
                                                  BSTR  bstrDeviceID,
                                                  BSTR  bstrDeviceDescription,
                                                  DWORD dwDeviceType,
                                                  BSTR  bstrFullItemName,
                                                  ULONG *pulEventType,
                                                  ULONG ulReserved
                                                 )
    {
        WIA_PUSHFUNCTION((TEXT("CAcquisitionManager::ImageEventCallback")));

        //
        // Don't want to run if this is a scanner connection event
        //
        if (pEventGUID && *pEventGUID==WIA_EVENT_DEVICE_CONNECTED && GET_STIDEVICE_TYPE(dwDeviceType)==StiDeviceTypeScanner)
        {
            return S_FALSE;
        }

        //
        // Try to create or open the shared memory section.
        //
        CSharedMemorySection<HWND> *pWizardSharedMemory = new CSharedMemorySection<HWND>;
        if (pWizardSharedMemory)
        {
            //
            // Assume we'll be running the wizard.
            //
            bool bRun = true;

            //
            // If we were able to open the memory section
            //
            if (CSharedMemorySection<HWND>::SmsOpened == pWizardSharedMemory->Open( CSimpleStringConvert::NaturalString(CSimpleStringWide(bstrDeviceID)), true ))
            {
                //
                // Try to get the previous instance
                //
                for (int i=0;i<c_nMaxActivationRetryCount;i++)
                {
                    //
                    // if we were able to open the shared memory section, there is already one running.
                    // so get a mutex'ed pointer to the shared memory.
                    //
                    HWND *pHwnd = pWizardSharedMemory->Lock();
                    if (pHwnd)
                    {
                        //
                        // If we were able to get the pointer, get the window handle stored in it.
                        // Set bRun to false, so we don't start up a new wizard
                        //
                        bRun = false;
                        if (*pHwnd && IsWindow(*pHwnd))
                        {
                            //
                            // If it is a valid window, bring it to the foreground.
                            //
                            SetForegroundWindow(*pHwnd);
                        }
                        //
                        // Release the mutex
                        //
                        pWizardSharedMemory->Release();

                        //
                        // We found the window the window handle, so we can exit the loop now.
                        //
                        break;
                    }

                    //
                    // Wait a while for the previous instance to be created
                    //
                    Sleep(c_nActivationRetryWait);
                }
            }

            //
            // We only do this if we need to open a new instance
            //
            if (bRun)
            {
                //
                // Prepare the event data
                //
                CEventParameters EventParameters;
                EventParameters.EventGUID = *pEventGUID;
                EventParameters.strEventDescription = static_cast<LPCWSTR>(bstrEventDescription);
                EventParameters.strDeviceID = static_cast<LPCWSTR>(bstrDeviceID);
                EventParameters.strDeviceDescription = static_cast<LPCWSTR>(bstrDeviceDescription);
                EventParameters.ulReserved = ulReserved;
                EventParameters.ulEventType = *pulEventType;
                EventParameters.hwndParent = NULL;
                EventParameters.pWizardSharedMemory = pWizardSharedMemory;

                //
                // If we are started manually, it will be with the IID_NULL event
                // If this is the case, we are going to treat the number stored as text as
                // the "parent" window handle, over which all windows will be centered
                //
                if (pEventGUID && *pEventGUID==IID_NULL)
                {
                    EventParameters.hwndParent = reinterpret_cast<HWND>(static_cast<UINT_PTR>(WiaUiUtil::StringToLong(CSimpleStringConvert::NaturalString(CSimpleStringWide(bstrEventDescription)))));
                }

                //
                // Start up the thread that actually displays the wizard
                //
                HANDLE hThread = CAcquisitionThread::Create( EventParameters );
                if (hThread)
                {
                    //
                    // Prevent deletion of this structure later
                    //
                    pWizardSharedMemory = NULL;

                    //
                    // Don't need this anymore
                    //
                    CloseHandle(hThread);
                }
            }
            else
            {
                WIA_TRACE((TEXT("There is already an instance of %ws running"), bstrDeviceID ));
            }

            //
            // Delete this memory mapped file, to prevent leaks
            //
            if (pWizardSharedMemory)
            {
                delete pWizardSharedMemory;
            }
        }
        return S_OK;
    }
};


class ATL_NO_VTABLE CMinimalTransfer :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CMinimalTransfer, &CLSID_MinimalTransfer>,
    public IWiaEventCallback
{
public:
    CMinimalTransfer()
    {
    }

    ~CMinimalTransfer()
    {
    }

DECLARE_REGISTRY_RESOURCEID(IDR_MINIMALTRANSFER)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CMinimalTransfer)
    COM_INTERFACE_ENTRY(IWiaEventCallback)
END_COM_MAP()

public:
    // IManager
    HRESULT STDMETHODCALLTYPE ImageEventCallback( const GUID *pEventGUID,
                                                  BSTR  bstrEventDescription,
                                                  BSTR  bstrDeviceID,
                                                  BSTR  bstrDeviceDescription,
                                                  DWORD dwDeviceType,
                                                  BSTR  bstrFullItemName,
                                                  ULONG *pulEventType,
                                                  ULONG ulReserved
                                                 )
    {
        if (pEventGUID && *pEventGUID==WIA_EVENT_DEVICE_CONNECTED && GET_STIDEVICE_TYPE(dwDeviceType)==StiDeviceTypeScanner)
        {
            return S_FALSE;
        }
        DWORD dwThreadId;
        _Module.Lock();
        HANDLE hThread = CreateThread( NULL, 0, reinterpret_cast<LPTHREAD_START_ROUTINE>(MinimalTransferThreadProc), SysAllocString(bstrDeviceID), 0, &dwThreadId );
        if (hThread)
        {
            CloseHandle(hThread);
            return S_OK;
        }
        else
        {
            _Module.Unlock();
            return HRESULT_FROM_WIN32(GetLastError());
        }
    }
};


class ATL_NO_VTABLE CStiEventHandler :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CStiEventHandler, &CLSID_StiEventHandler>,
    public IWiaEventCallback
{
public:
    CStiEventHandler()
    {
    }

    ~CStiEventHandler()
    {
    }

DECLARE_REGISTRY_RESOURCEID(IDR_STIEVENTHANDLER)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CStiEventHandler)
    COM_INTERFACE_ENTRY(IWiaEventCallback)
END_COM_MAP()

public:
    HRESULT STDMETHODCALLTYPE ImageEventCallback( const GUID *pEventGUID,
                                                  BSTR  bstrEventDescription,
                                                  BSTR  bstrDeviceID,
                                                  BSTR  bstrDeviceDescription,
                                                  DWORD dwDeviceType,
                                                  BSTR  bstrFullItemName,
                                                  ULONG *pulEventType,
                                                  ULONG ulReserved
                                                 )
    {
        //
        // Package the event data for the handler
        //
        CStiEventData StiEventData( pEventGUID, bstrEventDescription, bstrDeviceID, bstrDeviceDescription, dwDeviceType, bstrFullItemName, pulEventType, ulReserved );

        //
        // Just call the handler and return it.
        //
        return StiEventHandler( StiEventData );
    }
};


#endif //__AcquisitionManager_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\wiaacmgr\acqmgrcw.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       ACQMGRCW.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        9/27/1999
 *
 *  DESCRIPTION:
 *
 *******************************************************************************/
#ifndef __ACQMGRCW_H_INCLUDED
#define __ACQMGRCW_H_INCLUDED

#include <windows.h>
#include "wia.h"
#include "evntparm.h"
#include "bkthread.h"
#include "wiaitem.h"
#include "errors.h"
#include "thrdmsg.h"
#include "thrdntfy.h"
#include "wndlist.h"
#include "shmemsec.h"
#include "wiaregst.h"
#include "wiadevdp.h"
#include "destdata.h"
#include "gwiaevnt.h"

#define REGSTR_PATH_USER_SETTINGS_WIAACMGR         REGSTR_PATH_USER_SETTINGS TEXT("\\WiaAcquisitionManager")
#define REGSTR_KEYNAME_USER_SETTINGS_WIAACMGR      TEXT("AcquisitionManagerDialogCustomSettings")
#define REG_STR_ROOTNAME_MRU                       TEXT("RootFileNameMru")
#define REG_STR_DIRNAME_MRU                        TEXT("DirectoryNameMru")
#define REG_STR_EXIT_AFTER_DOWNLOAD                TEXT("ExitAfterDownload")
#define REG_STR_LASTFORMAT                         TEXT("LastSaveAsFormat")
#define REG_STR_OPENSHELL                          TEXT("OpenShellAfterDownload")
#define REG_STR_SUPRESSFIRSTPAGE                   TEXT("SuppressFirstPage")

#define CONNECT_SOUND                              TEXT("WiaDeviceConnect")
#define DISCONNECT_SOUND                           TEXT("WiaDeviceDisconnect")

//
// We use different advanced settings for scanners and cameras, thus we store them in different places
//
#define REG_STR_STORE_IN_SUBDIRECTORY_SCANNER      TEXT("StorePicturesInSubdirectoryScanner")
#define REG_STR_SUBDIRECTORY_DATED_SCANNER         TEXT("UseDatedSubdirectoryScanner")
#define REG_STR_STORE_IN_SUBDIRECTORY_CAMERA       TEXT("StorePicturesInSubdirectoryCamera")
#define REG_STR_SUBDIRECTORY_DATED_CAMERA          TEXT("UseDatedSubdirectoryCamera")

#define ACQUISITION_MANAGER_CONTROLLER_WINDOW_CLASSNAME TEXT("AcquisitionManagerControllerWindow")
#define ACQUISITION_MANAGER_DEVICE_MUTEX_ROOT_NAME      TEXT("AcquisitionManagerDevice:")

#define STR_UPLOAD_WIZARD_MESSAGE                  TEXT("WiaUploadWizardInternalMessage")

#ifndef StiDeviceTypeStreamingVideo
#define StiDeviceTypeStreamingVideo 3
#endif

#define FE_WIAACMGR TEXT("Scanner and Camera Wizard")

//
// For handling createdevice busy errors
//
#define CREATE_DEVICE_RETRY_MAX_COUNT 10   // 10 tries
#define CREATE_DEVICE_RETRY_WAIT      1000 // 1000 Milliseconds (1 second) wait between retries


#define MAX_WIZ_PAGES                 10
//
// Private user window messages
//
#define PWM_POSTINITIALIZE       (WM_USER+0x0001)


class CAcquisitionManagerControllerWindow : public IWizardSite, IServiceProvider
{
public:
    enum CDeviceTypeMode
    {
        UnknownMode,  // This would be an error
        CameraMode,
        ScannerMode,
        VideoMode
    };

    enum
    {
        ScannerTypeUnknown    = 0,
        ScannerTypeFlatbed    = 1,
        ScannerTypeScrollFed  = 2,
        ScannerTypeFlatbedAdf = 3,
    };

    enum
    {
        OnDisconnectGotoLastpage = 0x00000001,
        OnDisconnectFailDownload = 0x00000002,
        OnDisconnectFailUpload   = 0x00000004,
        OnDisconnectFailDelete   = 0x00000008,
        DontAllowSuspend         = 0x00000100
    };
    
    typedef bool (*ComparisonCallbackFuntion)( const CWiaItem &, LPARAM lParam );

private:
    //
    // Private data
    //

public:
    //
    // Public data
    //
    CComPtr<IGlobalInterfaceTable>  m_pGlobalInterfaceTable;            // Global interface table
    CComPtr<IUnknown>               m_pConnectEventObject;              // Event object
    CComPtr<IUnknown>               m_pCreateItemEventObject;           // Event object
    CComPtr<IUnknown>               m_pDeleteItemEventObject;           // Event object
    CComPtr<IUnknown>               m_pDisconnectEventObject;           // Event object
    CComPtr<IWiaItem>               m_pWiaItemRoot;                     // Root item
    CComPtr<IWiaProgressDialog>     m_pWiaProgressDialog;               // The progress dialog, used during initialization
    CComPtr<IPublishingWizard>      m_pPublishingWizard;                // Web upload wizard
    CDestinationData                m_CurrentDownloadDestination;       // Current download destination
    CDestinationData::CNameData     m_DestinationNameData;              // Current download destination data
    CDeviceTypeMode                 m_DeviceTypeMode;                   // Which kind of device are we?
    CEventParameters               *m_pEventParameters;                 // The parameters we were started with
    CDownloadedFileInformationList  m_DownloadedFileInformationList;    // A list of filenames we have downloaded
    CSimpleEvent                    m_CancelEvent;                      // Cancel event, which is set when we want to cancel a download
    CSimpleEvent                    m_EventThumbnailCancel;             // Event that is set to cancel thumbnail download
    CSimpleEvent                    m_EventPauseBackgroundThread;       // Event that is set pause the background thread
    CSimpleString                   m_strErrorMessage;                  // Error message to be displayed by the finish page
    CSimpleStringWide               m_strwDeviceName;                   // Device name
    CSimpleStringWide               m_strwDeviceUiClassId;              // Device name
    CThreadMessageQueue            *m_pThreadMessageQueue;              // The background queue
    CWiaItem                       *m_pCurrentScannerItem;              // The scanner item from which we are transferring data
    CWiaItemList                    m_WiaItemList;                      // list of all enumerated wia items
    CWindowList                     m_WindowList;                       // The list of all the windows which are subscribing to broadcast messages
    GUID                            m_guidOutputFormat;                 // Output format
    HANDLE                          m_hBackgroundThread;                // The background worker thread
    HICON                           m_hWizardIconBig;                   // The large icon used by the wizard
    HICON                           m_hWizardIconSmall;                 // The small icon used by the wizard
    HRESULT                         m_hrDownloadResult;                 // HRESULT for the entire download
    HRESULT                         m_hrUploadResult;                   // HRESULT for the entire upload
    HRESULT                         m_hrDeleteResult;                   // HRESULT for the entire deletion
    HWND                            m_hWndWizard;                       // HWND of the main wizard window
    LONG                            m_cRef;                             // Reference count
    LONG                            m_nDeviceType;                      // STI Device type
    SIZE                            m_sizeThumbnails;                   // The size of camera thumbnails
    TCHAR                           m_szDestinationDirectory[MAX_PATH]; // The directory to which we are going to download the images
    TCHAR                           m_szRootFileName[MAX_PATH];         // Base file name
    UINT                            m_nThreadNotificationMessage;       // Registered window message, used to identify worker thread notification messages
    UINT                            m_nUploadWizardPageCount;           // Number of pages in the web upload wizard
    UINT                            m_nWiaEventMessage;                 // Registered window message, used to identify event messages
    UINT                            m_nWiaWizardPageCount;              // Number of pages in the WIA wizard
    UINT                            m_OnDisconnect;                     // Flags which specify behavior on receipt of disconnect event
    bool                            m_bDeletePicturesIfSuccessful;      // Set to true if we should delete the pictures when we are done
    bool                            m_bDisconnected;                    // Set to true if the device has been disconnected
    bool                            m_bOpenShellAfterDownload;          // Set to true to open the shell after we download all of the pictures
    bool                            m_bStampTimeOnSavedFiles;           // Set to true to save the time on files
    bool                            m_bSuppressFirstPage;               // Set to true to suppress display of the welcome page
    bool                            m_bTakePictureIsSupported;          // Set to true if the device supports the TAKE PICTURE command
    bool                            m_bUploadToWeb;                     // Set to true to chain NETPLWIZ
    bool                            m_bDownloadCancelled;               // Set to true to cancel the web upload
    bool                            m_bUpdateEnumerationCount;          // Update the count of images during enumeration.  We suppress update for scanners.
    int                             m_nDestinationPageIndex;            // The index, in the HPROPSHEETPAGE array, of the destination page
    int                             m_nSelectionPageIndex;              // The index, in the HPROPSHEETPAGE array, of the selection page
    int                             m_nFailedImagesCount;               // Count of all download failures
    int                             m_nFinishPageIndex;                 // The index, in the HPROPSHEETPAGE array, of the finish page
    int                             m_nProgressPageIndex;               // The index, in the HPROPSHEETPAGE array, of the download progress page
    int                             m_nUploadQueryPageIndex;            // The index, in the HPROPSHEETPAGE array, of the upload progress page
    int                             m_nDeleteProgressPageIndex;         // The index, in the HPROPSHEETPAGE array, of the delete progress page
    int                             m_nScannerType;                     // What type of scanner are we dealing with?
    HWND                            m_hWnd;                             // Our hidden window
    DWORD                           m_dwLastEnumerationTickCount;       // To ensure we don't update the progress dialog too often
    HPROPSHEETPAGE                  m_PublishWizardPages[MAX_WIZ_PAGES];

private:
    //
    // No implementation
    //
    CAcquisitionManagerControllerWindow(void);
    CAcquisitionManagerControllerWindow( const CAcquisitionManagerControllerWindow & );
    CAcquisitionManagerControllerWindow &operator=( const CAcquisitionManagerControllerWindow & );

private:
    //
    // Constructor and destructor
    //
    explicit CAcquisitionManagerControllerWindow( HWND hWnd );
    virtual ~CAcquisitionManagerControllerWindow(void);

    //
    // Private helper functions
    //
    HRESULT CreateDevice(void);
    void GetCookiesOfSelectedImages( CWiaItem *pCurr, CSimpleDynamicArray<DWORD> &Cookies );
    void GetRotationOfSelectedImages( CWiaItem *pCurr, CSimpleDynamicArray<int> &Rotation );
    void GetCookiesOfAllImages( CWiaItem *pCurr, CSimpleDynamicArray<DWORD> &Cookies );
    void GetSelectedItems( CWiaItem *pCurr, CSimpleDynamicArray<CWiaItem*> &Items );
    void MarkAllItemsUnselected( CWiaItem *pCurrItem );
    void MarkItemSelected( CWiaItem *pItem, CWiaItem *pCurrItem );
    HRESULT CreateAndExecuteWizard(void);
    void DetermineScannerType(void);
    void AddNewItemToList( CGenericWiaEventHandler::CEventMessage *pEventMessage );
    void RequestThumbnailForNewItem( CGenericWiaEventHandler::CEventMessage *pEventMessage );
    static bool EnumItemsCallback( CWiaItemList::CEnumEvent EnumEvent, UINT nData, LPARAM lParam, bool bForceUpdate );

    //
    // Standard windows message handlers
    //
    LRESULT OnCreate( WPARAM, LPARAM lParam );
    LRESULT OnDestroy( WPARAM, LPARAM );
    LRESULT OnPowerBroadcast( WPARAM, LPARAM );

    //
    // Custom windows message handlers
    //
    LRESULT OnPostInitialize( WPARAM, LPARAM );
    LRESULT OnOldThreadNotification( WPARAM, LPARAM );
    LRESULT OnThreadNotification( WPARAM, LPARAM );

    //
    // Thread notification handlers
    //
    void OnNotifyDownloadThumbnail( UINT nMsg, CThreadNotificationMessage *pThreadNotificationMessage );
    void OnNotifyDownloadImage( UINT nMsg, CThreadNotificationMessage *pThreadNotificationMessage );
    LRESULT OnEventNotification( WPARAM wParam, LPARAM lParam );

    //
    // Thread message handlers
    //
    static BOOL WINAPI OnThreadDestroy( CThreadMessage *pMsg );
    static BOOL WINAPI OnThreadDownloadImage( CThreadMessage *pMsg );
    static BOOL WINAPI OnThreadDownloadThumbnail( CThreadMessage *pMsg );
    static BOOL WINAPI OnThreadPreviewScan( CThreadMessage *pMsg );
    static BOOL WINAPI OnThreadDeleteImages( CThreadMessage *pMsg );
private:
    //
    // Window procedure
    //
    static LRESULT CALLBACK WndProc( HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam );

    //
    // Property sheet callback
    //
    static int CALLBACK PropSheetCallback( HWND hWnd, UINT uMsg, LPARAM lParam );

public:

    //
    // Public functions
    //
    static bool IsCameraThumbnailDownloaded( const CWiaItem &WiaItem, LPARAM lParam );
    int GetCookies( CSimpleDynamicArray<DWORD> &Cookies, CWiaItem *pCurr, ComparisonCallbackFuntion pfnCallback, LPARAM lParam );
    bool DownloadSelectedImages( HANDLE hCancelDownloadEvent );
    bool DeleteDownloadedImages( HANDLE hCancelDeleteEvent );
    bool DeleteSelectedImages(void);
    void DownloadAllThumbnails(void);
    void SetMainWindowInSharedMemory( HWND hWnd );
    bool PerformPreviewScan( CWiaItem *pItem, HANDLE hCancelPreviewEvent );
    bool GetAllImageItems( CSimpleDynamicArray<CWiaItem*> &Items, CWiaItem *pCurr );
    bool GetAllImageItems( CSimpleDynamicArray<CWiaItem*> &Items );
    bool CanSomeSelectedImagesBeDeleted(void);
    BOOL ConfirmWizardCancel( HWND hWndParent );
    static bool DirectoryExists( LPCTSTR pszDirectoryName );
    static bool RecursiveCreateDirectory( CSimpleString strDirectoryName );
    static CSimpleString GetCurrentDate(void);
    void DisplayDisconnectMessageAndExit(void);
    CWiaItem *FindItemByName( LPCWSTR pwszItemName );
    int GetSelectedImageCount(void);
    bool SuppressFirstPage(void);
    bool IsSerialCamera(void);

public:

    //
    // Public creation functions
    //
    static bool Register( HINSTANCE hInstance );
    static HWND Create( HINSTANCE hInstance, CEventParameters *pEventParameters );

    //
    // IUnknown
    //
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);

    //
    // IWizardSite
    //
    STDMETHODIMP GetPreviousPage(HPROPSHEETPAGE *phPage);
    STDMETHODIMP GetNextPage(HPROPSHEETPAGE *phPage);
    STDMETHODIMP GetCancelledPage(HPROPSHEETPAGE *phPage);
    
    //
    // IServiceProvider
    //
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);
};


#endif //__ACQMGRCW_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\wiaacmgr\atl.cpp ===
// atl.cpp : source file that includes just the standard includes
// precomp.pch will be the pre-compiled header
// precomp.obj will contain the pre-compiled type information

#include "precomp.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\ui\wiaacmgr\acqmgrcw.cpp ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       ACQMGRCW.CPP
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        9/27/1999
 *
 *  DESCRIPTION:
 *
 *******************************************************************************/
#include "precomp.h"
#pragma hdrstop
#include <windows.h>
#include <simcrack.h>
#include <commctrl.h>
#include <wiatextc.h>
#include <pviewids.h>
#include <commctrl.h>
#include "resource.h"
#include "acqmgrcw.h"
#include "wia.h"
#include "wiadevdp.h"
#include "evntparm.h"
#include "itranhlp.h"
#include "bkthread.h"
#include "wiaitem.h"
#include "errors.h"
#include "isuppfmt.h"
#include "uiexthlp.h"
#include "gphelper.h"
#include "svselfil.h"
#include "gwiaevnt.h"
#include "modlock.h"
#include "comfin.h"
#include "comprog.h"
#include "upquery.h"
#include "comdelp.h"
#include "devprop.h"
#include "mboxex.h"
#include "dumpprop.h"
#include "psutil.h"

#undef TRY_SMALLER_THUMBNAILS

#if defined(TRY_SMALLER_THUMBNAILS)

static const int c_nDefaultThumbnailWidth   =  80;
static const int c_nDefaultThumbnailHeight  =  80;

static const int c_nMaxThumbnailWidth       = 80;
static const int c_nMaxThumbnailHeight      = 80;

static const int c_nMinThumbnailWidth       = 80;
static const int c_nMinThumbnailHeight      = 80;

#else

static const int c_nDefaultThumbnailWidth   =  90;
static const int c_nDefaultThumbnailHeight  =  90;

static const int c_nMaxThumbnailWidth       = 120;
static const int c_nMaxThumbnailHeight      = 120;

static const int c_nMinThumbnailWidth       = 80;
static const int c_nMinThumbnailHeight      = 80;


#endif

//
// Property sheet pages' window class declarations
//
#include "comfirst.h"
#include "camsel.h"
#include "comtrans.h"
#include "scansel.h"

// -------------------------------------------------
// CAcquisitionManagerControllerWindow
// -------------------------------------------------
CAcquisitionManagerControllerWindow::CAcquisitionManagerControllerWindow( HWND hWnd )
  : m_hWnd(hWnd),
    m_pEventParameters(NULL),
    m_DeviceTypeMode(UnknownMode),
    m_hWizardIconSmall(NULL),
    m_hWizardIconBig(NULL),
    m_guidOutputFormat(IID_NULL),
    m_bDeletePicturesIfSuccessful(false),
    m_nThreadNotificationMessage(RegisterWindowMessage(STR_THREAD_NOTIFICATION_MESSAGE)),
    m_nWiaEventMessage(RegisterWindowMessage(STR_WIAEVENT_NOTIFICATION_MESSAGE)),
    m_bDisconnected(false),
    m_pThreadMessageQueue(NULL),
    m_bStampTimeOnSavedFiles(true),
    m_bOpenShellAfterDownload(true),
    m_bSuppressFirstPage(false),
    m_nFailedImagesCount(0),
    m_nDestinationPageIndex(-1),
    m_nFinishPageIndex(-1),
    m_nDeleteProgressPageIndex(-1),
    m_nSelectionPageIndex(-1),
    m_hWndWizard(NULL),
    m_bTakePictureIsSupported(false),
    m_nWiaWizardPageCount(0),
    m_nUploadWizardPageCount(0),
    m_bUploadToWeb(false),
    m_cRef(1),
    m_nScannerType(ScannerTypeUnknown),
    m_OnDisconnect(0),
    m_dwLastEnumerationTickCount(0)
{
    WIA_PUSHFUNCTION(TEXT("CAcquisitionManagerControllerWindow::CAcquisitionManagerControllerWindow"));

    // This sets up the map that maps thread messages to message handlers, which are declared to be static
    // member functions.
    static CThreadMessageMap s_MsgMap[] =
    {
        { TQ_DESTROY, OnThreadDestroy},
        { TQ_DOWNLOADIMAGE, OnThreadDownloadImage},
        { TQ_DOWNLOADTHUMBNAIL, OnThreadDownloadThumbnail},
        { TQ_SCANPREVIEW, OnThreadPreviewScan},
        { TQ_DELETEIMAGES, OnThreadDeleteImages},
        { 0, NULL}
    };

    // Assume the default thumbnail size, in case we aren't able to calculate it
    m_sizeThumbnails.cx = c_nDefaultThumbnailWidth;
    m_sizeThumbnails.cy = c_nDefaultThumbnailHeight;

    //
    // Read the initial settings
    //
    CSimpleReg reg( HKEY_CURRENT_USER, REGSTR_PATH_USER_SETTINGS_WIAACMGR, false, KEY_READ );
    m_bOpenShellAfterDownload = (reg.Query( REG_STR_OPENSHELL, m_bOpenShellAfterDownload ) != FALSE);
    m_bSuppressFirstPage = (reg.Query( REG_STR_SUPRESSFIRSTPAGE, m_bSuppressFirstPage ) != FALSE);

    //
    // Initialize the background thread queue, which will handle all of our background requests
    //
    m_pThreadMessageQueue = new CThreadMessageQueue;
    if (m_pThreadMessageQueue)
    {
        //
        // Note that CBackgroundThread takes ownership of m_pThreadMessageQueue, and it doesn't have to be deleted in this thread
        //
        m_hBackgroundThread = CBackgroundThread::Create( m_pThreadMessageQueue, s_MsgMap, m_CancelEvent.Event(), NULL );
    }

    ZeroMemory( m_PublishWizardPages, sizeof(m_PublishWizardPages) );
}

CAcquisitionManagerControllerWindow::~CAcquisitionManagerControllerWindow(void)
{
    WIA_PUSHFUNCTION(TEXT("CAcquisitionManagerControllerWindow::~CAcquisitionManagerControllerWindow"));
    if (m_pEventParameters)
    {
        if (m_pEventParameters->pWizardSharedMemory)
        {
            delete m_pEventParameters->pWizardSharedMemory;
        }
        m_pEventParameters = NULL;
    }

}

LRESULT CAcquisitionManagerControllerWindow::OnDestroy( WPARAM, LPARAM )
{
    WIA_PUSHFUNCTION(TEXT("CAcquisitionManagerControllerWindow::OnDestroy"));

    //
    // Tell the publishing wizard to release us
    //
    if (m_pPublishingWizard)
    {
        IUnknown_SetSite( m_pPublishingWizard, NULL );
    }

    //
    // Release the publishing wizard and its data
    //
    m_pPublishingWizard = NULL;

    //
    // Stop downloading thumbnails
    //
    m_EventThumbnailCancel.Signal();

    //
    // Unpause the background thread
    //
    m_EventPauseBackgroundThread.Signal();

    //
    // Tell the background thread to destroy itself
    //
    m_pThreadMessageQueue->Enqueue( new CThreadMessage(TQ_DESTROY),CThreadMessageQueue::PriorityUrgent);

    //
    // Issue a cancel io command for this item
    //
    WiaUiUtil::IssueWiaCancelIO(m_pWiaItemRoot);

    //
    // Tell other instances we are done before the background thread is finished,
    // so we can immediately start again
    //
    if (m_pEventParameters && m_pEventParameters->pWizardSharedMemory)
    {
        m_pEventParameters->pWizardSharedMemory->Close();
    }

    //
    // Wait for the thread to exit
    //
    WiaUiUtil::MsgWaitForSingleObject( m_hBackgroundThread, INFINITE );
    CloseHandle( m_hBackgroundThread );

    //
    // Clean up the icons
    //
    if (m_hWizardIconSmall)
    {
        DestroyIcon( m_hWizardIconSmall );
        m_hWizardIconSmall = NULL;
    }
    if (m_hWizardIconBig)
    {
        DestroyIcon( m_hWizardIconBig );
        m_hWizardIconBig = NULL;
    }

    return 0;
}

BOOL WINAPI CAcquisitionManagerControllerWindow::OnThreadDestroy( CThreadMessage *pMsg )
{
    WIA_PUSHFUNCTION(TEXT("CAcquisitionManagerControllerWindow::OnThreadDestroy"));
    // Return false to close the queue
    return FALSE;
}


BOOL WINAPI CAcquisitionManagerControllerWindow::OnThreadDownloadImage( CThreadMessage *pMsg )
{
    CDownloadImagesThreadMessage *pDownloadImageThreadMessage = dynamic_cast<CDownloadImagesThreadMessage*>(pMsg);
    if (pDownloadImageThreadMessage)
    {
        pDownloadImageThreadMessage->Download();
    }
    else
    {
        WIA_ERROR((TEXT("pDownloadImageThreadMessage was NULL")));
    }
    return TRUE;
}

BOOL WINAPI CAcquisitionManagerControllerWindow::OnThreadDownloadThumbnail( CThreadMessage *pMsg )
{
    CDownloadThumbnailsThreadMessage *pDownloadThumnailsThreadMessage = dynamic_cast<CDownloadThumbnailsThreadMessage*>(pMsg);
    if (pDownloadThumnailsThreadMessage)
    {
        pDownloadThumnailsThreadMessage->Download();
    }
    else
    {
        WIA_ERROR((TEXT("pDownloadThumnailThreadMessage was NULL")));
    }
    return TRUE;
}


BOOL WINAPI CAcquisitionManagerControllerWindow::OnThreadPreviewScan( CThreadMessage *pMsg )
{
    CPreviewScanThreadMessage *pPreviewScanThreadMessage = dynamic_cast<CPreviewScanThreadMessage*>(pMsg);
    if (pPreviewScanThreadMessage)
    {
        pPreviewScanThreadMessage->Scan();
    }
    else
    {
        WIA_ERROR((TEXT("pPreviewScanThreadMessage was NULL")));
    }
    return TRUE;
}

BOOL WINAPI CAcquisitionManagerControllerWindow::OnThreadDeleteImages( CThreadMessage *pMsg )
{
    CDeleteImagesThreadMessage *pDeleteImagesThreadMessage = dynamic_cast<CDeleteImagesThreadMessage*>(pMsg);
    if (pDeleteImagesThreadMessage)
    {
        pDeleteImagesThreadMessage->DeleteImages();
    }
    else
    {
        WIA_ERROR((TEXT("pPreviewScanThreadMessage was NULL")));
    }
    return TRUE;
}

HRESULT CAcquisitionManagerControllerWindow::CreateDevice(void)
{
    WIA_PUSHFUNCTION(TEXT("CAcquisitionManagerControllerWindow::CreateDevice"));
    CComPtr<IWiaDevMgr> pWiaDevMgr;
    HRESULT hr = CoCreateInstance( CLSID_WiaDevMgr, NULL, CLSCTX_LOCAL_SERVER, IID_IWiaDevMgr, (void**)&pWiaDevMgr );
    if (SUCCEEDED(hr))
    {
        bool bRetry = true;
        for (DWORD dwRetryCount = 0;dwRetryCount < CREATE_DEVICE_RETRY_MAX_COUNT && bRetry;dwRetryCount++)
        {
            hr = pWiaDevMgr->CreateDevice( CSimpleBStr(m_pEventParameters->strDeviceID), &m_pWiaItemRoot );
            WIA_PRINTHRESULT((hr,TEXT("pWiaDevMgr->CreateDevice returned")));
            if (SUCCEEDED(hr))
            {
                //
                // Break out of loop
                //
                bRetry = false;

                //
                // Register for events
                //
                CGenericWiaEventHandler::RegisterForWiaEvent( m_pEventParameters->strDeviceID, WIA_EVENT_DEVICE_DISCONNECTED, &m_pDisconnectEventObject, m_hWnd, m_nWiaEventMessage );
                CGenericWiaEventHandler::RegisterForWiaEvent( m_pEventParameters->strDeviceID, WIA_EVENT_ITEM_DELETED, &m_pDeleteItemEventObject, m_hWnd, m_nWiaEventMessage );
                CGenericWiaEventHandler::RegisterForWiaEvent( m_pEventParameters->strDeviceID, WIA_EVENT_DEVICE_CONNECTED, &m_pConnectEventObject, m_hWnd, m_nWiaEventMessage );
                CGenericWiaEventHandler::RegisterForWiaEvent( m_pEventParameters->strDeviceID, WIA_EVENT_ITEM_CREATED, &m_pCreateItemEventObject, m_hWnd, m_nWiaEventMessage );
            }
            else if (WIA_ERROR_BUSY == hr)
            {
                //
                // Wait a little while before retrying
                //
                Sleep(CREATE_DEVICE_RETRY_WAIT);
            }
            else
            {
                //
                // All other errors are considered fatal
                //
                bRetry = false;
            }
        }
    }
    return hr;
}

void CAcquisitionManagerControllerWindow::GetCookiesOfSelectedImages( CWiaItem *pCurr, CSimpleDynamicArray<DWORD> &Cookies )
{
    while (pCurr)
    {
        GetCookiesOfSelectedImages(pCurr->Children(),Cookies);
        if (pCurr->IsDownloadableItemType() && pCurr->SelectedForDownload())
        {
            Cookies.Append(pCurr->GlobalInterfaceTableCookie());
        }
        pCurr = pCurr->Next();
    }
}

void CAcquisitionManagerControllerWindow::MarkAllItemsUnselected( CWiaItem *pCurrItem )
{
    while (pCurrItem)
    {
        pCurrItem->SelectedForDownload(false);
        MarkAllItemsUnselected( pCurrItem->Children() );
        pCurrItem = pCurrItem->Next();
    }
}

void CAcquisitionManagerControllerWindow::MarkItemSelected( CWiaItem *pItem, CWiaItem *pCurrItem )
{
    while (pCurrItem)
    {
        if (pItem == pCurrItem && !pCurrItem->Deleted())
        {
            pCurrItem->SelectedForDownload(true);
        }
        MarkItemSelected( pItem, pCurrItem->Children() );
        pCurrItem = pCurrItem->Next();
    }
}

void CAcquisitionManagerControllerWindow::GetSelectedItems( CWiaItem *pCurr, CSimpleDynamicArray<CWiaItem*> &Items )
{
    while (pCurr)
    {
        GetSelectedItems(pCurr->Children(),Items);
        if (pCurr->IsDownloadableItemType() && pCurr->SelectedForDownload())
        {
            Items.Append(pCurr);
        }
        pCurr = pCurr->Next();
    }
}

void CAcquisitionManagerControllerWindow::GetRotationOfSelectedImages( CWiaItem *pCurr, CSimpleDynamicArray<int> &Rotation )
{
    while (pCurr)
    {
        GetRotationOfSelectedImages(pCurr->Children(),Rotation);
        if (pCurr->IsDownloadableItemType() && pCurr->SelectedForDownload())
        {
            Rotation.Append(pCurr->Rotation());
        }
        pCurr = pCurr->Next();
    }
}

void CAcquisitionManagerControllerWindow::GetCookiesOfAllImages( CWiaItem *pCurr, CSimpleDynamicArray<DWORD> &Cookies )
{
    while (pCurr)
    {
        GetCookiesOfAllImages(pCurr->Children(),Cookies);
        if (pCurr->IsDownloadableItemType())
        {
            Cookies.Append(pCurr->GlobalInterfaceTableCookie());
        }
        pCurr = pCurr->Next();
    }
}


int CAcquisitionManagerControllerWindow::GetSelectedImageCount( void )
{
    CSimpleDynamicArray<DWORD> Cookies;
    CSimpleDynamicArray<int> Rotation;
    GetCookiesOfSelectedImages( m_WiaItemList.Root(), Cookies );
    GetRotationOfSelectedImages( m_WiaItemList.Root(), Rotation );
    if (Rotation.Size() != Cookies.Size())
    {
        return 0;
    }
    return Cookies.Size();
}

bool CAcquisitionManagerControllerWindow::DeleteDownloadedImages( HANDLE hCancelDeleteEvent )
{
    //
    // Make sure we are not paused
    //
    m_EventPauseBackgroundThread.Signal();

    CSimpleDynamicArray<DWORD> Cookies;
    for (int i=0;i<m_DownloadedFileInformationList.Size();i++)
    {
        Cookies.Append(m_DownloadedFileInformationList[i].Cookie());
    }
    if (Cookies.Size())
    {
        CDeleteImagesThreadMessage *pDeleteImageThreadMessage = new CDeleteImagesThreadMessage(
                                                                                                m_hWnd,
                                                                                                Cookies,
                                                                                                hCancelDeleteEvent,
                                                                                                m_EventPauseBackgroundThread.Event(),
                                                                                                true
                                                                                                );
        if (pDeleteImageThreadMessage)
        {
            m_pThreadMessageQueue->Enqueue( pDeleteImageThreadMessage, CThreadMessageQueue::PriorityNormal );
        }
        else
        {
            WIA_TRACE((TEXT("Uh-oh!  Couldn't allocate the thread message")));
            return false;
        }
    }
    else
    {
        WIA_TRACE((TEXT("Uh-oh!  No selected items! Cookies.Size() = %d"), Cookies.Size()));
        return false;
    }
    return true;
}

bool CAcquisitionManagerControllerWindow::DeleteSelectedImages(void)
{
    WIA_PUSHFUNCTION(TEXT("CAcquisitionManagerControllerWindow::DeleteSelectedImages"));
    CSimpleDynamicArray<DWORD> Cookies;
    GetCookiesOfSelectedImages( m_WiaItemList.Root(), Cookies );

    //
    // Make sure we are not paused
    //
    m_EventPauseBackgroundThread.Signal();

    if (Cookies.Size())
    {
        CDeleteImagesThreadMessage *pDeleteImageThreadMessage = new CDeleteImagesThreadMessage(
                                                                                                m_hWnd,
                                                                                                Cookies,
                                                                                                NULL,
                                                                                                m_EventPauseBackgroundThread.Event(),
                                                                                                false
                                                                                                );
        if (pDeleteImageThreadMessage)
        {
            m_pThreadMessageQueue->Enqueue( pDeleteImageThreadMessage, CThreadMessageQueue::PriorityNormal );
        }
        else
        {
            WIA_TRACE((TEXT("Uh-oh!  Couldn't allocate the thread message")));
            return false;
        }
    }
    else
    {
        WIA_TRACE((TEXT("Uh-oh!  No selected items! Cookies.Size() = %d"), Cookies.Size()));
        return false;
    }
    return true;
}

bool CAcquisitionManagerControllerWindow::DownloadSelectedImages( HANDLE hCancelDownloadEvent )
{
    WIA_PUSHFUNCTION(TEXT("CAcquisitionManagerControllerWindow::DownloadSelectedImages"));
    CSimpleDynamicArray<DWORD> Cookies;
    CSimpleDynamicArray<int> Rotation;
    GetCookiesOfSelectedImages( m_WiaItemList.Root(), Cookies );
    GetRotationOfSelectedImages( m_WiaItemList.Root(), Rotation );

    //
    // Make sure we are not paused
    //
    m_EventPauseBackgroundThread.Signal();

    if (Cookies.Size() && Rotation.Size() == Cookies.Size())
    {
        CDownloadImagesThreadMessage *pDownloadImageThreadMessage = new CDownloadImagesThreadMessage(
                                                                                                    m_hWnd,
                                                                                                    Cookies,
                                                                                                    Rotation,
                                                                                                    m_szDestinationDirectory,
                                                                                                    m_szRootFileName,
                                                                                                    m_guidOutputFormat,
                                                                                                    hCancelDownloadEvent,
                                                                                                    m_bStampTimeOnSavedFiles,
                                                                                                    m_EventPauseBackgroundThread.Event()
                                                                                                    );
        if (pDownloadImageThreadMessage)
        {
            m_pThreadMessageQueue->Enqueue( pDownloadImageThreadMessage, CThreadMessageQueue::PriorityNormal );
        }
        else
        {
            WIA_TRACE((TEXT("Uh-oh!  Couldn't allocate the thread message")));
            return false;
        }
    }
    else
    {
        WIA_TRACE((TEXT("Uh-oh!  No selected items! Cookies.Size() = %d, Rotation.Size() = %d"), Cookies.Size(), Rotation.Size()));
        return false;
    }
    return true;
}


bool CAcquisitionManagerControllerWindow::DirectoryExists( LPCTSTR pszDirectoryName )
{
    // Try to determine if this directory exists
    DWORD dwFileAttributes = GetFileAttributes(pszDirectoryName);
    if (dwFileAttributes == 0xFFFFFFFF || !(dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        return false;
    else return true;
}

bool CAcquisitionManagerControllerWindow::RecursiveCreateDirectory( CSimpleString strDirectoryName )
{
    // If this directory already exists, return true.
    if (DirectoryExists(strDirectoryName))
        return true;
    // Otherwise try to create it.
    CreateDirectory(strDirectoryName,NULL);
    // If it now exists, return true
    if (DirectoryExists(strDirectoryName))
        return true;
    else
    {
        // Remove the last subdir and try again
        int nFind = strDirectoryName.ReverseFind(TEXT('\\'));
        if (nFind >= 0)
        {
            RecursiveCreateDirectory( strDirectoryName.Left(nFind) );
            // Now try to create it.
            CreateDirectory(strDirectoryName,NULL);
        }
    }
    //Does it exist now?
    return DirectoryExists(strDirectoryName);
}

bool CAcquisitionManagerControllerWindow::IsCameraThumbnailDownloaded( const CWiaItem &WiaItem, LPARAM lParam )
{
    CAcquisitionManagerControllerWindow *pControllerWindow = reinterpret_cast<CAcquisitionManagerControllerWindow*>(lParam);
    if (pControllerWindow &&
        (pControllerWindow->m_DeviceTypeMode==CameraMode || pControllerWindow->m_DeviceTypeMode==VideoMode) &&
        WiaItem.IsDownloadableItemType() &&
        !WiaItem.BitmapData())
    {
        return true;
    }
    else
    {
        return false;
    }
}

int CAcquisitionManagerControllerWindow::GetCookies( CSimpleDynamicArray<DWORD> &Cookies, CWiaItem *pCurr, ComparisonCallbackFuntion pfnCallback, LPARAM lParam )
{
    while (pCurr)
    {
        GetCookies(Cookies, pCurr->Children(), pfnCallback, lParam );
        if (pfnCallback && pfnCallback(*pCurr,lParam))
        {
            Cookies.Append(pCurr->GlobalInterfaceTableCookie());
        }
        pCurr = pCurr->Next();
    }
    return Cookies.Size();
}

// Download all of the camera's thumbnails that haven't been downloaded yet
void CAcquisitionManagerControllerWindow::DownloadAllThumbnails()
{
    //
    // Get all of the images in the device
    //
    CSimpleDynamicArray<DWORD> Cookies;
    GetCookies( Cookies, m_WiaItemList.Root(), IsCameraThumbnailDownloaded, reinterpret_cast<LPARAM>(this) );
    if (Cookies.Size())
    {
        m_EventThumbnailCancel.Reset();
        CDownloadThumbnailsThreadMessage *pDownloadThumbnailsThreadMessage = new CDownloadThumbnailsThreadMessage( m_hWnd, Cookies, m_EventThumbnailCancel.Event() );
        if (pDownloadThumbnailsThreadMessage)
        {
            m_pThreadMessageQueue->Enqueue( pDownloadThumbnailsThreadMessage, CThreadMessageQueue::PriorityNormal );
        }
    }
}

bool CAcquisitionManagerControllerWindow::PerformPreviewScan( CWiaItem *pWiaItem, HANDLE hCancelPreviewEvent )
{
    WIA_PUSHFUNCTION(TEXT("CAcquisitionManagerControllerWindow::PerformPreviewScan"));
    if (pWiaItem)
    {
        CPreviewScanThreadMessage *pPreviewScanThreadMessage = new CPreviewScanThreadMessage( m_hWnd, pWiaItem->GlobalInterfaceTableCookie(), hCancelPreviewEvent );
        if (pPreviewScanThreadMessage)
        {
            m_pThreadMessageQueue->Enqueue( pPreviewScanThreadMessage, CThreadMessageQueue::PriorityNormal );
            return true;
        }
    }
    return false;
}

void CAcquisitionManagerControllerWindow::DisplayDisconnectMessageAndExit(void)
{
    //
    // Make sure we are not doing this more than once
    //
    if (!m_bDisconnected)
    {
        //
        // Don't do this again
        //
        m_bDisconnected = true;

        //
        // Close the shared memory section so another instance can start up
        //
        if (m_pEventParameters && m_pEventParameters->pWizardSharedMemory)
        {
            m_pEventParameters->pWizardSharedMemory->Close();
        }

        if (m_OnDisconnect & OnDisconnectFailDownload)
        {
            //
            // Set an appropriate error message
            //
            m_hrDownloadResult = WIA_ERROR_OFFLINE;
            m_strErrorMessage.LoadString( IDS_DEVICE_DISCONNECTED, g_hInstance );
        }

        if ((m_OnDisconnect & OnDisconnectGotoLastpage) && m_hWndWizard)
        {
            //
            // Find any active dialogs and close them
            //
            HWND hWndLastActive = GetLastActivePopup(m_hWndWizard);
            if (hWndLastActive && hWndLastActive != m_hWndWizard)
            {
                SendMessage( hWndLastActive, WM_CLOSE, 0, 0 );
            }

            //
            // Go to the finish page
            //
            PropSheet_SetCurSelByID( m_hWndWizard, IDD_COMMON_FINISH );
        }
    }
}

void CAcquisitionManagerControllerWindow::SetMainWindowInSharedMemory( HWND hWnd )
{
    //
    // Try to grab the mutex
    //
    if (m_pEventParameters && m_pEventParameters->pWizardSharedMemory)
    {
        HWND *pHwnd = m_pEventParameters->pWizardSharedMemory->Lock();
        if (pHwnd)
        {
            //
            // Save the hWnd
            //
            *pHwnd = hWnd;

            //
            // Release the mutex
            //
            m_pEventParameters->pWizardSharedMemory->Release();
        }

        m_hWndWizard = hWnd;
    }
}

bool CAcquisitionManagerControllerWindow::GetAllImageItems( CSimpleDynamicArray<CWiaItem*> &Items, CWiaItem *pCurr )
{
    while (pCurr)
    {
        if (pCurr->IsDownloadableItemType())
        {
            Items.Append( pCurr );
        }
        GetAllImageItems( Items, pCurr->Children() );
        pCurr = pCurr->Next();
    }
    return(Items.Size() != 0);
}

bool CAcquisitionManagerControllerWindow::GetAllImageItems( CSimpleDynamicArray<CWiaItem*> &Items )
{
    return GetAllImageItems( Items, m_WiaItemList.Root() );
}

bool CAcquisitionManagerControllerWindow::CanSomeSelectedImagesBeDeleted(void)
{
    CSimpleDynamicArray<CWiaItem*> Items;
    GetSelectedItems( m_WiaItemList.Root(), Items );
    //
    // Since we get these access flags in the background, if we don't actually have any yet,
    // we will assume some images CAN be deleted
    //
    bool bNoneAreInitialized = true;
    for (int i=0;i<Items.Size();i++)
    {
        if (Items[i])
        {
            if (Items[i]->AccessRights())
            {
                // At least one of the selected images has been initialized
                bNoneAreInitialized = false;

                // If at least one can be deleted, return true immediately
                if (Items[i]->AccessRights() & WIA_ITEM_CAN_BE_DELETED)
                {
                    return true;
                }
            }
        }
    }
    // If none of the images have been initialized, then we will report true
    if (bNoneAreInitialized)
    {
        return true;
    }
    else
    {
        return false;
    }
}

CWiaItem *CAcquisitionManagerControllerWindow::FindItemByName( LPCWSTR pwszItemName )
{
    WIA_PUSH_FUNCTION((TEXT("CAcquisitionManagerControllerWindow::FindItemByName( %ws )"), pwszItemName ));
    if (!pwszItemName)
        return NULL;
    if (!m_pWiaItemRoot)
        return NULL;
    return m_WiaItemList.Find(pwszItemName);
}

BOOL CAcquisitionManagerControllerWindow::ConfirmWizardCancel( HWND hWndParent )
{
    //
    // Always let it exit, for now.
    //
    return FALSE;
}

int CALLBACK CAcquisitionManagerControllerWindow::PropSheetCallback( HWND hWnd, UINT uMsg, LPARAM lParam )
{
    WIA_PUSHFUNCTION(TEXT("CAcquisitionManagerControllerWindow::PropSheetCallback"));
    if (PSCB_INITIALIZED == uMsg)
    {
        //
        // Try to bring the window to the foreground.
        //
        SetForegroundWindow(hWnd);

    }
    return 0;
}

void CAcquisitionManagerControllerWindow::DetermineScannerType(void)
{
    LONG nProps = ScannerProperties::GetDeviceProps( m_pWiaItemRoot );

    m_nScannerType = ScannerTypeUnknown;

    //
    // Determine which scanner type we have, based on which properties the scanner has, as follows:
    //
    // HasFlatBed         HasDocumentFeeder   SupportsPreview     SupportsPageSize
    // 1                  1                   1                   1                   ScannerTypeFlatbedAdf
    // 1                  0                   1                   0                   ScannerTypeFlatbed
    // 0                  1                   1                   1                   ScannerTypeFlatbedAdf
    // 0                  1                   0                   0                   ScannerTypeScrollFed
    //
    // otherwise it is ScannerTypeUnknown
    //
    const int nMaxControllingProps = 4;
    static struct
    {
        LONG ControllingProps[nMaxControllingProps];
        int nScannerType;
    }
    s_DialogResourceData[] =
    {
        { ScannerProperties::HasFlatBed, ScannerProperties::HasDocumentFeeder, ScannerProperties::SupportsPreview, ScannerProperties::SupportsPageSize, NULL },
        { ScannerProperties::HasFlatBed, ScannerProperties::HasDocumentFeeder, ScannerProperties::SupportsPreview, ScannerProperties::SupportsPageSize, ScannerTypeFlatbedAdf },
        { ScannerProperties::HasFlatBed, 0,                                    ScannerProperties::SupportsPreview, 0,                                   ScannerTypeFlatbed },
        { 0,                             ScannerProperties::HasDocumentFeeder, ScannerProperties::SupportsPreview, ScannerProperties::SupportsPageSize, ScannerTypeFlatbedAdf },
        { 0,                             ScannerProperties::HasDocumentFeeder, 0,                                  0,                                   ScannerTypeScrollFed },
        { 0,                             ScannerProperties::HasDocumentFeeder, 0,                                  ScannerProperties::SupportsPageSize, ScannerTypeFlatbedAdf },
        { ScannerProperties::HasFlatBed, ScannerProperties::HasDocumentFeeder, 0,                                  ScannerProperties::SupportsPageSize, ScannerTypeFlatbedAdf },
    };

    //
    // Find the set of flags that match this device.  If they match, use this scanner type.
    // Loop through each type description.
    //
    for (int nCurrentResourceFlags=1;nCurrentResourceFlags<ARRAYSIZE(s_DialogResourceData) && (ScannerTypeUnknown == m_nScannerType);nCurrentResourceFlags++)
    {
        //
        // Loop through each controlling property
        //
        for (int nControllingProp=0;nControllingProp<nMaxControllingProps;nControllingProp++)
        {
            //
            // If this property DOESN'T match, break out prematurely
            //
            if ((nProps & s_DialogResourceData[0].ControllingProps[nControllingProp]) != s_DialogResourceData[nCurrentResourceFlags].ControllingProps[nControllingProp])
            {
                break;
            }
        }
        //
        // If the current controlling property is equal to the maximum controlling property,
        // we had matches all the way through, so use this type
        //
        if (nControllingProp == nMaxControllingProps)
        {
            m_nScannerType = s_DialogResourceData[nCurrentResourceFlags].nScannerType;
        }
    }
}

CSimpleString CAcquisitionManagerControllerWindow::GetCurrentDate(void)
{
    SYSTEMTIME SystemTime;
    TCHAR szText[MAX_PATH] = TEXT("");

    GetLocalTime( &SystemTime );
    GetDateFormat( LOCALE_USER_DEFAULT, 0, &SystemTime, CSimpleString(IDS_DATEFORMAT,g_hInstance), szText, ARRAYSIZE(szText) );
    return szText;
}


bool CAcquisitionManagerControllerWindow::SuppressFirstPage(void)
{
    return m_bSuppressFirstPage;
}

bool CAcquisitionManagerControllerWindow::IsSerialCamera(void)
{
    WIA_PUSHFUNCTION(TEXT("CAcquisitionManagerControllerWindow::IsSerialCamera"));

    //
    // Only check for serial devices if we are a camera
    //
    if (m_DeviceTypeMode==CameraMode)
    {
#if defined(WIA_DIP_HW_CONFIG)
        //
        // Get the hardware configuration information
        //
        LONG nHardwareConfig = 0;
        if (PropStorageHelpers::GetProperty( m_pWiaItemRoot, WIA_DIP_HW_CONFIG, nHardwareConfig ))
        {
            //
            // If this is a serial device, return true
            //
            if (nHardwareConfig & STI_HW_CONFIG_SERIAL)
            {
                return true;
            }
        }
#else
        CSimpleStringWide strwPortName;
        if (PropStorageHelpers::GetProperty( m_pWiaItemRoot, WIA_DIP_PORT_NAME, strwPortName ))
        {
            //
            // Compare the leftmost 3 characters to the word COM (as in COM1, COM2, ... )
            //
            if (strwPortName.Left(3).CompareNoCase(CSimpleStringWide(L"COM"))==0)
            {
                WIA_TRACE((TEXT("A comparison of %ws and COM succeeded"), strwPortName.Left(3).String() ));
                return true;
            }
            //
            // Compare the portname to the word AUTO
            //
            else if (strwPortName.CompareNoCase(CSimpleStringWide(L"AUTO"))==0)
            {
                WIA_TRACE((TEXT("A comparison of %ws and AUTO succeeded"), strwPortName.String() ));
                return true;
            }
        }
#endif
    }
    //
    // Not a serial camera
    //
    return false;
}

HRESULT CAcquisitionManagerControllerWindow::CreateAndExecuteWizard(void)
{
    //
    // Structure used to setup our data-driven property sheet factory
    //
    enum CPageType
    {
        NormalPage = 0,
        FirstPage  = 1,
        LastPage   = 2
    };
    struct CPropertyPageInfo
    {
        LPCTSTR   pszTemplate;
        DLGPROC   pfnDlgProc;
        int       nIdTitle;
        int       nIdSubTitle;
        TCHAR     szTitle[256];
        TCHAR     szSubTitle[1024];
        CPageType PageType;
        bool     *pbDisplay;
        int      *pnPageIndex;
    };

    //
    // Maximum number of statically created wizard pages
    //
    const int c_nMaxWizardPages = 7;


    HRESULT hr = S_OK;

    //
    // Register common controls
    //
    INITCOMMONCONTROLSEX icce;
    icce.dwSize = sizeof(icce);
    icce.dwICC  = ICC_WIN95_CLASSES | ICC_LISTVIEW_CLASSES | ICC_USEREX_CLASSES | ICC_PROGRESS_CLASS | ICC_LINK_CLASS;
    InitCommonControlsEx( &icce );

    //
    // Register custom window classes
    //
    CWiaTextControl::RegisterClass( g_hInstance );
    RegisterWiaPreviewClasses( g_hInstance );

    //
    // These are the pages we'll use for the scanner wizard, if it doesn't have an ADF
    //
    CPropertyPageInfo ScannerPropSheetPageInfo[] =
    {
        { MAKEINTRESOURCE(IDD_SCANNER_FIRST),      CCommonFirstPage::DialogProc,          0,                          0,                             TEXT(""), TEXT(""), FirstPage,  NULL, NULL },
        { MAKEINTRESOURCE(IDD_SCANNER_SELECT),     CScannerSelectionPage::DialogProc,     IDS_SCANNER_SELECT_TITLE,   IDS_SCANNER_SELECT_SUBTITLE,   TEXT(""), TEXT(""), NormalPage, NULL, &m_nSelectionPageIndex },
        { MAKEINTRESOURCE(IDD_SCANNER_TRANSFER),   CCommonTransferPage::DialogProc,       IDS_SCANNER_TRANSFER_TITLE, IDS_SCANNER_TRANSFER_SUBTITLE, TEXT(""), TEXT(""), NormalPage, NULL, &m_nDestinationPageIndex },
        { MAKEINTRESOURCE(IDD_COMMON_PROGRESS),    CCommonProgressPage::DialogProc,       IDS_SCANNER_PROGRESS_TITLE, IDS_SCANNER_PROGRESS_SUBTITLE, TEXT(""), TEXT(""), NormalPage, NULL, &m_nProgressPageIndex },
        { MAKEINTRESOURCE(IDD_UPLOAD_QUERY),       CCommonUploadQueryPage::DialogProc,    IDS_COMMON_UPLOAD_TITLE,    IDS_COMMON_UPLOAD_SUBTITLE,    TEXT(""), TEXT(""), NormalPage, NULL, &m_nUploadQueryPageIndex },
        { MAKEINTRESOURCE(IDD_COMMON_DELETE),      CCommonDeleteProgressPage::DialogProc, IDS_COMMON_DELETE_TITLE,    IDS_COMMON_DELETE_SUBTITLE,    TEXT(""), TEXT(""), NormalPage, NULL, &m_nDeleteProgressPageIndex },
        { MAKEINTRESOURCE(IDD_COMMON_FINISH),      CCommonFinishPage::DialogProc,         0,                          0,                             TEXT(""), TEXT(""), LastPage,   NULL, &m_nFinishPageIndex }
    };

    //
    // These are the pages we'll use for the scanner wizard, if it is a scroll-fed scanner
    //
    CPropertyPageInfo ScannerScrollFedPropSheetPageInfo[] =
    {
        { MAKEINTRESOURCE(IDD_SCANNER_FIRST),      CCommonFirstPage::DialogProc,          0,                          0,                             TEXT(""), TEXT(""), FirstPage,  NULL, NULL },
        { MAKEINTRESOURCE(IDD_SCANNER_SELECT),     CScannerSelectionPage::DialogProc,     IDS_SCROLLFED_SELECT_TITLE, IDS_SCROLLFED_SELECT_SUBTITLE, TEXT(""), TEXT(""), NormalPage, NULL, &m_nSelectionPageIndex },
        { MAKEINTRESOURCE(IDD_SCANNER_TRANSFER),   CCommonTransferPage::DialogProc,       IDS_SCANNER_TRANSFER_TITLE, IDS_SCANNER_TRANSFER_SUBTITLE, TEXT(""), TEXT(""), NormalPage, NULL, &m_nDestinationPageIndex },
        { MAKEINTRESOURCE(IDD_COMMON_PROGRESS),    CCommonProgressPage::DialogProc,       IDS_SCANNER_PROGRESS_TITLE, IDS_SCANNER_PROGRESS_SUBTITLE, TEXT(""), TEXT(""), NormalPage, NULL, &m_nProgressPageIndex },
        { MAKEINTRESOURCE(IDD_UPLOAD_QUERY),       CCommonUploadQueryPage::DialogProc,    IDS_COMMON_UPLOAD_TITLE,    IDS_COMMON_UPLOAD_SUBTITLE,    TEXT(""), TEXT(""), NormalPage, NULL, &m_nUploadQueryPageIndex },
        { MAKEINTRESOURCE(IDD_COMMON_DELETE),      CCommonDeleteProgressPage::DialogProc, IDS_COMMON_DELETE_TITLE,    IDS_COMMON_DELETE_SUBTITLE,    TEXT(""), TEXT(""), NormalPage, NULL, &m_nDeleteProgressPageIndex },
        { MAKEINTRESOURCE(IDD_COMMON_FINISH),      CCommonFinishPage::DialogProc,         0,                          0,                             TEXT(""), TEXT(""), LastPage,   NULL, &m_nFinishPageIndex }
    };

    //
    // These are the pages we'll use for the scanner wizard, if it does have an ADF
    //
    CPropertyPageInfo ScannerADFPropSheetPageInfo[] =
    {
        { MAKEINTRESOURCE(IDD_SCANNER_FIRST),      CCommonFirstPage::DialogProc,          0,                          0,                             TEXT(""), TEXT(""), FirstPage,  NULL, NULL },
        { MAKEINTRESOURCE(IDD_SCANNER_ADF_SELECT), CScannerSelectionPage::DialogProc,     IDS_SCANNER_SELECT_TITLE,   IDS_SCANNER_SELECT_SUBTITLE,   TEXT(""), TEXT(""), NormalPage, NULL, &m_nSelectionPageIndex },
        { MAKEINTRESOURCE(IDD_SCANNER_TRANSFER),   CCommonTransferPage::DialogProc,       IDS_SCANNER_TRANSFER_TITLE, IDS_SCANNER_TRANSFER_SUBTITLE, TEXT(""), TEXT(""), NormalPage, NULL, &m_nDestinationPageIndex },
        { MAKEINTRESOURCE(IDD_COMMON_PROGRESS),    CCommonProgressPage::DialogProc,       IDS_SCANNER_PROGRESS_TITLE, IDS_SCANNER_PROGRESS_SUBTITLE, TEXT(""), TEXT(""), NormalPage, NULL, &m_nProgressPageIndex },
        { MAKEINTRESOURCE(IDD_UPLOAD_QUERY),       CCommonUploadQueryPage::DialogProc,    IDS_COMMON_UPLOAD_TITLE,    IDS_COMMON_UPLOAD_SUBTITLE,    TEXT(""), TEXT(""), NormalPage, NULL, &m_nUploadQueryPageIndex },
        { MAKEINTRESOURCE(IDD_COMMON_DELETE),      CCommonDeleteProgressPage::DialogProc, IDS_COMMON_DELETE_TITLE,    IDS_COMMON_DELETE_SUBTITLE,    TEXT(""), TEXT(""), NormalPage, NULL, &m_nDeleteProgressPageIndex },
        { MAKEINTRESOURCE(IDD_COMMON_FINISH),      CCommonFinishPage::DialogProc,         0,                          0,                             TEXT(""), TEXT(""), LastPage,   NULL, &m_nFinishPageIndex }
    };

    //
    // These are the pages we'll use for the camera wizard
    //
    CPropertyPageInfo CameraPropSheetPageInfo[] =
    {
        { MAKEINTRESOURCE(IDD_CAMERA_FIRST),       CCommonFirstPage::DialogProc,          0,                          0,                             TEXT(""), TEXT(""), FirstPage,  NULL, NULL },
        { MAKEINTRESOURCE(IDD_CAMERA_SELECT),      CCameraSelectionPage::DialogProc,      IDS_CAMERA_SELECT_TITLE,    IDS_CAMERA_SELECT_SUBTITLE,    TEXT(""), TEXT(""), NormalPage, NULL, &m_nSelectionPageIndex },
        { MAKEINTRESOURCE(IDD_CAMERA_TRANSFER),    CCommonTransferPage::DialogProc,       IDS_CAMERA_TRANSFER_TITLE,  IDS_CAMERA_TRANSFER_SUBTITLE,  TEXT(""), TEXT(""), NormalPage, NULL, &m_nDestinationPageIndex },
        { MAKEINTRESOURCE(IDD_COMMON_PROGRESS),    CCommonProgressPage::DialogProc,       IDS_CAMERA_PROGRESS_TITLE,  IDS_CAMERA_PROGRESS_SUBTITLE,  TEXT(""), TEXT(""), NormalPage, NULL, &m_nProgressPageIndex },
        { MAKEINTRESOURCE(IDD_UPLOAD_QUERY),       CCommonUploadQueryPage::DialogProc,    IDS_COMMON_UPLOAD_TITLE,    IDS_COMMON_UPLOAD_SUBTITLE,    TEXT(""), TEXT(""), NormalPage, NULL, &m_nUploadQueryPageIndex },
        { MAKEINTRESOURCE(IDD_COMMON_DELETE),      CCommonDeleteProgressPage::DialogProc, IDS_COMMON_DELETE_TITLE,    IDS_COMMON_DELETE_SUBTITLE,    TEXT(""), TEXT(""), NormalPage, NULL, &m_nDeleteProgressPageIndex },
        { MAKEINTRESOURCE(IDD_COMMON_FINISH),      CCommonFinishPage::DialogProc,         0,                          0,                             TEXT(""), TEXT(""), LastPage,   NULL, &m_nFinishPageIndex }
    };

    //
    // These are the pages we'll use for the video wizard
    //
    CPropertyPageInfo VideoPropSheetPageInfo[] =
    {
        { MAKEINTRESOURCE(IDD_VIDEO_FIRST),        CCommonFirstPage::DialogProc,          0,                          0,                             TEXT(""), TEXT(""), FirstPage,  NULL, NULL },
        { MAKEINTRESOURCE(IDD_VIDEO_SELECT),       CCameraSelectionPage::DialogProc,      IDS_VIDEO_SELECT_TITLE,     IDS_VIDEO_SELECT_SUBTITLE,     TEXT(""), TEXT(""), NormalPage, NULL, &m_nSelectionPageIndex },
        { MAKEINTRESOURCE(IDD_CAMERA_TRANSFER),    CCommonTransferPage::DialogProc,       IDS_CAMERA_TRANSFER_TITLE,  IDS_CAMERA_TRANSFER_SUBTITLE,  TEXT(""), TEXT(""), NormalPage, NULL, &m_nDestinationPageIndex },
        { MAKEINTRESOURCE(IDD_COMMON_PROGRESS),    CCommonProgressPage::DialogProc,       IDS_CAMERA_PROGRESS_TITLE,  IDS_CAMERA_PROGRESS_SUBTITLE,  TEXT(""), TEXT(""), NormalPage, NULL, &m_nProgressPageIndex },
        { MAKEINTRESOURCE(IDD_UPLOAD_QUERY),       CCommonUploadQueryPage::DialogProc,    IDS_COMMON_UPLOAD_TITLE,    IDS_COMMON_UPLOAD_SUBTITLE,    TEXT(""), TEXT(""), NormalPage, NULL, &m_nUploadQueryPageIndex },
        { MAKEINTRESOURCE(IDD_COMMON_DELETE),      CCommonDeleteProgressPage::DialogProc, IDS_COMMON_DELETE_TITLE,    IDS_COMMON_DELETE_SUBTITLE,    TEXT(""), TEXT(""), NormalPage, NULL, &m_nDeleteProgressPageIndex },
        { MAKEINTRESOURCE(IDD_COMMON_FINISH),      CCommonFinishPage::DialogProc,         0,                          0,                             TEXT(""), TEXT(""), LastPage,   NULL, &m_nFinishPageIndex }
    };

    //
    // Initialize all of these variables, which differ depending on which type of device we are loading
    //
    LPTSTR pszbmWatermark                 = NULL;
    LPTSTR pszbmHeader                    = NULL;
    CPropertyPageInfo *pPropSheetPageInfo = NULL;
    int nPropPageCount                    = 0;
    int nWizardIconId                     = 0;
    CSimpleString strDownloadManagerTitle = TEXT("");

    //
    // Decide which pages to use.
    //
    switch (m_DeviceTypeMode)
    {
    case CameraMode:
        pszbmWatermark     = MAKEINTRESOURCE(IDB_CAMERA_WATERMARK);
        pszbmHeader        = MAKEINTRESOURCE(IDB_CAMERA_HEADER);
        pPropSheetPageInfo = CameraPropSheetPageInfo;
        nPropPageCount     = ARRAYSIZE(CameraPropSheetPageInfo);
        strDownloadManagerTitle.LoadString( IDS_DOWNLOAD_MANAGER_TITLE, g_hInstance );
        nWizardIconId      = IDI_CAMERA_WIZARD;
        break;

    case VideoMode:
        pszbmWatermark     = MAKEINTRESOURCE(IDB_VIDEO_WATERMARK);
        pszbmHeader        = MAKEINTRESOURCE(IDB_VIDEO_HEADER);
        pPropSheetPageInfo = VideoPropSheetPageInfo;
        nPropPageCount     = ARRAYSIZE(VideoPropSheetPageInfo);
        strDownloadManagerTitle.LoadString( IDS_DOWNLOAD_MANAGER_TITLE, g_hInstance );
        nWizardIconId      = IDI_VIDEO_WIZARD;
        break;

    case ScannerMode:
        DetermineScannerType();
        pszbmWatermark     = MAKEINTRESOURCE(IDB_SCANNER_WATERMARK);
        pszbmHeader        = MAKEINTRESOURCE(IDB_SCANNER_HEADER);
        strDownloadManagerTitle.LoadString( IDS_DOWNLOAD_MANAGER_TITLE, g_hInstance );
        nWizardIconId      = IDI_SCANNER_WIZARD;
        if (m_nScannerType == ScannerTypeFlatbedAdf)
        {
            pPropSheetPageInfo = ScannerADFPropSheetPageInfo;
            nPropPageCount     = ARRAYSIZE(ScannerADFPropSheetPageInfo);
        }
        else if (m_nScannerType == ScannerTypeFlatbed)
        {
            pPropSheetPageInfo = ScannerPropSheetPageInfo;
            nPropPageCount     = ARRAYSIZE(ScannerPropSheetPageInfo);
        }
        else if (m_nScannerType == ScannerTypeScrollFed)
        {
            pPropSheetPageInfo = ScannerScrollFedPropSheetPageInfo;
            nPropPageCount     = ARRAYSIZE(ScannerScrollFedPropSheetPageInfo);
        }
        else
        {
            //
            // Unknown scanner type
            //
        }

        break;

    default:
        return E_INVALIDARG;
    }

    HICON hIconSmall=NULL, hIconBig=NULL;
    if (!SUCCEEDED(WiaUiExtensionHelper::GetDeviceIcons( CSimpleBStr(m_strwDeviceUiClassId), m_nDeviceType, &hIconSmall, &hIconBig )))
    {
        //
        // Load the icons.  They will be set using WM_SETICON in the first pages.
        //
        hIconSmall = reinterpret_cast<HICON>(LoadImage( g_hInstance, MAKEINTRESOURCE(nWizardIconId), IMAGE_ICON, GetSystemMetrics(SM_CXSMICON), GetSystemMetrics(SM_CYSMICON), LR_DEFAULTCOLOR ));
        hIconBig = reinterpret_cast<HICON>(LoadImage( g_hInstance, MAKEINTRESOURCE(nWizardIconId), IMAGE_ICON, GetSystemMetrics(SM_CXICON), GetSystemMetrics(SM_CYICON), LR_DEFAULTCOLOR ));
    }
    
    //
    // Make copies of these icons to work around NTBUG 351806
    //
    if (hIconSmall)
    {
        m_hWizardIconSmall = CopyIcon(hIconSmall);
        DestroyIcon(hIconSmall);
    }
    if (hIconBig)
    {
        m_hWizardIconBig = CopyIcon(hIconBig);
        DestroyIcon(hIconBig);
    }


    //
    // Make sure we have a valid set of data
    //
    if (pszbmWatermark && pszbmHeader && pPropSheetPageInfo && nPropPageCount)
    {
        const int c_MaxPageCount = 20;
        HPROPSHEETPAGE PropSheetPages[c_MaxPageCount] = {0};

        //
        // We might not be adding all of the pages.
        //
        int nTotalPageCount = 0;

        for (int nCurrPage=0;nCurrPage<nPropPageCount && nCurrPage<c_MaxPageCount;nCurrPage++)
        {
            //
            // Only add the page if the controlling pbDisplay variable is NULL or points to a non-FALSE value
            //
            if (!pPropSheetPageInfo[nCurrPage].pbDisplay || *(pPropSheetPageInfo[nCurrPage].pbDisplay))
            {
                PROPSHEETPAGE CurrentPropSheetPage = {0};

                //
                // Set up all of the required fields from out static info.
                //
                CurrentPropSheetPage.dwSize      = sizeof(PROPSHEETPAGE);
                CurrentPropSheetPage.hInstance   = g_hInstance;
                CurrentPropSheetPage.lParam      = reinterpret_cast<LPARAM>(this);
                CurrentPropSheetPage.pfnDlgProc  = pPropSheetPageInfo[nCurrPage].pfnDlgProc;
                CurrentPropSheetPage.pszTemplate = pPropSheetPageInfo[nCurrPage].pszTemplate;
                CurrentPropSheetPage.pszTitle    = strDownloadManagerTitle.String();
                CurrentPropSheetPage.dwFlags     = PSP_DEFAULT;

                //
                // Add in the fusion flags to get COMCTLV6
                //
                WiaUiUtil::PreparePropertyPageForFusion( &CurrentPropSheetPage  );

                //
                // If we want to save the index of this page, save it
                //
                if (pPropSheetPageInfo[nTotalPageCount].pnPageIndex)
                {
                    *(pPropSheetPageInfo[nTotalPageCount].pnPageIndex) = nTotalPageCount;
                }

                if (FirstPage == pPropSheetPageInfo[nCurrPage].PageType)
                {
                    //
                    // No title or subtitle needed for "first pages"
                    //
                    CurrentPropSheetPage.dwFlags |= PSP_PREMATURE | PSP_HIDEHEADER | PSP_USETITLE;
                }
                else if (LastPage == pPropSheetPageInfo[nCurrPage].PageType)
                {
                    //
                    // No title or subtitle needed for "last pages"
                    //
                    CurrentPropSheetPage.dwFlags |= PSP_HIDEHEADER | PSP_USETITLE;
                }
                else
                {
                    //
                    // Add header and subtitle
                    //
                    CurrentPropSheetPage.dwFlags |= PSP_PREMATURE | PSP_USEHEADERTITLE | PSP_USEHEADERSUBTITLE | PSP_USETITLE;

                    //
                    // Load the header and subtitle
                    //
                    LoadString( g_hInstance, pPropSheetPageInfo[nCurrPage].nIdTitle, pPropSheetPageInfo[nCurrPage].szTitle, ARRAYSIZE(pPropSheetPageInfo[nCurrPage].szTitle) );
                    LoadString( g_hInstance, pPropSheetPageInfo[nCurrPage].nIdSubTitle, pPropSheetPageInfo[nCurrPage].szSubTitle, ARRAYSIZE(pPropSheetPageInfo[nCurrPage].szSubTitle) );

                    //
                    // Assign the title and subtitle strings
                    //
                    CurrentPropSheetPage.pszHeaderTitle    = pPropSheetPageInfo[nCurrPage].szTitle;
                    CurrentPropSheetPage.pszHeaderSubTitle = pPropSheetPageInfo[nCurrPage].szSubTitle;
                }

                //
                // Create and add one more page
                //
                HPROPSHEETPAGE hPropSheetPage = CreatePropertySheetPage(&CurrentPropSheetPage);
                if (!hPropSheetPage)
                {
                    WIA_PRINTHRESULT((HRESULT_FROM_WIN32(GetLastError()),TEXT("CreatePropertySheetPage failed on page %d"), nCurrPage ));
                    return E_FAIL;
                }
                PropSheetPages[nTotalPageCount++] = hPropSheetPage;
            }
        }

        //
        // Save the count of our pages
        //
        m_nWiaWizardPageCount = nTotalPageCount;

        //
        // Create the property sheet header
        //
        PROPSHEETHEADER PropSheetHeader = {0};
        PropSheetHeader.hwndParent      = NULL;
        PropSheetHeader.dwSize          = sizeof(PROPSHEETHEADER);
        PropSheetHeader.dwFlags         = PSH_NOAPPLYNOW | PSH_WIZARD97 | PSH_WATERMARK | PSH_HEADER | PSH_USECALLBACK;
        PropSheetHeader.pszbmWatermark  = pszbmWatermark;
        PropSheetHeader.pszbmHeader     = pszbmHeader;
        PropSheetHeader.hInstance       = g_hInstance;
        PropSheetHeader.nPages          = m_nWiaWizardPageCount;
        PropSheetHeader.phpage          = PropSheetPages;
        PropSheetHeader.pfnCallback     = PropSheetCallback;
        PropSheetHeader.nStartPage      = SuppressFirstPage() ? 1 : 0;

        //
        // Display the property sheet
        //
        INT_PTR nResult = PropertySheet( &PropSheetHeader );

        //
        // Check for an error
        //
        if (nResult == -1)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }

    }
    else
    {
        //
        // Generic failure will have to do
        //
        hr = E_FAIL;

        //
        // Dismiss the wait dialog before we display the message box
        //
        if (m_pWiaProgressDialog)
        {
            m_pWiaProgressDialog->Destroy();
            m_pWiaProgressDialog = NULL;
        }

        //
        // Display an error message telling the user this is not a supported device
        //
        CMessageBoxEx::MessageBox( m_hWnd, CSimpleString(IDS_UNSUPPORTED_DEVICE,g_hInstance), CSimpleString(IDS_ERROR_TITLE,g_hInstance), CMessageBoxEx::MBEX_ICONWARNING );

        WIA_ERROR((TEXT("Unknown device type")));
    }

    //
    // Make sure the status dialog has been dismissed by now
    //
    if (m_pWiaProgressDialog)
    {
        m_pWiaProgressDialog->Destroy();
        m_pWiaProgressDialog = NULL;
    }
    return hr;
}

bool CAcquisitionManagerControllerWindow::EnumItemsCallback( CWiaItemList::CEnumEvent EnumEvent, UINT nData, LPARAM lParam, bool bForceUpdate )
{
    //
    // We would return false to cancel enumeration
    //
    bool bResult = true;

    //
    // Get the instance of the controller window
    //
    CAcquisitionManagerControllerWindow *pThis = reinterpret_cast<CAcquisitionManagerControllerWindow*>(lParam);
    if (pThis)
    {
        //
        // Which event are we being called for?
        //
        switch (EnumEvent)
        {
        case CWiaItemList::ReadingItemInfo:
            //
            // This is the event that is sent while the tree is being built
            //
            if (pThis->m_pWiaProgressDialog && pThis->m_bUpdateEnumerationCount && nData)
            {
                //
                // We don't want to update the status text any more often than this (minimizes flicker)
                //
                const DWORD dwMinDelta = 200;

                //
                // Get the current tick count and see if it has been more than dwMinDelta milliseconds since our last update
                //
                DWORD dwCurrentTickCount = GetTickCount();
                if (bForceUpdate || dwCurrentTickCount - pThis->m_dwLastEnumerationTickCount >= dwMinDelta)
                {
                    //
                    // Assume we haven't been cancelled
                    //
                    BOOL bCancelled = FALSE;

                    //
                    // Set the progress message
                    //
                    pThis->m_pWiaProgressDialog->SetMessage( CSimpleStringWide().Format( IDS_ENUMERATIONCOUNT, g_hInstance, nData ) );

                    //
                    // Find out if we've been cancelled
                    //
                    pThis->m_pWiaProgressDialog->Cancelled(&bCancelled);

                    //
                    // If we have been cancelled, we'll return false to stop the enumeration
                    //
                    if (bCancelled)
                    {
                        bResult = false;
                    }

                    //
                    // Save the current tick count for next time
                    //
                    pThis->m_dwLastEnumerationTickCount = dwCurrentTickCount;
                }
            }
            break;
        }
    }
    return bResult;
}

LRESULT CAcquisitionManagerControllerWindow::OnPostInitialize( WPARAM, LPARAM )
{
    WIA_PUSHFUNCTION(TEXT("CAcquisitionManagerControllerWindow::OnInitialize"));

    //
    // Try to get the correct animation for this device type.  If we can't get the type,
    // just use the camera animation.  If there is a real error, it will get handled later
    //
    int nAnimationType = WIA_PROGRESSDLG_ANIM_CAMERA_COMMUNICATE;
    LONG nAnimationDeviceType = 0;

    //
    // We don't want to update our enumeration count in the progress dialog for scanners, but we do for cameras
    //
    m_bUpdateEnumerationCount = true;
    if (SUCCEEDED(WiaUiUtil::GetDeviceTypeFromId( CSimpleBStr(m_pEventParameters->strDeviceID), &nAnimationDeviceType )))
    {
        if (StiDeviceTypeScanner == GET_STIDEVICE_TYPE(nAnimationDeviceType))
        {
            nAnimationType = WIA_PROGRESSDLG_ANIM_SCANNER_COMMUNICATE;
            m_bUpdateEnumerationCount = false;
        }
        else if (StiDeviceTypeStreamingVideo == GET_STIDEVICE_TYPE(nAnimationDeviceType))
        {
            nAnimationType = WIA_PROGRESSDLG_ANIM_VIDEO_COMMUNICATE;
        }
    }

    //
    // Put up a wait dialog
    //
    HRESULT hr = CoCreateInstance( CLSID_WiaDefaultUi, NULL, CLSCTX_INPROC_SERVER, IID_IWiaProgressDialog, (void**)&m_pWiaProgressDialog );
    if (SUCCEEDED(hr))
    {
        m_pWiaProgressDialog->Create( m_hWnd, nAnimationType|WIA_PROGRESSDLG_NO_PROGRESS );
        m_pWiaProgressDialog->SetTitle( CSimpleStringConvert::WideString(CSimpleString(IDS_DOWNLOADMANAGER_NAME,g_hInstance)));
        m_pWiaProgressDialog->SetMessage( CSimpleStringConvert::WideString(CSimpleString(IDS_PROGDLG_MESSAGE,g_hInstance)));

        //
        // Show the progress dialog
        //
        m_pWiaProgressDialog->Show();

        //
        // Create the global interface table
        //
        hr = CoCreateInstance( CLSID_StdGlobalInterfaceTable, NULL, CLSCTX_INPROC_SERVER, IID_IGlobalInterfaceTable, (VOID**)&m_pGlobalInterfaceTable );
        if (SUCCEEDED(hr))
        {
            //
            // Create the device
            //
            hr = WIA_FORCE_ERROR(FE_WIAACMGR,100,CreateDevice());
            if (SUCCEEDED(hr))
            {
                //
                // Save a debug snapshot, if the entry is in the registry
                //
                WIA_SAVEITEMTREELOG(HKEY_CURRENT_USER,REGSTR_PATH_USER_SETTINGS_WIAACMGR,TEXT("CreateDeviceTreeSnapshot"),true,m_pWiaItemRoot);

                //
                // First, figure out what kind of device it is and get the UI class ID
                //
                if (PropStorageHelpers::GetProperty( m_pWiaItemRoot, WIA_DIP_DEV_TYPE, m_nDeviceType ) &&
                    PropStorageHelpers::GetProperty( m_pWiaItemRoot, WIA_DIP_UI_CLSID, m_strwDeviceUiClassId ))
                {
                    switch (GET_STIDEVICE_TYPE(m_nDeviceType))
                    {
                    case StiDeviceTypeScanner:
                        m_DeviceTypeMode = ScannerMode;
                        break;

                    case StiDeviceTypeDigitalCamera:
                        m_DeviceTypeMode = CameraMode;
                        break;

                    case StiDeviceTypeStreamingVideo:
                        m_DeviceTypeMode = VideoMode;
                        break;

                    default:
                        m_DeviceTypeMode = UnknownMode;
                        hr = E_FAIL;
                        break;
                    }
                }
                else
                {
                    hr = E_FAIL;
                    WIA_ERROR((TEXT("Unable to read the device type")));
                }

                if (SUCCEEDED(hr))
                {
                    //
                    // Get the device name
                    //
                    PropStorageHelpers::GetProperty( m_pWiaItemRoot, WIA_DIP_DEV_NAME, m_strwDeviceName );

                    //
                    // Find out if Take Picture is supported
                    //
                    m_bTakePictureIsSupported = WiaUiUtil::IsDeviceCommandSupported( m_pWiaItemRoot, WIA_CMD_TAKE_PICTURE );

                    //
                    // Enumerate all the items in the device tree
                    //
                    hr = m_WiaItemList.EnumerateAllWiaItems(m_pWiaItemRoot,EnumItemsCallback,reinterpret_cast<LPARAM>(this));
                    if (S_OK == hr)
                    {
                        if (ScannerMode == m_DeviceTypeMode)
                        {
                            //
                            // Mark only one scanner item as selected, and save it as the current scanner item
                            //
                            MarkAllItemsUnselected( m_WiaItemList.Root() );
                            CSimpleDynamicArray<CWiaItem*>  Items;
                            GetAllImageItems( Items, m_WiaItemList.Root() );
                            if (Items.Size() && Items[0])
                            {
                                m_pCurrentScannerItem = Items[0];
                                MarkItemSelected(Items[0],m_WiaItemList.Root());

                                //
                                // Make sure we have all of the properties we need to construct the device
                                //
                                hr = WiaUiUtil::VerifyScannerProperties(Items[0]->WiaItem());
                            }
                            else
                            {
                                hr = E_FAIL;
                                WIA_ERROR((TEXT("There don't seem to be any transfer items on this scanner")));
                            }
                        }
                        else if (VideoMode == m_DeviceTypeMode || CameraMode == m_DeviceTypeMode)
                        {
                            //
                            // Get the thumbnail width
                            //
                            LONG nWidth, nHeight;
                            if (PropStorageHelpers::GetProperty( m_pWiaItemRoot, WIA_DPC_THUMB_WIDTH, nWidth ) &&
                                PropStorageHelpers::GetProperty( m_pWiaItemRoot, WIA_DPC_THUMB_HEIGHT, nHeight ))
                            {
                                int nMax = max(nWidth,nHeight); // Allow for rotation
                                m_sizeThumbnails.cx = max(c_nMinThumbnailWidth,min(nMax,c_nMaxThumbnailWidth));
                                m_sizeThumbnails.cy = max(c_nMinThumbnailHeight,min(nMax,c_nMaxThumbnailHeight));
                            }
                        }
                    }
                }
            }
        }
    }


    if (!SUCCEEDED(hr))
    {
        //
        // Dismiss the wait dialog
        //
        if (m_pWiaProgressDialog)
        {
            m_pWiaProgressDialog->Destroy();
            m_pWiaProgressDialog = NULL;
        }

        //
        // Choose an appropriate error message if we have a recognizable error.
        //
        CSimpleString strMessage;
        int nIconId = 0;
        switch (hr)
        {
        case WIA_ERROR_BUSY:
            strMessage.LoadString( IDS_DEVICE_BUSY, g_hInstance );
            nIconId = MB_ICONINFORMATION;
            break;

        case WIA_S_NO_DEVICE_AVAILABLE:
            strMessage.LoadString( IDS_DEVICE_NOT_FOUND, g_hInstance );
            nIconId = MB_ICONINFORMATION;
            break;


        default:
            strMessage.LoadString( IDS_UNABLETOCREATE, g_hInstance );
            nIconId = MB_ICONINFORMATION;
            break;
        }

        //
        // Tell the user we had a problem creating the device
        //
        MessageBox( m_hWnd, strMessage, CSimpleString( IDS_DOWNLOAD_MANAGER_TITLE, g_hInstance ), nIconId );
    }
    else if (S_OK == hr)
    {
        hr = CreateAndExecuteWizard();
    }
    //
    // If we were cancelled, shut down the progress UI
    //
    else if (m_pWiaProgressDialog)
    {
        m_pWiaProgressDialog->Destroy();
        m_pWiaProgressDialog = NULL;
    }

    //
    // Make sure we kill this window, and thus, this thread.
    //
    PostMessage( m_hWnd, WM_CLOSE, 0, 0 );

    return 0;
}

LRESULT CAcquisitionManagerControllerWindow::OnCreate( WPARAM, LPARAM lParam )
{
    WIA_PUSHFUNCTION(TEXT("CAcquisitionManagerControllerWindow::OnCreate"));

    //
    // Ensure the background thread was started
    //
    if (!m_hBackgroundThread || !m_pThreadMessageQueue)
    {
        WIA_ERROR((TEXT("There was an error starting the background thread")));
        return -1;
    }

    //
    // Make sure we got a valid lParam
    //
    LPCREATESTRUCT pCreateStruct = reinterpret_cast<LPCREATESTRUCT>(lParam);
    if (!pCreateStruct)
    {
        WIA_ERROR((TEXT("pCreateStruct was NULL")));
        return -1;
    }

    //
    // Get the event parameters
    //
    m_pEventParameters = reinterpret_cast<CEventParameters*>(pCreateStruct->lpCreateParams);
    if (!m_pEventParameters)
    {
        WIA_ERROR((TEXT("m_pEventParameters was NULL")));
        return -1;
    }

    SetForegroundWindow(m_hWnd);

    //
    // Center ourselves on the parent window
    //
    WiaUiUtil::CenterWindow( m_hWnd, m_pEventParameters->hwndParent );

    PostMessage( m_hWnd, PWM_POSTINITIALIZE, 0, 0 );

    return 0;
}

void CAcquisitionManagerControllerWindow::OnNotifyDownloadImage( UINT nMsg, CThreadNotificationMessage *pThreadNotificationMessage )
{
    CDownloadImagesThreadNotifyMessage *pDownloadImageThreadNotifyMessage = dynamic_cast<CDownloadImagesThreadNotifyMessage*>(pThreadNotificationMessage);
    if (pDownloadImageThreadNotifyMessage)
    {
        switch (pDownloadImageThreadNotifyMessage->Status())
        {
        case CDownloadImagesThreadNotifyMessage::End:
            {
                switch (pDownloadImageThreadNotifyMessage->Operation())
                {
                case CDownloadImagesThreadNotifyMessage::DownloadImage:
                    {
                        if (S_OK != pDownloadImageThreadNotifyMessage->hr())
                        {
                            m_nFailedImagesCount++;
                        }
                    }
                    break;

                case CDownloadImagesThreadNotifyMessage::DownloadAll:
                    {
                        if (S_OK == pDownloadImageThreadNotifyMessage->hr())
                        {
                            m_DownloadedFileInformationList = pDownloadImageThreadNotifyMessage->DownloadedFileInformation();
                        }
                        else
                        {
                            m_DownloadedFileInformationList.Destroy();
                        }
                    }
                    break;
                }
            }
            break;

        case CDownloadImagesThreadNotifyMessage::Begin:
            {
                switch (pDownloadImageThreadNotifyMessage->Operation())
                {
                case CDownloadImagesThreadNotifyMessage::DownloadAll:
                    {
                        m_nFailedImagesCount = 0;
                    }
                    break;
                }
            }
            break;
        }
    }
}

void CAcquisitionManagerControllerWindow::OnNotifyDownloadThumbnail( UINT nMsg, CThreadNotificationMessage *pThreadNotificationMessage )
{
    WIA_PUSH_FUNCTION((TEXT("CAcquisitionManagerControllerWindow::OnNotifyDownloadThumbnail( %d, %p )"), nMsg, pThreadNotificationMessage ));
    CDownloadThumbnailsThreadNotifyMessage *pDownloadThumbnailsThreadNotifyMessage= dynamic_cast<CDownloadThumbnailsThreadNotifyMessage*>(pThreadNotificationMessage);
    if (pDownloadThumbnailsThreadNotifyMessage)
    {
        switch (pDownloadThumbnailsThreadNotifyMessage->Status())
        {
        case CDownloadThumbnailsThreadNotifyMessage::Begin:
            {
            }
            break;
        case CDownloadThumbnailsThreadNotifyMessage::Update:
            {
            }
            break;
        case CDownloadThumbnailsThreadNotifyMessage::End:
            {
                switch (pDownloadThumbnailsThreadNotifyMessage->Operation())
                {
                case CDownloadThumbnailsThreadNotifyMessage::DownloadThumbnail:
                    {
                        WIA_TRACE((TEXT("Handling CDownloadThumbnailsThreadNotifyMessage::DownloadThumbnail")));
                        //
                        // Find the item in the list
                        //
                        CWiaItem *pWiaItem = m_WiaItemList.Find( pDownloadThumbnailsThreadNotifyMessage->Cookie() );
                        if (pWiaItem)
                        {
                            //
                            // Set the flag that indicates we've tried this image already
                            //
                            pWiaItem->AttemptedThumbnailDownload(true);

                            //
                            // Make sure we have valid thumbnail data
                            //
                            if (pDownloadThumbnailsThreadNotifyMessage->BitmapData())
                            {
                                //
                                // Don't replace existing thumbnail data
                                //
                                if (!pWiaItem->BitmapData())
                                {
                                    //
                                    // Set the item's thumbnail data.  Take ownership of the thumbnail data
                                    //
                                    WIA_TRACE((TEXT("Found the thumbnail for the item with the GIT cookie %08X"), pDownloadThumbnailsThreadNotifyMessage->Cookie() ));
                                    pWiaItem->BitmapData(pDownloadThumbnailsThreadNotifyMessage->DetachBitmapData());
                                    pWiaItem->Width(pDownloadThumbnailsThreadNotifyMessage->Width());
                                    pWiaItem->Height(pDownloadThumbnailsThreadNotifyMessage->Height());
                                    pWiaItem->BitmapDataLength(pDownloadThumbnailsThreadNotifyMessage->BitmapDataLength());
                                    pWiaItem->ImageWidth(pDownloadThumbnailsThreadNotifyMessage->PictureWidth());
                                    pWiaItem->ImageHeight(pDownloadThumbnailsThreadNotifyMessage->PictureHeight());
                                    pWiaItem->AnnotationType(pDownloadThumbnailsThreadNotifyMessage->AnnotationType());
                                    pWiaItem->DefExt(pDownloadThumbnailsThreadNotifyMessage->DefExt());
                                }
                                else
                                {
                                    WIA_TRACE((TEXT("Already got the image data for item %08X!"), pDownloadThumbnailsThreadNotifyMessage->Cookie()));
                                }
                            }
                            else
                            {
                                WIA_ERROR((TEXT("pDownloadThumbnailsThreadNotifyMessage->BitmapData was NULL!")));
                            }


                            //
                            // Assign the default format
                            //
                            pWiaItem->DefaultFormat(pDownloadThumbnailsThreadNotifyMessage->DefaultFormat());

                            //
                            // Assign the access flags
                            //
                            pWiaItem->AccessRights(pDownloadThumbnailsThreadNotifyMessage->AccessRights());

                            //
                            // Make sure we discard rotation angles if rotation is not possible
                            //
                            pWiaItem->DiscardRotationIfNecessary();
                        }
                        else
                        {
                            WIA_ERROR((TEXT("Can't find %08X in the item list"), pDownloadThumbnailsThreadNotifyMessage->Cookie() ));
                        }
                    }
                    break;
                }
            }
            break;
        }
    }
}

LRESULT CAcquisitionManagerControllerWindow::OnThreadNotification( WPARAM wParam, LPARAM lParam )
{
    WIA_PUSH_FUNCTION((TEXT("CAcquisitionManagerControllerWindow::OnThreadNotification( %d, %08X )"), wParam, lParam ));
    CThreadNotificationMessage *pThreadNotificationMessage = reinterpret_cast<CThreadNotificationMessage*>(lParam);
    if (pThreadNotificationMessage)
    {
        switch (pThreadNotificationMessage->Message())
        {
        case TQ_DOWNLOADTHUMBNAIL:
            OnNotifyDownloadThumbnail( static_cast<UINT>(wParam), pThreadNotificationMessage );
            break;

        case TQ_DOWNLOADIMAGE:
            OnNotifyDownloadImage( static_cast<UINT>(wParam), pThreadNotificationMessage );
            break;
        }

        //
        // Notify all the registered windows
        //
        m_WindowList.SendMessage( m_nThreadNotificationMessage, wParam, lParam );

        //
        // Free the message structure
        //
        delete pThreadNotificationMessage;
    }

    return HANDLED_THREAD_MESSAGE;
}


void CAcquisitionManagerControllerWindow::AddNewItemToList( CGenericWiaEventHandler::CEventMessage *pEventMessage )
{
    WIA_PUSHFUNCTION((TEXT("CAcquisitionManagerControllerWindow::AddNewItemToList")));

    //
    // Check to see if the item is already in our list
    //
    CWiaItem *pWiaItem = m_WiaItemList.Find(pEventMessage->FullItemName());
    if (pWiaItem)
    {
        //
        // If it is already in our list, just return.
        //
        return;
    }

    //
    // Get an IWiaItem interface pointer for this item
    //
    CComPtr<IWiaItem> pItem;
    HRESULT hr = m_pWiaItemRoot->FindItemByName( 0, CSimpleBStr(pEventMessage->FullItemName()).BString(), &pItem );
    if (SUCCEEDED(hr) && pItem)
    {
        //
        // Add it to the root of the item tree
        //
        m_WiaItemList.Add( NULL, new CWiaItem(pItem) );
    }
}


void CAcquisitionManagerControllerWindow::RequestThumbnailForNewItem( CGenericWiaEventHandler::CEventMessage *pEventMessage )
{
    WIA_PUSHFUNCTION((TEXT("CAcquisitionManagerControllerWindow::RequestThumbnailForNewItem")));

    //
    // Find the item in our list
    //
    CWiaItem *pWiaItem = m_WiaItemList.Find(pEventMessage->FullItemName());
    if (pWiaItem)
    {
        //
        // Add this item's cookie to an empty list
        //
        CSimpleDynamicArray<DWORD> Cookies;
        Cookies.Append( pWiaItem->GlobalInterfaceTableCookie() );
        if (Cookies.Size())
        {
            //
            // Reset the cancel event
            //
            m_EventThumbnailCancel.Reset();

            //
            // Prepare and send the request
            //
            CDownloadThumbnailsThreadMessage *pDownloadThumbnailsThreadMessage = new CDownloadThumbnailsThreadMessage( m_hWnd, Cookies, m_EventThumbnailCancel.Event() );
            if (pDownloadThumbnailsThreadMessage)
            {
                m_pThreadMessageQueue->Enqueue( pDownloadThumbnailsThreadMessage, CThreadMessageQueue::PriorityNormal );
            }
        }
    }

}


LRESULT CAcquisitionManagerControllerWindow::OnEventNotification( WPARAM wParam, LPARAM lParam )
{
    WIA_PUSHFUNCTION(TEXT("CAcquisitionManagerControllerWindow::OnEventNotification"));
    CGenericWiaEventHandler::CEventMessage *pEventMessage = reinterpret_cast<CGenericWiaEventHandler::CEventMessage *>(lParam);
    if (pEventMessage)
    {
        //
        // If we got an item created message, add the item to the list
        //
        if (pEventMessage->EventId() == WIA_EVENT_ITEM_CREATED)
        {
            AddNewItemToList( pEventMessage );
        }

        //
        // On Disconnect, perform disconnection operations
        //
        else if (pEventMessage->EventId() == WIA_EVENT_DEVICE_DISCONNECTED)
        {
            DisplayDisconnectMessageAndExit();
        }

        //
        //